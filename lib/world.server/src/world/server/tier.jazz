;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.server.tier jazz


(import (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.io)
        (jazz.logger)
        (jazz.markup)
        (jazz.network)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.zlib)
        (world)
        (world.audio)
        (world.assets)
        (world.autoload)
        (world.capabilities)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.history)
        (world.id)
        (world.instance)
        (world.io)
        (world.log)
        (world.network)
        (world.profiling)
        (world.scripting)
        (world.script.remote)
        (world.server)
        (world.server.client)
        (world.server.group)
        (world.server.problem)
        (world.server.serving)
        (world.server.udp)
        (world.settings)
        (world.stream)
        (world.streaming)
        (world.stub)
        (world.support)
        (world.task)
        (world.tier)
        (world.udp)
        (world.video))


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                                       getter generate)
  (slot delegates      initialize '()                       getter generate)
  (slot disconnected   initialize '()                       getter generate)
  (slot instances      initialize (make-table test: equal?) getter generate)
  (slot zones          initialize '()                       getter generate)
  (slot groups         initialize '()                       getter generate)
  (slot hits           initialize 0                         getter generate)
  (slot aliveness-task initialize #f                        getter generate)
  (slot udp-server     initialize #f                        getter generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (unless debug-connections?
      (set-presence-already-connected
        (lambda (presence remote-uuid existing-connection accept)
          (problem "Already connected")
          (close-connection presence remote-uuid existing-connection)
          (accept)))
      (set-presence-accept-handler
        (lambda (proc presence)
          (handle-exception-filter
            connection-exception?
            (lambda (exc)
              (problem "Accepting remote: {a}" (exception-reason exc)))
            (lambda ()
              (proc presence)))))
      (set-presence-process-handler
        (lambda (proc connection)
          (handle-exception-filter
            connection-exception?
            (lambda (exc)
              (problem "Processing remote: {a}" (exception-reason exc))
              (let ((delegate (find-delegate-by-uuid self (get-remote-uuid connection))))
                (when delegate
                  (set-exception delegate exc)
                  (set-exception-stack delegate (execution-stack))
                  (set-exception-time delegate (current-seconds))
                  (delay-disconnected-client self delegate))))
            (lambda ()
              (proc connection)))))
      (set-presence-execute-handler
        (lambda (proc connection)
          (handle-exception-filter
            connection-exception?
            (lambda (exc)
              (problem "Executing remote: {a}" (exception-reason exc)))
            (lambda ()
              (proc connection))))))
    (set! configuration (get-server-configuration))
    (set! assets (make-assets self directory))
    (let ((id (make-unique-id)))
      ;; not sure about this, for now lets use the hardcoded server-no = 0
      (set-client-id/no id server-no @w (literal->id id self)))
    (reset-last-broadcast)
    (setup-instances self)
    (setup-zones self))
  
  
  (method override (startup self)
    (nextmethod self)
    (start-aliveness-task self)
    (start-udp-server self))
  
  
  (method override (enter self)
    (let ((me (current-me+)))
      (when me
        (set-name me (get-character-name configuration))
        (set-avatar me (get-character-avatar configuration)))))
  
  
  (method override (shutdown self)
    (stop-udp-server self)
    (stop-aliveness-task self)
    (detach-clients self))
  
  
  (method override (get-udp-tier self)
    udp-server)
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state self)
    'started)
    
  
  (method override (start self)
    )
  
  
  (method override (stop self)
    )
  
  
  (method override (restart self)
    )
  
  
  (method override (wait-started self)
    )
  
  
  (method override (wait-stopped self)
    )
  
  
  (method override (server-name self)
    "World")
  
  
  (method override (server-title self)
    "World")
  
  
  (method override (server-version self)
    (process-version (current-process)))
  
  
  (method override (server-host self)
    (host->string (listening-host (get-remote-listener))))
  
  
  (method override (server-service self)
    (port->string (listening-port (get-remote-listener))))
  
  
  (method override (server-hits self)
    hits)
  
  
  (method override (server-debug? self)
    #f)
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (next-literal-id!))
  
  
  (method override (tier-id->literal self id)
    (error "Unregistered id: {s}" id))
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (method (count-alive self)
    (length delegates))
  
  
  (method package (collect-alive self)
    (sort ci<? delegates key: get-name))
  
  
  (method package (collect-disconnected self)
    disconnected)
  
  
  ;;;
  ;;;; Instances
  ;;;
  
  
  (method (find-instance self uuid)
    (table-ref instances uuid #f))


  (method (setup-instances self)
    (let ((instances-dir (instances-dir self)))
      (when (exists? instances-dir)
        (iterate-directory instances-dir
          (lambda (instance-dir)
            (let ((file (new-file instance-dir ".instance")))
              (when (exists? file)
                (let ((instance (instantiate (read-form file))))
                  (let ((uuid (get-name instance)))
                    (table-set! instances uuid instance))))))
          files?: #f
          directories?: #t
          recursive?: #f))))
  
  
  (method (instances-dir self)
    (new-directory directory "instances"))
  
  
  ;;;
  ;;;; Zones
  ;;;


  (method (setup-zones self)
    (let ((zones-dir (zones-dir self))
          (queue (new-queue)))
      (when (exists? zones-dir)
        (iterate-directory zones-dir
          (lambda (path kind)
            (let ((zone-dir (new-directory zones-dir path)))
              (let ((file (new-file zone-dir ".zone")))
                (when (exists? file)
                  (enqueue queue path)))))
          full?: #f
          files?: #f
          directories?: #t
          recursive?: #t))
      (set! zones (queue-list queue))))
  
  
  (method package (zones-dir self)
    (new-directory directory "zones"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (setup-me self)
    (setup-current-me self)
    (register-id (current-me) (make-unique-id)))
  
  
  (method override (save-me self)
    (save-current-me self))
  
  
  (method override (player-file self)
    (new-file directory '("start" ".player")))
  
  
  (method override (anonymous self)
    "Server")
  
  
  ;;;
  ;;;; Groups
  ;;;
  
  
  (method (find-group self name)
    (find-if (lambda (group)
               (equal? (get-name group) name))
             groups))
  
  
  (method (create-group self delegate name persistent?)
    (logger/activity self "Create group {a} ({a})" name (get-name delegate))
    (let ((group (new Server-Group name persistent?)))
      (set! groups (cons group groups))
      group))
  
  
  (method (delete-group self delegate group)
    (logger/activity self "Delete group {a} ({a})" (get-name group) (if delegate (get-name delegate) "Server"))
    (set! groups (remove! group groups)))
  
  
  (method (maybe-delete-group self delegate group)
    (if (or (get-persistent? group)
            (has-members? self group)
            (has-streams? self group))
        #f
      (delete-group self delegate group)
      #t))
  
  
  (method (disband-group self group)
    (for-each (lambda (delegate)
                (leave-group self delegate group))
              (get-members group))
    (set! groups (remove! group groups)))
  
  
  (method (has-members? self group)
    (not-null? (get-members group)))
  
  
  (method (has-streams? self group)
    (not-null? (get-streams group)))
  
  
  (method (join-group self delegate group)
    (logger/activity self "Join group {a} ({a})" (get-name group) (get-name delegate))
    (set-group delegate group)
    (set-members group (cons delegate (get-members group)))
    (wait-keyframes udp-server delegate (delegate->connection self delegate))
    (update-streaming udp-server group))
  
  
  (method (leave-group self delegate group)
    (logger/activity self "Leave group {a} ({a})" (get-name group) (get-name delegate))
    (done-keyframes udp-server delegate (delegate->connection self delegate))
    (set-group delegate #f)
    (set-members group (remove! delegate (get-members group)))
    (update-streaming udp-server group)
    (maybe-delete-group self delegate group))
  
  
  (method (delegate->connection self delegate)
    (no->connection udp-server (get-no delegate)))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method package (client-connect self client client-uuid character-name character-avatar character-script character-zone character-role character-sphere?)
    (let ((max-connections (world-setting 'world.server-max-connections #f)))
      (if (and max-connections (>= (count-alive self) max-connections))
          (begin
            (logger/activity self "Max connections reached ({a})" character-name)
            (format "Server max {a} connections reached" max-connections))
        (cleanup-disconnected self)
        (let ((existing-delegate (find-delegate-by-name self character-name)))
          ;; open test first draft at reconnection
          (let ((reconnected-delegate
                  (and existing-delegate
                       (or (get-exception existing-delegate)
                           (not (live? (get-client existing-delegate))))
                       existing-delegate))
                (disconnected-delegate
                  (find-if (lambda (delegate)
                             (equal? (get-name delegate) character-name))
                           disconnected)))
            (if (and existing-delegate
                     (not reconnected-delegate))
                (begin
                  (logger/activity self "Name unavailable {a}" character-name)
                  (format "{a} {a} is unavailable" (registered-domain-name 'character "Character") character-name))
              ;; register client
              (let ((delegate (cond (reconnected-delegate
                                     (client-reconnected self client reconnected-delegate client-uuid)
                                     (cleanup-client self reconnected-delegate)
                                     reconnected-delegate)
                                    (disconnected-delegate
                                     (set! disconnected (remove! disconnected-delegate disconnected))
                                     (client-reconnected self client disconnected-delegate client-uuid)
                                     disconnected-delegate)
                                    (else
                                     (let ((id (make-unique-id)))
                                       (new Client-Delegate client 'connected client-uuid id (literal->id id self) character-name character-avatar character-script character-role character-sphere?))))))
                (logger/activity self "{a} {a}" (if reconnected-delegate "Reconnect" "Connect") character-name)
                (unless reconnected-delegate
                  (set! delegates (cons delegate delegates)))
                ;; retrieve character
                (let ((client-id (get-id delegate))
                      (client-no (get-no delegate))
                      (character (character-retrieve self character-name character-avatar))
                      (character-delegate delegate))
                  (set-character character-delegate character)
                  (if (not character-sphere?)
                      (let ((form (call-with-input-file (path-settings {File Settings "servers" "Together" "zones" "Circle" ".zone"}) read-content-string)))
                        (let ((assets #f)
                              (processor #f)
                              (welcome "Welcome to Together!")
                              (spawnpoint (make-zero-vertex))
                              (player-spawnpoint (make-zero-vertex))
                              (player-id client-id)
                              (player-no client-no)
                              (player-position (make-zero-vertex))
                              (player-lookat (make-standard-lookat))
                              (other-players '()))
                          (list client-id client-no assets processor welcome form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players)))
                    ;; join character zone
                    (let ((character-zone (or character-zone (get-zone character))))
                      (let ((processor (spawn-processor (get-host configuration) (get-service configuration) character-zone)))
                        (let ((join-info (client-enter processor client client-uuid client-id client-no character-name character-avatar character-script character-role)))
                          (if (string? join-info)
                              join-info
                            (set-zone character-delegate character-zone)
                            (set-processor character-delegate processor)
                            (bind (form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) join-info
                              (let ((assets #f)
                                    (welcome (cond (arc-en-ciel? "Bienvenue Arc-en-ciel!")
                                                   (open-test? (format "Welcome to the {a} open test!" tier-title))
                                                   (else (format "Welcome to {a}!" tier-title)))))
                                (rebroadcast-draws)
                                (list client-id client-no assets (proxy-connection-info client processor) welcome form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players))))))))))))))))
  
  
  (method package (client-start self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-state delegate 'started)
        @peer2peer
        (broadcast-peers self)
        (broadcast-hierarchy self)
        (broadcast-entered self delegate))))
  
  
  (method package (client-stop self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (let ((group (get-group delegate)))
          (when group
            (leave-group self delegate group)))
        (set-state delegate 'stopped)
        @peer2peer
        (broadcast-peers self)
        (broadcast-hierarchy self)
        (broadcast-exited self delegate))))
  
  
  (method package (client-reconnected self client reconnected-delegate uuid)
    (set-client reconnected-delegate client)
    (set-alive reconnected-delegate (current-seconds))
    (set-exception reconnected-delegate #f)
    (set-exception-stack reconnected-delegate #f)
    (set-exception-time reconnected-delegate #f)
    (set-uuid reconnected-delegate uuid)
    (broadcast-reconnected self reconnected-delegate)
    (set-preserved-group reconnected-delegate #f))
  
  
  (method package (client-disconnect self client character-name)
    (logger/activity self "Disconnect {a}" character-name)
    ;; find server client
    (let ((character-delegate (find-delegate self client)))
      ;; together robust
      (when character-delegate
        ;; disconnect udp
        (when udp-server
          (unconnect-source udp-server (get-no character-delegate)))
        ;; store character
        (character-store self (get-character character-delegate))
        ;; leave zone
        (when (get-sphere? character-delegate)
          (client-exit (get-processor character-delegate) client character-name))
        ;; unregister client
        (set! delegates (remove! character-delegate delegates))
        ;; update state
        (set-state character-delegate 'disconnected)
        ;; closing remote
        (closing-remote-proxy client))))
  
  
  (method package (client-sleep self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-asleep? delegate #t)
        (broadcast-hierarchy self))))
  
  
  (method package (client-wake self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-asleep? delegate #f)
        (broadcast-hierarchy self)
        ;; deliver queued messages
        (let ((queue (get-message-queue delegate)))
          (let ((messages (queue-list queue)))
            (when (not-null? messages)
              (reset-queue queue)
              (deliver-messages self delegate messages)))))))
                  
  
  
  @peer2peer
  (method (broadcast-peers self)
    (let ((peers '()))
      (iterate-table (get-no-connections udp-server)
        (lambda (origin connection)
          (let ((delegate (find-delegate-by-no self origin)))
            (when (and delegate (eq? (get-state delegate) 'started))
              (let ((host (get-host connection))
                    (port (get-port connection))
                    (local-host (get-local-host connection))
                    (local-port (get-local-port connection)))
                (set! peers (cons (list origin host port local-host local-port) peers)))))))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (peers-update client peers))))))
                delegates)))
  
  
  (method (broadcast-hierarchy self)
    (let ((hierarchy (collect-hierarchy self)))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (hierarchy-update client hierarchy))))))
                delegates)))
  
  
  (method (broadcast-entered self client-delegate)
    (let ((client-id (get-id client-delegate))
          (client-no (get-no client-delegate))
          (client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (server-entered client client-id client-no client-name))))))
                delegates)))
  
  
  (method (broadcast-exited self client-delegate)
    (let ((client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (server-exited client client-name))))))
                delegates)))
  
  
  (method (character-retrieve self character-name character-avatar)
    (let ((file (new-file (characters-dir self) (format "{a}.character" character-name))))
      (let ((character
              (if (exists? file)
                  (let ((character (instantiate (read-form file))))
                    (set-name character character-name)
                    (set-avatar character character-avatar)
                    character)
                (let ((units '(world.character)))
                  (let ((tag '(<Character>))
                        (data (new Data zone-version 'jazz units #f)))
                    (let ((form (construct-form tag (imports-locator units) data)))
                      (set-origin form file)
                      (let ((character (instantiate form)))
                        (set-name character character-name)
                        (set-avatar character character-avatar)
                        (set-zone character 'start)
                        character)))))))
        character)))
  
  
  (method (character-store self character)
    (let ((file (new-file (characters-dir self) (format "{a}.character" (get-name character)))))
      (create-directories file)
      (let ((designer (new Former form: (get-form character) reference: character)))
        (define (save-character)
          (set-property designer character 'zone (get-zone character)))
        
        (save-character)
        (save designer))))
  
  
  (method (characters-dir self)
    (new-directory directory "characters"))
  
  
  (method package (client-alive self client)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (when delegate
        (set-alive delegate (current-seconds)))))
  
  
  (method package (client-message self client kind recipient message)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (when delegate
        (let ((sender (get-name delegate)))
          (log-message self sender message)
          (for-each (lambda (delegate)
                      (when (case kind
                              ((whisper)
                               (equal? (get-name delegate) recipient))
                              ((group)
                               (let ((group (get-group delegate)))
                                 (equal? (and group (get-name group)) recipient)))
                              (else
                               #t))
                        (deliver-message self delegate sender kind message)))
                    delegates)))))
  
  
  (method package (client-log self client time message)
    (server-log client time message))
  
  
  (method package (processor-log self processor time message)
    (server-log processor time message))
  
  
  (method package (client-connected-player self client no)
    (connected-player self no))
  
  
  (method override (connected-player self no)
    (if (= no client-no)
        "Server"
      (let ((delegate (find-delegate-by-no self no)))
        (and delegate
             (get-name delegate)))))
  
  
  (method package (client-connected-players self client)
    (connected-players self))
  
  
  (method package (client-available-templates self client)
    (available-templates self))
  
  
  (method package (client-available-zone-base self client from)
    (available-zone-base self from))
  
  
  (method package (client-available-zone-base? self client base)
    (available-zone-base? self base))
  
  
  (method package (client-create-zone self client from base)
    (and (create-zone self from base)
         (list 'zone base)))
  
  
  (method package (client-available-zones self client)
    (available-zones self))
  
  
  (method package (client-change-zone self client zone)
    (change-client-zone self client zone))
  
  
  (method package (client-create-group self client name persistent?)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (if (find-group self name)
            (format "{a} {a} already exists" (group-domain-name self) name)
          (create-group self delegate name persistent?)
          (broadcast-hierarchy self)
          #f))))
  
  
  (method package (client-delete-group self client name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name)))
          (if (not group)
              (format "{a} {a} doesn't exist anymore" (group-domain-name self) name)
            (if (has-members? self group)
                (format "{a} {a} still has members" (group-domain-name self) name)
              (if (has-streams? self group)
                  (format "{a} {a} still has streams" (group-domain-name self) name)
                (when (maybe-delete-group self delegate name)
                  (broadcast-hierarchy self))
                #f)))))))
  
  
  (method package (client-disband-group self client name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (disband-group self name)
        (broadcast-hierarchy self)
        #f)))
  
  
  (method package (client-join-group self client name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name)))
          (if (not group)
              (format "{a} {a} doesn't exist anymore" (group-domain-name self) name)
            (join-group self delegate group)
            (broadcast-hierarchy self)
            (group-streams self group))))))
  
  
  (method package (client-leave-group self client name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name)))
          (if (not group)
              (format "{a} {a} doesn't exist anymore" (group-domain-name self) name)
            (leave-group self delegate group)
            (broadcast-hierarchy self)
            #f)))))
  
  
  (method package (client-change-video-level self client video-level)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((origin (get-no delegate))
              (connection (delegate->connection self delegate)))
          (set-video-level connection video-level)
          (iterate-table (get-server-streams udp-server)
            (lambda (no stream)
              (when (and (get-video-level stream)
                         (= (get-origin stream) origin))
                (set-video-level stream video-level))))
          (let ((group (get-group delegate)))
            (when group
              (update-streaming udp-server group)
              (for-each (lambda (member)
                          (unless (eq? member delegate)
                            (let ((client (get-client member)))
                              (calling-client self member
                                (lambda ()
                                  (streamer-update client origin video-level))))))
                        (get-members group))))
          #f))))
  
  
  (method package (client-register-stream self client sender name source-kind video-level channels recipient)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          (format "Delegate not found")
        (let ((group (get-group client-delegate)))
          (define (normalize-recipient)
            (if (not recipient)
                group
              (map (lambda (no)
                     (find-delegate-by-no self no))
                   recipient)))
          
          (if (and (not recipient)
                   (not group))
              (format "You are not in a group")
            (let ((origin (get-no client-delegate))
                  (recipient (normalize-recipient))
                  (exclude-register client-delegate)
                  (exclude-broadcast client-delegate))
              (bind (stream . server-channels) (server-register-stream self sender name origin source-kind video-level channels recipient exclude-register exclude-broadcast #f)
                (cons (get-no stream) (map get-no server-channels)))))))))
  
  
  (method package (server-register-stream self sender name origin source-kind video-level channels recipient exclude-register exclude-broadcast server-sender?)
    (let ((no (next-stream-no!)))
      (let ((stream (register-server-stream udp-server sender name no origin source-kind video-level recipient exclude-register exclude-broadcast)))
        (let ((server-channels (map (lambda (channel)
                                      (bind (media-kind source-kind level resolution framerate bitrate codec caps metadata) channel
                                        (server-add-channel self no origin media-kind source-kind level resolution framerate bitrate codec caps metadata server-sender?)))
                                    channels))
              (recipients (stream-recipients self stream)))
          (let ((extended-channels (map (lambda (descriptor server-channel)
                                          (cons (get-no server-channel) descriptor))
                                        channels
                                        server-channels)))
            (for-each (lambda (delegate)
                        (unless (eq? delegate exclude-register)
                          (when (eq? (get-state delegate) 'started)
                            (let ((client (get-client delegate)))
                              (calling-client self delegate
                                (lambda ()
                                  (stream-add client sender name no origin source-kind video-level extended-channels)))))))
                      recipients)
            (cons stream server-channels))))))
  
  
  (method package (client-unregister-stream self client stream-no)
    (server-unregister-stream self stream-no))
  
  
  (method package (server-unregister-stream self stream-no)
    (let ((stream (find-server-stream udp-server stream-no)))
      ;; together robust
      (when stream
        (let ((recipients (stream-recipients self stream))
              (exclude-register (get-exclude-register stream)))
          (for-each (lambda (delegate)
                      (unless (eq? delegate exclude-register)
                        (when (eq? (get-state delegate) 'started)
                          (let ((client (get-client delegate)))
                            (calling-client self delegate
                              (lambda ()
                                (stream-remove client stream-no)))))))
                    recipients)
          (close-server-stream udp-server stream)
          #f))))
  
  
  (method package (client-stream-action self client stream-no action arguments)
    (let ((send-stream (find-send-stream udp-server stream-no)))
      (if send-stream
          (let ((action-proc (get-action-proc send-stream)))
            (when action-proc
              (action-proc send-stream action arguments)))
        (let ((stream (find-server-stream udp-server stream-no)))
          ;; together robust
          (when stream
            (let ((origin (get-origin stream)))
              (let ((delegate (find-delegate-by-no self origin)))
                (when delegate
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (action-stream client stream-no action arguments))))))))))))
  
  
  (method package (server-add-channel self stream-no origin media-kind source-kind level resolution framerate bitrate codec caps metadata server-sender?)
    (let ((no (next-channel-no!)))
      (register-server-channel udp-server stream-no no origin media-kind source-kind level resolution framerate bitrate codec caps metadata server-sender?)))
  
  
  (method package (client-channel-action self client channel-no action arguments)
    (let ((channel (find-server-channel udp-server channel-no)))
      ;; together robust
      (when channel
        (let ((origin (get-origin channel)))
          (let ((delegate (find-delegate-by-no self origin)))
            (when delegate
              (let ((client (get-client delegate)))
                (calling-client self delegate
                  (lambda ()
                    (action-channel client channel-no action arguments))))))))))
  
  
  (method (stream-recipients self stream)
    (let ((recipient (get-recipient stream)))
      (if (is? recipient Server-Group)
          (get-members recipient)
        recipient)))
  
  
  (method (group-streams self group)
    (let ((origins (map get-no (get-members group)))
          (streams (new-queue)))
      (iterate-table (get-server-streams udp-server)
        (lambda (no stream)
          (define (collect-channels)
            (let ((channels (new-queue)))
              (iterate-table (get-channels stream)
                (lambda (no channel)
                  (let ((media-kind (get-media-kind channel))
                        (source-kind (get-source-kind channel))
                        (level (get-level channel))
                        (resolution (get-resolution channel))
                        (framerate (get-framerate channel))
                        (bitrate (get-bitrate channel))
                        (codec (get-codec channel))
                        (caps (get-caps channel))
                        (metadata (get-metadata channel)))
                    (enqueue channels (list no media-kind source-kind level resolution framerate bitrate codec caps metadata)))))
              (queue-list channels)))
          
          (let ((origin (get-origin stream)))
            (when (or (memv? origin origins)
                      (= origin server-no))
              (let ((recipient (get-recipient stream)))
                (when (eq? recipient group)
                  (let ((sender (get-sender stream))
                        (name (get-name stream))
                        (source-kind (get-source-kind stream))
                        (video-level (get-video-level stream))
                        (channels (collect-channels)))
                    (enqueue streams (list sender name no origin source-kind video-level channels)))))))))
      (queue-list streams)))
  
  
  (method package (client-list-group-members self name)
    (let ((group (find-group self name)))
      (if (not group)
          (format "{a} {a} doesn't exist anymore" (group-domain-name self) name)
        (map get-name (get-members group)))))
  
  
  (method package (client-list-hierarchy self)
    (collect-hierarchy self))
  
  
  (method (collect-hierarchy self)
    (define (member-info delegate)
      (list (get-name delegate)
            (get-id delegate)
            (get-no delegate)
            (get-asleep? delegate)))
    
    (cons (cons #f
                (map member-info (collect-if (lambda (delegate)
                                               (and (eq? (get-state delegate) 'started)
                                                    (not (get-group delegate))))
                                             delegates)))
          (map (lambda (group)
                 (cons (get-name group)
                       (map member-info (get-members group))))
               groups)))
  
  
  (method (group-domain-name self)
    (registered-domain-name 'group "Group"))
  
  
  (method override (connected-players self)
    (map (lambda (delegate)
           (let ((zone (get-zone delegate)))
             (list (get-name delegate) zone (present-zone self zone))))
         delegates))
  
  
  (method override (retrieve-entity self id)
    (find-entity id))
  
  
  (method override (available-templates self)
    (collect-templates))
  
  
  (method override (available-zone-base self from)
    (unique-zone-base from))
  
  
  (method override (available-zone-base? self base)
    (zone-base-available? base))
  
  
  (method override (create-zone self from base)
    (prog1 (create-new-zone from base
             create: (lambda (dir)
                       (create (new-directory dir "players")))
             open: (lambda (file)
                     #f))
      (setup-zones self)))
  
  
  (method override (available-zones self)
    (let ((queue (new-queue)))
      (iterate-table instances
        (lambda (uuid instance)
          (enqueue queue (cons (list 'instance uuid)
                               (format "{a}{? <{a}>~}" (join (get-template instance) "/") (+ (get-rank instance) 1))))))
      (for-each (lambda (path)
                  (enqueue queue (cons (cons 'zone path)
                                       (last path))))
                zones)
      (queue-list queue)))
  
  
  (method override (change-zone self zone)
    (change-server-zone self zone))
  
  
  (method (change-client-zone self client zone)
    (let ((delegate (find-delegate self client)))
      (let ((client-uuid (get-uuid delegate))
            (client-id (get-id delegate))
            (client-no (get-no delegate))
            (character-name (get-name delegate))
            (character-avatar (get-avatar delegate))
            (character-script (get-script delegate))
            (character-role (get-role delegate)))
        ;; leave
        (client-exit (get-processor delegate) client character-name)
        ;; join
        (let ((processor (spawn-processor (get-host configuration) (get-service configuration) zone)))
          (let ((join-info (client-enter processor client client-uuid client-id client-no character-name character-avatar character-script character-role)))
            (set-zone delegate zone)
            (set-processor delegate processor)
            (cons (proxy-connection-info client processor) join-info))))))
  
  
  ;; todo
  (method (change-server-zone self zone)
    )
  
  
  (method (present-zone self zone)
    (if (eq? zone 'start)
        "<Start Zone>"
      (case (car zone)
        ((instance)
         (let ((instance (find-instance self (cadr zone))))
           (format "{a}{? <{a}>~}" (get-name (get-template instance)) (+ (get-rank instance) 1))))
        (else
         (last zone)))))
  
  
  (method package (retrieve-asset self path)
    (if (ends-with? path "/")
        (let ((dir (make-directory assets path)))
          (and (exists? dir)
               (let ((queue (new-queue)))
                 (iterate-directory dir
                   (lambda (file)
                     (enqueue queue (cons (get-name file) (zlib-deflate (load-binary file)))))
                   files?: #t
                   directories?: #f
                   recursive?: #f)
                 (queue-list queue))))
      (let ((file (make-file assets path)))
        (and (exists? file)
             (zlib-deflate (load-binary file))))))
  
  
  (method package (register-literal self literal)
    (literal->id literal))
  
  
  (method package (registered-id self id)
    (id->literal id))
  
  
  (method (find-delegate self target)
    (find-if (lambda (delegate)
               (proxy=? (get-client delegate) target))
             delegates))
  
  
  (method (find-delegate-by-name self target)
    (find-if (lambda (delegate)
               (equal? (get-name delegate) target))
             delegates))
  
  
  (method (find-delegate-by-uuid self uuid)
    (find-if (lambda (delegate)
               (uuid=? (get-uuid delegate) uuid))
             delegates))
  
  
  (method (find-delegate-by-id self id)
    (find-if (lambda (delegate)
               (equal? (get-id delegate) id))
             delegates))
  
  
  (method (find-delegate-by-no self no)
    (find-if (lambda (delegate)
               (= (get-no delegate) no))
             delegates))
  
  
  (method package (tile-server self)
    (tile self))
  
  
  (method package (restore-server self)
    (restore self))
  
  
  (method package (profile-start self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (profile-start connection)))))
  
  
  (method package (profile-test self client test arguments)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (profile-test connection test arguments)))))
  
  
  (method package (profile-retrieve self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (profile-retrieve connection)))))
  
  
  (method package (profile-stop self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (profile-stop connection)))))
  
  
  (method package (admin-metadata self (requester-group #f))
    (define (send-streams)
      (streams-metadata (get-send-streams udp-server)))
    
    (define (server-streams)
      (streams-metadata (get-server-streams udp-server)))
    
    (define (start-time)
      (and requester-group (get-start-time requester-group)))
    
    (list server-no "_server" (send-streams) (server-streams) (sites-metadata) (start-time)))
  
  
  (method package (admin-command self client command arguments)
    (case command
      ((date)
       (date->string (system-date) "~Y-~m-~d_~H-~M-~S"))
      ((version)
       (let ((version (process-version (current-process))))
         (format "v{a}{a}" (present version) environment-suffix)))
      ((who)
       (map get-name delegates))
      ((crashes)
       (let ((dir {Directory Settings "work" "crashes"}))
         (if (equal? arguments '(clear))
             (begin
               (empty dir)
               (unspecified))
           (let ((queue (new-queue)))
             (iterate-directory dir
               (lambda (file)
                 (when (extension=? (get-extension file) "snapshot")
                   (enqueue queue (get-name file)))))
             (queue-list queue)))))
      ((crash)
       (let ((file (new-file {Directory Settings "work" "crashes"} (car arguments))))
         (and (exists? file)
              (call-with-input-file (path-settings file)
                (lambda (port)
                  (let ((queue (new-queue)))
                    (loop (repeat 10)
                          (let ((line (read-line port)))
                            (unless (eof-object? line)
                              (enqueue queue line))))
                    (queue-list queue)))))))
      ((logs)
       (let ((dir {Directory Settings "work" "logs"}))
         (if (equal? arguments '(clear))
             (let ((active-log (logger-file)))
               (iterate-directory dir
                 (lambda (path)
                   (unless (pathname=? path active-log)
                     (delete path)))
                 files?: #t
                 directories?: #f
                 recursive?: #f)
               (unspecified))
           (let ((queue (new-queue)))
             (iterate-directory dir
               (lambda (file)
                 (when (extension=? (get-extension file) "log")
                   (enqueue queue (get-name file)))))
             (queue-list queue)))))
      ((log)
       (let ((file (if (null? arguments)
                       (logger-file)
                     (new-file {Directory Settings "work" "logs"} (car arguments)))))
         (and (exists? file)
              (load-lines file))))
      ((threads)
       (map ->string (top-threads)))
      ((disconnected)
       (map (lambda (delegate)
              (list (get-name delegate)
                    (exception-reason (get-exception delegate))
                    (get-exception-stack delegate)))
            disconnected))
      ((metadata)
       (admin-metadata self))
      ((latency)
       (bind (who . rest) arguments
         (let ((delegate (find-delegate self client)))
           (let ((connection (no->connection udp-server (get-no delegate))))
             (let ((simulator (require-simulator udp-server connection))
                   (latency (if (null? rest) #f (car rest))))
               (setup-latency simulator latency)
               #f)))))
      ((drop)
       (bind (who . rest) arguments
         (let ((delegate (find-delegate self client)))
           (let ((connection (no->connection udp-server (get-no delegate))))
             (let ((simulator (require-simulator udp-server connection))
                   (drop (if (null? rest) #f (car rest))))
               (setup-drop simulator drop)
               #f)))))
      ((test)
       (let ((no (and (not-null? arguments) (car arguments))))
         (logger "Test server{? {a}~}" no)
         (cond ((not no)
                (exit-no-jobs))
               ((eq? no 'convert)
                (convert-streams {Directory Documents "streams"} what: 'audio))
               (else
                #f))))
      ((attach)
       (logger "Attach server")
       (let ((debugger (car arguments)))
         (delay-event
           (lambda ()
             (setup-debuggee debugger: debugger)
             (start-repl-thread (current-thread) #f (current-console-port))
             (select-debugger-console)
             (current-input-port (console-input-port))
             (current-output-port (console-output-port))
             (ready-to-controller))))
       (unspecified))
      ((detach)
       (logger "Detach server")
       (current-input-port (standard-input-port))
       (current-output-port (standard-output-port))
       (detach-from-controller)
       (unspecified))
      ((restart)
       (logger "Restart server")
       (let ((delay (if (null? arguments) 1 (car arguments))))
         (restart-server self delay))
       (unspecified))
      ((reset)
       (let ((what (if (null? arguments) #f (car arguments))))
         (case what
           ((evolution)
            (reset-evolution)
            #t)
           (else
            #f))))
      ((stream)
       (bind-optionals ((action #f) (what #f) (count #f) (spacing #f)) arguments
         (case action
           ((list)
            (stream-list self client))
           ((play)
            (if (not what)
                "Missing location"
              (or (stream-invalid self client what)
                  (begin
                    (if (not count)
                        (stream-play self client what)
                      (delay-event
                        (lambda ()
                          (loop (for n from 0 below count)
                                (when (and spacing (/= n 0))
                                  (sleep spacing))
                                (stream-play self client what #f)))))
                    #f))))
           ((compare)
            (delay-event
              (lambda ()
                (loop (for location in (cdr arguments))
                      (stream-play self client location #f))))
            #f)
           ((stop)
            (stream-stop self client what))
           ((done)
            (let ((broadcast-hierarchy? #f))
              (iterate-table (get-send-streams udp-server)
                (lambda (no stream)
                  (when (server-close-send-stream self stream)
                    (set! broadcast-hierarchy? #t))))
              (when broadcast-hierarchy?
                (broadcast-hierarchy self)))
            #f))))
      (else
       (let ((requester client))
         (define (dispatch-who who dispatch-server dispatch-client)
           (cond ((equal? who "server")
                  (dispatch-server)
                  #f)
                 ((equal? who "all")
                  (let ((requester-delegate (find-delegate self requester)))
                    (let ((requester-group (and requester-delegate (get-group requester-delegate))))
                      (if (not requester-group)
                          "Not in a circle"
                        (dispatch-server requester-group)
                        (for-each dispatch-client (get-members requester-group))
                        #f))))
                 (else
                  (let ((delegate (find-delegate-by-name self who)))
                    (if (not delegate)
                        (format "Unable to find {a}" who)
                      (dispatch-client delegate)
                      #f)))))
         
         (case command
           ((request)
            (bind (cookie who what action) arguments
              (define (request-server (requester-group #f))
                (admin-server-request self requester requester-group cookie what action))
              
              (define (request-client delegate)
                (let ((client (get-client delegate)))
                  (calling-client self delegate
                    (lambda ()
                      (admin-request client requester cookie what action)))))
              
              (dispatch-who who request-server request-client)))
           ;((run)
           ; (bind (cookie script who) arguments
           ;   (define (run-server (requester-group #f))
           ;     (admin-server-run self requester cookie script))
           ;   
           ;   (define (run-client delegate)
           ;     (let ((client (get-client delegate)))
           ;       (calling-client self delegate
           ;         (lambda ()
           ;           (admin-run client requester cookie script)))))
           ;   
           ;   (dispatch-who who run-server run-client)))
           (else
            (format "Unknown command: {s}" command)))))))
  
  
  (method (admin-server-request self requester requester-group cookie what action)
    (define (send-caps)
      (let ((file {File Settings "caps" "server.caps"}))
        (when (exists? file)
          (send-file 0 file))))
    
    (define (send-info)
      (send-threaded 0
        (lambda ()
          (let ((server (current-server)))
            ;; gc before process-memory
            (let ((garbage-collect (estimate-garbage-collect)))
              (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
                (object->u8vector
                  (list
                    (server-host server)
                    (server-service server)
                    (map get-name (collect-alive (current-server)))
                    (map get-name (collect-disconnected (current-server)))
                    (table-values processors)
                    (map get-purpose (table-values presences))
                    (collect-hierarchy (current-server))
                    garbage-collect
                    (estimate-cpu%)
                    (length (top-threads))
                    last-gc-live
                    last-gc-movable
                    last-gc-nonmovable
                    (let ((port (get-udp-port udp-server)))
                      (list (udp-socket-receive-buffer-size port)
                            (udp-socket-send-buffer-size port)
                            (udp-socket-send-again-count port)))
                    outgoing-max))))))))
    
    (define (send-replay)
      (send-threaded 0
        (lambda ()
          (let ((metadata (admin-metadata self requester-group))
                (chronology (copy-chronology (current-chronology)))
                (evolution (copy-evolution (current-evolution))))
            (object->u8vector (list metadata chronology evolution) serialize)))
        (lambda ()
          (gather-replay-missing udp-server action))))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Documents "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file name)
      (let ((dir {Directory Documents "shared"}))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-settings)
      (let ((file support-settings-file))
        (when (exists? file)
          (send-file 0 file))))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (send-threaded name extract (missing #f))
      (let ((thread
              (new-thread
                (lambda ()
                  (let ((sender "_server"))
                    (admin-chunk requester cookie sender name #f #f)
                    (let ((content (zlib-deflate (extract)))
                          (give-time .01))
                      (when missing
                        (let ((missing (missing)))
                          (for-each (lambda (missing)
                                      (sleep give-time)
                                      (admin-request-chunk self requester cookie sender 'missing missing #f))
                                    missing)))
                      (let ((content-size (u8vector-length content))
                            (max-size 8192))
                        (let (loop-chunk (part 0) (pos 0))
                          (let ((remain (- content-size pos)))
                            (when (> remain 0)
                              (sleep give-time)
                              (let ((chunk-size (min remain max-size)))
                                (let ((chunk (make-u8vector chunk-size))
                                      (done? (>= chunk-size remain)))
                                  (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                                  (admin-request-chunk self requester cookie sender name chunk done?))
                                (loop-chunk (+ part 1) (+ pos chunk-size))))))))))
                'request)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)))
    
    (if (string? what)
        (send-shared-file what)
      (case what
        ((caps)
         (send-caps))
        ((info)
         (send-info))
        ((replay)
         (send-replay))
        ((shared)
         (send-shared))
        ((settings)
         (send-settings)))))
  
  
  ;(method (admin-server-run self requester cookie script)
  ;  (run-remote-script script
  ;    (lambda (state data)
  ;      (let ((sender "_server"))
  ;        (admin-run-return self requester cookie sender state data)))))
  
  
  (method (admin-request-chunk self requester cookie sender name chunk done?)
    (let ((delegate (find-delegate self requester)))
      (when delegate
        (calling-client self delegate
          (lambda ()
            (admin-chunk requester cookie sender name chunk done?))))))
  
  
  ;(method (admin-run-return self requester cookie sender state data)
  ;  (let ((delegate (find-delegate self requester)))
  ;    (when delegate
  ;      (calling-client self delegate
  ;        (lambda ()
  ;          (admin-return requester cookie sender state data))))))
  
  
  (method (restart-server self delay)
    (let ((process (current-process)))
      (delay-event
        (lambda ()
          (count-down delay
            (lambda (suffix)
              (broadcast-server-message self
                (if (= delay 1)
                    "Restart"
                  (format "Restart in {a}" suffix))))
            (lambda ()
              (quit-process process)))))))
  
  
  (method (broadcast-server-message self message)
    (let ((sender "Server")
          (kind 'server))
      (for-each (lambda (delegate)
                  (deliver-message self delegate sender kind message))
                delegates)))
  
  
  (method (broadcast-activity-message self message)
    (let ((sender "Server")
          (kind 'activity))
      (for-each (lambda (delegate)
                  (when (memq? (get-role delegate) '(developer admin))
                    (deliver-message self delegate sender kind message)))
                delegates)))
  
  
  ;;;
  ;;;; Aliveness
  ;;;
  
  
  (method (start-aliveness-task self)
    ;; together robust
    (unless together?
    (set! aliveness-task (new Task 'aliveness (lambda (task)
                                                (aliveness-loop self task))
                              priority: aliveness-priority))
    (start-task aliveness-task)))
  
  
  (method (stop-aliveness-task self)
    ;; together robust
    (unless together?
    (exit-thread (get-thread aliveness-task))
    (thread-join! (get-thread aliveness-task))
    (set! aliveness-task #f)))
  
  
  (method (aliveness-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (with-task-mutex
                (lambda ()
                  (unless (stopping? task)
                    (site (aliveness)
                      (check-aliveness self)))))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task aliveness-period duration exit))
              (iter time)))))))
  
  
  (method (check-aliveness self)
    (let ((newly-disconnected '()))
      (for-each (lambda (delegate)
                  (when (not (still-alive? delegate))
                    (let ((group (get-group delegate)))
                      (set-exception delegate "Disconnected")
                      (set-exception-stack delegate '())
                      (set-exception-time delegate (current-seconds))
                      (disconnected-client self delegate)
                      (set! newly-disconnected (cons (cons delegate group) newly-disconnected)))))
                delegates)
      (cleanup-disconnected self)
      (when (not-null? newly-disconnected)
        (broadcast-disconnected self newly-disconnected))))
  
  
  (method (cleanup-disconnected self)
    (set! disconnected (collect-if keep-disconnected? disconnected)))
  
  
  (method (disconnected-client self delegate)
    (logger/activity self "Disconnected {a}" (get-name delegate))
    (set! delegates (remove! delegate delegates))
    (set! disconnected (cons delegate disconnected))
    (set-preserved-group delegate (get-group delegate))
    (cleanup-client self delegate)
    (calling-client self delegate
      (lambda ()
        (catch (connection-exception? exc)
          (detach-client (get-client delegate))))))
  
  
  (method package (cleanup-client self delegate)
    ;; unregister existing streams
    (let ((reconnected-no (get-no delegate)))
      (iterate-table (get-server-streams udp-server)
        (lambda (no stream)
          (when (= (get-origin stream) reconnected-no)
            (server-unregister-stream self no)))))
    ;; leave group
    (let ((group (get-group delegate)))
      (when group
        (leave-group self delegate group))))
  
  
  (method override (delay-disconnected-client self delegate)
    (delay-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (let ((group (get-group delegate)))
              (disconnected-client self delegate)
              (broadcast-disconnected self (list (cons delegate group)))))))))
  
  
  (method (broadcast-disconnected self newly-disconnected)
    (broadcast-hierarchy self)
    (for-each (lambda (client-info)
                (bind (client-delegate . client-group) client-info
                  (when client-group
                    (let ((client-name (get-name client-delegate)))
                      (for-each (lambda (delegate)
                                  (unless (eq? delegate client-delegate)
                                    (let ((client (get-client delegate)))
                                      (calling-client self delegate
                                        (lambda ()
                                          (server-disconnected client client-name))))))
                                (get-members client-group))))))
              newly-disconnected))
  
  
  (method (broadcast-reconnected self client-delegate)
    (let ((client-group (or (get-group client-delegate) (get-preserved-group client-delegate))))
      (when (and client-group (memq? client-group groups))
        (let ((client-name (get-name client-delegate)))
          (for-each (lambda (delegate)
                      (unless (eq? delegate client-delegate)
                        (let ((client (get-client delegate)))
                          (calling-client self delegate
                            (lambda ()
                              (server-reconnected client client-name))))))
                    (get-members client-group))))))
  
  
  ;;;
  ;;;; UDP
  ;;;
  
  
  (method (start-udp-server self)
    (let ((host (get-host configuration))
          (service (get-service configuration)))
      (let ((server (new UDP-Server)))
        (start server host service)
        (set! udp-server server)
        (set-?u server))))
  
  
  (method (stop-udp-server self)
    (when udp-server
      (stop udp-server)
      (set! udp-server #f)))
  
  
  ;;;
  ;;;; Detach
  ;;;
  
  
  (method (detach-clients self)
    (for-each (lambda (delegate)
                (calling-client self delegate
                  (lambda ()
                    (detach-client (get-client delegate)))))
              delegates))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method (stream-list self client)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          "Delegate not found"
        (let ((group (get-group client-delegate))
              (video-extensions (streaming-video-extensions))
              (audio-extensions (streaming-audio-extensions))
              (queue (new-queue)))
          (iterate-streams
            (lambda (file)
              (when (or (member? (get-extension file) video-extensions test: extension=?)
                        (member? (get-extension file) audio-extensions test: extension=?))
                (let ((base (get-base file)))
                  (let ((location (filename-spine (join (subpath {Directory Documents} file) "/"))))
                    (unless (member? location (queue-list queue) key: car test: filename=?)
                      (enqueue queue (list location (if (some? (lambda (stream)
                                                                 (or (not group)
                                                                     (let ((server-stream (find-server-stream udp-server (get-no stream))))
                                                                       (eq? (get-recipient server-stream) group))))
                                                               (find-streams self base))
                                                        'playing
                                                      #f)))))))))
          (queue-list queue)))))
  
  
  (method (make-server-stream self name source-kind video-level creators group (location: location #f))
    (let ((channels (map get-descriptor creators)))
      (bind (stream . server-channels) (server-register-stream self server-sender name server-no source-kind video-level channels group #f #f #t)
        (let ((stream-no (get-no stream)))
          (let ((send-stream (register-send-stream udp-server server-sender name stream-no source-kind video-level)))
            (set-location send-stream location)
            (for-each (lambda (server-channel creator)
                        (let ((create (get-create creator)))
                          (create stream-no (get-no server-channel))))
                      server-channels
                      creators)
            (values stream send-stream))))))
  
  
  (method (stream-invalid self client location)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          "Delegate not found"
        (let ((group (get-group client-delegate)))
          (if (not group)
              "You are not in a group"
            (if (not (string? location))
                "Invalid location"
              (let ((audio? (exists? (new-file {Directory Documents} (add-extension location (audio-profile-extension))))))
                (if audio?
                    #f
                  (if (null? (existing-video-profiles location))
                      "No stream found"
                    #f)))))))))
  
  
  (method (stream-play self client location (delay-streaming? #t))
    (let ((client-delegate (find-delegate self client)))
      (let ((group (get-group client-delegate)))
        (let ((name (filename-name location))
              (audio-file? (exists? (new-file {Directory Documents} (add-extension location (audio-profile-extension))))))
          (let ((audio-channels (if (and audio-file?
                                         (not stream-silent?))
                                    (list (make-server-audio-channel self location group))
                                  '()))
                (video-channels (make-server-video-channels self location group)))
            (let ((video-level (and (not-null? video-channels) (determine-stream-video-level video-channels)))
                  (channels (append audio-channels video-channels)))
              (receive (stream send-stream) (make-server-stream self name 'stream video-level channels group location: location)
                (set-action-proc send-stream stream-controller-action)
                (set-streams group (cons stream (get-streams group)))
                (if delay-streaming?
                    (delay-streaming
                      (lambda ()
                        (play send-stream)))
                  (sleep streaming-delay)
                  (play send-stream)))))))))
  
  
  (method (stream-stop self client location)
    (let ((name (filename-name location)))
      (let ((streams (find-streams self name)))
        (if (null? streams)
            "Stream not found"
          (let ((broadcast-hierarchy? #f))
            (for-each (lambda (stream)
                        (when (server-close-send-stream self stream)
                          (set! broadcast-hierarchy? #t)))
                      streams)
            (when broadcast-hierarchy?
              (broadcast-hierarchy self)))
          #f))))
  
  
  (method (find-streams self name)
    (let ((queue (new-queue)))
      (iterate-table (get-send-streams udp-server)
        (lambda (no stream)
          (when (equal? (get-name stream) name)
            (enqueue queue stream))))
      (queue-list queue)))
  
  
  (method (streaming-channels self)
    (map-table (lambda (no channel)
                 channel)
               (get-send-channels udp-server)))
  
  
  (method (make-server-audio-channel self location group)
    (let ((file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
      (let ((reader (new Stream-Reader file)))
        (let ((media-kind udp-audio)
              (source-kind 'stream)
              (level #f)
              (resolution #f)
              (framerate #f)
              (bitrate #f)
              (codec audio-codec)
              (caps (get-caps reader))
              (metadata '()))
          (close reader)
          (new Channel-Creator
            (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
            (lambda (stream-no channel-no)
              (let ((channel (register-send-channel udp-server stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                (let ((src (new File-Stream-Audio-Src
                             location))
                      (sink (new Stream-Consumer
                              consumer: (lambda (buffer dts pts duration)
                                          (send-server-media self channel-no buffer #f dts pts duration)))))
                  (let ((pipeline (pipeline (list src sink))))
                    (set-pipeline channel pipeline))))))))))
  
  
  (method (make-server-video-channels self location group)
    (let ((existing-profiles (existing-video-profiles location)))
      (map (lambda (profile)
             (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
               (let ((reader (new Stream-Reader file)))
                 (let ((media-kind udp-video)
                       (source-kind 'stream)
                       (level (get-level profile)))
                   (let ((resolution (if (not level) (get-resolution reader) (get-resolution profile)))
                         (framerate (get-framerate profile))
                         (bitrate (get-bitrate profile))
                         (codec (get-codec profile))
                         (caps (get-caps reader))
                         (metadata (list start: (get-start reader) end: (get-end reader))))
                     (close reader)
                     (new Channel-Creator
                       (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                       (lambda (stream-no channel-no)
                         (let ((channel (register-send-channel udp-server stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                           (let ((src (new File-Stream-Video-Src
                                        profile
                                        location
                                        stream?: (stream-to-group? udp-server channel group)))
                                 (sink (new Stream-Consumer
                                         consumer: (lambda (buffer dts pts duration)
                                                     (let ((keyframe? (and buffer (video-buffer-keyframe? buffer))))
                                                       (send-server-media self channel-no buffer keyframe? dts pts duration))))))
                             (let ((pipeline (pipeline (list src sink))))
                               (set-pipeline channel pipeline)))))))))))
           existing-profiles)))
  
  
  (method package (send-server-media self channel-no buffer keyframe? dts pts duration)
    (when udp-server
      (send-media udp-server channel-no buffer keyframe? dts pts duration)))
  
  
  (method (server-close-send-stream self stream)
    (let ((server-stream (find-server-stream udp-server (get-no stream))))
      (let ((group (get-recipient server-stream)))
        (close-send-stream udp-server stream)
        (set-streams group (remove! server-stream (get-streams group)))
        (maybe-delete-group self #f group))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (world.window:tile-server/clients (non-bot-clients self)))
  
  
  (method override (restore self)
    (world.window:restore-server/clients (non-bot-clients self)))
  
  
  (method (non-bot-clients self)
    (map get-client (collect-if (lambda (delegate)
                                   (not (get-script delegate)))
                                 delegates)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (server-log #f (current-seconds) message)))
  
  
  ;;;
  ;;;; Logger
  ;;;
  
  
  (method package (logger/activity self . rest)
    (let ((message (apply format rest)))
      (logger "{a}" message)
      (broadcast-activity-message self message)))
  
  
  ;;;
  ;;;; Simulate
  ;;;
  
  
  (method package (protocol-simulation self kind)
    (define (setup-protocol-simulation server-protocol clients-protocol)
      @convert-to-presence
      (for-each (lambda (delegate)
                  (let ((client (get-client delegate)))
                    (let ((uuid (get-uuid (get-ior client))))
                      (let ((connection (require-remote-connection uuid)))
                        (set-protocol connection clients-protocol)))
                    (server-protocol client server-protocol)))
                delegates))
    
    (case kind
      ((none) (setup-protocol-simulation #f #f))
      ((slow) (setup-protocol-simulation .05 .1))
      ((awful) (setup-protocol-simulation .25 .5))
      (else (error "Unknown protocol simulation: {a}" kind))))
  
  
  ;;;
  ;;;; Messages
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file self)
    (or log-file
        (let ((file (timestamped-file (new-directory directory "messages") "messages" "txt")))
          (create-directories file)
          (set! log-file file)
          file)))
  
  
  (method (log-message self sender message)
    (call-with-output-file (path-settings (cache-log-file self) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message))))
  
  
  (method (deliver-message self delegate sender kind message)
    (if (get-asleep? delegate)
        (enqueue (get-message-queue delegate) (list sender kind message))
      (let ((client (get-client delegate)))
        (calling-client self delegate
          (lambda ()
            (server-message client sender kind message))))))
  
  
  (method (deliver-messages self delegate messages)
    (let ((client (get-client delegate)))
      (calling-client self delegate
        (lambda ()
          (server-messages client messages))))))


;;;
;;;; Slave
;;;


(definition protected (ready-server)
  (when master-process
    (let ((server (load-object (get-local-register) 'world.server.remote 'world-remote-server)))
      (slave-setup master-process server master-cookie)
      (slave-ready master-process server master-cookie)))))
