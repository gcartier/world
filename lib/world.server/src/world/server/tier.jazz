;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.server.tier jazz


(import (jazz.component)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.jrm.protocol)
        (jazz.network)
        (jazz.process)
        (world)
        (world.assets)
        (world.autoload)
        (world.history)
        (world.instance)
        (world.server.client)
        (world.server.serving)
        (world.settings)
        (world.syntax (phase syntax)))


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                                      getter generate)
  (slot clients       initialize '()                       getter generate)
  (slot instances     initialize (make-table test: equal?) getter generate)
  (slot zones         initialize '()                       getter generate)
  (slot hits          initialize 0                         getter generate)
  
  
  (method override (initialize dir)
    (nextmethod dir)
    (set! configuration (instantiate~ (read-form (new-file~ dir ".server"))))
    (set! assets (gather-assets 'tier (new-directory~ directory "assets")))
    (let ((id (make-unique-id)))
      (set-client-id/no id (literal->id id self)))
    ;; aec quicky
    (set-remote-problem-handler
      (lambda (process)
        (catch (connection-problem? obj
                 obj)
          (process))))
    (let ((host (get-host~ configuration))
          (service (get-service~ configuration)))
      ;; quick solution to launch the server process with an explicit
      ;; listen parameter because it is not possible at the moment to
      ;; change the remote listener host / service after it is started
      (assert (or (not (get-remote-listener)) (command-argument "listen"))
        (start-remote-listener host: host service: service)))
    (setup-instances)
    (setup-zones))
  
  
  (method override (enter)
    (let ((me (current-me+)))
      (when me
        (set-name~ me (get-character-name~ configuration))
        (set-avatar~ me (get-character-avatar~ configuration)))))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state)
    'started)
    
  
  (method override (start)
    )
  
  
  (method override (stop)
    )
  
  
  (method override (restart)
    )
  
  
  (method override (wait-started)
    )
  
  
  (method override (wait-stopped)
    )
  
  
  (method override (server-name)
    "World")
  
  
  (method override (server-title)
    "World")
  
  
  (method override (server-version)
    (process-version~ (get-process)))
  
  
  (method override (server-host)
    (host->string (listening-host~ (get-remote-listener))))
  
  
  (method override (server-service)
    (port->string (listening-port~ (get-remote-listener))))
  
  
  (method override (server-hits)
    hits)
  
  
  (method override (server-debug?)
    #f)
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id literal)
    (next-literal-id!))
  
  
  (method override (tier-id->literal id)
    (error "Unregistered id: {s}" id))
  
  
  ;;;
  ;;;; Instances
  ;;;
  
  
  (method (find-instance uuid)
    (table-ref instances uuid #f))


  (method (setup-instances)
    (let ((instances-dir (instances-dir)))
      (when (exists?~ instances-dir)
        (iterate-directory~ instances-dir
          (lambda (instance-dir)
            (let ((file (new-file~ instance-dir ".instance")))
              (when (exists?~ file)
                (let ((instance (instantiate~ (read-form file))))
                  (let ((uuid (get-name~ instance)))
                    (table-set! instances uuid instance))))))
          files?: #f
          directories?: #t
          recursive?: #f))))
  
  
  (method (instances-dir)
    (new-directory~ directory "instances"))
  
  
  ;;;
  ;;;; Zones
  ;;;


  (method (setup-zones)
    (let ((zones-dir (zones-dir))
          (queue (new-queue)))
      (when (exists?~ zones-dir)
        (iterate-directory~ zones-dir
          (lambda (path kind)
            (let ((zone-dir (new-directory~ zones-dir path)))
              (let ((file (new-file~ zone-dir ".zone")))
                (when (exists?~ file)
                  (enqueue queue path)))))
          full?: #f
          files?: #f
          directories?: #t
          recursive?: #t))
      (set! zones (queue-list queue))))
  
  
  (method (zones-dir)
    (new-directory~ directory "zones"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (setup-me)
    (when (window?)
      (setup-current-me)
      (register-id~ (current-me) (make-unique-id))))
  
  
  (method override (save-me)
    (when (window?)
      (save-current-me)))
  
  
  (method override (player-file)
    (new-file~ directory '("start" ".player")))
  
  
  (method override (anonymous)
    "Server")
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (definition disconnect-delay
    30.)
  
  
  (method (still-alive? client-state)
    (let ((alive (get-alive~ client-state)))
      (and alive (< (- (current-seconds) alive) disconnect-delay))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (client-enter client character-name character-avatar)
    (let ((world (current-world))
          (zone (current-zone)))
      (debug-server 'client-enter character-name character-avatar)
      (let ((existing-client-state (find-client-state-by-name character-name)))
        ;; open test first draft at reconnection
        (let ((reconnected-client-state
                (and existing-client-state
                     (or (get-exception~ existing-client-state)
                         (not (still-alive? existing-client-state))
                         (not (live?~ (get-client~ existing-client-state))))
                     existing-client-state)))
          (if (and existing-client-state
                   (not reconnected-client-state))
              (format "Character {a} is unavailable" character-name)
            ;; register client
            (let ((client-state (if (not reconnected-client-state)
                                    (let ((id (make-unique-id)))
                                      (new Client-State client id (literal->id id self) character-name character-avatar))
                                  (set-client~ reconnected-client-state client)
                                  (set-alive~ reconnected-client-state (current-seconds))
                                  (set-exception~ reconnected-client-state #f)
                                  (set-exception-time~ reconnected-client-state #f)
                                  reconnected-client-state)))
              (unless reconnected-client-state
                (set! clients (cons client-state clients)))
              ;; retrieve character
              (let ((client-id (get-id~ client-state))
                    (client-no (get-no~ client-state))
                    (character (character-retrieve character-name character-avatar))
                    (character-client-state client-state))
                (set-character~ character-client-state character)
                ;; join character zone
                (let ((character-zone (get-zone~ character)))
                  (let ((processor (if (eq? character-zone 'start) (get-remote-processor~ (current-processor)) (spawn-processor character-zone))))
                    (let ((join-info (client-join~ processor client client-id client-no character-name character-avatar)))
                      (if (string? join-info)
                          join-info
                        (set-zone~ character-client-state character-zone)
                        (set-processor~ character-client-state processor)
                        (bind (form spawnpoint player-id player-position player-lookat other-players) join-info
                          (when (window?)
                            (let ((player (find-player~ zone character-name)))
                              ;; aec robust
                              (when player
                                (add-simulation~ zone player)))
                            (if reconnected-client-state
                                (display-message~ world (format "{a} reconnected" character-name))
                              (display-message~ world (format "{a} entered world" character-name))))
                          (let ((assets #f)
                                (welcome (cond ((arc-en-ciel?) "Bienvenue Arc-en-ciel!")
                                               (open-test? "Welcome to the Yownu open test!")
                                               (else "Welcome to Yownu!"))))
                            (list client-id client-no assets processor welcome form spawnpoint player-id player-position player-lookat other-players))))))))))))))
  
  
  (method (client-exit client character-name)
    (let ((world (current-world))
          (zone (current-zone)))
      (debug-server 'client-exit character-name)
      (when (window?)
        (let ((player (find-player~ zone character-name)))
          ;; aec robust
          (when player
            (remove-simulation~ zone player))))
      ;; find server client
      (let ((character-client-state (find-client-state client)))
          ;; store character
        (character-store (get-character~ character-client-state))
        ;; leave zone
        (client-leave~ (get-processor~ character-client-state) client character-name)
        ;; unregister client
        (set! clients (remove! character-client-state clients)))
      (when (window?)
        (display-message~ world (format "{a} exited world" character-name)))))
  
  
  (method (character-retrieve character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file~ (characters-dir) (format "{a}.character" character-name))))
        (let ((character
                (if (exists?~ file)
                    (let ((character (instantiate~ (read-form file))))
                      (set-name~ character character-name)
                      (set-avatar~ character character-avatar)
                      character)
                  (let ((units '(world.data)))
                    (let ((tag '(<Character>))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin~ form file)
                        (let ((character (instantiate~ form)))
                          (set-name~ character character-name)
                          (set-avatar~ character character-avatar)
                          (set-zone~ character 'start)
                          character)))))))
          character))))
  
  
  (method (character-store character)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file~ (characters-dir) (format "{a}.character" (get-name~ character)))))
        (create-directories~ file)
        (let ((designer (new Former form: (get-form~ character) reference: character)))
          (define (save-character)
            (set-property~ designer character 'zone (get-zone~ character)))
          
          (save-character)
          (save~ designer)))))
  
  
  (method (characters-dir)
    (new-directory~ directory "characters"))
  
  
  (method (client-alive client)
    (let ((client-state (find-client-state client)))
      ;; aec robust
      (when client-state
        (set-alive~ client-state (current-seconds)))))
  
  
  (method (client-message client kind recipient message)
    ;; aec robust
    (let ((client-state (find-client-state client)))
      (when client-state
        (let ((sender (get-name~ client-state)))
          (log-message sender message)
          (for-each (lambda (client-state)
                      (let ((client (get-client~ client-state)))
                        (when (or (neq? kind 'whisper)
                                  (ci=? (get-name~ client-state) recipient))
                          (calling-client client-state
                            (lambda ()
                              (server-message~ client sender kind message))))))
                    clients)))))
  
  
  (method (client-log client message)
    (server-log client message))
  
  
  (method (client-debug client arguments)
    ;; aec robust
    (let ((client-state (find-client-state client)))
      (when client-state
        (apply debug (get-name~ client-state) arguments))))
  
  
  (method (processor-debug processor arguments)
    (apply debug processor arguments))
  
  
  (method (client-connected-players client)
    (connected-players))
  
  
  (method override (connected-players)
    (map (lambda (client-state)
           (let ((zone (get-zone~ client-state)))
             (list (get-name~ client-state) zone (present-zone zone))))
         clients))
  
  
  (method (available-zones client)
    (let ((queue (new-queue)))
      (iterate-table instances
        (lambda (uuid instance)
          (enqueue queue (cons (list 'instance uuid)
                               (format "{a}{? <{a}>~}" (get-name~ (get-template~ instance)) (+ (get-rank~ instance) 1))))))
      (for-each (lambda (path)
                  (enqueue queue (cons (cons 'zone path)
                                       (last path))))
                zones)
      (queue-list queue)))
  
  
  (method (change-zone client zone)
    (let ((client-state (find-client-state client)))
      (let ((client-id (get-id~ client-state))
            (client-no (get-no~ client-state))
            (character-name (get-name~ client-state))
            (character-avatar (get-avatar~ client-state)))
        ;; leave
        (client-leave~ (get-processor~ client-state) client character-name)
        ;; join
        (let ((processor (if (eq? zone 'start) (get-remote-processor~ (current-processor)) (spawn-processor zone))))
          (let ((join-info (client-join~ processor client client-id client-no character-name character-avatar)))
            (set-zone~ client-state zone)
            (set-processor~ client-state processor)
            (cons processor join-info))))))
  
  
  (method (present-zone zone)
    (if (eq? zone 'start)
        "<Start Zone>"
      (case (car zone)
        ((instance)
         (let ((instance (find-instance (cadr zone))))
           (format "{a}{? <{a}>~}" (get-name~ (get-template~ instance)) (+ (get-rank~ instance) 1))))
        (else
         (last zone)))))
  
  
  (method (retrieve-asset path)
    #f)
  
  
  (method (register-literal literal)
    (literal->id literal))
  
  
  (method (registered-id id)
    (id->literal id))
  
  
  (method (find-client-state target)
    (find-if (lambda (client)
               (proxy=? (get-client~ client) target))
             clients))
  
  
  (method (find-client-state-by-name target)
    (find-if (lambda (client)
               (equal? (get-name~ client) target))
             clients))
  
  
  ;; todo
  (method (check-clients-liveliness)
    (for-each (lambda (client-state)
                )
              clients))
  
  
  (method (live-server)
    (live))
  
  
  (method (restore-server)
    (restore))
  
  
  ;;;
  ;;;; Live
  ;;;
  
  
  (method override (live)
    (when (window?)
      (world.window:tile-server/clients (map get-client~ clients))))
  
  
  (method override (restore)
    (when (window?)
      (world.window:restore-server/clients (map get-client~ clients))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log message)
    (when (world-setting 'world.log? #f)
      (server-log #f message)))
  
  
  (method (server-log client message)
    (define (log)
      (let ((character-name (and client (get-name~ (find-client-state client)))))
        (format :console "{a} {a}{%}" character-name message)))
    
    (if (primordial-thread?)
        (log)
      (thread-post (primordial-thread) 'post-event
        (lambda ()
          (log)))))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (debug-server . rest)
    (when (world-setting 'world.server.debug? #f)
      (apply debug 'server rest)))
  
  
  ;;;
  ;;;; Messages
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file)
    (or log-file
        (let ((zone (current-zone)))
          (let ((file (timestamped-file (new-directory~ directory "messages") "messages" "txt")))
            (create-directories~ file)
            (set! log-file file)
            file))))
  
  
  (method (log-message sender message)
    (call-with-output-file (path-settings (cache-log-file) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message))))))
