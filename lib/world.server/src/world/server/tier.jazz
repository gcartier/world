;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.server.tier jazz


(import (jazz.graphic)
        (jazz.jrm)
        (jazz.process)
        (jazz.settings)
        (world)
        (world.autoload)
        (world.change)
        (world.geometry)
        (world.history)
        (world.network)
        (world.server.client)
        (world.settings)
        (world.syntax (phase syntax))
        (world.tier)
        (world.window))


(class Server-Tier extends Tier
  
  
  (slot clients initialize '() getter generate)
  
  
  (method override (initialize settings)
    (set! settings~self settings)
    (setup))
  
  
  (method override (setup)
    (register-settings settings))
  
  
  (method override (shutdown)
    (unregister-settings settings))
  
  
  ;;;
  ;;;; Remote
  ;;;
  
  
  (method override (get-world-server)
    #f)
  
  
  (method override (get-world-client)
    #f)
  
  
  ;;;
  ;;;; Clients
  ;;;
  
  
  (method (client-enter player-client player-name player-avatar)
    (let ((world (current-world)))
      (debug-server 'client-enter player-name player-avatar)
      ;; register client
      (let ((client-id (next-unique-id!)))
        (let ((server-client (new Server-Client client-id player-client player-name)))
          (set! clients (cons server-client clients))
          ;; retrieve player
          (let ((player (player-retrieve player-name player-avatar))
                (player-server-client (find-server-client player-client)))
            ;; send existing players to client
            (for-each (lambda (server-client)
                        (unless (eq? server-client player-server-client)
                          (let ((name (get-name~ server-client)))
                            (let ((existing (find-player~ world name)))
                              (let ((id (get-id~ existing))
                                    (avatar (get-avatar~ existing))
                                    (position (get-position~ existing))
                                    (lookat (get-lookat~ existing)))
                                (server-player~ player-client id name avatar position lookat))))))
                      clients)
            ;; broadcast entering player to other clients
            (let ((player-id (get-id~ player))
                  (player-position (get-position~ player))
                  (player-lookat (get-lookat~ player)))
              (for-each (lambda (server-client)
                          (unless (eq? server-client player-server-client)
                            (let ((client (get-client~ server-client)))
                              (server-entered~ client player-id player-name player-avatar player-position player-lookat))))
                        clients)
              (when (get-visible?~ (current-world-window))
                (display-message~ world (format "{a} entered world" player-name)))
              (list client-id player-id player-position player-lookat)))))))
  
  
  (method (client-exit player-client player-name)
    (let ((world (current-world)))
      (debug-server 'client-exit player-name)
      ;; store player
      (player-store (find-player~ world player-name))
      ;; broadcast exiting player to other clients
      (let ((player-server-client (find-server-client player-client)))
        (for-each (lambda (server-client)
                    (unless (eq? server-client player-server-client)
                      (let ((client (get-client~ server-client)))
                        (server-exited~ client player-name))))
                  clients))
      ;; unregister client
      (let ((server-client (find-server-client player-client)))
        (set! clients (remove! server-client clients)))
      (when (get-visible?~ (current-world-window))
        (display-message~ world (format "{a} exited world" player-name)))))
  
  
  (method (player-retrieve player-name player-avatar)
    (let ((zone (current-zone)))
      (let ((player-position (find-spawnpoint~ zone))
            (player-lookat (make-standard-lookat)))
        (let ((player (new Player parent: zone name: player-name avatar: player-avatar position: player-position lookat: player-lookat)))
          (set-billboard-name~ player player-name)
          (add-element~ zone player)
          (when (get-visible?~ (current-world-window))
            (add-simulation~ zone player))
          player))))
  
  
  (method (player-store player)
    (let ((zone (current-zone)))
      (when (get-visible?~ (current-world-window))
        (remove-simulation~ zone player))
      (remove-element~ zone player)))
  
  
  (method (client-update client changes)
    (increase-hits~ (get-process))
    ;; should probably be applied by a task
    (forward-changes changes)
    (outgoing-push-changes changes))
  
  
  (method (client-debug client arguments)
    (when (world-setting 'world.server.debug? #f)
      (apply debug 'client arguments)))
  
  
  (method (retrieve-region region-x region-z)
    (let ((zone (current-zone)))
      (debug-server 'retrieve-region region-x region-z)
      (boolean (get-region~ zone region-x region-z))))
  
  
  (method (retrieve-chunk region-x region-z chunk-x chunk-z chunk-digest)
    (let ((zone (current-zone)))
      (let ((region (get-region~ zone region-x region-z)))
        (when region
          (let ((chunk (get-chunk~ region chunk-x chunk-z create?: #t)))
            (when chunk
              (unless (equal? (get-digest~ chunk) chunk-digest)
                (let ((chunk-raw (get-raw~ chunk)))
                  (debug-server 'retrieve-chunk region-x region-z chunk-x chunk-z (u8vector-length chunk-raw))
                  chunk-raw))))))))
  
  
  (method (register-literal literal)
    (literal->id literal))
  
  
  (method (registered-id id)
    (id->literal id))
  
  
  (method (find-server-client target)
    (find-if (lambda (client)
               (proxy=? (get-client~ client) target))
             clients))
  
  
  (method (broadcast-server-update changes)
    (for-each (lambda (server-client)
                (let ((client (get-client~ server-client)))
                  (server-update~ client changes)))
              clients))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (debug-server . rest)
    (when (world-setting 'world.server.debug? #f)
      (apply debug 'server rest)))))
