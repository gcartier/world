;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.server.tier jazz


(import (jazz.associative)
        (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.io)
        (jazz.json)
        (jazz.logger)
        (jazz.markup)
        (jazz.network)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.zlib)
        (world)
        (world.audio)
        (world.assets)
        (world.autoload)
        (world.capabilities)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.history)
        (world.id)
        (world.io)
        (world.log)
        (world.network)
        (world.processor)
        (world.profiling)
        (world.server)
        (world.server.client)
        (world.server.group)
        (world.server.mobile)
        (world.server.presence)
        (world.server.problem)
        (world.server.serving)
        (world.server.udp)
        (world.settings)
        (world.stream)
        (world.streaming)
        (world.stub)
        (world.support)
        (world.task)
        (world.tier)
        (world.udp)
        (world.video))


(definition max-connections
  (world-setting 'world.server-max-connections #f))


(definition world-assets-mutex
  (make-mutex 'world-assets))


(definition (with-world-assets-mutex thunk)
  (mutex-lock! world-assets-mutex)
  (prog1 (thunk)
    (mutex-unlock! world-assets-mutex)))


(definition universe-asset-entries
  #f)


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                                       getter generate)
  (slot instances      initialize (make-table test: equal?) getter generate)
  (slot zones          initialize '()                       getter generate)
  (slot groups         initialize '()                       getter generate)
  (slot hits           initialize 0                         getter generate)
  (slot aliveness-task initialize #f                        getter generate)
  (slot udp-server     initialize #f                        getter generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (set! configuration (get-server-configuration))
    (prepare-assets self)
    (let ((id (make-unique-id)))
      ;; not sure about this, for now lets use the hardcoded server-no = 0
      (set-client-id/no id server-no @w (literal->id id self)))
    (reset-last-broadcast)
    (setup-instances self)
    (setup-zones self))
  
  
  (method override (prepare-assets self)
    (let ((assets-dir {Directory Universe "assets"}))
      (set! universe-assets (new Remote-Assets 'universe assets-dir)))
    (let ((assets-dir (new-directory directory "assets")))
      (set! world-assets (new Remote-Assets 'world assets-dir))))
  
  
  (method override (startup self)
    (nextmethod self)
    (start-aliveness-task self)
    (start-mobile-server (~ mobile-connect self))
    (start-udp-server self))
  
  
  (method override (enter self)
    (let ((me (current-me+)))
      (when me
        (set-name me (get-character-name configuration))
        (set-avatar me (get-character-avatar configuration)))))
  
  
  (method override (shutdown self)
    (stop-mobile-server)
    (stop-udp-server self)
    (stop-aliveness-task self)
    (detach-clients self))
  
  
  (method override (get-udp-tier self)
    udp-server)
  
  
  (method (calling-processor self processor thunk)
    (thunk))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state self)
    'started)
    
  
  (method override (start self)
    )
  
  
  (method override (stop self)
    )
  
  
  (method override (restart self)
    )
  
  
  (method override (wait-started self)
    )
  
  
  (method override (wait-stopped self)
    )
  
  
  (method override (server-name self)
    "World")
  
  
  (method override (server-title self)
    "World")
  
  
  (method override (server-version self)
    (process-version (current-process)))
  
  
  (method override (server-host self)
    (host->string (listening-host (get-remote-listener))))
  
  
  (method override (server-service self)
    (port->string (listening-port (get-remote-listener))))
  
  
  (method override (server-hits self)
    hits)
  
  
  (method override (server-debug? self)
    #f)
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (next-literal-id!))
  
  
  (method override (tier-id->literal self id)
    (error "Unregistered id: {s}" id))
  
  
  ;;;
  ;;;; Delegates
  ;;;
  
  
  (method (count-delegates self)
    (length delegates))
  
  
  (method package (collect-delegates self)
    (sort ci<? delegates key: get-name))
  
  
  (method package (collect-disconnected self)
    (collect-if get-disconnected? delegates))
  
  
  ;;;
  ;;;; Instances
  ;;;
  
  
  (method (find-instance self uuid)
    (table-ref instances uuid #f))


  (method (setup-instances self)
    (let ((instances-dir (instances-dir self)))
      (when (exists? instances-dir)
        (iterate-directory instances-dir
          (lambda (instance-dir)
            (let ((file (new-file instance-dir ".instance")))
              (when (exists? file)
                (let ((instance (instantiate (read-form file))))
                  (let ((uuid (get-name instance)))
                    (table-set! instances uuid instance))))))
          files?: #f
          directories?: #t
          recursive?: #f))))
  
  
  (method (instances-dir self)
    (new-directory directory "instances"))
  
  
  ;;;
  ;;;; Zones
  ;;;


  (method (setup-zones self)
    (let ((zones-dir (zones-dir self))
          (queue (new-queue)))
      (when (exists? zones-dir)
        (iterate-directory zones-dir
          (lambda (path kind)
            (let ((zone-dir (new-directory zones-dir path)))
              (let ((file (new-file zone-dir ".zone")))
                (when (exists? file)
                  (enqueue queue path)))))
          full?: #f
          files?: #f
          directories?: #t
          recursive?: #t))
      (set! zones (queue-list queue))))
  
  
  (method package (zones-dir self)
    (new-directory directory "zones"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (setup-me self)
    (setup-current-me self)
    (register-id (current-me) (make-unique-id)))
  
  
  (method override (save-me self)
    (save-current-me self))
  
  
  (method override (player-file self name)
    (new-file directory '("start" ".player")))
  
  
  (method override (anonymous self)
    "Server")
  
  
  ;;;
  ;;;; Groups
  ;;;
  
  
  (method (find-group self name/no)
    (if (integer? name/no)
        (find-if (lambda (group)
                   (= (get-no group) name/no))
                 groups)
      (find-if (lambda (group)
                 (equal? (get-name group) name/no))
               groups)))
  
  
  (method (create-group self delegate name persistent? audio-only? auto-create?)
    (logger/activity self "Create group{? {a}~} ({a})" name (get-name delegate))
    (let ((group (new Server-Group name persistent? audio-only? (if auto-create? 'start (get-zone delegate)))))
      (set! groups (cons group groups))
      group))
  
  
  (method (delete-group self delegate group)
    (logger/activity self "Delete group{? {a}~} ({a})" (get-name group) (if delegate (get-name delegate) "Server"))
    (set! groups (remove! group groups)))
  
  
  (method (maybe-delete-group self delegate group)
    (if (or (get-persistent? group)
            (has-members? self group)
            (has-streams? self group))
        #f
      (delete-group self delegate group)
      #t))
  
  
  (method (maybe-disband-group self delegate group)
    (let ((members (get-members group)))
      (when (= (length members) 1)
        (disband-group self delegate group)
        (broadcast-hierarchy-to self members))))
  
  
  (method (disband-group self delegate group)
    (logger/activity self "Disband group{? {a}~} ({a})" (get-name group) (get-name delegate))
    (for-each (lambda (delegate)
                (leave-group self delegate group)
                (if (is? delegate Mobile-Delegate)
                    (send-disband self delegate)
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (server-disband client))))))
              (get-members group))
    (set! groups (remove! group groups)))
  
  
  (method (has-members? self group)
    (not-null? (get-members group)))
  
  
  (method (has-streams? self group)
    (not-null? (get-streams group)))
  
  
  (method (join-group self delegate group)
    (let ((delegate-name (get-name delegate))
          (group-name (get-name group)))
      (logger/activity self "Join group{? {a}~} ({a})" group-name (get-name delegate))
      (set-group delegate group)
      (unless group-name
        (for-each (lambda (delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-join self delegate delegate-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-join client delegate-name))))))
                  (get-members group)))
      (set-members group (cons delegate (get-members group)))
      (wait-keyframes udp-server delegate (delegate->connection self delegate))
      (update-streaming udp-server group)))
  
  
  (method (leave-group self delegate group)
    (let ((delegate-name (get-name delegate))
          (group-name (get-name group)))
      (logger/activity self "Leave group{? {a}~} ({a})" group-name delegate-name)
      (unless (is? delegate Mobile-Delegate)
        (done-keyframes udp-server delegate (delegate->connection self delegate)))
      (set-group delegate #f)
      (set-members group (remove delegate (get-members group)))
      (update-streaming udp-server group)
      (unless group-name
        (for-each (lambda (delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-leave self delegate delegate-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-leave client delegate-name))))))
                  (get-members group)))
      (if (get-name group)
          (maybe-delete-group self delegate group)
        (maybe-disband-group self delegate group))))
  
  
  (method (delegate->connection self delegate)
    (no->connection udp-server (get-no delegate)))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method package (client-connect self client client-uuid personal-key character-avatar character-script character-zone)
    (let ((identity (retrieve-identity directory personal-key)))
      (if (not identity)
          "Invalid personal key"
        (let ((character-name (get-name identity))
              (character-role (or (get-role identity) default-role))
              (character-admin? (get-admin? identity)))
          (if (and max-connections (>= (count-delegates self) max-connections))
              (begin
                (logger/activity self "Max connections reached ({a})" character-name)
                (format "Max {a} connections reached" max-connections))
            (let ((existing-delegate (find-delegate-by-name self character-name)))
              (if (and existing-delegate (not (get-disconnected? existing-delegate)))
                  (begin
                    (logger/activity self "{a} is already connected" character-name)
                    (format "{a} is already connected" character-name))
                ;; register client
                (let ((reconnect-info (and existing-delegate
                                           (let ((group (get-group existing-delegate)))
                                             (list (get-mode existing-delegate)
                                                   (get-zone existing-delegate)
                                                   (and group
                                                        (or (get-name group)
                                                            (get-no group)))
                                                   (and group
                                                        (get-audio-only? group)))))))
                  (let ((delegate (cond (existing-delegate
                                          (reconnect-client self client existing-delegate client-uuid)
                                          existing-delegate)
                                        (else
                                         (let ((id (make-unique-id)))
                                           (new Client-Delegate client 'connected client-uuid id (literal->id id self) character-name character-avatar character-script character-role character-admin?))))))
                    (logger/activity self "{a} {a}" (if existing-delegate "Reconnect" "Connect") character-name)
                    (unless existing-delegate
                      (set! delegates (cons delegate delegates)))
                    ;; retrieve character
                    (let ((client-id (get-id delegate))
                          (client-no (get-no delegate))
                          (universe-asset-entries (cache-universe-asset-entries self))
                          (world-asset-entries (collect-world-asset-entries self))
                          (character (character-retrieve self character-name character-avatar))
                          (character-delegate delegate))
                      (set-character character-delegate character)
                      ;; join character zone
                      (let ((character-zone (if existing-delegate (get-zone existing-delegate) (or character-zone (get-zone character)))))
                        (let ((processor (spawn-processor (effective-host configuration) (effective-service configuration) world-asset-entries character-zone)))
                          (if (string? processor)
                              processor
                            (let ((remote-processor (get-remote-proxy processor)))
                              (let ((join-info (client-enter remote-processor client client-uuid client-id client-no character-name character-avatar character-script character-role character-admin?)))
                                (if (string? join-info)
                                    join-info
                                  (set-zone character-delegate character-zone)
                                  (set-processor character-delegate processor)
                                  (add-delegate processor character-delegate)
                                  (bind (form zone-asset-entries spawnpoint player-spawnpoint player-id player-no player-position player-lookat camera-position camera-lookat zone-daytime other-players) join-info
                                    (let ((welcome (format "Welcome to {a}!" tier-title)))
                                      (list client-id
                                            client-no
                                            character-name
                                            character-role
                                            character-admin?
                                            universe-asset-entries
                                            world-asset-entries
                                            zone-asset-entries
                                            (proxy-connection-info client remote-processor)
                                            welcome
                                            form
                                            spawnpoint
                                            player-spawnpoint
                                            player-id
                                            player-no
                                            player-position
                                            player-lookat
                                            camera-position
                                            camera-lookat
                                            zone-daytime
                                            other-players
                                            reconnect-info)))))))))))))))))))
  
  
  (method package (client-start self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-state delegate 'started)
        @peer2peer
        (broadcast-peers self)
        (broadcast-hierarchy self)
        (broadcast-entered self delegate))))
  
  
  (method package (client-stop self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (delegate-stop self delegate))))
  
  
  (method (delegate-stop self delegate)
    (let ((group (get-group delegate)))
      (when group
        (leave-group self delegate group)))
    (set-state delegate 'stopped))
  
  
  (method package (client-deconnect self client)
    ;; find server client
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (let ((name (get-name delegate)))
          (logger/activity self "Deconnect {a}" name)
          (delegate-deconnect self delegate)))))
  
  
  (method (delegate-deconnect self delegate)
    (let ((client (get-client delegate))
          (name (get-name delegate)))
      ;; deconnect udp
      (when udp-server
        (deconnect-source udp-server (get-no delegate)))
      ;; store character
      (character-store self (get-character delegate))
      ;; leave zone
      (client-exit (get-remote-proxy (get-processor delegate)) client name)
      (remove-delegate (get-processor delegate) delegate)
      ;; unregister delegate
      (set! delegates (remove! delegate delegates))
      ;; update state
      (set-state delegate 'deconnected)
      ;; closing remote
      (closing-remote-proxy client)
      ;; broadcast
      (broadcast-exited self delegate)
      @peer2peer
      (broadcast-peers self)
      (broadcast-hierarchy self)))
  
  
  (method package (client-reconnect self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (server-unregister-streams self (get-no delegate)))))
  
  
  (method package (client-observe self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          "Delegate not found"
        (set-mode delegate 'observer)
        (client-mode (get-remote-proxy (get-processor delegate)) client 'observer)
        (broadcast-hierarchy self)
        #f)))
  
  
  (method package (client-play self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          "Delegate not found"
        (if (not (processor-playable? (get-processor delegate)))
            (format "Max {a} played zone{a} reached" max-played (format-plural max-played))
          (set-mode delegate 'player)
          (client-mode (get-remote-proxy (get-processor delegate)) client 'player)
          (broadcast-hierarchy self)
          #f))))
  
  
  (method package (client-roam self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          "Delegate not found"
        (set-roaming? delegate #t)
        #f)))
  
  
  (method package (client-anchor self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          "Delegate not found"
        (set-roaming? delegate #f)
        #f)))
  
  
  (method package (client-sleep self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-asleep? delegate #t)
        (broadcast-hierarchy self))))
  
  
  (method package (client-wake self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-asleep? delegate #f)
        (broadcast-hierarchy self)
        ;; deliver queued messages
        (let ((queue (get-message-queue delegate)))
          (let ((messages (queue-list queue)))
            (when (not-null? messages)
              (reset-queue queue)
              (deliver-messages self delegate messages)))))))
                  
  
  
  @peer2peer
  (method (broadcast-peers self)
    (let ((peers '()))
      (iterate-table (get-no-connections udp-server)
        (lambda (origin connection)
          (let ((delegate (find-delegate-by-no self origin)))
            (when (and delegate (eq? (get-state delegate) 'started))
              (let ((host (get-host connection))
                    (port (get-port connection))
                    (local-host (get-local-host connection))
                    (local-port (get-local-port connection)))
                (set! peers (cons (list origin host port local-host local-port) peers)))))))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (unless (is? delegate Mobile-Delegate)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (peers-update client peers)))))))
                delegates)))
  
  
  (method (broadcast-hierarchy self)
    (broadcast-hierarchy-to self delegates))
  
  
  (method (broadcast-hierarchy-to self delegates)
    (let ((hierarchy (collect-hierarchy self))
          ;; quick hack
          (mobile-hierarchy (collect-hierarchy self #t)))
      (for-each (lambda (delegate)
                  (if (is? delegate Mobile-Delegate)
                      (send-people self delegate mobile-hierarchy)
                    (when (eq? (get-state delegate) 'started)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (hierarchy-update client hierarchy)))))))
                delegates)))
  
  
  (method (broadcast-entered self client-delegate)
    (let ((client-id (get-id client-delegate))
          (client-no (get-no client-delegate))
          (client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-entered self delegate client-no client-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-entered client client-id client-no client-name)))))))
                delegates)))
  
  
  (method (broadcast-exited self client-delegate)
    (let ((client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-exited self delegate client-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-exited client client-name)))))))
                delegates)))
  
  
  (method (character-retrieve self character-name character-avatar)
    (let ((file (new-file (characters-dir self) (format "{a}.character" character-name))))
      (let ((character
              (if (exists? file)
                  (let ((character (instantiate (read-form file))))
                    (set-name character character-name)
                    (set-avatar character character-avatar)
                    character)
                (let ((units '(world.character)))
                  (let ((tag '(<Character>))
                        (data (new Data zone-version 'jazz units #f)))
                    (let ((form (construct-form tag (imports-locator units) data)))
                      (set-origin form file)
                      (let ((character (instantiate form)))
                        (set-name character character-name)
                        (set-avatar character character-avatar)
                        (set-zone character 'start)
                        character)))))))
        character)))
  
  
  (method (character-store self character)
    (let ((file (new-file (characters-dir self) (format "{a}.character" (get-name character)))))
      (create-directories file)
      (let ((designer (new Former form: (get-form character) reference: character)))
        (define (save-character)
          (set-property designer character 'zone (get-zone character)))
        
        (save-character)
        (save designer))))
  
  
  (method (characters-dir self)
    (new-directory directory "characters"))
  
  
  (method package (client-alive self client)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (when delegate
        (set-alive delegate (current-seconds)))))
  
  
  (method package (client-invite self client recipient)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-invite self delegate recipient))))
  
  
  (method (delegate-invite self delegate recipient)
    (let ((recipient-delegate (find-delegate-by-ci-name self recipient)))
      (if (not recipient-delegate)
          (format "Unable to find {a}" recipient)
        (if (eq? delegate recipient-delegate)
            (format "Cannot invite yourself")
          (if (get-group recipient-delegate)
              (format "{a} is already in a group" recipient)
            (if (memq? delegate (get-invites recipient-delegate))
                #f
              (let ((client (get-client recipient-delegate))
                    (sender (get-name delegate)))
                (if (is? recipient-delegate Mobile-Delegate)
                    (send-invite self recipient-delegate sender)
                  (calling-client self recipient-delegate
                    (lambda ()
                      (server-invite client sender)))))
              (add-invite recipient-delegate delegate)
              #f))))))
  
  
  (method package (client-accept self client sender)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-accept self delegate sender))))
  
  
  (method (delegate-accept self delegate sender)
    (if (get-group delegate)
        (format "You are already in a group")
      (let ((sender-delegate (find-delegate-by-ci-name self sender)))
        (if (not sender-delegate)
            (format "Unable to find {a}" sender)
          (let ((sender-group (get-group sender-delegate)))
            (let ((group (if sender-group
                             (begin
                               (join-group self delegate sender-group)
                               sender-group)
                           (let ((group (create-group self sender-delegate #f #f #t #f)))
                             (join-group self sender-delegate group)
                             (join-group self delegate group)
                             group))))
              (let ((sender-client (get-client sender-delegate))
                    (recipient (get-name delegate)))
                (if (is? sender-delegate Mobile-Delegate)
                    (send-accept self sender-delegate recipient)
                  (calling-client self sender-delegate
                    (lambda ()
                      (server-accept sender-client recipient)))))
              (remove-invite delegate sender-delegate)
              (broadcast-hierarchy-to self (get-members group))
              (if (is? delegate Mobile-Delegate)
                  (get-no group)
                (cons (get-no group) (cons (get-audio-only? group) (group-streams self group))))))))))
  
  
  (method package (client-decline self client sender)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-decline self delegate sender))))
  
  
  (method (delegate-decline self delegate sender)
    (let ((sender-delegate (find-delegate-by-ci-name self sender)))
      (if (not sender-delegate)
          (format "Unable to find {a}" sender)
        (let ((sender-client (get-client sender-delegate))
              (recipient (get-name delegate)))
          (if (is? sender-delegate Mobile-Delegate)
              (send-decline self sender-delegate recipient)
            (calling-client self sender-delegate
              (lambda ()
                (server-decline sender-client recipient)))))
        (remove-invite delegate sender-delegate)
        #f)))
  
  
  (method package (client-leave self client)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (and delegate
           (delegate-leave self delegate))))
  
  
  (method (delegate-leave self delegate)
    (let ((group (get-group delegate)))
      (if (not group)
          (format "You are not in a group")
        (let ((members (get-members group)))
          (leave-group self delegate group)
          (broadcast-hierarchy-to self members)
          #f))))
  
  
  (method package (client-message self client kind recipient message)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (and delegate
           (delegate-message self delegate kind recipient message))))
  
  
  (method package (client-log self client time message)
    (server-log client time message))
  
  
  (method package (processor-log self processor time message)
    (server-log processor time message))
  
  
  (method package (client-connected-player self client no)
    (connected-player self no))
  
  
  (method override (connected-player self no)
    (if (= no client-no)
        "Server"
      (let ((delegate (find-delegate-by-no self no)))
        (and delegate
             (get-name delegate)))))
  
  
  (method package (client-connected-players self client)
    (connected-players self))
  
  
  (method package (client-available-templates self client)
    (available-templates self))
  
  
  (method package (client-available-zone-base self client from)
    (available-zone-base self from))
  
  
  (method package (client-available-zone-base? self client base)
    (available-zone-base? self base))
  
  
  (method package (client-create-zone self client from base)
    (and (create-zone self from base)
         (list 'zone base)))
  
  
  (method package (client-available-zones self client)
    (available-zones self))
  
  
  (method package (client-load-zone self client zone)
    (let ((delegate (with-task-mutex
                      (lambda ()
                        (find-delegate self client)))))
      ;; aec robust
      (when delegate
        (let ((spawn-result #f))
          (let ((spawn-thread (current-thread)))
            (delay-event
              (lambda ()
                (thread-join! spawn-thread)
                (let ((error-string (if (string? spawn-result) spawn-result #f)))
                  (with-task-mutex
                    (lambda ()
                      (calling-client self delegate
                        (lambda ()
                          (zone-loaded client zone error-string)))))))))
          (set! spawn-result (spawn-processor (effective-host configuration) (effective-service configuration) (collect-world-asset-entries self) zone delegate))))))
  
  
  (method package (client-change-zone self client zone)
    (change-client-zone self client zone))
  
  
  (method package (client-changed-zone self client)
    (changed-client-zone self client))
  
  
  (method package (client-create-group self client name persistent? audio-only? broadcast-hierarchy? auto-create?)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (if (and (not auto-create?) (get-group delegate))
            (format "You are already in a group")
          (let ((existing-group (and name (find-group self name))))
            (if existing-group
                (format "{a}{? {a}~} already exists" (group-domain-name self name) name)
              (let ((group (create-group self delegate name persistent? audio-only? auto-create?)))
                (when broadcast-hierarchy?
                  (broadcast-hierarchy self))
                (get-no group))))))))
  
  
  (method package (client-delete-group self client name/no)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name/no))
              (group-name (and (string? name/no) name/no)))
          (if (not group)
              (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
            (if (has-members? self group)
                (format "{a}{? {a}~} still has members" (group-domain-name self name/no) group-name)
              (if (has-streams? self group)
                  (format "{a}{? {a}~} still has streams" (group-domain-name self name/no) group-name)
                (when (maybe-delete-group self delegate name/no)
                  (broadcast-hierarchy self))
                #f)))))))
  
  
  (method package (client-join-group self client name/no mode)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (if (get-group delegate)
            (format "You are already in a group")
          (let ((group (find-group self name/no))
                (group-name (and (string? name/no) name/no)))
            (if (not group)
                (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
              (when mode
                (set-mode delegate mode))
              (join-group self delegate group)
              (broadcast-hierarchy self)
              (cons (get-no group) (cons (get-audio-only? group) (group-streams self group)))))))))
  
  
  (method package (client-rejoin-group self client name/no)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name/no))
              (group-name (and (string? name/no) name/no)))
          (if (not group)
              (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
            (cons (get-no group) (cons (get-audio-only? group) (group-streams self group))))))))
  
  
  (method package (client-leave-group self client name/no mode)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name/no))
              (group-name (and (string? name/no) name/no)))
          (if (not group)
              (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
            (when mode
              (set-mode delegate mode))
            (leave-group self delegate group)
            (broadcast-hierarchy self)
            #f)))))
  
  
  (method package (client-change-video-level self client video-level)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((origin (get-no delegate))
              (connection (delegate->connection self delegate)))
          (set-video-level connection video-level)
          (iterate-table (get-server-streams udp-server)
            (lambda (no stream)
              (when (and (get-video-level stream)
                         (= (get-origin stream) origin))
                (set-video-level stream video-level))))
          (let ((group (get-group delegate)))
            (when group
              (update-streaming udp-server group)
              (for-each (lambda (member)
                          (unless (eq? member delegate)
                            (unless (is? member Mobile-Delegate)
                              (let ((client (get-client member)))
                                (calling-client self member
                                  (lambda ()
                                    (streamer-update client origin video-level)))))))
                        (get-members group))))
          #f))))
  
  
  (method package (client-register-stream self client sender name source-kind video-level channels recipient)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          (format "Delegate not found")
        (let ((group (get-group client-delegate)))
          (define (normalize-recipient)
            (if (not recipient)
                group
              (map (lambda (no)
                     (find-delegate-by-no self no))
                   recipient)))
          
          (if (and (not recipient)
                   (not group))
              (format "You are not in a group")
            (let ((origin (get-no client-delegate))
                  (recipient (normalize-recipient))
                  (exclude-register client-delegate)
                  (exclude-broadcast client-delegate))
              (bind (stream . server-channels) (server-register-stream self sender name origin source-kind video-level channels recipient exclude-register exclude-broadcast #f)
                (cons (get-no stream) (map get-no server-channels)))))))))
  
  
  (method package (server-register-stream self sender name origin source-kind video-level channels recipient exclude-register exclude-broadcast server-sender?)
    (let ((no (next-stream-no!)))
      (let ((stream (register-server-stream udp-server sender name no origin source-kind video-level recipient exclude-register exclude-broadcast)))
        (let ((server-channels (map (lambda (channel)
                                      (bind (media-kind source-kind level resolution framerate bitrate codec caps metadata) channel
                                        (server-add-channel self no media-kind source-kind level resolution framerate bitrate codec caps metadata server-sender?)))
                                    channels))
              (recipients (stream-recipients self stream))
              (group-no (stream-group-no self stream))
              (group-audio-only? (stream-group-audio-only? self stream)))
          (let ((extended-channels (map (lambda (descriptor server-channel)
                                          (cons (get-no server-channel) descriptor))
                                        channels
                                        server-channels)))
            (for-each (lambda (delegate)
                        (unless (eq? delegate exclude-register)
                          (when (eq? (get-state delegate) 'started)
                            (unless (is? delegate Mobile-Delegate)
                              (let ((client (get-client delegate)))
                                (calling-client self delegate
                                  (lambda ()
                                    (stream-add client group-no group-audio-only? sender name no origin source-kind video-level extended-channels))))))))
                      recipients)
            (cons stream server-channels))))))
  
  
  (method package (client-unregister-stream self client stream-no)
    (server-unregister-stream self stream-no))
  
  
  (method package (server-unregister/disconnect-streams self client-no)
    (iterate-table (get-server-streams udp-server)
      (lambda (no stream)
        (when (= (get-origin stream) client-no)
          (if (eq? (get-source-kind stream) 'live)
              (server-disconnect-stream self no)
            (server-unregister-stream self no))))))
  
  
  (method package (server-unregister-streams self client-no)
    (iterate-table (get-server-streams udp-server)
      (lambda (no stream)
        (when (= (get-origin stream) client-no)
          (server-unregister-stream self no)))))
  
  
  (method package (server-unregister-stream self stream-no)
    (let ((stream (find-server-stream udp-server stream-no)))
      ;; together robust
      (when stream
        (let ((recipients (stream-recipients self stream))
              (exclude-register (get-exclude-register stream)))
          (for-each (lambda (delegate)
                      (unless (eq? delegate exclude-register)
                        (when (eq? (get-state delegate) 'started)
                          (unless (is? delegate Mobile-Delegate)
                            (let ((client (get-client delegate)))
                              (calling-client self delegate
                                (lambda ()
                                  (stream-remove client stream-no))))))))
                    recipients)
          (close-server-stream udp-server stream)))))
  
  
  (method package (server-disconnect-stream self stream-no)
    (let ((stream (find-server-stream udp-server stream-no)))
      ;; together robust
      (when stream
        (let ((recipients (stream-recipients self stream))
              (exclude-register (get-exclude-register stream)))
          (for-each (lambda (delegate)
                      (unless (eq? delegate exclude-register)
                        (when (eq? (get-state delegate) 'started)
                          (unless (is? delegate Mobile-Delegate)
                            (let ((client (get-client delegate)))
                              (calling-client self delegate
                                (lambda ()
                                  (stream-disconnect client stream-no))))))))
                    recipients)))))
  
  
  (method package (client-stream-action self client stream-no action arguments)
    (let ((send-stream (find-send-stream udp-server stream-no)))
      (if send-stream
          (let ((action-proc (get-action-proc send-stream)))
            (when action-proc
              (action-proc send-stream action arguments)))
        (let ((stream (find-server-stream udp-server stream-no)))
          ;; together robust
          (when stream
            (let ((origin (get-origin stream)))
              (let ((delegate (find-delegate-by-no self origin)))
                (when (and delegate (is-not? delegate Mobile-Delegate))
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (action-stream client stream-no action arguments))))))))))))
  
  
  (method package (server-add-channel self stream-no media-kind source-kind level resolution framerate bitrate codec caps metadata server-sender?)
    (let ((no (next-channel-no!)))
      (register-server-channel udp-server stream-no no media-kind source-kind level resolution framerate bitrate codec caps metadata server-sender?)))
  
  
  (method package (client-channel-action self client channel-no action arguments)
    (let ((channel (find-server-channel udp-server channel-no)))
      ;; together robust
      (when channel
        (let ((origin (get-origin (get-stream channel))))
          (let ((delegate (find-delegate-by-no self origin)))
            (when (and delegate (is-not? delegate Mobile-Delegate))
              (let ((client (get-client delegate)))
                (calling-client self delegate
                  (lambda ()
                    (action-channel client channel-no action arguments))))))))))
  
  
  (method (stream-recipients self stream)
    (let ((recipient (get-recipient stream)))
      (if (is? recipient Server-Group)
          (get-members recipient)
        recipient)))
  
  
  (method (stream-group-no self stream)
    (let ((recipient (get-recipient stream)))
      (if (is? recipient Server-Group)
          (get-no recipient)
        #f)))
  
  
  (method (stream-group-audio-only? self stream)
    (let ((recipient (get-recipient stream)))
      (if (is? recipient Server-Group)
          (get-audio-only? recipient)
        #f)))
  
  
  (method (group-streams self group)
    (let ((origins (map get-no (get-members group)))
          (streams (new-queue)))
      (iterate-table (get-server-streams udp-server)
        (lambda (no stream)
          (define (collect-channels)
            (let ((channels (new-queue)))
              (iterate-table (get-channels stream)
                (lambda (no channel)
                  (let ((media-kind (get-media-kind channel))
                        (source-kind (get-source-kind channel))
                        (level (get-level channel))
                        (resolution (get-resolution channel))
                        (framerate (get-framerate channel))
                        (bitrate (get-bitrate channel))
                        (codec (get-codec channel))
                        (caps (get-caps channel))
                        (metadata (get-metadata channel)))
                    (enqueue channels (list no media-kind source-kind level resolution framerate bitrate codec caps metadata)))))
              (queue-list channels)))
          
          (let ((origin (get-origin stream)))
            (when (or (memv? origin origins)
                      (= origin server-no))
              (let ((recipient (get-recipient stream)))
                (when (eq? recipient group)
                  (let ((sender (get-sender stream))
                        (name (get-name stream))
                        (source-kind (get-source-kind stream))
                        (video-level (get-video-level stream))
                        (channels (collect-channels)))
                    (enqueue streams (list sender name no origin source-kind video-level channels)))))))))
      (queue-list streams)))
  
  
  (method package (client-list-group-members self name/no)
    (let ((group (find-group self name/no))
          (group-name (and (string? name/no) name/no)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
        (map get-name (get-members group)))))
  
  
  (method package (client-list-hierarchy self)
    (collect-hierarchy self))
  
  
  (method (collect-hierarchy self (mobile? #f))
    (define (member-info delegate)
      (list (get-name delegate)
            (and (not mobile?) (get-id delegate))
            (get-no delegate)
            (get-asleep? delegate)
            (get-disconnected? delegate)
            (get-roaming? delegate)
            (get-zone delegate)
            (get-mode delegate)))
    
    (cons (cons #f
                (cons #f
                      (cons #f
                            (map member-info (collect-if (lambda (delegate)
                                                           (and (eq? (get-state delegate) 'started)
                                                                (not (get-group delegate))))
                                                         delegates)))))
          (map (lambda (group)
                 (cons (or (get-name group)
                           (get-no group))
                       (cons (get-audio-only? group)
                             (cons (get-zone group)
                                   (map member-info (get-members group))))))
               groups)))
  
  
  (method (group-domain-name self name)
    (if (or (not name)
            (integer? name))
        (registered-domain-name 'group "Group")
      (registered-domain-name 'circle "Circle")))
  
  
  (method override (connected-players self)
    (map (lambda (delegate)
           (let ((zone (get-zone delegate)))
             (list (get-name delegate) zone (present-zone self zone))))
         delegates))
  
  
  (method override (available-templates self)
    (collect-templates))
  
  
  (method override (available-zone-base self from)
    (unique-zone-base from))
  
  
  (method override (available-zone-base? self base)
    (zone-base-available? base))
  
  
  (method override (create-zone self from base)
    (prog1 (create-new-zone from base
             create: (lambda (dir)
                       (create (new-directory dir "players")))
             open: (lambda (file)
                     #f))
      (setup-zones self)))
  
  
  (method override (available-zones self)
    (let ((queue (new-queue)))
      (iterate-table instances
        (lambda (uuid instance)
          (enqueue queue (cons (list 'instance uuid)
                               (format "{a}{? <{a}>~}" (join (get-template instance) "/") (+ (get-rank instance) 1))))))
      (for-each (lambda (path)
                  (enqueue queue (cons (cons 'zone path)
                                       (last path))))
                zones)
      (queue-list queue)))
  
  
  (method (change-client-zone self client zone)
    (let ((delegate (find-delegate self client)))
      (let ((client-uuid (get-uuid delegate))
            (client-id (get-id delegate))
            (client-no (get-no delegate))
            (character-name (get-name delegate))
            (character-avatar (get-avatar delegate))
            (character-script (get-script delegate))
            (character-role (get-role delegate))
            (character-admin? (get-admin? delegate)))
        ;; spawn
        (let ((processor (spawn-processor (effective-host configuration) (effective-service configuration) (collect-world-asset-entries self) zone delegate)))
          (if (string? processor)
              processor
            ;; leave
            (client-exit (get-remote-proxy (get-processor delegate)) client character-name)
            (remove-delegate (get-processor delegate) delegate)
            ;; join
            (let ((remote-processor (get-remote-proxy processor)))
              (let ((join-info (client-enter remote-processor client client-uuid client-id client-no character-name character-avatar character-script character-role character-admin?)))
                (set-zone delegate zone)
                (set-processor delegate processor)
                (add-delegate processor delegate)
                (broadcast-hierarchy self)
                (cons (proxy-connection-info client remote-processor) join-info))))))))
  
  
  (method (changed-client-zone self client)
    (cleanup-processors))
  
  
  (method (present-zone self zone)
    (if (eq? zone 'start)
        "<Start Zone>"
      (case (car zone)
        ((instance)
         (let ((instance (find-instance self (cadr zone))))
           (format "{a}{? <{a}>~}" (get-name (get-template instance)) (+ (get-rank instance) 1))))
        (else
         (last zone)))))
    
  
  (method (cache-universe-asset-entries self)
    (or universe-asset-entries
        (let ((entries (zlib-deflate (object->u8vector (get-entries (get-index (get-repository universe-assets)))))))
          (set! universe-asset-entries entries)
          entries)))

  
  (method (collect-world-asset-entries self)
    (with-world-assets-mutex
      (lambda ()
        (get-entries (get-index (get-repository world-assets))))))
  
  
  (method package (retrieve-universe-asset self path)
    (let ((repository (get-repository universe-assets)))
      (let ((entry (find-entry repository path)))
        (and entry
             (bind (path digest seconds) entry
               (list (retrieve-object repository digest) digest))))))
  
  
  (method package (retrieve-world-asset self path)
    (with-world-assets-mutex
      (lambda ()
        (let ((repository (get-repository world-assets)))
          (let ((entry (find-entry repository path)))
            (and entry
                 (bind (path digest seconds) entry
                   (list (retrieve-object repository digest) digest))))))))
  
  
  (method package (upload-world-asset self content digest)
    (with-world-assets-mutex
      (lambda ()
        (let ((repository (get-repository world-assets)))
          (store-object repository content digest)))))
  
  
  (method package (update-world-assets self client changes)
    (with-world-assets-mutex
      (lambda ()
        (let ((repository (get-repository world-assets)))
          (let ((delegate (find-delegate self client)))
            (apply-changes repository changes)
            (broadcast-assets self delegate changes))))))
  
  
  (method (broadcast-assets self client-delegate changes)
    (iterate-processors
      (lambda (zone processor)
        (let ((remote-processor (get-remote-proxy processor)))
          (calling-processor self processor
            (lambda ()
              (world-assets-update remote-processor changes))))))
    (for-each (lambda (delegate)
                (when (eq? (get-state delegate) 'started)
                  (unless (eq? delegate client-delegate)
                    (unless (is? delegate Mobile-Delegate)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (world-assets-update client changes))))))))
              delegates))
  
  
  (method package (register-literal self literal)
    (literal->id literal))
  
  
  (method package (registered-id self id)
    (id->literal id))
  
  
  (method (find-delegate-by-id self id)
    (find-if (lambda (delegate)
               (equal? (get-id delegate) id))
             delegates))
  
  
  (method (find-delegate-by-no self no)
    (find-if (lambda (delegate)
               (= (get-no delegate) no))
             delegates))
  
  
  (method package (tile-server self)
    (tile self))
  
  
  (method package (restore-server self)
    (restore self))
  
  
  (method package (profile-start self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (profile-start connection)))))
  
  
  (method package (profile-test self client test arguments)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (profile-test connection test arguments)))))
  
  
  (method package (profile-retrieve self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (profile-retrieve connection)))))
  
  
  (method package (profile-stop self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (profile-stop connection)))))
  
  
  (method package (admin-metadata self (requester-group #f))
    (define (send-streams)
      (streams-metadata (get-send-streams udp-server)))
    
    (define (server-streams)
      (streams-metadata (get-server-streams udp-server)))
    
    (define (start-time)
      (and requester-group (get-start-time requester-group)))
    
    (list server-no "_server" (send-streams) (server-streams) (sites-metadata) (start-time)))
  
  
  (method package (admin-command self client command arguments)
    (case command
      ((date)
       (date->string (system-date) "~Y-~m-~d_~H-~M-~S"))
      ((version)
       (let ((version (process-version (current-process))))
         (format "v{a}{a}" (present version) environment-suffix)))
      ((who)
       (map get-name delegates))
      ((crashes)
       (let ((dir {Directory Settings "work" "crashes"}))
         (if (equal? arguments '(clear))
             (begin
               (empty dir)
               (unspecified))
           (let ((queue (new-queue)))
             (iterate-directory dir
               (lambda (file)
                 (when (extension=? (get-extension file) "snapshot")
                   (enqueue queue (get-name file)))))
             (queue-list queue)))))
      ((crash)
       (let ((file (new-file {Directory Settings "work" "crashes"} (car arguments))))
         (and (exists? file)
              (call-with-input-file (path-settings file)
                (lambda (port)
                  (let ((queue (new-queue)))
                    (loop (repeat 10)
                          (let ((line (read-line port)))
                            (unless (eof-object? line)
                              (enqueue queue line))))
                    (queue-list queue)))))))
      ((logs)
       (let ((dir {Directory Settings "work" "logs"}))
         (if (equal? arguments '(clear))
             (let ((active-log (logger-file)))
               (iterate-directory dir
                 (lambda (path)
                   (unless (pathname=? path active-log)
                     (delete path)))
                 files?: #t
                 directories?: #f
                 recursive?: #f)
               (unspecified))
           (let ((queue (new-queue)))
             (iterate-directory dir
               (lambda (file)
                 (when (extension=? (get-extension file) "log")
                   (enqueue queue (get-name file)))))
             (queue-list queue)))))
      ((log)
       (let ((file (if (null? arguments)
                       (logger-file)
                     (new-file {Directory Settings "work" "logs"} (car arguments)))))
         (and (exists? file)
              (load-lines file))))
      ((threads)
       (map ->string (top-threads)))
      ((disconnected)
       (map (lambda (delegate)
              (list (get-name delegate)
                    (exception-reason (get-exception delegate))
                    (get-exception-stack delegate)))
            (collect-disconnected self)))
      ((metadata)
       (admin-metadata self))
      ((latency)
       (bind (who . rest) arguments
         (let ((delegate (find-delegate self client)))
           (let ((connection (no->connection udp-server (get-no delegate))))
             (let ((simulator (require-simulator udp-server connection))
                   (latency (if (null? rest) #f (car rest))))
               (setup-latency simulator latency)
               #f)))))
      ((drop)
       (bind (who . rest) arguments
         (let ((delegate (find-delegate self client)))
           (let ((connection (no->connection udp-server (get-no delegate))))
             (let ((simulator (require-simulator udp-server connection))
                   (drop (if (null? rest) #f (car rest))))
               (setup-drop simulator drop)
               #f)))))
      ((test)
       (let ((no (and (not-null? arguments) (car arguments))))
         (logger "Test server{? {a}~}" no)
         (cond ((not no)
                (exit-no-jobs))
               (else
                #f))))
      ((attach)
       (logger "Attach server")
       (let ((debugger (car arguments)))
         (delay-event
           (lambda ()
             (setup-debuggee debugger: debugger)
             (start-repl-thread (current-thread) #f (current-console-port))
             (select-debugger-console)
             (current-input-port (console-input-port))
             (current-output-port (console-output-port))
             (ready-to-controller)
             (iterate-processors
               (lambda (zone processor)
                 (let ((remote-processor (get-remote-proxy processor)))
                   (calling-processor self processor
                     (lambda ()
                       (attach remote-processor debugger)))))))))
       (unspecified))
      ((detach)
       (logger "Detach server")
       (current-input-port (standard-input-port))
       (current-output-port (standard-output-port))
       (detach-from-controller)
       (iterate-processors
         (lambda (zone processor)
           (let ((remote-processor (get-remote-proxy processor)))
             (calling-processor self processor
               (lambda ()
                 (detach remote-processor))))))
       (unspecified))
      ((stop)
       (logger "Stop server")
       (stop-server self)
       (unspecified))
      ((restart)
       (logger "Restart server")
       (let ((delay (if (null? arguments) 1 (car arguments))))
         (restart-server self delay))
       (unspecified))
      ((reset)
       (let ((what (if (null? arguments) #f (car arguments))))
         (case what
           ((evolution)
            (reset-evolution)
            #t)
           (else
            #f))))
      ((stream)
       (bind-optionals ((action #f) (what #f) (count #f) (spacing #f)) arguments
         (case action
           ((list)
            (stream-list self client))
           ((play)
            (if (not what)
                "Missing location"
              (or (stream-invalid self client what)
                  (begin
                    (if (not count)
                        (stream-play self client what)
                      (delay-event
                        (lambda ()
                          (loop (for n from 0 below count)
                                (when (and spacing (/= n 0))
                                  (sleep spacing))
                                (stream-play self client what #f)))))
                    #f))))
           ((compare)
            (delay-event
              (lambda ()
                (loop (for location in (cdr arguments))
                      (stream-play self client location #f))))
            #f)
           ((stop)
            (stream-stop self client what))
           ((done)
            (let ((broadcast-hierarchy? #f))
              (iterate-table (get-send-streams udp-server)
                (lambda (no stream)
                  (when (server-close-send-stream self stream)
                    (set! broadcast-hierarchy? #t))))
              (when broadcast-hierarchy?
                (broadcast-hierarchy self)))
            #f))))
      (else
       (let ((requester client))
         (define (dispatch-who who dispatch-server dispatch-client)
           (cond ((equal? who "server")
                  (dispatch-server)
                  #f)
                 ((equal? who "all")
                  (let ((requester-delegate (find-delegate self requester)))
                    (let ((requester-group (and requester-delegate (get-group requester-delegate))))
                      (if (not requester-group)
                          "You are not in a circle"
                        (dispatch-server requester-group)
                        (for-each dispatch-client (get-members requester-group))
                        #f))))
                 (else
                  (let ((delegate (find-delegate-by-ci-name self who)))
                    (if (not delegate)
                        (format "Unable to find {a}" who)
                      (dispatch-client delegate)
                      #f)))))
         
         (case command
           ((request)
            (bind (cookie who what action) arguments
              (define (request-server (requester-group #f))
                (admin-server-request self requester requester-group cookie what action))
              
              (define (request-client delegate)
                (let ((client (get-client delegate)))
                  (calling-client self delegate
                    (lambda ()
                      (admin-request client requester cookie what action)))))
              
              (dispatch-who who request-server request-client)))
           ;((run)
           ; (bind (cookie script who) arguments
           ;   (define (run-server (requester-group #f))
           ;     (admin-server-run self requester cookie script))
           ;   
           ;   (define (run-client delegate)
           ;     (let ((client (get-client delegate)))
           ;       (calling-client self delegate
           ;         (lambda ()
           ;           (admin-run client requester cookie script)))))
           ;   
           ;   (dispatch-who who run-server run-client)))
           (else
            (format "Unknown command: {s}" command)))))))
  
  
  (method (admin-server-request self requester requester-group cookie what action)
    (define (send-caps)
      (let ((file {File Settings "work" "caps" "server.caps"}))
        (when (exists? file)
          (send-file 0 file))))
    
    (define (send-info)
      (send-threaded 0
        (lambda ()
          (let ((server (current-server)))
            ;; gc before process-memory
            (let ((garbage-collect (estimate-garbage-collect)))
              (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
                (object->u8vector
                  (list
                    (server-host server)
                    (server-service server)
                    (map get-name (collect-delegates (current-server)))
                    (map get-zone (list-processors))
                    (map get-purpose (table-values presences))
                    (collect-hierarchy (current-server))
                    garbage-collect
                    (estimate-cpu%)
                    (length (top-threads))
                    last-gc-live
                    last-gc-movable
                    last-gc-nonmovable
                    (let ((port (get-udp-port udp-server)))
                      (list (udp-socket-receive-buffer-size port)
                            (udp-socket-send-buffer-size port)
                            (udp-socket-send-again-count port)))
                    outgoing-max))))))))
    
    (define (send-replay)
      (send-threaded 0
        (lambda ()
          (let ((metadata (admin-metadata self requester-group))
                (chronology (copy-chronology (current-chronology)))
                (evolution (copy-evolution (current-evolution))))
            (object->u8vector (list metadata chronology evolution) serialize)))
        (lambda ()
          (gather-replay-missing udp-server action))))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Documents "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file name)
      (let ((dir {Directory Documents "shared"}))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-settings)
      (let ((file support-settings-file))
        (when (exists? file)
          (send-file 0 file))))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (send-threaded name extract (missing #f))
      (let ((thread
              (new-thread
                (lambda ()
                  (let ((sender "_server"))
                    (admin-chunk requester cookie sender name #f #f)
                    (let ((content (zlib-deflate (extract)))
                          (give-time .01))
                      (when missing
                        (let ((missing (missing)))
                          (for-each (lambda (missing)
                                      (sleep give-time)
                                      (admin-request-chunk self requester cookie sender 'missing missing #f))
                                    missing)))
                      (let ((content-size (u8vector-length content))
                            (max-size 8192))
                        (let (loop-chunk (part 0) (pos 0))
                          (let ((remain (- content-size pos)))
                            (when (> remain 0)
                              (sleep give-time)
                              (let ((chunk-size (min remain max-size)))
                                (let ((chunk (make-u8vector chunk-size))
                                      (done? (>= chunk-size remain)))
                                  (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                                  (admin-request-chunk self requester cookie sender name chunk done?))
                                (loop-chunk (+ part 1) (+ pos chunk-size))))))))))
                'request)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)))
    
    (if (string? what)
        (send-shared-file what)
      (case what
        ((caps)
         (send-caps))
        ((info)
         (send-info))
        ((replay)
         (send-replay))
        ((shared)
         (send-shared))
        ((settings)
         (send-settings)))))
  
  
  ;(method (admin-server-run self requester cookie script)
  ;  (run-remote-script script
  ;    (lambda (state data)
  ;      (let ((sender "_server"))
  ;        (admin-run-return self requester cookie sender state data)))))
  
  
  (method (admin-request-chunk self requester cookie sender name chunk done?)
    (let ((delegate (find-delegate self requester)))
      (when delegate
        (calling-client self delegate
          (lambda ()
            (admin-chunk requester cookie sender name chunk done?))))))
  
  
  ;(method (admin-run-return self requester cookie sender state data)
  ;  (let ((delegate (find-delegate self requester)))
  ;    (when delegate
  ;      (calling-client self delegate
  ;        (lambda ()
  ;          (admin-return requester cookie sender state data))))))
  
  
  (method (stop-server self)
    (let ((process (current-process)))
      (delay-event
        (lambda ()
          (quit-process process)))))
  
  
  (method (restart-server self delay)
    (let ((process (current-process)))
      (delay-event
        (lambda ()
          (count-down delay
            (lambda (suffix)
              (broadcast-server-message self
                (if (= delay 1)
                    "Restart"
                  (format "Restart in {a}" suffix))))
            (lambda ()
              (quit-process process)))))))
  
  
  (method (broadcast-server-message self message)
    (let ((sender "Server")
          (kind 'server))
      (for-each (lambda (delegate)
                  (deliver-message self delegate sender kind message))
                delegates)))
  
  
  (method (broadcast-activity-message self message)
    (let ((sender "Server")
          (kind 'activity))
      (for-each (lambda (delegate)
                  (when (get-admin? delegate)
                    (deliver-message self delegate sender kind message)))
                delegates)))
  
  
  ;;;
  ;;;; Aliveness
  ;;;
  
  
  (method (start-aliveness-task self)
    (set! aliveness-task (new Task 'aliveness (lambda (task)
                                                (aliveness-loop self task))
                              priority: aliveness-priority))
    (start-task aliveness-task))
  
  
  (method (stop-aliveness-task self)
    (exit-thread (get-thread aliveness-task))
    (thread-join! (get-thread aliveness-task))
    (set! aliveness-task #f))
  
  
  (method (aliveness-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (with-task-mutex
                (lambda ()
                  (unless (stopping? task)
                    (site (aliveness)
                      (check-aliveness self)))))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task aliveness-period duration exit))
              (iter time)))))))
  
  
  (method (check-aliveness self)
    ;; disconnect
    (let ((disconnect (collect-if (lambda (delegate)
                                    (and (not (get-asleep? delegate))
                                         (not (get-disconnected? delegate))
                                         (not (still-alive? delegate))))
                                  delegates)))
      (for-each (lambda (delegate)
                  (set-exception delegate "Disconnected")
                  (set-exception-stack delegate '())
                  (set-exception-time delegate (current-seconds))
                  (disconnect-client self delegate))
                disconnect)
      ;; giveup
      (let ((giveup (collect-if (lambda (delegate)
                                  (and (not (get-asleep? delegate))
                                       (disconnected-giveup? delegate)))
                                delegates)))
        (for-each (lambda (delegate)
                    (giveup-client self delegate))
                  giveup)
        ;; broadcast
        (when (or (not-null? disconnect)
                  (not-null? giveup))
          (broadcast-hierarchy self)))))
  
  
  (method override (delayed-disconnect-client self delegate)
    (disconnect-client self delegate)
    (broadcast-hierarchy self))
  
  
  (method override (disconnect-client self delegate)
    (logger/activity self "Disconnect {a}" (get-name delegate))
    (set-disconnected? delegate #t)
    ;; unregister non-live streams
    (server-unregister/disconnect-streams self (get-no delegate))
    (client-disconnect (get-remote-proxy (get-processor delegate)) (get-client delegate))
    (broadcast-disconnected self (list delegate)))
  
  
  (method (broadcast-disconnected self newly-disconnected)
    (for-each (lambda (client-delegate)
                (let ((client-group (get-group client-delegate)))
                  (when client-group
                    (let ((client-name (get-name client-delegate)))
                      (for-each (lambda (delegate)
                                  (unless (eq? delegate client-delegate)
                                    (if (is? delegate Mobile-Delegate)
                                        (send-disconnected self delegate client-name)
                                      (let ((client (get-client delegate)))
                                        (calling-client self delegate
                                          (lambda ()
                                            (server-disconnected client client-name)))))))
                                (get-members client-group))))))
              newly-disconnected))
  
  
  (method (reconnect-client self client delegate uuid)
    (set-disconnected? delegate #f)
    (set-client delegate client)
    (set-state delegate 'connected)
    (set-alive delegate (current-seconds))
    (set-exception delegate #f)
    (set-exception-stack delegate #f)
    (set-exception-time delegate #f)
    (set-uuid delegate uuid)
    (client-reconnect (get-remote-proxy (get-processor delegate)) client)
    (broadcast-reconnected self delegate))
  
  
  (method (broadcast-reconnected self client-delegate)
    (let ((client-group (get-group client-delegate)))
      (when (and client-group (memq? client-group groups))
        (let ((client-name (get-name client-delegate)))
          (for-each (lambda (delegate)
                      (unless (eq? delegate client-delegate)
                        (if (is? delegate Mobile-Delegate)
                            (send-reconnected self delegate client-name)
                          (let ((client (get-client delegate)))
                            (calling-client self delegate
                              (lambda ()
                                (server-reconnected client client-name)))))))
                    (get-members client-group))))))
  
  
  (method (giveup-client self delegate)
    (logger/activity self "Giveup {a}" (get-name delegate))
    (server-unregister-streams self (get-no delegate))
    (delegate-stop self delegate)
    (delegate-deconnect self delegate))
  
  
  ;;;
  ;;;; Mobile
  ;;;
  
  
  (method (read-mobile self port)
    (let ((code (make-string 4)))
      (if (= (read-substring code 0 4 port) 4)
          (if (equal? code mobile-code)
              (let ((obj (read port)))
                (if (eof-object? obj)
                    obj
                  (object->json obj)))
            (throw-connection-broke (format "Invalid code: {a}" code)))
        (throw-connection-broke "Read code received eof"))))
  
  
  (method (write-mobile self port kind message obj)
    (print-json (list kind message obj) port)
    (write-char #\| port)
    (force-output port))
  
  
  (method package (mobile-connect self port)
    (input-port-readtable-set! port json-readtable)
    (let ((personal-key (catch (connection-exception? exc
                                 (problem "Connecting mobile: {a}" (exception-reason exc))
                                 (eof-object))
                          (read-mobile self port))))
      (unless (eof-object? personal-key)
        (let ((identity (retrieve-identity directory personal-key)))
          (if (not identity)
              (write-mobile self port "result" "connect" "Invalid personal key")
            (let ((character-name (get-name identity))
                  (character-role (or (get-role identity) default-role))
                  (character-admin? (get-admin? identity)))
              (let ((existing-delegate (find-delegate-by-name self character-name)))
                (if (and existing-delegate (not (get-disconnected? existing-delegate)))
                    (begin
                      (logger/activity self "{a} is already connected" character-name)
                      (format "{a} is already connected" character-name))
                  (let ((delegate (cond (existing-delegate
                                          (mobile-reconnect self port existing-delegate)
                                          existing-delegate)
                                        (else
                                         (let ((id (make-unique-id)))
                                           (new Mobile-Delegate port 'started id (literal->id id self) character-name character-role character-admin?))))))
                    (let ((client-id #f)
                          (client-no (get-no delegate)))
                      (write-mobile self port "result" "connect" (list
                                                                   client-id
                                                                   client-no
                                                                   character-name
                                                                   character-role
                                                                   character-admin?))
                      (set-zone delegate 'start)
                      (unless existing-delegate
                        (set! delegates (cons delegate delegates)))
                      (broadcast-hierarchy self)
                      (broadcast-entered self delegate)
                      (serve-mobile self delegate)))))))))))
  
  
  (method package (mobile-deconnect self delegate)
    (logger/activity self "Deconnect {a}" (get-name delegate))
    (let ((group (get-group delegate)))
      (when group
        (leave-group self delegate group)))
    (set! delegates (remove! delegate delegates))
    (set-state delegate 'deconnected)
    (broadcast-exited self delegate)
    (broadcast-hierarchy self))
  
  
  (method package (mobile-disconnect self delegate)
    (logger/activity self "Disconnect {a}" (get-name delegate))
    (set-disconnected? delegate #t))
  
  
  (method (mobile-reconnect self port delegate)
    (set-disconnected? delegate #f)
    (set-port delegate port)
    (set-state delegate 'started)
    (set-alive delegate (current-seconds))
    (set-exception delegate #f)
    (set-exception-stack delegate #f)
    (set-exception-time delegate #f)
    (broadcast-reconnected self delegate))
  
  
  (method (mobile-message self delegate kind recipient message)
    (delegate-message self delegate kind recipient message))
  
  
  (method (mobile-invite self delegate recipient)
    (delegate-invite self delegate recipient))
  
  
  (method (mobile-accept self delegate sender)
    (delegate-accept self delegate sender))
  
  
  (method (mobile-decline self delegate sender)
    (delegate-decline self delegate sender))
  
  
  (method (mobile-leave self delegate)
    (delegate-leave self delegate))
  
  
  (method (serve-mobile self delegate)
    (declare (proper-tail-calls))
    (let ((port (get-port delegate)))
      (let (loop)
        (let ((obj (catch (connection-exception? exc
                            (problem "Serving mobile: {a}" (exception-reason exc))
                            (eof-object))
                     (read-mobile self port))))
          (if (eof-object? obj)
              (mobile-disconnect self delegate)
            (if (not (pair? obj))
                (begin
                  (write-mobile self port "result" "" (format "Invalid command: {a}" obj))
                  (loop))
              (bind (command . arguments) obj
                (if (equal? command "deconnect")
                    (begin
                      (write-mobile self port "result" command #f)
                      (mobile-deconnect self delegate))
                  (cond ((equal? command "message")
                         (bind (kind recipient message) arguments
                           (let ((kind (string->symbol kind)))
                             (write-mobile self port "result" command (mobile-message self delegate kind recipient message)))))
                        ((equal? command "invite")
                         (bind (recipient) arguments
                           (write-mobile self port "result" command (mobile-invite self delegate recipient))))
                        ((equal? command "accept")
                         (bind (sender) arguments
                           (write-mobile self port "result" command (mobile-accept self delegate sender))))
                        ((equal? command "decline")
                         (bind (sender) arguments
                           (write-mobile self port "result" command (mobile-decline self delegate sender))))
                        ((equal? command "leave")
                         (write-mobile self port "result" command (mobile-leave self delegate)))
                        (else
                         (write-mobile self port "result" command (format "Unknown command: {a}" command))))
                  (loop)))))))))
  
  
  (method (calling-mobile self delegate thunk)
    ;; should be handled in each call explicitly
    (unless (get-disconnected? delegate)
      (handle-exception-filter
        connection-exception?
        (lambda (exc)
          (problem "Calling mobile: {a}" (exception-reason exc))
          (set-exception delegate exc)
          (set-exception-stack delegate (execution-stack))
          (set-exception-time delegate (current-seconds))
          (mobile-disconnect self delegate))
        thunk)))
  
  
  (method (send-detach self delegate)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "detach" '()))))
  
  
  (method (send-people self delegate hierarchy)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "people" (list hierarchy)))))
  
  
  (method (send-entered self delegate client-no client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "entered" (list client-no client-name)))))
  
  
  (method (send-exited self delegate client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "exited" (list client-name)))))
  
  
  (method (send-disconnected self delegate client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "disconnected" (list client-name)))))
  
  
  (method (send-reconnected self delegate client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "reconnected" (list client-name)))))
  
  
  (method (send-message self delegate sender kind message)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "message" (list sender kind message)))))
  
  
  (method (send-messages self delegate messages)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "messages" (list messages)))))
  
  
  (method (send-invite self recipient-delegate sender)
    (calling-mobile self recipient-delegate
      (lambda ()
        (write-mobile self (get-port recipient-delegate) "call" "invite" (list sender)))))
  
  
  (method (send-accept self sender-delegate recipient)
    (calling-mobile self sender-delegate
      (lambda ()
        (write-mobile self (get-port sender-delegate) "call" "accept" (list recipient)))))
  
  
  (method (send-decline self sender-delegate recipient)
    (calling-mobile self sender-delegate
      (lambda ()
        (write-mobile self (get-port sender-delegate) "call" "decline" (list recipient)))))
  
  
  (method (send-join self delegate recipient)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "join" (list recipient)))))
  
  
  (method (send-leave self delegate recipient)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "leave" (list recipient)))))
  
  
  (method (send-disband self delegate)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "disband" '()))))
  
  
  ;;;
  ;;;; UDP
  ;;;
  
  
  (method (start-udp-server self)
    (let ((host (effective-host configuration))
          (service (effective-service configuration)))
      (let ((server (new UDP-Server)))
        (start server host service)
        (set! udp-server server)
        (set-?u server))))
  
  
  (method (stop-udp-server self)
    (when udp-server
      (stop udp-server)
      (set! udp-server #f)))
  
  
  ;;;
  ;;;; Detach
  ;;;
  
  
  (method (detach-clients self)
    (for-each (lambda (delegate)
                (if (is? delegate Mobile-Delegate)
                    (send-detach self delegate)
                  (calling-client self delegate
                    (lambda ()
                      (detach-client (get-client delegate))))))
              delegates))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method (stream-list self client)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          "Delegate not found"
        (let ((group (get-group client-delegate))
              (video-extensions (streaming-video-extensions))
              (audio-extensions (streaming-audio-extensions))
              (queue (new-queue)))
          (iterate-streams
            (lambda (file)
              (when (or (member? (get-extension file) video-extensions test: extension=?)
                        @audio-only-not-supported-at-the-moment
                        (member? (get-extension file) audio-extensions test: extension=?))
                (let ((base (get-base file)))
                  (let ((location (filename-spine (join (subpath {Directory Documents} file) "/"))))
                    (unless (member? location (queue-list queue) key: car test: filename=?)
                      (enqueue queue (list location (if (some? (lambda (stream)
                                                                 (or (not group)
                                                                     (let ((server-stream (find-server-stream udp-server (get-no stream))))
                                                                       (eq? (get-recipient server-stream) group))))
                                                               (find-streams self base))
                                                        'playing
                                                      #f)))))))))
          (queue-list queue)))))
  
  
  (method (make-server-stream self name source-kind video-level creators group (location: location #f))
    (let ((channels (map get-descriptor creators)))
      (bind (stream . server-channels) (server-register-stream self server-sender name server-no source-kind video-level channels group #f #f #t)
        (let ((stream-no (get-no stream)))
          (let ((send-stream (register-send-stream udp-server server-sender name stream-no source-kind video-level)))
            (set-location send-stream location)
            (for-each (lambda (server-channel creator)
                        (let ((create (get-create creator)))
                          (create stream-no (get-no server-channel))))
                      server-channels
                      creators)
            (values stream send-stream))))))
  
  
  (method (stream-invalid self client location)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          "Delegate not found"
        (let ((group (get-group client-delegate)))
          (if (not group)
              "You are not in a group"
            (if (not (string? location))
                "Invalid location"
              (let ((audio? (exists? (new-file {Directory Documents} (add-extension location (audio-profile-extension))))))
                (if audio?
                    #f
                  (if (null? (existing-video-profiles location))
                      "No stream found"
                    #f)))))))))
  
  
  (method (stream-play self client location (delay-streaming? #t))
    (let ((client-delegate (find-delegate self client)))
      (let ((group (get-group client-delegate)))
        (let ((name (filename-name location))
              (audio-file? (exists? (new-file {Directory Documents} (add-extension location (audio-profile-extension))))))
          (let ((audio-channels (if (and audio-file?
                                         (not stream-silent?))
                                    (list (make-server-audio-channel self location group))
                                  '()))
                (video-channels (make-server-video-channels self location group)))
            (let ((video-level (and (not-null? video-channels) (determine-stream-video-level video-channels)))
                  (channels (append audio-channels video-channels)))
              (receive (stream send-stream) (make-server-stream self name 'stream video-level channels group location: location)
                (set-action-proc send-stream stream-controller-action)
                (set-streams group (cons stream (get-streams group)))
                (if delay-streaming?
                    (delay-streaming
                      (lambda ()
                        (play send-stream)))
                  (sleep streaming-delay)
                  (play send-stream)))))))))
  
  
  (method (stream-stop self client location)
    (let ((name (filename-name location)))
      (let ((streams (find-streams self name)))
        (if (null? streams)
            "Stream not found"
          (let ((broadcast-hierarchy? #f))
            (for-each (lambda (stream)
                        (when (server-close-send-stream self stream)
                          (set! broadcast-hierarchy? #t)))
                      streams)
            (when broadcast-hierarchy?
              (broadcast-hierarchy self)))
          #f))))
  
  
  (method (find-streams self name)
    (let ((queue (new-queue)))
      (iterate-table (get-send-streams udp-server)
        (lambda (no stream)
          (when (equal? (get-name stream) name)
            (enqueue queue stream))))
      (queue-list queue)))
  
  
  (method (streaming-channels self)
    (map-table (lambda (no channel)
                 channel)
               (get-send-channels udp-server)))
  
  
  (method (make-server-audio-channel self location group)
    (let ((file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
      (let ((reader (new Stream-Reader file)))
        (let ((media-kind udp-audio)
              (source-kind 'stream)
              (level #f)
              (resolution #f)
              (framerate #f)
              (bitrate #f)
              (codec (get-codec reader))
              (caps (get-caps reader))
              (metadata '()))
          (close reader)
          (new Channel-Creator
            (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
            (lambda (stream-no channel-no)
              (let ((channel (register-send-channel udp-server stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                (let ((src (new File-Stream-Audio-Src
                             location))
                      (sink (new Stream-Consumer
                              consumer: (lambda (buffer dts pts duration keyframe?)
                                          (send-server-media self channel-no buffer dts pts duration keyframe?)))))
                  (let ((pipeline (pipeline (list src sink))))
                    (set-pipeline channel pipeline))))))))))
  
  
  (method (make-server-video-channels self location group)
    (let ((existing-profiles (existing-video-profiles location)))
      (map (lambda (profile)
             (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
               (let ((reader (new Stream-Reader file)))
                 (let ((media-kind udp-video)
                       (source-kind 'stream)
                       (level (get-level profile)))
                   (let ((resolution (get-resolution reader))
                         (framerate (get-framerate reader))
                         (bitrate (get-bitrate reader))
                         (codec (get-codec reader))
                         (caps (get-caps reader))
                         (metadata (list start: (get-start reader) end: (get-end reader))))
                     (close reader)
                     (new Channel-Creator
                       (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                       (lambda (stream-no channel-no)
                         (let ((channel (register-send-channel udp-server stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                           (let ((src (new File-Stream-Video-Src
                                        profile
                                        location
                                        stream?: (stream-to-group? udp-server channel group)))
                                 (sink (new Stream-Consumer
                                         consumer: (lambda (buffer dts pts duration keyframe?)
                                                     (send-server-media self channel-no buffer dts pts duration keyframe?)))))
                             (let ((pipeline (pipeline (list src sink))))
                               (set-pipeline channel pipeline)))))))))))
           existing-profiles)))
  
  
  (method package (send-server-media self channel-no buffer dts pts duration keyframe?)
    (when udp-server
      (send-media udp-server channel-no buffer dts pts duration keyframe?)))
  
  
  (method (server-close-send-stream self stream)
    (let ((server-stream (find-server-stream udp-server (get-no stream))))
      (let ((group (get-recipient server-stream)))
        (close-send-stream udp-server stream)
        (set-streams group (remove! server-stream (get-streams group)))
        (maybe-delete-group self #f group))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (world.window:tile-server/clients (non-bot-clients self)))
  
  
  (method override (restore self)
    (world.window:restore-server/clients (non-bot-clients self)))
  
  
  (method (non-bot-clients self)
    (map get-client (collect-if (lambda (delegate)
                                   (not (get-script delegate)))
                                 delegates)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (server-log #f (current-seconds) message)))
  
  
  ;;;
  ;;;; Logger
  ;;;
  
  
  (method package (logger/activity self . rest)
    (let ((message (apply format rest)))
      (logger "{a}" message)
      (broadcast-activity-message self message)))
  
  
  ;;;
  ;;;; Messages
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file self)
    (or log-file
        (let ((file (timestamped-file (new-directory directory "messages") "messages" "txt")))
          (create-directories file)
          (set! log-file file)
          file)))
  
  
  (method (log-message self sender message)
    (call-with-output-file (path-settings (cache-log-file self) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message))))
  
  
  (method (delegate-message self delegate kind recipient message)
    (let ((sender (get-name delegate)))
      (log-message self sender message)
      (case kind
        ((whisper)
         (let ((delegate (find-delegate-by-ci-name self recipient)))
           (if (not delegate)
               (format "Unable to find {a}" recipient)
             (deliver-message self delegate sender kind message)
             #f)))
        ((group)
         (let ((group (get-group delegate)))
           (if (not group)
               (format "You are not in a group")
             (for-each (lambda (delegate)
                           (deliver-message self delegate sender kind message))
                         (get-members group))
             #f)))
        ((gathering)
         (for-each (lambda (delegate)
                     (when (eq? (get-mode delegate) 'observer)
                       (deliver-message self delegate sender kind message)))
                   delegates)
         #f)
        ((server)
         (for-each (lambda (delegate)
                     (deliver-message self delegate sender kind message))
                   delegates)
         #f))))
  
  
  (method (deliver-message self delegate sender kind message)
    (if (get-asleep? delegate)
        (enqueue (get-message-queue delegate) (list sender kind message))
      (if (is? delegate Mobile-Delegate)
          (send-message self delegate sender kind message)
        (let ((client (get-client delegate)))
          (calling-client self delegate
            (lambda ()
              (server-message client sender kind message)))))))
  
  
  (method (deliver-messages self delegate messages)
    (if (is? delegate Mobile-Delegate)
        (send-messages self delegate messages)
      (let ((client (get-client delegate)))
        (calling-client self delegate
          (lambda ()
            (server-messages client messages)))))))


;;;
;;;; Slave
;;;


(definition protected (ready-server)
  (when master-process
    (let ((server (load-object (get-local-register) 'world.server.remote 'world-remote-server)))
      (slave-setup master-process server master-cookie)
      (slave-ready master-process server master-cookie)))))
