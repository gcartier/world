;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.server.tier jazz


(import (jazz.associative)
        (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.io)
        (jazz.json)
        (jazz.logger)
        (jazz.markup)
        (jazz.network)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.zlib)
        (world)
        (world.audio)
        (world.assets)
        (world.autoload)
        (world.capabilities)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.history)
        (world.id)
        (world.io)
        (world.log)
        (world.network)
        (world.processor)
        (world.profiling)
        (world.server)
        (world.server.client)
        (world.server.group)
        (world.server.mobile)
        (world.server.presence)
        (world.server.problem)
        (world.server.report)
        (world.server.serving)
        (world.server.udp)
        (world.settings)
        (world.stream)
        (world.streaming)
        (world.stub)
        (world.support)
        (world.task)
        (world.tier)
        (world.udp)
        (world.video))


(definition max-connections
  (world-setting 'world.server-max-connections #f))


;; quick solution for sending the reconnected message
;; while we are not keeping the disconnected delegate
(definition protected disconnected-groups
  (make-table test: equal?))

(definition (registered-disconnected-group character-name)
  (table-ref disconnected-groups character-name #f))

(definition (register-disconnected-group character-name group)
  (table-set! disconnected-groups character-name group))

(definition (unregister-disconnected-group character-name)
  (table-clear disconnected-groups character-name))

(definition (cleanup-disconnected-group group)
  (let ((character-name (table-find disconnected-groups group)))
    (when character-name
      (table-clear disconnected-groups character-name))))


(definition world-assets-mutex
  (make-mutex 'world-assets))


(definition (with-world-assets-mutex thunk)
  (mutex-lock! world-assets-mutex)
  (prog1 (thunk)
    (mutex-unlock! world-assets-mutex)))


(definition universe-asset-entries
  #f)


(definition stream-what
  'media)


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                                       getter generate)
  (slot instances      initialize (make-table test: equal?) getter generate)
  (slot zones          initialize '()                       getter generate)
  (slot groups         initialize '()                       getter generate)
  (slot hits           initialize 0                         getter generate)
  (slot aliveness-task initialize #f                        getter generate)
  (slot udp-server     initialize #f                        getter generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (set! configuration (get-server-configuration))
    (prepare-assets self)
    (let ((id (make-unique-id)))
      ;; not sure about this, for now lets use the hardcoded server-no = 0
      (set-client-id/no id server-no @w (literal->id id self)))
    (reset-last-broadcast)
    (setup-instances self)
    (setup-zones self))
  
  
  (method override (prepare-assets self)
    (let ((assets-dir {Directory Universe "assets"}))
      (set! universe-assets (new Remote-Assets 'universe assets-dir)))
    (let ((assets-dir (new-directory directory "assets")))
      (set! world-assets (new Remote-Assets 'world assets-dir))))
  
  
  (method override (startup self)
    (nextmethod self)
    (start-aliveness-task self)
    @wait-mobile
    (start-mobile-server (~ mobile-connect self))
    (start-udp-server self)
    (delay-spawn-start-zone self))
  
  
  (method (delay-spawn-start-zone self)
    (delay-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (spawn-processor (effective-host configuration) (effective-service configuration) (~ collect-world-asset-entries self) 'start))))))
  
  
  (method override (enter self)
    (let ((me (current-me+)))
      (when me
        (set-name me (get-character-name configuration))
        (set-avatar me (get-character-avatar configuration))
        (set-color me (get-character-dye configuration)))))
  
  
  (method override (shutdown self)
    @wait-mobile
    (stop-mobile-server)
    (stop-udp-server self)
    (stop-aliveness-task self)
    (detach-clients self))
  
  
  (method override (get-udp-tier self)
    udp-server)
  
  
  (method (calling-processor self processor thunk)
    (thunk))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state self)
    'started)
    
  
  (method override (start self)
    )
  
  
  (method override (stop self)
    )
  
  
  (method override (restart self)
    )
  
  
  (method override (wait-started self)
    )
  
  
  (method override (wait-stopped self)
    )
  
  
  (method override (server-name self)
    "World")
  
  
  (method override (server-title self)
    "World")
  
  
  (method override (server-version self)
    (process-version (current-process)))
  
  
  (method override (server-host self)
    (host->string (listening-host (get-remote-listener))))
  
  
  (method override (server-service self)
    (port->string (listening-port (get-remote-listener))))
  
  
  (method override (server-hits self)
    hits)
  
  
  (method override (server-debug? self)
    #f)
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (next-literal-id!))
  
  
  (method override (tier-id->literal self id)
    (error "Unregistered id: {s}" id))
  
  
  ;;;
  ;;;; Delegates
  ;;;
  
  
  (method (count-delegates self)
    (length delegates))
  
  
  (method package (collect-delegates self)
    (sort ci<? delegates key: get-name))
  
  
  (method package (collect-disconnected self)
    (collect-if get-disconnected? delegates))
  
  
  ;;;
  ;;;; Instances
  ;;;
  
  
  (method (find-instance self uuid)
    (table-ref instances uuid #f))


  (method (setup-instances self)
    (let ((instances-dir (instances-dir self)))
      (when (exists? instances-dir)
        (iterate-directory instances-dir
          (lambda (instance-dir)
            (let ((file (new-file instance-dir ".instance")))
              (when (exists? file)
                (let ((instance (instantiate (read-form file))))
                  (let ((uuid (get-name instance)))
                    (table-set! instances uuid instance))))))
          files?: #f
          directories?: #t
          recursive?: #f))))
  
  
  (method (instances-dir self)
    (new-directory directory "instances"))
  
  
  ;;;
  ;;;; Zones
  ;;;


  (method (setup-zones self)
    (let ((zones-dir (zones-dir self))
          (queue (new-queue)))
      (when (exists? zones-dir)
        (iterate-directory zones-dir
          (lambda (path kind)
            (let ((zone-dir (new-directory zones-dir path)))
              (let ((file (new-file zone-dir ".zone")))
                (when (exists? file)
                  (enqueue queue path)))))
          full?: #f
          files?: #f
          directories?: #t
          recursive?: #t))
      (set! zones (queue-list queue))))
  
  
  (method package (zones-dir self)
    (new-directory directory "zones"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (setup-me self)
    (setup-current-me self)
    (register-id (current-me) (make-unique-id)))
  
  
  (method override (save-me self)
    (save-current-me self))
  
  
  (method override (player-file self name)
    (new-file directory '("start" ".player")))
  
  
  (method override (anonymous self)
    "Server")
  
  
  ;;;
  ;;;; Groups
  ;;;
  
  
  (method (find-group self name/no)
    (if (integer? name/no)
        (find-if (lambda (group)
                   (= (get-no group) name/no))
                 groups)
      (find-if (lambda (group)
                 (equal? (get-name group) name/no))
               groups)))
  
  
  (method (create-group self delegate name persistent? allow-audio-only? auto-create?)
    (logger/activity self "Create group{? {a}~} ({a})" name (get-name delegate))
    (let ((group (new Server-Group name persistent? allow-audio-only? (if auto-create? 'start (get-zone delegate)))))
      (set! groups (cons group groups))
      group))
  
  
  (method (delete-group self delegate group)
    (logger/activity self "Delete group{? {a}~} ({a})" (get-name group) (if delegate (get-name delegate) "Server"))
    (set! groups (remove! group groups))
    (cleanup-disconnected-group group))
  
  
  (method (maybe-delete-group self delegate group)
    (if (or (get-persistent? group)
            (has-members? self group)
            (has-streams? self group))
        #f
      (delete-group self delegate group)
      #t))
  
  
  (method (maybe-disband-group self delegate group)
    (let ((members (get-members group)))
      (when (= (length members) 1)
        (disband-group self delegate group)
        (broadcast-hierarchy-to self members))))
  
  
  (method (disband-group self delegate group)
    (logger/activity self "Disband group{? {a}~} ({a})" (get-name group) (get-name delegate))
    (for-each (lambda (delegate)
                (leave-group self delegate group)
                (if (is? delegate Mobile-Delegate)
                    (send-disband self delegate)
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (server-disband client))))))
              (get-members group))
    (set! groups (remove! group groups))
    (cleanup-disconnected-group group))
  
  
  (method (has-members? self group)
    (not-null? (get-members group)))
  
  
  (method (has-streams? self group)
    (not-null? (get-streams group)))
  
  
  (method (join-group self delegate group)
    (let ((delegate-name (get-name delegate))
          (group-name (get-name group)))
      (logger/activity self "Join group{? {a}~} ({a})" group-name (get-name delegate))
      (set-group delegate group)
      (unless group-name
        (for-each (lambda (delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-join self delegate delegate-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-join client delegate-name))))))
                  (get-members group)))
      (set-members group (cons delegate (get-members group)))
      (wait-keyframes udp-server delegate (delegate->connection self delegate))
      (update-streaming udp-server group)
      (update-streaming-levels self group)))
  
  
  (method (leave-group self delegate group)
    (let ((delegate-name (get-name delegate))
          (group-name (get-name group)))
      (logger/activity self "Leave group{? {a}~} ({a})" group-name delegate-name)
      (unless (is? delegate Mobile-Delegate)
        (done-keyframes udp-server delegate (delegate->connection self delegate)))
      (set-group delegate #f)
      (set-members group (remove delegate (get-members group)))
      (update-streaming udp-server group)
      (update-streaming-levels self group)
      (unless group-name
        (for-each (lambda (delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-leave self delegate delegate-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-leave client delegate-name))))))
                  (get-members group)))
      (if (get-name group)
          (maybe-delete-group self delegate group)
        (maybe-disband-group self delegate group))))
  
  
  (method (delegate->connection self delegate)
    (no->connection udp-server (get-no delegate)))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method package (client-connect self client client-uuid personal-key machine-identity machine-caps machine-features character-avatar character-dye character-script character-zone)
    (let ((identity (retrieve-identity directory personal-key)))
      (if (not identity)
          "Invalid personal key"
        (let ((character-name (get-name identity))
              (character-role (or (get-role identity) default-role))
              (character-admin? (get-admin? identity)))
          (if (and max-connections (>= (count-delegates self) max-connections))
              (begin
                (logger/activity self "Max connections reached ({a})" character-name)
                (format "Max {a} connections reached" max-connections))
            (let ((existing-delegate (find-delegate-by-name self character-name)))
              (when existing-delegate
                (kick-client self existing-delegate)
                (set! existing-delegate #f))
              (if (and existing-delegate (not (get-disconnected? existing-delegate)))
                  (begin
                    (logger/activity self "{a} is already connected" character-name)
                    (format "{a} is already connected" character-name))
                ;; register client
                (let ((reconnect-info (and existing-delegate
                                           (let ((group (get-group existing-delegate)))
                                             (list (get-mode existing-delegate)
                                                   (get-zone existing-delegate)
                                                   (and group
                                                        (or (get-name group)
                                                            (get-no group)))
                                                   (and group
                                                        (get-allow-audio-only? group)))))))
                  (let ((delegate (cond (existing-delegate
                                          (reconnect-client self client existing-delegate client-uuid)
                                          existing-delegate)
                                        (else
                                         (let ((id (make-unique-id)))
                                           (new Client-Delegate client 'connected client-uuid id (literal->id id self) character-name character-avatar character-dye character-script character-role character-admin?)))))
                        (machine (retrieve-machine directory character-name machine-identity machine-caps machine-features)))
                    (logger/activity self "{a} {a}" (if existing-delegate "Reconnect" "Connect") character-name)
                    (unless existing-delegate
                      (set! delegates (cons delegate delegates))
                      (let ((group (registered-disconnected-group character-name)))
                        (when group
                          (unregister-disconnected-group character-name)
                          (broadcast-reconnected-to-group self delegate group))))
                    ;; retrieve character
                    (let ((client-id (get-id delegate))
                          (client-no (get-no delegate))
                          (machine-identity (get-identity machine))
                          (machine-settings (get-settings machine))
                          (universe-asset-entries (cache-universe-asset-entries self))
                          (world-asset-entries (collect-world-asset-entries self))
                          (character (character-retrieve self character-name character-avatar character-dye))
                          (character-delegate delegate))
                      (set-character character-delegate character)
                      ;; join character zone
                      (let ((character-zone (if existing-delegate (get-zone existing-delegate) (or character-zone (get-zone character)))))
                        (let ((processor (spawn-processor (effective-host configuration) (effective-service configuration) world-asset-entries character-zone)))
                          (if (string? processor)
                              processor
                            (let ((remote-processor (get-remote-proxy processor)))
                              (let ((join-info (client-enter remote-processor client client-uuid client-id client-no character-name character-avatar character-dye character-script character-role character-admin?)))
                                (if (string? join-info)
                                    join-info
                                  (set-zone character-delegate character-zone)
                                  (set-processor character-delegate processor)
                                  (add-delegate processor character-delegate)
                                  (bind (form zone-asset-entries spawnpoint player-spawnpoint player-id player-no player-position player-lookat camera-position camera-lookat zone-daytime other-players) join-info
                                    (let ((welcome (format "Welcome to {a}!" tier-title)))
                                      (list client-id
                                            client-no
                                            machine-identity
                                            machine-settings
                                            character-name
                                            character-role
                                            character-admin?
                                            universe-asset-entries
                                            world-asset-entries
                                            zone-asset-entries
                                            (proxy-connection-info client remote-processor)
                                            welcome
                                            form
                                            spawnpoint
                                            player-spawnpoint
                                            player-id
                                            player-no
                                            player-position
                                            player-lookat
                                            camera-position
                                            camera-lookat
                                            zone-daytime
                                            other-players
                                            reconnect-info)))))))))))))))))))
  
  
  (method package (client-start self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-state delegate 'started)
        @peer2peer
        (broadcast-peers self)
        (broadcast-hierarchy self)
        (broadcast-entered self delegate))))
  
  
  (method package (client-stop self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (delegate-stop self delegate))))
  
  
  (method (delegate-stop self delegate)
    (let ((group (get-group delegate)))
      (when group
        (leave-group self delegate group)))
    (set-state delegate 'stopped))
  
  
  (method package (client-deconnect self client)
    ;; find server client
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (let ((name (get-name delegate)))
          (logger/activity self "Deconnect {a}" name)
          (delegate-deconnect self delegate)))))
  
  
  (method (delegate-deconnect self delegate (broadcast-exited?: broadcast-exited? #t))
    (let ((client (get-client delegate))
          (name (get-name delegate)))
      ;; deconnect udp
      (when udp-server
        (deconnect-source udp-server (get-no delegate)))
      ;; store character
      (character-store self (get-character delegate))
      ;; leave zone
      (let ((processor-proxy (get-remote-proxy (get-processor delegate))))
        (when (remote-proxy-connected? processor-proxy)
          (client-exit processor-proxy client name)))
      (remove-delegate (get-processor delegate) delegate)
      ;; unregister delegate
      (set! delegates (remove! delegate delegates))
      ;; update state
      (set-state delegate 'deconnected)
      ;; closing remote
      (closing-remote-proxy-safe client)
      ;; broadcast
      (when broadcast-exited?
        (broadcast-exited self delegate))
      @peer2peer
      (broadcast-peers self)
      (broadcast-hierarchy self)))
  
  
  (method package (client-reconnection self client zone group)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (server-unregister-streams self (get-no delegate)))))
  
  
  (method package (client-observe self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          "Delegate not found"
        (set-mode delegate 'observer)
        (client-mode (get-remote-proxy (get-processor delegate)) client 'observer)
        (broadcast-hierarchy self)
        #f)))
  
  
  (method package (client-play self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          "Delegate not found"
        (if (not (processor-playable? (get-processor delegate)))
            (format "Max {a} played zone{a} reached" max-played (format-plural max-played))
          (set-mode delegate 'player)
          (client-mode (get-remote-proxy (get-processor delegate)) client 'player)
          (broadcast-hierarchy self)
          #f))))
  
  
  (method package (client-roam self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          "Delegate not found"
        (set-roaming? delegate #t)
        #f)))
  
  
  (method package (client-anchor self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          "Delegate not found"
        (set-roaming? delegate #f)
        #f)))
  
  
  (method package (client-sleep self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-asleep? delegate #t)
        (broadcast-hierarchy self))))
  
  
  (method package (client-wake self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-asleep? delegate #f)
        (broadcast-hierarchy self)
        ;; deliver queued messages
        (let ((queue (get-message-queue delegate)))
          (let ((messages (queue-list queue)))
            (when (not-null? messages)
              (reset-queue queue)
              (deliver-messages self delegate messages)))))))
                  
  
  
  @peer2peer
  (method (broadcast-peers self)
    (let ((peers '()))
      (iterate-table (get-no-connections udp-server)
        (lambda (origin connection)
          (let ((delegate (find-delegate-by-no self origin)))
            (when (and delegate (eq? (get-state delegate) 'started))
              (let ((host (get-host connection))
                    (port (get-port connection))
                    (local-host (get-local-host connection))
                    (local-port (get-local-port connection)))
                (set! peers (cons (list origin host port local-host local-port) peers)))))))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (unless (is? delegate Mobile-Delegate)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (peers-update client peers)))))))
                delegates)))
  
  
  (method (broadcast-hierarchy self)
    (broadcast-hierarchy-to self delegates))
  
  
  (method (broadcast-hierarchy-to self delegates)
    (let ((hierarchy (collect-hierarchy self))
          ;; quick hack
          (mobile-hierarchy (collect-hierarchy self #t)))
      (for-each (lambda (delegate)
                  (if (is? delegate Mobile-Delegate)
                      (send-people self delegate mobile-hierarchy)
                    (when (eq? (get-state delegate) 'started)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (hierarchy-update client hierarchy)))))))
                delegates)))
  
  
  (method (broadcast-entered self client-delegate)
    (let ((client-id (get-id client-delegate))
          (client-no (get-no client-delegate))
          (client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-entered self delegate client-no client-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-entered client client-id client-no client-name)))))))
                delegates)))
  
  
  (method (broadcast-exited self client-delegate)
    (let ((client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-exited self delegate client-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-exited client client-name)))))))
                delegates)))
  
  
  (method (character-retrieve self character-name character-avatar character-dye)
    (let ((file (new-file (characters-dir self) (format "{a}.character" character-name))))
      (let ((character
              (if (exists? file)
                  (let ((character (instantiate (read-form file))))
                    (set-name character character-name)
                    (set-avatar character character-avatar)
                    (set-dye character character-dye)
                    character)
                (let ((units '(world.character)))
                  (let ((tag '(<Character>))
                        (data (new Data zone-version 'jazz units #f)))
                    (let ((form (construct-form tag (imports-locator units) data)))
                      (set-origin form file)
                      (let ((character (instantiate form)))
                        (set-name character character-name)
                        (set-avatar character character-avatar)
                        (set-dye character character-dye)
                        (set-zone character 'start)
                        character)))))))
        character)))
  
  
  (method (character-store self character)
    (let ((file (new-file (characters-dir self) (format "{a}.character" (get-name character)))))
      (create-directories file)
      (let ((designer (new Former form: (get-form character) reference: character)))
        (define (save-character)
          (set-property designer character 'zone (get-zone character)))
        
        (save-character)
        (save designer))))
  
  
  (method (characters-dir self)
    (new-directory directory "characters"))
  
  
  (method package (client-alive self client)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (when delegate
        (set-alive delegate (current-seconds)))))
  
  
  (method package (client-invite self client recipient)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-invite self delegate recipient))))
  
  
  (method (delegate-invite self delegate recipient)
    (let ((recipient-delegate (find-delegate-by-ci-name self recipient)))
      (if (not recipient-delegate)
          (format "Unable to find {a}" recipient)
        (if (eq? delegate recipient-delegate)
            (format "Cannot invite yourself")
          (if (get-group recipient-delegate)
              (format "{a} is already in a group" recipient)
            (if (memq? delegate (get-invites recipient-delegate))
                #f
              (let ((client (get-client recipient-delegate))
                    (sender (get-name delegate)))
                (if (is? recipient-delegate Mobile-Delegate)
                    (send-invite self recipient-delegate sender)
                  (calling-client self recipient-delegate
                    (lambda ()
                      (server-invite client sender)))))
              (add-invite recipient-delegate delegate)
              #f))))))
  
  
  (method package (client-accept self client sender)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-accept self delegate sender))))
  
  
  (method (delegate-accept self delegate sender)
    (if (get-group delegate)
        (format "You are already in a group")
      (let ((sender-delegate (find-delegate-by-ci-name self sender)))
        (if (not sender-delegate)
            (format "Unable to find {a}" sender)
          (let ((sender-group (get-group sender-delegate)))
            (let ((group (if sender-group
                             (begin
                               (join-group self delegate sender-group)
                               sender-group)
                           (let ((group (create-group self sender-delegate #f #f #t #f)))
                             (join-group self sender-delegate group)
                             (join-group self delegate group)
                             group))))
              (let ((sender-client (get-client sender-delegate))
                    (recipient (get-name delegate)))
                (if (is? sender-delegate Mobile-Delegate)
                    (send-accept self sender-delegate recipient)
                  (calling-client self sender-delegate
                    (lambda ()
                      (server-accept sender-client recipient)))))
              (remove-invite delegate sender-delegate)
              (broadcast-hierarchy-to self (get-members group))
              (if (is? delegate Mobile-Delegate)
                  (get-no group)
                (group-information self group))))))))
  
  
  (method package (client-decline self client sender)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-decline self delegate sender))))
  
  
  (method (delegate-decline self delegate sender)
    (let ((sender-delegate (find-delegate-by-ci-name self sender)))
      (if (not sender-delegate)
          (format "Unable to find {a}" sender)
        (let ((sender-client (get-client sender-delegate))
              (recipient (get-name delegate)))
          (if (is? sender-delegate Mobile-Delegate)
              (send-decline self sender-delegate recipient)
            (calling-client self sender-delegate
              (lambda ()
                (server-decline sender-client recipient)))))
        (remove-invite delegate sender-delegate)
        #f)))
  
  
  (method package (client-leave self client)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (and delegate
           (delegate-leave self delegate))))
  
  
  (method (delegate-leave self delegate)
    (let ((group (get-group delegate)))
      (if (not group)
          (format "You are not in a group")
        (let ((members (get-members group)))
          (leave-group self delegate group)
          (broadcast-hierarchy-to self members)
          #f))))
  
  
  (method package (client-message self client kind recipient message)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (and delegate
           (delegate-message self delegate kind recipient message))))
  
  
  (method package (client-log self client time message)
    (server-log client time message))
  
  
  (method package (processor-log self processor time message)
    (server-log processor time message))
  
  
  (method package (client-connected-player self client no)
    (connected-player self no))
  
  
  (method override (connected-player self no)
    (if (= no client-no)
        "Server"
      (let ((delegate (find-delegate-by-no self no)))
        (and delegate
             (get-name delegate)))))
  
  
  (method package (client-connected-players self client)
    (connected-players self))
  
  
  (method package (client-available-templates self client)
    (available-templates self))
  
  
  (method package (client-available-zone-base self client from)
    (available-zone-base self from))
  
  
  (method package (client-available-zone-base? self client base)
    (available-zone-base? self base))
  
  
  (method package (client-create-zone self client from base)
    (and (create-zone self from base)
         (list 'zone base)))
  
  
  (method package (client-available-zones self client)
    (available-zones self))
  
  
  (method package (client-load-zone self client zone)
    (let ((delegate (with-task-mutex
                      (lambda ()
                        (find-delegate self client)))))
      ;; aec robust
      (when delegate
        (let ((spawn-result #f))
          (let ((spawn-thread (current-thread)))
            (delay-event
              (lambda ()
                (thread-join! spawn-thread)
                (let ((error-string (if (string? spawn-result) spawn-result #f)))
                  (with-task-mutex
                    (lambda ()
                      (calling-client self delegate
                        (lambda ()
                          (zone-loaded client zone error-string)))))))))
          (set! spawn-result (spawn-processor (effective-host configuration) (effective-service configuration) (~ collect-world-asset-entries self) zone delegate))))))
  
  
  (method package (client-change-zone self client zone)
    (change-client-zone self client zone))
  
  
  (method package (client-changed-zone self client)
    (changed-client-zone self client))
  
  
  (method package (client-create-group self client name persistent? allow-audio-only? broadcast-hierarchy? auto-create?)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (if (and (not auto-create?) (get-group delegate))
            (format "You are already in a group")
          (let ((existing-group (and name (find-group self name))))
            (if existing-group
                (format "{a}{? {a}~} already exists" (group-domain-name self name) name)
              (let ((group (create-group self delegate name persistent? allow-audio-only? auto-create?)))
                (when broadcast-hierarchy?
                  (broadcast-hierarchy self))
                (get-no group))))))))
  
  
  (method package (client-delete-group self client name/no)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name/no))
              (group-name (and (string? name/no) name/no)))
          (if (not group)
              (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
            (if (has-members? self group)
                (format "{a}{? {a}~} still has members" (group-domain-name self name/no) group-name)
              (if (has-streams? self group)
                  (format "{a}{? {a}~} still has streams" (group-domain-name self name/no) group-name)
                (when (maybe-delete-group self delegate name/no)
                  (broadcast-hierarchy self))
                #f)))))))
  
  
  (method package (client-join-group self client name/no mode)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (if (get-group delegate)
            (format "You are already in a group")
          (let ((group (find-group self name/no))
                (group-name (and (string? name/no) name/no)))
            (if (not group)
                (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
              (when mode
                (set-mode delegate mode))
              (join-group self delegate group)
              (broadcast-hierarchy self)
              (group-information self group)))))))
  
  
  (method package (client-rejoin-group self client name/no)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name/no))
              (group-name (and (string? name/no) name/no)))
          (if (not group)
              (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
            (group-information self group))))))
  
  
  (method package (client-leave-group self client name/no mode)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name/no))
              (group-name (and (string? name/no) name/no)))
          (if (not group)
              (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
            (when mode
              (set-mode delegate mode))
            (leave-group self delegate group)
            (broadcast-hierarchy self)
            #f)))))
  
  
  (method package (client-change-video-level self client video-level)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((origin (get-no delegate))
              (connection (delegate->connection self delegate)))
          (if (not connection)
              (format "Connection not found")
            (set-video-level connection video-level)
            (iterate-table (get-server-streams udp-server)
              (lambda (no stream)
                (when (and (get-video-level stream)
                           (= (get-origin stream) origin))
                  (set-video-level stream video-level))))
            (let ((group (get-group delegate)))
              (when group
                (update-streaming udp-server group)
                (update-streaming-levels self group)
                (for-each (lambda (member)
                            (unless (eq? member delegate)
                              (unless (is? member Mobile-Delegate)
                                (let ((client (get-client member)))
                                  (calling-client self member
                                    (lambda ()
                                      (streamer-update client origin video-level)))))))
                          (get-members group))))
            #f)))))
  
  
  (method package (update-streaming-levels self group)
    (define (determine-streaming-levels ignore)
      (let ((levels '()))
        (for-each (lambda (member)
                    (unless (eq? member ignore)
                      (let ((no (get-no member)))
                        (let ((connection (no->connection udp-server no)))
                          (when connection
                            (let ((level (get-video-level connection)))
                              (unless (memv? level levels)
                                (set! levels (cons level levels)))))))))
                  (get-members group))
        (sort < levels)))
    
    (for-each (lambda (member)
                (unless (is? member Mobile-Delegate)
                  (let ((streaming-levels (determine-streaming-levels member)))
                    (unless (equal? (get-streaming-levels member) streaming-levels)
                      (let ((client (get-client member)))
                        (calling-client self member
                          (lambda ()
                            (streaming-update client streaming-levels))))
                      (set-streaming-levels member streaming-levels)))))
              (get-members group)))
  
  
  (method package (client-register-stream self client sender name source-kind video-level channels recipient)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          (format "Delegate not found")
        (let ((group (get-group client-delegate)))
          (define (normalize-recipient)
            (if (not recipient)
                group
              (map (lambda (no)
                     (find-delegate-by-no self no))
                   recipient)))
          
          (if (and (not recipient)
                   (not group))
              (format "You are not in a group")
            (let ((origin (get-no client-delegate))
                  (recipient (normalize-recipient))
                  (exclude-register client-delegate)
                  (exclude-broadcast client-delegate))
              (bind (stream . server-channels) (server-register-stream self sender name origin source-kind video-level channels recipient exclude-register exclude-broadcast #f)
                (cons (get-no stream) (map get-no server-channels)))))))))
  
  
  (method package (server-register-stream self sender name origin source-kind video-level channels recipient exclude-register exclude-broadcast server-sender?)
    (let ((no (next-stream-no!)))
      (let ((stream (register-server-stream udp-server sender name no origin source-kind video-level recipient exclude-register exclude-broadcast)))
        (let ((server-channels (map (lambda (channel)
                                      (bind (media-kind source-kind level resolution framerate bitrate codec caps metadata) channel
                                        (server-add-channel self no media-kind source-kind level resolution framerate bitrate codec caps metadata server-sender?)))
                                    channels))
              (recipients (stream-recipients self stream))
              (group-no (stream-group-no self stream))
              (group-allow-audio-only? (stream-group-allow-audio-only? self stream)))
          (let ((extended-channels (map (lambda (descriptor server-channel)
                                          (cons (get-no server-channel) descriptor))
                                        channels
                                        server-channels)))
            (for-each (lambda (delegate)
                        (unless (eq? delegate exclude-register)
                          (when (eq? (get-state delegate) 'started)
                            (unless (is? delegate Mobile-Delegate)
                              (let ((client (get-client delegate)))
                                (calling-client self delegate
                                  (lambda ()
                                    (stream-add client group-no group-allow-audio-only? sender name no origin source-kind video-level extended-channels))))))))
                      recipients)
            (cons stream server-channels))))))
  
  
  (method package (client-unregister-stream self client stream-no)
    (server-unregister-stream self stream-no))
  
  
  (method package (server-unregister/disconnect-streams self client-no)
    (iterate-table (get-server-streams udp-server)
      (lambda (no stream)
        (when (= (get-origin stream) client-no)
          (if (eq? (get-source-kind stream) 'live)
              (server-disconnect-stream self no)
            (server-unregister-stream self no))))))
  
  
  (method package (server-unregister-streams self client-no)
    (iterate-table (get-server-streams udp-server)
      (lambda (no stream)
        (when (= (get-origin stream) client-no)
          (server-unregister-stream self no)))))
  
  
  (method package (server-unregister-stream self stream-no)
    (let ((stream (find-server-stream udp-server stream-no)))
      ;; together robust
      (when stream
        (let ((recipients (stream-recipients self stream))
              (exclude-register (get-exclude-register stream)))
          (for-each (lambda (delegate)
                      (unless (eq? delegate exclude-register)
                        (when (eq? (get-state delegate) 'started)
                          (unless (is? delegate Mobile-Delegate)
                            (let ((client (get-client delegate)))
                              (calling-client self delegate
                                (lambda ()
                                  (stream-remove client stream-no))))))))
                    recipients)
          (close-server-stream udp-server stream)))))
  
  
  (method package (server-disconnect-stream self stream-no)
    (let ((stream (find-server-stream udp-server stream-no)))
      ;; together robust
      (when stream
        (let ((recipients (stream-recipients self stream))
              (exclude-register (get-exclude-register stream)))
          (for-each (lambda (delegate)
                      (unless (eq? delegate exclude-register)
                        (when (eq? (get-state delegate) 'started)
                          (unless (is? delegate Mobile-Delegate)
                            (let ((client (get-client delegate)))
                              (calling-client self delegate
                                (lambda ()
                                  (stream-disconnect client stream-no))))))))
                    recipients)))))
  
  
  (method package (client-channel-init self client channel-no caps resolution)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((channel (find-server-channel udp-server channel-no)))
          ;; together robust
          (when channel
            (set-caps channel caps)
            (set-resolution channel resolution)))
        (let ((group (get-group delegate)))
          (when group
            (for-each (lambda (member)
                        (unless (eq? member delegate)
                          (unless (is? member Mobile-Delegate)
                            (let ((client (get-client member)))
                              (calling-client self member
                                (lambda ()
                                  (stream-channel-init client channel-no caps resolution)))))))
                      (get-members group))))
        #f)))
  
  
  (method package (client-stream-action self client stream-no action arguments)
    (let ((send-stream (find-send-stream udp-server stream-no)))
      (if send-stream
          (let ((action-proc (get-action-proc send-stream)))
            (when action-proc
              (action-proc send-stream action arguments)))
        (let ((stream (find-server-stream udp-server stream-no)))
          ;; together robust
          (when stream
            (let ((origin (get-origin stream)))
              (let ((delegate (find-delegate-by-no self origin)))
                (when (and delegate (is-not? delegate Mobile-Delegate))
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (action-stream client stream-no action arguments))))))))))))
  
  
  (method package (server-add-channel self stream-no media-kind source-kind level resolution framerate bitrate codec caps metadata server-sender?)
    (let ((no (next-channel-no!)))
      (register-server-channel udp-server stream-no no media-kind source-kind level resolution framerate bitrate codec caps metadata server-sender?)))
  
  
  (method package (client-channel-action self client channel-no action arguments)
    (let ((channel (find-server-channel udp-server channel-no)))
      ;; together robust
      (when channel
        (let ((origin (get-origin (get-stream channel))))
          (let ((delegate (find-delegate-by-no self origin)))
            (when (and delegate (is-not? delegate Mobile-Delegate))
              (let ((client (get-client delegate)))
                (calling-client self delegate
                  (lambda ()
                    (action-channel client channel-no action arguments))))))))))
  
  
  (method (stream-recipients self stream)
    (let ((recipient (get-recipient stream)))
      (if (is? recipient Server-Group)
          (get-members recipient)
        recipient)))
  
  
  (method (stream-group-no self stream)
    (let ((recipient (get-recipient stream)))
      (if (is? recipient Server-Group)
          (get-no recipient)
        #f)))
  
  
  (method (stream-group-allow-audio-only? self stream)
    (let ((recipient (get-recipient stream)))
      (if (is? recipient Server-Group)
          (get-allow-audio-only? recipient)
        #f)))
  
  
  (method (group-information self group)
    (cons (get-no group)
          (cons (get-allow-audio-only? group)
                (cons (get-duration group)
                      (group-streams self group)))))
  
  
  (method (group-streams self group)
    (let ((origins (map get-no (get-members group)))
          (streams (new-queue)))
      (iterate-table (get-server-streams udp-server)
        (lambda (no stream)
          (define (collect-channels)
            (let ((channels (new-queue)))
              (iterate-table (get-channels stream)
                (lambda (no channel)
                  (let ((media-kind (get-media-kind channel))
                        (source-kind (get-source-kind channel))
                        (level (get-level channel))
                        (resolution (get-resolution channel))
                        (framerate (get-framerate channel))
                        (bitrate (get-bitrate channel))
                        (codec (get-codec channel))
                        (caps (get-caps channel))
                        (metadata (get-metadata channel)))
                    (enqueue channels (list no media-kind source-kind level resolution framerate bitrate codec caps metadata)))))
              (queue-list channels)))
          
          (let ((origin (get-origin stream)))
            (when (or (memv? origin origins)
                      (= origin server-no))
              (let ((recipient (get-recipient stream)))
                (when (eq? recipient group)
                  (let ((sender (get-sender stream))
                        (name (get-name stream))
                        (source-kind (get-source-kind stream))
                        (video-level (get-video-level stream))
                        (channels (collect-channels)))
                    (enqueue streams (list sender name no origin source-kind video-level channels)))))))))
      (queue-list streams)))
  
  
  (method package (client-list-group-members self name/no)
    (let ((group (find-group self name/no))
          (group-name (and (string? name/no) name/no)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
        (map get-name (get-members group)))))
  
  
  (method package (client-list-hierarchy self)
    (collect-hierarchy self))
  
  
  (method (collect-hierarchy self (mobile? #f))
    (define (member-info delegate)
      (list (get-name delegate)
            (and (not mobile?) (get-id delegate))
            (get-no delegate)
            (get-asleep? delegate)
            (get-disconnected? delegate)
            (get-roaming? delegate)
            (get-zone delegate)
            (get-mode delegate)))
    
    (cons (cons #f
                (cons #f
                      (cons #f
                            (map member-info (collect-if (lambda (delegate)
                                                           (and (eq? (get-state delegate) 'started)
                                                                (not (get-group delegate))))
                                                         delegates)))))
          (map (lambda (group)
                 (cons (or (get-name group)
                           (get-no group))
                       (cons (get-allow-audio-only? group)
                             (cons (get-zone group)
                                   (map member-info (get-members group))))))
               groups)))
  
  
  (method (group-domain-name self name)
    (if (or (not name)
            (integer? name))
        (registered-domain-name 'group "Group")
      (registered-domain-name 'circle "Circle")))
  
  
  (method override (connected-players self)
    (map (lambda (delegate)
           (let ((zone (get-zone delegate)))
             (list (get-name delegate) zone (present-zone self zone))))
         delegates))
  
  
  (method override (available-templates self)
    (collect-templates))
  
  
  (method override (available-zone-base self from)
    (unique-zone-base from))
  
  
  (method override (available-zone-base? self base)
    (zone-base-available? base))
  
  
  (method override (create-zone self from base)
    (prog1 (create-new-zone from base
             create: (lambda (dir)
                       (create (new-directory dir "players")))
             open: (lambda (file)
                     #f))
      (setup-zones self)))
  
  
  (method override (available-zones self)
    (let ((queue (new-queue)))
      (iterate-table instances
        (lambda (uuid instance)
          (enqueue queue (cons (list 'instance uuid)
                               (format "{a}{? <{a}>~}" (join (get-template instance) "/") (+ (get-rank instance) 1))))))
      (for-each (lambda (path)
                  (enqueue queue (cons (cons 'zone path)
                                       (last path))))
                zones)
      (queue-list queue)))
  
  
  (method (change-client-zone self client zone)
    (let ((delegate (find-delegate self client)))
      (let ((client-uuid (get-uuid delegate))
            (client-id (get-id delegate))
            (client-no (get-no delegate))
            (character-name (get-name delegate))
            (character-avatar (get-avatar delegate))
            (character-dye (get-dye delegate))
            (character-script (get-script delegate))
            (character-role (get-role delegate))
            (character-admin? (get-admin? delegate)))
        ;; spawn
        (let ((processor (spawn-processor (effective-host configuration) (effective-service configuration) (~ collect-world-asset-entries self) zone delegate)))
          (if (string? processor)
              processor
            ;; leave
            (client-exit (get-remote-proxy (get-processor delegate)) client character-name)
            (remove-delegate (get-processor delegate) delegate)
            ;; join
            (let ((remote-processor (get-remote-proxy processor)))
              (let ((join-info (client-enter remote-processor client client-uuid client-id client-no character-name character-avatar character-dye character-script character-role character-admin?)))
                (set-zone delegate zone)
                (set-processor delegate processor)
                (add-delegate processor delegate)
                (broadcast-hierarchy self)
                (cons (proxy-connection-info client remote-processor) join-info))))))))
  
  
  (method (changed-client-zone self client)
    (cleanup-processors))
  
  
  (method (present-zone self zone)
    (if (eq? zone 'start)
        "<Start Zone>"
      (case (car zone)
        ((instance)
         (let ((instance (find-instance self (cadr zone))))
           (format "{a}{? <{a}>~}" (get-name (get-template instance)) (+ (get-rank instance) 1))))
        (else
         (last zone)))))
    
  
  (method (cache-universe-asset-entries self)
    (or universe-asset-entries
        (let ((entries (zlib-deflate (object->u8vector (get-entries (get-index (get-repository universe-assets)))))))
          (set! universe-asset-entries entries)
          entries)))

  
  (method (collect-world-asset-entries self)
    (with-world-assets-mutex
      (lambda ()
        (get-entries (get-index (get-repository world-assets))))))
  
  
  (method package (retrieve-universe-asset self path)
    (let ((repository (get-repository universe-assets)))
      (let ((entry (find-entry repository path)))
        (and entry
             (bind (path digest seconds) entry
               (list (retrieve-object repository digest) digest))))))
  
  
  (method package (retrieve-world-asset self path)
    (with-world-assets-mutex
      (lambda ()
        (let ((repository (get-repository world-assets)))
          (let ((entry (find-entry repository path)))
            (and entry
                 (bind (path digest seconds) entry
                   (list (retrieve-object repository digest) digest))))))))
  
  
  (method package (upload-world-asset self content digest)
    (with-world-assets-mutex
      (lambda ()
        (let ((repository (get-repository world-assets)))
          (store-object repository content digest)))))
  
  
  (method package (update-world-assets self client changes)
    (with-world-assets-mutex
      (lambda ()
        (let ((repository (get-repository world-assets)))
          (let ((delegate (find-delegate self client)))
            (apply-changes repository changes)
            (broadcast-assets self delegate changes))))))
  
  
  (method (broadcast-assets self client-delegate changes)
    (iterate-processors
      (lambda (zone processor)
        (let ((remote-processor (get-remote-proxy processor)))
          (calling-processor self processor
            (lambda ()
              (world-assets-update remote-processor changes))))))
    (for-each (lambda (delegate)
                (when (eq? (get-state delegate) 'started)
                  (unless (eq? delegate client-delegate)
                    (unless (is? delegate Mobile-Delegate)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (world-assets-update client changes))))))))
              delegates))
  
  
  (method package (register-literal self literal)
    (literal->id literal))
  
  
  (method package (registered-id self id)
    (id->literal id))
  
  
  (method (find-delegate-by-id self id)
    (find-if (lambda (delegate)
               (equal? (get-id delegate) id))
             delegates))
  
  
  (method (find-delegate-by-no self no)
    (find-if (lambda (delegate)
               (= (get-no delegate) no))
             delegates))
  
  
  (method package (tile-server self)
    (tile self))
  
  
  (method package (restore-server self)
    (restore self))
  
  
  (method package (profile-start self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (when connection
            (profile-start connection))))))
  
  
  (method package (profile-test self client test arguments)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (when connection
            (profile-test connection test arguments))))))
  
  
  (method package (profile-retrieve self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (and connection
               (profile-retrieve connection))))))
  
  
  (method package (profile-stop self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (when connection
            (profile-stop connection))))))
  
  
  (method package (admin-metadata self (requester-group #f))
    (define (send-streams)
      (streams-metadata (get-send-streams udp-server)))
    
    (define (server-streams)
      (streams-metadata (get-server-streams udp-server)))
    
    (define (start-time)
      (and requester-group (get-start-time requester-group)))
    
    (list server-no "_server" (send-streams) (server-streams) (sites-metadata) (start-time)))
  
  
  (method package (admin-command self client command arguments)
    (case command
      ((activity)
       (let ((file (logger-file)))
         (and (exists? file)
              (load-lines file))))
      ((date)
       (date->string (system-date) "~Y-~m-~d_~H-~M-~S"))
      ((disconnected)
       (map (lambda (delegate)
              (list (get-name delegate)
                    (exception-reason (get-exception delegate))
                    (get-exception-stack delegate)))
            (collect-disconnected self)))
      ((drop)
       (bind (who drop) arguments
         (let ((delegate (find-delegate self client)))
           (let ((connection (no->connection udp-server (get-no delegate))))
             (and connection
                  (let ((simulator (require-simulator udp-server connection))
                        (drop (if (unspecified? drop) #f drop)))
                    (setup-drop simulator drop)
                    #f))))))
      ((identity)
       (bind (action . rest) arguments
         (define (show key)
           (let ((identity (retrieve-identity directory key)))
             (list key
                   (get-name identity)
                   role: (get-role identity)
                   admin?: (get-admin? identity))))
         
         (case action
           ((list)
            (bind (target) rest
              (let ((queue (new-queue)))
                (iterate-identities directory
                  (lambda (key identity)
                    (let ((name (get-name identity))
                          (role (get-role identity))
                          (admin? (get-admin? identity)))
                      (when (or (unspecified? target)
                                (search name target ignore-case?: #t))
                        (enqueue queue (list (substring key 0 8)
                                             name
                                             role: role
                                             admin?: admin?))))))
                (queue-list queue))))
           ((show)
            (bind (target) rest
              (let ((key (find-identity-key directory target)))
                (if (not key)
                    "Identity not found"
                  (show key)))))
           ((add)
            (bind (name role admin?) rest
              (let ((key (generate-uuid))
                    (role (if (unspecified? role) #f role))
                    (admin? (if (unspecified? admin?) #f admin?)))
                (add-identity directory key name role admin?)
                (show key))))
           ((existing)
            (bind (key name role admin?) rest
              (let ((role (if (unspecified? role) #f role))
                    (admin? (if (unspecified? admin?) #f admin?)))
                (add-identity directory key name role admin?)
                (show key))))
           ((modify)
            (bind (target name role admin?) rest
              (let ((key (find-identity-key directory target)))
                (if (not key)
                    "Identity not found"
                  (modify-identity directory key
                    (lambda (designer identity)
                      (when (specified? name)
                        (set-name designer identity name))
                      (when (specified? role)
                        (set-property designer identity 'role role))
                      (when (specified? admin?)
                        (set-property designer identity 'admin? admin?))))
                  (show key)))))
           ((remove)
            (bind (target) rest
              (let ((key (find-identity-key directory target)))
                (if (not key)
                    "Identity not found"
                  (remove-identity directory key)
                  #f)))))))
      ((kick)
       (bind (who) arguments
         (let ((delegate (find-delegate-by-ci-name self who)))
           (if (not delegate)
               (format "Unable to find {s}" who)
             (kick-client self delegate)
             #f))))
      ((latency)
       (bind (who latency) arguments
         (let ((delegate (find-delegate self client)))
           (let ((connection (no->connection udp-server (get-no delegate))))
             (and connection
                  (let ((simulator (require-simulator udp-server connection))
                        (latency (if (unspecified? latency) #f latency)))
                    (setup-latency simulator latency)
                    #f))))))
      ((machine)
       (bind (action . rest) arguments
         (case action
           ((list)
            (bind (target) rest
              (let ((queue (new-queue)))
                (iterate-machines directory
                  (lambda (identity machine)
                    (let ((user (get-user machine)))
                      (when (or (unspecified? target)
                                (search user target ignore-case?: #t))
                        (let ((caps (get-caps machine))
                              (features (get-features machine))
                              (settings (get-settings machine)))
                          (define (flatten-settings)
                            (let ((queue (new-queue)))
                              (for-each (lambda (pair)
                                          (bind (setting . value) pair
                                            (enqueue queue setting)
                                            (enqueue queue value)))
                                        settings)
                              (queue-list queue)))
                          
                          (enqueue queue `(,(substring identity 0 8)
                                           ,user
                                           platform: ,(assq-value 'kernel.platform features #f)
                                           profile: ,(assq-value 'caps.profile.base caps #f)
                                           speed: ,(fxround (assq-value 'caps.computer-speed caps #f))
                                           ,@(if settings (cons settings: (flatten-settings)) '()))))))))
                (queue-list queue))))
           ((caps)
            (bind (target) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (get-caps machine)))))
           ((features)
            (bind (target) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (get-features machine)))))
           ((settings)
            (bind (target) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (or (get-settings machine) '())))))
           ((set)
            (bind (target setting value) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (let ((settings (or (get-settings machine) '())))
                    (let ((pair (assq setting settings)))
                      (if pair
                          (set-cdr! pair value)
                        (set-settings machine (cons (cons setting value) settings)))))
                  (save-machine directory (get-identity machine) machine)
                  (or (get-settings machine) '())))))
           ((unset)
            (bind (target setting) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (let ((settings (or (get-settings machine) '())))
                    (let ((pair (assq setting settings)))
                      (when pair
                        (let ((settings (remove pair settings)))
                          (set-settings machine (if (null? settings) #f settings))
                          (save-machine directory (get-identity machine) machine)))))
                  (or (get-settings machine) '()))))))))
      ((metadata)
       (admin-metadata self))
      ((problems)
       (let ((file (problem-file)))
         (and (exists? file)
              (load-lines file))))
      ((reset)
       (bind (ring) arguments
         (case ring
           ((evolution)
            (reset-evolution)
            #t)
           (else
            #f))))
      ((restart)
       (logger "Restart server")
       (let ((delay (if (null? arguments) 1 (car arguments))))
         (restart-server self delay))
       (unspecified))
      ((send)
       (send-crash-reports))
      ((stream)
       (bind (action . rest) arguments
         (case action
           ((audio)
            (set! stream-what 'audio)
            stream-what)
           ((video)
            (set! stream-what 'video)
            stream-what)
           ((media)
            (set! stream-what 'media)
            stream-what)
           ((list)
            (stream-list self client))
           ((play)
            (bind (location count spacing) rest
              (or (stream-invalid self client location)
                  (begin
                    (if (unspecified? count)
                        (stream-play self client location)
                      (delay-event
                        (lambda ()
                          (loop (for n from 0 below count)
                                (when (and (specified? spacing) (/= n 0))
                                  (sleep spacing))
                                (stream-play self client location #f)))))
                    #f))))
           ((compare)
            (bind (locations) rest
              (delay-event
                (lambda ()
                  (loop (for location in locations)
                        (stream-play self client location #f))))
              #f))
           ((stop)
            (bind (location) rest
              (stream-stop self client location)))
           ((done)
            (let ((broadcast-hierarchy? #f))
              (iterate-table (get-send-streams udp-server)
                (lambda (no stream)
                  (when (server-close-send-stream self stream)
                    (set! broadcast-hierarchy? #t))))
              (when broadcast-hierarchy?
                (broadcast-hierarchy self)))
            #f))))
      ((stop)
       (logger "Stop server")
       (stop-server self)
       (unspecified))
      ((test)
       (bind (no) arguments
         (let ((no (if (unspecified? no) #f no)))
           (logger "Test server{? {a}~}" no)
           (cond ((not no)
                  #f)
                 (else
                  #f)))))
      ((threads)
       (map ->string (top-threads)))
      ((version)
       (let ((version (process-version (current-process))))
         (format "v{a}{a}" (present version) environment-suffix)))
      ((who)
       (map get-name delegates))
      (else
       (let ((requester client))
         (let ((requester-delegate (find-delegate self requester)))
           (define (dispatch-who what who dispatch-server dispatch-client)
             (cond ((equal? who 'server)
                    (dispatch-server)
                    #f)
                   ((equal? who 'all)
                    (if (eq? what 'energy)
                        (begin
                          (for-each dispatch-client delegates)
                          #f)
                      (let ((requester-group (and requester-delegate (get-group requester-delegate))))
                        (if (not requester-group)
                            "You are not in a circle"
                          (unless (memq? what '(info capture uncapture))
                            (dispatch-server requester-group))
                          (for-each dispatch-client (get-members requester-group))
                          #f))))
                   (else
                    (let ((delegate (find-delegate-by-ci-name self who)))
                      (if (not delegate)
                          (format "Unable to find {s}" who)
                        (dispatch-client delegate)
                        #f)))))
           
           (case command
             ((request)
              (let ((requester-name (if requester-delegate (get-name requester-delegate) "Unknown")))
                (bind (cookie what who action) arguments
                  (define (request-server (requester-group #f))
                    (admin-server-request self requester requester-name requester-group cookie what action))
                  
                  (define (request-client delegate)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (admin-request client requester requester-name cookie what action)))))
                  
                  (if (memq? what '(set unset))
                      (let ((machine (find-machine directory who)))
                        (if (not machine)
                            "Machine not found"
                          (let ((who (get-user machine)))
                            ;; no error if who is not connected
                            (if (find-delegate-by-ci-name self who)
                                (dispatch-who what who request-server request-client)
                              #f))))
                    (dispatch-who what who request-server request-client)))))
             ;((run)
             ; (bind (cookie script who) arguments
             ;   (define (run-server (requester-group #f))
             ;     (admin-server-run self requester cookie script))
             ;   
             ;   (define (run-client delegate)
             ;     (let ((client (get-client delegate)))
             ;       (calling-client self delegate
             ;         (lambda ()
             ;           (admin-run client requester cookie script)))))
             ;   
             ;   (dispatch-who what who run-server run-client)))
             (else
              (format "Unknown command: {s}" command))))))))
    
  
  (definition preserved-exception-debugger
    #f)
  
  (definition preserved-exception-hook
    #f)

  
  (method (admin-server-request self requester requester-name requester-group cookie what action)
    (define (send-info)
      (send-threaded 0
        (lambda ()
          (let ((server (current-server)))
            ;; gc before process-memory
            (let ((garbage-collect (estimate-garbage-collect)))
              (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
                (object->u8vector
                  (list
                    (server-host server)
                    (server-service server)
                    (map get-name (collect-delegates (current-server)))
                    (map get-zone (list-processors))
                    (map get-purpose (table-values presences))
                    (collect-hierarchy (current-server))
                    garbage-collect
                    (estimate-cpu%)
                    (length (top-threads))
                    last-gc-live
                    last-gc-movable
                    last-gc-nonmovable
                    (let ((port (get-udp-port udp-server)))
                      (list (udp-socket-receive-buffer-size port)
                            (udp-socket-send-buffer-size port)
                            (udp-socket-send-again-count port)))
                    outgoing-max))))))))
    
    (define (send-replay)
      (send-threaded 0
        (lambda ()
          (let ((metadata (admin-metadata self requester-group))
                (chronology (copy-chronology (current-chronology)))
                (evolution (copy-evolution (current-evolution))))
            (object->u8vector (list metadata chronology evolution) serialize)))
        (lambda ()
          (gather-replay-missing udp-server action))))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Documents "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file)
      (let ((dir {Directory Documents "shared"})
            (name action))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (generate-snapshot)
      (background
        (lambda ()
          (snapshot-process reason: (format "Snapshot requested by {a}" requester-name))
          (send-reply "done" #t))))
    
    (define (attach-to-debugger)
      (if (get-controller-debugger)
          (send-reply "Already attached" #f)
        (logger "Attach server")
        (let ((debugger action))
          (thread-int! (primordial-thread)
            (lambda ()
              (let ((exception-debugger (get-exception-debugger))
                    (exception-hook (jazz:get-exception-hook)))
                (let ((exc (setup-debuggee debugger: debugger connection-exception-exit?: #f)))
                  (if exc
                      (send-reply "Unable to connect to debugger" #f)
                    (set! preserved-exception-debugger exception-debugger)
                    (set! preserved-exception-hook exception-hook)
                    (start-repl-thread (current-thread) #f (current-console-port))
                    (select-debugger-console)
                    (current-input-port (console-input-port))
                    (current-output-port (console-output-port))
                    (ready-to-controller)
                    (iterate-processors
                      (lambda (zone processor)
                        (let ((remote-processor (get-remote-proxy processor)))
                          (calling-processor self processor
                            (lambda ()
                              (attach remote-processor debugger))))))
                    (send-reply "attached" #t)))))))))
    
    (define (detach-from-debugger)
      (if (not (get-controller-debugger))
          (send-reply "Already detached" #f)
        (logger "Detach server")
        (current-input-port (standard-input-port))
        (current-output-port (standard-output-port))
        (detach-from-controller)
        (set-exception-debugger preserved-exception-debugger)
        (set-exception-hook preserved-exception-hook)
        (set! preserved-exception-debugger #f)
        (set! preserved-exception-hook #f)
        (iterate-processors
          (lambda (zone processor)
            (let ((remote-processor (get-remote-proxy processor)))
              (calling-processor self processor
                (lambda ()
                  (detach remote-processor))))))
        (send-reply "detached" #t)))
    
    (define (send-reply name done?)
      (let ((sender "_server"))
        (admin-chunk requester cookie sender name #f done?)))
    
    (define (send-threaded name extract (missing #f))
      (background
        (lambda ()
          (let ((sender "_server"))
            (admin-chunk requester cookie sender name #f #f)
            (let ((content (zlib-deflate (extract)))
                  (give-time .01))
              (when missing
                (let ((missing (missing)))
                  (for-each (lambda (missing)
                              (sleep give-time)
                              (admin-request-chunk self requester cookie sender 'missing missing #f))
                            missing)))
              (let ((content-size (u8vector-length content))
                    (max-size 8192))
                (let (loop-chunk (part 0) (pos 0))
                  (let ((remain (- content-size pos)))
                    (when (> remain 0)
                      (sleep give-time)
                      (let ((chunk-size (min remain max-size)))
                        (let ((chunk (make-u8vector chunk-size))
                              (done? (>= chunk-size remain)))
                          (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                          (admin-request-chunk self requester cookie sender name chunk done?))
                        (loop-chunk (+ part 1) (+ pos chunk-size))))))))))))
    
    (define (background thunk)
      (let ((thread (new-thread thunk 'request)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)))
    
    (case what
      ((info)
       (send-info))
      ((replay)
       (send-replay))
      ((shared)
       (send-shared))
      ((transfer)
       (send-shared-file))
      ((snapshot)
       (generate-snapshot))
      ((attach)
       (attach-to-debugger))
      ((detach)
       (detach-from-debugger))))
  
  
  ;(method (admin-server-run self requester cookie script)
  ;  (run-remote-script script
  ;    (lambda (state data)
  ;      (let ((sender "_server"))
  ;        (admin-run-return self requester cookie sender state data)))))
  
  
  (method (admin-request-chunk self requester cookie sender name chunk done?)
    (let ((delegate (find-delegate self requester)))
      (when delegate
        (calling-client self delegate
          (lambda ()
            (admin-chunk requester cookie sender name chunk done?))))))
  
  
  ;(method (admin-run-return self requester cookie sender state data)
  ;  (let ((delegate (find-delegate self requester)))
  ;    (when delegate
  ;      (calling-client self delegate
  ;        (lambda ()
  ;          (admin-return requester cookie sender state data))))))
  
  
  (method (stop-server self)
    (let ((process (current-process)))
      (delay-event
        (lambda ()
          (quit-process process)))))
  
  
  (method (restart-server self delay)
    (let ((process (current-process)))
      (delay-event
        (lambda ()
          (count-down delay
            (lambda (suffix)
              (broadcast-server-message self
                (if (= delay 1)
                    "Restart"
                  (format "Restart in {a}" suffix))))
            (lambda ()
              (quit-process process)))))))
  
  
  (method (broadcast-server-message self message)
    (let ((sender "Server")
          (kind 'server))
      (for-each (lambda (delegate)
                  (deliver-message self delegate sender kind message))
                delegates)))
  
  
  (method (broadcast-activity-message self message)
    (let ((sender "Server")
          (kind 'activity))
      (for-each (lambda (delegate)
                  (when (get-admin? delegate)
                    (deliver-message self delegate sender kind message)))
                delegates)))
  
  
  ;;;
  ;;;; Aliveness
  ;;;
  
  
  (method (start-aliveness-task self)
    (set! aliveness-task (new Task 'aliveness (~ run-aliveness self) priority: aliveness-priority))
    (start-task aliveness-task))
  
  
  (method (stop-aliveness-task self)
    (stop-task aliveness-task)
    (set! aliveness-task #f))
  
  
  (method (run-aliveness self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (with-task-mutex
                (lambda ()
                  (unless (stopping? task)
                    (site aliveness
                      (check-aliveness self)))))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task aliveness-period duration exit))
              (iter time)))))))
  
  
  (method (check-aliveness self)
    ;; no disconnect at the moment as the reconnection
    ;; protocol is too fragile and needs a lot more work
    (let ((disconnect (collect-if (lambda (delegate)
                                    (and (not (get-asleep? delegate))
                                         (not (still-alive? delegate))))
                                  delegates)))
      (for-each (lambda (delegate)
                  (set-exception delegate "Disconnected")
                  (set-exception-stack delegate '())
                  (set-exception-time delegate (current-seconds))
                  (disconnect-client self delegate reason: "Check aliveness"))
                disconnect))
    @wait-disconnect (
    ;; disconnect
    (let ((disconnect (collect-if (lambda (delegate)
                                    (and (not (get-asleep? delegate))
                                         (not (get-disconnected? delegate))
                                         (not (still-alive? delegate))))
                                  delegates)))
      (for-each (lambda (delegate)
                  (set-exception delegate "Disconnected")
                  (set-exception-stack delegate '())
                  (set-exception-time delegate (current-seconds))
                  (disconnect-client self delegate reason: "Check aliveness"))
                disconnect)
      ;; giveup
      (let ((giveup (collect-if (lambda (delegate)
                                  (and (not (get-asleep? delegate))
                                       (disconnected-giveup? delegate)))
                                delegates)))
        (for-each (lambda (delegate)
                    (giveup-client self delegate))
                  giveup)
        ;; broadcast
        (when (or (not-null? disconnect)
                  (not-null? giveup))
          (broadcast-hierarchy self))))))
  
  
  (method override (delayed-disconnect-client self delegate (reason: reason #f))
    (disconnect-client self delegate reason: reason)
    (broadcast-hierarchy self))
  
  
  (method override (disconnect-client self delegate (reason: reason #f))
    ;; so we disconnect only once
    (when (memq? delegate delegates)
      @debugging-read-header-received-eof-disconnects
      (snapshot-process user: (get-name delegate) kind: "Disconnect" reason: reason max-depth: 0)
      ;; no disconnect at the moment as the reconnection
      ;; protocol is too fragile and needs a lot more work
      (logger/activity self "Disconnect {a}{? ({a})~}" (get-name delegate) reason)
      (kick-client self delegate #f))
    @reconnection-too-fragile (
    (set-disconnected? delegate #t)
    ;; unregister non-live streams
    (server-unregister/disconnect-streams self (get-no delegate))
    (disconnect-remote-proxy (get-client delegate))
    (let ((processor-proxy (get-remote-proxy (get-processor delegate))))
      (when (remote-proxy-connected? processor-proxy)
        (client-disconnect processor-proxy (get-client delegate))))
    (broadcast-disconnected self (list delegate))))
  
  
  (method (client-disconnect self client reason)
    (let ((delegate (find-delegate self client)))
      (when delegate
        (disconnect-client self delegate reason: reason))))
  
  
  (method (broadcast-disconnected self newly-disconnected)
    (for-each (lambda (client-delegate)
                (let ((client-group (get-group client-delegate)))
                  (when client-group
                    (broadcast-disconnected-to-group self client-delegate client-group))))
              newly-disconnected))
  
  
  (method (broadcast-disconnected-to-group self client-delegate client-group)
    (let ((client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-disconnected self delegate client-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-disconnected client client-name)))))))
                (get-members client-group))))
  
  
  (method (reconnect-client self client delegate uuid)
    (set-disconnected? delegate #f)
    (set-client delegate client)
    (set-state delegate 'connected)
    (set-alive delegate (current-seconds))
    (set-exception delegate #f)
    (set-exception-stack delegate #f)
    (set-exception-time delegate #f)
    (set-uuid delegate uuid)
    (client-reconnect (get-remote-proxy (get-processor delegate)) client)
    (broadcast-reconnected self delegate))
  
  
  (method (broadcast-reconnected self client-delegate)
    (let ((client-group (get-group client-delegate)))
      (when client-group
        (broadcast-reconnected-to-group self client-delegate client-group))))
  
  
  (method (broadcast-reconnected-to-group self client-delegate client-group)
    (when (memq? client-group groups)
      (let ((client-name (get-name client-delegate)))
        (for-each (lambda (delegate)
                    (unless (eq? delegate client-delegate)
                      (if (is? delegate Mobile-Delegate)
                          (send-reconnected self delegate client-name)
                        (let ((client (get-client delegate)))
                          (calling-client self delegate
                            (lambda ()
                              (server-reconnected client client-name)))))))
                  (get-members client-group)))))
  
  
  (method (giveup-client self delegate)
    (logger/activity self "Giveup {a}" (get-name delegate))
    (server-unregister-streams self (get-no delegate))
    (delegate-stop self delegate)
    (delegate-deconnect self delegate))
  
  
  (method (kick-client self delegate (activity? #t))
    (let ((client (get-client delegate))
          (group (get-group delegate)))
      (when activity?
        (logger/activity self "Kick {a}" (get-name delegate)))
      (server-unregister-streams self (get-no delegate))
      (delegate-stop self delegate)
      (delegate-deconnect self delegate broadcast-exited?: #f)
      (disconnect-remote-proxy client)
      (let ((processor-proxy (get-remote-proxy (get-processor delegate))))
        (when (remote-proxy-connected? processor-proxy)
          (client-kick processor-proxy client)))
      (when group
        (register-disconnected-group (get-name delegate) group)
        (broadcast-disconnected-to-group self delegate group))))
  
  
  ;;;
  ;;;; Mobile
  ;;;
  
  
  (method (read-mobile self port)
    (let ((code (make-string 4)))
      (if (= (read-substring code 0 4 port) 4)
          (if (equal? code mobile-code)
              (let ((obj (read port)))
                (if (eof-object? obj)
                    obj
                  (object->json obj)))
            (throw-connection-broke (format "Invalid code: {a}" code)))
        (throw-connection-broke "Read code received eof"))))
  
  
  (method (write-mobile self port kind message obj)
    (print-json (list kind message obj) port)
    (write-char #\| port)
    (force-output port))
  
  
  (method package (mobile-connect self port)
    (input-port-readtable-set! port json-readtable)
    (let ((personal-key (catch (connection-exception? exc
                                 (problem "Connecting mobile: {a}" (exception-reason exc))
                                 (eof-object))
                          (read-mobile self port))))
      (unless (eof-object? personal-key)
        (let ((identity (retrieve-identity directory personal-key)))
          (if (not identity)
              (write-mobile self port "result" "connect" "Invalid personal key")
            (let ((character-name (get-name identity))
                  (character-role (or (get-role identity) default-role))
                  (character-admin? (get-admin? identity)))
              (let ((existing-delegate (find-delegate-by-name self character-name)))
                (if (and existing-delegate (not (get-disconnected? existing-delegate)))
                    (begin
                      (logger/activity self "{a} is already connected" character-name)
                      (format "{a} is already connected" character-name))
                  (let ((delegate (cond (existing-delegate
                                          (mobile-reconnect self port existing-delegate)
                                          existing-delegate)
                                        (else
                                         (let ((id (make-unique-id)))
                                           (new Mobile-Delegate port 'started id (literal->id id self) character-name character-role character-admin?))))))
                    (let ((client-id #f)
                          (client-no (get-no delegate)))
                      (write-mobile self port "result" "connect" (list
                                                                   client-id
                                                                   client-no
                                                                   character-name
                                                                   character-role
                                                                   character-admin?))
                      (set-zone delegate 'start)
                      (unless existing-delegate
                        (set! delegates (cons delegate delegates)))
                      (broadcast-hierarchy self)
                      (broadcast-entered self delegate)
                      (serve-mobile self delegate)))))))))))
  
  
  (method package (mobile-deconnect self delegate)
    (logger/activity self "Deconnect {a}" (get-name delegate))
    (let ((group (get-group delegate)))
      (when group
        (leave-group self delegate group)))
    (set! delegates (remove! delegate delegates))
    (set-state delegate 'deconnected)
    (broadcast-exited self delegate)
    (broadcast-hierarchy self))
  
  
  (method package (mobile-disconnect self delegate)
    (logger/activity self "Disconnect {a}" (get-name delegate))
    (set-disconnected? delegate #t))
  
  
  (method (mobile-reconnect self port delegate)
    (set-disconnected? delegate #f)
    (set-port delegate port)
    (set-state delegate 'started)
    (set-alive delegate (current-seconds))
    (set-exception delegate #f)
    (set-exception-stack delegate #f)
    (set-exception-time delegate #f)
    (broadcast-reconnected self delegate))
  
  
  (method (mobile-message self delegate kind recipient message)
    (delegate-message self delegate kind recipient message))
  
  
  (method (mobile-invite self delegate recipient)
    (delegate-invite self delegate recipient))
  
  
  (method (mobile-accept self delegate sender)
    (delegate-accept self delegate sender))
  
  
  (method (mobile-decline self delegate sender)
    (delegate-decline self delegate sender))
  
  
  (method (mobile-leave self delegate)
    (delegate-leave self delegate))
  
  
  (method (serve-mobile self delegate)
    (declare (proper-tail-calls))
    (let ((port (get-port delegate)))
      (let (loop)
        (let ((obj (catch (connection-exception? exc
                            (problem "Serving mobile: {a}" (exception-reason exc))
                            (eof-object))
                     (read-mobile self port))))
          (if (eof-object? obj)
              (mobile-disconnect self delegate)
            (if (not (pair? obj))
                (begin
                  (write-mobile self port "result" "" (format "Invalid command: {a}" obj))
                  (loop))
              (bind (command . arguments) obj
                (if (equal? command "deconnect")
                    (begin
                      (write-mobile self port "result" command #f)
                      (mobile-deconnect self delegate))
                  (cond ((equal? command "message")
                         (bind (kind recipient message) arguments
                           (let ((kind (string->symbol kind)))
                             (write-mobile self port "result" command (mobile-message self delegate kind recipient message)))))
                        ((equal? command "invite")
                         (bind (recipient) arguments
                           (write-mobile self port "result" command (mobile-invite self delegate recipient))))
                        ((equal? command "accept")
                         (bind (sender) arguments
                           (write-mobile self port "result" command (mobile-accept self delegate sender))))
                        ((equal? command "decline")
                         (bind (sender) arguments
                           (write-mobile self port "result" command (mobile-decline self delegate sender))))
                        ((equal? command "leave")
                         (write-mobile self port "result" command (mobile-leave self delegate)))
                        (else
                         (write-mobile self port "result" command (format "Unknown command: {a}" command))))
                  (loop)))))))))
  
  
  (method (calling-mobile self delegate thunk)
    ;; should be handled in each call explicitly
    (unless (get-disconnected? delegate)
      (handle-exception-filter
        connection-exception?
        (lambda (exc)
          (problem "Calling mobile: {a}" (exception-reason exc))
          (set-exception delegate exc)
          (set-exception-stack delegate (execution-stack))
          (set-exception-time delegate (current-seconds))
          (mobile-disconnect self delegate))
        thunk)))
  
  
  (method (send-detach self delegate)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "detach" '()))))
  
  
  (method (send-people self delegate hierarchy)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "people" (list hierarchy)))))
  
  
  (method (send-entered self delegate client-no client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "entered" (list client-no client-name)))))
  
  
  (method (send-exited self delegate client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "exited" (list client-name)))))
  
  
  (method (send-disconnected self delegate client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "disconnected" (list client-name)))))
  
  
  (method (send-reconnected self delegate client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "reconnected" (list client-name)))))
  
  
  (method (send-message self delegate sender kind message)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "message" (list sender kind message)))))
  
  
  (method (send-messages self delegate messages)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "messages" (list messages)))))
  
  
  (method (send-invite self recipient-delegate sender)
    (calling-mobile self recipient-delegate
      (lambda ()
        (write-mobile self (get-port recipient-delegate) "call" "invite" (list sender)))))
  
  
  (method (send-accept self sender-delegate recipient)
    (calling-mobile self sender-delegate
      (lambda ()
        (write-mobile self (get-port sender-delegate) "call" "accept" (list recipient)))))
  
  
  (method (send-decline self sender-delegate recipient)
    (calling-mobile self sender-delegate
      (lambda ()
        (write-mobile self (get-port sender-delegate) "call" "decline" (list recipient)))))
  
  
  (method (send-join self delegate recipient)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "join" (list recipient)))))
  
  
  (method (send-leave self delegate recipient)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "leave" (list recipient)))))
  
  
  (method (send-disband self delegate)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-port delegate) "call" "disband" '()))))
  
  
  ;;;
  ;;;; UDP
  ;;;
  
  
  (method (start-udp-server self)
    (let ((host (effective-host configuration))
          (service (effective-service configuration)))
      (let ((server (new UDP-Server)))
        (start server host service)
        (set! udp-server server)
        (set-?u server))))
  
  
  (method (stop-udp-server self)
    (when udp-server
      (stop udp-server)
      (set! udp-server #f)))
  
  
  ;;;
  ;;;; Detach
  ;;;
  
  
  (method (detach-clients self)
    (for-each (lambda (delegate)
                (if (is? delegate Mobile-Delegate)
                    (send-detach self delegate)
                  (calling-client self delegate
                    (lambda ()
                      (detach-client (get-client delegate))))))
              delegates))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method (stream-list self client)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          "Delegate not found"
        (let ((group (get-group client-delegate))
              (video-extensions (streaming-video-extensions))
              (audio-extensions (streaming-audio-extensions))
              (queue (new-queue)))
          (iterate-streams
            (lambda (file)
              (when (or (member? (get-extension file) video-extensions test: extension=?)
                        (member? (get-extension file) audio-extensions test: extension=?))
                (let ((base (get-base file)))
                  (let ((location (filename-spine (join (subpath {Directory Documents} file) "/"))))
                    (unless (member? location (queue-list queue) key: car test: filename=?)
                      (enqueue queue (list location (if (some? (lambda (stream)
                                                                 (or (not group)
                                                                     (let ((server-stream (find-server-stream udp-server (get-no stream))))
                                                                       (eq? (get-recipient server-stream) group))))
                                                               (find-streams self base))
                                                        'playing
                                                      #f)))))))))
          (queue-list queue)))))
  
  
  (method (make-server-stream self name source-kind video-level creators group (location: location #f))
    (let ((channels (map get-descriptor creators)))
      (bind (stream . server-channels) (server-register-stream self server-sender name server-no source-kind video-level channels group #f #f #t)
        (let ((stream-no (get-no stream)))
          (let ((send-stream (register-send-stream udp-server server-sender name stream-no source-kind video-level)))
            (set-location send-stream location)
            (for-each (lambda (server-channel creator)
                        (let ((create (get-create creator)))
                          (create stream-no (get-no server-channel))))
                      server-channels
                      creators)
            (values stream send-stream))))))
  
  
  (method (stream-invalid self client location)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          "Delegate not found"
        (let ((group (get-group client-delegate)))
          (if (not group)
              "You are not in a group"
            (if (not (string? location))
                "Invalid location"
              (let ((audio? (exists? (new-file {Directory Documents} (add-extension location (audio-profile-extension))))))
                (if audio?
                    #f
                  (if (null? (existing-video-profiles location))
                      "No stream found"
                    #f)))))))))
  
  
  (method (stream-play self client location (delay-streaming? #t))
    (let ((client-delegate (find-delegate self client)))
      (let ((group (get-group client-delegate)))
        (let ((name (filename-name location))
              (audio-file? (exists? (new-file {Directory Documents} (add-extension location (audio-profile-extension))))))
          (let ((audio-channels (if (and audio-file?
                                         (not stream-silent?)
                                         (neq? stream-what 'video))
                                    (list (make-server-audio-channel self location group))
                                  '()))
                (video-channels (if (eq? stream-what 'audio) '() (make-server-video-channels self location group))))
            (let ((video-level (and (not-null? video-channels) (determine-stream-video-level video-channels)))
                  (channels (append audio-channels video-channels)))
              (receive (stream send-stream) (make-server-stream self name 'stream video-level channels group location: location)
                (set-action-proc send-stream stream-controller-action)
                (set-streams group (cons stream (get-streams group)))
                (if delay-streaming?
                    (delay-streaming
                      (lambda ()
                        (play send-stream)))
                  (sleep streaming-delay)
                  (play send-stream)))))))))
  
  
  (method (stream-stop self client location)
    (let ((name (filename-name location)))
      (let ((streams (find-streams self name)))
        (if (null? streams)
            "Stream not found"
          (let ((broadcast-hierarchy? #f))
            (for-each (lambda (stream)
                        (when (server-close-send-stream self stream)
                          (set! broadcast-hierarchy? #t)))
                      streams)
            (when broadcast-hierarchy?
              (broadcast-hierarchy self)))
          #f))))
  
  
  (method (find-streams self name)
    (let ((queue (new-queue)))
      (iterate-table (get-send-streams udp-server)
        (lambda (no stream)
          (when (equal? (get-name stream) name)
            (enqueue queue stream))))
      (queue-list queue)))
  
  
  (method (streaming-channels self)
    (map-table (lambda (no channel)
                 channel)
               (get-send-channels udp-server)))
  
  
  (method (make-server-audio-channel self location group)
    (let ((file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
      (let ((reader (new Stream-Reader file)))
        (let ((media-kind udp-audio)
              (source-kind 'stream)
              (level #f)
              (resolution #f)
              (framerate #f)
              (bitrate #f)
              (codec (get-codec reader))
              (caps (get-caps reader))
              (metadata '()))
          (close reader)
          (new Channel-Creator
            (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
            (lambda (stream-no channel-no)
              (let ((channel (register-send-channel udp-server stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                (let ((src (new File-Stream-Audio-Src
                             location))
                      (sink (new Stream-Frame-Consumer
                              consumer: (lambda (buffer dts pts duration keyframe?)
                                          (send-server-media self channel-no buffer dts pts duration keyframe?)))))
                  (let ((pipeline (pipeline (list src sink))))
                    (set-pipeline channel pipeline))))))))))
  
  
  (method (make-server-video-channels self location group)
    (let ((existing-profiles (existing-video-profiles location)))
      (map (lambda (profile)
             (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
               (let ((reader (new Stream-Reader file)))
                 (let ((media-kind udp-video)
                       (source-kind 'stream)
                       (level (get-level profile)))
                   (let ((resolution (get-resolution reader))
                         (framerate (get-framerate reader))
                         (bitrate (get-bitrate reader))
                         (codec (get-codec reader))
                         (caps (get-caps reader))
                         (metadata (list start: (get-start reader) end: (get-end reader))))
                     (close reader)
                     (new Channel-Creator
                       (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                       (lambda (stream-no channel-no)
                         (let ((channel (register-send-channel udp-server stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                           (let ((src (new File-Stream-Video-Src
                                        profile
                                        location
                                        stream?: (stream-to-group? udp-server channel group)))
                                 (sink (new Stream-Frame-Consumer
                                         consumer: (lambda (buffer dts pts duration keyframe?)
                                                     (send-server-media self channel-no buffer dts pts duration keyframe?)))))
                             (let ((pipeline (pipeline (list src sink))))
                               (set-pipeline channel pipeline)))))))))))
           existing-profiles)))
  
  
  (method package (send-server-media self channel-no buffer dts pts duration keyframe?)
    (when udp-server
      (send-media udp-server channel-no buffer dts pts duration keyframe?)))
  
  
  (method (server-close-send-stream self stream)
    (let ((server-stream (find-server-stream udp-server (get-no stream))))
      (let ((group (get-recipient server-stream)))
        (close-send-stream udp-server stream)
        (set-streams group (remove! server-stream (get-streams group)))
        (maybe-delete-group self #f group))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (world.window:tile-server/clients (non-bot-clients self)))
  
  
  (method override (restore self)
    (world.window:restore-server/clients (non-bot-clients self)))
  
  
  (method (non-bot-clients self)
    (map get-client (collect-if (lambda (delegate)
                                   (not (get-script delegate)))
                                 delegates)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (server-log #f (current-seconds) message)))
  
  
  ;;;
  ;;;; Logger
  ;;;
  
  
  (method package (logger/activity self . rest)
    (let ((message (apply format rest)))
      (logger "{a}" message)
      (broadcast-activity-message self message)))
  
  
  ;;;
  ;;;; Messages
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file self)
    (or log-file
        (let ((file (timestamped-file (new-directory directory "messages") "messages" "txt")))
          (create-directories file)
          (set! log-file file)
          file)))
  
  
  (method (log-message self sender message)
    (call-with-output-file (path-settings (cache-log-file self) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message))))
  
  
  (method (delegate-message self delegate kind recipient message)
    (let ((sender (get-name delegate)))
      (log-message self sender message)
      (case kind
        ((whisper)
         (let ((delegate (find-delegate-by-ci-name self recipient)))
           (if (not delegate)
               (format "Unable to find {a}" recipient)
             (deliver-message self delegate sender kind message)
             #f)))
        ((group)
         (let ((group (get-group delegate)))
           (if (not group)
               (format "You are not in a group")
             (for-each (lambda (delegate)
                           (deliver-message self delegate sender kind message))
                         (get-members group))
             #f)))
        ((gathering)
         (for-each (lambda (delegate)
                     (when (eq? (get-mode delegate) 'observer)
                       (deliver-message self delegate sender kind message)))
                   delegates)
         #f)
        ((server)
         (for-each (lambda (delegate)
                     (deliver-message self delegate sender kind message))
                   delegates)
         #f))))
  
  
  (method (deliver-message self delegate sender kind message)
    (if (get-asleep? delegate)
        (enqueue (get-message-queue delegate) (list sender kind message))
      (if (is? delegate Mobile-Delegate)
          (send-message self delegate sender kind message)
        (let ((client (get-client delegate)))
          (calling-client self delegate
            (lambda ()
              (server-message client sender kind message)))))))
  
  
  (method (deliver-messages self delegate messages)
    (if (is? delegate Mobile-Delegate)
        (send-messages self delegate messages)
      (let ((client (get-client delegate)))
        (calling-client self delegate
          (lambda ()
            (server-messages client messages)))))))


;;;
;;;; Slave
;;;


(definition protected (ready-server)
  (when master-process
    (let ((server (load-object (get-local-register) 'world.server.remote 'world-remote-server)))
      (slave-setup master-process server master-cookie)
      (slave-ready master-process server master-cookie)))))
