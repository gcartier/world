;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.server.tier jazz


(import (jazz.component)
        (jazz.io)
        (jazz.markup)
        (jazz.network)
        (jazz.process)
        (jazz.presence)
        (jazz.zlib)
        (world)
        (world.assets)
        (world.autoload)
        (world.context)
        (world.history)
        (world.id)
        (world.instance)
        (world.io)
        (world.log)
        (world.network)
        (world.scripting)
        (world.server)
        (world.server.client)
        (world.server.serving)
        (world.server.udp)
        (world.settings)
        (world.support))


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                                      getter generate)
  (slot delegates     initialize '()                       getter generate)
  (slot instances     initialize (make-table test: equal?) getter generate)
  (slot zones         initialize '()                       getter generate)
  (slot hits          initialize 0                         getter generate)
  (slot udp-server    initialize #f                        getter generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (set! configuration (get-server-configuration))
    (set! assets (make-assets self directory))
    (let ((id (make-unique-id)))
      (set-client-id/no id (literal->id id self)))
    (reset-last-broadcast)
    (setup-instances self)
    (setup-zones self))
  
  
  (method override (startup self)
    (nextmethod self)
    (start-udp-server self))
  
  
  (method override (enter self)
    (let ((me (current-me+)))
      (when me
        (set-name me (get-character-name configuration))
        (set-avatar me (get-character-avatar configuration)))))
  
  
  (method override (shutdown self)
    (stop-udp-server self)
    (detach-clients self))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state self)
    'started)
    
  
  (method override (start self)
    )
  
  
  (method override (stop self)
    )
  
  
  (method override (restart self)
    )
  
  
  (method override (wait-started self)
    )
  
  
  (method override (wait-stopped self)
    )
  
  
  (method override (server-name self)
    "World")
  
  
  (method override (server-title self)
    "World")
  
  
  (method override (server-version self)
    (process-version (current-process)))
  
  
  (method override (server-host self)
    (host->string (listening-host (get-remote-listener))))
  
  
  (method override (server-service self)
    (port->string (listening-port (get-remote-listener))))
  
  
  (method override (server-hits self)
    hits)
  
  
  (method override (server-debug? self)
    #f)
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (next-literal-id!))
  
  
  (method override (tier-id->literal self id)
    (error "Unregistered id: {s}" id))
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (method (count-alive self)
    (count-if still-alive? delegates))
  
  
  (method package (collect-alive self)
    (sort > (collect-if still-alive? delegates) key: get-alive))
  
  
  (method package (collect-disconnected self)
    (collect-if (lambda (delegate) (not (still-alive? delegate))) delegates))
  
  
  ;;;
  ;;;; Instances
  ;;;
  
  
  (method (find-instance self uuid)
    (table-ref instances uuid #f))


  (method (setup-instances self)
    (let ((instances-dir (instances-dir self)))
      (when (exists? instances-dir)
        (iterate-directory instances-dir
          (lambda (instance-dir)
            (let ((file (new-file instance-dir ".instance")))
              (when (exists? file)
                (let ((instance (instantiate (read-form file))))
                  (let ((uuid (get-name instance)))
                    (table-set! instances uuid instance))))))
          files?: #f
          directories?: #t
          recursive?: #f))))
  
  
  (method (instances-dir self)
    (new-directory directory "instances"))
  
  
  ;;;
  ;;;; Zones
  ;;;


  (method (setup-zones self)
    (let ((zones-dir (zones-dir self))
          (queue (new-queue)))
      (when (exists? zones-dir)
        (iterate-directory zones-dir
          (lambda (path kind)
            (let ((zone-dir (new-directory zones-dir path)))
              (let ((file (new-file zone-dir ".zone")))
                (when (exists? file)
                  (enqueue queue path)))))
          full?: #f
          files?: #f
          directories?: #t
          recursive?: #t))
      (set! zones (queue-list queue))))
  
  
  (method package (zones-dir self)
    (new-directory directory "zones"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (setup-me self)
    (setup-current-me self)
    (register-id (current-me) (make-unique-id)))
  
  
  (method override (save-me self)
    (save-current-me self))
  
  
  (method override (player-file self)
    (new-file directory '("start" ".player")))
  
  
  (method override (anonymous self)
    "Server")
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method package (client-connect self client character-name character-avatar character-script character-zone)
    (let ((zone (current-zone)))
      (let ((max-connections (world-setting 'world.server-max-connections #f)))
        (if (and max-connections (>= (count-alive self) max-connections))
            (format "Server max {a} connections reached" max-connections)
          (let ((existing-delegate (find-delegate-by-name self character-name)))
            ;; open test first draft at reconnection
            (let ((reconnected-delegate
                    (and existing-delegate
                         (or (get-exception existing-delegate)
                             (not (still-alive? existing-delegate))
                             (not (alive? (get-client existing-delegate))))
                         existing-delegate)))
              (if (and existing-delegate
                       (not reconnected-delegate))
                  (format "Character {a} is unavailable" character-name)
                ;; register client
                (let ((delegate (if (not reconnected-delegate)
                                    (let ((id (make-unique-id)))
                                      (new Client-Delegate client 'connected id (literal->id id self) character-name character-avatar character-script))
                                  (set-client reconnected-delegate client)
                                  (set-alive reconnected-delegate (current-seconds))
                                  (set-exception reconnected-delegate #f)
                                  (set-exception-time reconnected-delegate #f)
                                  reconnected-delegate)))
                  (unless reconnected-delegate
                    (set! delegates (cons delegate delegates)))
                  ;; retrieve character
                  (let ((client-id (get-id delegate))
                        (client-no (get-no delegate))
                        (character (character-retrieve self character-name character-avatar))
                        (character-delegate delegate))
                    (set-character character-delegate character)
                    ;; join character zone
                    (let ((character-zone (or character-zone (get-zone character))))
                      (let ((processor (spawn-processor (get-host configuration) (get-service configuration) character-zone)))
                        (let ((join-info (client-enter processor client client-id client-no character-name character-avatar character-script)))
                          (if (string? join-info)
                              join-info
                            (set-zone character-delegate character-zone)
                            (set-processor character-delegate processor)
                            (bind (form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) join-info
                              (let ((assets #f)
                                    (welcome (cond (arc-en-ciel? "Bienvenue Arc-en-ciel!")
                                                   (open-test? "Welcome to the Yownu open test!")
                                                   (else "Welcome to Yownu!"))))
                                (rebroadcast-draws)
                                (list client-id client-no assets (proxy-connection-info client processor) welcome form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players))))))))))))))))
  
  
  (method package (client-start self client)
    (let ((delegate (find-delegate self client)))
      (set-state delegate 'started)
      (broadcast-peers self)))
  
  
  (method package (client-stop self client)
    (let ((delegate (find-delegate self client)))
      (set-state delegate 'stopped)
      (broadcast-peers self)))
  
  
  (method package (client-disconnect self client character-name)
    (let ((zone (current-zone)))
      ;; find server client
      (let ((character-delegate (find-delegate self client)))
          ;; store character
        (character-store self (get-character character-delegate))
        ;; leave zone
        (client-exit (get-processor character-delegate) client character-name)
        ;; unregister client
        (set! delegates (remove! character-delegate delegates))
        ;; update state
        (set-state character-delegate 'disconnected))))
  
  
  (method (broadcast-peers self)
    (let ((peers '()))
      (iterate-table (get-origin-connections udp-server)
        (lambda (origin connection)
          (let ((delegate (find-delegate-by-no self origin)))
            (when (and delegate (eq? (get-state delegate) 'started))
              (let ((host (get-host connection))
                    (port (get-port connection))
                    (local-host (get-local-host connection))
                    (local-port (get-local-port connection)))
                (set! peers (cons (list origin host port local-host local-port) peers)))))))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (peers-update client peers))))))
                delegates)))
  
  
  (method (character-retrieve self character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file (characters-dir self) (format "{a}.character" character-name))))
        (let ((character
                (if (exists? file)
                    (let ((character (instantiate (read-form file))))
                      (set-name character character-name)
                      (set-avatar character character-avatar)
                      character)
                  (let ((units '(world.character)))
                    (let ((tag '(<Character>))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin form file)
                        (let ((character (instantiate form)))
                          (set-name character character-name)
                          (set-avatar character character-avatar)
                          (set-zone character 'start)
                          character)))))))
          character))))
  
  
  (method (character-store self character)
    (let ((zone (current-zone)))
      (let ((file (new-file (characters-dir self) (format "{a}.character" (get-name character)))))
        (create-directories file)
        (let ((designer (new Former form: (get-form character) reference: character)))
          (define (save-character)
            (set-property designer character 'zone (get-zone character)))
          
          (save-character)
          (save designer)))))
  
  
  (method (characters-dir self)
    (new-directory directory "characters"))
  
  
  (method package (client-alive self client)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (when delegate
        (set-alive delegate (current-seconds)))))
  
  
  (method package (client-message self client kind recipient message)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (when delegate
        (let ((sender (get-name delegate)))
          (log-message self sender message)
          (for-each (lambda (delegate)
                      (let ((client (get-client delegate)))
                        (when (or (neq? kind 'whisper)
                                  (ci=? (get-name delegate) recipient))
                          (calling-client self delegate
                            (lambda ()
                              (server-message client sender kind message))))))
                    delegates)))))
  
  
  (method package (client-log self client time message)
    (server-log client time message))
  
  
  (method package (processor-log self processor time message)
    (server-log processor time message))
  
  
  (method package (client-connected-player self client no)
    (connected-player self no))
  
  
  (method override (connected-player self no)
    (if (= no client-no)
        "Server"
      (let ((delegate (find-delegate-by-no self no)))
        (and delegate
             (get-name delegate)))))
  
  
  (method package (client-connected-players self client)
    (connected-players self))
  
  
  (method package (client-available-templates self client)
    (available-templates self))
  
  
  (method package (client-available-zone-base self client from)
    (available-zone-base self from))
  
  
  (method package (client-available-zone-base? self client base)
    (available-zone-base? self base))
  
  
  (method package (client-create-zone self client from base)
    (and (create-zone self from base)
         (list 'zone base)))
  
  
  (method package (client-available-zones self client)
    (available-zones self))
  
  
  (method package (client-change-zone self client zone)
    (change-client-zone self client zone))
  
  
  (method override (connected-players self)
    (map (lambda (delegate)
           (let ((zone (get-zone delegate)))
             (list (get-name delegate) zone (present-zone self zone))))
         delegates))
  
  
  (method override (retrieve-entity self id)
    (find-entity id))
  
  
  (method override (available-templates self)
    (collect-templates))
  
  
  (method override (available-zone-base self from)
    (unique-zone-base from))
  
  
  (method override (available-zone-base? self base)
    (zone-base-available? base))
  
  
  (method override (create-zone self from base)
    (prog1 (create-new-zone from base
             create: (lambda (dir)
                       (create (new-directory dir "players")))
             open: (lambda (file)
                     #f))
      (setup-zones self)))
  
  
  (method override (available-zones self)
    (let ((queue (new-queue)))
      (iterate-table instances
        (lambda (uuid instance)
          (enqueue queue (cons (list 'instance uuid)
                               (format "{a}{? <{a}>~}" (join (get-template instance) "/") (+ (get-rank instance) 1))))))
      (for-each (lambda (path)
                  (enqueue queue (cons (cons 'zone path)
                                       (last path))))
                zones)
      (queue-list queue)))
  
  
  (method override (change-zone self zone)
    (change-server-zone self zone))
  
  
  (method (change-client-zone self client zone)
    (let ((delegate (find-delegate self client)))
      (let ((client-id (get-id delegate))
            (client-no (get-no delegate))
            (character-name (get-name delegate))
            (character-avatar (get-avatar delegate))
            (character-script (get-script delegate)))
        ;; leave
        (client-exit (get-processor delegate) client character-name)
        ;; join
        (let ((processor (spawn-processor (get-host configuration) (get-service configuration) zone)))
          (let ((join-info (client-enter processor client client-id client-no character-name character-avatar character-script)))
            (set-zone delegate zone)
            (set-processor delegate processor)
            (cons (proxy-connection-info client processor) join-info))))))
  
  
  ;; todo
  (method (change-server-zone self zone)
    )
  
  
  (method (present-zone self zone)
    (if (eq? zone 'start)
        "<Start Zone>"
      (case (car zone)
        ((instance)
         (let ((instance (find-instance self (cadr zone))))
           (format "{a}{? <{a}>~}" (get-name (get-template instance)) (+ (get-rank instance) 1))))
        (else
         (last zone)))))
  
  
  (method package (retrieve-asset self path)
    #f)
  
  
  (method package (register-literal self literal)
    (literal->id literal))
  
  
  (method package (registered-id self id)
    (id->literal id))
  
  
  (method (find-delegate self target)
    (find-if (lambda (delegate)
               (proxy=? (get-client delegate) target))
             delegates))
  
  
  (method (find-delegate-by-name self target)
    (find-if (lambda (delegate)
               (equal? (get-name delegate) target))
             delegates))
  
  
  (method (find-delegate-by-no self no)
    (find-if (lambda (delegate)
               (= (get-no delegate) no))
             delegates))
  
  
  ;; todo
  (method (check-clients-liveliness self)
    )
  
  
  (method package (tile-server self)
    (tile self))
  
  
  (method package (restore-server self)
    (restore self))
  
  
  ;;;
  ;;;; UDP
  ;;;
  
  
  (method (start-udp-server self)
    (let ((host (get-host configuration))
          (service (get-service configuration)))
      (let ((server (new UDP-Server)))
        (start server host service)
        (set! udp-server server))))
  
  
  (method (stop-udp-server self)
    (when udp-server
      (stop udp-server)
      (set! udp-server #f)))
  
  
  ;;;
  ;;;; Detach
  ;;;
  
  
  (method (detach-clients self)
    (for-each (lambda (delegate)
                (calling-client self delegate
                  (lambda ()
                    (detach-client (get-client delegate)))))
              delegates))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (world.window:tile-server/clients (non-bot-clients self)))
  
  
  (method override (restore self)
    (world.window:restore-server/clients (non-bot-clients self)))
  
  
  (method (non-bot-clients self)
    (map get-client (collect-if (lambda (delegate)
                                   (not (get-script delegate)))
                                 delegates)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (server-log #f (current-seconds) message)))
  
  
  ;;;
  ;;;; Simulate
  ;;;
  
  
  (method package (protocol-simulation self kind)
    (define (setup-protocol-simulation server-protocol clients-protocol)
      @convert-to-presence
      (for-each (lambda (delegate)
                  (let ((client (get-client delegate)))
                    (let ((uuid (get-uuid (get-ior client))))
                      (let ((connection (require-remote-connection uuid)))
                        (set-protocol connection clients-protocol)))
                    (server-protocol client server-protocol)))
                delegates))
    
    (case kind
      ((none) (setup-protocol-simulation #f #f))
      ((slow) (setup-protocol-simulation .05 .1))
      ((awful) (setup-protocol-simulation .25 .5))
      (else (error "Unknown protocol simulation: {a}" kind))))
  
  
  ;;;
  ;;;; Messages
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file self)
    (or log-file
        (let ((zone (current-zone)))
          (let ((file (timestamped-file (new-directory directory "messages") "messages" "txt")))
            (create-directories file)
            (set! log-file file)
            file))))
  
  
  (method (log-message self sender message)
    (call-with-output-file (path-settings (cache-log-file self) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message)))))


;;;
;;;; Slave
;;;


(definition protected (ready-server)
  (when master-process
    (let ((server (load-object (get-local-register) 'world.server.remote 'world-remote-server)))
      (slave-setup master-process server master-cookie)
      (slave-ready master-process server master-cookie)))))
