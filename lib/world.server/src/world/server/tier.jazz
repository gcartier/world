;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.server.tier jazz


(import (jazz.component)
        (jazz.io)
        (jazz.markup)
        (jazz.network)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.settings)
        (jazz.zlib)
        (world)
        (world.assets)
        (world.autoload)
        (world.context)
        (world.history)
        (world.id)
        (world.instance)
        (world.log)
        (world.network)
        (world.scripting)
        (world.server)
        (world.server.client)
        (world.server.serving)
        (world.settings)
        (world.syntax (phase syntax))
        (world.tier))


(definition audio-self?
  (world-setting 'world.audio-self? #f))

(definition video-self?
  (world-setting 'world.video-self? #f))


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                                      getter generate)
  (slot delegates     initialize '()                       getter generate)
  (slot instances     initialize (make-table test: equal?) getter generate)
  (slot zones         initialize '()                       getter generate)
  (slot hits          initialize 0                         getter generate)
  (slot udp-server    initialize #f                        getter generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (set! configuration (get-server-configuration))
    (set! assets (make-assets self directory))
    (let ((id (make-unique-id)))
      (set-client-id/no id (literal->id id self)))
    (reset-last-broadcast)
    (setup-instances self)
    (setup-zones self))
  
  
  (method override (startup self)
    (nextmethod self)
    (start-udp-server self))
  
  
  (method override (enter self)
    (let ((me (current-me+)))
      (when me
        (set-name me (get-character-name configuration))
        (set-avatar me (get-character-avatar configuration)))))
  
  
  (method override (shutdown self)
    (stop-udp-server self)
    (detach-clients self))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state self)
    'started)
    
  
  (method override (start self)
    )
  
  
  (method override (stop self)
    )
  
  
  (method override (restart self)
    )
  
  
  (method override (wait-started self)
    )
  
  
  (method override (wait-stopped self)
    )
  
  
  (method override (server-name self)
    "World")
  
  
  (method override (server-title self)
    "World")
  
  
  (method override (server-version self)
    (process-version (current-process)))
  
  
  (method override (server-host self)
    (host->string (listening-host (get-remote-listener))))
  
  
  (method override (server-service self)
    (port->string (listening-port (get-remote-listener))))
  
  
  (method override (server-hits self)
    hits)
  
  
  (method override (server-debug? self)
    #f)
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (next-literal-id!))
  
  
  (method override (tier-id->literal self id)
    (error "Unregistered id: {s}" id))
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (method (count-alive self)
    (count-if still-alive? delegates))
  
  
  (method package (collect-alive self)
    (sort > (collect-if still-alive? delegates) key: get-alive))
  
  
  (method package (collect-disconnected self)
    (collect-if (lambda (delegate) (not (still-alive? delegate))) delegates))
  
  
  ;;;
  ;;;; Instances
  ;;;
  
  
  (method (find-instance self uuid)
    (table-ref instances uuid #f))


  (method (setup-instances self)
    (let ((instances-dir (instances-dir self)))
      (when (exists? instances-dir)
        (iterate-directory instances-dir
          (lambda (instance-dir)
            (let ((file (new-file instance-dir ".instance")))
              (when (exists? file)
                (let ((instance (instantiate (read-form file))))
                  (let ((uuid (get-name instance)))
                    (table-set! instances uuid instance))))))
          files?: #f
          directories?: #t
          recursive?: #f))))
  
  
  (method (instances-dir self)
    (new-directory directory "instances"))
  
  
  ;;;
  ;;;; Zones
  ;;;


  (method (setup-zones self)
    (let ((zones-dir (zones-dir self))
          (queue (new-queue)))
      (when (exists? zones-dir)
        (iterate-directory zones-dir
          (lambda (path kind)
            (let ((zone-dir (new-directory zones-dir path)))
              (let ((file (new-file zone-dir ".zone")))
                (when (exists? file)
                  (enqueue queue path)))))
          full?: #f
          files?: #f
          directories?: #t
          recursive?: #t))
      (set! zones (queue-list queue))))
  
  
  (method package (zones-dir self)
    (new-directory directory "zones"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (setup-me self)
    (setup-current-me self)
    (register-id (current-me) (make-unique-id)))
  
  
  (method override (save-me self)
    (save-current-me self))
  
  
  (method override (player-file self)
    (new-file directory '("start" ".player")))
  
  
  (method override (anonymous self)
    "Server")
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method package (client-connect self client character-name character-avatar character-script character-zone)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((max-connections (world-setting 'world.server-max-connections #f)))
        (if (and max-connections (>= (count-alive self) max-connections))
            (format "Server max {a} connections reached" max-connections)
          (let ((existing-delegate (find-delegate-by-name self character-name)))
            ;; open test first draft at reconnection
            (let ((reconnected-delegate
                    (and existing-delegate
                         (or (get-exception existing-delegate)
                             (not (still-alive? existing-delegate))
                             (not (alive? (get-client existing-delegate))))
                         existing-delegate)))
              (if (and existing-delegate
                       (not reconnected-delegate))
                  (format "Character {a} is unavailable" character-name)
                ;; register client
                (let ((delegate (if (not reconnected-delegate)
                                    (let ((id (make-unique-id)))
                                      (new Client-Delegate client id (literal->id id self) character-name character-avatar character-script))
                                  (set-client reconnected-delegate client)
                                  (set-alive reconnected-delegate (current-seconds))
                                  (set-exception reconnected-delegate #f)
                                  (set-exception-time reconnected-delegate #f)
                                  reconnected-delegate)))
                  (unless reconnected-delegate
                    (set! delegates (cons delegate delegates)))
                  ;; retrieve character
                  (let ((client-id (get-id delegate))
                        (client-no (get-no delegate))
                        (character (character-retrieve self character-name character-avatar))
                        (character-delegate delegate))
                    (set-character character-delegate character)
                    ;; join character zone
                    (let ((character-zone (or character-zone (get-zone character))))
                      (let ((processor (spawn-processor (get-host configuration) (get-service configuration) character-zone)))
                        (let ((join-info (client-enter processor client client-id client-no character-name character-avatar character-script)))
                          (if (string? join-info)
                              join-info
                            (set-zone character-delegate character-zone)
                            (set-processor character-delegate processor)
                            (bind (form spawnpoint player-spawnpoint player-id player-position player-lookat other-players) join-info
                              (when (window?)
                                (if reconnected-delegate
                                    (display-message world (format "{a} reconnected" character-name))
                                  (display-message world (format "{a} entered world" character-name))))
                              (let ((assets #f)
                                    (welcome (cond (arc-en-ciel? "Bienvenue Arc-en-ciel!")
                                                   (open-test? "Welcome to the Yownu open test!")
                                                   (else "Welcome to Yownu!"))))
                                (rebroadcast-draws)
                                (list client-id client-no assets (proxy-connection-info client processor) welcome form spawnpoint player-spawnpoint player-id player-position player-lookat other-players))))))))))))))))
  
  
  (method package (client-disconnect self client character-name)
    (let ((world (current-world))
          (zone (current-zone)))
      ;; find server client
      (let ((character-delegate (find-delegate self client)))
          ;; store character
        (character-store self (get-character character-delegate))
        ;; leave zone
        (client-exit (get-processor character-delegate) client character-name)
        ;; unregister client
        (set! delegates (remove! character-delegate delegates)))
      (when (window?)
        (display-message world (format "{a} exited world" character-name)))))
  
  
  (method (character-retrieve self character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file (characters-dir self) (format "{a}.character" character-name))))
        (let ((character
                (if (exists? file)
                    (let ((character (instantiate (read-form file))))
                      (set-name character character-name)
                      (set-avatar character character-avatar)
                      character)
                  (let ((units '(world.data)))
                    (let ((tag '(<Character>))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin form file)
                        (let ((character (instantiate form)))
                          (set-name character character-name)
                          (set-avatar character character-avatar)
                          (set-zone character 'start)
                          character)))))))
          character))))
  
  
  (method (character-store self character)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file (characters-dir self) (format "{a}.character" (get-name character)))))
        (create-directories file)
        (let ((designer (new Former form: (get-form character) reference: character)))
          (define (save-character)
            (set-property designer character 'zone (get-zone character)))
          
          (save-character)
          (save designer)))))
  
  
  (method (characters-dir self)
    (new-directory directory "characters"))
  
  
  (method package (client-alive self client)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (when delegate
        (set-alive delegate (current-seconds)))))
  
  
  (method package (client-audio self client buffer timestamp duration)
    (broadcast-server-audio self client buffer timestamp duration))
  
  
  (method package (client-video self client buffer timestamp duration)
    (broadcast-server-video self client buffer timestamp duration))
  
  
  (method package (client-message self client kind recipient message)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (when delegate
        (let ((sender (get-name delegate)))
          (log-message self sender message)
          (for-each (lambda (delegate)
                      (let ((client (get-client delegate)))
                        (when (or (neq? kind 'whisper)
                                  (ci=? (get-name delegate) recipient))
                          (calling-client self delegate
                            (lambda ()
                              (server-message client sender kind message))))))
                    delegates)))))
  
  
  (method package (client-log self client time message)
    (server-log client time message))
  
  
  (method package (processor-log self processor time message)
    (server-log processor time message))
  
  
  (method package (client-connected-player self client no)
    (connected-player self no))
  
  
  (method override (connected-player self no)
    (if (= no client-no)
        "Server"
      (let ((delegate (find-delegate-by-no self no)))
        (and delegate
             (get-name delegate)))))
  
  
  (method package (client-connected-players self client)
    (connected-players self))
  
  
  (method package (client-available-templates self client)
    (available-templates self))
  
  
  (method package (client-available-zone-base self client from)
    (available-zone-base self from))
  
  
  (method package (client-available-zone-base? self client base)
    (available-zone-base? self base))
  
  
  (method package (client-create-zone self client from base)
    (and (create-zone self from base)
         (list 'zone base)))
  
  
  (method package (client-available-zones self client)
    (available-zones self))
  
  
  (method package (client-change-zone self client zone)
    (change-client-zone self client zone))
  
  
  (method override (connected-players self)
    (map (lambda (delegate)
           (let ((zone (get-zone delegate)))
             (list (get-name delegate) zone (present-zone self zone))))
         delegates))
  
  
  (method override (retrieve-entity self id)
    (find-entity id))
  
  
  (method override (available-templates self)
    (let ((world (current-world)))
      (collect-templates world)))
  
  
  (method override (available-zone-base self from)
    (let ((world (current-world)))
      (unique-zone-base world from)))
  
  
  (method override (available-zone-base? self base)
    (let ((world (current-world)))
      (zone-base-available? world base)))
  
  
  (method override (create-zone self from base)
    (let ((world (current-world)))
      (prog1 (create-new-zone world from base
               create: (lambda (dir)
                         (create (new-directory dir "players")))
               open: (lambda (file)
                       #f))
        (setup-zones self))))
  
  
  (method override (available-zones self)
    (let ((queue (new-queue)))
      @wait
      (iterate-table instances
        (lambda (uuid instance)
          (enqueue queue (cons (list 'instance uuid)
                               (format "{a}{? <{a}>~}" (join (get-template instance) "/") (+ (get-rank instance) 1))))))
      (for-each (lambda (path)
                  (enqueue queue (cons (cons 'zone path)
                                       (last path))))
                zones)
      (queue-list queue)))
  
  
  (method override (change-zone self zone)
    (change-server-zone self zone))
  
  
  (method (change-client-zone self client zone)
    (let ((delegate (find-delegate self client)))
      (let ((client-id (get-id delegate))
            (client-no (get-no delegate))
            (character-name (get-name delegate))
            (character-avatar (get-avatar delegate))
            (character-script (get-script delegate)))
        ;; leave
        (client-exit (get-processor delegate) client character-name)
        ;; join
        (let ((processor (spawn-processor (get-host configuration) (get-service configuration) zone)))
          (let ((join-info (client-enter processor client client-id client-no character-name character-avatar character-script)))
            (set-zone delegate zone)
            (set-processor delegate processor)
            (cons (proxy-connection-info client processor) join-info))))))
  
  
  ;; todo
  (method (change-server-zone self zone)
    )
  
  
  (method (present-zone self zone)
    (if (eq? zone 'start)
        "<Start Zone>"
      (case (car zone)
        ((instance)
         (let ((instance (find-instance self (cadr zone))))
           (format "{a}{? <{a}>~}" (get-name (get-template instance)) (+ (get-rank instance) 1))))
        (else
         (last zone)))))
  
  
  (method package (retrieve-asset self path)
    #f)
  
  
  (method package (register-literal self literal)
    (literal->id literal))
  
  
  (method package (registered-id self id)
    (id->literal id))
  
  
  (method (find-delegate self target)
    (find-if (lambda (delegate)
               (proxy=? (get-client delegate) target))
             delegates))
  
  
  (method (find-delegate-by-name self target)
    (find-if (lambda (delegate)
               (equal? (get-name delegate) target))
             delegates))
  
  
  (method (find-delegate-by-no self no)
    (find-if (lambda (delegate)
               (= (get-no delegate) no))
             delegates))
  
  
  ;; todo
  (method (check-clients-liveliness self)
    )
  
  
  (method package (tile-server self)
    (tile self))
  
  
  (method package (restore-server self)
    (restore self))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (broadcast-server-audio self origin-client buffer timestamp duration)
    (let ((tier (current-tier))
          (id (get-id (find-delegate self origin-client))))
      (for-each (lambda (delegate)
                  (let ((client (get-client delegate)))
                    (when (or (not (proxy=? client origin-client))
                              (world-setting 'world.audio-self? #f))
                      (calling-client tier delegate
                        (lambda ()
                          (server-audio client id buffer timestamp duration))))))
                delegates)))
  
  
  (method (broadcast-server-video self origin-client buffer timestamp duration)
    (let ((tier (current-tier))
          (id (get-id (find-delegate self origin-client))))
      (for-each (lambda (delegate)
                  (let ((client (get-client delegate)))
                    (when (or (not (proxy=? client origin-client))
                              (world-setting 'world.video-self? #f))
                      (calling-client tier delegate
                        (lambda ()
                          (server-video client id buffer timestamp duration))))))
                delegates)))
  
  
  ;;;
  ;;;; UDP
  ;;;
  
  
  (method (start-udp-server self)
    (let ((host (get-host configuration))
          (service (get-service configuration)))
      (let ((server (new UDP-Server)))
        (start server host service)
        (set! udp-server server))))
  
  
  (method (stop-udp-server self)
    (when udp-server
      (stop udp-server)
      (set! udp-server #f)))
  
  
  ;;;
  ;;;; Detach
  ;;;
  
  
  (method (detach-clients self)
    (for-each (lambda (delegate)
                (calling-client self delegate
                  (lambda ()
                    (detach-client (get-client delegate)))))
              delegates))
  
  
  ;;;
  ;;;; Pause
  ;;;
  
  
  (method package (pause self)
    (let ((world (current-world))
          (history (current-history)))
      (cond ((not (get-paused? history))
             (pause-world world)
             (for-each (lambda (delegate)
                         (calling-client self delegate
                           (lambda ()
                             (pause-client (get-client delegate)))))
                       delegates))
            (else
             (for-each (lambda (delegate)
                         (calling-client self delegate
                           (lambda ()
                             (unpause-client (get-client delegate)))))
                       delegates)
             (unpause-world world)))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (world.window:tile-server/clients (non-bot-clients self)))
  
  
  (method override (restore self)
    (world.window:restore-server/clients (non-bot-clients self)))
  
  
  (method (non-bot-clients self)
    (map get-client (collect-if (lambda (delegate)
                                   (not (get-script delegate)))
                                 delegates)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (server-log #f (current-seconds) message)))
  
  
  ;;;
  ;;;; Simulate
  ;;;
  
  
  (method package (protocol-simulation self kind)
    (define (setup-protocol-simulation server-protocol clients-protocol)
      @convert-to-presence
      (for-each (lambda (delegate)
                  (let ((client (get-client delegate)))
                    (let ((uuid (get-uuid (get-ior client))))
                      (let ((connection (require-remote-connection uuid)))
                        (set-protocol connection clients-protocol)))
                    (server-protocol client server-protocol)))
                delegates))
    
    (case kind
      ((none) (setup-protocol-simulation #f #f))
      ((slow) (setup-protocol-simulation .05 .1))
      ((awful) (setup-protocol-simulation .25 .5))
      (else (error "Unknown protocol simulation: {a}" kind))))
  
  
  ;;;
  ;;;; Messages
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file self)
    (or log-file
        (let ((zone (current-zone)))
          (let ((file (timestamped-file (new-directory directory "messages") "messages" "txt")))
            (create-directories file)
            (set! log-file file)
            file))))
  
  
  (method (log-message self sender message)
    (call-with-output-file (path-settings (cache-log-file self) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message)))))


;;;
;;;; UDP Server
;;;


(definition udp-debug?
  (world-setting 'world.udp-debug? #f))


(class UDP-Server extends Object
  
  
  (slot udp-port    initialize #f getter generate)
  (slot udp-thread  initialize #f getter generate)
  (slot connections initialize #f getter generate)
  (slot stopping?   initialize #f getter generate)
  
  
  (method (start self host service)
    (when udp-debug?
      (terminal (get-remote-name) 'listen host service))
    (set! udp-port (open-udp (list
                               local-address: host
                               local-port-number: service)))
    (set! udp-thread (new-thread
                       (lambda ()
                         (process self))
                       'udp))
    (set! connections '())
    (set! stopping? #f)
    (thread-start! udp-thread))
  
  
  (method (stop self)
    (set! stopping? #t)
    (close-port udp-port)
    (thread-join! udp-thread)
    (set! udp-port #f)
    (set! udp-thread #f))
  
  
  (method (process self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((data (with-exception-filter
                    (lambda (exc)
                      stopping?)
                    (lambda (exc)
                      #f)
                    (lambda ()
                      (read udp-port)))))
        (when data
          (process-data self data)
          (loop)))))
  
  
  (method (process-data self data)
    (define (extract-kind)
      (let ((b1 (u8vector-ref data 0))
            (b2 (u8vector-ref data 1))
            (b3 (u8vector-ref data 2))
            (b4 (u8vector-ref data 3)))
        (bytes->32-bit-integer b1 b2 b3 b4)))
    
    (let ((kind (extract-kind)))
      (ecase kind
        ((udp-connect)
         (connect-source self))
        ((udp-chunk udp-audio udp-audio-off udp-video udp-video-off)
         (broadcast-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (connect-source self)
    (let ((source-info (udp-source-socket-info udp-port)))
      (let ((source-host (socket-info-address source-info))
            (source-port (socket-info-port-number source-info)))
        (when udp-debug?
          (terminal (get-remote-name) 'connect source-host source-port))
        (let ((connection (new UDP-Connection source-host source-port)))
          (set! connections (cons connection connections))))))
  
  
  (method (broadcast-media self kind data)
    (let ((source-info (udp-source-socket-info udp-port)))
      (let ((source-host (socket-info-address source-info))
            (source-port (socket-info-port-number source-info)))
        (when udp-debug?
          (terminal (get-remote-name) 'broadcast source-host source-port (udp-name kind) (u8vector-length data)))
        (for-each (lambda (connection)
                    (let ((host (get-host connection))
                          (port (get-port connection)))
                      (when (or (not (host=? host source-host))
                                (not (service=? port source-port))
                                ;; quicky
                                (or audio-self? video-self?)
                                @wait-channel-in-chunk (and (= kind udp-audio) audio-self?)
                                @wait-channel-in-chunk (and (= kind udp-video) video-self?))
                        (udp-destination-set! host port udp-port)
                        (write data udp-port))))
                  connections)))))


;;;
;;;; UDP Connection
;;;


(class UDP-Connection extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Slave
;;;


(definition protected (ready-server)
  (when master-process
    (let ((server (load-object (get-local-register) 'world.server.remote 'world-remote-server)))
      (slave-setup master-process server master-cookie)
      (slave-ready master-process server master-cookie)))))
