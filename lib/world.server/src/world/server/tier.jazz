;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.server.tier jazz


(import (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.io)
        (jazz.logger)
        (jazz.markup)
        (jazz.network)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.zlib)
        (world)
        (world.audio)
        (world.assets)
        (world.autoload)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.history)
        (world.id)
        (world.instance)
        (world.io)
        (world.log)
        (world.network)
        (world.profiling)
        (world.scripting)
        (world.server)
        (world.server.client)
        (world.server.group)
        (world.server.serving)
        (world.server.udp)
        (world.settings)
        (world.streaming)
        (world.stub)
        (world.support)
        (world.task)
        (world.udp)
        (world.video))


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                                       getter generate)
  (slot delegates      initialize '()                       getter generate)
  (slot disconnected   initialize '()                       getter generate)
  (slot instances      initialize (make-table test: equal?) getter generate)
  (slot zones          initialize '()                       getter generate)
  (slot groups         initialize '()                       getter generate)
  (slot hits           initialize 0                         getter generate)
  (slot aliveness-task initialize #f                        getter generate)
  (slot udp-server     initialize #f                        getter generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (set-connection-problem-handler
      (lambda (process connection remote-uuid)
        (catch (connection-exception? exc
                 (let ((delegate (find-delegate-by-uuid self remote-uuid)))
                   (when delegate
                     (set-exception delegate exc)
                     (set-exception-time delegate (current-seconds))
                     (delay-disconnected-client self delegate))))
          (process connection remote-uuid))))
    (set! configuration (get-server-configuration))
    (set! assets (make-assets self directory))
    (let ((id (make-unique-id)))
      ;; not sure about this, for now lets use the hardcoded server-no = 0
      (set-client-id/no id server-no @w (literal->id id self)))
    (reset-last-broadcast)
    (setup-instances self)
    (setup-zones self))
  
  
  (method override (startup self)
    (nextmethod self)
    (start-aliveness-task self)
    (start-udp-server self))
  
  
  (method override (enter self)
    (let ((me (current-me+)))
      (when me
        (set-name me (get-character-name configuration))
        (set-avatar me (get-character-avatar configuration)))))
  
  
  (method override (shutdown self)
    (stop-udp-server self)
    (stop-aliveness-task self)
    (detach-clients self))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state self)
    'started)
    
  
  (method override (start self)
    )
  
  
  (method override (stop self)
    )
  
  
  (method override (restart self)
    )
  
  
  (method override (wait-started self)
    )
  
  
  (method override (wait-stopped self)
    )
  
  
  (method override (server-name self)
    "World")
  
  
  (method override (server-title self)
    "World")
  
  
  (method override (server-version self)
    (process-version (current-process)))
  
  
  (method override (server-host self)
    (host->string (listening-host (get-remote-listener))))
  
  
  (method override (server-service self)
    (port->string (listening-port (get-remote-listener))))
  
  
  (method override (server-hits self)
    hits)
  
  
  (method override (server-debug? self)
    #f)
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (next-literal-id!))
  
  
  (method override (tier-id->literal self id)
    (error "Unregistered id: {s}" id))
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (method (count-alive self)
    (length delegates))
  
  
  (method package (collect-alive self)
    (sort ci<? delegates key: get-name))
  
  
  (method package (collect-disconnected self)
    disconnected)
  
  
  ;;;
  ;;;; Instances
  ;;;
  
  
  (method (find-instance self uuid)
    (table-ref instances uuid #f))


  (method (setup-instances self)
    (let ((instances-dir (instances-dir self)))
      (when (exists? instances-dir)
        (iterate-directory instances-dir
          (lambda (instance-dir)
            (let ((file (new-file instance-dir ".instance")))
              (when (exists? file)
                (let ((instance (instantiate (read-form file))))
                  (let ((uuid (get-name instance)))
                    (table-set! instances uuid instance))))))
          files?: #f
          directories?: #t
          recursive?: #f))))
  
  
  (method (instances-dir self)
    (new-directory directory "instances"))
  
  
  ;;;
  ;;;; Zones
  ;;;


  (method (setup-zones self)
    (let ((zones-dir (zones-dir self))
          (queue (new-queue)))
      (when (exists? zones-dir)
        (iterate-directory zones-dir
          (lambda (path kind)
            (let ((zone-dir (new-directory zones-dir path)))
              (let ((file (new-file zone-dir ".zone")))
                (when (exists? file)
                  (enqueue queue path)))))
          full?: #f
          files?: #f
          directories?: #t
          recursive?: #t))
      (set! zones (queue-list queue))))
  
  
  (method package (zones-dir self)
    (new-directory directory "zones"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (setup-me self)
    (setup-current-me self)
    (register-id (current-me) (make-unique-id)))
  
  
  (method override (save-me self)
    (save-current-me self))
  
  
  (method override (player-file self)
    (new-file directory '("start" ".player")))
  
  
  (method override (anonymous self)
    "Server")
  
  
  ;;;
  ;;;; Groups
  ;;;
  
  
  (method (find-group self name)
    (find-if (lambda (group)
               (equal? (get-name group) name))
             groups))
  
  
  (method (create-group self name)
    (let ((group (new Server-Group name)))
      (set! groups (cons group groups))
      group))
  
  
  (method (delete-group self group)
    (set! groups (remove! group groups)))
  
  
  (method (disband-group self group)
    (for-each (lambda (delegate)
                (leave-group self group delegate))
              (get-members group))
    (set! groups (remove! group groups)))
  
  
  (method (has-members? self group)
    (not-null? (get-members group)))
  
  
  (method (join-group self group delegate)
    (set-group delegate group)
    (set-members group (cons delegate (get-members group))))
  
  
  (method (leave-group self group delegate)
    (set-group delegate #f)
    (set-members group (remove! delegate (get-members group)))
    (when (not (has-members? self group))
      (if (world-setting 'together.guillaume? #f)
          (unless (equal? (get-name group) "Circle")
            (delete-group self group))
        (delete-group self group))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method package (client-connect self client client-uuid character-name character-avatar character-script character-zone character-sphere?)
    (let ((max-connections (world-setting 'world.server-max-connections #f)))
      (if (and max-connections (>= (count-alive self) max-connections))
          (begin
            (logger "Max connections reached ({a})" character-name)
            (format "Server max {a} connections reached" max-connections))
        (let ((existing-delegate (find-delegate-by-name self character-name)))
          ;; open test first draft at reconnection
          (let ((reconnected-delegate
                  (and existing-delegate
                       (or (get-exception existing-delegate)
                           (not (alive? (get-client existing-delegate))))
                       existing-delegate)))
            (if (and existing-delegate
                     (not reconnected-delegate))
                (begin
                  (logger "Name unavailable {a}" character-name)
                  (format "{a} {a} is unavailable" (registered-domain-name 'character "Character") character-name))
              ;; register client
              (let ((delegate (if (not reconnected-delegate)
                                  (let ((id (make-unique-id)))
                                    (new Client-Delegate client 'connected client-uuid id (literal->id id self) character-name character-avatar character-script character-sphere?))
                                (set-client reconnected-delegate client)
                                (set-alive reconnected-delegate (current-seconds))
                                (set-exception reconnected-delegate #f)
                                (set-exception-time reconnected-delegate #f)
                                reconnected-delegate)))
                (logger "{a} {a}" (if reconnected-delegate "Reconnect" "Connect") character-name)
                (unless reconnected-delegate
                  (set! delegates (cons delegate delegates)))
                ;; retrieve character
                (let ((client-id (get-id delegate))
                      (client-no (get-no delegate))
                      (character (character-retrieve self character-name character-avatar))
                      (character-delegate delegate))
                  (set-character character-delegate character)
                  (if (not character-sphere?)
                      (let ((form (call-with-input-file (path-settings {File Settings "servers" "Together" "zones" "Circle" ".zone"}) read-content-string)))
                        (let ((assets #f)
                              (processor #f)
                              (welcome "Welcome to Together!")
                              (spawnpoint (make-zero-vertex))
                              (player-spawnpoint (make-zero-vertex))
                              (player-id client-id)
                              (player-no client-no)
                              (player-position (make-zero-vertex))
                              (player-lookat (make-standard-lookat))
                              (other-players '()))
                          (list client-id client-no assets processor welcome form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players)))
                    ;; join character zone
                    (let ((character-zone (or character-zone (get-zone character))))
                      (let ((processor (spawn-processor (get-host configuration) (get-service configuration) character-zone)))
                        (let ((join-info (client-enter processor client client-uuid client-id client-no character-name character-avatar character-script)))
                          (if (string? join-info)
                              join-info
                            (set-zone character-delegate character-zone)
                            (set-processor character-delegate processor)
                            (bind (form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) join-info
                              (let ((assets #f)
                                    (welcome (cond (arc-en-ciel? "Bienvenue Arc-en-ciel!")
                                                   (open-test? (format "Welcome to the {a} open test!" tier-title))
                                                   (else (format "Welcome to {a}!" tier-title)))))
                                (rebroadcast-draws)
                                (list client-id client-no assets (proxy-connection-info client processor) welcome form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players))))))))))))))))
  
  
  (method package (client-start self client)
    (let ((delegate (find-delegate self client)))
      (set-state delegate 'started)
      (broadcast-peers self)
      (broadcast-hierarchy self)
      (broadcast-entered self delegate)))
  
  
  (method package (client-stop self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (let ((group (get-group delegate)))
          (when group
            (leave-group self group delegate)))
        (set-state delegate 'stopped)
        (broadcast-peers self)
        (broadcast-hierarchy self)
        (broadcast-exited self delegate #f))))
  
  
  (method package (client-disconnect self client character-name)
    (logger "Disconnect {a}" character-name)
    ;; find server client
    (let ((character-delegate (find-delegate self client)))
      ;; together robust
      (when character-delegate
        ;; store character
        (character-store self (get-character character-delegate))
        ;; leave zone
        (when (get-sphere? character-delegate)
          (client-exit (get-processor character-delegate) client character-name))
        ;; unregister client
        (set! delegates (remove! character-delegate delegates))
        ;; update state
        (set-state character-delegate 'disconnected)
        ;; close connection
        (request-close-remote-proxy client))))
  
  
  (method (broadcast-peers self)
    (let ((peers '()))
      (iterate-table (get-origin-connections udp-server)
        (lambda (origin connection)
          (let ((delegate (find-delegate-by-no self origin)))
            (when (and delegate (eq? (get-state delegate) 'started))
              (let ((host (get-host connection))
                    (port (get-port connection))
                    (local-host (get-local-host connection))
                    (local-port (get-local-port connection)))
                (set! peers (cons (list origin host port local-host local-port) peers)))))))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (peers-update client peers))))))
                delegates)))
  
  
  (method (broadcast-hierarchy self)
    (let ((hierarchy (collect-hierarchy self)))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (hierarchy-update client hierarchy))))))
                delegates)))
  
  
  (method (broadcast-entered self client-delegate)
    (let ((client-id (get-id client-delegate))
          (client-no (get-no client-delegate))
          (client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (server-entered client client-id client-no client-name))))))
                delegates)))
  
  
  (method (broadcast-exited self client-delegate disconnected?)
    (let ((client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (server-exited client client-name disconnected?))))))
                delegates)))
  
  
  (method (character-retrieve self character-name character-avatar)
    (let ((file (new-file (characters-dir self) (format "{a}.character" character-name))))
      (let ((character
              (if (exists? file)
                  (let ((character (instantiate (read-form file))))
                    (set-name character character-name)
                    (set-avatar character character-avatar)
                    character)
                (let ((units '(world.character)))
                  (let ((tag '(<Character>))
                        (data (new Data zone-version 'jazz units #f)))
                    (let ((form (construct-form tag (imports-locator units) data)))
                      (set-origin form file)
                      (let ((character (instantiate form)))
                        (set-name character character-name)
                        (set-avatar character character-avatar)
                        (set-zone character 'start)
                        character)))))))
        character)))
  
  
  (method (character-store self character)
    (let ((file (new-file (characters-dir self) (format "{a}.character" (get-name character)))))
      (create-directories file)
      (let ((designer (new Former form: (get-form character) reference: character)))
        (define (save-character)
          (set-property designer character 'zone (get-zone character)))
        
        (save-character)
        (save designer))))
  
  
  (method (characters-dir self)
    (new-directory directory "characters"))
  
  
  (method package (client-alive self client)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (when delegate
        (set-alive delegate (current-seconds)))))
  
  
  (method package (client-message self client kind recipient message)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (when delegate
        (let ((sender (get-name delegate)))
          (log-message self sender message)
          (for-each (lambda (delegate)
                      (let ((client (get-client delegate)))
                        (when (case kind
                                ((whisper)
                                 (equal? (get-name delegate) recipient))
                                ((group)
                                 (let ((group (get-group delegate)))
                                   (equal? (and group (get-name group)) recipient)))
                                (else
                                 #t))
                          (calling-client self delegate
                            (lambda ()
                              (server-message client sender kind message))))))
                    delegates)))))
  
  
  (method package (client-log self client time message)
    (server-log client time message))
  
  
  (method package (processor-log self processor time message)
    (server-log processor time message))
  
  
  (method package (client-connected-player self client no)
    (connected-player self no))
  
  
  (method override (connected-player self no)
    (if (= no client-no)
        "Server"
      (let ((delegate (find-delegate-by-no self no)))
        (and delegate
             (get-name delegate)))))
  
  
  (method package (client-connected-players self client)
    (connected-players self))
  
  
  (method package (client-available-templates self client)
    (available-templates self))
  
  
  (method package (client-available-zone-base self client from)
    (available-zone-base self from))
  
  
  (method package (client-available-zone-base? self client base)
    (available-zone-base? self base))
  
  
  (method package (client-create-zone self client from base)
    (and (create-zone self from base)
         (list 'zone base)))
  
  
  (method package (client-available-zones self client)
    (available-zones self))
  
  
  (method package (client-change-zone self client zone)
    (change-client-zone self client zone))
  
  
  (method package (client-create-group self client name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (if (find-group self name)
            (format "{a} {a} already exists" (group-domain-name self) name)
          (logger "Create group {a} ({a})" name (get-name delegate))
          (create-group self name)
          (broadcast-hierarchy self)
          #f))))
  
  
  (method package (client-delete-group self client name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name)))
          (if (not group)
              (format "{a} {a} doesn't exist anymore" (group-domain-name self) name)
            (if (has-members? self group)
                (format "{a} {a} still has members" (group-domain-name self) name)
              (logger "Delete group {a} ({a})" name (get-name delegate))
              (delete-group self name)
              (broadcast-hierarchy self)
              #f))))))
  
  
  (method package (client-disband-group self client name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (logger "Disband group {a} ({a})" name (get-name delegate))
        (disband-group self name)
        (broadcast-hierarchy self)
        #f)))
  
  
  (method package (client-join-group self client name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name)))
          (if (not group)
              (format "{a} {a} doesn't exist anymore" (group-domain-name self) name)
            (logger "Join group {a} ({a})" name (get-name delegate))
            (join-group self group delegate)
            (broadcast-hierarchy self)
            (group-channels self group))))))
  
  
  (method package (client-leave-group self client name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name)))
          (if (not group)
              (format "{a} {a} doesn't exist anymore" (group-domain-name self) name)
            (logger "Leave group {a} ({a})" name (get-name delegate))
            (leave-group self group delegate)
            (broadcast-hierarchy self)
            #f)))))
  
  
  (method package (client-register-channel self client name media-kind resolution recipient mirror?)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          (format "Delegate not found")
        (let ((group (get-group client-delegate)))
          (if (and (not recipient)
                   (not group))
              (format "You are not in a group")
            (let ((origin (get-no client-delegate))
                  (recipient (or recipient group))
                  (exclude-delegate (if mirror? #f client-delegate)))
              (server-register-channel self name origin media-kind resolution recipient exclude-delegate)))))))
  
  
  (method package (server-register-channel self name origin media-kind resolution recipient exclude-delegate)
    (let ((recipients (recipient-delegates self recipient)))
      (let ((no (next-channel-no!)))
        (let ((channel (register-server-channel udp-server name no origin media-kind resolution recipient exclude-delegate)))
          (for-each (lambda (delegate)
                      (unless (eq? delegate exclude-delegate)
                        (when (eq? (get-state delegate) 'started)
                          (let ((client (get-client delegate)))
                            (calling-client self delegate
                              (lambda ()
                                (add-channel client name no origin media-kind resolution)))))))
                    recipients)
          no))))
  
  
  (method package (client-unregister-channel self client channel-no)
    (server-unregister-channel self channel-no))
  
  
  (method package (client-channel-action self client channel-no action)
    (let ((channel (find-server-channel udp-server channel-no)))
      ;; together robust
      (when channel
        (let ((origin (get-origin channel)))
          (let ((delegate (find-delegate-by-no self origin)))
            (when delegate
              (let ((client (get-client delegate)))
                (calling-client self delegate
                  (lambda ()
                    (action-channel client channel-no action))))))))))
  
  
  (method package (server-unregister-channel self channel-no)
    (let ((channel (find-server-channel udp-server channel-no)))
      ;; together robust
      (when channel
        (let ((recipient (get-recipient channel))
              (exclude-delegate (get-exclude-delegate channel)))
          (let ((recipients (recipient-delegates self recipient)))
            (for-each (lambda (delegate)
                        (unless (eq? delegate exclude-delegate)
                          (when (eq? (get-state delegate) 'started)
                            (let ((client (get-client delegate)))
                              (calling-client self delegate
                                (lambda ()
                                  (remove-channel client channel-no)))))))
                      recipients)
            (close-server-channel udp-server channel-no)
            #f)))))
  
  
  (method (recipient-delegates self recipient)
    (if (is? recipient Server-Group)
        (get-members recipient)
      (list (find-delegate-by-no recipient))))
  
  
  (method (group-channels self group)
    (let ((origins (map get-no (get-members group)))
          (channels (new-queue)))
      (iterate-table (get-server-channels udp-server)
        (lambda (no channel)
          (let ((origin (get-origin channel)))
            (when (memv? origin origins)
              (let ((recipient (get-recipient channel)))
                (when (eq? recipient group)
                  (let ((name (get-name channel))
                        (media-kind (get-media-kind channel))
                        (resolution (get-resolution channel)))
                    (enqueue channels (list name no origin media-kind resolution)))))))))
      (queue-list channels)))
  
  
  (method package (client-list-group-members self name)
    (let ((group (find-group self name)))
      (if (not group)
          (format "{a} {a} doesn't exist anymore" (group-domain-name self) name)
        (map get-name (get-members group)))))
  
  
  (method package (client-list-hierarchy self)
    (collect-hierarchy self))
  
  
  (method (collect-hierarchy self)
    (define (member-info delegate)
      (list (get-name delegate)
            (get-id delegate)
            (get-no delegate)))
    
    (cons (cons #f
                (map member-info (collect-if (lambda (delegate)
                                               (and (eq? (get-state delegate) 'started)
                                                    (not (get-group delegate))))
                                             delegates)))
          (map (lambda (group)
                 (cons (get-name group)
                       (map member-info (get-members group))))
               groups)))
  
  
  (method (group-domain-name self)
    (registered-domain-name 'group "Group"))
  
  
  (method override (connected-players self)
    (map (lambda (delegate)
           (let ((zone (get-zone delegate)))
             (list (get-name delegate) zone (present-zone self zone))))
         delegates))
  
  
  (method override (retrieve-entity self id)
    (find-entity id))
  
  
  (method override (available-templates self)
    (collect-templates))
  
  
  (method override (available-zone-base self from)
    (unique-zone-base from))
  
  
  (method override (available-zone-base? self base)
    (zone-base-available? base))
  
  
  (method override (create-zone self from base)
    (prog1 (create-new-zone from base
             create: (lambda (dir)
                       (create (new-directory dir "players")))
             open: (lambda (file)
                     #f))
      (setup-zones self)))
  
  
  (method override (available-zones self)
    (let ((queue (new-queue)))
      (iterate-table instances
        (lambda (uuid instance)
          (enqueue queue (cons (list 'instance uuid)
                               (format "{a}{? <{a}>~}" (join (get-template instance) "/") (+ (get-rank instance) 1))))))
      (for-each (lambda (path)
                  (enqueue queue (cons (cons 'zone path)
                                       (last path))))
                zones)
      (queue-list queue)))
  
  
  (method override (change-zone self zone)
    (change-server-zone self zone))
  
  
  (method (change-client-zone self client zone)
    (let ((delegate (find-delegate self client)))
      (let ((client-uuid (get-uuid delegate))
            (client-id (get-id delegate))
            (client-no (get-no delegate))
            (character-name (get-name delegate))
            (character-avatar (get-avatar delegate))
            (character-script (get-script delegate)))
        ;; leave
        (client-exit (get-processor delegate) client character-name)
        ;; join
        (let ((processor (spawn-processor (get-host configuration) (get-service configuration) zone)))
          (let ((join-info (client-enter processor client client-uuid client-id client-no character-name character-avatar character-script)))
            (set-zone delegate zone)
            (set-processor delegate processor)
            (cons (proxy-connection-info client processor) join-info))))))
  
  
  ;; todo
  (method (change-server-zone self zone)
    )
  
  
  (method (present-zone self zone)
    (if (eq? zone 'start)
        "<Start Zone>"
      (case (car zone)
        ((instance)
         (let ((instance (find-instance self (cadr zone))))
           (format "{a}{? <{a}>~}" (get-name (get-template instance)) (+ (get-rank instance) 1))))
        (else
         (last zone)))))
  
  
  (method package (retrieve-asset self path)
    (if (ends-with? path "/")
        (let ((dir (make-directory assets path)))
          (and (exists? dir)
               (let ((queue (new-queue)))
                 (iterate-directory dir
                   (lambda (file)
                     (enqueue queue (cons (get-name file) (zlib-deflate (load-binary file)))))
                   files?: #t
                   directories?: #f
                   recursive?: #f)
                 (queue-list queue))))
      (let ((file (make-file assets path)))
        (and (exists? file)
             (zlib-deflate (load-binary file))))))
  
  
  (method package (register-literal self literal)
    (literal->id literal))
  
  
  (method package (registered-id self id)
    (id->literal id))
  
  
  (method (find-delegate self target)
    (find-if (lambda (delegate)
               (proxy=? (get-client delegate) target))
             delegates))
  
  
  (method (find-delegate-by-name self target)
    (find-if (lambda (delegate)
               (equal? (get-name delegate) target))
             delegates))
  
  
  (method (find-delegate-by-uuid self uuid)
    (find-if (lambda (delegate)
               (uuid=? (get-uuid delegate) uuid))
             delegates))
  
  
  (method (find-delegate-by-id self id)
    (find-if (lambda (delegate)
               (equal? (get-id delegate) id))
             delegates))
  
  
  (method (find-delegate-by-no self no)
    (find-if (lambda (delegate)
               (= (get-no delegate) no))
             delegates))
  
  
  (method package (tile-server self)
    (tile self))
  
  
  (method package (restore-server self)
    (restore self))
  
  
  (method package (admin-command self client command arguments)
    (case command
      ((who)
       (map get-name delegates))
      ((crashes)
       (let ((dir {Directory Settings "work" "crashes"}))
         (if (equal? arguments '(clear))
             (begin
               (empty dir)
               (unspecified))
           (let ((queue (new-queue)))
             (iterate-directory dir
               (lambda (file)
                 (when (extension=? (get-extension file) "snapshot")
                   (enqueue queue (get-name file)))))
             (queue-list queue)))))
      ((crash)
       (let ((file (new-file {Directory Settings "work" "crashes"} (car arguments))))
         (and (exists? file)
              (call-with-input-file (path-settings file)
                (lambda (port)
                  (let ((queue (new-queue)))
                    (loop (repeat 10)
                          (let ((line (read-line port)))
                            (unless (eof-object? line)
                              (enqueue queue line))))
                    (queue-list queue)))))))
      ((logs)
       (let ((dir {Directory Settings "work" "logs"}))
         (if (equal? arguments '(clear))
             (let ((active-log (logger-file)))
               (iterate-directory dir
                 (lambda (path)
                   (unless (pathname=? path active-log)
                     (delete path)))
                 files?: #t
                 directories?: #f
                 recursive?: #f)
               (unspecified))
           (let ((queue (new-queue)))
             (iterate-directory dir
               (lambda (file)
                 (when (extension=? (get-extension file) "log")
                   (enqueue queue (get-name file)))))
             (queue-list queue)))))
      ((log)
       (let ((file (if (null? arguments)
                       (logger-file)
                     (new-file {Directory Settings "work" "logs"} (car arguments)))))
         (and (exists? file)
              (load-lines file))))
      ((info)
       (let ((server (current-server)))
         (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
           (list
             (server-host server)
             (server-service server)
             (map get-name (collect-alive (current-server)))
             (map get-name (collect-disconnected (current-server)))
             (table-values processors)
             (collect-hierarchy (current-server))
             (length (top-threads))
             last-gc-live
             last-gc-movable
             last-gc-nonmovable
             outgoing-max))))
      ((threads)
       (map ->string (top-threads)))
      ((test)
       (let ((no (and (not-null? arguments) (car arguments))))
         (logger "Test server{? {a}~}" no)
         (if (not no)
             (exit-no-jobs)
           #f)))
      ((attach)
       (logger "Attach server")
       (let ((debugger (car arguments)))
         (delay-event
           (lambda ()
             (setup-debuggee debugger: debugger)
             (start-repl-thread (current-thread) #f (current-console-port))
             (select-debugger-console)
             (current-input-port (console-input-port))
             (current-output-port (console-output-port))
             (ready-to-controller))))
       (unspecified))
      ((detach)
       (logger "Detach server")
       (current-input-port (standard-input-port))
       (current-output-port (standard-output-port))
       (detach-from-controller)
       (unspecified))
      ((restart)
       (logger "Restart server")
       (let ((delay (if (null? arguments) 1 (car arguments))))
         (restart-server self delay))
       (unspecified))
      ((reset)
       (let ((what (if (null? arguments) #f (car arguments))))
         (case what
           ((evolution)
            (reset-evolution)
            #t)
           (else
            #f))))
      ((stream)
       (bind-optionals ((action #f) (what #f)) arguments
         (case action
           ((list)
            (stream-list self))
           ((play)
            (stream-play self client what))
           ((stop)
            (stream-stop self client what)))))
      ((request)
       (bind (cookie who what action) arguments
         (let ((requester client))
           (define (request-server (requester-group #f))
             (admin-server-request self requester requester-group cookie what))
           
           (define (request-client delegate)
             (let ((client (get-client delegate)))
               (calling-client self delegate
                 (lambda ()
                   (admin-request client requester cookie what action)))))
           
           (cond ((equal? who "server")
                  (request-server)
                  #f)
                 ((equal? who "all")
                  (let ((requester-delegate (find-delegate self requester)))
                    (let ((requester-group (and requester-delegate (get-group requester-delegate))))
                      (if (not requester-group)
                          "Not in a circle"
                        (request-server requester-group)
                        (for-each request-client (get-members requester-group))
                        #f))))
                 (else
                  (let ((delegate (find-delegate-by-name self who)))
                    (if (not delegate)
                        (format "Unable to find {a}" who)
                      (request-client delegate)
                      #f)))))))))
  
  
  ;; to be unified with admin-request
  (method (admin-server-request self requester requester-group cookie what)
    (define (send-caps)
      (let ((file {File Settings "work" "logs" "server.caps"}))
        (when (exists? file)
          (send-file 0 file))))
    
    (define (send-crashes)
      )
    
    (define (send-replay)
      (send-threaded 0
        (lambda ()
          (define (metadata)
            (define (send-channels)
              (channels-metadata (get-send-channels udp-server)))
            
            (define (server-channels)
              (channels-metadata (get-server-channels udp-server)))
            
            (define (start-time)
              (and requester-group (get-start-time requester-group)))
            
            (list server-no "<server>" (send-channels) (server-channels) (start-time)))
          
          (let ((metadata (metadata))
                (chronology (copy-chronology (current-chronology)))
                (evolution (copy-evolution (current-evolution))))
            (object->u8vector (list metadata chronology evolution) serialize)))))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Settings "work" "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file name)
      (let ((dir {Directory Settings "work" "shared"}))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-settings)
      (let ((file {File Settings ".admin"}))
        (when (exists? file)
          (send-file 0 file))))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (send-threaded name extract)
      (let ((thread
              (new-thread
                (lambda ()
                  (let ((sender "<server>"))
                    (admin-result requester cookie sender name #f #f)
                    (let ((content (zlib-deflate (extract))))
                      (let ((content-size (u8vector-length content))
                            (max-size 8192)
                            (give-time .01))
                        (let (loop-chunk (part 0) (pos 0))
                          (let ((remain (- content-size pos)))
                            (when (> remain 0)
                              (sleep give-time)
                              (let ((chunk-size (min remain max-size)))
                                (let ((chunk (make-u8vector chunk-size))
                                      (done? (>= chunk-size remain)))
                                  (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                                  (admin-chunk self requester cookie sender name chunk done?))
                                (loop-chunk (+ part 1) (+ pos chunk-size))))))))))
                'request)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)))
    
    (if (string? what)
        (send-shared-file what)
      (case what
        ((caps)
         (send-caps))
        ((crashes)
         (send-crashes))
        ((replay)
         (send-replay))
        ((shared)
         (send-shared))
        ((settings)
         (send-settings)))))
  
  
  (method (admin-chunk self requester cookie sender name chunk done?)
    (let ((delegate (find-delegate self requester)))
      (when delegate
        (calling-client self delegate
          (lambda ()
            (admin-result requester cookie sender name chunk done?))))))
  
  
  (method (restart-server self delay)
    (let ((process (current-process)))
      (delay-event
        (lambda ()
          (count-down delay
            (lambda (suffix)
              (broadcast-server-message self
                (if (= delay 1)
                    "Restart"
                  (format "Restart in {a}" suffix))))
            (lambda ()
              (quit-process process)))))))
  
  
  (method (broadcast-server-message self message)
    (let ((sender #f)
          (kind 'server))
      (for-each (lambda (delegate)
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (server-message client sender kind message)))))
                delegates)))
  
  
  ;;;
  ;;;; Aliveness
  ;;;
  
  
  (method (start-aliveness-task self)
    ;; together robust
    (unless together?
    (set! aliveness-task (new Task 'aliveness (lambda (task)
                                                (aliveness-loop self task))
                              priority: aliveness-priority))
    (start-task aliveness-task)))
  
  
  (method (stop-aliveness-task self)
    ;; together robust
    (unless together?
    (exit-thread (get-thread aliveness-task))
    (thread-join! (get-thread aliveness-task))
    (set! aliveness-task #f)))
  
  
  (method (aliveness-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          (let ((time (current-seconds)))
            (let ((elapse (- time previous)))
              (with-task-mutex
                (lambda ()
                  (unless (stopping? task)
                    (site (aliveness on?: #t)
                      (check-aliveness self)))))
              (let ((duration (- (current-seconds) time)))
                (task-wait task aliveness-period duration exit))
              (iter time)))))))
  
  
  (method (check-aliveness self)
    (let ((newly-disconnected '()))
      (for-each (lambda (delegate)
                  (when (not (still-alive? delegate))
                    (set-exception delegate "Disconnected")
                    (set-exception-time delegate (current-seconds))
                    (disconnected-client self delegate)
                    (set! newly-disconnected (cons delegate newly-disconnected))))
                delegates)
      (set! disconnected (collect-if keep-disconnected? disconnected))
      (when (not-null? newly-disconnected)
        (broadcast-disconnected self newly-disconnected))))
  
  
  (method (disconnected-client self delegate)
    (logger "Disconnected {a}" (get-name delegate))
    (set! delegates (remove! delegate delegates))
    (set! disconnected (cons delegate disconnected))
    (let ((group (get-group delegate)))
      (when group
        (leave-group self group delegate)))
    (calling-client self delegate
      (lambda ()
        (catch (connection-exception? exc)
          (detach-client (get-client delegate))))))
  
  
  (method override (delay-disconnected-client self delegate)
    (delay-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (disconnected-client self delegate)
            (broadcast-disconnected self (list delegate)))))))
  
  
  (method (broadcast-disconnected self newly-disconnected)
    (broadcast-hierarchy self)
    (for-each (lambda (delegate)
                (broadcast-exited self delegate #t))
              newly-disconnected))
  
  
  ;;;
  ;;;; UDP
  ;;;
  
  
  (method (start-udp-server self)
    (let ((host (get-host configuration))
          (service (get-service configuration)))
      (let ((server (new UDP-Server)))
        (start server host service)
        (set! udp-server server))))
  
  
  (method (stop-udp-server self)
    (when udp-server
      (stop udp-server)
      (set! udp-server #f)))
  
  
  ;;;
  ;;;; Detach
  ;;;
  
  
  (method (detach-clients self)
    (for-each (lambda (delegate)
                (calling-client self delegate
                  (lambda ()
                    (detach-client (get-client delegate)))))
              delegates))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method (stream-list self)
    (let ((queue (new-queue)))
      (define (scan root extension)
        (iterate-streams root
          (lambda (file)
            (when (extension=? (get-extension file) extension)
              (let ((base (get-base file)))
                (let ((location (filename-spine (join (subpath streams-dir file) "/"))))
                  (enqueue queue (list location (if (not-null? (find-stream-channels self base))
                                                    'playing
                                                  #f)))))))))
      
      (scan "videos" "streamvideo")
      (scan "musics" "streamaudio")
      (queue-list queue)))
  
  
  (method (stream-play self client location)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          "Delegate not found"
        (let ((group (get-group client-delegate)))
          (if (not group)
              "You are not in a group"
            ;; so that the add-channel call that uses tcp is not blocked
            (delay-event
              (lambda ()
                (let ((name (filename-name location)))
                  (let ((streaming-audio? (streaming-audio? self)))
                    (let ((audio-channel (and (not streaming-audio?) (make-server-audio-channel self group location name)))
                          (video-channel (make-server-video-channel self group location name)))
                      (when audio-channel
                        (play audio-channel))
                      (play video-channel))))))
            #f)))))
  
  
  (method (stream-stop self client location)
    (let ((name (filename-name location)))
      (let ((channels (find-stream-channels self name)))
        (if (null? channels)
            "Stream not found"
          (for-each (lambda (channel)
                      (close-send-channel udp-server (get-no channel)))
                    channels)
          #f))))
  
  
  (method (find-stream-channels self name)
    (let ((queue (new-queue)))
      (iterate-table (get-send-channels udp-server)
        (lambda (no channel)
          (when (equal? (get-name channel) name)
            (enqueue queue channel))))
      (queue-list queue)))
  
  
  (method (streaming-channels self)
    (map-table (lambda (no channel)
                 channel)
               (get-send-channels udp-server)))
  
  
  (method (streaming-audio? self)
    (some? (lambda (channel)
             (= (get-media-kind channel) udp-audio))
           (streaming-channels self)))
  
  
  (method (make-server-audio-channel self group location name)
    (let ((channel-no (server-register-channel self name client-no udp-audio #f group #f)))
      (let ((channel (register-send-channel udp-server name channel-no udp-audio #f)))
        ;; because the add-channel call uses tcp, the first udp packets
        ;; will often arrive before it hence the need for a small delay
        (sleep .1)
        (let ((src (new File-Stream-Audio-Src
                     location))
              (sink (new Stream-Sink
                      consumer: (lambda (buffer timestamp duration)
                                  (case audio-codec
                                    ((opus)
                                     (let ((header? (and buffer (audio-buffer-header? buffer))))
                                       (send-server-media self channel-no buffer header? timestamp duration)))
                                    ((vorbis)
                                     (if (pair? buffer)
                                         (send-server-media self channel-no (car buffer) #t -1 GST_CLOCK_TIME_NONE)
                                       (send-server-media self channel-no buffer #f timestamp duration))))))))
          (let ((pipeline (pipeline src sink)))
            (set-pipeline channel pipeline)
            channel)))))
  
  
  (method (make-server-video-channel self group location name)
    (let ((channel-no (server-register-channel self name client-no udp-video #f group #f)))
      (let ((channel (register-send-channel udp-server name channel-no udp-video #f)))
        ;; because the add-channel call uses tcp, the first udp packets
        ;; will often arrive before it hence the need for a small delay
        (sleep .1)
        (let ((src (new File-Stream-Video-Src
                     location))
              (sink (new Stream-Sink
                      consumer: (lambda (buffer timestamp duration)
                                  (let ((header? (and buffer (video-buffer-header? buffer))))
                                    (send-server-media self channel-no buffer header? timestamp duration))))))
          (let ((pipeline (pipeline src sink)))
            (set-pipeline channel pipeline)
            channel)))))
  
  
  (method package (send-server-media self channel-no buffer header? timestamp duration)
    (when udp-server
      (send-media udp-server channel-no buffer header? timestamp duration)))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (world.window:tile-server/clients (non-bot-clients self)))
  
  
  (method override (restore self)
    (world.window:restore-server/clients (non-bot-clients self)))
  
  
  (method (non-bot-clients self)
    (map get-client (collect-if (lambda (delegate)
                                   (not (get-script delegate)))
                                 delegates)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (server-log #f (current-seconds) message)))
  
  
  ;;;
  ;;;; Simulate
  ;;;
  
  
  (method package (protocol-simulation self kind)
    (define (setup-protocol-simulation server-protocol clients-protocol)
      @convert-to-presence
      (for-each (lambda (delegate)
                  (let ((client (get-client delegate)))
                    (let ((uuid (get-uuid (get-ior client))))
                      (let ((connection (require-remote-connection uuid)))
                        (set-protocol connection clients-protocol)))
                    (server-protocol client server-protocol)))
                delegates))
    
    (case kind
      ((none) (setup-protocol-simulation #f #f))
      ((slow) (setup-protocol-simulation .05 .1))
      ((awful) (setup-protocol-simulation .25 .5))
      (else (error "Unknown protocol simulation: {a}" kind))))
  
  
  ;;;
  ;;;; Messages
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file self)
    (or log-file
        (let ((file (timestamped-file (new-directory directory "messages") "messages" "txt")))
          (create-directories file)
          (set! log-file file)
          file)))
  
  
  (method (log-message self sender message)
    (call-with-output-file (path-settings (cache-log-file self) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message)))))


;;;
;;;; Slave
;;;


(definition protected (ready-server)
  (when master-process
    (let ((server (load-object (get-local-register) 'world.server.remote 'world-remote-server)))
      (slave-setup master-process server master-cookie)
      (slave-ready master-process server master-cookie)))))
