;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.server.tier jazz


(import (jazz.component)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.jrm.transmission)
        (jazz.network)
        (jazz.process)
        (world)
        (world.assets)
        (world.autoload)
        (world.history)
        (world.id)
        (world.instance)
        (world.log)
        (world.network)
        (world.server.client)
        (world.server.serving)
        (world.settings)
        (world.syntax (phase syntax)))


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                                      getter generate)
  (slot delegates     initialize '()                       getter generate)
  (slot instances     initialize (make-table test: equal?) getter generate)
  (slot zones         initialize '()                       getter generate)
  (slot hits          initialize 0                         getter generate)
  
  
  (method override (initialize dir)
    (nextmethod dir)
    (set! configuration (instantiate~ (read-form (new-file~ dir ".server"))))
    (set! assets (gather-assets 'tier (new-directory~ directory "assets")))
    (let ((id (make-unique-id)))
      (set-client-id/no id (literal->id id self)))
    (simulate-protocol 'world.server-protocol)
    (reset-last-broadcast)
    ;; aec quicky
    (set-remote-problem-handler
      (lambda (process)
        (catch (connection-problem? obj
                 obj)
          (process))))
    (let ((host (get-host~ configuration))
          (service (get-service~ configuration))
          (listener (get-remote-listener)))
      (assert (or (not listener)
                  (and (host=? (host->string host) (host->string (listening-host~ listener)))
                       (service=? service (listening-port~ listener))))
        (start-remote-listener host: host service: service)))
    (setup-instances)
    (setup-zones))
  
  
  (method override (enter)
    (let ((me (current-me+)))
      (when me
        (set-name~ me (get-character-name~ configuration))
        (set-avatar~ me (get-character-avatar~ configuration)))))
  
  
  (method override (shutdown)
    (detach-clients))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state)
    'started)
    
  
  (method override (start)
    )
  
  
  (method override (stop)
    )
  
  
  (method override (restart)
    )
  
  
  (method override (wait-started)
    )
  
  
  (method override (wait-stopped)
    )
  
  
  (method override (server-name)
    "World")
  
  
  (method override (server-title)
    "World")
  
  
  (method override (server-version)
    (process-version~ (get-process)))
  
  
  (method override (server-host)
    (host->string (listening-host~ (get-remote-listener))))
  
  
  (method override (server-service)
    (port->string (listening-port~ (get-remote-listener))))
  
  
  (method override (server-hits)
    hits)
  
  
  (method override (server-debug?)
    #f)
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id literal)
    (next-literal-id!))
  
  
  (method override (tier-id->literal id)
    (error "Unregistered id: {s}" id))
  
  
  ;;;
  ;;;; Instances
  ;;;
  
  
  (method (find-instance uuid)
    (table-ref instances uuid #f))


  (method (setup-instances)
    (let ((instances-dir (instances-dir)))
      (when (exists?~ instances-dir)
        (iterate-directory~ instances-dir
          (lambda (instance-dir)
            (let ((file (new-file~ instance-dir ".instance")))
              (when (exists?~ file)
                (let ((instance (instantiate~ (read-form file))))
                  (let ((uuid (get-name~ instance)))
                    (table-set! instances uuid instance))))))
          files?: #f
          directories?: #t
          recursive?: #f))))
  
  
  (method (instances-dir)
    (new-directory~ directory "instances"))
  
  
  ;;;
  ;;;; Zones
  ;;;


  (method (setup-zones)
    (let ((zones-dir (zones-dir))
          (queue (new-queue)))
      (when (exists?~ zones-dir)
        (iterate-directory~ zones-dir
          (lambda (path kind)
            (let ((zone-dir (new-directory~ zones-dir path)))
              (let ((file (new-file~ zone-dir ".zone")))
                (when (exists?~ file)
                  (enqueue queue path)))))
          full?: #f
          files?: #f
          directories?: #t
          recursive?: #t))
      (set! zones (queue-list queue))))
  
  
  (method (zones-dir)
    (new-directory~ directory "zones"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (setup-me)
    (setup-current-me)
    (register-id~ (current-me) (make-unique-id)))
  
  
  (method override (save-me)
    (save-current-me))
  
  
  (method override (player-file)
    (new-file~ directory '("start" ".player")))
  
  
  (method override (anonymous)
    "Server")
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (definition disconnect-delay
    30.)
  
  
  (method (still-alive? delegate)
    (let ((alive (get-alive~ delegate)))
      (and alive (< (- (current-seconds) alive) disconnect-delay))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (client-enter client character-name character-avatar character-script)
    (let ((world (current-world))
          (zone (current-zone)))
      (debug-server 'client-enter character-name character-avatar character-script)
      (let ((existing-delegate (find-delegate-by-name character-name)))
        ;; open test first draft at reconnection
        (let ((reconnected-delegate
                (and existing-delegate
                     (or (get-exception~ existing-delegate)
                         (not (still-alive? existing-delegate))
                         (not (live?~ (get-client~ existing-delegate))))
                     existing-delegate)))
          (if (and existing-delegate
                   (not reconnected-delegate))
              (format "Character {a} is unavailable" character-name)
            ;; register client
            (let ((delegate (if (not reconnected-delegate)
                                (let ((id (make-unique-id)))
                                  (new Client-Delegate client id (literal->id id self) character-name character-avatar character-script))
                              (set-client~ reconnected-delegate client)
                              (set-alive~ reconnected-delegate (current-seconds))
                              (set-exception~ reconnected-delegate #f)
                              (set-exception-time~ reconnected-delegate #f)
                              reconnected-delegate)))
              (unless reconnected-delegate
                (set! delegates (cons delegate delegates)))
              ;; retrieve character
              (let ((client-id (get-id~ delegate))
                    (client-no (get-no~ delegate))
                    (character (character-retrieve character-name character-avatar))
                    (character-delegate delegate))
                (set-character~ character-delegate character)
                ;; join character zone
                (let ((character-zone (get-zone~ character)))
                  (let ((processor (if (eq? character-zone 'start) (get-remote-processor~ (current-processor)) (spawn-processor (get-host~ configuration) (get-service~ configuration) character-zone))))
                    (let ((join-info (client-join~ processor client client-id client-no character-name character-avatar character-script)))
                      (if (string? join-info)
                          join-info
                        (set-zone~ character-delegate character-zone)
                        (set-processor~ character-delegate processor)
                        (bind (form spawnpoint player-spawnpoint player-id player-position player-lookat other-players) join-info
                          (when (window?)
                            (if reconnected-delegate
                                (display-message~ world (format "{a} reconnected" character-name))
                              (display-message~ world (format "{a} entered world" character-name))))
                          (let ((assets #f)
                                (welcome (cond (sejour? "Bienvenue au s√©jour informatique!")
                                               (arc-en-ciel? "Bienvenue Arc-en-ciel!")
                                               (open-test? "Welcome to the Yownu open test!")
                                               (else "Welcome to Yownu!"))))
                            (list client-id client-no assets (proxy-connection-info client processor) welcome form spawnpoint player-spawnpoint player-id player-position player-lookat other-players))))))))))))))
  
  
  (method (client-exit client character-name)
    (let ((world (current-world))
          (zone (current-zone)))
      (debug-server 'client-exit character-name)
      ;; find server client
      (let ((character-delegate (find-delegate client)))
          ;; store character
        (character-store (get-character~ character-delegate))
        ;; leave zone
        (client-leave~ (get-processor~ character-delegate) client character-name)
        ;; unregister client
        (set! delegates (remove! character-delegate delegates)))
      (when (window?)
        (display-message~ world (format "{a} exited world" character-name)))))
  
  
  (method (character-retrieve character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file~ (characters-dir) (format "{a}.character" character-name))))
        (let ((character
                (if (exists?~ file)
                    (let ((character (instantiate~ (read-form file))))
                      (set-name~ character character-name)
                      (set-avatar~ character character-avatar)
                      character)
                  (let ((units '(world.data)))
                    (let ((tag '(<Character>))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin~ form file)
                        (let ((character (instantiate~ form)))
                          (set-name~ character character-name)
                          (set-avatar~ character character-avatar)
                          (set-zone~ character 'start)
                          character)))))))
          character))))
  
  
  (method (character-store character)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file~ (characters-dir) (format "{a}.character" (get-name~ character)))))
        (create-directories~ file)
        (let ((designer (new Former form: (get-form~ character) reference: character)))
          (define (save-character)
            (set-property~ designer character 'zone (get-zone~ character)))
          
          (save-character)
          (save~ designer)))))
  
  
  (method (characters-dir)
    (new-directory~ directory "characters"))
  
  
  (method (client-alive client)
    (let ((delegate (find-delegate client)))
      ;; aec robust
      (when delegate
        (set-alive~ delegate (current-seconds)))))
  
  
  (method (client-message client kind recipient message)
    ;; aec robust
    (let ((delegate (find-delegate client)))
      (when delegate
        (let ((sender (get-name~ delegate)))
          (log-message sender message)
          (for-each (lambda (delegate)
                      (let ((client (get-client~ delegate)))
                        (when (or (neq? kind 'whisper)
                                  (ci=? (get-name~ delegate) recipient))
                          (calling-client delegate
                            (lambda ()
                              (server-message~ client sender kind message))))))
                    delegates)))))
  
  
  (method (client-log client time message)
    (server-log client time message))
  
  
  (method (client-debug client arguments)
    ;; aec robust
    (let ((delegate (find-delegate client)))
      (when delegate
        (apply debug (get-name~ delegate) arguments))))
  
  
  (method (processor-debug processor arguments)
    (apply debug processor arguments))
  
  
  (method (client-connected-player client no)
    (connected-player no))
  
  
  (method override (connected-player no)
    (if (= no client-no)
        "Server"
      (let ((delegate (find-delegate-by-no no)))
        (and delegate
             (get-name~ delegate)))))
  
  
  (method (client-connected-players client)
    (connected-players))
  
  
  (method (client-available-templates client)
    (available-templates))
  
  
  (method (client-available-zone-base client from)
    (available-zone-base from))
  
  
  (method (client-available-zone-base? client base)
    (available-zone-base? base))
  
  
  (method (client-create-zone client from base)
    (and (create-zone from base)
         (list 'zone base)))
  
  
  (method (client-available-zones client)
    (available-zones))
  
  
  (method (client-change-zone client zone)
    (change-client-zone client zone))
  
  
  (method override (connected-players)
    (map (lambda (delegate)
           (let ((zone (get-zone~ delegate)))
             (list (get-name~ delegate) zone (present-zone zone))))
         delegates))
  
  
  (method override (retrieve-entity id)
    (find-entity id))
  
  
  (method override (available-templates)
    (let ((world (current-world)))
      (collect-templates~ world)))
  
  
  (method override (available-zone-base from)
    (let ((world (current-world)))
      (unique-zone-base~ world from)))
  
  
  (method override (available-zone-base? base)
    (let ((world (current-world)))
      (zone-base-available?~ world base)))
  
  
  (method override (create-zone from base)
    (let ((world (current-world)))
      (prog1 (create-new-zone~ world from base
               create: (lambda (dir)
                         (create~ (new-directory~ dir "players")))
               open: (lambda (file)
                       #f))
        (setup-zones))))
  
  
  (method override (available-zones)
    (let ((queue (new-queue)))
      @wait
      (iterate-table instances
        (lambda (uuid instance)
          (enqueue queue (cons (list 'instance uuid)
                               (format "{a}{? <{a}>~}" (get-name~ (get-template~ instance)) (+ (get-rank~ instance) 1))))))
      (for-each (lambda (path)
                  (enqueue queue (cons (cons 'zone path)
                                       (last path))))
                zones)
      (queue-list queue)))
  
  
  (method override (change-zone zone)
    (change-server-zone zone))
  
  
  (method (change-client-zone client zone)
    (let ((delegate (find-delegate client)))
      (let ((client-id (get-id~ delegate))
            (client-no (get-no~ delegate))
            (character-name (get-name~ delegate))
            (character-avatar (get-avatar~ delegate))
            (character-script (get-script~ delegate)))
        ;; leave
        (client-leave~ (get-processor~ delegate) client character-name)
        ;; join
        (let ((processor (if (eq? zone 'start) (get-remote-processor~ (current-processor)) (spawn-processor (get-host~ configuration) (get-service~ configuration) zone))))
          (let ((join-info (client-join~ processor client client-id client-no character-name character-avatar character-script)))
            (set-zone~ delegate zone)
            (set-processor~ delegate processor)
            (cons (proxy-connection-info client processor) join-info))))))
  
  
  ;; todo
  (method (change-server-zone zone)
    )
  
  
  (method (present-zone zone)
    (if (eq? zone 'start)
        "<Start Zone>"
      (case (car zone)
        ((instance)
         (let ((instance (find-instance (cadr zone))))
           (format "{a}{? <{a}>~}" (get-name~ (get-template~ instance)) (+ (get-rank~ instance) 1))))
        (else
         (last zone)))))
  
  
  (method (retrieve-asset path)
    #f)
  
  
  (method (register-literal literal)
    (literal->id literal))
  
  
  (method (registered-id id)
    (id->literal id))
  
  
  (method (find-delegate target)
    (find-if (lambda (delegate)
               (proxy=? (get-client~ delegate) target))
             delegates))
  
  
  (method (find-delegate-by-name target)
    (find-if (lambda (delegate)
               (equal? (get-name~ delegate) target))
             delegates))
  
  
  (method (find-delegate-by-no no)
    (find-if (lambda (delegate)
               (= (get-no~ delegate) no))
             delegates))
  
  
  ;; todo
  (method (check-clients-liveliness)
    )
  
  
  (method (tile-server)
    (tile))
  
  
  (method (restore-server)
    (restore))
  
  
  ;;;
  ;;;; Detach
  ;;;
  
  
  (method (detach-clients)
    (for-each (lambda (delegate)
                (calling-client delegate
                  (lambda ()
                    (detach-client~ (get-client~ delegate)))))
              delegates))
  
  
  ;;;
  ;;;; Pause
  ;;;
  
  
  (method (pause)
    (let ((world (current-world))
          (history (current-history)))
      (cond ((not (get-paused?~ history))
             (pause-world~ world)
             (for-each (lambda (delegate)
                         (calling-client delegate
                           (lambda ()
                             (pause-client~ (get-client~ delegate)))))
                       delegates))
            (else
             (for-each (lambda (delegate)
                         (calling-client delegate
                           (lambda ()
                             (unpause-client~ (get-client~ delegate)))))
                       delegates)
             (unpause-world~ world)))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile)
    (when (window?)
      (world.window:tile-server/clients (non-bot-clients))))
  
  
  (method override (restore)
    (when (window?)
      (world.window:restore-server/clients (non-bot-clients))))
  
  
  (method (non-bot-clients)
    (map get-client~ (collect-if (lambda (delegate)
                                   (not (get-script~ delegate)))
                                 delegates)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log message)
    (when log?
      (server-log #f (current-seconds) message)))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (debug-server . rest)
    (when (world-setting 'world.server.debug? #f)
      (apply debug 'server rest)))
  
  
  ;;;
  ;;;; Simulate
  ;;;
  
  
  (method (protocol-simulation kind)
    (define (setup-protocol-simulation server-protocol clients-protocol)
      (for-each (lambda (delegate)
                  (let ((client (get-client~ delegate)))
                    (let ((uuid (get-uuid~ (get-ior~ client))))
                      (let ((connection (require-remote-connection uuid)))
                        (set-protocol~ connection clients-protocol)))
                    (server-protocol~ client server-protocol)))
                delegates))
    
    (case kind
      ((none) (setup-protocol-simulation #f #f))
      ((slow) (setup-protocol-simulation .05 .1))
      ((awful) (setup-protocol-simulation .25 .5))
      (else (error "Unknown protocol simulation: {a}" kind))))
  
  
  ;;;
  ;;;; Messages
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file)
    (or log-file
        (let ((zone (current-zone)))
          (let ((file (timestamped-file (new-directory~ directory "messages") "messages" "txt")))
            (create-directories~ file)
            (set! log-file file)
            file))))
  
  
  (method (log-message sender message)
    (call-with-output-file (path-settings (cache-log-file) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message))))))
