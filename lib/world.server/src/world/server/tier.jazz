;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.server.tier jazz


(import (jazz.associative)
        (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.io)
        (jazz.json)
        (jazz.logger)
        (jazz.markup)
        (jazz.network)
        (jazz.network.websocket)
        (jazz.platform)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.zlib)
        (gaea.geometry)
        (world)
        (world.audio)
        (world.assets)
        (world.autoload)
        (world.capabilities)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.history)
        (world.id)
        (world.io)
        (world.log)
        (world.moment)
        (world.moment.syntax (phase syntax))
        (world.network)
        (world.processor)
        (world.profile)
        (world.profiling)
        (world.server)
        (world.server.client)
        (world.server.group)
        (world.server.mobile)
        (world.server.presence)
        (world.server.problem)
        (world.server.report)
        (world.server.serving)
        (world.server.udp)
        (world.settings)
        (world.stream)
        (world.streaming)
        (world.stub)
        (world.support)
        (world.task)
        (world.tier)
        (world.udp)
        (world.video))


(definition max-connections
  (world-setting 'world.server-max-connections #f))


;; quick solution for sending the reconnected message
;; while we are not keeping the disconnected delegate
(definition protected disconnected-groups
  (make-table test: equal?))

(definition (registered-disconnected-group character-name)
  (table-ref disconnected-groups character-name #f))

(definition (register-disconnected-group character-name group)
  (table-set! disconnected-groups character-name group))

(definition (unregister-disconnected-group character-name)
  (table-clear disconnected-groups character-name))

(definition (cleanup-disconnected-group group)
  (let ((character-name (table-find disconnected-groups group)))
    (when character-name
      (table-clear disconnected-groups character-name))))


(definition world-assets-mutex
  (make-mutex 'world-assets))


(definition (with-world-assets-mutex thunk)
  (mutex-lock! world-assets-mutex)
  (prog1 (thunk)
    (mutex-unlock! world-assets-mutex)))


(definition universe-asset-entries
  #f)


(definition stream-what
  'media)

(definition stream-loop?
  #f)


(definition (with-mobile thunk)
  (with-reentrant-task-mutex
    thunk))


(definition package debugging-service-offset
  45)


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                                        getter generate)
  (slot instances       initialize (make-table test: equal?) getter generate)
  (slot zones           initialize '()                       getter generate)
  (slot zones-available initialize '()                       getter generate)
  (slot groups          initialize '()                       getter generate)
  (slot ghost-groups    initialize '()                       getter generate)
  (slot circles-index   initialize (make-table test: equal?) getter generate)
  (slot hits            initialize 0                         getter generate)
  (slot urgency-server  initialize #f                        getter generate)
  (slot urgency-thread  initialize #f                        getter generate)
  (slot aliveness-task  initialize #f                        getter generate)
  (slot udp-server      initialize #f                        getter generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (set! configuration (get-server-configuration))
    (prepare-assets self)
    (let ((id (make-unique-id)))
      ;; not sure about this, for now lets use the hardcoded server-no = 0
      (set-client-id/no id server-no @w (literal->id id self)))
    (setup-circles self)
    (setup-instances self)
    (setup-zones self))
  
  
  (method override (prepare-assets self)
    (let ((assets-dir {Directory Universe "assets"}))
      (set! universe-assets (new Remote-Assets 'universe assets-dir)))
    (let ((assets-dir (new-directory directory "assets")))
      (set! world-assets (new Remote-Assets 'world assets-dir))))
  
  
  (method override (startup self)
    (nextmethod self)
    (start-urgency-server self)
    (start-aliveness-task self)
    (start-mobile-server (new-directory directory "certificates") (~ mobile-connect self) (~ mobile-serve self))
    (start-udp-server self)
    (delay-spawn-start-zone self)
    (add-exit-job! quit-processors)
    (when (boolean-argument "debugging" #f)
      (start-debugging-presence self)))
  
  
  ;; this is dangerous as a port sniffer can crash the debugging presence at the moment
  (method (start-debugging-presence self)
    (start-remote-presence purpose: 'debugging host: (effective-host configuration) service: (+ (effective-service configuration) debugging-service-offset))
    (setup-local-process))
  
  
  (method (spawn/cleanup-processor self world-asset-entries zone (delegate #f))
    (define (collect-zone-ghost-groups)
      (collect-if (lambda (group)
                    (equal? (get-zone group) zone))
                  ghost-groups))
    
    (let ((processor (spawn-processor (effective-host configuration)
                                      (effective-service configuration)
                                      world-asset-entries
                                      zone
                                      delegate)))
      (if (string? processor)
          processor
        (let ((zone-ghost-groups (collect-zone-ghost-groups)))
          (when (not-null? zone-ghost-groups)
            (let ((remote-processor (get-remote-proxy processor)))
              (for-each (lambda (ghost-group)
                          (let ((stone (get-stone ghost-group)))
                            (when stone
                              (calling-processor self processor
                                (lambda ()
                                  (delete-circle-stone remote-processor stone)))))
                          (set! ghost-groups (remove! ghost-group ghost-groups))
                          (delete-circle self (get-name ghost-group)))
                        zone-ghost-groups))))
        processor)))
  
  
  (method (delay-spawn-start-zone self)
    (delay-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (spawn/cleanup-processor self (~ collect-world-asset-entries self) 'start))))))
  
  
  (method override (enter self)
    (let ((me (current-me+)))
      (when me
        (set-name me (get-character-name configuration))
        (set-avatar me (get-character-avatar configuration))
        (set-color me (get-character-dye configuration)))))
  
  
  (method override (shutdown self)
    (stop-mobile-server)
    (stop-udp-server self)
    (stop-aliveness-task self)
    (stop-urgency-server self)
    (detach-clients self))
  
  
  (method override (get-udp-tier self)
    udp-server)
  
  
  (method (calling-processor self processor thunk)
    (thunk))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state self)
    'started)
    
  
  (method override (start self)
    )
  
  
  (method override (stop self)
    )
  
  
  (method override (restart self)
    )
  
  
  (method override (wait-started self)
    )
  
  
  (method override (wait-stopped self)
    )
  
  
  (method override (server-name self)
    "World")
  
  
  (method override (server-title self)
    "World")
  
  
  (method override (server-version self)
    (process-version (current-process)))
  
  
  (method override (server-host self)
    (host->string (listening-host (get-remote-listener))))
  
  
  (method override (server-service self)
    (port->string (listening-port (get-remote-listener))))
  
  
  (method override (server-hits self)
    hits)
  
  
  (method override (server-debug? self)
    #f)
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (next-literal-id!))
  
  
  (method override (tier-id->literal self id)
    (error "Unregistered id: {s}" id))
  
  
  ;;;
  ;;;; Delegates
  ;;;
  
  
  (method (count-delegates self)
    (length delegates))
  
  
  (method package (collect-delegates self)
    (sort ci<? delegates key: get-name))
  
  
  (method package (collect-disconnected self)
    (collect-if get-disconnected? delegates))
  
  
  ;;;
  ;;;; Instances
  ;;;
  
  
  (method (find-instance self uuid)
    (table-ref instances uuid #f))


  (method (setup-instances self)
    (let ((instances-dir (instances-dir self)))
      (when (exists? instances-dir)
        (iterate-directory instances-dir
          (lambda (instance-dir)
            (let ((file (new-file instance-dir ".instance")))
              (when (exists? file)
                (let ((instance (instantiate (read-form file))))
                  (let ((uuid (get-name instance)))
                    (table-set! instances uuid instance))))))
          files?: #f
          directories?: #t
          recursive?: #f))))
  
  
  (method (instances-dir self)
    (new-directory directory "instances"))
  
  
  ;;;
  ;;;; Zones
  ;;;


  (method (setup-zones self)
    (let ((zones-dir (zones-dir self))
          (queue (new-queue)))
      (when (exists? zones-dir)
        (let ((zones-file (new-file zones-dir ".zones")))
          (when (exists? zones-file)
            (set! zones-available (call-with-input-file (path-settings zones-file)
                                    read-all))))
        (iterate-directory zones-dir
          (lambda (path kind)
            (let ((zone-dir (new-directory zones-dir path)))
              (let ((file (new-file zone-dir ".zone")))
                (when (exists? file)
                  (enqueue queue path)))))
          full?: #f
          files?: #f
          directories?: #t
          recursive?: #t))
      (set! zones (queue-list queue))))
  
  
  (method (save-zones self)
    (let ((zones-dir (zones-dir self)))
      (let ((zones-file (new-file zones-dir ".zones")))
        (call-with-output-file (path-settings zones-file)
          (lambda (output)
            (for-each (lambda (path)
                        (format output "{s}{%}" path))
                      zones-available))))))
  
  
  (method package (zones-dir self)
    (new-directory directory "zones"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (setup-me self)
    (setup-current-me self)
    (register-id (current-me) (make-unique-id)))
  
  
  (method override (save-me self)
    (save-current-me self))
  
  
  (method override (player-file self name)
    (new-file directory '("start" ".player")))
  
  
  (method override (anonymous self)
    "Server")
  
  
  ;;;
  ;;;; Groups
  ;;;
  
  
  (method (find-group self name/no)
    (if (integer? name/no)
        (find-if (lambda (group)
                   (= (get-no group) name/no))
                 groups)
      (find-if (lambda (group)
                 (equal? (get-name group) name/no))
               groups)))
  
  
  (method (group-already-exists? self name/no)
    (define (standardize name)
      (trim-inner-whitespace (trim-whitespace name)))
    
    (if (integer? name/no)
        (find-group self name/no)
      (let ((name (standardize name/no)))
        (find-if (lambda (group)
                   (let ((group-name (get-name group)))
                     (and group-name
                          (ci=? (standardize group-name) name))))
                 groups))))
  
  
  (method (create-group self delegate name persistent? require-microphone? require-camera? auto-create? stone zoom? link description)
    (logger/activity self "Create group{? {a}~} ({a})" name (get-name delegate))
    (let ((owner (get-personal-key delegate))
          (created (date-truncate-nanosecond (current-date)))
          (invite-only? #f)
          (shape 'flow))
      (let ((group (new Server-Group name owner created persistent? invite-only? require-microphone? require-camera? (if auto-create? 'start (get-zone delegate)) stone shape zoom? link description)))
        (set! groups (cons group groups))
        (when name
          (save-circle self group))
        group)))
  
  
  (method (delete-group self delegate group)
    (logger/activity self "Delete group{? {a}~} ({a})" (get-name group) (if delegate (get-name delegate) "Server"))
    (set! groups (remove! group groups))
    (cleanup-disconnected-group group)
    (let ((name (get-name group)))
      (when name
        (delete-circle self name))))
  
  
  (method (maybe-delete-group self delegate group (delete-persistent? #f))
    (if (or (and (get-persistent? group) (not delete-persistent?))
            (has-members? self group)
            (has-server-streams? self group))
        (begin
          (when (not (has-members? self group))
            (set-invite-only? group #f))
          #f)
      (delete-group self delegate group)
      (when (get-name group)
        (broadcast-circle-removed self group)
        (let ((stone (get-stone group)))
          ;; not sure we always have the stone
          (when stone
            (let ((processor (find-processor (get-zone group))))
              (when processor
                (let ((remote-processor (get-remote-proxy processor)))
                  (calling-processor self processor
                    (lambda ()
                      (delete-circle-stone remote-processor stone)))))))))
      #t))
  
  
  (method (maybe-disband-group self delegate group)
    (let ((members (get-members group)))
      (if (= (length members) 1)
          (begin
            (disband-group self delegate group)
            (broadcast-hierarchy self)
            #t)
        #f)))
  
  
  (method (disband-group self delegate group)
    (logger/activity self "Disband group{? {a}~} ({a})" (get-name group) (get-name delegate))
    (for-each (lambda (delegate)
                (leave-group self delegate group)
                (if (is? delegate Mobile-Delegate)
                    (send-disband self delegate)
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (server-disband client))))))
              (get-members group))
    (set! groups (remove! group groups))
    (cleanup-disconnected-group group))
  
  
  (method (has-members? self group)
    (not-null? (get-members group)))
  
  
  (method (has-server-streams? self group)
    (not-null? (get-server-streams group)))
  
  
  (method (join-group self delegate group)
    (let ((delegate-name (get-name delegate))
          (group-name (get-name group)))
      (logger/activity self "Join group{? {a}~} ({a})" group-name (get-name delegate))
      (set-group delegate group)
      (unless group-name
        (for-each (lambda (delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-join self delegate delegate-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-join client delegate-name))))))
                  (get-members group)))
      (set-members group (cons delegate (get-members group)))
      (update-group-streaming self group)
      (wait-keyframes udp-server delegate (delegate->connection self delegate))))
  
  
  (method (leave-group self delegate group)
    (let ((delegate-name (get-name delegate))
          (group-name (get-name group)))
      (logger/activity self "Leave group{? {a}~} ({a})" group-name delegate-name)
      (unless (is? delegate Mobile-Delegate)
        (let ((connection (delegate->connection self delegate)))
          (done-keyframes udp-server delegate connection)
          (leave-group-reset connection)))
      (set-group delegate #f)
      (set-members group (remove delegate (get-members group)))
      (update-group-streaming self group)
      (unless group-name
        (for-each (lambda (delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-leave self delegate delegate-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-leave client delegate-name))))))
                  (get-members group)))
      (if (get-name group)
          (maybe-delete-group self delegate group)
        (maybe-disband-group self delegate group))))
  
  
  (method (delegate->connection self delegate)
    (no->connection udp-server (get-no delegate)))
  
  
  (method (update-group-streaming self group)
    (let ((members (get-members group))
          (ordered-streams (get-ordered-streams group)))
      (when (not-null? ordered-streams)
        (let ((shape (get-shape group))
              (count (length ordered-streams))
              (stream-nos (map get-no ordered-streams)))
          (let ((heart (and (eq? shape 'heart) (car stream-nos))))
            (define (update-download connection)
              (let ((level (get-graphic-level connection))
                    (mode (get-circle-mode connection))
                    (focused (get-circle-focused connection))
                    (need (get-download-need connection)))
                (cond ;; tiled
                      ((or (eq? mode 'avatar)
                           (and (eq? mode 'presence)
                                (memq? shape '(round flow)))
                           (eq? mode 'gallery))
                       (let ((tiled-level (tiled-level level count)))
                         (for-each (lambda (stream)
                                     (let ((stream-no (get-no stream))
                                           (video-levels (get-video-levels stream)))
                                       (when (not-null? video-levels)
                                         (if (not (get-video-on? stream))
                                             (table-set! need stream-no #f)
                                           (let ((level tiled-level))
                                             (table-set! need stream-no (find-video-level level video-levels)))))))
                                   ordered-streams)))
                      ;; focus
                      ((eq? mode 'focus)
                       (for-each (lambda (stream)
                                   (let ((stream-no (get-no stream))
                                         (video-levels (get-video-levels stream)))
                                       (when (not-null? video-levels)
                                         (if (not (get-video-on? stream))
                                             (table-set! need stream-no #f)
                                           (let ((level (if (eqv? stream-no focused)
                                                            (focused-level level)
                                                          widget-graphic-level)))
                                             (table-set! need stream-no (find-video-level level video-levels)))))))
                                 ordered-streams))
                      ;; heart
                      (else
                       (let ((tiled-level (tiled-level level count)))
                         (for-each (lambda (stream)
                                     (let ((stream-no (get-no stream))
                                           (video-levels (get-video-levels stream)))
                                       (when (not-null? video-levels)
                                         (if (not (get-video-on? stream))
                                             (table-set! need stream-no #f)
                                           (let ((level (if (eqv? stream-no heart)
                                                            (max level tiled-level)
                                                          tiled-level)))
                                             (table-set! need stream-no (find-video-level level video-levels)))))))
                                   ordered-streams))))))
            
            (define (update-upload no upload-needs)
              (let ((upload-changed '()))
                (for-each (lambda (stream)
                            (when (= (get-origin stream) no)
                              (let ((stream-no (get-no stream))
                                    (upload '()))
                                (for-each (lambda (member)
                                            (let ((download-no (get-no member)))
                                              (when (/= download-no no)
                                                (let ((connection (no->connection udp-server download-no)))
                                                  (let ((need (table-ref (get-download-need connection) stream-no #f)))
                                                    (when need
                                                      (unless (memv? need upload)
                                                        (set! upload (cons need upload)))))))))
                                          members)
                                (let ((upload (sort < upload)))
                                  (unless (equal? upload (table-ref upload-needs stream-no #f))
                                    (table-set! upload-needs stream-no upload)
                                    (set! upload-changed (cons (cons stream-no upload) upload-changed)))))))
                          ordered-streams)
                upload-changed))
            
            ;; download
            (for-each (lambda (member)
                        (let ((no (get-no member)))
                          (let ((connection (no->connection udp-server no)))
                            (update-download connection))))
                      members)
            ;; server upload
            (let ((no server-no))
              (let ((upload-needs (get-needs (no->upload udp-server no))))
                (let ((upload-changed (update-upload no upload-needs)))
                  (when (not-null? upload-changed)
                    (update-streaming udp-server upload-changed)))))
            ;; clients upload
            (for-each (lambda (member)
                        (let ((no (get-no member)))
                          (let ((upload-needs (get-needs (no->upload udp-server no))))
                            (let ((upload-changed (update-upload no upload-needs)))
                              (when (not-null? upload-changed)
                                (unless (is? member Mobile-Delegate)
                                  (let ((client (get-client member)))
                                    (calling-client self member
                                      (lambda ()
                                        (upload-update client upload-changed))))))))))
                      members)
            ;; download
            (update-group-download self group #f #f))))))
  
  
  (method package (update-group-download self group stream-target stream-closing)
    (let ((members (get-members group))
          (ordered-streams (get-ordered-streams group)))
      (for-each (lambda (stream)
                  (let ((stream-no (get-no stream))
                        (origin (get-origin stream)))
                    (when (or (not stream-target)
                              (= stream-no stream-target))
                      ;; download
                      (let ((upload-specs (table-ref (get-specs (no->upload udp-server origin)) stream-no '())))
                        (for-each (lambda (member)
                                    (let ((no (get-no member)))
                                      (when (/= no origin)
                                        (let ((connection (no->connection udp-server no))
                                              (client (get-client member)))
                                          (unless (null? upload-specs)
                                            (let ((need (table-ref (get-download-need connection) stream-no #f)))
                                              (when need
                                                (let ((current-spec (table-ref (get-download-spec connection) stream-no #f))
                                                      (download-spec (find-video-level need upload-specs key: car)))
                                                  (unless (equal? current-spec download-spec)
                                                    ;; remember if current channel is closing
                                                    (when stream-closing
                                                      (when current-spec
                                                        (let ((current-level (car current-spec)))
                                                          (when (memv? current-level stream-closing)
                                                            (table-set! (get-download-closing connection) stream-no current-level)))))
                                                    (table-set! (get-download-spec connection) stream-no download-spec)
                                                    (calling-client self member
                                                      (lambda ()
                                                        (download-update client stream-no download-spec))))
                                                  ;; reset when not closing anymore
                                                  (when stream-closing
                                                    (let ((current-closing (table-ref (get-download-closing connection) stream-no #f)))
                                                      (when (and current-closing (not (memv? current-closing stream-closing)))
                                                        (table-set! (get-download-closing connection) stream-no #f))))))))))))
                                  members))
                      ;; receivers
                      (update-stream-receivers udp-server stream))))
                ordered-streams)))
  
  
  (method package (client-change-upload-specs self client stream-no upload-specs upload-closing)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (let ((origin (get-no delegate))
              (upload (no->upload udp-server (get-no delegate))))
          (when upload
            (unless (and (equal? (table-ref (get-specs upload) stream-no #f) upload-specs)
                         (equal? (table-ref (get-closing upload) stream-no #f) upload-closing))
              (table-set! (get-specs upload) stream-no upload-specs)
              (table-set! (get-closing upload) stream-no upload-closing)
              (let ((group (get-group delegate)))
                (when group
                  (update-group-download self group stream-no upload-closing)))))))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method package (client-invitation self client invitation-word name)
    (define (name-already-taken?)
      (continuation-capture
        (lambda (return)
          (iterate-identities directory
            (lambda (key identity)
              (when (ci=? name (get-name identity))
                (continuation-return return #t))))
          #f)))
    
    (let ((invitation-word (standardize-invitation-word invitation-word)))
      (let ((invitation (retrieve-invitation directory invitation-word)))
        (if (not invitation)
            (begin
              (logger/activity self "Invalid invitation ({a})" invitation-word)
              (list #f "Invalid invitation"))
          (let ((expires (get-expires invitation)))
            (if (and expires (nu>? (current-date) expires))
                (begin
                  (logger/activity self "Invitation has expired ({a})" invitation-word)
                  (list #f "Invitation has expired"))
              (if (name-already-taken?)
                  (list #f "Name is already taken")
                (let ((key (generate-identity directory))
                      (type #f)
                      (role #f)
                      (admin? #f)
                      (email #f)
                      (inviter invitation-word))
                  (logger/activity self "Accept invitation {a} ({a})" name invitation-word)
                  (add-identity directory key name type role admin? email inviter)
                  (list key #f)))))))))
  
  
  (method package (client-connect self client client-uuid personal-key machine-identity machine-caps machine-features character-avatar character-dye character-script cached-literals)
    (let ((identity (retrieve-identity directory personal-key)))
      (if (not identity)
          "Invalid personal key"
        (let ((character-name (get-name identity))
              (character-role (or (get-role identity) default-role))
              (character-admin? (get-admin? identity))
              (character-verified? (get-verified? identity))
              (character-verifier (get-verifier identity)))
          (if (and max-connections (>= (count-delegates self) max-connections))
              (begin
                (logger/activity self "Max connections reached ({a})" character-name)
                (format "Max {a} connections reached" max-connections))
            (let ((existing-delegate (find-delegate-by-name self character-name)))
              (when existing-delegate
                (kick-client self existing-delegate)
                (set! existing-delegate #f))
              (if (and existing-delegate (not (get-disconnected? existing-delegate)))
                  (begin
                    (logger/activity self "{a} is already connected" character-name)
                    (format "{a} is already connected" character-name))
                ;; register client
                (let ((reconnect-info (and existing-delegate
                                           (let ((group (get-group existing-delegate)))
                                             (list (get-mode existing-delegate)
                                                   (get-zone existing-delegate)
                                                   (and group
                                                        (or (get-name group)
                                                            (get-no group)))
                                                   (and group
                                                        (get-require-microphone? group))
                                                   (and group
                                                        (get-require-camera? group)))))))
                  (let ((delegate (cond (existing-delegate
                                          (reconnect-client self client existing-delegate client-uuid)
                                          existing-delegate)
                                        (else
                                         (let ((id (make-unique-id)))
                                           (let ((delegate (new Client-Delegate client 'connected client-uuid id (literal->id id self) character-name character-avatar character-dye character-script character-role character-admin? character-verified? character-verifier personal-key))
                                                 (connected (date-truncate-nanosecond (current-date))))
                                             (modify-identity directory personal-key
                                               (lambda (designer identity)
                                                 (set-property designer identity 'connected connected)))
                                             delegate)))))
                        (machine (retrieve-machine directory character-name machine-identity machine-caps machine-features))
                        (cached-ids (map literal->id cached-literals)))
                    (logger/activity self "{a} {a}" (if existing-delegate "Reconnect" "Connect") character-name)
                    (unless existing-delegate
                      (set! delegates (cons delegate delegates))
                      (let ((group (registered-disconnected-group character-name)))
                        (when group
                          (unregister-disconnected-group character-name)
                          (broadcast-reconnected-to-group self delegate group))))
                    ;; retrieve character
                    (let ((client-id (get-id delegate))
                          (client-no (get-no delegate))
                          (machine-identity (get-identity machine))
                          (machine-settings (get-settings machine))
                          (universe-asset-entries (cache-universe-asset-entries self))
                          (world-asset-entries (collect-world-asset-entries self))
                          (banner (get-banner configuration))
                          (welcome (format "Welcome to {a}!" tier-title))
                          (character (character-retrieve self character-name character-avatar character-dye))
                          (character-delegate delegate))
                      (set-character character-delegate character)
                      (list client-id
                            client-no
                            machine-identity
                            machine-settings
                            character-name
                            character-role
                            character-admin?
                            character-verified?
                            universe-asset-entries
                            world-asset-entries
                            banner
                            welcome
                            reconnect-info
                            cached-ids)))))))))))
    
  
  (method package (client-enter self client zone)
    (let ((delegate (find-delegate self client)))
      (let ((client-uuid (get-uuid delegate))
            (client-id (get-id delegate))
            (client-no (get-no delegate))
            (character-name (get-name delegate))
            (character-avatar (get-avatar delegate))
            (character-dye (get-dye delegate))
            (character-script (get-script delegate))
            (character-role (get-role delegate))
            (character-admin? (get-admin? delegate)))
        (let ((processor (spawn/cleanup-processor self (~ collect-world-asset-entries self) zone)))
          (if (string? processor)
              processor
            (let ((remote-processor (get-remote-proxy processor)))
              (let ((enter-info (client-enter remote-processor client client-uuid client-id client-no character-name character-avatar character-dye character-script character-role character-admin?))
                    (circles (collect-circles self zone)))
                (if (string? enter-info)
                    enter-info
                  (set-zone delegate zone)
                  (set-processor delegate processor)
                  (add-delegate processor delegate)
                  (append (cons (proxy-connection-info client remote-processor) enter-info)
                          (list circles))))))))))

  
  (method package (client-start self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (let ((processor (get-processor delegate)))
          (when processor
            (let ((processor-proxy (get-remote-proxy processor)))
              (client-ready processor-proxy client))))
        (set-state delegate 'started)
        (broadcast-hierarchy self delegate)
        (broadcast-entered self delegate))))
  
  
  (method package (client-ready self client)
    (collect-hierarchy self))
  
  
  (method package (client-stop self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (delegate-stop self delegate))))
  
  
  (method (delegate-stop self delegate)
    (let ((group (get-group delegate)))
      (when group
        (leave-group self delegate group)))
    (delete-owner-zoom-circles self delegate)
    (set-state delegate 'stopped))
  
  
  (method (delete-owner-zoom-circles self delegate)
    (let ((key (get-personal-key delegate)))
      (for-each (lambda (group)
                  (when (and (get-zoom? group)
                             (not (get-persistent? group))
                             (equal? (get-owner group) key))
                    (maybe-delete-group self delegate group)))
                groups)))
  
  
  (method package (client-deconnect self client)
    ;; find server client
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (let ((name (get-name delegate)))
          (logger/activity self "Deconnect {a}" name)
          (delegate-deconnect self delegate)))))
  
  
  (method (delegate-deconnect self delegate (broadcast-exited?: broadcast-exited? #t))
    (let ((client (get-client delegate))
          (name (get-name delegate)))
      ;; deconnect udp
      (when udp-server
        (deconnect-source udp-server (get-no delegate)))
      ;; store character
      (character-store self (get-character delegate))
      ;; leave zone
      (let ((processor (get-processor delegate)))
        (when processor
          (let ((processor-proxy (get-remote-proxy processor)))
            (when (remote-proxy-connected? processor-proxy)
              (client-exit processor-proxy client name)))
          (remove-delegate processor delegate)))
      ;; unregister delegate
      (set! delegates (remove! delegate delegates))
      ;; update state
      (set-state delegate 'deconnected)
      ;; closing remote
      (closing-remote-proxy-safe client)
      ;; urgency
      (close-urgency self delegate)
      ;; broadcast
      (when broadcast-exited?
        (broadcast-exited self delegate))
      (broadcast-hierarchy self)))
  
  
  (method package (client-reconnection self client zone group)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (server-unregister-streams self (get-no delegate)))))
  
  
  (method package (client-visit self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-mode delegate 'visitor)
        (client-mode (get-remote-proxy (get-processor delegate)) client 'visitor)
        (broadcast-hierarchy self))))
  
  
  (method package (client-observe self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-mode delegate 'observer)
        (client-mode (get-remote-proxy (get-processor delegate)) client 'observer)
        (broadcast-hierarchy self))))
  
  
  (method package (client-participate self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-mode delegate 'participant)
        (client-mode (get-remote-proxy (get-processor delegate)) client 'participant)
        (broadcast-hierarchy self))))
  
  
  (method package (client-sleep self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-asleep? delegate #t)
        (broadcast-hierarchy self))))
  
  
  (method package (client-wake self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-asleep? delegate #f)
        (broadcast-hierarchy self)
        ;; deliver queued messages
        (let ((queue (get-message-queue delegate)))
          (let ((messages (queue-list queue)))
            (when (not-null? messages)
              (reset-queue queue)
              (deliver-messages self delegate messages)))))))
  
  
  (method (broadcast-circle-added self circle)
    (let ((name (get-name circle))
          (zone (get-zone circle))
          (stone (get-stone circle)))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (when (equal? (get-zone delegate) zone)
                      (if (is? delegate Mobile-Delegate)
                          (send-circle-added self delegate name stone)
                        (let ((client (get-client delegate)))
                          (calling-client self delegate
                            (lambda ()
                              (circle-added client name stone))))))))
                delegates)))
  
  
  (method (broadcast-circle-removed self circle)
    (let ((name (get-name circle))
          (zone (get-zone circle)))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (when (equal? (get-zone delegate) zone)
                      (if (is? delegate Mobile-Delegate)
                          (send-circle-removed self delegate name)
                        (let ((client (get-client delegate)))
                          (calling-client self delegate
                            (lambda ()
                              (circle-removed client name))))))))
                delegates)))
  
  
  (method (broadcast-circle-change-shape self client-delegate circle shape)
    (let ((name (get-name circle))
          (zone (get-zone circle)))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (unless (eq? delegate client-delegate)
                      (unless (is? delegate Mobile-Delegate)
                        (let ((client (get-client delegate)))
                          (calling-client self delegate
                            (lambda ()
                              (circle-change-shape client name shape))))))))
                (get-members circle))))
  
  
  (method (broadcast-circle-change-order self client-delegate circle order)
    (let ((name (get-name circle))
          (zone (get-zone circle)))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'started)
                    (unless (is? delegate Mobile-Delegate)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (circle-change-order client name order)))))))
                (get-members circle))))
  
  
  (method (broadcast-hierarchy self (except-delegate #f))
    (let ((hierarchy (collect-hierarchy self))
          ;; quick hack
          (mobile-hierarchy (collect-hierarchy self #t)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate except-delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-people self delegate mobile-hierarchy)
                      (when (eq? (get-state delegate) 'started)
                        (let ((client (get-client delegate)))
                          (calling-client self delegate
                            (lambda ()
                              (hierarchy-update client hierarchy))))))))
                delegates)))
  
  
  (method (broadcast-entered self client-delegate)
    (let ((client-id (get-id client-delegate))
          (client-no (get-no client-delegate))
          (client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-entered self delegate client-no client-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-entered client client-id client-no client-name)))))))
                delegates)))
  
  
  (method (broadcast-exited self client-delegate)
    (let ((client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-exited self delegate client-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-exited client client-name)))))))
                delegates)))
  
  
  (method (character-retrieve self character-name character-avatar character-dye)
    (let ((file (new-file (characters-dir self) (format "{a}.character" character-name))))
      (let ((character
              (if (exists? file)
                  (let ((character (instantiate (read-form file))))
                    (set-name character character-name)
                    (set-avatar character character-avatar)
                    (set-dye character character-dye)
                    character)
                (let ((units '(world.character)))
                  (let ((tag '(<Character>))
                        (data (new Data zone-version 'jazz units #f)))
                    (let ((form (construct-form tag (imports-locator units) data)))
                      (set-origin form file)
                      (let ((character (instantiate form)))
                        (set-name character character-name)
                        (set-avatar character character-avatar)
                        (set-dye character character-dye)
                        (set-zone character 'start)
                        character)))))))
        character)))
  
  
  (method (character-store self character)
    (let ((file (new-file (characters-dir self) (format "{a}.character" (get-name character)))))
      (create-directories file)
      (let ((designer (new Former form: (get-form character) reference: character)))
        (define (save-character)
          (set-property designer character 'zone (get-zone character)))
        
        (save-character)
        (save designer))))
  
  
  (method (characters-dir self)
    (new-directory directory "characters"))
  
  
  (method package (client-alive self client)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (when delegate
        (set-alive delegate (current-seconds)))))
  
  
  (method package (client-verify self client verifier verified)
    (let ((verifier-delegate (find-delegate self client))
          (verified-delegate (find-delegate-by-name self verified)))
      (if (not verified-delegate)
          "Person not found"
        (logger/activity self "Verify {a} ({a})" verified (get-name verifier-delegate))
        (let ((verifier-key (get-personal-key verifier-delegate))
              (verified-client (get-client verified-delegate))
              (verified-key (get-personal-key verified-delegate)))
          (verify-identity directory verified-key verifier-key)
          (set-verified? verified-delegate #t)
          (set-verifier verified-delegate verifier-key)
          (broadcast-hierarchy self)
          (if (is? verified-delegate Mobile-Delegate)
              (send-verified self verified-delegate verifier)
            (calling-client self verified-delegate
              (lambda ()
                (server-verified verified-client verifier)))))
        #f)))
  
  
  (method package (client-upgrade self client upgrader-delegate upgraded-delegate role)
    (let ((upgrader (get-name upgrader-delegate))
          (upgraded (get-name upgraded-delegate)))
      (logger/activity self "Upgrade {a} role ({a})" upgraded (get-name upgrader-delegate))
      (let ((upgrader-key (get-personal-key upgrader-delegate))
            (upgraded-client (get-client upgraded-delegate))
            (upgraded-key (get-personal-key upgraded-delegate)))
        (upgrade-identity directory upgraded-key upgrader-key role)
        (set-role upgraded-delegate role)
        (client-role (get-remote-proxy (get-processor upgraded-delegate)) upgraded-client role)
        (when (is-not? upgraded-delegate Mobile-Delegate)
          (calling-client self upgraded-delegate
            (lambda ()
              (server-upgraded upgraded-client upgrader role)))))))
  
  
  (method package (client-invite self client recipient circle-name)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-invite self delegate recipient circle-name))))
  
  
  (method (delegate-invite self delegate recipient circle-name)
    (let ((recipient-delegate (search-for-delegate self recipient)))
      (if (string? recipient-delegate)
          recipient-delegate
        (if (eq? delegate recipient-delegate)
            (format "You cannot invite yourself")
          (if (get-group recipient-delegate)
              (if (and circle-name (equal? (get-name (get-group recipient-delegate)) circle-name))
                  (format "{a} is already in your circle" recipient)
                (format "{a} is already in a group" recipient))
            (if (memq? delegate (get-invites recipient-delegate))
                #f
              (let ((client (get-client recipient-delegate))
                    (sender (get-name delegate)))
                (if (is? recipient-delegate Mobile-Delegate)
                    (send-invite self recipient-delegate sender)
                  (calling-client self recipient-delegate
                    (lambda ()
                      (server-invite client sender circle-name
                        (and circle-name (get-require-microphone? (get-group delegate)))
                        (and circle-name (get-require-camera? (get-group delegate))))))))
              (add-invite recipient-delegate delegate)
              #f))))))
  
  
  (method package (client-accept self client sender circle-name)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-accept self delegate sender circle-name))))
  
  
  (method (delegate-accept self delegate sender circle-name)
    (if (get-group delegate)
        (format "You are already in a group")
      (let ((sender-delegate (find-delegate-by-ci-name self sender)))
        (if (not sender-delegate)
            (format "Unable to find {a}" sender)
          (let ((sender-group (get-group sender-delegate)))
            (if (and circle-name (not sender-group))
                (format "Unable to find circle")
              (let ((group (if sender-group
                               (begin
                                 (when circle-name
                                   (set-mode delegate 'participant))
                                 (join-group self delegate sender-group)
                                 sender-group)
                             (let ((group (create-group self sender-delegate #f #f #f #f #f #f #f #f #f)))
                               (join-group self sender-delegate group)
                               (join-group self delegate group)
                               group))))
                (let ((sender-client (get-client sender-delegate))
                      (recipient (get-name delegate)))
                  (if (is? sender-delegate Mobile-Delegate)
                      (send-accept self sender-delegate recipient)
                    (calling-client self sender-delegate
                      (lambda ()
                        (server-accept sender-client recipient circle-name)))))
                (remove-invite delegate sender-delegate)
                (broadcast-hierarchy self)
                (if (is? delegate Mobile-Delegate)
                    (get-no group)
                  (group-information self group)))))))))
  
  
  (method package (client-decline self client sender reason)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-decline self delegate sender reason))))
  
  
  (method (delegate-decline self delegate sender reason)
    (let ((sender-delegate (find-delegate-by-ci-name self sender)))
      (if (not sender-delegate)
          (format "Unable to find {a}" sender)
        (let ((sender-client (get-client sender-delegate))
              (recipient (get-name delegate)))
          (if (is? sender-delegate Mobile-Delegate)
              (send-decline self sender-delegate recipient)
            (calling-client self sender-delegate
              (lambda ()
                (server-decline sender-client recipient reason)))))
        (remove-invite delegate sender-delegate)
        #f)))
  
  
  (method package (client-problem self client sender problem)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-problem self delegate sender problem))))
  
  
  (method (delegate-problem self delegate sender problem)
    (let ((sender-delegate (find-delegate-by-ci-name self sender)))
      (if (not sender-delegate)
          (format "Unable to find {a}" sender)
        (let ((sender-client (get-client sender-delegate))
              (recipient (get-name delegate)))
          (if (is? sender-delegate Mobile-Delegate)
              (send-problem self sender-delegate recipient)
            (calling-client self sender-delegate
              (lambda ()
                (server-problem sender-client recipient problem)))))
        (remove-invite delegate sender-delegate)
        #f)))
  
  
  (method package (client-teleport self client teleported zone position sight)
    (let ((delegate (find-delegate self client)))
      ;; aec robust
      (and delegate
           (delegate-teleport self delegate teleported zone position sight))))
  
  
  (method (delegate-teleport self delegate teleported zone position sight)
    (let ((teleported-delegate (search-for-delegate self teleported)))
      (if (string? teleported-delegate)
          teleported-delegate
        (if (eq? delegate teleported-delegate)
            (format "You cannot teleport yourself")
          (if (eq? (get-role teleported-delegate) 'user)
              (format "A Circler cannot be teleported")
            (let ((client (get-client teleported-delegate))
                  (teleporter (get-name delegate)))
              (when (is-not? teleported-delegate Mobile-Delegate)
                (calling-client self teleported-delegate
                  (lambda ()
                    (server-teleport client teleporter zone position sight)))))
            #f)))))
  
  
  (method package (client-status self client status)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (when delegate
        (modify-identity directory (get-personal-key delegate)
          (lambda (designer identity)
            (set-property designer identity 'status status))))))
  
  
  (method package (client-leave self client)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (and delegate
           (delegate-leave self delegate))))
  
  
  (method (delegate-leave self delegate)
    (let ((group (get-group delegate)))
      (if (not group)
          (format "You are not in a group")
        (let ((members (get-members group)))
          (leave-group self delegate group)
          (broadcast-hierarchy self)
          #f))))
  
  
  (method package (client-message self client kind recipient message)
    ;; aec robust
    (let ((delegate (find-delegate self client)))
      (and delegate
           (delegate-message self delegate kind recipient message))))
  
  
  (method package (client-log self client time message)
    (server-log client time message))
  
  
  (method package (processor-log self processor time message)
    (server-log processor time message))
  
  
  (method package (client-connected-player self client no)
    (connected-player self no))
  
  
  (method override (connected-player self no)
    (if (= no client-no)
        "Server"
      (let ((delegate (find-delegate-by-no self no)))
        (and delegate
             (get-name delegate)))))
  
  
  (method package (client-connected-players self client)
    (connected-players self))
  
  
  (method package (client-available-templates self client)
    (available-templates self))
  
  
  (method package (client-available-zone-base self client from)
    (available-zone-base self from))
  
  
  (method package (client-available-zone-base? self client base)
    (available-zone-base? self base))
  
  
  (method package (client-create-zone self client from base)
    (and (create-zone self from base)
         (list 'zone base)))
  
  
  (method package (client-available-zones self client)
    (available-zones self))
  
  
  (method package (client-load-zone self client zone)
    (let ((delegate (with-task-mutex
                      (lambda ()
                        (find-delegate self client)))))
      ;; aec robust
      (when delegate
        (let ((spawn-result #f))
          (let ((spawn-thread (current-thread)))
            (delay-event
              (lambda ()
                (thread-join! spawn-thread)
                (let ((error-string (if (string? spawn-result) spawn-result #f)))
                  (with-task-mutex
                    (lambda ()
                      (calling-client self delegate
                        (lambda ()
                          (zone-loaded client zone error-string)))))))))
          (set! spawn-result (spawn/cleanup-processor self (~ collect-world-asset-entries self) zone delegate))))))
  
  
  (method package (client-change-zone self client zone)
    (change-client-zone self client zone))
  
  
  (method package (client-changed-zone self client)
    (changed-client-zone self client))
  
  
  (method package (client-create-group self client name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone zoom? link description)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (delegate-create-group self delegate name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone zoom? link description))))
  
  
  (method (delegate-create-group self delegate name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone zoom? link description)
    (if (and (not auto-create?) (get-group delegate))
        (format "You are already in a group")
      (let ((existing-group (and name (group-already-exists? self name))))
        (if existing-group
            (format "{a}{? {a}~} already exists" (group-domain-name self name) name)
          (let ((group (create-group self delegate name persistent? require-microphone? require-camera? auto-create? stone zoom? link description)))
            (when name
              (broadcast-circle-added self group))
            (when broadcast-hierarchy?
              (broadcast-hierarchy self))
            (get-no group))))))
  
  
  (method package (client-create-circle self client name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone zoom? link description mode)
    (let ((err (client-create-group self client name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone zoom? link description)))
      (if (string? err)
          err
        (let ((name-id (literal->id name))
              (group-info (client-join-group self client name mode)))
          (cons name-id group-info)))))
  
  
  (method package (client-delete-group self client name/no)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (delegate-delete-group self delegate name/no))))
  
  
  (method (delegate-delete-group self delegate name/no)
    (let ((group (find-group self name/no))
          (group-name (and (string? name/no) name/no)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
        (if (has-members? self group)
            (format "{a}{? {a}~} still has members" (group-domain-name self name/no) group-name)
          (if (has-server-streams? self group)
              (format "{a}{? {a}~} still has streams" (group-domain-name self name/no) group-name)
            (when (maybe-delete-group self delegate group #t)
              (broadcast-hierarchy self))
            #f)))))
  
  
  (method package (client-group-requirements self client name/no)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (if (get-group delegate)
            (format "You are already in a group")
          (let ((group (find-group self name/no))
                (group-name (and (string? name/no) name/no)))
            (if (not group)
                (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
              (if (get-invite-only? group)
                  (format "Joining this {a} is by invite only" (downcase (group-domain-name self name/no)))
                (group-requirements self group))))))))
  
  
  (method package (client-join-group self client name/no mode)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (if (get-group delegate)
            (format "You are already in a group")
          (let ((group (find-group self name/no))
                (group-name (and (string? name/no) name/no)))
            (if (not group)
                (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
              (if (get-invite-only? group)
                  (format "Joining this {a} is by invite only" (downcase (group-domain-name self name/no)))
                (when mode
                  (set-mode delegate mode))
                (join-group self delegate group)
                (broadcast-hierarchy self)
                (group-information self group))))))))
  
  
  (method package (client-rejoin-group self client name/no)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((group (find-group self name/no))
              (group-name (and (string? name/no) name/no)))
          (if (not group)
              (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
            (group-information self group))))))
  
  
  (method package (client-leave-group self client name/no)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          #f
        (let ((group (find-group self name/no)))
          (if (not group)
              #f
            (prog1 (leave-group self delegate group)
              (broadcast-hierarchy self)))))))
  
  
  (method package (client-change-mode/focused self client mode focused)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (let ((origin (get-no delegate))
              (connection (delegate->connection self delegate)))
          (when connection
            (set-circle-mode connection mode)
            (set-circle-focused connection focused)
            (let ((group (get-group delegate)))
              (when group
                (update-group-streaming self group))))))))
  
  
  (method package (client-register-stream self client sender name source-kind video-levels video-on? channels)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          (format "Delegate not found")
        (let ((group (get-group client-delegate)))
          (if (not group)
              (format "You are not in a group")
            (let ((origin (get-no client-delegate))
                  (recipient group)
                  (exclude-register client-delegate)
                  (exclude-broadcast client-delegate))
              (bind (stream . server-channels) (server-register-stream self sender name origin source-kind video-levels video-on? channels recipient exclude-register exclude-broadcast #f)
                (update-group-streaming self recipient)
                (cons (get-no stream) (map get-no server-channels)))))))))
  
  
  (method package (server-register-stream self sender name origin source-kind video-levels video-on? channels recipient exclude-register exclude-broadcast server-sender?)
    (let ((no (next-stream-no!)))
      (let ((stream (register-server-stream udp-server sender name no origin source-kind video-levels video-on? recipient exclude-register exclude-broadcast)))
        (let ((server-channels (map (lambda (channel)
                                      (bind (media-kind source-kind level resolution framerate bitrate codec caps metadata send-state) channel
                                        (server-add-channel self no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state server-sender?)))
                                    channels))
              (members (get-members recipient))
              (group-no (get-no recipient))
              (group-require-microphone? (get-require-microphone? recipient))
              (group-require-camera? (get-require-camera? recipient)))
          (let ((extended-channels (map (lambda (descriptor server-channel)
                                          (cons (get-no server-channel) descriptor))
                                        channels
                                        server-channels)))
            (for-each (lambda (delegate)
                        (unless (eq? delegate exclude-register)
                          (when (eq? (get-state delegate) 'started)
                            (unless (is? delegate Mobile-Delegate)
                              (let ((client (get-client delegate)))
                                (calling-client self delegate
                                  (lambda ()
                                    (stream-add client group-no group-require-microphone? group-require-camera? sender name no origin source-kind video-levels extended-channels))))))))
                      members)
            (cons stream server-channels))))))
  
  
  (method package (client-unregister-stream self client stream-no)
    (server-unregister-stream self stream-no)
    #f)
  
  
  (method package (server-unregister/disconnect-streams self client-no)
    (iterate-table (get-server-streams udp-server)
      (lambda (no stream)
        (when (= (get-origin stream) client-no)
          (if (eq? (get-source-kind stream) 'live)
              (server-disconnect-stream self no)
            (server-unregister-stream self no))))))
  
  
  (method package (server-unregister-streams self client-no)
    (iterate-table (get-server-streams udp-server)
      (lambda (no stream)
        (when (= (get-origin stream) client-no)
          (server-unregister-stream self no)))))
  
  
  (method package (server-unregister-stream self stream-no)
    (let ((stream (find-server-stream udp-server stream-no)))
      ;; together robust
      (when stream
        (let ((recipient (get-recipient stream)))
          (let ((members (get-members recipient))
                (exclude-register (get-exclude-register stream)))
            (for-each (lambda (delegate)
                        (unless (eq? delegate exclude-register)
                          (when (eq? (get-state delegate) 'started)
                            (unless (is? delegate Mobile-Delegate)
                              (let ((no (get-no delegate)))
                                (let ((connection (no->connection udp-server no)))
                                  (unregister-stream-reset connection stream-no)))
                              (let ((client (get-client delegate)))
                                (calling-client self delegate
                                  (lambda ()
                                    (stream-remove client stream-no))))))))
                      members)
            (close-server-stream udp-server stream)
            (update-group-streaming self recipient))))))
  
  
  (method package (server-disconnect-stream self stream-no)
    (let ((stream (find-server-stream udp-server stream-no)))
      ;; together robust
      (when stream
        (let ((members (get-members (get-recipient stream)))
              (exclude-register (get-exclude-register stream)))
          (for-each (lambda (delegate)
                      (unless (eq? delegate exclude-register)
                        (when (eq? (get-state delegate) 'started)
                          (unless (is? delegate Mobile-Delegate)
                            (let ((client (get-client delegate)))
                              (calling-client self delegate
                                (lambda ()
                                  (stream-disconnect client stream-no))))))))
                    members)))))
  
  
  (method package (client-media-init self client stream-no channels-init)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (for-each (lambda (channel-init)
                    (bind (channel-no caps resolution) channel-init
                      (let ((channel (find-server-channel udp-server channel-no)))
                        ;; together robust
                        (when channel
                          (set-caps channel caps)
                          (set-resolution channel resolution)))))
                  channels-init)
        (let ((group (get-group delegate)))
          (when group
            (for-each (lambda (member)
                        (unless (eq? member delegate)
                          (unless (is? member Mobile-Delegate)
                            (let ((client (get-client member)))
                              (calling-client self member
                                (lambda ()
                                  (stream-media-init client stream-no channels-init)))))))
                      (get-members group))))
        #f)))
  
  
  (method package (client-media-on self client stream-no media-kind)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((stream (find-server-stream udp-server stream-no)))
          ;; together robust
          (when stream
            (when (= media-kind udp-video)
              (set-video-on? stream #t))
            (iterate-table (get-channels stream)
              (lambda (no channel)
                (when (= (get-media-kind channel) media-kind)
                  (set-send-state channel 'on))))))
        (let ((group (get-group delegate)))
          (when group
            (for-each (lambda (member)
                        (unless (eq? member delegate)
                          (unless (is? member Mobile-Delegate)
                            (let ((client (get-client member)))
                              (calling-client self member
                                (lambda ()
                                  (stream-media-on client stream-no media-kind)))))))
                      (get-members group))
            (update-group-streaming self group)))
        #f)))
  
  
  (method package (client-media-off self client stream-no media-kind)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (let ((stream (find-server-stream udp-server stream-no)))
          ;; together robust
          (when stream
            (when (= media-kind udp-video)
              (set-video-on? stream #f))
            (iterate-table (get-channels stream)
              (lambda (no channel)
                (when (= (get-media-kind channel) media-kind)
                  (set-send-state channel 'off))))))
        (let ((group (get-group delegate)))
          (when group
            (for-each (lambda (member)
                        (unless (eq? member delegate)
                          (unless (is? member Mobile-Delegate)
                            (let ((client (get-client member)))
                              (calling-client self member
                                (lambda ()
                                  (stream-media-off client stream-no media-kind)))))))
                      (get-members group))
            (update-group-streaming self group)))
        #f)))
  
  
  (method package (client-stream-action self client stream-no action arguments)
    (let ((send-stream (find-send-stream udp-server stream-no)))
      (if send-stream
          (let ((action-proc (get-action-proc send-stream)))
            (when action-proc
              (action-proc send-stream action arguments)))
        (let ((stream (find-server-stream udp-server stream-no)))
          ;; together robust
          (when stream
            (let ((origin (get-origin stream)))
              (let ((delegate (find-delegate-by-no self origin)))
                (when (and delegate (is-not? delegate Mobile-Delegate))
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (action-stream client stream-no action arguments))))))))))))
  
  
  (method package (server-add-channel self stream-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state server-sender?)
    (let ((no (next-channel-no!)))
      (register-server-channel udp-server stream-no no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state server-sender?)))
  
  
  (method package (client-channel-action self client channel-no action arguments)
    (let ((channel (find-server-channel udp-server channel-no)))
      ;; together robust
      (when channel
        (let ((origin (get-origin (get-stream channel))))
          (let ((delegate (find-delegate-by-no self origin)))
            (when (and delegate (is-not? delegate Mobile-Delegate))
              (let ((client (get-client delegate)))
                (calling-client self delegate
                  (lambda ()
                    (action-channel client channel-no action arguments))))))))))
  
  
  (method (group-requirements self group)
    (list (get-require-microphone? group)
          (get-require-camera? group)))
  
  
  (method (group-information self group)
    (cons (get-no group)
          (cons (get-require-microphone? group)
                (cons (get-require-camera? group)
                      (cons (get-duration group)
                            (cons (get-zone group)
                                  (cons (get-stone group)
                                        (cons (get-shape group)
                                              (group-streams self group)))))))))
  
  
  (method (group-streams self group)
    (let ((origins (map get-no (get-members group))))
      (collect (lambda (stream)
                 (define (collect-channels)
                   (let ((channels (new-queue)))
                     (iterate-table (get-channels stream)
                       (lambda (no channel)
                         (let ((media-kind (get-media-kind channel))
                               (source-kind (get-source-kind channel))
                               (level (get-level channel))
                               (resolution (get-resolution channel))
                               (framerate (get-framerate channel))
                               (bitrate (get-bitrate channel))
                               (codec (get-codec channel))
                               (caps (get-caps channel))
                               (metadata (get-metadata channel))
                               (send-state (get-send-state channel)))
                           (enqueue channels (list no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))))
                     (queue-list channels)))
                 
                 (let ((origin (get-origin stream)))
                   (and (or (memv? origin origins)
                             (= origin server-no))
                        (let ((sender (get-sender stream))
                              (name (get-name stream))
                              (no (get-no stream))
                              (source-kind (get-source-kind stream))
                              (video-levels (get-video-levels stream))
                              (channels (collect-channels)))
                          (list sender name no origin source-kind video-levels channels)))))
               (get-ordered-streams group))))
  
  
  (method package (client-circle-properties self client circle-name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (delegate-circle-properties self delegate circle-name))))
  
  
  (method (delegate-circle-properties self delegate circle-name)
    (let ((group (find-group self circle-name)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self circle-name) circle-name)
        (list
          'shape (get-shape group)
          'persistent? (get-persistent? group)
          'invite-only? (get-invite-only? group)
          'require-microphone? (get-require-microphone? group)
          'require-camera? (get-require-camera? group)
          'link (get-link group)
          'description (get-description group)))))
  
  
  (method package (client-circle-property self client circle-name property)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (delegate-circle-property self delegate circle-name property))))
  
  
  (method (delegate-circle-property self delegate circle-name property)
    (let ((group (find-group self circle-name)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self circle-name) circle-name)
        (case property
          ((persistent?)
           (get-persistent? group))
          ((invite-only?)
           (get-invite-only? group))
          ((require-microphone?)
           (get-require-microphone? group))
          ((require-camera?)
           (get-require-camera? group))
          ((link)
           (get-link group))
          ((description)
           (get-description group))))))
  
  
  (method package (client-change-circle-property self client circle-name property value)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (delegate-change-circle-property self delegate circle-name property value))))
  
  
  (method (delegate-change-circle-property self delegate circle-name property value)
    (let ((group (find-group self circle-name)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self circle-name) circle-name)
        (case property
          ((persistent?)
           (set-persistent? group value)
           (update-circle self group circle-name))
          ((invite-only?)
           (set-invite-only? group value)
           (update-circle self group circle-name))
          ((require-microphone?)
           (set-require-microphone? group value)
           (update-circle self group circle-name))
          ((require-camera?)
           (set-require-camera? group value)
           (update-circle self group circle-name))
          ((link)
           (set-link group value)
           (update-circle self group circle-name))
          ((description)
           (set-description group value)
           (update-circle self group circle-name)
           (broadcast-hierarchy self)))
        #f)))
  
  
  (method package (client-circle-information self client circle-name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (delegate-circle-information self delegate circle-name))))
  
  
  (method (delegate-circle-information self delegate circle-name)
    (let ((group (find-group self circle-name)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self circle-name) circle-name)
        (group-information self group))))
  
  
  (method package (client-circle-shape self client circle-name)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (delegate-circle-shape self delegate circle-name))))
  
  
  (method (delegate-circle-shape self delegate circle-name)
    (let ((group (find-group self circle-name)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self circle-name) circle-name)
        (get-shape group))))
  
  
  (method package (client-change-circle-shape self client circle-name shape)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (delegate-change-circle-shape self delegate circle-name shape))))
  
  
  (method (delegate-change-circle-shape self delegate circle-name shape)
    (let ((group (find-group self circle-name)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self circle-name) circle-name)
        (set-shape group shape)
        (update-group-streaming self group)
        (broadcast-circle-change-shape self delegate group shape)
        #f)))
  
  
  (method package (client-change-circle-order self client circle-name order)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (if (not delegate)
          (format "Delegate not found")
        (delegate-change-circle-order self delegate circle-name order))))
  
  
  (method (delegate-change-circle-order self delegate circle-name order)
    (let ((group (find-group self circle-name)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self circle-name) circle-name)
        (let ((order (reorder-ordered-streams group order)))
          (update-group-streaming self group)
          (broadcast-circle-change-order self delegate group order)
          #f))))
  
  
  (method (collect-circles self zone)
    (collect (lambda (group)
               (let ((name (get-name group)))
                 (and name
                      (equal? (get-zone group) zone)
                      (list name (get-stone group)))))
             groups))
  
  
  (method (setup-circles self)
    (load-circles-index self)
    (iterate-table circles-index
      (lambda (circle-name filename)
        (let ((file (persistent-circle-file self filename)))
          (when (exists? file)
            (let ((client-circle (load-circle self file)))
              (let ((owner (get-owner client-circle))
                    (created (get-created client-circle))
                    (persistent? (get-persistent? client-circle))
                    (invite-only? (get-invite-only? client-circle))
                    (require-microphone? (get-require-microphone? client-circle))
                    (require-camera? (get-require-camera? client-circle))
                    (zone (get-zone client-circle))
                    (stone (get-stone client-circle))
                    (shape (get-shape client-circle))
                    (zoom? (get-zoom? client-circle))
                    (link (get-link client-circle))
                    (description (get-description client-circle)))
                (let ((group (new Server-Group circle-name owner created persistent? invite-only? require-microphone? require-camera? zone stone shape zoom? link description)))
                  (if persistent?
                      (set! groups (cons group groups))
                    ;; group survived because of server crash and needs cleanup
                    (set! ghost-groups (cons group ghost-groups)))))))))))
  
  
  (method (circles-directory self)
    (new-directory directory "circles"))
  
  
  (method (circles-index-file self)
    (new-file (circles-directory self) ".index"))
  
  
  (method (persistent-circle-file self filename)
    (new-file (circles-directory self) filename))
  
  
  (method (load-circles-index self)
    (let ((file (circles-index-file self)))
      (when (exists? file)
        (load-table circles-index file))))
  
  
  (method (save-circles-index self)
    (let ((file (circles-index-file self)))
      (create-directories file)
      (save-table circles-index file)))
  
  
  (method (find-persistent-circle self circle-name)
    (let ((filename (table-ref circles-index circle-name #f)))
      (and filename
           (let ((file (persistent-circle-file self filename)))
             (and (exists? file)
                  file)))))
  
  
  (method (update-circle self group circle-name)
    (let ((file (find-persistent-circle self circle-name)))
      (when file
        (create-directories file)
        (store-circle self file group))))
  
  
  (method (delete-circle self circle-name)
    (let ((file (find-persistent-circle self circle-name)))
      (when file
        (delete file)))
    (table-clear circles-index circle-name)
    (save-circles-index self))
  
  
  (method (save-circle self group)
    (let ((dir (circles-directory self)))
      (create-directories dir)
      (let ((circle-name (get-name group))
            (filename (add-extension (make-uuid) "circle")))
        (table-set! circles-index circle-name filename)
        (let ((file (persistent-circle-file self filename)))
          (store-circle self file group)))
      (save-circles-index self)))
  
  
  (method (store-circle self file group)
    (let ((owner (get-owner group))
          (created (get-created group))
          (persistent? (get-persistent? group))
          (invite-only? (get-invite-only? group))
          (require-microphone? (get-require-microphone? group))
          (require-camera? (get-require-camera? group))
          (zone (get-zone group))
          (stone (get-stone group))
          (shape (get-shape group))
          (zoom? (get-zoom? group))
          (link (get-link group))
          (description (get-description group)))
      (call-with-output-file (path-settings file)
        (lambda (output)
          (format output ";;;========={%}")
          (format output ";;;  World{%}")
          (format output ";;;========={%}")
          (format output ";;;{%}")
          (format output ";;;; Circle{%}")
          (format output ";;;{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(data jazz{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(import world.server.circle){%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(form{%}")
          (format output "  (<Client-Circle> owner: {s} created: {s} persistent?: {s} invite-only?: {s} require-microphone?: {s} require-camera?: {s} zone: {s} stone: {s} shape: {s} zoom?: {s} link: {s} description: {s}))){%}" owner created persistent? invite-only? require-microphone? require-camera? zone stone shape zoom? link description)))))
  
  
  (method (load-circle self file)
    (instantiate (read-form file)))
  
  
  (method package (client-list-group-members self name/no)
    (let ((group (find-group self name/no))
          (group-name (and (string? name/no) name/no)))
      (if (not group)
          (format "{a}{? {a}~} doesn't exist anymore" (group-domain-name self name/no) group-name)
        (map get-name (get-members group)))))
  
  
  (method package (client-list-hierarchy self)
    (collect-hierarchy self))
  
  
  (method (collect-hierarchy self (sending-to-mobile? #f))
    (define (member-info delegate)
      (list (get-name delegate)
            (and (not sending-to-mobile?) (get-id delegate))
            (get-no delegate)
            (get-verified? delegate)
            (get-asleep? delegate)
            (get-disconnected? delegate)
            (get-zone delegate)
            (get-mode delegate)
            (mobile? delegate)))
    
    (cons (cons #f
                (cons #f
                      (cons #f
                            (cons #f
                                  (cons #f
                                        (cons #f
                                              (cons #f
                                                    (cons #f
                                                          (cons #f
                                                                (cons #f
                                                                      (cons #f
                                                                            (map member-info (collect-if (lambda (delegate)
                                                                                                           (and (eq? (get-state delegate) 'started)
                                                                                                                (not (get-group delegate))))
                                                                                                         delegates)))))))))))))
          (map (lambda (group)
                 (cons (or (get-name group)
                           (get-no group))
                       (cons (get-owner group)
                             (cons (get-persistent? group)
                                   (cons (get-invite-only? group)
                                         (cons (get-require-microphone? group)
                                               (cons (get-require-camera? group)
                                                     (cons (get-zone group)
                                                           (cons (and (not sending-to-mobile?) (get-stone group))
                                                                 (cons (get-zoom? group)
                                                                       (cons (effective-link group sending-to-mobile?)
                                                                             (cons (get-description group)
                                                                                   (map member-info (get-members group))))))))))))))
               groups)))
  
  
  (method (group-domain-name self name)
    (if (or (not name)
            (integer? name))
        (registered-domain-name 'group "Group")
      (registered-domain-name 'circle "Circle")))
  
  
  (method override (connected-players self)
    (map (lambda (delegate)
           (let ((zone (get-zone delegate)))
             (list (get-name delegate) zone (present-zone self zone))))
         delegates))
  
  
  (method override (available-templates self)
    (collect-templates))
  
  
  (method override (available-zone-base self from)
    (unique-zone-base from))
  
  
  (method override (available-zone-base? self base)
    (zone-base-available? base))
  
  
  (method override (create-zone self from base)
    (prog1 (create-new-zone from base
             create: (lambda (dir)
                       (create (new-directory dir "players")))
             open: (lambda (file)
                     #f))
      (setup-zones self)))
  
  
  (method override (available-zones self)
    (let ((queue (new-queue)))
      (iterate-table instances
        (lambda (uuid instance)
          (enqueue queue (cons (list 'instance uuid)
                               (format "{a}{? <{a}>~}" (join (get-template instance) "/") (+ (get-rank instance) 1))))))
      (for-each (lambda (path)
                  (enqueue queue (cons (cons 'zone path)
                                       (last path))))
                zones-available)
      (queue-list queue)))
  
  
  (method (zone-available self path)
    (unless (member? path zones-available)
      (set! zones-available (sort-zones self (cons path zones-available)))
      (save-zones self)))
  
  
  (method (zone-unavailable self path)
    (when (member? path zones-available)
      (set! zones-available (sort-zones self (remove path zones-available test: equal?)))
      (save-zones self)))
  
  
  (method (zone-has-people? self zone)
    (some? (lambda (delegate)
             (equal? (get-zone delegate) zone))
           delegates))
  
  
  (method (sort-zones self paths)
    (sort nu<? paths key: (lambda (path)
                            (cons (if (= (length path) 1) 0 1) path))))
  
  
  (method (change-client-zone self client zone)
    (let ((delegate (find-delegate self client)))
      (let ((client-uuid (get-uuid delegate))
            (client-id (get-id delegate))
            (client-no (get-no delegate))
            (character-name (get-name delegate))
            (character-avatar (get-avatar delegate))
            (character-dye (get-dye delegate))
            (character-script (get-script delegate))
            (character-role (get-role delegate))
            (character-admin? (get-admin? delegate)))
        ;; spawn
        (let ((processor (spawn/cleanup-processor self (~ collect-world-asset-entries self) zone delegate)))
          (if (string? processor)
              processor
            ;; exit
            (client-exit (get-remote-proxy (get-processor delegate)) client character-name)
            (remove-delegate (get-processor delegate) delegate)
            ;; enter
            (let ((remote-processor (get-remote-proxy processor)))
              (let ((enter-info (client-enter remote-processor client client-uuid client-id client-no character-name character-avatar character-dye character-script character-role character-admin?))
                    (circles (collect-circles self zone)))
                (set-zone delegate zone)
                (set-processor delegate processor)
                (add-delegate processor delegate)
                (broadcast-hierarchy self)
                (append (cons (proxy-connection-info client remote-processor) enter-info)
                        (list circles)))))))))
  
  
  (method (changed-client-zone self client)
    (cleanup-processors))
  
  
  (method (present-zone self zone)
    (if (eq? zone 'start)
        "<Start Zone>"
      (case (car zone)
        ((instance)
         (let ((instance (find-instance self (cadr zone))))
           (format "{a}{? <{a}>~}" (get-name (get-template instance)) (+ (get-rank instance) 1))))
        (else
         (last zone)))))
    
  
  (method (cache-universe-asset-entries self)
    (or universe-asset-entries
        (let ((entries (zlib-deflate (object->u8vector (entries->list (get-entries (get-index (get-repository universe-assets))))))))
          (set! universe-asset-entries entries)
          entries)))

  
  (method (collect-world-asset-entries self)
    (with-world-assets-mutex
      (lambda ()
        (entries->list (get-entries (get-index (get-repository world-assets)))))))
  
  
  (method package (request-universe-asset self client path)
    (let ((delegate (find-delegate self client)))
      (let ((repository (get-repository universe-assets)))
        (let ((entry (find-entry repository path)))
          (let ((info (and entry
                           (let ((digest (get-digest entry))
                                 (flags (get-flags entry)))
                             (list (retrieve-object repository digest) digest flags)))))
            (calling-client self delegate
              (lambda ()
                (receive-asset client 'universe path info))))))))
  
  
  (method package (request-world-asset self client path)
    (with-world-assets-mutex
      (lambda ()
        (let ((delegate (find-delegate self client)))
          (let ((repository (get-repository world-assets)))
            (let ((entry (find-entry repository path)))
              (let ((info (and entry
                               (let ((digest (get-digest entry))
                                     (flags (get-flags entry)))
                                 (list (retrieve-object repository digest) digest flags)))))
                (calling-client self delegate
                  (lambda ()
                    (receive-asset client 'world path info))))))))))
  
  
  (method package (retrieve-world-asset self path)
    (with-world-assets-mutex
      (lambda ()
        (let ((repository (get-repository world-assets)))
          (let ((entry (find-entry repository path)))
            (and entry
                 (let ((digest (get-digest entry))
                       (flags (get-flags entry)))
                   (list (retrieve-object repository digest) digest flags))))))))
  
  
  (method package (upload-world-asset self content digest)
    (with-world-assets-mutex
      (lambda ()
        (let ((repository (get-repository world-assets)))
          (store-object repository content digest)))))
  
  
  (method package (update-world-assets self client changes)
    (with-world-assets-mutex
      (lambda ()
        (let ((repository (get-repository world-assets)))
          (let ((delegate (find-delegate self client)))
            (update-changes (get-index repository) (list->changes changes))
            (broadcast-assets self delegate changes))))))
  
  
  (method (broadcast-assets self client-delegate changes)
    (iterate-processors
      (lambda (zone processor)
        (let ((remote-processor (get-remote-proxy processor)))
          (calling-processor self processor
            (lambda ()
              (world-assets-update remote-processor changes))))))
    (for-each (lambda (delegate)
                (when (eq? (get-state delegate) 'started)
                  (unless (eq? delegate client-delegate)
                    (unless (is? delegate Mobile-Delegate)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (world-assets-update client changes))))))))
              delegates))
  
  
  (method package (register-literal self literal)
    (literal->id literal))
  
  
  (method package (registered-id self id)
    (id->literal id))
  
  
  (method (find-delegate-by-id self id)
    (find-if (lambda (delegate)
               (equal? (get-id delegate) id))
             delegates))
  
  
  (method (find-delegate-by-no self no)
    (find-if (lambda (delegate)
               (= (get-no delegate) no))
             delegates))
  
  
  (method package (tile-server self)
    (tile self))
  
  
  (method package (restore-server self)
    (restore self))
  
  
  (method package (profile-start self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (when connection
            (profile-start connection))))))
  
  
  (method package (profile-test self client test arguments)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (when connection
            (profile-test connection test arguments))))))
  
  
  (method package (profile-retrieve self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (and connection
               (profile-retrieve connection))))))
  
  
  (method package (profile-stop self client)
    (let ((delegate (find-delegate self client)))
      (let ((no (get-no delegate)))
        (let ((connection (no->connection udp-server no)))
          (when connection
            (profile-stop connection))))))
  
  
  (method package (invitation-list self client)
    (let ((delegate (find-delegate self client)))
      (let ((personal-key (get-personal-key delegate))
            (invitations (make-table test: equal?)))
        ;; collect client invitations
        (iterate-invitations directory
          (lambda (invitation-word invitation)
            (let ((inviter (get-inviter invitation))
                  (created (get-created invitation))
                  (expires (get-expires invitation)))
              (when (equal? inviter personal-key)
                (table-set! invitations invitation-word (list invitation-word
                                                              (serialize-date created)
                                                              (and expires (serialize-date expires))
                                                              '()))))))
        ;; iterate matching identities
        (iterate-identities directory
          (lambda (key identity)
            (let ((invitation-word (get-invitation identity)))
              (let ((info (table-ref invitations invitation-word #f)))
                (when info
                  (let ((name (get-name identity))
                        (connected (get-connected identity))
                        (status (get-status identity)))
                    (let ((connected (and connected (serialize-date connected))))
                      (set-fourth! info (append! (fourth info) (list (list name connected status)))))))))))
        (table-values invitations))))
  
  
  (method package (invitation-add self client invitation-word expires)
    (if (retrieve-invitation directory invitation-word)
        "Invitation already exists"
      (let ((delegate (find-delegate self client)))
        (let ((inviter (get-personal-key delegate))
              (expires (and expires (deserialize-date expires))))
          (add-invitation directory invitation-word inviter expires)))
      #f))
  
  
  (method package (invitation-modify self client invitation-word expires)
    (if (not (retrieve-invitation directory invitation-word))
        "Invitation not found"
      (modify-invitation directory invitation-word
        (lambda (designer invitation)
          (let ((expires (and expires (deserialize-date expires))))
            (set-property designer invitation 'expires expires))))
      #f))
  
  
  (method package (invitation-remove self client invitation-word)
    (if (not (retrieve-invitation directory invitation-word))
        "Invitation not found"
      (remove-invitation directory invitation-word)
      #f))
  
  
  (method package (admin-metadata self (requester-delegate/group #f))
    (define (send-streams)
      (streams-metadata (get-send-streams udp-server)))
    
    (define (server-streams)
      (streams-metadata (get-server-streams udp-server)))
    
    (define (start-time)
      (typecase requester-delegate/group
        ((Client-Delegate) (get-create-time requester-delegate/group))
        ((Server-Group) (get-start-time requester-delegate/group))
        (else #f)))
    
    (list server-no "_server" (send-streams) (server-streams) (sites-metadata) (start-time)))
  
  
  (method package (admin-command self client command arguments)
    (case command
      ((activity)
       (let ((file (logger-file)))
         (and (exists? file)
              (load-lines file))))
      ((crash)
       (bind (who) arguments
         (let ((delegate (search-for-delegate self who)))
           (if (string? delegate)
               delegate
             (let ((port (get-urgency-port delegate)))
               (if (not port)
                   (format "Unable to find urgency port")
                 (urgency-crash self port)
                 #f))))))
      ((date)
       (date->string (system-date) "~Y-~m-~d_~H-~M-~S"))
      ((disconnected)
       (map (lambda (delegate)
              (list (get-name delegate)
                    (exception-reason (get-exception delegate))
                    (get-exception-stack delegate)))
            (collect-disconnected self)))
      ((drop)
       (bind (who drop) arguments
         (let ((delegate (find-delegate self client)))
           (let ((connection (no->connection udp-server (get-no delegate))))
             (and connection
                  (let ((simulator (require-simulator udp-server connection))
                        (drop (if (unspecified? drop) #f drop)))
                    (setup-drop simulator drop)
                    #f))))))
      ((identity)
       (bind (action . rest) arguments
         (define (show key)
           (let ((identity (retrieve-identity directory key)))
             (let ((name (get-name identity))
                   (type (get-type identity))
                   (role (get-role identity))
                   (admin? (get-admin? identity))
                   (verified? (get-verified? identity))
                   (verifier (get-verifier identity))
                   (email (get-email identity))
                   (created (get-created identity))
                   (connected (get-connected identity))
                   (status (get-status identity)))
               `(,key
                  ,name
                  ,@(if type (list type: type) '())
                  ,@(if role (list role: role) '())
                  ,@(if admin? (list admin?: admin?) '())
                  ,@(if verified? (list verifier: verifier) '())
                  ,@(if email (list email: email) '())
                  ,@(if created (list created: (present-date created)) '())
                  ,@(if connected (list connected: (present-date connected)) '())
                  ,@(if status (list status: status) '())))))
         
         (case action
           ((list)
            (bind (target) rest
              (let ((queue (new-queue)))
                (iterate-identities directory
                  (lambda (key identity)
                    (let ((name (get-name identity))
                          (type (get-type identity))
                          (role (get-role identity))
                          (admin? (get-admin? identity))
                          (verified? (get-verified? identity))
                          (verifier (get-verifier identity))
                          (email (get-email identity))
                          (status (get-status identity)))
                      (when (or (unspecified? target)
                                (search name target ignore-case?: #t))
                        (enqueue queue `(,key
                                         ,name
                                         ,@(if type (list type: type) '())
                                         ,@(if role (list role: role) '())
                                         ,@(if admin? (list admin?: admin?) '())
                                         ,@(if verified? (list verifier: verifier) '())
                                         ,@(if email (list email: email) '())
                                         ,@(if status (list status: status) '())))))))
                (queue-list queue))))
           ((type)
            (bind (target) rest
              (let ((queue (new-queue)))
                (iterate-identities directory
                  (lambda (key identity)
                    (let ((name (get-name identity))
                          (type (get-type identity))
                          (role (get-role identity))
                          (admin? (get-admin? identity))
                          (verified? (get-verified? identity))
                          (verifier (get-verifier identity))
                          (email (get-email identity))
                          (status (get-status identity)))
                      (when (or (unspecified? target)
                                (eq? type target))
                        (enqueue queue `(,type
                                         ,key
                                         ,name
                                         ,@(if role (list role: role) '())
                                         ,@(if admin? (list admin?: admin?) '())
                                         ,@(if verified? (list verifier: verifier) '())
                                         ,@(if email (list email: email) '())
                                         ,@(if status (list status: status) '())))))))
                (queue-list queue))))
           ((show)
            (bind (target) rest
              (let ((key (find-identity-key directory target)))
                (if (not key)
                    "Identity not found"
                  (show key)))))
           ((add)
            (let ((delegate (find-delegate self client)))
              (bind (name type role admin? email) rest
                (let ((key (generate-identity directory))
                      (type (if (unspecified? type) #f type))
                      (role (if (unspecified? role) #f role))
                      (admin? (if (unspecified? admin?) #f admin?))
                      (email (if (unspecified? email) #f email))
                      (inviter (get-personal-key delegate)))
                  (add-identity directory key name type role admin? email inviter)
                  (show key)))))
           ((create)
            (let ((delegate (find-delegate self client)))
              (bind (names type role) rest
                (define (parse-names)
                  (map (lambda (name)
                         (if (ends-with? name ">")
                             (let ((pos (find name #\< reversed?: #t)))
                               (if pos
                                   (values (trim-whitespace (substring name 0 (- pos 1))) (substring name (+ pos 1) (- (string-length name) 1)))
                                 (values name #f)))
                           (values name #f)))
                       (map trim-whitespace (split-string names #\,))))
                
                (let ((type (if (unspecified? type) #f type))
                      (role (if (unspecified? role) #f role))
                      (admin? #f)
                      (inviter (get-personal-key delegate)))
                  (map (lambda (info)
                         (receive (name email) info
                           (let ((key (generate-identity directory)))
                             (add-identity directory key name type role admin? email inviter)
                             (list name email key))))
                       (parse-names))))))
           ((existing)
            (let ((delegate (find-delegate self client)))
              (bind (key name type role admin? email) rest
                (let ((type (if (unspecified? type) #f type))
                      (role (if (unspecified? role) #f role))
                      (admin? (if (unspecified? admin?) #f admin?))
                      (email (if (unspecified? email) #f email))
                      (inviter (get-personal-key delegate)))
                  (add-identity directory key name type role admin? email inviter)
                  (show key)))))
           ((modify)
            (bind (target name type role admin? email) rest
              (let ((key (find-identity-key directory target)))
                (if (not key)
                    "Identity not found"
                  (modify-identity directory key
                    (lambda (designer identity)
                      (when (specified? name)
                        (set-name designer identity name))
                      (when (specified? type)
                        (set-property designer identity 'type type))
                      (when (specified? role)
                        (set-property designer identity 'role role))
                      (when (specified? admin?)
                        (set-property designer identity 'admin? admin?))
                      (when (specified? email)
                        (set-property designer identity 'email email))))
                  (show key)))))
           ((verify)
            (bind (target) rest
              (let ((verified-key (find-identity-key directory target)))
                (if (not verified-key)
                    "Identity not found"
                  (let ((verified-identity (retrieve-identity directory verified-key)))
                    (let ((verified (get-name verified-identity)))
                      (let ((verifier-delegate (find-delegate self client))
                            (verified-delegate (find-delegate-by-name self verified)))
                        (if verified-delegate
                            (let ((verifier (get-name verifier-delegate)))
                              (client-verify self client verifier verified))
                          (let ((verifier-key (get-personal-key verifier-delegate)))
                            (verify-identity directory verified-key verifier-key)))
                        #f)))))))
           ((upgrade)
            (bind (target role) rest
              (let ((upgraded-key (find-identity-key directory target)))
                (if (not upgraded-key)
                    "Identity not found"
                  (let ((upgraded-identity (retrieve-identity directory upgraded-key)))
                    (let ((upgraded (get-name upgraded-identity)))
                      (let ((upgrader-delegate (find-delegate self client))
                            (upgraded-delegate (find-delegate-by-name self upgraded)))
                        (if upgraded-delegate
                            (client-upgrade self client upgrader-delegate upgraded-delegate role)
                          (let ((upgrader-key (get-personal-key upgrader-delegate)))
                            (upgrade-identity directory upgraded-key upgrader-key role)))
                        #f)))))))
           ((remove)
            (bind (target) rest
              (let ((key (find-identity-key directory target)))
                (if (not key)
                    "Identity not found"
                  (remove-identity directory key)
                  #f))))
           ((convert)
            (convert-identities directory)))))
      ((invitation)
       (bind (action . rest) arguments
         (define (show invitation-word invitation)
           (let ((inviter (get-inviter invitation))
                 (created (get-created invitation))
                 (expires (get-expires invitation)))
             `(,invitation-word
               ,inviter
               ,@(list created: (present-date created))
               ,@(list expires: (if (not expires) 'never (present-date expires))))))
         
         (case action
           ((list)
            (bind (target) rest
              (let ((queue (new-queue)))
                (iterate-invitations directory
                  (lambda (invitation-word invitation)
                    (let ((inviter (get-inviter invitation))
                          (created (get-created invitation))
                          (expires (get-expires invitation)))
                      (when (or (unspecified? target)
                                (search invitation-word target ignore-case?: #t))
                        (enqueue queue `(,invitation-word
                                         ,inviter
                                         ,@(list created: (present-date created))
                                         ,@(list expires: (if (not expires) 'never (present-date expires)))))))))
                (queue-list queue))))
           ((show)
            (bind (invitation-word) rest
              (let ((invitation (retrieve-invitation directory invitation-word)))
                (if (not invitation)
                    "Invitation not found"
                  (show invitation-word invitation)))))
           ((add)
            (let ((delegate (find-delegate self client)))
              (bind (invitation-word inviter) rest
                (add-invitation directory invitation-word inviter #f)
                (show invitation-word (retrieve-invitation directory invitation-word)))))
           ((remove)
            (bind (invitation-word) rest
              (let ((invitation (retrieve-invitation directory invitation-word)))
                (if (not invitation)
                    "Invitation not found"
                  (remove-invitation directory invitation-word)
                  #f)))))))
      ((kick)
       (bind (who) arguments
         (let ((delegate (search-for-delegate self who)))
           (if (string? delegate)
               delegate
             (if (eq? delegate (find-delegate self client))
                 "Kicking yourself?"
               (kick-client self delegate)
               #f)))))
      ((latency)
       (bind (who latency) arguments
         (let ((delegate (find-delegate self client)))
           (let ((connection (no->connection udp-server (get-no delegate))))
             (and connection
                  (let ((simulator (require-simulator udp-server connection))
                        (latency (if (unspecified? latency) #f latency)))
                    (setup-latency simulator latency)
                    #f))))))
      ((machine)
       (bind (action . rest) arguments
         (case action
           ((list)
            (bind (target) rest
              (let ((queue (new-queue)))
                (iterate-machines directory
                  (lambda (identity machine)
                    (let ((user (get-user machine)))
                      (when (or (unspecified? target)
                                (search user target ignore-case?: #t))
                        (let ((caps (get-caps machine))
                              (features (get-features machine))
                              (settings (get-settings machine)))
                          (define (flatten-settings)
                            (let ((queue (new-queue)))
                              (for-each (lambda (pair)
                                          (bind (setting . value) pair
                                            (enqueue queue setting)
                                            (enqueue queue value)))
                                        settings)
                              (queue-list queue)))
                          
                          (enqueue queue `(,(substring identity 0 8)
                                           ,user
                                           platform: ,(assq-value 'kernel.platform features #f)
                                           speed: ,(fxround (assq-value 'caps.computer-speed caps #f))
                                           ,@(if settings (cons settings: (flatten-settings)) '()))))))))
                (queue-list queue))))
           ((caps)
            (bind (target) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (get-caps machine)))))
           ((features)
            (bind (target) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (get-features machine)))))
           ((settings)
            (bind (target) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (or (get-settings machine) '())))))
           ((set)
            (bind (target setting value) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (let ((settings (or (get-settings machine) '())))
                    (let ((pair (assq setting settings)))
                      (if pair
                          (set-cdr! pair value)
                        (set-settings machine (cons (cons setting value) settings)))))
                  (save-machine directory (get-identity machine) machine)
                  (or (get-settings machine) '())))))
           ((unset)
            (bind (target setting) rest
              (let ((machine (find-machine directory target)))
                (if (not machine)
                    #f
                  (let ((settings (or (get-settings machine) '())))
                    (let ((pair (assq setting settings)))
                      (when pair
                        (let ((settings (remove pair settings)))
                          (set-settings machine (if (null? settings) #f settings))
                          (save-machine directory (get-identity machine) machine)))))
                  (or (get-settings machine) '()))))))))
      ((metadata)
       (admin-metadata self))
      ((problems)
       (let ((file (problem-file)))
         (and (exists? file)
              (load-lines file))))
      ((reset)
       (bind (ring) arguments
         (case ring
           ((evolution)
            (reset-evolution)
            #t)
           (else
            #f))))
      ((restart)
       (logger "Restart server")
       (let ((delay (if (null? arguments) 1 (car arguments))))
         (restart-server self delay))
       (unspecified))
      ((send)
       (send-crash-reports))
      ((simulate)
       (bind (simulation) arguments
         (let ((delegate (find-delegate self client)))
           (let ((connection (no->connection udp-server (get-no delegate))))
             (and connection
                  (let ((simulator (require-simulator udp-server connection))
                        (simulation (if (unspecified? simulation) #f simulation)))
                    (setup-simulation simulator simulation)
                    #f))))))
      ((stream)
       (bind (action . rest) arguments
         (case action
           ((audio)
            (set! stream-what 'audio)
            stream-what)
           ((video)
            (set! stream-what 'video)
            stream-what)
           ((media)
            (set! stream-what 'media)
            stream-what)
           ((loop)
            (set! stream-loop? (not stream-loop?))
            stream-loop?)
           ((list)
            (stream-list self client))
           ((play)
            (bind (kind location count spacing) rest
              (or (stream-invalid self client kind location)
                  (begin
                    (if (unspecified? count)
                        (stream-play self client kind location)
                      (delay-event
                        (lambda ()
                          (loop (for n from 0 below count)
                                (when (and (specified? spacing) (/= n 0))
                                  (sleep spacing))
                                (stream-play self client kind location #f)))))
                    #f))))
           ((compare)
            (bind (kind locations) rest
              (delay-event
                (lambda ()
                  (loop (for location in locations)
                        (stream-play self client kind location #f))))
              #f))
           ((stop)
            (bind (kind location) rest
              (stream-stop self client kind location)))
           ((done)
            (bind (count) rest
              (let ((broadcast-hierarchy? #f)
                    (remain (if (specified? count) count +inf.0)))
                (continuation-capture
                  (lambda (done)
                    (iterate-table (get-send-streams udp-server)
                      (lambda (no stream)
                        (when (server-close-send-stream self stream)
                          (set! broadcast-hierarchy? #t))
                        (decrease! remain)
                        (when (<= remain 0)
                          (continuation-return done #f))))))
                (when broadcast-hierarchy?
                  (broadcast-hierarchy self))))
            #f)
           ((convert)
            (stream-convert self))
           ((parse)
            (stream-parse self)))))
      ((stop)
       (logger "Stop server")
       (stop-server self)
       (unspecified))
      ((test)
       (bind (no) arguments
         (let ((no (if (unspecified? no) #f no)))
           (logger "Test server{? {a}~}" no)
           (cond ((not no)
                  #f)
                 (else
                  #f)))))
      ((threads)
       (map ->string (top-threads)))
      ((version)
       (let ((version (process-version (current-process))))
         (format "v{a}{a}" (present version) environment-suffix)))
      ((who)
       (map get-name delegates))
      ((zone)
       (bind (action . rest) arguments
         (case action
           ((list)
            (bind (target) rest
              (let ((queue (new-queue)))
                (for-each (lambda (path)
                            (let ((pathname (join path "/")))
                              (when (or (unspecified? target)
                                        (search pathname target ignore-case?: #t))
                                (let ((available? (member? path zones-available)))
                                  (let ((info (list path available?)))
                                    (enqueue queue info))))))
                          (sort-zones self zones))
                (queue-list queue))))
           ((available)
            (bind (path) rest
              (zone-available self path)
              #f))
           ((unavailable)
            (bind (path) rest
              (let ((zone (cons 'zone path)))
                (if (zone-has-people? self zone)
                    "has people"
                  (zone-unavailable self path)
                  (let ((processor (find-processor zone)))
                    (when processor
                      (quit-processor processor)))
                  #f)))))))
      (else
       (let ((requester client))
         (let ((requester-delegate (find-delegate self requester)))
           (define (dispatch-who what who dispatch-server dispatch-processors dispatch-client)
             (cond ((equal? who 'server)
                    (dispatch-server)
                    #f)
                   ((equal? who 'processor)
                    (let ((delegate (find-delegate self client)))
                      (dispatch-processors (get-processor delegate)))
                    #f)
                   ((equal? who 'processors)
                    (dispatch-processors)
                    #f)
                   ((equal? who 'all)
                    (if (eq? what 'energy)
                        (begin
                          (for-each dispatch-client delegates)
                          #f)
                      (let ((requester-group (and requester-delegate (get-group requester-delegate))))
                        (unless (memq? what '(info capture uncapture))
                          (dispatch-server (or requester-group requester-delegate)))
                        (if (not requester-group)
                            (when requester-delegate
                              (dispatch-client requester-delegate))
                          (for-each dispatch-client (get-members requester-group)))
                        #f)))
                   (else
                    (let ((delegate (search-for-delegate self who)))
                      (if (string? delegate)
                          delegate
                        (dispatch-client delegate)
                        #f)))))
           
           (case command
             ((request)
              (let ((requester-name (if requester-delegate (get-name requester-delegate) "Unknown")))
                (bind (cookie what who action) arguments
                  (define (request-server (requester-delegate/group #f))
                    (admin-server-request self requester requester-name requester-delegate/group cookie what action))
                  
                  (define (request-processors (processor #f))
                    (admin-processors-request self processor requester requester-name cookie what action))
                  
                  (define (request-client delegate)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (admin-request client requester requester-name cookie what action)))))
                  
                  (if (memq? what '(set unset))
                      (let ((machine (find-machine directory who)))
                        (if (not machine)
                            "Machine not found"
                          (let ((who (get-user machine)))
                            ;; no error if who is not connected
                            (if (find-delegate-by-ci-name self who)
                                (dispatch-who what who request-server request-processors request-client)
                              #f))))
                    (dispatch-who what who request-server request-processors request-client)))))
             ;((run)
             ; (bind (cookie script who) arguments
             ;   (define (run-server (requester-group #f))
             ;     (admin-server-run self requester cookie script))
             ;   
             ;   (define (run-client delegate)
             ;     (let ((client (get-client delegate)))
             ;       (calling-client self delegate
             ;         (lambda ()
             ;           (admin-run client requester cookie script)))))
             ;   
             ;   (dispatch-who what who run-server run-client)))
             (else
              (format "Unknown command: {s}" command))))))))
    
  
  (definition preserved-exception-debugger
    #f)
  
  (definition preserved-exception-hook
    #f)

  
  (method (admin-server-request self requester requester-name requester-delegate/group cookie what action)
    (define (send-info)
      (send-threaded 0
        (lambda ()
          ;; gc before process-memory
          (let ((garbage-collect (estimate-garbage-collect)))
            (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
              (object->u8vector
                (list
                  (server-host self)
                  (server-service self)
                  (map get-name (collect-delegates self))
                  (map get-zone (list-processors))
                  (map get-purpose (table-values presences))
                  (collect-hierarchy self)
                  garbage-collect
                  (estimate-cpu%)
                  (length (top-threads))
                  (current-monotonic-frequency)
                  (current-process-memory)
                  last-gc-live
                  last-gc-movable
                  last-gc-nonmovable
                  (let ((port (get-udp-port udp-server)))
                    (list (udp-socket-receive-buffer-size port)
                          (udp-socket-send-buffer-size port)
                          (udp-socket-send-again-count port)))
                  outgoing-max)))))))
    
    (define (send-moments)
      (send-threaded 0
        (lambda ()
          (object->u8vector (retrieve-moments) serialize))))
    
    (define (send-evolution)
      (send-threaded 0
        (lambda ()
          (let ((metadata (admin-metadata self requester-delegate/group))
                (chronology (copy-chronology (current-chronology)))
                (evolution (copy-evolution (current-evolution))))
            (object->u8vector (list metadata chronology evolution) serialize)))))
    
    (define (send-replay)
      (send-threaded 0
        (lambda ()
          (let ((metadata (admin-metadata self requester-delegate/group))
                (chronology (copy-chronology (current-chronology)))
                (evolution (copy-evolution (current-evolution))))
            (object->u8vector (list metadata chronology evolution) serialize)))
        missing: (lambda ()
                   (gather-replay-missing udp-server action))))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Documents "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file)
      (let ((dir {Directory Documents "shared"})
            (name action))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (generate-snapshot)
      (background
        (lambda ()
          (snapshot-process reason: (format "Snapshot requested by {a}" requester-name))
          (send-reply "done" #t))))
    
    (define (debugging-presence)
      (if (find-presence 'debugging)
          (send-reply "Already debugging" #f)
        (start-debugging-presence self)
        (send-reply "debugging" #t)))
    
    (define (attach-to-debugger)
      (if (get-controller-debugger)
          (send-reply "Already attached" #f)
        (logger "Attach server")
        (let ((debugger action))
          (background
            (lambda ()
              (let ((exception-debugger (get-exception-debugger))
                    (exception-hook (jazz:get-exception-hook)))
                ;; setup-debuggee because of calling tcp-client-peer-socket-info
                ;; can take a very long time to timeout so run in the background
                (let ((exc (setup-debuggee debugger: debugger connection-exception-exit?: #f)))
                  (if exc
                      (with-task-mutex
                        (lambda ()
                          (send-reply "Unable to connect to debugger" #f)))
                    (thread-int! (primordial-thread)
                      (lambda ()
                        (with-reentrant-task-mutex
                          (lambda ()
                            (set! preserved-exception-debugger exception-debugger)
                            (set! preserved-exception-hook exception-hook)
                            (start-repl-thread (current-thread) #f (current-console-port))
                            (select-debugger-console)
                            (current-input-port (console-input-port))
                            (current-output-port (console-output-port))
                            (ready-to-controller)
                            (iterate-processors
                              (lambda (zone processor)
                                (let ((remote-processor (get-remote-proxy processor)))
                                  (calling-processor self processor
                                    (lambda ()
                                      (attach remote-processor debugger))))))
                            (send-reply "attached" #t)))))))))
            'attach))))
    
    (define (detach-from-debugger)
      (if (not (get-controller-debugger))
          (send-reply "Already detached" #f)
        (logger "Detach server")
        (current-input-port (standard-input-port))
        (current-output-port (standard-output-port))
        (detach-from-controller)
        (set-exception-debugger preserved-exception-debugger)
        (set-exception-hook preserved-exception-hook)
        (set! preserved-exception-debugger #f)
        (set! preserved-exception-hook #f)
        (iterate-processors
          (lambda (zone processor)
            (let ((remote-processor (get-remote-proxy processor)))
              (calling-processor self processor
                (lambda ()
                  (detach remote-processor))))))
        (send-reply "detached" #t)))
    
    (define (send-reply name done?)
      (let ((sender "_server"))
        (admin-chunk requester cookie sender name #f done?)))
    
    (define (send-threaded name extract (missing: missing #f))
      (background
        (lambda ()
          (let ((data (extract))
                (sender "_server"))
            (admin-chunk requester cookie sender name #f #f)
            (let ((content (zlib-deflate data))
                  (give-time .01))
              (when missing
                (let ((missing (missing)))
                  (for-each (lambda (missing)
                              (sleep give-time)
                              (admin-request-chunk self requester cookie sender 'missing missing #f))
                            missing)))
              (let ((content-size (u8vector-length content))
                    (max-size 8192))
                (let (loop-chunk (part 0) (pos 0))
                  (let ((remain (- content-size pos)))
                    (when (> remain 0)
                      (sleep give-time)
                      (let ((chunk-size (min remain max-size)))
                        (let ((chunk (make-u8vector chunk-size))
                              (done? (>= chunk-size remain)))
                          (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                          (admin-request-chunk self requester cookie sender name chunk done?))
                        (loop-chunk (+ part 1) (+ pos chunk-size))))))))))))
    
    (define (background thunk (name 'request))
      (let ((thread (new-thread thunk name)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)
        thread))
    
    (case what
      ((info)
       (send-info))
      ((moments)
       (send-moments))
      ((evolution)
       (send-evolution))
      ((replay)
       (send-replay))
      ((shared)
       (send-shared))
      ((transfer)
       (send-shared-file))
      ((snapshot)
       (generate-snapshot))
      ((debugging)
       (debugging-presence))
      ((attach)
       (attach-to-debugger))
      ((detach)
       (detach-from-debugger))))
  
  
  (method (admin-processors-request self processor requester requester-name cookie what action)
    (define (send-info)
      (for-each-processor
        (lambda (processor)
          (send-threaded processor 0
            (lambda ()
              (let ((remote-processor (get-remote-proxy processor)))
                (calling-processor self processor
                  (lambda ()
                    (admin-request-info remote-processor)))))))))
    
    (define (for-each-processor proc)
      (if processor
          (proc processor)
        (iterate-processors
          (lambda (zone processor)
            (proc processor)))))
    
    (define (send-threaded processor name extract)
      (background
        (lambda ()
          (let ((content (extract))
                (sender (present-processor processor)))
            (admin-chunk requester cookie sender name #f #f)
            (let ((give-time .01))
              (let ((content-size (u8vector-length content))
                    (max-size 8192))
                (let (loop-chunk (part 0) (pos 0))
                  (let ((remain (- content-size pos)))
                    (when (> remain 0)
                      (sleep give-time)
                      (let ((chunk-size (min remain max-size)))
                        (let ((chunk (make-u8vector chunk-size))
                              (done? (>= chunk-size remain)))
                          (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                          (admin-request-chunk self requester cookie sender name chunk done?))
                        (loop-chunk (+ part 1) (+ pos chunk-size))))))))))))
    
    (define (background thunk)
      (let ((thread (new-thread thunk 'request)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)
        thread))
    
    (case what
      ((info)
       (send-info))))
  
  
  ;(method (admin-server-run self requester cookie script)
  ;  (run-remote-script script
  ;    (lambda (state data)
  ;      (let ((sender "_server"))
  ;        (admin-run-return self requester cookie sender state data)))))
  
  
  (method (admin-request-chunk self requester cookie sender name chunk done?)
    (let ((delegate (find-delegate self requester)))
      (when delegate
        (calling-client self delegate
          (lambda ()
            (admin-chunk requester cookie sender name chunk done?))))))
  
  
  ;(method (admin-run-return self requester cookie sender state data)
  ;  (let ((delegate (find-delegate self requester)))
  ;    (when delegate
  ;      (calling-client self delegate
  ;        (lambda ()
  ;          (admin-return requester cookie sender state data))))))
  
  
  (method (stop-server self)
    (let ((process (current-process)))
      (delay-event
        (lambda ()
          (quit-process process)))))
  
  
  (method (restart-server self delay)
    (let ((process (current-process)))
      (delay-event
        (lambda ()
          (count-down delay
            (lambda (suffix)
              (broadcast-server-message self
                (if (= delay 1)
                    "Restart"
                  (format "Restart in {a}" suffix))))
            (lambda ()
              (quit-process process)))))))
  
  
  (method (broadcast-server-message self message)
    (let ((sender "Server")
          (kind 'server))
      (for-each (lambda (delegate)
                  (deliver-message self delegate sender kind message))
                delegates)))
  
  
  (method (broadcast-activity-message self message)
    (let ((sender "Server")
          (kind 'activity))
      (for-each (lambda (delegate)
                  (when (get-admin? delegate)
                    (deliver-message self delegate sender kind message)))
                delegates)))
  
  
  ;;;
  ;;;; Urgency
  ;;;
  
  
  (method (start-urgency-server self)
    (let ((host (effective-host configuration))
          (service (+ (effective-service configuration) urgency-service-offset)))
      (let ((server (open-tcp-server (list server-address: host port-number: service keep-alive: #t))))
        (let ((thread
                (new-thread
                  (lambda ()
                    (declare (proper-tail-calls))
                    (let (loop)
                      (let ((port (read server)))
                        (accept-urgency self port))
                      (loop)))
                  'urgency)))
        (thread-base-priority-set! thread urgency-priority)
        (thread-start! thread)
        (set! urgency-server server)
        (set! urgency-thread thread)))))
  
  
  (method (with-urgency self prefix thunk)
    (catch-exception-filter
      (lambda (exc)
        #t)
      (lambda (exc)
        (problem "{a}: {a}" prefix (exception-reason exc)))
      thunk))
  
  
  (method (accept-urgency self port)
    (with-urgency self "Accept urgency"
      (lambda ()
        (receive (code version) (read-transmission-header port)
          (validate-code urgency-code code)
          (validate-version urgency-version version)
          (let ((no (read port)))
            (let ((delegate (find-if (lambda (delegate)
                                       (= (get-no delegate) no))
                                     delegates)))
              (when delegate
                (set-urgency-port delegate port))))))))
  
  
  (method (close-urgency self delegate)
    (with-urgency self "Close urgency"
      (lambda ()
        (let ((port (get-urgency-port delegate)))
          (when port
            (close-port port)
            (set-urgency-port delegate #f))))))
  
  
  (method (urgency-crash self port)
    (with-urgency self "Urgency crash"
      (lambda ()
        (write 'crash port)
        (newline port)
        (force-output port))))
  
  
  (method (stop-urgency-server self)
    (when urgency-thread
      (exit-thread urgency-thread)
      (thread-join! urgency-thread)
      (close-port urgency-server)
      (set! urgency-server #f)
      (set! urgency-thread #f)))
  
  
  ;;;
  ;;;; Aliveness
  ;;;
  
  
  (method (start-aliveness-task self)
    (set! aliveness-task (new Task 'aliveness (~ run-aliveness self) priority: aliveness-priority))
    (start-task aliveness-task))
  
  
  (method (stop-aliveness-task self)
    (stop-task aliveness-task)
    (set! aliveness-task #f))
  
  
  (method (run-aliveness self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (with-task-mutex
                (lambda ()
                  (unless (stopping? task)
                    (site aliveness
                      (check-aliveness self)))))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task aliveness-period duration exit))
              (iter time)))))))
  
  
  (method (check-aliveness self)
    ;; no disconnect at the moment as the reconnection
    ;; protocol is too fragile and needs a lot more work
    (let ((disconnect (collect-if (lambda (delegate)
                                    (and (not (get-asleep? delegate))
                                         (not (still-alive? delegate))))
                                  delegates)))
      (for-each (lambda (delegate)
                  (set-exception delegate "Disconnected")
                  (set-exception-stack delegate '())
                  (set-exception-time delegate (current-seconds))
                  (disconnect-client self delegate reason: "Check aliveness"))
                disconnect))
    @wait-disconnect (
    ;; disconnect
    (let ((disconnect (collect-if (lambda (delegate)
                                    (and (not (get-asleep? delegate))
                                         (not (get-disconnected? delegate))
                                         (not (still-alive? delegate))))
                                  delegates)))
      (for-each (lambda (delegate)
                  (set-exception delegate "Disconnected")
                  (set-exception-stack delegate '())
                  (set-exception-time delegate (current-seconds))
                  (disconnect-client self delegate reason: "Check aliveness"))
                disconnect)
      ;; giveup
      (let ((giveup (collect-if (lambda (delegate)
                                  (and (not (get-asleep? delegate))
                                       (disconnected-giveup? delegate)))
                                delegates)))
        (for-each (lambda (delegate)
                    (giveup-client self delegate))
                  giveup)
        ;; broadcast
        (when (or (not-null? disconnect)
                  (not-null? giveup))
          (broadcast-hierarchy self))))))
  
  
  (method override (delayed-disconnect-client self delegate (reason: reason #f))
    (disconnect-client self delegate reason: reason)
    (broadcast-hierarchy self))
  
  
  (method override (disconnect-client self delegate (reason: reason #f))
    ;; so we disconnect only once
    (when (memq? delegate delegates)
      @debugging-read-header-received-eof-disconnects
      (snapshot-process user: (get-name delegate) kind: "Disconnect" reason: reason max-depth: 0)
      ;; no disconnect at the moment as the reconnection
      ;; protocol is too fragile and needs a lot more work
      (kick-client self delegate #f)
      (logger/activity self "Disconnect {a}{? ({a})~}" (get-name delegate) reason))
    @reconnection-too-fragile (
    (set-disconnected? delegate #t)
    ;; unregister non-live streams
    (server-unregister/disconnect-streams self (get-no delegate))
    (disconnect-remote-proxy (get-client delegate))
    (let ((processor (get-processor delegate)))
      (when processor
        (let ((processor-proxy (get-remote-proxy processor)))
          (when (remote-proxy-connected? processor-proxy)
            (client-disconnect processor-proxy (get-client delegate))))))
    (broadcast-disconnected self (list delegate))))
  
  
  (method (client-disconnect self client reason)
    (let ((delegate (find-delegate self client)))
      (when delegate
        (disconnect-client self delegate reason: reason))))
  
  
  (method (broadcast-disconnected self newly-disconnected)
    (for-each (lambda (client-delegate)
                (let ((client-group (get-group client-delegate)))
                  (when client-group
                    (broadcast-disconnected-to-group self client-delegate client-group))))
              newly-disconnected))
  
  
  (method (broadcast-disconnected-to-group self client-delegate client-group)
    (let ((client-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (if (is? delegate Mobile-Delegate)
                        (send-disconnected self delegate client-name)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (server-disconnected client client-name)))))))
                (get-members client-group))))
  
  
  (method (reconnect-client self client delegate uuid)
    (set-disconnected? delegate #f)
    (set-client delegate client)
    (set-state delegate 'connected)
    (set-alive delegate (current-seconds))
    (set-exception delegate #f)
    (set-exception-stack delegate #f)
    (set-exception-time delegate #f)
    (set-uuid delegate uuid)
    (client-reconnect (get-remote-proxy (get-processor delegate)) client)
    (broadcast-reconnected self delegate))
  
  
  (method (broadcast-reconnected self client-delegate)
    (let ((client-group (get-group client-delegate)))
      (when client-group
        (broadcast-reconnected-to-group self client-delegate client-group))))
  
  
  (method (broadcast-reconnected-to-group self client-delegate client-group)
    (when (memq? client-group groups)
      (let ((client-name (get-name client-delegate)))
        (for-each (lambda (delegate)
                    (unless (eq? delegate client-delegate)
                      (if (is? delegate Mobile-Delegate)
                          (send-reconnected self delegate client-name)
                        (let ((client (get-client delegate)))
                          (calling-client self delegate
                            (lambda ()
                              (server-reconnected client client-name)))))))
                  (get-members client-group)))))
  
  
  (method (giveup-client self delegate)
    (logger/activity self "Giveup {a}" (get-name delegate))
    (server-unregister-streams self (get-no delegate))
    (delegate-stop self delegate)
    (delegate-deconnect self delegate))
  
  
  (method (kick-client self delegate (activity? #t))
    (if (is? delegate Mobile-Delegate)
        (mobile-kick self delegate activity?)
      (let ((client (get-client delegate))
            (group (get-group delegate)))
        (disconnect-remote-proxy client)
        (set! delegates (remove! delegate delegates))
        (when activity?
          (logger/activity self "Kick {a}" (get-name delegate)))
        (server-unregister-streams self (get-no delegate))
        (delegate-stop self delegate)
        (delegate-deconnect self delegate broadcast-exited?: #f)
        (let ((processor (get-processor delegate)))
          (when processor
            (let ((processor-proxy (get-remote-proxy processor)))
              (when (remote-proxy-connected? processor-proxy)
                (client-kick processor-proxy client)))))
        (when group
          (register-disconnected-group (get-name delegate) group)
          (broadcast-disconnected-to-group self delegate group)))))
  
  
  ;;;
  ;;;; Mobile
  ;;;
  
  
  (method (read-mobile self server port (unknown (eof-object)))
    (let ((frame (read-frame server 0 port)))
      (if (eof-object? frame)
          (begin
            (when websocket-trace?
              (terminal 'read-frame 'eof))
            frame)
        (case (get-optype frame)
          ((text)
           (let ((text (unmask server frame)))
             (call-with-input-u8vector (list init: text readtable: json-readtable)
               (lambda (port)
                 (let ((code (make-string 4)))
                   (if (= (read-substring code 0 4 port) 4)
                       (if (equal? code mobile-code)
                           (let ((obj (read-json port)))
                             (when websocket-trace?
                               (terminal 'read-frame (get-optype frame) (get-length frame) (get-masked? frame) (get-fin frame) code obj))
                             obj)
                         (throw-connection-broke (format "Invalid code: {a}" code)))
                     (throw-connection-broke "Read code received eof")))))))
          ((connection-close)
           (when websocket-trace?
             (terminal 'read-frame (get-optype frame)))
           (eof-object))
          (else
           (when websocket-trace?
             (terminal 'read-frame '******** (get-optype frame) (get-length frame) (get-masked? frame) (get-fin frame) (get-payload frame)))
           ;; for now
           unknown)))))
  
  
  (method (write-mobile self server port kind message obj)
    (let ((output (open-output-string)))
      (print-json (list kind message obj) output)
      (let ((data (get-output-string output)))
        (when websocket-trace?
          (terminal 'write-frame 'text (list kind message obj)))
        (write-frame server 'text data #t port))))
  
  
  (method package (mobile-connect self server port)
    (with-mobile
      (lambda ()
        (input-port-readtable-set! port json-readtable)
        (let ((personal-key (handle-exception-filter
                              connection-exception?
                              (lambda (exc)
                                (problem "Connecting mobile: {a}" (exception-reason exc))
                                (eof-object))
                              (lambda ()
                                (read-mobile self server port)))))
          (if (eof-object? personal-key)
              #f
            (let ((identity (retrieve-identity directory personal-key)))
              (if (not identity)
                  (begin
                    (write-mobile self server port "result" "connect" "Invalid personal key")
                    #f)
                (let ((character-name (get-name identity))
                      (character-role (or (get-role identity) default-role))
                      (character-admin? (get-admin? identity))
                      (character-verified? (get-verified? identity))
                      (character-verifier (get-verifier identity)))
                  (let ((existing-delegate (find-delegate-by-name self character-name)))
                    (when existing-delegate
                      (kick-client self existing-delegate)
                      (set! existing-delegate #f))
                    (if (and existing-delegate (not (get-disconnected? existing-delegate)))
                        (begin
                          (logger/activity self "{a} (Web) is already connected" character-name)
                          (format "{a} is already connected" character-name)
                          #f)
                      (logger/activity self "{a} {a} (Web)" (if existing-delegate "Reconnect" "Connect") character-name)
                      (let ((delegate (cond (existing-delegate
                                              (mobile-reconnect self server port existing-delegate)
                                              existing-delegate)
                                            (else
                                             (let ((id (make-unique-id)))
                                               (new Mobile-Delegate server port 'started id (literal->id id self) character-name character-role character-admin? character-verified? character-verifier personal-key))))))
                        (let ((client-id #f)
                              (client-no (get-no delegate)))
                          (write-mobile self server port "result" "connect" (list
                                                                              client-id
                                                                              client-no
                                                                              character-name
                                                                              character-role
                                                                              character-admin?))
                          (set-zone delegate 'start)
                          (unless existing-delegate
                            (set! delegates (cons delegate delegates)))
                          (broadcast-hierarchy self)
                          (broadcast-entered self delegate)
                          delegate))))))))))))
  
  
  (method package (mobile-kick self delegate (activity? #t))
    (with-mobile
      (lambda ()
        (handle-exception-filter
          connection-exception?
          (lambda (exc)
            (problem "Kicking mobile: {a}" (exception-reason exc)))
          (lambda ()
            (when activity?
              (logger/activity self "Kick {a} (Web)" (get-name delegate)))
            (let ((port (get-port delegate)))
              (mobile-deconnect self delegate #f)
              (close-port port)))))))
  
  
  (method package (mobile-deconnect self delegate (activity? #t))
    (with-mobile
      (lambda ()
        (when activity?
          (logger/activity self "Deconnect {a} (Web)" (get-name delegate)))
        (let ((group (get-group delegate)))
          (when group
            (leave-group self delegate group)))
        (set! delegates (remove! delegate delegates))
        (set-state delegate 'deconnected)
        (broadcast-exited self delegate)
        (broadcast-hierarchy self))))
  
  
  (method package (mobile-disconnect self delegate)
    (with-mobile
      (lambda ()
        ;; so we disconnect only once
        (when (memq? delegate delegates)
          (logger/activity self "Disconnect {a} (Web)" (get-name delegate))
          (mobile-kick self delegate #f))
        @reconnection-too-fragile
        (set-disconnected? delegate #t))))
  
  
  (method (mobile-reconnect self server port delegate)
    (with-mobile
      (lambda ()
        (set-disconnected? delegate #f)
        (set-server delegate server)
        (set-port delegate port)
        (set-state delegate 'started)
        (set-alive delegate (current-seconds))
        (set-exception delegate #f)
        (set-exception-stack delegate #f)
        (set-exception-time delegate #f)
        (broadcast-reconnected self delegate))))
  
  
  (method (mobile-message self delegate kind recipient message)
    (with-mobile
      (lambda ()
        (delegate-message self delegate kind recipient message))))
  
  
  (method (mobile-invite self delegate recipient)
    (with-mobile
      (lambda ()
        (delegate-invite self delegate recipient #f))))
  
  
  (method (mobile-accept self delegate sender)
    (with-mobile
      (lambda ()
        (delegate-accept self delegate sender #f))))
  
  
  (method (mobile-decline self delegate sender)
    (with-mobile
      (lambda ()
        (delegate-decline self delegate sender #f))))
  
  
  (method (mobile-leave self delegate)
    (with-mobile
      (lambda ()
        (delegate-leave self delegate))))
  
  
  (method (mobile-create-group self delegate name persistent? broadcast-hierarchy? zoom? link description)
    (with-mobile
      (lambda ()
        (delegate-create-group self delegate name persistent? #f #f broadcast-hierarchy? #f #f zoom? link description))))
  
  
  (method (mobile-delete-group self delegate name/no)
    (with-mobile
      (lambda ()
        (delegate-delete-group self delegate name/no))))
  
  
  (method (mobile-circle-property self delegate circle-name property)
    (with-mobile
      (lambda ()
        (delegate-circle-property self delegate circle-name property))))
  
  
  (method (mobile-change-circle-property self delegate circle-name property value)
    (with-mobile
      (lambda ()
        (delegate-change-circle-property self delegate circle-name property value))))
  
  
  (method (mobile-string->circle-property self property-string)
    (and (string? property-string)
         (let ((property (string->symbol property-string)))
           (and (memq? property '(persistent? invite-only? require-microphone? require-camera? link))
                property))))
  
  
  (method package (mobile-serve self delegate)
    (declare (proper-tail-calls))
    (let ((server (get-server delegate))
          (port (get-port delegate)))
      (let (loop)
        (let ((obj (handle-exception-filter
                     connection-exception?
                     (lambda (exc)
                       (problem "Serving mobile: {a}" (exception-reason exc))
                       (eof-object))
                     (lambda ()
                       (read-mobile self server port 'ignore)))))
          (if (eof-object? obj)
              (begin
                (problem "Serving mobile received eof")
                (mobile-disconnect self delegate))
            (if (eq? obj 'ignore)
                (loop)
              (if (not (pair? obj))
                  (begin
                    (write-mobile self server port "result" "" (format "Invalid command: {a}" obj))
                    (loop))
                (bind (command . arguments) obj
                  (if (equal? command "deconnect")
                      (begin
                        (write-mobile self server port "result" command #f)
                        (mobile-deconnect self delegate))
                    (cond ((equal? command "message")
                           (bind (kind recipient message) arguments
                             (let ((kind (string->symbol kind)))
                               (write-mobile self server port "result" command (mobile-message self delegate kind recipient message)))))
                          ((equal? command "invite")
                           (bind (recipient) arguments
                             (write-mobile self server port "result" command (mobile-invite self delegate recipient))))
                          ((equal? command "accept")
                           (bind (sender) arguments
                             (write-mobile self server port "result" command (mobile-accept self delegate sender))))
                          ((equal? command "decline")
                           (bind (sender) arguments
                             (write-mobile self server port "result" command (mobile-decline self delegate sender))))
                          ((equal? command "leave")
                           (write-mobile self server port "result" command (mobile-leave self delegate)))
                          ((equal? command "create-group")
                           (bind (name persistent? broadcast-hierarchy? zoom? link . rest) arguments
                             ;; patch around mobile bug
                             (bind-optionals ((description #f)) rest
                               (write-mobile self server port "result" command (mobile-create-group self delegate name persistent? broadcast-hierarchy? zoom? link description)))))
                          ((equal? command "delete-group")
                           (bind (name/no) arguments
                             (write-mobile self server port "result" command (mobile-delete-group self delegate name/no))))
                          ((equal? command "circle-property")
                           (bind (circle-name property-string) arguments
                             (let ((property (mobile-string->circle-property self property-string)))
                               (write-mobile self server port "result" command
                                 (if (not property)
                                     "Invalid property"
                                   (mobile-circle-property self delegate circle-name property))))))
                          ((equal? command "change-circle-property")
                           (bind (circle-name property-string value) arguments
                             (let ((property (mobile-string->circle-property self property-string)))
                               (write-mobile self server port "result" command
                                 (if (not property)
                                     "Invalid property"
                                   (mobile-change-circle-property self delegate circle-name property value))))))
                          (else
                           (write-mobile self server port "result" command (format "Unknown command: {a}" command))))
                    (loop))))))))))
  
  
  (method (calling-mobile self delegate thunk)
    ;; should be handled in each call explicitly
    (unless (get-disconnected? delegate)
      (handle-exception-filter
        connection-exception?
        (lambda (exc)
          (problem "Calling mobile: {a}" (exception-reason exc))
          (set-exception delegate exc)
          (set-exception-stack delegate (execution-stack))
          (set-exception-time delegate (current-seconds))
          (mobile-disconnect self delegate))
        thunk)))
  
  
  (method (send-detach self delegate)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "detach" '()))))
  
  
  (method (send-people self delegate hierarchy)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "people" (list hierarchy)))))
  
  
  (method (send-entered self delegate client-no client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "entered" (list client-no client-name)))))
  
  
  (method (send-exited self delegate client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "exited" (list client-name)))))
  
  
  (method (send-disconnected self delegate client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "disconnected" (list client-name)))))
  
  
  (method (send-reconnected self delegate client-name)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "reconnected" (list client-name)))))
  
  
  (method (send-message self delegate sender kind message)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "message" (list sender kind message)))))
  
  
  (method (send-messages self delegate messages)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "messages" (list messages)))))
  
  
  (method (send-invite self recipient-delegate sender)
    (calling-mobile self recipient-delegate
      (lambda ()
        (write-mobile self (get-server recipient-delegate) (get-port recipient-delegate) "call" "invite" (list sender)))))
  
  
  (method (send-accept self sender-delegate recipient)
    (calling-mobile self sender-delegate
      (lambda ()
        (write-mobile self (get-server sender-delegate) (get-port sender-delegate) "call" "accept" (list recipient)))))
  
  
  (method (send-decline self sender-delegate recipient)
    (calling-mobile self sender-delegate
      (lambda ()
        (write-mobile self (get-server sender-delegate) (get-port sender-delegate) "call" "decline" (list recipient)))))
  
  
  (method (send-problem self sender-delegate recipient)
    (calling-mobile self sender-delegate
      (lambda ()
        (write-mobile self (get-server sender-delegate) (get-port sender-delegate) "call" "problem" (list recipient)))))
  
  
  (method (send-join self delegate recipient)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "join" (list recipient)))))
  
  
  (method (send-leave self delegate recipient)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "leave" (list recipient)))))
  
  
  (method (send-disband self delegate)
    (calling-mobile self delegate
      (lambda ()
        (write-mobile self (get-server delegate) (get-port delegate) "call" "disband" '()))))
  
  
  (method (send-circle-added self delegate name stone)
    ;; todo
    )
  
  
  (method (send-circle-removed self delegate name)
    ;; todo
    )
  
  
  (method (send-verified self delegate verifier)
    ;; todo
    )
  
  
  ;;;
  ;;;; UDP
  ;;;
  
  
  (method (start-udp-server self)
    (let ((host (effective-host configuration))
          (service (effective-service configuration)))
      (let ((server (new UDP-Server)))
        (start server host service)
        (set! udp-server server)
        (set-?u server))))
  
  
  (method (stop-udp-server self)
    (when udp-server
      (stop udp-server)
      (set! udp-server #f)))
  
  
  ;;;
  ;;;; Detach
  ;;;
  
  
  (method (detach-clients self)
    (for-each (lambda (delegate)
                (if (is? delegate Mobile-Delegate)
                    (send-detach self delegate)
                  (calling-client self delegate
                    (lambda ()
                      (detach-client (get-client delegate))))))
              delegates))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method (stream-list self client)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          "Delegate not found"
        (let ((group (get-group client-delegate))
              (streams (gather-streams)))
          (map (lambda (info)
                 (bind (kind location audio? video) info
                   (let ((base (filename-base location)))
                     (list kind
                           location
                           (streaming-level-suffix video)
                           (if (some? (lambda (stream)
                                        (or (not group)
                                            (let ((server-stream (find-server-stream udp-server (get-no stream))))
                                              (eq? (get-recipient server-stream) group))))
                                      (find-streams self base))
                               'playing
                             #f)))))
               streams)))))
  
  
  (method (make-server-stream self name source-kind video-levels video-on? creators group (location: location #f))
    (let ((channels (map get-descriptor creators)))
      (bind (stream . server-channels) (server-register-stream self server-sender name server-no source-kind video-levels video-on? channels group #f #f #t)
        (let ((stream-no (get-no stream)))
          (let ((send-stream (register-send-stream udp-server server-sender name stream-no source-kind video-levels)))
            (set-location send-stream location)
            (for-each (lambda (server-channel creator)
                        (let ((create (get-create creator)))
                          (create send-stream (get-no server-channel))))
                      server-channels
                      creators)
            (update-group-streaming self group)
            (values stream send-stream))))))
  
  
  (method (stream-invalid self client kind location)
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (if (not client-delegate)
          "Delegate not found"
        (let ((group (get-group client-delegate)))
          (if (not group)
              "You are not in a group"
            (if (not (string? location))
                "Invalid location"
              (if (eq? kind 'image)
                  (let ((file (new-file {Directory Documents} (add-extension location streaming-image-extension))))
                    (if (exists? file)
                        #f
                      "No stream found"))
                (let ((audio? (exists? (new-file {Directory Documents} (add-extension location (audio-profile-extension))))))
                  (if audio?
                      #f
                    (if (null? (existing-video-profiles location))
                        "No stream found"
                      #f))))))))))
  
  
  (method (stream-play self client kind location (delay-streaming? #t))
    (let ((client-delegate (find-delegate self client)))
      ;; together robust
      (when client-delegate
        (let ((group (get-group client-delegate)))
          (when group
            (let ((name (filename-name location)))
              (if (eq? kind 'image)
                  (let ((channels (list (make-server-image-channel self location))))
                    (let ((video-levels (determine-stream-video-levels channels))
                          (video-on? #t))
                      (receive (stream send-stream) (make-server-stream self name 'stream video-levels video-on? channels group location: location)
                        (set-action-proc send-stream stream-controller-action)
                        (set-server-streams group (cons stream (get-server-streams group)))
                        (if delay-streaming?
                            (delay-stream send-stream)
                          (sleep stream-delay)
                          (play send-stream)))))
                (let ((audio-file? (exists? (new-file {Directory Documents} (add-extension location (audio-profile-extension))))))
                  (let ((audio-channels (if (and audio-file?
                                                 (neq? stream-what 'video))
                                            (list (make-server-audio-channel self location group))
                                          '()))
                        (video-channels (if (eq? stream-what 'audio) '() (make-server-video-channels self location group))))
                    (let ((channels (append audio-channels video-channels)))
                      (let ((video-levels (determine-stream-video-levels channels))
                            (video-on? (neq? stream-what 'audio)))
                        (receive (stream send-stream) (make-server-stream self name 'stream video-levels video-on? channels group location: location)
                          (set-action-proc send-stream stream-controller-action)
                          (set-server-streams group (cons stream (get-server-streams group)))
                          (if delay-streaming?
                              (delay-stream send-stream)
                            (sleep stream-delay)
                            (play send-stream))))))))))))))
  
  
  (method (stream-stop self client kind location)
    (let ((name (filename-name location)))
      (let ((streams (find-streams self name)))
        (if (null? streams)
            "Stream not found"
          (let ((broadcast-hierarchy? #f))
            (for-each (lambda (stream)
                        (when (server-close-send-stream self stream)
                          (set! broadcast-hierarchy? #t)))
                      streams)
            (when broadcast-hierarchy?
              (broadcast-hierarchy self)))
          #f))))
  
  
  (method (find-streams self name)
    (let ((queue (new-queue)))
      (iterate-table (get-send-streams udp-server)
        (lambda (no stream)
          (when (equal? (get-name stream) name)
            (enqueue queue stream))))
      (queue-list queue)))
  
  
  (method (streaming-channels self)
    (map-table (lambda (no channel)
                 channel)
               (get-send-channels udp-server)))
  
  
  (method (make-server-audio-channel self location group)
    (let ((file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
      (let ((reader (new Stream-Reader file)))
        (let ((media-kind udp-audio)
              (source-kind 'stream)
              (level #f)
              (resolution #f)
              (framerate #f)
              (bitrate #f)
              (codec (get-codec reader))
              (caps (get-caps reader))
              (metadata '())
              (send-state 'on))
          (close reader)
          (new Channel-Creator
            (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
            (lambda (stream channel-no)
              (let ((stream-no (get-no stream)))
                (let ((channel (register-send-channel udp-server upload-stream-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                  (let ((src (new File-Stream-Audio-Src
                               location
                               loop?: stream-loop?))
                        (sink (new Stream-Frame-Consumer
                                consumer: (lambda (buffer dts pts duration flags)
                                            (send-server-media self channel-no buffer dts pts duration flags)))))
                    (let ((pipeline (pipeline (list src sink))))
                      (set-pipeline channel pipeline)))))))))))
  
  
  (method (make-server-video-channels self location group)
    (let ((existing-profiles (existing-video-profiles location)))
      (map (lambda (profile)
             (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
               (let ((reader (new Stream-Reader file)))
                 (let ((media-kind udp-video)
                       (source-kind 'stream)
                       (level (get-level profile)))
                   (let ((resolution (get-resolution reader))
                         (framerate (get-framerate reader))
                         (bitrate (get-bitrate reader))
                         (codec (get-codec reader))
                         (caps (get-caps reader))
                         (metadata (list start: (get-start reader) end: (get-end reader)))
                         (send-state 'on))
                     (close reader)
                     (new Channel-Creator
                       (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
                       (lambda (stream channel-no)
                         (let ((stream-no (get-no stream)))
                           (let ((channel (register-send-channel udp-server upload-stream-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                             (let ((src (new File-Stream-Video-Src
                                          profile
                                          location
                                          stream?: (= media-kind udp-audio)
                                          loop?: stream-loop?))
                                   (sink (new Stream-Frame-Consumer
                                           consumer: (lambda (buffer dts pts duration flags)
                                                       (send-server-media self channel-no buffer dts pts duration flags)))))
                               (let ((pipeline (pipeline (list src sink))))
                                 (set-pipeline channel pipeline))))))))))))
           existing-profiles)))
  
  
  (method (make-server-image-channel self location)
    (let ((file (new-file {Directory Documents} (add-extension location "streamimage"))))
      (let ((reader (new Stream-Reader file)))
        (let ((media-kind udp-video)
              (source-kind 'image)
              (resolution (get-resolution reader))
              (framerate (get-framerate reader))
              (bitrate (get-bitrate reader))
              (codec (get-codec reader))
              (caps (get-caps reader))
              (metadata '())
              (send-state 'on))
          (let ((level (get-level (estimate-resolution-profile resolution))))
            (close reader)
            (new Channel-Creator
              (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
              (lambda (stream channel-no)
                (let ((stream-no (get-no stream)))
                  (let ((channel (register-send-channel udp-server upload-stream-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                    (let ((src (new File-Stream-Image-Src
                                 location))
                          (sink (new Stream-Frame-Consumer
                                  consumer: (lambda (buffer dts pts duration flags)
                                              (send-server-media self channel-no buffer dts pts duration flags)))))
                      (let ((pipeline (pipeline (list src sink))))
                        (set-pipeline channel pipeline))))))))))))
  
  
  (method package (send-server-media self channel-no buffer dts pts duration flags)
    (when udp-server
      (send-media udp-server channel-no buffer dts pts duration flags)))
  
  
  (method (server-close-send-stream self stream)
    (let ((server-stream (find-server-stream udp-server (get-no stream))))
      (let ((group (get-recipient server-stream)))
        (close-send-stream udp-server stream)
        (set-server-streams group (remove! server-stream (get-server-streams group)))
        (maybe-delete-group self #f group))))
  
  
  (method (stream-convert self)
    (continuation-capture
      (lambda (exit)
        (let ((video-extensions (streaming-video-extensions))
              (image-extension streaming-image-extension)
              (converted 0))
          (iterate-streams
            (lambda (file)
              (let ((extension (get-extension file)))
                (cond ((member? extension video-extensions test: extension=?)
                       (with ((patcher (new Stream-Patcher file)))
                         (when (not (get-caps patcher))
                           (if (neq? (get-codec patcher) 'h264)
                               (continuation-return exit (format "Unable to patch non-h264 {a}" (get-name file)))
                             (let ((resolution (get-resolution patcher))
                                   (framerate (get-framerate patcher)))
                               (let ((width (get-width resolution))
                                     (height (get-height resolution)))
                                 (let ((caps (tie "video/x-h264, stream-format=byte-stream, alignment=au, width={width}, height={height}, framerate={framerate}")))
                                   (patch-caps patcher caps)
                                   (patch-write patcher)
                                   (increase! converted))))))))
                      ((extension=? extension image-extension)
                       (with ((patcher (new Stream-Patcher file)))
                         (when (not (get-caps patcher))
                           (let ((resolution draw-resolution)
                                 (framerate draw-framerate)
                                 (bitrate draw-bitrate)
                                 (codec draw-codec))
                             (let ((width (get-width resolution))
                                   (height (get-height resolution)))
                               (let ((caps (tie "video/x-h264, stream-format=byte-stream, alignment=au, width={width}, height={height}, framerate={framerate}")))
                                 (patch-resolution patcher resolution)
                                 (patch-framerate patcher framerate)
                                 (patch-bitrate patcher bitrate)
                                 (patch-codec patcher codec)
                                 (patch-caps patcher caps)
                                 (patch-write patcher)
                                 (increase! converted)))))))))))
          converted))))
  
  
  (method (stream-parse self)
    (continuation-capture
      (lambda (exit)
        (let ((parsed 0))
          (iterate-streams
            (lambda (file)
              (let ((extension (get-extension file)))
                (when (starts-with? extension "streamvideo")
                  (let ((reader (new Stream-Reader file)))
                    (let ((caps (get-caps reader)))
                      (close reader)
                      (assert caps
                        (when (not (caps-string-codec-data? caps))
                          (tell 'parsing (get-name file))
                          (parse-stream file)
                          (increase! parsed)))))))))
          parsed))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (world.window:tile-server/clients (non-bot-clients self)))
  
  
  (method override (restore self)
    (world.window:restore-server/clients (non-bot-clients self)))
  
  
  (method (non-bot-clients self)
    (map get-client (collect-if (lambda (delegate)
                                   (not (get-script delegate)))
                                 delegates)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (server-log #f (current-seconds) message)))
  
  
  ;;;
  ;;;; Logger
  ;;;
  
  
  (method package (logger/activity self . rest)
    (let ((message (apply format rest)))
      (logger "{a}" message)
      (broadcast-activity-message self message)))
  
  
  ;;;
  ;;;; Messages
  ;;;
  
  
  @keep-this-for-saving-undelivered-personal-messages
  (slot log-file initialize #f getter generate)
  
  
  @keep-this-for-saving-undelivered-personal-messages
  (method (cache-log-file self)
    (or log-file
        (let ((file (timestamped-file (new-directory directory "messages") "messages" "txt")))
          (create-directories file)
          (set! log-file file)
          file)))
  
  
  @keep-this-for-saving-undelivered-personal-messages
  (method (log-message self sender message)
    (call-with-output-file (path-settings (cache-log-file self) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message))))
  
  
  (method (delegate-message self delegate kind recipient message)
    (let ((sender (get-name delegate)))
      @keep-this-for-saving-undelivered-personal-messages
      (log-message self sender message)
      (case kind
        ((whisper)
         (let ((delegate (search-for-delegate self recipient)))
           (if (string? delegate)
               delegate
             (deliver-message self delegate sender kind message)
             #f)))
        ((group)
         (let ((group (get-group delegate)))
           (if (not group)
               (format "You are not in a group")
             (for-each (lambda (delegate)
                           (deliver-message self delegate sender kind message))
                         (get-members group))
             #f)))
        ((gathering)
         (for-each (lambda (delegate)
                     (when (neq? (get-mode delegate) 'participant)
                       (deliver-message self delegate sender kind message)))
                   delegates)
         #f)
        ((server)
         (for-each (lambda (delegate)
                     (deliver-message self delegate sender kind message))
                   delegates)
         #f))))
  
  
  (method (deliver-message self delegate sender kind message)
    (if (get-asleep? delegate)
        (enqueue (get-message-queue delegate) (list sender kind message))
      (if (is? delegate Mobile-Delegate)
          (send-message self delegate sender kind message)
        (let ((client (get-client delegate)))
          (calling-client self delegate
            (lambda ()
              (server-message client sender kind message)))))))
  
  
  (method (deliver-messages self delegate messages)
    (if (is? delegate Mobile-Delegate)
        (send-messages self delegate messages)
      (let ((client (get-client delegate)))
        (calling-client self delegate
          (lambda ()
            (server-messages client messages)))))))


;;;
;;;; Slave
;;;


(definition protected (ready-server)
  (when master-process
    (let ((server (load-object (get-local-register) 'world.server.remote 'world-remote-server)))
      (slave-setup master-process server master-cookie)
      (slave-ready master-process server master-cookie)))))
