;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.server.tier jazz


(import (jazz.component)
        (jazz.debuggee)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.jrm.protocol)
        (jazz.network)
        (jazz.process)
        (jazz.settings)
        (world)
        (world.autoload)
        (world.change)
        (world.geometry)
        (world.history)
        (world.instance)
        (world.io)
        (world.network)
        (world.server.client)
        (world.server.serving)
        (world.settings)
        (world.syntax (phase syntax))
        (world.tier)
        (world.window))


(class Server-Tier extends Serving-Tier implements Server-Interface
  
  
  (slot configuration                getter generate)
  (slot clients       initialize '() getter generate)
  (slot instances     initialize '() getter generate)
  (slot hits          initialize 0   getter generate)
  
  
  (method override (initialize dir)
    (nextmethod dir)
    (set! configuration (instantiate~ (read-form (new-file~ dir ".server"))))
    (setup))
  
  
  (method override (setup)
    (set-client-id (next-unique-id!))
    ;; aec quicky
    (set-remote-problem-handler
      (lambda (process)
        (catch (connection-problem? obj
                 obj)
          (process))))
    (let ((host (get-host~ configuration))
          (service (get-service~ configuration)))
      (assert (or (get-controller-debugger) (not (get-remote-listener)))
        (start-remote-listener host: host service: service)))
    (setup-instances))
  
  
  (method override (enter)
    (let ((me (current-me+)))
      (when me
        (set-name~ me (get-player-name~ configuration))
        (set-avatar~ me (get-player-avatar~ configuration)))))
  
  
  (method override (shutdown)
    (unless (get-controller-debugger)
      (stop-remote-listener)))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state)
    'started)
    
  
  (method override (start)
    )
  
  
  (method override (stop)
    )
  
  
  (method override (restart)
    )
  
  
  (method override (wait-started)
    )
  
  
  (method override (wait-stopped)
    )
  
  
  (method override (server-name)
    "World")
  
  
  (method override (server-title)
    "World")
  
  
  (method override (server-version)
    (process-version~ (get-process)))
  
  
  (method override (server-host)
    (host->string (listening-host~ (get-remote-listener))))
  
  
  (method override (server-service)
    (port->string (listening-port~ (get-remote-listener))))
  
  
  (method override (server-hits)
    hits)
  
  
  (method override (server-debug?)
    #f)
  
  
  ;;;
  ;;;; Instances
  ;;;


  (method (setup-instances)
    (let ((instances-dir (instances-dir))
          (queue (new-queue)))
      (when (exists?~ instances-dir)
        (iterate-directory~ instances-dir
          (lambda (instance-dir)
            (let ((file (new-file~ instance-dir ".instance")))
              (when (exists?~ file)
                (let ((instance (instantiate~ (read-form file))))
                  (enqueue queue instance)))))
          files?: #f
          directories?: #t
          recursive?: #f))
      (set! instances (queue-list queue))))
  
  
  (method (instances-dir)
    (new-directory~ directory "instances"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (anonymous)
    "Server")
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (definition disconnect-delay
    30.)
  
  
  (method (still-alive? client-state)
    (let ((alive (get-alive~ client-state)))
      (and alive (< (- (current-seconds) alive) disconnect-delay))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (client-enter client character-name character-avatar)
    (let ((world (current-world))
          (zone (current-zone)))
      (debug-server 'client-enter character-name character-avatar)
      (let ((existing-client-state (find-client-state-by-name character-name)))
        ;; open test first draft at reconnection
        (let ((reconnected-client-state
                (and existing-client-state
                     (or (get-exception~ existing-client-state)
                         (not (still-alive? existing-client-state))
                         (not (live?~ (get-client~ existing-client-state))))
                     existing-client-state)))
          (if (and existing-client-state
                   (not reconnected-client-state))
              (format "Character {a} is unavailable" character-name)
            ;; register client
            (let ((client-state (if (not reconnected-client-state)
                                    (new Client-State client (next-unique-id!) character-name character-avatar)
                                  (set-client~ reconnected-client-state client)
                                  (set-alive~ reconnected-client-state (current-seconds))
                                  (set-exception~ reconnected-client-state #f)
                                  (set-exception-time~ reconnected-client-state #f)
                                  reconnected-client-state)))
              (unless reconnected-client-state
                (set! clients (cons client-state clients)))
              ;; retrieve character
              (let ((client-id (get-id~ client-state))
                    (character (character-retrieve character-name character-avatar))
                    (character-client-state client-state))
                ;; join instance
                (let ((instance (get-instance~ character)))
                  (let ((processor (if instance (spawn-processor instance) (get-remote-processor~ (current-processor)))))
                    (let ((join-info (client-join~ processor client client-id character-name character-avatar)))
                      (if (string? join-info)
                          join-info
                        (set-processor~ character-client-state processor)
                        (bind (form spawnpoint player-id player-position player-lookat other-players) join-info
                          (when (application?)
                            (if reconnected-client-state
                                (display-message~ world (format "{a} reconnected" character-name))
                              (display-message~ world (format "{a} entered world" character-name))))
                          (let ((welcome (cond ((arc-en-ciel?) "Bienvenue Arc-en-ciel!")
                                               (open-test? "Welcome to the Yownu multiplayer test!")
                                               (else "Welcome to Yownu!"))))
                            (list client-id processor welcome form spawnpoint player-id player-position player-lookat other-players))))))))))))))
  
  
  (method (client-exit client character-name)
    (let ((world (current-world))
          (zone (current-zone)))
      (debug-server 'client-exit character-name)
      ;; find server client
      (let ((character-client-state (find-client-state client)))
        ;; leave instance
        (client-leave~ (get-processor~ character-client-state) client character-name)
        ;; unregister client
        (set! clients (remove! character-client-state clients)))
      (when (application?)
        (display-message~ world (format "{a} exited world" character-name)))))
  
  
  (method (character-retrieve character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file~ (characters-dir) (format "{a}.character" character-name))))
        (let ((character
                (if (exists?~ file)
                    (let ((character (instantiate~ (read-form file))))
                      (set-name~ character character-name)
                      (set-avatar~ character character-avatar)
                      character)
                  (let ((units '(world.data)))
                    (let ((tag '(<Character>))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin~ form file)
                        (let ((character (instantiate~ form)))
                          (set-name~ character character-name)
                          (set-avatar~ character character-avatar)
                          character)))))))
          character))))
  
  
  (method (character-store character)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file~ (characters-dir) (format "{a}.character" (get-name~ character)))))
        (create-directories~ file)
        (let ((designer (new Former form: (get-form~ character) reference: character)))
          (define (save-character)
            (set-property~ designer character 'instance (get-instance~ character)))
          
          (save-character)
          (save~ designer)))))
  
  
  (method (characters-dir)
    (new-directory~ directory "characters"))
  
  
  (method (client-alive client)
    (let ((client-state (find-client-state client)))
      ;; aec robust
      (when client-state
        (set-alive~ client-state (current-seconds)))))
  
  
  (method (client-update client changes)
    (increase! hits)
    ;; should probably be applied by a task when application
    (forward-changes changes)
    (outgoing-push-changes changes))
  
  
  (method (client-message client kind recipient message)
    ;; aec robust
    (let ((client-state (find-client-state client)))
      (when client-state
        (let ((sender (get-name~ client-state)))
          (log-message sender message)
          (for-each (lambda (client-state)
                      (let ((client (get-client~ client-state)))
                        (when (or (neq? kind 'whisper)
                                  (ci=? (get-name~ client-state) recipient))
                          (calling-client client-state
                            (lambda ()
                              (server-message~ client sender kind message))))))
                    clients)))))
  
  
  (method (client-debug client arguments)
    (when (world-setting 'world.server.debug? #f)
      (apply debug 'client arguments)))
  
  
  (method (change-instance client instance)
    (let ((client-state (find-client-state client)))
      (let ((client-id (get-id~ client-state))
            (character-name (get-name~ client-state))
            (character-avatar (get-avatar~ client-state)))
        ;; leave
        (client-leave~ (get-processor~ client-state) client character-name)
        ;; join
        (let ((processor (if instance (spawn-processor instance) (get-remote-processor~ (current-processor)))))
          (let ((join-info (client-join~ processor client client-id character-name character-avatar)))
            (set-processor~ client-state processor)
            (cons processor join-info))))))
  
  
  (method (register-literal literal)
    (literal->id literal))
  
  
  (method (registered-id id)
    (id->literal id))
  
  
  (method (find-client-state target)
    (find-if (lambda (client)
               (proxy=? (get-client~ client) target))
             clients))
  
  
  (method (find-client-state-by-name target)
    (find-if (lambda (client)
               (equal? (get-name~ client) target))
             clients))
  
  
  (method (broadcast-server-update changes)
    (for-each (lambda (client-state)
                (let ((client (get-client~ client-state)))
                  (calling-client client-state
                    (lambda ()
                      (server-update~ client changes)))))
              clients))
  
  
  ;; todo
  (method (check-clients-liveliness)
    (for-each (lambda (client-state)
                )
              clients))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (debug-server . rest)
    (when (world-setting 'world.server.debug? #f)
      (apply debug 'server rest)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file)
    (or log-file
        (let ((zone (current-zone)))
          (let ((file (timestamped-file (new-directory~ directory "messages") "messages" "txt")))
            (create-directories~ file)
            (set! log-file file)
            file))))
  
  
  (method (log-message sender message)
    (call-with-output-file (path-settings (cache-log-file) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message))))))
