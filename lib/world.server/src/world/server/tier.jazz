;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.server.tier jazz


(import (jazz.component)
        (jazz.debuggee)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.jrm.protocol)
        (jazz.network)
        (jazz.process)
        (jazz.settings)
        (world)
        (world.autoload)
        (world.change)
        (world.geometry)
        (world.history)
        (world.instance)
        (world.io)
        (world.network)
        (world.server.client)
        (world.settings)
        (world.syntax (phase syntax))
        (world.tier)
        (world.window))


(class Server-Tier extends Tier implements Server-Interface
  
  
  (slot configuration                getter generate)
  (slot clients       initialize '() getter generate)
  (slot instances     initialize '() getter generate)
  (slot hits          initialize 0   getter generate)
  
  
  (method override (initialize dir)
    (nextmethod dir)
    (set! configuration (instantiate~ (read-form (new-file~ dir ".server"))))
    (setup))
  
  
  (method override (setup)
    (set-client-id (next-unique-id!))
    ;; aec quicky
    (set-remote-problem-handler
      (lambda (process)
        (catch (connection-problem? obj
                 obj)
          (process))))
    (unless (get-controller-debugger)
      (let ((host (get-host~ configuration))
            (service (get-service~ configuration)))
        (start-remote-listener host: host service: service)))
    (setup-instances))
  
  
  (method override (enter)
    (let ((me (current-me+)))
      (when me
        (set-name~ me (get-player-name~ configuration))
        (set-avatar~ me (get-player-avatar~ configuration)))))
  
  
  (method override (shutdown)
    (unless (get-controller-debugger)
      (stop-remote-listener)))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method override (get-state)
    'started)
    
  
  (method override (start)
    )
  
  
  (method override (stop)
    )
  
  
  (method override (restart)
    )
  
  
  (method override (wait-started)
    )
  
  
  (method override (wait-stopped)
    )
  
  
  (method override (server-name)
    "World")
  
  
  (method override (server-title)
    "World")
  
  
  (method override (server-version)
    (process-version~ (get-process)))
  
  
  (method override (server-host)
    (host->string (listening-host~ (get-remote-listener))))
  
  
  (method override (server-service)
    (port->string (listening-port~ (get-remote-listener))))
  
  
  (method override (server-hits)
    hits)
  
  
  (method override (server-debug?)
    #f)
  
  
  ;;;
  ;;;; Instances
  ;;;


  (method (setup-instances)
    (let ((instances-dir (instances-dir))
          (queue (new-queue)))
      (when (exists?~ instances-dir)
        (iterate-directory~ instances-dir
          (lambda (instance-dir)
            (let ((file (new-file~ instance-dir ".instance")))
              (when (exists?~ file)
                (let ((instance (instantiate~ (read-form file))))
                  (enqueue queue instance)))))
          files?: #f
          directories?: #t
          recursive?: #f))
      (set! instances (queue-list queue))))
  
  
  (method (instances-dir)
    (new-directory~ directory "instances"))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (anonymous)
    "Server")
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (definition disconnect-delay
    30.)
  
  
  (method (still-alive? client-state)
    (let ((alive (get-alive~ client-state)))
      (and alive (< (- (current-seconds) alive) disconnect-delay))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (calling-client client-state thunk)
    ;; longer timeout while in development as server
    ;; and clients might be running under a debugger
    @open-test
    (parameterize ((receive-timeout 60))
      (thunk))
    (unless (get-exception~ client-state)
      (parameterize ((post-problem-handler
                       (lambda (exc)
                         (set-exception~ client-state exc)
                         (set-exception-time~ client-state (current-seconds)))))
        (thunk))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (client-enter client character-name character-avatar)
    (let ((world (current-world))
          (zone (current-zone)))
      (debug-server 'client-enter character-name character-avatar)
      (let ((existing-player (find-player~ world character-name)))
        ;; open test first draft at reconnection
        (let ((reconnected-client-state
                (and existing-player
                     (let ((client-state (find-client-state-by-name character-name)))
                       (and client-state
                            (or (get-exception~ client-state)
                                (not (still-alive? client-state))
                                (not (live?~ (get-client~ client-state))))
                            client-state)))))
          (if (and existing-player
                   (not reconnected-client-state))
              (format "Name {a} is unavailable" character-name)
            ;; register client
            (let ((client-state (if (not reconnected-client-state)
                                    (new Client-State (next-unique-id!) client character-name)
                                  (set-client~ reconnected-client-state client)
                                  (set-alive~ reconnected-client-state (current-seconds))
                                  (set-exception~ reconnected-client-state #f)
                                  (set-exception-time~ reconnected-client-state #f)
                                  reconnected-client-state)))
              (unless reconnected-client-state
                (set! clients (cons client-state clients)))
              ;; retrieve character
              (let ((character (character-retrieve character-name character-avatar))
                    (character-client-state client-state))
                ;; retrieve player
                (let ((player (or existing-player (player-retrieve character-name character-avatar))))
                  ;; collect other players for client
                  (define (collect-other-players)
                    (define (player-info player)
                      (let ((id (get-id~ player))
                            (name (get-name~ player))
                            (avatar (get-avatar~ player))
                            (position (get-position~ player))
                            (lookat (get-lookat~ player)))
                        (list id name avatar position lookat)))
                    
                    (let ((players
                            (collect (lambda (client-state)
                                       (unless (eq? client-state character-client-state)
                                         (let ((name (get-name~ client-state)))
                                           (let ((existing (find-player~ world name)))
                                             (player-info existing)))))
                                     clients)))
                      (if (admin?)
                          players
                        (cons (player-info (current-me)) players))))
                  
                  (let ((player-id (get-id~ player))
                        (player-position (get-position~ player))
                        (player-lookat (get-lookat~ player))
                        (other-players (collect-other-players)))
                    ;; broadcast entering player to other clients
                    (unless reconnected-client-state
                      (for-each (lambda (client-state)
                                  (unless (eq? client-state character-client-state)
                                    (let ((client (get-client~ client-state)))
                                      (calling-client client-state
                                        (lambda ()
                                          (server-entered~ client player-id character-name character-avatar player-position player-lookat))))))
                                clients))
                    (when (application?)
                      (if reconnected-client-state
                          (display-message~ world (format "{a} reconnected" character-name))
                        (display-message~ world (format "{a} entered world" character-name))))
                    (let ((client-id (get-id~ client-state))
                          (processor (spawn-processor "935CF3C7-704C-433E-959C-60689C184E71") @TEST (get-remote-processor~ (current-processor)))
                          (welcome (cond ((arc-en-ciel?) "Bienvenue Arc-en-ciel!")
                                         (open-test? "Welcome to the Yownu multiplayer test!")
                                         (else "Welcome to Yownu!")))
                          ;; open test quicky to send form as a string
                          (form (call-with-input-file (path-settings (get-moniker~ zone)) read-content-string))
                          (spawnpoint (get-spawnpoint~ zone)))
                      (list client-id processor welcome form spawnpoint player-id player-position player-lookat other-players)))))))))))
  
  
  (method (client-exit client character-name)
    (let ((world (current-world)))
      (debug-server 'client-exit character-name)
      ;; aec robust
      (let ((player (find-player~ world character-name)))
        (when player
          ;; store player
          (player-store player)
          ;; find server client
          (let ((player-client-state (find-client-state client)))
            ;; broadcast exiting player to other clients
            (for-each (lambda (client-state)
                        (unless (eq? client-state player-client-state)
                          (let ((client (get-client~ client-state)))
                            (calling-client client-state
                              (lambda ()
                                (server-exited~ client character-name))))))
                      clients)
            ;; unregister client
            (set! clients (remove! player-client-state clients)))
          (when (application?)
            (display-message~ world (format "{a} exited world" character-name)))))))
  
  
  (method (character-retrieve character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file~ (characters-dir) (format "{a}.character" character-name))))
        (let ((character
                (if (exists?~ file)
                    (let ((character (instantiate~ (read-form file))))
                      (set-name~ character character-name)
                      (set-avatar~ character character-avatar)
                      character)
                  (let ((units '(world.data)))
                    (let ((tag '(<Character>))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin~ form file)
                        (let ((character (instantiate~ form)))
                          (set-name~ character character-name)
                          (set-avatar~ character character-avatar)
                          character)))))))
          character))))
  
  
  (method (character-store character)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file~ (characters-dir) (format "{a}.character" (get-name~ character)))))
        (create-directories~ file)
        (let ((designer (new Former form: (get-form~ character) reference: character)))
          (define (save-character)
            (set-property~ designer character 'instance (get-instance~ character)))
          
          (save-character)
          (save~ designer)))))
  
  
  (method (characters-dir)
    (new-directory~ directory "characters"))
  
  
  (method (player-retrieve player-name player-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" player-name))))
        (let ((player
                (if (exists?~ file)
                    (let ((player (instantiate~ (read-form file))))
                      (set-name~ player player-name)
                      (set-avatar~ player player-avatar)
                      (set-parent~ player zone)
                      player)
                  (let ((units '(world.data)))
                    (let ((tag '(<Player> (<Camera>)))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin~ form file)
                        (let ((player (instantiate~ form)))
                          (set-name~ player player-name)
                          (set-avatar~ player player-avatar)
                          (set-parent~ player zone)
                          (set-position~ player (find-spawnpoint~ zone))
                          (set-lookat~ player (find-spawnlookat~ zone))
                          player)))))))
          (set-billboard-name~ player player-name)
          (add-element~ zone player)
          (when (application?)
            (add-simulation~ zone player))
          player))))
  
  
  (method (player-store player)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" (get-name~ player)))))
        (create-directories~ file)
        (let ((designer (new Former form: (get-form~ player) reference: player)))
          (define (save-camera)
            (let ((eye (get-eye~ world))
                  (camera (player-camera~ player)))
              (set-property~ designer camera 'position (get-position~ eye))
              (set-property~ designer camera 'lookat (get-lookat~ eye))))
          
          (define (save-player)
            (set-property~ designer player 'position (get-position~ player))
            (set-property~ designer player 'lookat (get-lookat~ player)))
          
          (save-camera)
          (save-player)
          (save~ designer)))
      (when (application?)
        (remove-simulation~ zone player))
      (remove-element~ zone player)))
  
  
  (method (players-dir)
    (new-directory~ directory "players"))
  
  
  (method (client-alive client)
    (let ((client-state (find-client-state client)))
      ;; aec robust
      (when client-state
        (set-alive~ client-state (current-seconds)))))
  
  
  (method (client-update client changes)
    (increase! hits)
    ;; should probably be applied by a task when application
    (forward-changes changes)
    (outgoing-push-changes changes))
  
  
  (method (client-message client kind recipient message)
    ;; aec robust
    (let ((client-state (find-client-state client)))
      (when client-state
        (let ((sender (get-name~ client-state)))
          (log-message sender message)
          (for-each (lambda (client-state)
                      (let ((client (get-client~ client-state)))
                        (when (or (neq? kind 'whisper)
                                  (ci=? (get-name~ client-state) recipient))
                          (calling-client client-state
                            (lambda ()
                              (server-message~ client sender kind message))))))
                    clients)))))
  
  
  (method (client-debug client arguments)
    (when (world-setting 'world.server.debug? #f)
      (apply debug 'client arguments)))
  
  
  (method (register-literal literal)
    (literal->id literal))
  
  
  (method (registered-id id)
    (id->literal id))
  
  
  (method (find-client-state target)
    (find-if (lambda (client)
               (proxy=? (get-client~ client) target))
             clients))
  
  
  (method (find-client-state-by-name target)
    (find-if (lambda (client)
               (equal? (get-name~ client) target))
             clients))
  
  
  (method (broadcast-server-update changes)
    (for-each (lambda (client-state)
                (let ((client (get-client~ client-state)))
                  (calling-client client-state
                    (lambda ()
                      (server-update~ client changes)))))
              clients))
  
  
  ;; todo
  (method (check-clients-liveliness)
    (for-each (lambda (client-state)
                )
              clients))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (debug-server . rest)
    (when (world-setting 'world.server.debug? #f)
      (apply debug 'server rest)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (slot log-file initialize #f getter generate)
  
  
  (method (cache-log-file)
    (or log-file
        (let ((zone (current-zone)))
          (let ((file (timestamped-file (new-directory~ directory "messages") "messages" "txt")))
            (create-directories~ file)
            (set! log-file file)
            file))))
  
  
  (method (log-message sender message)
    (call-with-output-file (path-settings (cache-log-file) append: #t)
      (lambda (output)
        (format output "{a} {a}{%}" sender message))))))
