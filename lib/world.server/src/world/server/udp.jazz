;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.server.udp jazz


(import (jazz.network)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.configure)
        (world.context)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.udp))


(class UDP-Server extends Object
  
  
  (slot udp-port              initialize #f getter generate)
  (slot udp-stopping?         initialize #f getter generate)
  (slot origin-connections    initialize #f getter generate)
  (slot host/port-connections initialize #f getter generate)
  (slot server-channels       initialize #f getter generate)
  (slot receive-task          initialize #f getter generate)
  
  
  (method (start self host service)
    (set! udp-port (open-udp (list
                               local-address: host
                               local-port-number: service)))
    (set! udp-stopping? #f)
    (set! origin-connections (make-table))
    (set! host/port-connections (make-table))
    (set! server-channels (make-table))
    (set! receive-task (new Task 'udp-receive (lambda (task)
                                                (receive-loop self task))
                            priority: udp-priority))
    (start-task receive-task))
  
  
  (method (stop self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (thread-join! (get-thread receive-task))
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  ;;;
  ;;;; Connection
  ;;;
  
  
  (method (register-connection self origin host port connection)
    (table-set! origin-connections origin connection)
    (table-set! host/port-connections (cons host port) connection))
  
  
  (method (unregister-connection self origin host port)
    (table-clear origin-connections origin)
    (table-clear host/port-connections (cons host port)))
  
  
  (method (origin->connection self origin)
    (table-ref origin-connections origin #f))
  
  
  (method (host/port->connection self host port)
    (table-ref host/port-connections (cons host port) #f))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method (require-server-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref server-channels key #f)
          (let ((channel (new UDP-Server-Channel origin media-kind)))
            (table-set! server-channels key channel)
            channel))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (receive-data self data))
              (loop)))))))
  
  
  (method (receive-data self data)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-connect)
         (connect-source self data))
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (connect-source self data)
    (let ((sent (read-udp-sent data))
          (origin (read-udp-origin data))
          (local-host (read-udp-connect-local-host data))
          (local-port (read-udp-connect-local-port data))
          (latency (read-udp-connect-latency data))
          (lag (read-udp-connect-lag data))
          (drop (read-udp-connect-drop data))
          (source-info (udp-source-socket-info udp-port)))
      (define (udp-simulator)
        (let ((latency (and (/= latency -1.) latency))
              (lag (and (/= lag -1.) lag))
              (drop (and (/= drop -1.) drop)))
          (if (or latency lag drop)
              (new UDP-Simulator latency lag drop
                   (lambda (info)
                     (bind (connection . data) info
                       (udp-destination-set! (get-host connection) (get-port connection) udp-port)
                       (retrying-write data udp-port))))
            #f)))
      
        (let ((source-host (socket-info-address source-info))
              (source-port (socket-info-port-number source-info)))
          (define (send-connected)
            (udp-destination-set! source-host source-port udp-port)
            (let ((size (+ 8 4)))
              (let ((data (make-u8vector size)))
                (write-udp-sent data sent)
                (write-udp-kind data udp-connected)
                (retrying-write data udp-port))))
          
          (if (origin->connection self origin)
              (send-connected)
            (let ((connection (new UDP-Connection source-host source-port local-host local-port (udp-simulator))))
              (register-connection self origin source-host source-port connection))
            (send-connected)))))
  
  
  (method (receive-ack self data)
    (let ((origin (read-udp-origin data)))
      ;; throttling
      (let ((connection (origin->connection self origin)))
        (when connection
          (set-last-received-ack connection (current-seconds))
          (when (get-throttle-media? connection)
            (set-throttle-media? connection #f)
            (when udp-show-throttle?
              (let ((delegate (find-delegate-by-no (current-server) origin)))
                (format :terminal "{s} {s} {a} {s}{%}" remote-name 'THROTTLE (if delegate (get-name delegate) origin) 'OFF))))))
      ;; kind #f is a hack for audio/video-self?
      (broadcast-ack self #f origin data)))
  
  
  (method (receive-nack self data)
    (let ((origin (read-udp-origin data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-latest-missing data))))
      (send-missing self origin media-kind missing)))
  
  
  (method (receive-media self kind data)
    (let ((origin (read-udp-origin data))
          (sequence (read-udp-sequence data)))
      (let ((channel (require-server-channel self origin kind)))
        (let ((last-sequence (get-last-sequence channel)))
          (let ((in-order? (or (not last-sequence)
                               (> sequence last-sequence))))
            (if (not in-order?)
                (remove-nack channel sequence)
              ;; send early nacks to source
              (when last-sequence
                (let ((expected (+ last-sequence 1)))
                  (when (> sequence expected)
                    ;; barbarasays braindead if gap is huge
                    (let ((seconds (current-seconds)))
                      (loop (for seq from expected below sequence)
                            (add-nack channel seconds seq))))))
              ;; remember time information
              (update-time channel sequence data (get-retain-ring channel)))))
        ;; always send the lastest nacks
        (let ((latest-missing (filter-latest-missing channel)))
          (unless (null? latest-missing)
            (let ((source-info (udp-source-socket-info udp-port)))
              (let ((source-host (socket-info-address source-info))
                    (source-port (socket-info-port-number source-info)))
                (let ((connection (host/port->connection self source-host source-port)))
                  (send-nack self connection origin kind latest-missing))))))
        (retain channel data)
        (broadcast-media self kind origin data))))
  
  
  (method (send-missing self origin media-kind missing)
    (let ((channel (require-server-channel self origin media-kind)))
      (let ((ring (get-retain-ring channel))
            (entries (get-retain-entries channel)))
        (for-each (lambda (sequence)
                    (let ((found (table-ref entries sequence #f) @old (locate ring (lambda (data)
                                                (= (read-udp-sequence data) sequence)))))
                      (if found
                          (let ((source-info (udp-source-socket-info udp-port)))
                            (let ((source-host (socket-info-address source-info))
                                  (source-port (socket-info-port-number source-info)))
                              (let ((connection (host/port->connection self source-host source-port)))
                                (when udp-show-nacks?
                                  (terminal remote-name (present-media-kind media-kind) '***nack-found-on-server*** sequence))
                                (send-data self connection found))))
                        ;; we already nacked the source early and will broadcast
                        ;; when we receive the resent so we can ignore this nack
                        )))
                  missing))))
  
  
  (method (send-nack self connection origin media-kind latest-missing)
    (when udp-show-nacks?
      (terminal remote-name (present-media-kind media-kind) '***send-nack*** latest-missing))
    (let ((missing (object->u8vector latest-missing)))
      (let ((size (+ 8 4 4 4 4 (u8vector-length missing))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-origin data origin)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-latest-missing data missing)
          (send-data self connection data)))))
  
  
  (method (broadcast-ack self kind origin data)
    (let ((delegate (find-delegate-by-no (current-server) origin)))
      (when delegate
        (let ((group (get-group delegate)))
          (when group
            (for-each (lambda (member)
                        (when (or (neq? member delegate)
                                  (and audio-self? (or (not kind) (= kind udp-audio)))
                                  (and video-self? (or (not kind) (= kind udp-video))))
                          (let ((no (get-no member)))
                            (let ((connection (table-ref origin-connections no #f)))
                              (when connection
                                (send-data self connection data))))))
                      (get-members group)))))))
  
  
  (method (broadcast-media self kind origin data)
    (let ((delegate (find-delegate-by-no (current-server) origin)))
      (when delegate
        (let ((group (get-group delegate)))
          (when group
            (for-each (lambda (member)
                        (when (or (neq? member delegate)
                                  (and audio-self? (or (not kind) (= kind udp-audio)))
                                  (and video-self? (or (not kind) (= kind udp-video))))
                          (let ((no (get-no member)))
                            (let ((connection (table-ref origin-connections no #f)))
                              (when connection
                                (let ((last-received-ack (get-last-received-ack connection)))
                                  (when last-received-ack
                                    (unless (get-throttle-media? connection)
                                      (let ((now (current-seconds))
                                            (throttle (if (= kind udp-audio) udp-audio-throttle udp-video-throttle)))
                                        (if (> (- now last-received-ack) throttle)
                                            (begin
                                              (set-throttle-media? connection #t)
                                              (when udp-show-throttle?
                                                (format :terminal "{s} {s} {a} {s}{%}" remote-name 'THROTTLE (get-name member) 'ON)))
                                          (send-data self connection data)))))))))))
                      (get-members group)))))))
  
  
  (method (send-data self connection data)
    (let ((simulator (get-simulator connection)))
      (if simulator
          (send simulator (cons connection data))
        (udp-destination-set! (get-host connection) (get-port connection) udp-port)
        (retrying-write data udp-port)))))


;;;
;;;; UDP Connection
;;;


(class UDP-Connection extends Object
  
  
  (slot host                            getter generate)
  (slot port                            getter generate)
  (slot local-host                      getter generate)
  (slot local-port                      getter generate)
  (slot simulator                       getter generate)
  (slot last-received-ack initialize #f accessors generate)
  (slot throttle-media?   initialize #f accessors generate)
  
  
  (method override (initialize self host port local-host local-port simulator)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port)
    (set! self.local-host local-host)
    (set! self.local-port local-port)
    (set! self.simulator simulator))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Server Channel
;;;


(class UDP-Server-Channel extends UDP-Channel
  
  
  (slot origin         getter generate)
  (slot latest-nacks   accessors generate)
  (slot retain-ring    getter generate)
  (slot retain-entries getter generate)
  (slot release-task   getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self media-kind)
    (set! self.origin origin)
    (set! self.latest-nacks '())
    (set! self.retain-ring (new Time-Ring udp-retain-size max-size: udp-retain-max-size now-proc: (lambda () (now-timestamp self udp-retain-window)) key-proc: udp-ring-key overflow-proc: (udp-ring-overflow 'server-retain)))
    (set! self.retain-entries (make-table test: eqv?))
    (set! self.release-task (new Task 'udp-release (lambda (task)
                                                     (release-loop self task))
                                 priority: udp-priority))
    (start-task release-task))
  
  
  (method protected (add-nack self seconds sequence)
    (set! latest-nacks (cons (cons seconds sequence) latest-nacks))
    (let ((ring-size (length latest-nacks)))
      (record-event udp-id-add-nack
                    (fixnum->flonum sequence)
                    (fixnum->flonum origin)
                    (fixnum->flonum ring-size)
                    0.))
    ;; trim when more than udp-latest-nacks
    (when (> (length latest-nacks) udp-latest-nacks)
      (let ((removed-sequence (cdr (last latest-nacks))))
        (set-cdr! (tail latest-nacks (- udp-latest-nacks 1)) '())
        (let ((ring-size (length latest-nacks)))
          (record-event udp-id-remove-nack
                        (fixnum->flonum removed-sequence)
                        (fixnum->flonum origin)
                        (fixnum->flonum ring-size)
                        0.))))
    latest-nacks)
  
  
  (method protected (remove-nack self sequence)
    (set! latest-nacks (remove! sequence latest-nacks key: cdr)))
  
  
  (method protected (filter-latest-missing self)
    (when udp-experimental-filter-nacks?
      ;; discard any nack older than udp-process-window
      (let ((now (current-seconds)))
        (set! latest-nacks (collect-if (lambda (nack)
                                         (let ((seconds (car nack)))
                                           (< (- now seconds) udp-process-window)))
                                       latest-nacks))))
    (map cdr latest-nacks))
  
  
  (method protected (retain self data)
    (insert retain-ring (read-udp-media-seconds data) data)
    (table-set! retain-entries (read-udp-sequence data) data)
    (let ((kind (read-udp-kind data)))
      (when (= kind udp-video)
        (let ((origin (read-udp-origin data))
              (sequence (read-udp-sequence data))
              (ring-size (get-count retain-ring))
              (timestamp (read-udp-media-timestamp data)))
          (record-event udp-id-add-retain
                        (fixnum->flonum sequence)
                        (fixnum->flonum origin)
                        (fixnum->flonum ring-size)
                        (timestamp->flonum timestamp))))))
  
  
  (method protected (release-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (wait retain-ring)))
            (if (not data)
                (continuation-return exit #f)
              (site (udp-release on?: #t)
                (table-clear retain-entries (read-udp-sequence data))
                (let ((kind (read-udp-kind data)))
                  (when (= kind udp-video)
                    (let ((origin (read-udp-origin data))
                          (sequence (read-udp-sequence data))
                          (ring-size (get-count retain-ring))
                          (timestamp (read-udp-media-timestamp data)))
                      (record-event udp-id-remove-retain
                                    (fixnum->flonum sequence)
                                    (fixnum->flonum origin)
                                    (fixnum->flonum ring-size)
                                    (timestamp->flonum timestamp))))))
              (loop)))))))))
