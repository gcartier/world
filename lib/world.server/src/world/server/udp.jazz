;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Server UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.server.udp jazz


(import (jazz.event)
        (jazz.network)
        (jazz.presence)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.format)
        (world.profiling)
        (world.record-syntax (phase syntax))
        (world.ring)
        (world.server.autoload)
        (world.server.client)
        (world.server.group)
        (world.server.problem)
        (world.settings)
        (world.stream)
        (world.support)
        (world.task)
        (world.time)
        (world.udp))


(class UDP-Server extends UDP-Tier
  
  
  (slot udp-port               initialize #f  getter generate)
  (slot udp-stopping?          initialize #f  getter generate)
  (slot no-uploads             initialize #f  getter generate)
  (slot no-connections         initialize #f  getter generate)
  ;; mutex was not needed before server streaming...
  (slot server-mutex           initialize #f  getter generate)
  (slot server-streams         initialize #f  getter generate)
  (slot server-channels        initialize #f  getter generate)
  (slot receive-task           initialize #f  getter generate)
  (slot reset-ring             initialize #f  getter generate)
  (slot reset-task             initialize #f  getter generate)
  (slot invalid-packets        initialize 0   getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! server-streams (make-table))
    (set! server-channels (make-table))
    (register-snapshot-callback (~ snapshot-server-streams self)))
  
  
  (method package (start self host service)
    (unless (simulation?)
      (set! udp-port (open-udp (list
                                 local-address: host
                                 local-port-number: service)))
      (setup-udp-port-buffers udp-port)
      (set! udp-stopping? #f)
      (set! no-uploads (make-table))
      (register-upload self server-no (new UDP-Upload))
      (set! no-connections (make-table))
      (set! server-mutex (make-mutex 'server))
      (set! server-channels (make-table))
      (set! send-channels (make-table))
      (set! receive-task (new Task 'receive (~ run-receive self) priority: receive-priority stack: stack-size))
      (start-task receive-task)
      (set! reset-ring (new Time-Ring 256 max-size: 4096))
      (set! reset-task (new Task 'reset (~ run-reset self) priority: reset-priority))
      (start-task reset-task)))
  
  
  (method package (stop self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (thread-join! (get-thread receive-task))
    (set! udp-port #f)
    (set! receive-task #f)
    (terminate reset-ring)
    (thread-join! (get-thread reset-task))
    (set! reset-ring #f)
    (set! reset-task #f))
  
  
  (method (snapshot-server-streams self)
    (let ((info (map-table (lambda (no stream)
                             (list (get-sender stream)
                                   (get-name stream)
                                   (get-source-kind stream)))
                           server-streams)))
      (add-snapshot-property 'live.udp-server info)))
  
  
  ;;;
  ;;;; Upload
  ;;;
  
  
  (method (register-upload self no upload)
    (table-set! no-uploads no upload))
  
  
  (method (unregister-upload self no)
    (table-clear no-uploads no))
  
  
  (method package (no->upload self no)
    (table-ref no-uploads no #f))
  
  
  ;;;
  ;;;; Connection
  ;;;
  
  
  (method (register-connection self no connection)
    (table-set! no-connections no connection))
  
  
  (method (unregister-connection self no)
    (table-clear no-connections no))
  
  
  (method package (no->connection self no)
    (table-ref no-connections no #f))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (register-server-stream self sender name no origin source-kind video-levels video-on? recipient exclude-register exclude-broadcast)
    (let ((stream (new UDP-Server-Stream sender name no origin source-kind video-levels video-on? recipient exclude-register exclude-broadcast)))
      (table-set! server-streams no stream)
      (when recipient
        (register-ordered-stream recipient stream))
      stream))
  
  
  (method package (find-server-stream self stream-no)
    (table-ref server-streams stream-no #f))
  
  
  (method package (close-server-stream self stream)
    (table-iterate-safe (get-channels stream)
      (lambda (no channel)
        (close-server-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (table-clear server-streams stream-no)
      (let ((recipient (get-recipient stream)))
        (unregister-ordered-stream recipient stream))))
  
  
  (method package (close-send-stream self stream)
    (table-iterate-safe (get-channels stream)
      (lambda (no channel)
        (close-send-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (server-unregister-stream (current-server) stream-no)
      (table-clear send-streams stream-no)))
  
  
  (method package (update-stream-receivers self stream)
    (let ((stream-no (get-no stream))
          (members (get-members (get-recipient stream)))
          (exclude-broadcast (get-exclude-broadcast stream)))
      (define (determine-receivers channel)
        (let ((media-kind (get-media-kind channel))
              (level (get-level channel)))
          (collect (lambda (member)
                     (let ((no (get-no member)))
                       (let ((connection (no->connection self no)))
                         (and (neq? member exclude-broadcast)
                              (or (= media-kind udp-audio)
                                  (let ((download-spec (table-ref (get-download-spec connection) stream-no #f)))
                                    (and download-spec
                                         (= (car download-spec) level)))
                                  (let ((download-closing (table-ref (get-download-closing connection) stream-no #f)))
                                    (and download-closing
                                         (= download-closing level))))
                              connection))))
                   members)))
      
      (table-iterate (get-channels stream)
        (lambda (no channel)
          (set-receivers channel (determine-receivers channel))))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (find-server-channel self channel-no)
    (table-ref server-channels channel-no #f))
  
  
  (method package (register-server-channel self stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state server-sender?)
    (let ((stream (find-server-stream self stream-no)))
      (let ((channel (new UDP-Server-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state server-sender?)))
        (table-set! server-channels channel-no channel)
        channel)))
  
  
  (method package (close-server-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (table-clear server-channels channel-no)))
  
  
  (method package (register-send-channel self priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (let ((stream (find-send-stream self stream-no)))
      (let ((channel (new UDP-Send-Channel priority stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
        (table-set! send-channels channel-no channel)
        channel)))
  
  
  (method package (close-send-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (table-clear send-channels channel-no)))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method package (send-media self channel-no buffer dts pts duration flags)
    (mutex-lock! server-mutex)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((kind (get-media-kind channel)))
          (let ((server-channel (find-server-channel self channel-no)))
            (sending-media channel server-no buffer dts pts duration flags
              (lambda (parcel)
                (broadcast-media self server-channel kind parcel)))))))
    (mutex-unlock! server-mutex))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (run-receive self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (catch-exception-filter
          (lambda (exc)
            udp-stopping?)
          (lambda (exc)
            (continuation-return exit #f))
          (lambda ()
            (let (loop)
              (let ((data (read-parcel udp-port)))
                (site receive
                  (receive-data self data))
                (loop))))))))
  
  
  (method (receive-data self data)
    (mutex-lock! server-mutex)
    (receive-data-unlocked self data)
    (mutex-unlock! server-mutex))
  
  
  (method (receive-data-unlocked self data)
    (if (< (parcel-length data) 4)
        (begin
          (problem "Receiving data: Invalid packet: {a}" data)
          (increase! invalid-packets))
      (with-record header
        (let ((code (read-header-code data)))
          (if (/= code udp-code)
              (begin
                (problem "Receiving data: Invalid code: {a}" code)
                (increase! invalid-packets))
            (let ((kind (read-header-kind data))
                  (sender (read-header-sender data)))
              (if (= kind udp-connect)
                  (connect-source self data)
                (let ((connection (no->connection self sender)))
                  (when connection
                    ;; experiment for a udp timeout hypothesis
                    (let ((source-info (udp-source-socket-info udp-port)))
                      (let ((source-host (socket-info-address source-info))
                            (source-port (socket-info-port-number source-info)))
                        (unless (and (host=? source-host (get-host connection))
                                     (service=? source-port (get-port connection)))
                          (when record-events?
                            (record-event udp-id-reconnect
                                          -1.
                                          (fixnum->flonum sender)
                                          -1.
                                          (fixnum->flonum (get-port connection))
                                          (fixnum->flonum source-port)
                                          -1.
                                          -1.))
                          (update-host/port connection source-host source-port))))
                    (increase-received connection data)
                    (ecase kind
                      ((udp-heartbeat)
                       (receive-heartbeat self connection sender data))
                      ((udp-nack)
                       (receive-nack self connection data))
                      ((udp-audio udp-video)
                       (receive-medias self connection kind data))
                      ((udp-media-trial)
                       (receive-media-trial self connection data))
                      ((udp-media-pulse)
                       (receive-media-pulse self connection data))
                      ((udp-state)
                       (receive-state self data))
                      ((udp-lively)
                       (receive-lively self connection sender data))
                      ((udp-profile-pulse)
                       (receive-profile-pulse self connection sender data))
                      ((udp-profile-media)
                       (receive-profile-media self connection data))
                      ((udp-profile-media-pulse)
                       (receive-profile-media-pulse self connection data))
                      ((udp-profile-dummy)
                       (receive-profile-dummy self connection data))
                      (else
                       (error "Unknown UDP kind: {s}" kind)))
                    (when (and (/= kind udp-audio)
                               (/= kind udp-video))
                      (unref-parcel$ data)))))))))))
  
  
  (method (connect-source self data)
    (with-record connect
      (let ((sender (read-header-sender data))
            (sent (read-connect-sent data))
            (graphic-level (read-connect-graphic-level data))
            (source-info (udp-source-socket-info udp-port)))
        (let ((source-host (socket-info-address source-info))
              (source-port (socket-info-port-number source-info)))
          (define (send-connected connection)
            (with-record connected
              (udp-destination-set! source-host source-port udp-port)
              (let ((size (calculate-connected-size)))
                (let ((data (make-u8vector size)))
                  (write-header-code data udp-code)
                  (write-header-kind data udp-connected)
                  (write-header-sender data server-no)
                  (write-connected-connect-sent data sent)
                  (write-data data udp-port)
                  (increase-sent connection data)))))
          
          (let ((existing-connection (no->connection self sender)))
            (if existing-connection
                (begin
                  (send-connected existing-connection)
                  (when record-events?
                    (record-event udp-id-connect
                                  -1.
                                  (fixnum->flonum sender)
                                  -1.
                                  reconnect-marker
                                  -1.
                                  -1.
                                  -1.)))
              (let ((graphic-level (and (/= graphic-level -1) graphic-level)))
                (let ((upload (new UDP-Upload))
                      (connection (new UDP-Connection source-host source-port graphic-level)))
                  (register-upload self sender upload)
                  (register-connection self sender connection)
                  (send-connected connection)
                  (when record-events?
                    (record-event udp-id-connect
                                  -1.
                                  (fixnum->flonum sender)
                                  -1.
                                  -1.
                                  -1.
                                  -1.
                                  -1.))))))))))
  
  
  (method package (deconnect-source self no)
    (let ((connection (no->connection self no)))
      (if (not connection)
          (when record-events?
            (record-event udp-id-deconnect
                          -1.
                          (fixnum->flonum no)
                          -1.
                          no-connection-marker
                          -1.
                          -1.
                          -1.))
        (unregister-upload self no)
        (unregister-connection self no)
        (when record-events?
          (record-event udp-id-deconnect
                        -1.
                        (fixnum->flonum no)
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.)))))
  
  
  (method package (new-simulator self)
    (new UDP-Simulator
         (lambda (data connection drop?)
           (unless drop?
             (send-connection self connection data)))))
  
  
  (method package (require-simulator self connection)
    (or (get-simulator connection)
        (let ((sim (new-simulator self)))
          (set-simulator connection sim)
          sim)))
   
  
  (method package (update-streaming self upload-changed)
    (let ((server-specs (get-specs (no->upload self server-no))))
      (for-each (lambda (changed)
                  (bind (stream-no . upload-needs) changed
                    (let ((stream (find-send-stream self stream-no)))
                      (when stream
                        (set-upload-needs stream upload-needs)
                        (let ((specs (new-queue)))
                          (table-iterate (get-channels stream)
                            (lambda (no channel)
                              (let ((src (get-src (get-pipeline channel)))
                                    (stream? (or (= (get-media-kind channel) udp-audio)
                                                 (memv? (get-level channel) upload-needs))))
                                (set-stream? src stream?)
                                (when (and stream? (= (get-media-kind channel) udp-video))
                                  (enqueue specs (cons (get-level channel) (get-caps channel)))))))
                          (table-set! server-specs stream-no (sort < (queue-list specs) key: car)))))))
                upload-changed)))
  
  
  (method (receive-heartbeat self connection sender data)
    ;; ack
    (send-ack self connection sender data))
  
  
  (method (receive-nack self connection data)
    (with-record nack
      (let ((sender (read-header-sender data))
            (channel-no (read-nack-channel data))
            (start (read-nack-start data))
            (gap (read-nack-gap data)))
        (send-missing self connection sender channel-no start gap))))
  
  
  ;; receive and reorder all available packets
  (method package (receive-medias self connection kind data)
    (declare (proper-tail-calls))
    (with-record media
      (let ((no (read-media-channel data)))
        ;; so a sequence of one doesn't allocate a pair
        (let (loop (ordered #f))
          (define (receive)
            (resend-nacks self connection)
            (if (not ordered)
                (receive-media self connection kind data)
              (for-each (lambda (data)
                          (receive-media self connection kind data))
                        ordered)))
          
          (input-port-timeout-set! udp-port 0)
          (let ((next (borrow-parcel$)))
            (let ((parcel-read (udp-read-subu8vector next 0 parcel-size udp-port)))
              (input-port-timeout-set! udp-port #f)
              (cond ((not parcel-read)
                     (unref-parcel$ next)
                     (receive))
                    ((and (= (read-header-kind next) kind)
                          (= (read-media-channel next) no))
                     (set-parcel-length next parcel-read)
                     (increase-received connection next)
                     (loop (add-ordered! next (or ordered (list data)) key: (lambda (data)
                                                                              (read-media-sequence data)))))
                    (else
                     (set-parcel-length next parcel-read)
                     (receive)
                     (receive-data-unlocked self next)))))))))
  
  
  (method (receive-media self connection kind data)
    (with-record media
      (let ((channel-no (read-media-channel data))
            (sender (read-header-sender data)))
        (let ((channel (find-server-channel self channel-no)))
          (when channel
            (send-media-ack self connection data)
            (retain-media channel data)
            (broadcast-media self channel kind data)
            (unref-parcel$ data))))))
  
  
  (method (send-missing self connection sender channel-no start gap)
    (let ((channel (or (find-send-channel self channel-no)
                       (find-server-channel self channel-no))))
      (when channel
        (let ((media-kind (get-media-kind channel))
              (ring (get-retain-ring channel)))
          (loop (for sequence from start below (+ start gap))
                (let ((data (locate-data ring sequence)))
                  (if data
                      (with-record media
                        (increase-media-resent data)
                        (send-data self connection data)
                        (when record-events?
                          (let ((frame (read-media-frame data)))
                            (record-event udp-id-resend-packet
                                          (fixnum->flonum channel-no)
                                          (fixnum->flonum sender)
                                          (fixnum->flonum media-kind)
                                          (fixnum->flonum sequence)
                                          (fixnum->flonum frame)
                                          -1.
                                          -1.))))
                    (when record-events?
                      (record-event udp-id-absent-packet
                                    (fixnum->flonum channel-no)
                                    (fixnum->flonum sender)
                                    (fixnum->flonum media-kind)
                                    (fixnum->flonum sequence)
                                    -1.
                                    -1.
                                    -1.))
                    ;; we already nacked the source early and will broadcast
                    ;; when we receive the resent so we can ignore this nack
                    )))))))
  
  
  (method (receive-media-trial self connection data)
    (send-media-ack self connection data))
  
  
  (method (receive-media-pulse self connection data)
    (send-media-ack self connection data))
  
  
  (method (receive-state self data)
    (with-record state
      (let ((sender (read-header-sender data)))
        ;; reset
        (let ((waiting (u8vector->object (read-state-waiting data)))
              (needs-reset '()))
          (for-each (lambda (channel-no)
                      (let ((channel (find-send-channel self channel-no)))
                        (when channel
                          (set! needs-reset (cons channel needs-reset)))))
                    waiting)
          (when (not-null? needs-reset)
            (delay-event
              (lambda ()
                (for-each reset-media needs-reset)))))
        ;; broadcast
        (broadcast-state self sender data))))
  
  
  (method (broadcast-state self sender data)
    (let ((delegate (find-delegate-by-no (current-server) sender)))
      (when delegate
        (let ((group (get-group delegate)))
          (when group
            (for-each (lambda (member)
                        (let ((no (get-no member)))
                          (let ((connection (no->connection self no)))
                            (when connection
                              (unless (eq? member delegate)
                                (send-data self connection data))))))
                      (get-members group)))))))
  
  
  (method override (send-nack self sender channel-no start gap ring)
    (let ((connection (no->connection self sender)))
      (when connection
        (with-record nack
          (let ((size (calculate-nack-size)))
            (let ((data (make-u8vector size)))
              (write-header-code data udp-code)
              (write-header-kind data udp-nack)
              (write-header-sender data server-no)
              (write-nack-channel data channel-no)
              (write-nack-start data start)
              (write-nack-gap data gap)
              (send-data self connection data)
              (add-resending-nacks connection data))))
        (let ((time (+ (current-seconds) .15)))
          (insert reset-ring time
            (lambda ()
              (let ((unfulfilled?
                      (loop (for seq from start below (+ start gap))
                            (some (let ((packet (locate-packet ring seq)))
                                    (and packet (not (get-data packet))))))))
                (when unfulfilled?
                  (send-reset self connection channel-no)))))))))
  
  
  (method (send-reset self connection channel-no)
    (mutex-lock! server-mutex)
    (with-record reset
      (let ((size (calculate-reset-size)))
        (let ((data (make-u8vector size)))
          (write-header-code data udp-code)
          (write-header-kind data udp-reset)
          (write-header-sender data server-no)
          (write-reset-channel data channel-no)
          (send-data self connection data))))
    (mutex-unlock! server-mutex))
  
  
  (method (send-media-ack self connection data)
    (with-record media-ack
      (let ((size (calculate-media-ack-size))
            (order (with-record media-ackable
                     (read-media-ackable-order data))))
        (let ((data (make-u8vector size)))
          (write-header-code data udp-code)
          (write-header-kind data udp-media-ack)
          (write-header-sender data server-no)
          (write-media-ack-order data order)
          (send-data self connection data)))))
  
  
  (method (resend-nacks self connection)
    (let ((resending-nacks (get-resending-nacks connection)))
      (when (not-null? resending-nacks)
        (for-each (lambda (data)
                    (send-data self connection data))
                  resending-nacks)
        (set-resending-nacks connection '()))))
  
  
  (method (send-ack self connection sender data)
    (let ((monitor (get-monitor connection)))
      (let ((bytes-sent (get-bytes-sent monitor))
            (bytes-received (get-bytes-received monitor)))
        (define (extract)
          (with-record heartbeat
            (values (read-heartbeat-sent data)
                    (read-heartbeat-sequence data)
                    (read-heartbeat-bytes-sent data))))
        
        (bind-values (heartbeat-sent heartbeat-sequence heartbeat-bytes-sent) (extract)
          (with-record ack
            (let ((size (calculate-ack-size)))
              (let ((data (make-u8vector size)))
                (write-header-code data udp-code)
                (write-header-kind data udp-ack)
                (write-header-sender data sender)
                (write-ack-heartbeat-sent data heartbeat-sent)
                (write-ack-heartbeat-sequence data heartbeat-sequence)
                (write-ack-heartbeat-bytes-sent data heartbeat-bytes-sent)
                (write-ack-sent data (current-seconds))
                (write-ack-bytes-sent data bytes-sent)
                (write-ack-bytes-received data bytes-received)
                (send-data self connection data))
              (when record-events?
                (record-event udp-id-send-ack
                              -1.
                              (fixnum->flonum sender)
                              -1.
                              (fixnum->flonum heartbeat-sequence)
                              -1.
                              -1.
                              -1.))))))))
  
  
  (method (broadcast-media self channel kind data)
    (for-each (lambda (connection)
                (if (waiting-keyframe? connection channel)
                    (with-record media
                      (when (frame-keyframe? (read-media-flags data))
                        (got-keyframe connection channel)
                        (send-data self connection data)))
                  (send-data self connection data)))
              (get-receivers channel)))
  
  
  (method package (wait-keyframes self delegate connection)
    (let ((server (current-server)))
      (table-iterate server-channels
        (lambda (no channel)
          (let ((stream (get-stream channel)))
            (when (memq? delegate (get-members (get-recipient stream)))
              (wait-keyframe connection channel)))))))
  
  
  (method package (done-keyframes self delegate connection)
    (let ((server (current-server)))
      (table-iterate server-channels
        (lambda (no channel)
          (let ((stream (get-stream channel)))
            (when (memq? delegate (get-members (get-recipient stream)))
              (done-keyframe connection channel)))))))
    
  
  (method (receive-lively self connection sender data)
    (send-lively-ack self connection sender data))
  
  
  (method (send-lively-ack self connection sender data)
    (with-record header
      (let ((size (calculate-lively-ack-size)))
        (let ((data (make-u8vector size)))
          (write-header-code data udp-code)
          (write-header-kind data udp-lively-ack)
          (write-header-sender data sender)
          (send-data self connection data)))))

  
  (method package (send-profile-media self connection order payload)
    (mutex-lock! server-mutex)
    (with-record profile-media
      (let ((size (calculate-profile-media-size payload)))
        (let ((data (make-u8vector size)))
          (write-header-code data udp-code)
          (write-header-kind data udp-profile-media)
          (write-header-sender data server-no)
          (write-profile-media-order data order)
          (write-profile-media-payload data payload)
          (send-data self connection data))))
    (mutex-unlock! server-mutex))
  
  
  (method (receive-profile-pulse self connection sender data)
    (receive-profile-pulse connection data)
    (send-profile-ack self connection sender data))
  
  
  (method (send-profile-ack self connection sender data)
    (let ((now (current-seconds))
          (time-base (get-profile-time-base connection))
          (profile-monitor (get-profile-monitor connection)))
      (let ((bytes-sent (get-bytes-sent profile-monitor))
            (bytes-received (get-bytes-received profile-monitor)))
        (define (extract)
          (with-record profile-pulse
            (values (read-profile-pulse-sent data)
                    (read-profile-pulse-sequence data)
                    (read-profile-pulse-bytes-sent data))))
        
        (bind-values (pulse-sent pulse-sequence pulse-bytes-sent) (extract)
          (update-time time-base now pulse-sent)
          (with-record profile-ack
            (let ((size (calculate-profile-ack-size)))
              (let ((data (make-u8vector size)))
                (write-header-code data udp-code)
                (write-header-kind data udp-profile-ack)
                (write-header-sender data sender)
                (write-profile-ack-pulse-sent data pulse-sent)
                (write-profile-ack-pulse-sequence data pulse-sequence)
                (write-profile-ack-pulse-bytes-sent data pulse-bytes-sent)
                (write-profile-ack-sent data now)
                (write-profile-ack-latency data (get-raw-latency time-base))
                (write-profile-ack-bytes-sent data bytes-sent)
                (write-profile-ack-bytes-received data bytes-received)
                (send-data self connection data)
                (increase-sent profile-monitor data))))))))
  
  
  (method (receive-profile-media self connection data)
    (send-profile-media-ack self connection data)
    (receive-profile-media connection data))
  
  
  (method package (send-profile-media-ack self connection data)
    (with-record profile-media-ack
      (let ((size (calculate-profile-media-ack-size))
            (order (with-record profile-media
                     (read-profile-media-order data))))
        (let ((data (make-u8vector size)))
          (write-header-code data udp-code)
          (write-header-kind data udp-profile-media-ack)
          (write-header-sender data server-no)
          (write-profile-media-ack-received data (current-seconds))
          (write-profile-media-ack-order data order)
          (send-data self connection data)))))
  
  
  (method (receive-profile-media-pulse self connection data)
    (send-profile-media-pulse-ack self connection data))
  
  
  (method package (send-profile-media-pulse-ack self connection data)
    (with-record profile-media-ack
      (let ((size (calculate-profile-media-ack-size))
            (order (with-record profile-media-pulse
                     (read-profile-media-pulse-order data))))
        (let ((data (make-u8vector size)))
          (write-header-code data udp-code)
          (write-header-kind data udp-profile-media-ack)
          (write-header-sender data server-no)
          (write-profile-media-ack-received data (current-seconds))
          (write-profile-media-ack-order data order)
          (send-data self connection data)))))
  
  
  (method (receive-profile-dummy self connection data)
    (receive-profile-dummy connection data))
  
  
  (method (send-data self connection data)
    (let ((simulator (get-simulator connection)))
      (if simulator
          (send simulator data connection)
        (send-connection self connection data)))
    (increase-sent connection data))
  
  
  (method (send-connection self connection data)
    (udp-destination-set! (get-host connection) (get-port connection) udp-port)
    (write-data data udp-port))
  
  
  ;;;
  ;;;; Reset
  ;;;
  
  
  (method (run-reset self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((proc (wait reset-ring)))
            (if (not proc)
                (continuation-return exit #f)
              (proc)
              (loop))))))))


;;;
;;;; UDP Upload
;;;


(class UDP-Upload extends Object
  
  
  (slot needs   getter generate)
  (slot specs   getter generate)
  (slot closing getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.needs (make-table))
    (set! self.specs (make-table))
    (set! self.closing (make-table)))
  
  
  (method package (unregister-stream-reset self stream-no)
    (table-clear needs stream-no)
    (table-clear specs stream-no)
    (table-clear closing stream-no))
  
  
  (method package (leave-group-reset self)
    (set! needs (make-table))
    (set! specs (make-table))
    (set! closing (make-table))))


;;;
;;;; UDP Connection
;;;


(class UDP-Connection extends Object
  
  
  (slot host                                   getter generate)
  (slot port                                   getter generate)
  (slot monitor                                getter generate)
  (slot simulator               initialize #f  accessors generate)
  (slot graphic-level                          getter generate)
  (slot circle-mode                            accessors generate)
  (slot circle-focused                         accessors generate)
  (slot download-need                          getter generate)
  (slot download-spec                          getter generate)
  (slot download-closing                       getter generate)
  (slot waiting-for-keyframe                   accessors generate)
  (slot resending-nacks         initialize '() accessors generate)
  (slot profile-base-time       initialize #f  getter generate)
  (slot profile-time-base       initialize #f  getter generate)
  (slot profile-media-order     initialize #f  getter generate)
  (slot profile-last-order      initialize #f  getter generate)
  (slot profile-monitor         initialize #f  getter generate)
  (slot profile-chronology      initialize #f  getter generate)
  (slot profile-evolution       initialize #f  getter generate)
  
  
  (method override (initialize self host port graphic-level)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port)
    (set! self.monitor (new UDP-Monitor))
    (set! self.graphic-level graphic-level)
    (set! self.circle-mode 'gallery)
    (set! self.circle-focused #f)
    (set! self.download-need (make-table))
    (set! self.download-spec (make-table))
    (set! self.download-closing (make-table))
    (set! self.waiting-for-keyframe (make-table test: eq?))
    (set! self.profile-time-base (new Time-Base)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port))))
  
  
  (method package (update-host/port self host port)
    (set! self.host host)
    (set! self.port port))
  
  
  (method package (unregister-stream-reset self stream-no)
    (table-clear download-need stream-no)
    (table-clear download-spec stream-no)
    (table-clear download-closing stream-no))
  
  
  (method package (leave-group-reset self)
    (set! circle-mode #f)
    (set! circle-focused #f)
    (set! download-need (make-table))
    (set! download-spec (make-table))
    (set! download-closing (make-table)))
  
  
  (method package (waiting-keyframe? self channel)
    (table-ref waiting-for-keyframe channel #f))
  
  
  (method package (wait-keyframe self channel)
    (when (= (get-media-kind channel) udp-video)
      (table-set! waiting-for-keyframe channel #t)))
  
  
  (method package (got-keyframe self channel)
    (table-clear waiting-for-keyframe channel))
  
  
  (method package (done-keyframe self channel)
    (table-clear waiting-for-keyframe channel))
  
  
  (method package (increase-sent self data)
    (increase-sent monitor data))
  
  
  (method package (increase-received self data)
    (increase-received monitor data))
  
  
  (method package (add-resending-nacks self data)
    (set! resending-nacks (cons data resending-nacks)))
  
  
  (method package (next-profile-media-order! self)
    (prog1 profile-media-order
      (increase! profile-media-order)))
  
  
  (method package (profile-start self)
    (set! profile-base-time (current-seconds))
    (set! profile-media-order 0)
    (set! profile-last-order #f)
    (set! profile-monitor (new UDP-Monitor))
    (set! profile-chronology (new Chronology 0))
    (set! profile-evolution (new Evolution 5000)))
  
  
  (method package (profile-test self test arguments)
    (let ((send-thread
            (new-thread
              (lambda ()
                (let ((base (current-seconds))
                      (recuperate .5))
                  (define (wait target)
                    (sleep (- (+ base target) (current-seconds))))
                  
                  (let ((server (current-server)))
                    (let ((mbps (car arguments)))
                      (let ((size 1000)
                            (duration 1.))
                        (let ((delay (/ (cast <fl> size) (mbps->bytes mbps)))
                              (udp-server (get-udp-server server)))
                          (let ((iter (fxround (/ duration delay))))
                            (let ((elapse (/ duration (cast <fl> iter)))
                                  (data (make-u8vector size)))
                              (loop (for n from 0 below iter)
                                    (wait (* (cast <fl> n) elapse))
                                    (send-profile-media udp-server self (next-profile-media-order! self) data)
                                    (increase-sent profile-monitor data))))))))))
              'send)))
      (thread-base-priority-set! send-thread profile-priority)
      (thread-start! send-thread)))
  
  
  (method package (profile-retrieve self)
    (let ((metadata (list server-no "_server" '() '() (sites-metadata) profile-base-time))
          (chronology (copy-chronology profile-chronology))
          (evolution (copy-evolution profile-evolution)))
      (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
  
  
  (method package (profile-stop self)
    (set! profile-chronology #f)
    (set! profile-evolution #f))
  
  
  (method (receive-profile-pulse self data)
    (increase-received profile-monitor data))
  
  
  (method package (receive-profile-media self data)
    (with-record profile-media
      (let ((sender (read-header-sender data))
            (order (read-profile-media-order data)))
        (when record-events?
          (when profile-last-order
            (let ((expected-order (+ profile-last-order 1)))
              (when (/= order expected-order)
                (parameterize ((simulation-evolution profile-evolution))
                  (loop (for ord from expected-order below order)
                        (record-event udp-id-lost-packet
                                      -1.
                                      (fixnum->flonum sender)
                                      (fixnum->flonum udp-profile-media)
                                      (fixnum->flonum ord)
                                      -1.
                                      -1.
                                      -1.)))))))
        (set! profile-last-order order)
        (increase-received profile-monitor data))))
  
  
  (method package (receive-profile-dummy self data)
    (with-record profile-dummy
      (let ((sender (read-header-sender data))
            (order (read-profile-dummy-order data)))
        (when record-events?
          (parameterize ((simulation-evolution profile-evolution))
            (record-event udp-id-dummy-receive
                          -1.
                          (fixnum->flonum sender)
                          -1.
                          -1.
                          (fixnum->flonum order)
                          -1.
                          -1.)))
        (increase-received profile-monitor data)))))


;;;
;;;; Server Stream
;;;


(class UDP-Server-Stream extends UDP-Stream
  
  
  (slot video-on?         accessors generate)
  (slot recipient         getter generate)
  (slot exclude-register  getter generate)
  (slot exclude-broadcast getter generate)
  
  
  (method override (initialize self sender name no origin source-kind video-levels video-on? recipient exclude-register exclude-broadcast)
    (nextmethod self sender name no origin source-kind video-levels)
    (set! self.video-on? video-on?)
    (set! self.recipient recipient)
    (set! self.exclude-register exclude-register)
    (set! self.exclude-broadcast exclude-broadcast)))


;;;
;;;; Server Channel
;;;


(class UDP-Server-Channel extends UDP-Retain-Channel
  
  
  (slot server-sender? getter generate)
  (slot receivers      accessors generate)
  
  
  (method override (initialize self stream-no no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state server-sender?)
    (nextmethod self stream-no no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (set! self.server-sender? server-sender?)
    (set! self.receivers '())
    (if server-sender?
        (set! self.retain-ring #f)
      (set! self.retain-ring (new UDP-Ring self no (get-origin stream) media-kind source-kind udp-retain-size max-size: udp-retain-max-size overflow-proc: (udp-ring-overflow 'retain udp-ring-kind-retain) retain-window: (effective-retain-window source-kind)))))
  
  
  (method package (retain-media self data)
    (ref-parcel$ data)
    (insert retain-ring data udp-id-retain-packet))))
