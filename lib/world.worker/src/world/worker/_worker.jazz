;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Worker
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.worker jazz


(require (dialect.development))

(import (jazz.debuggee)
        (jazz.digest)
        (jazz.evaluate)
        (jazz.event)
        (jazz.io)
        (jazz.jrm)
        (jazz.runtime)
        (jazz.snapshot)
        (jazz.time))


(definition protected (start-worker-thread port feedback hide)
  (thread-start!
    (new-thread
      (lambda ()
        (set! worker-feedback feedback)
        (set! worker-hide hide)
        (process-work port))
      'worker)))


(definition worker-cache-dir
  #f)

(definition worker-evaluation-dir
  #f)

(definition worker-evaluation-file
  #f)

(definition worker-debug?
  #f)

(definition worker-feedback
  #f)

(definition worker-hide
  #f)

(definition worker-repositories
  (make-table test: equal?))


(definition (setup-worker crashes cache debug? repositories)
  ;; setup crashes
  (snapshots-directory (new Directory (tokenise-filename crashes)))
  (snapshot-max-depth 3)
  (snapshot-max-width 32768)
  ;; append the kernel destination so running different configurations don't overrite one another
  (set! worker-cache-dir (new Directory (tokenise-filename (string-append cache kernel-destination))))
  (set! worker-evaluation-dir (new-directory~ worker-cache-dir "evaluate"))
  (set! worker-evaluation-file (new-file~ worker-evaluation-dir "evaluate.jazz"))
  (set! worker-debug? debug?)
  (create-directories~ worker-cache-dir)
  (create-directories~ worker-evaluation-dir)
  (cleanup-evaluation-cache)
  (setup-worker-repositories repositories)
  (unless (get-controller-debugger)
    (start-remote-listener)))


(definition (setup-worker-repositories new)
  (update-repositories worker-repositories new))


(definition (cleanup-evaluation-cache)
  (when (exists?~ worker-evaluation-dir)
    (empty-directory~ worker-evaluation-dir)))


(definition (load-digests output-dir base)
  (let ((dgs (new-file~ output-dir (add-extension base "dgs")))
        (digests (make-table test: eq?)))
    (when (exists?~ dgs)
      (call-with-input-file (path-settings dgs)
        (lambda (port)
          (let ((form (read port)))
            (assert (and (pair? form) (eq? (car form) 'digests))
              (for-each (lambda (info)
                          (bind (kind hash time) info
                            (table-set! digests kind (new File-Digest hash time))))
                        (cdr form)))))))
    digests))


(definition (lookup/update-digests digests kind src)
  (let ((old-digest (table-ref digests kind #f)))
    (let ((new-digest (file-digest (new File src) old-digest)))
      (table-set! digests kind new-digest)
      (eq? new-digest old-digest))))


(definition (save-digests digests output-dir base)
  (let ((dgs (new-file~ output-dir (add-extension base "dgs"))))
    (call-with-output-file (path-settings dgs)
      (lambda (port)
        (display "(digests" port)
        (newline port)
        (iterate-table digests
          (lambda (kind digest)
            (let ((hash (get-hash~ digest))
                  (time (get-time~ digest)))
              (newline port)
              (display "  " port)
              (write (list kind hash time) port))))
        (display ")" port)
        (newline port)))))


(definition (handling-exceptions thunk problem (debug? worker-debug?))
  (if debug?
      (thunk)
    (with-exception-catcher
      (lambda (exc)
        (problem (list 'error (exception-reason exc) #f)))
      (lambda ()
        (catch (Walk-Problems exc
                 (problem (list 'walk (exception-reason exc) (exception-detail exc))))
          (thunk))))))


(definition (handling-worker-exceptions thunk)
  (handling-exceptions thunk
    (lambda (info)
      info)))


(definition protected (worker-process-repositories repositories)
  (handling-worker-exceptions
    (lambda ()
      (setup-worker-repositories repositories)
      (list 'result #f))))


(definition protected (worker-process-unit mode feedback? time? unit-name)
  (handling-worker-exceptions
    (lambda ()
      (let ((resource (find-unit-src unit-name)))
        (let ((pathname (resource-pathname resource))
              (path (resource-path resource)))
          (let ((output-dir (new-directory~ worker-cache-dir (cons "unit" (tokenise-filename (extract-dir path)))))
                (base (extract-base path)))
            (define (compile-unit)
              (when feedback?
                (feedback (format "Compiling {a}..." unit-name)))
              (let ((timer (new Timer)))
                (prog1 (expanding-unit unit-name
                         (lambda ()
                           (with-resource-reader resource
                             (lambda ()
                               (compile-file pathname options: compile-options cc-options: "-U___SINGLE_HOST -O0" output: (parse~ output-dir))))))
                  (when (and feedback? time?)
                    (let ((duration (real-duration~ timer)))
                      (feedback (format "Compiling {a}... {r precision: 1}s" unit-name duration))
                      (cond ((> duration 5.) (sleep 1.))
                            (else (sleep .5))))))))
            
            (create-directories~ output-dir)
            (case mode
              ((interpret)
               (let ((digests (load-digests output-dir base))
                     (exp (parse~ (new-file~ output-dir (add-extension base "exp")))))
                 (if (lookup/update-digests digests 'interpret pathname)
                     (list 'evaload exp)
                   (let ((expansion (expand-unit unit-name)))
                     (call-with-output-file exp
                       (lambda (port)
                         (write-binary expansion port)))
                     (save-digests digests output-dir base)
                     (list 'evaload exp)))))
              ((compile)
               (let ((digests (load-digests output-dir base)))
                 (if (lookup/update-digests digests 'compile pathname)
                     (list 'load (parse~ (new-file~ output-dir base)))
                   (let ((object-path (compile-unit)))
                     (save-digests digests output-dir base)
                     (list 'load object-path))))))))))))


;; because gambit doesn't support loading the same object file twice, it would be
;; very tricky to cache script compilation as scripts are meant to be ran over and over.
;; in fact this is probably a good thing giving the user the freedom to choose between
;; scripts that stay interpreted and load fast, and modules that get compiled to cache
(definition protected (worker-process-script mode path)
  (handling-worker-exceptions
    (lambda ()
      (list 'eval (expand-script path)))))


(definition protected (worker-process-evaluate mode feedback? syntax str container line col evaluation-mode)
  (handling-worker-exceptions
    (lambda ()
      (case mode
        ((interpret)
         (list 'eval (evaluate-forms syntax str container line col 'interpret evaluate?: #f outline?: #f)))
        ((compile)
         (when feedback?
           (feedback "Compiling evaluation..."))
         (list 'load (evaluate-forms syntax str container line col 'compile file: worker-evaluation-file evaluate?: #f)))))))


(definition protected (worker-process-console unit-name expr)
  (handling-worker-exceptions
    (lambda ()
      (let ((module-declaration (outline-unit unit-name)))
        (let ((form `(module ,unit-name ,(get-dialect-name~ module-declaration) ,expr)))
          (load-unit 'dialect.development)
          (list 'eval (expand-form form unit-name: unit-name walk-for: 'eval)))))))


(definition protected (worker-process-hide)
  (handling-worker-exceptions
    (lambda ()
      (worker-hide)
      (list 'result #f))))


(definition (process-work port)
  (declare (proper-tail-calls))
  (let ((port (open-tcp-client (string->number port))))
    (let (iter)
      (let ((form (read-binary port)))
        (if (or (eof-object? form)
                (null? form))
            (begin
              (close-port port)
              (post-event quit))
          (bind (crashes cache debug? repositories) form
            (handling-exceptions
              (lambda ()
                (setup-worker crashes cache debug? repositories)
                (write-binary (list 'result (list (listening-host~ (get-remote-listener)) (listening-port~ (get-remote-listener))) #f) port))
              (lambda (info)
                (write-binary info port))
              debug?))
          (iter)))))))
