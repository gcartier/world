;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Worker
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.worker jazz


(require (dialect.development))

(import (jazz.digest)
        (jazz.evaluate)
        (jazz.io)
        (jazz.snapshot)
        (jazz.time))


(definition protected (start-worker-thread port feedback hide)
  (thread-start!
    (new-thread
      (lambda ()
        (process-work port feedback hide))
      'worker)))


(definition worker-cache-dir
  #f)

(definition worker-evaluation-dir
  #f)

(definition worker-evaluation-file
  #f)

(definition worker-debug?
  #f)


(definition (setup-worker crashes cache debug?)
  ;; setup crashes
  (snapshots-directory (new Directory (tokenise-filename crashes)))
  (snapshot-max-depth 3)
  (snapshot-max-width 32768)
  ;; append the kernel destination so running different configurations don't overrite one another
  (set! worker-cache-dir (new Directory (tokenise-filename (string-append cache kernel-destination))))
  (set! worker-evaluation-dir (new-directory~ worker-cache-dir "evaluate"))
  (set! worker-evaluation-file (new-file~ worker-evaluation-dir "evaluate.jazz"))
  (set! worker-debug? debug?)
  (create-directories~ worker-cache-dir)
  (create-directories~ worker-evaluation-dir)
  (cleanup-evaluation-cache))


(definition (cleanup-evaluation-cache)
  (when (exists?~ worker-evaluation-dir)
    (empty-directory~ worker-evaluation-dir)))


(definition (load-digests output-dir base)
  (let ((dgs (new-file~ output-dir (add-extension base "dgs")))
        (digests (make-table test: eq?)))
    (when (exists?~ dgs)
      (call-with-input-file (path-settings dgs)
        (lambda (port)
          (let ((form (read port)))
            (assert (and (pair? form) (eq? (car form) 'digests))
              (for-each (lambda (info)
                          (bind (kind hash time) info
                            (table-set! digests kind (new File-Digest hash time))))
                        (cdr form)))))))
    digests))


(definition (lookup/update-digests digests kind src)
  (let ((old-digest (table-ref digests kind #f)))
    (let ((new-digest (file-digest (new File src) old-digest)))
      (table-set! digests kind new-digest)
      (eq? new-digest old-digest))))


(definition (save-digests digests output-dir base)
  (let ((dgs (new-file~ output-dir (add-extension base "dgs"))))
    (call-with-output-file (path-settings dgs)
      (lambda (port)
        (display "(digests" port)
        (newline port)
        (iterate-table digests
          (lambda (kind digest)
            (let ((hash (get-hash~ digest))
                  (time (get-time~ digest)))
              (newline port)
              (display "  " port)
              (write (list kind hash time) port))))
        (display ")" port)
        (newline port)))))


(definition (process-work port feedback hide)
  (declare (proper-tail-calls))
  (let ((port (open-tcp-client (string->number port))))
    (let (iter)
      (let ((form (read-binary port)))
        (if (or (eof-object? form)
                (null? form))
            (begin
              (close-port port)
              (exit))
          (bind (command . rest) form
            (case command
              ((setup)
               (bind (crashes cache debug?) rest
                 (setup-worker crashes cache debug?)))
              ((repositories)
               (bind (repositories) rest
                 (for-each install-repository repositories)))
              (else
               (bind (command mode feedback? time? . arguments) form
                 (define (process-unit unit-name)
                   (let ((resource (find-unit-src unit-name)))
                     (let ((pathname (resource-pathname resource))
                           (path (resource-path resource)))
                       (let ((output-dir (new-directory~ worker-cache-dir (cons "unit" (tokenise-filename (extract-dir path)))))
                             (base (extract-base path)))
                         (define (compile-unit)
                           (when feedback?
                             (feedback (format "Compiling {a}..." unit-name)))
                           (let ((timer (new Timer)))
                             (prog1 (expanding-unit unit-name
                                      (lambda ()
                                        (with-resource-reader resource
                                          (lambda ()
                                            (compile-file pathname options: compile-options cc-options: "-U___SINGLE_HOST -O0" output: (parse~ output-dir))))))
                               (when (and feedback? time?)
                                 (let ((duration (real-duration~ timer)))
                                   (feedback (format "Compiling {a}... {r precision: 1}s" unit-name duration))
                                   (cond ((> duration 5.) (sleep 1.))
                                         (else (sleep .5))))))))
                         
                         (create-directories~ output-dir)
                         (case mode
                           ((interpret)
                            (let ((digests (load-digests output-dir base))
                                  (exp (parse~ (new-file~ output-dir (add-extension base "exp")))))
                              (if (lookup/update-digests digests 'interpret pathname)
                                  (write-result 'evaload exp)
                                (let ((expansion (expand-unit unit-name)))
                                  (call-with-output-file exp
                                    (lambda (port)
                                      (write-binary expansion port)))
                                  (save-digests digests output-dir base)
                                  (write-result 'evaload exp)))))
                           ((compile)
                            (let ((digests (load-digests output-dir base)))
                              (if (lookup/update-digests digests 'compile pathname)
                                  (write-result 'load (parse~ (new-file~ output-dir base)))
                                (let ((object-path (compile-unit)))
                                  (save-digests digests output-dir base)
                                  (write-result 'load object-path))))))))))
                 
                 ;; because gambit doesn't support loading the same object file twice, it would be
                 ;; very tricky to cache script compilation as scripts are meant to be ran over and over.
                 ;; in fact this is probably a good thing giving the user the freedom to choose between
                 ;; scripts that stay interpreted and load fast, and modules that get compiled to cache
                 (define (process-script path)
                   (write-result 'eval (expand-script path)))
                 
                 (define (process-evaluate syntax str container line col evaluation-mode)
                   (case mode
                     ((interpret)
                      (write-result 'eval (evaluate-forms syntax str container line col 'interpret evaluate?: #f)))
                     ((compile)
                      (when feedback?
                        (feedback "Compiling evaluation..."))
                      (write-result 'load (evaluate-forms syntax str container line col 'compile file: worker-evaluation-file evaluate?: #f)))))
                 
                 (define (process-console unit-name expr)
                   (let ((module-declaration (outline-unit unit-name)))
                     (let ((form `(module ,unit-name ,(get-dialect-name~ module-declaration) ,expr)))
                       (load-unit 'dialect.development)
                       (write-result 'eval (expand-form form unit-name: unit-name walk-for: 'eval)))))
                 
                 (define (write-result what result)
                   (write-binary (list what result #f) port))
                 
                 (define (handling-exceptions thunk)
                   (if worker-debug?
                       (thunk)
                     (with-exception-catcher
                       (lambda (exc)
                         (write-binary (list 'error (exception-reason exc) #f) port))
                       (lambda ()
                         (catch (Walk-Problems exc
                                  (write-binary (list 'walk (exception-reason exc) (exception-detail exc)) port))
                           (thunk))))))
                 
                 (case command
                   ((unit)
                    (handling-exceptions
                      (lambda ()
                        (apply process-unit arguments))))
                   ((script)
                    (handling-exceptions
                      (lambda ()
                        (apply process-script arguments))))
                   ((evaluate)
                    (handling-exceptions
                      (lambda ()
                        (apply process-evaluate arguments))))
                   ((console)
                    (handling-exceptions
                      (lambda ()
                        (apply process-console arguments))))
                   ((hide)
                    (hide))
                   (else
                    (error "Unknown worker command" command)))))))
          (iter)))))))
