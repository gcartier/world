;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Worker
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.worker jazz


(require (dialect.development))

(import (jazz.debuggee)
        (jazz.digest)
        (jazz.evaluate)
        (jazz.event)
        (jazz.io)
        (jazz.jrm)
        (jazz.network)
        (jazz.runtime)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.time))


(definition worker-mutex
  (make-mutex 'worker))

(definition worker-cache-dir
  #f)

(definition worker-evaluation-dir
  #f)

(definition worker-evaluation-file
  #f)

(definition worker-optimize?
  #f)

(definition worker-debug?
  #f)

(definition worker-feedback
  #f)

(definition worker-hide
  #f)

(definition worker-repositories
  (make-table test: equal?))


(definition protected (ready-worker feedback hide)
  (set! worker-feedback feedback)
  (set! worker-hide hide)
  (start-remote-listener)
  (let ((master (command-argument "master"))
        (cookie (integer-argument "master-cookie")))
    (receive (host port alternate-port) (parse-host/service master)
      (let ((remote-register (connect-remote-register host port #t)))
        (let ((master (load-object~ remote-register 'world.master 'world-remote-master))
              (worker (load-object~ (get-local-register) 'world.worker.remote 'world-remote-worker)))
          (slave-setup~ master worker cookie)
          (slave-ready~ master worker cookie))))))


(definition (setup-worker crashes cache optimize? debug? repositories)
  ;; setup crashes
  (snapshots-directory (new Directory (tokenise-filename crashes)))
  (snapshot-max-depth 3)
  (snapshot-max-width 32768)
  ;; append the kernel destination so running different configurations don't overrite one another
  (set! worker-cache-dir (new Directory (tokenise-filename (string-append cache kernel-destination))))
  (set! worker-evaluation-dir (new-directory~ worker-cache-dir "evaluate"))
  (set! worker-evaluation-file (new-file~ worker-evaluation-dir "evaluate.jazz"))
  (set! worker-optimize? optimize?)
  (set! worker-debug? debug?)
  (create-directories~ worker-cache-dir)
  (create-directories~ worker-evaluation-dir)
  (cleanup-evaluation-cache)
  (setup-worker-repositories repositories)
  (start-remote-listener))


(definition (setup-worker-repositories new)
  (update-repositories worker-repositories new))


(definition (cleanup-evaluation-cache)
  (when (exists?~ worker-evaluation-dir)
    (empty-directory~ worker-evaluation-dir)))


(definition (load-digests output-dir base)
  (let ((dgs (new-file~ output-dir (add-extension base "dgs")))
        (digests (make-table test: eq?)))
    (when (exists?~ dgs)
      (call-with-input-file (path-settings dgs)
        (lambda (port)
          (let ((form (read port)))
            (assert (and (pair? form) (eq? (car form) 'digests))
              (for-each (lambda (info)
                          (bind (kind hash time) info
                            (table-set! digests kind (new File-Digest hash time))))
                        (cdr form)))))))
    digests))


(definition (lookup/update-digests digests kind src)
  (let ((old-digest (table-ref digests kind #f)))
    (let ((new-digest (file-digest (new File src) old-digest)))
      (table-set! digests kind new-digest)
      (eq? new-digest old-digest))))


(definition (save-digests digests output-dir base)
  (let ((dgs (new-file~ output-dir (add-extension base "dgs"))))
    (call-with-output-file (path-settings dgs)
      (lambda (port)
        (display "(digests" port)
        (newline port)
        (iterate-table digests
          (lambda (kind digest)
            (let ((hash (get-hash~ digest))
                  (time (get-time~ digest)))
              (newline port)
              (display "  " port)
              (write (list kind hash time) port))))
        (display ")" port)
        (newline port)))))


(definition (with-worker thunk (debug?: debug? worker-debug?))
  (unwind-protect
      (begin
        (mutex-lock! worker-mutex)
        (if worker-debug?
            (thunk)
          (with-exception-catcher
            (lambda (exc)
              (list 'error (exception-reason exc) #f))
            (lambda ()
              (catch (Walk-Problems exc
                       (list 'walk (exception-reason exc) (exception-detail exc)))
                (thunk))))))
    (mutex-unlock! worker-mutex)))


(definition protected (worker-process-setup crashes cache optimize? debug? repositories)
  (with-worker
    (lambda ()
      (setup-worker crashes cache optimize? debug? repositories)
      (list 'result #f #f))
    debug?: debug?))


(definition protected (worker-process-repositories repositories)
  (with-worker
    (lambda ()
      (setup-worker-repositories repositories)
      (list 'result #f #f))))


(definition protected (worker-process-unit mode feedback? time? unit-name)
  (with-worker
    (lambda ()
      (let ((resource (find-unit-src unit-name)))
        (let ((pathname (resource-pathname resource))
              (path (resource-path resource)))
          (let ((output-dir (new-directory~ worker-cache-dir (cons "unit" (tokenise-filename (extract-dir path)))))
                (base (extract-base path)))
            (define (compile-unit)
              (when feedback?
                (worker-feedback (format "Compiling {a}..." unit-name)))
              (let ((timer (new Timer)))
                (load-build)
                (prog1 (bind-keywords ((cc-options #f) (ld-options #f)) (or (find-unit-options unit-name) '())
                         (let ((deoptimize (if worker-optimize? "" "-U___SINGLE_HOST -O0")))
                           (expanding-unit unit-name
                             (lambda ()
                               (with-resource-reader resource
                                 (lambda ()
                                   (compile-file pathname options: compile-options cc-options: (if cc-options (string-append deoptimize " " cc-options) deoptimize) ld-options: (or ld-options "") output: (parse~ output-dir))))))))
                  (when (and feedback? time?)
                    (let ((duration (real-duration~ timer)))
                      (worker-feedback (format "Compiling {a}... {r precision: 1}s" unit-name duration))
                      (cond ((> duration 5.) (sleep 1.))
                            (else (sleep .5))))))))
            
            (create-directories~ output-dir)
            (case mode
              ((interpret)
               (let ((digests (load-digests output-dir base))
                     (exp (parse~ (new-file~ output-dir (add-extension base "exp")))))
                 (if (lookup/update-digests digests 'interpret pathname)
                     (list 'evaload exp #f)
                   (let ((expansion (expand-unit unit-name)))
                     (call-with-output-file exp
                       (lambda (port)
                         (write-binary expansion port)))
                     (save-digests digests output-dir base)
                     (list 'evaload exp #f)))))
              ((compile)
               (let ((digests (load-digests output-dir base)))
                 (if (lookup/update-digests digests 'compile pathname)
                     (list 'load (parse~ (new-file~ output-dir base)) #f)
                   (let ((object-path (compile-unit)))
                     (save-digests digests output-dir base)
                     (list 'load object-path #f))))))))))))


;; because gambit doesn't support loading the same object file twice, it would be
;; very tricky to cache script compilation as scripts are meant to be ran over and over.
;; in fact this is probably a good thing giving the user the freedom to choose between
;; scripts that stay interpreted and load fast, and modules that get compiled to cache
(definition protected (worker-process-script mode path)
  (with-worker
    (lambda ()
      (list 'eval (expand-script path) #f))))


(definition protected (worker-process-evaluate mode feedback? syntax str container line col evaluation-mode)
  (with-worker
    (lambda ()
      (case mode
        ((interpret)
         (list 'eval (evaluate-forms syntax str container line col 'interpret evaluate?: #f) #f))
        ((compile)
         (when feedback?
           (worker-feedback "Compiling evaluation..."))
         (list 'load (evaluate-forms syntax str container line col 'compile file: worker-evaluation-file evaluate?: #f) #f))))))


(definition protected (worker-process-run mode feedback? syntax str container line col evaluation-mode)
  (with-worker
    (lambda ()
      (case mode
        ((interpret)
         (list 'eval (evaluate-forms syntax str container line col 'interpret evaluate?: #f scripting?: #t) #f))
        ((compile)
         (when feedback?
           (worker-feedback "Compiling evaluation..."))
         (list 'load (evaluate-forms syntax str container line col 'compile file: worker-evaluation-file evaluate?: #f scripting?: #t) #f))))))


(definition protected (worker-process-console unit-name expr)
  (with-worker
    (lambda ()
      (let ((module-declaration (outline-unit unit-name)))
        (let ((form `(module ,unit-name ,(get-dialect-name~ module-declaration) ,expr)))
          (load-unit 'dialect.development)
          (list 'eval (expand-form form unit-name: unit-name walk-for: 'eval) #f))))))


(definition protected (worker-process-hide)
  (with-worker
    (lambda ()
      (worker-hide)
      (list 'result #f #f))))


(definition protected (worker-process-quit)
  (quit)))
