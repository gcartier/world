;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Worker
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.worker jazz


(require (dialect.development))

(import (jazz.evaluate)
        (jazz.io)
        (jazz.system))


(definition protected (start-worker-thread port feedback hide)
  (thread-start!
    (new-thread
      (lambda ()
        (process-work port feedback hide))
      'worker)))


(definition worker-cache-dir
  #f)

(definition worker-evaluation-dir
  #f)

(definition worker-evaluation-file
  #f)

(definition worker-debug?
  #f)


(definition (setup-worker cache debug?)
  ;; append the kernel destination so running different configurations don't overrite one another
  (set! worker-cache-dir (new Directory (tokenise-filename (string-append cache kernel-destination))))
  (set! worker-evaluation-dir (new-directory~ worker-cache-dir "evaluate"))
  (set! worker-evaluation-file (new-file~ worker-evaluation-dir "evaluate.jazz"))
  (set! worker-debug? debug?)
  (create-directories~ worker-cache-dir)
  (create-directories~ worker-evaluation-dir)
  (cleanup-evaluation-cache))


(definition (cleanup-evaluation-cache)
  (when (exists?~ worker-evaluation-dir)
    (empty-directory~ worker-evaluation-dir)))


(definition (lookup-compilation-cache kind path)
  #f
  ;(write-result 'load object-path)
  ;#t
  )


(definition (process-work port feedback hide)
  (declare (proper-tail-calls))
  (let ((port (open-tcp-client (string->number port))))
    (let (iter)
      (let ((form (read-binary port)))
        (if (or (eof-object? form)
                (null? form))
            (begin
              (close-port port)
              (exit))
          (bind (command . rest) form
            (if (eq? command 'setup)
                (bind (cache debug?) rest
                  (setup-worker cache debug?))
              (bind (command mode feedback? . arguments) form
                (define (process-unit unit-name)
                  (case mode
                    ((interpret)
                     (write-result 'eval (expand-unit unit-name)))
                    ((compile)
                     (let ((output-dir (new-directory~ worker-cache-dir (cons "unit" (map symbol->string (butlast (split-identifier unit-name)))))))
                       (create-directories~ output-dir)
                       (let ((resource (find-unit-src unit-name #f)))
                         (let ((path (resource-pathname resource)))
                           (unless (lookup-compilation-cache 'unit path)
                             (when feedback?
                               (feedback (format "Compiling {a}..." unit-name)))
                             (expanding-unit unit-name
                               (lambda ()
                                 (with-resource-reader resource
                                   (lambda ()
                                     (let ((object-path (compile-file path options: compile-options output: (parse~ output-dir))))
                                       (write-result 'load object-path)))))))))))))
                
                (define (process-script path name)
                  ;; a name is needed to cache the compilation
                  (let ((effective-mode (if (not name) 'interpret mode)))
                    (case effective-mode
                      ((interpret)
                       (write-result 'eval (expand-script path)))
                      ((compile)
                       (let ((output-dir (new-directory~ worker-cache-dir (cons "script" (butlast name)))))
                         (create-directories~ output-dir)
                         (unless (lookup-compilation-cache 'script name)
                           (let ((name (join name "/")))
                             (when feedback?
                               (feedback (format "Compiling {a}..." (extract-base (join name "/")))))
                             (expanding-script path
                               (lambda ()
                                 (with-extension-reader (extract-extension name)
                                   (lambda ()
                                     (let ((object-path (compile-file path options: compile-options output: (parse~ output-dir))))
                                       (write-result 'load object-path)))))))))))))
                
                (define (process-evaluate syntax str container line col evaluation-mode)
                  (case mode
                    ((interpret)
                     (write-result 'eval (evaluate-forms syntax str container line col 'interpret evaluate?: #f)))
                    ((compile)
                     (when feedback?
                       (feedback "Compiling evaluation..."))
                     (write-result 'load (evaluate-forms syntax str container line col 'compile file: worker-evaluation-file evaluate?: #f)))))
                
                (define (process-console unit-name expr)
                  (let ((module-declaration (outline-unit unit-name)))
                    (let ((form `(module ,unit-name ,(get-dialect-name~ module-declaration) ,expr)))
                      (load-unit 'dialect.development)
                      (write-result 'eval (expand-form form unit-name: unit-name walk-for: 'eval)))))
                
                (define (write-result what result)
                  (write-binary-content port (list what result #f) marshall))
                
                (define (with-walk-problems thunk)
                  (if worker-debug?
                      (thunk)
                    (with-exception-catcher
                      (lambda (exc)
                        (write-binary-content port (list 'error (exception-reason exc) #f) marshall))
                      (lambda ()
                        (catch (Walk-Problems exc
                                 (write-binary-content port (list 'walk (exception-reason exc) (exception-detail exc)) marshall))
                          (thunk))))))
                
                (case command
                  ((unit)
                   (with-walk-problems
                     (lambda ()
                       (apply process-unit arguments))))
                  ((script)
                   (with-walk-problems
                     (lambda ()
                       (apply process-script arguments))))
                  ((evaluate)
                   (with-walk-problems
                     (lambda ()
                       (apply process-evaluate arguments))))
                  ((console)
                   (with-walk-problems
                     (lambda ()
                       (apply process-console arguments))))
                  ((hide)
                   (hide))
                  (else
                   (error "Unknown worker command" command))))))
          (iter)))))))
