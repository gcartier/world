;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Worker
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.worker jazz


(require (dialect.development))

(import (jazz.evaluate)
        (jazz.io)
        (jazz.library)
        (jazz.system))


(definition protected (start-worker-thread port feedback hide)
  (thread-start!
    (new-thread
      (lambda ()
        (process-work port feedback hide))
      'worker)))


(definition worker-cache-dir
  #f)

(definition worker-evaluation-dir
  #f)

(definition worker-evaluation-file
  #f)

(definition worker-debug?
  #f)


(definition (setup-worker cache debug?)
  ;; append the kernel destination so running different configurations don't overrite one another
  (set! worker-cache-dir (new Directory (tokenise-filename (string-append cache kernel-destination))))
  (set! worker-evaluation-dir (new-directory~ worker-cache-dir "evaluate"))
  (set! worker-evaluation-file (new-file~ worker-evaluation-dir "evaluate.jazz"))
  (set! worker-debug? debug?)
  (create-directories~ worker-cache-dir)
  (create-directories~ worker-evaluation-dir)
  (cleanup-evaluation-cache))


(definition (cleanup-evaluation-cache)
  (when (exists?~ worker-evaluation-dir)
    (empty-directory~ worker-evaluation-dir)))


(definition (load-digests output-dir base)
  (let ((dgs (new-file~ output-dir (add-extension base "dgs")))
        (digests (make-table test: eq?)))
    (when (exists?~ dgs)
      (call-with-input-file (path-settings dgs)
        (lambda (port)
          (let ((form (read port)))
            (assert (and (pair? form) (eq? (car form) 'digests))
              (for-each (lambda (info)
                          (bind (kind hash time) info
                            (table-set! digests kind (new File-Digest hash time))))
                        (cdr form)))))))
    digests))


(definition (lookup/update-digests digests kind src)
  (let ((old-digest (table-ref digests kind #f)))
    (let ((new-digest (file-digest (new File src) old-digest)))
      (table-set! digests kind new-digest)
      (eq? new-digest old-digest))))


(definition (save-digests digests output-dir base)
  (let ((dgs (new-file~ output-dir (add-extension base "dgs"))))
    (call-with-output-file (path-settings dgs)
      (lambda (port)
        (display "(digests" port)
        (newline port)
        (iterate-table digests
          (lambda (kind digest)
            (let ((hash (get-hash~ digest))
                  (time (get-time~ digest)))
              (newline port)
              (display "  " port)
              (write (list kind hash time) port))))
        (display ")" port)
        (newline port)))))


(definition (process-work port feedback hide)
  (declare (proper-tail-calls))
  (let ((port (open-tcp-client (string->number port))))
    (let (iter)
      (let ((form (read-binary port)))
        (if (or (eof-object? form)
                (null? form))
            (begin
              (close-port port)
              (exit))
          (bind (command . rest) form
            (if (eq? command 'setup)
                (bind (cache debug?) rest
                  (setup-worker cache debug?))
              (bind (command mode feedback? . arguments) form
                (define (process-unit unit-name)
                  (case mode
                    ((interpret)
                     (write-result 'eval (expand-unit unit-name)))
                    ((compile)
                     (let ((splitted (split-identifier unit-name)))
                       (let ((output-dir (new-directory~ worker-cache-dir (cons "unit" (map symbol->string (butlast splitted)))))
                             (base (symbol->string (last splitted))))
                         (create-directories~ output-dir)
                         (let ((resource (find-unit-src unit-name #f)))
                           (let ((path (resource-pathname resource)))
                             (define (compile-unit)
                               (when feedback?
                                 (feedback (format "Compiling {a}..." unit-name)))
                               (expanding-unit unit-name
                                 (lambda ()
                                   (with-resource-reader resource
                                     (lambda ()
                                       (compile-file path options: compile-options output: (parse~ output-dir)))))))
                             
                             (let ((digests (load-digests output-dir base)))
                               (if (lookup/update-digests digests 'compile path)
                                   (write-result 'load (parse~ (new-file~ output-dir base)))
                                 (let ((object-path (compile-unit)))
                                   (save-digests digests output-dir base)
                                   (write-result 'load object-path)))))))))))
                
                ;; because gambit doesn't support loading the same object file twice, it would be
                ;; very tricky to cache script compilation as scripts are meant to be ran over and over.
                ;; in fact this is probably a good thing giving the user the freedom to choose between
                ;; scripts that stay interpreted and load fast, and modules that get cache compiled
                (define (process-script path)
                  (write-result 'eval (expand-script path)))
                
                (define (process-evaluate syntax str container line col evaluation-mode)
                  (case mode
                    ((interpret)
                     (write-result 'eval (evaluate-forms syntax str container line col 'interpret evaluate?: #f)))
                    ((compile)
                     (when feedback?
                       (feedback "Compiling evaluation..."))
                     (write-result 'load (evaluate-forms syntax str container line col 'compile file: worker-evaluation-file evaluate?: #f)))))
                
                (define (process-console unit-name expr)
                  (let ((module-declaration (outline-unit unit-name)))
                    (let ((form `(module ,unit-name ,(get-dialect-name~ module-declaration) ,expr)))
                      (load-unit 'dialect.development)
                      (write-result 'eval (expand-form form unit-name: unit-name walk-for: 'eval)))))
                
                (define (write-result what result)
                  (write-binary-content port (list what result #f) marshall))
                
                (define (with-walk-problems thunk)
                  (if worker-debug?
                      (thunk)
                    (with-exception-catcher
                      (lambda (exc)
                        (write-binary-content port (list 'error (exception-reason exc) #f) marshall))
                      (lambda ()
                        (catch (Walk-Problems exc
                                 (write-binary-content port (list 'walk (exception-reason exc) (exception-detail exc)) marshall))
                          (thunk))))))
                
                (case command
                  ((unit)
                   (with-walk-problems
                     (lambda ()
                       (apply process-unit arguments))))
                  ((script)
                   (with-walk-problems
                     (lambda ()
                       (apply process-script arguments))))
                  ((evaluate)
                   (with-walk-problems
                     (lambda ()
                       (apply process-evaluate arguments))))
                  ((console)
                   (with-walk-problems
                     (lambda ()
                       (apply process-console arguments))))
                  ((hide)
                   (hide))
                  (else
                   (error "Unknown worker command" command))))))
          (iter)))))))
