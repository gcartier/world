;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Spawn
;;;
;;;  The Initial Developer of the Original Code is Edouard Hebert.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.spawn jazz


(import (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.enemy)
        (world.flow)
        (world.geometry)
        (world.history)
        (world.generation)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task))


(definition spawn-enemies?      <bool> (world-setting 'world.spawn-enemies? #t))
(definition spawn-initial-delay <pair> (world-setting 'world.spawn-initial-delay '(5. 20.)))
(definition spawn-delay         <pair> (world-setting 'world.spawn-delay '(10. 40.)))
(definition spawn-minimum       <fx>   (world-setting 'world.spawn-minimum 2))
(definition spawn-maximum       <fx>   (world-setting 'world.spawn-maximum 4))

;; be very conservative until enemy task is fully optimized and adaptive to not starve other tasks
(definition max-spawner-enemies <fx>   (world-setting 'world.max-spawner-enemies 4)) ;; 10
(definition max-enemies         <fx>   (world-setting 'world.max-enemies 10)) ;; 40initialize 


(definition protected spawned-count   0)
(definition protected spawned-enemies '())
(definition protected spawner-list    '())
(definition protected spawner-added?  #f)

(definition protected (set-spawned-count count)
  (set! spawned-count count))

(definition protected (set-spawned-enemies enemies)
  (set! spawned-enemies enemies))

(definition protected (set-spawner-added? added?)
  (set! spawner-added? added?))


(definition protected (initialize-spawned)
  (set! spawned-count 0)
  (set! spawned-enemies '())
  (set! spawner-list '()))


(definition (sorted-spawned-enemies)
  (let ((me (current-me)))
    (let ((pos (get-position~ me)))
      (sort > spawned-enemies key: (lambda (enemy)
                                     (vertex-distance (get-position~ enemy) pos))))))


(definition public (spawn-task task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone))
        (me (current-me))
        (history (current-history)))
    (with-task task
      (lambda (exit)
        (let ((sector #f))
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds)))
              (let ((elapse (- time previous)))
                (unless (get-paused?~ history)
                  (with-task-mutex
                    (lambda ()
                      (unless (stopping?~ task)
                        (trace-task spawn "W")
                        (let ((current-sector (element-sector~ zone me)))
                          (let ((current-spawners (if (and (eq? sector current-sector)
                                                           (not spawner-added?))
                                                      spawner-list
                                                    (find-spawners current-sector spawner-list))))
                            (set! sector current-sector)
                            (set! spawner-list current-spawners)
                            (set! spawner-added? #f)
                            (tick-spawn elapse current-spawners)))))))
                (let ((duration (- (current-seconds) time)))
                  (task-sleep task spawn-period duration exit))
                (iter time)))))))))


(definition (tick-spawn elapse spawners)
  (site (spawn on?: #t)
    (when spawn-enemies?
      (spawn-enemies elapse spawners))))


(definition (find-spawners sector old-spawners)
  (let ((zone (current-zone))
        (queue (new-queue)))
    (iterate-sector-neighbors~ zone sector 1
      (lambda (sector)
        (sector-iterate-blocks~ zone sector '(52)
          (lambda (index)
            ;; spawn faster the first time to compensate for not having natural spawning
            (let ((coords (index->coordinates index)))
              (let ((spawner (find-object (lambda (spawner)
                                            (when (and (eq? (get-sector~ spawner) sector)
                                                       (equal? (get-coordinates~ spawner) coords))
                                              spawner))
                                          old-spawners)))
                (if spawner
                    (enqueue queue spawner)
                  (enqueue queue (new Spawner sector coords 0. (random-between (first spawn-initial-delay) (second spawn-initial-delay)) 0 (sector/index->position sector index))))))))))
    (queue-list queue)))


(definition (spawn-enemies elapse spawners)
  (let ((world (current-world))
        (zone (current-zone)))
    (for-each (lambda (spawner)
                (let ((sector (get-sector~ spawner))
                      (time-since-last (get-time-since-last~ spawner))
                      (time-for-spawn (get-time-for-spawn~ spawner))
                      (enemy-count (get-enemy-count~ spawner))
                      (coordinates (get-coordinates~ spawner)))
                  (bind (i j k) coordinates
                    (call-with-sector~ zone sector i j k
                      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                        (define (find-spawning-places needed)
                          (define (random-x)
                            (random-element '(-1 1)))
                          
                          (define (random-y)
                            (random-element '(-1 0 1)))
                          
                          (let ((places '())
                                (a 0)
                                (b 0)
                                (c 0))
                            (set! needed (* needed 4))
                            (let (iter-distance (dist 1))
                              (let (iter-circle (max-places (max 2 (/ needed 2))))
                                (set! a (* dist (if (= dist 1) (random-y) (random-x))))
                                (set! b (* dist (random-y)))
                                (set! c (* dist (if (= dist 1) (random-y) (random-x))))
                                (with-field (+ i a) (+ j b) (+ k c)
                                  (lambda (section index)
                                    (when (and section (= (block-ref section index) 0))
                                      (decrease! needed)
                                      (decrease! max-places)
                                      (set! places (cons (cons (section/index->position section index) (blocklight-ref section index)) places)) ;; maybe include skylight
                                      (cond ((> max-places 0)
                                             (iter-circle max-places))
                                            ((and (< dist 4) (= max-places 0) (> needed 0))
                                             (iter-distance (+ dist 1)))
                                            (else
                                             #f)))))))
                            places))
                        
                        (let ((time-now (+ time-since-last elapse)))
                          (if (and (> time-now time-for-spawn))
                              (let ((spawn-count spawn-maximum))
                                (let ((sorted-enemies (and (> (+ spawned-count spawn-count) max-enemies) (sorted-spawned-enemies)))
                                      (possible-spawn-places (find-spawning-places spawn-count)))
                                  (loop (for number from 0 below spawn-count)
                                        (unless (or (null? possible-spawn-places) (>= enemy-count max-spawner-enemies))
                                          (let ((position (random-element possible-spawn-places)))
                                            (when (< (cdr position) 8)
                                              (set! possible-spawn-places (remove position possible-spawn-places test: equal?))
                                              (let ((enemy (new (random-element (list Spider Wolf Jumper)) parent: world position: (car position) animate?: #t)))
                                                (set-spawner-position~ enemy (vertex x y z))
                                                (add-element~ zone enemy)
                                                (add-enemy~ zone enemy)
                                                (increase! enemy-count 1))
                                              (when (and (> spawned-count max-enemies) (not-null? sorted-enemies))
                                                (let ((enemy (car sorted-enemies)))
                                                  (remove-enemy~ zone enemy)
                                                  (remove-element~ zone enemy)
                                                  (set! sorted-enemies (cdr sorted-enemies))))))))
                                  (set-time-since-last~ spawner 0.)
                                  (set-time-for-spawn~ spawner (random-between (first spawn-delay) (second spawn-delay)))
                                  (set-enemy-count~ spawner enemy-count)))
                            (set-time-since-last~ spawner time-now))))))))
              spawners))))
