;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Scripter
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.scripter jazz


(import (jazz.component)
        (jazz.event)
        (world)
        (world.autoload)
        (world.console)
        (world.context)
        (world.scriptum)
        (world.settings)
        (world.task)
        (world.work))


;;;
;;;; Script
;;;


(class Script extends Component
  
  
  (property text <object> initialize #f getter generate setter explicit)
  
  
  (slot kind         <object> initialize #f accessors generate)
  (slot module       <object> initialize #f accessors generate)
  (slot state        <object> initialize #f accessors generate)
  (slot state-time   <object> initialize #f accessors generate)
  (slot reason       <object> initialize #f accessors generate)
  (slot detail       <object> initialize #f accessors generate)
  (slot stack        <object> initialize #f accessors generate)
  (slot tick         <object> initialize #f accessors generate)
  (slot interact     <object> initialize #f accessors generate)
  (slot double-click <object> initialize #f accessors generate)
  (slot power        <object> initialize #f accessors generate)
  (slot unpower      <object> initialize #f accessors generate)
  (slot teleport     <object> initialize #f accessors generate)
  (slot explode      <object> initialize #f accessors generate)
  (slot hit          <object> initialize #f accessors generate)
  (slot trail?       <bool>   initialize #f accessors generate)
  (slot trail        <object> initialize #f accessors generate)
  (slot trail-color  <object> initialize #f accessors generate)
  (slot indicators   <object> initialize #f accessors generate)
  
  
  (method public (set-text self text)
    (set! self.text text)
    (set! self.kind (and text (if (starts-with? text ";;; -*- ")
                                  'client
                                'server))))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        )))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method package (make-state-entity self)
    (new Script-State
      state: state
      model: (case state
               ((read) "warcraft/base/talktomeexclamation")
               ((walk) "warcraft/base/talktomeexclamation")
               ((error) "warcraft/base/talktomeexclamationred")
               (else "warcraft/base/talktomeexclamationgreen"))
      animation: "Idle"))
  
  
  ;;;
  ;;;; Event
  ;;;
  
  
  (method package (enqueue-event self event)
    (let ((entity parent))
      (thread-send (get-thread (get-task entity))
        (lambda (exit)
          (handle-one-event entity (get-script entity) event)))))
  
  
  (method package (dequeue-event self)
    (thread-receive 0 #f))
  
  
  (method package (wait-event self)
    (thread-receive))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  (method package (run-script self task exit)
    (define (determine-module)
      ;; for the moment always generating a new module is by far the most robust
      ;; way of ensuring any changes to the imports are resolved correctly and it
      ;; might also uncover some weird module persistent data usage...
      (gensym 'script)
      #;
        (or module
            (let ((mod (gensym 'script)))
              (set! module mod)
              mod)))
    
    (define (extract-header)
      (let ((prefix ";;; -*- "))
        (and (starts-with? text prefix)
             (let ((content (call-with-input-string text read-line)))
               (let ((header (substring content (string-length prefix) (string-length content))))
                 (call-with-input-string header
                   (lambda (port)
                     (catch-exception-filter
                       (lambda (exc)
                         (datum-parsing-exception? exc))
                       (lambda (exc)
                         #f)
                       (lambda ()
                         (read-all port))))))))))
    
    (define (extract-dialect header)
      (let ((explicit (and header (even? (length header)) (getf header dialect:))))
        (if explicit
            (if (symbol? explicit)
                `(dialect ,explicit)
              `(dialect ,@explicit))
          'script)))
    
    (define (script-code module dialect)
      (string-append "(module " (symbol->string module) " " (->string dialect) "\n" text "\n)"))
    
    (if (or (not text) (not (scripting-available?)))
        (begin
          (set-task parent #f)
          (continuation-return exit #f))
      (let ((module (determine-module))
            (header (extract-header)))
        (let ((code (script-code module (extract-dialect header)))
              (instance parent))
          (define (state-change state data)
            (case kind
              ((client)
               (update-state self instance state data))
              ((server)
               (with-task-mutex
                 (lambda ()
                   (world.changes:state-script-change (current-seconds) instance state data))))
              ;((remote)
              ; (state-return parent state data))
              ))
          
          (continuation-capture
            (lambda (exit)
              (parameterize ((%%current-instance instance)
                             (current-task task)
                             (current-exit exit))
                (worker-run instance code
                  ;; read
                  (lambda (data)
                    (state-change 'read data)
                    (running-handler self
                      (lambda ()
                        (handle-events parent))))
                  ;; walk
                  (lambda (data)
                    (state-change 'walk data)
                    (running-handler self
                      (lambda ()
                        (handle-events parent))))
                  ;; error
                  (lambda (data)
                    (state-change 'error data)
                    (running-handler self
                      (lambda ()
                        (handle-events parent))))
                  ;; run
                  (lambda ()
                    (state-change 'run #f))
                  ;; result
                  (lambda (result)
                    (define (package-result)
                      (cond ((unspecified? result)
                             '())
                            ((values? result)
                             (map ->string (values->list result)))
                            (else
                             (list (->string result)))))
                    
                    (state-change 'result (package-result)))))))))))


  (method package (running-handler self thunk)
    (declare (proper-tail-calls))
    (if (world-setting 'world.debug-scripts? bot?)
        (thunk)
      (continuation-capture
        (lambda (exit)
          (with-exception-handler
            (lambda (exc)
              (continuation-capture
                (lambda (cont)
                  (continuation-graft exit
                    (lambda ()
                      (update-error self parent (exception-reason exc) (exception-location exc cont) (continuation-stack cont))
                      (running-handler self
                        (lambda ()
                          (handle-events parent))))))))
            thunk)))))
  
  
  (method (update-run self instance)
    (when (neq? state 'run)
      (clear-indicators instance)
      (set-console-pane instance #f))
    (set-state self 'run)
    (set-state-time self (current-seconds))
    (set-reason self #f)
    (set-detail self #f)
    (set-stack self #f))
  
  
  (definition read-color 'Orange)
  (definition walk-color 'Orange)
  (definition error-color 'Red)
  
  
  (method (update-read self instance reason location)
    (update-error self instance reason location #f 'read))
  
  
  ;; some code copied from edit-stop/detail for now
  (method (update-walk self instance reason detail)
    (define (collect-details)
      (let ((queue (new-queue)))
        (define (collect detail)
          (let ((children (get-children detail)))
            (if (null? children)
                (enqueue queue detail)
              (for-each collect children))))
        
        (collect detail)
        (queue-list queue)))
    
    (define (detail-location detail)
      (let ((location (get-location detail)))
        (and location
             (if (pair? location)
                 location
               (let ((locat (get-locat location)))
                 (locat->container/line/col locat))))))
    
    (let ((details (collect-details)))
      (define (present-walk)
        `(<span>
           ,@(map (lambda (detail)
                    `(<paragraph> (<text> color: ,walk-color ,(get-title detail))))
                  details)))
      
      (set-state self 'walk)
      (set-state-time self (current-seconds))
      (set-reason self reason)
      (set-detail self detail)
      (set-stack self #f)
      (when (window?)
        ;; quick hack until solution to pure scripts
        (if (is? instance world.script.asset:Asset-Entity)
            (display-message (current-world) (let ((all (split-string reason #\newline)))
                                               (if (and (>= (length all) 3)
                                                        (equal? (car all) "Walk problems encountered"))
                                                   (subseq all 2 (length all))
                                                 all))
              duration: 60.)
          (set-console-pane instance (present-walk) size: 24)
          (clear-indicators instance)
          (update-script-walk instance (collect detail-location details))
          (delay-update-debugger self)))))
  
  
  (method (update-error self instance reason location stack (state 'error))
    (define (present-error)
      (let ((color (if (eq? state 'read) read-color error-color)))
        `(<span>
           ,@(let ((lst (split reason "\n")))
               (bind (header . rest) lst
                 (cons (let ((prefix "(Argument "))
                         (if (starts-with? header prefix)
                             (let ((pos (find header #\) start: (+ (string-length prefix) 1))))
                               ;; this test is a bit overboard
                               (if pos
                                   `(<paragraph> (<text> color: ,color ,(string-append (substring header 1 pos) "," (substring header (+ pos 1) (string-length header)))))
                                 `(<paragraph> (<text> color: ,color ,header))))
                           `(<paragraph> (<text> color: ,color ,header))))
                       (map (lambda (str)
                              `(<paragraph> (<text> color: ,color ,str)))
                            rest)))))))
    
    (set-state self state)
    (set-state-time self (current-seconds))
    (set-reason self reason)
    (set-detail self #f)
    (set-stack self stack)
    (when (window?)
      ;; quick hack until solution to pure scripts
      (if (is? instance world.script.asset:Asset-Entity)
          (display-message (current-world)
                           (split-string reason #\newline)
            duration: 60.)
        (set-console-pane instance (present-error) size: 24)
        (clear-indicators instance)
        (update-script-error instance location state)
        (delay-update-debugger self))))
  
  
  (method (update-result self instance result)
    (define (present-result)
      `(<span>
         ,@result))
    
    ;; quick hack until solution to pure scripts
    (unless (is? instance world.script.asset:Asset-Entity)
      (unless (null? result)
        (set-console-pane instance (present-result)))))
  
  
  (method package (update-state self instance state data)
    (case state
      ((run)
       (update-run self instance))
      ((read)
       (bind (reason location) data
         (update-read self instance reason location)))
      ((walk)
       (bind (reason detail) data
         (update-walk self instance reason detail)))
      ((error)
       (bind (reason location stack) data
         (update-error self instance reason location stack)))
      ((result)
       (let ((result data))
         (update-result self instance result)))))
  
  
  (method (delay-update-debugger self)
    (delay-event
      (lambda ()
        (world.interface.script:update-debugger-panel parent))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method package (evaluate-script self instance (evaluate-run?: evaluate-run? #f))
    (let ((task (get-task instance)))
      (continuation-graft pristine-thread-continuation
        (lambda ()
          (parameterize ((run? evaluate-run?))
            (task-run instance task self))))))
  
  
  ;;;
  ;;;; Trail
  ;;;
  
  
  ;; quicky
  (method (clear-trail self)
    (set! trail (new-queue))))


;;;
;;;; Script-State
;;;


(class Script-State extends Entity
  
  
  (property state initialize #f accessors generate)))
