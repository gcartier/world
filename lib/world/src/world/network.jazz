;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Networking
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.network jazz


(import (jazz.math)
        (jazz.syntax (phase syntax))
        (world)
        (world.configure)
        (world.context)
        (world.support)
        (world.task))


(proclaim (not check bounds)
          (warn optimizations))


;;;
;;;; Task
;;;


(definition public (network-task task <Task>)
  (declare (proper-tail-calls))
  (with-task task
    (lambda (exit)
      (let ((period (if (processing?) server-period client-period)))
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site (network)
                  (cond ((client?)
                         (send-update))
                        ((processing?)
                         (broadcast-update)))))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task period duration exit))
              (iter time))))))))


(definition public (alive-task task <Task>)
  (declare (proper-tail-calls))
  (with-task task
    (lambda (exit)
      (let (iter (previous (current-monotonic)))
        (let ((time (current-monotonic)))
          (let ((elapse (- time previous)))
            (unless (stopping? task)
              (site (alive)
                (let ((client (current-client)))
                  (send-client-alive client)
                  (let ((udp-client (get-udp-client client)))
                    (when udp-client
                      (send-alive udp-client))))))
            (let ((duration (- (current-monotonic) time)))
              (task-wait task alive-period duration exit))
            (iter time)))))))


;;;
;;;; Outgoing
;;;


(definition protected outgoing-mutex
  (make-mutex 'outgoing))

(definition protected (with-outgoing-mutex thunk)
  (mutex-lock! outgoing-mutex)
  (prog1 (thunk)
    (mutex-unlock! outgoing-mutex)))


(definition protected outgoing-max <fx>
  1024)

(definition protected outgoing-changes <f64vector>
  (make-f64vector outgoing-max))

(definition protected outgoing-size <fx>
  0)


(definition (maybe-grow-outgoing new-size <fx>)
  (define (grow vect <f64vector> old-reserved <fx> new-reserved <fx>) <f64vector>
    (let ((new-vect (make-f64vector new-reserved)))
      (subf64vector-move! vect 0 old-reserved new-vect 0)
      new-vect))
  
  (when (> new-size outgoing-max)
    (let ((new-reserved (fxround (* (cast <fl> new-size) GOLDEN-RATIO))))
      (set! outgoing-changes (grow outgoing-changes outgoing-size new-reserved))
      (set! outgoing-max new-reserved))))


;;;
;;;; Client
;;;


(definition protected (outgoing-push val <fl>)
  (let ((new-size (+ outgoing-size 1)))
    (maybe-grow-outgoing new-size)
    (f64vector-set! outgoing-changes outgoing-size val)
    (set! outgoing-size new-size)))


(definition protected (send-update)
  (mutex-lock! outgoing-mutex)
  (when (> outgoing-size 0)
    ;; quick first draft to optimize
    (let ((changes (make-f64vector outgoing-size)))
      (subf64vector-move! outgoing-changes 0 outgoing-size changes 0)
      (send-client-update (current-client) changes)
      (set! outgoing-size 0)))
  (mutex-unlock! outgoing-mutex))


;;;
;;;; Server
;;;


(definition protected (push-client-changes changes <f64vector>)
  (let ((len (f64vector-length changes)))
    (let ((new-size (+ outgoing-size len)))
      (maybe-grow-outgoing new-size)
      (subf64vector-move! changes 0 len outgoing-changes outgoing-size)
      (set! outgoing-size new-size))))


;; debug sequence
(definition protected last-broadcast <fx>
  -1)

(definition protected (reset-last-broadcast)
  (set! last-broadcast -1))


(definition protected (broadcast-update)
  (mutex-lock! outgoing-mutex)
  (when (> outgoing-size 0)
    ;; quick first draft to optimize
    (let ((changes (make-f64vector outgoing-size)))
      (subf64vector-move! outgoing-changes 0 outgoing-size changes 0)
      (when debug-sequence?
        (world.change:show-changes changes)
        (world.change:iterate-changes changes
          (lambda (change offset)
            (let ((sequence-no (flonum->fixnum (f64vector-ref changes (+ offset 5)))))
              (let ((last-no last-broadcast))
                (when (<= sequence-no last-no)
                  (terminal 'out-of-sequence (current-thread) sequence-no 'with last-no)
                  (break)))
              (set! last-broadcast sequence-no)))))
      (broadcast-processor-update (current-tier) changes)
      (set! outgoing-size 0)))
  (mutex-unlock! outgoing-mutex)))
