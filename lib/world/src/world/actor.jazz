;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Actors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.actor jazz


(import (jazz.geometry)
        (jazz.syntax (phase syntax))
        (world)
        (world.animation)
        (world.area)
        (world.audio)
        (world.autoload)
        (world.change)
        (world.changes)
        (world.collision)
        (world.commands)
        (world.dye)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.mark)
        (world.motion)
        (world.queue)
        (world.scripter)
        (world.scripting)
        (world.settings)
        (world.spell)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.work))


;;;
;;;; Actor
;;;


(definition *global-cooldown*
  0.5)

(definition protected max-fall-speed <fl>
  1.25)

(definition protected die-bottom <fl>
  -180.)

(definition protected water-slowdown <fl>
  0.75)


(definition default-walk-speed
  3.)

(definition default-run-speed
  6.)


(definition sprint-speed <fl>
  (world-setting 'world.sprint-speed 5.))

(definition blink-speed <fl>
  (world-setting 'world.blink-speed 5.))

(definition sprint-jump <fl>
  (world-setting 'world.sprint-jump 2.))

(definition blink-jump <fl>
  (world-setting 'world.blink-jump 1.5))


(definition protected base-armor <fl>
  (world-setting 'world.base-armor 20.))

(definition protected base-power <fl>
  (world-setting 'world.base-power 10.))

(definition protected base-ranged-power <fl>
  (world-setting 'world.base-ranged-power 10.))


(class Actor extends Entity implements Scriptable
  
  
  (slot velocity                <f64vector>  initialize (make-zero-vertex) getter generate)
  (slot fall-velocity           <f64vector>  initialize (make-zero-vertex) getter generate)
  (slot effective-velocity      <f64vector>  initialize (make-zero-vertex) getter generate)
  (slot velocity-angle          <fl>         initialize 0.                 getter generate)
  (slot motion                  <symbol>     initialize 'walk              accessors generate)
  (slot life                    <fl>         initialize 100.               accessors generate)
  (slot alive?                  <bool>       initialize #t                 accessors generate)
  (slot global-cooldown         <fl>         initialize 0.                 accessors generate)
  (slot spell                   <Spell+>     initialize #f                 accessors generate)
  (slot adjustments             <list>       initialize '()                accessors generate)
  (slot rapid-fire-acceleration <fl>         initialize 1.                 accessors generate)
  (slot rapid-fire-duration     <fl>         initialize 0.                 accessors generate)
  (slot rapid-fire-cooldown     <fl>         initialize 0.                 accessors generate)
  (slot last-missile            <fl+>        initialize #f                 accessors generate)
  (slot max-missiles            <fx>         initialize 10                 accessors generate)
  (slot missiles-count          <fx>         initialize 0                  accessors generate)
  (slot history-color           <object>     initialize #f                 accessors generate)
  (slot jumping?                <bool>       initialize #f                 accessors generate)
  (slot jump-ready?             <bool>       initialize #f                 accessors generate)
  (slot jump-grace?             <bool>       initialize #f                 accessors generate)
  (slot jump-time               <fl>         initialize 0.                 accessors generate)
  (slot ground?                 <bool>       initialize #f                 accessors generate)
  (slot hover?                  <bool>       initialize #f                 accessors generate)
  (slot water?                  <bool>       initialize #f                 accessors generate)
  (slot water-collision?        <bool>       initialize #f                 accessors generate)
  (slot shallow-water?          <bool>       initialize #f                 accessors generate)
  (slot lava?                   <bool>       initialize #f                 accessors generate)
  (slot swim-timer              <fl>         initialize 0.                 accessors generate)
  (slot water-jump?             <bool>       initialize #f                 accessors generate)
  (slot ladder?                 <bool>       initialize #f                 accessors generate)
  (slot ladder-shaft            <f64vector+> initialize #f                 accessors generate)
  (slot pressure-plates         <list>       initialize '()                accessors generate)
  (slot rail-dir                <list+>      initialize #f                 accessors generate)
  (slot last-turn               <f64vector+> initialize #f                 accessors generate)
  (slot last-step               <fl>         initialize 0.                 accessors generate)
  (slot rotation                <fl>         initialize 0.                 accessors generate)
  (slot orientation             <object>     initialize 'vertical          accessors generate)
  (slot dash                    <fl>         initialize 1.                 accessors generate)
  (slot dash-duration           <fl>         initialize 0.                 accessors generate)
  (slot jump?                   <bool>       initialize #f                 accessors generate)
  (slot jump-impulsion          <object>     initialize #f                 accessors generate)
  (slot animation-active        <object>     initialize #f                 accessors generate)
  (slot animation-speed         <fl+>        initialize #f                 accessors generate)
  (slot animation-fall          <object>     initialize #f                 accessors generate)
  (slot animation-once          <bool>       initialize #f                 accessors generate)
  (slot animation-continuous    <bool>       initialize #f                 accessors generate)
  (slot armor                   <fl>         initialize base-armor         accessors generate)
  (slot armor-factor            <fl>         initialize 1.                 accessors generate)
  (slot power                   <fl>         initialize base-power         accessors generate)
  (slot power-factor            <fl>         initialize 1.                 accessors generate)
  (slot ranged-power            <fl>         initialize base-ranged-power  accessors generate)
  (slot ranged-power-factor     <fl>         initialize 1.                 accessors generate)
  (slot area-cube               <object>     initialize #f                 accessors generate)
  
  
  (method override (finish rest)
    (nextmethod rest)
    (let ((color (copy-dye color)))
      (dye-alpha-set! color .2)
      (set! history-color color))
    (setup-area-cube))
  
  
  (method protected virtual (setup-area-cube)
    (set! area-cube (new Area-Cube 2)))
  
  
  (method (update-area-cube)
    (get-areas~ area-cube position)
    area-cube)
  
  
  (method public inline (set-velocity vel <f64vector>) <void>
    (vertex-copy! velocity vel))
  
  
  (method public inline (set-fall-velocity vel <f64vector>) <void>
    (vertex-copy! fall-velocity vel))
  
  
  (method public inline (set-effective-velocity vel <f64vector>) <void>
    (vertex-copy! effective-velocity vel))
  
  
  (method override (call-model-update model)
    (nextmethod model)
    (set! animation-active #f)
    (set! animation-speed #f)
    (set! animation-fall #f)
    (set! animation-once #f)
    (set! animation-continuous #f))
  
  
  (method (setup-armor value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.5)
            (max-armor 500.))
        (+ min-factor (* (/ value max-armor) (- max-factor min-factor)))))
    
    (set! armor value)
    (set! armor-factor (calculate-factor)))
  
  
  (method (setup-power value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.5)
            (max-power 160.))
        (+ min-factor (* (/ value max-power) (- max-factor min-factor)))))
    
    (set! power value)
    (set! power-factor (calculate-factor)))
  
  
  (method (setup-ranged-power value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.)
            (max-power 120.))
        (+ min-factor (* (/ value max-power) (- max-factor min-factor)))))
    
    (set! ranged-power value)
    (set! ranged-power-factor (calculate-factor)))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (definition missile-delay <fl>
    .1)

  
  ;(method (maybe-add-action name arguments)
  ;  (if (<= global-cooldown 0.)
  ;      (add-action~ commands name (arguments))
  ;    (set! global-cooldown (- global-cooldown 0.))))
  
  
  (method (maybe-fire commands kind)
    (let ((seconds (current-seconds)))
      (when (or (not last-missile)
                (> (- seconds last-missile) (/ missile-delay rapid-fire-acceleration)))
        (fire commands kind)
        (set! last-missile seconds))))
  
  
  (method (fire commands kind)
    (let ((direction (aim-direction)))
      (add-action~ commands 'fire (list direction kind))))
  
  
  (method (fire-missile direction kind)
    (let ((interface (current-interface))
          (world (current-world))
          (zone (current-zone)))
      (let ((pane (child~ interface 'character)))
        (when (and (< missiles-count max-missiles)
                   (or (neq? kind 'arrow)
                       (> (count-arrows~ pane) 0)))
          (when (eq? kind 'arrow)
            (use-arrow~ pane))
          (let ((lens (lens-center))
                (adjusted-radius (* (get-radius-x) 2.)))
            (let ((pos (vertex+& lens (vertex-scalar*& direction adjusted-radius))))
              (let ((missile (new (missile-class~ world) parent: zone position: pos actor: self kind: kind)))
                (increase-missiles)
                (set-velocity~ missile (vertex-scalar*& direction (missile-speed~ missile)))
                (add-element~ zone missile))))
          (attack kind)))))
  
  
  (method override (lens-center)
    (let ((model (cache-model)))
      (let ((center (get-center~ model))
            (bounds (get-bounds~ model))
            (eye-level (if (eq? (get-name~ model) 'Orb)
                           .15
                         ;; why is the division necessary?
                         (/ (or (get-lens~ model) .8) 2.))))
        ;; aec quicky
        (let ((model-lens (vertex 0. (+ (vertex-y center) (* (cuboid-height bounds) eye-level)) 0.)))
          (matrix-transform-3x4 matrix model-lens)))))
  
  
  (method (aim-direction)
    (let ((world (current-world)))
      (let ((eye (get-eye~ world)))
        (if (get-free-aim?~ world)
            (get-sight~ eye)
          (cross-normal (get-up~ eye) (get-right~ lookat))))))
  
  
  (method (start-rapid-fire)
    (set! rapid-fire-acceleration 3.)
    (set! rapid-fire-duration 15.)
    (set! rapid-fire-cooldown 45.))
  
  
  (method (warp-forward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) 2.)))
      (follow-player~ world)))
  
  
  (method (warp-backward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) -2.)))
      (follow-player~ world)))
  
  
  (method (start-dash)
    (let ((world (current-world)))
      (set! dash 5.)
      (set! dash-duration 10.)
      (update-parameter~ world 'dash)))
  
  
  (method public virtual (damage amount critical?)
    (play-3d-sound-if (if critical? (wound-critical-sound) (wound-sound)) position)
    @w
    (let ((animation (if critical? "CombatCritical" "CombatWound")))
      (when (find-animation~ (cache-model) animation)
        (set! animation-once animation)))
    (decrease! life amount)
    (when (<= life 0.)
      (die)))
  
  
  (method protected virtual (attacking?)
    #f)
  
  
  (method protected virtual (attack kind)
    )
  
  
  (method protected virtual (attack-amount factor amount)
    (* amount factor))
  
  
  (method public virtual (wound inflictor factor (amount #f))
    (let ((world (current-world)))
      (let ((critical? (> (random-real) .8)))
        (damage (if amount
                    amount
                  (attack-amount~ inflictor factor (wound-amount critical?)))
                (if amount #f critical?)))))
  
  
  (method public virtual (wound-amount critical?)
    (if critical? 20. 10.))
  
  
  (method public virtual (wound-sound)
    (find-sound 'wound))
  
  
  (method public virtual (wound-critical-sound)
    (find-sound 'wound-critical))
  
  
  (method public virtual (explode inflictor)
    (let ((zone (current-zone))
          (radius 2.))
      (play-3d-sound "sound/spells/ExplosiveShot" position)
      (for-each (lambda (actor)
                  (when (and (<= (vertex-distance& position (get-position~ actor)) radius)
                             (explosion-damage?~ actor))
                    (wound~ actor inflictor (get-ranged-power-factor~ inflictor))))
                (get-actors~ zone))))
  
  
  (method public virtual (explosion-damage?)
    #t)
  
  
  (method public virtual (die)
    (let ((world (current-world)))
      (play-3d-sound-if (death-sound) position)
      (remove-element~ world self)
      (set! alive? #f)))
  
  
  (method public virtual (death-sound)
    (find-sound 'death))
  
  
  (method public virtual (stomp)
    #f)
  
  
  (method protected virtual (get-friction)
    4.)
  
  
  (method protected (block-at-center)
    (let ((zone (current-zone)))
      (block-at~ zone (transformed-center))))
  
  
  (method protected (enter-water lava? (time 0.))
    (when (> (abs (vertex-y fall-velocity)) 1.)
      (play-3d-sound "sound/water/EnterWaterSmallA" position))
    (set! jumping? #f)
    (set! jump-time time)
    (set! water-jump? #f)
    (set! water? #t)
    (set-lava?~ self lava?))
  
  
  (method protected (exit-water (forced? #f))
    (set! swim-timer 0.)
    (set! shallow-water? #f)
    (set! water? #f)
    (set! lava? #f)
    (set! water-jump? (not forced?)))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  ;; (slot position           <f64vector>)    ;; position
  ;; (slot lookat             <LookAt>)       ;; lookat is always perpendicular to gravity
  ;; (slot scale              <f64vector>)    ;; scale
  ;; (slot matrix             <f64vector>)    ;; matrix
  ;; (slot radiuses           <f64vector+>)   ;; radiuses
  ;; (slot radius             <fl+>)          ;; radius
  ;; (slot velocity           <f64vector>)    ;; velocity
  ;; (slot fall-velocity      <f64vector>)    ;; fall-velocity
  ;; (slot effective-velocity <f64vector>)    ;; velocity + fall-velocity
  ;; (slot velocity-angle     <fl>)           ;; real displacement / elapse
  ;; (slot jumping?           <bool>)         ;; are we currently jumping
  ;; (slot jump-ready?        <bool>)         ;; so holding the jump key only jumps once
  ;; (slot jump-grace?        <bool>)         ;; a standing jump allows us one last move
  ;; (slot jump-time          <fl>)           ;; time of current jump
  ;; (slot ground?            <bool>)         ;; are we currently in contact with the ground
  ;; (slot hover?             <bool>)         ;; are we hovering over ground
  ;; (slot water?             <bool>)         ;; are we in a liquid environment
  ;; (slot water-collision?   <bool>)         ;; are we colliding with a liquid polygon
  ;; (slot shallow-water?     <bool>)         ;; are we in shallow water
  ;; (slot lava?              <bool>)         ;; are we in lava
  ;; (slot swim-timer         <bool>)         ;; time before able to swim up
  ;; (slot water-jump?        <bool>)         ;; jump when we get out of water
  ;; (slot ladder?            <bool>)         ;; are we climbing up a ladder
  ;; (slot ladder-shaft       <f64vector+>)   ;; the xz of the shaft we are climbing in
  ;; (slot pressure-plates    <list>          ;; list of pressure plates we were on last time tick-actor was called
  ;; (slot rail-dir           <list+>         ;; are we "riding" a rail -> the direction[s] to ride
  ;; (slot last-turn          <f64vector+>)   ;; last position where we turned
  ;; (slot last-step          <fl>)           ;; last time we played a step sound
  ;; (slot rotation           <fl>)           ;; rotation for the character model
  ;; (slot orientation        <object>)       ;; vertical or horizontal like for four-legged creatures
  ;; (slot dash               <fl>)           ;; temporary speed increase
  
  (method (tick-actor commands <Commands> time <fl> elapse <fl> gravity? collision-response (ignore-entities?: ignore-entities? (ignore-entities?)) (ignore-players?: ignore-players? (ignore-players?)) (ignore-me?: ignore-me? (ignore-me?)) (proportional-slide?: proportional-slide? #t))
    (site (tick-actor on?: #f parent: player)
      (let ((interface (current-interface))
            (world (current-world))
            (zone (current-zone))
            (me (current-me))
            (motion (current-motion))
            (camera (current-camera))
            (history (current-history))
            (model (cache-model))
            (center (transformed-center))
            (scaling (average-scaling))
            (sprint-forward? (get-sprint-forward?~ commands))
            (sprint-backward? (get-sprint-backward?~ commands))
            (blink-forward? (get-blink-forward?~ commands))
            (blink-backward? (get-blink-backward?~ commands)))
        (let ((gravity (compute-gravity&~ world center))
              (area-cube (update-area-cube))
              (me? (eq? self me))
              (fly? (get-fly?~ world))
              (sprint? (or sprint-forward? sprint-backward?))
              (blink? (or blink-forward? blink-backward?))
              (speed #f)
              (animation-speed #f)
              (displacement (vertex& 0. 0. 0.))
              (grace-slowdown .25)
              (grace-move? #f)
              (floor-level (floor-level~ world))
              (target? (eq? (motion-target~ motion) self))
              (old-lookat (lookat-copy& lookat))
              (animation #f))
          (define (process-commands)
            (when (and (get-modified?~ commands) (hook-commands~ world commands))
              ;; move forward
              (when (and (get-move-forward?~ commands) (not sprint?) (not blink?))
                (when (allow-movement?)
                  (move move-forward)
                  (animate (move-animation))))
              ;; move backward
              (when (and (get-move-backward?~ commands) (not sprint?) (not blink?))
                (when (allow-movement?)
                  (move move-backward)
                  (animate "WalkBackwards")))
              ;; move left
              (when (get-move-left?~ commands)
                (when (allow-movement?)
                  (move move-left)
                  (animate (move-animation))))
              ;; move right
              (when (get-move-right?~ commands)
                (when (allow-movement?)
                  (move move-right)
                  (animate (move-animation))))
              ;; move up
              (when (get-move-up?~ commands)
                (move move-up))
              ;; move down
              (when (get-move-down?~ commands)
                (move move-down))
              ;; sprint forward
              (when sprint-forward?
                (move sprint-forward)
                (animate "Run"))
              ;; sprint backward
              (when sprint-backward?
                (move sprint-backward)
                (animate "Run"))
              ;; blink forward
              (when blink-forward?
                (move blink-forward)
                (animate "Run"))
              ;; blink backward
              (when blink-backward?
                (move blink-backward)
                (animate "Run"))
              ;; rotate left
              (when (get-rotate-left?~ commands)
                (rotate-left))
              ;; rotate right
              (when (get-rotate-right?~ commands)
                (rotate-right))))
          
          (define (move proc)
            (cond ((and water? (>= swim-timer 0.))
                   (proc (* dash water-slowdown scaling) displacement))
                  ((or ground? hover? ladder? fly? blink?)
                   (proc (* dash scaling) displacement))
                  ((and jumping? jump-grace?)
                   (proc (* dash grace-slowdown scaling) displacement)
                   (set! grace-move? #t)
                   (set! jump-grace? #f)))
            (when (> dash-duration 0.)
              (decrease! dash-duration elapse)
              (when (<= dash-duration 0.)
                (set! dash 1.)
                (set! dash-duration 0.)
                (update-parameter~ world 'dash))))
          
          (define (move-forward factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (if rail-dir
                (vertex-increase! displacement (vertex-scalar*& (vertex* (get-sight~ lookat) (car rail-dir)) speed))
              (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) speed))))
          
          (define (move-backward factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (if rail-dir
                (vertex-decrease! displacement (vertex-scalar*& (vertex* (get-sight~ lookat) (car rail-dir)) speed))
              (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) speed))))
          
          (define (move-left factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (vertex-decrease! displacement (vertex-scalar*& (get-right~ lookat) speed)))
          
          (define (move-right factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (vertex-increase! displacement (vertex-scalar*& (get-right~ lookat) speed)))
          
          (define (move-up factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (vertex-increase! displacement (vertex-scalar*& (get-up~ lookat) speed)))
          
          (define (move-down factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (vertex-decrease! displacement (vertex-scalar*& (get-up~ lookat) speed)))
          
          (define (sprint-forward factor displacement)
            (set! speed (if rail-dir
                            (* factor (vehicle-speed~ world self))
                          (* factor (vehicle-speed~ world self) (if (user?) 2. sprint-speed))))
            (if rail-dir
                (vertex-increase! displacement (vertex-scalar*& (vertex* (get-sight~ lookat) (car rail-dir)) speed))
              (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) speed))))
          
          (define (sprint-backward factor displacement)
            (set! speed (if rail-dir
                            (* factor (vehicle-speed~ world self))
                          (* factor (vehicle-speed~ world self) (if (user?) 2. sprint-speed))))
            (if rail-dir
                (vertex-decrease! displacement (vertex-scalar*& (vertex* (get-sight~ lookat) (car rail-dir)) speed))
              (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) speed))))
          
          (define (blink-forward factor displacement)
            (set! speed (* factor (vehicle-speed~ world self) blink-speed))
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ camera) speed)))
          
          (define (blink-backward factor displacement)
            (set! speed (* factor (vehicle-speed~ world self) blink-speed))
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ camera) speed)))
          
          (define player-rotation-speed <fl>
            1.3)
          
          (define (rotate-left)
            (rotate-actor-horizontal~ motion self (* player-rotation-speed elapse)))
          
          (define (rotate-right)
            (rotate-actor-horizontal~ motion self (- (* player-rotation-speed elapse))))
          
          (define (animate name)
            (set! animation name)
            ;; arbitrary maximum so animation isn't crazy fast
            (set! animation-speed (and speed (min 2.5 (/ speed (* (model-ground-speed) scaling)))))
            (animate/change time name speed: animation-speed))
          
          (define (animate/change time name (speed: speed #f))
            (let ((old-animation animation-active))
              (animate-model time name speed: speed)
              (animate-change time self old-animation animation-active)))
          
          (define (move-animation)
            (case motion~self
             ((idle) "Idle")
             ((walk) "Walk")
             ((run) "Run")))
          
          (define (process-velocity)
            (cond ((or ground? hover? ladder? fly? blink? grace-move? (and water? (moving?~ commands)))
                   (if rail-dir
                       (vertex-copy! velocity (vertex-scalar*& displacement (/ 2.5 scaling)))
                     (vertex-copy! velocity (vertex-scalar/& displacement scaling))))
                  ((or (not jumping?)
                       (> (- time jump-time) 1.))
                   (let ((friction (get-friction)))
                     (when friction
                       (let ((reduce <fl> (* friction elapse (if water? 4. 1.))))
                         (if (< (vertex-norm& velocity) reduce)
                             (vertex-zero! velocity)
                           (vertex-decrease! velocity (vertex-scalar*& (vertex-normalize-safe& velocity) reduce)))))))))
          
          (define (process-gravity)
            (let ((normalized-gravity (vertex-normalize& gravity)))
              (if (or jump? (get-jump?~ commands))
                  (when (and (not rail-dir) (or water-jump? (and jump-ready? (or (and sprint? (not (user?))) blink? water? (and (or ground? ladder?) (not jumping?))))))
                    (unless (or water? water-jump?)
                      (set! jumping? #t)
                      (set! jump-ready? #f)
                      (set! jump-grace? (and (allow-grace?) (vertex-zero? velocity)))
                      (set! jump-time time))
                    (vertex-copy! fall-velocity (if water?
                                                    (vertex-y-set! fall-velocity (min (+ (vertex-y fall-velocity) 0.02) 0.07))
                                                  (vertex-scalar*& normalized-gravity (* (- (/ (or jump-impulsion (get-jump-impulsion~ world)) (if water-jump? 1.5 1.))) (cond (sprint? (if (user?) 1. sprint-jump))
                                                                                                                                                                               (blink? blink-jump)
                                                                                                                                                                               (water? (if water-jump? 1. (/ 1. 4.)))
                                                                                                                                                                               (else 1.))))))
                    (when water-jump?
                      (set! water-jump? #f))
                    (set! jump? #f)
                    (set! jump-impulsion #f)
                    (animate/change time :context))
                (unless water?
                  (set! jump-ready? #t)))
              (when (> swim-timer 0.)
                (decrease! swim-timer elapse)
                (when (<= swim-timer 0.)
                  (set! swim-timer 0.)
                  (set! jump-ready? #t)))
              (when (and ground? (vertex-zero? fall-velocity))
                (unless jump-ready?
                  (set! jump-ready? #t))
                (when water-jump?
                  (set! water-jump? #f)))
              (when (> (dot-product& fall-velocity normalized-gravity) (if water? 0.015 max-fall-speed))
                (if water?
                    (vertex-y-set! fall-velocity (* (vertex-y fall-velocity) 0.85))
                  (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity max-fall-speed))))))
          
          (define (collide-actor)
            (break-logic slide)
            (when (get-debug-collisions?)
              (reset-marks~ zone))
            (let* ((radiuses (transformed-radiuses))
                   (pumps (and (not water?) (effective-pumps)))
                   (pumped-center (if pumps
                                      (bind-values (pumped pumped-direction pumped-collisions) (collide&stop$ center (vertex+& center pumps) lookat radiuses area-cube: area-cube ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me?)
                                        (free-collisions$ pumped-collisions)
                                        pumped)
                                    center))
                   (target-center (vertex+& pumped-center (vertex-scalar*& velocity elapse)))
                   (collide$ (case collision-response ((stop) collide&stop$) ((slide) collide&slide$))))
              ;; slide
              (bind-values (new-center slide-direction slide-collisions) (site (collide&slide$ on?: #f parent: tick-actor) (collide$ pumped-center target-center lookat radiuses area-cube: area-cube include-back-facing?: #t ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: proportional-slide? debuggable-collisions?: #t))
                (bind-values (new-slide-collisions slide-water?) (filter-water-collisions slide-collisions #t) ;; set water? with both slide and fall
                  (when slide-water?
                    (bind-values (new-center-2 slide-direction-2 slide-collisions-2) (collide$ pumped-center target-center lookat radiuses area-cube: area-cube polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t)
                      (vertex-copy! new-center new-center-2)
                      (free-collisions$ slide-collisions)
                      (set! slide-collisions slide-collisions-2)))
                  (let ((new-center (if pumps
                                        (bind-values (unpumped unpumped-direction unpumped-collisions) (collide&stop$ new-center (vertex-& new-center pumps) lookat radiuses area-cube: area-cube polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me?)
                                          (free-collisions$ unpumped-collisions)
                                          unpumped)
                                      new-center)))
                    ;; kind of a quick hack so we dont slide farther than the player
                    (when (and (not proportional-slide?) (not jumping?))
                      (adjust-fast-slide! center new-center))
                    (break-action
                      (when (in-logic?)
                        (move-actor new-center #f)))
                    (if (or (not gravity?) fly?)
                        (values new-center slide-collisions '())
                      (let ((adjusted (* elapse 50.)))
                        (define (xz-position&)
                          (vertex& (+ (fxceiling (get-x)) .5) 0. (+ (fxceiling (get-z)) .5)))
                        
                        ;; ladder
                        (set! ladder? (some? (lambda (collision) (= (flonum->fixnum (get-data1~ (get-polygon~ collision))) 65)) slide-collisions))
                        (cond (ladder?
                                (when (not ladder-shaft)
                                  (set! ladder-shaft (make-vertex)))
                                (vertex-copy! ladder-shaft (xz-position&)))
                              (else
                               (when ladder-shaft
                                 (if (vertex=? (xz-position&) ladder-shaft)
                                     (if (not-null? slide-collisions)
                                         (set! ladder? #t)
                                       ;; slow fall
                                       (set! adjusted (/ adjusted 3.)))
                                   (set! ladder-shaft #f)))))
                        
                        (break-logic fall)
                        (break-action
                          (when (get-debug-collisions?)
                            (reset-marks~ zone)))
                        (when water?
                          (set! adjusted (/ adjusted 1.5)))
                        (vertex+! fall-velocity fall-velocity (vertex-scalar*& gravity adjusted))
                        (cond (rail-dir
                                (vertex! fall-velocity 0. -.20 0.))
                              (ladder?
                                (vertex! fall-velocity 0. .075 0.)))
                        (let ((target-fall (vertex+& new-center (vertex+& (vertex-scalar*& fall-velocity adjusted) (vertex-scalar*& gravity (* .5 adjusted adjusted))))))
                          ;; fall
                          ;; megahack around many edge / point collision snags when jumping next to blocks (AM)
                          (bind-values (new-fall fall-direction fall-collisions) (site (collide&stop$ on?: #f parent: tick-actor) (collide&stop$ new-center target-fall lookat radiuses area-cube: area-cube include-back-facing?: #t ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t megahack?: (and me? (or jumping? ladder? ladder-shaft))))
                            (break-action
                              (when (in-logic?)
                                (move-actor new-fall #f)))
                            (let ((new-fall-collisions (liquid? fall-collisions slide-water?)))
                              (if water-collision?
                                  (begin
                                    (unless shallow-water?
                                      (set! shallow-water? #t)
                                      (when target?
                                        (change-ambience~ (current-ambience))))
                                    (bind-values (new-fall-2 fall-direction other-fall-collisions) (collide&stop$ new-center target-fall lookat radiuses area-cube: area-cube polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t)
                                      (vertex-copy! new-fall new-fall-2)
                                      (free-collisions$ fall-collisions)
                                      (set! fall-collisions other-fall-collisions)))
                                (when (and water? shallow-water?)
                                  (set! shallow-water? #f)
                                  (when target?
                                    (play-ambience~ (current-ambience) "ambience/water/Underwater"))))
                              (vertex-copy! new-fall (or (manage-fall-collisions fall-collisions) new-fall))
                              (values new-fall slide-collisions fall-collisions)))))))))))
          
          (define (manage-fall-collisions fall-collisions)
            (manage-pressure-plates fall-collisions)
            (manage-rails fall-collisions))
          
          (define (manage-pressure-plates fall-collisions)
            (define (common-list-elements l1 l2)
              (let ((common '()))
                (for-each (lambda (element)
                            (when (member? element l2)
                              (set! common (cons element common))))
                          l1)
                common))
            
            (let ((new-pp '())
                  (to-add '())
                  (to-remove '()))
              (for-each (lambda (coll)
                          (when (memq? (flonum->fixnum (get-data1~ (get-polygon~ coll))) '(70 72))
                            (let ((poly (get-polygon~ coll)))
                              (set! new-pp (cons (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly)) new-pp)))))
                        fall-collisions)
              (let ((common (intersection test: equal? new-pp pressure-plates)))
                (set! to-add (list-copy new-pp))
                (set! to-remove (list-copy pressure-plates))
                (for-each (lambda (com)
                            (set! to-add (remove com to-add test: equal?))
                            (set! to-remove (remove com to-remove test: equal?)))
                          common)
                (pressure-plates-update~ (current-game) to-add to-remove self)
                (set! pressure-plates new-pp))))
          
          (define (manage-rails fall-collisions)
            (let ((rail (find-object (lambda (coll) (when (memq? (flonum->fixnum (get-data1~ (get-polygon~ coll))) '(27 28 66)) (get-polygon~ coll))) fall-collisions))
                  (pos #f))
              (if rail
                  (call-with-position~ (current-zone) (vertex& (get-data2~ rail) (get-data3~ rail) (get-data4~ rail))
                    (lambda (region sector block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                      (let ((data (if (memq? block-id '(27 28)) (bit-set data-id 3 #f) data-id)))
                        (let ((curved? (> data 5)))
                          (if (not curved?)
                              (begin
                                (let ((dir (if (memq? data '(0 4 5)) #f64(0. 0. 1.) #f64(1. 0. 0.)))) ;; N W
                                  (let ((angle (vector-angle (get-sight~ lookat) dir))
                                        (dist (vertex-norm& (vertex*& (vertex-& position (vertex& x y z)) (if (memq? data '(0 4 5)) #f64(1. 0. 0.) #f64(0. 0. 1.))))))
                                    (if (and (or (< angle (degree->radian 10.)) (> angle (degree->radian 170.))) (< dist .2))
                                        (unless rail-dir
                                          (set! rail-dir (list dir)))
                                      (set! rail-dir #f))))
                                (set! last-turn #f))
                            (let ((dir1 (if (memq? data '(6 7)) #f64(0. 0. 1.) #f64(0. 0. -1.)))
                                  (dir2 (if (memq? data '(6 9)) #f64(1. 0. 0.) #f64(-1. 0. 0.))))
                              (let ((curve (curve-angle (get-sight~ lookat) dir1 dir2)))
                                (when rail-dir
                                  (unless (and last-turn (vertex=? (vertex& x (- y .5) z) last-turn))
                                    (set! pos (vertex x y z))
                                    (set! last-turn (vertex x (- y .5) z))
                                    (set! rail-dir (cdr rail-dir))
                                    (rotate-actor-horizontal~ motion self curve))))))))))
                (set! rail-dir #f)
                (set! last-turn #f))
              pos))
          
          (define (curve-angle sight d1 d2)
            (let ((a1 (vector-angle sight d1))
                  (a2 (vector-angle sight d2))
                  (main-dir (make-vertex))
                  (curve (degree->radian 90.)))
              (cond ((> a1 (degree->radian 170.))
                     (vertex-copy! main-dir d1)
                     (set! curve (* curve -1. (vertex-x d2) (vertex-z main-dir)))
                     (unless last-turn
                       (set! rail-dir (list (vertex-abs main-dir) d2))))
                    ((> a2 (degree->radian 170.))
                     (vertex-copy! main-dir d2)
                     (set! curve (* curve (vertex-z d1) (vertex-x main-dir)))
                     (unless last-turn
                       (set! rail-dir (list (vertex-abs main-dir) d1))))
                    (else
                     (set! rail-dir #f)
                     (set! last-turn #f)))
              curve))
          
          (define (liquid? fall-collisions slide-water?)
            (let ((new-collisions (make-queue$))
                  (water-polygons (make-queue$))
                  (lava-collision? #f))
              (for-each (lambda (collision)
                          (let ((poly (get-polygon~ collision)))
                            (if (get-water-cube?~ (world.generation:id->block (flonum->fixnum (get-data1~ poly))))
                                (begin
                                  (when (memq? (flonum->fixnum (get-data1~ poly)) '(10 11))
                                    (set! lava-collision? #t))
                                  (enqueue water-polygons poly))
                              (enqueue new-collisions collision))))
                        fall-collisions)
              (if (and (queue-empty? water-polygons) (not slide-water?))
                  (begin
                    (set! water-collision? #f)
                    (when water?
                      (unless (get-water-cube?~ (world.generation:id->block (block-at-center)))
                        (exit-water))))
                (unless water?
                  (enter-water lava-collision? time)
                  (set! grace-move? #f))
                (unless water-collision?
                  (set! water-collision? #t)))
              (let ((lst (queue-list new-collisions)))
                (free-queue$ new-collisions)
                (free-queue$ water-polygons)
                lst)))
          
          (define (liquid-filter poly)
            (not (get-water-cube?~ (world.generation:id->block (flonum->fixnum (get-data1~ poly))))))
          
          (define (hit-action slide-collisions)
            (define (find-actionable)
              (continuation-capture
                (lambda (found)
                  (for-each (lambda (collision)
                              (let ((poly (get-polygon~ collision)))
                                (when (= (flonum->fixnum (get-data1~ poly)) 90)
                                  (continuation-return found poly))))
                            slide-collisions)
                  #f)))
            
            (let ((poly (find-actionable)))
              (when poly
                (let ((id (flonum->fixnum (get-data1~ poly)))
                      (pos (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly))))
                  (cond ;; portal
                        ((= id 90)
                         (world.generation:invoke-block-action pos))
                        (else
                         #f))))))
          
          (define (hit-collisions new-center slide-collisions fall-collisions)
            (define (ground-update flag velocity)
              (when (neq? ground? flag)
                (set! ground? flag)
                (if velocity
                    (hit-ground velocity)
                  (leave-ground))))
            
            (hit slide-collisions)
            (let ((floor-level (and floor-level (+ floor-level (get-radius-y))))
                  (velocity (copy-vertex fall-velocity)))
              (if (and floor-level (< (vertex-y new-center) floor-level) (not fly?))
                  (begin
                    (hit-floor velocity)
                    (vertex-y-set! new-center floor-level)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))
                (let ((fall-collided? (not-null? fall-collisions))
                      (water-only? (null? (filter-water-collisions fall-collisions #f))))
                  (if (not fall-collided?)
                      (ground-update #f #f)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update (not water-only?) velocity))))))
          
          (define (filter-water-collisions fall-collisions slide?)
            (define (not-water? collision)
              (liquid-filter (get-polygon~ collision)))
            
            ;; optimize the by far most common case
            (if (every? not-water? fall-collisions)
                (if slide?
                    (values fall-collisions #f)
                  fall-collisions)
              (let ((new-collisions (collect-if not-water? fall-collisions)))
                (if slide?
                    (values new-collisions #t)
                  new-collisions))))
          
          (define (foot-step fall-collisions)
            (when (and target? (get-steps?~ model) (or ground? @not-really-nice ladder?) (or (not water?) shallow-water?))
              (let ((speed (vertex-norm& velocity)))
                (when (> speed 0.)
                  ;; two steps for each animation
                  (let ((step-time (/ (effective-duration~ morphing) 2.)))
                    (when (> (- time last-step) step-time)
                      (set! last-step time)
                      (let ((kind (cond @not-really-nice
                                    (ladder?
                                      'ladder)
                                    ((and water? shallow-water?)
                                     'water)
                                    ((null? fall-collisions)
                                     'stone)
                                    (else
                                     (let ((collision (car fall-collisions)))
                                       (let ((id (flonum->fixnum (get-data1~ (get-polygon~ collision)))))
                                         (case id
                                           ((2) 'grass)
                                           ((5) 'wood)
                                           ((12 13) 'dirt)
                                           ((78 79 80) 'snow)
                                           (else 'stone))))))))
                        (play-sound-file (random-step kind) volume: .075))))))))
          
          (define (move-actor new-center (calculate? #t))
            (let ((movement (vertex- new-center center)))
              (let ((new-position (vertex+& position movement))
                    (old-position (vertex-copy& position))
                    (old-velocity (vertex-copy& effective-velocity)))
                (vertex+! effective-velocity velocity fall-velocity)
                (when (and calculate? (moving?~ commands))
                  (set! velocity-angle (abs (- 90. (radian->degree (vector-angle (vertex*& (vertex-& new-position old-position) (vertex& 1. 0. 1.)) (get-sight~ lookat)))))))
                (set-position new-position)
                (vertex-copy! center new-center)
                (unless (vertex-near? old-position new-position)
                  (update-compass~ world))
                (move-change time self old-position new-position old-velocity effective-velocity)
                movement)))
          
          (define (rotate-model movement)
            (when target?
              (let ((distance (/ (dot-product& (get-sight~ lookat) movement) (get-radius))))
                (define (set-x-rotation name)
                  (let ((model (child~ model name)))
                    (vertex-x-set! (get-rotation~ model) rotation)
                    (update-matrix~ model)))
                
                (when (/= distance 0.)
                  (decrease! rotation distance)
                  (case (get-name~ model)
                    ((Orb)
                     (set-x-rotation 'body))
                    ((OrbOnWheels OrbOnHummer)
                     (set-x-rotation 'wheel1)
                     (set-x-rotation 'wheel2)
                     (set-x-rotation 'wheel3)
                     (set-x-rotation 'wheel4)))))))
          
          (define (realign-actor slide-collisions fall-collisions)
            (when (and gravity? (not fly?))
              (update-world-up~ world gravity)
              (case orientation
                ((vertical)
                 (realign-lookat (gravity-up& gravity)))
                ((horizontal)
                 (when (or (not-null? slide-collisions)
                           (not-null? fall-collisions))
                   (let ()
                     (define (average-normal)
                       (let ((factor-sum 0.)
                             (dir-sum (make-zero-vertex)))
                         (define (process-collisions collisions)
                           (for-each (lambda (collision)
                                       (let ((plane (get-plane~ collision)))
                                         (let ((origin (get-origin~ plane))
                                               (normal (get-normal~ plane)))
                                           (let ((dist (vertex-distance& origin center)))
                                             (let ((factor (/ (+ 1. dist))))
                                               (increase! factor-sum factor)
                                               (vertex+! dir-sum dir-sum (vertex-scalar*& normal factor-sum)))))))
                                     collisions))
                         
                         (process-collisions slide-collisions)
                         (process-collisions fall-collisions)
                         (vertex-scalar/& dir-sum factor-sum)))
                     
                     (remove-up-roll! lookat (average-normal) lookat)
                     (update-matrix)))))))
          
          (define (realign-horizon)
            (when (and gravity? (not fly?) target? (is? motion Person-Motion))
              (let ((final-gravity (compute-gravity~ world center)))
                (set-lookat~ camera (realign-lookat-horizon& (get-lookat~ camera) (get-up~ lookat) gravity final-gravity))
                (camera-update~ camera))))
          
          (define (center-eye)
            (when target?
              (eye-center-player~ motion)))
          
          (define (verify-death)
            (when (and lava? (user?))
              (damage 1. #f))
            (when (and die-bottom (< (get-y) die-bottom))
              (damage 100. #f)))
          
          (process-commands)
          (process-velocity)
          (process-gravity)
          (when (not animation)
            (animate/change time :context))
          ;; aec quicky
          (let ((collide-info (parameterize ((aec-rotate-hack? (or (get-rotate-left?~ commands) (get-rotate-right?~ commands))))
                                (collide-actor))))
            (bind-values (new-center slide-collisions fall-collisions) collide-info
              (unless (hit-action slide-collisions)
                (hit-collisions new-center slide-collisions fall-collisions)
                (if (not alive?)
                    (begin
                      (free-collisions$ slide-collisions)
                      (free-collisions$ fall-collisions))
                  (foot-step fall-collisions)
                  (let ((movement (move-actor new-center)))
                    (rotate-model movement)
                    (realign-actor slide-collisions fall-collisions)
                    (free-collisions$ slide-collisions)
                    (free-collisions$ fall-collisions)
                    (lookat-change time self old-lookat lookat)
                    (unless (vertex-zero? movement)
                      (realign-horizon)
                      (center-eye)
                      (verify-death)
                      collide-info))))))))))
  
  
  (method protected virtual (tick-slice)
    #f)
  
  
  (method protected virtual (tick-actions commands)
    )
  
  
  (method (tick-actor-actions commands)
    (let ((world (current-world)))
      (when (get-modified?~ commands)
        (for-each (lambda (action)
                    (bind (name . arguments) action
                      (tick-actor-action name arguments)))
                  (get-actions~ commands)))))
  
  
  (method protected virtual (tick-actor-action name arguments)
    (let ((world (current-world)))
      (when (hook-action~ world name arguments)
        (case name
          ((track)
           (bind (dh dv eye-sight eye-up eye-right first?) arguments
             (track-actor~ (current-motion) self dh dv eye-sight eye-up eye-right first?)))
          ((add)
           (bind (mode class grid? grid-plane grid-position eye direction stage) arguments
             (editor-add~ world mode class grid? grid-plane grid-position eye direction stage)))
          ((delete)
           (bind (position) arguments
             (editor-delete~ world position)))
          ((fire)
           (when (person-motion?)
             (bind (direction kind) arguments
               (fire-missile direction kind))))
          ((rapid-fire)
           (start-rapid-fire))))))
  
  
  (method protected virtual (effective-pumps)
    #f)
  
  
  (method protected virtual (ignore-entities?)
    #t)
  
  
  (method protected virtual (ignore-players?)
    #f)
  
  
  (method protected virtual (ignore-me?)
    #f)
  
  
  (method protected virtual (hit collisions)
    )
  
  
  (method protected virtual (hit-floor velocity)
    )
  
  
  (method protected virtual (hit-ground velocity)
    (define fall-conversion-a <fl>
      (/ 1. .18))
    
    (define fall-conversion-b <fl>
      (/ 1. .51))

    (define (blocks-fallen speed)
      (fxround (expt (* speed fall-conversion-a) fall-conversion-b)))
    
    (unless (or ladder? (not (user?)))
      (let ((fall-speed (abs (vertex-y velocity)))
            (minimum-speed .7))
        (when (> fall-speed minimum-speed)
          (let ((amount (* 4 (- (blocks-fallen fall-speed) 5))))
            (damage amount #f))))))
  
  
  (method protected virtual (leave-ground)
    )
  
  
  (method protected virtual (ground-speed)
    (case motion
      ((walk) (walk-speed))
      ((run) (run-speed))))
  
  
  (method protected virtual (walk-speed)
    (model-walk-speed))
  
  
  (method protected virtual (run-speed)
    (model-run-speed))
  
  
  (method (model-ground-speed)
    (case motion
      ((walk) (model-walk-speed))
      ((run) (model-run-speed))))
  
  
  (method (model-walk-speed)
    (or (get-walk-speed~ (cache-model)) default-walk-speed))
  
  
  (method (model-run-speed)
    (or (get-run-speed~ (cache-model)) default-run-speed))
  
  
  (method protected virtual (allow-movement?)
    #t)
  
  
  (method protected virtual (allow-grace?)
    #t)
  
  
  (method protected virtual (adjust-fast-slide! center new-center)
    )
  
  
  ;;;
  ;;;; Type
  ;;;
  
  
  (method protected virtual (is-player?)
    #f)
  
  
  (method protected virtual (is-missile?)
    #f)
  
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method override (animated)
    (set! animated? #t))
  
  
  (method override (unanimated)
    (set! animated? #f))
  
  
  (method protected virtual (animate-model time name (speed: speed #f) (duration: duration #f) (next: next #f))
    (let ((elapse-before-fall .5)
          (jump-start-frame 8.))
      (unless (not morphing)
        (let ((fall? (not ground?)))
          (unless jumping?
            (if fall?
                (when (not animation-fall)
                  (set! animation-fall time))
              (set! animation-fall #f)))
          (when (or (not animation-fall)
                    (equal? name :context)
                    ;; to not switch non-stop between run and fall while running down a slope
                    (> (- time animation-fall) elapse-before-fall))
            (let ((model (cache-model)))
              (define (determine-animation proc)
                (cond ((eq? motion 'idle) (proc '("Idle") #f))
                      ((and water? (not shallow-water?)) (proc (if (eq? name :context) '("SwimIdle" "Idle") '("Swim" "Run")) #f))
                      (jumping? (proc '("JumpStart" "Jump" "Fall" "Idle") (list "Jump" "Fall" "Idle")))
                      ((and fall? (not ladder?)) (proc '("Fall" "Idle") #f))
                      (else (proc (if (eq? name :context)
                                      (cond (animation-once
                                             (list animation-once))
                                            (animation-continuous
                                             (list animation-continuous))
                                            (else
                                             (list "Idle")))
                                    (listify name))
                                  #f))))
              
              (define (existing-animation animation-list)
                (let (iter (scan animation-list))
                  (if (or (not scan)
                          (null? scan))
                      #f
                    (let ((animation (car scan)))
                      (if (find-animation~ model animation)
                          animation
                        (iter (cdr scan)))))))
              
              (determine-animation
                (lambda (animation-list next-list)
                  (let ((animation (existing-animation animation-list)))
                    (if (not animation)
                        (error "No animation found in: {l detail: :human separator: \", \"}" animation-list)
                      (let ((next (existing-animation next-list)))
                        (unless (and (equal? animation-active animation)
                                     (equal? animation-speed speed))
                          (let ((previous animation-active))
                            (let ((was-falling? (or (equal? previous "JumpStart")
                                                    (equal? previous "Jump")
                                                    (equal? previous "Fall"))))
                              (cond ((and animation-once (equal? animation animation-once))
                                     (transition-morphing animation next: "Idle" next-proc: (lambda () (set! animation-once #f)))
                                     (set! animation-active animation)
                                     (set! animation-speed #f))
                                    ((and animation-continuous (equal? animation animation-continuous))
                                     (transition-morphing animation)
                                     (set! animation-active animation)
                                     (set! animation-speed #f))
                                    ((and was-falling? (equal? animation "Idle"))
                                     (change-morphing (existing-animation '("JumpEnd" "Idle")) next: "Idle")
                                     (set! animation-active "Idle")
                                     (set! animation-speed #f)
                                     (set! animation-once #f)
                                     (set! animation-continuous #f))
                                    ((and was-falling? (equal? animation "Run"))
                                     (change-morphing (existing-animation '("JumpLandRun" "Run")) next: "Run")
                                     (set! animation-active "Run")
                                     (set! animation-speed #f)
                                     (set! animation-once #f)
                                     (set! animation-continuous #f))
                                    (else
                                     (let ((frame (if (equal? animation "JumpStart") jump-start-frame #f))
                                           (duration (if (equal? previous "Idle") .1 #f)))
                                       (transition-morphing animation frame: frame speed: speed duration: duration next: next)
                                       (set! animation-active animation)
                                       (set! animation-speed speed)
                                       (set! animation-once #f)
                                       (set! animation-continuous #f))))))))))))))))))
  
  
  ;;;
  ;;;; Missiles
  ;;;
  
  
  (method protected (increase-missiles)
    (increase! missiles-count))
  
  
  (method protected (decrease-missiles)
    (decrease! missiles-count))

  
  ;;;
  ;;;; Billboard
  ;;;
  
  
  (method override (cache-billboard)
    (unless (user?)
      (when interface-script?
        (let ((script (get-script)))
          (when script
            (let ((state (get-state~ script)))
              (if (and billboard (eq? (get-state~ billboard) state))
                  billboard
                (let ((board (make-billboard~ script)))
                  (set-billboard board)
                  board))))))))
  
  
  ;;;
  ;;;; Script
  ;;;
  
  
  (method override (get-script)
    (find-type Script))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-target color)
    (draw-target-circle))))
