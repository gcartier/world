;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Actors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.actor jazz


(import (jazz.geometry)
        (jazz.platform)
        (jazz.syntax (phase syntax))
        (gaea.dye)
        (gaea.geometry)
        (gaea.homogeneous)
        (world)
        (world.animation)
        (world.area)
        (world.autoload)
        (world.collision)
        (world.commands)
        (world.configure)
        (world.context)
        (world.element)
        (world.entity)
        (world.folio)
        (world.generation.block)
        (world.history)
        (world.id)
        (world.model)
        (world.motion)
        (world.polygon)
        (world.queue)
        (world.settings)
        (world.sound)
        (world.spell)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Actor
;;;


(definition *global-cooldown*
  0.5)

(definition protected max-fall-speed <fl>
  2.75)

(definition protected die-bottom <fl>
  -180.)

(definition protected water-slowdown <fl>
  0.75)


(definition default-walk-speed
  3.)

(definition default-run-speed
  6.)


(definition sprint-speed <fl>
  (world-setting 'world.sprint-speed 5.))

(definition sprint-jump <fl>
  (world-setting 'world.sprint-jump 2.))


(definition protected base-armor <fl>
  (world-setting 'world.base-armor 20.))

(definition protected base-power <fl>
  (world-setting 'world.base-power 10.))

(definition protected base-ranged-power <fl>
  (world-setting 'world.base-ranged-power 10.))


(definition protected max-missiles <fx>
  10)


;; quick hacks to slow down running
(definition protected move-slowdown
  .7)

;; quick hacks to slow down running
(definition protected animation-slowdown
  .75)


(definition protected override-gravity
  #f)

(definition protected (set-override-gravity gravity)
  (set! override-gravity gravity))


(class Actor extends Entity
  

  ;; backward compatibility quicky for sejour  
  (property mount?              <bool>       initialize #f                 accessors generate)
  ;; backward compatibility quicky for sejour
  (property fly?                <bool>       initialize #f                 accessors generate)
  (property mount               <symbol+>    initialize #f                 accessors generate)
  
  (slot velocity                <vertex>     initialize (make-zero-vertex) getter generate)
  (slot fall-velocity           <vertex>     initialize (make-zero-vertex) getter generate)
  (slot effective-velocity      <vertex>     initialize (make-zero-vertex) getter generate)
  (slot velocity-angle          <fl>         initialize 0.                 getter generate)
  (slot motion                  <symbol>     initialize 'walk              accessors generate)
  (slot vehicle                 <Entity+>    initialize #f                 accessors generate)
  (slot life                    <fl>         initialize 100.               accessors generate)
  (slot alive?                  <bool>       initialize #t                 accessors generate)
  (slot global-cooldown         <fl>         initialize 0.                 accessors generate)
  (slot spell                   <Spell+>     initialize #f                 accessors generate)
  (slot adjustments             <list>       initialize '()                accessors generate)
  (slot rapid-fire-acceleration <fl>         initialize 1.                 accessors generate)
  (slot rapid-fire-duration     <fl>         initialize 0.                 accessors generate)
  (slot rapid-fire-cooldown     <fl>         initialize 0.                 accessors generate)
  (slot last-missile            <fl+>        initialize #f                 accessors generate)
  (slot missiles-count          <fx>         initialize 0                  accessors generate)
  (slot history-color           <object>     initialize #f                 accessors generate)
  (slot sprint?                 <bool>       initialize #f                 accessors generate)
  (slot jumping?                <bool>       initialize #f                 accessors generate)
  (slot jump-ready?             <bool>       initialize #f                 accessors generate)
  (slot jump-grace?             <bool>       initialize #f                 accessors generate)
  (slot jump-time               <fl>         initialize 0.                 accessors generate)
  (slot ground?                 <bool>       initialize #f                 accessors generate)
  (slot hover?                  <bool>       initialize #f                 accessors generate)
  (slot water?                  <bool>       initialize #f                 accessors generate)
  (slot water-collision?        <bool>       initialize #f                 accessors generate)
  (slot shallow-water?          <bool>       initialize #f                 accessors generate)
  (slot lava?                   <bool>       initialize #f                 accessors generate)
  (slot swim-timer              <fl>         initialize 0.                 accessors generate)
  (slot water-jump?             <bool>       initialize #f                 accessors generate)
  (slot ladder?                 <bool>       initialize #f                 accessors generate)
  (slot ladder-shaft            <vertex+>    initialize #f                 accessors generate)
  (slot ladder-center           <vertex+>    initialize #f                 accessors generate)
  (slot ladder-orientation      <object>     initialize #f                 accessors generate)
  (slot plates                  <list>       initialize '()                accessors generate)
  (slot rail-dir                <list+>      initialize #f                 accessors generate)
  (slot last-turn               <vertex+>    initialize #f                 accessors generate)
  (slot last-step               <fl>         initialize 0.                 accessors generate)
  (slot rotation                <fl>         initialize 0.                 accessors generate)
  (slot orientation             <object>     initialize 'vertical          accessors generate)
  (slot dash                    <fl>         initialize 1.                 accessors generate)
  (slot dash-duration           <fl>         initialize 0.                 accessors generate)
  (slot jump?                   <bool>       initialize #f                 accessors generate)
  (slot jump-impulsion          <object>     initialize #f                 accessors generate)
  (slot animation-active        <object>     initialize #f                 accessors generate)
  (slot animation-speedup       <fl+>        initialize #f                 accessors generate)
  (slot animation-fall          <object>     initialize #f                 accessors generate)
  (slot animation-once          <object>     initialize #f                 accessors generate)
  (slot animation-continuous    <object>     initialize #f                 accessors generate)
  (slot armor                   <fl>         initialize base-armor         accessors generate)
  (slot armor-factor            <fl>         initialize 1.                 accessors generate)
  (slot power                   <fl>         initialize base-power         accessors generate)
  (slot power-factor            <fl>         initialize 1.                 accessors generate)
  (slot ranged-power            <fl>         initialize base-ranged-power  accessors generate)
  (slot ranged-power-factor     <fl>         initialize 1.                 accessors generate)
  (slot area-cube               <object>     initialize #f                 accessors generate)
  
  
  (method override (finish self rest)
    (nextmethod self rest)
    (let ((color (copy-dye color)))
      (dye-alpha-set! color .2)
      (set! history-color color))
    @only-me-area-cube-for-now
    (when (client?)
      (setup-area-cube self)))
  
  
  (method override (register-id self id)
    (set! self.id id)
    (register-actor id self))
  
  
  (method override (unregister-id self)
    (when id
      (unregister-actor id)))
  
  
  (method package virtual (setup-area-cube self)
    (set! area-cube (new Area-Cube 2)))
  
  
  (method package virtual (update-area-cube self)
    (update-cube area-cube position)
    area-cube)
  
  
  (method public inline (set-velocity self vel <vertex>) <void>
    (vertex-copy! velocity vel))
  
  
  (method public inline (set-fall-velocity self vel <vertex>) <void>
    (vertex-copy! fall-velocity vel))
  
  
  (method public inline (set-effective-velocity self vel <vertex>) <void>
    (vertex-copy! effective-velocity vel))
  
  
  (method override (call-model-update self model)
    (nextmethod self model)
    (set! animation-active #f)
    (set! animation-speedup #f)
    (set! animation-fall #f)
    (set! animation-once #f)
    (set! animation-continuous #f))
  
  
  ;; quick hacks to try and enclose the vehicle in our bounds
  (method override (entity-bounds self)
    (if (not vehicle)
        (nextmethod self)
      ;; normalize both models to a scaling of 1
      ;; and in the end reapply our own scaling
      (let ((vehicle-model (cache-model vehicle)))
        (let ((vehicle-scale (get-scale vehicle-model)))
          (let ((bounds (scale-cuboid (get-bounds (cache-model self)) scale))
                (vehicle-bounds (scale-cuboid (get-bounds vehicle-model) vehicle-scale))
                (saddle (get-saddle vehicle-model)))
            (let ((translated (if (not saddle) bounds (translate-cuboid bounds (vertex& 0. saddle 0.)))))
              (let ((union (cuboid-union translated vehicle-bounds)))
                (scale-cuboid union (vertex-inverse& scale)))))))))
  
  
  ;; quick hacks to try and enclose the vehicle in our bounds
  (method override (transformed-center self)
    (let ((center (nextmethod self)))
      (if (not vehicle)
          center
        (let ((vehicle-model (cache-model vehicle)))
          (let ((saddle (get-saddle vehicle-model)))
            (if (not saddle)
                center
              (vertex+ center (vertex& 0. (- (* saddle (vertex-y (get-scale vehicle-model)) (vertex-y scale))) 0.))))))))
  
  
  (method package (setup-armor self value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.5)
            (max-armor 500.))
        (+ min-factor (* (/ value max-armor) (- max-factor min-factor)))))
    
    (set! armor value)
    (set! armor-factor (calculate-factor)))
  
  
  (method package (setup-power self value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.5)
            (max-power 160.))
        (+ min-factor (* (/ value max-power) (- max-factor min-factor)))))
    
    (set! power value)
    (set! power-factor (calculate-factor)))
  
  
  (method package (setup-ranged-power self value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.)
            (max-power 120.))
        (+ min-factor (* (/ value max-power) (- max-factor min-factor)))))
    
    (set! ranged-power value)
    (set! ranged-power-factor (calculate-factor)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (definition missile-delay <fl>
    .1)
  
  
  (method package (maybe-fire self kind)
    (let ((time (current-monotonic)))
      (when (or (not last-missile)
                (> (- time last-missile) (/ missile-delay rapid-fire-acceleration)))
        (fire-aim self kind)
        (set! last-missile time))))
  
  
  (method package (fire-aim self kind)
    (when (person-motion?)
      (let ((direction (aim-direction self)))
        (fire-missile self direction kind))))
  
  
  (method package (fire-missile self direction kind)
    (let ((interface (current-interface))
          (world (current-world)))
      (let ((panel (child interface 'character)))
        (when (and (< missiles-count max-missiles)
                   (or (neq? kind 'arrow)
                       (> (count-arrows panel) 0)))
          (when (eq? kind 'arrow)
            (use-arrow panel))
          (let ((lens (lens-center self))
                (adjusted-radius (* (get-radius-x self) 2.)))
            (let ((pos (vertex+& lens (vertex-scalar*& direction adjusted-radius))))
              (world.changes:fire-change pos direction kind self)))
          (attack self kind)))))
  
  
  (method override (lens-center self)
    (let ((model (cache-model self)))
      (let ((center (get-center model))
            (bounds (get-bounds model))
            (eye-level (let ((name (get-name model)))
                         (if (orb? name)
                             .15
                           ;; why is the division necessary?
                           (+ (/ (or (get-lens model) .8) 2.)
                              (case (vehicle-name self)
                                ((Saucer Rocket) .10)
                                ((Hummer) .23)
                                (else 0.)))))))
        ;; aec quicky
        (let ((model-lens (vertex 0. (+ (vertex-y center) (* (cuboid-height bounds) eye-level)) 0.)))
          (matrix-transform-3x4 matrix model-lens)))))
  
  
  (method (aim-direction self)
    (let ((world (current-world)))
      (let ((eye (get-eye world)))
        (if (get-free-aim? world)
            (get-sight eye)
          (cross-normal (get-up eye) (get-right lookat))))))
  
  
  (method package (start-rapid-fire self)
    (set! rapid-fire-acceleration 3.)
    (set! rapid-fire-duration 15.)
    (set! rapid-fire-cooldown 45.))
  
  
  (method package (warp-forward self)
    (let ((world (current-world)))
      (set-position self (vertex+& position (vertex-scalar*& (get-sight (current-camera)) 2.)))
      (follow-player world)))
  
  
  (method package (warp-backward self)
    (let ((world (current-world)))
      (set-position self (vertex+& position (vertex-scalar*& (get-sight (current-camera)) -2.)))
      (follow-player world)))
  
  
  (method package (start-dash self)
    (let ((world (current-world)))
      (set! dash 5.)
      (set! dash-duration 10.)
      (update-parameter world 'dash)))
  
  
  (method public virtual (damage self amount critical?)
    (play-3d-sound-if (if critical? (wound-critical-sound self) (wound-sound self)) position)
    @w
    (let ((animation (if critical? "CombatCritical" "CombatWound")))
      (when (find-animation (cache-model) animation)
        (set! animation-once animation)))
    (decrease! life amount)
    ;; only server kills
    (when (and (<= life 0.) (not (client?)))
      (world.changes:die-change self)))
  
  
  (method protected virtual (attacking? self)
    #f)
  
  
  (method protected virtual (attack self kind)
    )
  
  
  (method package virtual (attack-amount self factor amount)
    (* amount factor))
  
  
  (method public virtual (wound self inflictor factor (amount #f))
    (let ((world (current-world)))
      (let ((critical? (> (random-real) .8)))
        (damage self (if amount
                    amount
                  (attack-amount inflictor factor (wound-amount self critical?)))
                (if amount #f critical?)))))
  
  
  (method public virtual (wound-amount self critical?)
    (if critical? 20. 10.))
  
  
  (method public virtual (wound-sound self)
    (find-sound self 'wound))
  
  
  (method public virtual (wound-critical-sound self)
    (find-sound self 'wound-critical))
  
  
  (method public virtual (explode self inflictor)
    (let ((zone (current-zone))
          (radius 2.))
      (play-3d-sound "warcraft/spells/ExplosiveShot" position)
      (for-each (lambda (actor)
                  (when (and (<= (vertex-distance& position (get-position actor)) radius)
                             (explosion-damage? actor))
                    (wound actor inflictor (get-ranged-power-factor inflictor))))
                (get-actors zone))))
  
  
  (method public virtual (explosion-damage? self)
    #t)
  
  
  (method public virtual (die self)
    (let ((world (current-world)))
      (play-3d-sound-if (death-sound self) position)
      (remove-element world self)
      (set! alive? #f)))
  
  
  (method public virtual (death-sound self)
    (find-sound self 'death))
  
  
  (method public virtual (resurrect self)
    (let ((zone (current-zone)))
      (add-element zone self)
      (set! alive? #t)))
  
  
  (method public virtual (stomp self)
    #f)
  
  
  (method protected virtual (get-friction self)
    4.)
  
  
  (method protected (block-at-center self)
    (let ((zone (current-zone)))
      (block-at zone (transformed-center self))))
  
  
  @wait-liquid
  (method protected (enter-water self lava? (time 0.))
    (set! jumping? #f)
    (set! jump-time time)
    (set! water-jump? #f)
    (set! water? #t)
    (set-lava? self lava?))
  
  
  @wait-liquid
  (method protected (exit-water self (forced? #f))
    (set! swim-timer 0.)
    (set! shallow-water? #f)
    (set! water? #f)
    (set! lava? #f)
    (set! water-jump? (not forced?)))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  ;; (slot position           <vertex>)       ;; position
  ;; (slot lookat             <LookAt>)       ;; lookat is always perpendicular to gravity
  ;; (slot scale              <vertex>)       ;; scale
  ;; (slot matrix             <matrix>)       ;; matrix
  ;; (slot radiuses           <vertex+>)      ;; radiuses
  ;; (slot radius             <fl+>)          ;; radius
  ;; (slot velocity           <vertex>)       ;; velocity
  ;; (slot fall-velocity      <vertex>)       ;; fall-velocity
  ;; (slot effective-velocity <vertex>)       ;; velocity + fall-velocity
  ;; (slot velocity-angle     <fl>)           ;; real displacement / elapse
  ;; (slot jumping?           <bool>)         ;; are we currently jumping
  ;; (slot jump-ready?        <bool>)         ;; so holding the jump key only jumps once
  ;; (slot jump-grace?        <bool>)         ;; a standing jump allows us one last move
  ;; (slot jump-time          <fl>)           ;; time of current jump
  ;; (slot ground?            <bool>)         ;; are we currently in contact with the ground
  ;; (slot hover?             <bool>)         ;; are we hovering over ground
  ;; (slot water?             <bool>)         ;; are we in a liquid environment
  ;; (slot water-collision?   <bool>)         ;; are we colliding with a liquid polygon
  ;; (slot shallow-water?     <bool>)         ;; are we in shallow water
  ;; (slot lava?              <bool>)         ;; are we in lava
  ;; (slot swim-timer         <bool>)         ;; time before able to swim up
  ;; (slot water-jump?        <bool>)         ;; jump when we get out of water
  ;; (slot ladder?            <bool>)         ;; are we climbing up a ladder
  ;; (slot ladder-shaft       <vertex+>)      ;; the xz of the shaft we are climbing in
  ;; (slot plates             <list>          ;; list of plates we were on last time tick-actor was called
  ;; (slot rail-dir           <list+>         ;; are we "riding" a rail -> the direction[s] to ride
  ;; (slot last-turn          <vertex+>)      ;; last position where we turned
  ;; (slot last-step          <fl>)           ;; last time we played a step sound
  ;; (slot rotation           <fl>)           ;; rotation for the character model
  ;; (slot orientation        <object>)       ;; vertical or horizontal like for four-legged creatures
  ;; (slot dash               <fl>)           ;; temporary speed increase
  
  (method package (tick-actor self commands <Commands> time <fl> elapse <fl> gravity? collision-response (ignore-entities?: ignore-entities? (ignore-entities? self)) (ignore-players?: ignore-players? (ignore-players? self)) (ignore-me?: ignore-me? (ignore-me? self)) (proportional-slide?: proportional-slide? #t))
    (site tick-actor
      (let ((world (current-world))
            (zone (current-zone))
            (me (current-me+))
            (motion (current-motion))
            (camera (current-camera))
            (history (current-history))
            (ambience (current-ambience))
            (seconds (current-seconds))
            (model (cache-model self))
            (center (transformed-center self))
            (scaling (average-scaling self))
            (sprint-forward? (get-sprint-forward? commands))
            (sprint-backward? (get-sprint-backward? commands)))
        (let ((gravity (or override-gravity (compute-gravity& world center)))
              (area-cube (update-area-cube self))
              (me? (eq? self me))
              (sprint? (or sprint-forward? sprint-backward?))
              (speed #f)
              (animation-speedup #f)
              (displacement (vertex& 0. 0. 0.))
              (grace-slowdown .25)
              (grace-move? #f)
              (floor-level (floor-level world))
              (motion-target? (eq? (motion-target motion) self))
              (old-lookat (lookat-copy& lookat))
              (old-ground? ground?)
              (animation #f)
              (fly? (flying? self)))
          (define (process-commands)
            (when (and (get-modified? commands) (hook-commands world commands))
              ;; move forward
              (when (and (get-move-forward? commands) (not sprint?))
                (when (allow-movement? self)
                  (move move-forward)
                  (animate (move-animation))))
              ;; move backward
              (when (and (get-move-backward? commands) (not sprint?))
                (when (allow-movement? self)
                  (move move-backward)
                  (animate "WalkBackwards")))
              ;; move left
              (when (get-move-left? commands)
                (when (allow-movement? self)
                  (move move-left)
                  (animate (move-animation))))
              ;; move right
              (when (get-move-right? commands)
                (when (allow-movement? self)
                  (move move-right)
                  (animate (move-animation))))
              ;; move up
              (when (get-move-up? commands)
                (move move-up))
              ;; move down
              (when (get-move-down? commands)
                (move move-down))
              ;; sprint forward
              (when sprint-forward?
                (move sprint-forward)
                (animate "Run"))
              ;; sprint backward
              (when sprint-backward?
                (move sprint-backward)
                (animate "Run"))
              ;; rotate left
              (when (get-rotate-left? commands)
                (rotate-left))
              ;; rotate right
              (when (get-rotate-right? commands)
                (rotate-right))))
          
          (define (move proc)
            (cond @wait-liquid ((and water? (>= swim-timer 0.))
                   (proc (* dash water-slowdown scaling) displacement))
                  ((or ground? hover? ladder? fly?)
                   (proc (* dash scaling) displacement))
                  ((and jumping? jump-grace?)
                   (proc (* dash grace-slowdown scaling) displacement)
                   (set! grace-move? #t)
                   (set! jump-grace? #f)))
            (when (> dash-duration 0.)
              (decrease! dash-duration elapse)
              (when (<= dash-duration 0.)
                (set! dash 1.)
                (set! dash-duration 0.)
                (update-parameter world 'dash))))
          
          (define (move-forward factor displacement)
            (set! speed (* factor (vehicle-speed world self) move-slowdown))
            (if rail-dir
                (vertex-increase! displacement (vertex-scalar*& (vertex* (get-sight lookat) (car rail-dir)) speed))
              (vertex-increase! displacement (vertex-scalar*& (get-sight lookat) speed))))
          
          (define (move-backward factor displacement)
            (set! speed (* factor (vehicle-speed world self) move-slowdown))
            (if rail-dir
                (vertex-decrease! displacement (vertex-scalar*& (vertex* (get-sight lookat) (car rail-dir)) speed))
              (vertex-decrease! displacement (vertex-scalar*& (get-sight lookat) speed))))
          
          (define (move-left factor displacement)
            (set! speed (* factor (vehicle-speed world self) move-slowdown))
            (vertex-decrease! displacement (vertex-scalar*& (get-right lookat) speed)))
          
          (define (move-right factor displacement)
            (set! speed (* factor (vehicle-speed world self) move-slowdown))
            (vertex-increase! displacement (vertex-scalar*& (get-right lookat) speed)))
          
          (define (move-up factor displacement)
            (set! speed (* factor (vehicle-speed world self) move-slowdown (if (high-speed?) 2. 1.)))
            (vertex-increase! displacement (vertex-scalar*& (get-up lookat) speed)))
          
          (define (move-down factor displacement)
            (set! speed (* factor (vehicle-speed world self) move-slowdown (if (high-speed?) 2. 1.)))
            (vertex-decrease! displacement (vertex-scalar*& (get-up lookat) speed)))
          
          (define (sprint-forward factor displacement)
            (set! speed (if rail-dir
                            (* factor (vehicle-speed world self))
                          (* factor (vehicle-speed world self) sprint-speed)))
            (if rail-dir
                (vertex-increase! displacement (vertex-scalar*& (vertex* (get-sight lookat) (car rail-dir)) speed))
              (vertex-increase! displacement (vertex-scalar*& (get-sight lookat) speed))))
          
          (define (sprint-backward factor displacement)
            (set! speed (if rail-dir
                            (* factor (vehicle-speed world self))
                          (* factor (vehicle-speed world self) sprint-speed)))
            (if rail-dir
                (vertex-decrease! displacement (vertex-scalar*& (vertex* (get-sight lookat) (car rail-dir)) speed))
              (vertex-decrease! displacement (vertex-scalar*& (get-sight lookat) speed))))
          
          (define (high-speed?)
            (or (key-down? #\3)
                (key-down? #\4)))
          
          (define player-rotation-speed <fl>
            1.3)
          
          (define (rotate-left)
            (rotate-actor (* player-rotation-speed elapse)))
          
          (define (rotate-right)
            (rotate-actor (- (* player-rotation-speed elapse))))
          
          (define (rotate-actor angle)
            (if motion-target?
                (rotate-actor-horizontal motion self angle)
              (rotate-horizontal self angle)))
          
          (define (animate name)
            (set! animation name)
            ;; arbitrary maximum so animation isn't crazy fast
            (set! animation-speedup (and speed (min 2.5 (/ speed (* (model-ground-speed self) scaling animation-slowdown)))))
            (animate/change time name speedup: animation-speedup))
          
          (define (animate/change time name (speedup: speedup #f))
            (let ((old-animation animation-active))
              (animate-model self time name speedup: speedup)
              (world.changes:animate-change seconds self old-animation animation-active)))
          
          (define (move-animation)
            (case self.motion
              ((idle) "Idle")
              ((walk) "Walk")
              ((run) "Run")))
          
          (define (process-velocity)
            (cond ((or ground? hover? ladder? fly? grace-move? @wait-liquid (and water? (moving? commands)))
                   (if rail-dir
                       (vertex-copy! velocity (vertex-scalar*& displacement (/ 2.5 scaling)))
                     (vertex-copy! velocity (vertex-scalar/& displacement scaling))))
                  ((or (not jumping?)
                       (> (- time jump-time) 1.))
                   (let ((friction (get-friction self)))
                     (when friction
                       (let ((reduce <fl> (* friction elapse (if water? 4. 1.))))
                         (if (< (vertex-norm& velocity) reduce)
                             (vertex-zero! velocity)
                           (vertex-decrease! velocity (vertex-scalar*& (vertex-normalize-safe& velocity) reduce)))))))))
          
          (define (process-gravity)
            (let ((normalized-gravity (vertex-normalize& gravity)))
              (if (or jump? (get-jump? commands))
                  (when (and (not rail-dir) (or water-jump? (and jump-ready? (or sprint? water? (and (or ground? ladder?) (not jumping?))))))
                    (unless (or water? water-jump?)
                      (set! jumping? #t)
                      (set! jump-ready? #f)
                      (set! jump-grace? (and (allow-grace? self) (vertex-zero? velocity)))
                      (set! jump-time time))
                    (vertex-copy! fall-velocity (if water?
                                                    (vertex-y-set! fall-velocity (min (+ (vertex-y fall-velocity) 0.02) 0.07))
                                                  (vertex-scalar*& normalized-gravity (* (- (/ (or jump-impulsion (get-jump-impulsion world)) (if water-jump? 1.5 1.))) (cond (sprint? sprint-jump)
                                                                                                                                                                              @wait-liquid
                                                                                                                                                                              (water? (if water-jump? 1. (/ 1. 4.)))
                                                                                                                                                                              (else 1.))))))
                    (when water-jump?
                      (set! water-jump? #f))
                    (set! jump? #f)
                    (set! jump-impulsion #f)
                    (animate/change time :context))
                (unless water?
                  (set! jump-ready? #t)))
              (when (> swim-timer 0.)
                (decrease! swim-timer elapse)
                (when (<= swim-timer 0.)
                  (set! swim-timer 0.)
                  (set! jump-ready? #t)))
              (when (and ground? (vertex-zero? fall-velocity))
                (unless jump-ready?
                  (set! jump-ready? #t))
                (when water-jump?
                  (set! water-jump? #f)))
              (when (> (dot-product& fall-velocity normalized-gravity) (if water? 0.015 max-fall-speed))
                (if water?
                    (vertex-y-set! fall-velocity (* (vertex-y fall-velocity) 0.85))
                  (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity max-fall-speed))))))
          
          (define (collide-actor)
            (break-logic slide)
            (when (get-debug-collisions?)
              (reset-marks zone))
            (let* ((radiuses (transformed-radiuses self))
                   (pumps (and (not water?) (effective-pumps self)))
                   (pumped-center (if pumps
                                      (bind-values (pumped pumped-direction pumped-collisions) (collide&stop$ center (vertex+& center pumps) lookat radiuses area-cube: area-cube ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me?)
                                        (free-collisions$ pumped-collisions)
                                        pumped)
                                    center))
                   (target-center (vertex+& pumped-center (vertex-scalar*& velocity elapse)))
                   (collide$ (case collision-response ((stop) collide&stop$) ((slide) collide&slide$))))
              ;; slide
              (bind-values (new-center slide-direction slide-collisions) (collide$ pumped-center target-center lookat radiuses area-cube: area-cube include-back-facing?: #t ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: proportional-slide? debuggable-collisions?: #t)
                (bind-values (new-slide-collisions slide-water?) (filter-water-collisions slide-collisions #t) ;; set water? with both slide and fall
                  @wait-liquid
                  (when slide-water?
                    (bind-values (new-center-2 slide-direction-2 slide-collisions-2) (collide$ pumped-center target-center lookat radiuses area-cube: area-cube @wait-liquid_polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t)
                      (vertex-copy! new-center new-center-2)
                      (free-collisions$ slide-collisions)
                      (set! slide-collisions slide-collisions-2)))
                  (let ((new-center (if pumps
                                        (bind-values (unpumped unpumped-direction unpumped-collisions) (collide&stop$ new-center (vertex-& new-center pumps) lookat radiuses area-cube: area-cube @wait-liquid_polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me?)
                                          (free-collisions$ unpumped-collisions)
                                          unpumped)
                                      new-center)))
                    ;; kind of a quick hack so we dont slide farther than the player
                    (when (and (not proportional-slide?) (not jumping?))
                      (adjust-fast-slide! self center new-center))
                    (break-action
                      (when (in-logic?)
                        (move-actor new-center #f)))
                    (if (or (not gravity?) fly?)
                        (values new-center slide-collisions '())
                      (let ((adjusted-elapse (* elapse 50.)))
                        (define (xz-position&)
                          (vertex& (+ (fxceiling (get-x self)) .5) 0. (+ (fxceiling (get-z self)) .5)))
                        
                        ;; ladder
                        (set! ladder? (some? (lambda (collision) (= (decode-id (get-data1 (get-polygon collision))) 65)) slide-collisions))
                        (cond (ladder?
                               (when (not ladder-center)
                                 (set! ladder-center (make-vertex))
                                 (for-each (lambda (collision)
                                             (let ((polygon (get-polygon collision)))
                                               (when (= (decode-id (get-data1 polygon)) 65)
                                                 (let ((center (get-center polygon))
                                                       (normal (get-normal polygon)))
                                                   (vertex+! ladder-center center (vertex-scalar*& normal .45))
                                                   (vertex-y-set! ladder-center 0.)
                                                   (set! ladder-orientation (if (>= (abs (vertex-x normal)) .5) 'x 'z))))))
                                           slide-collisions))
                               (when (not ladder-shaft)
                                 (set! ladder-shaft (make-vertex)))
                               (vertex-copy! ladder-shaft (xz-position&)))
                              (else
                               (when ladder-shaft
                                 (if (vertex=? (xz-position&) ladder-shaft)
                                     (if (not-null? slide-collisions)
                                         (set! ladder? #t)
                                       ;; slow fall
                                       (set! adjusted-elapse (/ adjusted-elapse 3.)))
                                   (set! ladder-shaft #f)
                                   (set! ladder-center #f)))))
                        
                        (break-logic fall)
                        (break-action
                          (when (get-debug-collisions?)
                            (reset-marks zone)))
                        @wait-liquid
                        (when water?
                          (set! adjusted-elapse (/ adjusted-elapse 1.5)))
                        (vertex+! fall-velocity fall-velocity (vertex-scalar*& gravity adjusted-elapse))
                        (cond (rail-dir
                               (vertex! fall-velocity 0. -.20 0.))
                              (ladder?
                               (case ladder-orientation
                                 ((x)
                                  (vertex-x-set! fall-velocity 0.)
                                  (vertex-y-set! fall-velocity .075)
                                  (vertex-z-set! fall-velocity (/ (- (vertex-z ladder-center) (get-z self)) 5.)))
                                 ((z)
                                  (vertex-x-set! fall-velocity (/ (- (vertex-x ladder-center) (get-x self)) 5.))
                                  (vertex-y-set! fall-velocity .075)
                                  (vertex-z-set! fall-velocity 0.)))))
                        (let ((target-fall (vertex+& new-center (vertex+& (vertex-scalar*& fall-velocity adjusted-elapse) (vertex-scalar*& gravity (* .5 adjusted-elapse adjusted-elapse))))))
                          (if (vertex-near? target-fall new-center)
                              #f
                            ;; fall
                            ;; megahack around many edge / point collision snags when jumping next to blocks (AM)
                            (bind-values (new-fall fall-direction fall-collisions) (collide&stop$ new-center target-fall lookat radiuses area-cube: area-cube include-back-facing?: #t ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t megahack?: (and me? (or jumping? ladder? ladder-shaft)))
                              (break-action
                                (when (in-logic?)
                                  (move-actor new-fall #f)))
                              (let ((new-fall-collisions fall-collisions @wait-liquid (liquid? fall-collisions slide-water?)))
                                @wait-liquid
                                (if water-collision?
                                    (begin
                                      (unless shallow-water?
                                        (set! shallow-water? #t)
                                        (when me?
                                          (change-ambience ambience error?: #f)))
                                      (bind-values (new-fall-2 fall-direction other-fall-collisions) (collide&stop$ new-center target-fall lookat radiuses area-cube: area-cube @wait-liquid_polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t)
                                        (vertex-copy! new-fall new-fall-2)
                                        (free-collisions$ fall-collisions)
                                        (set! fall-collisions other-fall-collisions)))
                                  ;; going from shallow to water
                                  (when (and water? shallow-water?)
                                    (set! shallow-water? #f)
                                    (when me?
                                      (play-ambience ambience (find-asset world "ambience/warcraft/water/Underwater.ogg")))))
                                (vertex-copy! new-fall (or (manage-fall-collisions fall-collisions) new-fall))
                                (values new-fall slide-collisions fall-collisions))))))))))))
          
          (define (manage-fall-collisions fall-collisions)
            (manage-plates fall-collisions)
            (manage-rails fall-collisions))
          
          (define (manage-plates fall-collisions)
            (define (common-list-elements l1 l2)
              (let ((common '()))
                (for-each (lambda (element)
                            (when (member? element l2)
                              (set! common (cons element common))))
                          l1)
                common))
            
            (let ((new-pp '())
                  (to-add '())
                  (to-remove '()))
              (for-each (lambda (coll)
                          (when (memq? (decode-id (get-data1 (get-polygon coll))) '(70 72))
                            (let ((poly (get-polygon coll)))
                              (set! new-pp (cons (polygon-position poly) new-pp)))))
                        fall-collisions)
              (let ((common (intersection test: equal? new-pp plates)))
                (set! to-add (list-copy new-pp))
                (set! to-remove (list-copy plates))
                (for-each (lambda (com)
                            (set! to-add (remove com to-add test: equal?))
                            (set! to-remove (remove com to-remove test: equal?)))
                          common)
                (plates-update (current-universe) to-add to-remove self)
                (set! plates new-pp))))
          
          (define (manage-rails fall-collisions)
            (let ((rail (find-if (lambda (coll) (and (memq? (decode-id (get-data1 (get-polygon coll))) '(27 28 66)) (get-polygon coll))) fall-collisions return: 'result))
                  (pos #f))
              (if rail
                  (call-with-position zone (vertex& (get-data2 rail) (get-data3 rail) (get-data4 rail))
                    (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                      (let ((data (if (memq? block-id '(27 28)) (bit-set data-id 3 #f) data-id)))
                        (let ((curved? (> data 5)))
                          (if (not curved?)
                              (begin
                                (let ((dir (if (memq? data '(0 4 5)) #f64(0. 0. 1.) #f64(1. 0. 0.)))) ;; N W
                                  (let ((angle (vector-angle (get-sight lookat) dir))
                                        (dist (vertex-norm& (vertex*& (vertex-& position (vertex& x y z)) (if (memq? data '(0 4 5)) #f64(1. 0. 0.) #f64(0. 0. 1.))))))
                                    (if (and (or (< angle (degree->radian 10.)) (> angle (degree->radian 170.))) (< dist .2))
                                        (unless rail-dir
                                          (set! rail-dir (list dir)))
                                      (set! rail-dir #f))))
                                (set! last-turn #f))
                            (let ((dir1 (if (memq? data '(6 7)) #f64(0. 0. 1.) #f64(0. 0. -1.)))
                                  (dir2 (if (memq? data '(6 9)) #f64(1. 0. 0.) #f64(-1. 0. 0.))))
                              (let ((curve (curve-angle (get-sight lookat) dir1 dir2)))
                                (when rail-dir
                                  (unless (and last-turn (vertex=? (vertex& x (- y .5) z) last-turn))
                                    (set! pos (vertex x y z))
                                    (set! last-turn (vertex x (- y .5) z))
                                    (set! rail-dir (let ((dir (cdr rail-dir)))
                                                     (if (null? dir)
                                                         #f
                                                       dir)))
                                    (rotate-actor curve))))))))))
                (set! rail-dir #f)
                (set! last-turn #f))
              pos))
          
          (define (curve-angle sight d1 d2)
            (let ((a1 (vector-angle sight d1))
                  (a2 (vector-angle sight d2))
                  (main-dir (make-vertex))
                  (curve (degree->radian 90.)))
              (cond ((> a1 (degree->radian 170.))
                     (vertex-copy! main-dir d1)
                     (set! curve (* curve -1. (vertex-x d2) (vertex-z main-dir)))
                     (unless last-turn
                       (set! rail-dir (list (vertex-abs main-dir) d2))))
                    ((> a2 (degree->radian 170.))
                     (vertex-copy! main-dir d2)
                     (set! curve (* curve (vertex-z d1) (vertex-x main-dir)))
                     (unless last-turn
                       (set! rail-dir (list (vertex-abs main-dir) d1))))
                    (else
                     (set! rail-dir #f)
                     (set! last-turn #f)))
              curve))
          
          @wait-liquid
          (define (liquid? fall-collisions slide-water?)
            (let ((new-collisions (make-queue$))
                  (water-polygons (make-queue$))
                  (lava-collision? #f))
              (for-each (lambda (collision)
                          (let ((poly (get-polygon collision)))
                            (if (get-liquid-cube? (id->block (decode-id (get-data1 poly))))
                                (begin
                                  (when (memq? (decode-id (get-data1 poly)) '(10 11))
                                    (set! lava-collision? #t))
                                  (enqueue water-polygons poly))
                              (enqueue new-collisions collision))))
                        fall-collisions)
              (if (and (queue-empty? water-polygons) (not slide-water?))
                  (begin
                    (set! water-collision? #f)
                    (when water?
                      (unless (get-liquid-cube? (id->block (block-at-center self)))
                        (exit-water self))))
                (unless water?
                  (when (> (abs (vertex-y fall-velocity)) 1.)
                    (play-3d-sound "warcraft/water/EnterWaterSmallA" position))
                  (enter-water self lava-collision? time)
                  (set! grace-move? #f))
                (unless water-collision?
                  (set! water-collision? #t)))
              (let ((lst (queue-list new-collisions)))
                (free-queue$ new-collisions)
                (free-queue$ water-polygons)
                lst)))
          
          @wait-liquid
          (define (liquid-filter poly)
            (not (get-liquid-cube? (id->block (decode-id (get-data1 poly))))))
          
          (define (hit-action slide-collisions)
            (define (find-actionable)
              (continuation-capture
                (lambda (found)
                  (for-each (lambda (collision)
                              (let ((poly (get-polygon collision)))
                                (when (= (decode-id (get-data1 poly)) 90)
                                  (continuation-return found poly))))
                            slide-collisions)
                  #f)))
            
            (let ((poly (find-actionable)))
              (and poly
                   (let ((id (decode-id (get-data1 poly)))
                         (pos (polygon-position poly)))
                     (cond ;; portal
                           ((= id 90)
                            (world.generation:invoke-block-action pos 'teleport))
                           (else
                            #f))))))
          
          (define (hit-collisions new-center slide-collisions fall-collisions)
            (define (ground-update flag velocity)
              (when (neq? ground? flag)
                (set! ground? flag)
                (if velocity
                    (begin
                      (set! override-gravity #f)
                      (hit-ground self velocity))
                  (leave-ground self))))
            
            (hit self slide-collisions)
            (let ((floor-level (and floor-level (+ floor-level (get-radius-y self))))
                  (velocity (copy-vertex fall-velocity)))
              (if (and floor-level (< (vertex-y new-center) floor-level) (not fly?))
                  (begin
                    (hit-floor self velocity)
                    (vertex-y-set! new-center floor-level)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))
                (let ((fall-collided? (not-null? fall-collisions))
                      (water-only? (null? (filter-water-collisions fall-collisions #f))))
                  (if (not fall-collided?)
                      (ground-update #f #f)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update (not water-only?) velocity))))))
          
          (define (filter-water-collisions fall-collisions slide?)
            @wait-liquid
            (define (not-water? collision)
              (liquid-filter (get-polygon collision)))
            
            ;; optimize the by far most common case
            (if #t @wait-liquid (every? not-water? fall-collisions)
                (if slide?
                    (values fall-collisions #f)
                  fall-collisions)
              @wait-liquid
              (let ((new-collisions (collect-if not-water? fall-collisions)))
                (if slide?
                    (values new-collisions #t)
                  new-collisions))))
          
          (define (foot-step fall-collisions)
            (when (and me? (get-steps? model) (or ground? @not-really-nice ladder?) @wait-liquid (or (not water?) shallow-water?) morphing)
              (let ((speed (vertex-norm& velocity)))
                (when (> speed 0.)
                  ;; two steps for each animation
                  (let ((step-time (/ (effective-duration morphing) 2.)))
                    (when (> (- time last-step) step-time)
                      (set! last-step time)
                      (let ((kind (cond @not-really-nice
                                    (ladder?
                                     'ladder)
                                    @wait-liquid
                                    ((and water? shallow-water?)
                                     'water)
                                    ((null? fall-collisions)
                                     'stone)
                                    (else
                                     (let ((collision (car fall-collisions)))
                                       (let ((id (decode-id (get-data1 (get-polygon collision)))))
                                         (case id
                                           ((2) 'grass)
                                           ((5) 'wood)
                                           ((12 13) 'dirt)
                                           ((78 79 80) 'snow)
                                           (else 'stone))))))))
                        (let ((step (random-step kind)))
                          (when step
                            (play-ambient-sound step volume: .075))))))))))
          
          (define (move-actor new-center (calculate? #t))
            (let ((movement (vertex- new-center center)))
              (let ((new-position (vertex+& position movement))
                    (old-position (vertex-copy& position))
                    (old-velocity (vertex-copy& effective-velocity))
                    (old-fall-velocity (vertex-copy& fall-velocity)))
                (vertex+! effective-velocity velocity fall-velocity)
                (when (and calculate? (moving? commands))
                  (set! velocity-angle (abs (- 90. (radian->degree (vector-angle (vertex*& (vertex-& new-position old-position) (vertex& 1. 0. 1.)) (get-sight lookat)))))))
                (set-position self new-position)
                (vertex-copy! center new-center)
                (unless (vertex-near? old-position new-position)
                  (refresh-compass world))
                (world.changes:move-change seconds self commands elapse old-position new-position old-velocity velocity old-fall-velocity fall-velocity old-ground? ground?)
                movement)))
          
          (define (rotate-model movement)
            (when me?
              (let ((distance (/ (dot-product& (get-sight lookat) movement) (get-radius self))))
                (define (set-x-rotation model name)
                  (let ((model (child model name)))
                    (vertex-x-set! (get-rotation model) rotation)
                    (update-matrix model)))
                
                (when (/= distance 0.)
                  (decrease! rotation distance)
                  (when (and (eq? (get-name model) 'Orb) (not fly?))
                    (set-x-rotation model 'body))
                  (when (memq? (vehicle-name self) '(Wheels Hummer))
                    (set-x-rotation (cache-model vehicle) 'wheel1)
                    (set-x-rotation (cache-model vehicle) 'wheel2)
                    (set-x-rotation (cache-model vehicle) 'wheel3)
                    (set-x-rotation (cache-model vehicle) 'wheel4))))))
          
          (define (realign-actor slide-collisions fall-collisions)
            (when (and gravity? (not fly?))
              (update-world-up world gravity)
              (case @until-horizontal-debugged orientation 'vertical
                ((vertical)
                 (realign-lookat self (gravity-up& gravity)))
                ((horizontal)
                 (when (or (not-null? slide-collisions)
                           (not-null? fall-collisions))
                   (let ()
                     (define (average-normal)
                       (let ((factor-sum 0.)
                             (dir-sum (make-zero-vertex)))
                         (define (process-collisions collisions)
                           (for-each (lambda (collision)
                                       (let ((plane (get-plane collision)))
                                         (let ((origin (get-origin plane))
                                               (normal (get-normal plane)))
                                           (let ((dist (vertex-distance& origin center)))
                                             (let ((factor (/ (+ 1. dist))))
                                               (increase! factor-sum factor)
                                               (vertex+! dir-sum dir-sum (vertex-scalar*& normal factor-sum)))))))
                                     collisions))
                         
                         (process-collisions slide-collisions)
                         (process-collisions fall-collisions)
                         (vertex-scalar/& dir-sum factor-sum)))
                     
                     ;; this is clearly buggy and can create an up with y != 1 on a flat floor (AM)
                     (remove-lookat-up-roll self (average-normal) lookat)))))))
          
          (define (realign-horizon)
            (when (and gravity? (not fly?) motion-target? (is? motion Person-Motion))
              (let ((final-gravity (compute-gravity world center)))
                (set-lookat camera (realign-lookat-horizon& (get-lookat camera) (get-up lookat) gravity final-gravity))
                (camera-update camera))))
          
          (define (center-eye)
            (when motion-target?
              (without-roll self
                (lambda ()
                  (eye-center-player motion)))))
          
          (define (verify-death)
            @wait-liquid
            (when lava?
              (damage self 1. #f))
            (when (and die-bottom (< (get-y self) die-bottom))
              (damage self 100. #f)
              ;; this death is client responsibility
              (when (and (client?) (<= life 0.))
                (world.changes:die-change self))))
          
          (process-commands)
          (process-velocity)
          (process-gravity)
          (when (not animation)
            (animate/change time :context))
          (let ((collide-info (collide-actor)))
            (and collide-info
                 (bind-values (new-center slide-collisions fall-collisions) collide-info
                   (and (not (hit-action slide-collisions))
                        (begin
                          (hit-collisions new-center slide-collisions fall-collisions)
                          (if (not alive?)
                              (begin
                                (free-collisions$ slide-collisions)
                                (free-collisions$ fall-collisions)
                                #f)
                            @wait-zero-initial-impact
                            (foot-step fall-collisions)
                            (let ((movement (move-actor new-center)))
                              (rotate-model movement)
                              (realign-actor slide-collisions fall-collisions)
                              (free-collisions$ slide-collisions)
                              (free-collisions$ fall-collisions)
                              (unless (lookat-near? old-lookat lookat)
                                (refresh-compass world))
                              (world.changes:lookat-change seconds self commands elapse old-lookat lookat)
                              (and (not (vertex-zero? movement))
                                   (begin
                                     (realign-horizon)
                                     (center-eye)
                                     (verify-death)
                                     collide-info)))))))))))))
  
  
  (method package virtual (tick-slice self)
    #f)
  
  
  (method protected virtual (effective-pumps self)
    #f)
  
  
  (method package virtual (ignore-entities? self)
    #t)
  
  
  (method package virtual (ignore-players? self)
    #f)
  
  
  (method package virtual (ignore-me? self)
    #f)
  
  
  (method protected virtual (hit self collisions)
    )
  
  
  (method protected virtual (hit-floor self velocity)
    )
  
  
  (method protected virtual (hit-ground self velocity)
    (define fall-conversion-a <fl>
      (/ 1. .18))
    
    (define fall-conversion-b <fl>
      (/ 1. .51))
    
    (define (blocks-fallen speed)
      (fxround (expt (* speed fall-conversion-a) fall-conversion-b)))
    
    (unless ladder?
      (let ((fall-speed (abs (vertex-y velocity)))
            (minimum-speed .7))
        (when (> fall-speed minimum-speed)
          (let ((amount (* 4 (- (blocks-fallen fall-speed) 5))))
            (damage self amount #f))))))
  
  
  (method protected virtual (leave-ground self)
    )
  
  
  (method package virtual (ground-speed self)
    (case motion
      ((idle) 0.)
      ((walk) (walk-speed self))
      ((run) (run-speed self))))
  
  
  (method protected virtual (walk-speed self)
    (model-walk-speed self))
  
  
  (method protected virtual (run-speed self)
    (model-run-speed self))
  
  
  (method (model-ground-speed self)
    (case motion
      ((idle) 0.)
      ((walk) (model-walk-speed self))
      ((run) (model-run-speed self))))
  
  
  (method (model-walk-speed self)
    (or (get-walk-speed (cache-model self)) default-walk-speed))
  
  
  (method (model-run-speed self)
    (or (get-run-speed (cache-model self)) default-run-speed))
  
  
  (method protected virtual (allow-movement? self)
    #t)
  
  
  (method protected virtual (allow-grace? self)
    #t)
  
  
  (method protected virtual (adjust-fast-slide! self center new-center)
    )
  
  
  (method package (rotate-horizontal self angle)
    (let ((world (current-world)))
      (let ((up (get-world-up world)))
        (set-lookat self (rotate-lookat& lookat angle up))
        (update-matrix self))))
  
  
  ;;;
  ;;;; Type
  ;;;
  
  
  (method protected virtual (is-player? self)
    #f)
  
  
  (method package virtual (is-missile? self)
    #f)
  
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method override (animated self)
    (set! animated? #t))
  
  
  (method override (unanimated self)
    (set! animated? #f))
  
  
  (method protected virtual (animate-model self time name (speedup: speedup #f) (duration: duration #f) (next: next #f))
    (let ((elapse-before-fall .5)
          (jump-start-frame 8.))
      (let ((fall? (not ground?)))
        (unless jumping?
          (if fall?
              (when (not animation-fall)
                (set! animation-fall time))
            (set! animation-fall #f)))
        (when (or (not animation-fall)
                  (equal? name :context)
                  ;; to not switch non-stop between run and fall while running down a slope
                  (> (- time animation-fall) elapse-before-fall))
          (let ((model (cache-model self)))
            (when (get-animations model)
              (let ()
                (define (determine-animation proc)
                  (cond ((or (eq? motion 'idle) (and vehicle ground?)) (proc '("Idle") #f))
                        @wait-liquid
                        ((and water? (not shallow-water?)) (proc (if (eq? name :context) '("SwimIdle" "Idle") '("Swim" "Run")) #f))
                        (jumping? (proc '("JumpStart" "Jump" "Fall" "Idle") (list "Jump" "Fall" "Idle")))
                        ((and fall? (not ladder?)) (proc '("Fall" "Idle") #f))
                        (else (proc (if (eq? name :context)
                                        (cond (animation-once
                                               (list animation-once))
                                              (animation-continuous
                                               (list animation-continuous))
                                              (else
                                               (list "Idle")))
                                      (listify name))
                                    #f))))
                
                (define (existing-animation animation-list)
                  (let (iter (scan animation-list))
                    (if (or (not scan)
                            (null? scan))
                        #f
                      (let ((animation (car scan)))
                        (if (find-animation model animation)
                            animation
                          (iter (cdr scan)))))))
                
                ;; simple pragmatic solution
                (define (effective-speedup animation speedup)
                  (if (or (equal? animation "Run")
                          ;; used for run backwards at the moment
                          (equal? animation "WalkBackwards"))
                      speedup
                    #f))
                
                (define (animation-change name)
                  (let ((old-animation animation-active))
                    (set! animation-active name)
                    (world.changes:animate-change (current-seconds) self old-animation animation-active)))
                
                (determine-animation
                  (lambda (animation-list next-list)
                    (let ((animation (existing-animation animation-list)))
                      (if (not animation)
                          (error "No animation found in: {l detail: :human separator: \", \"}" animation-list)
                        (let ((next (existing-animation next-list))
                              (speedup (effective-speedup animation speedup)))
                          (unless (and (equal? animation-active animation)
                                       (equal? animation-speedup speedup))
                            (let ((previous animation-active))
                              (let ((was-falling? (or (equal? previous "JumpStart")
                                                      (equal? previous "Jump")
                                                      (equal? previous "Fall"))))
                                (cond ((and animation-once (equal? animation animation-once))
                                       (when morphing
                                         (transition-morphing self animation next: "Idle" next-proc: (lambda (name) (set! animation-once #f))))
                                       (set! animation-active animation)
                                       (set! animation-speedup #f))
                                      ((and animation-continuous (equal? animation animation-continuous))
                                       (when morphing
                                         (transition-morphing self animation))
                                       (set! animation-active animation)
                                       (set! animation-speedup #f))
                                      ((and was-falling? (equal? animation "Idle"))
                                       (let ((animation (existing-animation '("JumpEnd" "Idle"))))
                                         (when morphing
                                           (change-morphing self animation next: "Idle" next-proc: animation-change))
                                         (set! animation-active animation)
                                         (set! animation-speedup #f)
                                         (set! animation-once #f)
                                         (set! animation-continuous #f)))
                                      ((and was-falling? (equal? animation "Run"))
                                       (let ((animation (existing-animation '("JumpLandRun" "Run"))))
                                         (when morphing
                                           (change-morphing self animation next: "Run" next-proc: animation-change))
                                         (set! animation-active animation)
                                         (set! animation-speedup #f)
                                         (set! animation-once #f)
                                         (set! animation-continuous #f)))
                                      (else
                                       (unless (and was-falling? (equal? animation "JumpStart"))
                                         (unless (and morphing (equal? animation (get-animation-next morphing)))
                                           (unless (and morphing (equal? animation (get-name (get-animation morphing))))
                                             (let ((frame (if (equal? animation "JumpStart") jump-start-frame #f))
                                                   (duration (if (equal? previous "Idle") .1 #f)))
                                               (when morphing
                                                 (transition-morphing self animation frame: frame speedup: speedup duration: duration next: next next-proc: animation-change))
                                               (set! animation-active animation)
                                               (set! animation-speedup speedup)
                                               (set! animation-once #f)
                                               (set! animation-continuous #f))))))))))))))))))))))
  
  
  ;;;
  ;;;; Simulation
  ;;;
  
  
  (method package (run-simulation self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-monotonic)))
            (with-task-mutex
              (lambda ()
                (unless (stopping? task)
                  (let ((elapse (- time previous)))
                    (unless (> elapse max-elapse)
                      (let ((history (current-history)))
                        (unless (get-paused? history)
                          (tick-simulation self elapse))))))))
            (let ((duration (- (current-monotonic) time)))
              (task-wait task simulation-period duration exit))
            (iter time))))))
  
  
  (method (tick-simulation self elapse)
    (site simulation
      @only-me-area-cube-for-now
      (simulate-actor self elapse)
      @only-me-area-cube-for-now
      (adjust-motion-target self)
      (animate self elapse)))
  
  
  (method protected virtual (simulate-actor self elapse)
    (let ((target (vertex+& position (vertex-scalar*& (vertex+& effective-velocity fall-velocity) elapse))))
      (set-position self target)))
  
  
  ;;;
  ;;;; Missiles
  ;;;
  
  
  (method package (increase-missiles self)
    (increase! missiles-count))
  
  
  (method package (decrease-missiles self)
    (decrease! missiles-count))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-target self color)
    (draw-target-circle self))
  
  
  ;;;
  ;;;; Travel
  ;;;
  
  
  (method package (activate-travel self mount vehicle)
    (cond ((not mount)
           (activate-trek self))
          ((eq? mount 'ride)
           (activate-ride self vehicle))
          ((eq? mount 'fly)
           (activate-fly self vehicle))))
  
  
  ;;;
  ;;;; Trek
  ;;;
  
  
  (method package (trekking? self)
    (not mount))
  
  
  (method package (activate-trek self)
    (cond ((riding? self) (deactivate-ride self))
          ((flying? self) (deactivate-fly self))))
  
  
  ;;;
  ;;;; Ride
  ;;;
  
  
  (method package (riding? self)
    (eq? mount 'ride))
  
  
  (method package (toggle-ride self)
    (let ((history (current-history))
          (world (current-world)))
      (unless (get-paused? history)
        (person-motion world)
        (if (riding? self)
            (world.changes:trek-change self)
          (world.changes:ride-change self (get-current (get-riders-folio world)))))))
  
  
  (method package (activate-ride self vehicle)
    (let ((world (current-world))
          (me (current-me+)))
      (if (eq? mount 'ride)
          (when (neq? (vehicle-name self) vehicle)
            (activate-vehicle self vehicle))
        (set! mount 'ride)
        (set! jumping? #f)
        (activate-vehicle self vehicle)
        (when (eq? self me)
          (update-parameter world 'ride)
          (update-parameter world 'fly)))))
  
  
  (method (deactivate-ride self)
    (let ((world (current-world))
          (me (current-me+)))
      (when (eq? mount 'ride)
        (set! mount #f)
        (activate-vehicle self #f)
        (when (eq? self me)
          (update-parameter world 'ride)
          (update-parameter world 'fly)))))
  
  
  ;;;
  ;;;; Fly
  ;;;
  
  
  (method package (flying? self)
    (eq? mount 'fly))
  
  
  (method package (toggle-fly self)
    (let ((history (current-history))
          (world (current-world)))
      (unless (get-paused? history)
        (person-motion world)
        (if (flying? self)
            (world.changes:trek-change self)
          (world.changes:fly-change self (get-current (get-flyers-folio world)))))))
  
  
  (method package (activate-fly self vehicle)
    (let ((world (current-world))
          (motion (current-motion+))
          (me (current-me+)))
      (if (eq? mount 'fly)
          (when (neq? (vehicle-name self) vehicle)
            (activate-vehicle self vehicle))
        (let ((motion-target? (and (client?) (eq? (motion-target motion) self)))
              (me? (eq? self me)))
          (set! mount 'fly)
          (set! jumping? #f)
          (set-position self (vertex+& (get-position self) (vertex& 0. 0.1 0.)))
          (activate-vehicle self vehicle)
          (when motion-target?
            ;; quick hack for orb
            (when (is? motion Target-Motion)
              (adjust-player-alpha motion))
            (follow-player motion))
          (when me?
            (update-parameter world 'ride)
            (update-parameter world 'fly))))))
  
  
  (method (deactivate-fly self)
    (let ((world (current-world))
          (motion (current-motion+))
          (me (current-me+)))
      (when (eq? mount 'fly)
        (let ((motion-target? (and (client?) (eq? (motion-target motion) self)))
              (me? (eq? self me)))
          (set! mount #f)
          (activate-vehicle self #f)
          (when motion-target?
            ;; quick hack for orb
            (when (is? motion Target-Motion)
              (adjust-player-alpha motion))
            (when (is? motion Person-Motion)
              (exit-fly motion)))
          (when me?
            (update-parameter world 'ride)
            (update-parameter world 'fly))))))
  
  
  ;;;
  ;;;; Vehicle
  ;;;
  
  
  (method package (vehicle-name self)
    (and vehicle (get-model vehicle)))
  
  
  (method package (change-vehicle self name)
    (set! vehicle (and name (new Entity model: name)))
    (update-matrix self))
  
  
  (method package (toggle-vehicle self)
    (let ((world (current-world)))
      (if (not vehicle)
          (bell)
        (let ((folio (if (flying? self) (get-flyers-folio world) (get-riders-folio world))))
          (let ((next (next-element (get-list folio) (get-model vehicle))))
            (set-current folio next)
            (world.changes:vehicle-change self next))))))
  
  
  (method (activate-vehicle self name)
    (change-vehicle self name)
    (when vehicle
      (let ((saddle (get-saddle (cache-model vehicle))))
        (when saddle
          (set-position self (vertex+& (get-position self) (vertex& 0. saddle 0.)))))))
  
  
  (method override (update-matrix self)
    (nextmethod self)
    (when vehicle
      (let ((saddle (get-saddle (cache-model vehicle)))
            (ride-saddle (get-ride-saddle (cache-model self)))
            (fly-saddle (get-fly-saddle (cache-model self)))
            (vehicle-scale (get-vehicle-scale (cache-model self))))
        (if (eq? (get-model vehicle) 'Wheels)
            (set! ride-saddle (/ ride-saddle 3.)))
        (matrix-multiply! (get-matrix vehicle)
                          matrix
                          (make-translation-matrix& (vertex-& (get-position vehicle) (vertex& 0. (+ saddle (if (flying? self) fly-saddle ride-saddle)) 0.)))
                          (make-scaling-matrix& vehicle-scale)))))
  
  
  (method override (register-parts self)
    (nextmethod self)
    (when vehicle
      (world.renderer:register-entity vehicle)))))
