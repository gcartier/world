;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Actors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.actor jazz


(import (jazz.geometry)
        (jazz.platform)
        (jazz.syntax (phase syntax))
        (world)
        (world.area)
        (world.audio)
        (world.autoload)
        (world.change)
        (world.changes)
        (world.collision)
        (world.configure)
        (world.commands)
        (world.dye)
        (world.element)
        (world.entity)
        (world.folio)
        (world.generation.block)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.log)
        (world.model)
        (world.motion)
        (world.parts)
        (world.polygon)
        (world.queue)
        (world.scripter)
        (world.settings)
        (world.spell)
        (world.support)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Actor
;;;


(definition *global-cooldown*
  0.5)

(definition protected max-fall-speed <fl>
  2.75)

(definition protected die-bottom <fl>
  -180.)

(definition protected water-slowdown <fl>
  0.75)


(definition default-walk-speed
  3.)

(definition default-run-speed
  6.)


(definition sprint-speed <fl>
  (world-setting 'world.sprint-speed 5.))

(definition blink-speed <fl>
  (world-setting 'world.blink-speed 5.))

(definition sprint-jump <fl>
  (world-setting 'world.sprint-jump 2.))

(definition blink-jump <fl>
  (world-setting 'world.blink-jump 1.5))


(definition protected base-armor <fl>
  (world-setting 'world.base-armor 20.))

(definition protected base-power <fl>
  (world-setting 'world.base-power 10.))

(definition protected base-ranged-power <fl>
  (world-setting 'world.base-ranged-power 10.))


(definition protected max-missiles <fx>
  10)


(class Actor extends Entity
  

  ;; backward compatibility quicky for sejour  
  (property mount?              <bool>       initialize #f                 accessors generate)
  ;; backward compatibility quicky for sejour
  (property fly?                <bool>       initialize #f                 accessors generate)
  (property mount               <symbol+>    initialize #f                 accessors generate)
  
  (slot velocity                <vertex>     initialize (make-zero-vertex) getter generate)
  (slot fall-velocity           <vertex>     initialize (make-zero-vertex) getter generate)
  (slot effective-velocity      <vertex>     initialize (make-zero-vertex) getter generate)
  (slot velocity-angle          <fl>         initialize 0.                 getter generate)
  (slot motion                  <symbol>     initialize 'walk              accessors generate)
  (slot vehicle                 <Entity+>    initialize #f                 accessors generate)
  (slot riders-folio            <Folio>      initialize #f                 accessors generate)
  (slot flyers-folio            <Folio>      initialize #f                 accessors generate)
  (slot life                    <fl>         initialize 100.               accessors generate)
  (slot alive?                  <bool>       initialize #t                 accessors generate)
  (slot global-cooldown         <fl>         initialize 0.                 accessors generate)
  (slot spell                   <Spell+>     initialize #f                 accessors generate)
  (slot adjustments             <list>       initialize '()                accessors generate)
  (slot rapid-fire-acceleration <fl>         initialize 1.                 accessors generate)
  (slot rapid-fire-duration     <fl>         initialize 0.                 accessors generate)
  (slot rapid-fire-cooldown     <fl>         initialize 0.                 accessors generate)
  (slot last-missile            <fl+>        initialize #f                 accessors generate)
  (slot missiles-count          <fx>         initialize 0                  accessors generate)
  (slot history-color           <object>     initialize #f                 accessors generate)
  (slot sprint?                 <bool>       initialize #f                 accessors generate)
  (slot jumping?                <bool>       initialize #f                 accessors generate)
  (slot jump-ready?             <bool>       initialize #f                 accessors generate)
  (slot jump-grace?             <bool>       initialize #f                 accessors generate)
  (slot jump-time               <fl>         initialize 0.                 accessors generate)
  (slot ground?                 <bool>       initialize #f                 accessors generate)
  (slot hover?                  <bool>       initialize #f                 accessors generate)
  (slot water?                  <bool>       initialize #f                 accessors generate)
  (slot water-collision?        <bool>       initialize #f                 accessors generate)
  (slot shallow-water?          <bool>       initialize #f                 accessors generate)
  (slot lava?                   <bool>       initialize #f                 accessors generate)
  (slot swim-timer              <fl>         initialize 0.                 accessors generate)
  (slot water-jump?             <bool>       initialize #f                 accessors generate)
  (slot ladder?                 <bool>       initialize #f                 accessors generate)
  (slot ladder-shaft            <vertex+>    initialize #f                 accessors generate)
  (slot plates                  <list>       initialize '()                accessors generate)
  (slot rail-dir                <list+>      initialize #f                 accessors generate)
  (slot last-turn               <vertex+>    initialize #f                 accessors generate)
  (slot last-step               <fl>         initialize 0.                 accessors generate)
  (slot rotation                <fl>         initialize 0.                 accessors generate)
  (slot orientation             <object>     initialize 'vertical          accessors generate)
  (slot dash                    <fl>         initialize 1.                 accessors generate)
  (slot dash-duration           <fl>         initialize 0.                 accessors generate)
  (slot jump?                   <bool>       initialize #f                 accessors generate)
  (slot jump-impulsion          <object>     initialize #f                 accessors generate)
  (slot animation-active        <object>     initialize #f                 accessors generate)
  (slot animation-speedup       <fl+>        initialize #f                 accessors generate)
  (slot animation-fall          <object>     initialize #f                 accessors generate)
  (slot animation-once          <bool>       initialize #f                 accessors generate)
  (slot animation-continuous    <bool>       initialize #f                 accessors generate)
  (slot armor                   <fl>         initialize base-armor         accessors generate)
  (slot armor-factor            <fl>         initialize 1.                 accessors generate)
  (slot power                   <fl>         initialize base-power         accessors generate)
  (slot power-factor            <fl>         initialize 1.                 accessors generate)
  (slot ranged-power            <fl>         initialize base-ranged-power  accessors generate)
  (slot ranged-power-factor     <fl>         initialize 1.                 accessors generate)
  (slot area-cube               <object>     initialize #f                 accessors generate)
  
  
  (method override (finish rest)
    (nextmethod rest)
    (let ((color (copy-dye color)))
      (dye-alpha-set! color .2)
      (set! history-color color))
    (set! riders-folio (new Folio 'Wheels '(Wheels Hummer)))
    (set! flyers-folio (new Folio 'Saucer '(Saucer Rocket)))
    (setup-area-cube))
  
  
  (method protected virtual (setup-area-cube)
    (set! area-cube (new Area-Cube 2)))
  
  
  (method protected virtual (update-area-cube)
    (update-cube~ area-cube position)
    area-cube)
  
  
  (method public inline (set-velocity vel <vertex>) <void>
    (vertex-copy! velocity vel))
  
  
  (method public inline (set-fall-velocity vel <vertex>) <void>
    (vertex-copy! fall-velocity vel))
  
  
  (method public inline (set-effective-velocity vel <vertex>) <void>
    (vertex-copy! effective-velocity vel))
  
  
  (method override (call-model-update model)
    (nextmethod model)
    (set! animation-active #f)
    (set! animation-speedup #f)
    (set! animation-fall #f)
    (set! animation-once #f)
    (set! animation-continuous #f))
  
  
  ;; quick hacks to try and enclose the vehicle in our bounds
  (method override (entity-bounds)
    (if (not vehicle)
        (nextmethod)
      ;; normalize both models to a scaling of 1
      ;; and in the end reapply our own scaling
      (let ((vehicle-model (cache-model~ vehicle)))
        (let ((vehicle-scale (get-scale~ vehicle-model)))
          (let ((bounds (scale-cuboid (get-bounds~ (cache-model)) scale))
                (vehicle-bounds (scale-cuboid (get-bounds~ vehicle-model) vehicle-scale))
                (saddle (get-saddle~ vehicle-model)))
            (let ((translated (if (not saddle) bounds (translate-cuboid bounds (vertex& 0. saddle 0.)))))
              (let ((union (cuboid-union translated vehicle-bounds)))
                (scale-cuboid union (vertex-inverse& scale)))))))))
  
  
  ;; quick hacks to try and enclose the vehicle in our bounds
  (method override (transformed-center)
    (let ((center (nextmethod)))
      (if (not vehicle)
          center
        (let ((vehicle-model (cache-model~ vehicle)))
          (let ((saddle (get-saddle~ vehicle-model)))
            (if (not saddle)
                center
              (vertex+ center (vertex& 0. (- (* saddle (vertex-y (get-scale~ vehicle-model)) (vertex-y scale))) 0.))))))))
  
  
  (method (setup-armor value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.5)
            (max-armor 500.))
        (+ min-factor (* (/ value max-armor) (- max-factor min-factor)))))
    
    (set! armor value)
    (set! armor-factor (calculate-factor)))
  
  
  (method (setup-power value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.5)
            (max-power 160.))
        (+ min-factor (* (/ value max-power) (- max-factor min-factor)))))
    
    (set! power value)
    (set! power-factor (calculate-factor)))
  
  
  (method (setup-ranged-power value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.)
            (max-power 120.))
        (+ min-factor (* (/ value max-power) (- max-factor min-factor)))))
    
    (set! ranged-power value)
    (set! ranged-power-factor (calculate-factor)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (definition missile-delay <fl>
    .1)
  
  
  (method (maybe-fire kind)
    (let ((seconds (current-seconds)))
      (when (or (not last-missile)
                (> (- seconds last-missile) (/ missile-delay rapid-fire-acceleration)))
        (fire kind)
        (set! last-missile seconds))))
  
  
  (method (fire kind)
    (when (person-motion?)
      (let ((direction (aim-direction)))
        (fire-missile direction kind))))
  
  
  (method (fire-missile direction kind)
    (let ((interface (current-interface))
          (world (current-world))
          (game (current-game)))
      (let ((pane (child~ interface 'character)))
        (when (and (< missiles-count max-missiles)
                   (or (neq? kind 'arrow)
                       (> (count-arrows~ pane) 0)))
          (when (eq? kind 'arrow)
            (use-arrow~ pane))
          (let ((lens (lens-center))
                (adjusted-radius (* (get-radius-x) 2.)))
            (let ((pos (vertex+& lens (vertex-scalar*& direction adjusted-radius))))
              (world.missile:fire-change pos direction kind self)))
          (attack kind)))))
  
  
  (method override (lens-center)
    (let ((model (cache-model)))
      (let ((center (get-center~ model))
            (bounds (get-bounds~ model))
            (eye-level (let ((name (get-name~ model)))
                         (if (orb? name)
                             .15
                           ;; why is the division necessary?
                           (+ (/ (or (get-lens~ model) .8) 2.)
                              (case (vehicle-name)
                                ((Saucer Rocket) .10)
                                ((Hummer) .23)
                                (else 0.)))))))
        ;; aec quicky
        (let ((model-lens (vertex 0. (+ (vertex-y center) (* (cuboid-height bounds) eye-level)) 0.)))
          (matrix-transform-3x4 matrix model-lens)))))
  
  
  (method (aim-direction)
    (let ((world (current-world)))
      (let ((eye (get-eye~ world)))
        (if (get-free-aim?~ world)
            (get-sight~ eye)
          (cross-normal (get-up~ eye) (get-right~ lookat))))))
  
  
  (method (start-rapid-fire)
    (set! rapid-fire-acceleration 3.)
    (set! rapid-fire-duration 15.)
    (set! rapid-fire-cooldown 45.))
  
  
  (method (warp-forward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) 2.)))
      (follow-player~ world)))
  
  
  (method (warp-backward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) -2.)))
      (follow-player~ world)))
  
  
  (method (start-dash)
    (let ((world (current-world)))
      (set! dash 5.)
      (set! dash-duration 10.)
      (update-parameter~ world 'dash)))
  
  
  (method public virtual (damage amount critical?)
    (play-3d-sound-if (if critical? (wound-critical-sound) (wound-sound)) position)
    @w
    (let ((animation (if critical? "CombatCritical" "CombatWound")))
      (when (find-animation~ (cache-model) animation)
        (set! animation-once animation)))
    (decrease! life amount)
    ;; only server kills
    (when (and (<= life 0.) (not (client?)))
      (die-change self)))
  
  
  (method protected virtual (attacking?)
    #f)
  
  
  (method protected virtual (attack kind)
    )
  
  
  (method protected virtual (attack-amount factor amount)
    (* amount factor))
  
  
  (method public virtual (wound inflictor factor (amount #f))
    (let ((world (current-world)))
      (let ((critical? (> (random-real) .8)))
        (damage (if amount
                    amount
                  (attack-amount~ inflictor factor (wound-amount critical?)))
                (if amount #f critical?)))))
  
  
  (method public virtual (wound-amount critical?)
    (if critical? 20. 10.))
  
  
  (method public virtual (wound-sound)
    (find-sound 'wound))
  
  
  (method public virtual (wound-critical-sound)
    (find-sound 'wound-critical))
  
  
  (method public virtual (explode inflictor)
    (let ((zone (current-zone))
          (radius 2.))
      (play-3d-sound "sound/spells/ExplosiveShot" position)
      (for-each (lambda (actor)
                  (when (and (<= (vertex-distance& position (get-position~ actor)) radius)
                             (explosion-damage?~ actor))
                    (wound~ actor inflictor (get-ranged-power-factor~ inflictor))))
                (get-actors~ zone))))
  
  
  (method public virtual (explosion-damage?)
    #t)
  
  
  (method public virtual (die)
    (let ((world (current-world)))
      (play-3d-sound-if (death-sound) position)
      (remove-element~ world self)
      (set! alive? #f)))
  
  
  (method public virtual (death-sound)
    (find-sound 'death))
  
  
  (method public virtual (resurrect)
    (let ((zone (current-zone)))
      (add-element~ zone self)
      (set! alive? #t)))
  
  
  (method public virtual (stomp)
    #f)
  
  
  (method protected virtual (get-friction)
    4.)
  
  
  (method protected (block-at-center)
    (let ((zone (current-zone)))
      (block-at~ zone (transformed-center))))
  
  
  (method protected (enter-water lava? (time 0.))
    (set! jumping? #f)
    (set! jump-time time)
    (set! water-jump? #f)
    (set! water? #t)
    (set-lava?~ self lava?))
  
  
  (method protected (exit-water (forced? #f))
    (set! swim-timer 0.)
    (set! shallow-water? #f)
    (set! water? #f)
    (set! lava? #f)
    (set! water-jump? (not forced?)))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  ;; (slot position           <vertex>)       ;; position
  ;; (slot lookat             <LookAt>)       ;; lookat is always perpendicular to gravity
  ;; (slot scale              <vertex>)       ;; scale
  ;; (slot matrix             <matrix>)       ;; matrix
  ;; (slot radiuses           <vertex+>)      ;; radiuses
  ;; (slot radius             <fl+>)          ;; radius
  ;; (slot velocity           <vertex>)       ;; velocity
  ;; (slot fall-velocity      <vertex>)       ;; fall-velocity
  ;; (slot effective-velocity <vertex>)       ;; velocity + fall-velocity
  ;; (slot velocity-angle     <fl>)           ;; real displacement / elapse
  ;; (slot jumping?           <bool>)         ;; are we currently jumping
  ;; (slot jump-ready?        <bool>)         ;; so holding the jump key only jumps once
  ;; (slot jump-grace?        <bool>)         ;; a standing jump allows us one last move
  ;; (slot jump-time          <fl>)           ;; time of current jump
  ;; (slot ground?            <bool>)         ;; are we currently in contact with the ground
  ;; (slot hover?             <bool>)         ;; are we hovering over ground
  ;; (slot water?             <bool>)         ;; are we in a liquid environment
  ;; (slot water-collision?   <bool>)         ;; are we colliding with a liquid polygon
  ;; (slot shallow-water?     <bool>)         ;; are we in shallow water
  ;; (slot lava?              <bool>)         ;; are we in lava
  ;; (slot swim-timer         <bool>)         ;; time before able to swim up
  ;; (slot water-jump?        <bool>)         ;; jump when we get out of water
  ;; (slot ladder?            <bool>)         ;; are we climbing up a ladder
  ;; (slot ladder-shaft       <vertex+>)      ;; the xz of the shaft we are climbing in
  ;; (slot plates             <list>          ;; list of plates we were on last time tick-actor was called
  ;; (slot rail-dir           <list+>         ;; are we "riding" a rail -> the direction[s] to ride
  ;; (slot last-turn          <vertex+>)      ;; last position where we turned
  ;; (slot last-step          <fl>)           ;; last time we played a step sound
  ;; (slot rotation           <fl>)           ;; rotation for the character model
  ;; (slot orientation        <object>)       ;; vertical or horizontal like for four-legged creatures
  ;; (slot dash               <fl>)           ;; temporary speed increase
  
  (method (tick-actor commands <Commands> time <fl> elapse <fl> gravity? collision-response (ignore-entities?: ignore-entities? (ignore-entities?)) (ignore-players?: ignore-players? (ignore-players?)) (ignore-me?: ignore-me? (ignore-me?)) (proportional-slide?: proportional-slide? #t))
    (site (tick-actor on?: #f parent: player)
      (let ((world (current-world))
            (zone (current-zone))
            (me (current-me+))
            (motion (current-motion))
            (camera (current-camera))
            (history (current-history))
            (model (cache-model))
            (center (transformed-center))
            (scaling (average-scaling))
            (sprint-forward? (get-sprint-forward?~ commands))
            (sprint-backward? (get-sprint-backward?~ commands))
            (blink-forward? (get-blink-forward?~ commands))
            (blink-backward? (get-blink-backward?~ commands)))
        (let ((gravity (compute-gravity&~ world center))
              (area-cube (update-area-cube))
              (me? (eq? self me))
              (sprint? (or sprint-forward? sprint-backward?))
              (blink? (or blink-forward? blink-backward?))
              (speed #f)
              (animation-speedup #f)
              (displacement (vertex& 0. 0. 0.))
              (grace-slowdown .25)
              (grace-move? #f)
              (floor-level (floor-level~ world))
              (motion-target? (eq? (motion-target~ motion) self))
              (old-lookat (lookat-copy& lookat))
              (animation #f)
              (fly? (flying?)))
          (define (process-commands)
            (when (and (get-modified?~ commands) (hook-commands~ world commands))
              ;; move forward
              (when (and (get-move-forward?~ commands) (not sprint?) (not blink?))
                (when (allow-movement?)
                  (move move-forward)
                  (animate (move-animation))))
              ;; move backward
              (when (and (get-move-backward?~ commands) (not sprint?) (not blink?))
                (when (allow-movement?)
                  (move move-backward)
                  (animate "WalkBackwards")))
              ;; move left
              (when (get-move-left?~ commands)
                (when (allow-movement?)
                  (move move-left)
                  (animate (move-animation))))
              ;; move right
              (when (get-move-right?~ commands)
                (when (allow-movement?)
                  (move move-right)
                  (animate (move-animation))))
              ;; move up
              (when (get-move-up?~ commands)
                (move move-up))
              ;; move down
              (when (get-move-down?~ commands)
                (move move-down))
              ;; sprint forward
              (when sprint-forward?
                (move sprint-forward)
                (animate "Run"))
              ;; sprint backward
              (when sprint-backward?
                (move sprint-backward)
                (animate "Run"))
              ;; blink forward
              (when blink-forward?
                (move blink-forward)
                (animate "Run"))
              ;; blink backward
              (when blink-backward?
                (move blink-backward)
                (animate "Run"))
              ;; rotate left
              (when (get-rotate-left?~ commands)
                (rotate-left))
              ;; rotate right
              (when (get-rotate-right?~ commands)
                (rotate-right))))
          
          (define (move proc)
            (cond ((and water? (>= swim-timer 0.))
                   (proc (* dash water-slowdown scaling) displacement))
                  ((or ground? hover? ladder? fly? blink?)
                   (proc (* dash scaling) displacement))
                  ((and jumping? jump-grace?)
                   (proc (* dash grace-slowdown scaling) displacement)
                   (set! grace-move? #t)
                   (set! jump-grace? #f)))
            (when (> dash-duration 0.)
              (decrease! dash-duration elapse)
              (when (<= dash-duration 0.)
                (set! dash 1.)
                (set! dash-duration 0.)
                (update-parameter~ world 'dash))))
          
          (define (move-forward factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (if rail-dir
                (vertex-increase! displacement (vertex-scalar*& (vertex* (get-sight~ lookat) (car rail-dir)) speed))
              (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) speed))))
          
          (define (move-backward factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (if rail-dir
                (vertex-decrease! displacement (vertex-scalar*& (vertex* (get-sight~ lookat) (car rail-dir)) speed))
              (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) speed))))
          
          (define (move-left factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (vertex-decrease! displacement (vertex-scalar*& (get-right~ lookat) speed)))
          
          (define (move-right factor displacement)
            (set! speed (* factor (vehicle-speed~ world self)))
            (vertex-increase! displacement (vertex-scalar*& (get-right~ lookat) speed)))
          
          (define (move-up factor displacement)
            (set! speed (* factor (vehicle-speed~ world self) (if (high-speed?) 2. 1.)))
            (vertex-increase! displacement (vertex-scalar*& (get-up~ lookat) speed)))
          
          (define (move-down factor displacement)
            (set! speed (* factor (vehicle-speed~ world self) (if (high-speed?) 2. 1.)))
            (vertex-decrease! displacement (vertex-scalar*& (get-up~ lookat) speed)))
          
          (define (sprint-forward factor displacement)
            (set! speed (if rail-dir
                            (* factor (vehicle-speed~ world self))
                          (* factor (vehicle-speed~ world self) (if (user?) 2. sprint-speed))))
            (if rail-dir
                (vertex-increase! displacement (vertex-scalar*& (vertex* (get-sight~ lookat) (car rail-dir)) speed))
              (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) speed))))
          
          (define (sprint-backward factor displacement)
            (set! speed (if rail-dir
                            (* factor (vehicle-speed~ world self))
                          (* factor (vehicle-speed~ world self) (if (user?) 2. sprint-speed))))
            (if rail-dir
                (vertex-decrease! displacement (vertex-scalar*& (vertex* (get-sight~ lookat) (car rail-dir)) speed))
              (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) speed))))
          
          (define (blink-forward factor displacement)
            (set! speed (* factor (vehicle-speed~ world self) blink-speed))
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ camera) speed)))
          
          (define (blink-backward factor displacement)
            (set! speed (* factor (vehicle-speed~ world self) blink-speed))
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ camera) speed)))
          
          (define (high-speed?)
            (or (key-down? #\3)
                (key-down? #\4)
                (key-down? #\5)))
          
          (define player-rotation-speed <fl>
            1.3)
          
          (define (rotate-left)
            (rotate-actor (* player-rotation-speed elapse)))
          
          (define (rotate-right)
            (rotate-actor (- (* player-rotation-speed elapse))))
          
          (define (rotate-actor angle)
            (if motion-target?
                (rotate-actor-horizontal~ motion self angle)
              (rotate-horizontal angle)))
          
          (define (animate name)
            (set! animation name)
            ;; arbitrary maximum so animation isn't crazy fast
            (set! animation-speedup (and speed (min 2.5 (/ speed (* (model-ground-speed) scaling)))))
            (animate/change time name speedup: animation-speedup))
          
          (define (animate/change time name (speedup: speedup #f))
            (let ((old-animation animation-active))
              (animate-model time name speedup: speedup)
              (animate-change time self old-animation animation-active)))
          
          (define (move-animation)
            (case motion~self
              ((idle) "Idle")
              ((walk) "Walk")
              ((run) "Run")))
          
          (define (process-velocity)
            (cond ((or ground? hover? ladder? fly? blink? grace-move? (and water? (moving?~ commands)))
                   (if rail-dir
                       (vertex-copy! velocity (vertex-scalar*& displacement (/ 2.5 scaling)))
                     (vertex-copy! velocity (vertex-scalar/& displacement scaling))))
                  ((or (not jumping?)
                       (> (- time jump-time) 1.))
                   (let ((friction (get-friction)))
                     (when friction
                       (let ((reduce <fl> (* friction elapse (if water? 4. 1.))))
                         (if (< (vertex-norm& velocity) reduce)
                             (vertex-zero! velocity)
                           (vertex-decrease! velocity (vertex-scalar*& (vertex-normalize-safe& velocity) reduce)))))))))
          
          (define (process-gravity)
            (let ((normalized-gravity (vertex-normalize& gravity)))
              (if (or jump? (get-jump?~ commands))
                  (when (and (not rail-dir) (or water-jump? (and jump-ready? (or (and sprint? (not (user?))) blink? water? (and (or ground? ladder?) (not jumping?))))))
                    (unless (or water? water-jump?)
                      (set! jumping? #t)
                      (set! jump-ready? #f)
                      (set! jump-grace? (and (allow-grace?) (vertex-zero? velocity)))
                      (set! jump-time time))
                    (vertex-copy! fall-velocity (if water?
                                                    (vertex-y-set! fall-velocity (min (+ (vertex-y fall-velocity) 0.02) 0.07))
                                                  (vertex-scalar*& normalized-gravity (* (- (/ (or jump-impulsion (get-jump-impulsion~ world)) (if water-jump? 1.5 1.))) (cond (sprint? (if (user?) 1. sprint-jump))
                                                                                                                                                                               (blink? blink-jump)
                                                                                                                                                                               (water? (if water-jump? 1. (/ 1. 4.)))
                                                                                                                                                                               (else 1.))))))
                    (when water-jump?
                      (set! water-jump? #f))
                    (set! jump? #f)
                    (set! jump-impulsion #f)
                    (animate/change time :context))
                (unless water?
                  (set! jump-ready? #t)))
              (when (> swim-timer 0.)
                (decrease! swim-timer elapse)
                (when (<= swim-timer 0.)
                  (set! swim-timer 0.)
                  (set! jump-ready? #t)))
              (when (and ground? (vertex-zero? fall-velocity))
                (unless jump-ready?
                  (set! jump-ready? #t))
                (when water-jump?
                  (set! water-jump? #f)))
              (when (> (dot-product& fall-velocity normalized-gravity) (if water? 0.015 max-fall-speed))
                (if water?
                    (vertex-y-set! fall-velocity (* (vertex-y fall-velocity) 0.85))
                  (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity max-fall-speed))))))
          
          (define (collide-actor)
            (break-logic slide)
            (when (get-debug-collisions?)
              (reset-marks~ zone))
            (let* ((radiuses (transformed-radiuses))
                   (pumps (and (not water?) (effective-pumps)))
                   (pumped-center (if pumps
                                      (bind-values (pumped pumped-direction pumped-collisions) (collide&stop$ center (vertex+& center pumps) lookat radiuses area-cube: area-cube ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me?)
                                        (free-collisions$ pumped-collisions)
                                        pumped)
                                    center))
                   (target-center (vertex+& pumped-center (vertex-scalar*& velocity elapse)))
                   (collide$ (case collision-response ((stop) collide&stop$) ((slide) collide&slide$))))
              ;; slide
              (bind-values (new-center slide-direction slide-collisions) (site (collide&slide$ on?: #f parent: tick-actor) (collide$ pumped-center target-center lookat radiuses area-cube: area-cube include-back-facing?: #t ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: proportional-slide? debuggable-collisions?: #t))
                (bind-values (new-slide-collisions slide-water?) (filter-water-collisions slide-collisions #t) ;; set water? with both slide and fall
                  (when slide-water?
                    (bind-values (new-center-2 slide-direction-2 slide-collisions-2) (collide$ pumped-center target-center lookat radiuses area-cube: area-cube polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t)
                      (vertex-copy! new-center new-center-2)
                      (free-collisions$ slide-collisions)
                      (set! slide-collisions slide-collisions-2)))
                  (let ((new-center (if pumps
                                        (bind-values (unpumped unpumped-direction unpumped-collisions) (collide&stop$ new-center (vertex-& new-center pumps) lookat radiuses area-cube: area-cube polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me?)
                                          (free-collisions$ unpumped-collisions)
                                          unpumped)
                                      new-center)))
                    ;; kind of a quick hack so we dont slide farther than the player
                    (when (and (not proportional-slide?) (not jumping?))
                      (adjust-fast-slide! center new-center))
                    (break-action
                      (when (in-logic?)
                        (move-actor new-center #f)))
                    (if (or (not gravity?) fly?)
                        (values new-center slide-collisions '())
                      (let ((adjusted (* elapse 50.)))
                        (define (xz-position&)
                          (vertex& (+ (fxceiling (get-x)) .5) 0. (+ (fxceiling (get-z)) .5)))
                        
                        ;; ladder
                        (set! ladder? (some? (lambda (collision) (= (decode-id (get-data1~ (get-polygon~ collision))) 65)) slide-collisions))
                        (cond (ladder?
                               (when (not ladder-shaft)
                                 (set! ladder-shaft (make-vertex)))
                               (vertex-copy! ladder-shaft (xz-position&)))
                              (else
                               (when ladder-shaft
                                 (if (vertex=? (xz-position&) ladder-shaft)
                                     (if (not-null? slide-collisions)
                                         (set! ladder? #t)
                                       ;; slow fall
                                       (set! adjusted (/ adjusted 3.)))
                                   (set! ladder-shaft #f)))))
                        
                        (break-logic fall)
                        (break-action
                          (when (get-debug-collisions?)
                            (reset-marks~ zone)))
                        (when water?
                          (set! adjusted (/ adjusted 1.5)))
                        (vertex+! fall-velocity fall-velocity (vertex-scalar*& gravity adjusted))
                        (cond (rail-dir
                               (vertex! fall-velocity 0. -.20 0.))
                              (ladder?
                               (vertex! fall-velocity 0. .075 0.)))
                        (let ((target-fall (vertex+& new-center (vertex+& (vertex-scalar*& fall-velocity adjusted) (vertex-scalar*& gravity (* .5 adjusted adjusted))))))
                          ;; fall
                          ;; megahack around many edge / point collision snags when jumping next to blocks (AM)
                          (bind-values (new-fall fall-direction fall-collisions) (site (collide&stop$ on?: #f parent: tick-actor) (collide&stop$ new-center target-fall lookat radiuses area-cube: area-cube include-back-facing?: #t ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t megahack?: (and me? (or jumping? ladder? ladder-shaft))))
                            (break-action
                              (when (in-logic?)
                                (move-actor new-fall #f)))
                            (let ((new-fall-collisions (liquid? fall-collisions slide-water?)))
                              (if water-collision?
                                  (begin
                                    (unless shallow-water?
                                      (set! shallow-water? #t)
                                      (when me?
                                        (change-ambience~ (current-ambience) error?: #f)))
                                    (bind-values (new-fall-2 fall-direction other-fall-collisions) (collide&stop$ new-center target-fall lookat radiuses area-cube: area-cube polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t)
                                      (vertex-copy! new-fall new-fall-2)
                                      (free-collisions$ fall-collisions)
                                      (set! fall-collisions other-fall-collisions)))
                                ;; going from shallow to water
                                (when (and water? shallow-water?)
                                  (set! shallow-water? #f)
                                  (when me?
                                    (play-ambience~ (current-ambience) "ambience/water/Underwater"))))
                              (vertex-copy! new-fall (or (manage-fall-collisions fall-collisions) new-fall))
                              (values new-fall slide-collisions fall-collisions)))))))))))
          
          (define (manage-fall-collisions fall-collisions)
            (manage-plates fall-collisions)
            (manage-rails fall-collisions))
          
          (define (manage-plates fall-collisions)
            (define (common-list-elements l1 l2)
              (let ((common '()))
                (for-each (lambda (element)
                            (when (member? element l2)
                              (set! common (cons element common))))
                          l1)
                common))
            
            (let ((new-pp '())
                  (to-add '())
                  (to-remove '()))
              (for-each (lambda (coll)
                          (when (memq? (decode-id (get-data1~ (get-polygon~ coll))) '(70 72))
                            (let ((poly (get-polygon~ coll)))
                              (set! new-pp (cons (polygon-position poly) new-pp)))))
                        fall-collisions)
              (let ((common (intersection test: equal? new-pp plates)))
                (set! to-add (list-copy new-pp))
                (set! to-remove (list-copy plates))
                (for-each (lambda (com)
                            (set! to-add (remove com to-add test: equal?))
                            (set! to-remove (remove com to-remove test: equal?)))
                          common)
                (plates-update~ (current-game) to-add to-remove self)
                (set! plates new-pp))))
          
          (define (manage-rails fall-collisions)
            (let ((rail (find-object (lambda (coll) (and (memq? (decode-id (get-data1~ (get-polygon~ coll))) '(27 28 66)) (get-polygon~ coll))) fall-collisions))
                  (pos #f))
              (if rail
                  (call-with-position~ zone (vertex& (get-data2~ rail) (get-data3~ rail) (get-data4~ rail))
                    (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                      (let ((data (if (memq? block-id '(27 28)) (bit-set data-id 3 #f) data-id)))
                        (let ((curved? (> data 5)))
                          (if (not curved?)
                              (begin
                                (let ((dir (if (memq? data '(0 4 5)) #f64(0. 0. 1.) #f64(1. 0. 0.)))) ;; N W
                                  (let ((angle (vector-angle (get-sight~ lookat) dir))
                                        (dist (vertex-norm& (vertex*& (vertex-& position (vertex& x y z)) (if (memq? data '(0 4 5)) #f64(1. 0. 0.) #f64(0. 0. 1.))))))
                                    (if (and (or (< angle (degree->radian 10.)) (> angle (degree->radian 170.))) (< dist .2))
                                        (unless rail-dir
                                          (set! rail-dir (list dir)))
                                      (set! rail-dir #f))))
                                (set! last-turn #f))
                            (let ((dir1 (if (memq? data '(6 7)) #f64(0. 0. 1.) #f64(0. 0. -1.)))
                                  (dir2 (if (memq? data '(6 9)) #f64(1. 0. 0.) #f64(-1. 0. 0.))))
                              (let ((curve (curve-angle (get-sight~ lookat) dir1 dir2)))
                                (when rail-dir
                                  (unless (and last-turn (vertex=? (vertex& x (- y .5) z) last-turn))
                                    (set! pos (vertex x y z))
                                    (set! last-turn (vertex x (- y .5) z))
                                    (set! rail-dir (cdr rail-dir))
                                    (rotate-actor curve))))))))))
                (set! rail-dir #f)
                (set! last-turn #f))
              pos))
          
          (define (curve-angle sight d1 d2)
            (let ((a1 (vector-angle sight d1))
                  (a2 (vector-angle sight d2))
                  (main-dir (make-vertex))
                  (curve (degree->radian 90.)))
              (cond ((> a1 (degree->radian 170.))
                     (vertex-copy! main-dir d1)
                     (set! curve (* curve -1. (vertex-x d2) (vertex-z main-dir)))
                     (unless last-turn
                       (set! rail-dir (list (vertex-abs main-dir) d2))))
                    ((> a2 (degree->radian 170.))
                     (vertex-copy! main-dir d2)
                     (set! curve (* curve (vertex-z d1) (vertex-x main-dir)))
                     (unless last-turn
                       (set! rail-dir (list (vertex-abs main-dir) d1))))
                    (else
                     (set! rail-dir #f)
                     (set! last-turn #f)))
              curve))
          
          (define (liquid? fall-collisions slide-water?)
            (let ((new-collisions (make-queue$))
                  (water-polygons (make-queue$))
                  (lava-collision? #f))
              (for-each (lambda (collision)
                          (let ((poly (get-polygon~ collision)))
                            (if (get-liquid-cube?~ (id->block (decode-id (get-data1~ poly))))
                                (begin
                                  (when (memq? (decode-id (get-data1~ poly)) '(10 11))
                                    (set! lava-collision? #t))
                                  (enqueue water-polygons poly))
                              (enqueue new-collisions collision))))
                        fall-collisions)
              (if (and (queue-empty? water-polygons) (not slide-water?))
                  (begin
                    (set! water-collision? #f)
                    (when water?
                      (unless (get-liquid-cube?~ (id->block (block-at-center)))
                        (exit-water))))
                (unless water?
                  (when (> (abs (vertex-y fall-velocity)) 1.)
                    (play-3d-sound "sound/water/EnterWaterSmallA" position))
                  (enter-water lava-collision? time)
                  (set! grace-move? #f))
                (unless water-collision?
                  (set! water-collision? #t)))
              (let ((lst (queue-list new-collisions)))
                (free-queue$ new-collisions)
                (free-queue$ water-polygons)
                lst)))
          
          (define (liquid-filter poly)
            (not (get-liquid-cube?~ (id->block (decode-id (get-data1~ poly))))))
          
          (define (hit-action slide-collisions)
            (define (find-actionable)
              (continuation-capture
                (lambda (found)
                  (for-each (lambda (collision)
                              (let ((poly (get-polygon~ collision)))
                                (when (= (decode-id (get-data1~ poly)) 90)
                                  (continuation-return found poly))))
                            slide-collisions)
                  #f)))
            
            (let ((poly (find-actionable)))
              (and poly
                   (let ((id (decode-id (get-data1~ poly)))
                         (pos (polygon-position poly)))
                     (cond ;; portal
                           ((= id 90)
                            (world.generation:invoke-block-action pos 'teleport))
                           (else
                            #f))))))
          
          (define (hit-collisions new-center slide-collisions fall-collisions)
            (define (ground-update flag velocity)
              (when (neq? ground? flag)
                (set! ground? flag)
                (if velocity
                    (hit-ground velocity)
                  (leave-ground))))
            
            (hit slide-collisions)
            (let ((floor-level (and floor-level (+ floor-level (get-radius-y))))
                  (velocity (copy-vertex fall-velocity)))
              (if (and floor-level (< (vertex-y new-center) floor-level) (not fly?))
                  (begin
                    (hit-floor velocity)
                    (vertex-y-set! new-center floor-level)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))
                (let ((fall-collided? (not-null? fall-collisions))
                      (water-only? (null? (filter-water-collisions fall-collisions #f))))
                  (if (not fall-collided?)
                      (ground-update #f #f)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update (not water-only?) velocity))))))
          
          (define (filter-water-collisions fall-collisions slide?)
            (define (not-water? collision)
              (liquid-filter (get-polygon~ collision)))
            
            ;; optimize the by far most common case
            (if (every? not-water? fall-collisions)
                (if slide?
                    (values fall-collisions #f)
                  fall-collisions)
              (let ((new-collisions (collect-if not-water? fall-collisions)))
                (if slide?
                    (values new-collisions #t)
                  new-collisions))))
          
          (define (foot-step fall-collisions)
            (when (and me? (get-steps?~ model) (or ground? @not-really-nice ladder?) (or (not water?) shallow-water?) morphing)
              (let ((speed (vertex-norm& velocity)))
                (when (> speed 0.)
                  ;; two steps for each animation
                  (let ((step-time (/ (effective-duration~ morphing) 2.)))
                    (when (> (- time last-step) step-time)
                      (set! last-step time)
                      (let ((kind (cond @not-really-nice
                                    (ladder?
                                     'ladder)
                                    ((and water? shallow-water?)
                                     'water)
                                    ((null? fall-collisions)
                                     'stone)
                                    (else
                                     (let ((collision (car fall-collisions)))
                                       (let ((id (decode-id (get-data1~ (get-polygon~ collision)))))
                                         (case id
                                           ((2) 'grass)
                                           ((5) 'wood)
                                           ((12 13) 'dirt)
                                           ((78 79 80) 'snow)
                                           (else 'stone))))))))
                        (let ((step (random-step kind)))
                          (when step
                            (play-sound-file step volume: .075))))))))))
          
          (define (move-actor new-center (calculate? #t))
            (let ((movement (vertex- new-center center)))
              (let ((new-position (vertex+& position movement))
                    (old-position (vertex-copy& position))
                    (old-velocity (vertex-copy& effective-velocity)))
                (vertex+! effective-velocity velocity fall-velocity)
                (when (and calculate? (moving?~ commands))
                  (set! velocity-angle (abs (- 90. (radian->degree (vector-angle (vertex*& (vertex-& new-position old-position) (vertex& 1. 0. 1.)) (get-sight~ lookat)))))))
                (set-position new-position)
                (vertex-copy! center new-center)
                (unless (vertex-near? old-position new-position)
                  (update-compass~ world))
                (move-change time self commands elapse old-position new-position old-velocity effective-velocity)
                movement)))
          
          (define (rotate-model movement)
            (when me?
              (let ((distance (/ (dot-product& (get-sight~ lookat) movement) (get-radius))))
                (define (set-x-rotation model name)
                  (let ((model (child~ model name)))
                    (vertex-x-set! (get-rotation~ model) rotation)
                    (update-matrix~ model)))
                
                (when (/= distance 0.)
                  (decrease! rotation distance)
                  (when (and (eq? (get-name~ model) 'Orb) (not fly?))
                    (set-x-rotation model 'body))
                  (when (memq? (vehicle-name) '(Wheels Hummer))
                    (set-x-rotation (cache-model~ vehicle) 'wheel1)
                    (set-x-rotation (cache-model~ vehicle) 'wheel2)
                    (set-x-rotation (cache-model~ vehicle) 'wheel3)
                    (set-x-rotation (cache-model~ vehicle) 'wheel4))))))
          
          (define (realign-actor slide-collisions fall-collisions)
            (when (and gravity? (not fly?))
              (update-world-up~ world gravity)
              (case @until-horizontal-debugged orientation 'vertical
                ((vertical)
                 (realign-lookat (gravity-up& gravity)))
                ((horizontal)
                 (when (or (not-null? slide-collisions)
                           (not-null? fall-collisions))
                   (let ()
                     (define (average-normal)
                       (let ((factor-sum 0.)
                             (dir-sum (make-zero-vertex)))
                         (define (process-collisions collisions)
                           (for-each (lambda (collision)
                                       (let ((plane (get-plane~ collision)))
                                         (let ((origin (get-origin~ plane))
                                               (normal (get-normal~ plane)))
                                           (let ((dist (vertex-distance& origin center)))
                                             (let ((factor (/ (+ 1. dist))))
                                               (increase! factor-sum factor)
                                               (vertex+! dir-sum dir-sum (vertex-scalar*& normal factor-sum)))))))
                                     collisions))
                         
                         (process-collisions slide-collisions)
                         (process-collisions fall-collisions)
                         (vertex-scalar/& dir-sum factor-sum)))
                     
                     ;; this is clearly buggy and can create an up with y != 1 on a flat floor (AM)
                     (remove-up-roll (average-normal) lookat)))))))
          
          (define (realign-horizon)
            (when (and gravity? (not fly?) motion-target? (is? motion Person-Motion))
              (let ((final-gravity (compute-gravity~ world center)))
                (set-lookat~ camera (realign-lookat-horizon& (get-lookat~ camera) (get-up~ lookat) gravity final-gravity))
                (camera-update~ camera))))
          
          (define (center-eye)
            (when motion-target?
              (without-roll
                (lambda ()
                  (eye-center-player~ motion)))))
          
          (define (verify-death)
            (when (and lava? (user?))
              (damage 1. #f))
            (when (and die-bottom (< (get-y) die-bottom))
              (damage 100. #f)
              ;; this death is client responsibility
              (when (and (client?) (<= life 0.))
                (die-change self))))
          
          (process-commands)
          (process-velocity)
          (process-gravity)
          (when (not animation)
            (animate/change time :context))
          (let ((collide-info (collide-actor)))
            (bind-values (new-center slide-collisions fall-collisions) collide-info
              (and (not (hit-action slide-collisions))
                   (begin
                     (hit-collisions new-center slide-collisions fall-collisions)
                     (if (not alive?)
                         (begin
                           (free-collisions$ slide-collisions)
                           (free-collisions$ fall-collisions)
                           #f)
                       (foot-step fall-collisions)
                       (let ((movement (move-actor new-center)))
                         (rotate-model movement)
                         (realign-actor slide-collisions fall-collisions)
                         (free-collisions$ slide-collisions)
                         (free-collisions$ fall-collisions)
                         (unless (lookat-near? old-lookat lookat)
                           (update-compass~ world))
                         (lookat-change time self commands elapse old-lookat lookat)
                         (and (not (vertex-zero? movement))
                              (begin
                                (realign-horizon)
                                (center-eye)
                                (verify-death)
                                collide-info))))))))))))
  
  
  (method protected virtual (tick-slice)
    #f)
  
  
  (method protected virtual (effective-pumps)
    #f)
  
  
  (method protected virtual (ignore-entities?)
    #t)
  
  
  (method protected virtual (ignore-players?)
    #f)
  
  
  (method protected virtual (ignore-me?)
    #f)
  
  
  (method protected virtual (hit collisions)
    )
  
  
  (method protected virtual (hit-floor velocity)
    )
  
  
  (method protected virtual (hit-ground velocity)
    (define fall-conversion-a <fl>
      (/ 1. .18))
    
    (define fall-conversion-b <fl>
      (/ 1. .51))
    
    (define (blocks-fallen speed)
      (fxround (expt (* speed fall-conversion-a) fall-conversion-b)))
    
    (unless (or ladder? (not (user?)))
      (let ((fall-speed (abs (vertex-y velocity)))
            (minimum-speed .7))
        (when (> fall-speed minimum-speed)
          (let ((amount (* 4 (- (blocks-fallen fall-speed) 5))))
            (damage amount #f))))))
  
  
  (method protected virtual (leave-ground)
    )
  
  
  (method protected virtual (ground-speed)
    (case motion
      ((idle) 0.)
      ((walk) (walk-speed))
      ((run) (run-speed))))
  
  
  (method protected virtual (walk-speed)
    (model-walk-speed))
  
  
  (method protected virtual (run-speed)
    (model-run-speed))
  
  
  (method (model-ground-speed)
    (case motion
      ((idle) 0.)
      ((walk) (model-walk-speed))
      ((run) (model-run-speed))))
  
  
  (method (model-walk-speed)
    (or (get-walk-speed~ (cache-model)) default-walk-speed))
  
  
  (method (model-run-speed)
    (or (get-run-speed~ (cache-model)) default-run-speed))
  
  
  (method protected virtual (allow-movement?)
    #t)
  
  
  (method protected virtual (allow-grace?)
    #t)
  
  
  (method protected virtual (adjust-fast-slide! center new-center)
    )
  
  
  (method (rotate-horizontal angle)
    (let ((world (current-world)))
      (let ((up (get-world-up~ world)))
        (set-lookat (rotate-lookat& lookat angle up))
        (update-matrix))))
  
  
  ;;;
  ;;;; Type
  ;;;
  
  
  (method protected virtual (is-player?)
    #f)
  
  
  (method protected virtual (is-missile?)
    #f)
  
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method override (animated)
    (set! animated? #t))
  
  
  (method override (unanimated)
    (set! animated? #f))
  
  
  (method protected virtual (animate-model time name (speedup: speedup #f) (duration: duration #f) (next: next #f))
    (let ((elapse-before-fall .5)
          (jump-start-frame 8.))
      (let ((fall? (not ground?)))
        (unless jumping?
          (if fall?
              (when (not animation-fall)
                (set! animation-fall time))
            (set! animation-fall #f)))
        (when (or (not animation-fall)
                  (equal? name :context)
                  ;; to not switch non-stop between run and fall while running down a slope
                  (> (- time animation-fall) elapse-before-fall))
          (let ((model (cache-model)))
            (when (get-animations~ model)
              (let ()
                (define (determine-animation proc)
                  (cond ((or (eq? motion 'idle) (and vehicle ground?)) (proc '("Idle") #f))
                        ((and water? (not shallow-water?)) (proc (if (eq? name :context) '("SwimIdle" "Idle") '("Swim" "Run")) #f))
                        (jumping? (proc '("JumpStart" "Jump" "Fall" "Idle") (list "Jump" "Fall" "Idle")))
                        ((and fall? (not ladder?)) (proc '("Fall" "Idle") #f))
                        (else (proc (if (eq? name :context)
                                        (cond (animation-once
                                               (list animation-once))
                                              (animation-continuous
                                               (list animation-continuous))
                                              (else
                                               (list "Idle")))
                                      (listify name))
                                    #f))))
                
                (define (existing-animation animation-list)
                  (let (iter (scan animation-list))
                    (if (or (not scan)
                            (null? scan))
                        #f
                      (let ((animation (car scan)))
                        (if (find-animation~ model animation)
                            animation
                          (iter (cdr scan)))))))
                
                ;; simple pragmatic solution
                (define (effective-speedup animation speedup)
                  (if (or (equal? animation "Run")
                          ;; used for run backwards at the moment
                          (equal? animation "WalkBackwards"))
                      speedup
                    #f))
                
                (determine-animation
                  (lambda (animation-list next-list)
                    (let ((animation (existing-animation animation-list)))
                      (if (not animation)
                          (error "No animation found in: {l detail: :human separator: \", \"}" animation-list)
                        (let ((next (existing-animation next-list))
                              (speedup (effective-speedup animation speedup)))
                          (unless (and (equal? animation-active animation)
                                       (equal? animation-speedup speedup))
                            (let ((previous animation-active))
                              (let ((was-falling? (or (equal? previous "JumpStart")
                                                      (equal? previous "Jump")
                                                      (equal? previous "Fall"))))
                                (cond ((and animation-once (equal? animation animation-once))
                                       (when morphing
                                         (transition-morphing animation next: "Idle" next-proc: (lambda () (set! animation-once #f))))
                                       (set! animation-active animation)
                                       (set! animation-speedup #f))
                                      ((and animation-continuous (equal? animation animation-continuous))
                                       (when morphing
                                         (transition-morphing animation))
                                       (set! animation-active animation)
                                       (set! animation-speedup #f))
                                      ((and was-falling? (equal? animation "Idle"))
                                       (when morphing
                                         (change-morphing (existing-animation '("JumpEnd" "Idle")) next: "Idle"))
                                       (set! animation-active "Idle")
                                       (set! animation-speedup #f)
                                       (set! animation-once #f)
                                       (set! animation-continuous #f))
                                      ((and was-falling? (equal? animation "Run"))
                                       (when morphing
                                         (change-morphing (existing-animation '("JumpLandRun" "Run")) next: "Run"))
                                       (set! animation-active "Run")
                                       (set! animation-speedup #f)
                                       (set! animation-once #f)
                                       (set! animation-continuous #f))
                                      (else
                                       (let ((frame (if (equal? animation "JumpStart") jump-start-frame #f))
                                             (duration (if (equal? previous "Idle") .1 #f)))
                                         (when morphing
                                           (transition-morphing animation frame: frame speedup: speedup duration: duration next: next))
                                         (set! animation-active animation)
                                         (set! animation-speedup speedup)
                                         (set! animation-once #f)
                                         (set! animation-continuous #f)))))))))))))))))))
  
  
  ;;;
  ;;;; Simulation
  ;;;
  
  
  (method (simulation-task task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (with-task-mutex
              (lambda ()
                (unless (stopping?~ task)
                  (let ((elapse (- time previous))
                        (max-elapse 10.))
                    ;; ignore ridiculous elapses like
                    ;; coming back from computer sleep
                    (unless (> elapse max-elapse)
                      (let ((history (current-history)))
                        (unless (get-paused?~ history)
                          (tick-simulation time elapse))))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task simulation-period duration exit))
            (iter time))))))
  
  
  (method (tick-simulation time elapse)
    (let ((world (current-world))
          (motion (current-motion)))
      (site (simulation on?: #t)
        (set-position (vertex+& position (vertex-scalar*& effective-velocity elapse)))
        (adjust-motion-target)
        (animate elapse))))
  
  
  ;;;
  ;;;; Missiles
  ;;;
  
  
  (method protected (increase-missiles)
    (increase! missiles-count))
  
  
  (method protected (decrease-missiles)
    (decrease! missiles-count))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-target color)
    (draw-target-circle))
  
  
  ;;;
  ;;;; Travel
  ;;;
  
  
  (method (activate-travel mount vehicle)
    (cond ((not mount)
           (activate-trek))
          ((eq? mount 'ride)
           (activate-ride vehicle: vehicle))
          ((eq? mount 'fly)
           (activate-fly vehicle: vehicle))))
  
  
  ;;;
  ;;;; Trek
  ;;;
  
  
  (method (trekking?)
    (not mount))
  
  
  (method (activate-trek)
    (cond ((riding?) (deactivate-ride))
          ((flying?) (deactivate-fly))))
  
  
  ;;;
  ;;;; Ride
  ;;;
  
  
  (method (riding?)
    (eq? mount 'ride))
  
  
  (method (toggle-ride)
    (let ((history (current-history))
          (world (current-world)))
      (unless (get-paused?~ history)
        (person-motion~ world)
        (if (riding?)
            (trek-change self)
          (ride-change self)))))
  
  
  (method (activate-ride (vehicle: vehicle #f))
    (let ((world (current-world))
          (me (current-me+)))
      (when (neq? mount 'ride)
        (set! mount 'ride)
        (set! jumping? #f)
        (activate-vehicle (or vehicle (get-current~ riders-folio)))
        (when (eq? self me)
          (update-parameter~ world 'ride)
          (update-parameter~ world 'fly)))))
  
  
  (method (deactivate-ride)
    (let ((world (current-world))
          (me (current-me+)))
      (when (eq? mount 'ride)
        (set! mount #f)
        (activate-vehicle #f)
        (when (eq? self me)
          (update-parameter~ world 'ride)
          (update-parameter~ world 'fly)))))
  
  
  ;;;
  ;;;; Fly
  ;;;
  
  
  (method (flying?)
    (eq? mount 'fly))
  
  
  (method (toggle-fly)
    (let ((history (current-history))
          (world (current-world)))
      (unless (or (user?) (creator?) (get-paused?~ history))
        (person-motion~ world)
        (if (flying?)
            (trek-change self)
          (fly-change self)))))
  
  
  (method (activate-fly (vehicle: vehicle #f))
    (let ((world (current-world))
          (motion (current-motion))
          (me (current-me+)))
      (when (neq? mount 'fly)
        (let ((motion-target? (eq? (motion-target~ motion) self))
              (me? (eq? self me)))
          (set! mount 'fly)
          (set! jumping? #f)
          (set-position (vertex+& (get-position) (vertex& 0. 0.1 0.)))
          (activate-vehicle (or vehicle (get-current~ flyers-folio)))
          (when motion-target?
            ;; quick hack for orb
            (when (is? motion Target-Motion)
              (adjust-player-alpha~ motion))
            (follow-player~ motion))
          (when me?
            (update-parameter~ world 'ride)
            (update-parameter~ world 'fly))))))
  
  
  (method (deactivate-fly)
    (let ((world (current-world))
          (motion (current-motion))
          (me (current-me+)))
      (when (eq? mount 'fly)
        (let ((motion-target? (eq? (motion-target~ motion) self))
              (me? (eq? self me)))
          (set! mount #f)
          (activate-vehicle #f)
          (when motion-target?
            ;; quick hack for orb
            (when (is? motion Target-Motion)
              (adjust-player-alpha~ motion))
            (when (is? motion Person-Motion)
              (exit-fly~ motion)))
          (when me?
            (update-parameter~ world 'ride)
            (update-parameter~ world 'fly))))))
  
  
  ;;;
  ;;;; Vehicle
  ;;;
  
  
  (method (vehicle-name)
    (and vehicle (get-model~ vehicle)))
  
  
  (method (change-vehicle name)
    (set! vehicle (and name (new Entity model: name)))
    (update-matrix))
  
  
  (method (toggle-vehicle)
    (if (not vehicle)
        (bell)
      (let ((folio (if (flying?) flyers-folio riders-folio)))
        (let ((next (next-element (get-list~ folio) (get-model~ vehicle))))
          (set-current~ folio next)
          (vehicle-change self next)))))
  
  
  (method (activate-vehicle name)
    (change-vehicle name)
    (when vehicle
      (let ((saddle (get-saddle~ (cache-model~ vehicle))))
        (when saddle
          (set-position (vertex+& (get-position) (vertex& 0. saddle 0.)))))))
  
  
  (method override (update-matrix)
    (nextmethod)
    (when vehicle
      (let ((saddle (get-saddle~ (cache-model~ vehicle)))
            (ride-saddle (get-ride-saddle~ (cache-model)))
            (fly-saddle (get-fly-saddle~ (cache-model)))
            (vehicle-scale (get-vehicle-scale~ (cache-model))))
        (if (eq? (get-model~ vehicle) 'Wheels)
            (set! ride-saddle (/ ride-saddle 3.)))
        (matrix-multiply! (get-matrix~ vehicle)
                          matrix
                          (make-translation-matrix& (vertex-& (get-position~ vehicle) (vertex& 0. (+ saddle (if (flying?) fly-saddle ride-saddle)) 0.)))
                          (make-scaling-matrix& vehicle-scale)))))
  
  
  (method override (register-billboards)
    (nextmethod)
    ;; THIS IS NOT A BILLBOARD
    (when vehicle
      (world.renderer:register-entity vehicle))))


;;;
;;;; Damage
;;;


(definition protected (damage-change actor amount critical?)
  (let ((history (current-history)))
    (unless (and (get-paused?~ history) (not (stepping-history?)))
      (apply-damage actor amount critical?)
      (bidirectional-change 'damage (current-seconds)
        (lambda (store push)
          )
        (lambda (store push)
          (store push actor amount critical?))
        (lambda (store push)
          (store push actor))))))


(definition protected (apply-damage actor amount critical?)
  (when (client?)
    (damage~ actor amount critical?)))


;; todo
(definition protected (apply-undamage actor)
  )


(define-change damage
  ;; forward
  forward-layout: '(entity double boolean)
  forward-store: (lambda (push actor amount critical?)
                   (push-entity push actor)
                   (push-double push amount)
                   (push-boolean push critical?))
  forward-apply: (lambda (client-id pop)
                   (let* ((actor (pop-entity pop))
                          (amount (pop-double pop))
                          (critical? (pop-boolean pop)))
                     (apply-damage actor amount critical?)))
  ;; backward
  backward-layout: '(entity)
  backward-store: (lambda (push actor)
                    (push-entity push actor))
  backward-apply: (lambda (client-id pop)
                    (let* ((actor (pop-entity pop)))
                      (apply-undamage actor))))


;;;
;;;; Die
;;;


(definition protected (die-change actor)
  (let ((history (current-history)))
    (unless (and (get-paused?~ history) (not (stepping-history?)))
      (apply-die actor)
      (bidirectional-change 'die (current-seconds)
        (lambda (store push)
          )
        (lambda (store push)
          (store push actor))
        (lambda (store push)
          (store push actor))))))


(definition protected (apply-die actor)
  (die~ actor))


;; useful for navigating history as only server should apply die
(definition protected (apply-resurrect actor)
  (resurrect~ actor))


(define-change die
  ;; forward
  forward-layout: '(entity)
  forward-store: (lambda (push actor)
                   (push-entity push actor))
  forward-apply: (lambda (client-id pop)
                   (let* ((actor (pop-entity pop)))
                     (apply-die actor)))
  ;; backward
  backward-layout: '(entity)
  backward-store: (lambda (push actor)
                    (push-entity push actor))
  backward-apply: (lambda (client-id pop)
                    (let* ((actor (pop-entity pop)))
                      (apply-resurrect actor))))


;;;
;;;; Trek
;;;


(definition protected (trek-change actor)
  (let ((world (current-world))
        (history (current-history)))
    (unless (and (get-paused?~ history) (not (stepping-history?)))
      (let ((old-mount (get-mount~ actor))
            (old-vehicle (vehicle-name~ actor)))
        (activate-trek~ actor)
        (bidirectional-change 'trek (current-seconds)
          (lambda (store push)
            )
          (lambda (store push)
            (store push actor))
          (lambda (store push)
            (store push actor old-mount old-vehicle)))))))


(define-change trek
  ;; forward
  forward-layout: '(entity)
  forward-store: (lambda (push actor)
                   (push-entity push actor))
  forward-apply: (lambda (client-id pop)
                   (let* ((actor (pop-entity pop)))
                     (activate-trek~ actor)))
  ;; backward
  backward-layout: '(entity literal literal)
  backward-store: (lambda (push actor old-mount old-vehicle)
                    (push-entity push actor)
                    (push-literal push old-mount)
                    (push-literal push old-vehicle))
  backward-apply: (lambda (client-id pop)
                    (let* ((actor (pop-entity pop))
                           (old-mount (pop-literal pop))
                           (old-vehicle (pop-literal pop)))
                      (activate-travel~ actor old-mount old-vehicle))))


;;;
;;;; Ride
;;;


(definition protected (ride-change actor)
  (let ((world (current-world))
        (history (current-history)))
    (unless (and (get-paused?~ history) (not (stepping-history?)))
      (let ((old-mount (get-mount~ actor))
            (old-vehicle (vehicle-name~ actor)))
        (activate-ride~ actor)
        (bidirectional-change 'ride (current-seconds)
          (lambda (store push)
            )
          (lambda (store push)
            (store push actor (vehicle-name~ actor)))
          (lambda (store push)
            (store push actor old-mount old-vehicle)))))))


(define-change ride
  ;; forward
  forward-layout: '(entity literal)
  forward-store: (lambda (push actor vehicle)
                   (push-entity push actor)
                   (push-literal push vehicle))
  forward-apply: (lambda (client-id pop)
                   (let* ((actor (pop-entity pop))
                          (vehicle (pop-literal pop)))
                     (activate-ride~ actor vehicle: vehicle)))
  ;; backward
  backward-layout: '(entity literal literal)
  backward-store: (lambda (push actor old-mount old-vehicle)
                    (push-entity push actor)
                    (push-literal push old-mount)
                    (push-literal push old-vehicle))
  backward-apply: (lambda (client-id pop)
                    (let* ((actor (pop-entity pop))
                           (old-mount (pop-literal pop))
                           (old-vehicle (pop-literal pop)))
                      (activate-travel~ actor old-mount old-vehicle))))


;;;
;;;; Fly
;;;


(definition protected (fly-change actor)
  (let ((world (current-world))
        (history (current-history)))
    (unless (and (get-paused?~ history) (not (stepping-history?)))
      (let ((old-mount (get-mount~ actor))
            (old-vehicle (vehicle-name~ actor)))
        (activate-fly~ actor)
        (bidirectional-change 'fly (current-seconds)
          (lambda (store push)
            )
          (lambda (store push)
            (store push actor (vehicle-name~ actor)))
          (lambda (store push)
            (store push actor old-mount old-vehicle)))))))


(define-change fly
  ;; forward
  forward-layout: '(entity literal)
  forward-store: (lambda (push actor vehicle)
                   (push-entity push actor)
                   (push-literal push vehicle))
  forward-apply: (lambda (client-id pop)
                   (let* ((actor (pop-entity pop))
                          (vehicle (pop-literal pop)))
                     (activate-fly~ actor vehicle: vehicle)))
  ;; backward
  backward-layout: '(entity literal literal)
  backward-store: (lambda (push actor old-mount old-vehicle)
                    (push-entity push actor)
                    (push-literal push old-mount)
                    (push-literal push old-vehicle))
  backward-apply: (lambda (client-id pop)
                    (let* ((actor (pop-entity pop))
                           (old-mount (pop-literal pop))
                           (old-vehicle (pop-literal pop)))
                      (activate-travel~ actor old-mount old-vehicle))))


;;;
;;;; Vehicle
;;;


(definition protected (vehicle-change actor vehicle)
  (let ((world (current-world))
        (history (current-history)))
    (unless (and (get-paused?~ history) (not (stepping-history?)))
      (let ((old-mount (get-mount~ actor))
            (old-vehicle (vehicle-name~ actor)))
        (change-vehicle~ actor vehicle)
        (bidirectional-change 'vehicle (current-seconds)
          (lambda (store push)
            )
          (lambda (store push)
            (store push actor vehicle))
          (lambda (store push)
            (store push actor old-mount old-vehicle)))))))


(define-change vehicle
  ;; forward
  forward-layout: '(entity literal)
  forward-store: (lambda (push actor vehicle)
                   (push-entity push actor)
                   (push-literal push vehicle))
  forward-apply: (lambda (client-id pop)
                   (let* ((actor (pop-entity pop))
                          (vehicle (pop-literal pop)))
                     (change-vehicle~ actor vehicle)))
  ;; backward
  backward-layout: '(entity literal literal)
  backward-store: (lambda (push actor old-mount old-vehicle)
                    (push-entity push actor)
                    (push-literal push old-mount)
                    (push-literal push old-vehicle))
  backward-apply: (lambda (client-id pop)
                    (let* ((actor (pop-entity pop))
                           (old-mount (pop-literal pop))
                           (old-vehicle (pop-literal pop)))
                      (activate-travel~ actor old-mount old-vehicle)))))
