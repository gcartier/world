;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Actors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.actor jazz


(import (jazz.syntax (phase syntax))
        (world)
        (world.animation)
        (world.autoload)
        (world.collision)
        (world.commands)
        (world.dye)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.motion)
        (world.settings)
        (world.spell)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Actor
;;;


(definition *global-cooldown*
  0.5)

(definition protected max-fall-speed <fl>
  .65)

(definition protected die-bottom <fl+>
  #f)


(class Actor extends Entity
  
  
  (properties (;; component
               name visible?
               ;; element
               position lookat scale radiuses radius color user-data
               ;; entity
               model animate? animation)
    
    (slot velocity                <f64vector>  initialize (make-zero-vertex) getter generate)
    (slot fall-velocity           <f64vector>  initialize (make-zero-vertex) getter generate)
    (slot life                    <fl>         initialize 100.               accessors generate)
    (slot global-cooldown         <fl>         initialize 0.                 accessors generate)
    (slot spell                   <Spell+>     initialize #f                 accessors generate)
    (slot adjustments             <list>       initialize '()                accessors generate)
    (slot rapid-fire-acceleration <fl>         initialize 1.                 accessors generate)
    (slot rapid-fire-duration     <fl>         initialize 0.                 accessors generate)
    (slot rapid-fire-cooldown     <fl>         initialize 0.                 accessors generate)
    (slot last-missile            <fl+>        initialize #f                 accessors generate)
    (slot max-missiles            <fx>         initialize 10                 accessors generate)
    (slot missiles-count          <fx>         initialize 0                  accessors generate)
    (slot history-color           <object>     initialize #f                 accessors generate)
    (slot jumping?                <bool>       initialize #f                 accessors generate)
    (slot jump-ready?             <bool>       initialize #f                 accessors generate)
    (slot jump-grace?             <bool>       initialize #f                 accessors generate)
    (slot jump-time               <fl>         initialize 0.                 accessors generate)
    (slot ground?                 <bool>       initialize #f                 accessors generate)
    (slot ladder?                 <bool>       initialize #f                 accessors generate)
    (slot ladder-shaft            <f64vector+> initialize #f                 accessors generate)
    (slot last-step               <fl>         initialize 0.                 accessors generate)
    (slot rotation                <fl>         initialize 0.                 accessors generate)
    (slot orientation             <object>     initialize 'vertical          accessors generate)
    (slot sprint                  <fl>         initialize 1.                 accessors generate)
    (slot sprint-duration         <fl>         initialize 0.                 accessors generate)
    (slot animation-active        <object>     initialize #f                 accessors generate)
    (slot animation-start         <object>     initialize #f                 accessors generate)
    (slot animation-end           <object>     initialize #f                 accessors generate)
    (slot animation-fall          <object>     initialize #f                 accessors generate))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (let ((color (copy-dye color)))
      (dye-alpha-set! color .2)
      (set! history-color color)))
  
  
  (method public inline (set-velocity vel <f64vector>) <void>
    (vertex-copy! velocity vel))
  
  
  (method public inline (set-fall-velocity vel <f64vector>) <void>
    (vertex-copy! fall-velocity vel))
  
  
  (method override (call-model-update model)
    (nextmethod model)
    (set! animation-active #f)
    (set! animation-start #f)
    (set! animation-end #f)
    (set! animation-fall #f))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (definition missile-delay <fl>
    .1)

  
  ;(method (maybe-add-action name arguments)
  ;  (if (<= global-cooldown 0.)
  ;      (add-action~ commands name (arguments))
  ;    (set! global-cooldown (- global-cooldown 0.))))
  
  
  (method (maybe-fire commands kind)
    (let ((seconds (current-seconds)))
      (when (or (not last-missile)
                (> (- seconds last-missile) (/ missile-delay rapid-fire-acceleration)))
        (fire commands kind)
        (set! last-missile seconds))))
  
  
  (method (fire commands kind)
    (let ((direction (aim-direction)))
      (add-action~ commands 'fire (list direction kind))))
  
  
  (method (fire-missile direction kind)
    (let ((world (current-world))
          (zone (current-zone)))
      (when (< missiles-count max-missiles)
        (let ((lens (player-lens~ world self))
              ;; because the radius is cubic at the moment
              (adjusted-radius (/ (get-radius) 1.8)))
          (let ((pos (vertex+ lens (vertex-scalar*& direction adjusted-radius))))
            (let ((missile (new (missile-class~ world) parent: world position: pos actor: self kind: kind)))
              (increase-missiles)
              (set-velocity~ missile (vertex-scalar*& direction (missile-speed~ missile)))
              (add-element~ zone missile)))))))
  
  
  (method (aim-direction)
    (let ((world (current-world)))
      (let ((eye (get-eye~ world)))
        (if (get-free-aim?~ world)
            (get-sight~ eye)
          (cross-normal (get-up~ eye) (get-right~ lookat))))))
  
  
  (method (start-rapid-fire)
    (set! rapid-fire-acceleration 3.)
    (set! rapid-fire-duration 15.)
    (set! rapid-fire-cooldown 45.))
  
  
  (method (warp-forward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) 2.)))
      (follow-player~ world)))
  
  
  (method (warp-backward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) -2.)))
      (follow-player~ world)))
  
  
  (method (start-sprint)
    (let ((world (current-world)))
      (set! sprint 5.)
      (set! sprint-duration 10.)
      (update-parameter~ world 'sprint)))
  
  
  (method protected virtual (attack-amount amount)
    amount)
  
  
  (method public virtual (wound inflictor)
    (let ((world (current-world)))
      (let ((critical? (> (random-real) .5)))
        (play-game-sound~ world (if critical? (wound-critical-sound) (wound-sound)))
        (decrease! life (attack-amount~ inflictor (wound-amount critical?))))
      (when (<= life 0)
        (die))))
  
  
  (method public virtual (wound-amount critical?)
    (if critical? 20. 10.))
  
  
  (method public virtual (wound-sound)
    #f)
  
  
  (method public virtual (wound-critical-sound)
    #f)
  
  
  (method public virtual (die)
    (let ((world (current-world)))
      (play-game-sound~ world (death-sound))
      (remove-element~ world self)))
  
  
  (method public virtual (death-sound)
    #f)
  
  
  (method public virtual (stomp)
    #f)
  
  
  (method protected virtual (get-friction)
    4.)
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  ;; If I augment the jump-impulsion, lets say by a factor a 2.5, then collide&stop starts
  ;; returning incorrect collisions as in the following example taken from minecraft/Sample
  ;; (collide&stop (vertex -262.292 .400 72.041) (vertex -262.292 1.227 72.041) (lookat (vertex .662 .000 -.749) (vertex -.000 1.000 .000) (vertex .749 .000 .662)) (vertex .4 .4 .4))
  
  
  ;; (slot position      <f64vector>)    ;; position
  ;; (slot lookat        <LookAt>)       ;; lookat is always perpendicular to gravity
  ;; (slot scale         <f64vector>)    ;; scale
  ;; (slot matrix        <f64vector>)    ;; matrix
  ;; (slot radiuses      <f64vector+>)   ;; radiuses
  ;; (slot radius        <fl+>)          ;; radius
  ;; (slot velocity      <f64vector>)    ;; velocity
  ;; (slot fall-velocity <f64vector>)    ;; fall-velocity
  ;; (slot jumping?      <bool>)         ;; are we currently jumping
  ;; (slot jump-ready?   <bool>)         ;; so holding the jump key only jumps once
  ;; (slot jump-grace?   <bool>)         ;; a standing jump allows us one last move
  ;; (slot jump-time     <fl>)           ;; time of current jump
  ;; (slot ground?       <bool>)         ;; are we currently in contact with the ground
  ;; (slot ladder?       <bool>)         ;; are we climbing up a ladder
  ;; (slot ladder-shaft  <f64vector+>)   ;; the xz of the shaft we are climbing in
  ;; (slot last-step     <fl>)           ;; last time we played a step sound
  ;; (slot rotation      <fl>)           ;; rotation for the character model
  ;; (slot orientation   <object>)       ;; vertical or horizontal like for four-legged creatures
  ;; (slot sprint        <fl>)           ;; temporary speed increase
  
  (method (tick-actor commands <Commands> time <fl> elapse <fl> exit gravity? collision-response (ignore-entities?: ignore-entities? (ignore-entities?)) (ignore-players?: ignore-players? (ignore-players?)))
    (site (tick-actor on?: #f parent: player)
      (let ((world (current-world))
            (zone (current-zone))
            (me (current-me))
            (motion (current-motion))
            (camera (current-camera))
            (model (cache-model))
            (center (transformed-center))
            (run-forward? (get-run-forward?~ commands))
            (run-backward? (get-run-backward?~ commands))
            (blink-forward? (get-blink-forward?~ commands))
            (blink-backward? (get-blink-backward?~ commands)))
        (let ((gravity (compute-gravity~ world center))
              (factor (* elapse 65.))
              (fly? (get-fly?~ world))
              (run? (or run-forward? run-backward?))
              (blink? (or blink-forward? blink-backward?))
              (displacement (make-zero-vertex))
              (grace-slowdown .25)
              (grace-move? #f)
              (floor-level (get-floor-level~ zone))
              (history (get-history~ world))
              (animation #f))
          (define (process-commands)
            (when (and (get-modified?~ commands) (hook-commands~ world commands))
              (when (get-command?~ commands)
                (log-commands~ history commands elapse))
              ;; move forward
              (when (get-move-forward?~ commands)
                @step-sound
                (when ground?
                  (let ((now (current-seconds)))
                    (when (> (- now last-step) .25)
                      (set! last-step now)
                      (play-sound-file~ world "sound/step/stone2" volume: .5))))
                (movement-callback)
                (when (allow-movement?)
                  (move move-forward)
                  (animate (move-animation))))
              ;; move backward
              (when (get-move-backward?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-backward)
                  (animate "WalkBackwards")))
              ;; move left
              (when (get-move-left?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-left)
                  (animate "Run")))
              ;; move right
              (when (get-move-right?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-right)
                  (animate "Run")))
              ;; move up
              (when (get-move-up?~ commands)
                (move move-up))
              ;; move down
              (when (get-move-down?~ commands)
                (move move-down))
              ;; run forward
              (when run-forward?
                (movement-callback)
                (move run-forward)
                (animate "Run"))
              ;; run backward
              (when run-backward?
                (movement-callback)
                (move run-backward)
                (animate "Run"))
              ;; blink forward
              (when blink-forward?
                (movement-callback)
                (move blink-forward)
                (animate "Run"))
              ;; blink backward
              (when blink-backward?
                (movement-callback)
                (move blink-backward)
                (animate "WalkBackwards"))
              ;; rotate left
              (when (get-rotate-left?~ commands)
                (rotate-left factor))
              ;; rotate right
              (when (get-rotate-right?~ commands)
                (rotate-right factor))))
          
          (define (move proc)
            (cond ((or ground? ladder? fly? blink?)
                   (proc (* factor sprint) displacement))
                  ((and jumping? jump-grace?)
                   (proc (* factor sprint grace-slowdown) displacement)
                   (set! grace-move? #t)
                   (set! jump-grace? #f)))
            (when (> sprint-duration 0.)
              (decrease! sprint-duration elapse)
              (when (<= sprint-duration 0.)
                (set! sprint 1.)
                (set! sprint-duration 0.)
                (update-parameter~ world 'sprint))))
          
          (define (move-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-left factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-right~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-right factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-right~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-up factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-up~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-down factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-up~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (run-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self) (world-setting 'world.run-speed 5.)))))
          
          (define (run-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self) (world-setting 'world.run-speed 5.)))))
          
          (define (blink-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ camera) (* factor (vehicle-speed~ world self) (world-setting 'world.blink-speed 5.)))))
          
          (define (blink-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ camera) (* factor (vehicle-speed~ world self) (world-setting 'world.blink-speed 5.)))))
          
          (define player-rotation-speed <fl>
            0.02)
          
          (define (rotate-left factor)
            (rotate-actor-horizontal~ motion self (* player-rotation-speed factor)))
          
          (define (rotate-right factor)
            (rotate-actor-horizontal~ motion self (- (* player-rotation-speed factor))))
          
          (define (animate name)
            (set! animation name)
            (animate-model time name))
          
          (define (move-animation)
            "Run")
          
          (define (process-velocity)
            (cond ((or ground? ladder? fly? blink? grace-move?)
                   (vertex-scalar/! velocity displacement elapse))
                  ((or (not jumping?)
                       (> (- time jump-time) 1.))
                   (let ((friction (get-friction)))
                     (when friction
                       (let ((reduce (* friction elapse)))
                         (if (< (vertex-norm velocity) reduce)
                             (vertex-zero! velocity)
                           (vertex-decrease! velocity (vertex-scalar*& (vertex-normalize-safe& velocity) reduce)))))))))
          
          (define (process-gravity)
            (let ((normalized-gravity (vertex-normalize gravity)))
              (if (get-jump?~ commands)
                  (when (and jump-ready? (or run? blink? (and (or ground? ladder?) (not jumping?))))
                    (set! jumping? #t)
                    (set! jump-ready? #f)
                    (set! jump-grace? (and (allow-grace?) (vertex-zero? velocity)))
                    (set! jump-time time)
                    (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity (* (- (get-jump-impulsion~ world)) (cond (run? (world-setting 'world.run-jump 2.))
                                                                                                                             (blink? (world-setting 'world.blink-jump 1.5))
                                                                                                                             (else 1.)))))
                    (animate-model time :context))
                (set! jump-ready? #t))
              (when (> (dot-product fall-velocity normalized-gravity) max-fall-speed)
                (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity max-fall-speed)))))
          
          (define (collide-actor)
            (break-logic slide)
            (when (get-debug-collisions?)
              (reset-marks~ zone))
            (let* ((radiuses (transformed-radiuses))
                   (pumps (and (needs-pumps?~ zone) (get-pumps~ model)))
                   (pumped-center (if pumps
                                      (receive (pumped pumped-direction pumped-collisions) (collide&stop center (vertex+ center pumps) lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?)
                                        pumped)
                                    center))
                   (target-center (vertex+ pumped-center (vertex-scalar*& velocity elapse)))
                   (collide (case collision-response ((stop) collide&stop) ((slide) collide&slide))))
              ;; collide&slide
              (receive (new-center slide-direction slide-collisions) (site (collide&slide on?: #f parent: tick-actor) (collide pumped-center target-center lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players? debuggable-collisions?: #t))
                (let ((new-center (if pumps
                                      (receive (unpumped unpumped-direction unpumped-collisions) (collide&stop new-center (vertex- new-center pumps) lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?)
                                        unpumped)
                                    new-center)))
                  (break-action
                    (move-actor new-center))
                  (if (or (not gravity?) fly?)
                      (values new-center slide-collisions '())
                    (let ((adjusted (* elapse 50.)))
                      (define (xz-position&)
                        (vertex& (+ (fxceiling (get-x)) .5) 0. (+ (fxceiling (get-z)) .5)))
                      
                      ;; ladder
                      (set! ladder? (some? (lambda (collision) (= (fxround (get-data1~ (get-polygon~ collision))) 65)) slide-collisions))
                      (cond (ladder?
                              (when (not ladder-shaft)
                                (set! ladder-shaft (make-vertex)))
                              (vertex-copy! ladder-shaft (xz-position&)))
                            (else
                             (when ladder-shaft
                               (if (vertex=? (xz-position&) ladder-shaft)
                                   (if (not-null? slide-collisions)
                                       (set! ladder? #t)
                                     ;; slow fall
                                     (set! adjusted (/ adjusted 3.)))
                                 (set! ladder-shaft #f)))))
                      (break-logic fall)
                      (break-action
                        (when (get-debug-collisions?)
                          (reset-marks~ zone)))
                      (vertex+! fall-velocity fall-velocity (vertex-scalar*& gravity adjusted))
                      (let ((target-fall (vertex+& new-center (if (and ladder? (not (vertex-zero? velocity)))
                                                                  ;; climb up
                                                                  (vertex 0. (* elapse 3.5) 0.)
                                                                (vertex+& (vertex-scalar*& fall-velocity adjusted) (vertex-scalar*& gravity (* .5 adjusted adjusted)))))))
                        ;; collide&stop
                        (receive (new-fall fall-direction fall-collisions) (site (collide&stop on?: #f parent: tick-actor) (collide&stop new-center target-fall lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players? debuggable-collisions?: #t))
                          (values new-fall slide-collisions fall-collisions)))))))))
          
          (define (hit-collisions new-center slide-collisions fall-collisions)
            (define (ground-update flag velocity)
              (when (neq? ground? flag)
                (set! ground? flag)
                (if ground?
                    (hit-ground velocity exit)
                  (leave-ground exit))))
            
            (hit slide-collisions exit)
            (let ((floor-level (and floor-level (+ floor-level (get-radius-y))))
                  (velocity (copy-vertex fall-velocity)))
              (if (and floor-level (< (vertex-y new-center) floor-level) (not fly?))
                  (begin
                    (hit-floor exit)
                    (vertex-y-set! new-center floor-level)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))
                (let ((fall-collided? (not-null? fall-collisions)))
                  (if (not fall-collided?)
                      (ground-update #f #f)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))))))
          
          (define (move-actor new-center)
            (let ((movement (vertex- new-center center)))
              (let ((new-position (vertex+ position movement))
                    (old-position (copy-vertex position)))
                (set-position new-position)
                (position-change)
                (update-element~ zone self old-position)
                (set! center new-center)
                movement)))
          
          (define (rotate-model movement)
            (let ((me (current-me))
                  (model (cache-model)))
              (when (eq? self me)
                (let ((distance (/ (dot-product (get-sight~ lookat) movement) (get-radius))))
                  (define (set-x-rotation name)
                    (let ((model (child~ model name)))
                      (vertex-x-set! (get-rotation~ model) rotation)
                      (update-matrix~ model)))
                  
                  (when (/= distance 0.)
                    (decrease! rotation distance)
                    (case (get-name~ model)
                      ((Character)
                       (set-x-rotation 'body))
                      ((CharacterOnWheels CharacterOnHummer)
                       (set-x-rotation 'wheel1)
                       (set-x-rotation 'wheel2)
                       (set-x-rotation 'wheel3)
                       (set-x-rotation 'wheel4))))))))
          
          (define (realign-actor slide-collisions fall-collisions)
            (define (average-normal)
              (let ((factor-sum 0.)
                    (dir-sum (make-zero-vertex)))
                (define (process-collisions collisions)
                  (for-each (lambda (collision)
                              (let ((plane (get-plane~ collision)))
                                (let ((origin (get-origin~ plane))
                                      (normal (get-normal~ plane)))
                                  (let ((dist (vertex-distance origin center)))
                                    (let ((factor (/ (+ 1. dist))))
                                      (increase! factor-sum factor)
                                      (vertex+! dir-sum dir-sum (vertex-scalar* normal factor-sum)))))))
                            collisions))
                
                (process-collisions slide-collisions)
                (process-collisions fall-collisions)
                (vertex-scalar/ dir-sum factor-sum)))
            
            (when (and gravity? (not fly?))
              (update-world-up~ world gravity)
              (case orientation
                ((vertical)
                 (realign-lookat (gravity-up gravity)))
                ((horizontal)
                 (when (or (not-null? slide-collisions)
                           (not-null? fall-collisions))
                   (remove-up-roll! lookat (average-normal) lookat)
                   (update-matrix))))))
          
          (define (realign-horizon)
            (when (and gravity? (not fly?) (eq? self me) (is? motion Person-Motion))
              (break-logic realign-horizon)
              (let ((final-gravity (compute-gravity~ world center)))
                (set-lookat~ camera (realign-lookat-horizon& (get-lookat~ camera) (get-up~ lookat) gravity final-gravity))
                (camera-update~ camera))))
          
          (define (center-eye)
            (when (eq? self me)
              (eye-center-player~ motion)))
          
          (define (verify-death)
            (when (and die-bottom (< (get-y) die-bottom))
              (lose~ world self)
              (continuation-return exit)))
          
          (process-commands)
          (process-velocity)
          (process-gravity)
          (when (not animation)
            (animate-model time :context))
          (receive (new-center slide-collisions fall-collisions) (collide-actor)
            (hit-collisions new-center slide-collisions fall-collisions)
            (let ((movement (move-actor new-center)))
              (rotate-model movement)
              (realign-actor slide-collisions fall-collisions)
              (unless (vertex-zero? movement)
                (realign-horizon)
                (center-eye)
                (verify-death))))))))
  
  
  (method protected virtual (tick-slice)
    #f)
  
  
  (method protected virtual (tick-actions commands)
    )
  
  
  (method (tick-actor-actions commands)
    (let ((world (current-world)))
      (when (get-modified?~ commands)
        (for-each (lambda (action)
                    (bind (name . arguments) action
                      (tick-actor-action name arguments)))
                  (get-actions~ commands)))))
  
  
  (method protected virtual (tick-actor-action name arguments)
    (let ((world (current-world)))
      (let ((history (get-history~ world)))
        (log-action~ history name arguments))
      (when (hook-action~ world name arguments)
        (case name
          ((track)
           (bind (dh dv eye-sight eye-up eye-right first?) arguments
             (track-actor~ (current-motion) self dh dv eye-sight eye-up eye-right first?)))
          ((add)
           (bind (mode class grid? grid-plane grid-position floor-grid? eye direction stage) arguments
             (editor-add~ world mode class grid? grid-plane grid-position floor-grid? eye direction stage)))
          ((delete)
           (bind (position) arguments
             (editor-delete~ world position)))
          ((fire)
           (when (person-motion?)
             (bind (direction kind) arguments
               (fire-missile direction kind))))
          ((rapid-fire)
           (start-rapid-fire))))))
  
  
  (method protected virtual (ignore-entities?)
    #t)
  
  
  (method protected virtual (ignore-players?)
    #f)
  
  
  (method protected virtual (position-change)
    )
  
  
  (method protected virtual (hit collisions exit)
    )
  
  
  (method protected virtual (hit-floor exit)
    )
  
  
  (method protected virtual (hit-ground velocity exit)
    )
  
  
  (method protected virtual (leave-ground exit)
    )
  
  
  (method protected virtual (ground-speed)
    0.1)
  
  
  (method protected virtual (movement-callback)
    )
  
  
  (method protected virtual (allow-movement?)
    #t)
  
  
  (method protected virtual (allow-grace?)
    #t)
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method protected virtual (is-player?)
    #f)
  
  
  (method protected virtual (move-animation)
    "Walk")
  
  
  (method protected virtual (animate-model time name (duration: duration #f) (next: next #f))
    (let ((jump-start-frame 8.))
      (let ((elapsed (and animation-start (- time animation-start))))
        (unless (not morphing)
          (let ((fall? (not ground?)))
            (unless jumping?
              (if fall?
                  (when (not animation-fall)
                    (set! animation-fall time))
                (set! animation-fall #f)))
            (when (or (not animation-fall)
                      ;; to not switch non-stop between run and fall while running down a slope
                      (> (- time animation-fall) .5))
              (let ((model (cache-model)))
                (define (determine-animation proc)
                  (cond (jumping? (proc '("JumpStart" "Jump") (list "Jump")))
                        (fall? (proc '("Fall") (list #f)))
                        (else (proc (if (eq? name :context)
                                        (list "Idle")
                                      (listify name))
                                    (list #f)))))
                
                (define (existing-animation animation-list)
                  (let (iter (scan animation-list))
                    (if (null? scan)
                        #f
                      (let ((animation (car scan)))
                        (if (find-animation~ model animation)
                            animation
                          (iter (cdr scan)))))))
                
                (determine-animation
                  (lambda (animation-list next-list)
                    (let ((animation (existing-animation animation-list))
                          (next (existing-animation next-list)))
                      (unless (equal? animation-active animation)
                        (let ((previous animation-active))
                          (set! animation-active animation)
                          (set! animation-start time)
                          (let ((jumping? (or (equal? previous "JumpStart")
                                              (equal? previous "Jump"))))
                            (cond ((and jumping? (equal? animation "Idle"))
                                   (change-morphing "JumpEnd" next: "Idle"))
                                  ((and jumping? (equal? animation "Run"))
                                   (change-morphing "JumpLandRun" next: "Run"))
                                  (else
                                   (let ((frame (if (equal? animation-active "JumpStart") jump-start-frame #f))
                                         (duration (if (not previous) .1 #f)))
                                     (transition-morphing animation-active frame: frame duration: duration next: next)))))))))))))))))
  
  
  ;;;
  ;;;; Missiles
  ;;;
  
  
  (method protected (increase-missiles)
    (increase! missiles-count))
  
  
  (method protected (decrease-missiles)
    (decrease! missiles-count))
  
  
  (method protected (get-self-wound-grace)
    .1)
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-target color)
    (draw-target-circle))))
