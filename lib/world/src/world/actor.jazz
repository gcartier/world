;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Actors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.actor jazz


(import (jazz.syntax (phase syntax))
        (jazz.geometry)
        (world)
        (world.animation)
        (world.audio)
        (world.autoload)
        (world.collision)
        (world.commands)
        (world.dye)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.motion)
        (world.settings)
        (world.spell)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Actor
;;;


(definition *global-cooldown*
  0.5)

(definition protected max-fall-speed <fl>
  1.25)

(definition protected die-bottom <fl+>
  #f)


(class Actor extends Entity
  
  
  (properties (;; component
               name visible?
               ;; element
               position lookat scale radiuses radius color user-data
               ;; entity
               model animate? animation)
    
    (slot velocity                <f64vector>  initialize (make-zero-vertex) getter generate)
    (slot fall-velocity           <f64vector>  initialize (make-zero-vertex) getter generate)
    (slot life                    <fl>         initialize 100.               accessors generate)
    (slot global-cooldown         <fl>         initialize 0.                 accessors generate)
    (slot spell                   <Spell+>     initialize #f                 accessors generate)
    (slot adjustments             <list>       initialize '()                accessors generate)
    (slot rapid-fire-acceleration <fl>         initialize 1.                 accessors generate)
    (slot rapid-fire-duration     <fl>         initialize 0.                 accessors generate)
    (slot rapid-fire-cooldown     <fl>         initialize 0.                 accessors generate)
    (slot last-missile            <fl+>        initialize #f                 accessors generate)
    (slot max-missiles            <fx>         initialize 10                 accessors generate)
    (slot missiles-count          <fx>         initialize 0                  accessors generate)
    (slot history-color           <object>     initialize #f                 accessors generate)
    (slot jumping?                <bool>       initialize #f                 accessors generate)
    (slot jump-ready?             <bool>       initialize #f                 accessors generate)
    (slot jump-grace?             <bool>       initialize #f                 accessors generate)
    (slot jump-time               <fl>         initialize 0.                 accessors generate)
    (slot ground?                 <bool>       initialize #f                 accessors generate)
    (slot water?                  <bool>       initialize #f                 accessors generate)
    (slot swim-timer              <fl>         initialize 0.                 accessors generate)
    (slot water-jump?             <bool>       initialize #f                 accessors generate)
    (slot ladder?                 <bool>       initialize #f                 accessors generate)
    (slot ladder-shaft            <f64vector+> initialize #f                 accessors generate)
    (slot last-step               <fl>         initialize 0.                 accessors generate)
    (slot rotation                <fl>         initialize 0.                 accessors generate)
    (slot orientation             <object>     initialize 'vertical          accessors generate)
    (slot sprint                  <fl>         initialize 1.                 accessors generate)
    (slot sprint-duration         <fl>         initialize 0.                 accessors generate)
    (slot animation-active        <object>     initialize #f                 accessors generate)
    (slot animation-fall          <object>     initialize #f                 accessors generate))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (let ((color (copy-dye color)))
      (dye-alpha-set! color .2)
      (set! history-color color)))
  
  
  (method public inline (set-velocity vel <f64vector>) <void>
    (vertex-copy! velocity vel))
  
  
  (method public inline (set-fall-velocity vel <f64vector>) <void>
    (vertex-copy! fall-velocity vel))
  
  
  (method override (call-model-update model)
    (nextmethod model)
    (set! animation-active #f)
    (set! animation-fall #f))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (definition missile-delay <fl>
    .1)

  
  ;(method (maybe-add-action name arguments)
  ;  (if (<= global-cooldown 0.)
  ;      (add-action~ commands name (arguments))
  ;    (set! global-cooldown (- global-cooldown 0.))))
  
  
  (method (maybe-fire commands kind)
    (let ((seconds (current-seconds)))
      (when (or (not last-missile)
                (> (- seconds last-missile) (/ missile-delay rapid-fire-acceleration)))
        (fire commands kind)
        (set! last-missile seconds))))
  
  
  (method (fire commands kind)
    (let ((direction (aim-direction)))
      (add-action~ commands 'fire (list direction kind))))
  
  
  (method (fire-missile direction kind)
    (let ((world (current-world))
          (zone (current-zone)))
      (when (< missiles-count max-missiles)
        (let ((lens (player-lens~ world self))
              ;; because the radius is cubic at the moment
              (adjusted-radius (/ (get-radius) 1.8)))
          (let ((pos (vertex+ lens (vertex-scalar*& direction adjusted-radius))))
            (let ((missile (new (missile-class~ world) parent: world position: pos actor: self kind: kind)))
              (increase-missiles)
              (set-velocity~ missile (vertex-scalar*& direction (missile-speed~ missile)))
              (add-element~ zone missile)))))))
  
  
  (method (aim-direction)
    (let ((world (current-world)))
      (let ((eye (get-eye~ world)))
        (if (get-free-aim?~ world)
            (get-sight~ eye)
          (cross-normal (get-up~ eye) (get-right~ lookat))))))
  
  
  (method (start-rapid-fire)
    (set! rapid-fire-acceleration 3.)
    (set! rapid-fire-duration 15.)
    (set! rapid-fire-cooldown 45.))
  
  
  (method (warp-forward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) 2.)))
      (follow-player~ world)))
  
  
  (method (warp-backward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) -2.)))
      (follow-player~ world)))
  
  
  (method (start-sprint)
    (let ((world (current-world)))
      (set! sprint 5.)
      (set! sprint-duration 10.)
      (update-parameter~ world 'sprint)))
  
  
  (method public virtual (damage amount critical?)
    (play-3d-sound (if critical? (wound-critical-sound) (wound-sound)) position)
    (decrease! life amount)
    (when (<= life 0)
      (die)))
  
  
  (method protected virtual (attack-amount amount)
    amount)
  
  
  (method public virtual (wound inflictor)
    (let ((critical? (> (random-real) .5)))
      (let ((amount (attack-amount~ inflictor (wound-amount critical?))))
        (damage amount critical?))))
  
  
  (method public virtual (wound-amount critical?)
    (if critical? 20. 10.))
  
  
  (method public virtual (wound-sound)
    #f)
  
  
  (method public virtual (wound-critical-sound)
    #f)
  
  
  (method public virtual (die)
    (let ((world (current-world)))
      (play-3d-sound (death-sound) position)
      (remove-element~ world self)))
  
  
  (method public virtual (death-sound)
    #f)
  
  
  (method public virtual (stomp)
    #f)
  
  
  (method protected virtual (get-friction)
    4.)
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  ;; (slot position      <f64vector>)    ;; position
  ;; (slot lookat        <LookAt>)       ;; lookat is always perpendicular to gravity
  ;; (slot scale         <f64vector>)    ;; scale
  ;; (slot matrix        <f64vector>)    ;; matrix
  ;; (slot radiuses      <f64vector+>)   ;; radiuses
  ;; (slot radius        <fl+>)          ;; radius
  ;; (slot velocity      <f64vector>)    ;; velocity
  ;; (slot fall-velocity <f64vector>)    ;; fall-velocity
  ;; (slot jumping?      <bool>)         ;; are we currently jumping
  ;; (slot jump-ready?   <bool>)         ;; so holding the jump key only jumps once
  ;; (slot jump-grace?   <bool>)         ;; a standing jump allows us one last move
  ;; (slot jump-time     <fl>)           ;; time of current jump
  ;; (slot ground?       <bool>)         ;; are we currently in contact with the ground
  ;; (slot water?        <bool>)         ;; are we colliding with a water polygon
  ;; (slot swim-timer    <bool>)         ;; time before able to swim up
  ;; (slot water-jump?   <bool>)         ;; jump when we get out of water
  ;; (slot ladder?       <bool>)         ;; are we climbing up a ladder
  ;; (slot ladder-shaft  <f64vector+>)   ;; the xz of the shaft we are climbing in
  ;; (slot last-step     <fl>)           ;; last time we played a step sound
  ;; (slot rotation      <fl>)           ;; rotation for the character model
  ;; (slot orientation   <object>)       ;; vertical or horizontal like for four-legged creatures
  ;; (slot sprint        <fl>)           ;; temporary speed increase
  
  (method (tick-actor commands <Commands> time <fl> elapse <fl> exit gravity? collision-response (ignore-entities?: ignore-entities? (ignore-entities?)) (ignore-players?: ignore-players? (ignore-players?)))
    (site (tick-actor on?: #f parent: player)
      (let ((world (current-world))
            (zone (current-zone))
            (me (current-me))
            (motion (current-motion))
            (camera (current-camera))
            (model (cache-model))
            (center (transformed-center))
            (run-forward? (get-run-forward?~ commands))
            (run-backward? (get-run-backward?~ commands))
            (blink-forward? (get-blink-forward?~ commands))
            (blink-backward? (get-blink-backward?~ commands)))
        (let ((gravity (compute-gravity~ world center))
              (fly? (get-fly?~ world))
              (run? (or run-forward? run-backward?))
              (blink? (or blink-forward? blink-backward?))
              (displacement (make-zero-vertex))
              (grace-slowdown .25)
              (grace-move? #f)
              (floor-level (get-floor-level~ zone))
              (history (get-history~ world))
              (animation #f))
          (define (process-commands)
            (when (and (get-modified?~ commands) (hook-commands~ world commands))
              (when (get-command?~ commands)
                (log-commands~ history commands elapse))
              ;; move forward
              (when (get-move-forward?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-forward)
                  (animate (move-animation))))
              ;; move backward
              (when (get-move-backward?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-backward)
                  (animate "WalkBackwards")))
              ;; move left
              (when (get-move-left?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-left)
                  (animate "Run")))
              ;; move right
              (when (get-move-right?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-right)
                  (animate "Run")))
              ;; move up
              (when (get-move-up?~ commands)
                (move move-up))
              ;; move down
              (when (get-move-down?~ commands)
                (move move-down))
              ;; run forward
              (when run-forward?
                (movement-callback)
                (move run-forward)
                (animate "Run"))
              ;; run backward
              (when run-backward?
                (movement-callback)
                (move run-backward)
                (animate "Run"))
              ;; blink forward
              (when blink-forward?
                (movement-callback)
                (move blink-forward)
                (animate "Run"))
              ;; blink backward
              (when blink-backward?
                (movement-callback)
                (move blink-backward)
                (animate "WalkBackwards"))
              ;; rotate left
              (when (get-rotate-left?~ commands)
                (rotate-left))
              ;; rotate right
              (when (get-rotate-right?~ commands)
                (rotate-right))))
          
          (define (move proc)
            (cond ((and water? (>= swim-timer 0.))
                    (proc (* sprint 0.75) displacement))
                  ((or ground? ladder? fly? blink?)
                   (proc sprint displacement))
                  ((and jumping? jump-grace?)
                   (proc (* sprint grace-slowdown) displacement)
                   (set! grace-move? #t)
                   (set! jump-grace? #f)))
            (when (> sprint-duration 0.)
              (decrease! sprint-duration elapse)
              (when (<= sprint-duration 0.)
                (set! sprint 1.)
                (set! sprint-duration 0.)
                (update-parameter~ world 'sprint))))
          
          (define (move-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-left factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-right~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-right factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-right~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-up factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-up~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-down factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-up~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (run-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self) (world-setting 'world.run-speed 5.)))))
          
          (define (run-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self) (world-setting 'world.run-speed 5.)))))
          
          (define (blink-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ camera) (* factor (vehicle-speed~ world self) (world-setting 'world.blink-speed 5.)))))
          
          (define (blink-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ camera) (* factor (vehicle-speed~ world self) (world-setting 'world.blink-speed 5.)))))
          
          (define player-rotation-speed <fl>
            1.3)
          
          (define (rotate-left)
            (rotate-actor-horizontal~ motion self (* player-rotation-speed elapse)))
          
          (define (rotate-right)
            (rotate-actor-horizontal~ motion self (- (* player-rotation-speed elapse))))
          
          (define (animate name)
            (set! animation name)
            (animate-model time name))
          
          (define (move-animation)
            "Run")
          
          (define (process-velocity)
            (cond ((or ground? ladder? fly? blink? grace-move? (and water? (moving?~ commands)))
                   (vertex-copy! velocity displacement))
                  ((or (not jumping?)
                       (> (- time jump-time) 1.))
                   (let ((friction (get-friction)))
                     (when friction
                       (let ((reduce (* friction elapse (if water? 4. 1.))))
                         (if (< (vertex-norm velocity) reduce)
                             (vertex-zero! velocity)
                           (vertex-decrease! velocity (vertex-scalar*& (vertex-normalize-safe& velocity) reduce)))))))))
          
          (define (process-gravity)
            (let ((normalized-gravity (vertex-normalize gravity)))
              (if (get-jump?~ commands)
                  (when (or water-jump? (and jump-ready? (or run? blink? water? (and (or ground? ladder?) (not jumping?)))))
                    (unless (and water? (not water-jump?))
                      (set! jumping? #t)
                      (set! jump-ready? #f)
                      (set! jump-grace? (and (allow-grace?) (vertex-zero? velocity)))
                      (set! jump-time time))
                    (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity (* (- (/ (get-jump-impulsion~ world) (if water-jump? 2. 1.))) (cond (run? (world-setting 'world.run-jump 2.))
                                                                                                                                                        (blink? (world-setting 'world.blink-jump 1.5))
                                                                                                                                                        (water? (/ 1. 3.))
                                                                                                                                                        (else 1.)))))
                    (when water-jump? (set! water-jump? #f))
                    (animate-model time :context))
                (unless water?
                  (set! jump-ready? #t)))
              (when (> swim-timer 0.)
                (decrease! swim-timer elapse)
                (when (<= swim-timer 0.)
                  (set! swim-timer 0.)
                  (set! jump-ready? #t)))
              (when (and (not jump-ready?) (vertex-zero? fall-velocity))
                (set! jump-ready? #t))
              (when (> (dot-product fall-velocity normalized-gravity) (if water? 0.01 max-fall-speed))
                (if water?
                    (vertex-y-set! fall-velocity (* (vertex-y fall-velocity) (if (< (vertex-y fall-velocity) -0.1) 0.7 0.5)))
                  (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity max-fall-speed))))))
          
          (define (collide-actor)
            (break-logic slide)
            (when (get-debug-collisions?)
              (reset-marks~ zone))
            (let* ((radiuses (transformed-radiuses))
                   (pumps (and (needs-pumps?~ zone) (get-pumps~ model)))
                   (pumped-center (if pumps
                                      (receive (pumped pumped-direction pumped-collisions) (collide&stop center (vertex+ center pumps) lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?)
                                        pumped)
                                    center))
                   (target-center (vertex+ pumped-center (vertex-scalar*& velocity elapse)))
                   (collide (case collision-response ((stop) collide&stop) ((slide) collide&slide))))
              ;; collide&slide
              (receive (new-center slide-direction slide-collisions) (site (collide&slide on?: #f parent: tick-actor) (collide pumped-center target-center lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players? debuggable-collisions?: #t))
                (receive (new-slide-collisions water-collisions?) (liquid? slide-collisions)
                  (when water-collisions? 
                    (receive (new-center-2 slide-direction-2 slide-collisions-2) (site (collide&stop on?: #f parent: tick-actor) (collide pumped-center target-center lookat radiuses polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? debuggable-collisions?: #t))
                      (set! new-center new-center-2)
                      (set! slide-collisions slide-collisions-2))))
                (let ((new-center (if pumps
                                      (receive (unpumped unpumped-direction unpumped-collisions) (collide&stop new-center (vertex- new-center pumps) lookat radiuses polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players?)
                                        unpumped)
                                    new-center)))
                  (break-action
                    (move-actor new-center))
                  (if (or (not gravity?) fly?)
                      (values new-center slide-collisions '())
                    (let ((adjusted (* elapse 50.)))
                      (define (xz-position&)
                        (vertex& (+ (fxceiling (get-x)) .5) 0. (+ (fxceiling (get-z)) .5)))
                      
                      ;; ladder
                      (set! ladder? (some? (lambda (collision) (= (fxround (get-data1~ (get-polygon~ collision))) 65)) slide-collisions))
                      (cond (ladder?
                              (when (not ladder-shaft)
                                (set! ladder-shaft (make-vertex)))
                              (vertex-copy! ladder-shaft (xz-position&)))
                            (else
                             (when ladder-shaft
                               (if (vertex=? (xz-position&) ladder-shaft)
                                   (if (not-null? slide-collisions)
                                       (set! ladder? #t)
                                     ;; slow fall
                                     (set! adjusted (/ adjusted 3.)))
                                 (set! ladder-shaft #f)))))
                      
                      (break-logic fall)
                      (break-action
                        (when (get-debug-collisions?)
                          (reset-marks~ zone)))
                      (vertex+! fall-velocity fall-velocity (vertex-scalar*& gravity adjusted))
                      (let ((target-fall (vertex+& new-center (if (and ladder? (not (vertex-zero? velocity)))
                                                                  ;; climb up
                                                                  (vertex 0. (* elapse 3.5) 0.)
                                                                (vertex+& (vertex-scalar*& fall-velocity adjusted) (vertex-scalar*& gravity (* .5 adjusted adjusted)))))))
                        ;; collide&stop
                        (receive (new-fall fall-direction fall-collisions) (site (collide&stop on?: #f parent: tick-actor) (collide&stop new-center target-fall lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players? debuggable-collisions?: #t))
                          (receive (new-fall-collisions water-collisions?) (liquid? fall-collisions)
                            (when water-collisions?
                              (receive (new-fall-2 fall-direction fall-collisions) (site (collide&stop on?: #f parent: tick-actor) (collide&stop new-center target-fall lookat radiuses polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? debuggable-collisions?: #t))
                                (set! new-fall new-fall-2)))
                            (values new-fall slide-collisions fall-collisions))))))))))
          
          (define (liquid? fall-collisions)
            (let ((new-collisions (new-queue))
                  (water-polygons (new-queue)))
              (for-each (lambda (collision)
                          (let ((poly (get-polygon~ collision)))
                            (if (get-water-cube?~ (world.external.minecraft:blockid->block (fxround (get-data1~ poly))))
                                (enqueue water-polygons poly)
                              (enqueue new-collisions collision))))
                        fall-collisions)
              (unless (queue-empty? water-polygons)
                (let ((entering? (entering-water? (queue-list water-polygons))))
                  (when (neq? entering? water?)
                    (set! water? entering?)
                    (when (eq? self me)
                      (if water?
                          (play-ambience~ (current-ambience) "ambience/water/Underwater")
                        (change-ambience~ (current-ambience)))))))
              (values (queue-list new-collisions) (not (queue-empty? water-polygons)))))
          
          (define (entering-water? water-polygons)
            (let ((poly (car water-polygons))) ;; For now we consider only one
              (let ((angle (radian->degree (vector-angle (get-normal~ poly) (vertex+ velocity fall-velocity)))))
                (cond ((< angle 90.)
                       (let ((block (get-block (current-me))))
                         (if (get-water-cube?~ (world.external.minecraft:blockid->block block))
                             #t
                           (begin
                             (set! water-jump? #t)
                             #f))))
                      (else
                       (set! jumping? #f)
                       (set! grace-move? #f)
                       (set! jump-time time)
                       (set! water-jump? #f)
                       (if (/= (vertex-y (get-normal~ poly)) 0)
                           (begin
                             (set! jump-ready? #f)
                             (set! swim-timer (* (abs (vertex-y fall-velocity)) 2)))
                         (set! jump-ready? #t))
                       #t)))))
          
          (define (liquid-filter poly)
            (not (get-water-cube?~ (world.external.minecraft:blockid->block (fxround (get-data1~ poly))))))
          
          (define (get-block actor)
            (let ((pos (get-position~ actor)))
              (call-with-position~ ?z pos
                (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                  (with-field i (+ j 1) k
                    (lambda (section index)
                      (if section
                          (block-ref section index)
                        0)))))))
          
          (define (hit-collisions new-center slide-collisions fall-collisions)
            (define (ground-update flag velocity)
              (when (neq? ground? flag)
                (set! ground? flag)
                (if ground?
                    (hit-ground velocity exit)
                  (leave-ground exit))))
            
            (hit slide-collisions exit)
            (let ((floor-level (and floor-level (+ floor-level (get-radius-y))))
                  (velocity (copy-vertex fall-velocity)))
              (if (and floor-level (< (vertex-y new-center) floor-level) (not fly?))
                  (begin
                    (hit-floor velocity exit)
                    (vertex-y-set! new-center floor-level)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))
                (let ((fall-collided? (not-null? fall-collisions)))
                  (if (not fall-collided?)
                      (ground-update #f #f)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))))))
          
          (define (foot-step fall-collisions)
            (when (and (or ground? @not-really-nice ladder?) (not water?))
              (let ((speed (vertex-norm velocity)))
                (when (> speed 0.)
                  (when (> (- time last-step) (/ 2.1 speed))
                    (set! last-step time)
                    (let ((kind (cond @not-really-nice
                                      (ladder?
                                       'ladder)
                                      ((null? fall-collisions)
                                       'stone)
                                      (else
                                       (let ((collision (car fall-collisions)))
                                         (let ((id (fxround (get-data1~ (get-polygon~ collision)))))
                                           (case id
                                             ((2) 'grass)
                                             ((5) 'wood)
                                             ((12 13) 'dirt)
                                             ((78 79 80) 'snow)
                                             (else 'stone))))))))
                      (play-sound-file (random-step kind) volume: .075)))))))
          
          (define (move-actor new-center)
            (let ((movement (vertex- new-center center)))
              (let ((new-position (vertex+ position movement))
                    (old-position (copy-vertex position)))
                (set-position new-position)
                (position-change)
                (update-element~ zone self old-position)
                (set! center new-center)
                movement)))
          
          (define (rotate-model movement)
            (let ((me (current-me))
                  (model (cache-model)))
              (when (eq? self me)
                (let ((distance (/ (dot-product (get-sight~ lookat) movement) (get-radius))))
                  (define (set-x-rotation name)
                    (let ((model (child~ model name)))
                      (vertex-x-set! (get-rotation~ model) rotation)
                      (update-matrix~ model)))
                  
                  (when (/= distance 0.)
                    (decrease! rotation distance)
                    (case (get-name~ model)
                      ((Character)
                       (set-x-rotation 'body))
                      ((CharacterOnWheels CharacterOnHummer)
                       (set-x-rotation 'wheel1)
                       (set-x-rotation 'wheel2)
                       (set-x-rotation 'wheel3)
                       (set-x-rotation 'wheel4))))))))
          
          (define (realign-actor slide-collisions fall-collisions)
            (define (average-normal)
              (let ((factor-sum 0.)
                    (dir-sum (make-zero-vertex)))
                (define (process-collisions collisions)
                  (for-each (lambda (collision)
                              (let ((plane (get-plane~ collision)))
                                (let ((origin (get-origin~ plane))
                                      (normal (get-normal~ plane)))
                                  (let ((dist (vertex-distance origin center)))
                                    (let ((factor (/ (+ 1. dist))))
                                      (increase! factor-sum factor)
                                      (vertex+! dir-sum dir-sum (vertex-scalar* normal factor-sum)))))))
                            collisions))
                
                (process-collisions slide-collisions)
                (process-collisions fall-collisions)
                (vertex-scalar/ dir-sum factor-sum)))
            
            (when (and gravity? (not fly?))
              (update-world-up~ world gravity)
              (case orientation
                ((vertical)
                 (realign-lookat (gravity-up gravity)))
                ((horizontal)
                 (when (or (not-null? slide-collisions)
                           (not-null? fall-collisions))
                   (remove-up-roll! lookat (average-normal) lookat)
                   (update-matrix))))))
          
          (define (realign-horizon)
            (when (and gravity? (not fly?) (eq? self me) (is? motion Person-Motion))
              (break-logic realign-horizon)
              (let ((final-gravity (compute-gravity~ world center)))
                (set-lookat~ camera (realign-lookat-horizon& (get-lookat~ camera) (get-up~ lookat) gravity final-gravity))
                (camera-update~ camera))))
          
          (define (center-eye)
            (when (eq? self me)
              (eye-center-player~ motion)))
          
          (define (verify-death)
            (when (and die-bottom (< (get-y) die-bottom))
              (lose~ world self)
              (continuation-return exit)))
          
          (process-commands)
          (process-velocity)
          (process-gravity)
          (when (not animation)
            (animate-model time :context))
          (receive (new-center slide-collisions fall-collisions) (collide-actor)
            (hit-collisions new-center slide-collisions fall-collisions)
            (foot-step fall-collisions)
            (let ((movement (move-actor new-center)))
              (rotate-model movement)
              (realign-actor slide-collisions fall-collisions)
              (unless (vertex-zero? movement)
                (realign-horizon)
                (center-eye)
                (verify-death))))))))
  
  
  (method protected virtual (tick-slice)
    #f)
  
  
  (method protected virtual (tick-actions commands)
    )
  
  
  (method (tick-actor-actions commands)
    (let ((world (current-world)))
      (when (get-modified?~ commands)
        (for-each (lambda (action)
                    (bind (name . arguments) action
                      (tick-actor-action name arguments)))
                  (get-actions~ commands)))))
  
  
  (method protected virtual (tick-actor-action name arguments)
    (let ((world (current-world)))
      (let ((history (get-history~ world)))
        (log-action~ history name arguments))
      (when (hook-action~ world name arguments)
        (case name
          ((track)
           (bind (dh dv eye-sight eye-up eye-right first?) arguments
             (track-actor~ (current-motion) self dh dv eye-sight eye-up eye-right first?)))
          ((add)
           (bind (mode class grid? grid-plane grid-position floor-grid? eye direction stage) arguments
             (editor-add~ world mode class grid? grid-plane grid-position floor-grid? eye direction stage)))
          ((delete)
           (bind (position) arguments
             (editor-delete~ world position)))
          ((fire)
           (when (person-motion?)
             (bind (direction kind) arguments
               (fire-missile direction kind))))
          ((rapid-fire)
           (start-rapid-fire))))))
  
  
  (method protected virtual (ignore-entities?)
    #t)
  
  
  (method protected virtual (ignore-players?)
    #f)
  
  
  (method protected virtual (position-change)
    )
  
  
  (method protected virtual (hit collisions exit)
    )
  
  
  (method protected virtual (hit-floor velocity exit)
    )
  
  
  (method protected virtual (hit-ground velocity exit)
    (let ((vertical-speed (abs (vertex-y velocity))))
      (if water?
          (when (> vertical-speed 1.)
            (play-3d-sound "sound/water/EnterWaterSmallA" position))
        (let ((minimum-speed .6))
          (let ((hurt (- vertical-speed minimum-speed)))
            (when (> hurt 0.)
              (let ((normalized (/ hurt (- max-fall-speed minimum-speed))))
                (let ((amount (* (expt normalized 2.) 100.)))
                  (damage amount #f)))))))))
  
  
  (method protected virtual (leave-ground exit)
    )
  
  
  (method protected virtual (ground-speed)
    6.5)
  
  
  (method protected virtual (movement-callback)
    )
  
  
  (method protected virtual (allow-movement?)
    #t)
  
  
  (method protected virtual (allow-grace?)
    #t)
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method protected virtual (is-player?)
    #f)
  
  
  (method protected virtual (move-animation)
    "Walk")
  
  
  (method protected virtual (animate-model time name (duration: duration #f) (next: next #f))
    (let ((elapse-before-fall .5)
          (jump-start-frame 8.))
      (unless (not morphing)
        (let ((fall? (not ground?)))
          (unless jumping?
            (if fall?
                (when (not animation-fall)
                  (set! animation-fall time))
              (set! animation-fall #f)))
          (when (or (not animation-fall)
                    (equal? name :context)
                    ;; to not switch non-stop between run and fall while running down a slope
                    (> (- time animation-fall) elapse-before-fall))
            (let ((model (cache-model)))
              (define (determine-animation proc)
                (cond (water? (proc (if (eq? name :context) '("SwimIdle") '("Swim")) #f))
                      (jumping? (proc '("JumpStart" "Jump") (list "Jump")))
                      (fall? (proc '("Fall") #f))
                      (else (proc (if (eq? name :context)
                                      (list "Idle")
                                    (listify name))
                                  #f))))
              
              (define (existing-animation animation-list)
                (let (iter (scan animation-list))
                  (if (or (not scan)
                          (null? scan))
                      #f
                    (let ((animation (car scan)))
                      (if (find-animation~ model animation)
                          animation
                        (iter (cdr scan)))))))
              
              (determine-animation
                (lambda (animation-list next-list)
                  (let ((animation (existing-animation animation-list)))
                    (if (not animation)
                        (error "No animation found in: {l detail: :human separator: \", \"}" animation-list)
                      (let ((next (existing-animation next-list)))
                        (unless (equal? animation-active animation)
                          (let ((previous animation-active))
                            (let ((was-falling? (or (equal? previous "JumpStart")
                                                    (equal? previous "Jump")
                                                    (equal? previous "Fall"))))
                              (cond ((and was-falling? (equal? animation "Idle"))
                                     (change-morphing "JumpEnd" next: "Idle")
                                     (set! animation-active "Idle"))
                                    ((and was-falling? (equal? animation "Run"))
                                     (change-morphing (existing-animation '("JumpLandRun" "Run")) next: "Run")
                                     (set! animation-active "Run"))
                                    (else
                                     (let ((frame (if (equal? animation "JumpStart") jump-start-frame #f))
                                           (duration (if (not previous) .1 #f)))
                                       (transition-morphing animation frame: frame duration: duration next: next)
                                       (set! animation-active animation))))))))))))))))))
  
  
  ;;;
  ;;;; Missiles
  ;;;
  
  
  (method protected (increase-missiles)
    (increase! missiles-count))
  
  
  (method protected (decrease-missiles)
    (decrease! missiles-count))
  
  
  (method protected (get-self-wound-grace)
    .1)
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-target color)
    (draw-target-circle))))
