;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Actors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.actor jazz


(import (jazz.geometry)
        (jazz.syntax (phase syntax))
        (world)
        (world.animation)
        (world.audio)
        (world.autoload)
        (world.collision)
        (world.commands)
        (world.dye)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.mark)
        (world.motion)
        (world.settings)
        (world.spell)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Actor
;;;


(definition *global-cooldown*
  0.5)

(definition protected max-fall-speed <fl>
  1.25)

(definition protected die-bottom <fl>
  -250.)

(definition protected water-slowdown <fl>
  0.75)


(definition run-speed <fl>
  (world-setting 'world.run-speed 5.))

(definition blink-speed <fl>
  (world-setting 'world.blink-speed 5.))

(definition run-jump <fl>
  (world-setting 'world.run-jump 2.))

(definition blink-jump <fl>
  (world-setting 'world.blink-jump 1.5))


(definition protected base-armor <fl>
  (world-setting 'world.base-armor 20.))

(definition protected base-power <fl>
  (world-setting 'world.base-power 10.))

(definition protected base-ranged-power <fl>
  (world-setting 'world.base-ranged-power 10.))


(class Actor extends Entity
  
  
  (properties (;; component
               name visible?
               ;; element
               position lookat scale radiuses radius color user-data
               ;; entity
               model animate? animation)
    
    (slot velocity                <f64vector>  initialize (make-zero-vertex) getter generate)
    (slot fall-velocity           <f64vector>  initialize (make-zero-vertex) getter generate)
    (slot life                    <fl>         initialize 100.               accessors generate)
    (slot alive?                  <bool>       initialize #t                 accessors generate)
    (slot global-cooldown         <fl>         initialize 0.                 accessors generate)
    (slot spell                   <Spell+>     initialize #f                 accessors generate)
    (slot adjustments             <list>       initialize '()                accessors generate)
    (slot rapid-fire-acceleration <fl>         initialize 1.                 accessors generate)
    (slot rapid-fire-duration     <fl>         initialize 0.                 accessors generate)
    (slot rapid-fire-cooldown     <fl>         initialize 0.                 accessors generate)
    (slot last-missile            <fl+>        initialize #f                 accessors generate)
    (slot max-missiles            <fx>         initialize 10                 accessors generate)
    (slot missiles-count          <fx>         initialize 0                  accessors generate)
    (slot history-color           <object>     initialize #f                 accessors generate)
    (slot jumping?                <bool>       initialize #f                 accessors generate)
    (slot jump-ready?             <bool>       initialize #f                 accessors generate)
    (slot jump-grace?             <bool>       initialize #f                 accessors generate)
    (slot jump-time               <fl>         initialize 0.                 accessors generate)
    (slot ground?                 <bool>       initialize #f                 accessors generate)
    (slot water?                  <bool>       initialize #f                 accessors generate)
    (slot water-collision?        <bool>       initialize #f                 accessors generate)
    (slot shallow-water?          <bool>       initialize #f                 accessors generate)
    (slot lava?                   <bool>       initialize #f                 accessors generate)
    (slot swim-timer              <fl>         initialize 0.                 accessors generate)
    (slot water-jump?             <bool>       initialize #f                 accessors generate)
    (slot ladder?                 <bool>       initialize #f                 accessors generate)
    (slot ladder-shaft            <f64vector+> initialize #f                 accessors generate)
    (slot pressure-plates         <list>       initialize '()                accessors generate)
    (slot last-step               <fl>         initialize 0.                 accessors generate)
    (slot rotation                <fl>         initialize 0.                 accessors generate)
    (slot orientation             <object>     initialize 'vertical          accessors generate)
    (slot sprint                  <fl>         initialize 1.                 accessors generate)
    (slot sprint-duration         <fl>         initialize 0.                 accessors generate)
    (slot animation-active        <object>     initialize #f                 accessors generate)
    (slot animation-fall          <object>     initialize #f                 accessors generate)
    (slot armor                   <fl>         initialize base-armor         accessors generate)
    (slot armor-factor            <fl>         initialize 1.                 accessors generate)
    (slot power                   <fl>         initialize base-power         accessors generate)
    (slot power-factor            <fl>         initialize 1.                 accessors generate)
    (slot ranged-power            <fl>         initialize base-ranged-power  accessors generate)
    (slot ranged-power-factor     <fl>         initialize 1.                 accessors generate))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (let ((color (copy-dye color)))
      (dye-alpha-set! color .2)
      (set! history-color color)))
  
  
  (method public inline (set-velocity vel <f64vector>) <void>
    (vertex-copy! velocity vel))
  
  
  (method public inline (set-fall-velocity vel <f64vector>) <void>
    (vertex-copy! fall-velocity vel))
  
  
  (method override (call-model-update model)
    (nextmethod model)
    (set! animation-active #f)
    (set! animation-fall #f))
  
  
  (method (setup-armor value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.5)
            (max-armor 500.))
        (+ min-factor (* (/ value max-armor) (- max-factor min-factor)))))
    
    (set! armor value)
    (set! armor-factor (calculate-factor)))
  
  
  (method (setup-power value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.5)
            (max-power 160.))
        (+ min-factor (* (/ value max-power) (- max-factor min-factor)))))
    
    (set! power value)
    (set! power-factor (calculate-factor)))
  
  
  (method (setup-ranged-power value)
    (define (calculate-factor)
      (let ((min-factor 1.)
            (max-factor 2.)
            (max-power 120.))
        (+ min-factor (* (/ value max-power) (- max-factor min-factor)))))
    
    (set! ranged-power value)
    (set! ranged-power-factor (calculate-factor)))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (definition missile-delay <fl>
    .1)

  
  ;(method (maybe-add-action name arguments)
  ;  (if (<= global-cooldown 0.)
  ;      (add-action~ commands name (arguments))
  ;    (set! global-cooldown (- global-cooldown 0.))))
  
  
  (method (maybe-fire commands kind)
    (let ((seconds (current-seconds)))
      (when (or (not last-missile)
                (> (- seconds last-missile) (/ missile-delay rapid-fire-acceleration)))
        (fire commands kind)
        (set! last-missile seconds))))
  
  
  (method (fire commands kind)
    (let ((direction (aim-direction)))
      (add-action~ commands 'fire (list direction kind))))
  
  
  (method (fire-missile direction kind)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((pane (child~ (get-interface~ world) 'character)))
        (when (and (< missiles-count max-missiles)
                   (or (neq? kind 'arrow)
                       (> (count-arrows~ pane) 0)))
          (when (eq? kind 'arrow)
            (use-arrow~ pane))
          (let ((lens (lens-center))
                (adjusted-radius (* (get-radius-x) 2.)))
            (let ((pos (vertex+ lens (vertex-scalar*& direction adjusted-radius))))
              (let ((missile (new (missile-class~ world) parent: world position: pos actor: self kind: kind)))
                (increase-missiles)
                (set-velocity~ missile (vertex-scalar*& direction (missile-speed~ missile)))
                (add-element~ zone missile))))
          (attack kind)))))
  
  
  (method override (lens-center)
    (let ((model (cache-model)))
      (let ((center (get-center~ model))
            (bounds (get-bounds~ model))
            ;; quick hack
            (eye-level (if (equal? (get-name~ model) "bloodelffemale")
                           .4
                         .15)))
        (let ((model-lens (vertex+ center (vertex 0. (* (cuboid-height bounds) eye-level) 0.))))
          (matrix-transform-3x4 matrix model-lens)))))
  
  
  (method (aim-direction)
    (let ((world (current-world)))
      (let ((eye (get-eye~ world)))
        (if (get-free-aim?~ world)
            (get-sight~ eye)
          (cross-normal (get-up~ eye) (get-right~ lookat))))))
  
  
  (method (start-rapid-fire)
    (set! rapid-fire-acceleration 3.)
    (set! rapid-fire-duration 15.)
    (set! rapid-fire-cooldown 45.))
  
  
  (method (warp-forward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) 2.)))
      (follow-player~ world)))
  
  
  (method (warp-backward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) -2.)))
      (follow-player~ world)))
  
  
  (method (start-sprint)
    (let ((world (current-world)))
      (set! sprint 5.)
      (set! sprint-duration 10.)
      (update-parameter~ world 'sprint)))
  
  
  (method public virtual (damage amount critical?)
    (play-3d-sound (if critical? (wound-critical-sound) (wound-sound)) position)
    @w
    (let ((animation (if critical? "CombatCritical" "CombatWound")))
      (when (find-animation~ (cache-model) animation)
        (transition-morphing animation)
        (set! animation-active animation)))
    (decrease! life amount)
    (when (<= life 0.)
      (die)))
  
  
  (method protected virtual (attacking?)
    #f)
  
  
  (method protected virtual (attack kind)
    )
  
  
  (method protected virtual (attack-amount factor amount)
    (* amount factor))
  
  
  (method public virtual (wound inflictor factor (amount #f))
    (let ((world (current-world)))
      (let ((critical? (> (random-real) .8)))
        (damage (if amount
                    amount
                  (attack-amount~ inflictor factor (wound-amount critical?)))
                (if amount #f critical?)))))
  
  
  (method public virtual (wound-amount critical?)
    (if critical? 20. 10.))
  
  
  (method public virtual (wound-sound)
    (require-sound 'wound))
  
  
  (method public virtual (wound-critical-sound)
    (require-sound 'wound-critical))
  
  
  (method public virtual (explode inflictor)
    (let ((zone (current-zone))
          (radius 2.))
      (play-3d-sound "sound/spells/ExplosiveShot" position)
      (for-each (lambda (actor)
                  (when (and (<= (f64-ref (vertex-distance& position (get-position~ actor))) radius)
                             (explosion-damage?~ actor))
                    (wound~ actor inflictor (get-ranged-power-factor~ inflictor))))
                (get-actors~ zone))))
  
  
  (method public virtual (explosion-damage?)
    #t)
  
  
  (method public virtual (die)
    (let ((world (current-world)))
      (play-3d-sound (death-sound) position)
      (remove-element~ world self)
      (set! alive? #f)))
  
  
  (method public virtual (death-sound)
    (require-sound 'death))
  
  
  (method public virtual (stomp)
    #f)
  
  
  (method protected virtual (get-friction)
    4.)
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  ;; (slot position         <f64vector>)    ;; position
  ;; (slot lookat           <LookAt>)       ;; lookat is always perpendicular to gravity
  ;; (slot scale            <f64vector>)    ;; scale
  ;; (slot matrix           <f64vector>)    ;; matrix
  ;; (slot radiuses         <f64vector+>)   ;; radiuses
  ;; (slot radius           <fl+>)          ;; radius
  ;; (slot velocity         <f64vector>)    ;; velocity
  ;; (slot fall-velocity    <f64vector>)    ;; fall-velocity
  ;; (slot jumping?         <bool>)         ;; are we currently jumping
  ;; (slot jump-ready?      <bool>)         ;; so holding the jump key only jumps once
  ;; (slot jump-grace?      <bool>)         ;; a standing jump allows us one last move
  ;; (slot jump-time        <fl>)           ;; time of current jump
  ;; (slot ground?          <bool>)         ;; are we currently in contact with the ground
  ;; (slot water?           <bool>)         ;; are we in a liquid environment
  ;; (slot water-collision? <bool>)         ;; are we going against a water polygon's normal
  ;; (slot shallow-water?   <bool>)         ;; are we in shallow water
  ;; (slot lava?            <bool>)         ;; are we in lava
  ;; (slot swim-timer       <bool>)         ;; time before able to swim up
  ;; (slot water-jump?      <bool>)         ;; jump when we get out of water
  ;; (slot ladder?          <bool>)         ;; are we climbing up a ladder
  ;; (slot ladder-shaft     <f64vector+>)   ;; the xz of the shaft we are climbing in
  ;; (slot pressure-plates  <list>          ;; list of pressure plates we were on last time tick-actor was called
  ;; (slot last-step        <fl>)           ;; last time we played a step sound
  ;; (slot rotation         <fl>)           ;; rotation for the character model
  ;; (slot orientation      <object>)       ;; vertical or horizontal like for four-legged creatures
  ;; (slot sprint           <fl>)           ;; temporary speed increase
  
  (method (tick-actor commands <Commands> time <fl> elapse <fl> exit gravity? collision-response (ignore-entities?: ignore-entities? (ignore-entities?)) (ignore-players?: ignore-players? (ignore-players?)) (ignore-me?: ignore-me? (ignore-me?)) (proportional-slide?: proportional-slide? #t))
    (site (tick-actor on?: #f parent: player)
      (let ((world (current-world))
            (zone (current-zone))
            (me (current-me))
            (motion (current-motion))
            (camera (current-camera))
            (history (current-history))
            (model (cache-model))
            (center (transformed-center))
            (run-forward? (get-run-forward?~ commands))
            (run-backward? (get-run-backward?~ commands))
            (blink-forward? (get-blink-forward?~ commands))
            (blink-backward? (get-blink-backward?~ commands)))
        (let ((gravity (compute-gravity~ world center))
              (me? (eq? self me))
              (fly? (get-fly?~ world))
              (run? (or run-forward? run-backward?))
              (blink? (or blink-forward? blink-backward?))
              (displacement (make-zero-vertex))
              (grace-slowdown .25)
              (grace-move? #f)
              (floor-level (floor-level~ world))
              (animation #f))
          (define (process-commands)
            (when (and (get-modified?~ commands) (hook-commands~ world commands))
              (when (get-command?~ commands)
                (log-commands~ history commands elapse))
              ;; move forward
              (when (and (get-move-forward?~ commands) (not run?))
                (movement-callback)
                (when (allow-movement?)
                  (move move-forward)
                  (animate (move-animation))))
              ;; move backward
              (when (and (get-move-backward?~ commands) (not run?))
                (movement-callback)
                (when (allow-movement?)
                  (move move-backward)
                  (animate "WalkBackwards")))
              ;; move left
              (when (get-move-left?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-left)
                  (animate "Run")))
              ;; move right
              (when (get-move-right?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-right)
                  (animate "Run")))
              ;; move up
              (when (get-move-up?~ commands)
                (move move-up))
              ;; move down
              (when (get-move-down?~ commands)
                (move move-down))
              ;; run forward
              (when run-forward?
                (movement-callback)
                (move run-forward)
                (animate "Run"))
              ;; run backward
              (when run-backward?
                (movement-callback)
                (move run-backward)
                (animate "Run"))
              ;; blink forward
              (when blink-forward?
                (movement-callback)
                (move blink-forward)
                (animate "Run"))
              ;; blink backward
              (when blink-backward?
                (movement-callback)
                (move blink-backward)
                (animate "WalkBackwards"))
              ;; rotate left
              (when (get-rotate-left?~ commands)
                (rotate-left))
              ;; rotate right
              (when (get-rotate-right?~ commands)
                (rotate-right))))
          
          (define (move proc)
            (cond ((and water? (>= swim-timer 0.))
                   (proc (* sprint water-slowdown) displacement))
                  ((or ground? ladder? fly? blink?)
                   (proc sprint displacement))
                  ((and jumping? jump-grace?)
                   (proc (* sprint grace-slowdown) displacement)
                   (set! grace-move? #t)
                   (set! jump-grace? #f)))
            (when (> sprint-duration 0.)
              (decrease! sprint-duration elapse)
              (when (<= sprint-duration 0.)
                (set! sprint 1.)
                (set! sprint-duration 0.)
                (update-parameter~ world 'sprint))))
          
          (define (move-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-left factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-right~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-right factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-right~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-up factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-up~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-down factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-up~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (run-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self) (if (user-role?) 2. run-speed)))))
          
          (define (run-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self) (if (user-role?) 2. run-speed)))))
          
          (define (blink-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ camera) (* factor (vehicle-speed~ world self) blink-speed))))
          
          (define (blink-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ camera) (* factor (vehicle-speed~ world self) blink-speed))))
          
          (define player-rotation-speed <fl>
            1.3)
          
          (define (rotate-left)
            (rotate-actor-horizontal~ motion self (* player-rotation-speed elapse)))
          
          (define (rotate-right)
            (rotate-actor-horizontal~ motion self (- (* player-rotation-speed elapse))))
          
          (define (animate name)
            (set! animation name)
            (animate-model time name))
          
          (define (move-animation)
            "Run")
          
          (define (process-velocity)
            (cond ((or ground? ladder? fly? blink? grace-move? (and water? (moving?~ commands)))
                   (vertex-copy! velocity displacement))
                  ((or (not jumping?)
                       (> (- time jump-time) 1.))
                   (let ((friction (get-friction)))
                     (when friction
                       (let ((reduce (* friction elapse (if water? 4. 1.))))
                         (if (< (vertex-norm velocity) reduce)
                             (vertex-zero! velocity)
                           (vertex-decrease! velocity (vertex-scalar*& (vertex-normalize-safe& velocity) reduce)))))))))
          
          (define (process-gravity)
            (let ((normalized-gravity (vertex-normalize gravity)))
              (if (get-jump?~ commands)
                  (when (or water-jump? (and jump-ready? (or (and run? (not (user-role?))) blink? water? (and (or ground? ladder?) (not jumping?)))))
                    (unless (or water? water-jump?)
                      (set! jumping? #t)
                      (set! jump-ready? #f)
                      (set! jump-grace? (and (allow-grace?) (vertex-zero? velocity)))
                      (set! jump-time time))
                    (vertex-copy! fall-velocity (if water?
                                                    (vertex-y-set! fall-velocity (min (+ (vertex-y fall-velocity) 0.02) 0.07))
                                                  (vertex-scalar*& normalized-gravity (* (- (/ (get-jump-impulsion~ world) (if water-jump? 1.5 1.))) (cond (run? (if (user-role?) 1. run-jump))
                                                                                                                                                           (blink? blink-jump)
                                                                                                                                                           (water? (if water-jump? 1. (/ 1. 4.)))
                                                                                                                                                           (else 1.))))))
                    (when water-jump?
                      (set! water-jump? #f))
                    (animate-model time :context))
                (unless water?
                  (set! jump-ready? #t)))
              (when (> swim-timer 0.)
                (decrease! swim-timer elapse)
                (when (<= swim-timer 0.)
                  (set! swim-timer 0.)
                  (set! jump-ready? #t)))
              (when (and ground? (vertex-zero? fall-velocity))
                (unless jump-ready?
                  (set! jump-ready? #t))
                (when water-jump?
                  (set! water-jump? #f)))
              (when (> (dot-product fall-velocity normalized-gravity) (if water? 0.015 max-fall-speed))
                (if water?
                    (vertex-y-set! fall-velocity (* (vertex-y fall-velocity) 0.85))
                  (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity max-fall-speed))))))
          
          (define (collide-actor)
            (break-logic slide)
            (when (get-debug-collisions?)
              (reset-marks~ zone))
            (let* ((radiuses (transformed-radiuses))
                   (pumps (and (not water?) (needs-pumps?~ zone) (get-pumps~ model)))
                   (pumped-center (if pumps
                                      (receive (pumped pumped-direction pumped-collisions) (collide&stop center (vertex+ center pumps) lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me?)
                                        pumped)
                                    center))
                   (target-center (vertex+ pumped-center (vertex-scalar*& velocity elapse)))
                   (collide (case collision-response ((stop) collide&stop) ((slide) collide&slide))))
              ;; collide&slide
              (receive (new-center slide-direction slide-collisions) (site (collide&slide on?: #f parent: tick-actor) (collide pumped-center target-center lookat radiuses include-back-facing?: #t ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: proportional-slide? debuggable-collisions?: #t))
                (receive (new-slide-collisions slide-water?) (remove-water-collisions slide-collisions #t) ;; set water? with both slide and fall
                  (when slide-water?
                    (receive (new-center-2 slide-direction-2 slide-collisions-2) (site (collide&stop on?: #f parent: tick-actor) (collide pumped-center target-center lookat radiuses polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t))
                      (set! new-center new-center-2)
                      (set! slide-collisions slide-collisions-2)))
                  (let ((new-center (if pumps
                                        (receive (unpumped unpumped-direction unpumped-collisions) (collide&stop new-center (vertex- new-center pumps) lookat radiuses polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me?)
                                          unpumped)
                                      new-center)))
                    ;; kind of a quick hack so we dont slide farther than the player
                    (when (and (not proportional-slide?) (not jumping?))
                      (adjust-fast-slide! center new-center))
                    (break-action
                      (move-actor new-center))
                    (if (or (not gravity?) fly?)
                        (values new-center slide-collisions '())
                      (let ((adjusted (* elapse 50.)))
                        (define (xz-position&)
                          (vertex& (+ (fxceiling (get-x)) .5) 0. (+ (fxceiling (get-z)) .5)))
                        
                        ;; ladder
                        (set! ladder? (some? (lambda (collision) (= (fxround (get-data1~ (get-polygon~ collision))) 65)) slide-collisions))
                        (cond (ladder?
                                (when (not ladder-shaft)
                                  (set! ladder-shaft (make-vertex)))
                                (vertex-copy! ladder-shaft (xz-position&)))
                              (else
                               (when ladder-shaft
                                 (if (vertex=? (xz-position&) ladder-shaft)
                                     (if (not-null? slide-collisions)
                                         (set! ladder? #t)
                                       ;; slow fall
                                       (set! adjusted (/ adjusted 3.)))
                                   (set! ladder-shaft #f)))))
                        
                        (break-logic fall)
                        (break-action
                          (when (get-debug-collisions?)
                            (reset-marks~ zone)))
                        (when water?
                          (set! adjusted (/ adjusted 1.5)))
                        (vertex+! fall-velocity fall-velocity (vertex-scalar*& gravity adjusted))
                        (when ladder?
                          (vertex! fall-velocity 0. .075 0.))
                        (let ((target-fall (vertex+& new-center (vertex+& (vertex-scalar*& fall-velocity adjusted) (vertex-scalar*& gravity (* .5 adjusted adjusted))))))
                          ;; collide&stop
                          (receive (new-fall fall-direction fall-collisions) (site (collide&stop on?: #f parent: tick-actor) (parameterize ((megahack (and me? (or jumping? ladder? ladder-shaft)))) (collide&stop new-center target-fall lookat radiuses include-back-facing?: #t ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t)))
                            (break-action
                              (move-actor new-fall))
                            (receive (new-fall-collisions) (liquid? fall-collisions slide-water?)
                              (if water-collision?
                                  (begin
                                    (unless shallow-water?
                                      (set! shallow-water? #t)
                                      (when me?
                                        (change-ambience~ (current-ambience))))
                                    (receive (new-fall-2 fall-direction other-fall-collisions) (site (collide&stop on?: #f parent: tick-actor) (collide&stop new-center target-fall lookat radiuses polygon-filter: liquid-filter ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? debuggable-collisions?: #t))
                                      (set! new-fall new-fall-2)
                                      (set! fall-collisions other-fall-collisions)))
                                (when (and water? shallow-water?)
                                  (set! shallow-water? #f)
                                  (when me?
                                    (play-ambience~ (current-ambience) "ambience/water/Underwater"))))
                              (deal-with-pressure-plates fall-collisions)
                              (values new-fall slide-collisions fall-collisions)))))))))))
          
          (define (deal-with-pressure-plates fall-collisions)
            (define (common-list-elements l1 l2)
              (let ((common '()))
                (for-each (lambda (element)
                            (when (member? element l2)
                              (set! common (cons element common))))
                          l1)
                common))
            
            (let ((new-pp '())
                  (to-add '())
                  (to-remove '()))
              (for-each (lambda (coll)
                          (when (memq? (fxround (get-data1~ (get-polygon~ coll))) '(70 72))
                            (let ((poly (get-polygon~ coll)))
                              (set! new-pp (cons (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly)) new-pp)))))
                        fall-collisions)
              (let ((common (intersection test: equal? new-pp pressure-plates~self)))
                (set! to-add (list-copy new-pp))
                (set! to-remove (list-copy pressure-plates~self))
                (for-each (lambda (com)
                            (set! to-add (remove com to-add test: equal?))
                            (set! to-remove (remove com to-remove test: equal?)))
                          common)
                (pressure-plates-update~ (current-game) to-add to-remove self)
                (set! pressure-plates~self new-pp))))
          
          (define (liquid? fall-collisions slide-water?)
            (let ((new-collisions (new-queue))
                  (water-polygons (new-queue))
                  (lava-collision #f))
              (for-each (lambda (collision)
                          (let ((poly (get-polygon~ collision)))
                            (if (get-water-cube?~ (world.generation:blockid->block (fxround (get-data1~ poly))))
                                (begin
                                  (when (memq? (fxround (get-data1~ poly)) '(10 11))
                                    (set! lava-collision #t))
                                  (enqueue water-polygons poly))
                              (enqueue new-collisions collision))))
                        fall-collisions)
              (if (and (queue-empty? water-polygons) (not slide-water?))
                  (begin
                    (set! water-collision? #f)
                    (when water?
                      (unless (get-water-cube?~ (world.generation:blockid->block (current-block)))
                        (set! water? #f)
                        (set! lava? #f)
                        (set! water-jump? #t))))
                (unless water?
                  (when (> (abs (vertex-y fall-velocity)) 1.)
                    (play-3d-sound "sound/water/EnterWaterSmallA" position))
                  (set! jumping? #f)
                  (set! grace-move? #f)
                  (set! jump-time time)
                  (set! water-jump? #f)
                  (set! water? #t)
                  (set! lava? lava-collision))
                (unless water-collision?
                  (set! water-collision? #t)))
              (values (queue-list new-collisions))))
          
          (define (liquid-filter poly)
            (not (get-water-cube?~ (world.generation:blockid->block (fxround (get-data1~ poly))))))
          
          (define (current-block)
            (let ((pos (get-position~ self)))
              (call-with-position~ (current-zone) (vertex (vertex-x pos) (+ (vertex-y pos) .8) (vertex-z pos))
                (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                  block-id))))
          
          (define (hit-action slide-collisions)
            (define (find-actionable)
              (continuation-capture
                (lambda (found)
                  (for-each (lambda (collision)
                              (let ((poly (get-polygon~ collision)))
                                (when (= (fxround (get-data1~ poly)) 90)
                                  (continuation-return found poly))))
                            slide-collisions)
                  #f)))
            
            (let ((poly (find-actionable)))
              (when poly
                (let ((id (fxround (get-data1~ poly)))
                      (pos (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly))))
                  (cond ;; portal
                        ((= id 90)
                         (world.generation:invoke-block-action pos))
                        (else
                         #f))))))
          
          (define (hit-collisions new-center slide-collisions fall-collisions)
            (define (ground-update flag velocity)
              (when (neq? ground? flag)
                (set! ground? flag)
                (if velocity
                    (hit-ground velocity exit)
                  (leave-ground exit))))
            
            (hit slide-collisions exit)
            (let ((floor-level (and floor-level (+ floor-level (get-radius-y))))
                  (velocity (copy-vertex fall-velocity)))
              (if (and floor-level (< (vertex-y new-center) floor-level) (not fly?))
                  (begin
                    (hit-floor velocity exit)
                    (vertex-y-set! new-center floor-level)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))
                (let ((fall-collided? (not-null? fall-collisions))
                      (water-only? (null? (remove-water-collisions fall-collisions))))
                  (if (not fall-collided?)
                      (ground-update #f #f)
                    (vertex! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update (not water-only?) velocity))))))
          
          (define (remove-water-collisions fall-collisions (slide #f))
            (let ((new-collisions (new-queue)))
              (for-each (lambda (collision)
                          (when (liquid-filter (get-polygon~ collision))
                            (enqueue new-collisions collision)))
                        fall-collisions)
              (if slide
                  (values (queue-list new-collisions) (/= (length fall-collisions) (length (queue-list new-collisions))))
                (queue-list new-collisions))))
          
          (define (foot-step fall-collisions)
            (when (and me? (get-steps?~ model) (or ground? @not-really-nice ladder?) (or (not water?) shallow-water?))
              (let ((speed (vertex-norm velocity)))
                (when (> speed 0.)
                  (when (> (- time last-step) (/ 2.1 speed))
                    (set! last-step time)
                    (let ((kind (cond @not-really-nice
                                      (ladder?
                                       'ladder)
                                      ((and water? shallow-water?)
                                       'water)
                                      ((null? fall-collisions)
                                       'stone)
                                      (else
                                       (let ((collision (car fall-collisions)))
                                         (let ((id (fxround (get-data1~ (get-polygon~ collision)))))
                                           (case id
                                             ((2) 'grass)
                                             ((5) 'wood)
                                             ((12 13) 'dirt)
                                             ((78 79 80) 'snow)
                                             (else 'stone))))))))
                      (play-sound-file (random-step kind) volume: .075)))))))
          
          (define (move-actor new-center)
            (let ((movement (vertex- new-center center)))
              (let ((new-position (vertex+ position movement))
                    (old-position (copy-vertex position)))
                (set-position new-position)
                (position-change)
                (update-element~ zone self old-position)
                (set! center new-center)
                movement)))
          
          (define (rotate-model movement)
            (let ((me (current-me)))
              (when me?
                (let ((distance (/ (dot-product (get-sight~ lookat) movement) (get-radius))))
                  (define (set-x-rotation name)
                    (let ((model (child~ model name)))
                      (vertex-x-set! (get-rotation~ model) rotation)
                      (update-matrix~ model)))
                  
                  (when (/= distance 0.)
                    (decrease! rotation distance)
                    (case (get-name~ model)
                      ((Orb)
                       (set-x-rotation 'body))
                      ((OrbOnWheels OrbOnHummer)
                       (set-x-rotation 'wheel1)
                       (set-x-rotation 'wheel2)
                       (set-x-rotation 'wheel3)
                       (set-x-rotation 'wheel4))))))))
          
          (define (realign-actor slide-collisions fall-collisions)
            (when (and gravity? (not fly?))
              (update-world-up~ world gravity)
              (case orientation
                ((vertical)
                 (realign-lookat (gravity-up gravity)))
                ((horizontal)
                 (when (or (not-null? slide-collisions)
                           (not-null? fall-collisions))
                   (let ()
                     (define (average-normal)
                       (let ((factor-sum 0.)
                             (dir-sum (make-zero-vertex)))
                         (define (process-collisions collisions)
                           (for-each (lambda (collision)
                                       (let ((plane (get-plane~ collision)))
                                         (let ((origin (get-origin~ plane))
                                               (normal (get-normal~ plane)))
                                           (let ((dist (vertex-distance origin center)))
                                             (let ((factor (/ (+ 1. dist))))
                                               (increase! factor-sum factor)
                                               (vertex+! dir-sum dir-sum (vertex-scalar* normal factor-sum)))))))
                                     collisions))
                         
                         (process-collisions slide-collisions)
                         (process-collisions fall-collisions)
                         (vertex-scalar/ dir-sum factor-sum)))
                     
                     (remove-up-roll! lookat (average-normal) lookat)
                     (update-matrix)))))))
          
          (define (realign-horizon)
            (when (and gravity? (not fly?) me? (is? motion Person-Motion))
              (let ((final-gravity (compute-gravity~ world center)))
                (set-lookat~ camera (realign-lookat-horizon& (get-lookat~ camera) (get-up~ lookat) gravity final-gravity))
                (camera-update~ camera))))
          
          (define (center-eye)
            (when me?
              (eye-center-player~ motion)))
          
          (define (verify-death)
            (when (and lava? (user-role?))
              (damage 1. #f))
            (when (and die-bottom (< (get-y) die-bottom))
              (damage 100. #f)))
          
          (process-commands)
          (process-velocity)
          (process-gravity)
          (when (not animation)
            (animate-model time :context))
          (let ((collide-info (collide-actor)))
            (receive (new-center slide-collisions fall-collisions) collide-info
              (unless (hit-action slide-collisions)
                (hit-collisions new-center slide-collisions fall-collisions)
                (foot-step fall-collisions)
                (let ((movement (move-actor new-center)))
                  (rotate-model movement)
                  (realign-actor slide-collisions fall-collisions)
                  (unless (vertex-zero? movement)
                    (realign-horizon)
                    (center-eye)
                    (verify-death)
                    collide-info)))))))))
  
  
  (method protected virtual (tick-slice)
    #f)
  
  
  (method protected virtual (tick-actions commands)
    )
  
  
  (method (tick-actor-actions commands)
    (let ((world (current-world)))
      (when (get-modified?~ commands)
        (for-each (lambda (action)
                    (bind (name . arguments) action
                      (tick-actor-action name arguments)))
                  (get-actions~ commands)))))
  
  
  (method protected virtual (tick-actor-action name arguments)
    (let ((world (current-world))
          (history (current-history)))
      (log-action~ history name arguments)
      (when (hook-action~ world name arguments)
        (case name
          ((track)
           (bind (dh dv eye-sight eye-up eye-right first?) arguments
             (track-actor~ (current-motion) self dh dv eye-sight eye-up eye-right first?)))
          ((add)
           (bind (mode class grid? grid-plane grid-position eye direction stage) arguments
             (editor-add~ world mode class grid? grid-plane grid-position eye direction stage)))
          ((delete)
           (bind (position) arguments
             (editor-delete~ world position)))
          ((fire)
           (when (person-motion?)
             (bind (direction kind) arguments
               (fire-missile direction kind))))
          ((rapid-fire)
           (start-rapid-fire))))))
  
  
  (method protected virtual (ignore-entities?)
    #t)
  
  
  (method protected virtual (ignore-players?)
    #f)
  
  
  (method protected virtual (ignore-me?)
    #f)
  
  
  (method protected virtual (position-change)
    )
  
  
  (method protected virtual (hit collisions exit)
    )
  
  
  (method protected virtual (hit-floor velocity exit)
    )
  
  
  (method protected virtual (hit-ground velocity exit)
    (define fall-conversion-a <fl>
      (/ 1. .18))
    
    (define fall-conversion-b <fl>
      (/ 1. .51))

    (define (blocks-fallen speed)
      (fxround (expt (* speed fall-conversion-a) fall-conversion-b)))
    
    (unless (or ladder? (not (user-role?)))
      (let ((fall-speed (abs (vertex-y velocity)))
            (minimum-speed .7))
        (when (> fall-speed minimum-speed)
          (let ((amount (* 4 (- (blocks-fallen fall-speed) 5))))
            (damage amount #f))))))
  
  
  (method protected virtual (leave-ground exit)
    )
  
  
  (method protected virtual (ground-speed)
    6.5)
  
  
  (method protected virtual (movement-callback)
    )
  
  
  (method protected virtual (allow-movement?)
    #t)
  
  
  (method protected virtual (allow-grace?)
    #t)
  
  
  (method protected virtual (adjust-fast-slide! center new-center)
    )
  
  
  ;;;
  ;;;; Type
  ;;;
  
  
  (method protected virtual (is-player?)
    #f)
  
  
  (method protected virtual (is-missile?)
    #f)
  
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method override (animated)
    (set! animated? #t))
  
  
  (method override (unanimated)
    (set! animated? #f))
  
  
  (method protected virtual (move-animation)
    "Walk")
  
  
  (method protected virtual (animate-model time name (duration: duration #f) (next: next #f))
    (let ((elapse-before-fall .5)
          (jump-start-frame 8.))
      (unless (not morphing)
        (let ((fall? (not ground?)))
          (unless jumping?
            (if fall?
                (when (not animation-fall)
                  (set! animation-fall time))
              (set! animation-fall #f)))
          (when (or (not animation-fall)
                    (equal? name :context)
                    ;; to not switch non-stop between run and fall while running down a slope
                    (> (- time animation-fall) elapse-before-fall))
            (let ((model (cache-model)))
              (define (determine-animation proc)
                (cond ((= sprint 0.) (proc '("Idle") #f))
                      ((and water? (not shallow-water?)) (proc (if (eq? name :context) '("SwimIdle" "Idle") '("Swim" "Run")) #f))
                      (jumping? (proc '("JumpStart" "Jump" "Fall" "Idle") (list "Jump" "Fall" "Idle")))
                      ((and fall? (not ladder?)) (proc '("Fall" "Idle") #f))
                      (else (proc (if (eq? name :context)
                                      (list "Idle")
                                    (listify name))
                                  #f))))
              
              (define (existing-animation animation-list)
                (let (iter (scan animation-list))
                  (if (or (not scan)
                          (null? scan))
                      #f
                    (let ((animation (car scan)))
                      (if (find-animation~ model animation)
                          animation
                        (iter (cdr scan)))))))
              
              (determine-animation
                (lambda (animation-list next-list)
                  (let ((animation (existing-animation animation-list)))
                    (if (not animation)
                        (error "No animation found in: {l detail: :human separator: \", \"}" animation-list)
                      (let ((next (existing-animation next-list)))
                        (unless (equal? animation-active animation)
                          (let ((previous animation-active))
                            (let ((was-falling? (or (equal? previous "JumpStart")
                                                    (equal? previous "Jump")
                                                    (equal? previous "Fall"))))
                              (cond ((and was-falling? (equal? animation "Idle"))
                                     (change-morphing "JumpEnd" next: "Idle")
                                     (set! animation-active "Idle"))
                                    ((and was-falling? (equal? animation "Run"))
                                     (change-morphing (existing-animation '("JumpLandRun" "Run")) next: "Run")
                                     (set! animation-active "Run"))
                                    (else
                                     (let ((frame (if (equal? animation "JumpStart") jump-start-frame #f))
                                           (duration (if (equal? previous "Idle") .1 #f)))
                                       (transition-morphing animation frame: frame duration: duration next: next)
                                       (set! animation-active animation))))))))))))))))))
  
  
  ;;;
  ;;;; Missiles
  ;;;
  
  
  (method protected (increase-missiles)
    (increase! missiles-count))
  
  
  (method protected (decrease-missiles)
    (decrease! missiles-count))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-target color)
    (draw-target-circle))))
