;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Actors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.actor jazz


(import (jazz.graphic.opengl.glew)
        (jazz.system)
        (world)
        (world.autoload)
        (world.collision)
        (world.commands)
        (world.dye)
        (world.entity)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.motion)
        (world.opengl)
        (world.serialization)
        (world.settings)
        (world.spell)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Actor
;;;


(definition *global-cooldown*
  0.5)

(definition protected max-fall-speed <fl>
  .65)

(definition protected die-bottom <fl+>
  #f)


(class Actor extends Entity
  
  
  (properties (;; component
               name visible?
               ;; element
               position lookat scale radiuses radius color user-data
               ;; entity
               model animate? animation)
    (slot velocity                <f64vector>  initialize (make-zero-vertex) getter generate)
    (slot fall-velocity           <f64vector>  initialize (make-zero-vertex) getter generate)
    (slot life                    <fx>         initialize 100                accessors generate)
    (slot global-cooldown         <fl>         initialize 0.                 accessors generate)
    (slot spell                   <Spell+>     initialize #f                 accessors generate)
    (slot adjustments             <list>       initialize '()                accessors generate)
    (slot rapid-fire-acceleration <fl>         initialize 1.                 accessors generate)
    (slot rapid-fire-duration     <fl>         initialize 0.                 accessors generate)
    (slot rapid-fire-cooldown     <fl>         initialize 0.                 accessors generate)
    (slot last-missile            <fl+>        initialize #f                 accessors generate)
    (slot max-missiles            <fx>         initialize 10                 accessors generate)
    (slot missiles-count          <fx>         initialize 0                  accessors generate)
    (slot history-color           <object>     initialize #f                 accessors generate)
    (slot jumping?                <bool>       initialize #f                 accessors generate)
    (slot jump-ready?             <bool>       initialize #f                 accessors generate)
    (slot jump-grace?             <bool>       initialize #f                 accessors generate)
    (slot jump-time               <fl>         initialize 0.                 accessors generate)
    (slot ground?                 <bool>       initialize #f                 accessors generate)
    (slot ladder?                 <bool>       initialize #f                 accessors generate)
    (slot ladder-shaft            <f64vector+> initialize #f                 accessors generate)
    (slot rotation                <fl>         initialize 0.                 accessors generate)
    (slot orientation             <object>     initialize 'vertical          accessors generate)
    (slot sprint                  <fl>         initialize 1.                 accessors generate)
    (slot sprint-duration         <fl>         initialize 0.                 accessors generate)
    (slot animation-active        <object>     initialize #f                 accessors generate)
    (slot animation-start         <object>     initialize #f                 accessors generate)
    (slot animation-end           <object>     initialize #f                 accessors generate)
    (slot animation-next          <object>     initialize #f                 accessors generate))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (let ((color (copy-dye color)))
      (dye-alpha-set! color .2)
      (set! history-color color)))
  
  
  (method public inline (set-velocity vel <f64vector>) <void>
    (vertex-copy! velocity vel))
  
  
  (method public inline (set-fall-velocity vel <f64vector>) <void>
    (vertex-copy! fall-velocity vel))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (definition missile-delay <fl>
    .1)

  
  ;(method (maybe-add-action name arguments)
  ;  (if (<= global-cooldown 0.)
  ;      (add-action~ commands name (arguments))
  ;    (set! global-cooldown (- global-cooldown 0.))))
  
  
  (method (maybe-fire commands kind)
    (let ((seconds (current-seconds)))
      (when (or (not last-missile)
                (> (- seconds last-missile) (/ missile-delay rapid-fire-acceleration)))
        (fire commands kind)
        (set! last-missile seconds))))
  
  
  (method (fire commands kind)
    (let ((direction (aim-direction)))
      (add-action~ commands 'fire (list direction kind))))
  
  
  (method (fire-missile direction kind)
    (let ((world (current-world))
          (zone (current-zone)))
      (when (< missiles-count max-missiles)
        (let ((lens (player-lens~ world self))
              ;; because the radius is cubic at the moment
              (adjusted-radius (/ (get-radius) 1.8)))
          (let ((pos (vertex+ lens (vertex-scalar*& direction adjusted-radius))))
            (let ((missile (new (missile-class~ world) parent: world position: pos actor: self kind: kind)))
              (increase-missiles)
              (set-velocity~ missile (vertex-scalar*& direction (missile-speed~ missile)))
              (add-element~ zone missile)))))))
  
  
  (method (aim-direction)
    (let ((world (current-world)))
      (let ((eye (get-eye~ world)))
        (if (get-free-aim?~ world)
            (get-sight~ eye)
          (cross-normal (get-up~ eye) (get-right~ lookat))))))
  
  
  (method (start-rapid-fire)
    (set! rapid-fire-acceleration 3.)
    (set! rapid-fire-duration 15.)
    (set! rapid-fire-cooldown 45.))
  
  
  (method (warp-forward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) 2.)))
      (follow-player~ world)))
  
  
  (method (warp-backward)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-sight~ (current-camera)) -2.)))
      (follow-player~ world)))
  
  
  (method (start-sprint)
    (let ((world (current-world)))
      (set! sprint 5.)
      (set! sprint-duration 10.)
      (update-parameter~ world 'sprint)))
  
  
  (method public virtual (wound)
    (let ((world (current-world)))
      (let ((critical? (> (random-real) .5)))
        (play-sound-file~ world (if critical? (wound-critical-sound) (wound-sound)))
        (decrease! life (if critical? 20 10)))
      (when (<= life 0)
        (die))))
  
  
  (method public virtual (wound-sound)
    #f)
  
  
  (method public virtual (wound-critical-sound)
    #f)
  
  
  (method public virtual (die)
    (let ((world (current-world)))
      (play-sound-file~ world (death-sound))
      (remove-element~ world self)))
  
  
  (method public virtual (death-sound)
    #f)
  
  
  (method public virtual (stomp)
    #f)
  
  
  (method protected virtual (get-friction)
    4.)
  
  
  (method (rotate-model movement)
    (let ((me (current-me))
          (model (cache-model)))
      (when (eq? self me)
        (let ((distance (/ (dot-product (get-sight~ lookat) movement) (get-radius))))
          (define (set-x-rotation name)
            (let ((model (child~ model name)))
              (vertex-x-set! (get-rotation~ model) rotation)
              (update-matrix~ model)))
          
          (when (/= distance 0.)
            (decrease! rotation distance)
            (case (get-name~ model)
              ((Character)
               (set-x-rotation 'body))
              ((CharacterOnWheels CharacterOnHummer)
               (set-x-rotation 'wheel1)
               (set-x-rotation 'wheel2)
               (set-x-rotation 'wheel3)
               (set-x-rotation 'wheel4))))))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  ;; If I augment the jump-impulsion, lets say by a factor a 2.5, then collide&stop starts
  ;; returning incorrect collisions as in the following example taken from minecraft/Sample
  ;; (collide&stop (vertex -262.292 .400 72.041) (vertex -262.292 1.227 72.041) (lookat (vertex .662 .000 -.749) (vertex -.000 1.000 .000) (vertex .749 .000 .662)) (vertex .4 .4 .4))
  
  
  ;; (slot position      <f64vector>)    ;; position
  ;; (slot lookat        <LookAt>)       ;; lookat is always perpendicular to gravity
  ;; (slot scale         <f64vector>)    ;; scale
  ;; (slot matrix        <f64vector>)    ;; matrix
  ;; (slot radiuses      <f64vector+>)   ;; radiuses
  ;; (slot radius        <fl+>)          ;; radius
  ;; (slot velocity      <f64vector>)    ;; velocity
  ;; (slot fall-velocity <f64vector>)    ;; fall-velocity
  ;; (slot jumping?      <bool>)         ;; are we currently jumping
  ;; (slot jump-ready?   <bool>)         ;; so holding the jump key only jumps once
  ;; (slot jump-grace?   <bool>)         ;; a standing jump allows us one last move
  ;; (slot jump-time     <fl>)           ;; time of current jump
  ;; (slot ground?       <bool>)         ;; are we currently in contact with the ground
  ;; (slot ladder?       <bool>)         ;; are we climbing up a ladder
  ;; (slot ladder-shaft  <f64vector+>)   ;; the xz of the shaft we are climbing in
  ;; (slot rotation      <fl>)           ;; rotation for the character model
  ;; (slot orientation   <object>)       ;; vertical or horizontal like for four-legged creatures
  ;; (slot sprint        <fl>)           ;; temporary speed increase
  
  (method (tick-actor commands <Commands> time <fl> elapse <fl> exit gravity? collision-response (ignore-entities?: ignore-entities? (ignore-entities?)) (ignore-players?: ignore-players? (ignore-players?)))
    (site (tick-actor on?: #f parent: player)
      (let ((world (current-world))
            (zone (current-zone))
            (me (current-me))
            (motion (current-motion))
            (camera (current-camera))
            (model (cache-model))
            (center (transformed-center))
            (run-forward? (get-run-forward?~ commands))
            (run-backward? (get-run-backward?~ commands))
            (blink-forward? (get-blink-forward?~ commands))
            (blink-backward? (get-blink-backward?~ commands)))
        (let ((gravity (compute-gravity~ world center))
              (factor (* elapse 65.))
              (fly? (get-fly?~ world))
              (run? (or run-forward? run-backward?))
              (blink? (or blink-forward? blink-backward?))
              (displacement (make-zero-vertex))
              (grace-slowdown .25)
              (grace-move? #f)
              (floor-level (get-floor-level~ zone))
              (history (get-history~ world)))
          (define (process-commands)
            (when (and (get-modified?~ commands) (hook-commands~ world commands))
              (when (get-command?~ commands)
                (log-commands~ history commands elapse))
              ;; move forward
              (when (get-move-forward?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-forward)
                  (context-animation time (move-animation))))
              ;; move backward
              (when (get-move-backward?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-backward)
                  (context-animation time "WalkBackwards")))
              ;; move left
              (when (get-move-left?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-left)
                  (context-animation time "Run")))
              ;; move right
              (when (get-move-right?~ commands)
                (movement-callback)
                (when (allow-movement?)
                  (move move-right)
                  (context-animation time "Run")))
              ;; move up
              (when (get-move-up?~ commands)
                (move move-up))
              ;; move down
              (when (get-move-down?~ commands)
                (move move-down))
              ;; run forward
              (when run-forward?
                (movement-callback)
                (move run-forward)
                (context-animation time "Run"))
              ;; run backward
              (when run-backward?
                (movement-callback)
                (move run-backward)
                (context-animation time "Run"))
              ;; blink forward
              (when blink-forward?
                (movement-callback)
                (move blink-forward)
                (context-animation time "Run"))
              ;; blink backward
              (when blink-backward?
                (movement-callback)
                (move blink-backward)
                (context-animation time "WalkBackwards"))
              ;; rotate left
              (when (get-rotate-left?~ commands)
                (rotate-left factor))
              ;; rotate right
              (when (get-rotate-right?~ commands)
                (rotate-right factor))))
          
          (define (move proc)
            (cond ((or ground? ladder? fly? blink?)
                   (proc (* factor sprint) displacement))
                  ((and jumping? jump-grace?)
                   (proc (* factor sprint grace-slowdown) displacement)
                   (set! grace-move? #t)
                   (set! jump-grace? #f)))
            (when (> sprint-duration 0.)
              (decrease! sprint-duration elapse)
              (when (<= sprint-duration 0.)
                (set! sprint 1.)
                (set! sprint-duration 0.)
                (update-parameter~ world 'sprint))))
          
          (define (move-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-left factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-right~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-right factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-right~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-up factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-up~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (move-down factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-up~ lookat) (* factor (vehicle-speed~ world self)))))
          
          (define (run-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self) (world-setting 'world.run-speed 5.)))))
          
          (define (run-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ lookat) (* factor (vehicle-speed~ world self) (world-setting 'world.run-speed 5.)))))
          
          (define (blink-forward factor displacement)
            (vertex-increase! displacement (vertex-scalar*& (get-sight~ camera) (* factor (vehicle-speed~ world self) (world-setting 'world.blink-speed 5.)))))
          
          (define (blink-backward factor displacement)
            (vertex-decrease! displacement (vertex-scalar*& (get-sight~ camera) (* factor (vehicle-speed~ world self) (world-setting 'world.blink-speed 5.)))))
          
          (define player-rotation-speed <fl>
            0.02)
          
          (define (rotate-left factor)
            (rotate-actor-horizontal~ motion self (* player-rotation-speed factor)))
          
          (define (rotate-right factor)
            (rotate-actor-horizontal~ motion self (- (* player-rotation-speed factor))))
          
          (define (process-velocity)
            (cond ((or ground? ladder? fly? blink? grace-move?)
                   (vertex-scalar/! velocity displacement elapse))
                  ((or (not jumping?)
                       (> (- time jump-time) 1.))
                   (let ((friction (get-friction)))
                     (when friction
                       (let ((reduce (* friction elapse)))
                         (if (< (vertex-norm velocity) reduce)
                             (vertex-zero! velocity)
                           (vertex-decrease! velocity (vertex-scalar*& (vertex-normalize-safe& velocity) reduce)))))))))
          
          (define (process-gravity)
            (let ((normalized-gravity (vertex-normalize gravity)))
              (if (get-jump?~ commands)
                  (when (and jump-ready? (or run? blink? (and (or ground? ladder?) (not jumping?))))
                    (set! jumping? #t)
                    (set! jump-ready? #f)
                    (set! jump-grace? (and (allow-grace?) (vertex-zero? velocity)))
                    (set! jump-time time)
                    (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity (* (- (get-jump-impulsion~ world)) (cond (run? (world-setting 'world.run-jump 2.))
                                                                                                                             (blink? (world-setting 'world.blink-jump 1.5))
                                                                                                                             (else 1.)))))
                    (context-animation time "JumpStart"))
                (set! jump-ready? #t))
              (when (> (dot-product fall-velocity normalized-gravity) max-fall-speed)
                (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity max-fall-speed)))))
          
          @new
          (define (collide-actor)
            (let* ((pumps (and (needs-pumps?~ zone) (get-pumps~ model)))
                   (pumped-center (if pumps (vertex+ center pumps) center))
                   (target-center (vertex+ pumped-center (vertex-scalar*& velocity elapse)))
                   (collide (case collision-response ((stop) collide&stop) ((slide) collide&slide)))
                   (radiuses (transformed-radiuses)))
              (receive (new-center slide-direction slide-collisions) (site (collide&slide on?: #f parent: tick-actor) (collide pumped-center target-center lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?))
                (let ((new-center (if pumps (vertex- new-center pumps) new-center)))
                  (if (or (not gravity?) fly?)
                      (values new-center slide-collisions '())
                    (break-logic fall
                      (move-actor new-center))
                    (when (eq? orientation 'horizontal)
                      @w
                      (realign-actor slide-collisions '())
                      (when (not-null? slide-collisions)
                        (let ((plane (get-plane~ (car slide-collisions))))
                          (let ((normal (get-normal~ plane))
                                (dist (plane-to-point-distance plane center)))
                            (let ((up (remove-roll normal (get-right~ lookat))))
                              (set-up~ lookat up)
                              (set-sight~ lookat (cross-normal& up (get-right~ lookat)))
                              (let ((target-center (vertex+ pumped-center (vertex-scalar* normal (- (vertex-y radiuses) dist)))))
                                (receive (new-center slide-direction slide-collisions) (collide&stop pumped-center target-center lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?)
                                  (let ((new-center (if pumps (vertex- new-center pumps) new-center)))
                                    (break-logic horizontal
                                      (move-actor new-center))))))))))
                    (let ((adjusted (* elapse 50.)))
                      (vertex+! fall-velocity fall-velocity (vertex-scalar*& gravity adjusted))
                      (let ((target-fall (vertex+& new-center (vertex+& (vertex-scalar*& fall-velocity adjusted) (vertex-scalar*& gravity (* .5 adjusted adjusted))))))
                        (receive (new-fall fall-direction fall-collisions) (site (collide&stop on?: #f parent: tick-actor) (collide&stop new-center target-fall lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?))
                          (values new-fall slide-collisions fall-collisions)))))))))
          
          (define (collide-actor)
            (define (xz-position&)
              (vertex& (+ (fxceiling (get-x)) .5) 0. (+ (fxceiling (get-z)) .5)))
            
            (let* ((radiuses (transformed-radiuses))
                   (pumps (and (needs-pumps?~ zone) (get-pumps~ model)))
                   (pumped-center (if pumps
                                      (receive (pumped pumped-direction pumped-collisions) (collide&stop center (vertex+ center pumps) lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?)
                                        pumped)
                                    center))
                   (target-center (vertex+ pumped-center (vertex-scalar*& velocity elapse)))
                   (collide (case collision-response ((stop) collide&stop) ((slide) collide&slide))))
              ;; collide&slide
              (receive (new-center slide-direction slide-collisions) (site (collide&slide on?: #f parent: tick-actor) (collide pumped-center target-center lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?))
                (let ((new-center (if pumps
                                      (receive (unpumped unpumped-direction unpumped-collisions) (collide&stop new-center (vertex- new-center pumps) lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?)
                                        unpumped)
                                    new-center)))
                  (if (or (not gravity?) fly?)
                      (values new-center slide-collisions '())
                    (break-logic fall
                      (move-actor new-center))
                    (when (eq? orientation 'horizontal)
                      (realign-actor slide-collisions '()))
                    (let ((adjusted (* elapse 50.)))
                      ;; ladder
                      (set! ladder? (some? (lambda (collision) (= (fxround (get-data1~ (get-polygon~ collision))) 65)) slide-collisions))
                      (cond (ladder?
                              (when (not ladder-shaft)
                                (set! ladder-shaft (make-vertex)))
                              (vertex-copy! ladder-shaft (xz-position&)))
                            (else
                             (when ladder-shaft
                               (if (vertex=? (xz-position&) ladder-shaft)
                                   (if (not-null? slide-collisions)
                                       (set! ladder? #t)
                                     ;; slow fall
                                     (set! adjusted (/ adjusted 3.)))
                                 (set! ladder-shaft #f)))))
                      (vertex+! fall-velocity fall-velocity (vertex-scalar*& gravity adjusted))
                      (let ((target-fall (vertex+& new-center (if (and ladder? (not (vertex-zero? velocity)))
                                                                  ;; climb up
                                                                  (vertex 0. (* elapse 3.5) 0.)
                                                                (vertex+& (vertex-scalar*& fall-velocity adjusted) (vertex-scalar*& gravity (* .5 adjusted adjusted)))))))
                        ;; collide&stop
                        (receive (new-fall fall-direction fall-collisions) (site (collide&stop on?: #f parent: tick-actor) (collide&stop new-center target-fall lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?))
                          (values new-fall slide-collisions fall-collisions)))))))))
          
          (define (hit-collisions new-center slide-collisions fall-collisions)
            (hit slide-collisions exit)
            (let ((floor-level (and floor-level (+ floor-level (get-radius-y))))
                  (velocity (copy-vertex fall-velocity)))
              (if (and floor-level (< (vertex-y new-center) floor-level) (not fly?))
                  (begin
                    (hit-floor exit)
                    (vertex-y-set! new-center floor-level)
                    (vertex-init! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))
                (let ((fall-collided? (not-null? fall-collisions)))
                  (if (not fall-collided?)
                      (ground-update #f #f)
                    (vertex-init! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (ground-update #t velocity))))))
          
          (define (ground-update flag velocity)
            (when (neq? ground? flag)
              (set! ground? flag)
              (if ground?
                  (hit-ground velocity exit)
                (leave-ground exit))))
          
          (define (move-actor new-center)
            (let ((movement (vertex- new-center center)))
              (let ((new-position (vertex+ position movement))
                    (old-position (copy-vertex position)))
                (set-position new-position)
                (position-change)
                (update-element~ zone self old-position)
                (set! center new-center)
                movement)))
          
          (define (realign-actor slide-collisions fall-collisions)
            (define (average-normal)
              (let ((factor-sum 0.)
                    (dir-sum (make-zero-vertex)))
                (define (process-collisions collisions)
                  (for-each (lambda (collision)
                              (let ((plane (get-plane~ collision)))
                                (let ((origin (get-origin~ plane))
                                      (normal (get-normal~ plane)))
                                  (let ((dist (vertex-distance origin center)))
                                    (let ((factor (/ (+ 1. dist))))
                                      (increase! factor-sum factor)
                                      (vertex+! dir-sum dir-sum (vertex-scalar* normal factor-sum)))))))
                            collisions))
                
                (process-collisions slide-collisions)
                (process-collisions fall-collisions)
                (vertex-scalar/ dir-sum factor-sum)))
            
            (when (and gravity? (not fly?))
              (case orientation
                ((vertical)
                 (update-world-up~ world gravity)
                 (realign-lookat (gravity-up gravity)))
                ((horizontal)
                 (break-logic realign-horizontal)
                 (when (or (not-null? slide-collisions)
                           (not-null? fall-collisions))
                   (let ((normal (average-normal)))
                     (let ((up (remove-roll normal (get-right~ lookat))))
                       (set-up~ lookat up)
                       (set-sight~ lookat (cross-normal& up (get-right~ lookat)))))
                   (update-matrix))))))
          
          (define (realign-horizon)
            (when (and gravity? (not fly?) (eq? self me))
              (let ((final-gravity (compute-gravity~ world center)))
                (set-lookat~ camera (realign-lookat-horizon& (get-lookat~ camera) (get-up~ lookat) gravity final-gravity))
                (camera-update~ camera))))
          
          (define (center-eye)
            (when (eq? self me)
              (eye-center-player~ motion)))
          
          (define (verify-death)
            (when (and die-bottom (< (get-y) die-bottom))
              (lose~ world self)
              (continuation-return exit)))
          
          (process-commands)
          (process-velocity)
          (process-gravity)
          (receive (new-center slide-collisions fall-collisions) (collide-actor)
            (hit-collisions new-center slide-collisions fall-collisions)
            (let ((movement (move-actor new-center)))
              (rotate-model movement)
              (realign-actor slide-collisions fall-collisions)
              (unless (vertex-zero? movement)
                (realign-horizon)
                (center-eye)
                (verify-death))))))))
  
  
  (method protected virtual (tick-slice)
    #f)
  
  
  (method protected virtual (tick-actions commands)
    )
  
  
  (method (tick-actor-actions commands)
    (let ((world (current-world)))
      (when (get-modified?~ commands)
        (for-each (lambda (action)
                    (bind (name . arguments) action
                      (tick-actor-action name arguments)))
                  (get-actions~ commands)))))
  
  
  (method protected virtual (tick-actor-action name arguments)
    (let ((world (current-world)))
      (let ((history (get-history~ world)))
        (log-action~ history name arguments))
      (when (hook-action~ world name arguments)
        (case name
          ((track)
           (bind (dh dv eye-sight eye-up eye-right first?) arguments
             (track-actor~ (current-motion) self dh dv eye-sight eye-up eye-right first?)))
          ((add)
           (bind (mode class grid? grid-plane grid-position floor-grid? eye direction stage) arguments
             (editor-add~ world mode class grid? grid-plane grid-position floor-grid? eye direction stage)))
          ((delete)
           (bind (position) arguments
             (editor-delete~ world position)))
          ((fire)
           (when (person-motion?)
             (bind (direction kind) arguments
               (fire-missile direction kind))))
          ((rapid-fire)
           (start-rapid-fire))))))
  
  
  (method protected virtual (ignore-entities?)
    #t)
  
  
  (method protected virtual (ignore-players?)
    #f)
  
  
  (method protected virtual (position-change)
    )
  
  
  (method protected virtual (hit collisions exit)
    )
  
  
  (method protected virtual (hit-floor exit)
    )
  
  
  (method protected virtual (hit-ground velocity exit)
    )
  
  
  (method protected virtual (leave-ground exit)
    )
  
  
  (method protected virtual (ground-speed)
    0.1)
  
  
  (method protected virtual (movement-callback)
    )
  
  
  (method protected virtual (allow-movement?)
    #t)
  
  
  (method protected virtual (allow-grace?)
    #t)
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method protected virtual (is-player?)
    #f)
  
  
  (method (idle-actor)
    (when ground?
      (set-velocity (make-zero-vertex)))
    (context-animation (current-seconds) #f))
  
  
  (method protected virtual (move-animation)
    "Walk")
  
  
  (method protected virtual (context-animation time name (duration: duration #f) (next: next #f))
    (let ((minimum-delay .15))
      (let ((elapsed (and animation-start (- time animation-start))))
        (unless (and elapsed (< elapsed minimum-delay))
          (let ((model (cache-model))
                (proposed-animation (cond ;fix me
                                      ;(jumping? (if (and elapsed (< elapsed 1.)) "JumpStart" "Jump"))
                                      ;((not ground?) "Fall")
                                      (else name))))
            (let ((effective-animation (and (find-animation~ model proposed-animation) proposed-animation)))
              (unless (equal? animation-active effective-animation)
                (set! animation-active effective-animation)
                (set! animation-start time)
                (if (equal? animation-active "JumpStart")
                    (change-morphing animation-active frame: .5)
                  (transition-morphing animation-active))
                (process-idleness~ (current-world) #f))))))))
  
  
  ;;;
  ;;;; Missiles
  ;;;
  
  
  (method protected (increase-missiles)
    (increase! missiles-count))
  
  
  (method protected (decrease-missiles)
    (decrease! missiles-count))
  
  
  (method protected (get-self-wound-grace)
    .1)
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-target color)
    (draw-target-circle))))
