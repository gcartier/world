;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Actors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.actor jazz


(import (jazz.graphic.opengl.glew)
        (world)
        (world.autoload)
        (world.collision)
        (world.commands)
        (world.dye)
        (world.entity)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.opengl)
        (world.serialization)
        (world.spell)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Actor
;;;


(definition *global-cooldown*
  0.5)

(definition protected max-fall-speed <fl>
  .36)

(definition protected die-bottom <fl+>
  #f)


(class Actor extends Entity
  
  
  (slot velocity                <f64vector>  initialize (make-zero-vertex)     getter generate)
  (slot fall-velocity           <f64vector>  initialize (make-zero-vertex)     getter generate)
  (slot life                    <fx>         initialize 100                    accessors generate)
  (slot global-cooldown         <fl>         initialize 0.                     accessors generate)
  (slot spell                   <Spell+>     initialize #f                     accessors generate)
  (slot adjustments             <list>       initialize '()                    accessors generate)
  (slot rapid-fire-acceleration <fl>         initialize 1.                     accessors generate)
  (slot rapid-fire-duration     <fl>         initialize 0.                     accessors generate)
  (slot rapid-fire-cooldown     <fl>         initialize 0.                     accessors generate)
  (slot last-missile            <fl+>        initialize #f                     accessors generate)
  (slot max-missiles            <fx>         initialize 10                     accessors generate)
  (slot missiles-count          <fx>         initialize 0                      accessors generate)
  (slot history-color           <object>     initialize #f                     accessors generate)
  (slot jumping?                <bool>       initialize #f                     accessors generate)
  (slot jump-ready?             <bool>       initialize #f                     accessors generate)
  (slot jump-grace?             <bool>       initialize #f                     accessors generate)
  (slot jump-time               <fl>         initialize 0.                     accessors generate)
  (slot ground?                 <bool>       initialize #f                     accessors generate)
  (slot rotation                <fl>         initialize 0.                     accessors generate)
  (slot orientation             <object>     initialize 'vertical              accessors generate)
  (slot sprint                  <fl>         initialize 1.                     accessors generate)
  (slot sprint-duration         <fl>         initialize 0.                     accessors generate)
  (slot animation-active        <object>     initialize #f                     accessors generate)
  (slot animation-start         <object>     initialize #f                     accessors generate)
  (slot animation-end           <object>     initialize #f                     accessors generate)
  (slot animation-next          <object>     initialize #f                     accessors generate)
  
  
  (method override (finish rest)
    (nextmethod rest)
    (let ((color (copy-dye color)))
      (dye-alpha-set! color .2)
      (set! history-color color)))
  
  
  (method meta override (marshall-object obj)
    (serialize-object (class-of obj)
                      (vector
                        ;; component
                        (serialize (get-name~ obj))
                        (serialize (get-visible?~ obj))
                        ;; element
                        (serialize (get-position~ obj))
                        (serialize (get-lookat~ obj))
                        (serialize (get-scale~ obj))
                        (serialize (get-radiuses~ obj))
                        (serialize (get-radius~ obj))
                        (serialize (get-color~ obj))
                        (serialize (get-hit-behavior~ obj))
                        (serialize (get-user-data~ obj))
                        ;; entity
                        (get-model~ obj)
                        (get-animate?~ obj)
                        (get-animation~ obj)
                        ;; actor
                        (serialize (get-velocity~ obj))
                        (serialize (get-fall-velocity~ obj))
                        (serialize (get-life~ obj))
                        (serialize (get-global-cooldown~ obj))
                        (serialize (get-spell~ obj))
                        (serialize (get-adjustments~ obj))
                        (serialize (get-rapid-fire-acceleration~ obj))
                        (serialize (get-rapid-fire-duration~ obj))
                        (serialize (get-rapid-fire-cooldown~ obj))
                        (serialize (get-last-missile~ obj))
                        (serialize (get-max-missiles~ obj))
                        (serialize (get-missiles-count~ obj))
                        (serialize (get-history-color~ obj))
                        (serialize (get-orientation~ obj)))))
  
  
  (method meta override (unmarshall-object content)
    (bind-vector (;; component
                  name
                  visible?
                  ;; element
                  position
                  lookat
                  scale
                  radiuses
                  radius
                  color
                  hit-behavior
                  user-data
                  ;; entity
                  model
                  animate?
                  animation
                  ;; actor
                  velocity
                  fall-velocity
                  life
                  global-cooldown
                  spell
                  adjustments
                  rapid-fire-acceleration
                  rapid-fire-duration
                  rapid-fire-cooldown
                  last-missile
                  max-missiles
                  missiles-count
                  history-color
                  orientation
                  ;; creature
                  path-duration
                  anim-duration
                  aggro-radius
                  aggro-target)
        content
      (let ((obj (new self name: name visible?: visible?)))
        ;; element
        (set-position~ obj (deserialize position))
        (set-lookat~ obj (deserialize lookat))
        (set-scale~ obj (deserialize scale))
        (set-radiuses~ obj (deserialize radiuses))
        (set-radius~ obj (deserialize radius))
        (set-color~ obj (deserialize color))
        (set-hit-behavior~ obj (deserialize hit-behavior))
        (set-user-data~ obj (deserialize user-data))
        ;; entity
        (set-model~ obj (deserialize model))
        (set-animate?~ obj (deserialize animate?))
        (set-animation~ obj (deserialize animation))
        ;; actor
        (set-velocity~ obj (deserialize velocity))
        (set-fall-velocity~ obj (deserialize fall-velocity))
        (set-life~ obj (deserialize life))
        (set-global-cooldown~ obj (deserialize global-cooldown))
        (set-spell~ obj (deserialize spell))
        (set-adjustments~ obj (deserialize adjustments))
        (set-rapid-fire-acceleration~ obj (deserialize rapid-fire-acceleration))
        (set-rapid-fire-duration~ obj (deserialize rapid-fire-duration))
        (set-rapid-fire-cooldown~ obj (deserialize rapid-fire-cooldown))
        (set-last-missile~ obj (deserialize last-missile))
        (set-max-missiles~ obj (deserialize max-missiles))
        (set-missiles-count~ obj (deserialize missiles-count))
        (set-history-color~ obj (deserialize history-color))
        (set-orientation~ obj (deserialize orientation)))))
  
  
  (method public inline (set-velocity vel <f64vector>) <void>
    (vertex-copy! velocity vel))
  
  
  (method public inline (set-fall-velocity vel <f64vector>) <void>
    (vertex-copy! fall-velocity vel))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (definition missile-delay <fl>
    .1)

  
  ;(method (maybe-add-action name arguments)
  ;  (if (<= global-cooldown 0.)
  ;      (add-action~ commands name (arguments))
  ;    (set! global-cooldown (- global-cooldown 0.))))
  
  
  (method (maybe-fire commands kind)
    (let ((seconds (current-seconds)))
      (when (or (not last-missile)
                (> (- seconds last-missile) (/ missile-delay rapid-fire-acceleration)))
        (fire commands kind)
        (set! last-missile seconds))))
  
  
  (method (fire commands kind)
    (let ((direction (aim-direction)))
      (add-action~ commands 'fire (list direction kind))))
  
  
  (method (fire-missile direction kind)
    (let ((world (current-world))
          (zone (current-zone)))
      (when (< missiles-count max-missiles)
        (let ((lens (player-lens~ world self)))
          (let ((pos (vertex+ lens (vertex-scalar*& direction (- (get-radius) .1)))))
            (let ((missile (new (missile-class~ world) parent: world position: pos actor: self kind: kind)))
              (increase-missiles)
              (set-velocity~ missile (vertex-scalar*& direction (missile-speed~ missile)))
              (add-element~ zone missile)))))))
  
  
  (method (aim-direction)
    (let ((world (current-world)))
      (if (get-free-aim?~ world)
          (get-eye-sight~ world)
        (cross-normal (get-eye-up~ world) (get-right~ lookat)))))
  
  
  (method (start-rapid-fire)
    (set! rapid-fire-acceleration 3.)
    (set! rapid-fire-duration 15.)
    (set! rapid-fire-cooldown 45.))
  
  
  (method (warp (reversed? #f))
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-eye-sight~ world) (if reversed? -2. 2.))))
      (follow-player~ world)))
  
  
  (method (start-sprint)
    (let ((world (current-world)))
      (set! sprint 5.)
      (set! sprint-duration 10.)
      (update-parameter~ world 'sprint)))
  
  
  (method public virtual (wound)
    (let ((world (current-world)))
      (let ((critical? (> (random-real) .5)))
        (play-sound-file~ world (if critical? (wound-critical-sound) (wound-sound)))
        (decrease! life (if critical? 20 10)))
      (when (<= life 0)
        (die))))
  
  
  (method public virtual (wound-sound)
    #f)
  
  
  (method public virtual (wound-critical-sound)
    #f)
  
  
  (method public virtual (die)
    (let ((world (current-world)))
      (play-sound-file~ world (death-sound))
      (remove-element~ world self)))
  
  
  (method public virtual (death-sound)
    #f)
  
  
  (method public virtual (stomp)
    #f)
  
  
  (method protected virtual (get-friction)
    .2)
  
  
  (method (rotate-model movement)
    (let ((me (current-me))
          (model (cache-model)))
      (when (eq? self me)
        (let ((distance (/ (dot-product (get-sight~ lookat) movement) (get-radius))))
          (define (set-x-rotation name)
            (let ((model (child~ model name)))
              (vertex-x-set! (get-rotation~ model) rotation)
              (update-matrix~ model)))
          
          (when (/= distance 0.)
            (decrease! rotation distance)
            (case (get-name~ model)
              ((Character)
               (set-x-rotation 'body))
              ((CharacterOnWheels)
               (set-x-rotation 'wheel1)
               (set-x-rotation 'wheel2)
               (set-x-rotation 'wheel3)
               (set-x-rotation 'wheel4))))))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  ;; If I augment the jump-impulsion, lets say by a factor a 2.5, then collide&stop starts
  ;; returning incorrect collisions as in the following example taken from minecraft/Sample
  ;; (collide&stop (vertex -262.292 .400 72.041) (vertex -262.292 1.227 72.041) (lookat (vertex .662 .000 -.749) (vertex -.000 1.000 .000) (vertex .749 .000 .662)) (vertex .4 .4 .4))
  
  
  ;; (slot position      <f64vector>)    ;; position
  ;; (slot lookat        <LookAt>)       ;; lookat is always perpendicular to gravity
  ;; (slot scale         <f64vector>)    ;; scale
  ;; (slot matrix        <f64vector>)    ;; matrix
  ;; (slot radiuses      <f64vector+>)   ;; radiuses
  ;; (slot radius        <fl+>)          ;; radius
  ;; (slot velocity      <f64vector>)    ;; velocity
  ;; (slot fall-velocity <f64vector>)    ;; fall-velocity
  ;; (slot jumping?      <bool>)         ;; are we currently jumping
  ;; (slot jump-ready?   <bool>)         ;; so holding the jump key only jumps once
  ;; (slot jump-grace?   <bool>)         ;; a standing jump allows us one last move
  ;; (slot jump-time     <fl>)           ;; time of current jump
  ;; (slot ground?       <bool>)         ;; are we currently in contact with the ground
  ;; (slot rotation      <fl>)           ;; rotation for the character model
  ;; (slot orientation   <object>)       ;; vertical or horizontal like for four-legged creatures
  ;; (slot sprint        <fl>)           ;; temporary speed increase
  
  (method (tick-actor commands <Commands> time <fl> elapse <fl> exit gravity? collision-response (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f))
    (site (tick-actor on?: #f parent: player)
      (let ((world (current-world))
            (zone (current-zone))
            (me (current-me))
            (model (cache-model))
            (center (transformed-center))
            (blink-forward? (get-blink-forward?~ commands))
            (blink-backward? (get-blink-backward?~ commands)))
        (let ((gravity (compute-gravity~ world center))
              (factor (* elapse 65.))
              (first-person? (get-first-person?~ world))
              (fly? (get-fly?~ world))
              (blink? (or blink-forward? blink-backward?))
              (target-velocity (make-zero-vertex))
              (grace-slowdown .25)
              (grace-move? #f)
              (floor-level (get-floor-level~ zone))
              (history (get-history~ world))
              (paused? (get-paused?~ world)))
          (define (process-commands)
            (when (and (get-modified?~ commands) (hook-commands~ world commands))
              (when (and history (get-command?~ commands))
                (log-commands~ history commands elapse))
              ;; move forward
              (when (and (get-move-forward?~ commands) first-person?)
                (move move-player-forward~)
                (context-animation time (move-animation)))
              ;; move backward
              (when (and (get-move-backward?~ commands) first-person?)
                (move move-player-backward~)
                (context-animation time "WalkBackwards"))
              ;; move left
              (when (and (get-move-left?~ commands) first-person?)
                (move move-player-left~)
                (context-animation time "Run"))
              ;; move right
              (when (and (get-move-right?~ commands) first-person?)
                (move move-player-right~)
                (context-animation time "Run"))
              ;; move up
              (when (and (get-move-up?~ commands))
                (move move-player-up~))
              ;; move down
              (when (and (get-move-down?~ commands))
                (move move-player-down~))
              ;; blink forward
              (when (and blink-forward? first-person?)
                (move blink-player-forward~)
                (context-animation time "Run"))
              ;; blink backward
              (when (and blink-backward? first-person?)
                (move blink-player-backward~)
                (context-animation time "WalkBackwards"))
              ;; rotate left
              (when (and (get-rotate-left?~ commands) first-person?)
                (rotate-player-left~ world self factor))
              ;; rotate right
              (when (and (get-rotate-right?~ commands) first-person?)
                (rotate-player-right~ world self factor))))
          
          (define (move proc)
            (cond ((or ground? fly? blink?)
                   (proc world self (* factor sprint) target-velocity))
                  ((and jumping? jump-grace?)
                   (proc world self (* factor sprint grace-slowdown) target-velocity)
                   (set! grace-move? #t)
                   (set! jump-grace? #f)))
            (when (> sprint-duration 0.)
              (decrease! sprint-duration elapse)
              (when (<= sprint-duration 0.)
                (set! sprint 1.)
                (set! sprint-duration 0.)
                (update-parameter~ world 'sprint))))
          
          (define (process-velocity)
            (cond ((or ground? fly? blink? grace-move?)
                   (vertex-copy! velocity target-velocity))
                  ((or (not jumping?)
                       (> (- time jump-time) 1.))
                   (let ((friction (get-friction)))
                     (when friction
                       (let ((reduce (* friction elapse)))
                         (if (< (vertex-norm velocity) reduce)
                             (vertex-zero! velocity)
                           (vertex-decrease! velocity (vertex-scalar*& (vertex-normalize-safe& velocity) reduce)))))))))
          
          (define (process-gravity)
            (let ((normalized-gravity (vertex-normalize gravity)))
              (if (get-jump?~ commands)
                  (when (and ground? jump-ready? (not jumping?))
                    (set! jumping? #t)
                    (set! jump-ready? #f)
                    (set! jump-grace? (vertex-zero? velocity))
                    (set! jump-time time)
                    (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity (- (get-jump-impulsion~ world))))
                    (context-animation time "JumpStart"))
                (set! jump-ready? #t))
              (when (> (dot-product fall-velocity normalized-gravity) max-fall-speed)
                (vertex-copy! fall-velocity (vertex-scalar*& normalized-gravity max-fall-speed)))))
          
          (define (collide-actor)
            (let* ((pumps (and (needs-pumps?~ zone) (get-pumps~ model)))
                   (pumped-center (if pumps (vertex+ center pumps) center))
                   (target-center (vertex+ pumped-center velocity))
                   (collide (case collision-response ((stop) collide&stop) ((slide) collide&slide)))
                   (radiuses (transformed-radiuses)))
              (when (stepping-history?)
                (debug 'slide))
              (receive (new-center slide-direction slide-collisions) (site (collide&slide on?: #f parent: tick-actor) (collide pumped-center target-center lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?))
                (let ((new-center (if pumps (vertex- new-center pumps) new-center)))
                  (if (or (not gravity?) fly?)
                      (values new-center slide-collisions '())
                    (break-logic fall
                      (move-actor new-center))
                    (let ((adjusted (* elapse 50.)))
                      (vertex+! fall-velocity fall-velocity (vertex-scalar*& gravity adjusted))
                      (let ((target-fall (vertex+& new-center (vertex+& (vertex-scalar*& fall-velocity adjusted) (vertex-scalar*& gravity (* .5 adjusted adjusted))))))
                        (when (stepping-history?)
                          (debug 'fall))
                        (receive (new-fall fall-direction fall-collisions) (site (collide&stop on?: #f parent: tick-actor) (collide&stop new-center target-fall lookat radiuses ignore-entities?: ignore-entities? ignore-players?: ignore-players?))
                          (values new-fall slide-collisions fall-collisions)))))))))
          
          (define (process-collisions new-center slide-collisions fall-collisions)
            (hit slide-collisions exit)
            (let ((floor-level (and floor-level (+ floor-level (get-radius-y)))))
              (if (and floor-level (< (vertex-y new-center) floor-level) (not fly?))
                  (begin
                    (hit-floor exit)
                    (vertex-y-set! new-center floor-level)
                    (vertex-init! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (set! ground? #t))
                (let ((fall-collided? (not-null? fall-collisions)))
                  (if (not fall-collided?)
                      (set! ground? #f)
                    (vertex-init! fall-velocity 0. 0. 0.)
                    (set! jumping? #f)
                    (set! ground? #t))))))
          
          (define (move-actor new-center)
            (let ((movement (vertex- new-center center)))
              (let ((new-position (vertex+ position movement))
                    (old-position (copy-vertex position)))
                (set-position new-position)
                (update-element~ zone self old-position)
                (set! center new-center)
                movement)))
          
          (define (realign-actor fall-collisions)
            (when (and gravity? (not fly?))
              (case orientation
                ((vertical)
                 (update-world-up~ world gravity)
                 (realign-lookat (gravity-up gravity)))
                ((horizontal)
                 (break-logic realign-horizontal)
                 (when (not-null? fall-collisions)
                   (let ((c0 (car fall-collisions)))
                     (when (stepping-history?)
                       (debug 'realign))
                     (let ((normal (get-normal~ (get-plane~ c0))))
                       (let ((up (remove-tilt normal (get-right~ lookat))))
                         (set-up~ lookat up)
                         (set-sight~ lookat (cross-normal& up (get-right~ lookat)))))
                     (update-matrix)))))))
          
          (define (realign-horizon)
            (when (and gravity? (not fly?) (eq? self me))
              (let ((final-gravity (compute-gravity~ world center)))
                (realign-lookat-horizon! (get-eye-lookat~ world) (get-up~ lookat) gravity final-gravity))))
          
          (define (center-eye)
            (when (eq? self me)
              (eye-center-player~ world)))
          
          (define (verify-death)
            (when (and die-bottom (< (get-y) die-bottom))
              (lose~ world self)
              (continuation-return exit)))
          
          (process-commands)
          (process-velocity)
          (process-gravity)
          (receive (new-center slide-collisions fall-collisions) (collide-actor)
            (process-collisions new-center slide-collisions fall-collisions)
            (let ((movement (move-actor new-center)))
              (rotate-model movement)
              (realign-actor fall-collisions)
              (unless (vertex-zero? movement)
                (realign-horizon)
                (center-eye)
                (verify-death))))))))
  
  
  (method protected virtual (tick-slice)
    #f)
  
  
  (method protected virtual (tick-actions commands)
    )
  
  
  (method (tick-actor-actions commands)
    (let ((world (current-world)))
      (when (get-modified?~ commands)
        (for-each (lambda (action)
                    (bind (name . arguments) action
                      (tick-actor-action name arguments)))
                  (get-actions~ commands)))))
  
  
  (method protected virtual (tick-actor-action name arguments)
    (let ((world (current-world)))
      (let ((history (get-history~ world)))
        (when history
          (log-action~ history name arguments)))
      (when (hook-action~ world name arguments)
        (case name
          ((track)
           (bind (dh dv eye-sight eye-up eye-right first?) arguments
             (track-actor~ world self dh dv eye-sight eye-up eye-right first?)))
          ((add)
           (bind (mode class grid? grid-plane grid-position floor-grid? eye direction stage) arguments
             (editor-add~ world mode class grid? grid-plane grid-position floor-grid? eye direction stage)))
          ((delete)
           (bind (position) arguments
             (editor-delete~ world position)))
          ((fire)
           (let ((first-person? (get-first-person?~ world)))
             (bind (direction kind) arguments
               (when first-person?
                 (fire-missile direction kind)))))
          ((rapid-fire)
           (start-rapid-fire))))))
  
  
  (method protected virtual (hit collisions exit)
    )
  
  
  (method protected virtual (hit-floor exit)
    )
  
  
  (method protected virtual (ground-speed)
    0.1)
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method protected virtual (is-player?)
    #f)
  
  
  (method (idle-actor)
    (when ground?
      (set-velocity (make-zero-vertex)))
    (context-animation (current-seconds) #f))
  
  
  (method protected virtual (move-animation)
    "Walk")
  
  
  (method protected virtual (context-animation time name (duration: duration #f) (next: next #f))
    (let ((minimum-delay .15))
      (let ((elapsed (and animation-start (- time animation-start))))
        (unless (and elapsed (< elapsed minimum-delay))
          (let ((model (cache-model))
                (proposed-animation (cond ;fix me
                                      ;(jumping? (if (and elapsed (< elapsed 1.)) "JumpStart" "Jump"))
                                      ;((not ground?) "Fall")
                                      (else name))))
            (let ((effective-animation (and (find-animation~ model proposed-animation) proposed-animation)))
              (unless (equal? animation-active effective-animation)
                (set! animation-active effective-animation)
                (set! animation-start time)
                (if (equal? animation-active "JumpStart")
                    (change-morphing animation-active frame: .5)
                  (transition-morphing animation-active))
                (process-idleness~ (current-world) #f))))))))
  
  
  ;;;
  ;;;; Missiles
  ;;;
  
  
  (method protected (increase-missiles)
    (increase! missiles-count))
  
  
  (method protected (decrease-missiles)
    (decrease! missiles-count))
  
  
  (method protected (get-self-wound-grace)
    .1)
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw)
    (let ((world (current-world)))
      (cond ((in-history?)
             (when (get-draw-actors-history?~ world)
               (draw-history)))
            (else
             (nextmethod)))))
  
  
  (method override (draw-target dye)
    (draw-target-circle))
  
  
  (method (draw-history)
    (let ((bounds (make-cuboid&)))
      (get-bounds! bounds)
      (let ((x1 (cuboid-left bounds))
            (x2 (cuboid-right bounds))
            (y1 (cuboid-bottom bounds))
            (y2 (cuboid-top bounds))
            (z1 (cuboid-back bounds))
            (z2 (cuboid-front bounds)))
        (glDisable GL_LIGHTING)
        (gl-colorize-dye history-color)
        (render-block x1 x2 y1 y2 z1 z2 GL_LINE_LOOP)
        (glEnable GL_LIGHTING))))))
