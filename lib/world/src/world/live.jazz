;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.live jazz


(require (jazz.jpeg)
         (world.generation.models))

(import (jazz.action)
        (jazz.application)
        (jazz.audio)
        (jazz.component)
        (jazz.debuggee)
        (jazz.debugger)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.media)
        (jazz.opengl)
        (jazz.opengl.glew)
        (jazz.platform)
        (jazz.presence)
        (jazz.runtime)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.tracker)
        (jazz.ui.dialog)
        (jazz.version)
        (jazz.view)
        (jazz.window)
        (jazz.zlib)
        (profiler)
        (world)
        (world.actor)
        (world.ambience)
        (world.asset)
        (world.assets)
        (world.atlas)
        (world.autoload)
        (world.block)
        (world.buffers)
        (world.camera)
        (world.change)
        (world.changes)
        (world.chronology)
        (world.client.tier)
        (world.collision)
        (world.commands)
        (world.configure)
        (world.context)
        (world.creature)
        (world.debug)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.entities)
        (world.entity)
        (world.external.milkshape)
        (world.external.obj)
        (world.fog)
        (world.folio)
        (world.foreign)
        (world.gadget)
        (world.generate)
        (world.generation)
        (world.generation.block)
        (world.generation.building)
        (world.generation.decoration)
        (world.generation.rendering)
        (world.geometry)
        (world.gravity)
        (world.grid)
        (world.history)
        (world.homogeneous)
        (world.interface)
        (world.interface.actions)
        (world.interface.animations)
        (world.interface.assets)
        (world.interface.avatars)
        (world.interface.bindings)
        (world.interface.blocks)
        (world.interface.character)
        (world.interface.chat)
        (world.interface.color)
        (world.interface.combat)
        (world.interface.command)
        (world.interface.compass)
        (world.interface.crafting)
        (world.interface.dialogs)
        (world.interface.documents)
        (world.interface.evolution)
        (world.interface.frame)
        (world.interface.gadgets)
        (world.interface.info)
        (world.interface.inventory)
        (world.interface.main)
        (world.interface.map)
        (world.interface.menu)
        (world.interface.meshes)
        (world.interface.models)
        (world.interface.options)
        (world.interface.panel)
        (world.interface.profiler)
        (world.interface.propagation)
        (world.interface.script)
        (world.interface.scripts)
        (world.interface.shaders)
        (world.interface.sheet)
        (world.interface.showcase)
        (world.interface.skyboxes)
        (world.interface.target)
        (world.interface.templates)
        (world.interface.textures)
        (world.interface.tiers)
        (world.interface.tiles)
        (world.interface.timeline)
        (world.interface.who)
        (world.interface.zones)
        (world.io)
        (world.keys)
        (world.light)
        (world.mark)
        (world.material)
        (world.missile)
        (world.model)
        (world.motion)
        (world.music)
        (world.pane)
        (world.parameters)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.profile)
        (world.profiling)
        (world.programs)
        (world.protocol)
        (world.quad)
        (world.ray)
        (world.render)
        (world.renderer)
        (world.renderers)
        (world.script.asset)
        (world.scripts)
        (world.sector)
        (world.settings)
        (world.shaders)
        (world.skybox)
        (world.sound)
        (world.spawn)
        (world.sphere)
        (world.support)
        (world.syntax (phase syntax))
        (world.target)
        (world.task)
        (world.texture)
        (world.travel)
        (world.triangle)
        (world.visualization)
        (world.w3d)
        (world.widget)
        (world.window)
        (world.work)
        (world.zone))


;;;
;;;; World
;;;


(definition (make-eye)
  (let ((camera (make-camera)))
    (setup-area-cube camera 7)
    camera))


(class World extends Object
  
  
  (slot width                  <fl>                initialize #f              accessors generate)
  (slot height                 <fl>                initialize #f              accessors generate)
  (slot eye                    <Camera>            initialize (make-eye)      getter generate)
  (slot eye-motion             <Motion>            initialize #f              getter generate)
  (slot eye-hook               <object>            initialize #f              accessors generate)
  (slot world-up               <vertex>            initialize (make-vertex)   getter generate)
  (slot lighting?              <bool>              initialize #t              getter generate)
  (slot what                   <object>            initialize #f              getter generate)
  (slot selection              <object>            initialize '()             getter generate)
  (slot target-polygon         <object>            initialize #f              getter generate)
  (slot target-vertex          <object>            initialize #f              getter generate)
  (slot target-mode            <object>            initialize 'select         getter generate)
  (slot target-widget          <Widget+>           initialize #f              getter generate)
  (slot last-point             <object>            initialize #f              getter generate)
  (slot last-time              <object>            initialize #f              getter generate)
  (slot showcase               <World-Showcase+>   initialize #f              getter generate)
  (slot showcases              <object>            initialize #f              getter generate)
  (slot showcase-down?         <bool>              initialize #f              getter generate)
  (slot polygon-mode           <fx>                initialize GL_FILL         getter generate)
  (slot window-cursor          <object>            initialize :arrow          getter generate)
  (slot earth?                 <bool>              initialize #t              getter generate)
  (slot interface?             <bool>              initialize #t              accessors generate)
  (slot interface-bars?        <bool>              initialize #t              accessors generate)
  (slot explore-interface?     <bool>              initialize #f              accessors generate)
  (slot ambient-gravity         <vertex>           initialize default-gravity accessors generate)
  (slot jump-impulsion          <fl>               initialize default-jump    accessors generate)
  (slot default-image           <object>           initialize "stone"         accessors generate)
  (slot properties              <object>           initialize '()             accessors generate)
  
  
  (slot version                <object>            initialize #f              getter generate)
  (slot orientation?           <bool>              initialize #f              getter generate)
  (slot aim?                   <bool>              initialize #f              getter generate)
  (slot free-aim?              <bool>              initialize #f              getter generate)
  (slot viewing?               <bool>              initialize #f              getter generate)
  (slot moving?                <bool>              initialize #f              getter generate)
  (slot moved?                 <bool>              initialize #f              getter generate)
  (slot first-camera           <object>            initialize #f              getter generate)
  (slot riders-folio           <Folio>             initialize #f              getter generate)
  (slot flyers-folio           <Folio>             initialize #f              getter generate)
  (slot x-rays?                <bool>              initialize #f              getter generate)
  (slot x-rays-category        <symbol+>           initialize #f              getter generate)
  (slot draw-blocks?           <bool>              initialize #t              getter generate)
  (slot draw-entities?         <bool>              initialize #t              getter generate)
  (slot draw-gadgets?          <bool>              initialize #f              getter generate)
  (slot draw-marks?            <bool>              initialize #t              getter generate)
  (slot draw-normals?          <bool>              initialize #f              getter generate)
  (slot draw-atlas?            <bool>              initialize #f              accessors generate)
  (slot view-distance          <fx>                initialize 7               getter generate)
  (slot view-radius            <fl>                initialize #f              accessors generate)
  (slot max-entity-radius      <fl>                initialize 60.             accessors generate)
  (slot render-thread          <object>            initialize #f              accessors generate)
  (slot render-trim?           <bool>              initialize #f              accessors generate)
  (slot dynamic-lights         <fx>                initialize 8               getter generate)
  (slot post-processing?       <bool>              initialize #t              getter generate)
  (slot player-thread          <object>            initialize #f              accessors generate)
  (slot ongoing-key            <object>            initialize #f              accessors generate)
  (slot axes?                  <bool>              initialize #f              accessors generate)
  (slot axes-graduation?       <bool>              initialize #f              accessors generate)
  (slot tick-slice?            <bool>              initialize #t              getter generate)
  (slot down?                  <bool>              initialize #f              getter generate)
  (slot down-point             <object>            initialize #f              getter generate)
  (slot double-click?          <bool>              initialize #f              getter generate)
  (slot drag-tolerance         <object>            initialize 5               getter generate)
  (slot tick-procedures        <object>            initialize '()             getter generate)
  (slot tick-no                <object>            initialize 0               getter generate)
  (slot commands               <object>            initialize #f              getter generate)
  (slot base-assets            <object>            initialize '()             getter generate)
  (slot user-assets            <object>            initialize '()             getter generate)
  (slot world-assets           <object>            initialize '()             getter generate)
  (slot zone-assets            <object>            initialize '()             accessors generate)
  (slot template-assets        <object>            initialize '()             accessors generate)
  (slot textures               <object>            initialize #f              getter generate)
  (slot models                 <object>            initialize #f              getter generate)
  (slot gc-sound?              <bool>              initialize #f              getter generate)
  (slot gc-trace?              <bool>              initialize #f              getter generate)
  (slot history?               <bool>              initialize #t              getter generate)
  (slot history-trail          <fx>                initialize 250             getter generate)
  (slot history-camera         <Camera>            initialize (make-camera)   getter generate)
  (slot history-camera?        <bool>              initialize #f              getter generate)
  (slot history-motion         <Motion>            initialize #f              getter generate)
  (slot message                <object>            initialize #f              getter generate)
  (slot message-time           <object>            initialize #f              getter generate)
  (slot message-color          <object>            initialize #f              getter generate)
  (slot message-duration       <object>            initialize #f              getter generate)
  (slot message-sheet          <object>            initialize #f              getter generate)
  (slot status                 <object>            initialize #f              getter generate)
  (slot status-time            <object>            initialize #f              getter generate)
  (slot status-color           <object>            initialize #f              getter generate)
  (slot status-sheet           <object>            initialize #f              getter generate)
  (slot compass-sheet          <object>            initialize #f              getter generate)
  (slot compass-visible?       <bool>              initialize #t              accessors generate)
  (slot map-sheet              <object>            initialize #f              getter generate)
  (slot map-visible?           <bool>              initialize #f              getter generate)
  (slot timeline-sheet         <object>            initialize #f              getter generate)
  (slot timeline-visible?      <bool>              initialize #f              getter generate)
  (slot interface-refresh?     <bool>              initialize #f              getter generate)
  (slot interface-refresh-rate <fl>                initialize #f              getter generate)
  (slot interface-last-time    <fl>                initialize #f              getter generate)
  (slot interface-target?      <bool>              initialize #f              getter generate)
  (slot show-belt?             <bool>              initialize #f              accessors generate)
  (slot last-script            <object>            initialize #f              getter generate)
  (slot last-whisperer         <object>            initialize #f              accessors generate)
  (slot escape-hook            <object>            initialize #f              accessors generate)
  (slot enter-hook             <object>            initialize #f              accessors generate)
  
  ;; Shader programs
  (slot mesh-programs          <object>            initialize #f              accessors generate)
  (slot block-atlas            <Atlas>             initialize #f              accessors generate)
  (slot block-texture          <Image-Texture>     initialize #f              accessors generate)
  (slot block-texture-repeat   <Image-Texture>     initialize #f              accessors generate)
  (slot block-opaque           <object>            initialize #f              accessors generate)
  (slot block-transparent      <object>            initialize #f              accessors generate)
  (slot block-coverage         <object>            initialize #f              accessors generate)
  (slot block-water            <object>            initialize #f              accessors generate)
  (slot block-wet              <object>            initialize #f              accessors generate)
  (slot block-multitexture     <object>            initialize #f              accessors generate)
  (slot block-materials        <object>            initialize #f              accessors generate)
  (slot block-program          <Mesh-Program>      initialize #f              accessors generate)
  (slot texture-program        <Texture-Program>   initialize #f              accessors generate)
  (slot sheet-program          <Sheet-Program>     initialize #f              accessors generate)
  (slot material-opaque        <object>            initialize #f              accessors generate)
  (slot material-transparent   <object>            initialize #f              accessors generate)
  (slot day-lightmap           <object>            initialize #f              accessors generate)
  (slot night-lightmap         <object>            initialize #f              accessors generate)
  
  ;; Render targets
  (slot render-target          <Render-Target+>    initialize #f              accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition max-dynamic-lights
    8)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set-current-world self)
    (set! view-distance (world-setting 'world.view-distance 9))
    (set! view-radius 200.)
    (set! history-motion (make-free-motion self history-camera))
    (set-callback history-camera (~ camera-callback self))
    (set! eye-motion (make-free-motion self eye))
    (set-callback eye (~ camera-callback self))
    (set-current-camera eye)
    (set-current-motion eye-motion)
    (set-current-music (new World-Music))
    (set-current-ambience (new World-Ambience))
    (when (window?)
      (set-current-audio (new World-Audio))
      (set-current-video (new World-Video)))
    (set! dynamic-lights (min max-dynamic-lights (world-setting 'world.dynamic-lights 4)))
    (set! earth? (world-setting 'world.earth? #f))
    (set-camera-smoothing? (world-setting 'world.camera-smoothing? #t))
    (set-independent-camera? (world-setting 'world.independent-camera? (not young-child?)))
    (set-autotrack-camera? (world-setting 'world.autotrack-camera? #f))
    (set-track-sensitivity (world-setting 'world.track-sensitivity 200.))
    (set! post-processing? (and (window?) (world-setting 'world.post-processing? #t)))
    (set! interface? (world-setting 'world.start-interface? #t))
    (set! interface-target? (world-setting 'world.interface-target? #f))
    (set-interface-script? (world-setting 'world.interface-script? #f))
    (set! show-belt? (world-setting 'world.show-belt? #t))
    (set! gc-sound? (world-setting 'world.gc-sound? #f))
    (set! gc-trace? (world-setting 'world.gc-trace? #f))
    (set! history? (world-setting 'world.history? #t))
    (set! history-trail (world-setting 'world.history-trail 250))
    (set! history-camera? (world-setting 'world.history-camera? #f))
    (set! evaluate-future? (world-setting 'world.evaluate-future? #f))
    (set! free-aim? (world-setting 'world.free-aim? #f))
    (set-fog? #f @until-for-is-really-nice (world-setting 'world.fog? #t))
    (set-fog-density (world-setting 'world.fog-density default-fog-density))
    (set-fog-color (world-setting 'world.fog-color default-fog-color))
    ;; aec quick hack
    (set-animations? (and (window?) (world-setting 'world.animations? (or arc-en-ciel? (>= (glGetInteger* GL_MAX_VERTEX_UNIFORM_COMPONENTS) 4096)))))
    (set-block-pumps? (world-setting 'world.block-pumps? #f))
    (set! tick-slice? (and (not debug-user?) (not (world-setting 'world.inhibit-slicing? #f))))
    (set! models (make-table test: equal?))
    (set-debug-sounds? (world-setting 'world.debug-sounds? #f))
    (update-world-up self ambient-gravity)
    (prepare-sounds self)
    (setup-history self)
    ;; not necessary if we are not using message-available?
    ;; (set-ignore-key-repeat? #t)
    (register-keys)
    (setup-info))
  
  
  (method package (setup-opengl self)
    (when (window?)
      (setup-size self)
      (glClear GL_COLOR_BUFFER_BIT)
      (glClear GL_DEPTH_BUFFER_BIT)
      (glEnable GL_DEPTH_TEST)
      (glDisable GL_BLEND)
      (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
      (glFrontFace GL_CW)
      (glPolygonMode GL_FRONT_AND_BACK GL_FILL)
      (glEnable GL_LINE_SMOOTH)
      (initialize-eye self))
    ;; need assets for models and models
    ;; are needed for collision detection
    (prepare-assets self)
    (when (window?)
      (prepare-showcases self)
      (prepare-shaders self)
      (prepare-renderes)
      (prepare-sheets self)
      (prepare-skyboxes)
      (initialize-render self)
      (reset-commands self)
      (gl-check-error)))
  
  
  (method (setup-size self)
    (let ((window (current-window)))
      (size-change self (get-size window))))
  
  
  (method package (size-change self size)
    (set! width (cast <fl> (get-width size)))
    (set! height (cast <fl> (get-height size)))
    (size-change eye size)
    (size-change history-camera size)
    (size-change (cache-inventory-camera) size)
    (when showcases
      (iterate-table showcases
        (lambda (name showcase)
          (size-change showcase size))))
    (let ((interface (current-interface+)))
      (when interface
        (set-size interface size)
        (interface-layout self)))
    (reset-inventory-blocks))
  
  
  (method (initialize-render self)
    (set! render-target (new Render-Target (fxround width) (fxround height))))
  
  
  (method package (update-world-up self gravity)
    (vertex-copy! world-up (gravity-up& gravity)))
  
  
  (method (reset-commands self)
    (when (or (not commands) (get-modified? commands))
      (set! commands (new Commands))))
  
  
  (method package (change-view-distance self distance)
    (let ((old-distance view-distance))
      (set! view-distance distance)
      (update-view-distance (current-zone) old-distance distance)))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (method (prepare-assets self)
    (set! base-assets (gather-assets 'base (new Directory (cons (world-alias) '("lib" "world.client" "assets")))))
    (set! user-assets (gather-assets 'user {Directory Documents "assets"}))
    (set! world-assets (gather-assets 'world (new-directory (get-world-directory) "assets"))))
  
  
  (method package (prepare-zone-assets self zone-dir)
    (set! zone-assets (gather-assets 'zone (new-directory zone-dir "assets"))))
  
  
  (method package (prepare-template-assets self zone-dir)
    (let ((instance (new-file zone-dir ".instance")))
      (if (exists? instance)
          (let ((instance (instantiate (read-form instance))))
            (let ((template (get-template instance)))
              (let ((template-dir (new-directory {Directory Application-World "templates"} (append template '("assets")))))
                (set! template-assets (gather-assets 'template template-dir)))))
        (set! template-assets #f))))
  
  
  (method (effective-zone-assets self)
    (if (and (developer?) template-assets)
        (append zone-assets template-assets)
      zone-assets))
  
  
  (method package (unique-zone-assets self)
    (let ((assets (effective-zone-assets self)))
      (and (not-null? assets)
           (car assets))))
  
  
  (method package (iterate-assets self proc)
    (for-each proc (effective-zone-assets self))
    (for-each proc world-assets)
    (let ((tier (current-tier+)))
      (when tier
        (let ((assets (get-assets tier)))
          (when assets
            (proc assets)))))
    (for-each proc user-assets)
    (for-each proc base-assets))
  
  
  (method (partition-assets self)
    (list
      (cons 'zone (effective-zone-assets self))
      (cons 'world world-assets)
      (cons 'tier (let ((tier (current-tier+)))
                    (if tier
                        (let ((assets (get-assets tier)))
                          (if assets
                              (list assets)
                            '()))
                      '())))
      (cons 'user user-assets)
      (cons 'base base-assets)))
  
  
  (method protected virtual (prepare-sheets self)
    (set! message-sheet (make-world-sheet 'message World-Sheet message-size))
    (set! status-sheet (make-world-sheet 'status World-Sheet status-size))
    (set! compass-sheet (make-world-sheet 'compass World-Sheet compass-size))
    (set! map-sheet (make-world-sheet 'map World-Sheet map-size))
    (set! timeline-sheet (make-world-sheet 'timeline World-Sheet timeline-size)))
  
  
  (method protected virtual (resize-sheets self)
    (make-orthographic-matrix! (get-projection-matrix message-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix status-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix compass-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix map-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix timeline-sheet) 0. width 0. height 0. 10.))
  
  
  (method package (prepare-block self atlas texture texture-repeat)
    (set! block-atlas atlas)
    (set! block-texture texture)
    (set! block-texture-repeat texture-repeat))
  
  
  (method package (prepare-materials self opaque-material transparent-material coverage-material water-material wet-material multitexture-material)
    (set! block-opaque opaque-material)
    (set! block-transparent transparent-material)
    (set! block-coverage coverage-material)
    (set! block-water water-material)
    (set! block-wet wet-material)
    (set! block-multitexture multitexture-material)
    (set! block-materials (make-table test: eq?))
    (set! material-opaque (get-entity-material (opaque-rendering)))
    (set! material-transparent (get-entity-material (transparent-rendering))))
  
  
  (method package (prepare-lightmaps self)
    (let ((day {File Application-World "assets" "world" "light" "day.png"})
          (night {File Application-World "assets" "world" "light" "night.png"}))
      (define (make-lightmap file)
        (make-png-texture file min-filter: GL_NEAREST mag-filter: GL_NEAREST wrap: GL_CLAMP_TO_EDGE mipmap?: #f))
      
      (set! day-lightmap (make-lightmap day))
      (set! night-lightmap (make-lightmap night))))
  
  
  ;;;
  ;;;; Sounds
  ;;;
  
  
  (method protected virtual (prepare-sounds self)
    (setup-sounds))

  
  ;;;
  ;;;; Modules
  ;;;
  
  
  (slot installed-repositories        initialize (make-table test: equal?) getter generate)
  (slot installed-repositories-assets initialize (make-table test: equal?) getter generate)
  
  
  (method package (prepare-modules self)
    (let ((queue (new-queue))
          (table (make-table test: equal?)))
      (define (process-assets assets)
        (let ((repository-dir (new-directory (get-directory assets) "module")))
          (when (exists? repository-dir)
            (let ((dirname (parse repository-dir)))
              (enqueue queue dirname)
              (table-set! table dirname assets)))))
      
      (iterate-assets self process-assets)
      (let ((new (queue-list queue)))
        (update-repositories installed-repositories new)
        (set-world-repositories new))
      (set! installed-repositories-assets table)))
  
  
  (method package (collect-modules self)
    (let ((modules '()))
      (for-each (lambda (path)
                  (let ((repository (table-ref installed-repositories path))
                        (assets (table-ref installed-repositories-assets path)))
                    (let ((assets-dir (get-directory assets)))
                      (iterate-packages repository
                        (lambda (package)
                          (let ((dir (new Directory (tokenise-filename (package-directory package)))))
                            (let ((asset-root (subpath assets-dir dir)))
                              (iterate-directory dir
                                (lambda (path kind)
                                  (let ((file (new-file dir path)))
                                    (when (extension=? (get-extension file) "jazz")
                                      (unless (member? (get-name file) '(".DS_Store") test: filename=?)
                                        (let ((asset (new Asset assets asset-root (subpath dir file))))
                                          (set! modules (cons asset modules)))))))
                                full?: #f
                                files?: #t
                                directories?: #f
                                recursive?: #t))))))))
                (get-world-repositories))
      modules))

  
  ;;;
  ;;;; Materials
  ;;;
  
  
  (method package (find-block-material self name)
    (or (table-ref block-materials name #f)
        (let ((mat (case name
                     ((opaque) block-opaque)
                     ((transparent) block-transparent)
                     (else (new Material atlas: block-atlas texture: block-texture-repeat renderer: (require-renderer name))))))
          (table-set! block-materials name mat)
          mat)))
  
  
  ;;;
  ;;;; Showcases
  ;;;
  
  
  (method (prepare-showcases self)
    (set! showcases (make-table test: eq?)))
  
  
  ;;;
  ;;;; Shaders
  ;;;
  
  
  (method (prepare-shaders self)
    ;; shaders
    (build-default-shaders)
    (build-interface-shaders)
    (build-texture-shaders)
    (build-skybox-shaders)
    (build-color-shaders)
    (build-terrain-shaders)
    (build-phong-shaders)
    (build-occlusion-shaders)
    (build-frame-shaders)
    (build-transformation-shaders)

    ;; mesh
    (set! mesh-programs (make-table test: eq?))
    (table-set! mesh-programs 'color                (new Mesh-Color-Program))
    (table-set! mesh-programs 'terrain              (new Mesh-Terrain-Program))
    (table-set! mesh-programs 'phong                (new Mesh-Phong-Program))
    (table-set! mesh-programs 'occlusion            (new Mesh-Occlusion-Program))
    (table-set! mesh-programs 'wireframe            (new Mesh-Wireframe-Program))
    (table-set! mesh-programs 'squareframe          (new Mesh-Squareframe-Program))
    (table-set! mesh-programs 'playerframe          (new Mesh-Playerframe-Program))
    (table-set! mesh-programs 'floorframe           (new Mesh-Floorframe-Program))
    (table-set! mesh-programs 'white                (new Mesh-White-Program))
    (table-set! mesh-programs 'radial-blur          (new Mesh-Radial-Blur-Program))
    (table-set! mesh-programs 'motion-blur          (new Mesh-Motion-Blur-Program))
    (table-set! mesh-programs 'water-terrain        (new Mesh-Water-Terrain-Program))
    (table-set! mesh-programs 'water                (new Mesh-Water-Program))
    (table-set! mesh-programs 'wet-terrain          (new Mesh-Wet-Terrain-Program))
    (table-set! mesh-programs 'julia                (new Mesh-Julia-Program))
    (table-set! mesh-programs 'sierpinski           (new Mesh-Sierpinski-Program))
    (table-set! mesh-programs 'multitexture-terrain (new Mesh-Multitexture-Terrain-Program))
    (table-set! mesh-programs 'multitexture         (new Mesh-Multitexture-Program))
    (table-set! mesh-programs 'kaleidoscope         (new Mesh-Kaleidoscope-Program))
    (table-set! mesh-programs 'tunnel               (new Mesh-Tunnel-Program))
    (table-set! mesh-programs 'square-tunnel        (new Mesh-Square-Tunnel-Program))
    (table-set! mesh-programs 'fly                  (new Mesh-Fly-Program))
    (table-set! mesh-programs 'pulse                (new Mesh-Pulse-Program))

    ;; block
    (set! block-program (find-mesh-program self 'terrain))
    
    ;; texture
    (set! texture-program (new Texture-Program))
    
    ;; sheet
    (set! sheet-program (new Sheet-Program))
    
    (gl-check-error))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (destroy self)
    (when (window?)
      (free-resources render-target)
      (detach-shaders block-program)
      (glDeleteTextures* (get-id (get-texture message-sheet)))
      (glDeleteTextures* (get-id (get-texture status-sheet)))
      (glDeleteTextures* (get-id (get-texture compass-sheet)))
      (glDeleteTextures* (get-id (get-texture map-sheet)))
      (glDeleteTextures* (get-id (get-texture timeline-sheet)))
      (close (current-video))
      (close (current-audio))
      (close-music (current-music))))
  
  
  (method public (toggle-gc-sound self)
    (set! gc-sound? (not gc-sound?))
    (display-on/off self "GC sound" gc-sound?))
  
  
  (method public (garbage-collect self)
    (let ((window (current-window)))
      (display-message self "Garbage collecting" color: {Color Red})
      (render-scene window)
      (gc)
      (let ((timer (new Timer)))
        (gc)
        (display-message self (format "Garbage collected ({a}ms)" (real-duration-in-milliseconds timer)) color: {Color Green}))
      (render-scene window)))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method package virtual (initialize-world self)
    (set! version world-version)
    (set! first-camera 'free)
    (set! grid? (world-setting 'world.grid? #f))
    (set! axes? (world-setting 'world.axes? #f))
    (set! axes-graduation? (world-setting 'world.axes-graduation? #f))
    (set! lighting? #t)
    (setup-gc self)
    (when (window?)
      (setup-interface self)))
  
  
  (method package (setup-interface self)
    (let ((interface (current-interface+)))
      (when interface
        (close interface)))
    (set-current-interface (make-world-sheet 'interface World-Interface {Dimension 10 10}))
    (let ((window (current-window))
          (interface (current-interface)))
      (make-orthographic-matrix! (get-projection-matrix interface) 0. 10. 0. 10. 0. 10.)
      (make-identity-matrix! (get-view-matrix interface))
      (set! interface-refresh-rate (world-setting 'world.interface-refresh-rate 1.))
      (set! interface-last-time -inf.0)
      (new Info-Panel parent: interface name: 'info visible?: #f layouter: (lambda (panel) (info-panel-layouter panel)))
      (new Profiler-Panel parent: interface name: 'profiler visible?: #f layouter: (lambda (panel) (profiler-panel-layouter panel)))
      (new Timeline-Panel parent: interface name: 'timeline visible?: #f layouter: (lambda (panel) (timeline-panel-layouter panel)))
      (new Evolution-Panel parent: interface name: 'evolution visible?: #f layouter: (lambda (panel) (evolution-panel-layouter panel)))
      (new Color-Panel parent: interface name: 'color visible?: #f layouter: (lambda (panel) (color-panel-layouter panel)))
      (new Target-Panel parent: interface name: 'target visible?: #f layouter: (lambda (panel) (target-panel-layouter panel)))
      (new Compass-Panel parent: interface name: 'compass visible?: #f layouter: (lambda (panel) (compass-panel-layouter panel)))
      (new Map-Panel parent: interface name: 'map visible?: #f layouter: (lambda (panel) (map-panel-layouter panel)))
      (new Combat-Panel parent: interface name: 'combat visible?: #f layouter: (lambda (panel) (combat-panel-layouter panel)))
      (new Character-Panel parent: interface name: 'character visible?: #f layouter: (lambda (panel) (character-panel-layouter panel)))
      (new Bag-Panel parent: interface name: 'bag visible?: #f layouter: (lambda (panel) (bag-panel-layouter panel)))
      (new Belt-Panel parent: interface name: 'belt visible?: #f layouter: (lambda (panel) (belt-panel-layouter panel)))
      (new Chest-Panel parent: interface name: 'chest visible?: #f layouter: (lambda (panel) (chest-panel-layouter panel)))
      (new Crafting-Panel parent: interface name: 'crafting visible?: #f layouter: (lambda (panel) (crafting-panel-layouter panel)))
      (new Chat-Panel parent: interface name: 'chat visible?: #f layouter: (lambda (panel) (chat-panel-layouter panel)))
      (new Command-Bar parent: interface name: 'command visible?: #f layouter: (lambda (panel) (command-bar-layouter panel)))
      (new (script-panel-class self) parent: interface name: 'script visible?: #f layouter: (lambda (panel) (script-panel-layouter panel)))
      (setup-application-interface (current-application))
      (set-root window interface offscreen?: #f)
      (update-background (get-manager (child interface 'script)))
      (setup-script-zoom)
      (interface-layout self)
      (acquire-focus interface)))
  
  
  (method protected virtual (script-panel-class self)
    Script-Panel)
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method package (zone-update self)
    (set! riders-folio (new Folio 'Wheels '(Wheels Hummer)))
    (set! flyers-folio (new Folio 'Saucer '(Saucer Rocket)))
    (let ((zone (current-zone))
          (me (current-me+)))
      (when me
        (let ((camera (player-camera me)))
          ;; eye
          (camera-copy! eye camera)
          ;; player
          ;; ride & fly (needs more work for it to reload exactly in the same state)
          (case (get-mount me)
            ((ride)
             (set-mount me #f)
             (ride-change me 'Wheels))
            ((fly)
             (set-mount me #f)
             (fly-change me 'Saucer)))
          ;; eye
          (let ((start-mode (or (get-start-mode zone) 'first-person)))
            (if (neq? start-mode 'first-person)
                (free-motion self feedback?: #f)
              (person-motion self eye-center?: #f feedback?: #f)
              (let ((distance (or (get-start-distance zone) 3.5)))
                (setup-motion (current-motion) distance))))))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method package (tick-task self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          (let ((time (current-seconds))
                (duration 0.))
            (let ((elapse (- time previous))
                  (max-elapse 10.))
              ;; ignore ridiculous elapses like
              ;; coming back from computer sleep
              (unless (> elapse max-elapse)
                (unless (stopping? task)
                  ;; take over player task when no me
                  (when (not (current-me+))
                    (process-mouse-run self)
                    (when (world-focused?)
                      (process-keys self)))
                  (increase! duration (tick-world self time elapse))))
              (task-wait task tick-period duration exit)
              (iter time)))))))
  
  
  (method (tick-world self time elapse)
    (let ((duration 0.))
      (site (tick on?: #t)
        (let ((zone (current-zone))
              (history (current-history)))
          (site (tick-scene on?: #f parent: tick)
            (increase! duration (tick-scene zone elapse))
            (when showcase
              (increase! duration (tick-scene showcase elapse))))
          (site (tick-procedures on?: #f parent: tick)
            (when (not-null? tick-procedures)
              (for-each (lambda (proc)
                          (with-task-mutex
                            (lambda ()
                              (when (memq? proc tick-procedures)
                                (let ((start (current-seconds)))
                                  (proc elapse)
                                  (increase! duration (- (current-seconds) start)))))))
                        tick-procedures)))))
      duration))
  
  
  (method package (register-tick self proc)
    (set! tick-procedures (cons proc tick-procedures)))
  
  
  (method package (unregister-tick self proc)
    (set! tick-procedures (remove! proc tick-procedures)))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (boost-player self)
    (unless together?
    (when (and player-thread (not player-boost?) (neq? (current-thread) player-thread))
      (set-player-boost? #t)
      (thread-base-priority-set! player-thread priority-boost))))
  
  
  (method (unboost-player self)
    (unless together?
    (set-player-boost? #f)
    (thread-base-priority-set! player-thread player-priority)))
  
  
  (method package (player-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (set! player-thread (current-thread))
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds))
                  (duration 0.))
              (let ((elapse (- time previous))
                    (max-elapse 10.))
                ;; ignore ridiculous elapses like
                ;; coming back from computer sleep
                (unless (> elapse max-elapse)
                  (with-task-mutex
                    (lambda ()
                      (unless (stopping? task)
                        (let ((start (current-seconds)))
                          (site (player on?: #t)
                            (unless bot?
                              (when sphere?
                              (process-mouse-run self))
                              (when (world-focused?)
                                (process-keys self))
                              (unless (get-paused? history)
                                (when sphere?
                                (let ((me (current-me)))
                                  (tick-sliced self me commands time elapse)
                                  (reset-commands self)
                                  (animate me elapse)
                                  (let ((vehicle (get-vehicle me)))
                                    (when vehicle
                                      (animate vehicle elapse (get-position me))))))))
                            (when sphere?
                            (update-transformation-time elapse)
                            (let ((me (current-me))
                                  (motion (current-motion)))
                              (restore-desired-distance motion elapse)
                              (restore-roll motion me))))
                          (increase! duration (- (current-seconds) start))))))))
              (unboost-player self)
              (boost-render self)
              (task-wait task player-period duration exit)
              (iter time)))))))
  
  
  (method package (tick-sliced self actor commands time elapse)
    (declare (proper-tail-calls))
    (let ((slice (tick-slice actor)))
      (if (or (not slice) (not tick-slice?) (<= elapse slice))
          (tick actor commands time elapse)
        (let (iter (from 0.) (to slice))
          (tick actor commands (- time (- elapse to)) (- to from))
          (when (and (< to elapse) (get-alive? actor))
            (iter to (min elapse (+ to slice))))))))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method package (missile-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds))
                  (duration 0.))
              ;; only server ticks missiles
              (unless (client?)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (or (> elapse max-elapse) 
                              (get-paused? history))
                    (increase! duration (tick-missiles self #f time elapse)))))
              (task-wait task missile-period duration exit)
              (iter time)))))))
  
  
  (method (tick-missiles self commands time elapse)
    (let ((zone (current-zone))
          (history (current-history)))
      (let ((duration 0.))
        (for-each (lambda (actor)
                    (when (is-missile? actor)
                      (with-task-mutex
                        (lambda ()
                          (site (missile on?: #t)
                            (unless (get-paused? history)
                              ;; check linked instead of alive because of
                              ;; missiles delayed unlinking until rendered
                              (when (linked? actor)
                                (let ((start (current-seconds)))
                                  (tick actor commands time elapse)
                                  (increase! duration (- (current-seconds) start))))))))))
                  (get-actors zone))
        duration)))

  
  ;;;
  ;;;; Circularity
  ;;;
  
  
  ;; quick hacks around circular dependencies
  (method (polygon-class self)
    Polygon)
  (method package (triangle-class self)
    Triangle)
  (method package (quad-class self)
    Quad)
  (method (missile-class self)
    Missile)

  
  ;;;
  ;;;; Events
  ;;;
  
  
  ;; Interface
  (method (on-main-menu self evt)
    (main-menu self))
  
  (method (on-video-options self evt)
    (video-options self))
  
  (method (on-audio-options self evt)
    (audio-options self))
  
  (method (on-interface-options self evt)
    (interface-options self))
  
  (method (on-view-bindings self evt)
    (view-bindings self))
  
  (method (on-view-news self evt)
    (view-news self))
  
  (method (on-view-roadmap self evt)
    (view-roadmap self))
  
  (method (on-view-help self evt)
    (view-help self))
  
  (method (on-open-about self evt)
    (open-about self))
  
  (method (on-toggle-interface self evt)
    (toggle-interface self))
  
  (method (on-toggle-occlusion self evt)
    (toggle-occlusion self))
  
  (method (on-toggle-wireframe self evt)
    (toggle-wireframe self))
  
  (method (on-toggle-profiler self evt)
    (toggle-profiler self))
  
  (method (on-reset-profiling self evt)
    (gc)
    (reset-profiling self)
    (display-message self "Profiling reset"))
  
  (method (on-toggle-timeline self evt)
    (toggle-timeline self))
  
  (method (on-toggle-evolution self evt)
    (toggle-evolution self))
  
  (method (on-open-welcome self evt)
    (open-welcome self))
  
  (method (on-quit-world self evt)
    (quit-process (current-application)))
  
  (method (on-resume-world self evt)
    (close-current-top self))

  (method (on-select/run-script self evt)
    (select/run-script self))

  (method (on-run-last-script self evt)
    (run-last-script self))
  
  (method (on-enter-press self evt)
    (enter-press self))
  
  (method package (on-tab-press self evt)
    (tab-press self))
  
  
  ;; Graphics
  (method (on-toggle-lighting self evt)
    (toggle-lighting self))
  
  (method (on-toggle-fog self evt)
    (toggle-fog self))
  
  (method (on-toggle-draw-gadgets self evt)
    (toggle-draw-gadgets self))
  
  (method (on-toggle-draw-normals self evt)
    (toggle-draw-normals self))
  
  (method (on-toggle-x-rays self evt)
    (toggle-x-rays self))
  
  (method (on-toggle-redstone-x-rays self evt)
    (toggle-redstone-x-rays self))
  
  (method (on-toggle-draw-blocks self evt)
    (toggle-draw-blocks self))
  
  (method (on-toggle-draw-models self evt)
    (toggle-draw-models self))
  
  (method (on-toggle-post-processing self evt)
    (toggle-post-processing self))
  
  
  ;; Sound
  (method (on-toggle-sound self evt)
    (toggle-sound self))
  
  
  ;; Server
  (method (on-server-state self evt)
    )
  
  (method (on-server-info self evt)
    )
  
  
  ;; Role
  (method (on-toggle-user self evt)
    (toggle-user self))
  
  
  ;; Zone
  (method (on-zone-new self evt)
    (zone-new self))
  
  (method (on-zone-open self evt)
    (zone-open self))
  
  (method (on-zone-open-content self evt)
    (zone-open-content self))
  
  (method (on-zone-reload self evt)
    (zone-reload self))
  
  (method (on-zone-regenerate self evt)
    (zone-regenerate self))
  
  
  ;; Universe
  (method (on-bullet self evt)
    ;; done in process-keys
    )
  
  (method (on-arrow self evt)
    ;; done in process-keys
    )
  
  @wait
  (method (on-rapid-fire evt)
    (maybe-rapid-fire))
  
  (method (on-sprint self evt)
    ;; done in process-keys
    )
  
  (method (on-blink self evt)
    ;; done in process-keys
    )
  
  (method (on-warp self evt)
    ;; done in process-keys
    )
  
  (method (on-toggle-run self evt)
    (toggle-run self))
  
  (method (on-start-dash self evt)
    (let ((me (current-controlled self)))
      (start-dash me)))
  
  (method (on-mind-control self evt)
    (mind-control self))
  
  (method (on-toggle-aim self evt)
    (toggle-aim self))
  
  (method (on-toggle-free-aim self evt)
    (toggle-free-aim self))
  
  (method (on-toggle-ride self evt)
    (toggle-ride (current-controlled self)))
  
  (method (on-toggle-fly self evt)
    (toggle-fly (current-controlled self)))
  
  (method (on-toggle-vehicle self evt)
    (toggle-vehicle (current-controlled self)))
  
  (method (on-compass-panel self evt)
    (compass-panel self))
  
  (method (on-map-panel self evt)
    (map-panel self))
  
  (method (on-combat-panel self evt)
    (combat-panel self))
  
  (method (on-character-panel self evt)
    (character-panel self))
  
  (method (on-bag-panel self evt)
    (bag-panel self))
  
  (method (on-belt-panel self evt)
    (belt-panel self))
  
  (method (on-who-panel self evt)
    (who-panel self))
  
  (method (on-chat-panel self evt)
    (chat-panel self))
  
  (method (on-command-message self evt)
    (command-message self))
  
  (method (on-command-slash self evt)
    (command-slash self))
  
  
  ;; Motion
  (method (on-person-motion self evt)
    (person-motion self))
  
  (method (on-orbit-motion self evt)
    (orbit-motion self))
  
  (method (on-free-motion self evt)
    (free-motion self))
  
  (method (on-toggle-camera-smoothing self evt)
    (toggle-camera-smoothing self))
  
  (method (on-toggle-camera-follow self evt)
    (toggle-camera-follow self))
  
  (method (on-toggle-cursor-mode self evt)
    (toggle-cursor-mode self))
  
  
  (method (on-move-forward self evt)
    ;; done in process-keys
    )
  
  (method (on-move-backward self evt)
    )
  
  (method (on-rotate-left self evt)
    )
  
  (method (on-rotate-right self evt)
    )
  
  
  ;; Edition
  (method (on-showcase self evt)
    (let ((showcase (get-property evt showcase:)))
      (goto-showcase self showcase)))
  
  (method (on-import-model self evt)
    (import-model self))
  
  (method (on-delete-target self evt)
    (delete-target self))
  
  (method (on-toggle-grid self evt)
    (toggle-grid self))
  
  (method (on-toggle-grid-plane self evt)
    (toggle-grid-plane self (get-property evt plane:)))
  
  (method (on-decrease-grid self evt)
    (decrease-grid self))
  
  (method (on-increase-grid self evt)
    (increase-grid self))
  
  (method (on-reload-textures self evt)
    (reload-textures self)
    (display-message self "Textures reloaded"))
  
  (method (on-change-editor-mode self evt)
    (change-editor-mode self reversed?: (effective-event-reversed? self evt)))
  
  (method (on-select-target-mode self evt)
    (select-target-mode self))
  
  (method (on-move-target-mode self evt)
    (move-target-mode self))
  
  (method (on-rotate-target-mode self evt)
    (rotate-target-mode self))
  
  (method (on-scale-target-mode self evt)
    (scale-target-mode self))
  
  (method (on-skeleton-target-mode self evt)
    (skeleton-target-mode self))
  
  
  ;; History
  (method (on-toggle-paused self evt)
    (toggle-paused self))
  
  (method (on-backward-history self evt)
    (backward-history self))
  
  (method (on-forward-history self evt)
    (forward-history self))
  
  (method (on-step-backward self evt)
    (step-backward self))
  
  (method (on-step-forward self evt)
    (step-forward self))
  
  (method (on-step-over self evt)
    (step-over self))
  
  (method (on-reset-history self evt)
    (reset-history self))
  
  (method (on-toggle-evaluate-future self evt)
    (toggle-evaluate-future self))
  
  (method (on-toggle-synchronize-cameras self evt)
    (toggle-synchronize-cameras self))
  
  (method (on-toggle-simulate-protocol self evt)
    (toggle-simulate-protocol self))
  
  
  ;; Window
  (method (on-toggle-windowed-mode self evt)
    (toggle-windowed-mode self))
  
  (method (on-tile-server/clients self evt)
    (tile-server/clients self))
  
  (method (on-restore-server/clients self evt)
    (restore-server/clients self))
  
  (method (on-live-gaia/world self evt)
    (live-gaia/world self))
  
  (method (on-design-gaia/world self evt)
    (design-gaia/world self))
  
  (method (on-restore-gaia/world self evt)
    (restore-gaia/world self))
  
  (method (on-zoom-horizontally self evt)
    (zoom-horizontally self))
  
  (method (on-zoom-vertically self evt)
    (zoom-vertically self))
  
  (method (on-zoom-fullscreen self evt)
    (zoom-fullscreen self))
  
  
  (method (on-zoom-in-script self evt)
    (zoom-in-script self))
  
  (method (on-zoom-out-script self evt)
    (zoom-out-script self))
  
  (method (on-unzoom-script self evt)
    (unzoom-script self))


  ;; Debug
  (method (on-toggle-axes self evt)
    (toggle-axes self))
  
  (method (on-toggle-axes-graduation self evt)
    (toggle-axes-graduation self))
  
  (method (on-toggle-info self evt)
    (toggle-info self))
  
  (method (on-toggle-target self evt)
    (toggle-target self))
  
  (method (on-toggle-script self evt)
    (toggle-script))
  
  (method (on-view-workspace self evt)
    (view-workspace))
  
  (method (on-view-console self evt)
    (view-console))
  
  (method (on-view-script self evt)
    (view-script))
  
  (method (on-view-debugger self evt)
    (view-debugger))
  
  (method (on-view-toolbox self evt)
    (view-toolbox))
  
  (method (on-cycle-panes self evt)
    (let ((target (first-target self)))
      (if (is-not? target Entity)
          (bell)
        (cycle-panes target))))
  
  (method (on-run-selected-script self evt)
    (run-selected-script))
  
  (method (on-toggle-orientation self evt)
    (toggle-orientation self))
  
  (method (on-toggle-debug-sections self evt)
    (toggle-debug-sections (current-zone)))
  
  (method (on-toggle-debug-sectors self evt)
    (toggle-debug-sectors (current-zone)))
  
  (method (on-toggle-debug-areas self evt)
    (toggle-debug-areas (current-zone)))
  
  (method (on-toggle-draw-atlas self evt)
    (toggle-draw-atlas self))
  
  (method (on-toggle-draw-me self evt)
    (toggle-draw-me self))
  
  (method (on-change-missile-behavior self evt)
    (change-missile-behavior self reversed?: (effective-event-reversed? self evt)))
  
  (method (on-reset-marks self evt)
    (reset-all-marks (current-zone)))
  
  (method (on-clear-terminal self evt)
    (clear-terminal))
  
  (method (on-clear-console self evt)
    (if (get-controller-debugger)
        (clear-debugger-console)
      (display-error self "Not connected to a debugger")))
  
  (method (on-toggle-gc-sound self evt)
    (toggle-gc-sound self))

  (method (on-garbage-collect self evt)
    (garbage-collect self))

  (method (on-explore-interface self evt)
    (explore-interface self))
  
  (method (on-propagation-debugger self evt)
    (propagation-debugger self))
  
  (method (on-test-script self evt)
    (test-script))
  
  (method (on-test1-script self evt)
    (test1-script))

  (method (on-test2-script self evt)
    (test2-script))

  (method (on-test3-script self evt)
    (test3-script))

  (method (on-test4-script self evt)
    (test4-script))

  (method (on-test5-script self evt)
    (test5-script))

  (method (on-test6-script self evt)
    (test6-script))

  (method (on-test7-script self evt)
    (test7-script))

  (method (on-test8-script self evt)
    (test8-script))

  (method (on-test9-script self evt)
    (test9-script))

  (method (on-test0-script self evt)
    (test0-script))
  
  
  ;; Collision
  (method (on-setup-collisions self evt)
    (set! evaluate-future? #f)
    (set! tick-slice? #f)
    (set-move-speed history-camera 0.05)
    (set-strafe-speed history-camera 0.02)
    (set-rotate-speed history-camera 0.02)
    (set-debug-collisions? #t)
    (update-parameter self 'debug-collisions)
    (reset-marks (current-zone))
    (when (shift-down?)
      (execute-script self "world/generate/stairs"))
    (display-message self "Collisions setup"))
  
  (method (on-toggle-debug-collisions self evt)
    (execute-script self "world/collision/debug-collisions"))
  
  (method (on-change-radiuses self evt)
    (execute-script self "world/collision/change-radiuses"))
  
  (method (on-test-collisions self evt)
    (execute-script self "world/collision/test"))
  
  
  ;; Utility
  (method (effective-event-reversed? self evt)
    (shift-down?))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method package (setup-history self)
    (set-current-history (new History (world-setting 'world.history-size 1000))))
  
  
  (method package (backward-history self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (backward-history history #t))))
  
  
  (method package (forward-history self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (forward-history history #t))))
  
  
  (method package (truncate-history self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (truncate-history history)))
  
  
  (method (reset-history self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (setup history)
      (display-message self "History reset")))
  
  
  (method package (step-backward self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (step-backward history))))
  
  
  (method package (step-forward self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (step-forward history))))
  
  
  (method package (step-over self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (step-over history))))
  
  
  (method package (recalculate-future self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (recalculate-future history))))
  
  
  (method (update-future self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (recalculate-future self))))
  
  
  (method (toggle-evaluate-future self)
    (unimplemented-connected self)
    (set! evaluate-future? (not evaluate-future?))
    (update-parameter self 'evaluate-future)
    (display-on/off self "Evaluate future" evaluate-future?))
  
  
  (method (toggle-synchronize-cameras self)
    (when (server?)
      (set-synchronize-cameras? (not synchronize-cameras?))
      (display-on/off self "Synchronize cameras" synchronize-cameras?)))
  
  
  (method (toggle-simulate-protocol self)
    (set-simulate-protocol? (not simulate-protocol?))
    (display-on/off self "Simulate protocol" simulate-protocol?)
    (if simulate-protocol?
        (lock-history-tooltip self)
      (unlock-history-tooltip self))
    (when (server?)
      (let ((tier (current-tier)))
        (for-each (lambda (delegate)
                    (calling-client tier delegate
                      (lambda ()
                        (protocol-client (get-client delegate) simulate-protocol?))))
                  (get-delegates tier)))))
  
  
  (method package (lock-history-tooltip self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'slider)))
        (lock-tooltip panel {Point 0 0}))))
  
  
  (method package (unlock-history-tooltip self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'slider)))
        (unlock-tooltip panel))))
  
  
  ;;;
  ;;;; Action
  ;;;
  
  
  (slot commands-hook initialize #f accessors generate)
  (slot action-hook   initialize #f accessors generate)
  
  
  (method package (hook-commands self commands)
    (if commands-hook
        (commands-hook commands)
      #t))
  
  
  (method (hook-action self name arguments)
    (if action-hook
        (action-hook name arguments)
      #t))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method package (move-forward self)
    (move-forward (current-motion)))
  
  
  (method package (move-backward self)
    (move-backward (current-motion)))
  
  
  (method package (sprint-forward self)
    (sprint-forward (current-motion)))
  
  
  (method package (sprint-backward self)
    (sprint-backward (current-motion)))
  
  
  (method package (blink-forward self)
    (blink-forward (current-motion)))
  
  
  (method package (blink-backward self)
    (blink-backward (current-motion)))
  
  
  (method package (warp-forward self)
    (warp-forward (current-motion)))
  
  
  (method package (warp-backward self)
    (warp-backward (current-motion)))
  
  
  (method package (move-left self)
    (move-left (current-motion)))
  
  
  (method package (move-right self)
    (move-right (current-motion)))
  
  
  (method package (process-move-up self)
    (let ((me (current-me))
          (history (current-history)))
      (if (or (get-paused? history) (and (person-motion?) (flying? me)))
          (move-up self)
        (space self))))
  
  
  (method package (move-up self)
    (move-up (current-motion)))
  
  
  (method package (process-move-down self)
    (move-down self))
  
  
  (method package (move-down self)
    (move-down (current-motion)))
  
  
  (method package (process-rotate-left self)
    (if (is-moving? self)
        (move-left self)
      (rotate-left self)))
  
  
  (method package (rotate-left self)
    (rotate-left (current-motion)))
  
  
  (method package (process-rotate-right self)
    (if (is-moving? self)
        (move-right self)
      (rotate-right self)))
  
  
  (method package (rotate-right self)
    (rotate-right (current-motion)))
  
  
  (method package (space self)
    (let ((me (current-me+))
          (motion (current-motion)))
      (cond ((person-motion?)
             (space me commands))
            ((orbit-motion?)
             (move-up motion))
            (else
             (move-up self)))))
  
  
  ;;;
  ;;;; Universe
  ;;;
  
  
  (method package (fire-aim self kind)
    (let ((me (current-controlled self)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (fire-aim me kind)))))
  
  
  (method package (maybe-fire self kind)
    (let ((me (current-controlled self)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (maybe-fire me kind)))))
  
  
  (method (maybe-rapid-fire self)
    (unless (orbit-motion?)
      (rapid-fire self)))
  
  
  (method (rapid-fire self)
    (let ((me (current-controlled self)))
      (start-rapid-fire me)))
  
  
  (method package (blink self (reversed? #f))
    (if reversed?
        (blink-backward self)
      (blink-forward self)))
  
  
  (method package (warp self (reversed? #f))
    (if reversed?
        (warp-backward self)
      (warp-forward self)))
  
  
  (method (toggle-run self)
    (let ((me (current-controlled self)))
      (set-motion me (if (eq? (get-motion me) 'run)
                          'walk
                        'run))))
  
  
  ;;;
  ;;;; Eye
  ;;;
  
  
  (method (set-eye self camera)
    (camera-copy! eye camera))
  
  
  (method (initialize-eye self)
    (set-move-speed eye (world-setting 'world.camera-move-speed .5))
    (set-sprint-speed eye (world-setting 'world.camera-sprint-speed 1.5))
    (set-blink-speed eye (world-setting 'world.camera-blink-speed 2.))
    (set-warp-speed eye (world-setting 'world.camera-warp-speed 4.))
    (set-strafe-speed eye (world-setting 'world.camera-strafe-speed .1))
    (set-rotate-speed eye (world-setting 'world.camera-rotate-speed .035)))
  
  
  (method package (prepare-motion self)
    (let ((motion (current-motion)))
      (when (is? motion Target-Motion)
        (remove-eye-occlusion motion (lens-center (motion-target motion))))))
  
  
  (method package (hook-eye self)
    (if eye-hook
        (eye-hook)
      #t))
  
  
  (method (camera-callback self stable?)
    (when (not stable?)
      (when (and render-thread (not render-trim?))
        (boost-player self)
        ;; sector priorities depend on the camera so we have to trim
        (set! render-trim? #t))))
  
  
  (method (toggle-orientation self)
    (set! orientation? (not orientation?))
    (update-parameter self 'orientation))

  
  (method package (zoom-in self)
    (zoom-in (current-motion)))
  
  
  (method package (zoom-out self)
    (zoom-out (current-motion)))
  
  
  (method (toggle-camera-smoothing self)
    (change-camera-smoothing self (not (get-camera-smoothing?)))
    (display-on/off self "Camera smoothing" (get-camera-smoothing?)))
  
  
  (method package (change-camera-smoothing self value)
    (set-camera-smoothing? value)
    (update-parameter self 'camera-smoothing))
  
  
  (method (toggle-camera-follow self)
    (let ((camera (next-element '(follow free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'follow)
        (follow-player self))
      (update-parameter self 'camera-follow)
      (display-message self (format "Camera {a}" camera))))
  
  
  (method (toggle-cursor-mode self)
    (let ((window (current-window)))
      (set-autotrack-camera? (not (get-autotrack-camera?)))
      (let ((autotrack? (get-autotrack-camera?)))
        (display-message self (if autotrack? "Track" "Select"))
        (cond (autotrack?
               (set-window-cursor window :cross)
               (capture-cursor window))
              (else
               (set-window-cursor window :arrow)
               (release-cursor window))))))
  
  
  (method package (current-controlled self)
    (let ((me (current-me)))
      (effective-controlled me)))
  
  
  (method (current-controlled+ self)
    (let ((me (current-me+)))
      (and me (effective-controlled me))))
  
  
  (method package (follow-player self)
    (follow-player (current-motion)))
  
  
  (method package (follow-actor self actor)
    (follow-actor (current-motion) actor))
  
  
  (method package (eye-behind-player self)
    (eye-behind-player (current-motion)))
  
  
  (method package (eye-behind-actor self actor)
    (eye-behind-actor (current-motion) actor))
  
  
  (method (mark-eye self)
    (let ((zone (current-zone))
          (me (current-me)))
      (add-mark zone (new Position-Mark (lens-center me) color: red-dye))
      (add-mark zone (new Position-Mark (get-position (current-camera)) color: green-dye))
      (add-mark zone (new Position-Mark (get-target (current-camera)) color: blue-dye))))
  
  
  (method (effective-autotrack-camera? self)
    (let ((zone (current-zone)))
      (and (get-autotrack-camera?)
           (world-focused?)
           (not (top-panel))
           (not (welcome? zone)))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method package (is-moving? self)
    (or (and (effective-autotrack-camera? self) (not (get-cursor-mode?)))
        (and down? (or (and moving? (or (person-motion?) (free-motion?))) (not (get-independent-camera?))))))
  
  
  (method (mind-control self)
    (let ((me (current-me)))
      (let ((controlled (get-controlled me))
            (target (first-target self)))
        (if (and (is? target Actor)
                 (neq? target controlled))
            (control me target)
          (when controlled
            (relinquish-control me))))))
  
  
  (method (toggle-aim self)
    (set! aim? (not aim?))
    (update-parameter self 'aim))
  
  
  (method (toggle-free-aim self)
    (set! free-aim? (not free-aim?))
    (update-parameter self 'free-aim)
    (display-on/off self "Free aim" free-aim?))

  
  (method (draw-aim self)
    (let ((me (current-me)))
      (let ((lens (lens-center me)))
        (let ((x (vertex-x lens))
              (y (vertex-y lens))
              (z (vertex-z lens))
              (size .05)
              (width .0015))
          (render-line (vertex (- x size) y z)
                       (vertex (+ x size) y z)
                       width
                       white-dye)
          (render-line (vertex x (- y size) z)
                       (vertex x (+ y size) z)
                       width
                       white-dye)
          (render-line (vertex x y (- z size))
                       (vertex x y (+ z size))
                       width
                       white-dye)))))
  
  
  ;;;
  ;;;; Resize
  ;;;
  
  
  (method package virtual (resize-scene self)
    (when (window?)
      (let ((width (fxround width))
            (height (fxround height)))
        (resize render-target width height))
      (resize-sheets self)
      (resize (current-video))))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (boost-render self)
    (unless together?
    (when (and render-thread (not render-boost?))
      (set-render-boost? #t)
      (thread-base-priority-set! render-thread priority-boost))))
  
  
  (method (unboost-render self)
    (unless together?
    (set-render-boost? #f)
    (thread-base-priority-set! render-thread render-priority)))
  
  
  (method package (render-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((window (current-window))
          (zone (current-zone)))
      (with-task task
        (lambda (exit)
          (set! render-thread (current-thread))
          (let (iter)
            (let ((time (current-seconds&))
                  (camera (current-camera)))
              (with-task-mutex
                (lambda ()
                  (unless (stopping? task)
                    (site (render on?: #t)
                      (when window-active?
                        (update-stable camera camera-stable-delay)
                        (when render-trim?
                          (let ((trimmed (trim-content 0)))
                            (when (> trimmed 0)
                              (decrease-sectors-generating zone trimmed)))
                          (set! render-trim? #f))
                        (render-frame self)
                        (site (render-sync on?: #t parent: render)
                          (render-sync window)))))))
              (unboost-render self)
              (let ((period (if application-active? render-period (if (server?) render-period-inactive-server render-period-inactive)))
                    (duration (- (current-seconds&) time)))
                (task-wait task period duration exit)))
            (iter))))))
  
  
  (method package virtual (render-frame self)
    (let ((interface (current-interface))
          (zone (current-zone))
          (video (current-video)))
      (define (update-interface)
        (when interface?
          (let ((now (current-seconds&)))
            (define (visible? name)
              (let ((view (child interface name)))
                (get-visible? view)))
            
            (when (> (- now interface-last-time) interface-refresh-rate)
              (when (or (visible? 'info)
                        (visible? 'target)
                        (visible? 'profiler)
                        (visible? 'timeline))
                (unless interface-refresh?
                  (refresh-interface self)))))))
      
      (with-render-mutex
        (lambda ()
          (update-interface)
          (when post-processing?
            (preprocess-render self))
          (glClear GL_COLOR_BUFFER_BIT)
          (glClear GL_DEPTH_BUFFER_BIT)
          (render-world self)
          (render-outputs video)
          (render-interface self)
          (render-visualizer)
          (when post-processing?
            (postprocess-render self))
          (gl-check-error)))))
  
  
  (method (preprocess-render self)
    (allege render-target
      (activate render-target)))
  
  
  (method (postprocess-render self)
    ;; Copy the color buffer from the render target onto the native color buffer (0)
    (allege render-target
      (blit render-target 0)
      (deactivate render-target)))
  
  
  (definition selection-dyes
    (list red-dye)
    @wait
    (list red-dye (dye .890 .043 .937 1.) blue-dye))
  
  
  (method (render-world self)
    (site (render-world on?: #t parent: render)
      (let ((zone (current-zone))
            (me (current-me+))
            (history (current-history)))
        (draw-zone zone)
        (when (and grid? (get-draw-grid? zone))
          (draw-grid))
        (when axes?
          (draw-axes self))
        (when (and aim? free-aim?)
          (draw-aim self))
        (when (get-paused? history)
          (site (draw-history on?: #f parent: render-world)
            (draw-history self)))
        (let ((skybox (get-skybox zone)))
          (when skybox
            (draw-skybox skybox)))
        (site (draw-renderers on?: #f parent: render-world)
          (render-opaque)
          (render-transparent)
          (render-orb))
        ;; draw player last
        (when (and me (show-me? zone))
          (reset-renderers)
          ;; aec quicky
          (let ((renderer (and (< (dye-alpha (get-overlay me)) 1.) (get-culled-transparent-renderer))))
            (register-entity me #f renderer))
          (render-opaque)
          (render-transparent)
          (render-orb))
        (when (and target-widget (not-null? selection) (target-moveable? (cast <Element> (car selection))))
          (draw-widget target-widget))
        ;; useful for debugging
        ;; (draw-bounds me red-dye)
        ;; (draw-collision-bounds me blue-dye)
        (let (iter (scan selection) (dyes selection-dyes))
          (when (not-null? scan)
            (let ((elem <Element> (car scan)))
              (draw-target elem (car dyes))
              (when draw-normals?
                (for-each (lambda (poly)
                            (draw-plane poly red-dye torus-radius: .015))
                          (element-polygons elem)))
              (iter (cdr scan) (if (null? (cdr dyes)) dyes (cdr dyes))))))
        (when (and target-polygon (null? selection))
          (draw-polygon target-polygon red-dye)
          (when target-vertex
            (draw-polygon-vertex target-polygon target-vertex purple-dye))
          (when draw-normals?
            (draw-plane target-polygon red-dye torus-radius: .015)))
        (when (get-debug-areas? zone)
          (draw-debug-areas zone))
        (when (get-debug-sectors? zone)
          (draw-debug-sectors zone))
        (when (get-debug-sections? zone)
          (draw-debug-sections zone))
        (when orientation?
          (draw-orientation (current-camera)))
        (when (and showcase interface?)
          (draw-showcase showcase))
        (gl-check-error))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (draw-axes self)
    ;; X
    (render-line (vertex -10.0   0.0   0.0) (vertex 10.0  0.0  0.0) .05 red-dye)
    (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0  0.5) .05 red-dye)
    (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0 -0.5) .05 red-dye)
    
    ;; Y
    (render-line (vertex   0.0 -10.0   0.0) (vertex  0.0 10.0  0.0) .05 green-dye)
    (render-line (vertex   0.0  10.0   0.0) (vertex  0.5  9.5  0.0) .05 green-dye)
    (render-line (vertex   0.0  10.0   0.0) (vertex -0.5  9.5  0.0) .05 green-dye)
    
    ;; Z
    (render-line (vertex   0.0   0.0 -10.0) (vertex  0.0  0.0 10.0) .05 blue-dye)
    (render-line (vertex   0.0   0.0  10.0) (vertex  0.5  0.0  9.5) .05 blue-dye)
    (render-line (vertex   0.0   0.0  10.0) (vertex -0.5  0.0  9.5) .05 blue-dye)
    
    (when axes-graduation?
      (let ((grad .15))
        ;; X
        (loop (for x <fl> from -9. to 9. by 1.)
              (render-line (vertex x (- grad) 0.0) (vertex x grad 0.0) .01 red-dye))
        
        ;; Y
        (loop (for y <fl> from -9. to 9. by 1.)
              (render-line (vertex (- grad) y 0.0) (vertex grad y 0.0) .01 green-dye))
        
        ;; Z
        (loop (for z <fl> from -9. to 9. by 1.)
              (render-line (vertex 0.0 (- grad) z) (vertex 0.0 grad z) .01 blue-dye)))))
  
  
  (method (draw-history self)
    (let ((history (current-history)))
      (define (draw-now metadata)
        (bind (entity model meshes matrix) metadata
          (when (history-draw-now? entity)
            (register-ghost entity model meshes matrix 0))))
        
      (define (draw-metadata metadata)
        (bind (entity model meshes matrix) metadata
          (when (history-draw-trail? entity)
            (register-ghost entity model meshes matrix 1))))
      
      (define (draw-trail from to)
        (let (iter (n from) (count 0))
          (when (and (<= n to) (< count history-trail))
            (let ((metadata (historical-metadata history n)))
              (if (not metadata)
                  (iter (+ n 1) count)
                (draw-metadata metadata)
                (iter (+ n 1) (+ count 1)))))))
      
      (unless simulate-protocol?
        (let ((now (get-now history))
              (first (history-first history))
              (last (history-last history)))
          (draw-trail first (- now 1))
          (draw-trail (+ now 1) last)
          (unless (= (get-count history) 0)
            (let ((now-metadata (historical-metadata history now)))
              (when now-metadata
                (draw-now now-metadata))))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method package (refresh-interface self (condition: condition #f))
    (let ((interface (current-interface)))
      (when (or (not condition)
                (some? (lambda (name)
                         (get-visible? (child interface name)))
                       condition))
        (set! interface-refresh? #t)
        (let ((info (child interface 'info)))
          (when (get-visible? info)
            (view-info info)))
        (let ((target (child interface 'target)))
          (when (get-visible? target)
            (view-target target)))
        (let ((profiler (child interface 'profiler)))
          (when (get-visible? profiler)
            (view-sites profiler)))
        (let ((timeline (child interface 'timeline)))
          (when (get-visible? timeline)
            (refresh-timeline))))))
  
  
  (method package (render-interface self)
    (let ((interface (current-interface)))
      (when interface?
        (site (render-interface on?: #t parent: render)
          (when interface-refresh?
            (invalidate-view interface)
            ;; update block at eye information
            (target-update (current-zone) #f #f #f #t)
            (set! interface-last-time (current-seconds))
            (set! interface-refresh? #f))
          ;; removing slots background and drawing them first is
          ;; a quick hack around slots being drawn over everything
          (site (draw-slots on?: #f parent: render-interface)
            (draw-slots))
          (render-sheet interface)
          (when compass-visible?
            (draw-compass))
          (when map-visible?
            (draw-map))
          (when timeline-visible?
            (draw-timeline))
          (when message
            (draw-message self))
          (when status
            (draw-status self))))))
  
  
  (method (explore-interface self)
    (set! explore-interface? (not explore-interface?))
    (when explore-interface?
      (set! interface? #t))
    (set-window-cursor (current-window) (if explore-interface? :spy :arrow)))
  
  
  (method package (update-compass self)
    (let ((interface (current-interface+)))
      (when interface
        (let ((panel (child interface 'compass)))
          (set-uptodate? panel #f)))))
  
  
  (method (propagation-debugger self)
    (let ((interface (current-interface)))
      (let ((frame (find-component interface 'propagation)))
        (if frame
            (close frame)
          (let ((size propagation-size)
                (slot-size propagation-slot-size))
            (open-frame
              (new Propagation-Frame
                name: 'propagation
                size: (new Dimension (+ (* slot-size size) 1) (+ 20 (* slot-size size) 1))
                location: '(center -75))))
          (layout-view interface)))))
  
  
  (method protected virtual (create-main-menu self)
    (let ((menu (new World-Main-Menu visible?: #f)))
      (set-title (child menu 'quit) (format "Quit {a}" tier-title))
      (set-visible? menu #t)
      menu))
  
  
  (method (main-menu self)
    (define (top-close)
      (let ((interface (current-interface)))
        (find-if (lambda (obj)
                   (and (is? obj World-Panel)
                        (get-visible? obj)
                        (escape-close? obj)))
                 (get-children interface)
                 reversed?: #t)))
    
    (let ((window (current-window))
          (zone (current-zone)))
      (when (main-menu? zone)
        (let ((focus (get-window-focus)))
          (if (is? focus World-Pane)
              (leave-pane focus)
            (let ((top (top-close)))
              (if top
                  ;; quicky
                  (if (is? top Script-Panel)
                      (interface-script #f)
                    (close top))
                (let ((menu (create-main-menu self)))
                  (push-panel (open-menu menu))
                  (release-cursor window)
                  ;; quick hack that should be replaced by
                  ;; a complete solution for in-window popups
                  (delay-event
                    (lambda ()
                      (acquire-focus menu))))
                @w
                (set-cursor-mode? #t))))))))
  
  
  (method package (main-menu-destroyed self)
    (let ((window (current-window)))
      (set-cursor-mode? #f)
      (when (effective-autotrack-camera? self)
        (capture-cursor window))))
  
  
  (method (video-options self)
    (push-panel (open-frame (new World-Video-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method (audio-options self)
    (push-panel (open-frame (new World-Audio-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method (interface-options self)
    (push-panel (open-frame (new World-Interface-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method package (view-bindings self)
    (push-panel (open-frame (new World-Bindings-Viewer size: {Dimension 406 588} location: 'center))))
  
  
  (method (view-news self)
    (push-panel (open-world-document (news-file (current-application)) class: World-Formatted-Text-View)))
  
  
  (method (view-roadmap self)
    (push-panel (open-world-document (roadmap-file (current-application)) class: World-Formatted-Text-View)))
  
  
  (method (view-help self)
    (push-panel (open-world-document (help-file (current-application)) class: World-Formatted-Text-View)))
  
  
  (method package (open-about self (name: name #f) (title: title #f) (movable?: movable? #t) (closable?: closable? #t) (closer: closer #f) (background: background #f))
    (let ((zone (current-zone)))
      (push-panel (open-world-document (about-file (current-application)) class: World-Formatted-Text-View name: (or name 'about) title: title movable?: movable? closable?: closable? closer: closer size: (about-size zone) background: background selectable?: #f))))
  
  
  (method package (open-welcome self (exception: exception #f))
    (close-current-top self)
    (set-inhibit-paint? #t)
    (prog1 (open-welcome-zone force-welcome?: #t)
      (when exception
        (report-exception (current-zone) exception #f))
      (set-inhibit-paint? #f)))
  
  
  (method (close-current-top self)
    (let ((top (or (top-frame) (top-menu))))
      (when top
        (close top))))
  
  
  (method package (interface-layout self)
    (let ((interface (current-interface)))
      (define (layout-panel name)
        (let ((panel (find-component interface name)))
          (when panel
            (let ((layouter (get-layouter panel)))
              (layouter panel)))))
      
      (for-each layout-panel '(info profiler target combat character bag belt chest chat command script models blocks))
      (when together?
        (for-each layout-panel '((replay timeline) (replay evolution))))
      (layout-view interface)))
  
  
  (method (enter-press self)
    (if enter-hook
        (enter-hook)
      (command-message self)))
  
  
  (method (tab-press self)
    (when showcase
      (if (shift-down?)
          (previous-category showcase)
        (next-category showcase))))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method package (missile-hit self missile collision)
    (let ((zone (current-zone))
          (poly (get-polygon collision)))
      (let ((element (get-element poly)))
        (cond ((is? element Actor)
               (case (get-kind missile)
                 ((bullet)
                  (let ((inflictor (get-actor missile)))
                    (wound element inflictor (get-power-factor inflictor))))
                 ((arrow)
                  (explode element (get-actor missile))))
               'remove)
              (else
               (case (get-missile-behavior zone)
                 ((absorb)
                  'remove)
                 ((rebound)
                  (let ((normal (get-normal (get-plane collision)))
                        (velocity (get-velocity missile)))
                    (let ((rebound (dot-product& normal velocity)))
                      (set-velocity missile (vertex-& velocity (vertex-scalar*& normal (* 2. rebound))))))
                  'stop)
                 ((slide)
                  'slide)
                 ((destroy)
                  (let ((editable? (zone-editable? zone))
                        (destructible? (zone-destructible? zone)))
                    (define (remove element)
                      (if editable?
                          (editor-remove-element self element)
                        (remove-element self element)))
                    
                    (when (or editable? destructible?)
                      (let ((element (effective-element self poly)))
                        (let ((pos (get-position element)))
                          (case (get-kind missile)
                            ((bullet)
                             (play-3d-sound "sound/combat/explosion" pos)
                             (if (virtual-block? self element)
                                 (delete-block-at (current-universe) pos)
                               (remove element)))
                            ((arrow)
                             @wait
                             (if (virtual-block? element)
                                 (explose-blocks-at (current-universe) pos)
                               (play-3d-sound "sound/spells/ExplosiveShot" pos)
                               (remove element))))))))
                  'remove)))))))
  
  
  (method (change-missile-behavior self (reversed?: reversed? #f))
    (let ((zone (current-zone))
          (next (if reversed? previous-element next-element)))
      (unimplemented-connected self)
      (set-missile-behavior zone (next '(destroy absorb rebound slide) (get-missile-behavior zone)))
      (display-message self (format "{a}" (capitalize (symbol->string (get-missile-behavior zone)))))))
  
  
  ;;;
  ;;;; Zone
  ;;;

  
  (method (zone-new self)
    (unless (welcome? (current-zone))
      (let ((interface (current-interface)))
        (let ((panel (find-type interface Zone-New)))
          (if panel
              (close panel)
            (open-frame (new Zone-New size: {Dimension 366 588} location: 'center)))))))
  
  
  (method (zone-open self)
    (unless (welcome? (current-zone))
      (let ((interface (current-interface)))
        (let ((panel (find-type interface Zone-Open)))
          (if panel
              (close panel)
            (open-frame (new Zone-Open size: {Dimension 366 588} location: 'center)))))))
  
  
  (method protected (zone-reload self)
    (unless (welcome? (current-zone))
      (unimplemented-connected self)
      (let ((zone (current-zone)))
        (reset-profiling self)
        (if (standalone?)
            (open-standalone (find-zone (join (zone-path zone 'standalone) "/") 'standalone))
          (open-local (find-zone (zone-path zone 'local) 'local))))))
  
  
  (method package (zone-regenerate self)
    (unless (welcome? (current-zone))
      (unimplemented-connected self)
      (let ((zone (current-zone)))
        (reset-profiling self)
        (iterate-directory (get-regions-dir zone)
          (lambda (file)
            (when (extension=? (get-extension file) "mca")
              (delete file))))
        (if (standalone?)
            (open-standalone (find-zone (zone-path zone 'standalone) 'standalone))
          (open-local (find-zone (zone-path zone 'local) 'local))))))
  
  
  (method (zone-open-content self)
    (unless (welcome? (current-zone))
      (unimplemented-connected self)
      (let ((interface (current-interface)))
        (let ((panel (find-type interface Tier-Open)))
          (if panel
              (close panel)
            (open-frame (new Tier-Open size: {Dimension 366 588} location: 'center scripts?: #f)))))))
  
  
  (method package (choose-new self title prefix initial-value proc (kind: kind #f) (kind-name: kind-name #f) (exists: exists #f))
    (let ((tier (current-tier)))
      (ask-string
        title: title
        prefix: prefix
        initial-value: initial-value
        action: (lambda (base)
                  (if (not ;; quick hack
                        (if kind
                            (zone-base-available? base kind)
                          (available-zone-base? tier base)))
                      (if exists
                          (exists base proc)
                        (open-message (format "{a} {a} already exists. Do you want to replace it?" (or kind-name "Zone") base)
                                      caption: "Save"
                                      type: 'confirmation
                                      yes: "Yes"
                                      no: "No"
                                      cancel: "Cancel"
                                      execute: (lambda (evt)
                                                 (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                                       (button (get-property evt button:)))
                                                   (close dialog)
                                                   (case button
                                                     ((yes) (proc base))
                                                     ((no))
                                                     ((cancel) (signal-cancel)))))))
                    (proc base))))))
  
  
  ;;;
  ;;;; Role
  ;;;
  
  
  (method public (toggle-user self)
    (setup-role self (if (eq? current-role initial-role)
                    'user
                  initial-role)))
  
  
  (method public (setup-role self new-role)
    (let ((zone (current-zone)))
      (let ((appl (current-application)))
        (uninstall-interface zone)
        (updating-actions appl
          (lambda ()
            (set-current-role new-role)
            (install-bindings appl)
            (install-role appl)))
        (when (eq? new-role 'user)
          (no-showcase self))
        (when (and (neq? new-role 'user)
                   (not non-user-aggroes?))
          (unaggro (current-me)))
        (reset-inventory-blocks)
        (setup-interface self)
        (install-interface zone)
        (update-parameter self 'user)
        (display-message self (capitalize (symbol->string new-role))))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (definition troposphere
    2.)
  
  (definition stratosphere
    3.)
  
  
  (method public (planet-troposphere self)
    troposphere)
  
  (method public (planet-stratosphere self)
    stratosphere)
  
  
  (method public (compute-gravity self position)
    (let ((gravity (make-vertex)))
      (vertex-copy! gravity (compute-gravity& self position))
      gravity))
  
  
  (method public (compute-gravity& self position)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (let ((gravity (vertex-copy& ambient-gravity)))
            (iterate-gravities zone
              (lambda (well)
                (let ((pos (get-position well))
                      (radius (get-radius well)))
                  (let ((direction (vertex-normalize& (vertex-& pos position)))
                        (distance (max radius (vertex-distance pos position))))
                    (let ((well-gravity (vertex-scalar*& direction (well-pull self well distance))))
                      (if (<= distance (+ radius troposphere))
                          (continuation-return return well-gravity)
                        (vertex+! gravity gravity well-gravity)))))))
            gravity)))))
  
  
  (method public (well-pull self well distance)
    (let ((mass (well-mass well)))
      (/ mass (* distance distance))))
  
  
  (method public (well-gravity self well position)
    (let ((pos (get-position well))
          (radius (get-radius well)))
      (let ((direction (vertex-normalize& (vertex-& pos position)))
            (distance (max radius (vertex-distance pos position))))
        (vertex-scalar* direction (well-pull self well distance)))))
  
  
  (method public (surface-pull self well)
    (well-pull self well (get-radius well)))
  
  
  (method public (inside-stratosphere? self well position)
    (let ((pos (get-position well))
          (radius (get-radius well)))
      (let ((distance (max radius (vertex-distance pos position))))
        (<= distance (+ radius stratosphere)))))
  
  
  ;;;
  ;;;; Planet
  ;;;
  
  
  (method public (determine-planet self pos)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (iterate-gravities zone
            (lambda (well)
              (when (and (is? well Planet)
                         (inside-stratosphere? self well pos))
                (continuation-return return well))))
          #f))))
  
  
  ;;;
  ;;;; Vehicle
  ;;;
  
  
  (method package (vehicle-speed self actor)
    (case (vehicle-name actor)
      ((Wheels) 13.)
      ((Hummer) 19.5)
      ((Saucer) 19.5)
      ((Rocket) 65.)
      (else (ground-speed actor))))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot editing?          <bool>   initialize #f     getter generate)
  (slot editor-mode       <object> initialize 'plane getter generate)
  (slot editor-added?     <bool>   initialize #f     getter generate)
  (slot editor-origin     <object> initialize #f     getter generate)
  (slot editor-normal     <object> initialize #f     getter generate)
  (slot editor-direction  <object> initialize #f     getter generate)
  (slot editor-floor?     <bool>   initialize #f     getter generate)
  (slot adding            <object> initialize #f     getter generate)
  (slot adding-properties <object> initialize #f     getter generate)
  (slot adding?           <bool>   initialize #f     getter generate)
  (slot deleting?         <bool>   initialize #f     getter generate)
  (slot removing?         <bool>   initialize #f     getter generate)
  (slot changing?         <bool>   initialize #f     getter generate)
  (slot mouse-run?        <bool>   initialize #f     getter generate)
  (slot widget-down       <object> initialize #f     getter generate)
  (slot widget-part       <object> initialize #f     getter generate)
  (slot grid?             <bool>   initialize #f     accessors generate)
  (slot grid-plane        <symbol> initialize 'y     getter generate)
  (slot grid-position     <fl>     initialize 0.     getter generate)
  
  
  (method (change-editor-mode self (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          (available-modes '(plane column free @comment crazy)))
      (let ((new-mode (next available-modes editor-mode)))
        (set! editor-mode new-mode)
        (display-message self (capitalize (->string new-mode))))))
  
  
  (method (select-target-mode self)
    (set! target-mode 'select)
    (set! target-widget #f)
    (update-target-parameters self)
    (display-message self "Select"))
  
  
  (method (move-target-mode self)
    (if (eq? target-mode 'move)
        (select-target-mode self)
      (set! target-mode 'move)
      (set! target-widget (new Mover))
      (update-target-parameters self)
      (display-message self "Move")))
  
  
  (method (rotate-target-mode self)
    (if (eq? target-mode 'rotate)
        (select-target-mode self)
      (set! target-mode 'rotate)
      (set! target-widget (new Rotater))
      (update-target-parameters self)
      (display-message self "Rotate")))
  
  
  (method (scale-target-mode self)
    (if (eq? target-mode 'scale)
        (select-target-mode self)
      (set! target-mode 'scale)
      (set! target-widget (new Scaler))
      (update-target-parameters self)
      (display-message self "Scale")))
  
  
  (method (skeleton-target-mode self)
    (if (eq? target-mode 'skeleton)
        (select-target-mode self)
      (set! target-mode 'skeleton)
      (set! target-widget (new Skeleton))
      (update-target-parameters self)
      (display-message self "Skeleton")))
  
  
  (method (update-target-parameters self)
    (update-parameter self 'select-target-mode)
    (update-parameter self 'move-target-mode)
    (update-parameter self 'rotate-target-mode)
    (update-parameter self 'scale-target-mode)
    (update-parameter self 'skeleton-target-mode))
  
  
  (method package (find-mesh-program self name)
    (or (table-ref mesh-programs name #f)
        (error "Unknown mesh program: {s}" name)))
  
  
  (method package (collect-textures self)
    (define (add-files dir table)
      (when (exists? dir)
        (add-subdir dir table)
        (iterate-directory dir
          (lambda (subdir)
            (add-subdir subdir table))
          files?: #f
          directories?: #t)))
    
    (define (add-subdir subdir table)
      (define (load-metadata)
        (let ((file (new-file subdir ".metadata")))
          (and (exists? file)
               (let ((metadata (call-with-input-file (path-settings file) read)))
                 (assert (and (pair? metadata)
                              (pair? (cdr metadata))
                              (eq? (cadr metadata) 'textures)))
                 (cddr metadata)))))
      
      (let ((metadata (load-metadata)))
        (define (texture-metadata file)
          (and metadata
               (let ((pair (associate (get-name file) metadata test: filename=?)))
                 (and pair
                      (cdr pair)))))
        
        (iterate-directory subdir
          (lambda (file)
            (when (member? (get-extension file) '("png" "tga") test: extension=?)
              (let ((metadata (texture-metadata file)))
                (table-set! table (get-base file) (cons metadata file)))))
          files?: #t
          directories?: #f
          recursive?: #f)))
    
    (when (not textures)
      (let ((table (make-table test: equal?)))
        (iterate-assets self
          (lambda (assets)
            (add-files (new-directory (get-directory assets) "texture") table)))
        (iterate-assets self
          (lambda (assets)
            (add-files (new-directory (get-directory assets) "tile") table)))
        (set! textures table)))
    textures)
  
  
  (method (reload-textures self)
    (set! textures #f))
  
  
  (method package (find-texture self name)
    (let ((textures (collect-textures self)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((pair? value)
               (bind (metadata . file) value
                 (let ((texture (make-file-texture file metadata: metadata)))
                   (table-set! textures name texture)
                   texture)))
              (else
               value)))))
  
  
  (method (find-texture-metadata self name (error?: error? #t))
    (let ((textures (collect-textures self)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (if error?
                   (error "Unable to find texture: {a}" name)
                 #f))
              ((pair? value)
               (car value))
              (else
               (get-metadata value))))))
  
  
  (method (find-texture-shader self name)
    (let ((metadata (find-texture-metadata self name error?: #f)))
      (and metadata
           (let ((pair (assq 'shader metadata)))
             (and pair
                  (cadr pair))))))
  
  
  (method package (find-texture-file self name)
    (let ((textures (collect-textures self)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((pair? value)
               (cdr value))
              (else
               (get-file value))))))
  
  
  (method (reset-showcases self)
    (register-entity-classes #t)
    (when showcase
      (showcase-deactivate self showcase))
    (set! showcases (make-table test: eq?))
    (set! showcase (and showcase (find-showcase self (showcase-name self showcase))))
    (when showcase
      (showcase-activate self showcase))
    (unspecified))
  
  
  (method (set-showcase self show)
    (set! showcase show))
  
  
  (method package (no-showcase self)
    (when showcase
      (showcase-deactivate self showcase)
      (set! showcase #f)))
  
  
  (method package (goto-showcase self show)
    (let ((actual (showcase-name self showcase)))
      (when showcase
        (showcase-deactivate self showcase))
      (let ((show (if (neq? show actual) (and show (find-showcase self show)) #f)))
        (set! showcase show)
        (when showcase
          (showcase-activate self showcase))
        (update-parameter self 'blocks-showcase)
        (update-parameter self 'models-showcase)
        (update-parameter self 'animations-showcase)
        (update-parameter self 'shaders-showcase)
        (update-parameter self 'tiles-showcase)
        (update-parameter self 'textures-showcase)
        (update-parameter self 'skyboxes-showcase)
        (update-parameter self 'gadgets-showcase)
        (update-parameter self 'meshes-showcase))))
  
  
  (method (showcase-activate self showcase)
    (activate showcase)
    (update-target-panel self)
    (invalidate-belt self)
    (interface-layout self)
    (reset-inventory-blocks))
  
  
  (method (showcase-deactivate self showcase)
    (deactivate showcase)
    (set! self.showcase #f)
    (update-target-panel self)
    (invalidate-belt self)
    (interface-layout self)
    (reset-inventory-blocks))
  
  
  (method package (find-showcase self name)
    (or (table-ref showcases name #f)
        (let ((class (showcase-class self name)))
          (let ((showcase (new class)))
            (table-set! showcases name showcase)
            showcase))))
  
  
  (method (showcase-class self name)
    (case name
      ((tiles) Tiles-Showcase)
      ((textures) Textures-Showcase)
      ((skyboxes) Skyboxes-Showcase)
      ((models) Models-Showcase)
      ((avatars) Avatars-Showcase)
      ((animations) Animations-Showcase)
      ((blocks) Blocks-Showcase)
      ((shaders) Shaders-Showcase)
      ((gadgets) Gadgets-Showcase)
      ((meshes) Meshes-Showcase)))
  
  
  (method package (showcase-name self showcase)
    (typecase showcase
      ((Tiles-Showcase) 'tiles)
      ((Textures-Showcase) 'textures)
      ((Skyboxes-Showcase) 'skyboxes)
      ((Models-Showcase) 'models)
      ((Avatars-Showcase) 'avatars)
      ((Animations-Showcase) 'animations)
      ((Blocks-Showcase) 'blocks)
      ((Shaders-Showcase) 'shaders)
      ((Gadgets-Showcase) 'gadgets)
      ((Meshes-Showcase) 'meshes)
      (else #f)))
  
  
  (method (import-model self)
    (let ((interface (current-interface)))
      (let ((panel (find-type interface Model-Import)))
        (if panel
            (close panel)
          (open-frame (new Model-Import size: {Dimension 366 588} location: 'center))))))
  
  
  (method package (collect-models self)
    (let ((models '()))
      (iterate-assets self
        (lambda (assets)
          (let ((models-dir (new-directory (get-directory assets) "model")))
            (when (exists? models-dir)
              (iterate-directory models-dir
                (lambda (path kind)
                  (let ((dir (new-directory models-dir path)))
                    (let ((idle "_Idle"))
                      (when (or (exists? (new-file dir (add-extension idle "fbx")))
                                (exists? (new-file dir (add-extension idle "w3ds")))
                                (exists? (new-file dir (add-extension idle "ms3d")))
                                (exists? (new-file dir (add-extension idle "obj"))))
                        (set! models (cons (new Asset assets "model" path) models))))))
                full?: #f
                files?: #f
                directories?: #t
                recursive?: #t)))))
      (sort di<? models)))
  
  
  (method package (add-model self path)
    (let ((me (current-me))
          (camera (current-camera)))
      (define (determine-position)
        (let ((pos (if (person-motion?) (vertex-& (get-position me) (vertex 0. (get-radius-y me) 0.)) (vertex-& (get-position camera) (vertex 0. 1. 0.)))))
          (vertex+ pos (vertex-scalar*& (get-sight camera) 2.))))
      
      (place-model self path (determine-position) class: Actor user-origin?: #t)))
  
  
  (method public (place-model self model position (scale: scale #f) (class: class #f) (animate?: animate? #t) (animation: animation #f) (savable?: savable? #t) (user-origin?: user-origin? #f))
    (let ((zone (current-zone)))
      (let ((scale (or scale (world-setting 'world.import-scale 1.))))
        (let ((scale (if (flonum? scale) (vertex scale scale scale) scale)))
          (let ((class (or class (get-entity-class (find-model self model)) Entity))
                (properties (list model: model scale: scale position: position animate?: animate? animation: (or animation "Idle"))))
            (let ((entity (apply new class properties)))
              (add-element zone entity)
              (when savable?
                (with-designer zone entity
                  (lambda (designer container)
                    (add-child designer entity container import: '(world.data) properties: properties))))
              (when user-origin?
                (set-selection self (list entity) user-origin?: #t))
              entity))))))
  
  
  (method public (find-model self path (error?: error? #t))
    (define (search-assets existing-time)
      (continuation-capture
        (lambda (return)
          (iterate-assets self
            (lambda (assets)
              (let ((info (search-in (new-directory (get-directory assets) "model") existing-time)))
                (when info
                  (continuation-return return info)))))
          (if #f @wait (client?)
              (let ((tier (current-tier))
                    (path (string-append "model/" path "/")))
                (let ((content (retrieve-asset tier path)))
                  (if (and content (pair? content))
                      (let ((dir (make-directory (get-assets tier) path)))
                        (create-directories dir)
                        (for-each (lambda (info)
                                    (bind (name . content) info
                                      (save-binary (new-file dir name) (zlib-inflate content))))
                                  content)
                        (let ((ms3d (new-file dir (add-extension "_Idle" "ms3d"))))
                          (values ms3d (import-ms3d ms3d))))
                    (values #f #f))))
            (values #f #f)))))
    
    (define (search-in models-dir existing-time)
      (and (exists? models-dir)
        (let ((dir (new-directory models-dir path)))
          (and (exists? dir)
            (let ((name (get-name dir))
                  (idle "_Idle"))
              (let ((metadata (load-model-metadata name (new-file dir ".model"))))
                (define (maybe-fbx)
                  (let ((fbx (new-file dir (add-extension idle "fbx"))))
                    (and (changed? fbx existing-time)
                      (let ((w3ds (new-file dir (add-extension idle "w3ds"))))
                        (when (or (not (exists? w3ds))
                                  (> (time->seconds (get-last-modification-time fbx))
                                     (time->seconds (get-last-modification-time w3ds))))
                          (let ((path (parse (world-file '("devel" "external" "fbx-conv" "windows" "fbx-conv") (get-settings-alias))))
                                (arguments (list (parse fbx) (parse w3ds))))
                            (call-process (list path: path arguments: arguments show-console: #f))))
                        (values fbx (import-w3ds w3ds metadata: metadata))))))
                
                (define (maybe-w3ds)
                  (let ((w3ds (new-file dir (add-extension idle "w3ds"))))
                    (and (changed? w3ds existing-time)
                      (values w3ds (import-w3ds w3ds metadata: metadata)))))
                
                (define (maybe-ms3d)
                  (let ((ms3d (new-file dir (add-extension idle "ms3d"))))
                    (and (changed? ms3d existing-time)
                      (values ms3d (import-ms3d ms3d metadata: metadata)))))
                
                (define (maybe-obj)
                  (let ((obj (new-file dir (add-extension idle "obj"))))
                    (and (changed? obj existing-time)
                      (let ((png (new-brother obj (add-extension (get-base obj) "png"))))
                        (assert (exists? png)
                          (values obj (import-obj obj (make-file-texture png))))))))
                
                (define (changed? file existing-time)
                  (and (exists? file)
                       (or (not existing-time)
                           (/= (time->seconds (get-last-modification-time file)) existing-time))))
                
                (or (maybe-fbx)
                    (maybe-w3ds)
                    (maybe-ms3d)
                    @obj-format-needs-fixing
                    (maybe-obj))))))))
    
    (if (symbol? path)
        (registered-model path)
      (let ((existing-model (table-ref models path #f)))
        (let ((existing-time (and existing-model (get-path-time existing-model))))
          (bind-values (file model) (search-assets existing-time)
            (if (not model)
                (or existing-model
                    (if error?
                        ;; a try
                        @wait
                        ;; and this is wrong wrong wrong oh so wrong to push dirt
                        ;; under the rug like this. it lead to a very nasty bug to
                        ;; debug: the dwarfmale was not being found on the processor
                        ;; and so it was being replaced by Orb and because the client
                        ;; had the correct model there was no way to know that something
                        ;; was wrong but buggy collision detection behaviors that
                        ;; turned out to be very difficult to debug
                        (find-model self 'Orb)
                        ;; test for a robust approach
                        (if #f @wait (not (equal? path "base/talktomequestiongrey"))
                            (find-model self "base/talktomequestiongrey" error?: #t)
                          (error "Unable to find model: {a}" path))
                      #f))
              (set-file model file)
              (set-path model path)
              (set-path-time model (time->seconds (get-last-modification-time file)))
              (table-set! models path model)
              model))))))
  
  
  (method (verify-reload-models self)
    (let ((zone (current-zone)))
      (let ((entities (get-entities zone))
            (reloaded '()))
        (for-each (lambda (entity)
                    (let ((model (get-model-cache entity)))
                      (when model
                        (let ((file (get-file model))
                              (time (get-path-time model)))
                          (when (and file time (exists? file) (/= (time->seconds (get-last-modification-time file)) time))
                            (clear-model-cache entity)
                            (when (eq? ?e entity)
                              (set-%o (cache-model entity)))
                            (set! reloaded (cons (get-model entity) reloaded)))))))
                  entities)
        (let ((count (length reloaded)))
          (when (> count 0)
            (display-status self (if (= count 1)
                                     (format "Model {a} reloaded" (car reloaded))
                                   (format "{a} models reloaded" count))))))))
  
  
  (method (collect-events self)
    (let ((queue (new-queue)))
      (for-each (lambda (partition)
                  (bind (kind . assets) partition
                    (let ((events '()))
                      (for-each (lambda (assets)
                                  (let ((events-dir (new-directory (get-directory assets) "event")))
                                    (when (exists? events-dir)
                                      (iterate-directory events-dir
                                        (lambda (path kind)
                                          (unless (member? (last path) '(".DS_Store" "README") test: filename=?)
                                            (set! events (cons (new Asset assets "event" path) events))))
                                        full?: #f
                                        files?: #t
                                        directories?: #f
                                        recursive?: #t))))
                                assets)
                      (for-each (lambda (event)
                                  (enqueue queue event))
                                (sort di<? events key: get-path)))))
                  (partition-assets self))
      (queue-list queue)))
  
  
  (method (find-event self path)
    (find (collect-events self) path test: equal? key: get-path return: 'item))
  
  
  (method package (launch-event self path)
    (let ((script (find-event self path)))
      (when script
        ;; quick hack to always reload
        (unregister-asset script)
        (run-asset-script script))))
  
  
  (method (select/run-script self)
    (let ((interface (current-interface)))
      (let ((panel (find-type interface Script-Run)))
        (if panel
            (close panel)
          (open-frame (new Script-Run size: {Dimension 366 588} location: 'center))))))
  
  
  (method (run-last-script self)
    (if (not last-script)
        (select/run-script self)
      (run-script self last-script)))
  
  
  (method package (collect-scripts self)
    (let ((queue (new-queue)))
      (for-each (lambda (partition)
                  (bind (kind . assets) partition
                    (let ((scripts '()))
                      (for-each (lambda (assets)
                                  (let ((scripts-dir (new-directory (get-directory assets) "script")))
                                    (when (exists? scripts-dir)
                                      (iterate-directory scripts-dir
                                        (lambda (path kind)
                                          (unless (member? (last path) '(".DS_Store" "README") test: filename=?)
                                            (set! scripts (cons (new Asset assets "script" path) scripts))))
                                        full?: #f
                                        files?: #t
                                        directories?: #f
                                        recursive?: #t))))
                                assets)
                      (for-each (lambda (script)
                                  (enqueue queue script))
                                (sort di<? scripts key: get-path)))))
                  (partition-assets self))
      (queue-list queue)))
  
  
  (method package (partition-scripts self scripts)
    (partition scripts key: (lambda (asset)
                              (let ((spine (get-spine asset)))
                                (if (> (length spine) 1)
                                    (car spine)
                                  "")))
      test: filename=?))
  
  
  (method package (find-script self path)
    (find (collect-scripts self) path test: equal? key: get-path return: 'item))
  
  
  (method package (run-script self script)
    ;; quick hack to always reload
    (unregister-asset script)
    (run-asset-script script)
    (set! last-script script))
  
  
  (method package (execute-script self path (synchronous?: synchronous? #f))
    (let ((script (find-script self path)))
      (if (not script)
          (display-message self (format "Unable to find script: {a}" path))
        ;; quick hack to always reload
        (unregister-asset script)
        (run-asset-script script synchronous?: synchronous?))))
  
  
  (method (toggle-grid self)
    (set! grid? (not grid?))
    (update-parameter self 'grid))
  
  
  (method (toggle-grid-plane self plane)
    (if (and grid? (eq? grid-plane plane))
        (set! grid? #f)
      (set! grid? #t)
      (set! grid-plane plane))
    (update-parameter self 'grid))
  
  
  (method (decrease-grid self)
    (move-grid-by self -1))
  
  
  (method (increase-grid self)
    (move-grid-by self 1))
  
  
  (cond-expand
    (cocoa
      (method (move-grid self delta)
        (move-grid-by self (fxround/ (- delta) 5))))
    (else
     (method (move-grid self delta)
       (move-grid-by self (fxround/ (- delta) 120)))))
  
  
  (method (move-grid-by self incr)
    (let ((dist incr))
     (increase! grid-position dist)
     (display-status self (format "Grid at {a}" grid-position))))
  
  
  (method (effective-element self poly)
    (let ((zone (current-zone)))
      (or (get-element poly)
          (bind-values (id variant-id) (decode-id/variant-id (get-data1 poly))
            (let ((block (id/variant-id->block id variant-id)))
              (create-block-entity zone (get-name block) (polygon-position poly)))))))
  
  
  (method (virtual-block? self elem)
    (and (is? elem Block-Entity)
         (not (get-parent elem))))
  
  
  (method protected virtual (floor-level self)
    (and grid? (eq? grid-plane 'y) grid-position))
    
  
  ;; editor-mouse-down
  ;; editor-mouse-move
  ;; editor-mouse-up
  ;; - editor-add / action 'add
  ;;   - editor-add-at
  ;;     - editor-add-element
  ;;       - add-element-class
  ;; - editor-remove
  ;; - editor-change

  
  (method (editor-add self mode class grid? grid-plane grid-position position direction stage)
    (let ((zone (current-zone)))
      (case stage
        ((down move)
         (editor-add-at self mode class grid? grid-plane grid-position position direction))
        ((up)
         (editor-up self)))))
  
  
  (method (editor-add-at self mode class grid? grid-plane grid-position position direction)
    (let ((zone (current-zone))
          (me (current-me+)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-direction) 0.) vertex-x)
                                ((/= (vertex-y editor-direction) 0.) vertex-y)
                                ((/= (vertex-z editor-direction) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& center editor-origin)) editor-normal))))))
        
        (define (free-filter poly)
          (let ((normal (get-normal poly)))
            (vertex=? normal editor-normal)))
        
        (and editor-added?
             (case mode
               ((plane) (plane-filter))
               ((column) column-filter)
               ((free) free-filter)
               ((crazy) #f))))
      
      (define (add-at origin normal poly)
        (define (collision-quad origin normal)
          (let ((inside (vertex+ origin (vertex-scalar* normal -.01))))
            (let ((cube (unit-cube inside)))
              (ray-closest-cuboid-inner-quad inside normal cube))))
        
        (define (determine-anchor element origin normal)
          (let ((bounds (transformed-bounds element)))
            (let ((radiuses (cuboid-radiuses bounds)))
              (cond ((float-near? (vertex-y normal) 1.)
                     origin)
                    ((float-near? (vertex-y normal) -1.)
                     (vertex- origin (vertex 0. (cuboid-height bounds) 0.)))
                    (else
                     (vertex+ (vertex- origin (vertex 0. .5 0.))
                              (vertex-scalar* normal (if (/= (vertex-x normal) 0.)
                                                         (vertex-x radiuses)
                                                       (vertex-z radiuses)))))))))
        
        (define (determine-anchor/position element origin normal)
          (if (is? class Block-Entity)
              (values origin origin)
            (let ((anchor (determine-anchor element origin normal)))
              (let ((position (anchor->position element anchor)))
                (values anchor position)))))
        
        (define (determine-polygon)
          (if (and (is? class Block-Entity) (not poly))
              (let ((closest (collision-quad origin normal)))
                (and closest
                     (bind (quad dist) closest
                       (let ((origin (get-origin quad))
                             (normal (vertex-scalar* (get-normal quad) -1.)))
                         (values (vertex+ origin (vertex-scalar*& normal .5)) normal)))))
            (values origin normal)))
        
        (let ((info (determine-polygon)))
          (when info
            (bind-values (origin normal) info
              (when (or (not editor-added?) (vertex=? normal editor-direction))
                (let ((player? (eq? class 'player)))
                  (unless player?
                    (instantiate-element-class self class))
                  (let ((element (if player? me adding)))
                    (when player?
                      (trek-change element))
                    (bind-values (anchor position) (determine-anchor/position element origin normal)
                      (let ((actual (if (is? class Block-Entity)
                                        (or (not (id? (block-at zone position) Air Water StationaryWater Lava StationaryLava))
                                            (element-near zone position))
                                      (element-near zone position))))
                        (unless actual
                          (if player?
                              (begin
                                (set-position me position)
                                (unless (person-motion?)
                                  (set-lookat me (get-lookat (current-camera))))
                                (follow-player self)
                                (unless (person-motion?)
                                  (person-motion self feedback?: #f))
                                #f)
                            (let ((added (editor-add-element self mode class poly anchor)))
                              (if editor-added?
                                  (add-target self added)
                                (set! editor-added? #t)
                                (set! editor-origin (if poly (get-center poly) origin))
                                (set! editor-normal (if poly (get-normal poly) normal))
                                (set! editor-direction normal)
                                (set! editor-floor? (not poly))
                                (set-selection self (list added))) 
                              added))))))))))))
      
      (let ((filter (determine-filter)))
        (let ((poly-closest (ray-closest-polygon position direction view-radius filter: filter ignore-non-physical?: #f ignore-players?: #t water-filter: (if (and (is? class Block-Entity) (eq? (get-model class) 'LilyPad)) only-water-filter liquid-filter)))
              (grid-closest (and (or (not editor-added?) (memq? mode '(free crazy)) (and editor-floor? (neq? mode 'column)))
                                 (bind-values (vert normal) (ray-grid-intersection self position direction grid? grid-plane grid-position)
                                   (and vert
                                        (cons vert normal))))))
          (let ((poly-distance (and poly-closest (second poly-closest)))
                (grid-distance (and grid-closest (vertex-distance position (car grid-closest)))))
            (if (and poly-closest (or (not grid-closest) (<= poly-distance grid-distance)))
                (bind (poly distance) poly-closest
                  (if (is? class Block-Entity)
                      (with-polygon-interaction (current-universe) poly
                        (lambda (poly block fore)
                          (add-at fore (get-normal poly) poly)))
                    (let ((element (get-element poly))
                          (normal (get-normal poly)))
                      (let ((target (vertex+ position (vertex-scalar* direction view-radius)))
                            (lookat (get-lookat (current-camera)))
                            (radiuses (vertex .001 .001 .001)))
                        (bind-values (new-position new-direction collisions) (collide&stop$ position target lookat radiuses max-distance: view-radius polygon-filter: filter ignore-entities?: #t ignore-players?: #t)
                          (when (not-null? collisions)
                            (let ((coll (car collisions)))
                              (let ((plane (get-plane coll)))
                                (add-at (get-origin plane) (get-normal plane) poly)))
                            (free-collisions$ collisions)))))))
              (when grid-closest
                (bind (vert . normal) grid-closest
                  (let ((normal (if (and (is? class Block-Entity)
                                         (get-flat? (cache-model class)))
                                    (vertex-negate normal)
                                  normal)))
                    (add-at vert normal #f))))))))))
  
  
  (method (editor-add-element self mode class poly anchor)
    (let ((zone (current-zone))
          (universe (current-universe)))
      (if (is? class Block-Entity)
          (let ((pos anchor)
                (block (name->block (get-name (cache-model class)))))
            (add-block-at universe poly pos block)
            (create-block-entity zone (get-name block) pos))
        (let ((element adding)
              (name #f)
              (position (anchor->position adding anchor))
              (lookat (make-standard-lookat))
              (scale (get-scale adding))
              (properties adding-properties))
          (add-element universe #f element name position lookat scale #f #f properties)
          (update-future self)
          (set! adding #f)
          (set! adding-properties #f)
          element))))
  
  
  (method (instantiate-element-class self class)
    (define (instantiate class/new (properties '()))
      (let ((elem (if (procedure? class/new) (class/new) (apply new class/new properties))))
        (set! adding elem)
        (set! adding-properties properties)))
    
    (define (instantiate-block block)
      (set! adding (new Block-Entity model: (get-name (cache-model block))))
      (set! adding-properties #f))
    
    (define (instantiate-entity entity)
      (let ((model (cache-model entity)))
        (let ((class (or (get-entity-class model) (class-of entity))))
          (let ((properties (registered-gadget class)))
            (if properties
                (let ((properties (properties)))
                  (instantiate (lambda ()
                                 (new class))
                               properties))
              (let ((model (or (get-model entity) (and model (get-name model))))
                    (meshes-mask (get-meshes-mask entity))
                    (animation (get-animation entity))
                    (animate? (get-animate? entity))
                    (queue (new-queue)))
                (define (enqueue-if property value (default #f))
                  (when (neq? value default)
                    (enqueue queue property)
                    (enqueue queue value)))
                
                (enqueue-if model: model)
                (enqueue-if meshes-mask: meshes-mask)
                (enqueue-if animation: animation)
                (enqueue-if animate?: animate?)
                (instantiate (lambda ()
                               (new class model: model))
                             (queue-list queue))))))))
    
    (when (not adding)
      (typecase class
        ((Block-Entity)
         (instantiate-block class))
        ((Entity)
         (instantiate-entity class))
        (else
         (case class
           ((block) (instantiate Block-Entity)))))))
  
  
  (method (editor-remove self mode position direction stage)
    (let ((zone (current-zone)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-normal) 0.) vertex-x)
                                ((/= (vertex-y editor-normal) 0.) vertex-y)
                                ((/= (vertex-z editor-normal) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& editor-origin center)) editor-normal))))))
        
        (case mode
          ((plane) (plane-filter))
          ((column) column-filter)
          ((free) #f)))
      
      (case stage
        ((down)
         (let ((closest (ray-closest-polygon position direction view-radius ignore-non-physical?: #f ignore-players?: #t)))
           (when closest
             (bind (poly distance) closest
               (let ((element (effective-element self poly)))
                 (when element
                   (let ((center (get-center poly))
                         (normal (get-normal poly)))
                     (editor-remove-element self element)
                     (set! editor-origin center)
                     (set! editor-normal normal))))))))
        ((move)
         (when editor-origin
           (let ((closest (ray-closest-polygon position direction view-radius filter: (determine-filter) ignore-non-physical?: #f ignore-players?: #t)))
             (when closest
               (bind (poly distance) closest
                 (let ((element (effective-element self poly)))
                   (when element
                     (editor-remove-element self element))))))))
        ((up)
         (set! editing? #f)
         (set! removing? #f)
         (set! editor-added? #f)
         (set! editor-origin #f)
         (set! editor-normal #f)
         (set! editor-direction #f)))))
  
  
  (method (editor-delete self position)
    (let ((zone (current-zone)))
      (if (zone-editable? zone)
          (let ((element #f @convert^^^ (element-at zone position)))
            (when element
              (editor-remove-element self element)
              (set-modified? zone #t)))
        (warn-non-editable self))))
  
  
  (method (editor-remove-element self elem)
    (let ((universe (current-universe)))
      (if (virtual-block? self elem)
          (delete-block-at universe (get-position elem))
        (remove-element universe #f elem))
      (update-future self)))
  
  
  (method package (remove-element self elem)
    (let ((zone (current-zone)))
      (remove-element zone elem)
      (when (memq? elem selection)
        (remove-target self elem))))
  
  
  (method (delete-target self)
    (let ((zone (current-zone))
          (history (current-history)))
      (define (delete)
        (for-each (lambda (elem)
                    (unless (is? elem Player)
                      (cond ((get-paused? history)
                             (editor-delete self (get-position elem)))
                            (else
                             ;; quicky copy-pasted from editor-delete
                             (editor-remove-element self elem)
                             (set-modified? zone #t)))))
                  selection))
      
      (if (null? selection)
          (bell)
        (if (some? get-script selection)
            (push-panel
              (open-message (if (= 1 (length selection))
                                "Entity has a script. Delete anyways?"
                              "Some entities have scripts. Delete anyways?")
                            caption: "Delete"
                            type: 'question
                            yes: "Yes"
                            no: "No"
                            execute: (lambda (evt)
                                       (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                             (button (get-property evt button:)))
                                         (close dialog)
                                         (case button
                                           ((yes)
                                            (delete)))))))
          
          (delete)))))
  
  
  (method (editor-change self position direction  stage)
    (case stage
      ((down move)
       (let ((closest (ray-closest-polygon position direction view-radius ignore-non-physical?: #f ignore-players?: #t)))
         (when closest
           (bind (poly distance) closest
             (let ((element (effective-element self poly))
                   (class (editor-element-class self)))
               (when class
                 (change-class self element class)))))))
      ((up)
       (set! editing? #f)
       (set! changing? #f))))
  
  
  (method (change-class self element class)
    (let ((zone (current-zone))
          (universe (current-universe)))
      (let ((anchor (position->anchor element (get-position element))))
        (if (virtual-block? self element)
            (let ((pos (get-position element))
                  (block (name->block (get-name (cache-model class)))))
              (let ((id (get-id block)))
                (unless (if (get-generic? (id->block id))
                            (equal? (block/data-at zone pos) (cons id (get-variant-id block)))
                          (= (block-at zone pos) id))
                  (updating-sections zone
                    (lambda (add-section)
                      (delete-block-at-updating universe pos add-section)
                      (add-block-at-updating universe #f pos block add-section))))))
          (editor-remove-element self element)
          (instantiate-element-class self class)
          (editor-add-element self editor-mode class #f anchor)))))
  
  
  (method (editor-add-class self)
    (if (shift-down?)
        'player
      (editor-element-class self)))
  
  
  (method (editor-element-class self)
    (let ((interface (current-interface)))
      (if showcase
          (and (selection-addable? showcase)
               (get-selection showcase))
        (let ((slot (selected-slot (child interface 'belt))))
          (let ((id (get-id slot)))
            (and id (block-id? id)
              (new Block-Entity model: (get-name (id/durability->block id (get-durability slot))))))))))
  
  
  (method (mouse-change self h v)
    (let ((zone (current-zone)))
      (if (zone-editable? zone)
          (unless (user?)
            (bind-values (position direction) (screen->world (current-camera) h v)
              (editor-change self position direction 'down)
              (set! editing? #t)
              (set! changing? #t)))
        (warn-non-editable self))))
  
  
  (method (mouse-add self h v)
    (let ((zone (current-zone))
          (camera (current-camera))
          (history (current-history)))
      (let ((player? (shift-down?)))
        (if (or (zone-editable? zone)
                player?)
            (unless (or (user?) (and (creator?) player?))
              (bind-values (position direction) (screen->world camera h v)
                (let ((class (editor-add-class self)))
                  (when class
                    (editor-add self editor-mode class grid? grid-plane grid-position position direction 'down)
                    (set! editing? #t)))))
          (warn-non-editable self)))))
  
  
  (method (mouse-remove self h v)
    (let ((zone (current-zone)))
      (if (zone-editable? zone)
          (unless (user?)
            (bind-values (position direction) (screen->world (current-camera) h v)
              (editor-remove self editor-mode position direction 'down)
              (set! editing? #t)
              (set! removing? #t)))
        (warn-non-editable self))))
  
  
  (method (editor-mouse-down self h v)
    (let ((control? (control-down?))
          (alt? (alt-down?))
          (shift? (shift-down?)))
      (cond ((and control? alt? (not shift?))
             (mouse-change self h v))
            (control?
             (mouse-add self h v))
            (alt?
             (mouse-remove self h v))
            (else
             (when target-widget
               (bind-values (position direction) (screen->world (current-camera) h v)
                 (let ((closest (ray-closest-widget position direction target-widget)))
                   (when closest
                     (bind (poly distance) closest
                       (bind (widget . part) (get-element poly)
                         (set! widget-down widget)
                         (set! widget-part part)
                         (widget-mouse-down widget-down h v)))))))))))
  
  
  (method (editor-mouse-move self h v)
    (let ((history (current-history)))
      (when editing?
        (cond (removing?
               (bind-values (position direction) (screen->world (current-camera) h v)
                 (editor-remove self editor-mode position direction 'move)))
              (changing?
               (bind-values (position direction) (screen->world (current-camera) h v)
                 (editor-change self position direction 'move)))
              (else
               (let ((player? (shift-down?)))
                 (unless player?
                   (bind-values (position direction) (screen->world (current-camera) h v)
                     (let ((class (editor-add-class self)))
                       (when class
                         (editor-add self editor-mode class grid? grid-plane grid-position position direction 'move)))))))))))
  
  
  (method (editor-mouse-up self h v)
    (let ((zone (current-zone))
          (history (current-history))
          (universe (current-universe)))
      (bind-values (position direction) (screen->world (current-camera) (get-h down-point) (get-v down-point))
        (if editing?
            (when (zone-editable? zone)
              (cond (removing?
                     (editor-remove self editor-mode position direction 'up))
                    (changing?
                     (editor-change self position direction 'up))
                    (else
                     (let ((class (editor-add-class self)))
                       (when class
                         (editor-add self editor-mode class grid? grid-plane grid-position position direction 'up))))))
          (let ((origin (get-position (current-camera))))
            (let ((closest (ray-closest-polygon origin direction view-radius ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #f ignore-me?: #t)))
              (if (not closest)
                  (begin
                    (reset-selection self user-origin?: #t)
                    (focus-world))
                (bind (poly distance) closest
                  (let ((element (effective-element self poly))
                        (vertex (ray/distance-closest-vertex poly origin direction distance))
                        (shift? (shift-down?)))
                    (define (select)
                      (let ((selection-sound? (is-not? element Block-Entity)))
                        (if shift?
                            (if (member? element selection test: (~ target=? self))
                                (remove-target self element user-origin?: #t)
                              (add-target self element polygon: poly vertex: vertex user-origin?: #t))
                          (set-selection self (list element) polygon: poly vertex: vertex selection-sound?: selection-sound? user-origin?: #t))))
                    
                    (if (not shift?)
                        (unless (mouse-up universe h v)
                          (if double-click?
                              (double-click universe h v)
                            (select)))
                      (select)))))))))
      (editor-up self)))
  
  
  (method (editor-up self)
    (set! editing? #f)
    (set! adding? #f)
    (set! deleting? #f)
    (set! removing? #f)
    (set! changing? #f)
    (set! editor-added? #f)
    (set! editor-origin #f)
    (set! editor-normal #f)
    (set! editor-direction #f)
    (set! editor-floor? #f)
    (set! adding #f)
    (set! adding-properties #f))
  
  
  (method protected virtual (warn-non-editable self)
    (let ((zone (current-zone)))
      (unless (or (get-editable-warned? zone) (admin?))
        (set-editable-warned? zone #t)
        (open-message "Zone is not editable"
                      caption: "Edition"
                      type: 'message
                      execute: (lambda (evt)
                                 (let ((dialog (find-ascendant (get-sender evt) World-Dialog)))
                                   (close dialog)))))))
  
  
  ;;;
  ;;;; Change
  ;;;
  
  
  ;; quick hack
  (method package (class->class-name self class)
    (category-name class))
  
  
  ;; quick hack
  (method package (class-name->class self class-name)
    (case class-name
      ((Sphere) Sphere)
      ((Spawner) Spawner)
      ((Wolf) Wolf)
      ((Spider) Spider)
      ((Jumper) Jumper)
      ((Creature) Creature)
      ((Missile) Missile)
      ((Actor) Actor)
      (else Entity)))
  
  
  ;;;
  ;;;; Grid
  ;;;
  
  
  (method package (ray-grid-intersection self position direction grid? grid-plane grid-position)
    (let ((zone (current-zone)))
      (define (perspective->world normal distance)
        (let ((norm-direction-dot-product (dot-product normal direction)))
          (and (not (and (= norm-direction-dot-product 0.)
                         (case grid-plane
                           ((x) (= (vertex-x position) grid-position))
                           ((y) (= (vertex-y position) grid-position))
                           ((z) (= (vertex-z position) grid-position)))))
               (let ((intersect (/ (- distance (dot-product normal position))
                                   norm-direction-dot-product)))
                 (and (> intersect 0.)
                      (let ((point (vertex+ position (vertex-scalar*& direction intersect))))
                        (if (> norm-direction-dot-product 0.)
                            (values point grid-position (vertex-negate normal))
                          (values point grid-position normal))))))))
      
      (if (not grid?)
          (values #f #f)
        (case grid-plane
          ((x) (let ((info (perspective->world (vertex 1. 0. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         pos
                                         (vertex-y vert)
                                         (vertex-z vert)))
                             normal)))))
          ((y) (let ((info (perspective->world (vertex 0. 1. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         pos
                                         (vertex-z vert)))
                             normal)))))
          ((z) (let ((info (perspective->world (vertex 0. 0. 1.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         (vertex-y vert)
                                         pos))
                             normal)))))))))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-future? initialize #t getter generate)
  
  
  (method (toggle-paused self)
    (let ((tier (current-tier))
          (history (current-history)))
      (if (get-paused? history)
          (unpause-processor tier)
        (pause-processor tier))))
  
  
  (method package (pause-world self)
    (let ((interface (current-interface+))
          (history (current-history)))
      (unless (get-paused? history)
        (pause history)
        (when (window?)
          (camera-copy! history-camera eye)
          (set-current-camera history-camera)
          (set-current-motion history-motion)
          (update-camera-parameters self)
          (unadvise-sites)
          (set-visible? (child interface 'slider) #t)
          (update-parameter self 'paused)))))
  
  
  (method package (unpause-world self)
    (let ((interface (current-interface+))
          (history (current-history)))
      (when (get-paused? history)
        @port-to-multiplayer
        (truncate-history self)
        (when (window?)
          (camera-copy! eye history-camera)
          (set-current-camera eye)
          (set-current-motion eye-motion))
        (unpause history)
        (when (window?)
          (eye-behind-player self)
          (follow-player self)
          (advise-sites)
          (set-visible? (child interface 'slider) #f)
          (update-parameter self 'paused)))))
  
  
  (method package (snapshot-metadata self entity)
    (and (snapshot-metadata? entity)
         (list entity (cache-model entity) (entity-meshes entity) (copy-matrix (get-matrix entity)))))
  
  
  (method package (first-target self)
    (and (not-null? selection) (first selection)))
  
  
  (method package (set-selection self sel (polygon: polygon #f) (vertex: vertex #f) (selection-sound?: selection-sound? #t) (selection-sound: selection-sound #f) (user-origin?: user-origin? #f))
    (when (window?)
      (let ((interface (current-interface))
            (zone (current-zone)))
        (when (not-null? selection)
          (deactivate-target (first selection)))
        (when (and user-origin? selection-sound? selection-sounds? (not (selection=? self sel selection)))
          (play-interface-sound (or selection-sound (if (not-null? sel) "sound/user/selectTarget" "sound/user/deselectTarget"))))
        (set! selection sel)
        (set! target-polygon polygon)
        (set! target-vertex vertex)
        (target-updated selection polygon vertex)
        (target-update zone selection polygon vertex)
        (invalidate-view interface)
        (reset-edited-entity)
        (update-color-panel self)
        (update-target-panel self)
        (unless together?
          (update-script-panel))
        (when (not-null? selection)
          (activate-target (first selection)))
        (refresh-interface self condition: '(info target)))))
  
  
  (method package (reset-selection self (user-origin?: user-origin? #f))
    (set-selection self '() user-origin?: user-origin?))
  
  
  (method package (shutdown-selection self)
    (set! selection '())
    (set! target-polygon #f)
    (set! target-vertex #f)
    (set! target-mode #f)
    (set! target-widget #f))
  
  
  (method (selection=? self sx sy)
    (and (= (length sx) (length sy))
         (every? (~ target=? self)
                 sx
                 sy)))
  
  
  (method (target=? self x y)
    (if (and (is? x Block-Entity)
             (is? y Block-Entity))
        (vertex=? (get-position x) (get-position y))
      (equal? x y)))
  
  
  (method (add-target self elem (polygon: polygon #f) (vertex: vertex #f) (user-origin?: user-origin? #f))
    (set-selection self (append! selection (list elem)) polygon: polygon vertex: vertex user-origin?: user-origin?))
  
  
  (method (remove-target self elem (user-origin?: user-origin? #f))
    (set-selection self (remove elem selection test: (~ target=? self)) selection-sound: "sound/user/deselectTarget" user-origin?: user-origin?))
  
  
  (method package (x-rays-mode? self)
    (and x-rays? (not x-rays-category)))
  
  
  (method (toggle-x-rays self)
    (cond ((x-rays-mode? self)
           (set! x-rays? #f)
           (set! x-rays-category #f))
          (else
           (set! x-rays? #t)
           (set! x-rays-category #f)))
    (update-parameter self 'x-rays)
    (display-on/off self "X-rays" x-rays?))
  
  
  (method package (redstone-x-rays-mode? self)
    (and x-rays? (eq? x-rays-category 'redstone)))
  
  
  (method (toggle-redstone-x-rays self)
    (cond ((redstone-x-rays-mode? self)
           (set! x-rays? #f)
           (set! x-rays-category #f))
          (else
           (set! x-rays? #t)
           (set! x-rays-category 'redstone)))
    (update-parameter self 'redstone-x-rays)
    (display-on/off self "Redstone X-rays" x-rays?))
  
  
  (method (toggle-draw-blocks self)
    (set! draw-blocks? (not draw-blocks?))
    (update-parameter self 'blocks)
    (display-on/off self "Draw blocks" draw-blocks?))
  
  
  (method (toggle-draw-models self)
    (set! draw-entities? (not draw-entities?))
    ;(update-parameter 'models)
    (display-on/off self "Draw models" draw-entities?))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (slot evaluate-hooks <object> initialize '() getter generate)
  
  
  (method (register-evaluate-hook self proc)
    (set! evaluate-hooks (cons proc evaluate-hooks)))
  
  
  (method (unregister-evaluate-hook self proc)
    (set! evaluate-hooks (remove! proc evaluate-hooks)))
  
  
  (method package (evaluate-world-hook self forms syntax str container line col)
    (let ((interface (current-interface))
          (zone (current-zone)))
      (evaluate-zone-hook zone forms syntax str container line col)
      (when (or (search container "shaders")
                (search str "baked-light"))
        (reload-programs self str))
      @test
      (when (search container "procedural")
        (increase-revision (get-generator zone))
        (reset-selection))
      (when evaluate-future?
        (update-future self))
      (for-each (lambda (proc)
                  (proc forms syntax str container line col))
                evaluate-hooks)
      @test
      (update-world-options (current-application))
      @test
      (install-skins (current-application))
      @test
      (install-bindings (current-application))
      (invalidate-view interface)
      (when (developer?)
        (set-uptodate? (child interface 'timeline) #f))
      (reset-profiling self)
      (render-scene (current-window))))
  
  
  (method (reload-programs self str)
    (cond ((search str "phong")
           (reload-phong-programs self))
          ((or (search str "terrain")
               (search str "baked-light"))
           (reload-terrain-programs self))
          ((search str "frame")
           (reload-frame-programs self))
          (else
           (reload-transformation-programs self)
           (reload-other-programs self))))
  
  
  (method (reload-terrain-programs self)
    (build-terrain-shaders)
    (relink-program self 'terrain)
    (relink-program self 'wet-terrain))
  
  
  (method (reload-phong-programs self)
    (build-phong-shaders)
    (relink-program self 'phong))
  
  
  (method (reload-frame-programs self)
    (build-frame-shaders)
    (relink-program self 'wireframe)
    (relink-program self 'squareframe)
    (relink-program self 'playerframe)
    (relink-program self 'floorframe))
  
  
  (method (reload-transformation-programs self)
    (build-transformation-shaders)
    (relink-program self 'radial-blur)
    (relink-program self 'motion-blur)
    (relink-program self 'water)
    (relink-program self 'julia)
    (relink-program self 'sierpinski)
    (relink-program self 'multitexture)
    (relink-program self 'kaleidoscope)
    (relink-program self 'tunnel)
    (relink-program self 'square-tunnel)
    (relink-program self 'fly)
    (relink-program self 'pulse))
  
  
  (method (reload-other-programs self)
    (build-occlusion-shaders)
    (relink-program self 'occlusion))
  
  
  (method (relink-program self name)
    (let ((program (find-mesh-program self name)))
      (relink program)))
  
  
  ;;;
  ;;;; GC
  ;;;
  
  
  (definition memory-site
    (register-site '(memory) '() '(kind: memory)))
  
  
  (method (setup-gc self)
    (proclaim (not check bounds))
    (add-gc-interrupt-job!
      (lambda ()
        (when gc-sound?
          (gc-sound))
        (when gc-trace?
          (terminal 'garbage-collect))
        ;; simulate call
        (let ((chronology (current-chronology)))
          (define (add-entries)
            (let ((running (last-gc-real-time))
                  (profile (get-profile memory-site))
                  (content (get-content chronology))
                  (id <fx> (get-id memory-site))
                  (marker (next-marker! chronology))
                  (seconds (current-seconds)))
              ;; start
              (let ((index (index-now chronology)))
                (f64vector-set! content index (cast <fl> id))
                (f64vector-set! content (+ index 1) (cast <fl> marker))
                (f64vector-set! content (+ index 2) (- seconds running))
                (f64vector-set! content (+ index 3) 0.)
                (advance! chronology))
              ;; end
              (let ((index (index-now chronology)))
                (f64vector-set! content index (cast <fl> id))
                (f64vector-set! content (+ index 1) (cast <fl> (+ marker 1)))
                (f64vector-set! content (+ index 2) seconds)
                (f64vector-set! content (+ index 3) 0.)
                (advance! chronology))))
          
          (let ((mutex (get-mutex chronology)))
            (if (eq? (mutex-state mutex) (current-thread))
                (add-entries)
              (mutex-lock! mutex)
              (add-entries)
              (mutex-unlock! mutex)))))))
  
  
  (cond-expand
    (windows
     (definition (gc-sound)
       (MessageBeep MB_ICONINFORMATION)))
    (cocoa
     (definition (gc-sound)
       (play-sound "Submarine")))
    (else
     (definition (gc-sound)
       (bell))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (slot previous-mouses initialize '())
  
  
  (method package virtual (mouse-down self h v (double? #f))
    (set! down? #t)
    (set! down-point (new Point h v))
    (set! double-click? double?)
    (set! previous-mouses '())
    (cond ((and showcase (in-showcase? showcase v))
           (set! showcase-down? #t)
           (showcase-mouse-down showcase h v))
          (else
           (editor-mouse-down self h v))))
  
  
  (method package virtual (mouse-moved self x y)
    (define (setup-cursor)
      (set! last-point (new Point$fl$ x y))
      (set! last-time (current-seconds)))
    
    (define (move-camera)
      (define (scalarproduct a <Point$fl$> b <Point$fl$>) <fl>
        (+ (* (get-h a) (get-h b)) (* (get-v a) (get-v b))))
      
      (let ((new-point (new Point$fl$ x y))
            (new-time (current-seconds)))
        (movecamera self new-point new-time last-point last-time previous-mouses)
        @wait
        (let ((poschange (nu- new-point last-point))
              (elapse (- new-time last-time)))
          (let ((delta (if (null? previous-mouses)
                           poschange
                         (let ((dirchange (if (null? (cdr previous-mouses)) -1. (scalarproduct poschange (nu- last-point (caadr previous-mouses))))))
                           (let ((ponderation (if (and (< (norm poschange) 5.)
                                                       (>= dirchange 0.))
                                                  .5
                                                1.)))
                             (bind (furthest-point . furthest-time) (last previous-mouses)
                               (nu+ (nu* (nu- new-point furthest-point) (* (/ elapse (- new-time furthest-time)) (- 1. ponderation)))
                                    (nu* poschange ponderation))))))))
            (let ((dx (get-h delta))
                  (dy (get-v delta)))
              (mouse-track elapse dx dy))))
        (set! last-point new-point)
        (set! last-time new-time)
        (when (get-camera-smoothing?)
          (let ((max-moves 5))
            (set! previous-mouses (cons (cons new-point new-time) previous-mouses))
            (when (> (length previous-mouses) max-moves)
              (set-cdr! (tail previous-mouses (- max-moves 1)) '()))))))
    
    (let ((window (current-window))
          (zone (current-zone))
          (history (current-history)))
      (mouse-moved zone x y)
      (let ((h (fxround x))
            (v (fxround y)))
        (cond (showcase-down?
               (showcase-mouse-drag showcase h v))
              ;; adding a test for last-point is a quick hack until major cleanup
              ((and (get-cursor-captured? window) (not (get-cursor-mode?)) last-point)
               (move-camera)
               (unless (or (is-moving? self) (get-paused? history))
                 (follow-player self)))
              (widget-down
               (widget-mouse-move widget-down h v))
              (editing?
               (editor-mouse-move self h v))
              ((and (effective-autotrack-camera? self) (not (get-cursor-mode?)))
               (setup-cursor)
               (capture-cursor window)
               (move-camera))
              ((and down? (not (near? (new Point h v) down-point drag-tolerance)))
               (set! viewing? #t)
               (setup-cursor)
               (capture-cursor window))))))
  
  
  (method package virtual (mouse-track self elapse dx dy)
    (let ((zone (current-zone))
          (me (current-controlled+ self))
          (motion (current-motion))
          (camera (current-camera))
          (history (current-history)))
      (unless (mouse-track zone elapse dx dy)
        (cond ((and (is-moving? self) (person-motion?))
               (let ((sight (copy-vertex (get-sight camera)))
                     (up (copy-vertex (get-up camera)))
                     (right (copy-vertex (get-right camera)))
                     (first? (not moved?)))
                 (track-actor motion me dx dy sight up right first?)
                 (boost-player self)
                 (set! moved? #t)))
              (else
               (track-camera motion dx dy))))))
  
  
  (method package virtual (mouse-up self h v)
    (let ((window (current-window)))
      (if mouse-run?
          (begin
            (set! viewing? #f)
            (set! moving? #t)
            (set! mouse-run? #f))
        (cond (showcase-down?
               (showcase-mouse-up showcase h v)
               (set! showcase-down? #f))
              ((get-cursor-captured? window)
               (release-cursor window)
               (follow-player self))
              (widget-down
               (widget-mouse-up widget-down h v)
               (set! widget-down #f)
               (set! widget-part #f))
              (else
               (when down?
                 (if (user?)
                     (begin
                       (mouse-up (current-universe) h v)
                       (focus-world))
                   (editor-mouse-up self h v)))))
        (set! down? #f)
        (set! down-point #f)
        (set! viewing? #f))))
  
  
  (method package virtual (double-click self h v)
    (cond ((and showcase (in-showcase? showcase v))
           (showcase-double-click showcase h v))
          (else
           (mouse-down self h v #t))))
  
  
  (method package virtual (right-mouse-down self h v)
    (set! down? #t)
    (set! down-point (new Point h v))
    (set! previous-mouses '())
    (set! moving? #t)
    (set! moved? #f))
  
  
  (method package virtual (right-mouse-up self h v)
    (let ((window (current-window))
          (me (current-me+))
          (motion (current-motion))
          (universe (current-universe)))
      (if mouse-run?
          (begin
            (set! viewing? #t)
            (set! moving? #f)
            (set! mouse-run? #f))
        (when me
          (reset-roll motion me))
        (unless (get-cursor-captured? window)
          (if (or (user?) (let ((elem (interaction-element universe h v)))
                            (and (or (not (admin?)) (shift-down?) (and (is? elem Block-Entity) (eq? (get-model elem) 'WoodenDoorBlock)))
                                 (or (and (is? elem Block-Entity)
                                          (get-right-mouse (name->block (get-name (cache-model elem)))))
                                     (is? elem Actor)))))
              (right-mouse-up universe h v)
            (when (or (not (admin?)) (shift-down?))
              (mouse-add self h v)
              (editor-up self))))
        (set! down? #f)
        (set! down-point #f)
        (set! moving? #f)
        (set! mouse-run? #f)
        (release-cursor window))))
  
  
  (method package (mouse-wheel self h v delta)
    (let ((interface (current-interface))
          (d (if (shift-down?) (get-h delta) (get-v delta))))
      (cond ((and grid? (alt-down?))
             (move-grid self d))
            ((xor (shift-down?) (world-setting 'world.wheel-zoom? #f))
             (cond ((> d 0)
                    (zoom-in self))
                   ((< d 0)
                    (zoom-out self))))
            (showcase
             (showcase-wheel showcase (> d 0)))
            (else
             (cycle-selection (child interface 'belt) d)))))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  ;; left+right mouse run
  (method (process-mouse-run self)
    (when application-active?
      (let ((modifiers (modifiers-keys)))
        (when (and (null? modifiers)
                   (get-mouse-down?)
                   (get-mouse-right-down?))
          (unless mouse-run?
            (set! mouse-run? #t)
            (mouse-track self 0. 0. 0.))
          (move-forward self)))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method (process-keys self)
    (site (process-keys on?: #f parent: player)
      (when application-active?
        ;; to optimize by using modifiers-mask
        (let ((modifiers (modifiers-keys)))
          (iterate-keys
            (lambda (shortcut proc)
              (when (and (equal? (get-modifiers shortcut) modifiers)
                         (let ((key (get-key shortcut)))
                           (or (eqv? key ongoing-key)
                               (key-down? (if (char? key)
                                              key
                                            (symbolic-key->code key))))))
                (proc self))))))))
  
  
  (method package virtual (process-shortcut self shortcut)
    (if (shortcut=? shortcut {Shortcut Escape})
        (if escape-hook
            (escape-hook)
          (main-menu self))
      #f))
  
  
  (method package virtual (key-down self c)
    )
  
  
  (method package virtual (key-press self key)
    )
  
  
  (method package virtual (key-up self c)
    )
  
  
  ;;;
  ;;;; Sound
  ;;;
  
  
  (method (toggle-sound self)
    (set-sounds? (not sounds?))
    (update-parameter self 'sound)
    (display-on/off self "Sound" sounds?))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method package (unimplemented-connected self)
    (let ((tier (current-tier)))
      (unimplemented-connected tier)))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method (tile-server/clients self)
    (tile (current-tier)))
  
  
  (method (restore-server/clients self)
    (restore (current-tier)))
  
  
  ;;;
  ;;;; Live
  ;;;
  
  
  (method package (live-gaia/world self)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error self "Not connected to a remote debugger")
        (let ((debuggee (load-object (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (live-gaia/world debugger debuggee)))))
  
  
  (method package (design-gaia/world self)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error self "Not connected to a remote debugger")
        (let ((debuggee (load-object (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (design-gaia/world debugger debuggee)))))
  
  
  (method package (restore-gaia/world self)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error self "Not connected to a remote debugger")
        (let ((debuggee (load-object (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (restore-gaia/world debugger debuggee)))))
  
  
  ;;;
  ;;;; Zoom
  ;;;
  
  
  (method (zoom-horizontally self)
    (set-setting options-settings 'world.script-horizontal? (not (world-setting 'world.script-horizontal? #f)))
    (save-content options-settings)
    (update-background (get-manager (child (current-interface) 'script)))
    (interface-layout self))
  
  
  (method (zoom-vertically self)
    (set-setting options-settings 'world.script-vertical? (not (world-setting 'world.script-vertical? #f)))
    (save-content options-settings)
    (update-background (get-manager (child (current-interface) 'script)))
    (interface-layout self))
  
  
  (method (zoom-fullscreen self)
    (set-setting options-settings 'world.script-fullscreen? (not (world-setting 'world.script-fullscreen? #f)))
    (save-content options-settings)
    (update-background (get-manager (child (current-interface) 'script)))
    (interface-layout self))
  
  
  (method (zoom-in-script self)
    (script-zoom-in))
  
  
  (method (zoom-out-script self)
    (script-zoom-out))
  
  
  (method (unzoom-script self)
    (script-unzoom))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (toggle-interface self)
    (set! interface? (not interface?))
    (update-parameter self 'interface))
  
  
  (method (toggle-occlusion self (force? #f))
    (set-wireframe? #f)
    (let ((occlusion? (or (not (get-occlusion?)) force?)))
      (set-occlusion? occlusion?)
      (set-override-renderer (and occlusion? (get-occlusion-renderer)))
      (set-block-program self (find-mesh-program self (if occlusion? 'occlusion 'terrain)))
      (update-parameter self 'occlusion)
      (update-parameter self 'wireframe)))
  
  
  (method (toggle-wireframe self (force? #f))
    (set-occlusion? #f)
    (let ((wireframe? (or (not (get-wireframe?)) force?)))
      (set-wireframe? wireframe?)
      (set-override-renderer (and wireframe? (get-wireframe-renderer)))
      (set-block-program self (find-mesh-program self (if wireframe? 'wireframe 'terrain)))
      (update-parameter self 'occlusion)
      (update-parameter self 'wireframe)))
  
  
  (method (toggle-polygon-mode self)
    (set! polygon-mode (ecase polygon-mode
                         ((GL_POINT) GL_LINE)
                         ((GL_LINE) GL_FILL)
                         ((GL_FILL) GL_POINT)))
    (glPolygonMode GL_FRONT_AND_BACK polygon-mode))
  
  
  (method (toggle-lighting self)
    (set! lighting? (not lighting?))
    (update-parameter self 'lighting)
    (display-on/off self "Lighting" lighting?))
  
  
  (method (toggle-fog self)
    (set-fog? (not fog?))
    (reload-terrain-programs self)
    (update-parameter self 'fog)
    (display-on/off self "Fog" fog?))
  
  
  (method package (toggle-windowed-mode self)
    (let ((window (current-window)))
      (toggle-windowed-mode window)
      (update-parameter self 'windowed-mode)))
  
  
  (method (toggle-post-processing self)
    (change-post-processing self (not post-processing?))
    (display-on/off self "Post processing" post-processing?))
  
  
  (method package (change-post-processing self value)
    (set! post-processing? value)
    (update-parameter self 'post-processing))
  
  
  (method package (person-motion self (eye-center?: eye-center? #t) (feedback?: feedback? #t))
    (unless (person-motion?)
      (set! eye-motion (make-person-motion self eye #f))
      (set-current-motion eye-motion)
      (when eye-center?
        (eye-center-player eye-motion))
      (update-camera-parameters self)
      (focus-world)
      (when feedback?
        (display-message self "First person"))))
  
  
  (method (orbit-motion self (feedback?: feedback? #t))
    (unless (orbit-motion?)
      (set! eye-motion (make-orbit-motion self eye #f))
      (set-current-motion eye-motion)
      (orbit-behind eye-motion (motion-target eye-motion))
      (update-camera-parameters self)
      (focus-world)
      (when feedback?
        (display-message self "Orbit around"))))
  
  
  (method package (free-motion self (feedback?: feedback? #t))
    (unless (free-motion?)
      (set! eye-motion (make-free-motion self eye))
      (set-current-motion eye-motion)
      (update-camera-parameters self)
      (focus-world)
      (when feedback?
        (display-message self "Free camera"))))
  
  
  (method (update-camera-parameters self)
    (update-parameter self 'person-motion)
    (update-parameter self 'orbit-motion)
    (update-parameter self 'free-motion))
  
  
  (method package (effective-draw-gadgets? self)
    (or draw-gadgets? (is? showcase Gadgets-Showcase)))
  
  
  (method (toggle-draw-gadgets self)
    (set! draw-gadgets? (not draw-gadgets?))
    (update-gadgets self)
    (update-parameter self 'gadgets)
    (display-on/off self "Draw gadgets" draw-gadgets?))
  
  
  (method (toggle-draw-normals self)
    (set! draw-normals? (not draw-normals?))
    (update-parameter self 'normals)
    (display-on/off self "Draw normals" draw-normals?))
  
  
  (method (toggle-draw-atlas self)
    (if texture-arrays?
        (display-error self "No atlas")
      (set! draw-atlas? (not draw-atlas?))
      (update-parameter self 'draw-atlas)
      (display-on/off self "Draw atlas" draw-atlas?)))
  
  
  (method (toggle-draw-me self)
    (let ((zone (current-zone)))
      (set-draw-me? zone (not (get-draw-me? zone)))
      (update-parameter self 'draw-me)
      (display-on/off self "Draw me" (get-draw-me? zone))))
  
  
  (method package (update-gadgets self (draw-gadgets? (effective-draw-gadgets? self)))
    (when (not draw-gadgets?)
      (for-each (lambda (elem)
                  (when (is? elem Gadget)
                    (remove-target self elem)))
                selection)))
  
  
  (method (toggle-axes self)
    (set! axes? (not axes?))
    (update-parameter self 'axes)
    (display-on/off self "Axes" axes?))
  
  
  (method (toggle-axes-graduation self)
    (set! axes-graduation? (not axes-graduation?))
    (display-on/off self "Axes graduation" axes-graduation?))
  
  
  (method (toggle-info self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'info)))
        (set-visible? panel (not (get-visible? panel)))
        (when (get-visible? panel)
          (bring-to-front panel)
          (set! interface? #t)))
      (update-parameter self 'info)))
  
  
  (method (toggle-profiler self)
    (let ((interface (current-interface))
          (history (current-history)))
      (let ((panel (child interface 'profiler)))
        (let ((visible? (not (get-visible? panel))))
          (unless (get-paused? history)
            (when visible?
              (reset-profiles)
              (reset-trackings)
              (reset-chronology)))
          (set-visible? panel visible?)
          (set-force-generate-acquire-task-mutex? visible?)
          (when visible?
            (bring-to-front panel)
            (set! interface? #t))))
      (update-parameter self 'profiler)))
  
  
  (method (reset-profiling self)
    (reset-chronology))
  
  
  (method (toggle-timeline self)
    (when (developer?)
      (set! timeline-visible? (not timeline-visible?))
      (let ((interface (current-interface)))
        (let ((panel (child interface 'timeline)))
          (when timeline-visible?
            (bring-to-front panel)
            (refresh-timeline))
          (set-visible? panel timeline-visible?))
        (update-parameter self 'timeline))))
  
  
  (method (toggle-evolution self)
    (when (developer?)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'evolution)))
          (let ((visible? (not (get-visible? panel))))
            (set-visible? panel visible?)
            (when visible?
              (bring-to-front panel)
              (set! interface? #t))))
        (update-parameter self 'evolution))))
  
  
  (method (update-color-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'color)))
        (set-visible? panel (some? (lambda (element)
                                     (is? element Light))
                                   selection)))))
  
  
  (method (toggle-target self)
    (set! interface-target? (not interface-target?))
    (update-target-panel self)
    (update-parameter self 'target))
  
  
  (method package (update-target-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'target)))
        (if (not interface-target?)
            (set-visible? panel #f)
          (set-visible? panel (or (not-null? selection)
                                  (and showcase (get-selection showcase))))))))
  
  
  (method (compass-panel self)
    (if compass-visible?
        (hide-compass self)
      (show-compass self)))
  
  
  (method (show-compass self)
    (set! compass-visible? #t)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'compass)))
        (set-visible? panel #t))))
  
  
  (method (hide-compass self)
    (set! compass-visible? #f)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'compass)))
        (set-visible? panel #f))))
  
  
  (method (map-panel self)
    (let ((zone (current-zone)))
      (when (is? (get-generator zone) World-Generator)
        (set! map-visible? (not map-visible?))
        (let ((interface (current-interface)))
          (let ((panel (child interface 'map)))
            (set-visible? panel map-visible?))))))
  
  
  (method (combat-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'combat)))
        (set-visible? panel (not (get-visible? panel))))))
  
  
  (method (character-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'character)))
        (if (get-visible? panel)
            (hide-character self)
          (show-character self)))))
  
  
  (method package (show-character self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'character)))
        (unless (get-visible? panel)
          (set-visible? panel #t)
          (view-inventory panel)
          (set! interface? #t)
          (update-parameter self 'character-panel)))))
  
  
  (method package (hide-character self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'character)))
        (when (get-visible? panel)
          (set-visible? panel #f)
          (save-inventory)
          (update-parameter self 'character-panel)))))
  
  
  (method package (crafting-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'crafting)))
        (if (get-visible? panel)
            (hide-crafting self)
          (show-crafting self)))))
  
  
  (method (show-crafting self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'crafting)))
        (unless (get-visible? panel)
          (set-visible? panel #t)
          (show-belt self)
          (show-bag self blocks?: #f)
          (hide-chest self)
          (set! interface? #t)))))
  
  
  (method (hide-crafting self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'crafting)))
        (when (get-visible? panel)
          (set-visible? panel #f)
          (hide-bag self)))))
  
  
  (method (bag-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'bag)))
        (if (get-visible? panel)
            (hide-bag self)
          (show-bag self)))))
  
  
  (method package (show-bag self (blocks?: blocks? #t))
    (let ((interface (current-interface)))
      (let ((panel (child interface 'bag)))
        (unless (get-visible? panel)
          (set-visible? panel #t)
          (view-inventory panel)
          (set! interface? #t)
          (update-parameter self 'bag-panel)
          (when (and blocks? (not (user?)))
            (goto-showcase self 'blocks))))))
  
  
  (method package (hide-bag self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'bag)))
        (when (get-visible? panel)
          (save-inventory)
          (set-visible? panel #f)
          (hide-crafting self)
          (update-parameter self 'bag-panel)
          (no-showcase self)))))
  
  
  (method (belt-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'belt)))
        (if (get-visible? panel)
            (hide-belt self)
          (show-belt self)))))
  
  
  (method (show-belt self)
    (let ((panel (child (current-interface) 'belt)))
      (set-visible? panel #t)))
  
  
  (method (hide-belt self)
    (let ((panel (child (current-interface) 'belt)))
      (set-visible? panel #f)))
  
  
  (method (who-panel self)
    ;; quicky should hide action when standalone
    (let ((interface (current-interface)))
      (let ((panel (find-type interface Who-Panel)))
        (if panel
            (close panel)
          (open-frame (new Who-Panel size: {Dimension 200 400} location: 'center))))))
  
  
  (method (chat-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'chat)))
        (if (get-visible? panel)
            (set-visible? panel #f)
          (set-visible? panel #t)))))
  
  
  (method (command-message self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'command)))
        (cond ((get-visible? panel)
               (set-visible? panel #f)
               (focus-world))
              (else
               (set-visible? panel #t)
               (acquire-focus (locate panel 'text))))))
    (interface-layout self))
  
  
  (method package (command-slash self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'command)))
        (command-slash panel))))
  
  
  (method package (hide-command self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'command)))
        (set-visible? panel #f)
        (focus-world)
        (interface-layout self))))
  
  
  (method (invalidate-belt self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'belt)))
        (when (get-visible? panel)
          (invalidate-view panel)))))
  
  
  (method package (show-chest self section data)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'chest)))
        (set-visible? panel #t)
        (hide-crafting self)
        (view-chest panel section data)
        (set! interface? #t))))
  
  
  (method package (hide-chest self)
    (let ((interface (current-interface)))
      (save-chest)
      (let ((panel (child interface 'chest)))
        (set-visible? panel #f))))
  
  
  (method package (update-parameter self name)
    (let ((interface (current-interface+)))
      (when interface
        (let ((view (parameter-view self name)))
          (unless (and together? (not view))
            (invalidate-view view))))))


  (method (parameter-view self name)
    (let ((interface (current-interface+)))
      (and interface
           (let ((parameter (registered-parameter name)))
             (define (find-view)
               (continuation-capture
                 (lambda (return)
                   (for-each (lambda (bar)
                               (when (is? bar World-Actionbar)
                                 (for-each (lambda (button)
                                             (when (and (is? button World-Parameter-Button)
                                                        (eq? (get-parameter button) name))
                                               (continuation-return return button)))
                                           (get-children bar))))
                             (get-children interface))
                   #f)))
             
             (or (get-view parameter)
                 (let ((view (find-view)))
                   (if (not view)
                       (if together?
                           #f
                         (error "Unable to find view: {a}" name))
                     (set-view parameter view)
                     view)))))))
  
  
  (method package (display-on/off self title flag)
    (display-message self (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method package (display-message self msg (color: color #f) (duration: duration #f))
    (assert (or (string? msg)
                (and (pair? msg)
                     (every? string? msg))))
    (set! message msg)
    (set! message-color color)
    (set! message-duration duration)
    (set! message-time (current-seconds)))
  
  
  (method package (clear-message self)
    (set! message #f)
    (set! message-time #f))
  
  
  (method (draw-message self)
    (let ((elapse (- (current-seconds) message-time))
          (duration (or message-duration 1.)))
      (let ((fade duration)
            (done (+ duration 1.)))
        (if (> elapse done)
            (begin
              (set! message #f)
              (set! message-time #f))
          (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f))
                (multiline? (pair? message)))
            (let ((surface (get-surface (get-texture message-sheet)))
                  (font (if multiline? {Font Message-Small} {Font Message}))
                  (incr (if multiline? 24 30))
                  (color (or message-color {Color World-Message}))
                  (first (if multiline? (car message) message))
                  (all (if multiline? message (list message))))
              (clear surface)
              (set-font surface font)
              (let ((color (if (not alpha)
                               color
                             (let ((color (copy-object color #f)))
                               (set-alpha color alpha)
                               color)))
                    (shadow-color (if (not alpha)
                                      {Color Black}
                                    (let ((color (copy-object {Color Black} #f)))
                                      (set-alpha color alpha)
                                      color)))
                    (v 10))
                (for-each (lambda (message)
                            (draw-text surface 0 v message color shadow-color: shadow-color)
                            (increase! v incr))
                          all))
              (map-texture (get-texture message-sheet))
              (let ((w (text-width font first)))
                (let ((x (cast <fl> (center w (fxround width))))
                      (y (cast <fl> (- (fxround height) (draw-message-offset self)))))
                  (let ((matrix (make-translation-matrix (vertex x y 0.))))
                    (render-sheet message-sheet matrix))))))))))
  
  
  (method protected virtual (draw-message-offset self)
    200)
    
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method package (display-error self msg (duration: duration 5.))
    (display-message self msg color: {Color Red} duration: duration))
  
  
  (method package (display-cancel self msg (duration: duration #f))
    (display-message self msg color: {Color Red} duration: duration)
    (signal-cancel))
  
  
  (method package (display-walk-problems self detail)
    (open-message (walk-problems-message detail)
                  caption: "Problems"
                  type: 'message
                  execute: (lambda (evt)
                             (let ((dialog (find-ascendant (get-sender evt) World-Dialog)))
                               (close dialog)))))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method package (display-status self msg (color: color #f))
    (set! status msg)
    (set! status-color color)
    (set! status-time (current-seconds)))
  
  
  (method (draw-status self)
    (let ((elapse (- (current-seconds) status-time))
          (fade 1.)
          (done 2.))
      (if (> elapse done)
          (begin
            (set! status #f)
            (set! status-time #f))
        (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f)))
          (let ((surface (get-surface (get-texture status-sheet)))
                (font {Font Status})
                (color (or status-color {Color World-Message})))
            (clear surface)
            (set-font surface font)
            (let ((color (if (not alpha)
                             color
                           (let ((color (copy-object color #f)))
                             (set-alpha color alpha)
                             color)))
                  (shadow-color (if (not alpha)
                                    {Color Black}
                                  (let ((color (copy-object {Color Black} #f)))
                                    (set-alpha color alpha)
                                    color))))
              (draw-text surface 0 0 status color shadow-color: shadow-color))
            (map-texture (get-texture status-sheet))
            (let ((w (text-width font status)))
              (let ((x (cast <fl> (center w (fxround width))))
                    (y 70.0))
                (let ((matrix (make-translation-matrix (vertex x y 0.))))
                  (render-sheet status-sheet matrix)))))))))))
