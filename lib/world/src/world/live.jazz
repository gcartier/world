;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World
;;;


(module world.live jazz


(import (jazz.debuggee)
        (jazz.designer)
        (jazz.development)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.autoload)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.library)
        (jazz.library.component)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.skin)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.version)
        (time)
        (world)
        (world.actor)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.block)
        (world.collision)
        (world.counter)
        (world.cuboid)
        (world.debug)
        (world.draw)
        (world.dye)
        (world.element)
        (world.enemy)
        (world.entity)
        (world.external.milkshape)
        (world.external.obj)
        (world.folio)
        (world.foreign)
        (world.foreign.obj)
        (world.gadget)
        (world.generate)
        (world.geometry)
        (world.gravity)
        (world.history)
        (world.interface)
        (world.interface.bindings)
        (world.interface.counters)
        (world.interface.dialogs)
        (world.interface.documents)
        (world.interface.frame)
        (world.interface.info)
        (world.interface.inventory)
        (world.interface.main)
        (world.interface.menu)
        (world.interface.options)
        (world.interface.pane)
        (world.interface.player)
        (world.interface.popup)
        (world.interface.worlds)
        (world.interface.zones)
        (world.io)
        (world.light)
        (world.lookat)
        (world.mark)
        (world.material)
        (world.mesh)
        (world.model)
        (world.object)
        (world.plane)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.programs)
        (world.render)
        (world.sector)
        (world.settings)
        (world.shader)
        (world.shaders)
        (world.texture)
        (world.test)
        (world.tile)
        (world.user)
        (world.view)
        (world.window)
        (world.zone)
        (world.client.configuration)
        (world.client.window))


;;;
;;;; World
;;;


(class World extends Component
  
  
  (property title             <string+>       initialize #f            accessors generate)
  (property gravity           <fl>            initialize .09           accessors generate)
  (property jump-impulsion    <fl>            initialize 2.0           accessors generate)
  (property start-zone        <string+>       initialize #f            accessors generate)
  (property start-mode        <symbol>        initialize 'free         accessors generate)
  (property start-3d?         <bool>          initialize #t            accessors generate)
  (property start-grid?       <bool>          initialize #t            accessors generate)
  (property default-image     <object>        initialize "dirty"       accessors generate)
  (property properties        <object>        initialize '()           accessors generate)
  
  
  (slot window                <OpenGL-Window> initialize #f            accessors generate)
  (slot width                 <fl>            initialize #f            accessors generate)
  (slot height                <fl>            initialize #f            accessors generate)
  (slot boundaries            <Cuboid+>       initialize #f            getter generate)
  (slot eye                   <f32vector>     initialize (make-vertex) getter generate)
  (slot eye-target            <f32vector>     initialize (make-vertex) getter generate)
  (slot eye-lookat            <LookAt>        initialize (make-lookat) getter generate)
  (slot world-up              <f32vector>     initialize (make-vertex) getter generate)
  (slot light?                <bool>          initialize #t            getter generate)
  (slot lightmaps?            <bool>          initialize #t            accessors generate)
  (slot shadowmaps?           <bool>          initialize #f            accessors generate)
  (slot mode                  <symbol>        initialize 'explore      getter generate)
  (slot what                  <object>        initialize #f            getter generate)
  (slot target                <object>        initialize #f            getter generate)
  (slot target-face           <object>        initialize #f            getter generate)
  (slot target-mode           <object>        initialize 'select       getter generate)
  (slot last-point            <object>        initialize #f            getter generate)
  (slot last-time             <object>        initialize #f            getter generate)
  (slot last-recenter         <object>        initialize #f            getter generate)
  (slot camera-distance       <fl>            initialize 60.           getter generate)
  (slot polygon-mode          <fx>            initialize GL_FILL       getter generate)
  (slot interface?            <bool>          initialize #t            getter generate)
  (slot explore-interface?    <bool>          initialize #f            accessors generate)
  
  
  (slot version               <object>        initialize #f            getter generate)
  (slot projection            <symbol>        initialize 'orthographic getter generate)
  (slot zoom-factor           <fl>            initialize 0.            getter generate)
  (slot desired-tilt          <fl>            initialize 0.            getter generate)
  (slot tilt-speed            <fl>            initialize 0.            getter generate)
  (slot last-tilt-time        <fl+>           initialize #f            getter generate)
  (slot 3d?                   <bool>          initialize #f            getter generate)
  (slot eye?                  <bool>          initialize #f            getter generate)
  (slot aim?                  <bool>          initialize #f            getter generate)
  (slot fly?                  <bool>          initialize #f            getter generate)
  (slot viewing?              <bool>          initialize #f            getter generate)
  (slot moving?               <bool>          initialize #f            getter generate)
  (slot moved?                <bool>          initialize #f            getter generate)
  (slot preserved-mouse       <object>        initialize #f            getter generate)
  (slot first-person?         <bool>          initialize #f            getter generate)
  (slot max-distance          <fl>            initialize 150.0         getter generate)
  (slot first-distance        <fl>            initialize 17.5          getter generate)
  (slot first-override        <fl+>           initialize #f            getter generate)
  (slot first-occlusion?      <bool>          initialize #f            getter generate)
  (slot first-camera          <object>        initialize #f            getter generate)
  (slot mount                 <object>        initialize 'none         getter generate)
  (slot ground-mounts-folio   <Folio>         initialize #f            getter generate)
  (slot all-mounts-folio      <Folio>         initialize #f            getter generate)
  (slot draw-elements?        <bool>          initialize #t            getter generate)
  (slot draw-gadgets?         <bool>          initialize #f            getter generate)
  (slot draw-wireframe?       <bool>          initialize #f            getter generate)
  (slot draw-marks?           <bool>          initialize #t            getter generate)
  (slot draw-atlas?           <bool>          initialize #f            getter generate)
  (slot draw-actors-history?  <bool>          initialize #t            getter generate)
  (slot draw-procedures       <object>        initialize '()           getter generate)
  (slot view-distance         <fx>            initialize 3             getter generate)
  (slot dynamic-lights        <fx>            initialize 8             getter generate)
  (slot post-processing?      <bool>          initialize #t            getter generate)
  (slot track-sensitivity     <fl>            initialize 200.          getter generate)
  (slot axes?                 <bool>          initialize #f            getter generate)
  (slot pulse                 <object>        initialize #f            getter generate)
  (slot last-tick             <fl>            initialize #f            getter generate)
  (slot down?                 <bool>          initialize #f            getter generate)
  (slot down-point            <object>        initialize #f            getter generate)
  (slot drag-tolerance        <object>        initialize 3             getter generate)
  (slot paused?               <bool>          initialize #f            getter generate)
  (slot counters              <object>        initialize #f            getter generate)
  (slot tick-procedures       <object>        initialize '()           getter generate)
  (slot tick-no               <object>        initialize 0             getter generate)
  (slot commands              <object>        initialize #f            getter generate)
  (slot base-assets           <object>        initialize #f            getter generate)
  (slot world-assets          <object>        initialize #f            getter generate)
  (slot user-assets           <object>        initialize #f            getter generate)
  (slot all-assets            <object>        initialize #f            getter generate)
  (slot texture-atlas         <object>        initialize #f            getter generate)
  (slot textures              <object>        initialize #f            getter generate)
  (slot models                <object>        initialize #f            getter generate)
  (slot last-missile          <fl+>           initialize #f            getter generate)
  (slot music?                <bool>          initialize #f            getter generate)
  (slot history?              <object>        initialize #t            getter generate)
  (slot history               <object>        initialize #f            getter generate)
  (slot message               <object>        initialize #f            getter generate)
  (slot message-time          <object>        initialize #f            getter generate)
  (slot message-color         <object>        initialize #f            getter generate)
  (slot message-texture       <object>        initialize #f            getter generate)
  (slot status                <object>        initialize #f            getter generate)
  (slot status-time           <object>        initialize #f            getter generate)
  (slot status-color          <object>        initialize #f            getter generate)
  (slot status-texture        <object>        initialize #f            getter generate)
  (slot information           <object>        initialize #f            getter generate)
  (slot interface             <object>        initialize #f            getter generate)
  
  ;; Shader programs
  (slot mesh-programs         <object>        initialize #f            accessors generate)
  (slot tile-mesh             <object>        initialize #f            accessors generate)
  (slot tile-matrix           <object>        initialize #f            accessors generate)
  (slot tile-program          <object>        initialize #f            accessors generate)
  (slot tile-program-folio    <object>        initialize #f            accessors generate)
  (slot pp-program            <object>        initialize #f            accessors generate)
  
  ;; Render targets
  (slot render-target         <object>        initialize #f            accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition max-dynamic-lights
    8)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-world self)
    (set! view-distance (find-setting 'world.view-distance 3))
    (set! dynamic-lights (min max-dynamic-lights (find-setting 'world.dynamic-lights 8)))
    (set! lightmaps? #f @temporary (find-setting 'world.lightmaps? #t))
    (set! shadowmaps? #f @temporary (find-setting 'world.shadowmaps? #f))
    (set! draw-wireframe? (find-setting 'world.draw-wireframe? #f))
    (set! draw-actors-history? (find-setting 'world.actors-history? #t))
    (set! track-sensitivity (find-setting 'world.track-sensitivity 200.))
    (set! post-processing? (find-setting 'world.post-processing? #t))
    (set! interface? (find-setting 'world.start-interface? #t))
    (set! history? (find-setting 'world.history? #t)))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (vertex-init! world-up 0. 1. 0.)
    (prepare-camera)
    (update-camera)
    (when music?
      (change-music)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method (setup-opengl)
    (let ((size (get-size~ window)))
      (set! width (cast <fl> (get-width~ size)))
      (set! height (cast <fl> (get-height~ size))))
    (glPolygonMode GL_FRONT GL_FILL)
    (glMatrixMode GL_MODELVIEW)
    (glEnable GL_NORMALIZE)
    (glEnable GL_LINE_SMOOTH)
    (initialize-camera)
    (prepare-assets)
    (prepare-models)
    (prepare-textures)
    (prepare-shaders)
    (prepare-editor)
    (initialize-render)
    (reset-commands)
    (gl-check-error))
  
  
  (method (start-world)
    (prepare-tick))
  
  
  (method (initialize-render)
    (set! render-target (new Render-Target (fxround width) (fxround height) multisample?: #t)))
  
  
  (method (reset-commands)
    (when (or (not commands) (get-modified?~ commands))
      (set! commands (new Commands)))
    (set-last-no~ commands tick-no)
    (increase! tick-no))
  
  
  (method (setup-world)
    (set! last-tick (time->seconds (current-time)))
    (set! paused? #f))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (method (prepare-assets)
    (let ((world-directory (get-world-directory)))
      (set! base-assets (new Directory (cons (world-alias) '("lib" "world.client" "assets"))))
      (set! world-assets (and world-directory (new-directory~ world-directory "assets")))
      (set! user-assets {Directory Settings "assets"})
      (set! all-assets (remove-false (list user-assets world-assets base-assets)))))
  
  
  (method (prepare-textures)
    (define (make-texture-atlas)
      (let ((atlas (new Atlas)))
        (for-each (lambda (assets)
                    (add-directory-if-exists~ atlas (new-directory~ assets "tile")))
                  all-assets)
        (complete~ atlas)
        atlas))
    
    (set! texture-atlas (make-texture-atlas))
    (set! tile-mesh (new Mesh material: (new Material texture: (get-texture~ texture-atlas))))
    (set! tile-matrix (make-identity-matrix))
    (set! message-texture (make-cairo-texture 800 100))
    (set! status-texture (make-cairo-texture 800 35)))
  
  
  ;;;
  ;;;; Models
  ;;;
  
  
  (method (prepare-models)
    (set! models (make-table test: equal?)))
  
  
  ;;;
  ;;;; Shaders
  ;;;
 
  
  (method (prepare-shaders)
    ;; mesh
    (set! mesh-programs (make-table test: eq?))
    (table-set! mesh-programs 'color         (new Mesh-Color-Program))
    (table-set! mesh-programs 'dynamic-phong (new Mesh-Dynamic-Phong-Program))
    (table-set! mesh-programs 'phong         (new Mesh-Phong-Program))
    (table-set! mesh-programs 'wireframe     (new Mesh-Wireframe-Program))
    (table-set! mesh-programs 'radial-blur   (new Mesh-Radial-Blur-Program))
    (table-set! mesh-programs 'motion-blur   (new Mesh-Motion-Blur-Program))
    (table-set! mesh-programs 'water         (new Mesh-Water-Program))
    (table-set! mesh-programs 'julia         (new Mesh-Julia-Program))
    (table-set! mesh-programs 'sierpinski    (new Mesh-Sierpinski-Program))
    (table-set! mesh-programs 'multitexture  (new Mesh-Multitexture-Program))
    (table-set! mesh-programs 'kaleidoscope  (new Mesh-Kaleidoscope-Program))
    (table-set! mesh-programs 'tunnel        (new Mesh-Tunnel-Program))
    (table-set! mesh-programs 'square-tunnel (new Mesh-Square-Tunnel-Program))
    (table-set! mesh-programs 'fly           (new Mesh-Fly-Program))
    (table-set! mesh-programs 'pulse         (new Mesh-Pulse-Program))

    ;; tile
    (set! tile-program (find-mesh-program (or (find-setting 'world.tile-shader #f) 'phong)))
    (set! tile-program-folio (new Folio 'phong '(phong @wireframe wireframe radial-blur motion-blur water julia sierpinski multitexture kaleidoscope tunnel square-tunnel fly @debug pulse)))
    
    ;; pp
    (set! pp-program (new PP-Program)))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))


  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (free-resources~ render-target)
    (detach-shaders~ tile-program)
    (detach-shaders~ pp-program)
    (glDeleteTextures* (get-texture~ message-texture))
    (glDeleteTextures* (get-texture~ status-texture))
    (close-music "ambiance")
    (close~ pulse))
  
  
  (method public (garbage-collect)
    (display-message "Garbage collecting")
    (gc)
    (gc))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method protected virtual (initialize-world)
    (set! version world-version)
    (set! first-camera 'free)
    (set! grid? start-grid?)
    (cond (start-3d?
           (activate-3d))
          (else
           (set! camera-distance 0.6)
           (set! first-distance 7.5)
           (set! editor-mode 'point)))
    (setup-interface)
    (setup-history)
    (setup-gc)
    (update-title))
  
  
  (method (setup-interface)
    (set! interface (new World-Interface))
    (new Info-Pane parent: interface name: 'info size: {Dimension 400 1200} location: 'head visible?: #f)
    (new Counters-Pane parent: interface name: 'counters size: {Dimension 400 82} location: '(head tail) visible?: #f)
    (new Player-Pane parent: interface name: 'player size: {Dimension 200 50} location: '(10 10) visible?: #f)
    (set! counters (make-table test: eq?))
    (add-counter 'latency (new Counter title: "Latency"))
    (add-counter 'render (new Counter title: "Render"))
    (add-counter 'tick (new Counter title: "Tick"))
    (add-counter 'camera (new Counter title: "Camera" kind: 'period))
    (add-counter 'gc (new Counter title: "GC" kind: 'frequency))
    (set-root~ window interface offscreen?: #f))
  
  
  (method (is-active?)
    (eq? self world))
  
  
  (method (is-inactive?)
    (not (is-active?)))
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method (zone-update)
    (enter-zone~ (get-process))
    (set! ground-mounts-folio (new Folio 'none '(none weels)))
    (set! all-mounts-folio (new Folio 'none '(none weels carpet)))
    ;; add player when not connected to server
    (when (and (client-side?~ (get-application)) (not (get-world-server~ (get-application))))
      (let ((start-position (get-start-position~ zone)))
        (when start-position
          (let ((player (new Player name: (effective-player-name~ (get-application)) x: (vertex-x start-position) y: (vertex-y start-position) z: (vertex-z start-position))))
            (let ((start-sight (get-start-sight~ zone))
                  (start-up (get-start-up~ zone)))
              (when (and start-sight start-up)
                (let ((lookat (get-lookat~ player)))
                  (set-sight~ lookat start-sight)
                  (set-up~ lookat start-up)
                  (set-right~ lookat (vertex-normalize (cross-product& start-sight start-up))))))
            (add-element~ zone player)
            (set-me player)
            (camera-behind-player)
            (follow-player))))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (prepare-tick)
    (set! pulse (new Pulse 'tick .01 (lambda () (if (eq? (testing) 'time) (time (tick-world)) (tick-world))))))
  
  
  (method (tick-world)
    (unless (or paused? (is-inactive?))
      (let ((seconds (time->seconds (current-time))))
        (let ((elapse (- seconds last-tick))
              (process (get-process)))
          (set! last-tick seconds)
          (when history?
            (add-history elapse))
          (when (get-sun-cycle?~ zone)
            (tick-sun~ zone elapse))
          (let ((counter (find-counter 'tick)))
            (start~ counter)
            (complete~ commands)
            (if (client-side?~ process)
                (if (not (get-world-server~ process))
                    (tick-actors commands elapse)
                  (when (get-modified?~ commands)
                    (tick-server~ (get-process) commands elapse)))
              (when me
                (tick-sliced me commands elapse)))
            (reset-commands)
            (when (not-null? tick-procedures)
              (for-each (lambda (proc)
                          (proc elapse))
                        tick-procedures))
            (end~ counter))
          (restore-first-distance elapse)))))
  
  
  (method (tick-actors commands elapse)
    (unless (and me (get-state~ me))
      (for-each (lambda (actor)
                  (tick-sliced actor commands elapse))
                (get-actors~ zone))))
  
  
  (method (register-tick proc)
    (set! tick-procedures (cons proc tick-procedures)))
  
  
  (method (unregister-tick proc)
    (set! tick-procedures (remove! proc tick-procedures)))
  
  
  (method (world-update players)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-update players))
    (for-each (lambda (info)
                (bind (player-name player-avatar player-position player-sight player-up player-right) info
                  (let ((player (find-named-player player-name)))
                    (if (not player)
                        (add-player player-name player-avatar player-position player-sight player-up player-right)
                      (let ((lookat (get-lookat~ player)))
                        (let ((in-sync? (and (vertex=? (get-position~ player) player-position)
                                             (vertex=? (get-sight~ lookat) player-sight)
                                             (vertex=? (get-up~ lookat) player-up)
                                             (vertex=? (get-right~ lookat) player-right))))
                          (when (not in-sync?)
                            (set-position~ player player-position)
                            (set-sight~ lookat player-sight)
                            (set-up~ lookat player-up)
                            (set-right~ lookat player-right)
                            (when (eq? player me)
                              (camera-behind-player)
                              (follow-player)))))))))
              players)
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (method (world-enter player-name player-avatar player-position player-lookat)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-enter player-name player-avatar player-position player-lookat))
    (bind (sight up right) player-lookat
      (add-player player-name player-avatar player-position sight up right))
    (display-message (format "{a} entered world" player-name))
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (method (add-player player-name player-avatar player-position player-sight player-up player-right)
    (let ((player (new Player name: player-name x: 0. y: 0. z: 0.)))
      (set-position~ player player-position)
      (let ((lookat (get-lookat~ player)))
        (set-sight~ lookat player-sight)
        (set-up~ lookat player-up)
        (set-right~ lookat player-right))
      (when player-avatar
        (if (is? player-avatar Color)
            (set-color~ player player-avatar)
          (set-avatar~ player player-avatar)))
      (add-element~ zone player)
      (when (and (client-side?~ (get-process)) (equal? player-name (get-player-name~ (get-process))))
        (set-me player)
        (camera-behind-player)
        (follow-player))))
  
  
  (method (world-exit player-name)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-exit player-name))
    (let ((player (find-named-player player-name)))
      (when player
        (remove-element player))
      (when (and (client-side?~ (get-process)) (equal? player-name (get-player-name~ (get-process))))
        (set-me #f))
      (display-message (format "{a} exited world" player-name)))
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (definition empty-commands
    (let ((commands (new Commands)))
      (complete~ commands)
      commands))
  
  
  (method (server-tick player-commands elapse)
    (unless (null? player-commands)
      (when (find-setting 'world.client.debug? #f)
        (terminal (effective-player-name~ (get-application)) 'server-tick player-commands elapse)))
    (let ((counter (find-counter 'latency)))
      (start~ counter)
      (unless (and me (get-state~ me))
        (for-each (lambda (actor)
                    (let ((name (and (is? actor Player) (get-name~ actor))))
                      (let ((pair (and name (assoc name player-commands))))
                        (let ((commands (if pair (deserialize-commands (cdr pair)) empty-commands)))
                          (tick-sliced actor commands elapse)))))
                  (get-actors~ zone)))
      (end~ counter))
    (unless (null? player-commands)
      (when (find-setting 'world.client.debug? #f)
        (debug-players))))
  
  
  (method (tick-sliced actor commands elapse)
    (parameterize ((tick-actor actor))
      (tick-actions~ actor commands)
      (continuation-capture
        (lambda (exit)
          (let ((slice (if (is? actor Player) .01 .05)))
            (let (iter (from 0.) (to slice))
              (tick~ actor commands (- to from) exit)
              (when (< to elapse)
                (iter to (min elapse (+ to slice))))))))))
  
  
  (method (server-test argument)
    (1)
    (debug 'server-test)
    argument)
  
  
  (method (debug-players)
    (for-each (lambda (player)
                (unless (equal? (get-name~ player) "Server")
                  (terminal '->
                            (get-name~ player)
                            (get-position~ player)
                            (present-vertex (get-sight~ (get-lookat~ player))))))
              (get-players~ zone)))

  
  ;;;
  ;;;; Events
  ;;;
  
  
  ;; Interface
  (method (on-main-menu evt)
    (main-menu))
  
  (method (on-video-options evt)
    (video-options))
  
  (method (on-audio-options evt)
    (audio-options))
  
  (method (on-interface-options evt)
    (interface-options))
  
  (method (on-view-bindings evt)
    (view-bindings))
  
  (method (on-view-news evt)
    (view-news))
  
  (method (on-view-roadmap evt)
    (view-roadmap))
  
  (method (on-view-help evt)
    (view-help))
  
  (method (on-toggle-mode evt)
    (toggle-mode))
  
  (method (on-toggle-interface evt)
    (toggle-interface))
  
  (method (on-toggle-counters evt)
    (toggle-counters))
  
  (method (on-reset-counters evt)
    (reset-counters)
    (display-message "Counters reset"))
  
  (method (on-exit-world evt)
    (define (exit)
      (exit-process~ (get-application)))
    
    (if (not (find-setting 'world.confirmation-dialogs? #t))
        (exit)
      (open-message "Are you sure you want to exit?"
                    caption: "Exit"
                    type: 'question
                    yes: "Yes"
                    no: "No"
                    execute: (lambda (evt)
                               (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog))
                                     (button (get-property~ evt button:)))
                                 (close~ dialog)
                                 (case button
                                   ((yes)
                                    (exit))))))))
  
  (method (on-resume-world evt)
    (close-current-popup))
  
  
  ;; Graphics
  (method (on-toggle-lighting evt)
    (toggle-lighting)
    (display-on/off "Light" light?))
  
  (method (on-toggle-projection evt)
    (toggle-projection))
  
  (method (on-toggle-draw-gadgets evt)
    (toggle-draw-gadgets))
  
  (method (on-toggle-draw-elements evt)
    (toggle-draw-elements))
  
  (method (on-toggle-post-processing evt)
    (toggle-post-processing))
  
  
  ;; Sounds
  (method (on-change-music evt)
    (change-music))
  
  
  ;; Server
  (method (on-connect-to-server evt)
    (connect-to-server))
  
  (method (on-disconnect-from-server evt)
    (disconnect-from-server))
  
  (method (on-request-server-update evt)
    (request-server-update))
  
  
  ;; World
  (method (on-world-open evt)
    (world-open))
  
  
  ;; Zone
  (method (on-zone-new evt)
    (zone-new))
  
  (method (on-zone-open evt)
    (zone-open))
  
  (method (on-zone-save evt)
    (zone-save))
  
  (method (on-zone-save-as evt)
    (zone-save-as))
  
  (method (on-save-player evt)
    (save-player))
  
  (method (on-zone-revert evt)
    (zone-revert))
  
  
  ;; Game
  (method (on-toggle-aim evt)
    (toggle-aim))
  
  (method (on-change-ground-mount evt)
    (change-ground-mount reversed?: (get-property~ evt reversed?:)))
  
  (method (on-toggle-fly evt)
    (toggle-fly))
  
  (method (on-change-missile-behavior evt)
    (change-missile-behavior))
  
  (method (on-toggle-player evt)
    (toggle-player))
  
  
  ;; Camera
  (method (on-first-person evt)
    (first-person))
  
  (method (on-toggle-3d evt)
    (toggle-3d))
  
  (method (on-change-first-camera evt)
    (change-first-camera))
  
  
  ;; Movement
  
  
  ;; Edition
  (method (on-remove-target evt)
    (remove-target))
  
  (method (on-toggle-grid evt)
    (toggle-grid))
  
  (method (on-toggle-grid-plane evt)
    (toggle-grid-plane (get-property~ evt plane:)))
  
  (method (on-decrease-grid evt)
    (decrease-grid))
  
  (method (on-increase-grid evt)
    (increase-grid))
  
  (method (on-change-element-class evt)
    (change-element-class reversed?: (get-property~ evt reversed?:)))
  
  (method (on-change-tile-program evt)
    (change-tile-program reversed?: (get-property~ evt reversed?:)))
  
  (method (on-change-tile-texture evt)
    (change-tile-texture reversed?: (get-property~ evt reversed?:)))
  
  (method (on-change-texture evt)
    (change-texture reversed?: (get-property~ evt reversed?:)))
  
  (method (on-reload-textures evt)
    (reload-textures)
    (display-message "Textures reloaded"))
  
  (method (on-select-brush evt)
    (select-brush))
  
  (method (on-toggle-brush-mode evt)
    (toggle-brush-mode))
  
  (method (on-change-editor-mode evt)
    (change-editor-mode reversed?: (get-property~ evt reversed?:)))
  
  (method (on-change-target-mode evt)
    (change-target-mode reversed?: (get-property~ evt reversed?:)))
  
  (method (on-set-element-template evt)
    (set-element-template))
  
  (method (on-unset-element-template evt)
    (unset-element-template))
  
  
  ;; History
  (method (on-toggle-paused evt)
    (toggle-paused))
  
  (method (on-backward-history evt)
    (backward-history))
  
  (method (on-forward-history evt)
    (forward-history))
  
  (method (on-step-world evt)
    (step-world))
  
  (method (on-toggle-history evt)
    (toggle-history))
  
  (method (on-reset-history evt)
    (reset-history))
  
  
  ;; Window
  (method (on-live-gaia/world evt)
    (live-gaia/world))
  
  (method (on-design-gaia/world evt)
    (design-gaia/world))
  
  (method (on-toggle-windowed-mode evt)
    (toggle-windowed-mode))
  
  (method (on-restore-gaia/world evt)
    (restore-gaia/world))


  ;; Debug
  (method (on-toggle-axes evt)
    (toggle-axes))
  
  (method (on-toggle-info evt)
    (toggle-info))
  
  (method (on-toggle-eye evt)
    (toggle-eye))
  
  (method (on-toggle-debug-areas evt)
    (toggle-debug-areas~ zone))
  
  (method (on-toggle-draw-atlas evt)
    (toggle-draw-atlas))
  
  (method (on-toggle-evaluation evt)
    (toggle-evaluation))
  
  (method (on-reset-all-marks evt)
    (reset-all-marks~ zone))
  
  (method (on-clear-terminal evt)
    (clear-terminal))

  (method (on-garbage-collect evt)
    (garbage-collect))

  (method (on-explore-interface evt)
    (explore-interface))
  
  (method (on-remove-duplicate-blocks~ evt)
    (remove-duplicate-blocks~ zone))
  
  (method (on-test1 evt)
    (test1))

  (method (on-test2 evt)
    (test2))

  (method (on-test3 evt)
    (test3))

  (method (on-test4 evt)
    (test4))

  (method (on-test5 evt)
    (test5))

  (method (on-test6 evt)
    (test6))

  (method (on-test7 evt)
    (test7))

  (method (on-test8 evt)
    (test8))

  (method (on-test9 evt)
    (test9))

  (method (on-test0 evt)
    (test0))

  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (setup-history)
    (set! history (new History self (find-setting 'world.history-max 500))))
  
  
  (method (historical-moment n)
    (historical-moment~ history n))
  
  
  (method (add-history elapse)
    (let ((moment (new Moment (snapshot-world) (object-copy commands) elapse)))
      (add-history~ history moment)))
  
  
  (method (backward-history)
    (backward-history~ history))
  
  
  (method (forward-history)
    (forward-history~ history))
  
  
  (method (slide-history where)
    (slide-history~ history where))
  
  
  (method (truncate-future)
    (truncate-future~ history))
  
  
  (method (toggle-history)
    (set! history? (not history?))
    (when (not history?)
      (setup~ history))
    (display-on/off "History" history?))
  
  
  (method (reset-history)
    (setup~ history)
    (display-message "History reset"))
  
  
  (method (step-world)
    (step-world~ history))
  
  
  (method (recalculate-future)
    (recalculate-future~ history))
  
  
  (method (update-future)
    (when (and history? paused?)
      (recalculate-future)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method (move-forward)
    (if (and me first-person? (not paused?))
        (move-up~ me commands)
      (vertex-copy! eye (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) (camera-move-speed))))
      (update-camera)))
  
  
  (method (move-backward)
    (if (and me first-person? (not paused?))
        (move-down~ me commands)
      (vertex-copy! eye (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) (- (camera-move-speed)))))
      (update-camera)))
  
  
  (method (strafe-left)
    (if (and me first-person? (not paused?))
        (strafe-left~ me commands)
      (strafe-horizontally (- (* (camera-strafe-speed) 2)))))
  
  
  (method (strafe-right)
    (if (and me first-person? (not paused?))
        (strafe-right~ me commands)
      (strafe-horizontally (* (camera-strafe-speed) 2))))
  
  
  (method (strafe-horizontally d)
    (vertex-copy! eye (vertex+ eye (vertex-scalar* (get-right~ eye-lookat) d)))
    (update-camera))
  
  
  (method (strafe-up)
    (if (and me first-person? (not paused?))
        (strafe-up~ me commands)
      (vertex-copy! eye (vertex+ eye (vertex-scalar* (get-up~ eye-lookat) (* (camera-strafe-speed) 2))))
      (update-camera)))
  
  
  (method (strafe-down)
    (if (and me first-person? (not paused?))
        (strafe-down~ me commands)
      (vertex-copy! eye (vertex+ eye (vertex-scalar* (get-up~ eye-lookat) (- (* (camera-strafe-speed) 2)))))
      (update-camera)))
  
  
  (method (rotate-left)
    (if (and me first-person? (not paused?))
        (rotate-left~ me commands)
      (rotate-horizontal (camera-rotate-speed))))
  
  
  (method (rotate-right)
    (if (and me first-person? (not paused?))
        (rotate-right~ me commands)
      (rotate-horizontal (- (camera-rotate-speed)))))
  
  
  (method (rotate-horizontal angle)
    (rotate-lookat! eye-lookat angle world-up)
    (update-camera))
  
  
  (method (rotate-up)
    @wrong-number-of-parameters???
    (rotate-vertical (camera-rotate-speed) (get-right~ eye-lookat) (get-sight~ eye-lookat)))
  
  
  (method (rotate-down)
    (rotate-vertical (- (camera-rotate-speed))))
  
  
  (method (rotate-vertical angle)
    (set-sight~ eye-lookat (vertex-normalize (rotate-upon angle (get-right~ eye-lookat) (get-sight~ eye-lookat))))
    (set-up~ eye-lookat (vertex-normalize (rotate-upon angle (get-right~ eye-lookat) (get-up~ eye-lookat))))
    (update-camera))
  
  
  (method (move-left)
    (when me
      (move-left~ me commands)))
  
  
  (method (move-right)
    (when me
      (move-right~ me commands)))
  
  
  (method (move-down)
    (when me
      (move-down~ me commands)))
  
  
  (method (move-up)
    (when me
      (move-up~ me commands)))
  
  
  (method (space)
    (if (or first-person? (not 3d?))
        (when me
          (space~ me commands))
      (strafe-up)))
  
  
  ;;;
  ;;;; Game
  ;;;
  
  
  (method (fire)
    (when (and me first-person? (not paused?))
      (fire~ me commands)))
  
  
  (method (maybe-fire)
    (let ((seconds (time->seconds (current-time))))
      (when (or (not last-missile)
                (> (- seconds last-missile) missile-delay))
        (fire)
        (set! last-missile seconds))))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method (prepare-projection)
    (let ((ratio (/ width height))
          (near 0.1)
          (far 10000.0))
      (glMatrixMode GL_PROJECTION)
      (glLoadIdentity)
      (case projection
        ((perspective)
         (let ((fovy 45.))
           (gluPerspective fovy ratio near far)))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (glOrtho (- width) width (- height) height near far)))))))
  
  
  (method (activate-perspective)
    (set! projection 'perspective))
  
  
  (method (activate-orthographic)
    (standardize!~ eye-lookat)
    (update-camera)
    (set! editor-mode 'point)
    (set! projection 'orthographic))
  
  
  (method (toggle-projection)
    (case projection
      ((perspective) (activate-orthographic))
      ((orthographic) (activate-perspective)))
    (display-message (format "Projection {a}" projection)))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (definition camera-limit
    5.)
  
  
  (method (camera-move-speed)
    (find-setting 'world.camera-move-speed 1.0))
  
  (method (camera-strafe-speed)
    (find-setting 'world.camera-strafe-speed 0.5))
  
  (method (camera-rotate-speed)
    (find-setting 'world.camera-rotate-speed 0.03))
  
  
  (method (initialize-camera)
    (set! zoom-factor 54.5)
    (prepare-camera)
    (update-camera))
  
  
  (method (setup-camera)
    (let ((up (get-up~ eye-lookat)))
      (gluLookAt
        (vertex-x eye) (vertex-y eye) (vertex-z eye)
        (vertex-x eye-target) (vertex-y eye-target) (vertex-z eye-target)
        (vertex-x up) (vertex-y up) (vertex-z up))))
  
  
  (method (prepare-camera)
    (cond ((find-setting 'world.eye #f)
           (vertex-copy! eye (find-setting 'world.eye #f))
           (vertex-copy! eye-target (find-setting 'world.eye-target #f))
           (vertex-copy! (get-sight~ eye-lookat) (find-setting 'world.eye-sight #f))
           (vertex-copy! (get-up~ eye-lookat) (find-setting 'world.eye-up #f))
           (vertex-copy! (get-right~ eye-lookat) (find-setting 'world.eye-right #f)))
          (start-3d?
           (vertex-init! eye 65. 35. 65.)
           (set-sight~ eye-lookat #f32(-.6717990040779114 -.3334861397743225 -.6614174246788025))
           (set-up~ eye-lookat #f32(-.23764048516750336 .9427545070648193 -.23396790027618408))
           (set-right~ eye-lookat #f32(.7015790343284607 -6.643728678312755e-9 -.7125917077064514)))
          (else
           (vertex-init! eye 0.0 36.25 60.0)
           (standardize!~ eye-lookat))))
  
  
  (method (update-camera)
    (vertex+! eye-target eye (get-sight~ eye-lookat)))
  
  
  (method (get-camera-me)
    (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) camera-distance)))
  
  
  (method (toggle-eye)
    (set! eye? (not eye?)))
  
  
  (method (draw-eye)
    (let ((center (vertex- (vertex- (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) 5.)) (vertex-scalar* (get-right~ eye-lookat) 1.5)) (get-up~ eye-lookat))))
      (let ((sight (vertex+ center (get-sight~ eye-lookat)))
            (up (vertex+ center (get-up~ eye-lookat)))
            (right (vertex+ center (get-right~ eye-lookat)))
            (axis-x (vertex+ center (vertex 1. 0. 0.)))
            (axis-y (vertex+ center (vertex 0. 1. 0.)))
            (axis-z (vertex+ center (vertex 0. 0. 1.))))
        (let ((cx (vertex-x center))
              (cy (vertex-y center))
              (cz (vertex-z center)))
          (glLineWidth 2.)
          (glDisable GL_LIGHTING)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x sight) (vertex-y sight) (vertex-z sight))
          (glEnd)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x right) (vertex-y right) (vertex-z right))
          (glEnd)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x up) (vertex-y up) (vertex-z up))
          (glEnd)
          (gl-colorize {Color Red})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-x) (vertex-y axis-x) (vertex-z axis-x))
          (glEnd)
          (gl-colorize {Color Green})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-y) (vertex-y axis-y) (vertex-z axis-y))
          (glEnd)
          (gl-colorize {Color Blue})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-z) (vertex-y axis-z) (vertex-z axis-z))
          (glEnd)
          (glEnable GL_LIGHTING)
          (glLineWidth 1.)))))

  
  (method (zoom-in)
    (if first-person?
        (first-distance-closer)
      (if (eq? projection 'perspective)
          (let ((me (get-camera-me)))
            (increase! camera-distance (- (zoom-speed)))
            (vertex+! eye me (vertex-scalar* (get-sight~ eye-lookat) (- camera-distance)))
            (update-camera))
        (set! zoom-factor (* zoom-factor .75)))))
  
  
  (method (zoom-out)
    (if first-person?
        (first-distance-further)
      (if (eq? projection 'perspective)
          (let ((me (get-camera-me)))
            (increase! camera-distance (zoom-speed))
            (vertex+! eye me (vertex-scalar* (get-sight~ eye-lookat) (- camera-distance)))
            (update-camera))
        (set! zoom-factor (/ zoom-factor .75)))))
  
  
  (method (zoom-speed)
    10.)
  
  
  (method (change-first-camera)
    (let ((camera (next-element '(locked free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'locked)
        (follow-player))
      (display-message (format "Camera {a}" camera))))
  
  
  (method (follow-player)
    (when first-person?
      (unless (or viewing? (eq? first-camera 'free))
        (camera-behind-player))
      (when me
        (let ((target (player-target me)))
          (vertex-! eye target (vertex-scalar* (get-sight~ eye-lookat) (effective-first-distance)))
          (vertex+! eye-target eye (get-sight~ eye-lookat))
          (let ((counter (find-counter 'camera)))
            (start~ counter)
            (remove-eye-occlusion target)
            (end~ counter))))))
  
  
  (method (camera-behind-player)
    (when (and first-person? me)
      (set-sight~ eye-lookat (get-sight~ (get-lookat~ me)))
      (set-up~ eye-lookat (get-up~ (get-lookat~ me)))
      (set-right~ eye-lookat (get-right~ (get-lookat~ me)))))
  
  
  (method (player-target player)
    (vertex+ (get-position~ player)
             (vertex-scalar* (get-up~ (get-lookat~ player))
                             1.5)))
  
  
  (method (restore-first-distance elapse)
    (when (and first-override (not first-occlusion?))
      (let ((augmented-override (+ first-override (* elapse 100.))))
        (if (>= augmented-override first-distance)
            (set! first-override #f)
          (set! first-override augmented-override)))
      (occlusion-update-eye (player-target me))
      (adjust-player-alpha)))
  
  
  (method (remove-eye-occlusion target)
    (define (determine-eye-occlusion target)
      (let ((closest (ray-closest-element target (vertex-negate (get-sight~ eye-lookat)) first-distance ignore-players?: #t)))
        (if (not closest)
            (values #f #f)
          (bind (element face triangle distance) closest
            (values distance (get-normal~ triangle))))))
    
    (define (closer-eye-occlusion occlusion normal)
      (let ((trend (inner-product (get-sight~ eye-lookat) normal)))
        (if (= trend 0.)
            occlusion
          (- occlusion (/ .1 trend)))))
    
    (receive (occlusion normal) (determine-eye-occlusion target)
      (unless (eqv? occlusion first-override)
        (if (not occlusion)
            (set! first-occlusion? #f)
          (set! first-override (closer-eye-occlusion occlusion normal))
          (set! first-occlusion? #t)
          (occlusion-update-eye target))
        (adjust-player-alpha))))
  
  
  (method (occlusion-update-eye target)
    (vertex-! eye target (vertex-scalar* (get-sight~ eye-lookat) (effective-first-distance)))
    (vertex+! eye-target eye (get-sight~ eye-lookat)))
  
  
  (method (mark-eye target)
    (set-marks~ zone
      (list (new Mark target color: {Color Red})
            (new Mark eye-target color: {Color Green})
            (new Mark eye color: {Color Blue}))))
  
  
  (definition current-area-visit <fx>
    -1)
  
  
  (method (travel-ray-elements proc orig <f32vector> dir <f32vector> radius <fl> breadth <fx> max-distance <fl> (filter: filter #f) (ignore-players?: ignore-players? #f))
    (increase! current-area-visit)
    (let ((step (cast <fl> (get-area-size~ zone))))
      (let ((position (vertex-copy& orig))
            (position-increment (vertex-scalar*& dir step))
            (position-distance 0.))
        (let (iter)
          (or (proc
                (lambda (proc)
                  (iterate-position-neighbor-areas~ zone position breadth
                    (lambda (area <Area>)
                      (unless (= (get-visit~ area) current-area-visit)
                        (iterate-area-elements~ zone area
                          (lambda (targ <Element>)
                            (when (get-visible?~ targ)
                              (unless (and ignore-players? (is? targ Player))
                                (when (ray-intersects-sphere? orig dir (get-position~ targ) (+ radius (get-radius~ targ)))
                                  (proc targ))))))
                        (set-visit~ area current-area-visit))))))
              (let ((new-distance (+ position-distance step)))
                (when (<= new-distance max-distance)
                  (vertex+! position position position-increment)
                  (set! position-distance new-distance)
                  (iter))))))))
  
  
  (method (ray-closest-element orig <f32vector> dir <f32vector> max-distance <fl> (filter: filter #f) (ignore-players?: ignore-players? #f))
    (travel-ray-elements
      (lambda (iterate)
        (let ((closest #f)
              (distance #f))
          (iterate
            (lambda (targ)
              (let ((cls (ray-closest-triangle~ targ orig dir filter)))
                (when cls
                  (bind (face triangle dist) cls
                    (when (and (or (not distance)
                                   (< dist distance))
                               (< dist max-distance))
                      (set! closest (cons targ cls))
                      (set! distance dist)))))))
          closest))
      orig
      dir
      0.
      1
      max-distance
      filter: filter
      ignore-players?: ignore-players?))
  
  
  (method (strafe-camera center-x)
    (let ((eye-x (vertex-x eye)))
      (if (> center-x (+ eye-x camera-limit))
          (strafe-horizontally (- center-x (+ eye-x camera-limit))))
      (if (< center-x (- eye-x camera-limit))
          (strafe-horizontally (- center-x (- eye-x camera-limit))))))
  
  
  (method (camera-center-player)
    (unless paused?
      (case projection
        ((perspective)
         (follow-player))
        ((orthographic)
         (strafe-camera (get-x~ me))))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (effective-first-distance)
    (or first-override first-distance))
  
  
  (method (first-distance-closer)
    (let ((distance (effective-first-distance)))
      (set! first-override #f)
      (set! first-distance (* distance .75))
      (camera-center-player)
      (adjust-player-alpha)))
  
  
  (method (first-distance-further)
    (let ((distance (effective-first-distance)))
      (set! first-override #f)
      (set! first-distance (min (/ distance .75) max-distance))
      (camera-center-player)
      (adjust-player-alpha)))
  
  
  (method (adjust-player-alpha)
    (when me
      (if (contains-vertex?~ me eye)
          (set-alpha~ me 0.)
        (set-alpha~ me (max 0.2 (min 1. (/ (effective-first-distance) 10.)))))))
  
  
  (method (is-moving?)
    moving?)
  
  
  (method (move-player-forward player factor)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* (or (let ((dir (get-direction~ player))) (and dir (not (vertex-zero? dir)) dir)) (get-sight~ (get-lookat~ player))) (* factor (mount-speed))))))
  
  
  (method (move-player-backward player factor)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* (or (let ((dir (get-direction~ player))) (and dir (not (vertex-zero? dir)) dir)) (get-sight~ (get-lookat~ player))) (* factor (mount-speed))))))
  
  
  (method (strafe-player-left player factor)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* (get-right~ (get-lookat~ player)) (* factor (mount-speed))))))
  
  
  (method (strafe-player-right player factor)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* (get-right~ (get-lookat~ player)) (* factor (mount-speed))))))
  
  
  (method (strafe-player-up player factor)
    (strafe-player-vertical player (* (camera-strafe-speed) 2)))
  
  
  (method (strafe-player-down player factor)
    (strafe-player-vertical player (- (* (camera-strafe-speed) 2))))
  
  
  (method (strafe-player-vertical player distance)
    (vertex-copy! eye (vertex+ eye (vertex-scalar* world-up distance)))
    (update-camera)
    (set-y~ player (+ (get-y~ player) distance))
    (follow-player))
  
  
  (definition player-rotation-speed
    0.02)
  
  
  (method (rotate-player-left player factor)
    (rotate-player-horizontal player (* player-rotation-speed factor))
    (when fly?
      (tilt-player player -1.)))
  
  
  (method (rotate-player-right player factor)
    (rotate-player-horizontal player (- (* player-rotation-speed factor)))
    (when fly?
      (tilt-player player 1.)))
  
  
  (method (rotate-player-horizontal player angle (follow-player?: follow-player? #t))
    (let ((lookat (get-lookat~ player)))
      (rotate-lookat! lookat angle world-up))
    (when (eq? player me)
      (unless (and down? (not moving?))
        (rotate-lookat! eye-lookat angle world-up))
      (when follow-player?
        (follow-player))))
  
  
  (method (rotate-player-vertical player angle (follow-player?: follow-player? #t))
    (let ((lookat (get-lookat~ player)))
      (rotate-lookat! lookat angle (get-right~ lookat)))
    (when (eq? player me)
      (rotate-lookat! eye-lookat angle (get-right~ eye-lookat))
      (when follow-player?
        (follow-player))))
  
  
  (method (tilt-player player speed)
    @fix-tilt
    (let ((lookat (get-lookat~ player))
          (max-tilt PI/8)
          (max-speed 0.4))
      (let ((current (vertical-angle (get-right~ lookat) world-up))
            (desired (* (sign speed) max-tilt)))
        (set! desired-tilt desired)
        (set! tilt-speed (min (/ (abs speed) 50000.) max-speed))
        (set! last-tilt-time (time->seconds (current-time)))
        (process-tilt player))))
  
  
  (method (reset-player-tilt player)
    @fix-tilt
    (when (or (not last-tilt-time)
              (> (- (time->seconds (current-time)) last-tilt-time) .1))
      (set! desired-tilt 0.)
      (set! tilt-speed .015)
      (process-tilt player)))
  
  
  (method (process-tilt player)
    @fix-tilt
    (let ((lookat (get-lookat~ player)))
      (let ((current (vertical-angle (get-right~ lookat) world-up)))
        (unless (near? current desired-tilt .001)
          (let ((direction (sign (- desired-tilt current))))
            (let ((new-tilt (+ current (* direction tilt-speed))))
              (case direction
                ((1) (when (> new-tilt desired-tilt) (set! new-tilt desired-tilt)))
                ((-1) (when (< new-tilt desired-tilt) (set! new-tilt desired-tilt))))
              (let ((inc (- new-tilt current)))
                (increase-player-tilt player inc))))))))
  
  
  (method (increase-player-tilt player inc)
    @fix-tilt
    (let ((lookat (get-lookat~ player)))
      (rotate-lookat! lookat inc (get-sight~ lookat))))
  
  
  (method (track-player player dh dv eye-sight eye-up eye-right first?)
    (let ((me? (eq? player me))
          @fix-tilt
          (tilt (vertical-angle eye-right world-up))
          (dh (cast <fl> dh))
          (dv (cast <fl> dv)))
      ;; remove tilt
      @fix-tilt
      (when (and me? (not fly?))
        (rotate-lookat! eye-lookat (- tilt) eye-sight))
      (let ((pitch (vertical-angle eye-sight world-up)))
        ;; remove pitch
        (when (and me? (not fly?))
          (rotate-vertical pitch))
        ;; start from the eye lookat
        (when first?
          (let ((lookat (get-lookat~ player)))
            (set-sight~ lookat eye-sight)
            (set-up~ lookat eye-up)
            (set-right~ lookat eye-right)))
        ;; remove tilt
        @fix-tilt
        (when (and me? fly?)
          (rotate-lookat! eye-lookat (- tilt) eye-sight))
        ;; remove pitch
        (when (and me? fly?)
          (rotate-vertical pitch))
        (rotate-player-horizontal player (/ (- dh) track-sensitivity) follow-player?: #f)
        ;; restore pitch
        (when me?
          (rotate-vertical (- pitch)))
        (if fly?
            (rotate-player-vertical player (/ (- dv) track-sensitivity) follow-player?: #f)
          (when me?
            (rotate-vertical (/ (- dv) track-sensitivity))))
        (when me?
          (follow-player))
        ;; restore tilt
        @fix-tilt
        (when me?
          (rotate-lookat! eye-lookat tilt eye-sight))
        @fix-tilt
        (when (and fly? (/= dh 0.))
          (let ((speed (/ (cast <fl> dh) elapse)))
            (tilt-player player speed))))))
  
  
  (method (toggle-aim)
    (set! aim? (not aim?)))

  
  (method (draw-aim)
    (let ((target (player-target me)))
      (let ((x (vertex-x target))
            (y (vertex-y target))
            (z (vertex-z target))
            (size .25))
        (glDisable GL_DEPTH_TEST)
        (glDisable GL_LIGHTING)
        (glBegin GL_LINES)
        (gl-colorize {Color White})
        (glVertex3f (- x size) y z)
        (glVertex3f (+ x size) y z)
        (glVertex3f x (- y size) z)
        (glVertex3f x (+ y size) z)
        (glVertex3f x y (- z size))
        (glVertex3f x y (+ z size))
        (glEnd)
        (glEnable GL_LIGHTING)
        (glEnable GL_DEPTH_TEST))))
  
  
  ;;;
  ;;;; Resize
  ;;;
  
  
  (method protected virtual (resize-scene)
    (let ((width (fxround width))
          (height (fxround height)))
      (when interface
        (set-size~ interface (new Dimension width height)))
      (resize~ render-target width height)))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method protected virtual (render-world)
    (let ((counter (find-counter 'render)))
      (start~ counter)
      (if post-processing?
          (prepare-render)
        (deactivate~ render-target))
      (prepare-world)
      (unless (get-focus)
        (process-keys))
      (setup-camera)
      (setup-lighting)
      (glEnable GL_DEPTH_TEST)
      (glShadeModel GL_SMOOTH)
      
      (draw-world)
      (render-interface)
      
      (when post-processing?
        (post-render))
      
      (end~ counter)))
  
  
  (method (prepare-world)
    (glClear (bitwise-ior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
    (prepare-projection)
    (glMatrixMode GL_MODELVIEW)
    (glLoadIdentity)
    (glDisable GL_LIGHTING)
    (glDisable GL_LIGHT0)
    (glDisable GL_LIGHT1)
    (glEnable GL_TEXTURE_2D)
    (glEnable GL_BLEND)
    (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA))
  
  
  (method (prepare-render)
    (activate~ render-target)
    (glClear GL_COLOR_BUFFER_BIT)
    (glClear GL_DEPTH_BUFFER_BIT))
  
  
  (method (post-render)
    (deactivate~ render-target)
    (glClearColor 0. 0. 0. 1.)
    (glClear GL_COLOR_BUFFER_BIT)
    (glClear GL_DEPTH_BUFFER_BIT)
    
    ;; Copy the color buffer from the render target onto the native color buffer (0)
    (blit~ render-target 0)
    
    @transfer-render-target-using-shader (
    (glClearColor 0. 0. 0. 1.)
    (glClear GL_COLOR_BUFFER_BIT)
    (glClear GL_DEPTH_BUFFER_BIT)
    
    (activate~ pp-program)
    (glActiveTexture GL_TEXTURE7)
    (glBindTexture GL_TEXTURE_2D (get-texture~ render-target))
    (glUniform1i (get-uniform~ pp-program "fbo_texture") 7)

    (glEnableVertexAttribArray (get-attribute~ pp-program "vertex_coord"))
    
    (glBindBuffer GL_ARRAY_BUFFER (get-vbo/fbo-vertices~ pp-program))
    (glVertexAttribPointer (get-attribute~ pp-program "vertex_coord") 2 GL_FLOAT GL_FALSE 0 #f)
    (glDrawArrays GL_TRIANGLE_STRIP 0 4)
    (glDisableVertexAttribArray (get-attribute~ pp-program "vertex_coord"))
    (deactivate~ pp-program)))
  
  
  (method (draw-world)
    (case projection
      ((perspective)
       (if 3d?
           (glEnable GL_DEPTH_TEST)
         (glDisable GL_DEPTH_TEST)))
      ((orthographic)
       (glDisable GL_DEPTH_TEST)))
    (when (not-null? draw-procedures)
      (for-each (lambda (proc)
                  (proc))
                draw-procedures))
    (draw-zone~ zone)
    (draw-grid)
    (when axes?
      (draw-axes))
    (when (and me aim?)
      (draw-aim))
    (when eye?
      (draw-eye))
    (when paused?
      (draw-history))
    (when draw-atlas?
      (draw-atlas))
    (when target
      (draw-target~ target)
      (draw-editor-target)))
  
  
  (method (draw-neighbors proc)
    (let ((sight (get-sight~ eye-lookat))
          (radius (get-sector-radius~ zone)))
      (iterate-position-neighbor-sectors~ zone eye view-distance
        (lambda (sector)
          ;; cull sectors that are behind the camera
          (when (<= (inner-product (vertex- eye (get-center~ sector)) sight)
                    radius)
            (proc sector))))))
  
  
  (method (draw-sectors)
    (use~ tile-program)
    (bind-uniforms~ tile-program tile-mesh tile-matrix)
    (draw-neighbors draw-sector)
    (unbind-uniforms~ tile-program)
    (unuse~ tile-program))
  
  
  (method (draw-sector sector)
    (update-content~ sector)
    (update-vertices~ sector)
    (update-lightmap~ sector)
    (let ((mesh (get-mesh~ sector)))
      (unless (empty?~ mesh)
        (draw-mesh~ tile-program mesh))))
  
  
  (method (draw-wireframe)
    (draw-neighbors
      (lambda (sector)
        (let ((content (get-vertices-content~ sector)))
          (when content
            (draw-triangles content mode: GL_LINE_LOOP))))))
  
  
  (method (draw-triangles content (mode: mode GL_TRIANGLES))
    (gl-colorize {Color Orange})
    (glLineWidth 2.)
    (glDisable GL_LIGHTING)
    (render-triangles content (f32vector-length content) mode)
    (glEnable GL_LIGHTING)
    (glLineWidth 1.))
  
  
  (method (draw-axes)
    (glLineWidth 5.)
    (glDisable GL_LIGHTING)
    (glBegin GL_LINES)
    ;; X
    (glColor3f 1.0 0.0 0.0)
    (glVertex3f -50.0  0.0  0.0)
    (glVertex3f  50.0  0.0  0.0)
    (glVertex3f  50.0  0.0  0.0)
    (glVertex3f  47.5  0.0  2.5)
    (glVertex3f  50.0  0.0  0.0)
    (glVertex3f  47.5  0.0 -2.5)
    
    ;; Y
    (glColor3f 0.0 1.0 0.0)
    (glVertex3f  0.0 -50.0  0.0)
    (glVertex3f  0.0  50.0  0.0)
    (glVertex3f  0.0  50.0  0.0)
    (glVertex3f  2.5  47.5  0.0)
    (glVertex3f  0.0  50.0  0.0)
    (glVertex3f -2.5  47.5  0.0)
    
    ;; Z
    (glColor3f 0.0 0.0 1.0)
    (glVertex3f  0.0  0.0 -50.0)
    (glVertex3f  0.0  0.0  50.0)
    (glVertex3f  0.0  0.0  50.0)
    (glVertex3f  2.5  0.0  47.5)
    (glVertex3f  0.0  0.0  50.0)
    (glVertex3f -2.5  0.0  47.5)
    (glEnd)
    
    (glLineWidth 1.)
    
    (when (find-setting 'world.axes-graduation? #f)
      (glBegin GL_LINES)
      ;; X
      (glColor3f 1.0 0.0 0.0)
      (loop (for x <fl> from -49. to 49. by 1.)
            (glVertex3f   x  0.0 -0.25)
            (glVertex3f   x  0.0  0.25))
      
      ;; Y
      (glColor3f 0.0 1.0 0.0)
      (loop (for y <fl> from -49. to 49. by 1.)
            (glVertex3f  -0.25  y 0.0)
            (glVertex3f   0.25  y 0.0))
      
      ;; Z
      (glColor3f 0.0 0.0 1.0)
      (loop (for z <fl> from -49. to 49. by 1.)
            (glVertex3f   -0.25 0.0 z)
            (glVertex3f   0.25  0.0 z))
      (glEnd))
    
    (glEnable GL_LIGHTING))
  
  
  (method (draw-grid)
    (when grid?
      (glDisable GL_LIGHTING)
      (case grid-plane
        ((x)
         (let ((min -500.)
               (max 500.))
           (gl-colorize {Color Yellow})
           (glBegin GL_LINES)
           (loop (for y <fl> from min to max by 5.)
                 (glVertex3f grid-position y min)
                 (glVertex3f grid-position y max))
           (loop (for z <fl> from min to max by 5.)
                 (glVertex3f grid-position min z)
                 (glVertex3f grid-position max z))
           (glEnd)))
        ((y)
         (let ((min -500.)
               (max 500.))
           (gl-colorize {Color Green})
           (glBegin GL_LINES)
           (loop (for x <fl> from min to max by 5.)
                 (glVertex3f x grid-position min)
                 (glVertex3f x grid-position max))
           (loop (for z <fl> from min to max by 5.)
                 (glVertex3f min grid-position z)
                 (glVertex3f max grid-position z))
           (glEnd)))
        ((z)
         (let ((min -500.)
               (max 500.))
           (gl-colorize {Color Red})
           (glBegin GL_LINES)
           (loop (for x <fl> from min to max by 5.)
                 (glVertex3f x min grid-position)
                 (glVertex3f x max grid-position))
           (loop (for y <fl> from min to max by 5.)
                 (glVertex3f min y grid-position)
                 (glVertex3f max y grid-position))
           (glEnd))))
      (glEnable GL_LIGHTING)))
  
  
  (method (draw-history)
    (draw-history~ history draw-moment))
  
  
  (method (draw-moment n)
    (let ((snapshot (get-snapshot~ (historical-moment n))))
      (for-each (lambda (player)
                  (parameterize ((in-history? #t))
                    (draw~ player)))
                (get-actors~ snapshot))))
  
  
  (method (register-draw proc)
    (set! draw-procedures (cons proc draw-procedures)))
  
  
  (method (unregister-draw proc)
    (set! draw-procedures (remove! proc draw-procedures)))
  
  
  ;;;
  ;;;; Lighting
  ;;;
  
  
  (method (setup-lighting)
    (setup-lighting~ zone))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method (render-interface)
    (when interface?
      (glDisable GL_LIGHTING)
      (glMatrixMode GL_MODELVIEW)
      (glLoadIdentity)
      (glMatrixMode GL_PROJECTION)
      (glEnable GL_BLEND)
      (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
      (glPushMatrix)
      (glLoadIdentity)
      (glOrtho 0.0 width 0.0 height -10.0 10.0)
      (draw-interface)
      (glPopMatrix)
      (glEnable GL_LIGHTING)))
  
  
  (method (draw-interface)
    (when (or (get-visible?~ (child~ interface 'info))
              (get-visible?~ (child~ interface 'counters)))
      (invalidate-view~ interface))
    (draw-interface~ interface)
    (when message
      (draw-message))
    (when status
      (draw-status))
    (when (and history? paused?)
      (draw-history-slider))
    @debug-activation
    (when (get-active?~ (get-application))
      (let ((width (fxround (get-width~ world))))
        (let ((h (- width 20))
              (v 20))
          (gl-segment-circle (new Point h v) 7 {Color Light-Blue} 100)))))
  
  
  (method (draw-history-slider)
    (draw-history-slider~ history))
  
  
  (method (explore-interface)
    (set! explore-interface? (not explore-interface?))
    (cursor-update))
  
  
  (method (main-menu)
    (let ((pane (find-if (lambda (pane) (is? pane World-Popup)) (get-children~ interface) reversed?: #t)))
      (if pane
          (close~ pane)
        (open-menu (new World-Main-Menu visible?: #t)))))
  
  
  (method (video-options)
    (open-frame (new World-Video-Options size: {Dimension 366 588} location: 'center)))
  
  
  (method (audio-options)
    (open-frame (new World-Audio-Options size: {Dimension 366 588} location: 'center)))
  
  
  (method (interface-options)
    (open-frame (new World-Interface-Options size: {Dimension 366 588} location: 'center)))
  
  
  (method (view-bindings)
    (open-frame (new World-Bindings-Viewer size: {Dimension 366 588} location: 'center)))
  
  
  (method (view-news)
    (open-document (world-file '("devel" "world" "News.ftx")) class: World-Formatted-Text-View))
  
  
  (method (view-roadmap)
    (open-document (world-file '("devel" "world" "Roadmap.ftx")) class: World-Formatted-Text-View))
  
  
  (method (view-help)
    (open-document (world-file '("devel" "world" "Help.ftx")) class: World-Formatted-Text-View))
  
  
  (method (close-current-popup)
    (let ((pane (find-if (lambda (pane) (is? pane World-Popup)) (get-children~ interface) reversed?: #t)))
      (when pane
        (close~ pane))))
  
  
  ;;;
  ;;;; Atlas
  ;;;
  
  
  (method (draw-atlas)
    (let ((texture (get-texture~ (if (is? % Entity)
                                     (get-material~ (get-mesh~ (get-model~ %)))
                                   texture-atlas)))
          (width 100.)
          (height 100.))
      (map-texture~ texture)
      (textured-quad~ texture
        (lambda () (glVertex3f 0.0 0.0 0.0))
        (lambda () (glVertex3f width 0.0 0.0))
        (lambda () (glVertex3f width height 0.0))
        (lambda () (glVertex3f 0.0 height 0.0)))))
  
  
  ;;;
  ;;;; Win / Lose
  ;;;
  
  
  (method (win player)
    (win~ player)
    (let ((block (find-element~ zone
                   (lambda (obj)
                     (and (is? obj Block)
                          (eq? (get-user-data~ obj) 'win))))))
      (set-color~ block {Color Blue}))
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (lose player)
    (lose~ player)
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (reset-game)
    (setup-history))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method (missile-hit missile element)
    (if (is? element Actor)
        (begin
          (wound~ element)
          'remove)
      (case (or (get-hit-behavior~ element) (get-missile-behavior~ zone))
        ((absorb)
         'remove)
        @convert
        ((rebound)
         (let ((velocity (get-velocity~ missile)))
           (case axis
             ((x) (vertex-x-set! velocity (- (vertex-x velocity))))
             ((y) (vertex-y-set! velocity (- (vertex-y velocity))))
             ((z) (vertex-z-set! velocity (- (vertex-z velocity))))))
         'stop)
        ((slide)
         'slide)
        ((destroy)
         (play-sound-file "sound/explosion")
         (editor-remove-element element)
         'remove))))
  
  
  (method (change-missile-behavior)
    (unimplemented-connected)
    (set-missile-behavior~ zone (next-element '(destroy absorb rebound slide) (get-missile-behavior~ zone)))
    (display-message (format "{a}" (get-missile-behavior~ zone))))

  
  ;;;
  ;;;; World
  ;;;

  
  (method (world-new)
    (unimplemented-connected)
    (new-world)
    (display-message "New world"))
  
  
  (method (world-open)
    (unimplemented-connected)
    (let ((pane (find-type~ interface World-Open)))
      (if pane
          (close~ pane)
        (open-frame (new World-Open size: {Dimension 366 588} location: 'center)))))
  
  
  (method (world-save)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (world-save-to moniker)
        (world-save-as))))
  
  
  (method (world-save-as)
    (unimplemented-connected)
    @convert
    (let ((file (choose-new-file title: "Save New World" default-extension: "world" extensions: '(("World Files" . "world")) directory: {Directory Settings "worlds"})))
      (world-save-to file)
      (update-title)))
  
  
  (method (world-save-to file)
    (unimplemented-connected)
    (parameterize ((pretty-print-forms? #f))
      (save-to~ designer file))
    (display-message "Saved"))
  
  
  (method (world-revert)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (open-world moniker)
        (bell))))
  
  
  (method (get-world-directory)
    (let ((moniker (get-moniker)))
      (when moniker
        (get-parent~ moniker))))
  
  
  (method (update-title)
    (define (present-zone)
      (if (not zone)
          "New"
        (present-title (get-moniker~ zone) (get-modified?~ zone))))
    
    (define (present-title moniker modified?)
      (format "{a}{a}"
              (present-name moniker)
              (present-modified modified?)))
    
    (define (present-name moniker)
      (if (not moniker)
          "New"
        (get-name~ moniker)))
    
    (define (present-modified modified?)
      (if modified?
          " *"
        ""))
      
    (define (present-directory moniker)
        (if (not moniker)
            ""
          (let ((parent (get-world-directory)))
            (if (not parent)
                ""
              (format " ~{{a}}" (present-location~ parent))))))
    
    (set-title~ window (format "World - {a} {a}"
                               (present-zone)
                               (present-directory (get-moniker)))))
  
  
  (method (get-moniker)
    (get-origin~ (get-form~ designer)))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (when (neq? flag (get-modified?~ designer))
      (set-modified?~ designer flag)
      (update-title)))
  
  
  ;;;
  ;;;; Zone
  ;;;

  
  (method (zone-new)
    (unimplemented-connected)
    (new-zone)
    (display-message "New zone"))
  
  
  (method (zone-open)
    (unimplemented-connected)
    (let ((pane (find-type~ interface Zone-Open)))
      (if pane
          (close~ pane)
        (open-frame (new Zone-Open size: {Dimension 366 588} location: 'center)))))
  
  
  (method (zone-save)
    (unimplemented-connected)
    (let ((moniker (get-moniker~ zone)))
      (if moniker
          (zone-save-to moniker)
        (zone-save-as))))
  
  
  (method (zone-save-as)
    (unimplemented-connected)
    (let ((directory (or (get-world-directory)
                         (let ((dir {Directory Settings "worlds" "user"}))
                           (if (exists?~ dir)
                               dir
                             (create-directories~ dir)
                             (world-save-to (new-file~ dir "_user.world"))
                             dir)))))
      (open-string
        title: "Choose New Zone"
        prefix: "Zone:"
        initial-value: "new"
        action: (lambda (base)
                  (let ((file (new-file~ directory (list "zones" (make-filename base "zone")))))
                    (create-directories~ file)
                    (zone-save-to file)
                    (update-title))))))
  
  
  (method (zone-save-to file)
    (unimplemented-connected)
    (let ((designer (get-designer~ zone)))
      (parameterize ((pretty-print-forms? #f))
        (save-to~ designer file))
      (display-message "Saved")))
  
  
  (method (save-player)
    (unimplemented-connected)
    (if (not me)
        (bell)
      (let ((designer (get-designer~ zone)))
        (set-property~ designer zone 'start-position (get-position~ me))
        (let ((lookat (get-lookat~ me)))
          (set-property~ designer zone 'start-sight (get-sight~ lookat))
          (set-property~ designer zone 'start-up (get-up~ lookat)))
        (zone-save)
        (display-message "Player saved"))))
  
  
  (method (zone-revert)
    (define (revert)
      (let ((moniker (get-moniker~ zone)))
        (if moniker
            (begin
              (initialize-camera)
              (setup-history)
              (open-zone moniker))
          (bell))))
    
    (unimplemented-connected)
    (if (not (find-setting 'world.confirmation-dialogs? #t))
        (revert)
      (open-message "Revert to saved and lose changes?"
                    caption: "Revert"
                    type: 'question
                    yes: "Yes"
                    no: "No"
                    execute: (lambda (evt)
                               (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog))
                                     (button (get-property~ evt button:)))
                                 (close~ dialog)
                                 (case button
                                   ((yes)
                                    (revert))))))))
  
  
  ;;;
  ;;;; Mount
  ;;;
  
  
  (method (change-ground-mount (reversed?: reversed? #f))
    (when (and first-person? (not paused?))
      (unimplemented-connected)
      (let ((next (if reversed? previous-element next-element)))
        (let ((new-class (next (get-list~ ground-mounts-folio) (get-class~ ground-mounts-folio))))
          (set-class~ ground-mounts-folio new-class)
          (activate-mount new-class)))))
  
  
  (method (activate-mount mnt)
    (set! mount mnt)
    (if (eq? mount 'carpet)
        (activate-fly)
      (deactivate-fly)))
  
  
  (method (mount-speed)
    (case mount
      ((carpet) 1.5)
      ((weels) 1.0)
      (else 0.5)))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot designer         <object> initialize #f  accessors generate)
  (slot edition?         <bool>   initialize #f  getter generate)
  (slot editor-mode      <object> initialize #f  getter generate)
  (slot editor-anchor    <object> initialize #f  getter generate)
  (slot editor-last      <object> initialize #f  getter generate)
  (slot editor-added     <object> initialize #f  getter generate)
  (slot editor-normal    <object> initialize #f  getter generate)
  (slot editor-from      <object> initialize #f  getter generate)
  (slot editor-floor?    <object> initialize #f  getter generate)
  (slot editing?         <bool>   initialize #f  getter generate)
  (slot adding?          <bool>   initialize #f  getter generate)
  (slot deleting?        <bool>   initialize #f  getter generate)
  (slot element-template <object> initialize #f  getter generate)
  (slot brush-mode?      <bool>   initialize #f  getter generate)
  (slot brush            <object> initialize #f  getter generate)
  (slot grid?            <bool>   initialize #f  getter generate)
  (slot grid-plane       <symbol> initialize 'y  getter generate)
  (slot grid-position    <fl>     initialize 0.  getter generate)
  (slot last-added       <object> initialize #f  getter generate)
  (slot players-folio    <Folio>                 getter generate)
  (slot enemies-folio    <Folio>                 getter generate)
  (slot tiles-folio      <Folio>                 getter generate)
  (slot entities-folio   <Folio>                 getter generate)
  
  
  (method (prepare-editor)
    (set! editor-mode 'block)
    (set! players-folio (new Folio 'player '(player pacman)))
    (set! enemies-folio (new Folio 'wolf '(wolf spider turtle)))
    (set! tiles-folio (new Folio 'block '(block triangle quad)))
    (set! entities-folio (new Folio 'light-point '(light-point light-ambien light-directional pyramid cube sphere gravity template))))
  
  
  (method (change-editor-mode (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          ;; disable non-functional modes in multi-player
          (available-modes '(block column free @comment crazy @comment point @comment rectangle)))
      (let ((new-mode (next available-modes editor-mode)))
        (set! editor-mode new-mode)
        (display-message (capitalize (->string new-mode))))))
  
  
  (method (change-target-mode (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          (available-modes '(select translate rotate scale)))
      (let ((new-mode (next available-modes target-mode)))
        (set! target-mode new-mode)
        (display-message (capitalize (->string new-mode))))))
  
  
  (method (set-element-template)
    (if (not target)
        (begin
          (bell)
          (display-error "No target selected"))
      (set! element-template target)
      (display-message "Element template set")))
  
  
  (method (unset-element-template)
    (set! element-template #f)
    (display-message "Element template unset"))
  
  
  (method (select-brush)
    (if (not target-face)
        (begin
          (bell)
          (display-error "No face selected"))
      (set! brush-mode? #t)
      (set! brush (or (get-texture~ target-face) default-image))
      (display-message "Brush set")))
  
  
  (method (toggle-brush-mode)
    (set! brush-mode? (not brush-mode?))
    (display-on/off "Brush mode" brush-mode?))
  
  
  (method (add-element-class class x y z)
    (define (add class/new (properties '()) (setup #f))
      (let ((properties (append (list x: x y: y z: z) properties)))
        (let ((obj (if (procedure? class/new) (class/new) (apply new class/new parent: zone properties))))
          (if (is? obj Player)
              (set-name~ obj (effective-player-name~ (get-application)))
            (add-child~ (get-designer~ zone) obj zone import: '(world.data) properties: properties))
          (add-element~ zone obj)
          (when setup
            (setup obj))
          obj)))
    
    (define (add-triangle)
      (add Triangle-Tile (list
                           v1: (vertex x (+ y 5.) z)
                           v2: (vertex (- x 2.5) y z)
                           v3: (vertex (+ x 2.5) y z))))
    
    (define (add-quad)
      (add Quad-Tile (list
                       v1: (vertex (- x 2.5) y z)
                       v2: (vertex (+ x 2.5) y z)
                       v3: (vertex (+ x 2.5) (+ y 5.) z)
                       v4: (vertex (- x 2.5) (+ y 5.) z))))
    
    (define (add-sphere)
      (add Sphere (list radius: 2.5)))
    
    (define (add-template)
      (add (lambda ()
             (new-template x y z))
           '()
           set-template-properties))
    
    (let ((element
            (case class
              ((player) (add Player))
              ((pacman) (add Pacman))
              ((turtle) (add Turtle))
              ((wolf) (add Wolf))
              ((spider) (add Spider))
              ((block) (add Block))
              ((triangle) (add-triangle))
              ((quad) (add-quad))
              ((light-point) (add Light-Point))
              ((light-ambien) (add Light-Ambient))
              ((light-directional) (add Light-Directional))
              ((pyramid) (add Pyramid))
              ((cube) (add Cube))
              ((sphere) (add-sphere))
              ((gravity) (add Gravity))
              ((template) (add-template)))))
      (when (is? element Gadget)
        (set! draw-gadgets? #t)
        (update-gadgets))
      element))
  
  
  (method (editor-add-element mode class vert (force?: force? #f))
    (define (sign r)
      (if (< r 0)
          -1
        1))
    
    (define (sign-test sign)
      (if (= sign -1)
          >=
        <=))
    
    (define (add-at left bottom back)
      (let ((element (add-element-class class left bottom back))
            (designer (get-designer~ zone)))
        (cond ((is? element Player)
               (set-x~ element (+ (get-x~ element) (get-radius-x~ element)))
               (set-y~ element (+ (get-y~ element) (get-radius-y~ element)))
               (set-z~ element (+ (get-z~ element) (get-radius-z~ element))))
              (else
               (set-property~ designer element 'x (+ (get-x~ element) (get-radius-x~ element)))
               (set-property~ designer element 'y (+ (get-y~ element) (get-radius-y~ element)))
               (set-property~ designer element 'z (+ (get-z~ element) (get-radius-z~ element)))))
        (update-position~ element)
        (copy-template element)
        (when (and (is? element Player) (not (get-world-server~ (get-process))))
          (let ((preserved-lookat (and me (get-lookat~ me))))
            (when me
              (remove-element me))
            (when (server-side?~ (get-process))
              (set-color~ element {Color White}))
            (set-me element)
            (when preserved-lookat
              (set-lookat~ me preserved-lookat))))
        (when (eq? element me)
          (camera-behind-player)
          (follow-player))
        element))
    
    (define (copy-template element)
      (let ((designer (get-designer~ zone)))
        (cond ((and (is? element Block) (is? element-template Block))
               (set-property~ designer element 'front-image (get-front-image~ element-template))
               (set-property~ designer element 'back-image (get-back-image~ element-template))
               (set-property~ designer element 'left-image (get-left-image~ element-template))
               (set-property~ designer element 'right-image (get-right-image~ element-template))
               (set-property~ designer element 'top-image (get-top-image~ element-template))
               (set-property~ designer element 'bottom-image (get-bottom-image~ element-template)))
              ((and (is? element Light) (is? element-template Light))
               (set-property~ designer element 'color (get-color~ element-template))
               (set-property~ designer element 'ambient-color (get-ambient-color~ element-template))
               (set-property~ designer element 'quadratic-attenuation (get-quadratic-attenuation~ element-template)))
              ((and (is? element Gravity) (is? element-template Gravity))
               (set-property~ designer element 'pull (get-pull~ element-template))))))
    
    (let ((to-x (* (floor (/ (vertex-x vert) 5.)) 5.))
          (to-y (* (floor (/ (vertex-y vert) 5.)) 5.))
          (to-z (* (floor (/ (vertex-z vert) 5.)) 5.)))
      (if (not editor-anchor)
          (let ((element (add-at to-x to-y to-z)))
            (set! last-added element)
            (set! editor-anchor (vertex to-x to-y to-z))
            element)
        (unless (and editor-last
                     (= (vertex-x editor-last) to-x)
                     (= (vertex-y editor-last) to-y)
                     (= (vertex-z editor-last) to-z)
                     (not force?))
          (case mode
            ((block column free crazy)
             (let ((actual (vertex->element~ zone vert)))
               (unless actual
                 (let ((element (add-at to-x to-y to-z)))
                   (set! last-added element)
                   (set! editor-added (list element))
                   (set! editor-last (vertex to-x to-y to-z))
                   element))))
            ((point)
             (let ((vert (vertex to-x to-y to-z)))
               (let ((actual (vertex->element~ zone vert)))
                 (unless actual
                   (let ((element (add-at to-x to-y to-z)))
                     (set! last-added element)
                     (set! editor-added (list element))
                     (set! editor-last (vertex to-x to-y to-z))
                     element)))))
            ((line))
            ((rectangle)
             (let ((anchor-x (vertex-x editor-anchor))
                   (anchor-y (vertex-y editor-anchor))
                   (anchor-z (vertex-z editor-anchor))
                   (last-x (vertex-x editor-last))
                   (last-y (vertex-y editor-last))
                   (last-z (vertex-z editor-last)))
               (let ((sign-x (sign (- to-x anchor-x)))
                     (sign-y (sign (- to-y anchor-y)))
                     (sign-z (sign (- to-z anchor-z))))
                 (let ((step-x (* sign-x 5.))
                       (step-y (* sign-y 5.))
                       (step-z (* sign-z 5.))
                       (test-x (sign-test sign-x))
                       (test-y (sign-test sign-y))
                       (test-z (sign-test sign-z)))
                   (let ((queue (new-queue))
                         (max-size 30))
                     (let (iter-x (x anchor-x) (count-x 0))
                       (when (and (< count-x max-size)
                                  (test-x x to-x))
                         (let (iter-y (y anchor-y) (count-y 0))
                           (when (and (< count-y max-size)
                                      (test-y y to-y))
                             (let (iter-z (z anchor-z) (count-z 0))
                               (when (and (< count-z max-size)
                                          (test-z z to-z))
                                 (let ((actual (vertex->element~ zone (vertex x y z))))
                                   (if actual
                                       (when (is? actual Tile)
                                         (enqueue queue actual))
                                     (let ((element (add-at x y z)))
                                       (enqueue queue element))))
                                 (iter-z (+ z step-z) (+ count-z 1))))
                             (iter-y (+ y step-y) (+ count-y 1))))
                         (iter-x (+ x step-x) (+ count-x 1))))
                     (let ((added (queue-list queue)))
                       (when editor-added
                         (for-each editor-remove-element (difference editor-added added)))
                       (set! editor-added added)
                       (set! editor-last (vertex to-x to-y to-z)))))))))))))
  
  
  (method (editor-element-class)
    (let ((alt? (alt-down?))
          (shift? (shift-down?)))
      (cond ((and alt? shift?) (get-class~ players-folio))
            (shift? (get-class~ enemies-folio))
            (alt? (get-class~ entities-folio))
            (else (get-class~ tiles-folio)))))
  
  
  (method (element-folio element)
    (typecase element
      ((Player) players-folio)
      ((Enemy) enemies-folio)
      ((Tile) tiles-folio)
      (else entities-folio)))
  
  
  (method (change-element-class (reversed?: reversed? #f))
    (if (not last-added)
        (bell)
      (let ((folio (element-folio last-added)))
        (let ((new-class ((if reversed? previous-element next-element) (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)
          (display-message (format "{a}" new-class))))))
  
  
  (method (change-class element class)
    (let ((vert (vertex (get-x~ element) (get-y~ element) (get-z~ element))))
      (editor-remove-element element)
      (editor-add-element editor-mode class vert force?: #t)))
  
  
  (method (remove-target)
    (cond ((not target)
           (bell))
          ((or paused? (not me))
           (editor-delete (get-position~ target)))
          (else
           (add-action~ commands 'delete (list (get-position~ target))))))
  
  
  (method (remove-element obj)
    (remove-element~ zone obj)
    (when (eq? obj target)
      (set-target #f)))
  
  
  (method (editor-remove-element obj)
    (let ((designer (get-designer~ zone)))
      (remove-child~ designer obj)
      (remove-element obj)))
  
  
  (method (find-mesh-program name)
    (or (table-ref mesh-programs name #f)
        (error "Unknown mesh program: {s}" name)))
  
  
  (method (change-tile-program (reversed?: reversed? #f))
    (let ((folio tile-program-folio)
          (next (if reversed? previous-element next-element)))
      (let ((new-program (next (get-list~ folio) (get-class~ folio))))
        (set-class~ folio new-program)
        (set! tile-program (find-mesh-program new-program))
        (display-message (format "{a}" new-program)))))
  
  
  (method (collect-textures)
    (define (add-files dir queue)
      (when (exists?~ dir)
        (iterate-directory~ dir
          (lambda (file)
            (when (extension=? (get-extension~ file) "png")
              (enqueue queue file)))
          files?: #t
          directories?: #f)))
    
    (when (not textures)
      (let ((queue (new-queue)))
        (for-each (lambda (assets)
                    (add-files (new-directory~ assets "tile") queue))
                  all-assets)
        (set! textures (map make-file-texture (sort di<? (queue-list queue) key: get-base~)))))
    textures)
  
  
  (method (reload-textures)
    (set! textures #f))
  
  
  (method (find-texture name)
    (find-if (lambda (texture)
               (let ((file (get-file~ texture)))
                 (and file (filename=? (get-name~ file) name))))
             (collect-textures)))
  
  
  (method (change-tile-texture (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element)))
      (if (is? target Sphere)
          (let ((mesh (get-mesh~ (get-model~ target))))
            (let ((texture (next (collect-textures) (get-texture~ (get-material~ mesh)))))
              (set-texture~ (get-material~ mesh) texture)
              (display-message (format "{a}" (get-name~ (get-file~ texture))))))
        (let ((mesh tile-mesh))
          (let ((image (next (image-names~ texture-atlas) default-image)))
            (set! default-image image)
            (iterate-sectors-with-tiles~ zone
              (lambda (index sector)
                (for-each reset-faces~ (get-tiles~ sector))
                (set-vertices-uptodate?~ sector #f)))
            (display-message (format "{a}" image)))))))
  
  
  (method (change-texture (reversed?: reversed? #f))
    (if (not target-face)
        (display-error "No face selected")
      (let ((next (if reversed? previous-element next-element)))
        (let ((texture (next (image-names~ texture-atlas) (get-texture~ target-face) test: equal?)))
          (set-face-texture target target-face texture)
          (display-message (format "{a}" texture))))))
  
  
  (method (set-face-texture element face texture)
    (let ((target-face? (eq? face target-face)))
      (let ((face (update-face-texture~ element face texture)))
        (when target-face?
          (set! target-face face))))
    (let ((sector (element-sector~ zone element)))
      (set-vertices-uptodate?~ sector #f)
      (invalidate-lightmaps~ zone element)))
  
  
  (method (find-model name (error?: error? #t))
    (define (search-assets)
      (let (iter (scan all-assets))
        (if (null? scan)
            #f
          (let ((assets (car scan)))
            (or (search-in (new-directory~ assets "model"))
                (iter (cdr scan)))))))
    
    (define (search-in models-dir)
      (when (exists?~ models-dir)
        (let ((dir (new-directory~ models-dir name)))
          (when (exists?~ dir)
            (let ((ms3d (new-file~ dir (make-filename (get-name~ dir) "ms3d"))))
              (if (exists?~ ms3d)
                  (make-ms3d ms3d)
                (let ((obj (new-file~ dir (make-filename (get-name~ dir) "obj"))))
                  (if (exists?~ obj)
                      (make-obj obj)
                    #f))))))))
    
    (define (make-ms3d ms3d)
      (load-ms3d ms3d))
    
    (define (make-obj obj)
      (let ((png (new-brother~ obj (make-filename (get-base~ obj) "png"))))
        (assert (exists?~ png)
          (load-obj obj (make-file-texture png)))))
    
    (or (table-ref models name #f)
        (let ((model (search-assets)))
          (if (not model)
              (if error?
                  (error "Unable to find model: {a}" name)
                #f)
            (table-set! models name model)
            model))))
  
  
  (method (toggle-grid)
    (set! grid? (not grid?))
    (activate-3d))
  
  
  (method (toggle-grid-plane plane)
    (if (and grid? (eq? grid-plane plane))
        (set! grid? #f)
      (set! grid? #t)
      (set! grid-plane plane)
      (activate-3d)))
  
  
  (method (decrease-grid)
    (move-grid-by -1))
  
  
  (method (increase-grid)
    (move-grid-by 1))
  
  
  (method (move-grid delta)
    (move-grid-by (fxround/ (- delta) 120)))
  
  
  (method (move-grid-by incr)
    (let ((dist (* incr 5.)))
     (increase! grid-position dist)
     (display-status (format "Grid at {a}" grid-position))))
  
  
  (method (editor-add-at mode vert)
    (let ((class (editor-element-class)))
      (let ((element (editor-add-element mode class vert)))
        (set-modified? #t)
        (update-future)
        element)))
  
  
  (method (editor-add-block mode grid? grid-plane grid-position eye direction first?)
    (define (determine-filter)
      (when (not first?)
        (case mode
          ((block) (block-filter))
          ((column) column-filter)
          ((free) free-filter)
          ((crazy) #f))))
    
    (define (block-filter)
      (let ((accessor (and editor-normal
                           (cond ((/= (vertex-x editor-normal) 0.) vertex-x)
                                 ((/= (vertex-y editor-normal) 0.) vertex-y)
                                 ((/= (vertex-z editor-normal) 0.) vertex-z)))))
        (lambda (element normal)
          (and editor-normal
               (vertex=? normal editor-normal)
               (or (not editor-from)
                   (= (accessor (get-position~ element)) (accessor editor-from)))))))
    
    (define (column-filter element normal)
      (and (vertex=? normal editor-normal)
           editor-from
           (let ((center (get-position~ element)))
             (or (vertex=? center editor-from)
                 (vertex=? (vertex-normalize (vertex- center editor-from)) editor-normal)))))
    
    (define (free-filter element normal)
      (vertex=? normal editor-normal))
    
    (define (add-block vert element normal)
      (unless (vertex->element~ zone vert)
        (let ((added (editor-add-at mode vert)))
          (when first?
            (set! editor-normal normal)
            (set! editor-from (if element
                                  (get-position~ element)
                                (vertex+ (get-position~ added) (vertex-scalar* normal -5.))))
            (set! editor-floor? (boolean (not element)))))))
    
    (let ((closest (ray-closest-element eye direction (get-radius~ zone) filter: (determine-filter) ignore-players?: #t)))
      (if closest
          (bind (element face triangle distance) closest
            (if (and brush-mode? brush)
                (let ((normal (get-normal~ triangle)))
                  (set-face-texture element face brush)
                  (set! editor-normal normal))
              (let ((normal (get-normal~ triangle)))
                (add-block (vertex+ (get-position~ element) (vertex-scalar* normal 5.)) element normal))))
        (when (or first? (memq? mode '(free crazy)) (and editor-floor? (neq? mode 'column)))
          (let ((vert (ray-plane-intersection eye direction grid? grid-plane grid-position floor-grid?: #t)))
            (when vert
              (let ((actual (vertex->element~ zone vert)))
                (unless actual
                  (add-block vert #f world-up)))))))))
  
  
  (method (editor-edit mode grid? grid-plane grid-position eye direction stage)
    (case stage
      ((down)
       (if (memq? mode '(block column free crazy))
           (editor-add-block mode grid? grid-plane grid-position eye direction #t)
         (let ((vert (ray-plane-intersection eye direction grid? grid-plane grid-position)))
           (if (not vert)
               (begin
                 (unless grid?
                   (display-error "3d edition requires a grid"))
                 (bell))
             (let ((obj (vertex->element~ zone vert)))
               (cond (obj
                      (show-cursor)
                      (set! preserved-mouse #f)
                      (set! editor-anchor #f)
                      (set! editor-last #f)
                      (set! deleting? #t)
                      (editor-remove-element obj)
                      (set-modified? #t)
                      (update-future))
                     (else
                      (show-cursor)
                      (set! preserved-mouse #f)
                      (set! editor-anchor #f)
                      (set! editor-last #f)
                      (set! adding? #t)
                      (editor-add-at mode vert)
                      (update-future))))))))
      ((move)
       (if (memq? mode '(block column free crazy))
           (editor-add-block mode grid? grid-plane grid-position eye direction #f)
         (let ((vert (ray-plane-intersection eye direction grid? grid-plane grid-position)))
           (when vert
             (let ((obj (vertex->element~ zone vert)))
               (cond (obj
                      (if (and adding? (eq? mode 'rectangle))
                          (let ((class (editor-element-class)))
                            (editor-add-element mode class vert)
                            (set-modified? #t)
                            (update-future))
                        (when deleting?
                          (editor-remove-element obj)
                          (set-modified? #t)
                          (update-future))))
                     (else
                      (when adding?
                        (let ((class (editor-element-class)))
                          (editor-add-element mode class vert)
                          (set-modified? #t))
                        (update-future)))))))))
      ((up)
       (set! editing? #f)
       (set! adding? #f)
       (set! deleting? #f)
       (set! editor-normal #f)
       (set! editor-from #f)
       (set! editor-floor? #f))))
  
  
  (method (editor-delete position)
    (let ((element (element-at~ zone position)))
      (when element
        (editor-remove-element element)
        (set-modified? #t)
        (update-future))))
  
  
  (method (editor-mouse-down h v)
    (when (control-down?)
      (receive (eye direction) (screen->ray h v)
        (if (or paused? (not me))
            (editor-edit editor-mode grid? grid-plane grid-position eye direction 'down)
          (add-action~ commands 'edit (list editor-mode grid? grid-plane grid-position eye direction 'down)))
        (set! editing? #t))))
  
  
  (method (editor-mouse-move h v)
    (when editing?
      (receive (eye direction) (screen->ray h v)
        (if (or paused? (not me))
            (editor-edit editor-mode grid? grid-plane grid-position eye direction 'move)
          (add-action~ commands 'edit (list editor-mode grid? grid-plane grid-position eye direction 'move))))))
  
  
  (method (editor-mouse-up h v)
    (receive (eye direction) (screen->ray (get-h~ down-point) (get-v~ down-point))
      (if editing?
          (if (or paused? (not me))
              (editor-edit editor-mode grid? grid-plane grid-position eye direction 'up)
            (add-action~ commands 'edit (list editor-mode grid? grid-plane grid-position eye direction 'up)))
        (case projection
          ((perspective)
           (let ((closest (ray-closest-element eye direction (get-radius~ zone) ignore-players?: #t)))
             (if (not closest)
                 (set-target #f)
               (bind (element face) closest
                 (set-target element face)))))
          (else
           (let ((vert (ray-plane-intersection eye direction grid? grid-plane grid-position)))
             (if (not vert)
                 (set-target #f)
               (set-target (vertex->element~ zone vert))))))))
    (set! editing? #f)
    (set! adding? #f)
    (set! deleting? #f)
    (set! editor-anchor #f)
    (set! editor-last #f)
    (set! editor-added #f))
  
  
  (method (draw-editor-target)
    (case target-mode
      ((translate) (draw-translater))
      ((rotate) (draw-rotater))
      ((scaler) (draw-scaler))))
  
  
  (method (draw-translater)
    (let ((x (get-x~ target))
          (y (get-y~ target))
          (z (get-z~ target)))
      (glLineWidth 2.)
      (glDisable GL_LIGHTING)
      (glDisable GL_DEPTH_TEST)
      ;; Axes
      (glBegin GL_LINES)
      ;; X
      (glColor3f 1.0 0.0 0.0)
      (glVertex3f (+ x   0.0)  y (+ z  0.0))
      (glVertex3f (+ x  10.0)  y (+ z  0.0))
      
      ;; Y
      (glColor3f 0.0 1.0 0.0)
      (glVertex3f (+ x  0.0) (+ y   0.0)  z)
      (glVertex3f (+ x  0.0) (+ y  10.0)  z)
      
      ;; Z
      (glColor3f 0.0 0.0 1.0)
      (glVertex3f (+ x  0.0)  y (+ z   0.0))
      (glVertex3f (+ x  0.0)  y (+ z  10.0))
      (glEnd)
      (glEnable GL_LIGHTING)
      (glLineWidth 1.)
      
      ;; Cone X
      (glPushMatrix)
      (glTranslatef (+ x 10.) y z)
      (glRotatef 90.0 0.0 1.0 0.0)
      (glScalef 0.5 0.5 0.5)
      (glColor4f 1.0 0.0 0.0 1.0)
      (gl-cylinder 1. 0. 2. 26 52)
      (glPopMatrix)
      
      ;; Cone Y
      (glPushMatrix)
      (glTranslatef x (+ y 10.) z)
      (glRotatef -90.0 1.0 0.0 0.0)
      (glScalef 0.5 0.5 0.5)
      (glColor3f 0.0 1.0 0.0)
      (gl-cylinder 1. 0. 2. 26 52)
      (glPopMatrix)
      
      ;; Cone Z
      (glPushMatrix)
      (glTranslatef x y (+ z 10.))
      (glRotatef -90.0 0.0 0.0 1.0)
      (glScalef 0.5 0.5 0.5)
      (glColor3f 0.0 0.0 1.0)
      (gl-cylinder 1. 0. 2. 26 52)
      (glPopMatrix)
      (glEnable GL_DEPTH_TEST)))
  
  
  (method (draw-rotater)
    (let ((x (get-x~ target))
          (y (get-y~ target))
          (z (get-z~ target)))
      (glLineWidth 2.)
      (glDisable GL_LIGHTING)
      (glDisable GL_DEPTH_TEST)
      ;; Rotate X
      (glPushMatrix)
      (glTranslatef x y z)
      (glRotatef 90.0 0.0 1.0 0.0)
      (gl-segment-circle {Point 0 0} 7.5 {Color Red} 100)
      (glPopMatrix)
      
      ;; Rotate Y
      (glPushMatrix)
      (glTranslatef x y z)
      (glRotatef 90.0 1.0 0.0 0.0)
      (gl-segment-circle {Point 0 0} 7.5 {Color Green} 100)
      (glPopMatrix)
      
      ;; Rotate Z
      (glPushMatrix)
      (glTranslatef x y z)
      (glRotatef 90.0 0.0 0.0 1.0)
      (gl-segment-circle {Point 0 0} 7.5 {Color Blue} 100)
      (glPopMatrix)
      (glEnable GL_LIGHTING)
      (glEnable GL_DEPTH_TEST)
      (glLineWidth 1.)))
  
  
  (method (draw-scaler)
    )
  
  
  ;;;
  ;;;; Screen
  ;;;
  
  
  (method (screen->ray h v)
    (let ((ratio (/ width height))
          (ch (- h (/ width 2)))
          (cv (- (- height v) (/ height 2))))
      (case projection
        ((perspective)
         (let ((f-over-y (/ PI/4 2.))
               (eye-up (get-up~ eye-lookat)))
           (let ((cone (tan f-over-y))
                 (d (vertex-distance eye eye-target))
                 (right (cross-product& (vertex- eye-target eye) eye-up)))
             (let ((target-in-eye-space (vertex+ (vertex-scalar* eye-up (/ (* cv d cone 2.) height))
                                                 (vertex+ (vertex-scalar* right (/ (* ch d cone 2. ratio) width))
                                                          eye-target))))
               (values (copy-vertex eye) (vertex-normalize (vertex- target-in-eye-space eye)))))))
        ((orthographic)
         (let ((x (+ (/ (* 2. ch zoom-factor) width) (vertex-x eye)))
               (y (+ (/ (* 2. cv zoom-factor) height ratio) (vertex-y eye))))
           (values (vertex x y (vertex-z eye)) (vertex 0. 0. -1.)))))))
  
  
  (method (world->screen vertex)
    (camera->screen eye eye-lookat vertex))
  
  
  (method (camera->screen eye eye-lookat vertex)
    (let ((projection (make-projection-matrix 45.0 (/ width height) 0.1 1000.0))
          (view (make-view-matrix eye eye-lookat)))
      (let ((projection/view (matrix-multiply& projection view)))
        (let ((vert (matrix-tranform projection/view vertex)))
          (new Point
            (fxround (* (+ (vertex-x vert) 1.) (/ width 2.)))
            (fxround (* (- 1. (vertex-y vert)) (/ height 2.))))))))
  
  
  (method (ray-plane-intersection eye direction grid? grid-plane grid-position (floor-grid?: floor-grid? #f))
    (define (perspective->world norm plane-k)
      (let ((norm-direction-inner-product (inner-product norm direction)))
        (unless (and (= norm-direction-inner-product 0.)
                     (case grid-plane
                       ((x) (= (vertex-x eye) grid-position))
                       ((y) (= (vertex-y eye) grid-position))
                       ((z) (= (vertex-z eye) grid-position))))
          (let ((intersect (/ (- plane-k (inner-product norm eye))
                              norm-direction-inner-product)))
            (unless (<= intersect 0)
              (let ((point (vertex+ eye (vertex-scalar* direction intersect))))
                (if (> norm-direction-inner-product 0.)
                    (values (vertex- point (vertex-scalar* norm 5.)) (+ grid-position -5.))
                  (values point grid-position))))))))
    
    (if (eq? projection 'orthographic)
        (let ((info (perspective->world (vertex 0. 0. 1.) 0.)))
          (when info
            (receive (vert position) info
              (and vert (vertex
                          (vertex-x vert)
                          (vertex-y vert)
                          position)))))
      (if (not grid?)
          (when floor-grid?
            (let ((info (perspective->world (vertex 0. 1. 0.) (get-floor-level~ zone))))
              (when info
                (receive (vert position) info
                  (and vert (vertex
                              (vertex-x vert)
                              position
                              (vertex-z vert)))))))
        (case grid-plane
          ((x) (let ((info (perspective->world (vertex 1. 0. 0.) grid-position)))
                 (when info
                   (receive (vert position) info
                     (and vert (vertex
                                 position
                                 (vertex-y vert)
                                 (vertex-z vert)))))))
          ((y) (let ((info (perspective->world (vertex 0. 1. 0.) grid-position)))
                 (when info
                   (receive (vert position) info
                     (and vert (vertex
                                 (vertex-x vert)
                                 position
                                 (vertex-z vert)))))))
          ((z) (let ((info (perspective->world (vertex 0. 0. 1.) grid-position)))
                 (when info
                   (receive (vert position) info
                     (and vert (vertex
                                 (vertex-x vert)
                                 (vertex-y vert)
                                 position))))))))))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-hook? initialize #t getter generate)
  
  
  (method (toggle-paused)
    (unimplemented-connected)
    (if paused?
        (unpause-world)
      (pause-world)))
  
  
  (method (toggle-evaluation)
    (set! evaluate-hook? (not evaluate-hook?))
    (display-on/off "Evaluation" evaluate-hook?))
  
  
  (method (pause-world)
    (when history?
      (set-current~ history (snapshot-world)))
    (set! paused? #t)
    (reset-counters))
  
  
  (method (unpause-world)
    (truncate-future)
    (set-current~ history #f)
    (set! last-tick (time->seconds (current-time)))
    (set! paused? #f)
    (camera-behind-player)
    (follow-player)
    (reset-counters))
  
  
  (method (snapshot-world)
    (snapshot-zone~ zone))
  
  
  (method (load-world snapshot)
    (let ((previous-target target))
      (load-zone~ zone snapshot)
      (set-me (find-player (get-actors~ zone)))
      (set-target (and previous-target (find-target previous-target (get-elements~ zone))))))
  
  
  (method (find-player actors)
    (find-if (lambda (obj)
               (is? obj Player))
             actors))
  
  
  (method (find-named-player player-name)
    (find-if (lambda (actor)
               (and (is? actor Player)
                    (equal? (get-name~ actor) player-name)))
             (get-actors~ zone)))
  
  
  (method (find-target target elements)
    (let ((origin (get-origin~ target)))
      (find-if (lambda (obj)
                 (eq? (get-origin~ obj) origin))
               elements)))
  
  
  (method (set-target targ (face #f))
    (when (and (neq? targ target) (or (is? targ Actor) (and (is-not? targ Actor) (is? target Actor))))
      (play-sound-file~ world (if (is? targ Actor) "sound/user/selectTarget" "sound/user/deselectTarget")))
    (set! target targ)
    (set! target-face face)
    (target-update target face)
    (invalidate-view~ interface))
  
  
  (method (toggle-draw-elements)
    (set! draw-elements? (not draw-elements?))
    (display-on/off "Draw elements" draw-elements?))
  
  
  ;;;
  ;;;; Music
  ;;;
  
  
  (method (change-music)
    (let ((queue (new-queue)))
      (for-each (lambda (assets)
                  (let ((music-dir (new-directory~ assets "music")))
                    (when (exists?~ music-dir)
                      (enqueue-list queue (get-content~ music-dir nodes?: #f)))))
                all-assets)
      (let ((music-list (map get-base~ (queue-list queue))))
        (let ((music (random-element music-list)))
          (play-ambiance (concatenate "music/" music))))))
  
  
  (method (play-intro-music)
    (play-ambiance "music/Intro"))
  
  
  (method (play-ambiance path)
    (play-music-file path "ambiance"))
  
  
  (method (play-music-file path name)
    (let ((file (effective-music-file path)))
      (when file
        (close-music name)
        (open-music file name)
        (play-music name))))
  
  
  (method (effective-music-file path)
    (when path
      (continuation-capture
        (lambda (return)
          (for-each (lambda (assets)
                      (let ((mp3 (new-file~ assets (make-filename path "mp3"))))
                        (if (exists?~ mp3)
                            (continuation-return return mp3)
                          (let ((ogg (new-file~ assets (make-filename path "ogg"))))
                            (when (exists?~ ogg)
                              (continuation-return return ogg))))))
                    all-assets)
          #f))))
  
  
  (method (play-sound-file path)
    (let ((file (effective-sound-file path)))
      (when file
        (play-sound file))))
  
  
  (method (effective-sound-file path)
    (when path
      (continuation-capture
        (lambda (return)
          (for-each (lambda (assets)
                      (let ((wav (new-file~ assets (make-filename path "wav"))))
                        (when (exists?~ wav)
                          (continuation-return return wav))))
                    all-assets)
          #f))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method (evaluate-hook)
    (when evaluate-hook?
      (setup-lighting~ zone)
      (update-future)
      (update-world-options~ (get-application))
      (install-skins~ (get-application))
      (install-bindings~ (get-application))
      (invalidate-view~ interface)))
  
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method (test1)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test1~ profile)
        (bell))))
  
  
  (method (test2)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test2~ profile)
        (bell))))
  
  
  (method (test3)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test3~ profile)
        (bell))))
  
  
  (method (test4)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test4~ profile)
        (bell))))
  
  
  (method (test5)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test5~ profile)
        (bell))))
  
  
  (method (test6)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test6~ profile)
        (bell))))
  
  
  (method (test7)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test7~ profile)
        (bell))))
  
  
  (method (test8)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test8~ profile)
        (bell))))
  
  
  (method (test9)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test9~ profile)
        (bell))))
  
  
  (method (test0)
    (let ((profile (get-profile~ (get-application))))
      (if profile
          (test0~ profile)
        (bell))))
  
  
  ;;;
  ;;;; GC
  ;;;
  
  
  (method (setup-gc)
    (add-gc-interrupt-job!
      (lambda ()
        (process~ (find-counter 'gc) (last-gc-real-time)))))
  
  
  ;;;
  ;;;; Slider
  ;;;
  
  
  (slot sliding? initialize #f)
  
  
  (method (slider-mouse-down h v)
    (set! sliding? #t)
    (unless (inside-slider-thumb?~ history h v)
      (slide-history (h->where h))))
  
  
  (method (slider-mouse-move h v)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-up h v)
    (set! sliding? #f))
  
  
  (method (h->where h)
    (let ((cx (fxround (/ width 2.))))
      (let ((where (/ (+ (- h cx) 200.) 400.)))
        (max 0. (min 1. where)))))
  
  
  (method (in-slider? v)
    (< v 60))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method protected virtual (cursor-update)
    (set-cursor (if explore-interface?
                    :spy
                  :arrow)))
  
  
  (method protected virtual (mouse-down h v)
    (set! down? #t)
    (set! down-point (new Point h v))
    (cond ((and history? paused? (in-slider? v))
           (slider-mouse-down h v))
          ((and paused? (eq? projection 'perspective))
           (setup-viewing h v))
          (else
           (editor-mouse-down h v))))
  
  
  (method protected virtual (mouse-move h v)
    (define (move-camera)
      (when last-point
        (if (and last-recenter
                 (= (get-h~ last-recenter) h)
                 (= (get-v~ last-recenter) v))
            (set! last-recenter #f)
          (let ((new-point (new Point h v))
                (new-time (time->seconds (current-time))))
            (let ((elapse (- new-time last-time)))
              (when (> elapse 0)
                (let ((delta (nu- new-point last-point)))
                  (let ((dh (get-h~ delta))
                        (dv (get-v~ delta)))
                    (mouse-track elapse dh dv)))))
            (set! last-point (new Point (fxround (/ width 2)) (fxround (/ height 2))))
            (set! last-time new-time)
            (set! last-recenter (new Point (fxround (/ width 2)) (fxround (/ height 2))))
            (set-mouse-position~ window last-recenter)))))
    
    (cond ((and history? paused? sliding?)
           (slider-mouse-move h v))
          ((and paused? (eq? projection 'perspective))
           (move-camera))
          (last-point
           (move-camera)
           (unless moving?
             (follow-player)))
          (editing?
           (editor-mouse-move h v))
          ((and down? (not (near? (new Point h v) down-point drag-tolerance)))
           (hide/preserve-cursor)
           (set! viewing? #t)
           (setup-viewing h v))))
  
  
  (method protected virtual (mouse-track elapse dh dv)
    (define (track-camera)
      (rotate-horizontal (/ (- (cast <fl> dh)) track-sensitivity))
      (rotate-vertical (/ (- (cast <fl> dv)) track-sensitivity)))
    
    (when (eq? projection 'perspective)
      (if (and me moving? (or (not paused?) (neq? projection 'perspective)))
          (let ((first? (not moved?)))
            (add-action~ commands 'track (list dh dv (get-sight~ eye-lookat) (get-up~ eye-lookat) (get-right~ eye-lookat) first?))
            (set! moved? #t))
        (track-camera))))
  
  
  (method protected virtual (mouse-up h v)
    (restore/show-cursor)
    (cond ((and history? paused? sliding?)
           (slider-mouse-up h v))
          ((and paused? (eq? projection 'perspective))
           (reset-viewing))
          (last-point
           (reset-viewing)
           (follow-player))
          (else
           (when down?
             (editor-mouse-up h v))))
    (set! down? #f)
    (set! down-point #f)
    (set! viewing? #f))
  
  
  (method protected virtual (right-mouse-down h v)
    (hide/preserve-cursor)
    (set! moving? #t)
    (set! moved? #f)
    (setup-viewing h v))
  
  
  (method protected virtual (right-mouse-up h v)
    (when me
      (reset-player-tilt me))
    (restore/show-cursor)
    (set! moving? #f)
    (reset-viewing))
  
  
  (method (setup-viewing h v)
    (set! last-point (new Point h v))
    (set! last-time (time->seconds (current-time))))
  
  
  (method (reset-viewing)
    (set! last-point #f)
    (set! last-time #f))
  
  
  (method (hide/preserve-cursor)
    (hide-cursor)
    (set! preserved-mouse (mouse-position~ window)))
  
  
  (method (restore/show-cursor)
    (when preserved-mouse
      (set-mouse-position~ window preserved-mouse)
      (set! preserved-mouse #f))
    (show-cursor))
  
  
  (method (mouse-wheel h v delta)
    (cond ((control-down?)
           (case target-mode
             ((translate)
              (when target
                (let ((d (/ delta 120)))
                  (let ((old-position (get-position~ target))
                        (dist (cond ((shift-down?) (vertex 0. 0. (* d 5.)))
                                    ((alt-down?) (vertex 0. (* d 5.) 0.))
                                    (else (vertex (* d 5.) 0. 0.)))))
                    (let ((new-position (vertex+ old-position dist)))
                      (set-position~ target new-position)
                      (update-area~ zone target old-position)
                      (invalidate-lightmaps~ zone target))))))
             (else
              (move-grid delta))))
          ((> delta 0)
           (zoom-in))
          (else
           (zoom-out))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method protected virtual (process-keys)
    (let ((evt (make-event Keyboard-Event :char self)))
      (process-movement evt allow-space?: paused?)
      (when (get-active?~ (get-application))
        (receive (shift? control? alt?) (modifiers-down)
          (unless (or shift? control? alt?)
            (when (key-down? VK_LEFT)
              (move-left))
            (when (key-down? VK_RIGHT)
              (move-right))
            (when (key-down? VK_DOWN)
              (move-down))
            (when (key-down? VK_UP)
              (move-up))
            (when (key-down? (char->integer #\space))
              (if (and first-person? fly?)
                  (strafe-up)
                (space)))
            (when (key-down? (char->integer #\1))
              (maybe-fire)))))))
  
  
  (method (process-movement evt (allow-space?: allow-space? #t))
    (when (get-active?~ (get-application))
      (let ((shift? (get-shift?~ evt))
            (control? (get-control?~ evt))
            (alt? (get-alt?~ evt)))
        (unless (or shift? control? alt?)
          (when (key-down? (char->integer #\W))
            (move-forward))
          (when (key-down? (char->integer #\S))
            (move-backward))
          (when (key-down? (char->integer #\Q))
            (strafe-left))
          (when (key-down? (char->integer #\E))
            (strafe-right))
          (when (or (key-down? (char->integer #\R))
                    (and allow-space? (key-down? (char->integer #\space))))
            (strafe-up))
          (when (key-down? (char->integer #\X))
            (strafe-down))
          (when (key-down? (char->integer #\A))
            (if (is-moving?)
                (strafe-left)
              (rotate-left)))
          (when (key-down? (char->integer #\D))
            (if (is-moving?)
                (strafe-right)
              (rotate-right)))))))
  
  
  (method protected virtual (process-shortcut shortcut)
    (if (shortcut=? shortcut {Shortcut Escape})
        (main-menu)
      #f))
  
  
  (method protected virtual (key-down c)
    )
  
  
  (method protected virtual (key-press key)
    )
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method (connect-to-server)
    (let ((process (get-process)))
      (if (get-world-server~ process)
          (display-error "Already connected")
        (connect-server~ process)
        (display-message "Connected" color: {Color Green}))))
  
  
  (method (disconnect-from-server)
    (let ((process (get-process)))
      (if (not (get-world-server~ process))
          (display-error "Not connected")
        (disconnect~ process)
        (display-message "Disconnected"))))
  
  
  (method (request-server-update)
    (let ((process (get-process)))
      (if (not (get-world-server~ process))
          (display-error "Not connected")
        (update-client~ process)
        (display-message "Requesting server update"))))
  
  
  (method (unimplemented-connected)
    (when (get-world-server~ (get-process))
      (display-error "Unimplemented when connected")
      (signal-cancel)))
  
  
  ;;;
  ;;;; Window
  ;;;
  
  
  (method (live-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (bell)
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (live-gaia/world~ debugger debuggee)))))
  
  
  (method (design-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (bell)
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (design-gaia/world~ debugger debuggee)))))
  
  
  (method (restore-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (bell)
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (restore-gaia/world~ debugger debuggee)))))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (toggle-mode)
    (set! edition? (not edition?))
    (display-message (format "{a}" (if edition? "Edition" "Game"))))
  
  
  (method (toggle-interface)
    (set! interface? (not interface?)))
  
  
  (method (toggle-polygon-mode)
    (set! polygon-mode (ecase polygon-mode
                         ((GL_POINT) GL_LINE)
                         ((GL_LINE) GL_FILL)
                         ((GL_FILL) GL_POINT)))
    (glPolygonMode GL_FRONT_AND_BACK polygon-mode))
  
  
  (method (toggle-lighting)
    (set! light? (not light?)))
  
  
  (method (toggle-windowed-mode)
    (toggle-windowed-mode~ window))
  
  
  (method (toggle-fullscreen)
    (toggle-fullscreen~ window))
  
  
  (method (toggle-post-processing)
    (set! post-processing? (not post-processing?))
    (display-on/off "Post processing" post-processing?))
  
  
  (method (first-person)
    (if (not me)
        (display-error "No player")
      (if first-person?
          (deactivate-first-person)
        (activate-first-person))
      (display-on/off "First person" first-person?)))
  
  
  (method (activate-first-person)
    (set! first-person? #t)
    (camera-center-player)
    (activate-3d))
  
  
  (method (deactivate-first-person)
    (set! first-person? #f))
    
  
  (method (toggle-3d)
    (if 3d?
        (deactivate-3d)
      (activate-3d))
    (display-on/off "3d" 3d?))
  
  
  (method (activate-3d)
    (set! 3d? #t)
    (set! light? #t)
    (activate-perspective))
  
  
  (method (deactivate-3d)
    (set! 3d? #f)
    (set! light? #f)
    (activate-orthographic))
  
  
  (method (toggle-fly)
    (unimplemented-connected)
    (activate-mount
      (if fly?
          'none
        'carpet)))
  
  
  (method (activate-fly)
    (unless fly?
      (set! fly? #t)
      (when me
        (set-y~ me (+ (get-y~ me) 2.))
        (update-position~ me)
        (follow-player))))
  
  
  (method (deactivate-fly)
    (when fly?
      (set! fly? #f)
      (when me
        (rotate-player-vertical me (vertical-angle (get-sight~ (get-lookat~ me)) world-up))
        (follow-player))))
  
  
  (method (toggle-draw-gadgets)
    (set! draw-gadgets? (not draw-gadgets?))
    (update-gadgets)
    (display-on/off "Draw gadgets" draw-gadgets?))
  
  
  (method (toggle-draw-atlas)
    (set! draw-atlas? (not draw-atlas?))
    (display-on/off "Draw atlas" draw-atlas?))
  
  
  (method (update-gadgets)
    (iterate-gadgets~ zone
      (lambda (gadget)
        (set-visible?~ gadget draw-gadgets?)))
    (when (and (is? target Gadget)
               (not (get-visible?~ target)))
      (set-target #f)))
  
  
  (method (toggle-axes)
    (set! axes? (not axes?))
    (display-on/off "Axes" axes?))
  
  
  (method (toggle-info)
    (let ((pane (child~ interface 'info)))
      (set-visible?~ pane (not (get-visible?~ pane)))
      (when (get-visible?~ pane)
        (set! interface? #t))))
  
  
  (method (toggle-counters)
    (let ((pane (child~ interface 'counters)))
      (set-visible?~ pane (not (get-visible?~ pane)))
      (when (get-visible?~ pane)
        (set! interface? #t)
        (reset-counters))))
  
  
  (method (reset-counters)
    (iterate-table counters
      (lambda (name counter)
        (reset~ counter))))
  
  
  (method (toggle-player)
    (let ((pane (child~ interface 'player)))
      (set-visible?~ pane (not (get-visible?~ pane)))
      (when (get-visible?~ pane)
        (set! interface? #t))))
  
  
  (method (display-on/off title flag)
    (display-message (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method (display-message msg (color: color #f))
    (set! message msg)
    (set! message-color color)
    (set! message-time (time->seconds (current-time))))
  
  
  (method (draw-message)
    (let ((elapse (- (time->seconds (current-time)) message-time)))
      (if (> elapse 2.)
          (begin
            (set! message #f)
            (set! message-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ message-texture))
                (font {Font Heading1})
                (color (or message-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 message)
            (map-texture~ message-texture)
            (let ((w (text-width~ font message)))
              (let ((c (center w (fxround width))))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) (cast <fl> (- (fxround height) 200)) 0.0)
                (textured-quad~ message-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 800.0 0.0 0.0))
                  (lambda () (glVertex3f 800.0 100.0 0.0))
                  (lambda () (glVertex3f 0.0 100.0 0.0)))
                (glPopMatrix))))))))
    
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method (display-error msg)
    (display-message msg color: {Color Red}))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method (display-status msg (color: color #f))
    (set! status msg)
    (set! status-color color)
    (set! status-time (time->seconds (current-time))))
  
  
  (method (draw-status)
    (let ((elapse (- (time->seconds (current-time)) status-time)))
      (if (> elapse 2.)
          (begin
            (set! status #f)
            (set! status-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ status-texture))
                (font {Font Heading2})
                (color (or status-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 status)
            (map-texture~ status-texture)
            (let ((w (text-width~ font status)))
              (let ((c (center w (fxround width))))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) 30.0 0.0)
                (textured-quad~ status-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 800.0 0.0 0.0))
                  (lambda () (glVertex3f 800.0 35.0 0.0))
                  (lambda () (glVertex3f 0.0 35.0 0.0)))
                (glPopMatrix))))))))
  
  
  ;;;
  ;;;; Info
  ;;;
  
  
  (method (debug-info)
    (define (present-object obj)
      (format "~{{s} #{s}}"
              (reference-name (get-name~ (class-of obj)))
              (object->serial obj)))
    
    (define (present-boolean bool)
      (if bool "true" "false"))
    
    `(,@(if (client-side?~ (get-process))
            `(,(format "{a}" (get-player-name~ (get-process))))
         `("Server"
           ,(format "clients: {a}" (length (get-clients~ (get-process))))
           ,(format "hits: {a}" (get-hits~ (get-process)))))
      ""
      ,(format "window: {a}" (present-object window))
      ,(format "width: {s}" width)
      ,(format "height: {s}" height)
      ""
      ,(format "world: {s}" self)
      ,(format "version: {s}" version)
      ""
      ,(format "zone: {s}" zone)
      ,(format "sectors: {s}, {s} non empty" (table-length (get-sectors~ zone)) (count-sectors-with-tiles~ zone))
      ,(format "areas: {s}" (table-length (get-areas~ zone)))
      ,(format "tiles: {s}" (length (get-tiles~ zone)))
      ,(format "actors: {s}" (length (get-actors~ zone)))
      ,(format "elements: {s}" (length (get-elements~ zone)))
      ,(format "gadgets: {s}" (length (get-gadgets~ zone)))
      ,(format "children: {s}" (length (get-children~ zone)))
      ,(format "marks: {s}" (length (get-marks~ zone)))
      ""
      ,@(let* ((floats (compute-floats~ zone))
               (indices (/ floats 3))
               (vertices (/ indices 3))
               (triangles (/ vertices 3)))
          `(,(format "VBO triangles: {s}" triangles)
            ,(format "VBO vertices: {s}" vertices)
            ,(format "VBO indices: {s}" indices)
            ,(format "VBO floats: {s}" floats)))
      ""
      ,@(if target
            `(,(format "target: {a}" (present-object target))
              ,(format "  x: {r precision: 1}" (get-x~ target))
              ,(format "  y: {r precision: 1}" (get-y~ target))
              ,(format "  z: {r precision: 1}" (get-z~ target))
              ,(format "  width: {s}" (get-width~ target))
              ,(format "  height: {s}" (get-height~ target))
              ,(format "  depth: {s}" (get-depth~ target))
              ,(format "  texture: {s}" (get-texture~ target))
              ,(format "  user-data: {s}" (get-user-data~ target))
              ,@(if (is? target Player)
                    (let ((lookat (get-lookat~ target)))
                      `(,(format "  sight: {a}" (present-vertex (get-sight~ lookat)))
                        ,(format "  up: {a}" (present-vertex (get-up~ lookat)))
                        ,(format "  right: {a}" (present-vertex (get-right~ lookat)))))
                  '())
              "")
          '())
      ,(format "server: {s}" (get-world-server~ (get-process)))
      ,(format "client: {s}" (get-world-client~ (get-process)))
      ""
      ,(format "history: {s}" (history-end~ history))
      ,(format "now: {s}" (get-now~ history))
      ,(format "first: {s}" (get-first~ history))
      ,@(if (and history? paused?)
            (present-history~ history)
          '())
      ""
      ,(format "projection: {s}" projection)
      ,(format "eye: {a}" (present-vertex eye))
      ,(format "eye-target: {a}" (present-vertex eye-target))
      ,(format "eye-lookat: {s}" eye-lookat)
      ,(format "camera-distance: {s}" camera-distance)
      ,(format "zoom-factor: {s}" zoom-factor)
      ,(format "first-distance: {s}" first-distance)
      ,(format "first-override: {s}" first-override)
      ,(format "first-occlusion?: {s}" first-occlusion?)
      ,(format "first-camera: {s}" first-camera)
      ,(format "desired-tilt: {s}" desired-tilt)
      ""
      ,(format "ambient-color: {s}" (get-ambient-color~ zone))
      ,(format "material-specular: {s}" (get-material-specular~ zone))
      ,(format "material-shininess: {s}" (get-material-shininess~ zone))
      ,(format "lights: {s}" (count-lights~ zone))
      ""
      ,@(if information
            `(,@information
              "")
          '())
      ,@(if me
            `(,(format "player: {a}" (present-object me))
              ,(format "  x: {r precision: 1}" (get-x~ me))
              ,(format "  y: {r precision: 1}" (get-y~ me))
              ,(format "  z: {r precision: 1}" (get-z~ me))
              ,(format "  left: {r precision: 1}" (get-left~ me))
              ,(format "  bottom: {r precision: 1}" (get-bottom~ me))
              ,(format "  back: {r precision: 1}" (get-back~ me))
              ,(format "  right: {r precision: 1}" (get-right~ me))
              ,(format "  top: {r precision: 1}" (get-top~ me))
              ,(format "  front: {r precision: 1}" (get-front~ me))
              ,(format "  width: {s}" (get-width~ me))
              ,(format "  height: {s}" (get-height~ me))
              ,(format "  depth: {s}" (get-depth~ me))
              ,(format "  texture: {s}" (get-texture~ me))
              ,(format "  velocity: {a}" (present-vertex (get-velocity~ me)))
              ,(format "  user-data: {s}" (get-user-data~ me))
              ,(format "  lookat: {s}" (get-lookat~ me))
              ,(format "  jumping?: {a}" (present-boolean (get-jumping?~ me)))
              ,(format "  facing: {s}" (get-facing~ me))
              ,(format "  state: {s}" (get-state~ me))
              "")
          '())
      ,(format "editor-mode: {a}" (capitalize (->string editor-mode)))
      ,(format "light?: {a}" (present-boolean light?))
      ,(format "music?: {a}" (present-boolean music?))
      ,(format "3d?: {a}" (present-boolean 3d?))
      ,(format "fly?: {a}" (present-boolean fly?))
      ,(format "first-person?: {a}" (present-boolean first-person?))
      ,(format "paused?: {a}" (present-boolean paused?))
      ""
      ,(format "gc-count: {a}" (gc-count))))
  
  
  (method (reset-information)
    (set! information #f))
  
  
  (method (set-information info)
    (set! information (map ->string info)))
  
  
  (method (add-information info)
    (set! information (append (or information '()) (list (->string info)))))
  
  
  ;;;
  ;;;; Counters
  ;;;
  
  
  (method (add-counter name counter)
    (table-set! counters name counter))
  
  
  (method (find-counter name)
    (table-ref counters name))))
