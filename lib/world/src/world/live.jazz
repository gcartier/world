;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.live jazz


(import (gambit.log)
        (jazz.debuggee)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.library)
        (jazz.media)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.project)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window)
        (time)
        (world)
        (world.actor)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.block)
        (world.camera)
        (world.collision)
        (world.commands)
        (world.configure)
        (world.debug)
        (world.defaults)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.enemy)
        (world.entities)
        (world.entity)
        (world.external.milkshape)
        (world.external.obj)
        (world.fog)
        (world.folio)
        (world.foreign)
        (world.gadget)
        (world.generate)
        (world.geometry)
        (world.gravity)
        (world.grid)
        (world.history)
        (world.homogeneous)
        (world.interface)
        (world.interface.actions)
        (world.interface.animations)
        (world.interface.assets)
        (world.interface.bindings)
        (world.interface.blocks)
        (world.interface.character)
        (world.interface.dialogs)
        (world.interface.documents)
        (world.interface.frame)
        (world.interface.gadgets)
        (world.interface.info)
        (world.interface.main)
        (world.interface.menu)
        (world.interface.meshes)
        (world.interface.models)
        (world.interface.options)
        (world.interface.panel)
        (world.interface.player)
        (world.interface.profiler)
        (world.interface.script)
        (world.interface.scripts)
        (world.interface.shaders)
        (world.interface.showcase)
        (world.interface.skyboxes)
        (world.interface.target)
        (world.interface.textures)
        (world.interface.tiles)
        (world.interface.worlds)
        (world.interface.zones)
        (world.io)
        (world.keys)
        (world.log)
        (world.lookat)
        (world.mark)
        (world.material)
        (world.mesh)
        (world.model)
        (world.motion)
        (world.opengl)
        (world.parameters)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.profiling)
        (world.programs)
        (world.quad)
        (world.render)
        (world.renderer)
        (world.renderers)
        (world.script)
        (world.sector)
        (world.serialization)
        (world.settings)
        (world.shaders)
        (world.skybox)
        (world.support)
        (world.syntax (phase syntax))
        (world.target)
        (world.task)
        (world.texture)
        (world.triangle)
        (world.w3d)
        (world.widget)
        (world.window)
        (world.zone))


;;;
;;;; World
;;;


(class World extends Component
  
  
  (property title              <string+>         initialize #f              accessors generate)
  (property ambient-gravity    <f64vector>       initialize default-gravity accessors generate)
  (property jump-impulsion     <fl>              initialize default-jump    accessors generate)
  (property start-zone         <string+>         initialize #f              accessors generate)
  (property start-grid?        <bool>            initialize #t              accessors generate)
  (property start-axes?        <bool>            initialize #f              accessors generate)
  (property default-image      <object>          initialize "dirty"         accessors generate)
  (property properties         <object>          initialize '()             accessors generate)
  
  
  (slot window                 <OpenGL-Window>   initialize #f              accessors generate)
  (slot width                  <fl>              initialize #f              accessors generate)
  (slot height                 <fl>              initialize #f              accessors generate)
  (slot boundaries             <f64vector+>      initialize #f              getter generate)
  (slot eye                    <Camera>          initialize (make-camera)   getter generate)
  (slot eye-motion             <Motion>          initialize #f              getter generate)
  (slot eye-hook               <object>          initialize #f              accessors generate)
  (slot world-up               <f64vector>       initialize (make-vertex)   getter generate)
  (slot lighting?              <bool>            initialize #t              getter generate)
  (slot what                   <object>          initialize #f              getter generate)
  (slot target                 <object>          initialize '()             getter generate)
  (slot target-face            <object>          initialize #f              getter generate)
  (slot target-face-rank       <object>          initialize #f              getter generate)
  (slot target-polygon         <object>          initialize #f              getter generate)
  (slot target-mode            <object>          initialize 'select         getter generate)
  (slot target-widget          <Widget+>         initialize #f              getter generate)
  (slot highlighted-polygons   <list>            initialize '()             getter generate)
  (slot last-point             <object>          initialize #f              getter generate)
  (slot last-time              <object>          initialize #f              getter generate)
  (slot showcase               <World-Showcase+> initialize #f              getter generate)
  (slot showcases              <object>          initialize #f              getter generate)
  (slot showcase-down?         <bool>            initialize #f              getter generate)
  (slot polygon-mode           <fx>              initialize GL_FILL         getter generate)
  (slot window-cursor          <object>          initialize :arrow          getter generate)
  (slot earth?                 <bool>            initialize #t              getter generate)
  (slot interface?             <bool>            initialize #t              accessors generate)
  (slot interface-bars?        <bool>            initialize #t              accessors generate)
  (slot explore-interface?     <bool>            initialize #f              accessors generate)
  (slot render-ready?          <bool>            initialize #f              accessors generate)
  (slot debugged?              <bool>            initialize #f              accessors generate)
  
  
  (slot version                <object>          initialize #f              getter generate)
  (slot orientation?           <bool>            initialize #f              getter generate)
  (slot aim?                   <bool>            initialize #f              getter generate)
  (slot free-aim?              <bool>            initialize #f              getter generate)
  (slot viewing?               <bool>            initialize #f              getter generate)
  (slot moving?                <bool>            initialize #f              getter generate)
  (slot moved?                 <bool>            initialize #f              getter generate)
  (slot first-camera           <object>          initialize #f              getter generate)
  (slot vehicle                <object>          initialize #f              getter generate)
  (slot mount?                 <bool>            initialize #f              getter generate)
  (slot mounts-folio           <Folio>           initialize #f              getter generate)
  (slot fly?                   <bool>            initialize #f              getter generate)
  (slot flyers-folio           <Folio>           initialize #f              getter generate)
  (slot draw-elements?         <bool>            initialize #t              getter generate)
  (slot draw-gadgets?          <bool>            initialize #f              getter generate)
  (slot draw-marks?            <bool>            initialize #t              getter generate)
  (slot draw-normals?          <bool>            initialize #f              getter generate)
  (slot draw-atlas?            <bool>            initialize #f              accessors generate)
  (slot draw-procedures        <object>          initialize '()             getter generate)
  (slot draw-procedure-names   <object>          initialize #f              getter generate)
  (slot view-distance          <fx>              initialize 7               getter generate)
  (slot view-radius            <fl>              initialize #f              accessors generate)
  (slot max-entity-radius      <fl>              initialize 60.             accessors generate)
  (slot visited-sectors        <fx>              initialize 0               accessors generate)
  (slot rendered-sectors       <fx>              initialize 0               accessors generate)
  (slot render-thread          <object>          initialize #f              accessors generate)
  (slot render-what            <fx+>             initialize 0               accessors generate)
  (slot dynamic-lights         <fx>              initialize 8               getter generate)
  (slot post-processing?       <bool>            initialize #t              getter generate)
  (slot player-thread          <object>          initialize #f              accessors generate)
  (slot ongoing-key            <object>          initialize #f              accessors generate)
  (slot axes?                  <bool>            initialize #f              accessors generate)
  (slot axes-graduation?       <bool>            initialize #f              accessors generate)
  (slot tick-slice?            <bool>            initialize #t              getter generate)
  (slot down?                  <bool>            initialize #f              getter generate)
  (slot down-point             <object>          initialize #f              getter generate)
  (slot drag-tolerance         <object>          initialize 3               getter generate)
  (slot idle?                  <bool>            initialize #t              getter generate)
  (slot paused?                <bool>            initialize #f              getter generate)
  (slot tick-procedures        <object>          initialize '()             getter generate)
  (slot tick-no                <object>          initialize 0               getter generate)
  (slot commands               <object>          initialize #f              getter generate)
  (slot base-assets            <object>          initialize #f              getter generate)
  (slot world-assets           <object>          initialize #f              getter generate)
  (slot user-assets            <object>          initialize #f              getter generate)
  (slot all-assets             <object>          initialize #f              getter generate)
  (slot textures               <object>          initialize #f              getter generate)
  (slot models                 <object>          initialize #f              getter generate)
  (slot newable?               <bool>            initialize #f              accessors generate)
  (slot writable?              <bool>            initialize #f              accessors generate)
  (slot music?                 <bool>            initialize #f              getter generate)
  (slot gc-sound?              <bool>            initialize #f              getter generate)
  (slot history                <object>          initialize #f              getter generate)
  (slot history-camera         <Camera>          initialize (make-camera)   getter generate)
  (slot history-motion         <Motion>          initialize #f              getter generate)
  (slot message                <object>          initialize #f              getter generate)
  (slot message-time           <object>          initialize #f              getter generate)
  (slot message-color          <object>          initialize #f              getter generate)
  (slot message-player         <object>          initialize #f              getter generate)
  (slot status                 <object>          initialize #f              getter generate)
  (slot status-time            <object>          initialize #f              getter generate)
  (slot status-color           <object>          initialize #f              getter generate)
  (slot status-player          <object>          initialize #f              getter generate)
  (slot interface              <World-Interface> initialize #f              getter generate)
  (slot interface-refresh?     <bool>            initialize #f              getter generate)
  (slot interface-refresh-rate <fl>              initialize #f              getter generate)
  (slot interface-last-time    <fl>              initialize #f              getter generate)
  (slot interface-target?      <bool>            initialize #f              getter generate)
  (slot interface-script?      <bool>            initialize #f              getter generate)
  (slot last-script            <object>          initialize #f              getter generate)
  (slot escape-hook            <object>          initialize #f              accessors generate)
  (slot enter-hook             <object>          initialize #f              accessors generate)
  
  ;; Shader programs
  (slot mesh-programs          <object>          initialize #f              accessors generate)
  (slot block-atlas            <Atlas>           initialize #f              accessors generate)
  (slot block-atlas-nearest    <Atlas>           initialize #f              accessors generate)
  (slot block-opaque           <object>          initialize #f              accessors generate)
  (slot block-transparent      <object>          initialize #f              accessors generate)
  (slot block-materials        <object>          initialize #f              accessors generate)
  (slot block-matrix           <object>          initialize #f              accessors generate)
  (slot block-program          <Mesh-Program>    initialize #f              accessors generate)
  
  ;; Render targets
  (slot render-target          <Render-Target+>  initialize #f              accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition max-dynamic-lights
    8)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-current-world self)
    (set! view-distance (find-setting 'world.view-distance 7))
    (set! view-radius 200.)
    (set! history-motion (make-free-motion self history-camera))
    (set-stable-callback~ history-camera eye-stable-callback)
    (set! eye-motion (make-free-motion self eye))
    (set-stable-callback~ eye eye-stable-callback)
    (set-current-camera eye)
    (set-current-motion eye-motion)
    (set! dynamic-lights (min max-dynamic-lights (find-setting 'world.dynamic-lights 8)))
    (set! earth? (find-setting 'world.earth? #t))
    (set-camera-smoothing? (find-setting 'world.camera-smoothing? #t))
    (set-independant-camera? (find-setting 'world.independant-camera? #t))
    (set-autotrack-camera? (find-setting 'world.autotrack-camera? #t))
    (set-track-sensitivity (find-setting 'world.track-sensitivity 200.))
    (set! post-processing? (find-setting 'world.post-processing? #t))
    (set! interface? (world-setting 'world.start-interface? #t 'default))
    (set! interface-target? (world-setting 'world.interface-target? #f 'default))
    (set! interface-script? (world-setting 'world.interface-script? (programmer-role?~ (get-application)) 'default))
    (set! gc-sound? (world-setting 'world.gc-sound? #f 'default))
    (set! evaluate-future? (find-setting 'world.evaluate-future? #t))
    (set! free-aim? (find-setting 'world.free-aim? #f))
    (set-fog? (find-setting 'world.fog? #f))
    (set-fog-density (world-setting 'world.fog-density default-fog-density 'default))
    (set-fog-color (world-setting 'world.fog-color default-fog-color 'default))
    (set-animations? (world-setting 'world.animations? (>= (glGetInteger* GL_MAX_VERTEX_UNIFORM_COMPONENTS) 4096) 'default))
    (set-debug-w3d? (find-setting 'world.debug-w3d? #f))
    (set-debug-ms3d? (find-setting 'world.debug-ms3d? #f))
    (set-debug-meshes? (find-setting 'world.debug-meshes? #f))
    (set-debug-lightmap? (find-setting 'world.debug-lightmap? #f))
    (set-debug-animations? (find-setting 'world.debug-animations? #f))
    (set-debug-collisions? (find-setting 'world.debug-collisions? #f))
    (set-trace-textures? (find-setting 'world.trace-textures? #f))
    (set-task-trace (or (find-setting 'world.task-trace #f) '()))
    (set-collide-max-slide (find-setting 'world.collide-max-slide 5))
    (set! tick-slice? (and (not debug-user?) (not (find-setting 'world.inhibit-slicing? #f))))
    (set! draw-procedure-names (make-table test: eq?))
    ;; not necessary if we are not using message-available?
    ;; (set-ignore-key-repeat? #t)
    (register-keys)
    (setup-info))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (update-world-up ambient-gravity)
    (music-played-callback music-played)
    (when music?
      (change-music))
    (setup-logs)
    (when log-heartbeat?
      (setup-logging-heartbeat! current-log-context heartbeat-state)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
   
   
  (method (setup-threads)
    ;; not 100% sure but i think this has a noticable impact
    ;(thread-heartbeat-interval-set! .001)
    (thread-base-priority-set! (event-thread) event-priority)
    (thread-base-priority-set! (message-thread) message-priority)
    (set-message-rate message-rate))
  
  
  (method (setup-opengl)
    (setup-size)
    (glClear GL_COLOR_BUFFER_BIT)
    (glClear GL_DEPTH_BUFFER_BIT)
    (glEnable GL_DEPTH_TEST)
    (glDisable GL_BLEND)
    (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
    (glFrontFace GL_CW)
    (glPolygonMode GL_FRONT_AND_BACK GL_FILL)
    (glEnable GL_LINE_SMOOTH)
    (initialize-eye)
    (prepare-assets)
    (prepare-modules)
    (prepare-models)
    (prepare-showcases)
    (prepare-shaders)
    (prepare-renderes)
    (prepare-players)
    (prepare-skyboxes)
    (initialize-render)
    (reset-commands)
    (gl-check-error))
  
  
  (method (setup-size)
    (size-change (get-size~ window)))
  
  
  (method (size-change size)
    (set! width (cast <fl> (get-width~ size)))
    (set! height (cast <fl> (get-height~ size)))
    (size-change~ eye size)
    (size-change~ history-camera size)
    (when showcases
      (iterate-table showcases
        (lambda (name showcase)
          (size-change~ showcase size)))))
  
  
  (method (start-world)
    )
  
  
  (method (initialize-render)
    (set! render-target (new Render-Target (fxround width) (fxround height))))
  
  
  (method (update-world-up gravity)
    (vertex-copy! world-up (gravity-up gravity)))
  
  
  (method (reset-commands)
    (when (or (not commands) (get-modified?~ commands))
      (set! commands (new Commands)))
    (set-last-no~ commands tick-no)
    (increase! tick-no))
  
  
  (method (setup-world)
    (set! paused? #f))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (slot installed-modules initialize (make-table test: eq?) getter generate)
  
  
  (method (user-assets?)
    (let ((role (get-current-role~ (get-application))))
      (world-setting 'world.user-assets? (eq? role 'programmer) 'default)))
  
  
  (method (prepare-assets)
    (define (gather-assets dir)
      (let ((queue (new-queue)))
        (define (try dir)
          (when (exists?~ (new-file~ dir ".assets"))
            (enqueue queue dir)))
        
        (when (and dir (exists?~ dir))
          (try dir)
          (iterate-directory~ dir
            try
            files?: #f
            directories?: #t))
        (queue-list queue)))
    
    (let ((world-directory (get-world-directory)))
      (set! base-assets (gather-assets (new Directory (cons (world-alias) '("lib" "world.client" "assets")))))
      (set! world-assets (gather-assets (and world-directory (new-directory~ world-directory "assets"))))
      (set! user-assets (gather-assets (and (user-assets?) {Directory Settings "assets"})))
      (set! all-assets (remove-false (append user-assets world-assets base-assets)))))
  
  
  (method (prepare-modules)
    (define (find-module target)
      (continuation-capture
        (lambda (return)
          (iterate-table installed-modules
            (lambda (name info)
              (bind (dirname . repository) info
                (when (filename=? target dirname)
                  (continuation-return return repository)))))
          #f)))
    
    (for-each (lambda (assets)
                (let ((module-dir (new-directory~ assets "module")))
                  (when (exists?~ module-dir)
                    (let ((module-dirname (parse~ module-dir)))
                      (unless (find-module module-dirname)
                        (let ((repo (install-repository module-dirname)))
                          (let ((name (repository-name repo)))
                            (table-set! installed-modules name (cons module-dirname repo)))))))))
              all-assets))
  
  
  (method (prepare-players)
    (set! message-player (make-world-player 'message World-Player 800 100))
    (set! status-player (make-world-player 'status World-Player 800 35)))
  
  
  (method (resize-players)
    (make-orthographic-matrix! (get-projection-matrix~ message-player) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix~ status-player) 0. width 0. height 0. 10.))
  
  
  (method (make-block-atlas (min-filter: min-filter #f) (mag-filter: mag-filter #f) (adder: adder #f))
    (let ((atlas (new Atlas min-filter: min-filter mag-filter: mag-filter)))
      (for-each (lambda (assets)
                  (add-directory-if-exists~ atlas (new-directory~ assets "tile")))
                all-assets)
      (when adder
        (adder atlas))
      (complete~ atlas)
      atlas))
  
  
  (method (prepare-block atlas atlas-nearest opaque-material transparent-material)
    (set! block-atlas atlas)
    (set! block-atlas-nearest atlas-nearest)
    (set! block-opaque opaque-material)
    (set! block-transparent transparent-material)
    (set! block-materials (make-table test: eq?))
    (set! block-matrix (make-identity-matrix)))
  
  
  ;;;
  ;;;; Materials
  ;;;
  
  
  (method (find-block-material name)
    (or (table-ref block-materials name #f)
        (let ((mat (case name
                     ((opaque) block-opaque)
                     ((transparent) block-transparent)
                     (else (new Material atlas: block-atlas-nearest texture: (get-texture~ block-atlas-nearest) renderer: (require-renderer name))))))
          (table-set! block-materials name mat)
          mat)))
  
  
  ;;;
  ;;;; Models
  ;;;
  
  
  (method (prepare-models)
    (set! models (make-table test: equal?)))
  
  
  ;;;
  ;;;; Showcases
  ;;;
  
  
  (method (prepare-showcases)
    (set! showcases (make-table test: eq?)))
  
  
  ;;;
  ;;;; Shaders
  ;;;
  
  
  (method (prepare-shaders)
    ;; shaders
    (build-default-shaders)
    (build-interface-shaders)
    (build-skybox-shaders)
    (build-color-shaders)
    (build-phong-shaders)
    (build-occlusion-shaders)
    (build-frame-shaders)
    (build-transformation-shaders)

    ;; mesh
    (set! mesh-programs (make-table test: eq?))
    (table-set! mesh-programs 'color          (new Mesh-Color-Program))
    (table-set! mesh-programs 'phong          (new Mesh-Phong-Program))
    (table-set! mesh-programs 'minecraft      (new Mesh-Minecraft-Program))
    (table-set! mesh-programs 'occlusion      (new Mesh-Occlusion-Program))
    (table-set! mesh-programs 'wireframe      (new Mesh-Wireframe-Program))
    (table-set! mesh-programs 'squareframe    (new Mesh-Squareframe-Program))
    (table-set! mesh-programs 'playerframe    (new Mesh-Playerframe-Program))
    (table-set! mesh-programs 'floorframe     (new Mesh-Floorframe-Program))
    (table-set! mesh-programs 'radial-blur    (new Mesh-Radial-Blur-Program))
    (table-set! mesh-programs 'motion-blur    (new Mesh-Motion-Blur-Program))
    (table-set! mesh-programs 'water          (new Mesh-Water-Program))
    (table-set! mesh-programs 'wet            (new Mesh-Wet-Program))
    (table-set! mesh-programs 'julia          (new Mesh-Julia-Program))
    (table-set! mesh-programs 'sierpinski     (new Mesh-Sierpinski-Program))
    (table-set! mesh-programs 'multitexture   (new Mesh-Multitexture-Program))
    (table-set! mesh-programs 'kaleidoscope   (new Mesh-Kaleidoscope-Program))
    (table-set! mesh-programs 'tunnel         (new Mesh-Tunnel-Program))
    (table-set! mesh-programs 'square-tunnel  (new Mesh-Square-Tunnel-Program))
    (table-set! mesh-programs 'fly            (new Mesh-Fly-Program))
    (table-set! mesh-programs 'pulse          (new Mesh-Pulse-Program))

    ;; block
    (set! block-program (find-mesh-program (or (find-setting 'world.block-shader #f) 'phong)))
    
    (gl-check-error))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))


  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (free-resources~ render-target)
    (detach-shaders~ block-program)
    (glDeleteTextures* (get-id~ (get-texture~ message-player)))
    (glDeleteTextures* (get-id~ (get-texture~ status-player)))
    (close-ambience))
  
  
  (method public (toggle-gc-sound)
    (set! gc-sound? (not gc-sound?))
    (display-on/off "GC sound" gc-sound?))
  
  
  (method public (garbage-collect)
    (let ((window (current-world-window)))
      (display-message "Garbage collecting" color: {Color Red})
      (render-scene~ window)
      (gc)
      (gc)
      (display-message "Done" color: {Color Green})
      (render-scene~ window)))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method protected virtual (zone-based?)
    #f)
  
  
  (method protected virtual (initialize-world)
    (set! version world-version)
    (set! first-camera 'free)
    (set! grid? start-grid?)
    (set! axes? (or start-axes? (find-setting 'world.axes? #f)))
    (set! axes-graduation? (find-setting 'world.axes-graduation? #f))
    (set! lighting? #t)
    (setup-interface)
    (unless (zone-based?)
      (setup-history))
    (setup-gc)
    (update-title))
  
  
  (method (setup-interface)
    (set! interface (make-world-player 'interface World-Interface 10 10))
    (make-orthographic-matrix! (get-projection-matrix~ interface) 0. 10. 0. 10. 0. 10.)
    (make-identity-matrix! (get-view-matrix~ interface))
    (set! interface-refresh-rate (find-setting 'world.interface-refresh-rate 1.))
    (set! interface-last-time -inf.0)
    (apply new Info-Pane parent: interface name: 'info visible?: #f (info-pane-properties))
    (apply new Profiler-Pane parent: interface name: 'profiler visible?: #f (profiler-pane-properties))
    (apply new Target-Pane parent: interface name: 'target visible?: #f (target-pane-properties))
    (apply new Script-Pane parent: interface name: 'script visible?: #f (script-pane-properties))
    (apply new Character-Pane parent: interface name: 'character visible?: #f (character-pane-properties))
    (setup-application-interface~ (get-application))
    (set-root~ window interface offscreen?: #f))
  
  
  (method (is-active?)
    (eq? self (current-world)))
  
  
  (method (is-inactive?)
    (not (is-active?)))
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method (zone-update)
    (enter-zone~ (get-process))
    (set! mounts-folio (new Folio 'wheels '(wheels hummer)))
    (set! flyers-folio (new Folio 'saucer '(saucer rocket)))
    ;; add player when not connected to server
    (when (and (client-side?~ (get-application)) (not (get-world-server~ (get-application))))
      (let ((zone (current-zone)))
        ;; eye
        (let ((eye-position (or (get-start-eye~ zone) default-start-eye))
              (eye-sight (or (get-start-eye-sight~ zone) default-start-eye-sight))
              (eye-up (or (get-start-eye-up~ zone) default-start-eye-up)))
          (set-position~ eye eye-position)
          (set-sight~ eye eye-sight)
          (set-up~ eye eye-up)
          (set-right~ eye (cross-normal& eye-sight eye-up))
          (derive-target~ eye)
          (camera-update~ eye))
        ;; player
        (let ((position (or (get-start-position~ zone) default-start-position))
              (sight (or (get-start-sight~ zone) default-start-sight))
              (up (or (get-start-up~ zone) default-start-up)))
          (let ((player (new (player-class) name: (effective-player-name~ (get-application)) parent: zone position: position)))
            (init-lookat~ player sight up)
            (add-element~ zone player)
            (set-current-me player)
            ;; eye
            (let ((start-mode (or (get-start-mode~ zone) 'first-person)))
              (if (neq? start-mode 'first-person)
                  (free-motion feedback?: #f)
                (person-motion feedback?: #f)
                (let ((distance (or (get-start-distance~ zone) default-start-distance)))
                  (setup-motion~ (current-motion) distance)))))))))
  
  
  ;;;
  ;;;; Keys
  ;;;
  
  
  (method (keys-task task <Task>)
    (declare (proper-tail-calls))
    (with-log-context "keys" keys-id support-state task
      (lambda (log-context)
        (set-context~ task log-context)
        (continuation-capture
          (lambda (exit)
            (ready-task~ task)
            (let (restart-loop)
              (with-current-loop
                (lambda ()
                  (with-restart-catcher 'resume-loop (present-current-loop-restart)
                    (lambda ()
                      (let (iter (previous (current-seconds)))
                        (let ((time (current-seconds)))
                          (with-task-mutex keys-sequential-state
                            (lambda ()
                              (unless (task-stopping?)
                                (site (keys on?: #t)
                                  (when (and (testing?) (memq? 'keys (get-task-trace)))
                                    (debug-string "K"))
                                  (unless (get-focus)
                                    (process-keys))))))
                          (let ((duration (- (current-seconds) time)))
                            (task-sleep (- keys-rate duration) exit #f))
                          (iter time)))))))
              (restart-loop)))))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (tick-task task <Task>)
    (declare (proper-tail-calls))
    (with-log-context "tick" tick-id support-state task
      (lambda (log-context)
        (set-context~ task log-context)
        (continuation-capture
          (lambda (exit)
            (ready-task~ task)
            (let (restart-loop)
              (with-current-loop
                (lambda ()
                  (with-restart-catcher 'resume-loop (present-current-loop-restart)
                    (lambda ()
                      (let (iter (previous (current-seconds)))
                        (let ((time (current-seconds)))
                          (let ((elapse (- time previous))
                                (max-elapse 10.))
                            ;; ignore ridiculous elapses like
                            ;; coming back from computer sleep
                            (unless (> elapse max-elapse)
                              (with-task-mutex tick-sequential-state
                                (lambda ()
                                  (unless (task-stopping?)
                                    (when (and (testing?) (memq? 'tick (get-task-trace)))
                                      (debug-string "T"))
                                    (tick-world time elapse)))))
                            (let ((duration (- (current-seconds) time)))
                              (task-sleep (- tick-rate duration) exit #f))
                            (iter time))))))))
              (restart-loop)))))))
  
  
  (method (tick-world time elapse)
    (unless (or debugged? (is-inactive?) (not render-ready?))
      (site (tick on?: #t)
        (let ((zone (current-zone)))
          (unless paused?
            (tick-actors #f time elapse))
          (site (tick-scene on?: #f parent: tick)
            (tick-scene~ zone elapse)
            (when showcase
              (tick-scene~ showcase elapse)))
          (site (tick-procedures on?: #f parent: tick)
            (when (not-null? tick-procedures)
              (for-each (lambda (proc)
                          (proc elapse))
                        tick-procedures)))))))
  
  
  (method (tick-actors commands time elapse)
    (let ((zone (current-zone))
          (me (current-me)))
      (for-each (lambda (actor)
                  (unless (eq? actor me)
                    (tick-sliced actor commands time elapse)))
                (get-actors~ zone))))
  
  
  (method (register-tick proc)
    (set! tick-procedures (cons proc tick-procedures)))
  
  
  (method (unregister-tick proc)
    (set! tick-procedures (remove! proc tick-procedures)))
  
  
  (method (world-update players)
    (let ((me (current-me)))
      (when (find-setting 'world.client.debug? #f)
        (terminal (effective-player-name~ (get-application)) 'world-update players))
      (for-each (lambda (info)
                  (bind (player-name player-avatar player-position player-sight player-up player-right) info
                    (let ((player (find-named-player player-name)))
                      (if (not player)
                          (add-player player-name player-avatar player-position player-sight player-up player-right)
                        (let ((lookat (get-lookat~ player)))
                          (let ((in-sync? (and (vertex=? (get-position~ player) player-position)
                                               (vertex=? (get-sight~ lookat) player-sight)
                                               (vertex=? (get-up~ lookat) player-up)
                                               (vertex=? (get-right~ lookat) player-right))))
                            (when (not in-sync?)
                              (set-position~ player player-position)
                              (init-lookat~ player player-sight player-up player-right)
                              (when (eq? player me)
                                (eye-behind-player)
                                (follow-player)))))))))
                players)
      (when (find-setting 'world.client.debug? #f)
        (debug-players))))
  
  
  (method (world-enter player-name player-avatar player-position player-lookat)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-enter player-name player-avatar player-position player-lookat))
    (bind (sight up right) player-lookat
      (add-player player-name player-avatar player-position sight up right))
    (display-message (format "{a} entered world" player-name))
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (method (add-player player-name player-avatar player-position player-sight player-up player-right)
    (let ((zone (current-zone)))
      (let ((player (new (player-class) name: player-name parent: zone position: (vertex 0. 0. 0.))))
        (set-position~ player player-position)
        (init-lookat~ player player-sight player-up player-right)
        (when player-avatar
          (if (dye? player-avatar)
              (set-color~ player player-avatar)
            (set-avatar~ player player-avatar)))
        (add-element~ zone player)
        (when (and (client-side?~ (get-process)) (equal? player-name (get-player-name~ (get-process))))
          (set-current-me player)
          (eye-behind-player)
          (follow-player)))))
  
  
  (method (world-exit player-name)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-exit player-name))
    (let ((player (find-named-player player-name)))
      (when player
        (remove-element player))
      (when (and (client-side?~ (get-process)) (equal? player-name (get-player-name~ (get-process))))
        (set-current-me #f))
      (display-message (format "{a} exited world" player-name)))
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (definition empty-commands
    (let ((commands (new Commands)))
      (complete~ commands)
      commands))
  
  
  (method (server-tick player-commands time elapse)
    (let ((zone (current-zone))
          (me (current-me)))
      (unless (null? player-commands)
        (when (find-setting 'world.client.debug? #f)
          (terminal (effective-player-name~ (get-application)) 'server-tick player-commands time elapse)))
      (unless (get-state~ me)
        (for-each (lambda (actor)
                    (let ((name (and (is? actor Player) (get-name~ actor))))
                      (let ((pair (and name (assoc name player-commands))))
                        (let ((commands (if pair (deserialize-commands (cdr pair)) empty-commands)))
                          (tick-sliced actor commands time elapse)))))
                  (get-actors~ zone)))
      (unless (null? player-commands)
        (when (find-setting 'world.client.debug? #f)
          (debug-players)))))
  
  
  (method (player-task task <Task>)
    (declare (proper-tail-calls))
    (with-log-context "player" player-id support-state task
      (lambda (log-context)
        (set-context~ task log-context)
        (continuation-capture
          (lambda (exit)
            (set! player-thread (current-thread))
            (ready-task~ task)
            (let (restart-loop)
              (with-current-loop
                (lambda ()
                  (with-restart-catcher 'resume-loop (present-current-loop-restart)
                    (lambda ()
                      (let (iter (previous (current-seconds)))
                        (let ((time (current-seconds)))
                          (let ((elapse (- time previous))
                                (max-elapse 10.))
                            ;; ignore ridiculous elapses like
                            ;; coming back from computer sleep
                            (unless (> elapse max-elapse)
                              (with-task-mutex player-sequential-state
                                (lambda ()
                                  (unless (task-stopping?)
                                    (site (player on?: #t)
                                      (when (and (testing?) (memq? 'player (get-task-trace)))
                                        (debug-string "P"))
                                      (unless paused?
                                        (let ((me (current-me)))
                                          (complete~ commands)
                                          (tick-sliced me commands time elapse)
                                          (when (not paused?)
                                            (site (history on?: #f parent: player)
                                              (add-history time elapse)))
                                          (reset-commands)))
                                      (update-transformation-time elapse)
                                      (let ((me (current-me))
                                            (motion (current-motion)))
                                        (restore-desired-distance~ motion elapse)
                                        (process-roll~ motion me))))))))
                          (set-player-boost? #f)
                          (let ((duration (- (current-seconds) time)))
                            (task-sleep (- player-rate duration) exit #f))
                          (iter time)))))))
              (restart-loop)))))))
  
  
  (method (tick-sliced actor commands time elapse)
    (declare (proper-tail-calls))
    (when commands
      (tick-actions~ actor commands))
    (continuation-capture
      (lambda (exit)
        (let ((slice (tick-slice~ actor)))
          (if (or (not slice) (not tick-slice?) (<= elapse slice))
              (tick~ actor commands time elapse exit)
            (let (iter (from 0.) (to slice))
              (tick~ actor commands (- time (- elapse to)) (- to from) exit)
              (when (< to elapse)
                (iter to (min elapse (+ to slice))))))))))
  
  
  (method (server-test argument)
    (1)
    (debug 'server-test)
    argument)
  
  
  (method (debug-players)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (unless (equal? (get-name~ player) "Server")
                    (terminal '->
                              (get-name~ player)
                              (get-position~ player)
                              (present-vertex (get-sight~ (get-lookat~ player))))))
                (get-players~ zone))))

  
  ;;;
  ;;;; Circularity
  ;;;
  
  
  ;; quick hacks around circular dependencies
  (method (polygon-class)
    Polygon)
  (method (triangle-class)
    Triangle)
  (method (quad-class)
    Quad)
  (method (missile-class)
    Missile)

  
  ;;;
  ;;;; Events
  ;;;
  
  
  ;; Interface
  (method (on-main-menu evt)
    (main-menu))
  
  (method (on-video-options evt)
    (video-options))
  
  (method (on-audio-options evt)
    (audio-options))
  
  (method (on-interface-options evt)
    (interface-options))
  
  (method (on-view-bindings evt)
    (view-bindings))
  
  (method (on-view-news evt)
    (view-news))
  
  (method (on-view-roadmap evt)
    (view-roadmap))
  
  (method (on-view-help evt)
    (view-help))
  
  (method (on-open-tutorial evt)
    (open-tutorial))
  
  (method (on-open-welcome evt)
    (open-welcome))
  
  (method (on-toggle-interface evt)
    (toggle-interface))
  
  (method (on-toggle-occlusion evt)
    (toggle-occlusion))
  
  (method (on-toggle-wireframe evt)
    (toggle-wireframe))
  
  (method (on-toggle-profiler evt)
    (toggle-profiler))
  
  (method (on-reset-profiling evt)
    (gc)
    (reset-profiling)
    (display-message "Profiling reset"))
  
  (method (on-exit-world evt)
    (exit-process~ (get-application)))
  
  (method (on-resume-world evt)
    (close-current-popup))

  (method (on-select/run-script evt)
    (select/run-script))

  (method (on-run-last-script evt)
    (run-last-script))
  
  (method (on-enter-press evt)
    (when enter-hook
      (enter-hook)))
  
  
  ;; Graphics
  (method (on-toggle-lighting evt)
    (toggle-lighting))
  
  (method (on-toggle-fog evt)
    (toggle-fog))
  
  (method (on-toggle-draw-gadgets evt)
    (toggle-draw-gadgets))
  
  (method (on-toggle-draw-normals evt)
    (toggle-draw-normals))
  
  (method (on-toggle-draw-elements evt)
    (toggle-draw-elements))
  
  (method (on-toggle-post-processing evt)
    (toggle-post-processing))
  
  
  ;; Sounds
  (method (on-change-music evt)
    (change-music))
  
  
  ;; Server
  (method (on-connect-to-server evt)
    (connect-to-server))
  
  (method (on-disconnect-from-server evt)
    (disconnect-from-server))
  
  (method (on-request-server-update evt)
    (request-server-update))
  
  
  ;; World
  (method (on-world-new evt)
    (world-new))
  
  (method (on-world-open evt)
    (world-open))
  
  (method (on-world-save evt)
    (world-save))
  
  (method (on-world-save-as evt)
    (world-save-as))
  
  (method (on-world-revert evt)
    (world-revert))
  
  
  ;; Zone
  (method (on-zone-new evt)
    (zone-new))
  
  (method (on-zone-open evt)
    (zone-open))
  
  (method (on-zone-open-content evt)
    (zone-open-content))
  
  (method (on-zone-save evt)
    (zone-save))
  
  (method (on-zone-save-as evt)
    (zone-save-as))
  
  (method (on-save-player&camera evt)
    (save-player&camera))
  
  (method (on-zone-revert evt)
    (zone-revert))
  
  
  ;; Game
  (method (on-bullet evt)
    ;; done in process-keys
    )
  
  (method (on-bomb evt)
    ;; done in process-keys
    )
  
  @wait
  (method (on-rapid-fire evt)
    (maybe-rapid-fire))
  
  (method (on-run evt)
    ;; done in process-keys
    )
  
  (method (on-blink evt)
    ;; done in process-keys
    )
  
  (method (on-warp evt)
    ;; done in process-keys
    )
  
  (method (on-start-sprint evt)
    (let ((me (current-controlled)))
      (start-sprint~ me)))
  
  (method (on-mind-control evt)
    (mind-control))
  
  (method (on-toggle-aim evt)
    (toggle-aim))
  
  (method (on-toggle-free-aim evt)
    (toggle-free-aim))
  
  (method (on-toggle-mount evt)
    (toggle-mount))
  
  (method (on-toggle-fly evt)
    (toggle-fly))
  
  (method (on-change-vehicle evt)
    (change-vehicle))
  
  (method (on-character-pane evt)
    (character-pane))
  
  
  ;; Motion
  (method (on-person-motion evt)
    (person-motion))
  
  (method (on-orbit-motion evt)
    (orbit-motion))
  
  (method (on-free-motion evt)
    (free-motion))
  
  (method (on-toggle-camera-smoothing evt)
    (toggle-camera-smoothing))
  
  (method (on-toggle-camera-lock evt)
    (toggle-camera-lock))
  
  
  ;; Movement
  
  
  ;; Edition
  (method (on-showcase evt)
    (let ((showcase (get-property~ evt showcase:)))
      (goto-showcase showcase)))
  
  (method (on-import-model evt)
    (import-model))
  
  (method (on-delete-target evt)
    (delete-target))
  
  (method (on-toggle-grid evt)
    (toggle-grid))
  
  (method (on-toggle-grid-plane evt)
    (toggle-grid-plane (get-property~ evt plane:)))
  
  (method (on-decrease-grid evt)
    (decrease-grid))
  
  (method (on-increase-grid evt)
    (increase-grid))
  
  (method (on-reload-textures evt)
    (reload-textures)
    (display-message "Textures reloaded"))
  
  (method (on-change-editor-mode evt)
    (change-editor-mode reversed?: (effective-event-reversed? evt)))
  
  (method (on-select-target-mode evt)
    (select-target-mode))
  
  (method (on-move-target-mode evt)
    (move-target-mode))
  
  (method (on-rotate-target-mode evt)
    (rotate-target-mode))
  
  (method (on-scale-target-mode evt)
    (scale-target-mode))
  
  
  ;; History
  (method (on-toggle-paused evt)
    (toggle-paused))
  
  (method (on-backward-history evt)
    (backward-history))
  
  (method (on-forward-history evt)
    (forward-history))
  
  (method (on-step-history evt)
    (step-history))
  
  (method (on-step-logic evt)
    (step-logic))
  
  (method (on-rewind-logic evt)
    (rewind-logic))
  
  (method (on-reset-history evt)
    (reset-history))
  
  (method (on-toggle-evaluate-future evt)
    (toggle-evaluate-future))
  
  
  ;; Window
  (method (on-toggle-windowed-mode evt)
    (toggle-windowed-mode))
  
  (method (on-live-gaia/world evt)
    (live-gaia/world))
  
  (method (on-design-gaia/world evt)
    (design-gaia/world))
  
  (method (on-restore-gaia/world evt)
    (restore-gaia/world))


  ;; Debug
  (method (on-toggle-axes evt)
    (toggle-axes))
  
  (method (on-toggle-axes-graduation evt)
    (toggle-axes-graduation))
  
  (method (on-toggle-info evt)
    (toggle-info))
  
  (method (on-toggle-target evt)
    (toggle-target))
  
  (method (on-toggle-script evt)
    (toggle-script))
  
  (method (on-toggle-orientation evt)
    (toggle-orientation))
  
  (method (on-toggle-debug-sectors evt)
    (toggle-debug-sectors~ (current-zone)))
  
  (method (on-toggle-debug-areas evt)
    (toggle-debug-areas~ (current-zone)))
  
  (method (on-toggle-draw-atlas evt)
    (toggle-draw-atlas))
  
  (method (on-toggle-draw-me evt)
    (toggle-draw-me))
  
  (method (on-change-missile-behavior evt)
    (change-missile-behavior reversed?: (effective-event-reversed? evt)))
  
  (method (on-reset-marks evt)
    (reset-all-marks~ (current-zone)))
  
  (method (on-clear-console evt)
    (if (get-controller-debugger)
        (clear-console)
      (display-error "Not connected to a debugger")))
  
  (method (on-clear-terminal evt)
    (clear-terminal))
  
  (method (on-toggle-gc-sound evt)
    (toggle-gc-sound))

  (method (on-garbage-collect evt)
    (garbage-collect))

  (method (on-explore-interface evt)
    (explore-interface))
  
  (method (on-remove-duplicate-blocks evt)
    (remove-duplicate-blocks~ (current-zone)))
  
  (method (on-test1 evt)
    (test1))

  (method (on-test2 evt)
    (test2))

  (method (on-test3 evt)
    (test3))

  (method (on-test4 evt)
    (test4))

  (method (on-test5 evt)
    (test5))

  (method (on-test6 evt)
    (test6))

  (method (on-test7 evt)
    (test7))

  (method (on-test8 evt)
    (test8))

  (method (on-test9 evt)
    (test9))

  (method (on-test0 evt)
    (test0))
  
  
  ;; Collision
  (method (on-setup-collisions evt)
    (set! evaluate-future? #f)
    (set! tick-slice? #f)
    (set-move-speed~ eye 0.05)
    (set-strafe-speed~ eye 0.02)
    (set-rotate-speed~ eye 0.02)
    (set-debug-collisions? #t)
    (when (shift-down?)
      (execute-script "world/generate/stairs"))
    (display-message "Collisions setup"))
  
  (method (on-toggle-debug-collisions evt)
    (set-debug-collisions? (not (get-debug-collisions?)))
    (update-parameter 'debug-collisions)
    (display-on/off "Debug collisions" (get-debug-collisions?)))
  
  (method (on-change-radiuses evt)
    (execute-script "world/collision/change-radiuses"))
  
  (method (on-test-collisions evt)
    (execute-script "world/collision/test"))
  
  
  ;; Utility
  (method (effective-event-reversed? evt)
    (shift-down?))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (setup-history)
    (set! history (new History (find-setting 'world.history-max 100))))
  
  
  (method (historical-moment n)
    (historical-moment~ history n))
  
  
  (method (add-history time elapse)
    (receive (metadata snapshot) (snapshot-metadata/world)
      (let ((moment (new Moment metadata snapshot (object-copy commands) time elapse)))
        (add-history~ history moment))))
  
  
  (method (backward-history)
    (when paused?
      (backward-history~ history)))
  
  
  (method (forward-history)
    (when paused?
      (forward-history~ history)))
  
  
  (method (truncate-future)
    (truncate-future~ history))
  
  
  (method (reset-history)
    (setup~ history)
    (display-message "History reset"))
  
  
  (method (step-history)
    (when paused?
      (step-history~ history)))
  
  
  (method (step-logic)
    (when paused?
      (step-logic~ history)))
  
  
  (method (rewind-logic)
    (when paused?
      (rewind-logic~ history)))
  
  
  (method (recalculate-future)
    (when paused?
      (recalculate-future~ history)))
  
  
  (method (update-future)
    (when paused?
      (recalculate-future)))
  
  
  (method (toggle-evaluate-future)
    (set! evaluate-future? (not evaluate-future?))
    (update-parameter 'evaluate-future)
    (display-on/off "Evaluate future" evaluate-future?))
  
  
  ;;;
  ;;;; Action
  ;;;
  
  
  (slot commands-hook initialize #f accessors generate)
  (slot action-hook   initialize #f accessors generate)
  
  
  (method (hook-commands commands)
    (if commands-hook
        (commands-hook commands)
      #t))
  
  
  (method (hook-action name arguments)
    (if action-hook
        (action-hook name arguments)
      #t))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method (process-idleness flag)
    (set! idle? flag)
    (when idle?
      (idle)))
  
  
  (method (idle)
    (let ((me (current-me)))
      (when (person-motion?)
        (idle~ me))))
  
  
  (method (motion-callback)
    (when (and (testing?) (memq? 'motion (get-task-trace)))
      (debug-string "M"))
    (when (and (not player-boost?) (neq? (current-thread) player-thread))
      (set-player-boost? #t)
      (task-wakeup player-thread))
    (when (not render-boost?)
      (set-render-boost? #t)
      (task-wakeup render-thread)))
  
  
  (method (move-forward)
    (move-forward~ (current-motion))
    (motion-callback))
  
  
  (method (move-backward)
    (move-backward~ (current-motion))
    (motion-callback))
  
  
  (method (run-forward)
    (run-forward~ (current-motion))
    (motion-callback))
  
  
  (method (run-backward)
    (run-backward~ (current-motion))
    (motion-callback))
  
  
  (method (blink-forward)
    (blink-forward~ (current-motion))
    (motion-callback))
  
  
  (method (blink-backward)
    (blink-backward~ (current-motion))
    (motion-callback))
  
  
  (method (warp-forward)
    (warp-forward~ (current-motion)))
  
  
  (method (warp-backward)
    (warp-backward~ (current-motion)))
  
  
  (method (move-left)
    (move-left~ (current-motion))
    (motion-callback))
  
  
  (method (move-right)
    (move-right~ (current-motion))
    (motion-callback))
  
  
  (method (process-move-up)
    (if (or paused? (and (person-motion?) fly?))
        (move-up)
      (space)))
  
  
  (method (move-up)
    (move-up~ (current-motion))
    (motion-callback))
  
  
  (method (process-move-down)
    (move-down))
  
  
  (method (move-down)
    (move-down~ (current-motion))
    (motion-callback))
  
  
  (method (process-rotate-left)
    (if (is-moving?)
        (move-left)
      (rotate-left)))
  
  
  (method (rotate-left)
    (rotate-left~ (current-motion))
    (motion-callback))
  
  
  (method (process-rotate-right)
    (if (is-moving?)
        (move-right)
      (rotate-right)))
  
  
  (method (rotate-right)
    (rotate-right~ (current-motion))
    (motion-callback))
  
  
  (method (space)
    (let ((me (current-me))
          (motion (current-motion)))
      (cond ((person-motion?)
             (space~ me commands))
            ((orbit-motion?)
             (move-up~ motion))
            (else
             (move-up)))))
  
  
  ;;;
  ;;;; Game
  ;;;
  
  
  (method (fire kind)
    (let ((me (current-controlled)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (fire~ me commands kind)))))
  
  
  (method (maybe-fire kind)
    (let ((me (current-controlled)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (maybe-fire~ me commands kind)))))
  
  
  (method (maybe-rapid-fire)
    (unless (orbit-motion?)
      (rapid-fire)))
  
  
  (method (rapid-fire)
    (add-action~ commands 'rapid-fire '()))
  
  
  (method (blink (reversed? #f))
    (if reversed?
        (blink-backward)
      (blink-forward)))
  
  
  (method (warp (reversed? #f))
    (if reversed?
        (warp-backward)
      (warp-forward)))
  
  
  ;;;
  ;;;; Eye
  ;;;
  
  
  (method (set-eye camera)
    (camera-copy! eye camera))
  
  
  (method (initialize-eye)
    (define (prepare-eye)
      (cond ((find-setting 'world.eye #f)
             (set-position~ eye (find-setting 'world.eye #f))
             (set-target~ eye (find-setting 'world.eye-target #f))
             (set-sight~ eye (find-setting 'world.eye-sight #f))
             (set-up~ eye (find-setting 'world.eye-up #f))
             (set-right~ eye (find-setting 'world.eye-right #f)))
            (else
             (set-position~ eye (vertex 65. 35. 65.))
             (set-sight~ eye (vertex -.6717990040779114 -.3334861397743225 -.6614174246788025))
             (set-up~ eye (vertex -.23764048516750336 .9427545070648193 -.23396790027618408))
             (set-right~ eye (vertex .7015790343284607 -6.643728678312755e-9 -.7125917077064514)))))
    
    (set-zoom-factor~ eye 10.9)
    (set-move-speed~ eye (find-setting 'world.camera-move-speed .2))
    (set-run-speed~ eye (find-setting 'world.camera-run-speed 1.5))
    (set-blink-speed~ eye (find-setting 'world.camera-blink-speed 2.))
    (set-warp-speed~ eye (find-setting 'world.camera-warp-speed 4.))
    (set-strafe-speed~ eye (find-setting 'world.camera-strafe-speed .1))
    (set-rotate-speed~ eye (find-setting 'world.camera-rotate-speed .035))
    (prepare-eye)
    (derive-target~ eye)
    (camera-update~ eye))
  
  
  (method (reset-camera)
    (vertex-copy! world-up (vertex 0. 1. 0.))
    (reset-camera~ (current-camera)))
  
  
  (method (hook-eye)
    (if eye-hook
        (eye-hook)
      #t))
  
  
  (method (eye-stable-callback stable?)
    (when (not stable?)
      (when (and render-thread (not render-boost?))
        (when (and (testing?) (memq? 'eye (get-task-trace)))
          (debug-string "E"))
        (when (and (not player-boost?) (neq? (current-thread) player-thread))
          (set-player-boost? #t)
          (task-wakeup player-thread))
        (set-render-boost? #t)
        (task-wakeup render-thread))))
  
  
  (method (toggle-orientation)
    (set! orientation? (not orientation?))
    (update-parameter 'orientation))

  
  (method (zoom-in)
    (zoom-in~ (current-motion)))
  
  
  (method (zoom-out)
    (zoom-out~ (current-motion)))
  
  
  (method (toggle-camera-smoothing)
    (set-camera-smoothing? (not (get-camera-smoothing?)))
    (update-parameter 'camera-smoothing)
    (display-on/off "Camera smoothing" (get-camera-smoothing?)))
  
  
  (method (toggle-camera-lock)
    (let ((camera (next-element '(locked free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'locked)
        (follow-player))
      (update-parameter 'camera-lock)
      (display-message (format "Camera {a}" camera))))
  
  
  (method (current-controlled)
    (let ((me (current-me)))
      (effective-controlled~ me)))
  
  
  (method (follow-player)
    (follow-player~ (current-motion)))
  
  
  (method (follow-actor actor)
    (follow-actor~ (current-motion) actor))
  
  
  (method (eye-behind-player)
    (eye-behind-player~ (current-motion)))
  
  
  (method (eye-behind-actor actor)
    (eye-behind-actor~ (current-motion) actor))
  
  
  (method (player-lens player)
    (player-lens~ (current-motion) player))
  
  
  (method (mark-eye)
    (let ((zone (current-zone))
          (me (current-me)))
      (add-mark~ zone (new Vertex-Mark (player-lens me) color: red-dye))
      (add-mark~ zone (new Vertex-Mark (get-position~ (current-camera)) color: green-dye))
      (add-mark~ zone (new Vertex-Mark (get-target~ (current-camera)) color: blue-dye))))
  
  
  (definition current-area-visit <fx>
    -1)
  
  
  (definition travel-triangle
    (new Triangle #f (vector (vertex 0. 0. 0.) (vertex 0. 0. 0.) (vertex 0. 0. 0.))))
  
  (definition travel-quad
    (new Quad #f (vector (vertex 0. 0. 0.) (vertex 0. 0. 0.) (vertex 0. 0. 0.) (vertex 0. 0. 0.))))
  
  
  (method (travel-ray-polygons& proc orig <f64vector> dir <f64vector> radius <fl> breadth <fx> max-distance <fl> sphere-matrix (filter: filter #f) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f))
    (validate-vertex-normalized dir)
    (let ((zone (current-zone)))
      (increase! current-area-visit)
      (let ((step (cast <fl> (get-area-size~ zone))))
        (let ((position (vertex-copy& orig))
              (position-increment (vertex-scalar*& dir step))
              (position-distance 0.))
          (let (iter)
            (or (proc
                  (lambda (proc)
                    (iterate-position-neighbor-areas~ zone position breadth
                      (lambda (area <Area>)
                        (unless (= (get-visit~ area) current-area-visit)
                          (iterate-polygons~ area
                            (lambda (element polygons offset)
                              (let ((poly-center (vertex& (f64vector-ref polygons (+ offset 0)) (f64vector-ref polygons (+ offset 1)) (f64vector-ref polygons (+ offset 2))))
                                    (poly-radius (f64vector-ref polygons (+ offset 15))))
                                (when (ray-intersects-sphere? orig dir poly-center (+ radius poly-radius))
                                  (let ((poly (if (nan? (f64vector-ref polygons (+ offset 12)))
                                                  travel-triangle
                                                travel-quad)))
                                    (when (or (not filter)
                                              (begin
                                                (polygon-extract!~ poly element polygons offset #f)
                                                (filter poly)))
                                      (polygon-extract!~ poly element polygons offset sphere-matrix)
                                      (proc poly)))))))
                          (unless ignore-entities?
                            (iterate-entities~ area
                              (lambda (entity)
                                (unless (or (not (element-visible?~ entity))
                                            (is? entity Missile)
                                            (and ignore-players? (is? entity Player)))
                                  (when (ray-intersects-sphere? orig dir (transformed-center~ entity) (+ radius (get-radius~ entity)))
                                    (for-each-bounding-quad~ entity sphere-matrix travel-quad
                                      proc))))))
                          (set-visit~ area current-area-visit))))))
                (let ((new-distance (+ position-distance step)))
                  (when (<= new-distance max-distance)
                    (vertex+! position position position-increment)
                    (set! position-distance new-distance)
                    (iter)))))))))
  
  
  (method (ray-closest-polygon orig <f64vector> dir <f64vector> max-distance <fl> (filter: filter #f) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f))
    (travel-ray-polygons&
      (lambda (iterate)
        (let ((closest #f)
              (distance #f))
          (iterate
            (lambda (poly)
              (let ((cls (ray-closest-triangle~ poly orig dir filter)))
                (when cls
                  (bind (poly dist) cls
                    (when (and (or (not distance)
                                   (< dist distance))
                               (< dist max-distance))
                      (set! closest (list (copy-polygon~ poly) dist))
                      (set! distance dist)))))))
          closest))
      orig
      dir
      0.
      1
      max-distance
      #f
      ignore-entities?: ignore-entities?
      ignore-players?: ignore-players?))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method protected virtual (player-class)
    Player)
  
  
  (method (is-moving?)
    (or (and (not (get-autotrack-camera?)) (not (get-cursor-mode?)))
        (and down? (or moving? (not (get-independant-camera?))))))
  
  
  (method (mind-control)
    (let ((me (current-me)))
      (let ((controlled (get-controlled~ me))
            (target (first-target)))
        (if (and (is? target Actor)
                 (neq? target controlled))
            (control~ me target)
          (when controlled
            (relinquish-control~ me))))))
  
  
  (method (toggle-aim)
    (set! aim? (not aim?))
    (update-parameter 'aim))
  
  
  (method (toggle-free-aim)
    (set! free-aim? (not free-aim?))
    (update-parameter 'free-aim)
    (display-on/off "Free aim" free-aim?))

  
  (method (draw-aim)
    (let ((me (current-me)))
      (let ((lens (player-lens me)))
        (let ((x (vertex-x lens))
              (y (vertex-y lens))
              (z (vertex-z lens))
              (size .05)
              (width .0015))
          (render-line (vertex (- x size) y z)
                       (vertex (+ x size) y z)
                       width
                       white-dye)
          (render-line (vertex x (- y size) z)
                       (vertex x (+ y size) z)
                       width
                       white-dye)
          (render-line (vertex x y (- z size))
                       (vertex x y (+ z size))
                       width
                       white-dye)))))
  
  
  ;;;
  ;;;; Resize
  ;;;
  
  
  (method protected virtual (resize-scene)
    (let ((width (fxround width))
          (height (fxround height)))
      (when interface
        (set-size~ interface (new Dimension width height)))
      (resize~ render-target width height))
    (resize-players))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (render-task task <Task>)
    (declare (proper-tail-calls))
    (let ((window (current-world-window)))
      (with-log-context "render" render-id support-state task
        (lambda (log-context)
          (set-context~ task log-context)
          (continuation-capture
            (lambda (exit)
              (set! render-thread (current-thread))
              (ready-task~ task)
              (let (restart-loop)
                (with-current-loop
                  (lambda ()
                    (with-restart-catcher 'resume-loop (present-current-loop-restart)
                      (lambda ()
                        (let ((zone (current-zone)))
                          (let (iter)
                            (let ((time (current-seconds))
                                  (camera (current-camera)))
                              (with-task-mutex render-sequential-state
                                (lambda ()
                                  (unless (task-stopping?)
                                    (site (render on?: #t)
                                      (site (process-events on?: #t parent: render)
                                        (let (loop)
                                          (let ((thunk (read-render-event)))
                                            (when (not (eof-object? thunk))
                                              (thunk)
                                              (loop)))))
                                      (update-stable~ camera camera-stable-delay)
                                      (when render-boost?
                                        (let ((trimmed (trim-content 0)))
                                          (when (> trimmed 0)
                                            (decrease-sectors-generating~ zone trimmed)))
                                        (set! render-what 0))
                                      (when (and (testing?) (memq? 'render (get-task-trace)))
                                        (debug-string "*"))
                                      (render-world)
                                      (when render-what
                                        (set! render-what (if (= render-what 1)
                                                              #f
                                                            (+ render-what 1))))
                                      (log-transition log-context render-sync-state)
                                      (when render-ready?
                                        (site (render-sync on?: #t parent: render)
                                          (render-sync~ window)))))))
                              (set-render-boost? #f)
                              (let ((rate (let ((stable? (get-stable?~ camera))
                                                (generating? (> (get-sectors-generating~ zone) 0)))
                                            (if generating?
                                                (if stable? render-rate-idle-generate render-rate-busy-generate)
                                              (if stable? render-rate-idle render-rate-busy))))
                                    (duration (- (current-seconds) time)))
                                (task-sleep (- rate duration) exit #f)))
                            (iter)))))))
                (restart-loop))))))))
  
  
  (method protected virtual (render-world)
    (define (update-interface)
      (when interface?
        (let ((now (current-seconds)))
          (when (> (- now interface-last-time) interface-refresh-rate)
            (let ((info <View> (child~ interface 'info))
                  (target <View> (child~ interface 'target))
                  (profiler <View> (child~ interface 'profiler)))
              (when (or (get-visible?~ info)
                        (get-visible?~ target)
                        (get-visible?~ profiler))
                (unless interface-refresh?
                  (refresh-interface))))))))
    
    (when (and render-ready? (not debugged?))
      (update-interface)
      (let ((zone (current-zone)))
        (when post-processing?
          (preprocess-render))
        (glClear GL_COLOR_BUFFER_BIT)
        (glClear GL_DEPTH_BUFFER_BIT)
        (setup-camera~ (current-camera))
        (setup-lighting~ zone)
        (draw-world)
        (render-interface)
        (when post-processing?
          (postprocess-render))
        (gl-check-error))))
  
  
  (method (preprocess-render)
    (activate~ render-target))
  
  
  (method (postprocess-render)
   ;; Copy the color buffer from the render target onto the native color buffer (0)
   (blit~ render-target 0)
   (deactivate~ render-target))
  
  
  (definition target-dyes
    (list red-dye)
    @wait
    (list red-dye (dye .890 .043 .937 1.) blue-dye))
  
  
  (method (draw-world)
    (site (draw-world on?: #t parent: render)
      (let ((zone (current-zone))
            (me (current-me)))
        (draw-zone~ zone)
        (when grid?
          (draw-grid))
        (when axes?
          (draw-axes))
        (when (and aim? free-aim?)
          (draw-aim))
        (when orientation?
          (draw-orientation~ (current-camera)))
        (when paused?
          (site (draw-history on?: #t parent: draw-world)
            (draw-history)))
        (let ((skybox (get-skybox~ zone)))
          (when skybox
            (draw-skybox~ skybox)))
        (site (draw-renderers on?: #t parent: draw-world)
          (render-opaque)
          (render-transparent))
        (site (draw-procedures on?: #f parent: draw-world)
          (when (not-null? draw-procedures)
            (for-each (lambda (proc)
                        (proc))
                      draw-procedures)))
        (let ((dyes target-dyes))
          (for-each (lambda (elem <Element>)
                      (draw-target~ elem (car dyes))
                      (when draw-normals?
                        (for-each (lambda (poly)
                                    (draw-plane poly red-dye))
                                  (element-polygons~ elem)))
                      (when (not-null? (cdr dyes))
                        (set! dyes (cdr dyes))))
                    target))
        (when (and target-widget (not-null? target) (target-moveable?~ (cast <Element> (car target))))
          (draw-widget~ target-widget))
        (when (and target-polygon (null? target))
          (draw-polygon target-polygon red-dye)
          (when draw-normals?
            (draw-plane target-polygon red-dye)))
        (when (not-null? highlighted-polygons)
          (for-each (lambda (poly)
                      (draw-polygon poly blue-dye))
                    highlighted-polygons))
        (when (get-draw-me?~ zone)
          (render-character))
        (when (and showcase interface?)
          (draw-showcase~ showcase))
        (gl-check-error))))
  
  
  (method (draw-neighbors @radius <fl> proc <procedure>) <void>
    (let ((zone (current-zone)))
      (draw-eye-neighbors~ zone (current-camera) view-distance @w radius proc)))
  
  
  (method (draw-sectors) <void>
    (site (draw-sectors on?: #t parent: draw-world)
      (set! visited-sectors 0)
      (set! rendered-sectors 0)
      
      (reset-renderes)
      
      (use~ block-program)
      (bind-material~ block-program block-opaque)
      (bind-uniforms~ block-program block-matrix #f 0 0.)
      
      (draw-neighbors @w max-entity-radius
        (lambda (sector <Sector>)
          (draw-sector sector)
          (site (register-meshes on?: #f parent: draw-neighbors)
            (let ((other-meshes (get-other-meshes~ sector)))
              (when other-meshes
                (register-meshes other-meshes))))
          (site (register-entities on?: #f parent: draw-neighbors)
            (let ((entities (get-entities~ sector)))
              (when (not-null? entities)
                (register-entities entities))))))
      ;; need to register last for correct drawing
      (register-entity (current-me))
      
      (unbind-uniforms~ block-program)
      (unuse~ block-program)
      (gl-check-error)))
  
  
  (method (draw-sector sector <Sector>) <void>
    (increase! visited-sectors)
    (let ((mesh (get-mesh~ sector)))
      (when mesh
        (draw-mesh~ block-program mesh)
        (increase! rendered-sectors))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (draw-axes)
    ;; X
    (render-line (vertex -10.0   0.0   0.0) (vertex 10.0  0.0  0.0) .05 red-dye)
    (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0  0.5) .05 red-dye)
    (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0 -0.5) .05 red-dye)
    
    ;; Y
    (render-line (vertex   0.0 -10.0   0.0) (vertex  0.0 10.0  0.0) .05 green-dye)
    (render-line (vertex   0.0  10.0   0.0) (vertex  0.5  9.5  0.0) .05 green-dye)
    (render-line (vertex   0.0  10.0   0.0) (vertex -0.5  9.5  0.0) .05 green-dye)
    
    ;; Z
    (render-line (vertex   0.0   0.0 -10.0) (vertex  0.0  0.0 10.0) .05 blue-dye)
    (render-line (vertex   0.0   0.0  10.0) (vertex  0.5  0.0  9.5) .05 blue-dye)
    (render-line (vertex   0.0   0.0  10.0) (vertex -0.5  0.0  9.5) .05 blue-dye)
    
    (when axes-graduation?
      (let ((grad .15))
        ;; X
        (loop (for x <fl> from -9. to 9. by 1.)
              (render-line (vertex x (- grad) 0.0) (vertex x grad 0.0) .01 red-dye))
        
        ;; Y
        (loop (for y <fl> from -9. to 9. by 1.)
              (render-line (vertex (- grad) y 0.0) (vertex grad y 0.0) .01 green-dye))
        
        ;; Z
        (loop (for z <fl> from -9. to 9. by 1.)
              (render-line (vertex 0.0 (- grad) z) (vertex 0.0 grad z) .01 blue-dye)))))
  
  
  (method (draw-history)
    (draw-history~ history))
  
  
  (method (registered-draw name)
    (table-ref draw-procedure-names name #f))
  
  
  (method (register-draw name proc)
    (when (registered-draw name)
      (unregister-draw name))
    (set! draw-procedures (cons proc draw-procedures))
    (table-set! draw-procedure-names name proc))
  
  
  (method (unregister-draw name)
    (let ((proc (table-ref draw-procedure-names name)))
      (set! draw-procedures (remove! proc draw-procedures))
      (table-clear draw-procedure-names name)))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method (refresh-interface (condition: condition #f))
    (when (or (not condition)
              (some? (lambda (name)
                       (get-visible?~ (child~ interface name)))
                     condition))
      (set! interface-refresh? #t)
      (let ((info (child~ interface 'info)))
        (when (get-visible?~ info)
          (view-info~ info)))
      (let ((target (child~ interface 'target)))
        (when (get-visible?~ target)
          (view-target~ target)))
      (let ((profiler (child~ interface 'profiler)))
        (when (get-visible?~ profiler)
          (view-sites~ profiler)))))
  
  
  (method (render-interface)
    (when interface?
      (site (render-interface on?: #t parent: render)
        (when interface-refresh?
          (invalidate-view~ interface)
          (set! interface-last-time (current-seconds))
          (set! interface-refresh? #f))
        (render-player~ interface)
        (when message
          (draw-message))
        (when status
          (draw-status)))))
  
  
  (method (explore-interface)
    (set! explore-interface? (not explore-interface?))
    (when explore-interface?
      (set! interface? #t))
    (set-window-cursor~ (current-world-window) (if explore-interface? :spy :arrow)))
  
  
  (method protected virtual (create-main-menu)
    (new World-Main-Menu visible?: #t))
  
  
  (method (main-menu)
    (let ((pane (find-if (lambda (pane) (is? pane World-Panel)) (get-children~ interface) reversed?: #t)))
      (if pane
          (close~ pane)
        (open-menu (create-main-menu))
        (release-cursor~ window)
        (set-cursor-mode? #t))))
  
  
  (method (main-menu-destroyed)
    (set-cursor-mode? #f)
    (when (not (get-autotrack-camera?))
      (capture-cursor~ window)))
  
  
  (method (video-options)
    (open-frame (new World-Video-Options size: {Dimension 366 588} location: 'center)))
  
  
  (method (audio-options)
    (open-frame (new World-Audio-Options size: {Dimension 366 588} location: 'center)))
  
  
  (method (interface-options)
    (open-frame (new World-Interface-Options size: {Dimension 366 588} location: 'center)))
  
  
  (method (view-bindings)
    (open-frame (new World-Bindings-Viewer size: {Dimension 406 588} location: 'center)))
  
  
  (method (view-news)
    (open-document (news-file~ (get-application)) class: World-Formatted-Text-View))
  
  
  (method (view-roadmap)
    (open-document (roadmap-file~ (get-application)) class: World-Formatted-Text-View))
  
  
  (method (view-help)
    (open-document (help-file~ (get-application)) class: World-Formatted-Text-View))
  
  
  (method (open-tutorial)
    (close-current-popup)
    (open-tutorial-zone))
  
  
  (method (open-welcome)
    (close-current-popup)
    (let ((zone (open-welcome-zone start-script: "tutorial/welcome")))
      (let ((designer (get-designer~ zone)))
        (set-property~ designer zone 'start-script "tutorial/welcome")
        (set-property~ designer zone 'next-zone 'welcome)
        (save~ designer)
        (set-modified?~ designer #f))))
  
  
  (method (close-current-popup)
    (let ((pane (find-if (lambda (pane) (is? pane World-Panel)) (get-children~ interface) reversed?: #t)))
      (when pane
        (close~ pane))))
  
  
  ;;;
  ;;;; Win / Lose
  ;;;
  
  
  (method (win player)
    (let ((zone (current-zone)))
      (win~ player)
      (let ((block (find-element~ zone
                     (lambda (obj)
                       (and (is? obj Block)
                            (eq? (get-user-data~ obj) 'win))))))
        (set-color~ block blue-dye))
      (unless paused?
        (sleep .5)
        (reset-position~ player)
        (reset-state~ player)
        (reset-game))))
  
  
  (method (lose player)
    (lose~ player)
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (reset-game)
    (setup-history))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method (missile-hit missile collision)
    (let ((zone (current-zone))
          (element (get-element~ collision)))
      (cond ((is? element Actor)
             (if (and (eq? (get-actor~ missile) element)
                      (< (get-alive~ missile) (get-self-wound-grace~ element)))
                 'ignore
               (wound~ element)
               'remove))
            (else
             (case (get-missile-behavior~ zone)
               ((absorb)
                'remove)
               ((rebound)
                (let ((normal (get-normal~ (get-plane~ collision)))
                      (velocity (get-velocity~ missile)))
                  (let ((rebound (dot-product normal velocity)))
                    (set-velocity~ missile (vertex- velocity (vertex-scalar* normal (* 2. rebound))))))
                'stop)
               ((slide)
                'slide)
               ((destroy)
                (let ((editable? (zone-editable?~ zone))
                      (destructible? (zone-destructible?~ zone)))
                  (define (remove element)
                    (if editable?
                        (editor-remove-element element)
                      (remove-element element)))
                  
                  (when (and element (or editable? destructible?))
                    (play-sound-file "sound/explosion")
                    (case (get-kind~ missile)
                      ((bullet)
                       (remove element))
                      ((bomb)
                       (let ((pos (get-position~ element)))
                         (iterate-position-neighbor-areas~ zone pos 1
                           (lambda (area)
                             (for-each (lambda (block)
                                         (when (< (vertex-distance pos (get-position~ block)) 1.9)
                                           (remove block)))
                                       (get-blocks~ area)))))))))
                'remove))))))
  
  
  (method (change-missile-behavior (reversed?: reversed? #f))
    (let ((zone (current-zone))
          (next (if reversed? previous-element next-element)))
      (unimplemented-connected)
      (set-missile-behavior~ zone (next '(destroy absorb rebound slide) (get-missile-behavior~ zone)))
      (display-message (format "{a}" (capitalize (symbol->string (get-missile-behavior~ zone)))))))

  
  ;;;
  ;;;; World
  ;;;

  
  (method (world-new)
    (unimplemented-connected)
    (new-world)
    (display-message "New world"))
  
  
  (method (world-open)
    (unimplemented-connected)
    (let ((pane (find-type~ interface World-Open)))
      (if pane
          (close~ pane)
        (open-frame (new World-Open size: {Dimension 366 588} location: 'center)))))
  
  
  (method (world-save)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (world-save-to moniker)
        (world-save-as))))
  
  
  (method (world-save-as)
    (unimplemented-connected)
    (let ((file (choose-new-file title: "Save New World" default-extension: "world" extensions: '(("World Files" . "world")) directory: {Directory Settings "worlds"})))
      (world-save-to file)))
  
  
  (method (world-save-to file)
    (unimplemented-connected)
    (with-window-cursor :wait
      (lambda ()
        (parameterize ((pretty-print-forms? #f))
          (save-to~ designer file))
        (update-title)
        (display-message "Saved"))))
  
  
  (method (world-revert)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (open-world moniker)
        (bell))))
  
  
  (method (get-world-directory)
    (let ((moniker (get-moniker)))
      (when moniker
        (get-parent~ moniker))))
  
  
  (method virtual (get-zones-directories)
    (let ((world-directory (get-world-directory)))
      (if world-directory
          (list (new-directory~ world-directory "zones"))
        '())))
  
  
  (method virtual (update-title)
    (define (present-zone)
      (let ((zone (current-zone+)))
        (if (not zone)
            "New"
          (present-title (get-moniker~ zone) (get-modified?~ zone)))))
    
    (define (present-title moniker modified?)
      (format "{a}{a}"
              (present-name moniker)
              (present-modified modified?)))
    
    (define (present-name moniker)
      (if (not moniker)
          "New"
        (get-base~ moniker)))
    
    (define (present-modified modified?)
      (if modified?
          " *"
        ""))
      
    (define (present-directory moniker)
        (if (not moniker)
            ""
          (let ((parent (get-world-directory)))
            (if (not parent)
                ""
              (format " ~{{a}}" (present-location~ parent))))))
    
    (set-title~ window (format "World - {a} {a}"
                               (present-zone)
                               (present-directory (get-moniker)))))
  
  
  (method (get-moniker)
    (get-origin~ (get-form~ designer)))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (when #t @buggy (neq? flag (get-modified?~ designer))
      (set-modified?~ designer flag)
      (update-title)))
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method protected virtual (zone-instantiate)
    (new-zone))

  
  (method (zone-new)
    (unimplemented-connected)
    (zone-confirm-close
      (lambda ()
        (with-window-cursor :wait
          (lambda ()
            (zone-instantiate)
            (set-grid? #t)
            (update-title)
            (display-message "New zone"))))))
  
  
  (method (zone-open)
    (unimplemented-connected)
    (let ((pane (find-type~ interface Zone-Open)))
      (if pane
          (close~ pane)
        (zone-confirm-close
          (lambda ()
            (open-frame (new Zone-Open size: {Dimension 366 588} location: 'center)))))))
  
  
  (method (zone-open-content)
    (unimplemented-connected)
    (let ((pane (find-type~ interface Zone-Open)))
      (if pane
          (close~ pane)
        (zone-confirm-close
          (lambda ()
            (open-frame (new Zone-Open size: {Dimension 366 588} location: 'center start-script?: #f)))))))
  
  
  (method (zone-container moniker)
    (get-parent~ (get-parent~ (get-parent~ moniker))))
  
  
  (method virtual (zone-writable? moniker)
    (let ((zone (current-zone)))
      (let ((moniker (get-moniker~ zone)))
        (and moniker writable?))))
  
  
  (method virtual (new-zone-file base)
    (let ((directory (or (and newable? (get-world-directory))
                         (let ((dir {Directory Settings "worlds" "user"}))
                           (if (exists?~ dir)
                               dir
                             (create-directories~ dir)
                             (world-save-to (new-file~ dir "_user.world"))
                             dir))))
          (path (split base "/")))
      (new-file~ directory (append (cons "zones" path) (list (zone-filename (last path)))))))
  
  
  (method (zone-save (pre: pre #f) (post: post #f) (feedback?: feedback? #t))
    (unimplemented-connected)
    (let ((zone (current-zone)))
      (let ((moniker (get-moniker~ zone)))
        (if (zone-writable? moniker)
            (begin
              (when pre
                (pre))
              (zone-save-to moniker feedback?: feedback?)
              (when post
                (post)))
          (zone-save-as pre: pre post: post feedback?: feedback?)))))
  
  
  (method (zone-save-as (pre: pre #f) (post: post #f) (feedback?: feedback? #t))
    (unimplemented-connected)
    (open-string
      title: "Choose New Zone"
      prefix: "Zone:"
      initial-value: "new"
      action: (lambda (base)
                (let ((file (new-zone-file base)))
                  (define (create)
                    (create-directories~ file)
                    (when pre
                      (pre))
                    (zone-save-to file feedback?: feedback?)
                    (when post
                      (post)))
                  
                  (if (exists?~ file)
                      (open-message (format "Zone {a} already exists. Do you want to replace it?" base)
                                    caption: "Save"
                                    type: 'confirmation
                                    yes: "Yes"
                                    no: "No"
                                    cancel: "Cancel"
                                    execute: (lambda (evt)
                                               (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog))
                                                     (button (get-property~ evt button:)))
                                                 (close~ dialog)
                                                 (case button
                                                   ((yes) (create))
                                                   ((no))
                                                   ((cancel) (signal-cancel))))))
                    (create))))))
  
  
  (method (zone-save-to file (feedback?: feedback? #t))
    (unimplemented-connected)
    (with-window-cursor :wait
      (lambda ()
        (let ((zone (current-zone))
              (me (current-me)))
          (let ((designer (get-designer~ zone)))
            (when (or (not (get-start-mode~ zone))
                      (not (get-start-eye~ zone))
                      (not (get-start-position~ zone)))
              (save-mode)
              (save-camera)
              (save-player))
            (parameterize ((pretty-print-forms? #f))
              (save-to~ designer file))
            (update-title)
            (when feedback?
              (display-message "Saved")))))))
  
  
  (method (save-mode)
    (unimplemented-connected)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone)))
        (set-property~ designer zone 'start-mode (if (person-motion?) 'first-person 'free-camera)))))
  
  
  (method (save-camera)
    (unimplemented-connected)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone)))
        (set-property~ designer zone 'start-eye (get-position~ eye))
        (set-property~ designer zone 'start-eye-sight (get-sight~ eye))
        (set-property~ designer zone 'start-eye-up (get-up~ eye)))))
  
  
  (method (save-player)
    (unimplemented-connected)
    (let ((zone (current-zone))
          (me (current-me)))
      (let ((designer (get-designer~ zone)))
        (set-property~ designer zone 'start-position (get-position~ me))
        (let ((lookat (get-lookat~ me)))
          (set-property~ designer zone 'start-sight (get-sight~ lookat))
          (set-property~ designer zone 'start-up (get-up~ lookat)))
        (set-property~ designer zone 'start-distance (get-desired-distance~ (current-motion))))))
  
  
  (method (save-player&camera (user-feedback?: user-feedback? #t))
    (zone-save
      pre: (lambda ()
             (save-mode)
             (save-camera)
             (save-player))
      post: (lambda ()
              (when user-feedback?
                (display-message "Player & camera saved")))
      feedback?: #f))
  
  
  (method (zone-confirm-close post)
    (let ((zone (current-zone)))
      (before-close~ zone)
      (if (not (get-modified?~ zone))
          (post)
        (open-message "Save changes to zone?"
                      caption: "Save"
                      type: 'confirmation
                      yes: "Yes"
                      no: "No"
                      cancel: "Cancel"
                      execute: (lambda (evt)
                                 (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog))
                                       (button (get-property~ evt button:)))
                                   (close~ dialog)
                                   (case button
                                     ((yes) (zone-save post: post))
                                     ((no) (post))
                                     ((cancel) (signal-cancel)))))))))
  
  
  (method (zone-save-exit)
    (let ((zone (current-zone)))
      (let ((settings (get-settings~ (get-application)))
            (setting-name 'world.last-zone)
            (path (determine-path~ zone)))
        (set-setting~ settings setting-name (and path (if (eq? path 'new) path (join path "/"))))
        (save-content~ settings))
      (when zone
        (save-exit~ zone))))
  
  
  (method (zone-revert)
    (define (revert)
      (let ((zone (current-zone)))
        (let ((moniker (get-moniker~ zone)))
          (if moniker
              (with-window-cursor :wait
                (lambda ()
                  (unpause-world)
                  (initialize-eye)
                  (setup-history)
                  (open-zone moniker)))
            (bell)))))
    
    (unimplemented-connected)
    (if (not (find-setting 'world.confirmation-dialogs? #t))
        (revert)
      (open-message "Revert to saved and lose changes?"
                    caption: "Revert"
                    type: 'question
                    yes: "Yes"
                    no: "No"
                    execute: (lambda (evt)
                               (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog))
                                     (button (get-property~ evt button:)))
                                 (close~ dialog)
                                 (case button
                                   ((yes)
                                    (revert))))))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (definition troposphere
    2.)
  
  (definition stratosphere
    3.)
  
  
  (method public (planet-troposphere)
    troposphere)
  
  (method public (planet-stratosphere)
    stratosphere)
  
  
  (method public (compute-gravity position)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (let ((gravity (copy-vertex ambient-gravity)))
            (iterate-gravities~ zone
              (lambda (well)
                (let ((pos (get-position~ well))
                      (radius (get-radius~ well)))
                  (let ((direction (vertex-normalize& (vertex-& pos position)))
                        (distance (max radius (vertex-distance pos position))))
                    (let ((well-gravity (vertex-scalar* direction (well-pull well distance))))
                      (if (<= distance (+ radius troposphere))
                          (continuation-return return well-gravity)
                        (vertex+! gravity gravity well-gravity)))))))
            gravity)))))
  
  
  (method public (well-pull well distance)
    (let ((mass (well-mass~ well)))
      (/ mass (* distance distance))))
  
  
  (method public (well-gravity well position)
    (let ((pos (get-position~ well))
          (radius (get-radius~ well)))
      (let ((direction (vertex-normalize& (vertex-& pos position)))
            (distance (max radius (vertex-distance pos position))))
        (vertex-scalar* direction (well-pull well distance)))))
  
  
  (method public (surface-pull well)
    (well-pull well (get-radius~ well)))
  
  
  (method public (inside-stratosphere? well position)
    (let ((pos (get-position~ well))
          (radius (get-radius~ well)))
      (let ((distance (max radius (vertex-distance pos position))))
        (<= distance (+ radius stratosphere)))))
  
  
  ;;;
  ;;;; Planet
  ;;;
  
  
  (method public (determine-planet pos)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (iterate-gravities~ zone
            (lambda (well)
              (when (and (is? well Planet)
                         (inside-stratosphere? well pos))
                (continuation-return return well))))
          #f))))
  
  
  ;;;
  ;;;; Vehicle
  ;;;
  
  
  (method (change-vehicle)
    (if (not vehicle)
        (bell)
      (let ((folio (if fly? flyers-folio mounts-folio)))
        (let ((next (next-element (get-list~ folio) vehicle)))
          (set-current~ folio next)
          (activate-vehicle next)))))
  
  
  (method (activate-vehicle vehi)
    (let ((me (current-me)))
      (set! vehicle vehi)
      (update-model~ me)
      (when (eq? vehicle 'hummer)
        (set-y~ me (+ (get-y~ me) 1.5)))))
  
  
  (method (vehicle-speed actor)
    (case vehicle
      ((wheels) .2)
      ((hummer) .3)
      ((saucer) .3)
      ((rocket) 1.)
      (else (ground-speed~ actor))))
  
  
  ;;;
  ;;;; Mount
  ;;;
  
  
  (method (toggle-mount)
    (when (not paused?)
      (unimplemented-connected)
      (person-motion)
      (deactivate-fly)
      (if mount?
          (deactivate-mount)
        (activate-mount))))
  
  
  (method (activate-mount)
    (unless mount?
      (set! mount? #t)
      (activate-vehicle (get-current~ mounts-folio))
      (update-parameter 'mount)
      (update-parameter 'fly)))
  
  
  (method (deactivate-mount)
    (when mount?
      (set! mount? #f)
      (activate-vehicle #f)
      (update-parameter 'mount)
      (update-parameter 'fly)))
  
  
  ;;;
  ;;;; Fly
  ;;;
  
  
  (method (toggle-fly)
    (unimplemented-connected)
    (person-motion)
    (deactivate-mount)
    (if fly?
        (deactivate-fly)
      (activate-fly)))
  
  
  (method (activate-fly)
    (unless fly?
      (let ((me (current-me)))
        (set! fly? #t)
        (set-y~ me (+ (get-y~ me) 2.))
        (activate-vehicle (get-current~ flyers-folio))
        (update-parameter 'mount)
        (update-parameter 'fly)
        (follow-player))))
  
  
  (method (deactivate-fly)
    (when fly?
      (let ((me (current-me)))
        (set! fly? #f)
        (activate-vehicle #f)
        (update-parameter 'mount)
        (update-parameter 'fly)
        (exit-fly~ (current-motion)))))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  ;; until fully debugged
  (definition editor-actions?
    #f)
  
  ;; until fully debugged
  (definition track-actions?
    #f)
  
  
  (slot designer          <object> initialize #f     accessors generate)
  (slot editing?          <bool>   initialize #f     getter generate)
  (slot editor-mode       <object> initialize 'plane getter generate)
  (slot editor-added?     <bool>   initialize #f     getter generate)
  (slot editor-origin     <object> initialize #f     getter generate)
  (slot editor-normal     <object> initialize #f     getter generate)
  (slot editor-direction  <object> initialize #f     getter generate)
  (slot editor-floor?     <bool>   initialize #f     getter generate)
  (slot adding            <object> initialize #f     getter generate)
  (slot adding-properties <object> initialize #f     getter generate)
  (slot adding?           <bool>   initialize #f     getter generate)
  (slot deleting?         <bool>   initialize #f     getter generate)
  (slot removing?         <bool>   initialize #f     getter generate)
  (slot changing?         <bool>   initialize #f     getter generate)
  (slot widget-down       <object> initialize #f     getter generate)
  (slot widget-part       <object> initialize #f     getter generate)
  (slot grid?             <bool>   initialize #f     accessors generate)
  (slot floor-grid?       <bool>   initialize #t     accessors generate)
  (slot grid-plane        <symbol> initialize 'y     getter generate)
  (slot grid-position     <fl>     initialize 0.     getter generate)
  
  
  (method (change-editor-mode (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          (available-modes '(plane column free @comment crazy)))
      (let ((new-mode (next available-modes editor-mode)))
        (set! editor-mode new-mode)
        (display-message (capitalize (->string new-mode))))))
  
  
  (method (select-target-mode)
    (set! target-mode 'select)
    (set! target-widget #f)
    (update-target-parameters)
    (display-message "Select"))
  
  
  (method (move-target-mode)
    (if (eq? target-mode 'move)
        (select-target-mode)
      (set! target-mode 'move)
      (set! target-widget (new Mover))
      (update-target-parameters)
      (display-message "Move")))
  
  
  (method (rotate-target-mode)
    (if (eq? target-mode 'rotate)
        (select-target-mode)
      (set! target-mode 'rotate)
      (set! target-widget (new Rotater))
      (update-target-parameters)
      (display-message "Rotate")))
  
  
  (method (scale-target-mode)
    (if (eq? target-mode 'scale)
        (select-target-mode)
      (set! target-mode 'scale)
      (set! target-widget (new Scaler))
      (update-target-parameters)
      (display-message "Scale")))
  
  
  (method (update-target-parameters)
    (update-parameter 'select-target-mode)
    (update-parameter 'move-target-mode)
    (update-parameter 'rotate-target-mode)
    (update-parameter 'scale-target-mode))
  
  
  (method (find-mesh-program name)
    (or (table-ref mesh-programs name #f)
        (error "Unknown mesh program: {s}" name)))
  
  
  (method (collect-textures)
    (define (add-files dir table)
      (when (exists?~ dir)
        (add-subdir dir table)
        (iterate-directory~ dir
          (lambda (subdir)
            (add-subdir subdir table))
          files?: #f
          directories?: #t)))
    
    (define (add-subdir subdir table)
      (define (load-metadata)
        (let ((file (new-file~ subdir ".metadata")))
          (when (exists?~ file)
            (let ((metadata (call-with-input-file (path-settings file) read)))
              (assert (and (pair? metadata)
                           (pair? (cdr metadata))
                           (eq? (cadr metadata) 'textures)))
              (cddr metadata)))))
      
      (let ((metadata (load-metadata)))
        (define (texture-metadata file)
          (and metadata
               (let ((pair (associate (get-name~ file) metadata test: filename=?)))
                 (and pair
                      (cdr pair)))))
        
        (iterate-directory~ subdir
          (lambda (file)
            (when (member? (get-extension~ file) '("png" "tga") test: extension=?)
              (let ((metadata (texture-metadata file)))
                (table-set! table (get-base~ file) (cons metadata file)))))
          files?: #t
          directories?: #f
          recursive?: #f)))
    
    (when (not textures)
      (let ((table (make-table test: equal?)))
        (for-each (lambda (assets)
                    (add-files (new-directory~ assets "texture") table))
                  all-assets)
        (for-each (lambda (assets)
                    (add-files (new-directory~ assets "tile") table))
                  all-assets)
        (set! textures table)))
    textures)
  
  
  (method (reload-textures)
    (set! textures #f))
  
  
  (method (find-texture name)
    (let ((textures (collect-textures)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((pair? value)
               (bind (metadata . file) value
                 (let ((texture (make-file-texture file metadata: metadata)))
                   (table-set! textures name texture)
                   texture)))
              (else
               value)))))
  
  
  (method (find-texture-metadata name (error?: error? #t))
    (let ((textures (collect-textures)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (if error?
                   (error "Unable to find texture: {a}" name)
                 #f))
              ((pair? value)
               (car value))
              (else
               (get-metadata~ value))))))
  
  
  (method (find-texture-shader name)
    (let ((metadata (find-texture-metadata name error?: #f)))
      (and metadata
           (let ((pair (assq 'shader metadata)))
             (and pair
                  (cadr pair))))))
  
  
  (method (find-texture-file name)
    (let ((textures (collect-textures)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((pair? value)
               (cdr value))
              (else
               (get-file~ value))))))
  
  
  (method (set-face-texture elem face face-rank texture)
    (let ((zone (current-zone)))
      (when (update-face-texture~ elem face face-rank texture)
        (let ((sector (element-sector~ zone elem)))
          (set-vertices-uptodate?~ sector #f)
          (set-lightmap-uptodate?~ sector #f)
          (invalidate-lightmaps~ zone elem)))))
  
  
  (method (set-face-shader elem face face-rank shader)
    (let ((zone (current-zone)))
      (when (update-face-shader~ elem face face-rank shader)
        (let ((sector (element-sector~ zone elem)))
          (set-vertices-uptodate?~ sector #f)
          (set-lightmap-uptodate?~ sector #f)
          (invalidate-lightmaps~ zone elem)))))
  
  
  (method (reset-showcases)
    (register-entity-classes #t)
    (when showcase
      (deactivate~ showcase))
    (set! showcases (make-table test: eq?))
    (set! showcase (and showcase (find-showcase (showcase-name showcase))))
    (when showcase
      (activate~ showcase))
    (unspecified))
  
  
  (method (goto-showcase show)
    (let ((actual (showcase-name showcase)))
      (when showcase
        (deactivate~ showcase))
      (let ((show (if (neq? show actual) (and show (find-showcase show)) #f)))
        (set! showcase show)
        (when showcase
          (activate~ showcase))
        (update-parameter 'blocks-showcase)
        (update-parameter 'models-showcase)
        (update-parameter 'animations-showcase)
        (update-parameter 'shaders-showcase)
        (update-parameter 'tiles-showcase)
        (update-parameter 'textures-showcase)
        (update-parameter 'skyboxes-showcase)
        (update-parameter 'gadgets-showcase)
        (update-parameter 'meshes-showcase))))
  
  
  (method (find-showcase name)
    (or (table-ref showcases name #f)
        (let ((class (showcase-class name)))
          (let ((showcase (new class)))
            (table-set! showcases name showcase)
            showcase))))
  
  
  (method (showcase-class name)
    (case name
      ((tiles) Tiles-Showcase)
      ((textures) Textures-Showcase)
      ((skyboxes) Skyboxes-Showcase)
      ((models) Models-Showcase)
      ((animations) Animations-Showcase)
      ((blocks) Blocks-Showcase)
      ((shaders) Shaders-Showcase)
      ((gadgets) Gadgets-Showcase)
      ((meshes) Meshes-Showcase)))
  
  
  (method (showcase-name showcase)
    (typecase showcase
      ((Tiles-Showcase) 'tiles)
      ((Textures-Showcase) 'textures)
      ((Skyboxes-Showcase) 'skyboxes)
      ((Models-Showcase) 'models)
      ((Animations-Showcase) 'animations)
      ((Blocks-Showcase) 'blocks)
      ((Shaders-Showcase) 'shaders)
      ((Gadgets-Showcase) 'gadgets)
      ((Meshes-Showcase) 'meshes)
      (else #f)))
  
  
  (method (import-model)
    (let ((pane (find-type~ interface Model-Import)))
      (if pane
          (close~ pane)
        (open-frame (new Model-Import size: {Dimension 366 588} location: 'center)))))
  
  
  (method (collect-models)
    (let ((models '()))
      (define (scan-assets)
        (let (iter (scan all-assets))
          (when (not-null? scan)
            (let ((assets (car scan)))
              (scan-directory (new-directory~ assets "model"))
              (iter (cdr scan))))))
      
      (define (scan-directory models-dir)
        (when (exists?~ models-dir)
          (iterate-directory~ models-dir
            (lambda (path kind)
              (let ((dir (new-directory~ models-dir path)))
                (let ((dirname (get-name~ dir)))
                  (when (or (exists?~ (new-file~ dir (make-filename dirname "fbx")))
                            (exists?~ (new-file~ dir (make-filename dirname "w3ds")))
                            (exists?~ (new-file~ dir (make-filename dirname "ms3d")))
                            (exists?~ (new-file~ dir (make-filename dirname "obj"))))
                    (let ((path (join path "/")))
                      (set! models (cons path models)))))))
            full?: #f
            files?: #f
            directories?: #t
            recursive?: #t)))
      
      (scan-assets)
      (sort di<? models)))
  
  
  (method (add-model path)
    (let ((me (current-me))
          (camera (current-camera)))
      (define (determine-position)
        (let ((pos (if (person-motion?) (vertex-& (get-position~ me) (vertex 0. (get-radius-y~ me) 0.)) (vertex-& (get-position~ camera) (vertex 0. 1. 0.)))))
          (vertex+ pos (vertex-scalar*& (get-sight~ camera) 2.))))
      
      (place-model path (determine-position) class: Actor user-origin?: #t)))
  
  
  (method public (place-model model position (scale: scale #f) (class: class #f) (animate?: animate? #t) (animation: animation #f) (savable?: savable? #t) (user-origin?: user-origin? #f))
    (let ((zone (current-zone)))
      (let ((scale (or scale (find-setting 'world.import-scale 1.))))
        (let ((scale (if (flonum? scale) (vertex scale scale scale) scale)))
          (let ((class (or class Entity))
                (properties (list model: model scale: scale position: position animate?: animate? animation: animation)))
            (let ((entity (apply new class properties)))
              (when savable?
                (add-child~ (get-designer~ zone) entity zone import: '(world.data) properties: properties))
              (add-element~ zone entity)
              (when user-origin?
                (set-target (list entity) user-origin?: #t))
              entity))))))
  
  
  (method public (find-model path (error?: error? #t))
    (define (search-assets existing-time)
      (let (iter (scan all-assets))
        (if (null? scan)
            (values #f #f)
          (let ((assets (car scan)))
            (or (search-in (new-directory~ assets "model") existing-time)
                (iter (cdr scan)))))))
    
    (define (search-in models-dir existing-time)
      (when (exists?~ models-dir)
        (let ((dir (new-directory~ models-dir path)))
          (when (exists?~ dir)
            (let ((name (get-name~ dir)))
              (let ((metadata (load-model-metadata name (new-file~ dir ".model"))))
                (define (maybe-fbx)
                  (let ((fbx (new-file~ dir (make-filename name "fbx"))))
                    (when (changed? fbx existing-time)
                      (let ((w3ds (new-file~ dir (make-filename name "w3ds"))))
                        (when (or (not (exists?~ w3ds))
                                  (> (time->seconds (get-modification-time~ fbx))
                                     (time->seconds (get-modification-time~ w3ds))))
                          (let ((path (parse~ (world-file '("devel" "external" "fbx-conv" "windows" "fbx-conv") (settings-alias~ (get-application)))))
                                (arguments (list (parse~ fbx) (parse~ w3ds))))
                            (call-process (list path: path arguments: arguments show-console: #f))))
                        (values fbx (load-w3ds w3ds metadata: metadata))))))
                
                (define (maybe-w3ds)
                  (let ((w3ds (new-file~ dir (make-filename name "w3ds"))))
                    (when (changed? w3ds existing-time)
                      (values w3ds (load-w3ds w3ds metadata: metadata)))))
                
                (define (maybe-ms3d)
                  (let ((ms3d (new-file~ dir (make-filename name "ms3d"))))
                    (when (changed? ms3d existing-time)
                      (values ms3d (load-ms3d ms3d metadata: metadata)))))
                
                (define (maybe-obj)
                  (let ((obj (new-file~ dir (make-filename name "obj"))))
                    (when (changed? obj existing-time)
                      (let ((png (new-brother~ obj (make-filename (get-base~ obj) "png"))))
                        (assert (exists?~ png)
                          (values obj (load-obj obj (make-file-texture png))))))))
                
                (define (changed? file existing-time)
                  (and (exists?~ file)
                       (or (not existing-time)
                           (/= (time->seconds (get-modification-time~ file)) existing-time))))
                
                (or (maybe-fbx)
                    (maybe-w3ds)
                    (maybe-ms3d)
                    @obj-format-needs-fixing
                    (maybe-obj))))))))
    
    (if (symbol? path)
        (registered-model path)
      (let ((existing-model (table-ref models path #f)))
        (let ((existing-time (and existing-model (get-path-time~ existing-model))))
          (receive (file model) (search-assets existing-time)
            (if (not model)
                (or existing-model
                    (if error?
                        (error "Unable to find model: {a}" path)
                      #f))
              (set-file~ model file)
              (set-path~ model path)
              (set-path-time~ model (time->seconds (get-modification-time~ file)))
              (table-set! models path model)
              model))))))
  
  
  (method (reload-model path)
    (table-clear models path))
  
  
  (method (select/run-script)
    (let ((pane (find-type~ interface Script-Run)))
      (if pane
          (close~ pane)
        (open-frame (new Script-Run size: {Dimension 366 588} location: 'center)))))
  
  
  (method (run-last-script)
    (if (not last-script)
        (select/run-script)
      (run-script last-script)))
  
  
  (method (collect-scripts)
    (let ((scripts '()))
      (define (scan-assets)
        (let (iter (scan all-assets))
          (when (not-null? scan)
            (let ((assets (car scan)))
              (scan-directory (new-directory~ assets "script"))
              (iter (cdr scan))))))
      
      (define (scan-directory scripts-dir)
        (when (exists?~ scripts-dir)
          (iterate-directory~ scripts-dir
            (lambda (path kind)
              (set! scripts (cons (cons scripts-dir path) scripts)))
            full?: #f
            files?: #t
            directories?: #f
            recursive?: #t)))
      
      (scan-assets)
      (sort di<? scripts key: cdr)))
  
  
  (method (find-script path)
    (find (collect-scripts) path test: equal? key: (lambda (info)
                                                     (let ((path (cdr info)))
                                                       (extract-base (join path "/"))))
      return: 'item))
  
  
  (method (run-script script)
    (launch-script script)
    (set! last-script script))
  
  
  (method (launch-script script)
    (bind (dir . path) script
      (;; glfc-fix-me with-window-cursor :wait
        (lambda ()
          (load-script (parse~ (new-file~ dir path)))))))
  
  
  (method (execute-script path)
    (let ((script (find-script path)))
      (if script
          (launch-script script)
        (display-error (format "Unable to find script: {a}" path))
        (bell))))
  
  
  (method (toggle-grid)
    (set! grid? (not grid?))
    (update-parameter 'grid))
  
  
  (method (toggle-grid-plane plane)
    (if (and grid? (eq? grid-plane plane))
        (set! grid? #f)
      (set! grid? #t)
      (set! grid-plane plane))
    (update-parameter 'grid))
  
  
  (method (decrease-grid)
    (move-grid-by -1))
  
  
  (method (increase-grid)
    (move-grid-by 1))
  
  
  (cond-expand
    (cocoa
      (method (move-grid delta)
        (move-grid-by (fxround/ (- delta) 5))))
    (else
     (method (move-grid delta)
       (move-grid-by (fxround/ (- delta) 120)))))
  
  
  (method (move-grid-by incr)
    (let ((dist incr))
     (increase! grid-position dist)
     (display-status (format "Grid at {a}" grid-position))))
    
  
  ;; editor-mouse-down
  ;; editor-mouse-move
  ;; editor-mouse-up
  ;; - editor-add / action 'add
  ;;   - editor-add-at
  ;;     - editor-add-element
  ;;       - add-element-class
  ;; - editor-remove
  ;; - editor-change

  
  (method (editor-add mode class grid? grid-plane grid-position floor-grid? position direction stage)
    (let ((zone (current-zone)))
      (case stage
        ((down move)
         (editor-add-at mode class grid? grid-plane grid-position floor-grid? position direction))
        ((up)
         (editor-up)))))
  
  
  (method (editor-add-at mode class grid? grid-plane grid-position floor-grid? position direction)
    (let ((zone (current-zone)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-direction) 0.) vertex-x)
                                ((/= (vertex-y editor-direction) 0.) vertex-y)
                                ((/= (vertex-z editor-direction) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal~ poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center~ poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal~ poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center~ poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& center editor-origin)) editor-normal))))))
        
        (define (free-filter poly)
          (let ((normal (get-normal~ poly)))
            (vertex=? normal editor-normal)))
        
        (when editor-added?
          (case mode
            ((plane) (plane-filter))
            ((column) column-filter)
            ((free) free-filter)
            ((crazy) #f))))
      
      (define (add-at origin normal polygon-center polygon-normal floor?)
        (define (collision-quad origin normal)
          (let ((inside (vertex+ origin (vertex-scalar* normal -.01))))
            (let ((cube (unit-cube inside)))
              (ray-closest-cuboid-inner-quad inside normal cube))))
        
        (define (determine-anchor origin normal)
          (let ((bounds (transformed-bounds~ adding)))
            (let ((radiuses (cuboid-radiuses bounds)))
              (cond ((= (vertex-y normal) 1.)
                     origin)
                    ((= (vertex-y normal) -1.)
                     (vertex- origin (vertex 0. (cuboid-height bounds) 0.)))
                    (else
                     (vertex+ (vertex- origin (vertex 0. .5 0.))
                              (vertex-scalar* normal (if (/= (vertex-x normal) 0.)
                                                         (vertex-x radiuses)
                                                       (vertex-z radiuses)))))))))
        
        (let ((closest (collision-quad origin normal)))
          (when closest
            (bind (quad dist) closest
              (let ((origin (get-origin~ quad))
                    (normal (vertex-scalar* (get-normal~ quad) -1.)))
                (when (or (not editor-added?) (vertex=? normal editor-direction))
                  (instantiate-element-class class)
                  (let ((anchor (determine-anchor origin normal)))
                    (let ((position (anchor->position~ adding anchor)))
                      (let ((actual (element-near~ zone position)))
                        (unless actual
                          (let ((added (editor-add-element mode class anchor)))
                            (if editor-added?
                                (unless (is? added Player)
                                  (add-target added))
                              (set! editor-added? #t)
                              (set! editor-origin (or polygon-center origin))
                              (set! editor-normal (or polygon-normal normal))
                              (set! editor-direction normal)
                              (set! editor-floor? floor?)
                              (unless (is? added Player)
                                (set-target (list added))))
                            added)))))))))))
      
      (let ((filter (determine-filter)))
        (let ((poly-closest (ray-closest-polygon position direction view-radius filter: filter ignore-players?: #t))
              (grid-closest (when (or (not editor-added?) (memq? mode '(free crazy)) (and editor-floor? (neq? mode 'column)))
                              (receive (vert normal) (ray-plane-intersection position direction grid? grid-plane grid-position floor-grid?: floor-grid?)
                                (when vert
                                  (cons vert normal))))))
          (let ((poly-distance (and poly-closest (second poly-closest)))
                (grid-distance (and grid-closest (vertex-distance position (car grid-closest)))))
            (if (and poly-closest (or (not grid-closest) (<= poly-distance grid-distance)))
                (bind (poly distance) poly-closest
                  (let ((element (get-element~ poly))
                        (normal (get-normal~ poly)))
                    (cond ((and (is? showcase Tiles-Showcase) (get-selection~ showcase))
                           (let ((texture (get-user-data~ (get-selection~ showcase))))
                             (receive (face face-rank) (find-face~ element poly)
                               (set-face-texture element face face-rank texture)
                               (when (not editor-added?)
                                 (set! editor-added? #t)
                                 (set! editor-normal normal)
                                 (set! editor-direction normal))
                               #f)))
                          ((and (is? showcase Shaders-Showcase) (get-selection~ showcase))
                           (let ((shader (get-user-data~ (get-selection~ showcase))))
                             (let ((effective-shader (if (eq? shader 'phong) #f shader)))
                               (receive (face face-rank) (find-face~ element poly)
                                 (set-face-shader element face face-rank effective-shader)
                                 (when (not editor-added?)
                                   (set! editor-added? #t)
                                   (set! editor-normal normal)
                                   (set! editor-direction normal))
                                 #f))))
                          (else
                           (let ((target (vertex+ position (vertex-scalar* direction view-radius)))
                                 (lookat (get-lookat~ (current-camera)))
                                 (radiuses (vertex .001 .001 .001)))
                             (receive (new-position new-direction collisions) (collide&stop position target lookat radiuses max-distance: view-radius polygon-filter: filter ignore-entities?: #t ignore-players?: #t)
                               (when (not-null? collisions)
                                 (let ((coll (car collisions)))
                                   (let ((plane (get-plane~ coll)))
                                     (add-at (get-origin~ plane) (get-normal~ plane) (get-center~ poly) (get-normal~ poly) #f))))))))))
              (when grid-closest
                (bind (vert . normal) grid-closest
                  (let ((normal (if (and (is? class Block)
                                         (get-flat?~ (cache-model~ class)))
                                    (vertex-negate normal)
                                  normal)))
                    (add-at vert normal #f #f #t))))))))))
  
  
  (method (editor-add-element mode class anchor)
    (let ((zone (current-zone))
          (me (current-me)))
      (let ((element adding)
            (position (anchor->position~ adding anchor))
            (designer (get-designer~ zone)))
        (set-parent~ element zone)
        (set-position~ element position)
        (unless (is? element Player)
          (add-child~ designer element zone import: '(world.data) properties: (cons position: (cons position adding-properties))))
        (unless (is? element Player)
          (set-property~ designer element 'position position))
        (add-element~ zone element)
        (when (and (is? element Player) (not (get-world-server~ (get-process))))
          (let ((preserved-lookat (and (person-motion?) (get-lookat~ me))))
            (remove-element me)
            (when (server-side?~ (get-process))
              (set-color~ element white-dye))
            (set-current-me element)
            (set-lookat~ element (or preserved-lookat (get-lookat~ (current-camera))))))
        (when (eq? element (current-me))
          (follow-player))
        (update-future)
        (set! adding #f)
        (set! adding-properties #f)
        element)))
  
  
  (method (instantiate-element-class class)
    (define (instantiate class/new (properties '()))
      (let ((elem (if (procedure? class/new) (class/new) (apply new class/new properties))))
        (when (is? elem Player)
          (set-name~ elem (effective-player-name~ (get-application))))
        (set! adding elem)
        (set! adding-properties properties)))
    
    (define (instantiate-block block)
      (define (determine-rotation)
        (let ((sight (get-sight~ (current-camera))))
          (let ((angle (plane-angle 1. 0. (vertex-x sight) (vertex-z sight))))
            (cond ((or (between? angle 0. PI/4) (between? angle (- PI*2 PI/4) PI*2)) 'north)
                  ((between? angle PI/4 (* 3. PI/4)) 'west)
                  ((between? angle (* 3. PI/4) (* 5. PI/4)) 'south)
                  (else 'east)))))
      
      (let ((model (get-model~ block))
            (rotation (determine-rotation)))
        (instantiate (lambda ()
                       (new (class-of block) model: model))
                     (list model: model rotation: rotation))))
    
    (define (instantiate-entity entity)
      (let ((class (class-of entity)))
        (let ((properties (registered-gadget class)))
          (if properties
              (let ((properties (properties)))
                (instantiate (lambda ()
                               (new class))
                             properties))
            (let ((model (or (get-model~ entity) (and (cache-model~ entity) (get-name~ (cache-model~ entity)))))
                  (meshes-mask (get-meshes-mask~ entity))
                  (animation (get-animation~ entity))
                  (animate? (get-animate?~ entity)))
              (instantiate (lambda ()
                             (new class model: model))
                           (list model: model meshes-mask: meshes-mask animation: animation animate?: animate?)))))))
    
    (when (not adding)
      (typecase class
        ((Block)
         (instantiate-block class))
        ((Entity)
         (instantiate-entity class))
        (else
         (case class
           ((player) (instantiate (player-class)))
           ((block) (instantiate Block)))))))
  
  
  (method (editor-remove mode position direction stage)
    (let ((zone (current-zone)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-normal) 0.) vertex-x)
                                ((/= (vertex-y editor-normal) 0.) vertex-y)
                                ((/= (vertex-z editor-normal) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal~ poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center~ poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal~ poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center~ poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& editor-origin center)) editor-normal))))))
        
        (case mode
          ((plane) (plane-filter))
          ((column) column-filter)
          ((free) #f)))
      
      (case stage
        ((down)
         (let ((closest (ray-closest-polygon position direction view-radius ignore-players?: #t)))
           (when closest
             (bind (poly distance) closest
               (let ((element (get-element~ poly))
                     (center (get-center~ poly))
                     (normal (get-normal~ poly)))
                 (editor-remove-element element)
                 (set! editor-origin center)
                 (set! editor-normal normal))))))
        ((move)
         (let ((closest (ray-closest-polygon position direction view-radius filter: (determine-filter) ignore-players?: #t)))
           (when closest
             (bind (poly distance) closest
               (let ((element (get-element~ poly)))
                 (editor-remove-element element))))))
        ((up)
         (set! editing? #f)
         (set! removing? #f)
         (set! editor-added? #f)
         (set! editor-origin #f)
         (set! editor-normal #f)
         (set! editor-direction #f)))))
  
  
  (method (editor-delete position)
    (let ((zone (current-zone)))
      (if (zone-editable?~ zone)
          (let ((element (element-at~ zone position)))
            (when element
              (editor-remove-element element)
              (set-modified?~ zone #t)
              (update-future)))
        (warn-non-editable))))
  
  
  (method (editor-remove-element elem)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone)))
        (remove-element elem)
        (remove-child~ designer elem))))
  
  
  (method (remove-element elem)
    (let ((zone (current-zone)))
      (remove-element~ zone elem)
      (when (memq? elem target)
        (remove-target elem))))
  
  
  (method (delete-target)
    (let ((zone (current-zone))
          (me (current-me)))
      (if (null? target)
          (bell)
        (for-each (lambda (elem)
                    (unless (is? elem Player)
                      (cond (paused?
                             (editor-delete (get-position~ elem)))
                            (else
                             (if (and editor-actions? (is? elem Block))
                                 (add-action~ commands 'delete (list (get-position~ elem)))
                               ;; quicky copy-pasted from editor-delete
                               (editor-remove-element elem)
                               (set-modified?~ zone #t)
                               (update-future))))))
                  target))))
  
  
  (method (editor-change position direction  stage)
    (case stage
      ((down move)
       (let ((closest (ray-closest-polygon position direction view-radius ignore-players?: #t)))
         (when closest
           (bind (poly distance) closest
             (let ((element (get-element~ poly))
                   (class (get-selection~ showcase)))
               (change-class element class))))))
      ((up)
       (set! editing? #f)
       (set! changing? #f))))
  
  
  (method (change-class element class)
    (let ((anchor (position->anchor~ element (get-position~ element))))
      (editor-remove-element element)
      (instantiate-element-class class)
      (editor-add-element editor-mode class anchor)))
  
  
  (method (editor-element-class)
    (if (shift-down?)
        'player
      (or (and showcase (selection-addable?~ showcase) (get-selection~ showcase))
          'block)))
  
  
  (method (mouse-change h v)
    (let ((zone (current-zone)))
      (if (zone-editable?~ zone)
          (when (and (is? showcase Blocks-Showcase) (get-selection~ showcase))
            (receive (position direction) (screen->ray~ (current-camera) h v)
              (editor-change position direction 'down)
              (set! editing? #t)
              (set! changing? #t)))
        (warn-non-editable))))
  
  
  (method (mouse-add h v)
    (let ((zone (current-zone))
          (player? (shift-down?)))
      (if (or (zone-editable?~ zone)
              player?)
          (receive (position direction) (screen->ray~ (current-camera) h v)
            (let ((class (editor-element-class)))
              (if (or (not editor-actions?) paused?)
                  (editor-add editor-mode class grid? grid-plane grid-position floor-grid? position direction 'down)
                (add-action~ commands 'add (list editor-mode class grid? grid-plane grid-position floor-grid? position direction 'down))))
            (set! editing? #t))
        (warn-non-editable))))
  
  
  (method (mouse-remove h v)
    (let ((zone (current-zone)))
      (if (zone-editable?~ zone)
          (receive (position direction) (screen->ray~ (current-camera) h v)
            (editor-remove editor-mode position direction 'down)
            (set! editing? #t)
            (set! removing? #t))
        (warn-non-editable))))
  
  
  (method (editor-mouse-down h v)
    (let ((control? (control-down?))
          (alt? (alt-down?))
          (shift? (shift-down?)))
      (cond ((and control? alt? (not shift?))
             (mouse-change h v))
            (control?
             (mouse-add h v))
            (alt?
             (mouse-remove h v))
            (else
             (when target-widget
               (receive (position direction) (screen->ray~ (current-camera) h v)
                 (let ((closest (ray-closest-widget position direction target-widget)))
                   (when closest
                     (bind (poly distance) closest
                       (bind (widget . part) (get-element~ poly)
                         (set! widget-down widget)
                         (set! widget-part part)
                         (widget-mouse-down~ widget-down h v)))))))))))
  
  
  (method (editor-mouse-move h v)
    (when editing?
      (cond (removing?
             (receive (position direction) (screen->ray~ (current-camera) h v)
               (editor-remove editor-mode position direction 'move)))
            (changing?
             (receive (position direction) (screen->ray~ (current-camera) h v)
               (editor-change position direction 'move)))
            (else
             (let ((player? (shift-down?)))
               (unless player?
                 (receive (position direction) (screen->ray~ (current-camera) h v)
                   (let ((class (editor-element-class)))
                     (if (or (not editor-actions?) paused?)
                         (editor-add editor-mode class grid? grid-plane grid-position floor-grid? position direction 'move)
                       (add-action~ commands 'add (list editor-mode class grid? grid-plane grid-position floor-grid? position direction 'move)))))))))))
  
  
  (method (editor-mouse-up h v)
    (let ((zone (current-zone)))
      (receive (position direction) (screen->ray~ (current-camera) (get-h~ down-point) (get-v~ down-point))
        (if editing?
            (cond (removing?
                   (editor-remove editor-mode position direction 'up))
                  (changing?
                   (editor-change position direction 'up))
                  (else
                   (let ((class (editor-element-class)))
                     (if (or (not editor-actions?) paused?)
                         (editor-add editor-mode class grid? grid-plane grid-position floor-grid? position direction 'up)
                       (add-action~ commands 'add (list editor-mode class grid? grid-plane grid-position floor-grid? position direction 'up))))))
          (let ((closest (ray-closest-polygon (get-position~ (current-camera)) direction view-radius ignore-entities?: #f ignore-players?: #t)))
            (if (not closest)
                (reset-target user-origin?: #t)
              (bind (poly distance) closest
                (let ((element (get-element~ poly)))
                  (if (not element)
                      (set-target '() polygon: poly user-origin?: #t)
                    (if (shift-down?)
                        (if (memq? element target)
                            (remove-target element user-origin?: #t)
                          (add-target element polygon: poly user-origin?: #t))
                      (set-target (list element) polygon: poly user-origin?: #t)))))))))
      (editor-up)))
  
  
  (method (editor-up)
    (set! editing? #f)
    (set! adding? #f)
    (set! deleting? #f)
    (set! removing? #f)
    (set! changing? #f)
    (set! editor-added? #f)
    (set! editor-origin #f)
    (set! editor-normal #f)
    (set! editor-direction #f)
    (set! editor-floor? #f)
    (set! adding #f)
    (set! adding-properties #f))
  
  
  (method protected virtual (warn-non-editable)
    (let ((zone (current-zone)))
      (unless (get-editable-warned?~ zone)
        (set-editable-warned?~ zone #t)
        (open-message "Zone is not editable"
                      caption: "Edition"
                      type: 'message
                      execute: (lambda (evt)
                                 (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog)))
                                   (close~ dialog)))))))
  
  
  ;;;
  ;;;; Plane
  ;;;
  
  
  (method (ray-plane-intersection position direction grid? grid-plane grid-position (floor-grid?: floor-grid? #f))
    (let ((zone (current-zone)))
      (define (perspective->world normal plane-k)
        (let ((norm-direction-inner-product (inner-product normal direction)))
          (unless (and (= norm-direction-inner-product 0.)
                       (case grid-plane
                         ((x) (= (vertex-x position) grid-position))
                         ((y) (= (vertex-y position) grid-position))
                         ((z) (= (vertex-z position) grid-position))))
            (let ((intersect (/ (- plane-k (inner-product normal position))
                                norm-direction-inner-product)))
              (unless (<= intersect 0)
                (let ((point (vertex+ position (vertex-scalar*& direction intersect))))
                  (if (> norm-direction-inner-product 0.)
                      (values point grid-position (vertex-negate normal))
                    (values point grid-position normal))))))))
      
      (if (not grid?)
          (if (not floor-grid?)
              (values #f #f)
            (let ((floor-level (get-floor-level~ zone)))
              (if (not floor-level)
                  (values #f #f)
                (let ((info (perspective->world (vertex 0. 1. 0.) floor-level)))
                  (if (not info)
                      (values #f #f)
                    (receive (vert pos normal) info
                      (if (vertex=? normal (vertex 0. 1. 0.))
                          (values (and vert (vertex
                                              (vertex-x vert)
                                              pos
                                              (vertex-z vert)))
                                  normal)
                        (values #f #f))))))))
        (case grid-plane
          ((x) (let ((info (perspective->world (vertex 1. 0. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (receive (vert pos normal) info
                     (values (and vert (vertex
                                         pos
                                         (vertex-y vert)
                                         (vertex-z vert)))
                             normal)))))
          ((y) (let ((info (perspective->world (vertex 0. 1. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (receive (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         pos
                                         (vertex-z vert)))
                             normal)))))
          ((z) (let ((info (perspective->world (vertex 0. 0. 1.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (receive (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         (vertex-y vert)
                                         pos))
                             normal)))))))))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-future? initialize #t getter generate)
  
  
  (method (toggle-paused)
    (unimplemented-connected)
    (if paused?
        (unpause-world)
      (pause-world)))
  
  
  (method (pause-world)
    (set-current~ history (snapshot-world))
    (activate~ history)
    (set! paused? #t)
    (camera-copy! history-camera eye)
    (set-current-camera history-camera)
    (set-current-motion history-motion)
    (update-camera-parameters)
    (reset-profiling)
    (set-visible?~ (child~ interface 'slider) #t)
    (update-parameter 'paused))
  
  
  (method (unpause-world)
    (truncate-future)
    (set-current~ history #f)
    (deactivate~ history)
    (camera-copy! eye history-camera)
    (set-current-camera eye)
    (set-current-motion eye-motion)
    (set! paused? #f)
    (eye-behind-player)
    (follow-player)
    (reset-profiling)
    (set-visible?~ (child~ interface 'slider) #f)
    (update-parameter 'paused))
  
  
  (method (snapshot-world)
    (let ((zone (current-zone)))
      (snapshot-zone~ zone)))
  
  
  (method (snapshot-metadata/world)
    (define (snapshot-metadata entity)
      (list entity (cache-model~ entity) (copy-matrix (get-matrix~ entity))))
    
    (values (list (snapshot-metadata (current-me))
                  @camera-history-wait
                  (snapshot-metadata eye))
            (snapshot-world)))
  
  
  (method (load-world snapshot)
    (let ((zone (current-zone)))
      (let ((previous-target (first-target)))
        (load-zone~ zone snapshot)
        (set-current-me (find-player (get-actors~ zone)))
        (when (is? previous-target Actor)
          (let ((elem (find-target previous-target (get-actors~ zone))))
            (if (not elem)
                (reset-target)
              (set-target (list elem))))))))
  
  
  (method (serialize-world)
    (object->u8vector history serialize))
  
  
  (method (deserialize-world content)
    (u8vector->object content deserialize))
  
  
  (method (install-history hist)
    (set! history hist)
    (goto-history~ history (get-now~ history)))
  
  
  (method (find-player actors)
    (find-if (lambda (obj)
               (is? obj Player))
             actors))
  
  
  (method (find-named-player player-name)
    (let ((zone (current-zone)))
      (find-if (lambda (actor)
                 (and (is? actor Player)
                      (equal? (get-name~ actor) player-name)))
               (get-actors~ zone))))
  
  
  (method (find-target target elements)
    (let ((original (get-original~ target)))
      (find-if (lambda (obj)
                 (eq? (get-original~ obj) original))
               elements)))
  
  
  (method (first-target)
    (and (not-null? target) (first target)))
  
  
  (method (set-target targ (polygon: polygon #f) (user-origin?: user-origin? #f))
    (let ((zone (current-zone)))
      (define (find-face target)
        (continuation-capture
          (lambda (return)
            (when polygon
              (for-each (lambda (elem)
                          (receive (face face-rank) (find-face~ elem polygon)
                            (when face
                              (continuation-return return (values face face-rank)))))
                        target))
            (values #f #f))))
      
      (receive (face face-rank) (find-face targ)
        (when (not-null? target)
          (deactivate-target~ (first target)))
        (when (and user-origin? (not (equal? targ target)) (find-setting 'world.selection-sounds? #t))
          (play-sound-file (if (not-null? targ) "sound/user/selectTarget" "sound/user/deselectTarget")))
        (set! target targ)
        (set! target-face face)
        (set! target-face-rank face-rank)
        (set! target-polygon polygon)
        (target-update target face face-rank polygon)
        (target-update~ zone target face face-rank polygon)
        (invalidate-view~ interface)
        (update-target-pane)
        (update-script-pane)
        (when (not-null? target)
          (activate-target~ (first target)))
        (refresh-interface condition: '(info target)))))
  
  
  (method (reset-target (user-origin?: user-origin? #f))
    (set-target '() user-origin?: user-origin?))
  
  
  (method (add-target elem (polygon: polygon #f) (user-origin?: user-origin? #f))
    (set-target (append! target (list elem)) polygon: polygon user-origin?: user-origin?))
  
  
  (method (remove-target elem (user-origin?: user-origin? #f))
    (set-target (remove! elem target) user-origin?: user-origin?))
  
  
  (method (toggle-draw-elements)
    (set! draw-elements? (not draw-elements?))
    (update-parameter 'elements)
    (display-on/off "Draw elements" draw-elements?))
  
  
  ;;;
  ;;;; Music
  ;;;
  
  
  (method (change-music)
    (let ((queue (new-queue)))
      (for-each (lambda (assets)
                  (let ((music-dir (new-directory~ assets "music")))
                    (when (exists?~ music-dir)
                      (iterate-directory~ music-dir
                        (lambda (path kind)
                          (let ((path (join path "/")))
                            (when (extension=? (extract-extension path) "mp3")
                              (enqueue queue (extract-base path)))))
                        full?: #f
                        files?: #t
                        directories?: #f))))
                all-assets)
      (let ((music-list (queue-list queue)))
        (if (null? music-list)
            (display-error "No music found")
          (let ((music (random-element music-list)))
            (play-ambience (concatenate "music/" music)))))))
  
  
  (method (play-intro-music)
    (play-ambience "music/Intro"))
  
  
  (method (play-ambience path)
    (play-music-file path "ambience"))
  
  
  (method (maybe-play-ambience path)
    (when (find-setting 'world.music? #t)
      (play-ambience path)))
  
  
  (method (close-ambience)
    (close-music "ambience"))
  
  
  (method (play-music-file path name)
    (let ((file (effective-music-file path)))
      (when file
        (close-music name)
        (open-music file name)
        (play-music name))))
  
  
  (method (effective-music-file path)
    (when path
      (continuation-capture
        (lambda (return)
          (for-each (lambda (assets)
                      (let ((mp3 (new-file~ assets (make-filename path "mp3"))))
                        (if (exists?~ mp3)
                            (continuation-return return mp3)
                          (let ((ogg (new-file~ assets (make-filename path "ogg"))))
                            (when (exists?~ ogg)
                              (continuation-return return ogg))))))
                    all-assets)
          #f))))
  
  
  (method (music-played alias)
    (when (and (equal? alias "ambience")
               (find-setting 'world.music? #f))
      (change-music)))
  
  
  (method (play-sound-file path)
    (let ((file (effective-sound-file path)))
      (when file
        (play-sound file))))
  
  
  (method (maybe-play-sound-file path)
    (when (find-setting 'world.sounds? #t)
      (play-sound-file path)))
  
  
  (method (effective-sound-file path)
    (when path
      (continuation-capture
        (lambda (return)
          (for-each (lambda (assets)
                      (let ((wav (new-file~ assets (make-filename path "wav"))))
                        (when (exists?~ wav)
                          (continuation-return return wav))))
                    all-assets)
          #f))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (slot evaluate-hooks <object> initialize '() getter generate)
  
  
  (method (register-evaluate-hook proc)
    (set! evaluate-hooks (cons proc evaluate-hooks)))
  
  
  (method (unregister-evaluate-hook proc)
    (set! evaluate-hooks (remove! proc evaluate-hooks)))
  
  
  (method (evaluate-hook syntax str container line col)
    (let ((zone (current-zone)))
      @test
      (setup-lighting~ zone)
      (when (search container "shaders")
        (reload-programs str))
      (when (search str "define-model")
        (increase-current-content-revision))
      (when evaluate-future?
        (update-future))
      (for-each (lambda (proc)
                  (proc syntax str container line col))
                evaluate-hooks)
      @test
      (update-world-options~ (get-application))
      @test
      (install-skins~ (get-application))
      @test
      (install-bindings~ (get-application))
      (invalidate-view~ interface)
      (reset-profiling)
      (render-scene~ (current-world-window))))
  
  
  (method (reload-programs str)
    (cond ((or (search str "phong")
               (search str "baked-light"))
           (reload-phong-programs))
          ((search str "frame")
           (reload-frame-programs))
          (else
           (reload-transformation-programs)
           (reload-other-programs))))
  
  
  (method (reload-phong-programs)
    (build-phong-shaders)
    (relink-program 'phong)
    (relink-program 'minecraft)
    (relink-program 'wet))
  
  
  (method (reload-frame-programs)
    (build-frame-shaders)
    (relink-program 'wireframe)
    (relink-program 'squareframe)
    (relink-program 'playerframe)
    (relink-program 'floorframe))
  
  
  (method (reload-transformation-programs)
    (build-transformation-shaders)
    (relink-program 'radial-blur)
    (relink-program 'motion-blur)
    (relink-program 'water)
    (relink-program 'julia)
    (relink-program 'sierpinski)
    (relink-program 'multitexture)
    (relink-program 'kaleidoscope)
    (relink-program 'tunnel)
    (relink-program 'square-tunnel)
    (relink-program 'fly)
    (relink-program 'pulse))
  
  
  (method (reload-other-programs)
    (build-occlusion-shaders)
    (relink-program 'occlusion))
  
  
  (method (relink-program name)
    (let ((program (find-mesh-program name)))
      (relink~ program)))
  
  
  ;;;
  ;;;; GC
  ;;;
  
  
  (definition memory-site
    (register-site 'memory '(kind: memory)))
  
  
  (method (setup-gc)
    (add-gc-interrupt-job!
      (lambda ()
        (when gc-sound?
          (gc-sound))
        (let ((running (last-gc-real-time))
              (profile (get-profile~ memory-site)))
          (site-profile-running-set! profile (+ (site-profile-running profile) running))
          (site-profile-called-set! profile (+ (site-profile-called profile) 1.))))))
  
  
  (cond-expand
    (windows
     (definition (gc-sound)
       (MessageBeep MB_ICONINFORMATION)))
    (cocoa
     (definition (gc-sound)
       (play-sound "Submarine")))
    (else
     (definition (gc-sound)
       (bell))))
  
  
  ;;;
  ;;;; Showcase
  ;;;
  
  
  (method (in-showcase? v)
    (between? v
              (percent 76. height)
              (percent 92. height)))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (slot previous-mouses initialize '())
  
  
  (method protected virtual (mouse-down h v)
    (set! down? #t)
    (set! down-point (new Point h v))
    (set! previous-mouses '())
    (cond ((and showcase (in-showcase? v))
           (set! showcase-down? #t)
           (showcase-mouse-down~ showcase h v))
          (else
           (editor-mouse-down h v))))
  
  
  (method protected virtual (mouse-moved x y)
    (define (setup-cursor)
      (set! last-point (new Point$fl$ x y))
      (set! last-time (current-seconds)))
    
    (define (move-camera)
      (define (scalarproduct a <Point$fl$> b <Point$fl$>) <fl>
        (+ (* (get-h~ a) (get-h~ b)) (* (get-v~ a) (get-v~ b))))
      
      (let ((new-point (new Point$fl$ x y))
            (new-time (current-seconds)))
        (movecamera self new-point new-time last-point last-time previous-mouses)
        @wait
        (let ((poschange (nu- new-point last-point))
              (elapse (- new-time last-time)))
          (let ((delta (if (null? previous-mouses)
                           poschange
                         (let ((dirchange (if (null? (cdr previous-mouses)) -1. (scalarproduct poschange (nu- last-point (caadr previous-mouses))))))
                           (let ((ponderation (if (and (< (norm poschange) 5.)
                                                       (>= dirchange 0.))
                                                  .5
                                                1.)))
                             (bind (furthest-point . furthest-time) (last previous-mouses)
                               (nu+ (nu* (nu- new-point furthest-point) (* (/ elapse (- new-time furthest-time)) (- 1. ponderation)))
                                    (nu* poschange ponderation))))))))
            (let ((dx (get-h~ delta))
                  (dy (get-v~ delta)))
              (mouse-track elapse dx dy))))
        (set! last-point new-point)
        (set! last-time new-time)
        (when (get-camera-smoothing?)
          (let ((max-moves 5))
            (set! previous-mouses (cons (cons new-point new-time) previous-mouses))
            (when (> (length previous-mouses) max-moves)
              (set-cdr! (tail previous-mouses (- max-moves 1)) '()))))))
    
    (let ((h (fxround x))
          (v (fxround y)))
      (cond (showcase-down?
             (showcase-mouse-move~ showcase h v))
            ((and (get-cursor-captured?~ window) (not (get-cursor-mode?)))
             (move-camera)
             (unless (or (is-moving?) paused?)
               (follow-player)))
            (widget-down
             (widget-mouse-move~ widget-down h v))
            (editing?
             (editor-mouse-move h v))
            ((and (not (get-autotrack-camera?)) (not (get-cursor-mode?)))
             (setup-cursor)
             (capture-cursor~ window)
             (move-camera))
            ((and down? (not (near? (new Point h v) down-point drag-tolerance)))
             (set! viewing? #t)
             (setup-cursor)
             (capture-cursor~ window)))))
  
  
  (method protected virtual (mouse-track elapse dx dy)
    (let ((me (current-controlled))
          (motion (current-motion))
          (camera (current-camera)))
      (cond ((orbit-motion?)
             (track-orbit~ motion dx dy))
            ((and (is-moving?) (person-motion?))
             (let ((sight (copy-vertex (get-sight~ camera)))
                   (up (copy-vertex (get-up~ camera)))
                   (right (copy-vertex (get-right~ camera)))
                   (first? (not moved?)))
               (if (or paused? (not track-actions?))
                   (track-actor~ motion me dx dy sight up right first?)
                 (add-action~ commands 'track (list dx dy sight up right first?)))
               (set! moved? #t)))
            (else
             (track-camera~ motion dx dy)))))
  
  
  (method protected virtual (mouse-up h v)
    (cond (showcase-down?
           (showcase-mouse-up~ showcase h v)
           (set! showcase-down? #f))
          ((get-cursor-captured?~ window)
           (release-cursor~ window)
           (follow-player))
          (widget-down
           (widget-mouse-up~ widget-down h v)
           (set! widget-down #f)
           (set! widget-part #f))
          (else
           (when down?
             (editor-mouse-up h v))))
    (set! down? #f)
    (set! down-point #f)
    (set! viewing? #f))
  
  
  (method protected virtual (double-click h v)
    (mouse-down h v))
  
  
  (method protected virtual (right-mouse-down h v)
    (set! down? #t)
    (set! down-point (new Point h v))
    (set! previous-mouses '())
    (set! moving? #t)
    (set! moved? #f))
  
  
  (method protected virtual (right-mouse-up h v)
    (let ((me (current-me))
          (motion (current-motion)))
      (reset-roll~ motion me)
      (set! down? #f)
      (set! down-point #f)
      (set! moving? #f)
      (unless (get-cursor-captured?~ window)
        (mouse-add h v)
        (editor-up))
      (release-cursor~ window)))
  
  
  (method (mouse-wheel h v delta)
    (let ((zone (current-zone))
          (me (current-me))
          (d (get-v~ delta)))
      (cond ((control-down?)
             (when showcase
               (showcase-wheel~ showcase (> d 0))))
            ((and grid? (alt-down?))
             (move-grid d))
            ((> d 0)
             (zoom-in))
            ((< d 0)
             (zoom-out)))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  ;; quick hack
  (cond-expand
    (windows
     (definition (application-active?)
       (get-active?~ (get-application))))
    (else
     (definition (application-active?)
       #t)))
  
  
  (method (process-keys)
    (site (process-keys on?: #f parent: keys)
      (when (application-active?)
        ;; to optimize by using modifiers-mask
        (let ((modifiers (modifiers-keys)))
          (iterate-keys
            (lambda (shortcut proc)
              (when (and (equal? (get-modifiers~ shortcut) modifiers)
                         (let ((key (get-key~ shortcut)))
                           (or (eqv? key ongoing-key)
                               (key-down? (if (char? key)
                                              (char->integer key)
                                            (symbolic-key->code key))))))
                (proc self))))))))
  
  
  (method protected virtual (process-shortcut shortcut)
    (if (shortcut=? shortcut {Shortcut Escape})
        (if escape-hook
            (escape-hook)
          (main-menu))
      #f))
  
  
  (method protected virtual (key-down c)
    )
  
  
  (method protected virtual (key-press key)
    )
  
  
  (method protected virtual (key-up c)
    )
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method (connect-to-server)
    (let ((process (get-process)))
      (if (get-world-server~ process)
          (display-error "Already connected")
        (connect-server~ process)
        (display-message "Connected" color: {Color Green}))))
  
  
  (method (disconnect-from-server)
    (let ((process (get-process)))
      (if (not (get-world-server~ process))
          (display-error "Not connected")
        (disconnect~ process)
        (display-message "Disconnected"))))
  
  
  (method (request-server-update)
    (let ((process (get-process)))
      (if (not (get-world-server~ process))
          (display-error "Not connected")
        (update-client~ process)
        (display-message "Requesting server update"))))
  
  
  (method (unimplemented-connected)
    (when (get-world-server~ (get-process))
      (display-cancel "Unimplemented when connected")))
  
  
  ;;;
  ;;;; Window
  ;;;
  
  
  ;; quick hack
  (cond-expand
    (cocoa
      (method (live-gaia/world)
        (world.client.window:position-world-window 'live))
      
      
      (method (design-gaia/world)
        (world.client.window:position-world-window 'design))
      
      
      (method (restore-gaia/world)
        (world.client.window:restore-world-window)))
    (else
      (method (live-gaia/world)
        (let ((controller-debugger (get-controller-debugger)))
          (if (not controller-debugger)
              (display-error "Not connected to a remote debugger")
            (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
                  (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
              (live-gaia/world~ debugger debuggee)))))
      
      
      (method (design-gaia/world)
        (let ((controller-debugger (get-controller-debugger)))
          (if (not controller-debugger)
              (display-error "Not connected to a remote debugger")
            (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
                  (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
              (design-gaia/world~ debugger debuggee)))))
      
      
      (method (restore-gaia/world)
        (let ((controller-debugger (get-controller-debugger)))
          (if (not controller-debugger)
              (display-error "Not connected to a remote debugger")
            (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
                  (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
              (restore-gaia/world~ debugger debuggee)))))))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (toggle-interface)
    (set! interface? (not interface?))
    (update-parameter 'interface))
  
  
  (method (toggle-occlusion)
    (set-wireframe? #f)
    (let ((occlusion? (not (get-occlusion?))))
      (set-occlusion? occlusion?)
      (set-override-renderer (and occlusion? (get-occlusion-renderer)))
      (set-block-program (find-mesh-program (if occlusion? 'occlusion (default-block-program~ (current-zone)))))
      (update-parameter 'occlusion)))
  
  
  (method (toggle-wireframe)
    (set-occlusion? #f)
    (let ((wireframe? (not (get-wireframe?))))
      (set-wireframe? wireframe?)
      (set-override-renderer (and wireframe? (get-wireframe-renderer)))
      (set-block-program (find-mesh-program (if wireframe? 'wireframe (default-block-program~ (current-zone)))))
      (update-parameter 'wireframe)))
  
  
  (method (toggle-polygon-mode)
    (set! polygon-mode (ecase polygon-mode
                         ((GL_POINT) GL_LINE)
                         ((GL_LINE) GL_FILL)
                         ((GL_FILL) GL_POINT)))
    (glPolygonMode GL_FRONT_AND_BACK polygon-mode))
  
  
  (method (toggle-lighting)
    (set! lighting? (not lighting?))
    (update-parameter 'lighting)
    (display-on/off "Lighting" lighting?))
  
  
  (method (toggle-fog)
    (set-fog? (not (get-fog?)))
    (reload-phong-programs)
    (update-parameter 'fog)
    (display-on/off "Fog" (get-fog?)))
  
  
  (method (toggle-windowed-mode)
    (toggle-windowed-mode~ window)
    (update-parameter 'windowed-mode))
  
  
  (method (toggle-post-processing)
    (set! post-processing? (not post-processing?))
    (update-parameter 'post-processing)
    (display-on/off "Post processing" post-processing?))
  
  
  (method (person-motion (feedback?: feedback? #t))
    (let ((me (current-me)))
      (unless (person-motion?)
        (set! eye-motion (make-person-motion self eye #f))
        (set-current-motion eye-motion)
        (eye-center-player~ eye-motion)
        (update-camera-parameters)
        (when feedback?
          (display-message "First person")))))
  
  
  (method (orbit-motion (feedback?: feedback? #t))
    (unless (orbit-motion?)
      (set! eye-motion (make-orbit-motion self eye #f))
      (set-current-motion eye-motion)
      (orbit-behind~ eye-motion (motion-target~ eye-motion))
      (update-camera-parameters)
      (when feedback?
        (display-message "Orbit around"))))
  
  
  (method (free-motion (feedback?: feedback? #t))
    (unless (free-motion?)
      (set! eye-motion (make-free-motion self eye))
      (set-current-motion eye-motion)
      (update-camera-parameters)
      (when feedback?
        (display-message "Free camera"))))
  
  
  (method (update-camera-parameters)
    (update-parameter 'person-motion)
    (update-parameter 'orbit-motion)
    (update-parameter 'free-motion))
  
  
  (method (effective-draw-gadgets?)
    (or draw-gadgets? (is? showcase Gadgets-Showcase)))
  
  
  (method (toggle-draw-gadgets)
    (set! draw-gadgets? (not draw-gadgets?))
    (update-gadgets)
    (update-parameter 'gadgets)
    (display-on/off "Draw gadgets" draw-gadgets?))
  
  
  (method (toggle-draw-normals)
    (set! draw-normals? (not draw-normals?))
    (update-parameter 'normals)
    (display-on/off "Draw normals" draw-normals?))
  
  
  (method (toggle-draw-atlas)
    (if (get-texture-arrays?)
        (display-error "No atlas")
      (set! draw-atlas? (not draw-atlas?))
      (update-parameter 'draw-atlas)
      (display-on/off "Draw atlas" draw-atlas?)))
  
  
  (method (toggle-draw-me)
    (let ((zone (current-zone)))
      (set-draw-me?~ zone (not (get-draw-me?~ zone)))
      (update-parameter 'draw-me)
      (display-on/off "Draw me" (get-draw-me?~ zone))))
  
  
  (method (update-gadgets (draw-gadgets? (effective-draw-gadgets?)))
    (when (not draw-gadgets?)
      (for-each (lambda (elem)
                  (when (is? elem Gadget)
                    (remove-target elem)))
                target)))
  
  
  (method (toggle-axes)
    (set! axes? (not axes?))
    (update-parameter 'axes)
    (display-on/off "Axes" axes?))
  
  
  (method (toggle-axes-graduation)
    (set! axes-graduation? (not axes-graduation?))
    (display-on/off "Axes graduation" axes-graduation?))
  
  
  (method (toggle-info)
    (let ((pane (child~ interface 'info)))
      (set-visible?~ pane (not (get-visible?~ pane)))
      (when (get-visible?~ pane)
        (set! interface? #t)))
    (update-parameter 'info))
  
  
  (method (toggle-profiler)
    (let ((pane (child~ interface 'profiler)))
      (let ((visible? (not (get-visible?~ pane))))
        (if visible?
            (begin
              (reset-sites)
              (advise-sites))
          (unadvise-sites))
        (set-visible?~ pane visible?)
        (when visible?
          (set! interface? #t))))
    (update-parameter 'profiler))
  
  
  (method (reset-profiling)
    (reset-sites))
  
  
  (method (toggle-target)
    (set! interface-target? (not interface-target?))
    (update-target-pane)
    (update-parameter 'target))
  
  
  (method (update-target-pane)
    (let ((pane (child~ interface 'target)))
      (if (not interface-target?)
          (set-visible?~ pane #f)
        (set-visible?~ pane (not-null? target)))))
  
  
  (method (toggle-script)
    (set! interface-script? (not interface-script?))
    (update-script-pane)
    (update-parameter 'script))
  
  
  (method (update-script-pane)
    (let ((pane (child~ interface 'script)))
      (if (not interface-script?)
          (set-visible?~ pane #f)
        (let ((targ (first-target)))
          (let ((scriptable? (and targ (scriptable?~ targ))))
            (if (not scriptable?)
                (set-visible?~ pane #f)
              (let ((name (get-name~ targ)))
                (if (not name)
                    (set-visible?~ pane #f)
                  (let ((locator (compose-reference 'tutorial.objectives name)))
                    (let ((entry (locator->entry locator)))
                      (if (not entry)
                          (set-visible?~ pane #f)
                        (let ((text (locate~ pane 'text)))
                          (set-moniker~ (get-document-controller~ text) (get-moniker~ entry))
                          (set-selection-safe~ text (get-range~ entry) reposition: 'vertical ensure-displayed?: #t)
                          (set-visible?~ pane #t)))))))))))))
  
  
  (method (character-pane)
    (let ((pane (child~ interface 'character)))
      (set-visible?~ pane (not (get-visible?~ pane)))
      (when (get-visible?~ pane)
        (set! interface? #t)))
    (update-parameter 'character-pane))
  
  
  (method (update-parameter name)
    (when interface
      (invalidate-view~ (parameter-view name))))


  (method (parameter-view name)
    (when interface
      (let ((parameter (registered-parameter name)))
        (define (find-view)
          (continuation-capture
            (lambda (return)
              (for-each (lambda (bar)
                          (when (is? bar World-Actionbar)
                            (for-each (lambda (button)
                                        (when (and (is? button World-Parameter-Button)
                                                   (eq? (get-parameter~ button) name))
                                          (continuation-return return button)))
                                      (get-children~ bar))))
                        (get-children~ interface))
              (error "Unable to find view: {a}" name))))
        
        (define (lookup-view)
          (or (get-view~ parameter)
              (let ((view (find-view)))
                (set-view~ parameter view)
                view)))
        
        (lookup-view))))
  
  
  (method (display-on/off title flag)
    (display-message (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method (display-message msg (color: color #f))
    (set! message msg)
    (set! message-color color)
    (set! message-time (current-seconds)))
  
  
  (method (draw-message)
    (let ((elapse (- (current-seconds) message-time))
          (fade 1.)
          (done 2.))
      (if (> elapse done)
          (begin
            (set! message #f)
            (set! message-time #f))
        (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f)))
          (let ((surface (get-surface~ (get-texture~ message-player)))
                (font {Font Message^})
                (color (or message-color {Color World-Message})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (let ((color (if (not alpha)
                             color
                           (let ((color (copy-object~ color #f)))
                             (set-alpha~ color alpha)
                             color)))
                  (shadow-color (if (not alpha)
                                    {Color Black}
                                  (let ((color (copy-object~ {Color Black} #f)))
                                    (set-alpha~ color alpha)
                                    color))))
              (draw-text~ surface 0 10 message color shadow-color: shadow-color))
            (map-texture~ (get-texture~ message-player))
            (let ((w (text-width~ font message)))
              (let ((x (cast <fl> (center w (fxround width))))
                    (y (cast <fl> (- (fxround height) 200))))
                (let ((matrix (make-translation-matrix (vertex x y 0.))))
                  (render-player~ message-player matrix)))))))))
    
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method (display-error msg)
    (display-message msg color: {Color Red}))
  
  
  (method (display-cancel msg)
    (display-message msg color: {Color Red})
    (signal-cancel))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method (display-status msg (color: color #f))
    (set! status msg)
    (set! status-color color)
    (set! status-time (current-seconds)))
  
  
  (method (draw-status)
    (let ((elapse (- (current-seconds) status-time))
          (fade 1.)
          (done 2.))
      (if (> elapse done)
          (begin
            (set! status #f)
            (set! status-time #f))
        (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f)))
          (let ((surface (get-surface~ (get-texture~ status-player)))
                (font {Font Status^})
                (color (or status-color {Color World-Message})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (let ((color (if (not alpha)
                             color
                           (let ((color (copy-object~ color #f)))
                             (set-alpha~ color alpha)
                             color)))
                  (shadow-color (if (not alpha)
                                    {Color Black}
                                  (let ((color (copy-object~ {Color Black} #f)))
                                    (set-alpha~ color alpha)
                                    color))))
              (draw-text~ surface 0 0 status color shadow-color: shadow-color))
            (map-texture~ (get-texture~ status-player))
            (let ((w (text-width~ font status)))
              (let ((x (cast <fl> (center w (fxround width))))
                    (y 70.0))
                (let ((matrix (make-translation-matrix (vertex x y 0.))))
                  (render-player~ status-player matrix)))))))))))
