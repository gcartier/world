;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Live
;;;


(module world.live jazz


(import (jazz.debuggee)
        (jazz.designer)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.library)
        (jazz.library.component)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (jazz.version)
        (time)
        (world)
        (world.actor)
        (world.area)
        (world.array)
        (world.asset)
        (world.autoload)
        (world.block)
        (world.counter)
        (world.debug)
        (world.draw)
        (world.enemy)
        (world.entity)
        (world.folio)
        (world.foreign)
        (world.foreign.obj)
        (world.gadget)
        (world.geometry)
        (world.gravity)
        (world.history)
        (world.interface)
        (world.interface.info)
        (world.interface.pane)
        (world.interface.player)
        (world.io)
        (world.light)
        (world.mark)
        (world.model)
        (world.object)
        (world.pack)
        (world.player)
        (world.programs)
        (world.render)
        (world.sector)
        (world.settings)
        (world.shader)
        (world.shaders)
        (world.sprite)
        (world.texture)
        (world.window)
        (world.zone)
        (world.client.configuration)
        (world.client.window))


;;;
;;;; Live
;;;


(class Live-World extends World
  
  
  (property title              <string+> initialize #f           accessors generate)
  (property gravity            <fl>      initialize .09          accessors generate)
  (property floor-level        <fl>      initialize 0.0          accessors generate)
  (property jump-impulsion     <fl>      initialize 2.0          accessors generate)
  (property start-zone         <string+> initialize #f           accessors generate)
  (property start-mode         <symbol>  initialize 'free        accessors generate)
  (property start-3d?          <bool>    initialize #t           accessors generate)
  (property start-grid?        <bool>    initialize #t           accessors generate)
  (property use-pack?          <bool>    initialize #f           accessors generate)
  (property default-texture    <object>  initialize #f           accessors generate)
  (property properties         <object>  initialize '()          accessors generate)
  
  
  (slot version               <object> initialize #f            getter generate)
  (slot projection            <symbol> initialize 'orthographic getter generate)
  (slot zoom-factor           <fl>                              getter generate)
  (slot desired-tilt          <fl>     initialize 0.            getter generate)
  (slot tilt-speed            <fl>     initialize 0.            getter generate)
  (slot last-tilt-time        <fl+>    initialize #f            getter generate)
  (slot 3d?                   <bool>   initialize #f            getter generate)
  (slot eye?                  <bool>   initialize #f            getter generate)
  (slot player-target?        <bool>   initialize #f            getter generate)
  (slot fly?                  <bool>   initialize #f            getter generate)
  (slot viewing?              <bool>   initialize #f            getter generate)
  (slot moving?               <bool>   initialize #f            getter generate)
  (slot moved?                <bool>   initialize #f            getter generate)
  (slot preserved-mouse       <object> initialize #f            getter generate)
  (slot first-person?         <bool>   initialize #f            getter generate)
  (slot max-distance          <fl>     initialize 150.0         getter generate)
  (slot first-distance        <fl>     initialize 17.5          getter generate)
  (slot first-override        <fl+>    initialize #f            getter generate)
  (slot first-occlusion?      <bool>   initialize #f            getter generate)
  (slot first-camera          <object> initialize #f            getter generate)
  (slot mount                 <object> initialize 'none         getter generate)
  (slot ground-mounts-folio   <Folio>  initialize #f            getter generate)
  (slot all-mounts-folio      <Folio>  initialize #f            getter generate)
  (slot draw-sprites?         <bool>   initialize #t            getter generate)
  (slot draw-gadgets?         <bool>   initialize #f            getter generate)
  (slot draw-marks?           <bool>   initialize #t            getter generate)
  (slot draw-pack?            <bool>   initialize #f            getter generate)
  (slot post-processing?      <bool>   initialize #t            getter generate)
  (slot axes?                 <bool>   initialize #f            getter generate)
  (slot pulse                 <object> initialize #f            getter generate)
  (slot last-tick             <fl>     initialize #f            getter generate)
  (slot down?                 <bool>   initialize #f            getter generate)
  (slot down-point            <object> initialize #f            getter generate)
  (slot drag-tolerance        <object> initialize 3             getter generate)
  (slot paused?               <bool>   initialize #f            getter generate)
  (slot gc-counter            <object> initialize #f            getter generate)
  (slot tick-counter          <object> initialize #f            getter generate)
  (slot render-counter        <object> initialize #f            getter generate)
  (slot latency-counter       <object> initialize #f            getter generate)
  (slot camera-counter        <object> initialize #f            getter generate)
  (slot counters?             <bool>   initialize #f            getter generate)
  (slot tick-no               <object> initialize 0             getter generate)
  (slot commands              <object> initialize #f            getter generate)
  (slot resources-dir         <object> initialize #f            getter generate)
  (slot texture-pack          <object> initialize #f            getter generate)
  (slot textures              <object> initialize #f            getter generate)
  (slot player-texture        <object> initialize #f            getter generate)
  (slot turtle-texture        <object> initialize #f            getter generate)
  (slot monster-texture       <object> initialize #f            getter generate)
  (slot missile-texture       <object> initialize #f            getter generate)
  (slot asset-texture         <object> initialize #f            getter generate)
  (slot background-texture    <object> initialize #f            getter generate)
  (slot models                <object> initialize #f            getter generate)
  (slot explosion-sound       <object> initialize #f            getter generate)
  (slot last-missile          <fl+>    initialize #f            getter generate)
  (slot history?              <object> initialize #t            getter generate)
  (slot history               <object> initialize #f            getter generate)
  (slot message               <object> initialize #f            getter generate)
  (slot message-time          <object> initialize #f            getter generate)
  (slot message-color         <object> initialize #f            getter generate)
  (slot message-texture       <object> initialize #f            getter generate)
  (slot status                <object> initialize #f            getter generate)
  (slot status-time           <object> initialize #f            getter generate)
  (slot status-color          <object> initialize #f            getter generate)
  (slot status-texture        <object> initialize #f            getter generate)
  (slot information           <object> initialize #f            getter generate)
  (slot interface             <object> initialize '()           getter generate)
  
  ;; Shader programs
  (slot asset-color-program   <object> initialize #f            accessors generate)
  (slot asset-texture-program <object> initialize #f            accessors generate)
  (slot asset-phong-program   <object> initialize #f            accessors generate)
  (slot asset-program         <object> initialize #f            accessors generate)
  (slot model-program         <object> initialize #f            accessors generate)
  (slot texture-program       <object> initialize #f            accessors generate)
  (slot pp-program            <object> initialize #f            accessors generate)
  
  ;; Render targets
  (slot render-target         <object> initialize #f            accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! post-processing? (find-setting 'world.post-processing? #t))
    (set! interface? (find-setting 'world.start-interface? #t)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method override (setup-opengl)
    (nextmethod)
    (initialize-camera)
    (unless immediate-mode?
      (prepare-shaders))
    (prepare-textures)
    (prepare-editor)
    (unless immediate-mode?
      (initialize-render))
    (reset-commands)
    (gl-check-error))
  
  
  (method (start-world)
    (prepare-tick))
 
  
  (method (prepare-shaders)
    ;; asset color
    (set! asset-color-program (new Asset-Color-Program name: 'asset-color))
    (prepare~ asset-color-program)
    
    ;; asset texture
    (set! asset-texture-program (new Asset-Texture-Program name: 'asset-texture))
    (prepare~ asset-texture-program)
    
    ;; asset phong
    (set! asset-phong-program (new Asset-Phong-Program name: 'asset-phong))
    (prepare~ asset-phong-program)
    
    ;; asset
    (set! asset-program asset-phong-program)
    
    ;; model
    (set! model-program (new Shader-Program name: 'model))
    (set-vs~ model-program phong-nlights-model-vs)
    (set-fs~ model-program phong-nlights-asset-fs)
    (link~ model-program)
    (add-uniform~ model-program "texture")
    (add-uniform~ model-program "lights_count")
    (add-uniform~ model-program "material")
    (add-attribute~ model-program "vertex_coord")
    (add-attribute~ model-program "texture_coord")
    (add-attribute~ model-program "normal")
    
    ;; texture
    (set! texture-program (new Shader-Program name: 'texture))
    (set-vs~ texture-program texture-vs)
    (set-fs~ texture-program texture-fs)
    (link~ texture-program)
    (add-uniform~ texture-program "texture")
    (add-uniform~ texture-program "overlay")
    
    ;; pp
    (set! pp-program (new PP-Program name: 'pp))
    (set-vs~ pp-program pp-vs)
    (set-fs~ pp-program pp-fs)
    (link~ pp-program)
    (set-vbo/fbo-vertices~ pp-program (glGenVertices*))
    (add-uniform~ pp-program "fbo_texture")
    (add-attribute~ pp-program "vertex_coord"))
  
  
  (method (prepare-textures)
    (define (make-texture-pack)
      (let ((pack (new Pack)))
        (add-directory-if-exists~ pack {Directory Settings "resources" "tiles"})
        (add-directory-if-exists~ pack {Directory Settings "resources-world" "tiles"})
        (complete~ pack texture-program)
        pack))
    
    (set! resources-dir {Directory Settings "resources-world"})
    (set! texture-pack (make-texture-pack))
    (set! player-texture (make-png-texture (new-file~ resources-dir "player/Idle.png") texture-program))
    (set! turtle-texture (make-png-texture (new-file~ resources-dir "player/Idle.png") texture-program))
    (set! monster-texture (make-png-texture (new-file~ resources-dir "player/Idle.png") texture-program))
    (set! missile-texture (make-png-texture (new-file~ resources-dir "player/Idle.png") texture-program))
    (set! asset-texture (determine-asset-texture))
    (set! background-texture (make-png-texture (new-file~ resources-dir "background/Layer0_0.png") texture-program))
    (set! message-texture (make-cairo-texture 500 100 program: texture-program overlay: 0.))
    (set! status-texture (make-cairo-texture 500 35 program: texture-program))
    (set! explosion-sound (new-file~ resources-dir (list "sounds" "explosion.wav"))))
  
  
  (method (determine-asset-texture)
    (if use-pack?
        (get-texture~ texture-pack)
      (if default-texture
          (find-texture default-texture)
        (car (collect-textures)))))
  
  
  (method (initialize-render)
    (set! render-target (new Render-Target (fxround width) (fxround height) ms-fbo: #t)))
  
  
  (method (reset-commands)
    (when (or (not commands) (get-modified?~ commands))
      (set! commands (new Commands)))
    (set-last-no~ commands tick-no)
    (increase! tick-no))
  
  
  (method (setup-world)
    (set! last-tick (time->seconds (current-time)))
    (set! paused? #f))
  
  
  (method (toggle-asset-stiches)
    (set-asset-stiches?~ zone (not (get-asset-stiches?~ zone)))
    (display-on/off "Stiches" (get-asset-stiches?~ zone)))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))


  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (unless immediate-mode?
      (free-resources~ render-target)
      (detach-shaders~ asset-program)
      (detach-shaders~ texture-program)
      (detach-shaders~ pp-program))
    (glDeleteTextures* (get-texture~ player-texture))
    (glDeleteTextures* (get-texture~ turtle-texture))
    (glDeleteTextures* (get-texture~ monster-texture))
    (glDeleteTextures* (get-texture~ missile-texture))
    (glDeleteTextures* (get-texture~ asset-texture))
    (glDeleteTextures* (get-texture~ background-texture))
    (glDeleteTextures* (get-texture~ message-texture))
    (glDeleteTextures* (get-texture~ status-texture))
    (close~ pulse))
  
  
  (method public (garbage-collect)
    (display-message "Garbage collecting")
    (gc)
    (gc))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method override (initialize-world)
    (set! version world-version)
    (set! first-camera 'free)
    (set! grid? start-grid?)
    (cond (start-3d?
           (activate-3d))
          (else
           (set! camera-distance 0.6)
           (set! first-distance 7.5)
           (set! editor-mode 'point)))
    (setup-interface)
    (setup-history)
    (setup-gc)
    (update-title))
  
  
  (method (setup-interface)
    (set! interface (new World-Interface))
    (new Info-Pane parent: interface name: 'info position: (vertex -10.0 0.0 0.0) visible?: #f)
    (new Player-Pane parent: interface name: 'player position: (vertex -10.0 0.0 0.0) visible?: #t)
    (set! latency-counter (new Counter parent: self x: -10.0 y: 0.0 z: 0.0 title: "Latency" vertical: 78.0))
    (set! render-counter (new Counter parent: self x: -10.0 y: 0.0 z: 0.0 title: "Render" vertical: 43.0))
    (set! tick-counter (new Counter parent: self x: -10.0 y: 0.0 z: 0.0 title: "Tick" vertical: 8.0))
    (set! camera-counter (new Counter parent: self x: -10.0 y: 0.0 z: 0.0 title: "Camera" vertical: 8.0))
    (set! gc-counter (new Counter parent: self x: -10.0 y: 0.0 z: 0.0 title: "GC" vertical: 8.0)))
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method (zone-update)
    (enter-zone~ (get-process))
    (set! ground-mounts-folio (new Folio 'none '(none weels)))
    (set! all-mounts-folio (new Folio 'none '(none weels carpet)))
    ;; add player when not connected to server
    (when (and (client-side?~ (get-application)) (not (get-world-server~ (get-application))))
      (let ((start-position (get-start-position~ zone)))
        (when start-position
          (let ((player (new Player name: (effective-player-name~ (get-application)) x: (vertex-x start-position) y: (vertex-y start-position) z: (vertex-z start-position))))
            (let ((start-sight (get-start-sight~ zone))
                  (start-up (get-start-up~ zone)))
              (when (and start-sight start-up)
                (let ((lookat (get-lookat~ player)))
                  (set-sight~ lookat start-sight)
                  (set-up~ lookat start-up)
                  (set-right~ lookat (vertex-normalize (cross-product start-sight start-up))))))
            (add-sprite~ zone player)
            (set-me player)
            (camera-behind-player)
            (follow-player))))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (prepare-tick)
    (set! pulse (new Pulse 'tick .01 tick-world)))
  
  
  (method (tick-world)
    (unless (or paused? (is-inactive?))
      (let ((seconds (time->seconds (current-time))))
        (let ((elapse (- seconds last-tick))
              (process (get-process)))
          (set! last-tick seconds)
          (when history?
            (add-history elapse))
          (start~ tick-counter)
          (complete~ commands)
          (if (client-side?~ process)
              (if (not (get-world-server~ process))
                  (tick-actors commands elapse)
                (when (get-modified?~ commands)
                  (tick-server~ (get-process) commands elapse)))
            (when me
              (tick-sliced me commands elapse)))
          (reset-commands)
          (end~ tick-counter)
          (restore-first-distance elapse)))))
  
  
  (method (tick-actors commands elapse)
    (unless (and me (get-state~ me))
      (for-each (lambda (actor)
                  (tick-sliced actor commands elapse))
                (get-actors~ zone))))
  
  
  (method (world-update players)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-update players))
    (for-each (lambda (info)
                (bind (player-name player-avatar player-position player-sight player-up player-right) info
                  (let ((player (find-named-player player-name)))
                    (if (not player)
                        (add-player player-name player-avatar player-position player-sight player-up player-right)
                      (let ((lookat (get-lookat~ player)))
                        (let ((in-sync? (and (vertex=? (get-position~ player) player-position)
                                             (vertex=? (get-sight~ lookat) player-sight)
                                             (vertex=? (get-up~ lookat) player-up)
                                             (vertex=? (get-right~ lookat) player-right))))
                          (when (not in-sync?)
                            (set-position~ player player-position)
                            (set-sight~ lookat player-sight)
                            (set-up~ lookat player-up)
                            (set-right~ lookat player-right)
                            (when (eq? player me)
                              (camera-behind-player)
                              (follow-player)))))))))
              players)
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (method (world-enter player-name player-avatar player-position player-lookat)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-enter player-name player-avatar player-position player-lookat))
    (bind (sight up right) player-lookat
      (add-player player-name player-avatar player-position sight up right))
    (display-message (format "{a} entered world" player-name))
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (method (add-player player-name player-avatar player-position player-sight player-up player-right)
    (let ((player (new Player name: player-name x: 0. y: 0. z: 0.)))
      (set-position~ player player-position)
      (let ((lookat (get-lookat~ player)))
        (set-sight~ lookat player-sight)
        (set-up~ lookat player-up)
        (set-right~ lookat player-right))
      (when player-avatar
        (if (is? player-avatar Color)
            (set-color~ player player-avatar)
          (set-avatar~ player player-avatar)))
      (add-sprite~ zone player)
      (when (and (client-side?~ (get-process)) (equal? player-name (get-player-name~ (get-process))))
        (set-me player)
        (camera-behind-player)
        (follow-player))))
  
  
  (method (world-exit player-name)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-exit player-name))
    (let ((player (find-named-player player-name)))
      (when player
        (remove-sprite player))
      (when (and (client-side?~ (get-process)) (equal? player-name (get-player-name~ (get-process))))
        (set-me #f))
      (display-message (format "{a} exited world" player-name)))
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (definition empty-commands
    (let ((commands (new Commands)))
      (complete~ commands)
      commands))
  
  
  (method (server-tick player-commands elapse)
    (unless (null? player-commands)
      (when (find-setting 'world.client.debug? #f)
        (terminal (effective-player-name~ (get-application)) 'server-tick player-commands elapse)))
    (start~ latency-counter)
    (unless (and me (get-state~ me))
      (for-each (lambda (actor)
                  (let ((name (and (is? actor Player) (get-name~ actor))))
                    (let ((pair (and name (assoc name player-commands))))
                      (let ((commands (if pair (deserialize-commands (cdr pair)) empty-commands)))
                        (tick-sliced actor commands elapse)))))
                (get-actors~ zone)))
    (end~ latency-counter)
    (unless (null? player-commands)
      (when (find-setting 'world.client.debug? #f)
        (debug-players))))
  
  
  (method (tick-sliced actor commands elapse)
    (parameterize ((tick-actor actor))
      (tick-actions~ actor commands)
      (continuation-capture
        (lambda (exit)
          (let ((slice (if (is? actor Player) .01 .05)))
            (let (iter (from 0.) (to slice))
              (tick~ actor commands (- to from) exit)
              (when (< to elapse)
                (iter to (min elapse (+ to slice))))))))))
  
  
  (method (server-test argument)
    (1)
    (debug 'server-test)
    argument)
  
  
  (method (debug-players)
    (for-each (lambda (player)
                (unless (equal? (get-name~ player) "Server")
                  (terminal '->
                            (get-name~ player)
                            (get-position~ player)
                            (present-vertex (get-sight~ (get-lookat~ player))))))
              (collect-players~ zone)))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (setup-history)
    (set! history (new History self 500)))
  
  
  (method (historical-moment n)
    (historical-moment~ history n))
  
  
  (method (add-history elapse)
    (let ((moment (new Moment (snapshot-world) (object-copy commands) elapse)))
      (add-history~ history moment)))
  
  
  (method (backward-history)
    (backward-history~ history))
  
  
  (method (forward-history)
    (forward-history~ history))
  
  
  (method (slide-history where)
    (slide-history~ history where))
  
  
  (method (truncate-future)
    (truncate-future~ history))
  
  
  (method (toggle-history)
    (set! history? (not history?))
    (when (not history?)
      (setup~ history))
    (display-on/off "History" history?))
  
  
  (method (reset-history)
    (setup~ history)
    (display-message "History reset"))
  
  
  (method (step-world)
    (step-world~ history))
  
  
  (method (recalculate-future)
    (recalculate-future~ history))
  
  
  (method (update-future)
    (when (and history? paused?)
      (recalculate-future)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method override (move-forward)
    (if (and me first-person? (not paused?))
        (move-up~ me commands)
      (nextmethod)))
  
  
  (method override (move-backward)
    (if (and me first-person? (not paused?))
        (move-down~ me commands)
      (nextmethod)))
  
  
  (method override (strafe-left)
    (if (and me first-person? (not paused?))
        (strafe-left~ me commands)
      (nextmethod)))
  
  
  (method override (strafe-right)
    (if (and me first-person? (not paused?))
        (strafe-right~ me commands)
      (nextmethod)))
  
  
  (method override (strafe-up)
    (if (and me first-person? (not paused?))
        (strafe-up~ me commands)
      (nextmethod)))
  
  
  (method override (strafe-down)
    (if (and me first-person? (not paused?))
        (strafe-down~ me commands)
      (nextmethod)))
  
  
  (method override (rotate-left)
    (if (and me first-person? (not paused?))
        (rotate-left~ me commands)
      (nextmethod)))
  
  
  (method override (rotate-right)
    (if (and me first-person? (not paused?))
        (rotate-right~ me commands)
      (nextmethod)))
  
  
  (method (move-left)
    (when me
      (move-left~ me commands)))
  
  
  (method (move-right)
    (when me
      (move-right~ me commands)))
  
  
  (method (move-down)
    (when me
      (move-down~ me commands)))
  
  
  (method (move-up)
    (when me
      (move-up~ me commands)))
  
  
  (method (space)
    (when me
      (space~ me commands)))
  
  
  ;;;
  ;;;; Game
  ;;;
  
  
  (method (fire)
    (when (and me first-person? (not paused?))
      (fire~ me commands)))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method override (prepare-projection)
    (let ((ratio (/ width height))
          (near 0.1)
          (far 1000.0))
      (glMatrixMode GL_PROJECTION)
      (glLoadIdentity)
      (case projection
        ((perspective)
         (gluPerspective 45.0 ratio near far))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (glOrtho (- width) width (- height) height near far)))))))
  
  
  (method (activate-perspective)
    (set! projection 'perspective))
  
  
  (method (activate-orthographic)
    (standardize!~ eye-lookat)
    (update-camera)
    (set! editor-mode 'point)
    (set! projection 'orthographic))
  
  
  (method (toggle-projection)
    (case projection
      ((perspective) (activate-orthographic))
      ((orthographic) (activate-perspective)))
    (display-message (format "Projection {a}" projection)))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (definition camera-limit
    5.)
  
  
  (method override (camera-move-speed)
    1.0)
  
  (method override (camera-strafe-speed)
    0.5)
  
  (method override (camera-rotate-speed)
    0.03)
  
  
  (method (initialize-camera)
    (set! zoom-factor 54.5)
    (prepare-camera)
    (update-camera))
  
  
  (method override (prepare-camera)
    (vertex-init! eye 0.0 36.25 60.0)
    (standardize!~ eye-lookat))
  
  
  (method (toggle-eye)
    (set! eye? (not eye?)))
  
  
  (method (draw-eye)
    (let ((center (vertex- (vertex- (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) 5.)) (vertex-scalar* (get-right~ eye-lookat) 1.5)) (get-up~ eye-lookat))))
      (let ((sight (vertex+ center (get-sight~ eye-lookat)))
            (up (vertex+ center (get-up~ eye-lookat)))
            (right (vertex+ center (get-right~ eye-lookat)))
            (axis-x (vertex+ center (vertex 1. 0. 0.)))
            (axis-y (vertex+ center (vertex 0. 1. 0.)))
            (axis-z (vertex+ center (vertex 0. 0. 1.))))
        (let ((cx (vertex-x center))
              (cy (vertex-y center))
              (cz (vertex-z center)))
          (glLineWidth 2.)
          (glDisable GL_LIGHTING)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x sight) (vertex-y sight) (vertex-z sight))
          (glEnd)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x right) (vertex-y right) (vertex-z right))
          (glEnd)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x up) (vertex-y up) (vertex-z up))
          (glEnd)
          (gl-colorize {Color Red})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-x) (vertex-y axis-x) (vertex-z axis-x))
          (glEnd)
          (gl-colorize {Color Green})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-y) (vertex-y axis-y) (vertex-z axis-y))
          (glEnd)
          (gl-colorize {Color Blue})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-z) (vertex-y axis-z) (vertex-z axis-z))
          (glEnd)
          (glEnable GL_LIGHTING)
          (glLineWidth 1.)))))

  
  (method override (zoom-in)
    (if first-person?
        (first-distance-closer)
      (if (eq? projection 'perspective)
          (nextmethod)
        (set! zoom-factor (* zoom-factor .75)))))
  
  
  (method override (zoom-out)
    (if first-person?
        (first-distance-further)
      (if (eq? projection 'perspective)
          (nextmethod)
        (set! zoom-factor (/ zoom-factor .75)))))
  
  
  (method override (zoom-speed)
    10.)
  
  
  (method (change-first-camera)
    (let ((camera (next-element '(locked free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'locked)
        (follow-player))
      (display-message (format "Camera {a}" camera))))
  
  
  (method (follow-player)
    (when first-person?
      (unless (or viewing? (eq? first-camera 'free))
        (camera-behind-player))
      (when me
        (let ((target (player-target me)))
          (vertex-! eye target (vertex-scalar* (get-sight~ eye-lookat) (effective-first-distance)))
          (vertex+! eye-target eye (get-sight~ eye-lookat))
          (start~ camera-counter)
          (remove-eye-occlusion target)
          (end~ camera-counter)))))
  
  
  (method (camera-behind-player)
    (set-sight~ eye-lookat (get-sight~ (get-lookat~ me)))
    (set-up~ eye-lookat (get-up~ (get-lookat~ me)))
    (set-right~ eye-lookat (get-right~ (get-lookat~ me))))
  
  
  (method (player-target player)
    (vertex+ (get-position~ player)
             (vertex-scalar* (get-up~ (get-lookat~ player))
                             1.5)))
  
  
  (method (restore-first-distance elapse)
    (when (and first-override (not first-occlusion?))
      (let ((augmented-override (+ first-override (* elapse 100.))))
        (if (>= augmented-override first-distance)
            (set! first-override #f)
          (set! first-override augmented-override)))
      (occlusion-update-eye (player-target me))
      (adjust-player-alpha)))
  
  
  (method (remove-eye-occlusion target)
    (define (determine-eye-occlusion target)
      (let ((closest (ray-closest-sprite target (vertex-negate (get-sight~ eye-lookat)) first-distance ignore-players?: #t)))
        (if (not closest)
            (values #f #f)
          (bind (sprite face triangle distance) closest
            (values distance (get-normal~ triangle))))))
    
    (define (closer-eye-occlusion occlusion normal)
      (let ((trend (inner-product (get-sight~ eye-lookat) normal)))
        (if (= trend 0.)
            occlusion
          (- occlusion (/ .1 trend)))))
    
    (receive (occlusion normal) (determine-eye-occlusion target)
      (unless (eqv? occlusion first-override)
        (if (not occlusion)
            (set! first-occlusion? #f)
          (set! first-override (closer-eye-occlusion occlusion normal))
          (set! first-occlusion? #t)
          (occlusion-update-eye target))
        (adjust-player-alpha))))
  
  
  (method (occlusion-update-eye target)
    (vertex-! eye target (vertex-scalar* (get-sight~ eye-lookat) (effective-first-distance)))
    (vertex+! eye-target eye (get-sight~ eye-lookat)))
  
  
  (method (mark-eye target)
    (set-marks~ zone
      (list (new Mark (copy-vertex target) color: {Color Red})
            (new Mark (copy-vertex eye-target) color: {Color Green})
            (new Mark (copy-vertex eye) color: {Color Blue}))))
  
  
  (method (ray-closest-sprite p d max-distance (filter: filter #f) (ignore-players?: ignore-players? #f))
    (let ((closest #f)
          (distance #f)
          (distance-step (cast <fl> (get-area-size~ zone)))
          (visited (make-table test: eq?)))
      (let ((position (copy-vertex p))
            (position-step (vertex-scalar* d distance-step))
            (position-distance 0.))
        (let (iter)
          (iterate-position-neighbor-areas~ zone position
            (lambda (area)
              (unless (table-ref visited area #f)
                (iterate-area-sprites~ zone area
                  (lambda (targ)
                    (when (get-visible?~ targ)
                      (unless (and ignore-players? (is? targ Player))
                        (when (ray-intersects-sphere? p d (get-position~ targ) (get-radius~ targ))
                          (let ((cls (ray-closest-triangle~ targ p d filter)))
                            (when cls
                              (bind (face triangle dist) cls
                                (when (and (or (not distance)
                                               (< dist distance))
                                           (or (not max-distance)
                                               (< dist max-distance)))
                                  (set! closest (cons targ cls))
                                  (set! distance dist))))))))))
                (table-set! visited area #t))))
          (let ((new-distance (+ position-distance distance-step)))
            (when (<= new-distance max-distance)
              (vertex+! position position position-step)
              (set! position-distance new-distance)
              (iter)))))
      closest))
  
  
  (method (strafe-camera center-x)
    (let ((eye-x (vertex-x eye)))
      (if (> center-x (+ eye-x camera-limit))
          (strafe-horizontally (- center-x (+ eye-x camera-limit))))
      (if (< center-x (- eye-x camera-limit))
          (strafe-horizontally (- center-x (- eye-x camera-limit))))))
  
  
  (method (camera-center-player)
    (unless paused?
      (case projection
        ((perspective)
         (follow-player))
        ((orthographic)
         (strafe-camera (get-x~ me))))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (effective-first-distance)
    (or first-override first-distance))
  
  
  (method (first-distance-closer)
    (let ((distance (effective-first-distance)))
      (set! first-override #f)
      (set! first-distance (* distance .75))
      (camera-center-player)
      (adjust-player-alpha)))
  
  
  (method (first-distance-further)
    (let ((distance (effective-first-distance)))
      (set! first-override #f)
      (set! first-distance (min (/ distance .75) max-distance))
      (camera-center-player)
      (adjust-player-alpha)))
  
  
  (method (adjust-player-alpha)
    (when me
      (if (contains-vertex?~ me eye)
          (set-alpha~ me 0.)
        (set-alpha~ me (max 0.2 (min 1. (/ (effective-first-distance) 10.)))))))
  
  
  (method (move-player-forward player factor)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* (get-sight~ (get-lookat~ player)) (* factor (mount-speed))))))
  
  
  (method (move-player-backward player factor)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* (get-sight~ (get-lookat~ player)) (* factor (mount-speed))))))
  
  
  (method (strafe-player-left player factor)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* (get-right~ (get-lookat~ player)) (* factor (mount-speed))))))
  
  
  (method (strafe-player-right player factor)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* (get-right~ (get-lookat~ player)) (* factor (mount-speed))))))
  
  
  (method (strafe-player-up player factor)
    (strafe-player-vertical player (* (camera-strafe-speed) 2)))
  
  
  (method (strafe-player-down player factor)
    (strafe-player-vertical player (- (* (camera-strafe-speed) 2))))
  
  
  (method (strafe-player-vertical player distance)
    (vertex-copy! eye (vertex+ eye (vertex-scalar* world-up distance)))
    (update-camera)
    (set-y~ player (+ (get-y~ player) distance))
    (follow-player))
  
  
  (definition player-rotation-speed
    0.02)
  
  
  (method (rotate-player-left player factor)
    (rotate-player-horizontal player (* player-rotation-speed factor))
    (when fly?
      (tilt-player player -1.)))
  
  
  (method (rotate-player-right player factor)
    (rotate-player-horizontal player (- (* player-rotation-speed factor)))
    (when fly?
      (tilt-player player 1.)))
  
  
  (method (rotate-player-horizontal player angle (follow-player?: follow-player? #t))
    (let ((lookat (get-lookat~ player)))
      (rotate~ lookat angle world-up))
    (when (eq? player me)
      (unless (and down? (not moving?))
        (rotate~ eye-lookat angle world-up))
      (when follow-player?
        (follow-player))))
  
  
  (method (rotate-player-vertical player angle (follow-player?: follow-player? #t))
    (let ((lookat (get-lookat~ player)))
      (rotate~ lookat angle (get-right~ lookat)))
    (when (eq? player me)
      (rotate~ eye-lookat angle (get-right~ eye-lookat))
      (when follow-player?
        (follow-player))))
  
  
  (method (tilt-player player speed)
    @fix-tilt
    (let ((lookat (get-lookat~ player))
          (max-tilt PI/8)
          (max-speed 0.4))
      (let ((current (vertical-angle (get-right~ lookat) world-up))
            (desired (* (sign speed) max-tilt)))
        (set! desired-tilt desired)
        (set! tilt-speed (min (/ (abs speed) 50000.) max-speed))
        (set! last-tilt-time (time->seconds (current-time)))
        (process-tilt player))))
  
  
  (method (reset-player-tilt player)
    @fix-tilt
    (when (or (not last-tilt-time)
              (> (- (time->seconds (current-time)) last-tilt-time) .1))
      (set! desired-tilt 0.)
      (set! tilt-speed .015)
      (process-tilt player)))
  
  
  (method (process-tilt player)
    @fix-tilt
    (let ((lookat (get-lookat~ player)))
      (let ((current (vertical-angle (get-right~ lookat) world-up)))
        (unless (near? current desired-tilt .001)
          (let ((direction (sign (- desired-tilt current))))
            (let ((new-tilt (+ current (* direction tilt-speed))))
              (case direction
                ((1) (when (> new-tilt desired-tilt) (set! new-tilt desired-tilt)))
                ((-1) (when (< new-tilt desired-tilt) (set! new-tilt desired-tilt))))
              (let ((inc (- new-tilt current)))
                (increase-player-tilt player inc))))))))
  
  
  (method (increase-player-tilt player inc)
    @fix-tilt
    (let ((lookat (get-lookat~ player)))
      (rotate~ lookat inc (get-sight~ lookat))))
  
  
  (method (track-player player dh dv eye-sight eye-up eye-right first?)
    (let ((me? (eq? player me))
          @fix-tilt
          (tilt (vertical-angle eye-right world-up))
          (dh (cast <fl> dh))
          (dv (cast <fl> dv)))
      ;; remove tilt
      @fix-tilt
      (when (and me? (not fly?))
        (rotate~ eye-lookat (- tilt) eye-sight))
      (let ((pitch (vertical-angle eye-sight world-up)))
        ;; remove pitch
        (when (and me? (not fly?))
          (rotate-vertical pitch))
        ;; start from the eye lookat
        (when first?
          (let ((lookat (get-lookat~ player)))
            (set-sight~ lookat eye-sight)
            (set-up~ lookat eye-up)
            (set-right~ lookat eye-right)))
        ;; remove tilt
        @fix-tilt
        (when (and me? fly?)
          (rotate~ eye-lookat (- tilt) eye-sight))
        ;; remove pitch
        (when (and me? fly?)
          (rotate-vertical pitch))
        (rotate-player-horizontal player (/ (- dh) 200.) follow-player?: #f)
        ;; restore pitch
        (when me?
          (rotate-vertical (- pitch)))
        (if fly?
            (rotate-player-vertical player (/ (- dv) 200.) follow-player?: #f)
          (when me?
            (rotate-vertical (/ (- dv) 200.))))
        (when me?
          (follow-player))
        ;; restore tilt
        @fix-tilt
        (when me?
          (rotate~ eye-lookat tilt eye-sight))
        @fix-tilt
        (when (and fly? (/= dh 0.))
          (let ((speed (/ (cast <fl> dh) elapse)))
            (tilt-player player speed))))))
  
  
  (method (toggle-player-target)
    (set! player-target? (not player-target?)))

  
  (method (draw-player-target)
    (let ((target (player-target me)))
      (let ((x (vertex-x target))
            (y (vertex-y target))
            (z (vertex-z target))
            (size .25))
        (glDisable GL_DEPTH_TEST)
        (glDisable GL_LIGHTING)
        (glBegin GL_LINES)
        (gl-colorize {Color White})
        (glVertex3f (- x size) y z)
        (glVertex3f (+ x size) y z)
        (glVertex3f x (- y size) z)
        (glVertex3f x (+ y size) z)
        (glVertex3f x y (- z size))
        (glVertex3f x y (+ z size))
        (glEnd)
        (glEnable GL_LIGHTING)
        (glEnable GL_DEPTH_TEST))))
  
  
  ;;;
  ;;;; Resize
  ;;;
  
  
  (method protected override (resize-scene)
    (nextmethod)
    (unless immediate-mode?
      (resize~ render-target (fxround width) (fxround height))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (render-world)
    (start~ render-counter)
    (unless immediate-mode?
      (if post-processing?
          (prepare-render)
        (deactivate~ render-target)))
    (prepare-world)
    (process-keys)
    (setup-camera)
    (setup-lighting)
    (glEnable GL_DEPTH_TEST)
    (glShadeModel GL_SMOOTH)
    
    (draw-world)
    (render-interface)
    
    (unless immediate-mode?
      (when post-processing?
        (post-render)))
    
    ;(glFlush)
    (end~ render-counter))
  
  
  (method (prepare-render)
    (activate~ render-target)
    (glClear GL_COLOR_BUFFER_BIT)
    (glClear GL_DEPTH_BUFFER_BIT))
  
  
  (method (post-render)
    (deactivate~ render-target)
    (glClearColor 0. 0. 0. 1.)
    (glClear GL_COLOR_BUFFER_BIT)
    (glClear GL_DEPTH_BUFFER_BIT)
    
    ;; Copy the color buffer from the render target onto the native color buffer (0)
    (blit~ render-target 0)
    
    @w(
    (glClearColor 0. 0. 0. 1.)
    (glClear GL_COLOR_BUFFER_BIT)
    (glClear GL_DEPTH_BUFFER_BIT)
    
    (activate~ pp-program)
    (glActiveTexture GL_TEXTURE7)
    (glBindTexture GL_TEXTURE_2D (get-texture~ render-target))
    (glUniform1i (get-uniform~ pp-program "fbo_texture") 7)

    (glEnableVertexAttribArray (get-attribute~ pp-program "vertex_coord"))
    
    (glBindBuffer GL_ARRAY_BUFFER (get-vbo/fbo-vertices~ pp-program))
    (glVertexAttribPointer (get-attribute~ pp-program "vertex_coord") 2 GL_FLOAT GL_FALSE 0 #f)
    (glDrawArrays GL_TRIANGLE_STRIP 0 4)
    (glDisableVertexAttribArray (get-attribute~ pp-program "vertex_coord"))
    (deactivate~ pp-program)))
  
  
  (method override (setup-lighting)
    (setup-lighting~ zone))
  
  
  (method override (draw-world)
    (case projection
      ((perspective)
       (if 3d?
           (glEnable GL_DEPTH_TEST)
         (glDisable GL_DEPTH_TEST)))
      ((orthographic)
       (glDisable GL_DEPTH_TEST)))
    (draw-zone~ zone)
    (draw-grid)
    (when axes?
      (draw-axes))
    (when (and me player-target?)
      (draw-player-target))
    (when eye?
      (draw-eye))
    (when paused?
      (draw-history))
    (when draw-pack?
      (draw-pack))
    (draw-models)
    (when target
      (draw-target~ target)
      (draw-editor-target)))
  
  
  (method (draw-sectors)
    (define (draw-neighbors)
      (let ((sight (get-sight~ eye-lookat))
            (radius (get-sector-radius~ zone)))
        (iterate-position-neighbor-sectors~ zone eye
          (lambda (sector)
            (when (<= (inner-product (vertex- eye (get-center~ sector)) sight)
                      radius)
              (draw-sector sector))))))
    
    (if (not (get-textures?~ zone))
        (draw-neighbors)
      ;; Activate the asset shader (does texturing - we need to add lighting)
      (activate~ asset-program)
      
      ;; Pass the asset texture to the shader
      (bind-uniforms~ asset-program)
      
      ;; Draw neighborhood sectors culling those that are behind the camera
      (draw-neighbors)
      
      ;; Deactivate the asset shader
      (deactivate~ asset-program)
      (glActiveTexture GL_TEXTURE0)
      (glBindTexture GL_TEXTURE_2D 0)))
  
  
  (method (draw-sector sector)
    (update-vao~ sector)
    (if (not (get-textures?~ zone))
        (draw-triangles (get-vbo-content~ sector))
      (let ((vao (get-vao~ sector)))
        ;; Enable array/pointer assignments
        (enable-attributes~ asset-program vao)
        
        ;; Activate the VAO
        (activate~ vao)
        
        ;; Tell the shader where to read from the VBO
        (set-attributes~ asset-program vao)
        
        ;; Draw the VBO on screen
        (draw~ vao)
        
        ;; Disable array/pointer assignments
        (disable-attributes~ asset-program vao)
        
        ;; Deactivate the VAO
        (deactivate~ vao))))
  
  
  (method (draw-triangles content)
    (gl-colorize {Color red: 134 green: 82 blue: 1})
    (render-triangles content (f32vector-length content) GL_TRIANGLES)
    (when (get-asset-stiches?~ zone)
      (gl-colorize {Color red: .459 green: .280 blue: .002})
      (render-triangles content (f32vector-length content) GL_LINE_LOOP)))
  
  
  (method (draw-models)
    )
  
  
  (method (draw-axes)
    (glLineWidth 5.)
    (glDisable GL_LIGHTING)
    (glBegin GL_LINES)
    ;; X
    (glColor3f 1.0 0.0 0.0)
    (glVertex3f -50.0  0.0  0.0)
    (glVertex3f  50.0  0.0  0.0)
    (glVertex3f  50.0  0.0  0.0)
    (glVertex3f  47.5  0.0  2.5)
    (glVertex3f  50.0  0.0  0.0)
    (glVertex3f  47.5  0.0 -2.5)
    
    ;; Y
    (glColor3f 0.0 1.0 0.0)
    (glVertex3f  0.0 -50.0  0.0)
    (glVertex3f  0.0  50.0  0.0)
    (glVertex3f  0.0  50.0  0.0)
    (glVertex3f  2.5  47.5  0.0)
    (glVertex3f  0.0  50.0  0.0)
    (glVertex3f -2.5  47.5  0.0)
    
    ;; Z
    (glColor3f 0.0 0.0 1.0)
    (glVertex3f  0.0  0.0 -50.0)
    (glVertex3f  0.0  0.0  50.0)
    (glVertex3f  0.0  0.0  50.0)
    (glVertex3f  2.5  0.0  47.5)
    (glVertex3f  0.0  0.0  50.0)
    (glVertex3f -2.5  0.0  47.5)
    (glEnd)
    (glEnable GL_LIGHTING)
    (glLineWidth 1.))
  
  
  (method (draw-grid)
    (when grid?
      (glDisable GL_LIGHTING)
      (case grid-plane
        ((x)
         (let ((min -500.)
               (max 500.))
           (gl-colorize {Color Yellow})
           (glBegin GL_LINES)
           (loop (for y <fl> from min to max by 5.)
                 (glVertex3f grid-position y min)
                 (glVertex3f grid-position y max))
           (loop (for z <fl> from min to max by 5.)
                 (glVertex3f grid-position min z)
                 (glVertex3f grid-position max z))
           (glEnd)))
        ((y)
         (let ((min -500.)
               (max 500.))
           (gl-colorize {Color Green})
           (glBegin GL_LINES)
           (loop (for x <fl> from min to max by 5.)
                 (glVertex3f x grid-position min)
                 (glVertex3f x grid-position max))
           (loop (for z <fl> from min to max by 5.)
                 (glVertex3f min grid-position z)
                 (glVertex3f max grid-position z))
           (glEnd)))
        ((z)
         (let ((min -500.)
               (max 500.))
           (gl-colorize {Color Red})
           (glBegin GL_LINES)
           (loop (for x <fl> from min to max by 5.)
                 (glVertex3f x min grid-position)
                 (glVertex3f x max grid-position))
           (loop (for y <fl> from min to max by 5.)
                 (glVertex3f min y grid-position)
                 (glVertex3f max y grid-position))
           (glEnd))))
      (glEnable GL_LIGHTING)))
  
  
  (method (draw-history)
    (draw-history~ history draw-moment))
  
  
  (method (draw-moment n)
    (let ((snapshot (get-snapshot~ (historical-moment n))))
      (for-each (lambda (player)
                  (parameterize ((in-history? #t))
                    (draw~ player)))
                (get-players~ snapshot))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method override (draw-interface)
    (nextmethod)
    (draw-interface~ interface)
    (when message
      (draw-message))
    (when status
      (draw-status))
    (when counters?
      (draw-rate~ latency-counter)
      (draw-rate~ render-counter)
      (draw-rate~ tick-counter)
      @w (draw-rate~ camera-counter 'period)
      @w (draw-rate~ gc-counter 'frequency))
    (when (and history? paused?)
      (draw-history-slider))
    @debug-activation
    (when (get-active?~ (get-application))
      (let ((width (fxround (get-width~ world))))
        (let ((h (- width 20))
              (v 20))
          (gl-segment-circle (new Point h v) 7 {Color Light-Blue} 100)))))
  
  
  (method (draw-history-slider)
    (draw-history-slider~ history))
  
  
  ;;;
  ;;;; Pack
  ;;;
  
  
  (method (toggle-use-pack)
    (set! use-pack? (not use-pack?))
    (set! asset-texture (determine-asset-texture))
    (iterate-table (get-sectors~ zone)
      (lambda (index sector)
        (set-vao-uptodate?~ sector #f)))
    (display-on/off "Use pack" use-pack?))
  
  
  (method (draw-pack)
    (let ((texture (get-texture~ texture-pack))
          (width 100.)
          (height 100.))
      (map-texture~ texture)
      (textured-quad~ texture
        (lambda () (glVertex3f 0.0 0.0 0.0))
        (lambda () (glVertex3f width 0.0 0.0))
        (lambda () (glVertex3f width height 0.0))
        (lambda () (glVertex3f 0.0 height 0.0)))))
  
  
  ;;;
  ;;;; Win / Lose
  ;;;
  
  
  (method (win player)
    (win~ player)
    (let ((block (find-sprite~ zone
                   (lambda (obj)
                     (and (is? obj Block)
                          (eq? (get-user-data~ obj) 'win))))))
      (set-color~ block {Color Blue}))
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (lose player)
    (lose~ player)
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (reset-game)
    (setup-history))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method (missile-hit missile obj axis new-x new-y new-z)
    (if (is? obj Player)
        (begin
          (injure obj)
          'remove)
      (case (or (get-hit-behavior~ obj) (get-default-hit-behavior~ zone))
        ((absorb)
         'remove)
        ((rebound)
         (let ((velocity (get-velocity~ missile)))
           (case axis
             ((x) (vertex-x-set! velocity (- (vertex-x velocity))))
             ((y) (vertex-y-set! velocity (- (vertex-y velocity))))
             ((z) (vertex-z-set! velocity (- (vertex-z velocity))))))
         'stop)
        ((slide)
         'slide)
        ((destroy)
         (play-sound (get-explosion-sound~ world))
         (editor-remove-sprite obj)
         'remove))))
  
  
  (method (injure obj)
    (play-sound (get-explosion-sound~ world))
    (set-life~ obj (- (get-life~ obj) 10))
    (when (<= (get-life~ obj) 0)
      (die obj)))
  
  
  (method (die player)
    (display-message (format "{a} died" (get-name~ player)))
    (set-life~ player 100)
    (let ((old-position (get-position~ player)))
      (set-position~ player (vertex -127.6 17.0 -138.0))
      (update-area~ zone player old-position))
    (let ((lookat (get-lookat~ player)))
      (set-sight~ lookat (vertex .6830981969833374 -.15438011288642883 .7138231992721558))
      (set-up~ lookat (vertex .10673626512289047 .9880115389823914 .11153727769851685))
      (set-right~ lookat (vertex -.7224847078323364 0. .6913869380950928)))
    (when (eq? player me)
      (camera-behind-player)
      (follow-player)))
  
  
  (method (change-default-hit-behavior)
    (unimplemented-connected)
    (set-default-hit-behavior~ zone (next-element '(destroy absorb rebound slide) (get-default-hit-behavior~ zone)))
    (display-message (format "{a}" (get-default-hit-behavior~ zone))))

  
  ;;;
  ;;;; World
  ;;;

  
  (method (world-new)
    (unimplemented-connected)
    (new-world)
    (display-message "New world"))
  
  
  (method (world-open (reversed?: reversed? #f))
    (define (open-directory dir)
      (let ((name (get-name~ dir)))
        (let ((world (open-world (new-file~ dir (format "_{a}.world" name)))))
          (display-message~ world (format "{a}{a}"
                                          (get-title~ world)
                                          (let ((title (get-title~ zone)))
                                            (if (not zone)
                                                ""
                                              (format " / {a}" title))))))))
    
    (unimplemented-connected)
    (let ((directories (collect-directories~ {Directory Settings "worlds"})))
      (if (null? directories)
          (begin
            (display-error "No worlds found")
            (bell))
        (let ((moniker (get-moniker)))
          (if (not moniker)
              (open-directory ((if reversed? last car) directories))
            (let ((next (if reversed? previous-element next-element)))
              (let ((dir (next directories (world-directory) test: pathname=?)))
                (open-directory dir)))))
        (update-title))))
  
  
  (method (world-save)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (world-save-to moniker)
        (world-save-as))))
  
  
  (method (world-save-as)
    (unimplemented-connected)
    (let ((file (choose-new-file title: "Save New World" default-extension: "world" extensions: '(("World Files" . "world")) directory: {Directory Settings "worlds"})))
      (world-save-to file)
      (update-title)))
  
  
  (method (world-save-to file)
    (unimplemented-connected)
    (parameterize ((pretty-print-forms? #f))
      (save-to~ designer file))
    (display-message "Saved"))
  
  
  (method (world-revert)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (open-world moniker)
        (bell))))
  
  
  (method (world-directory)
    (let ((moniker (get-moniker)))
      (when moniker
        (get-parent~ moniker))))
  
  
  (method (update-title)
    (define (present-zone)
      (if (not zone)
          "New"
        (present-title (get-moniker~ zone) (get-modified?~ zone))))
    
    (define (present-title moniker modified?)
      (format "{a}{a}"
              (present-name moniker)
              (present-modified modified?)))
    
    (define (present-name moniker)
      (if (not moniker)
          "New"
        (get-name~ moniker)))
    
    (define (present-modified modified?)
      (if modified?
          " *"
        ""))
      
    (define (present-directory moniker)
        (if (not moniker)
            ""
          (let ((parent (world-directory)))
            (if (not parent)
                ""
              (format " ~{{a}}" (present-location~ parent))))))
    
    (set-title~ window (format "World - {a} {a}"
                               (present-zone)
                               (present-directory (get-moniker)))))
  
  
  (method (get-moniker)
    (get-origin~ (get-form~ designer)))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (when (neq? flag (get-modified?~ designer))
      (set-modified?~ designer flag)
      (update-title)))
  
  
  (method (reset-live)
    (unimplemented-connected)
    (set-target #f)
    (reset-zone~ zone)
    (camera-center-player)
    (reset-counters)
    (display-message "World reset"))
  
  
  ;;;
  ;;;; Zone
  ;;;

  
  (method (zone-new)
    (unimplemented-connected)
    (new-zone)
    (display-message "New zone"))
  
  
  (method (zone-open (reversed?: reversed? #f))
    (define (open-file file)
      (let ((zone (open-zone file)))
        (display-message~ world (get-title~ zone))))
    
    (unimplemented-connected)
    (let ((directory (world-directory)))
      (if (not directory)
          (bell)
        (let ((files (collect-files~ directory (lambda (file) (extension=? (get-extension~ file) "zone")))))
          (if (null? files)
              (begin
                (display-error "No zones found")
                (bell))
            (let ((moniker (get-moniker~ zone)))
              (if (not moniker)
                  (open-file ((if reversed? last car) files))
                (let ((next (if reversed? previous-element next-element)))
                  (let ((file (next files moniker test: pathname=?)))
                    (open-file file)))))
            (update-title))))))
  
  
  (method (zone-save)
    (unimplemented-connected)
    (let ((moniker (get-moniker~ zone)))
      (if moniker
          (zone-save-to moniker)
        (zone-save-as))))
  
  
  (method (zone-save-as)
    (unimplemented-connected)
    (let ((directory (or (world-directory) {Directory Settings "worlds"})))
      (let ((file (choose-new-file title: "Save New Zone" default-extension: "zone" extensions: '(("Zone Files" . "zone")) directory: directory)))
        (zone-save-to file)
        (update-title))))
  
  
  (method (zone-save-to file)
    (unimplemented-connected)
    (let ((designer (get-designer~ zone)))
      (parameterize ((pretty-print-forms? #f))
        (save-to~ designer file))
      (display-message "Saved")))
  
  
  (method (save-player)
    (unimplemented-connected)
    (if (not me)
        (bell)
      (let ((designer (get-designer~ zone)))
        (set-property~ designer zone 'start-position (get-position~ me))
        (let ((lookat (get-lookat~ me)))
          (set-property~ designer zone 'start-sight (get-sight~ lookat))
          (set-property~ designer zone 'start-up (get-up~ lookat)))
        (zone-save)
        (display-message "Player saved"))))
  
  
  (method (zone-revert)
    (unimplemented-connected)
    (let ((moniker (get-moniker~ zone)))
      (if moniker
          (begin
            (initialize-camera)
            (open-zone moniker))
        (bell))))
  
  
  ;;;
  ;;;; Mount
  ;;;
  
  
  (method (change-ground-mount (reversed?: reversed? #f))
    (unimplemented-connected)
    (let ((next (if reversed? previous-element next-element)))
      (let ((new-class (next (get-list~ ground-mounts-folio) (get-class~ ground-mounts-folio))))
        (set-class~ ground-mounts-folio new-class)
        (activate-mount new-class))))
  
  
  (method (activate-mount mnt)
    (set! mount mnt)
    (if (eq? mount 'carpet)
        (activate-fly)
      (deactivate-fly)))
  
  
  (method (mount-speed)
    (case mount
      ((carpet) 1.5)
      ((weels) 1.0)
      (else 0.5)))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot designer         <object> initialize #f  accessors generate)
  (slot editor-mode      <object> initialize #f  getter generate)
  (slot editor-anchor    <object> initialize #f  getter generate)
  (slot editor-last      <object> initialize #f  getter generate)
  (slot editor-added     <object> initialize #f  getter generate)
  (slot editor-normal    <object> initialize #f  getter generate)
  (slot editor-from      <object> initialize #f  getter generate)
  (slot editor-floor?    <object> initialize #f  getter generate)
  (slot editing?         <bool>   initialize #f  getter generate)
  (slot adding?          <bool>   initialize #f  getter generate)
  (slot deleting?        <bool>   initialize #f  getter generate)
  (slot sprite-template  <object> initialize #f  getter generate)
  (slot texture-template <object> initialize #f  getter generate)
  (slot grid?            <bool>   initialize #f  getter generate)
  (slot grid-plane       <symbol> initialize 'y  getter generate)
  (slot grid-position    <fl>     initialize 0.  getter generate)
  (slot last-added       <object> initialize #f  getter generate)
  (slot players-folio    <Folio>                 getter generate)
  (slot enemies-folio    <Folio>                 getter generate)
  (slot assets-folio     <Folio>                 getter generate)
  (slot gadgets-folio    <Folio>                 getter generate)
  
  
  (method (prepare-editor)
    (set! editor-mode 'block)
    (set! players-folio (new Folio 'player '(player pacman)))
    (set! enemies-folio (new Folio 'turtle '(turtle monster)))
    (set! assets-folio (new Folio 'block '(block block-red block-green block-blue)))
    (set! gadgets-folio (new Folio 'light '(light light-ambien light-sun gravity))))
  
  
  (method (change-editor-mode (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          ;; disable non-functional modes in multi-player
          (available-modes '(block column free @comment crazy @comment point @comment rectangle)))
      (let ((new-mode (next available-modes editor-mode)))
        (set! editor-mode new-mode)
        (display-message (capitalize (->string new-mode))))))
  
  
  (method (set-sprite-template)
    (if (not target)
        (begin
          (bell)
          (display-error "No target selected"))
      (set! sprite-template target)
      (display-message "Sprite template set")))
  
  
  (method (unset-sprite-template)
    (set! sprite-template #f)
    (display-message "Sprite template unset"))
  
  
  (method (set-texture-template)
    (if (not target-face)
        (begin
          (bell)
          (display-error "No face selected"))
      (set! texture-template (get-texture~ target-face))
      (display-message "Texture template set")))
  
  
  (method (unset-texture-template)
    (set! texture-template #f)
    (display-message "Texture template unset"))
  
  
  (method (add-sprite-class class x y z)
    (define (add class)
      (let ((obj (new class parent: zone x: x y: y z: z)))
        (if (is? obj Player)
            (set-name~ obj (effective-player-name~ (get-application)))
          (add-child~ (get-designer~ zone) obj zone import: '(world.data) properties: (list x: x y: y z: z)))
        (add-sprite~ zone obj)
        obj))
    
    (let ((sprite
            (case class
              ((player) (add Player))
              ((pacman) (add Pacman))
              ((turtle) (add Turtle))
              ((monster) (add Monster))
              ((block) (add Block))
              ((block-red) (add Block-Red))
              ((block-green) (add Block-Green))
              ((block-blue) (add Block-Blue))
              ((triangle) (add Triangle-Asset))
              ((quad) (add Quad-Asset))
              ((light) (add Light))
              ((light-ambien) (add Light-Ambient))
              ((light-sun) (add Light-Sun))
              ((gravity) (add Gravity)))))
      (when (is? sprite Gadget)
        (set! draw-gadgets? #t)
        (update-gadgets))
      sprite))
  
  
  (method (editor-add-sprite mode class vert (force?: force? #f))
    (define (sign r)
      (if (< r 0)
          -1
        1))
    
    (define (sign-test sign)
      (if (= sign -1)
          >=
        <=))
    
    (define (add-at left bottom back)
      (let ((sprite (add-sprite-class class left bottom back))
            (designer (get-designer~ zone)))
        (cond ((is? sprite Player)
               (set-x~ sprite (+ (get-x~ sprite) (get-radius-x~ sprite)))
               (set-y~ sprite (+ (get-y~ sprite) (get-radius-y~ sprite)))
               (set-z~ sprite (+ (get-z~ sprite) (get-radius-z~ sprite))))
              (else
               (set-property~ designer sprite 'x (+ (get-x~ sprite) (get-radius-x~ sprite)))
               (set-property~ designer sprite 'y (+ (get-y~ sprite) (get-radius-y~ sprite)))
               (set-property~ designer sprite 'z (+ (get-z~ sprite) (get-radius-z~ sprite)))))
        (update-position~ sprite)
        (copy-template sprite)
        (when (and (is? sprite Player) (not (get-world-server~ (get-process))))
          (let ((preserved-lookat (and me (get-lookat~ me))))
            (when me
              (remove-sprite me))
            (when (server-side?~ (get-process))
              (set-color~ sprite {Color White}))
            (set-me sprite)
            (when preserved-lookat
              (set-lookat~ me preserved-lookat))))
        (when (eq? sprite me)
          (camera-behind-player)
          (follow-player))
        sprite))
    
    (define (copy-template sprite)
      (let ((designer (get-designer~ zone)))
        (cond ((and (is? sprite Block) (is? sprite-template Block))
               (set-property~ designer sprite 'front-image (get-front-image~ sprite-template))
               (set-property~ designer sprite 'back-image (get-back-image~ sprite-template))
               (set-property~ designer sprite 'left-image (get-left-image~ sprite-template))
               (set-property~ designer sprite 'right-image (get-right-image~ sprite-template))
               (set-property~ designer sprite 'top-image (get-top-image~ sprite-template))
               (set-property~ designer sprite 'bottom-image (get-bottom-image~ sprite-template)))
              ((and (is? sprite Light) (is? sprite-template Light))
               (set-property~ designer sprite 'color (get-color~ sprite-template))
               (set-property~ designer sprite 'ambient-color (get-ambient-color~ sprite-template))
               (set-property~ designer sprite 'quadratic-attenuation (get-quadratic-attenuation~ sprite-template)))
              ((and (is? sprite Gravity) (is? sprite-template Gravity))
               (set-property~ designer sprite 'pull (get-pull~ sprite-template))))))
    
    (let ((to-x (* (floor (/ (vertex-x vert) 5.)) 5.))
          (to-y (* (floor (/ (vertex-y vert) 5.)) 5.))
          (to-z (* (floor (/ (vertex-z vert) 5.)) 5.)))
      (if (not editor-anchor)
          (let ((sprite (add-at to-x to-y to-z)))
            (set! last-added sprite)
            (set! editor-anchor (vertex to-x to-y to-z))
            sprite)
        (unless (and editor-last
                     (= (vertex-x editor-last) to-x)
                     (= (vertex-y editor-last) to-y)
                     (= (vertex-z editor-last) to-z)
                     (not force?))
          (case mode
            ((block column free crazy)
             (let ((actual (vertex->sprite~ zone vert)))
               (unless actual
                 (let ((sprite (add-at to-x to-y to-z)))
                   (set! last-added sprite)
                   (set! editor-added (list sprite))
                   (set! editor-last (vertex to-x to-y to-z))
                   sprite))))
            ((point)
             (let ((vert (vertex to-x to-y to-z)))
               (let ((actual (vertex->sprite~ zone vert)))
                 (unless actual
                   (let ((sprite (add-at to-x to-y to-z)))
                     (set! last-added sprite)
                     (set! editor-added (list sprite))
                     (set! editor-last (vertex to-x to-y to-z))
                     sprite)))))
            ((line))
            ((rectangle)
             (let ((anchor-x (vertex-x editor-anchor))
                   (anchor-y (vertex-y editor-anchor))
                   (anchor-z (vertex-z editor-anchor))
                   (last-x (vertex-x editor-last))
                   (last-y (vertex-y editor-last))
                   (last-z (vertex-z editor-last)))
               (let ((sign-x (sign (- to-x anchor-x)))
                     (sign-y (sign (- to-y anchor-y)))
                     (sign-z (sign (- to-z anchor-z))))
                 (let ((step-x (* sign-x 5.))
                       (step-y (* sign-y 5.))
                       (step-z (* sign-z 5.))
                       (test-x (sign-test sign-x))
                       (test-y (sign-test sign-y))
                       (test-z (sign-test sign-z)))
                   (let ((queue (new-queue))
                         (max-size 30))
                     (let (iter-x (x anchor-x) (count-x 0))
                       (when (and (< count-x max-size)
                                  (test-x x to-x))
                         (let (iter-y (y anchor-y) (count-y 0))
                           (when (and (< count-y max-size)
                                      (test-y y to-y))
                             (let (iter-z (z anchor-z) (count-z 0))
                               (when (and (< count-z max-size)
                                          (test-z z to-z))
                                 (let ((actual (vertex->sprite~ zone (vertex x y z))))
                                   (if actual
                                       (when (is? actual Asset)
                                         (enqueue queue actual))
                                     (let ((sprite (add-at x y z)))
                                       (enqueue queue sprite))))
                                 (iter-z (+ z step-z) (+ count-z 1))))
                             (iter-y (+ y step-y) (+ count-y 1))))
                         (iter-x (+ x step-x) (+ count-x 1))))
                     (let ((added (queue-list queue)))
                       (when editor-added
                         (for-each editor-remove-sprite (difference editor-added added)))
                       (set! editor-added added)
                       (set! editor-last (vertex to-x to-y to-z)))))))))))))
  
  
  (method (editor-sprite-class)
    (let ((alt? (alt-down?))
          (shift? (shift-down?)))
      (cond ((and alt? shift?) (get-class~ players-folio))
            (shift? (get-class~ enemies-folio))
            (alt? (get-class~ gadgets-folio))
            (else (get-class~ assets-folio)))))
  
  
  (method (sprite-folio sprite)
    (typecase sprite
      ((Player) players-folio)
      ((Enemy) enemies-folio)
      ((Asset) assets-folio)
      ((Gadget) gadgets-folio)
      (else #f)))
  
  
  (method (forward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (next-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)
          (display-message (format "{a}" new-class))))))
  
  
  (method (backward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (previous-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)
          (display-message (format "{a}" new-class))))))
  
  
  (method (change-class sprite class)
    (let ((vert (vertex (get-x~ sprite) (get-y~ sprite) (get-z~ sprite))))
      (editor-remove-sprite sprite)
      (editor-add-sprite editor-mode class vert force?: #t)))
  
  
  (method (remove-target)
    (if (not target)
        (bell)
      (add-action~ commands 'delete (list (get-position~ target)))))
  
  
  (method (remove-sprite obj)
    (remove-sprite~ zone obj)
    (when (eq? obj target)
      (set-target #f)))
  
  
  (method (editor-remove-sprite obj)
    (let ((designer (get-designer~ zone)))
      (remove-child~ designer obj)
      (remove-sprite obj)))
  
  
  (method (collect-textures)
    (define (add-files dir queue)
      (when (exists?~ dir)
        (iterate-directory~ dir
          (lambda (file)
            (when (extension=? (get-extension~ file) "png")
              (enqueue queue file)))
          files?: #t
          directories?: #f)))
    
    (define (make-texture file)
      (make-png-texture file texture-program))
    
    (when (not textures)
      (let ((queue (new-queue)))
        (add-files {Directory Settings "resources" "tiles"} queue)
        (add-files (new-directory~ resources-dir "tiles") queue)
        (set! textures (map make-texture (sort di<? (queue-list queue) key: get-base~)))))
    textures)
  
  
  (method (find-texture name)
    (find-if (lambda (texture)
               (let ((file (get-file~ texture)))
                 (and file (filename=? (get-name~ file) name))))
             (collect-textures)))
  
  
  (method (change-asset-texture (reversed?: reversed? #f))
    (if immediate-mode?
        (begin
          (bell)
          (display-error "Textures are disabled"))
      (if (not (get-textures?~ zone))
          (set-textures?~ zone #t)
        (let ((next (if reversed? previous-element next-element)))
          (let ((texture (next (collect-textures) asset-texture)))
            (set! asset-texture texture)
            (display-message (format "{a}" (get-name~ (get-file~ texture)))))))))
  
  
  (method (change-texture (reversed?: reversed? #f))
    (if immediate-mode?
        (begin
          (bell)
          (display-error "Textures are disabled"))
      (if (not target-face)
          (display-error "No face selected")
        (let ((next (if reversed? previous-element next-element)))
          (let ((texture (next (get-names~ texture-pack) (get-texture~ target-face) test: equal?)))
            (set-face-texture target target-face texture)
            (display-message (format "{a}" texture)))))))
  
  
  (method (set-face-texture sprite face texture)
    (if immediate-mode?
        (begin
          (bell)
          (display-error "Textures are disabled"))
      (let ((target-face? (eq? face target-face)))
        (let ((face (update-face-texture~ sprite face texture)))
          (when target-face?
            (set! target-face face))))
      (set-vao-uptodate?~ (sprite-sector~ zone sprite) #f)))
  
  
  (method (collect-models)
    (define (add-files dir table)
      (when (exists?~ dir)
        (iterate-directory~ dir
          (lambda (dir)
            (table-set! table (get-name~ dir) (make-model dir)))
          files?: #f
          directories?: #t)))
    
    (define (make-model dir)
      (let ((obj (new-file~ dir (make-filename (get-name~ dir) "obj")))
            (png (new-file~ dir (make-filename (get-name~ dir) "png"))))
        (assert (and (exists?~ obj)
                     (exists?~ png))
          (let ((model (new Model)))
            (load-obj~ model obj (make-png-texture png texture-program))
            model))))
    
    (when (not models)
      (let ((table (make-table test: equal?)))
        (add-files {Directory Settings "resources" "models"} table)
        (add-files (new-directory~ resources-dir "models") table)
        (set! models table)))
    models)
  
  
  (method (find-model name)
    (table-ref (collect-models) name #f))
  
  
  (method (toggle-grid)
    (set! grid? (not grid?))
    (activate-3d))
  
  
  (method (toggle-grid-plane plane)
    (if (and grid? (eq? grid-plane plane))
        (set! grid? #f)
      (set! grid? #t)
      (set! grid-plane plane)
      (activate-3d)))
  
  
  (method (decrease-grid)
    (move-grid-by -1))
  
  
  (method (increase-grid)
    (move-grid-by 1))
  
  
  (method (move-grid delta)
    (move-grid-by (fxround/ (- delta) 120)))
  
  
  (method (move-grid-by incr)
    (let ((dist (* incr 5.)))
     (increase! grid-position dist)
     (display-status (format "Grid at {a}" grid-position))))
  
  
  (method (editor-add-at mode vert)
    (let ((class (editor-sprite-class)))
      (let ((sprite (editor-add-sprite mode class vert)))
        (set-modified? #t)
        (update-future)
        sprite)))
  
  
  (method (editor-add-block mode grid? grid-plane grid-position eye direction first?)
    (define (determine-filter)
      (when (not first?)
        (case mode
          ((block) (block-filter))
          ((column) column-filter)
          ((free) free-filter)
          ((crazy) #f))))
    
    (define (block-filter)
      (let ((accessor (and editor-normal
                           (cond ((/= (vertex-x editor-normal) 0.) vertex-x)
                                 ((/= (vertex-y editor-normal) 0.) vertex-y)
                                 ((/= (vertex-z editor-normal) 0.) vertex-z)))))
        (lambda (sprite normal)
          (and editor-normal
               (vertex=? normal editor-normal)
               (or (not editor-from)
                   (= (accessor (get-position~ sprite)) (accessor editor-from)))))))
    
    (define (column-filter sprite normal)
      (and (vertex=? normal editor-normal)
           editor-from
           (let ((center (get-position~ sprite)))
             (or (vertex=? center editor-from)
                 (vertex=? (vertex-normalize (vertex- center editor-from)) editor-normal)))))
    
    (define (free-filter sprite normal)
      (vertex=? normal editor-normal))
    
    (define (add-block vert sprite normal)
      (unless (vertex->sprite~ zone vert)
        (let ((added (editor-add-at mode vert)))
          (when first?
            (set! editor-normal normal)
            (set! editor-from (if sprite
                                  (get-position~ sprite)
                                (vertex+ (get-position~ added) (vertex-scalar* normal -5.))))
            (set! editor-floor? (boolean (not sprite)))))))
    
    (let ((closest (ray-closest-sprite eye direction (get-radius~ zone) filter: (determine-filter) ignore-players?: #t)))
      (if closest
          (bind (sprite face triangle distance) closest
            (if texture-template
                (let ((normal (get-normal~ triangle)))
                  (set-face-texture sprite face texture-template)
                  (set! editor-normal normal))
              (let ((normal (get-normal~ triangle)))
                (add-block (vertex+ (get-position~ sprite) (vertex-scalar* normal 5.)) sprite normal))))
        (when (or first? (memq? mode '(free crazy)) (and editor-floor? (neq? mode 'column)))
          (let ((vert (screen->world eye direction grid? grid-plane grid-position floor-grid?: #t)))
            (when vert
              (let ((actual (vertex->sprite~ zone vert)))
                (unless actual
                  (add-block vert #f world-up)))))))))
  
  
  (method (editor-edit mode grid? grid-plane grid-position eye direction stage)
    (case stage
      ((down)
       (if (memq? mode '(block column free crazy))
           (editor-add-block mode grid? grid-plane grid-position eye direction #t)
         (let ((vert (screen->world eye direction grid? grid-plane grid-position)))
           (if (not vert)
               (begin
                 (unless grid?
                   (display-error "3d edition requires a grid"))
                 (bell))
             (let ((obj (vertex->sprite~ zone vert)))
               (cond (obj
                      (show-cursor)
                      (set! preserved-mouse #f)
                      (set! editor-anchor #f)
                      (set! editor-last #f)
                      (set! deleting? #t)
                      (editor-remove-sprite obj)
                      (set-modified? #t)
                      (update-future))
                     (else
                      (show-cursor)
                      (set! preserved-mouse #f)
                      (set! editor-anchor #f)
                      (set! editor-last #f)
                      (set! adding? #t)
                      (editor-add-at mode vert)
                      (update-future))))))))
      ((move)
       (if (memq? mode '(block column free crazy))
           (editor-add-block mode grid? grid-plane grid-position eye direction #f)
         (let ((vert (screen->world eye direction grid? grid-plane grid-position)))
           (when vert
             (let ((obj (vertex->sprite~ zone vert)))
               (cond (obj
                      (if (and adding? (eq? mode 'rectangle))
                          (let ((class (editor-sprite-class)))
                            (editor-add-sprite mode class vert)
                            (set-modified? #t)
                            (update-future))
                        (when deleting?
                          (editor-remove-sprite obj)
                          (set-modified? #t)
                          (update-future))))
                     (else
                      (when adding?
                        (let ((class (editor-sprite-class)))
                          (editor-add-sprite mode class vert)
                          (set-modified? #t))
                        (update-future)))))))))
      ((up)
       (set! editing? #f)
       (set! adding? #f)
       (set! deleting? #f)
       (set! editor-normal #f)
       (set! editor-from #f)
       (set! editor-floor? #f))))
  
  
  (method (editor-delete position)
    (let ((sprite (sprite-at~ zone position)))
      (when sprite
        (editor-remove-sprite sprite)
        (set-modified? #t))))
  
  
  (method (editor-mouse-down h v)
    (when (control-down?)
      (receive (eye direction) (screen->ray h v)
        (add-action~ commands 'edit (list editor-mode grid? grid-plane grid-position eye direction 'down))
        (set! editing? #t))))
  
  
  (method (editor-mouse-move h v)
    (when editing?
      (receive (eye direction) (screen->ray h v)
        (add-action~ commands 'edit (list editor-mode grid? grid-plane grid-position eye direction 'move)))))
  
  
  (method (editor-mouse-up h v)
    (receive (eye direction) (screen->ray (get-h~ down-point) (get-v~ down-point))
      (if editing?
          (add-action~ commands 'edit (list editor-mode grid? grid-plane grid-position eye direction 'up))
        (case projection
          ((perspective)
           (let ((closest (ray-closest-sprite eye direction (get-radius~ zone) ignore-players?: #t)))
             (if (not closest)
                 (set-target #f)
               (bind (sprite face) closest
                 (set-target sprite face)))))
          (else
           (let ((vert (screen->world eye direction grid? grid-plane grid-position)))
             (if (not vert)
                 (set-target #f)
               (set-target (vertex->sprite~ zone vert))))))))
    (set! editing? #f)
    (set! adding? #f)
    (set! deleting? #f)
    (set! editor-anchor #f)
    (set! editor-last #f)
    (set! editor-added #f))
  
  
  (method (draw-editor-target)
    ;(draw-movers)
    ;(draw-rotaters)
    ;(draw-scalers)
    )
  
  
  (method (draw-movers)
    (let ((x (get-x~ target))
          (y (get-y~ target))
          (z (get-z~ target)))
      (glLineWidth 2.)
      (glDisable GL_LIGHTING)
      (glDisable GL_DEPTH_TEST)
      ;; Axes
      (glBegin GL_LINES)
      ;; X
      (glColor3f 1.0 0.0 0.0)
      (glVertex3f (+ x   0.0)  y (+ z  0.0))
      (glVertex3f (+ x  10.0)  y (+ z  0.0))
      
      ;; Y
      (glColor3f 0.0 1.0 0.0)
      (glVertex3f (+ x  0.0) (+ y   0.0)  z)
      (glVertex3f (+ x  0.0) (+ y  10.0)  z)
      
      ;; Z
      (glColor3f 0.0 0.0 1.0)
      (glVertex3f (+ x  0.0)  y (+ z   0.0))
      (glVertex3f (+ x  0.0)  y (+ z  10.0))
      (glEnd)
      (glEnable GL_LIGHTING)
      (glLineWidth 1.)
      
      ;; Cone X
      (glPushMatrix)
      (glTranslatef (+ x 10.) y z)
      (glRotatef 90.0 0.0 1.0 0.0)
      (glScalef 0.5 0.5 0.5)
      (glColor4f 1.0 0.0 0.0 1.0)
      (gl-cylinder 1. 0. 2. 26 52)
      (glPopMatrix)
      
      ;; Cone Y
      (glPushMatrix)
      (glTranslatef x (+ y 10.) z)
      (glRotatef -90.0 1.0 0.0 0.0)
      (glScalef 0.5 0.5 0.5)
      (glColor3f 0.0 1.0 0.0)
      (gl-cylinder 1. 0. 2. 26 52)
      (glPopMatrix)
      
      ;; Cone Z
      (glPushMatrix)
      (glTranslatef x y (+ z 10.))
      (glRotatef -90.0 0.0 0.0 1.0)
      (glScalef 0.5 0.5 0.5)
      (glColor3f 0.0 0.0 1.0)
      (gl-cylinder 1. 0. 2. 26 52)
      (glPopMatrix)
      (glEnable GL_DEPTH_TEST)))
  
  
  (method (draw-rotaters)
    (let ((x (get-x~ target))
          (y (get-y~ target))
          (z (get-z~ target)))
      (glLineWidth 2.)
      (glDisable GL_LIGHTING)
      (glDisable GL_DEPTH_TEST)
      ;; Rotate X
      (glPushMatrix)
      (glTranslatef x y z)
      (glRotatef 90.0 0.0 1.0 0.0)
      (gl-segment-circle {Point 0 0} 7.5 {Color Red} 100)
      (glPopMatrix)
      
      ;; Rotate Y
      (glPushMatrix)
      (glTranslatef x y z)
      (glRotatef 90.0 1.0 0.0 0.0)
      (gl-segment-circle {Point 0 0} 7.5 {Color Green} 100)
      (glPopMatrix)
      
      ;; Rotate Z
      (glPushMatrix)
      (glTranslatef x y z)
      (glRotatef 90.0 0.0 0.0 1.0)
      (gl-segment-circle {Point 0 0} 7.5 {Color Blue} 100)
      (glPopMatrix)
      (glEnable GL_LIGHTING)
      (glEnable GL_DEPTH_TEST)
      (glLineWidth 1.)))
  
  
  (method (draw-scalers)
    )
  
  
  ;;;
  ;;;; Screen
  ;;;
  
  
  (method (screen->ray h v)
    (let ((ratio (/ width height))
          (ch (- h (/ width 2)))
          (cv (- (- height v) (/ height 2))))
      (case projection
        ((perspective)
         (let ((f-over-y (/ PI/4 2.))
               (eye-up (get-up~ eye-lookat)))
           (let ((cone (tan f-over-y))
                 (d (vertex-distance eye eye-target))
                 (right (cross-product (vertex- eye-target eye) eye-up)))
             (let ((target-in-eye-space (vertex+ (vertex-scalar* eye-up (/ (* cv d cone 2.) height))
                                                 (vertex+ (vertex-scalar* right (/ (* ch d cone 2. ratio) width))
                                                          eye-target))))
               (values (copy-vertex eye) (vertex-normalize (vertex- target-in-eye-space eye)))))))
        ((orthographic)
         (let ((x (+ (/ (* 2. ch zoom-factor) width) (vertex-x eye)))
               (y (+ (/ (* 2. cv zoom-factor) height ratio) (vertex-y eye))))
           (values (vertex x y (vertex-z eye)) (vertex 0. 0. -1.)))))))
  
  
  (method (screen->world eye direction grid? grid-plane grid-position (floor-grid?: floor-grid? #f))
    (define (perspective->world norm plane-k)
      (let ((norm-direction-inner-product (inner-product norm direction)))
        (unless (and (= norm-direction-inner-product 0.)
                     (case grid-plane
                       ((x) (= (vertex-x eye) grid-position))
                       ((y) (= (vertex-y eye) grid-position))
                       ((z) (= (vertex-z eye) grid-position))))
          (let ((intersect (/ (- plane-k (inner-product norm eye))
                              norm-direction-inner-product)))
            (unless (<= intersect 0)
              (let ((point (vertex+ eye (vertex-scalar* direction intersect))))
                (if (> norm-direction-inner-product 0.)
                    (values (vertex- point (vertex-scalar* norm 5.)) (+ grid-position -5.))
                  (values point grid-position))))))))
    
    (if (eq? projection 'orthographic)
        (let ((info (perspective->world (vertex 0. 0. 1.) 0.)))
          (when info
            (receive (vert position) info
              (and vert (vertex
                          (vertex-x vert)
                          (vertex-y vert)
                          position)))))
      (if (not grid?)
          (when floor-grid?
            (let ((info (perspective->world (vertex 0. 1. 0.) floor-level)))
              (when info
                (receive (vert position) info
                  (and vert (vertex
                              (vertex-x vert)
                              position
                              (vertex-z vert)))))))
        (case grid-plane
          ((x) (let ((info (perspective->world (vertex 1. 0. 0.) grid-position)))
                 (when info
                   (receive (vert position) info
                     (and vert (vertex
                                 position
                                 (vertex-y vert)
                                 (vertex-z vert)))))))
          ((y) (let ((info (perspective->world (vertex 0. 1. 0.) grid-position)))
                 (when info
                   (receive (vert position) info
                     (and vert (vertex
                                 (vertex-x vert)
                                 position
                                 (vertex-z vert)))))))
          ((z) (let ((info (perspective->world (vertex 0. 0. 1.) grid-position)))
                 (when info
                   (receive (vert position) info
                     (and vert (vertex
                                 (vertex-x vert)
                                 (vertex-y vert)
                                 position))))))))))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-hook? initialize #t getter generate)
  
  
  (method (toggle-paused)
    (unimplemented-connected)
    (if paused?
        (unpause-world)
      (pause-world)))
  
  
  (method (toggle-evaluation)
    (set! evaluate-hook? (not evaluate-hook?))
    (display-on/off "Evaluation" evaluate-hook?))
  
  
  (method (pause-world)
    (when history?
      (set-current~ history (snapshot-world)))
    (set! paused? #t)
    (set! animate? #f)
    (reset-counters))
  
  
  (method (unpause-world)
    (truncate-future)
    (set-current~ history #f)
    (set! paused? #f)
    (set! animate? #t)
    (follow-player)
    (reset-counters))
  
  
  (method (snapshot-world)
    (snapshot-zone~ zone))
  
  
  (method (load-world snapshot)
    (let ((previous-target target))
      (load-zone~ zone snapshot)
      (set-me (find-player (get-actors~ zone)))
      (set-target (and previous-target (find-target previous-target (get-sprites~ zone))))))
  
  
  (method (find-player actors)
    (find-if (lambda (obj)
               (is? obj Player))
             actors))
  
  
  (method (find-named-player player-name)
    (find-if (lambda (actor)
               (and (is? actor Player)
                    (equal? (get-name~ actor) player-name)))
             (get-actors~ zone)))
  
  
  (method (find-target target sprites)
    (let ((origin (get-origin~ target)))
      (find-if (lambda (obj)
                 (eq? (get-origin~ obj) origin))
               sprites)))
  
  
  (method (set-target targ (face #f))
    (set! target targ)
    (set! target-face face)
    (target-update target))
  
  
  (method (toggle-draw-sprites)
    (set! draw-sprites? (not draw-sprites?))
    (display-on/off "Draw sprites" draw-sprites?))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method override (evaluate-hook)
    (when evaluate-hook?
      (setup-lights~ zone)
      (setup-lighting~ zone)
      (update-future)))
  
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method (test1-world)
    )
  
  
  (method (test2-world)
    )
  
  
  (method (test3-world)
    )
  
  
  (method (test4-world)
    )
  
  
  (method (test5-world)
    )
  
  
  (method (test6-world)
    )
  
  
  (method (test7-world)
    )
  
  
  (method (test8-world)
    (case (tier~ (get-application))
      ((server)
       (for-each (lambda (server-client)
                   (let ((client (get-client~ server-client)))
                     (server-test~ client #f)))
                 (get-clients~ (get-application))))
      ((client)
       (let ((server (get-remote-server~ (get-application)))
             (client (get-remote-client~ (get-application))))
         (if (not server)
             (bell)
           (client-test~ server client #f))))))
  
  
  (method (test9-world)
    (if (validate-areas~ zone)
        (display-message "Areas valid" color: {Color Green})
      (display-message "Areas corrupted!" color: {Color Red})
      (set-visible?~ (child~ interface 'info) #t)))
  
  
  (method (test0-world)
    (testing? (not (testing?)))
    (display-on/off "Testing" (testing?)))
  
  
  ;;;
  ;;;; GC
  ;;;
  
  
  (method (setup-gc)
    (add-gc-interrupt-job!
      (lambda ()
        (process~ gc-counter (last-gc-real-time)))))
  
  
  ;;;
  ;;;; Slider
  ;;;
  
  
  (slot sliding? initialize #f)
  
  
  (method (slider-mouse-down h v)
    (set! sliding? #t)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-move h v)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-up h v)
    (set! sliding? #f))
  
  
  (method (h->where h)
    (let ((cx (fxround (/ width 2.))))
      (let ((where (/ (+ (- h cx) 200.) 400.)))
        (max 0. (min 1. where)))))
  
  
  (method (in-slider? v)
    (< v 60))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down h v)
    (set! down? #t)
    (set! down-point (new Point h v))
    (cond ((and history? paused? (in-slider? v))
           (slider-mouse-down h v))
          ((and paused? (eq? projection 'perspective))
           (setup-viewing h v)
           (nextmethod h v))
          (else
           (editor-mouse-down h v))))
  
  
  (method override (mouse-move h v)
    (cond ((and history? paused? sliding?)
           (slider-mouse-move h v))
          ((and paused? (eq? projection 'perspective))
           (nextmethod h v))
          (last-point
           (nextmethod h v)
           (unless moving?
             (follow-player)))
          (editing?
           (editor-mouse-move h v))
          ((and down? (not (near? (new Point h v) down-point drag-tolerance)))
           (hide/preserve-cursor)
           (set! viewing? #t)
           (setup-viewing h v))))
  
  
  (method override (mouse-track elapse dh dv)
    (when (eq? projection 'perspective)
      (if (and me moving? (or (not paused?) (neq? projection 'perspective)))
          (let ((first? (not moved?)))
            (add-action~ commands 'track (list dh dv (get-sight~ eye-lookat) (get-up~ eye-lookat) (get-right~ eye-lookat) first?))
            (set! moved? #t))
        (nextmethod elapse dh dv))))
  
  
  (method override (mouse-up h v)
    (restore/show-cursor)
    (cond ((and history? paused? sliding?)
           (slider-mouse-up h v))
          ((and paused? (eq? projection 'perspective))
           (nextmethod h v))
          (last-point
           (nextmethod h v)
           (follow-player))
          (else
           (editor-mouse-up h v)))
    (set! down? #f)
    (set! down-point #f)
    (set! viewing? #f))
  
  
  (method override (right-mouse-down h v)
    (hide/preserve-cursor)
    (set! moving? #t)
    (set! moved? #f)
    (nextmethod h v))
  
  
  (method override (right-mouse-up h v)
    (when me
      (reset-player-tilt me))
    (restore/show-cursor)
    (set! moving? #f)
    (nextmethod h v))
  
  
  (method (hide/preserve-cursor)
    (hide-cursor)
    (set! preserved-mouse (mouse-position~ window)))
  
  
  (method (restore/show-cursor)
    (when preserved-mouse
      (set-mouse-position~ window preserved-mouse)
      (set! preserved-mouse #f))
    (show-cursor))
  
  
  (method override (mouse-wheel h v delta)
    (if (control-down?)
        (move-grid delta)
      (nextmethod h v delta)))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (process-keys)
    (let ((evt (make-event Keyboard-Event :char self)))
      ;; camera
      (process-movement evt allow-space?: paused?)
      ;; me
      (when (get-active?~ (get-application))
        (receive (shift? control? alt?) (modifiers-down)
          (unless (or shift? control? alt?)
            (when (key-down? VK_LEFT)
              (move-left))
            (when (key-down? VK_RIGHT)
              (move-right))
            (when (key-down? VK_DOWN)
              (move-down))
            (when (key-down? VK_UP)
              (move-up))
            (when (key-down? (char->integer #\space))
              (if (and first-person? fly?)
                  (strafe-up)
                (space)))
            (when (key-down? (char->integer #\1))
              (let ((seconds (time->seconds (current-time))))
                (when (or (not last-missile)
                          (> (- seconds last-missile) missile-delay))
                  (fire)
                  (set! last-missile seconds)))))))))
  
  
  (method override (process-shortcut shortcut)
    (continuation-capture
      (lambda (return)
        (cond ;; server
              ((shortcut=? shortcut {Shortcut #\;}) (connect-to-server))
              ((shortcut=? shortcut {Shortcut :shift #\;}) (disconnect-from-server))
              ;; window
              ((or (shortcut=? shortcut {Shortcut F9}) (shortcut=? shortcut {Shortcut :control :alt F9})) (live-gaia/world))
              ((or (shortcut=? shortcut {Shortcut F10}) (shortcut=? shortcut {Shortcut :control :alt F10})) (design-gaia/world))
              ((or (shortcut=? shortcut {Shortcut F11}) (shortcut=? shortcut {Shortcut :control :alt F11})) (toggle-windowed-mode))
              ((or (shortcut=? shortcut {Shortcut F12}) (shortcut=? shortcut {Shortcut :control :alt F12})) (restore-gaia/world))
              ;; world
              ((shortcut=? shortcut {Shortcut :control #\O}) (world-open))
              ((shortcut=? shortcut {Shortcut :control :shift #\O}) (world-open reversed?: #t))
              ;; zone
              ((shortcut=? shortcut {Shortcut :control #\N}) (zone-new))
              ((shortcut=? shortcut {Shortcut :control #\L}) (zone-open))
              ((shortcut=? shortcut {Shortcut :control :shift #\L}) (zone-open reversed?: #t))
              ((shortcut=? shortcut {Shortcut :control #\S}) (zone-save))
              ((shortcut=? shortcut {Shortcut :control :shift #\S}) (zone-save-as))
              ((shortcut=? shortcut {Shortcut :control :alt #\S}) (save-player))
              ((shortcut=? shortcut {Shortcut :control #\R}) (zone-revert))
              ;; history
              ((shortcut=? shortcut {Shortcut :shift #\H}) (reset-history))
              ;; camera
              ((shortcut=? shortcut {Shortcut :alt #\1}) (first-person))
              ((shortcut=? shortcut {Shortcut :alt #\3}) (toggle-3d))
              ((shortcut=? shortcut {Shortcut :alt #\8}) (change-first-camera))
              ;; draw
              ((shortcut=? shortcut {Shortcut #\G}) (toggle-draw-gadgets))
              ((shortcut=? shortcut {Shortcut #\J}) (toggle-draw-sprites))
              ((shortcut=? shortcut {Shortcut :control #\H}) (change-default-hit-behavior))
              ((shortcut=? shortcut {Shortcut :control #\K}) (toggle-draw-pack))
              ;; mount
              ((shortcut=? shortcut {Shortcut #\R}) (change-ground-mount))
              ((shortcut=? shortcut {Shortcut :shift #\R}) (change-ground-mount reversed?: #t))
              ;; editor
              ((shortcut=? shortcut {Shortcut Delete}) (remove-target))
              ((shortcut=? shortcut {Shortcut :control #\G}) (toggle-grid))
              ((shortcut=? shortcut {Shortcut :control #\1}) (toggle-grid-plane 'z))
              ((shortcut=? shortcut {Shortcut :control #\2}) (toggle-grid-plane 'y))
              ((shortcut=? shortcut {Shortcut :control #\3}) (toggle-grid-plane 'x))
              ((shortcut=? shortcut {Shortcut :control Left}) (decrease-grid))
              ((shortcut=? shortcut {Shortcut :control Right}) (increase-grid))
              ((shortcut=? shortcut {Shortcut :control Tab}) (forward-sprite-class))
              ((shortcut=? shortcut {Shortcut :control :shift Tab}) (backward-sprite-class))
              ((shortcut=? shortcut {Shortcut :control #\B}) (change-asset-texture))
              ((shortcut=? shortcut {Shortcut :control :shift #\B}) (change-asset-texture reversed?: #t))
              ((shortcut=? shortcut {Shortcut :control #\T}) (change-texture))
              ((shortcut=? shortcut {Shortcut :control :shift #\T}) (change-texture reversed?: #t))
              ((shortcut=? shortcut {Shortcut :control #\W}) (change-editor-mode))
              ((shortcut=? shortcut {Shortcut :control :shift #\W}) (change-editor-mode reversed?: #t))
              ((shortcut=? shortcut {Shortcut :control #\C}) (set-sprite-template))
              ((shortcut=? shortcut {Shortcut :control :shift #\C}) (unset-sprite-template))
              ((shortcut=? shortcut {Shortcut :control :alt #\C}) (set-texture-template))
              ((shortcut=? shortcut {Shortcut :control :alt :shift #\C}) (unset-texture-template))
              ((shortcut=? shortcut {Shortcut :control :alt #\D}) (remove-duplicate-blocks~ zone))
              ;; debug
              ((shortcut=? shortcut {Shortcut :control #\M}) (reset-all-marks~ zone))
              ((shortcut=? shortcut {Shortcut :control :alt #\1}) (test1-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\2}) (test2-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\3}) (test3-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\4}) (test4-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\5}) (test5-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\6}) (test6-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\7}) (test7-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\8}) (test8-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\9}) (test9-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\0}) (test0-world))
              ((shortcut=? shortcut {Shortcut #\0}) (reset-live))
              ((shortcut=? shortcut {Shortcut :alt #\C}) (garbage-collect))
              (else (continuation-return return #f)))
        #t)))
  
  
  (method override (key-press key)
    (let ((evt (make-event Keyboard-Event :char self key: key)))
      (case key
        ;; editor
        ((#\backspace) (remove-target))
        ;; debug
        ((#\p) (toggle-paused))
        ((#\\) (toggle-evaluation))
        ((#\[) (backward-history))
        ((#\]) (forward-history))
        ((#\return) (step-world))
        ((#\h) (toggle-history))
        ((#\c) (clear-terminal))
        ((#\6) (toggle-debug-areas~ zone))
        ;; world
        ((#\5) (toggle-asset-stiches))
        ((#\.) (toggle-post-processing))
        ;; me
        ((#\7) (toggle-player-target))
        ;; projection
        ((#\8) (toggle-eye))
        ((#\f) (toggle-fly))
        ;; music
        ((#\m) (change-music))
        ;; settings
        ((#\z) (toggle-interface))
        ((#\-) (toggle-counters))
        ((#\_) (reset-counters) (display-message "Counters reset"))
        ((#\=) (toggle-axes))
        ((#\i) (toggle-info))
        ((#\y) (request-server-update))
        ((#\l) (toggle-lighting) (display-on/off "Light" light?))
        ((#\v) (toggle-projection))
        ((#\t) (toggle-textures))
        ((#\k) (toggle-use-pack)))))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method (connect-to-server)
    (let ((process (get-process)))
      (if (get-world-server~ process)
          (display-error "Already connected")
        (connect-server~ process)
        (display-message "Connected" color: {Color Green}))))
  
  
  (method (disconnect-from-server)
    (let ((process (get-process)))
      (if (not (get-world-server~ process))
          (display-error "Not connected")
        (disconnect~ process)
        (display-message "Disconnected"))))
  
  
  (method (request-server-update)
    (let ((process (get-process)))
      (if (not (get-world-server~ process))
          (display-error "Not connected")
        (update-client~ process)
        (display-message "Requesting server update"))))
  
  
  (method (unimplemented-connected)
    (when (get-world-server~ (get-process))
      (display-error "Unimplemented when connected")
      (signal-cancel)))
  
  
  ;;;
  ;;;; Window
  ;;;
  
  
  (method (live-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (bell)
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (live-gaia/world~ debugger debuggee)))))
  
  
  (method (design-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (bell)
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (design-gaia/world~ debugger debuggee)))))
  
  
  (method (restore-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (bell)
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (restore-gaia/world~ debugger debuggee)))))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (toggle-post-processing)
    (set! post-processing? (not post-processing?))
    (display-on/off "Post processing" post-processing?))
  
  
  (method (first-person)
    (if (not me)
        (display-error "No player")
      (if first-person?
          (deactivate-first-person)
        (activate-first-person))
      (display-on/off "First person" first-person?)))
  
  
  (method (activate-first-person)
    (set! first-person? #t)
    (camera-center-player)
    (activate-3d))
  
  
  (method (deactivate-first-person)
    (set! first-person? #f))
    
  
  (method (toggle-3d)
    (if 3d?
        (deactivate-3d)
      (activate-3d))
    (display-on/off "3d" 3d?))
  
  
  (method (activate-3d)
    (set! 3d? #t)
    (set! light? #t)
    (activate-perspective))
  
  
  (method (deactivate-3d)
    (set! 3d? #f)
    (set! light? #f)
    (activate-orthographic))
  
  
  (method (toggle-fly)
    (unimplemented-connected)
    (activate-mount
      (if fly?
          'none
        'carpet)))
  
  
  (method (activate-fly)
    (unless fly?
      (set! fly? #t)
      (when me
        (set-y~ me (+ (get-y~ me) 2.))
        (update-position~ me)
        (follow-player))))
  
  
  (method (deactivate-fly)
    (when fly?
      (set! fly? #f)
      (when me
        (rotate-player-vertical me (vertical-angle (get-sight~ (get-lookat~ me)) world-up))
        (follow-player))))

  
  (method (toggle-textures)
    (if immediate-mode?
        (begin
          (bell)
          (display-error "Textures are disabled"))
      (set-textures?~ zone (not (get-textures?~ zone)))
      (iterate-table (get-sectors~ zone)
        (lambda (index sector)
          (set-vao-uptodate?~ sector #f)))
      (display-on/off "Textures" (get-textures?~ zone))))
  
  
  (method (toggle-draw-gadgets)
    (set! draw-gadgets? (not draw-gadgets?))
    (update-gadgets)
    (display-on/off "Draw gadgets" draw-gadgets?))
  
  
  (method (toggle-draw-pack)
    (set! draw-pack? (not draw-pack?))
    (display-on/off "Draw pack" draw-pack?))
  
  
  (method (update-gadgets)
    (iterate-gadgets~ zone
      (lambda (gadget)
        (set-visible?~ gadget draw-gadgets?)))
    (when (and (is? target Gadget)
               (not (get-visible?~ target)))
      (set-target #f)))
  
  
  (method (toggle-axes)
    (set! axes? (not axes?))
    (display-on/off "Axes" axes?))
  
  
  (method (toggle-info)
    (let ((pane (child~ interface 'info)))
      (set-visible?~ pane (not (get-visible?~ pane)))
      (when (get-visible?~ pane)
        (set! interface? #t))))
  
  
  (method (toggle-counters)
    (set! counters? (not counters?))
    (reset-counters)
    (when counters?
      (set! interface? #t)))
  
  
  (method (reset-counters)
    (reset~ gc-counter)
    (reset~ tick-counter)
    (reset~ render-counter)
    (reset~ latency-counter)
    (reset~ camera-counter))
  
  
  (method (display-on/off title flag)
    (display-message (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method (display-message msg (color: color #f))
    (set! message msg)
    (set! message-color color)
    (set! message-time (time->seconds (current-time))))
  
  
  (method (draw-message)
    (let ((elapse (- (time->seconds (current-time)) message-time)))
      (if (> elapse 2.)
          (begin
            (set! message #f)
            (set! message-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ message-texture))
                (font {Font Heading1})
                (color (or message-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 message)
            (map-texture~ message-texture)
            (let ((w (text-width~ font message)))
              (let ((c (center w (fxround width))))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) (cast <fl> (- (fxround height) 200)) 0.0)
                (textured-quad~ message-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 100.0 0.0))
                  (lambda () (glVertex3f 0.0 100.0 0.0)))
                (glPopMatrix))))))))
    
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method (display-error msg)
    (display-message msg color: {Color Red}))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method (display-status msg (color: color #f))
    (set! status msg)
    (set! status-color color)
    (set! status-time (time->seconds (current-time))))
  
  
  (method (draw-status)
    (let ((elapse (- (time->seconds (current-time)) status-time)))
      (if (> elapse 2.)
          (begin
            (set! status #f)
            (set! status-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ status-texture))
                (font {Font Heading2})
                (color (or status-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 status)
            (map-texture~ status-texture)
            (let ((w (text-width~ font status)))
              (let ((c (center w (fxround width))))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) 30.0 0.0)
                (textured-quad~ status-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 35.0 0.0))
                  (lambda () (glVertex3f 0.0 35.0 0.0)))
                (glPopMatrix))))))))
  
  
  ;;;
  ;;;; Info
  ;;;
  
  
  (method (debug-info)
    (define (present-object obj)
      (format "~{{s} #{s}}"
              (reference-name (get-name~ (class-of obj)))
              (object->serial obj)))
    
    (define (present-boolean bool)
      (if bool "true" "false"))
    
    `(,@(if (client-side?~ (get-process))
            `(,(format "{a}" (get-player-name~ (get-process))))
         `("Server"
           ,(format "clients: {a}" (length (get-clients~ (get-process))))
           ,(format "hits: {a}" (get-hits~ (get-process)))))
      ""
      ,(format "window: {a}" (present-object window))
      ,(format "width: {s}" width)
      ,(format "height: {s}" height)
      ""
      ,(format "world: {s}" self)
      ,(format "version: {s}" version)
      ""
      ,(format "zone: {s}" zone)
      ,(format "sectors: {s}" (table-length (get-sectors~ zone)))
      ,(format "areas: {s}" (table-length (get-areas~ zone)))
      ,(format "assets: {s}" (length (get-assets~ zone)))
      ,(format "actors: {s}" (length (get-actors~ zone)))
      ,(format "sprites: {s}" (length (get-sprites~ zone)))
      ,(format "gadgets: {s}" (length (get-gadgets~ zone)))
      ,(format "children: {s}" (length (get-children~ zone)))
      ,(format "marks: {s}" (length (get-marks~ zone)))
      ""
      ,@(let* ((floats (compute-vbo-floats~ zone))
               (indices (/ floats 3))
               (vertices (/ indices 3))
               (triangles (/ vertices 3)))
          `(,(format "VBO triangles: {s}" triangles)
            ,(format "VBO vertices: {s}" vertices)
            ,(format "VBO indices: {s}" indices)
            ,(format "VBO floats: {s}" floats)))
      ""
      ,@(if target
            `(,(format "target: {a}" (present-object target))
              ,(format "  x: {r precision: 1}" (get-x~ target))
              ,(format "  y: {r precision: 1}" (get-y~ target))
              ,(format "  z: {r precision: 1}" (get-z~ target))
              ,(format "  width: {s}" (get-width~ target))
              ,(format "  height: {s}" (get-height~ target))
              ,(format "  depth: {s}" (get-depth~ target))
              ,(format "  texture: {s}" (get-texture~ target))
              ,(format "  user-data: {s}" (get-user-data~ target))
              ,@(if (is? target Player)
                    (let ((lookat (get-lookat~ target)))
                      `(,(format "  sight: {a}" (present-vertex (get-sight~ lookat)))
                        ,(format "  up: {a}" (present-vertex (get-up~ lookat)))
                        ,(format "  right: {a}" (present-vertex (get-right~ lookat)))))
                  '())
              "")
          '())
      ,(format "server: {s}" (get-world-server~ (get-process)))
      ,(format "client: {s}" (get-world-client~ (get-process)))
      ""
      ,(format "history: {s}" (history-end~ history))
      ,(format "now: {s}" (get-now~ history))
      ,(format "first: {s}" (get-first~ history))
      ,@(if (and history? paused?)
            (present-history~ history)
          '())
      ""
      ,(format "projection: {s}" projection)
      ,(format "eye: {a}" (present-vertex eye))
      ,(format "eye-lookat: {s}" eye-lookat)
      ,(format "eye-target: {a}" (present-vertex eye-target))
      ,(format "camera-distance: {s}" camera-distance)
      ,(format "zoom-factor: {s}" zoom-factor)
      ,(format "first-distance: {s}" first-distance)
      ,(format "first-override: {s}" first-override)
      ,(format "first-occlusion?: {s}" first-occlusion?)
      ,(format "first-camera: {s}" first-camera)
      ,(format "desired-tilt: {s}" desired-tilt)
      ""
      ,(format "ambient-color: {s}" (get-ambient-color~ zone))
      ,(format "material-specular: {s}" (get-material-specular~ zone))
      ,(format "material-shininess: {s}" (get-material-shininess~ zone))
      ,(format "lights: {s}" (count-lights~ zone))
      ""
      ,@(if information
            `(,@information
              "")
          '())
      ,@(if me
            `(,(format "player: {a}" (present-object me))
              ,(format "  x: {r precision: 1}" (get-x~ me))
              ,(format "  y: {r precision: 1}" (get-y~ me))
              ,(format "  z: {r precision: 1}" (get-z~ me))
              ,(format "  left: {r precision: 1}" (get-left~ me))
              ,(format "  bottom: {r precision: 1}" (get-bottom~ me))
              ,(format "  back: {r precision: 1}" (get-back~ me))
              ,(format "  right: {r precision: 1}" (get-right~ me))
              ,(format "  top: {r precision: 1}" (get-top~ me))
              ,(format "  front: {r precision: 1}" (get-front~ me))
              ,(format "  width: {s}" (get-width~ me))
              ,(format "  height: {s}" (get-height~ me))
              ,(format "  depth: {s}" (get-depth~ me))
              ,(format "  texture: {s}" (get-texture~ me))
              ,(format "  velocity: {s}" (present-vertex (get-velocity~ me)))
              ,(format "  user-data: {s}" (get-user-data~ me))
              ,(format "  lookat: {s}" (get-lookat~ me))
              ,(format "  jumping?: {a}" (present-boolean (get-jumping?~ me)))
              ,(format "  facing: {s}" (get-facing~ me))
              ,(format "  state: {s}" (get-state~ me))
              "")
          '())
      ,(format "editor-mode: {a}" (capitalize (->string editor-mode)))
      ,(format "animate?: {a}" (present-boolean animate?))
      ,(format "light?: {a}" (present-boolean light?))
      ,(format "music?: {a}" (present-boolean music?))
      ,(format "3d?: {a}" (present-boolean 3d?))
      ,(format "fly?: {a}" (present-boolean fly?))
      ,(format "first-person?: {a}" (present-boolean first-person?))
      ,(format "textures?: {a}" (present-boolean (get-textures?~ zone)))
      ,(format "paused?: {a}" (present-boolean paused?))
      ""
      ,(format "gc-count: {a}" (gc-count))))
  
  
  (method (reset-information)
    (set! information #f))
  
  
  (method (set-information info)
    (set! information (map ->string info)))
  
  
  (method (add-information info)
    (set! information (append (or information '()) (list (->string info)))))))
