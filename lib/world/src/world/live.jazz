;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.live jazz


(import (jazz.action)
        (jazz.application)
        (jazz.component)
        (jazz.debuggee)
        (jazz.debugger)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.media)
        (jazz.opengl)
        (jazz.opengl.glew)
        (jazz.platform)
        (jazz.runtime)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.tracker)
        (jazz.ui.dialog)
        (jazz.view)
        (jazz.window)
        (profiler)
        (world)
        (world.actor)
        (world.ambience)
        (world.assets)
        (world.atlas)
        (world.audio)
        (world.autoload)
        (world.block)
        (world.buffers)
        (world.camera)
        (world.change)
        (world.collision)
        (world.commands)
        (world.configure)
        (world.creature)
        (world.debug)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.entities)
        (world.entity)
        (world.external.milkshape)
        (world.external.obj)
        (world.fog)
        (world.folio)
        (world.foreign)
        (world.gadget)
        (world.generate)
        (world.generation)
        (world.generation.block)
        (world.generation.building)
        (world.generation.models)
        (world.generation.rendering)
        (world.geometry)
        (world.gravity)
        (world.grid)
        (world.history)
        (world.homogeneous)
        (world.interface)
        (world.interface.actions)
        (world.interface.animations)
        (world.interface.assets)
        (world.interface.avatars)
        (world.interface.bindings)
        (world.interface.blocks)
        (world.interface.character)
        (world.interface.chat)
        (world.interface.chronology)
        (world.interface.color)
        (world.interface.combat)
        (world.interface.command)
        (world.interface.compass)
        (world.interface.crafting)
        (world.interface.dialogs)
        (world.interface.documents)
        (world.interface.frame)
        (world.interface.gadgets)
        (world.interface.info)
        (world.interface.inventory)
        (world.interface.main)
        (world.interface.map)
        (world.interface.menu)
        (world.interface.meshes)
        (world.interface.models)
        (world.interface.options)
        (world.interface.pane)
        (world.interface.panel)
        (world.interface.player)
        (world.interface.profiler)
        (world.interface.propagation)
        (world.interface.script)
        (world.interface.scripts)
        (world.interface.shaders)
        (world.interface.showcase)
        (world.interface.skyboxes)
        (world.interface.target)
        (world.interface.templates)
        (world.interface.textures)
        (world.interface.tiers)
        (world.interface.tiles)
        (world.interface.who)
        (world.interface.worlds)
        (world.interface.zones)
        (world.io)
        (world.keys)
        (world.light)
        (world.mark)
        (world.material)
        (world.missile)
        (world.model)
        (world.motion)
        (world.music)
        (world.parameters)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.profiling)
        (world.programs)
        (world.protocol)
        (world.quad)
        (world.render)
        (world.renderer)
        (world.renderers)
        (world.script.entity)
        (world.scripter)
        (world.scripts)
        (world.sector)
        (world.settings)
        (world.shaders)
        (world.skybox)
        (world.spawn)
        (world.sphere)
        (world.support)
        (world.syntax (phase syntax))
        (world.target)
        (world.task)
        (world.texture)
        (world.travel)
        (world.triangle)
        (world.w3d)
        (world.widget)
        (world.window)
        (world.work)
        (world.zone))


;;;
;;;; World
;;;


(definition (make-eye)
  (let ((camera (make-camera)))
    (setup-area-cube~ camera 7)
    camera))


(class World extends Component
  
  
  (property title              <string+>           initialize #f              accessors generate)
  (property ambient-gravity    <vertex>            initialize default-gravity accessors generate)
  (property jump-impulsion     <fl>                initialize default-jump    accessors generate)
  (property default-image      <object>            initialize "stone"         accessors generate)
  (property properties         <object>            initialize '()             accessors generate)
  
  
  (slot window                 <OpenGL-Window>     initialize #f              accessors generate)
  (slot width                  <fl>                initialize #f              accessors generate)
  (slot height                 <fl>                initialize #f              accessors generate)
  (slot eye                    <Camera>            initialize (make-eye)      getter generate)
  (slot eye-motion             <Motion>            initialize #f              getter generate)
  (slot eye-hook               <object>            initialize #f              accessors generate)
  (slot world-up               <vertex>            initialize (make-vertex)   getter generate)
  (slot lighting?              <bool>              initialize #t              getter generate)
  (slot what                   <object>            initialize #f              getter generate)
  (slot selection              <object>            initialize '()             getter generate)
  (slot target-polygon         <object>            initialize #f              getter generate)
  (slot target-vertex          <object>            initialize #f              getter generate)
  (slot target-mode            <object>            initialize 'select         getter generate)
  (slot target-widget          <Widget+>           initialize #f              getter generate)
  (slot last-point             <object>            initialize #f              getter generate)
  (slot last-time              <object>            initialize #f              getter generate)
  (slot showcase               <World-Showcase+>   initialize #f              getter generate)
  (slot showcases              <object>            initialize #f              getter generate)
  (slot showcase-down?         <bool>              initialize #f              getter generate)
  (slot polygon-mode           <fx>                initialize GL_FILL         getter generate)
  (slot window-cursor          <object>            initialize :arrow          getter generate)
  (slot earth?                 <bool>              initialize #t              getter generate)
  (slot interface?             <bool>              initialize #t              accessors generate)
  (slot interface-bars?        <bool>              initialize #t              accessors generate)
  (slot explore-interface?     <bool>              initialize #f              accessors generate)
  
  
  (slot version                <object>            initialize #f              getter generate)
  (slot orientation?           <bool>              initialize #f              getter generate)
  (slot aim?                   <bool>              initialize #f              getter generate)
  (slot free-aim?              <bool>              initialize #f              getter generate)
  (slot viewing?               <bool>              initialize #f              getter generate)
  (slot moving?                <bool>              initialize #f              getter generate)
  (slot moved?                 <bool>              initialize #f              getter generate)
  (slot first-camera           <object>            initialize #f              getter generate)
  (slot mounts-folio           <Folio>             initialize #f              getter generate)
  (slot flyers-folio           <Folio>             initialize #f              getter generate)
  (slot x-rays?                <bool>              initialize #f              getter generate)
  (slot x-rays-category        <symbol+>           initialize #f              getter generate)
  (slot draw-blocks?           <bool>              initialize #t              getter generate)
  (slot draw-entities?         <bool>              initialize #t              getter generate)
  (slot draw-gadgets?          <bool>              initialize #f              getter generate)
  (slot draw-marks?            <bool>              initialize #t              getter generate)
  (slot draw-normals?          <bool>              initialize #f              getter generate)
  (slot draw-atlas?            <bool>              initialize #f              accessors generate)
  (slot view-distance          <fx>                initialize 7               getter generate)
  (slot view-radius            <fl>                initialize #f              accessors generate)
  (slot max-entity-radius      <fl>                initialize 60.             accessors generate)
  (slot render-thread          <object>            initialize #f              accessors generate)
  (slot render-trim?           <bool>              initialize #f              accessors generate)
  (slot dynamic-lights         <fx>                initialize 8               getter generate)
  (slot post-processing?       <bool>              initialize #t              getter generate)
  (slot player-thread          <object>            initialize #f              accessors generate)
  (slot ongoing-key            <object>            initialize #f              accessors generate)
  (slot axes?                  <bool>              initialize #f              accessors generate)
  (slot axes-graduation?       <bool>              initialize #f              accessors generate)
  (slot tick-slice?            <bool>              initialize #t              getter generate)
  (slot down?                  <bool>              initialize #f              getter generate)
  (slot down-point             <object>            initialize #f              getter generate)
  (slot double-click?          <bool>              initialize #f              getter generate)
  (slot drag-tolerance         <object>            initialize 5               getter generate)
  (slot tick-procedures        <object>            initialize '()             getter generate)
  (slot tick-no                <object>            initialize 0               getter generate)
  (slot commands               <object>            initialize #f              getter generate)
  (slot base-assets            <object>            initialize '()             getter generate)
  (slot user-assets            <object>            initialize '()             getter generate)
  (slot world-assets           <object>            initialize '()             getter generate)
  (slot zone-assets            <object>            initialize '()             accessors generate)
  (slot textures               <object>            initialize #f              getter generate)
  (slot models                 <object>            initialize #f              getter generate)
  (slot gc-sound?              <bool>              initialize #f              getter generate)
  (slot gc-trace?              <bool>              initialize #f              getter generate)
  (slot history?               <bool>              initialize #t              getter generate)
  (slot history-trail          <fx>                initialize 250             getter generate)
  (slot history-camera         <Camera>            initialize (make-camera)   getter generate)
  (slot history-camera?        <bool>              initialize #f              getter generate)
  (slot history-motion         <Motion>            initialize #f              getter generate)
  (slot message                <object>            initialize #f              getter generate)
  (slot message-time           <object>            initialize #f              getter generate)
  (slot message-color          <object>            initialize #f              getter generate)
  (slot message-player         <object>            initialize #f              getter generate)
  (slot status                 <object>            initialize #f              getter generate)
  (slot status-time            <object>            initialize #f              getter generate)
  (slot status-color           <object>            initialize #f              getter generate)
  (slot status-player          <object>            initialize #f              getter generate)
  (slot compass-player         <object>            initialize #f              getter generate)
  (slot compass-visible?       <bool>              initialize #t              accessors generate)
  (slot map-player             <object>            initialize #f              getter generate)
  (slot map-visible?           <bool>              initialize #f              getter generate)
  (slot chronology-player      <object>            initialize #f              getter generate)
  (slot chronology-visible?    <bool>              initialize #f              getter generate)
  (slot interface-refresh?     <bool>              initialize #f              getter generate)
  (slot interface-refresh-rate <fl>                initialize #f              getter generate)
  (slot interface-last-time    <fl>                initialize #f              getter generate)
  (slot interface-target?      <bool>              initialize #f              getter generate)
  (slot show-belt?             <bool>              initialize #f              accessors generate)
  (slot last-script            <object>            initialize #f              getter generate)
  (slot last-whisperer         <object>            initialize #f              accessors generate)
  (slot escape-hook            <object>            initialize #f              accessors generate)
  (slot enter-hook             <object>            initialize #f              accessors generate)
  
  ;; Shader programs
  (slot mesh-programs          <object>            initialize #f              accessors generate)
  (slot block-atlas            <Atlas>             initialize #f              accessors generate)
  (slot block-texture          <Image-Texture>     initialize #f              accessors generate)
  (slot block-texture-repeat   <Image-Texture>     initialize #f              accessors generate)
  (slot block-opaque           <object>            initialize #f              accessors generate)
  (slot block-transparent      <object>            initialize #f              accessors generate)
  (slot block-coverage         <object>            initialize #f              accessors generate)
  (slot block-water            <object>            initialize #f              accessors generate)
  (slot block-wet              <object>            initialize #f              accessors generate)
  (slot block-multitexture     <object>            initialize #f              accessors generate)
  (slot block-materials        <object>            initialize #f              accessors generate)
  (slot block-program          <Mesh-Program>      initialize #f              accessors generate)
  (slot texture-program        <Texture-Program>   initialize #f              accessors generate)
  (slot player-program         <Player-Program>    initialize #f              accessors generate)
  (slot material-opaque        <object>            initialize #f              accessors generate)
  (slot material-transparent   <object>            initialize #f              accessors generate)
  
  ;; Render targets
  (slot render-target          <Render-Target+>    initialize #f              accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition max-dynamic-lights
    8)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-current-world self)
    (set! view-distance (world-setting 'world.view-distance 9))
    (set! view-radius 200.)
    (set! history-motion (make-free-motion self history-camera))
    (set-callback~ history-camera camera-callback)
    (set! eye-motion (make-free-motion self eye))
    (set-callback~ eye camera-callback)
    (set-current-camera eye)
    (set-current-motion eye-motion)
    (set-current-ambience (new World-Ambience))
    (set-current-music (new World-Music))
    (set! dynamic-lights (min max-dynamic-lights (world-setting 'world.dynamic-lights 4)))
    (set! earth? (world-setting 'world.earth? #f))
    (set-camera-smoothing? (world-setting 'world.camera-smoothing? #t))
    (set-independent-camera? (world-setting 'world.independent-camera? (not young-child?)))
    (set-autotrack-camera? (world-setting 'world.autotrack-camera? #t))
    (set-track-sensitivity (world-setting 'world.track-sensitivity 200.))
    (set! post-processing? (and (window?) (world-setting 'world.post-processing? #t)))
    (set! interface? (world-setting 'world.start-interface? #t))
    (set! interface-target? (world-setting 'world.interface-target? #f))
    (set-interface-script? (world-setting 'world.interface-script? #f))
    (set! show-belt? (world-setting 'world.show-belt? #t))
    (set! gc-sound? (world-setting 'world.gc-sound? #f))
    (set! gc-trace? (world-setting 'world.gc-trace? #f))
    (set! history? (world-setting 'world.history? #t))
    (set! history-trail (world-setting 'world.history-trail 250))
    (set! history-camera? (world-setting 'world.history-camera? #f))
    (set! evaluate-future? (world-setting 'world.evaluate-future? #f))
    (set! free-aim? (world-setting 'world.free-aim? #f))
    (set-fog? #f @until-for-is-really-nice (world-setting 'world.fog? #t))
    (set-fog-density (world-setting 'world.fog-density default-fog-density))
    (set-fog-color (world-setting 'world.fog-color default-fog-color))
    ;; aec quick hack
    (set-animations? (world-setting 'world.animations? (or (arc-en-ciel?) (>= (glGetInteger* GL_MAX_VERTEX_UNIFORM_COMPONENTS) 4096))))
    (set! tick-slice? (and (not debug-user?) (not (world-setting 'world.inhibit-slicing? #f))))
    (prepare-sounds)
    ;; not necessary if we are not using message-available?
    ;; (set-ignore-key-repeat? #t)
    (register-keys)
    (when always-profile?
      (advise-sites))
    (setup-info))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (update-world-up ambient-gravity))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
   
   
  (method (setup-threads)
    ;; not 100% sure but i think this has a noticable impact
    (when heartbeat-interval
      (thread-heartbeat-interval-set! heartbeat-interval))
    (thread-base-priority-set! (event-thread) event-priority)
    (thread-base-priority-set! (message-thread) message-priority)
    (when quantum-interval
      (thread-quantum-set! (event-thread) quantum-interval)
      (thread-quantum-set! (message-thread) quantum-interval))
    (set-message-period message-period)
    (set-message-sleep message-sleep))
  
  
  (method (setup-opengl)
    (setup-size)
    (when (window?)
      (glClear GL_COLOR_BUFFER_BIT)
      (glClear GL_DEPTH_BUFFER_BIT)
      (glEnable GL_DEPTH_TEST)
      (glDisable GL_BLEND)
      (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
      (glFrontFace GL_CW)
      (glPolygonMode GL_FRONT_AND_BACK GL_FILL)
      (glEnable GL_LINE_SMOOTH))
    (initialize-eye)
    (prepare-assets)
    (prepare-models)
    (when (window?)
      (prepare-showcases)
      (prepare-shaders)
      (prepare-renderes)
      (prepare-players)
      (prepare-skyboxes)
      (initialize-render))
    (reset-commands)
    (gl-check-error))
  
  
  (method (setup-size)
    (size-change (get-size~ window)))
  
  
  (method (size-change size)
    (set! width (cast <fl> (get-width~ size)))
    (set! height (cast <fl> (get-height~ size)))
    (size-change~ eye size)
    (size-change~ history-camera size)
    (size-change~ (cache-inventory-camera) size)
    (when showcases
      (iterate-table showcases
        (lambda (name showcase)
          (size-change~ showcase size))))
    (let ((interface (current-interface+)))
      (when interface
        (set-size~ interface size)
        (interface-layout)))
    (reset-inventory-blocks))
  
  
  (method (initialize-render)
    (set! render-target (new Render-Target (fxround width) (fxround height))))
  
  
  (method (update-world-up gravity)
    (vertex-copy! world-up (gravity-up& gravity)))
  
  
  (method (reset-commands)
    (when (or (not commands) (get-modified?~ commands))
      (set! commands (new Commands))))
  
  
  (method (change-view-distance distance)
    (let ((old-distance view-distance))
      (set! view-distance distance)
      (update-view-distance~ (current-zone) old-distance distance)))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (method (prepare-assets)
    (set! base-assets (gather-assets 'base (new Directory (cons (world-alias) '("lib" "world.client" "assets")))))
    (set! user-assets (gather-assets 'user {Directory Settings "assets"}))
    (set! world-assets (gather-assets 'world (let ((dir (get-world-directory))) (and dir (new-directory~ dir "assets"))))))
  
  
  (method (iterate-assets proc (include-zone?: include-zone? #t))
    (when include-zone?
      (for-each proc zone-assets))
    (for-each proc world-assets)
    (let ((tier (current-tier+)))
      (when tier
        (for-each proc (get-assets~ tier))))
    (for-each proc user-assets)
    (for-each proc base-assets))
  
  
  (method (partition-assets (include-zone?: include-zone? #t))
    (list
      (cons 'zone (if include-zone?
                      zone-assets
                    '()))
      (cons 'world world-assets)
      (cons 'tier (let ((tier (current-tier+)))
                    (if tier
                        (get-assets~ tier)
                      '())))
      (cons 'user user-assets)
      (cons 'base base-assets)))
  
  
  (method (prepare-players)
    (set! message-player (make-world-player 'message World-Player 800 100))
    (set! status-player (make-world-player 'status World-Player 800 35))
    (set! compass-player (make-world-player 'compass World-Player 170 170))
    (set! map-player (make-world-player 'map World-Player 1024 512))
    (set! chronology-player (make-world-player 'chronology World-Player 600 105)))
  
  
  (method (resize-players)
    (make-orthographic-matrix! (get-projection-matrix~ message-player) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix~ status-player) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix~ compass-player) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix~ map-player) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix~ chronology-player) 0. width 0. height 0. 10.))
  
  
  (method (prepare-block atlas texture texture-repeat)
    (set! block-atlas atlas)
    (set! block-texture texture)
    (set! block-texture-repeat texture-repeat))
  
  
  (method (prepare-materials opaque-material transparent-material coverage-material water-material wet-material multitexture-material)
    (set! block-opaque opaque-material)
    (set! block-transparent transparent-material)
    (set! block-coverage coverage-material)
    (set! block-water water-material)
    (set! block-wet wet-material)
    (set! block-multitexture multitexture-material)
    (set! block-materials (make-table test: eq?))
    (set! material-opaque (get-entity-material~ (opaque-rendering)))
    (set! material-transparent (get-entity-material~ (transparent-rendering))))

  
  ;;;
  ;;;; Modules
  ;;;
  
  
  (slot installed-repositories initialize (make-table test: equal?) getter generate)
  
  
  (method (prepare-modules instance)
    (let ((queue (new-queue)))
      (define (process-assets assets)
        (let ((repository-dir (new-directory~ (get-directory~ assets) "module")))
          (when (exists?~ repository-dir)
            (enqueue queue (parse~ repository-dir)))))
      
      (define (template-modules)
        (and instance (exists?~ instance)
          (let ((instance (instantiate~ (read-form instance))))
            (let ((template-dir (get-template~ instance)))
              (new-directory~ template-dir '("assets" "module"))))))
      
      (if (not (programmer?))
          (iterate-assets process-assets)
        ;; enable direct edition of template code
        (iterate-assets process-assets include-zone?: #f)
        (let ((module-dir (template-modules)))
          (if (and module-dir (exists?~ module-dir))
              (enqueue queue (parse~ module-dir))
            (for-each process-assets zone-assets))))
      (let ((new (queue-list queue)))
        (update-repositories installed-repositories new)
        (set-world-repositories new))))
  
  
  (method (collect-modules)
    (let ((modules '()))
      (for-each (lambda (path)
                  (let ((repository (table-ref installed-repositories path)))
                    (iterate-packages repository
                      (lambda (package)
                        (let ((dir (new Directory (tokenise-filename (package-directory package)))))
                          (iterate-directory~ dir
                            (lambda (path kind)
                              (let ((file (new-file~ dir path)))
                                (when (extension=? (get-extension~ file) "jazz")
                                  (unless (member? (get-name~ file) '(".DS_Store") test: filename=?)
                                    (set! modules (cons (cons dir path) modules))))))
                            full?: #f
                            files?: #t
                            directories?: #f
                            recursive?: #t))))))
                (get-world-repositories))
      modules))

  
  ;;;
  ;;;; Materials
  ;;;
  
  
  (method (find-block-material name)
    (or (table-ref block-materials name #f)
        (let ((mat (case name
                     ((opaque) block-opaque)
                     ((transparent) block-transparent)
                     (else (new Material atlas: block-atlas texture: block-texture-repeat renderer: (require-renderer name))))))
          (table-set! block-materials name mat)
          mat)))
  
  
  ;;;
  ;;;; Models
  ;;;
  
  
  (method (prepare-models)
    (set! models (make-table test: equal?)))
  
  
  ;;;
  ;;;; Showcases
  ;;;
  
  
  (method (prepare-showcases)
    (set! showcases (make-table test: eq?)))
  
  
  ;;;
  ;;;; Shaders
  ;;;
  
  
  (method (prepare-shaders)
    ;; shaders
    (build-default-shaders)
    (build-interface-shaders)
    (build-texture-shaders)
    (build-skybox-shaders)
    (build-color-shaders)
    (build-terrain-shaders)
    (build-phong-shaders)
    (build-occlusion-shaders)
    (build-frame-shaders)
    (build-transformation-shaders)

    ;; mesh
    (set! mesh-programs (make-table test: eq?))
    (table-set! mesh-programs 'color                (new Mesh-Color-Program))
    (table-set! mesh-programs 'terrain              (new Mesh-Terrain-Program))
    (table-set! mesh-programs 'phong                (new Mesh-Phong-Program))
    (table-set! mesh-programs 'occlusion            (new Mesh-Occlusion-Program))
    (table-set! mesh-programs 'wireframe            (new Mesh-Wireframe-Program))
    (table-set! mesh-programs 'squareframe          (new Mesh-Squareframe-Program))
    (table-set! mesh-programs 'playerframe          (new Mesh-Playerframe-Program))
    (table-set! mesh-programs 'floorframe           (new Mesh-Floorframe-Program))
    (table-set! mesh-programs 'radial-blur          (new Mesh-Radial-Blur-Program))
    (table-set! mesh-programs 'motion-blur          (new Mesh-Motion-Blur-Program))
    (table-set! mesh-programs 'water-terrain        (new Mesh-Water-Terrain-Program))
    (table-set! mesh-programs 'water                (new Mesh-Water-Program))
    (table-set! mesh-programs 'wet-terrain          (new Mesh-Wet-Terrain-Program))
    (table-set! mesh-programs 'julia                (new Mesh-Julia-Program))
    (table-set! mesh-programs 'sierpinski           (new Mesh-Sierpinski-Program))
    (table-set! mesh-programs 'multitexture-terrain (new Mesh-Multitexture-Terrain-Program))
    (table-set! mesh-programs 'multitexture         (new Mesh-Multitexture-Program))
    (table-set! mesh-programs 'kaleidoscope         (new Mesh-Kaleidoscope-Program))
    (table-set! mesh-programs 'tunnel               (new Mesh-Tunnel-Program))
    (table-set! mesh-programs 'square-tunnel        (new Mesh-Square-Tunnel-Program))
    (table-set! mesh-programs 'fly                  (new Mesh-Fly-Program))
    (table-set! mesh-programs 'pulse                (new Mesh-Pulse-Program))

    ;; block
    (set! block-program (find-mesh-program 'terrain))
    
    ;; texture
    (set! texture-program (new Texture-Program))
    
    ;; player
    (set! player-program (new Player-Program))
    
    (gl-check-error))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))


  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (when (window?)
      (free-resources~ render-target)
      (detach-shaders~ block-program)
      (glDeleteTextures* (get-id~ (get-texture~ message-player)))
      (glDeleteTextures* (get-id~ (get-texture~ status-player)))
      (glDeleteTextures* (get-id~ (get-texture~ compass-player)))
      (glDeleteTextures* (get-id~ (get-texture~ map-player)))
      (glDeleteTextures* (get-id~ (get-texture~ chronology-player)))
      (close-music~ (current-music))))
  
  
  (method public (toggle-gc-sound)
    (set! gc-sound? (not gc-sound?))
    (display-on/off "GC sound" gc-sound?))
  
  
  (method public (garbage-collect)
    (let ((window (current-world-window)))
      (display-message "Garbage collecting" color: {Color Red})
      (render-scene~ window)
      (gc)
      (let ((timer (new Timer)))
        (gc)
        (display-message (format "Garbage collected ({a}ms)" (real-duration-in-milliseconds~ timer)) color: {Color Green}))
      (render-scene~ window)))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method protected virtual (initialize-world)
    (set! version world-version)
    (set! first-camera 'free)
    (set! grid? (world-setting 'world.grid? #f))
    (set! axes? (world-setting 'world.axes? #f))
    (set! axes-graduation? (world-setting 'world.axes-graduation? #f))
    (set! lighting? #t)
    (setup-gc)
    (when (window?)
      (setup-interface)))
  
  
  (method (setup-interface)
    (let ((interface (current-interface+)))
      (when interface
        (close~ interface)))
    (set-current-interface (make-world-player 'interface World-Interface 10 10))
    (let ((interface (current-interface)))
      (make-orthographic-matrix! (get-projection-matrix~ interface) 0. 10. 0. 10. 0. 10.)
      (make-identity-matrix! (get-view-matrix~ interface))
      (set! interface-refresh-rate (world-setting 'world.interface-refresh-rate 1.))
      (set! interface-last-time -inf.0)
      (new Info-Pane parent: interface name: 'info visible?: #f layouter: info-pane-layouter)
      (new Profiler-Pane parent: interface name: 'profiler visible?: #f layouter: profiler-pane-layouter)
      (new Chronology-Pane parent: interface name: 'chronology visible?: #f layouter: chronology-pane-layouter)
      (new Color-Pane parent: interface name: 'color visible?: #f layouter: color-pane-layouter)
      (new Target-Pane parent: interface name: 'target visible?: #f layouter: target-pane-layouter)
      (new Script-Pane parent: interface name: 'script visible?: #f layouter: script-pane-layouter)
      (new Compass-Pane parent: interface name: 'compass visible?: #f layouter: compass-pane-layouter)
      (new Map-Pane parent: interface name: 'map visible?: #f layouter: map-pane-layouter)
      (new Combat-Pane parent: interface name: 'combat visible?: #f layouter: combat-pane-layouter)
      (new Character-Pane parent: interface name: 'character visible?: #f layouter: character-pane-layouter)
      (new Bag-Pane parent: interface name: 'bag visible?: #f layouter: bag-pane-layouter)
      (new Belt-Pane parent: interface name: 'belt visible?: #f layouter: belt-pane-layouter)
      (new Chest-Pane parent: interface name: 'chest visible?: #f layouter: chest-pane-layouter)
      (new Crafting-Pane parent: interface name: 'crafting visible?: #f layouter: crafting-pane-layouter)
      (new Chat-Pane parent: interface name: 'chat visible?: #f layouter: chat-pane-layouter)
      (new Command-Bar parent: interface name: 'command visible?: #f layouter: command-bar-layouter)
      (setup-application-interface~ (get-application))
      (set-root~ window interface offscreen?: #f)
      (interface-layout)))
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method (zone-update)
    (set! mounts-folio (new Folio 'wheels '(wheels hummer)))
    (set! flyers-folio (new Folio 'saucer '(saucer rocket)))
    (let ((zone (current-zone))
          (me (current-me+)))
      (when me
        (let ((camera (player-camera~ me)))
          ;; eye
          (camera-copy! eye camera)
          ;; player
          ;; quick hack for now
          (unless (< (vertex-y (get-position~ me)) 0.)
            (verify-water~ me))
          ;; fly (needs a bit more work for it to reload exactly in the same state)
          (when (get-fly?~ me)
            (activate-fly force?: #t))
          ;; eye
          (let ((start-mode (or (get-start-mode~ zone) 'first-person)))
            (if (neq? start-mode 'first-person)
                (free-motion feedback?: #f)
              (person-motion eye-center?: #f feedback?: #f)
              (let ((distance (or (get-start-distance~ zone) 3.5)))
                (setup-motion~ (current-motion) distance))))))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (tick-task task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          (let ((time (current-seconds))
                (duration 0.))
            (let ((elapse (- time previous))
                  (max-elapse 10.))
              ;; ignore ridiculous elapses like
              ;; coming back from computer sleep
              (unless (> elapse max-elapse)
                (unless (stopping?~ task)
                  ;; take over player task when no me
                  (when (not (current-me+))
                    (process-mouse-run)
                    (unless (get-focus)
                      (process-keys)))
                  (increase! duration (tick-world time elapse))))
              (task-sleep task tick-period duration exit)
              (iter time)))))))
  
  
  (method (tick-world time elapse)
    (let ((duration 0.))
      (site (tick on?: #t)
        (let ((zone (current-zone))
              (history (current-history)))
          (site (tick-scene on?: #f parent: tick)
            (increase! duration (tick-scene~ zone elapse))
            (when showcase
              (increase! duration (tick-scene~ showcase elapse))))
          (site (tick-procedures on?: #f parent: tick)
            (when (not-null? tick-procedures)
              (for-each (lambda (proc)
                          (with-task-mutex
                            (lambda ()
                              (let ((start (current-seconds)))
                                (proc elapse)
                                (increase! duration (- (current-seconds) start))))))
                        tick-procedures)))))
      duration))
  
  
  (method (register-tick proc)
    (set! tick-procedures (cons proc tick-procedures)))
  
  
  (method (unregister-tick proc)
    (set! tick-procedures (remove! proc tick-procedures)))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (boost-player)
    (when (and player-thread (not player-boost?) (neq? (current-thread) player-thread))
      (set-player-boost? #t)
      (thread-base-priority-set! player-thread priority-boost)))
  
  
  (method (unboost-player)
    (set-player-boost? #f)
    (thread-base-priority-set! player-thread player-priority))
  
  
  (method (player-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (set! player-thread (current-thread))
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds))
                  (duration 0.))
              (let ((elapse (- time previous))
                    (max-elapse 10.))
                ;; ignore ridiculous elapses like
                ;; coming back from computer sleep
                (unless (> elapse max-elapse)
                  (with-task-mutex
                    (lambda ()
                      (unless (stopping?~ task)
                        (let ((start (current-seconds)))
                          (site (player on?: #t)
                            (process-mouse-run)
                            (unless (get-focus)
                              (process-keys))
                            (unless (get-paused?~ history)
                              (let ((me (current-me)))
                                (tick-sliced me commands time elapse)
                                (reset-commands)
                                (animate~ me elapse)))
                            (update-transformation-time elapse)
                            (let ((me (current-me))
                                  (motion (current-motion)))
                              (restore-desired-distance~ motion elapse)
                              (process-roll~ motion me)))
                          (increase! duration (- (current-seconds) start))))))))
              (unboost-player)
              (boost-render)
              (task-sleep task player-period duration exit)
              (iter time)))))))
  
  
  (method (tick-sliced actor commands time elapse)
    (declare (proper-tail-calls))
    (let ((slice (tick-slice~ actor)))
      (if (or (not slice) (not tick-slice?) (<= elapse slice))
          (tick~ actor commands time elapse)
        (let (iter (from 0.) (to slice))
          (tick~ actor commands (- time (- elapse to)) (- to from))
          (when (and (< to elapse) (get-alive?~ actor))
            (iter to (min elapse (+ to slice))))))))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method (missile-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds))
                  (duration 0.))
              ;; only server ticks missiles
              (unless (client?)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (or (> elapse max-elapse) 
                              (get-paused?~ history))
                    (increase! duration (tick-missiles #f time elapse)))))
              (task-sleep task missile-period duration exit)
              (iter time)))))))
  
  
  (method (tick-missiles commands time elapse)
    (let ((zone (current-zone))
          (history (current-history)))
      (let ((duration 0.))
        (for-each (lambda (actor)
                    (when (is-missile?~ actor)
                      (with-task-mutex
                        (lambda ()
                          (site (missile on?: #t)
                            (unless (get-paused?~ history)
                              (when (get-alive?~ actor)
                                (let ((start (current-seconds)))
                                  (tick~ actor commands time elapse)
                                  (increase! duration (- (current-seconds) start))))))))))
                  (get-actors~ zone))
        duration)))

  
  ;;;
  ;;;; Circularity
  ;;;
  
  
  ;; quick hacks around circular dependencies
  (method (polygon-class)
    Polygon)
  (method (triangle-class)
    Triangle)
  (method (quad-class)
    Quad)
  (method (missile-class)
    Missile)

  
  ;;;
  ;;;; Events
  ;;;
  
  
  ;; Interface
  (method (on-main-menu evt)
    (main-menu))
  
  (method (on-video-options evt)
    (video-options))
  
  (method (on-audio-options evt)
    (audio-options))
  
  (method (on-interface-options evt)
    (interface-options))
  
  (method (on-view-bindings evt)
    (view-bindings))
  
  (method (on-view-news evt)
    (view-news))
  
  (method (on-view-roadmap evt)
    (view-roadmap))
  
  (method (on-view-help evt)
    (view-help))
  
  (method (on-open-about evt)
    (open-about))
  
  (method (on-toggle-interface evt)
    (toggle-interface))
  
  (method (on-toggle-occlusion evt)
    (toggle-occlusion))
  
  (method (on-toggle-wireframe evt)
    (toggle-wireframe))
  
  (method (on-toggle-profiler evt)
    (toggle-profiler))
  
  (method (on-reset-profiling evt)
    (gc)
    (reset-profiling)
    (display-message "Profiling reset"))
  
  (method (on-chronology-pane evt)
    (chronology-pane))
  
  (method (on-open-welcome evt)
    (open-welcome))
  
  (method (on-quit-world evt)
    (quit-process~ (get-application)))
  
  (method (on-resume-world evt)
    (close-current-popup))

  (method (on-select/run-script evt)
    (select/run-script))

  (method (on-run-last-script evt)
    (run-last-script))
  
  (method (on-enter-press evt)
    (enter-press))
  
  (method (on-tab-press evt)
    (tab-press))
  
  
  ;; Graphics
  (method (on-toggle-lighting evt)
    (toggle-lighting))
  
  (method (on-toggle-fog evt)
    (toggle-fog))
  
  (method (on-toggle-draw-gadgets evt)
    (toggle-draw-gadgets))
  
  (method (on-toggle-draw-normals evt)
    (toggle-draw-normals))
  
  (method (on-toggle-x-rays evt)
    (toggle-x-rays))
  
  (method (on-toggle-redstone-x-rays evt)
    (toggle-redstone-x-rays))
  
  (method (on-toggle-draw-blocks evt)
    (toggle-draw-blocks))
  
  (method (on-toggle-draw-models evt)
    (toggle-draw-models))
  
  (method (on-toggle-post-processing evt)
    (toggle-post-processing))
  
  
  ;; Sound
  (method (on-toggle-sound evt)
    (toggle-sound))
  
  
  ;; Server
  (method (on-server-state evt)
    )
  
  (method (on-server-info evt)
    )
  
  
  ;; World
  (method (on-world-open evt)
    (world-open))
  
  (method (on-world-save evt)
    (world-save))
  
  (method (on-world-save-as evt)
    (world-save-as))
  
  (method (on-world-revert evt)
    (world-revert))
  
  (method (on-toggle-user evt)
    (toggle-user))
  
  
  ;; Zone
  (method (on-zone-new evt)
    (zone-new))
  
  (method (on-zone-open evt)
    (zone-open))
  
  (method (on-zone-open-content evt)
    (zone-open-content))
  
  (method (on-zone-reload evt)
    (zone-reload))
  
  (method (on-zone-regenerate evt)
    (zone-regenerate))
  
  
  ;; Game
  (method (on-bullet evt)
    ;; done in process-keys
    )
  
  (method (on-arrow evt)
    ;; done in process-keys
    )
  
  @wait
  (method (on-rapid-fire evt)
    (maybe-rapid-fire))
  
  (method (on-sprint evt)
    ;; done in process-keys
    )
  
  (method (on-blink evt)
    ;; done in process-keys
    )
  
  (method (on-warp evt)
    ;; done in process-keys
    )
  
  (method (on-toggle-run evt)
    (toggle-run))
  
  (method (on-start-dash evt)
    (let ((me (current-controlled)))
      (start-dash~ me)))
  
  (method (on-mind-control evt)
    (mind-control))
  
  (method (on-toggle-aim evt)
    (toggle-aim))
  
  (method (on-toggle-free-aim evt)
    (toggle-free-aim))
  
  (method (on-toggle-mount evt)
    (toggle-mount))
  
  (method (on-toggle-fly evt)
    (toggle-fly))
  
  (method (on-change-vehicle evt)
    (change-vehicle))
  
  (method (on-compass-pane evt)
    (compass-pane))
  
  (method (on-map-pane evt)
    (map-pane))
  
  (method (on-combat-pane evt)
    (combat-pane))
  
  (method (on-character-pane evt)
    (character-pane))
  
  (method (on-bag-pane evt)
    (bag-pane))
  
  (method (on-belt-pane evt)
    (belt-pane))
  
  (method (on-who-pane evt)
    (who-pane))
  
  (method (on-chat-pane evt)
    (chat-pane))
  
  (method (on-command-message evt)
    (command-message))
  
  (method (on-command-slash evt)
    (command-slash))
  
  
  ;; Motion
  (method (on-person-motion evt)
    (person-motion))
  
  (method (on-orbit-motion evt)
    (orbit-motion))
  
  (method (on-free-motion evt)
    (free-motion))
  
  (method (on-toggle-camera-smoothing evt)
    (toggle-camera-smoothing))
  
  (method (on-toggle-camera-lock evt)
    (toggle-camera-lock))
  
  
  (method (on-move-forward evt)
    ;; done in process-keys
    )
  
  (method (on-move-backward evt)
    )
  
  (method (on-rotate-left evt)
    )
  
  (method (on-rotate-right evt)
    )
  
  
  ;; Edition
  (method (on-showcase evt)
    (let ((showcase (get-property~ evt showcase:)))
      (goto-showcase showcase)))
  
  (method (on-import-model evt)
    (import-model))
  
  (method (on-delete-target evt)
    (delete-target))
  
  (method (on-toggle-grid evt)
    (toggle-grid))
  
  (method (on-toggle-grid-plane evt)
    (toggle-grid-plane (get-property~ evt plane:)))
  
  (method (on-decrease-grid evt)
    (decrease-grid))
  
  (method (on-increase-grid evt)
    (increase-grid))
  
  (method (on-reload-textures evt)
    (reload-textures)
    (display-message "Textures reloaded"))
  
  (method (on-change-editor-mode evt)
    (change-editor-mode reversed?: (effective-event-reversed? evt)))
  
  (method (on-select-target-mode evt)
    (select-target-mode))
  
  (method (on-move-target-mode evt)
    (move-target-mode))
  
  (method (on-rotate-target-mode evt)
    (rotate-target-mode))
  
  (method (on-scale-target-mode evt)
    (scale-target-mode))
  
  (method (on-skeleton-target-mode evt)
    (skeleton-target-mode))
  
  
  ;; History
  (method (on-toggle-paused evt)
    (toggle-paused))
  
  (method (on-backward-history evt)
    (backward-history))
  
  (method (on-forward-history evt)
    (forward-history))
  
  (method (on-step-backward evt)
    (step-backward))
  
  (method (on-step-forward evt)
    (step-forward))
  
  (method (on-step-over evt)
    (step-over))
  
  (method (on-reset-history evt)
    (reset-history))
  
  (method (on-toggle-evaluate-future evt)
    (toggle-evaluate-future))
  
  (method (on-toggle-synchronize-cameras evt)
    (toggle-synchronize-cameras))
  
  (method (on-toggle-simulate-protocol evt)
    (toggle-simulate-protocol))
  
  
  ;; Window
  (method (on-toggle-windowed-mode evt)
    (toggle-windowed-mode))
  
  (method (on-tile-server/clients evt)
    (tile-server/clients))
  
  (method (on-restore-server/clients evt)
    (restore-server/clients))
  
  (method (on-live-gaia/world evt)
    (live-gaia/world))
  
  (method (on-design-gaia/world evt)
    (design-gaia/world))
  
  (method (on-restore-gaia/world evt)
    (restore-gaia/world))


  ;; Debug
  (method (on-toggle-axes evt)
    (toggle-axes))
  
  (method (on-toggle-axes-graduation evt)
    (toggle-axes-graduation))
  
  (method (on-toggle-info evt)
    (toggle-info))
  
  (method (on-toggle-target evt)
    (toggle-target))
  
  (method (on-toggle-script evt)
    (toggle-script))
  
  (method (on-view-workspace evt)
    (view-workspace))
  
  (method (on-view-script evt)
    (view-script))
  
  (method (on-view-debugger evt)
    (view-debugger))
  
  (method (on-view-toolbox evt)
    (view-toolbox))
  
  (method (on-run-selected-script evt)
    (run-selected-script))
  
  (method (on-toggle-orientation evt)
    (toggle-orientation))
  
  (method (on-toggle-debug-sections evt)
    (toggle-debug-sections~ (current-zone)))
  
  (method (on-toggle-debug-sectors evt)
    (toggle-debug-sectors~ (current-zone)))
  
  (method (on-toggle-debug-areas evt)
    (toggle-debug-areas~ (current-zone)))
  
  (method (on-toggle-draw-atlas evt)
    (toggle-draw-atlas))
  
  (method (on-toggle-draw-me evt)
    (toggle-draw-me))
  
  (method (on-change-missile-behavior evt)
    (change-missile-behavior reversed?: (effective-event-reversed? evt)))
  
  (method (on-reset-marks evt)
    (reset-all-marks~ (current-zone)))
  
  (method (on-clear-console evt)
    (if (get-controller-debugger)
        (clear-console)
      (display-error "Not connected to a debugger")))
  
  (method (on-clear-terminal evt)
    (clear-terminal))
  
  (method (on-toggle-gc-sound evt)
    (toggle-gc-sound))

  (method (on-garbage-collect evt)
    (garbage-collect))

  (method (on-explore-interface evt)
    (explore-interface))
  
  (method (on-propagation-debugger evt)
    (propagation-debugger))
  
  (method (on-test1 evt)
    (test1))

  (method (on-test2 evt)
    (test2))

  (method (on-test3 evt)
    (test3))

  (method (on-test4 evt)
    (test4))

  (method (on-test5 evt)
    (test5))

  (method (on-test6 evt)
    (test6))

  (method (on-test7 evt)
    (test7))

  (method (on-test8 evt)
    (test8))

  (method (on-test9 evt)
    (test9))

  (method (on-test0 evt)
    (test0))
  
  
  ;; Collision
  (method (on-setup-collisions evt)
    (set! evaluate-future? #f)
    (set! tick-slice? #f)
    (set-move-speed~ history-camera 0.05)
    (set-strafe-speed~ history-camera 0.02)
    (set-rotate-speed~ history-camera 0.02)
    (set-debug-collisions? #t)
    (update-parameter 'debug-collisions)
    (reset-marks~ (current-zone))
    (when (shift-down?)
      (execute-script "world/generate/stairs"))
    (display-message "Collisions setup"))
  
  (method (on-toggle-debug-collisions evt)
    (execute-script "world/collision/debug-collisions"))
  
  (method (on-change-radiuses evt)
    (execute-script "world/collision/change-radiuses"))
  
  (method (on-test-collisions evt)
    (execute-script "world/collision/test"))
  
  
  ;; Utility
  (method (effective-event-reversed? evt)
    (shift-down?))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (setup-history)
    (set-current-history (new History (world-setting 'world.history-size 1000))))
  
  
  (method (backward-history)
    (let ((history (current-history)))
      (when (get-paused?~ history)
        (backward-history~ history #t))))
  
  
  (method (forward-history)
    (let ((history (current-history)))
      (when (get-paused?~ history)
        (forward-history~ history #t))))
  
  
  (method (truncate-history)
    (let ((history (current-history)))
      (truncate-history~ history)))
  
  
  (method (reset-history)
    (let ((history (current-history)))
      (setup~ history)
      (display-message "History reset")))
  
  
  (method (step-backward)
    (let ((history (current-history)))
      (when (get-paused?~ history)
        (step-backward~ history))))
  
  
  (method (step-forward)
    (let ((history (current-history)))
      (when (get-paused?~ history)
        (step-forward~ history))))
  
  
  (method (step-over)
    (let ((history (current-history)))
      (when (get-paused?~ history)
        (step-over~ history))))
  
  
  (method (recalculate-future)
    (let ((history (current-history)))
      (when (get-paused?~ history)
        (recalculate-future~ history))))
  
  
  (method (update-future)
    (let ((history (current-history)))
      (when (get-paused?~ history)
        (recalculate-future))))
  
  
  (method (toggle-evaluate-future)
    (set! evaluate-future? (not evaluate-future?))
    (update-parameter 'evaluate-future)
    (display-on/off "Evaluate future" evaluate-future?))
  
  
  (method (toggle-synchronize-cameras)
    (when (server?)
      (set-synchronize-cameras? (not synchronize-cameras?))
      (display-on/off "Synchronize cameras" synchronize-cameras?)))
  
  
  (method (toggle-simulate-protocol)
    (set-simulate-protocol? (not simulate-protocol?))
    (display-on/off "Simulate protocol" simulate-protocol?)
    (if simulate-protocol?
        (lock-history-tooltip)
      (unlock-history-tooltip))
    (when (server?)
      (for-each (lambda (delegate)
                  (protocol-client~ (get-client~ delegate) simulate-protocol?))
                (get-delegates~ (current-tier)))))
  
  
  (method (lock-history-tooltip)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'slider)))
        (lock-tooltip~ pane {Point 0 0}))))
  
  
  (method (unlock-history-tooltip)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'slider)))
        (unlock-tooltip~ pane))))
  
  
  ;;;
  ;;;; Action
  ;;;
  
  
  (slot commands-hook initialize #f accessors generate)
  (slot action-hook   initialize #f accessors generate)
  
  
  (method (hook-commands commands)
    (if commands-hook
        (commands-hook commands)
      #t))
  
  
  (method (hook-action name arguments)
    (if action-hook
        (action-hook name arguments)
      #t))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method (move-forward)
    (move-forward~ (current-motion)))
  
  
  (method (move-backward)
    (move-backward~ (current-motion)))
  
  
  (method (sprint-forward)
    (sprint-forward~ (current-motion)))
  
  
  (method (sprint-backward)
    (sprint-backward~ (current-motion)))
  
  
  (method (blink-forward)
    (blink-forward~ (current-motion)))
  
  
  (method (blink-backward)
    (blink-backward~ (current-motion)))
  
  
  (method (warp-forward)
    (warp-forward~ (current-motion)))
  
  
  (method (warp-backward)
    (warp-backward~ (current-motion)))
  
  
  (method (move-left)
    (move-left~ (current-motion)))
  
  
  (method (move-right)
    (move-right~ (current-motion)))
  
  
  (method (process-move-up)
    (let ((me (current-me))
          (history (current-history)))
      (if (or (get-paused?~ history) (and (person-motion?) (get-fly?~ me)))
          (move-up)
        (space))))
  
  
  (method (move-up)
    (move-up~ (current-motion)))
  
  
  (method (process-move-down)
    (move-down))
  
  
  (method (move-down)
    (move-down~ (current-motion)))
  
  
  (method (process-rotate-left)
    (if (is-moving?)
        (move-left)
      (rotate-left)))
  
  
  (method (rotate-left)
    (rotate-left~ (current-motion)))
  
  
  (method (process-rotate-right)
    (if (is-moving?)
        (move-right)
      (rotate-right)))
  
  
  (method (rotate-right)
    (rotate-right~ (current-motion)))
  
  
  (method (space)
    (let ((me (current-me+))
          (motion (current-motion)))
      (cond ((person-motion?)
             (space~ me commands))
            ((orbit-motion?)
             (move-up~ motion))
            (else
             (move-up)))))
  
  
  ;;;
  ;;;; Game
  ;;;
  
  
  (method (fire kind)
    (let ((me (current-controlled)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (fire~ me kind)))))
  
  
  (method (maybe-fire kind)
    (let ((me (current-controlled)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (maybe-fire~ me kind)))))
  
  
  (method (maybe-rapid-fire)
    (unless (orbit-motion?)
      (rapid-fire)))
  
  
  (method (rapid-fire)
    (let ((me (current-controlled)))
      (start-rapid-fire~ me)))
  
  
  (method (blink (reversed? #f))
    (if reversed?
        (blink-backward)
      (blink-forward)))
  
  
  (method (warp (reversed? #f))
    (if reversed?
        (warp-backward)
      (warp-forward)))
  
  
  (method (toggle-run)
    (let ((me (current-controlled)))
      (set-motion~ me (if (eq? (get-motion~ me) 'run)
                          'walk
                        'run))))
  
  
  ;;;
  ;;;; Eye
  ;;;
  
  
  (method (set-eye camera)
    (camera-copy! eye camera))
  
  
  (method (initialize-eye)
    (set-move-speed~ eye (world-setting 'world.camera-move-speed .5))
    (set-sprint-speed~ eye (world-setting 'world.camera-sprint-speed 1.5))
    (set-blink-speed~ eye (world-setting 'world.camera-blink-speed 2.))
    (set-warp-speed~ eye (world-setting 'world.camera-warp-speed 4.))
    (set-strafe-speed~ eye (world-setting 'world.camera-strafe-speed .1))
    (set-rotate-speed~ eye (world-setting 'world.camera-rotate-speed .035)))
  
  
  (method (prepare-motion)
    (let ((motion (current-motion)))
      (when (is? motion Target-Motion)
        (remove-eye-occlusion~ motion (lens-center~ (motion-target~ motion))))))
  
  
  (method (hook-eye)
    (if eye-hook
        (eye-hook)
      #t))
  
  
  (method (camera-callback stable?)
    (when (not stable?)
      (when (and render-thread (not render-trim?))
        (boost-player)
        ;; sector priorities depend on the camera so we have to trim
        (set! render-trim? #t))))
  
  
  (method (toggle-orientation)
    (set! orientation? (not orientation?))
    (update-parameter 'orientation))

  
  (method (zoom-in)
    (zoom-in~ (current-motion)))
  
  
  (method (zoom-out)
    (zoom-out~ (current-motion)))
  
  
  (method (toggle-camera-smoothing)
    (change-camera-smoothing (not (get-camera-smoothing?)))
    (display-on/off "Camera smoothing" (get-camera-smoothing?)))
  
  
  (method (change-camera-smoothing value)
    (set-camera-smoothing? value)
    (update-parameter 'camera-smoothing))
  
  
  (method (toggle-camera-lock)
    (let ((camera (next-element '(locked free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'locked)
        (follow-player))
      (update-parameter 'camera-lock)
      (display-message (format "Camera {a}" camera))))
  
  
  (method (current-controlled)
    (let ((me (current-me)))
      (effective-controlled~ me)))
  
  
  (method (current-controlled+)
    (let ((me (current-me+)))
      (and me (effective-controlled~ me))))
  
  
  (method (follow-player)
    (follow-player~ (current-motion)))
  
  
  (method (follow-actor actor)
    (follow-actor~ (current-motion) actor))
  
  
  (method (eye-behind-player)
    (eye-behind-player~ (current-motion)))
  
  
  (method (eye-behind-actor actor)
    (eye-behind-actor~ (current-motion) actor))
  
  
  (method (mark-eye)
    (let ((zone (current-zone))
          (me (current-me)))
      (add-mark~ zone (new Position-Mark (lens-center~ me) color: red-dye))
      (add-mark~ zone (new Position-Mark (get-position~ (current-camera)) color: green-dye))
      (add-mark~ zone (new Position-Mark (get-target~ (current-camera)) color: blue-dye))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (is-moving?)
    (or (and (not (get-autotrack-camera?)) (not (get-cursor-mode?)))
        (and down? (or (and moving? (or (person-motion?) (free-motion?))) (not (get-independent-camera?))))))
  
  
  (method (mind-control)
    (let ((me (current-me)))
      (let ((controlled (get-controlled~ me))
            (target (first-target)))
        (if (and (is? target Actor)
                 (neq? target controlled))
            (control~ me target)
          (when controlled
            (relinquish-control~ me))))))
  
  
  (method (toggle-aim)
    (set! aim? (not aim?))
    (update-parameter 'aim))
  
  
  (method (toggle-free-aim)
    (set! free-aim? (not free-aim?))
    (update-parameter 'free-aim)
    (display-on/off "Free aim" free-aim?))

  
  (method (draw-aim)
    (let ((me (current-me)))
      (let ((lens (lens-center~ me)))
        (let ((x (vertex-x lens))
              (y (vertex-y lens))
              (z (vertex-z lens))
              (size .05)
              (width .0015))
          (render-line (vertex (- x size) y z)
                       (vertex (+ x size) y z)
                       width
                       white-dye)
          (render-line (vertex x (- y size) z)
                       (vertex x (+ y size) z)
                       width
                       white-dye)
          (render-line (vertex x y (- z size))
                       (vertex x y (+ z size))
                       width
                       white-dye)))))
  
  
  ;;;
  ;;;; Resize
  ;;;
  
  
  (method protected virtual (resize-scene)
    (when (window?)
      (let ((width (fxround width))
            (height (fxround height)))
        (resize~ render-target width height))
      (resize-players)))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (boost-render)
    (when (and render-thread (not render-boost?))
      (set-render-boost? #t)
      (thread-base-priority-set! render-thread priority-boost)))
  
  
  (method (unboost-render)
    (set-render-boost? #f)
    (thread-base-priority-set! render-thread render-priority))
  
  
  (method (render-task task <Task>)
    (declare (proper-tail-calls))
    (let ((window (current-world-window))
          (zone (current-zone)))
      (with-task task
        (lambda (exit)
          (set! render-thread (current-thread))
          (let (iter)
            (let ((time (current-seconds&))
                  (camera (current-camera)))
              (with-task-mutex
                (lambda ()
                  (unless (stopping?~ task)
                    (site (render on?: #t)
                      (update-stable~ camera camera-stable-delay)
                      (when render-trim?
                        (let ((trimmed (trim-content 0)))
                          (when (> trimmed 0)
                            (decrease-sectors-generating~ zone trimmed)))
                        (set! render-trim? #f))
                      (render-world)
                      (site (render-sync on?: #t parent: render)
                        (render-sync~ window))))))
              (unboost-render)
              (let ((period (if active? render-period render-period-inactive))
                    (duration (- (current-seconds&) time)))
                (task-sleep task period duration exit)))
            (iter))))))
  
  
  (method protected virtual (render-world)
    (let ((interface (current-interface)))
      (define (update-interface)
        (when interface?
          (let ((now (current-seconds&)))
            (when (> (- now interface-last-time) interface-refresh-rate)
              (let ((info <View> (child~ interface 'info))
                    (target <View> (child~ interface 'target))
                    (profiler <View> (child~ interface 'profiler)))
                (when (or (get-visible?~ info)
                          (get-visible?~ target)
                          (get-visible?~ profiler))
                  (unless interface-refresh?
                    (refresh-interface))))))))
      
      (with-render-mutex
        (lambda ()
          (update-interface)
          (when post-processing?
            (preprocess-render))
          (glClear GL_COLOR_BUFFER_BIT)
          (glClear GL_DEPTH_BUFFER_BIT)
          (draw-world)
          (render-interface)
          (when post-processing?
            (postprocess-render))
          (gl-check-error)))))
  
  
  (method (preprocess-render)
    (allege render-target
      (activate~ render-target)))
  
  
  (method (postprocess-render)
    ;; Copy the color buffer from the render target onto the native color buffer (0)
    (allege render-target
      (blit~ render-target 0)
      (deactivate~ render-target)))
  
  
  (definition selection-dyes
    (list red-dye)
    @wait
    (list red-dye (dye .890 .043 .937 1.) blue-dye))
  
  
  (method (draw-world)
    (site (draw-world on?: #t parent: render)
      (let ((zone (current-zone))
            (me (current-me+))
            (history (current-history)))
        (draw-zone~ zone)
        (when grid?
          (draw-grid))
        (when axes?
          (draw-axes))
        (when (and aim? free-aim?)
          (draw-aim))
        (when (get-paused?~ history)
          (site (draw-history on?: #f parent: draw-world)
            (draw-history)))
        (let ((skybox (get-skybox~ zone)))
          (when skybox
            (draw-skybox~ skybox)))
        (site (draw-renderers on?: #t parent: draw-world)
          (render-opaque)
          (render-transparent)
          (render-orb))
        ;; draw player last
        (when (and me (get-draw-me?~ zone))
          (reset-renderers)
          ;; aec quicky
          (let ((renderer (and (< (dye-alpha (get-overlay~ me)) 1.) (get-culled-transparent-renderer))))
            (register-entity me #f renderer))
          (render-opaque)
          (render-transparent)
          (render-orb))
        (when (and target-widget (not-null? selection) (target-moveable?~ (cast <Element> (car selection))))
          (draw-widget~ target-widget))
        ;; useful for debugging
        ;; (draw-bounds~ me red-dye)
        ;; (draw-collision-bounds~ me blue-dye)
        (let (iter (scan selection) (dyes selection-dyes))
          (when (not-null? scan)
            (let ((elem <Element> (car scan)))
              (draw-target~ elem (car dyes))
              (when draw-normals?
                (for-each (lambda (poly)
                            (draw-plane poly red-dye torus-radius: .015))
                          (element-polygons~ elem)))
              (iter (cdr scan) (if (null? (cdr dyes)) dyes (cdr dyes))))))
        (when (and target-polygon (null? selection))
          (draw-polygon target-polygon red-dye)
          (when target-vertex
            (draw-polygon-vertex target-polygon target-vertex purple-dye))
          (when draw-normals?
            (draw-plane target-polygon red-dye torus-radius: .015)))
        (when (get-debug-areas?~ zone)
          (draw-debug-areas~ zone))
        (when (get-debug-sectors?~ zone)
          (draw-debug-sectors~ zone))
        (when (get-debug-sections?~ zone)
          (draw-debug-sections~ zone))
        (when orientation?
          (draw-orientation~ (current-camera)))
        (when (and showcase interface?)
          (draw-showcase~ showcase))
        (gl-check-error))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (draw-axes)
    ;; X
    (render-line (vertex -10.0   0.0   0.0) (vertex 10.0  0.0  0.0) .05 red-dye)
    (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0  0.5) .05 red-dye)
    (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0 -0.5) .05 red-dye)
    
    ;; Y
    (render-line (vertex   0.0 -10.0   0.0) (vertex  0.0 10.0  0.0) .05 green-dye)
    (render-line (vertex   0.0  10.0   0.0) (vertex  0.5  9.5  0.0) .05 green-dye)
    (render-line (vertex   0.0  10.0   0.0) (vertex -0.5  9.5  0.0) .05 green-dye)
    
    ;; Z
    (render-line (vertex   0.0   0.0 -10.0) (vertex  0.0  0.0 10.0) .05 blue-dye)
    (render-line (vertex   0.0   0.0  10.0) (vertex  0.5  0.0  9.5) .05 blue-dye)
    (render-line (vertex   0.0   0.0  10.0) (vertex -0.5  0.0  9.5) .05 blue-dye)
    
    (when axes-graduation?
      (let ((grad .15))
        ;; X
        (loop (for x <fl> from -9. to 9. by 1.)
              (render-line (vertex x (- grad) 0.0) (vertex x grad 0.0) .01 red-dye))
        
        ;; Y
        (loop (for y <fl> from -9. to 9. by 1.)
              (render-line (vertex (- grad) y 0.0) (vertex grad y 0.0) .01 green-dye))
        
        ;; Z
        (loop (for z <fl> from -9. to 9. by 1.)
              (render-line (vertex 0.0 (- grad) z) (vertex 0.0 grad z) .01 blue-dye)))))
  
  
  (method (draw-history)
    (let ((history (current-history)))
      (define (draw-now metadata)
        (bind (entity model meshes matrix) metadata
          (when (history-draw-now?~ entity)
            (register-ghost entity model meshes matrix 0))))
        
      (define (draw-metadata metadata)
        (bind (entity model meshes matrix) metadata
          (when (history-draw-trail?~ entity)
            (register-ghost entity model meshes matrix 1))))
      
      (define (draw-trail from to)
        (let (iter (n from) (count 0))
          (when (and (<= n to) (< count history-trail))
            (let ((metadata (historical-metadata~ history n)))
              (if (not metadata)
                  (iter (+ n 1) count)
                (draw-metadata metadata)
                (iter (+ n 1) (+ count 1)))))))
      
      (unless simulate-protocol?
        (let ((now (get-now~ history))
              (first (history-first~ history))
              (last (history-last~ history)))
          (draw-trail first (- now 1))
          (draw-trail (+ now 1) last)
          (unless (= (get-count~ history) 0)
            (let ((now-metadata (historical-metadata~ history now)))
              (when now-metadata
                (draw-now now-metadata))))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method (refresh-interface (condition: condition #f))
    (let ((interface (current-interface)))
      (when (or (not condition)
                (some? (lambda (name)
                         (get-visible?~ (child~ interface name)))
                       condition))
        (set! interface-refresh? #t)
        (let ((info (child~ interface 'info)))
          (when (get-visible?~ info)
            (view-info~ info)))
        (let ((target (child~ interface 'target)))
          (when (get-visible?~ target)
            (view-target~ target)))
        (let ((profiler (child~ interface 'profiler)))
          (when (get-visible?~ profiler)
            (view-sites~ profiler))))))
  
  
  (method (render-interface)
    (let ((interface (current-interface)))
      (when interface?
        (site (render-interface on?: #t parent: render)
          (when interface-refresh?
            (invalidate-view~ interface)
            (set! interface-last-time (current-seconds))
            (set! interface-refresh? #f))
          ;; removing slots background and drawing them first is
          ;; a quick hack around slots being drawn over everything
          (site (draw-slots on?: #t parent: render-interface)
            (draw-slots))
          (render-player~ interface)
          (when message
            (draw-message))
          (when status
            (draw-status))
          (when compass-visible?
            (draw-compass))
          (when map-visible?
            (draw-map))
          (when chronology-visible?
            (draw-chronology))))))
  
  
  (method (explore-interface)
    (set! explore-interface? (not explore-interface?))
    (when explore-interface?
      (set! interface? #t))
    (set-window-cursor~ (current-world-window) (if explore-interface? :spy :arrow)))
  
  
  (method (update-compass)
    (let ((interface (current-interface+)))
      (when interface
        (let ((pane (child~ interface 'compass)))
          (set-uptodate?~ pane #f)))))
  
  
  (method (propagation-debugger)
    (let ((interface (current-interface)))
      (let ((frame (find-component~ interface 'propagation)))
        (if frame
            (close~ frame)
          (let ((size propagation-size)
                (slot-size propagation-slot-size))
            (open-frame
              (new Propagation-Frame
                name: 'propagation
                size: (new Dimension (+ (* slot-size size) 1) (+ 20 (* slot-size size) 1))
                location: '(center -75))))
          (layout-view~ interface)))))
  
  
  (method protected virtual (create-main-menu)
    (new World-Main-Menu visible?: #t))
  
  
  (method (main-menu)
    (let ((panel (top-panel)))
      (if panel
          (close~ panel)
        (let ((menu (create-main-menu)))
          (push-pane (open-menu menu))
          (release-cursor~ window)
          ;; quick hack that should be replaced by
          ;; a complete solution for in-window popups
          (delay-event
            (lambda ()
              (acquire-focus~ menu))))
        @w
        (set-cursor-mode? #t))))
  
  
  (method (main-menu-destroyed)
    (set-cursor-mode? #f)
    (when (not (get-autotrack-camera?))
      (capture-cursor~ window)))
  
  
  (method (video-options)
    (push-pane (open-frame (new World-Video-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method (audio-options)
    (push-pane (open-frame (new World-Audio-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method (interface-options)
    (push-pane (open-frame (new World-Interface-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method (view-bindings)
    (push-pane (open-frame (new World-Bindings-Viewer size: {Dimension 406 588} location: 'center))))
  
  
  (method (view-news)
    (push-pane (open-world-document (news-file~ (get-application)) class: World-Formatted-Text-View)))
  
  
  (method (view-roadmap)
    (push-pane (open-world-document (roadmap-file~ (get-application)) class: World-Formatted-Text-View)))
  
  
  (method (view-help)
    (push-pane (open-world-document (help-file~ (get-application)) class: World-Formatted-Text-View)))
  
  
  (method (open-about (name: name #f) (title: title #f) (movable?: movable? #t) (closable?: closable? #t) (background: background #f))
    (push-pane (open-world-document (about-file~ (get-application)) class: World-Formatted-Text-View name: (or name 'about) title: title movable?: movable? closable?: closable? size: {Dimension 715 470} background: background selectable?: #f)))
  
  
  (method (open-welcome)
    (close-current-popup)
    (open-welcome-zone))
  
  
  (method (close-current-popup)
    (let ((interface (current-interface)))
      (let ((pane (find-if (lambda (pane) (is? pane World-Panel)) (get-children~ interface) reversed?: #t)))
        (when pane
          (close~ pane)))))
  
  
  (method (interface-layout)
    (let ((interface (current-interface)))
      (for-each (lambda (name)
                  (let ((pane (find-component~ interface name)))
                    (when pane
                      (let ((layouter (get-layouter~ pane)))
                        (layouter pane)))))
                '(info profiler target script combat character bag belt chest chat command models blocks))
      (layout-view~ interface)))
  
  
  (method (enter-press)
    (when enter-hook
      (enter-hook)))
  
  
  (method (tab-press)
    (when showcase
      (if (shift-down?)
          (previous-category~ showcase)
        (next-category~ showcase))))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method (missile-hit missile collision)
    (let ((zone (current-zone))
          (poly (get-polygon~ collision)))
      (let ((element (get-element~ poly)))
        (cond ((is? element Actor)
               (case (get-kind~ missile)
                 ((bullet)
                  (let ((inflictor (get-actor~ missile)))
                    (wound~ element inflictor (get-power-factor~ inflictor))))
                 ((arrow)
                  (explode~ element (get-actor~ missile))))
               'remove)
              (else
               (case (get-missile-behavior~ zone)
                 ((absorb)
                  'remove)
                 ((rebound)
                  (let ((normal (get-normal~ (get-plane~ collision)))
                        (velocity (get-velocity~ missile)))
                    (let ((rebound (dot-product& normal velocity)))
                      (set-velocity~ missile (vertex-& velocity (vertex-scalar*& normal (* 2. rebound))))))
                  'stop)
                 ((slide)
                  'slide)
                 ((destroy)
                  (let ((editable? (zone-editable?~ zone))
                        (destructible? (zone-destructible?~ zone)))
                    (define (remove element)
                      (if editable?
                          (editor-remove-element element)
                        (remove-element element)))
                    
                    (when (or editable? destructible?)
                      (let ((element (effective-element poly)))
                        (let ((pos (get-position~ element)))
                          (case (get-kind~ missile)
                            ((bullet)
                             (play-3d-sound "sound/combat/explosion" pos)
                             (if (virtual-block? element)
                                 (delete-block-at~ (current-game) pos)
                               (remove element)))
                            ((arrow)
                             @wait
                             (if (virtual-block? element)
                                 (explose-blocks-at~ (current-game) pos)
                               (play-3d-sound "sound/spells/ExplosiveShot" pos)
                               (remove element))))))))
                  'remove)))))))
  
  
  (method (change-missile-behavior (reversed?: reversed? #f))
    (let ((zone (current-zone))
          (next (if reversed? previous-element next-element)))
      (unimplemented-connected)
      (set-missile-behavior~ zone (next '(absorb destroy rebound slide) (get-missile-behavior~ zone)))
      (display-message (format "{a}" (capitalize (symbol->string (get-missile-behavior~ zone)))))))

  
  ;;;
  ;;;; World
  ;;;
  
  
  (method (world-open)
    (unimplemented-connected)
    (let ((interface (current-interface)))
      (let ((pane (find-type~ interface World-Open)))
        (if pane
            (close~ pane)
          (open-frame (new World-Open size: {Dimension 366 588} location: 'center))))))
  
  
  (method (world-save)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (world-save-to moniker)
        (world-save-as))))
  
  
  (method (world-save-as)
    (unimplemented-connected)
    (let ((file (choose-new-file title: "Save New World" default-extension: "world" extensions: '(("World Files" . "world")) directory: {Directory Settings "worlds"})))
      (world-save-to file)))
  
  
  (method (world-save-to file)
    (unimplemented-connected)
    (with-window-cursor :wait
      (lambda ()
        (parameterize ((pretty-print-forms? #f))
          (save-to~ designer file))
        (update-title)
        (display-message "Saved"))))
  
  
  (method (world-revert)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (open-world moniker)
        (bell))))
  
  
  (method (get-world-directory)
    (let ((moniker (get-moniker)))
      (when moniker
        (get-parent~ moniker))))
  
  
  (method (get-tiers-directory kind)
    (case kind
      ((local) {Directory Settings "local" "zones"})
      ((client) {Directory Settings "clients"})
      ((server) {Directory Settings "servers"})))
  
  
  (method (get-templates-directories)
    (let ((world-directory (get-world-directory)))
      (if world-directory
          (list (new-directory~ world-directory "templates"))
        '())))
  
  
  (method (update-title)
    (let ((zone (current-zone)))
      (set-caption~ window (get-title~ zone))))
  
  
  (method (get-moniker)
    (get-origin~ form))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (when #t @buggy (neq? flag (get-modified?~ designer))
      (set-modified?~ designer flag)
      (update-title)))
  
  
  ;;;
  ;;;; Zone
  ;;;

  
  (method (zone-new)
    (unimplemented-connected)
    (let ((interface (current-interface)))
      (let ((pane (find-type~ interface Zone-New)))
        (if pane
            (close~ pane)
          (open-frame (new Zone-New size: {Dimension 366 588} location: 'center))))))
  
  
  (method (zone-open)
    (if (client?)
        (client-zone-open)
      (let ((interface (current-interface)))
        (let ((pane (find-type~ interface Tier-Open)))
          (if pane
              (close~ pane)
            (open-frame (new Tier-Open size: {Dimension 366 588} location: 'center)))))))
  
  
  (method (zone-reload)
    (unimplemented-connected)
    (let ((zone (current-zone)))
      (reset-profiling)
      (open-local (find-zone (zone-path~ zone 'local) 'local))))
  
  
  (method (zone-regenerate)
    (unimplemented-connected)
    (let ((zone (current-zone)))
      (reset-profiling)
      (iterate-directory~ (get-regions-dir~ zone)
        (lambda (file)
          (when (extension=? (get-extension~ file) "mca")
            (delete-file~ file))))
      (open-local (find-zone (zone-path~ zone 'local) 'local))))
  
  
  (method (zone-open-content)
    (unimplemented-connected)
    (let ((interface (current-interface)))
      (let ((pane (find-type~ interface Tier-Open)))
        (if pane
            (close~ pane)
          (open-frame (new Tier-Open size: {Dimension 366 588} location: 'center start-script?: #f))))))
            
  
  (method (choose-new title prefix initial-value proc (kind: kind 'local) (exists: exists #f))
    (open-string
      title: title
      prefix: prefix
      initial-value: initial-value
      action: (lambda (base)
                (let ((file (new-zone-file base kind)))
                  (if (exists?~ file)
                      (if exists
                          (exists file proc)
                        (open-message (format "Zone {a} already exists. Do you want to replace it?" base)
                                      caption: "Save"
                                      type: 'confirmation
                                      yes: "Yes"
                                      no: "No"
                                      cancel: "Cancel"
                                      execute: (lambda (evt)
                                                 (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog))
                                                       (button (get-property~ evt button:)))
                                                   (close~ dialog)
                                                   (case button
                                                     ((yes) (proc file))
                                                     ((no))
                                                     ((cancel) (signal-cancel)))))))
                    (proc file))))))
  
  
  ;;;
  ;;;; Client
  ;;;
  
  
  (method (client-zone-open)
    (let ((interface (current-interface)))
      (let ((pane (find-type~ interface Zone-Open)))
        (if pane
            (close~ pane)
          (open-frame (new Zone-Open size: {Dimension 366 588} location: 'center))))))
  
  
  ;;;
  ;;;; Role
  ;;;
  
  
  (method public (toggle-user)
    (setup-role (if (eq? current-role initial-role)
                    'user
                  initial-role)))
  
  
  (method public (setup-role new-role)
    (let ((zone (current-zone)))
      (let ((appl (get-application)))
        (uninstall-interface~ zone)
        (updating-actions~ appl
          (lambda ()
            (set-current-role new-role)
            (install-bindings~ appl)
            (install-role~ appl)))
        (when (eq? new-role 'user)
          (no-showcase))
        (when (and (neq? new-role 'user)
                   (not non-user-aggroes?))
          (unaggro~ (current-me)))
        (reset-inventory-blocks)
        (setup-interface)
        (install-interface~ zone)
        (update-parameter 'user)
        (display-message (capitalize (symbol->string new-role))))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (definition troposphere
    2.)
  
  (definition stratosphere
    3.)
  
  
  (method public (planet-troposphere)
    troposphere)
  
  (method public (planet-stratosphere)
    stratosphere)
  
  
  (method public (compute-gravity position)
    (let ((gravity (make-vertex)))
      (vertex-copy! gravity (compute-gravity& position))
      gravity))
  
  
  (method public (compute-gravity& position)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (let ((gravity (vertex-copy& ambient-gravity)))
            (iterate-gravities~ zone
              (lambda (well)
                (let ((pos (get-position~ well))
                      (radius (get-radius~ well)))
                  (let ((direction (vertex-normalize& (vertex-& pos position)))
                        (distance (max radius (vertex-distance pos position))))
                    (let ((well-gravity (vertex-scalar*& direction (well-pull well distance))))
                      (if (<= distance (+ radius troposphere))
                          (continuation-return return well-gravity)
                        (vertex+! gravity gravity well-gravity)))))))
            gravity)))))
  
  
  (method public (well-pull well distance)
    (let ((mass (well-mass~ well)))
      (/ mass (* distance distance))))
  
  
  (method public (well-gravity well position)
    (let ((pos (get-position~ well))
          (radius (get-radius~ well)))
      (let ((direction (vertex-normalize& (vertex-& pos position)))
            (distance (max radius (vertex-distance pos position))))
        (vertex-scalar* direction (well-pull well distance)))))
  
  
  (method public (surface-pull well)
    (well-pull well (get-radius~ well)))
  
  
  (method public (inside-stratosphere? well position)
    (let ((pos (get-position~ well))
          (radius (get-radius~ well)))
      (let ((distance (max radius (vertex-distance pos position))))
        (<= distance (+ radius stratosphere)))))
  
  
  ;;;
  ;;;; Planet
  ;;;
  
  
  (method public (determine-planet pos)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (iterate-gravities~ zone
            (lambda (well)
              (when (and (is? well Planet)
                         (inside-stratosphere? well pos))
                (continuation-return return well))))
          #f))))
  
  
  ;;;
  ;;;; Vehicle
  ;;;
  
  
  (method (change-vehicle)
    (let ((me (current-me)))
      (if (not (get-vehicle~ me))
          (bell)
        (let ((folio (if (get-fly?~ me) flyers-folio mounts-folio)))
          (let ((next (next-element (get-list~ folio) (get-vehicle~ me))))
            (set-current~ folio next)
            (activate-vehicle next))))))
  
  
  (method (activate-vehicle vehi)
    (let ((me (current-me)))
      (set-vehicle~ me vehi)
      (update-model~ me)
      (when (eq? (get-vehicle~ me) 'hummer)
        (set-position~ me (vertex+& (get-position~ me) (vertex& 0. 1.5 0.))))))
  
  
  (method (vehicle-speed actor)
    (case (get-vehicle~ actor)
      ((wheels) 13.)
      ((hummer) 19.5)
      ((saucer) 19.5)
      ((rocket) 65.)
      (else (ground-speed~ actor))))
  
  
  ;;;
  ;;;; Mount
  ;;;
  
  
  (method (toggle-mount)
    (let ((me (current-me))
          (history (current-history)))
      (unless (get-paused?~ history)
        (unless (programmer?)
          (unimplemented-connected))
        (person-motion)
        (deactivate-fly)
        (if (get-mount?~ me)
            (deactivate-mount)
          (activate-mount)))))
  
  
  (method (activate-mount)
    (let ((me (current-me)))
      (unless (get-mount?~ me)
        (set-mount?~ me #t)
        (activate-vehicle (get-current~ mounts-folio))
        (update-parameter 'mount)
        (update-parameter 'fly))))
  
  
  (method (deactivate-mount)
    (let ((me (current-me)))
      (when (get-mount?~ me)
        (set-mount?~ me #f)
        (activate-vehicle #f)
        (update-parameter 'mount)
        (update-parameter 'fly))))
  
  
  ;;;
  ;;;; Fly
  ;;;
  
  
  (method (toggle-fly)
    (let ((me (current-me)))
      (unless (or (user?) (creator?))
        (unless (programmer?)
          (unimplemented-connected))
        (person-motion)
        (deactivate-mount)
        (if (get-fly?~ me)
            (deactivate-fly)
          (activate-fly)))))
  
  
  (method (activate-fly (force?: force? #f))
    (let ((me (current-me))
          (motion (current-motion)))
      (unless (and (not force?) (get-fly?~ me))
        (set-fly?~ me #t)
        (set-position~ me (vertex+& (get-position~ me) (vertex& 0. 2. 0.)))
        (activate-vehicle (get-current~ flyers-folio))
        ;; quick hack for orb
        (when (is? motion Target-Motion)
          (adjust-player-alpha~ motion))
        (update-parameter 'mount)
        (update-parameter 'fly)
        (follow-player))))
  
  
  (method (deactivate-fly)
    (let ((me (current-me))
          (motion (current-motion)))
      (when (get-fly?~ me)
        (set-fly?~ me #f)
        (activate-vehicle #f)
        ;; quick hack for orb
        (when (is? motion Target-Motion)
          (adjust-player-alpha~ motion))
        (update-parameter 'mount)
        (update-parameter 'fly)
        (when (is? motion Person-Motion)
          (exit-fly~ motion)))))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot designer          <object> initialize #f     accessors generate)
  (slot editing?          <bool>   initialize #f     getter generate)
  (slot editor-mode       <object> initialize 'plane getter generate)
  (slot editor-added?     <bool>   initialize #f     getter generate)
  (slot editor-origin     <object> initialize #f     getter generate)
  (slot editor-normal     <object> initialize #f     getter generate)
  (slot editor-direction  <object> initialize #f     getter generate)
  (slot editor-floor?     <bool>   initialize #f     getter generate)
  (slot adding            <object> initialize #f     getter generate)
  (slot adding-properties <object> initialize #f     getter generate)
  (slot adding?           <bool>   initialize #f     getter generate)
  (slot deleting?         <bool>   initialize #f     getter generate)
  (slot removing?         <bool>   initialize #f     getter generate)
  (slot changing?         <bool>   initialize #f     getter generate)
  (slot mouse-run?        <bool>   initialize #f     getter generate)
  (slot widget-down       <object> initialize #f     getter generate)
  (slot widget-part       <object> initialize #f     getter generate)
  (slot grid?             <bool>   initialize #f     accessors generate)
  (slot grid-plane        <symbol> initialize 'y     getter generate)
  (slot grid-position     <fl>     initialize 0.     getter generate)
  
  
  (method (change-editor-mode (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          (available-modes '(plane column free @comment crazy)))
      (let ((new-mode (next available-modes editor-mode)))
        (set! editor-mode new-mode)
        (display-message (capitalize (->string new-mode))))))
  
  
  (method (select-target-mode)
    (set! target-mode 'select)
    (set! target-widget #f)
    (update-target-parameters)
    (display-message "Select"))
  
  
  (method (move-target-mode)
    (if (eq? target-mode 'move)
        (select-target-mode)
      (set! target-mode 'move)
      (set! target-widget (new Mover))
      (update-target-parameters)
      (display-message "Move")))
  
  
  (method (rotate-target-mode)
    (if (eq? target-mode 'rotate)
        (select-target-mode)
      (set! target-mode 'rotate)
      (set! target-widget (new Rotater))
      (update-target-parameters)
      (display-message "Rotate")))
  
  
  (method (scale-target-mode)
    (if (eq? target-mode 'scale)
        (select-target-mode)
      (set! target-mode 'scale)
      (set! target-widget (new Scaler))
      (update-target-parameters)
      (display-message "Scale")))
  
  
  (method (skeleton-target-mode)
    (if (eq? target-mode 'skeleton)
        (select-target-mode)
      (set! target-mode 'skeleton)
      (set! target-widget (new Skeleton))
      (update-target-parameters)
      (display-message "Skeleton")))
  
  
  (method (update-target-parameters)
    (update-parameter 'select-target-mode)
    (update-parameter 'move-target-mode)
    (update-parameter 'rotate-target-mode)
    (update-parameter 'scale-target-mode)
    (update-parameter 'skeleton-target-mode))
  
  
  (method (find-mesh-program name)
    (or (table-ref mesh-programs name #f)
        (error "Unknown mesh program: {s}" name)))
  
  
  (method (collect-textures)
    (define (add-files dir table)
      (when (exists?~ dir)
        (add-subdir dir table)
        (iterate-directory~ dir
          (lambda (subdir)
            (add-subdir subdir table))
          files?: #f
          directories?: #t)))
    
    (define (add-subdir subdir table)
      (define (load-metadata)
        (let ((file (new-file~ subdir ".metadata")))
          (and (exists?~ file)
               (let ((metadata (call-with-input-file (path-settings file) read)))
                 (assert (and (pair? metadata)
                              (pair? (cdr metadata))
                              (eq? (cadr metadata) 'textures)))
                 (cddr metadata)))))
      
      (let ((metadata (load-metadata)))
        (define (texture-metadata file)
          (and metadata
               (let ((pair (associate (get-name~ file) metadata test: filename=?)))
                 (and pair
                      (cdr pair)))))
        
        (iterate-directory~ subdir
          (lambda (file)
            (when (member? (get-extension~ file) '("png" "tga") test: extension=?)
              (let ((metadata (texture-metadata file)))
                (table-set! table (get-base~ file) (cons metadata file)))))
          files?: #t
          directories?: #f
          recursive?: #f)))
    
    (when (not textures)
      (let ((table (make-table test: equal?)))
        (iterate-assets
          (lambda (assets)
            (add-files (new-directory~ (get-directory~ assets) "texture") table)))
        (iterate-assets
          (lambda (assets)
            (add-files (new-directory~ (get-directory~ assets) "tile") table)))
        (set! textures table)))
    textures)
  
  
  (method (reload-textures)
    (set! textures #f))
  
  
  (method (find-texture name)
    (let ((textures (collect-textures)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((pair? value)
               (bind (metadata . file) value
                 (let ((texture (make-file-texture file metadata: metadata)))
                   (table-set! textures name texture)
                   texture)))
              (else
               value)))))
  
  
  (method (find-texture-metadata name (error?: error? #t))
    (let ((textures (collect-textures)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (if error?
                   (error "Unable to find texture: {a}" name)
                 #f))
              ((pair? value)
               (car value))
              (else
               (get-metadata~ value))))))
  
  
  (method (find-texture-shader name)
    (let ((metadata (find-texture-metadata name error?: #f)))
      (and metadata
           (let ((pair (assq 'shader metadata)))
             (and pair
                  (cadr pair))))))
  
  
  (method (find-texture-file name)
    (let ((textures (collect-textures)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((pair? value)
               (cdr value))
              (else
               (get-file~ value))))))
  
  
  (method (reset-showcases)
    (register-entity-classes #t)
    (when showcase
      (showcase-deactivate showcase))
    (set! showcases (make-table test: eq?))
    (set! showcase (and showcase (find-showcase (showcase-name showcase))))
    (when showcase
      (showcase-activate showcase))
    (unspecified))
  
  
  (method (set-showcase show)
    (set! showcase show))
  
  
  (method (no-showcase)
    (when showcase
      (showcase-deactivate showcase)
      (set! showcase #f)))
  
  
  (method (goto-showcase show)
    (let ((actual (showcase-name showcase)))
      (when showcase
        (showcase-deactivate showcase))
      (let ((show (if (neq? show actual) (and show (find-showcase show)) #f)))
        (set! showcase show)
        (when showcase
          (showcase-activate showcase))
        (update-parameter 'blocks-showcase)
        (update-parameter 'models-showcase)
        (update-parameter 'animations-showcase)
        (update-parameter 'shaders-showcase)
        (update-parameter 'tiles-showcase)
        (update-parameter 'textures-showcase)
        (update-parameter 'skyboxes-showcase)
        (update-parameter 'gadgets-showcase)
        (update-parameter 'meshes-showcase))))
  
  
  (method (showcase-activate showcase)
    (activate~ showcase)
    (update-target-pane)
    (invalidate-belt)
    (interface-layout)
    (reset-inventory-blocks))
  
  
  (method (showcase-deactivate showcase)
    (deactivate~ showcase)
    (set! showcase~self #f)
    (update-target-pane)
    (invalidate-belt)
    (interface-layout)
    (reset-inventory-blocks))
  
  
  (method (find-showcase name)
    (or (table-ref showcases name #f)
        (let ((class (showcase-class name)))
          (let ((showcase (new class)))
            (table-set! showcases name showcase)
            showcase))))
  
  
  (method (showcase-class name)
    (case name
      ((tiles) Tiles-Showcase)
      ((textures) Textures-Showcase)
      ((skyboxes) Skyboxes-Showcase)
      ((models) Models-Showcase)
      ((avatars) Avatars-Showcase)
      ((animations) Animations-Showcase)
      ((blocks) Blocks-Showcase)
      ((shaders) Shaders-Showcase)
      ((gadgets) Gadgets-Showcase)
      ((meshes) Meshes-Showcase)))
  
  
  (method (showcase-name showcase)
    (typecase showcase
      ((Tiles-Showcase) 'tiles)
      ((Textures-Showcase) 'textures)
      ((Skyboxes-Showcase) 'skyboxes)
      ((Models-Showcase) 'models)
      ((Avatars-Showcase) 'avatars)
      ((Animations-Showcase) 'animations)
      ((Blocks-Showcase) 'blocks)
      ((Shaders-Showcase) 'shaders)
      ((Gadgets-Showcase) 'gadgets)
      ((Meshes-Showcase) 'meshes)
      (else #f)))
  
  
  (method (import-model)
    (let ((interface (current-interface)))
      (let ((pane (find-type~ interface Model-Import)))
        (if pane
            (close~ pane)
          (open-frame (new Model-Import size: {Dimension 366 588} location: 'center))))))
  
  
  (method (collect-models)
    (let ((models '()))
      (iterate-assets
        (lambda (assets)
          (let ((models-dir (new-directory~ (get-directory~ assets) "model")))
            (when (exists?~ models-dir)
              (iterate-directory~ models-dir
                (lambda (path kind)
                  (let ((dir (new-directory~ models-dir path)))
                    (let ((dirname (get-name~ dir)))
                      (when (or (exists?~ (new-file~ dir (make-filename dirname "fbx")))
                                (exists?~ (new-file~ dir (make-filename dirname "w3ds")))
                                (exists?~ (new-file~ dir (make-filename dirname "ms3d")))
                                (exists?~ (new-file~ dir (make-filename dirname "obj"))))
                        (let ((path (join path "/")))
                          (set! models (cons path models)))))))
                full?: #f
                files?: #f
                directories?: #t
                recursive?: #t)))))
      (sort di<? models)))
  
  
  (method (add-model path)
    (let ((me (current-me))
          (camera (current-camera)))
      (define (determine-position)
        (let ((pos (if (person-motion?) (vertex-& (get-position~ me) (vertex 0. (get-radius-y~ me) 0.)) (vertex-& (get-position~ camera) (vertex 0. 1. 0.)))))
          (vertex+ pos (vertex-scalar*& (get-sight~ camera) 2.))))
      
      (place-model path (determine-position) class: Actor user-origin?: #t)))
  
  
  (method public (place-model model position (scale: scale #f) (class: class #f) (animate?: animate? #t) (animation: animation #f) (savable?: savable? #t) (user-origin?: user-origin? #f))
    (let ((zone (current-zone)))
      (let ((scale (or scale (world-setting 'world.import-scale 1.))))
        (let ((scale (if (flonum? scale) (vertex scale scale scale) scale)))
          (let ((class (or class (get-entity-class~ (find-model model)) Entity))
                (properties (list model: model scale: scale position: position animate?: animate? animation: (or animation "Idle"))))
            (let ((entity (apply new class properties)))
              (add-element~ zone entity)
              (when savable?
                (with-designer~ zone entity
                  (lambda (designer container)
                    (add-child~ designer entity container import: '(world.data) properties: properties))))
              (when user-origin?
                (set-selection (list entity) user-origin?: #t))
              entity))))))
  
  
  (method public (find-model path (error?: error? #t))
    (define (search-assets existing-time)
      (continuation-capture
        (lambda (return)
          (iterate-assets
            (lambda (assets)
              (let ((info (search-in (new-directory~ (get-directory~ assets) "model") existing-time)))
                (when info
                  (continuation-return return info)))))
          (values #f #f))))
    
    (define (search-in models-dir existing-time)
      (and (exists?~ models-dir)
        (let ((dir (new-directory~ models-dir path)))
          (and (exists?~ dir)
            (let ((name (get-name~ dir)))
              (let ((metadata (load-model-metadata name (new-file~ dir ".model"))))
                (define (maybe-fbx)
                  (let ((fbx (new-file~ dir (make-filename name "fbx"))))
                    (and (changed? fbx existing-time)
                      (let ((w3ds (new-file~ dir (make-filename name "w3ds"))))
                        (when (or (not (exists?~ w3ds))
                                  (> (time->seconds (get-modification-time~ fbx))
                                     (time->seconds (get-modification-time~ w3ds))))
                          (let ((path (parse~ (world-file '("devel" "external" "fbx-conv" "windows" "fbx-conv") (get-settings-alias))))
                                (arguments (list (parse~ fbx) (parse~ w3ds))))
                            (call-process (list path: path arguments: arguments show-console: #f))))
                        (values fbx (load-w3ds w3ds metadata: metadata))))))
                
                (define (maybe-w3ds)
                  (let ((w3ds (new-file~ dir (make-filename name "w3ds"))))
                    (and (changed? w3ds existing-time)
                      (values w3ds (load-w3ds w3ds metadata: metadata)))))
                
                (define (maybe-ms3d)
                  (let ((ms3d (new-file~ dir (make-filename name "ms3d"))))
                    (and (changed? ms3d existing-time)
                      (values ms3d (load-ms3d ms3d metadata: metadata)))))
                
                (define (maybe-obj)
                  (let ((obj (new-file~ dir (make-filename name "obj"))))
                    (and (changed? obj existing-time)
                      (let ((png (new-brother~ obj (make-filename (get-base~ obj) "png"))))
                        (assert (exists?~ png)
                          (values obj (load-obj obj (make-file-texture png))))))))
                
                (define (changed? file existing-time)
                  (and (exists?~ file)
                       (or (not existing-time)
                           (/= (time->seconds (get-modification-time~ file)) existing-time))))
                
                (or (maybe-fbx)
                    (maybe-w3ds)
                    (maybe-ms3d)
                    @obj-format-needs-fixing
                    (maybe-obj))))))))
    
    (if (symbol? path)
        (registered-model path)
      (let ((existing-model (table-ref models path #f)))
        (let ((existing-time (and existing-model (get-path-time~ existing-model))))
          (bind-values (file model) (search-assets existing-time)
            (if (not model)
                (or existing-model
                    (if error?
                        (error "Unable to find model: {a}" path)
                      #f))
              (set-file~ model file)
              (set-path~ model path)
              (set-path-time~ model (time->seconds (get-modification-time~ file)))
              (table-set! models path model)
              model))))))
  
  
  (method (reload-model path)
    (table-clear models path))
  
  
  (method (select/run-script)
    (let ((interface (current-interface)))
      (let ((pane (find-type~ interface Script-Run)))
        (if pane
            (close~ pane)
          (open-frame (new Script-Run size: {Dimension 366 588} location: 'center))))))
  
  
  (method (run-last-script)
    (if (not last-script)
        (select/run-script)
      (run-script last-script)))
  
  
  (method (collect-scripts (include-zone?: include-zone? #t))
    (let ((queue (new-queue)))
      (for-each (lambda (partition)
                  (bind (kind . assets) partition
                    (let ((scripts '()))
                      (for-each (lambda (assets)
                                  (let ((scripts-dir (new-directory~ (get-directory~ assets) "script")))
                                    (when (exists?~ scripts-dir)
                                      (iterate-directory~ scripts-dir
                                        (lambda (path kind)
                                          (unless (member? (last path) '(".DS_Store" "README") test: filename=?)
                                            (set! scripts (cons (cons scripts-dir path) scripts))))
                                        full?: #f
                                        files?: #t
                                        directories?: #f
                                        recursive?: #t))))
                                assets)
                      (for-each (lambda (script)
                                  (enqueue queue script))
                                (sort di<? scripts key: cdr)))))
                  (partition-assets include-zone?: include-zone?))
      (queue-list queue)))
  
  
  (method (partition-scripts scripts)
    (partition scripts key: (lambda (script)
                              (bind (dir . path) script
                                (if (> (length path) 1)
                                    (car path)
                                  "")))
      test: filename=?))
  
  
  (method (find-script path)
    (find (collect-scripts) path test: equal? key: (lambda (info)
                                                     (let ((path (cdr info)))
                                                       (extract-spine (join path "/"))))
      return: 'item))
  
  
  (method (run-script script)
    (launch-script script)
    (set! last-script script))
  
  
  (method (execute-script path)
    (let ((script (find-script path)))
      (if script
          (launch-script script)
        (display-error (format "Unable to find script: {a}" path))
        (bell))))
  
  
  (method (toggle-grid)
    (set! grid? (not grid?))
    (update-parameter 'grid))
  
  
  (method (toggle-grid-plane plane)
    (if (and grid? (eq? grid-plane plane))
        (set! grid? #f)
      (set! grid? #t)
      (set! grid-plane plane))
    (update-parameter 'grid))
  
  
  (method (decrease-grid)
    (move-grid-by -1))
  
  
  (method (increase-grid)
    (move-grid-by 1))
  
  
  (cond-expand
    (cocoa
      (method (move-grid delta)
        (move-grid-by (fxround/ (- delta) 5))))
    (else
     (method (move-grid delta)
       (move-grid-by (fxround/ (- delta) 120)))))
  
  
  (method (move-grid-by incr)
    (let ((dist incr))
     (increase! grid-position dist)
     (display-status (format "Grid at {a}" grid-position))))
  
  
  (method (effective-element poly)
    (let ((zone (current-zone)))
      (or (get-element~ poly)
          (bind-values (id variant-id) (decode-id/variant-id (get-data1~ poly))
            (let ((block (id/variant-id->block id variant-id)))
              (create-block-entity~ zone (get-name~ block) (polygon-position poly)))))))
  
  
  (method (virtual-block? elem)
    (and (is? elem Block-Entity)
         (not (get-parent~ elem))))
  
  
  (method (floor-level)
    (and grid? (eq? grid-plane 'y) grid-position))
    
  
  ;; editor-mouse-down
  ;; editor-mouse-move
  ;; editor-mouse-up
  ;; - editor-add / action 'add
  ;;   - editor-add-at
  ;;     - editor-add-element
  ;;       - add-element-class
  ;; - editor-remove
  ;; - editor-change

  
  (method (editor-add mode class grid? grid-plane grid-position position direction stage)
    (let ((zone (current-zone)))
      (case stage
        ((down move)
         (editor-add-at mode class grid? grid-plane grid-position position direction))
        ((up)
         (editor-up)))))
  
  
  (method (editor-add-at mode class grid? grid-plane grid-position position direction)
    (let ((zone (current-zone))
          (me (current-me+)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-direction) 0.) vertex-x)
                                ((/= (vertex-y editor-direction) 0.) vertex-y)
                                ((/= (vertex-z editor-direction) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal~ poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center~ poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal~ poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center~ poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& center editor-origin)) editor-normal))))))
        
        (define (free-filter poly)
          (let ((normal (get-normal~ poly)))
            (vertex=? normal editor-normal)))
        
        (and editor-added?
             (case mode
               ((plane) (plane-filter))
               ((column) column-filter)
               ((free) free-filter)
               ((crazy) #f))))
      
      (define (add-at origin normal poly)
        (define (collision-quad origin normal)
          (let ((inside (vertex+ origin (vertex-scalar* normal -.01))))
            (let ((cube (unit-cube inside)))
              (ray-closest-cuboid-inner-quad inside normal cube))))
        
        (define (determine-anchor element origin normal)
          (let ((bounds (transformed-bounds~ element)))
            (let ((radiuses (cuboid-radiuses bounds)))
              (cond ((float-near? (vertex-y normal) 1.)
                     origin)
                    ((float-near? (vertex-y normal) -1.)
                     (vertex- origin (vertex 0. (cuboid-height bounds) 0.)))
                    (else
                     (vertex+ (vertex- origin (vertex 0. .5 0.))
                              (vertex-scalar* normal (if (/= (vertex-x normal) 0.)
                                                         (vertex-x radiuses)
                                                       (vertex-z radiuses)))))))))
        
        (define (determine-anchor/position element origin normal)
          (if (is? class Block-Entity)
              (values origin origin)
            (let ((anchor (determine-anchor element origin normal)))
              (let ((position (anchor->position~ element anchor)))
                (values anchor position)))))
        
        (define (determine-polygon)
          (if (and (is? class Block-Entity) (not poly))
              (let ((closest (collision-quad origin normal)))
                (and closest
                     (bind (quad dist) closest
                       (let ((origin (get-origin~ quad))
                             (normal (vertex-scalar* (get-normal~ quad) -1.)))
                         (values (vertex+ origin (vertex-scalar*& normal .5)) normal)))))
            (values origin normal)))
        
        (let ((info (determine-polygon)))
          (when info
            (bind-values (origin normal) info
              (when (or (not editor-added?) (vertex=? normal editor-direction))
                (let ((player? (eq? class 'player)))
                  (unless player?
                    (instantiate-element-class class))
                  (let ((element (if player? me adding)))
                    (when player?
                      (deactivate-fly))
                    (bind-values (anchor position) (determine-anchor/position element origin normal)
                      (let ((actual (if (is? class Block-Entity)
                                        (or (not (id? (block-at~ zone position) Air Water StationaryWater Lava StationaryLava))
                                            (element-near~ zone position))
                                      (element-near~ zone position))))
                        (unless actual
                          (if player?
                              (begin
                                (set-position~ me position)
                                (unless (person-motion?)
                                  (set-lookat~ me (get-lookat~ (current-camera))))
                                (follow-player)
                                (unless (person-motion?)
                                  (person-motion feedback?: #f))
                                #f)
                            (let ((added (editor-add-element mode class poly anchor)))
                              (if editor-added?
                                  (add-target added)
                                (set! editor-added? #t)
                                (set! editor-origin (if poly (get-center~ poly) origin))
                                (set! editor-normal (if poly (get-normal~ poly) normal))
                                (set! editor-direction normal)
                                (set! editor-floor? (not poly))
                                (set-selection (list added))) 
                              added))))))))))))
      
      (let ((filter (determine-filter)))
        (let ((poly-closest (ray-closest-polygon position direction view-radius filter: filter ignore-non-physical?: #f ignore-players?: #t water-filter: (if (and (is? class Block-Entity) (eq? (get-model~ class) 'LilyPad)) only-water-filter liquid-filter)))
              (grid-closest (and (or (not editor-added?) (memq? mode '(free crazy)) (and editor-floor? (neq? mode 'column)))
                                 (bind-values (vert normal) (ray-grid-intersection position direction grid? grid-plane grid-position)
                                   (and vert
                                        (cons vert normal))))))
          (let ((poly-distance (and poly-closest (second poly-closest)))
                (grid-distance (and grid-closest (vertex-distance position (car grid-closest)))))
            (if (and poly-closest (or (not grid-closest) (<= poly-distance grid-distance)))
                (bind (poly distance) poly-closest
                  (if (is? class Block-Entity)
                      (with-polygon-interaction~ (current-game) poly
                        (lambda (poly block fore)
                          (add-at fore (get-normal~ poly) poly)))
                    (let ((element (get-element~ poly))
                          (normal (get-normal~ poly)))
                      (let ((target (vertex+ position (vertex-scalar* direction view-radius)))
                            (lookat (get-lookat~ (current-camera)))
                            (radiuses (vertex .001 .001 .001)))
                        (bind-values (new-position new-direction collisions) (collide&stop$ position target lookat radiuses max-distance: view-radius polygon-filter: filter ignore-entities?: #t ignore-players?: #t)
                          (when (not-null? collisions)
                            (let ((coll (car collisions)))
                              (let ((plane (get-plane~ coll)))
                                (add-at (get-origin~ plane) (get-normal~ plane) poly)))
                            (free-collisions$ collisions)))))))
              (when grid-closest
                (bind (vert . normal) grid-closest
                  (let ((normal (if (and (is? class Block-Entity)
                                         (get-flat?~ (cache-model~ class)))
                                    (vertex-negate normal)
                                  normal)))
                    (add-at vert normal #f))))))))))
  
  
  (method (editor-add-element mode class poly anchor)
    (let ((zone (current-zone))
          (game (current-game)))
      (if (is? class Block-Entity)
          (let ((pos anchor)
                (block (name->block (get-name~ (cache-model~ class)))))
            (add-block-at~ game poly pos block)
            (create-block-entity~ zone (get-name~ block) pos))
        (let ((element adding)
              (position (anchor->position~ adding anchor))
              (properties adding-properties))
          (add-element~ game #f element position properties)
          (update-future)
          (set! adding #f)
          (set! adding-properties #f)
          element))))
  
  
  (method (instantiate-element-class class)
    (define (instantiate class/new (properties '()))
      (let ((elem (if (procedure? class/new) (class/new) (apply new class/new properties))))
        (set! adding elem)
        (set! adding-properties properties)))
    
    (define (instantiate-block block)
      (set! adding (new Block-Entity model: (get-name~ (cache-model~ block))))
      (set! adding-properties #f))
    
    (define (instantiate-entity entity)
      (let ((model (cache-model~ entity)))
        (let ((class (or (get-entity-class~ model) (class-of entity))))
          (let ((properties (registered-gadget class)))
            (if properties
                (let ((properties (properties)))
                  (instantiate (lambda ()
                                 (new class))
                               properties))
              (let ((model (or (get-model~ entity) (and model (get-name~ model))))
                    (meshes-mask (get-meshes-mask~ entity))
                    (animation (get-animation~ entity))
                    (animate? (get-animate?~ entity))
                    (queue (new-queue)))
                (define (enqueue-if property value (default #f))
                  (when (neq? value default)
                    (enqueue queue property)
                    (enqueue queue value)))
                
                (enqueue-if model: model)
                (enqueue-if meshes-mask: meshes-mask)
                (enqueue-if animation: animation)
                (enqueue-if animate?: animate?)
                (instantiate (lambda ()
                               (new class model: model))
                             (queue-list queue))))))))
    
    (when (not adding)
      (typecase class
        ((Block-Entity)
         (instantiate-block class))
        ((Entity)
         (instantiate-entity class))
        (else
         (case class
           ((block) (instantiate Block-Entity)))))))
  
  
  (method (editor-remove mode position direction stage)
    (let ((zone (current-zone)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-normal) 0.) vertex-x)
                                ((/= (vertex-y editor-normal) 0.) vertex-y)
                                ((/= (vertex-z editor-normal) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal~ poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center~ poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal~ poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center~ poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& editor-origin center)) editor-normal))))))
        
        (case mode
          ((plane) (plane-filter))
          ((column) column-filter)
          ((free) #f)))
      
      (case stage
        ((down)
         (let ((closest (ray-closest-polygon position direction view-radius ignore-non-physical?: #f ignore-players?: #t)))
           (when closest
             (bind (poly distance) closest
               (let ((element (effective-element poly)))
                 (when element
                   (let ((center (get-center~ poly))
                         (normal (get-normal~ poly)))
                     (editor-remove-element element)
                     (set! editor-origin center)
                     (set! editor-normal normal))))))))
        ((move)
         (when editor-origin
           (let ((closest (ray-closest-polygon position direction view-radius filter: (determine-filter) ignore-non-physical?: #f ignore-players?: #t)))
             (when closest
               (bind (poly distance) closest
                 (let ((element (effective-element poly)))
                   (when element
                     (editor-remove-element element))))))))
        ((up)
         (set! editing? #f)
         (set! removing? #f)
         (set! editor-added? #f)
         (set! editor-origin #f)
         (set! editor-normal #f)
         (set! editor-direction #f)))))
  
  
  (method (editor-delete position)
    (let ((zone (current-zone)))
      (if (zone-editable?~ zone)
          (let ((element #f @convert^^^ (element-at~ zone position)))
            (when element
              (editor-remove-element element)
              (set-modified?~ zone #t)))
        (warn-non-editable))))
  
  
  (method (editor-remove-element elem)
    (let ((game (current-game)))
      (if (virtual-block? elem)
          (delete-block-at~ game (get-position~ elem))
        (remove-element~ game #f elem))
      (update-future)))
  
  
  (method (remove-element elem)
    (let ((zone (current-zone)))
      (remove-element~ zone elem)
      (when (memq? elem selection)
        (remove-target elem))))
  
  
  (method (delete-target)
    (let ((zone (current-zone))
          (history (current-history)))
      (if (null? selection)
          (bell)
        (for-each (lambda (elem)
                    (unless (is? elem Player)
                      (cond ((get-paused?~ history)
                             (editor-delete (get-position~ elem)))
                            (else
                             ;; quicky copy-pasted from editor-delete
                             (editor-remove-element elem)
                             (set-modified?~ zone #t)))))
                  selection))))
  
  
  (method (editor-change position direction  stage)
    (case stage
      ((down move)
       (let ((closest (ray-closest-polygon position direction view-radius ignore-non-physical?: #f ignore-players?: #t)))
         (when closest
           (bind (poly distance) closest
             (let ((element (effective-element poly))
                   (class (editor-element-class)))
               (when class
                 (change-class element class)))))))
      ((up)
       (set! editing? #f)
       (set! changing? #f))))
  
  
  (method (change-class element class)
    (let ((zone (current-zone))
          (game (current-game)))
      (let ((anchor (position->anchor~ element (get-position~ element))))
        (if (virtual-block? element)
            (let ((pos (get-position~ element))
                  (block (name->block (get-name~ (cache-model~ class)))))
              (let ((id (get-id~ block)))
                (unless (if (get-generic?~ (id->block id))
                            (equal? (block/data-at~ zone pos) (cons id (get-variant-id~ block)))
                          (= (block-at~ zone pos) id))
                  (updating-sections~ zone
                    (lambda (add-section)
                      (delete-block-at-updating~ game pos add-section)
                      (add-block-at-updating~ game #f pos block add-section))))))
          (editor-remove-element element)
          (instantiate-element-class class)
          (editor-add-element editor-mode class #f anchor)))))
  
  
  (method (editor-add-class)
    (if (shift-down?)
        'player
      (editor-element-class)))
  
  
  (method (editor-element-class)
    (let ((interface (current-interface)))
      (or (and showcase (selection-addable?~ showcase) (get-selection~ showcase))
          (let ((slot (selected-slot~ (child~ interface 'belt))))
            (let ((id (get-id~ slot)))
              (and id (block-id? id)
                (new Block-Entity model: (get-name~ (id/durability->block id (get-durability~ slot))))))))))
  
  
  (method (mouse-change h v)
    (let ((zone (current-zone)))
      (if (zone-editable?~ zone)
          (unless (user?)
            (bind-values (position direction) (screen->world~ (current-camera) h v)
              (editor-change position direction 'down)
              (set! editing? #t)
              (set! changing? #t)))
        (warn-non-editable))))
  
  
  (method (mouse-add h v)
    (let ((zone (current-zone))
          (camera (current-camera))
          (history (current-history)))
      (let ((player? (shift-down?)))
        (if (or (zone-editable?~ zone)
                player?)
            (unless (or (user?) (and (creator?) player?))
              (bind-values (position direction) (screen->world~ camera h v)
                (let ((class (editor-add-class)))
                  (when class
                    (editor-add editor-mode class grid? grid-plane grid-position position direction 'down)
                    (set! editing? #t)))))
          (warn-non-editable)))))
  
  
  (method (mouse-remove h v)
    (let ((zone (current-zone)))
      (if (zone-editable?~ zone)
          (unless (user?)
            (bind-values (position direction) (screen->world~ (current-camera) h v)
              (editor-remove editor-mode position direction 'down)
              (set! editing? #t)
              (set! removing? #t)))
        (warn-non-editable))))
  
  
  (method (editor-mouse-down h v)
    (let ((control? (control-down?))
          (alt? (alt-down?))
          (shift? (shift-down?)))
      (cond ((and control? alt? (not shift?))
             (mouse-change h v))
            (control?
             (mouse-add h v))
            (alt?
             (mouse-remove h v))
            (else
             (when target-widget
               (bind-values (position direction) (screen->world~ (current-camera) h v)
                 (let ((closest (ray-closest-widget position direction target-widget)))
                   (when closest
                     (bind (poly distance) closest
                       (bind (widget . part) (get-element~ poly)
                         (set! widget-down widget)
                         (set! widget-part part)
                         (widget-mouse-down~ widget-down h v)))))))))))
  
  
  (method (editor-mouse-move h v)
    (let ((history (current-history)))
      (when editing?
        (cond (removing?
               (bind-values (position direction) (screen->world~ (current-camera) h v)
                 (editor-remove editor-mode position direction 'move)))
              (changing?
               (bind-values (position direction) (screen->world~ (current-camera) h v)
                 (editor-change position direction 'move)))
              (else
               (let ((player? (shift-down?)))
                 (unless player?
                   (bind-values (position direction) (screen->world~ (current-camera) h v)
                     (let ((class (editor-add-class)))
                       (when class
                         (editor-add editor-mode class grid? grid-plane grid-position position direction 'move)))))))))))
  
  
  (method (editor-mouse-up h v)
    (let ((zone (current-zone))
          (history (current-history))
          (game (current-game)))
      (bind-values (position direction) (screen->world~ (current-camera) (get-h~ down-point) (get-v~ down-point))
        (if editing?
            (when (zone-editable?~ zone)
              (cond (removing?
                     (editor-remove editor-mode position direction 'up))
                    (changing?
                     (editor-change position direction 'up))
                    (else
                     (let ((class (editor-add-class)))
                       (when class
                         (editor-add editor-mode class grid? grid-plane grid-position position direction 'up))))))
          (let ((origin (get-position~ (current-camera))))
            (let ((closest (ray-closest-polygon origin direction view-radius ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #f ignore-me?: #t)))
              (if (not closest)
                  (reset-selection user-origin?: #t)
                (bind (poly distance) closest
                  (let ((element (effective-element poly))
                        (vertex (ray/distance-closest-vertex~ poly origin direction distance))
                        (shift? (shift-down?)))
                    (define (select)
                      (let ((selection-sound? (is-not? element Block-Entity)))
                        (if shift?
                            (if (member? element selection test: target=?)
                                (remove-target element user-origin?: #t)
                              (add-target element polygon: poly vertex: vertex user-origin?: #t))
                          (set-selection (list element) polygon: poly vertex: vertex selection-sound?: selection-sound? user-origin?: #t))))
                    
                    (if (not shift?)
                        (unless (mouse-up~ game h v)
                          (if double-click?
                              (double-click~ game h v)
                            (select)))
                      (select)))))))))
      (editor-up)))
  
  
  (method (editor-up)
    (set! editing? #f)
    (set! adding? #f)
    (set! deleting? #f)
    (set! removing? #f)
    (set! changing? #f)
    (set! editor-added? #f)
    (set! editor-origin #f)
    (set! editor-normal #f)
    (set! editor-direction #f)
    (set! editor-floor? #f)
    (set! adding #f)
    (set! adding-properties #f))
  
  
  (method protected virtual (warn-non-editable)
    (let ((zone (current-zone)))
      (unless (or (get-editable-warned?~ zone) (admin?))
        (set-editable-warned?~ zone #t)
        (open-message "Zone is not editable"
                      caption: "Edition"
                      type: 'message
                      execute: (lambda (evt)
                                 (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog)))
                                   (close~ dialog)))))))
  
  
  ;;;
  ;;;; Change
  ;;;
  
  
  ;; quick hack
  (method (class->class-name class)
    (category-name class))
  
  
  ;; quick hack
  (method (class-name->class class-name)
    (case class-name
      ((Sphere) Sphere)
      ((Spawner) Spawner)
      ((Wolf) Wolf)
      ((Spider) Spider)
      ((Jumper) Jumper)
      ((Creature) Creature)
      ((Missile) Missile)
      ((Actor) Actor)
      (else Entity)))
  
  
  ;;;
  ;;;; Grid
  ;;;
  
  
  (method (ray-grid-intersection position direction grid? grid-plane grid-position)
    (let ((zone (current-zone)))
      (define (perspective->world normal plane-k)
        (let ((norm-direction-dot-product (dot-product normal direction)))
          (unless (and (= norm-direction-dot-product 0.)
                       (case grid-plane
                         ((x) (= (vertex-x position) grid-position))
                         ((y) (= (vertex-y position) grid-position))
                         ((z) (= (vertex-z position) grid-position))))
            (let ((intersect (/ (- plane-k (dot-product normal position))
                                norm-direction-dot-product)))
              (unless (<= intersect 0)
                (let ((point (vertex+ position (vertex-scalar*& direction intersect))))
                  (if (> norm-direction-dot-product 0.)
                      (values point grid-position (vertex-negate normal))
                    (values point grid-position normal))))))))
      
      (if (not grid?)
          (values #f #f)
        (case grid-plane
          ((x) (let ((info (perspective->world (vertex 1. 0. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         pos
                                         (vertex-y vert)
                                         (vertex-z vert)))
                             normal)))))
          ((y) (let ((info (perspective->world (vertex 0. 1. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         pos
                                         (vertex-z vert)))
                             normal)))))
          ((z) (let ((info (perspective->world (vertex 0. 0. 1.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         (vertex-y vert)
                                         pos))
                             normal)))))))))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-future? initialize #t getter generate)
  
  
  (method (toggle-paused)
    (let ((history (current-history)))
      (if (server?)
          (pause~ (current-tier))
        (unimplemented-connected)
        (if (get-paused?~ history)
            (unpause-world)
          (pause-world)))))
  
  
  (method (pause-world)
    (let ((interface (current-interface))
          (history (current-history)))
      (unless (get-paused?~ history)
        (pause~ history)
        (camera-copy! history-camera eye)
        (set-current-camera history-camera)
        (set-current-motion history-motion)
        (update-camera-parameters)
        (inactive-sites)
        (unadvise-sites)
        (when always-profile?
          (set! chronology-visible? #t)
          (update-chronology force?: #t)
          (set-visible?~ (child~ interface 'chronology) #t))
        (set-visible?~ (child~ interface 'slider) #t)
        (update-parameter 'paused))))
  
  
  (method (unpause-world)
    (let ((interface (current-interface))
          (history (current-history)))
      (when (get-paused?~ history)
        (truncate-history)
        (camera-copy! eye history-camera)
        (set-current-camera eye)
        (set-current-motion eye-motion)
        (unpause~ history)
        (eye-behind-player)
        (follow-player)
        (when (or (get-visible?~ (child~ interface 'profiler)) always-profile?)
          (advise-sites)
          (active-sites))
        (when always-profile?
          (set! chronology-visible? #f)
          (set-visible?~ (child~ interface 'chronology) #f))
        (set-visible?~ (child~ interface 'slider) #f)
        (update-parameter 'paused))))
  
  
  (method (snapshot-metadata entity)
    (and (snapshot-metadata? entity)
         (list entity (cache-model~ entity) (entity-meshes~ entity) (copy-matrix (get-matrix~ entity)))))
  
  
  (method (first-target)
    (and (not-null? selection) (first selection)))
  
  
  (method (set-selection sel (polygon: polygon #f) (vertex: vertex #f) (selection-sound?: selection-sound? #t) (selection-sound: selection-sound #f) (user-origin?: user-origin? #f))
    (when (window?)
      (let ((interface (current-interface))
            (zone (current-zone)))
        (when (not-null? selection)
          (deactivate-target~ (first selection)))
        (when (and user-origin? selection-sound? selection-sounds? (not (selection=? sel selection)))
          (play-interface-sound (or selection-sound (if (not-null? sel) "sound/user/selectTarget" "sound/user/deselectTarget"))))
        (set! selection sel)
        (set! target-polygon polygon)
        (set! target-vertex vertex)
        (target-update selection polygon vertex)
        (target-update~ zone selection polygon vertex)
        (invalidate-view~ interface)
        (reset-edited-entity)
        (update-color-pane)
        (update-target-pane)
        (update-script-pane)
        (when (not-null? selection)
          (activate-target~ (first selection)))
        (refresh-interface condition: '(info target)))))
  
  
  (method (reset-selection (user-origin?: user-origin? #f))
    (set-selection '() user-origin?: user-origin?))
  
  
  (method (selection=? sx sy)
    (and (= (length sx) (length sy))
         (every? target=?
                 sx
                 sy)))
  
  
  (method (target=? x y)
    (if (and (is? x Block-Entity)
             (is? y Block-Entity))
        (vertex=? (get-position~ x) (get-position~ y))
      (equal? x y)))
  
  
  (method (add-target elem (polygon: polygon #f) (vertex: vertex #f) (user-origin?: user-origin? #f))
    (set-selection (append! selection (list elem)) polygon: polygon vertex: vertex user-origin?: user-origin?))
  
  
  (method (remove-target elem (user-origin?: user-origin? #f))
    (set-selection (remove elem selection test: target=?) selection-sound: "sound/user/deselectTarget" user-origin?: user-origin?))
  
  
  (method (x-rays-mode?)
    (and x-rays? (not x-rays-category)))
  
  
  (method (toggle-x-rays)
    (cond ((x-rays-mode?)
           (set! x-rays? #f)
           (set! x-rays-category #f))
          (else
           (set! x-rays? #t)
           (set! x-rays-category #f)))
    (update-parameter 'x-rays)
    (display-on/off "X-rays" x-rays?))
  
  
  (method (redstone-x-rays-mode?)
    (and x-rays? (eq? x-rays-category 'redstone)))
  
  
  (method (toggle-redstone-x-rays)
    (cond ((redstone-x-rays-mode?)
           (set! x-rays? #f)
           (set! x-rays-category #f))
          (else
           (set! x-rays? #t)
           (set! x-rays-category 'redstone)))
    (update-parameter 'redstone-x-rays)
    (display-on/off "Redstone X-rays" x-rays?))
  
  
  (method (toggle-draw-blocks)
    (set! draw-blocks? (not draw-blocks?))
    (update-parameter 'blocks)
    (display-on/off "Draw blocks" draw-blocks?))
  
  
  (method (toggle-draw-models)
    (set! draw-entities? (not draw-entities?))
    ;(update-parameter 'models)
    (display-on/off "Draw models" draw-entities?))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (slot evaluate-hooks <object> initialize '() getter generate)
  
  
  (method (register-evaluate-hook proc)
    (set! evaluate-hooks (cons proc evaluate-hooks)))
  
  
  (method (unregister-evaluate-hook proc)
    (set! evaluate-hooks (remove! proc evaluate-hooks)))
  
  
  (method (evaluate-hook forms syntax str container line col)
    (let ((interface (current-interface))
          (zone (current-zone)))
      (evaluate-hook~ zone forms syntax str container line col)
      (when (or (search container "shaders")
                (search str "baked-light"))
        (reload-programs str))
      @test
      (when (search container "procedural")
        (increase-revision~ (get-generator~ zone))
        (reset-selection))
      (when evaluate-future?
        (update-future))
      (for-each (lambda (proc)
                  (proc forms syntax str container line col))
                evaluate-hooks)
      @test
      (update-world-options~ (get-application))
      @test
      (install-skins~ (get-application))
      @test
      (install-bindings~ (get-application))
      (invalidate-view~ interface)
      (set-uptodate?~ (child~ interface 'chronology) #f)
      (reset-profiling)
      (render-scene~ (current-world-window))))
  
  
  (method (reload-programs str)
    (cond ((search str "phong")
           (reload-phong-programs))
          ((or (search str "terrain")
               (search str "baked-light"))
           (reload-terrain-programs))
          ((search str "frame")
           (reload-frame-programs))
          (else
           (reload-transformation-programs)
           (reload-other-programs))))
  
  
  (method (reload-terrain-programs)
    (build-terrain-shaders)
    (relink-program 'terrain)
    (relink-program 'wet-terrain))
  
  
  (method (reload-phong-programs)
    (build-phong-shaders)
    (relink-program 'phong))
  
  
  (method (reload-frame-programs)
    (build-frame-shaders)
    (relink-program 'wireframe)
    (relink-program 'squareframe)
    (relink-program 'playerframe)
    (relink-program 'floorframe))
  
  
  (method (reload-transformation-programs)
    (build-transformation-shaders)
    (relink-program 'radial-blur)
    (relink-program 'motion-blur)
    (relink-program 'water)
    (relink-program 'julia)
    (relink-program 'sierpinski)
    (relink-program 'multitexture)
    (relink-program 'kaleidoscope)
    (relink-program 'tunnel)
    (relink-program 'square-tunnel)
    (relink-program 'fly)
    (relink-program 'pulse))
  
  
  (method (reload-other-programs)
    (build-occlusion-shaders)
    (relink-program 'occlusion))
  
  
  (method (relink-program name)
    (let ((program (find-mesh-program name)))
      (relink~ program)))
  
  
  ;;;
  ;;;; GC
  ;;;
  
  
  (definition memory-site
    (register-site '(memory) '() '(kind: memory)))
  
  
  (method (setup-gc)
    (add-gc-interrupt-job!
      (lambda ()
        (when gc-sound?
          (gc-sound))
        (when gc-trace?
          (terminal 'garbage-collect))
        ;; simulate call
        (let ((running (last-gc-real-time))
              (profile (get-profile~ memory-site))
              (content (get-content~ chronology))
              (id <fx> (get-id~ memory-site))
              (marker (next-chronology-marker!))
              (seconds (current-seconds)))
          (site-profile-running-set! profile (+ (site-profile-running profile) running))
          (site-profile-called-set! profile (+ (site-profile-called profile) 1.))
          ;; start
          (let ((index (index-now~ chronology)))
            (f64vector-set! content index (cast <fl> id))
            (f64vector-set! content (+ index 1) (cast <fl> marker))
            (f64vector-set! content (+ index 2) (- seconds running))
            (f64vector-set! content (+ index 3) 0.)
            (advance!~ chronology))
          ;; end
          (let ((index (index-now~ chronology)))
            (f64vector-set! content index (cast <fl> id))
            (f64vector-set! content (+ index 1) (cast <fl> (+ marker 1)))
            (f64vector-set! content (+ index 2) seconds)
            (f64vector-set! content (+ index 3) 0.)
            (advance!~ chronology))))))
  
  
  (cond-expand
    (windows
     (definition (gc-sound)
       (MessageBeep MB_ICONINFORMATION)))
    (cocoa
     (definition (gc-sound)
       (play-sound "Submarine")))
    (else
     (definition (gc-sound)
       (bell))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (slot previous-mouses initialize '())
  
  
  (method protected virtual (mouse-down h v (double? #f))
    (set! down? #t)
    (set! down-point (new Point h v))
    (set! double-click? double?)
    (set! previous-mouses '())
    (cond ((and showcase (in-showcase?~ showcase v))
           (set! showcase-down? #t)
           (showcase-mouse-down~ showcase h v))
          (else
           (editor-mouse-down h v))))
  
  
  (method protected virtual (mouse-moved x y)
    (define (setup-cursor)
      (set! last-point (new Point$fl$ x y))
      (set! last-time (current-seconds)))
    
    (define (move-camera)
      (define (scalarproduct a <Point$fl$> b <Point$fl$>) <fl>
        (+ (* (get-h~ a) (get-h~ b)) (* (get-v~ a) (get-v~ b))))
      
      (let ((new-point (new Point$fl$ x y))
            (new-time (current-seconds)))
        (movecamera self new-point new-time last-point last-time previous-mouses)
        @wait
        (let ((poschange (nu- new-point last-point))
              (elapse (- new-time last-time)))
          (let ((delta (if (null? previous-mouses)
                           poschange
                         (let ((dirchange (if (null? (cdr previous-mouses)) -1. (scalarproduct poschange (nu- last-point (caadr previous-mouses))))))
                           (let ((ponderation (if (and (< (norm poschange) 5.)
                                                       (>= dirchange 0.))
                                                  .5
                                                1.)))
                             (bind (furthest-point . furthest-time) (last previous-mouses)
                               (nu+ (nu* (nu- new-point furthest-point) (* (/ elapse (- new-time furthest-time)) (- 1. ponderation)))
                                    (nu* poschange ponderation))))))))
            (let ((dx (get-h~ delta))
                  (dy (get-v~ delta)))
              (mouse-track elapse dx dy))))
        (set! last-point new-point)
        (set! last-time new-time)
        (when (get-camera-smoothing?)
          (let ((max-moves 5))
            (set! previous-mouses (cons (cons new-point new-time) previous-mouses))
            (when (> (length previous-mouses) max-moves)
              (set-cdr! (tail previous-mouses (- max-moves 1)) '()))))))
    
    (let ((history (current-history)))
      (let ((h (fxround x))
            (v (fxround y)))
        (cond (showcase-down?
               (showcase-mouse-drag~ showcase h v))
              ((and (get-cursor-captured?~ window) (not (get-cursor-mode?)))
               (move-camera)
               (unless (or (is-moving?) (get-paused?~ history))
                 (follow-player)))
              (widget-down
               (widget-mouse-move~ widget-down h v))
              (editing?
               (editor-mouse-move h v))
              ((and (not (get-autotrack-camera?)) (not (get-cursor-mode?)))
               (setup-cursor)
               (capture-cursor~ window)
               (move-camera))
              ((and down? (not (near? (new Point h v) down-point drag-tolerance)))
               (set! viewing? #t)
               (setup-cursor)
               (capture-cursor~ window))))))
  
  
  (method protected virtual (mouse-track elapse dx dy)
    (let ((zone (current-zone))
          (me (current-controlled+))
          (motion (current-motion))
          (camera (current-camera))
          (history (current-history)))
      (unless (mouse-track~ zone elapse dx dy)
        (cond ((and (is-moving?) (person-motion?))
               (let ((sight (copy-vertex (get-sight~ camera)))
                     (up (copy-vertex (get-up~ camera)))
                     (right (copy-vertex (get-right~ camera)))
                     (first? (not moved?)))
                 (track-actor~ motion me dx dy sight up right first?)
                 (boost-player)
                 (set! moved? #t)))
              (else
               (track-camera~ motion dx dy))))))
  
  
  (method protected virtual (mouse-up h v)
    (let ((zone (current-zone)))
      (if mouse-run?
          (begin
            (set! viewing? #f)
            (set! moving? #t)
            (set! mouse-run? #f))
        (cond (showcase-down?
               (showcase-mouse-up~ showcase h v)
               (set! showcase-down? #f))
              ((get-cursor-captured?~ window)
               (release-cursor~ window)
               (follow-player))
              (widget-down
               (widget-mouse-up~ widget-down h v)
               (set! widget-down #f)
               (set! widget-part #f))
              (else
               (when down?
                 (if (user?)
                     (mouse-up~ (current-game) h v)
                   (editor-mouse-up h v)))))
        (set! down? #f)
        (set! down-point #f)
        (set! viewing? #f))))
  
  
  (method protected virtual (double-click h v)
    (cond ((and showcase (in-showcase?~ showcase v))
           (showcase-double-click~ showcase h v))
          (else
           (mouse-down h v #t))))
  
  
  (method protected virtual (right-mouse-down h v)
    (set! down? #t)
    (set! down-point (new Point h v))
    (set! previous-mouses '())
    (set! moving? #t)
    (set! moved? #f))
  
  
  (method protected virtual (right-mouse-up h v)
    (let ((me (current-me+))
          (motion (current-motion))
          (game (current-game)))
      (if mouse-run?
          (begin
            (set! viewing? #t)
            (set! moving? #f)
            (set! mouse-run? #f))
        (when me
          (reset-roll~ motion me))
        (unless (get-cursor-captured?~ window)
          (if (or (user?) (let ((elem (interaction-element~ game h v)))
                            (and (or (not (admin?)) (shift-down?) (and (is? elem Block-Entity) (eq? (get-model~ elem) 'WoodenDoorBlock)))
                                 (or (and (is? elem Block-Entity)
                                          (get-right-mouse~ (name->block (get-name~ (cache-model~ elem)))))
                                     (and (is? elem Actor)
                                          (let ((script (get-script~ elem)))
                                            (and script
                                                 (get-interact~ script))))))))
              (right-mouse-up~ game h v)
            (when (or (not (admin?)) (shift-down?))
              (mouse-add h v)
              (editor-up))))
        (set! down? #f)
        (set! down-point #f)
        (set! moving? #f)
        (set! mouse-run? #f)
        (release-cursor~ window))))
  
  
  (method (mouse-wheel h v delta)
    (let ((interface (current-interface))
          (zone (current-zone))
          (d (if (shift-down?) (get-h~ delta) (get-v~ delta))))
      (cond ((and grid? (alt-down?))
             (move-grid d))
            ((xor (shift-down?) (world-setting 'world.wheel-zoom? #f))
             (cond ((> d 0)
                    (zoom-in))
                   ((< d 0)
                    (zoom-out))))
            (showcase
             (showcase-wheel~ showcase (> d 0)))
            (else
             (cycle-selection~ (child~ interface 'belt) d)))))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  ;; left+right mouse run
  (method (process-mouse-run)
    (when active?
      (let ((modifiers (modifiers-keys)))
        (when (and (null? modifiers)
                   mouse-down?
                   mouse-right-down?)
          (unless mouse-run?
            (set! mouse-run? #t)
            (mouse-track 0. 0. 0.))
          (move-forward)))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method (process-keys)
    (site (process-keys on?: #f parent: player)
      (when active?
        ;; to optimize by using modifiers-mask
        (let ((modifiers (modifiers-keys)))
          (iterate-keys
            (lambda (shortcut proc)
              (when (and (equal? (get-modifiers~ shortcut) modifiers)
                         (let ((key (get-key~ shortcut)))
                           (or (eqv? key ongoing-key)
                               (key-down? (if (char? key)
                                              (char->integer key)
                                            (symbolic-key->code key))))))
                (proc self))))))))
  
  
  (method protected virtual (process-shortcut shortcut)
    (if (shortcut=? shortcut {Shortcut Escape})
        (if escape-hook
            (escape-hook)
          (main-menu))
      #f))
  
  
  (method protected virtual (key-down c)
    )
  
  
  (method protected virtual (key-press key)
    )
  
  
  (method protected virtual (key-up c)
    )
  
  
  ;;;
  ;;;; Sound
  ;;;
  
  
  (method (toggle-sound)
    (set-sounds? (not sounds?))
    (update-parameter 'sound)
    (display-on/off "Sound" sounds?))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method (unimplemented-connected)
    (let ((tier (current-tier)))
      (unimplemented-connected~ tier)))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method (tile-server/clients)
    (if (local?)
        (live-gaia/world)
      (tile~ (current-tier))))
  
  
  (method (restore-server/clients)
    (if (local?)
        (restore-gaia/world)
      (restore~ (current-tier))))
  
  
  ;;;
  ;;;; Live
  ;;;
  
  
  (method (live-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error "Not connected to a remote debugger")
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (live-gaia/world~ debugger debuggee)))))
  
  
  (method (design-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error "Not connected to a remote debugger")
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (design-gaia/world~ debugger debuggee)))))
  
  
  (method (restore-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error "Not connected to a remote debugger")
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (restore-gaia/world~ debugger debuggee)))))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (toggle-interface)
    (set! interface? (not interface?))
    (update-parameter 'interface))
  
  
  (method (toggle-occlusion (force? #f))
    (set-wireframe? #f)
    (let ((occlusion? (or (not (get-occlusion?)) force?)))
      (set-occlusion? occlusion?)
      (set-override-renderer (and occlusion? (get-occlusion-renderer)))
      (set-block-program (find-mesh-program (if occlusion? 'occlusion 'terrain)))
      (update-parameter 'occlusion)
      (update-parameter 'wireframe)))
  
  
  (method (toggle-wireframe (force? #f))
    (set-occlusion? #f)
    (let ((wireframe? (or (not (get-wireframe?)) force?)))
      (set-wireframe? wireframe?)
      (set-override-renderer (and wireframe? (get-wireframe-renderer)))
      (set-block-program (find-mesh-program (if wireframe? 'wireframe 'terrain)))
      (update-parameter 'occlusion)
      (update-parameter 'wireframe)))
  
  
  (method (toggle-polygon-mode)
    (set! polygon-mode (ecase polygon-mode
                         ((GL_POINT) GL_LINE)
                         ((GL_LINE) GL_FILL)
                         ((GL_FILL) GL_POINT)))
    (glPolygonMode GL_FRONT_AND_BACK polygon-mode))
  
  
  (method (toggle-lighting)
    (set! lighting? (not lighting?))
    (update-parameter 'lighting)
    (display-on/off "Lighting" lighting?))
  
  
  (method (toggle-fog)
    (set-fog? (not fog?))
    (reload-terrain-programs)
    (update-parameter 'fog)
    (display-on/off "Fog" fog?))
  
  
  (method (toggle-windowed-mode)
    (toggle-windowed-mode~ window)
    (update-parameter 'windowed-mode))
  
  
  (method (toggle-post-processing)
    (change-post-processing (not post-processing?))
    (display-on/off "Post processing" post-processing?))
  
  
  (method (change-post-processing value)
    (set! post-processing? value)
    (update-parameter 'post-processing))
  
  
  (method (person-motion (eye-center?: eye-center? #t) (feedback?: feedback? #t))
    (let ((me (current-me)))
      (unless (person-motion?)
        (set! eye-motion (make-person-motion self eye #f))
        (set-current-motion eye-motion)
        (when eye-center?
          (eye-center-player~ eye-motion))
        (update-camera-parameters)
        (when feedback?
          (display-message "First person")))))
  
  
  (method (orbit-motion (feedback?: feedback? #t))
    (unless (orbit-motion?)
      (set! eye-motion (make-orbit-motion self eye #f))
      (set-current-motion eye-motion)
      (orbit-behind~ eye-motion (motion-target~ eye-motion))
      (update-camera-parameters)
      (when feedback?
        (display-message "Orbit around"))))
  
  
  (method (free-motion (feedback?: feedback? #t))
    (unless (free-motion?)
      (set! eye-motion (make-free-motion self eye))
      (set-current-motion eye-motion)
      (update-camera-parameters)
      (when feedback?
        (display-message "Free camera"))))
  
  
  (method (update-camera-parameters)
    (update-parameter 'person-motion)
    (update-parameter 'orbit-motion)
    (update-parameter 'free-motion))
  
  
  (method (effective-draw-gadgets?)
    (or draw-gadgets? (is? showcase Gadgets-Showcase)))
  
  
  (method (toggle-draw-gadgets)
    (set! draw-gadgets? (not draw-gadgets?))
    (update-gadgets)
    (update-parameter 'gadgets)
    (display-on/off "Draw gadgets" draw-gadgets?))
  
  
  (method (toggle-draw-normals)
    (set! draw-normals? (not draw-normals?))
    (update-parameter 'normals)
    (display-on/off "Draw normals" draw-normals?))
  
  
  (method (toggle-draw-atlas)
    (if texture-arrays?
        (display-error "No atlas")
      (set! draw-atlas? (not draw-atlas?))
      (update-parameter 'draw-atlas)
      (display-on/off "Draw atlas" draw-atlas?)))
  
  
  (method (toggle-draw-me)
    (let ((zone (current-zone)))
      (set-draw-me?~ zone (not (get-draw-me?~ zone)))
      (update-parameter 'draw-me)
      (display-on/off "Draw me" (get-draw-me?~ zone))))
  
  
  (method (update-gadgets (draw-gadgets? (effective-draw-gadgets?)))
    (when (not draw-gadgets?)
      (for-each (lambda (elem)
                  (when (is? elem Gadget)
                    (remove-target elem)))
                selection)))
  
  
  (method (toggle-axes)
    (set! axes? (not axes?))
    (update-parameter 'axes)
    (display-on/off "Axes" axes?))
  
  
  (method (toggle-axes-graduation)
    (set! axes-graduation? (not axes-graduation?))
    (display-on/off "Axes graduation" axes-graduation?))
  
  
  (method (toggle-info)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'info)))
        (set-visible?~ pane (not (get-visible?~ pane)))
        (when (get-visible?~ pane)
          (set! interface? #t)))
      (update-parameter 'info)))
  
  
  (method (toggle-profiler)
    (let ((interface (current-interface))
          (history (current-history)))
      (let ((pane (child~ interface 'profiler)))
        (let ((visible? (not (get-visible?~ pane))))
          (unless (or (get-paused?~ history) always-profile?)
            (if visible?
                (begin
                  (reset-profiles)
                  (reset-trackings)
                  (reset-sites)
                  (advise-sites))
              (unadvise-sites)))
          (set-visible?~ pane visible?)
          (when visible?
            (set! interface? #t))))
      (update-parameter 'profiler)))
  
  
  (method (reset-profiling)
    (reset-sites))
  
  
  (method (chronology-pane)
    (set! chronology-visible? (not chronology-visible?))
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'chronology)))
        (when chronology-visible?
          (update-chronology))
        (set-visible?~ pane chronology-visible?))))
  
  
  (method (update-color-pane)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'color)))
        (set-visible?~ pane (some? (lambda (element)
                                     (is? element Light))
                                   selection)))))
  
  
  (method (toggle-target)
    (set! interface-target? (not interface-target?))
    (update-target-pane)
    (update-parameter 'target))
  
  
  (method (update-target-pane)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'target)))
        (if (not interface-target?)
            (set-visible?~ pane #f)
          (set-visible?~ pane (or (not-null? selection)
                                  (and showcase (get-selection~ showcase))))))))
  
  
  (method (compass-pane)
    (set! compass-visible? (not compass-visible?))
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'compass)))
        (set-visible?~ pane compass-visible?))))
  
  
  (method (map-pane)
    (set! map-visible? (not map-visible?))
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'map)))
        (set-visible?~ pane map-visible?))))
  
  
  (method (combat-pane)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'combat)))
        (set-visible?~ pane (not (get-visible?~ pane))))))
  
  
  (method (character-pane)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'character)))
        (if (get-visible?~ pane)
            (hide-character)
          (show-character)))))
  
  
  (method (show-character)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'character)))
        (unless (get-visible?~ pane)
          (set-visible?~ pane #t)
          (view-inventory~ pane)
          (set! interface? #t)
          (update-parameter 'character-pane)))))
  
  
  (method (hide-character)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'character)))
        (when (get-visible?~ pane)
          (set-visible?~ pane #f)
          (save-inventory)
          (update-parameter 'character-pane)))))
  
  
  (method (crafting-pane)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'crafting)))
        ;; devel hack
        (remove-child~ interface pane)
        (set! pane (new Crafting-Pane parent: interface name: 'crafting visible?: (get-visible?~ pane) layouter: crafting-pane-layouter))
        (interface-layout)
        (if (get-visible?~ pane)
            (hide-crafting)
          (show-crafting)))))
  
  
  (method (show-crafting)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'crafting)))
        (unless (get-visible?~ pane)
          (set-visible?~ pane #t)
          (show-belt)
          (show-bag blocks?: #f)
          (hide-chest)
          (set! interface? #t)))))
  
  
  (method (hide-crafting)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'crafting)))
        (when (get-visible?~ pane)
          (set-visible?~ pane #f)
          (hide-bag)))))
  
  
  (method (bag-pane)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'bag)))
        (if (get-visible?~ pane)
            (hide-bag)
          (show-bag)))))
  
  
  (method (show-bag (blocks?: blocks? #t))
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'bag)))
        (unless (get-visible?~ pane)
          (set-visible?~ pane #t)
          (view-inventory~ pane)
          (set! interface? #t)
          (update-parameter 'bag-pane)
          (when (and blocks? (not (user?)))
            (goto-showcase 'blocks))))))
  
  
  (method (hide-bag)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'bag)))
        (when (get-visible?~ pane)
          (save-inventory)
          (set-visible?~ pane #f)
          (hide-crafting)
          (update-parameter 'bag-pane)
          (no-showcase)))))
  
  
  (method (belt-pane)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'belt)))
        (if (get-visible?~ pane)
            (hide-belt)
          (show-belt)))))
  
  
  (method (show-belt)
    (let ((pane (child~ (current-interface) 'belt)))
      (set-visible?~ pane #t)))
  
  
  (method (hide-belt)
    (let ((pane (child~ (current-interface) 'belt)))
      (set-visible?~ pane #f)))
  
  
  (method (who-pane)
    ;; quicky should hide action when local
    (unless (local?)
      (let ((interface (current-interface)))
        (let ((pane (find-type~ interface Who-Pane)))
          (if pane
              (close~ pane)
            (open-frame (new Who-Pane size: {Dimension 200 400} location: 'center)))))))
  
  
  (method (chat-pane)
    ;; quicky should hide action when local
    (unless (local?)
      (let ((interface (current-interface)))
        (let ((pane (child~ interface 'chat)))
          (if (get-visible?~ pane)
              (set-visible?~ pane #f)
            (set-visible?~ pane #t))))))
  
  
  (method (command-message)
    (unless (local?)
      ;; quicky should hide action when local
      (let ((interface (current-interface)))
        (let ((pane (child~ interface 'command)))
          (cond ((get-visible?~ pane)
                 (set-visible?~ pane #f)
                 (reset-focus~ window))
                (else
                 (set-visible?~ pane #t)
                 (acquire-focus~ (locate~ pane 'text))))))
      (interface-layout)))
  
  
  (method (command-slash)
    (unless (local?)
      (let ((interface (current-interface)))
        (let ((pane (child~ interface 'command)))
          (command-slash~ pane)))))
  
  
  (method (hide-command)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'command)))
        (set-visible?~ pane #f)
        (reset-focus~ window)
        (interface-layout))))
  
  
  (method (invalidate-belt)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'belt)))
        (when (get-visible?~ pane)
          (invalidate-view~ pane)))))
  
  
  (method (show-chest section data)
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'chest)))
        (set-visible?~ pane #t)
        (hide-crafting)
        (view-chest~ pane section data)
        (set! interface? #t))))
  
  
  (method (hide-chest)
    (let ((interface (current-interface)))
      (save-chest)
      (let ((pane (child~ interface 'chest)))
        (set-visible?~ pane #f))))
  
  
  (method (update-parameter name)
    (let ((interface (current-interface+)))
      (when interface
        (invalidate-view~ (parameter-view name)))))


  (method (parameter-view name)
    (let ((interface (current-interface+)))
      (when interface
        (let ((parameter (registered-parameter name)))
          (define (find-view)
            (continuation-capture
              (lambda (return)
                (for-each (lambda (bar)
                            (when (is? bar World-Actionbar)
                              (for-each (lambda (button)
                                          (when (and (is? button World-Parameter-Button)
                                                     (eq? (get-parameter~ button) name))
                                            (continuation-return return button)))
                                        (get-children~ bar))))
                          (get-children~ interface))
                (error "Unable to find view: {a}" name))))
          
          (define (lookup-view)
            (or (get-view~ parameter)
                (let ((view (find-view)))
                  (set-view~ parameter view)
                  view)))
          
          (lookup-view)))))
  
  
  (method (display-on/off title flag)
    (display-message (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method (display-message msg (color: color #f))
    (set! message msg)
    (set! message-color color)
    (set! message-time (current-seconds)))
  
  
  (method (draw-message)
    (let ((elapse (- (current-seconds) message-time))
          (fade 1.)
          (done 2.))
      (if (> elapse done)
          (begin
            (set! message #f)
            (set! message-time #f))
        (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f)))
          (let ((surface (get-surface~ (get-texture~ message-player)))
                (font {Font Message})
                (color (or message-color {Color World-Message})))
            (clear~ surface)
            (set-font~ surface font)
            (let ((color (if (not alpha)
                             color
                           (let ((color (copy-object~ color #f)))
                             (set-alpha~ color alpha)
                             color)))
                  (shadow-color (if (not alpha)
                                    {Color Black}
                                  (let ((color (copy-object~ {Color Black} #f)))
                                    (set-alpha~ color alpha)
                                    color))))
              (draw-text~ surface 0 10 message color shadow-color: shadow-color))
            (map-texture~ (get-texture~ message-player))
            (let ((w (text-width~ font message)))
              (let ((x (cast <fl> (center w (fxround width))))
                    (y (cast <fl> (- (fxround height) 200))))
                (let ((matrix (make-translation-matrix (vertex x y 0.))))
                  (render-player~ message-player matrix)))))))))
    
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method (display-error msg)
    (display-message msg color: {Color Red}))
  
  
  (method (display-cancel msg)
    (display-message msg color: {Color Red})
    (signal-cancel))
  
  
  (method (display-walk-problems detail)
    (open-message (walk-problems-message detail)
                  caption: "Problems"
                  type: 'message
                  execute: (lambda (evt)
                             (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog)))
                               (close~ dialog)))))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method (display-status msg (color: color #f))
    (set! status msg)
    (set! status-color color)
    (set! status-time (current-seconds)))
  
  
  (method (draw-status)
    (let ((elapse (- (current-seconds) status-time))
          (fade 1.)
          (done 2.))
      (if (> elapse done)
          (begin
            (set! status #f)
            (set! status-time #f))
        (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f)))
          (let ((surface (get-surface~ (get-texture~ status-player)))
                (font {Font Status})
                (color (or status-color {Color World-Message})))
            (clear~ surface)
            (set-font~ surface font)
            (let ((color (if (not alpha)
                             color
                           (let ((color (copy-object~ color #f)))
                             (set-alpha~ color alpha)
                             color)))
                  (shadow-color (if (not alpha)
                                    {Color Black}
                                  (let ((color (copy-object~ {Color Black} #f)))
                                    (set-alpha~ color alpha)
                                    color))))
              (draw-text~ surface 0 0 status color shadow-color: shadow-color))
            (map-texture~ (get-texture~ status-player))
            (let ((w (text-width~ font status)))
              (let ((x (cast <fl> (center w (fxround width))))
                    (y 70.0))
                (let ((matrix (make-translation-matrix (vertex x y 0.))))
                  (render-player~ status-player matrix)))))))))))
