;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.live jazz


(import (jazz.debuggee)
        (jazz.designer)
        (jazz.development)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.autoload)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.jrm.protocol)
        (jazz.library)
        (jazz.library.component)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.skin)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.version)
        (time)
        (zlib)
        (world)
        (world.actor)
        (world.animation)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.block)
        (world.collision)
        (world.counter)
        (world.debug)
        (world.defaults)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.enemy)
        (world.entity)
        (world.external)
        (world.external.milkshape)
        (world.external.obj)
        (world.folio)
        (world.foreign)
        (world.foreign.obj)
        (world.gadget)
        (world.generate)
        (world.geometry)
        (world.gravity)
        (world.history)
        (world.homogeneous)
        (world.interface)
        (world.interface.actions)
        (world.interface.assets)
        (world.interface.bindings)
        (world.interface.character)
        (world.interface.counters)
        (world.interface.dialogs)
        (world.interface.documents)
        (world.interface.frame)
        (world.interface.host)
        (world.interface.info)
        (world.interface.inventory)
        (world.interface.main)
        (world.interface.menu)
        (world.interface.options)
        (world.interface.pane)
        (world.interface.popup)
        (world.interface.scripts)
        (world.interface.worlds)
        (world.interface.zones)
        (world.io)
        (world.light)
        (world.lookat)
        (world.mark)
        (world.material)
        (world.mesh)
        (world.model)
        (world.movement)
        (world.object)
        (world.opengl)
        (world.parameters)
        (world.plane)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.profiling)
        (world.programs)
        (world.quad)
        (world.render)
        (world.sector)
        (world.serialization)
        (world.settings)
        (world.shader)
        (world.shaders)
        (world.support)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile)
        (world.triangle)
        (world.user)
        (world.view)
        (world.window)
        (world.zone)
        (world.client.configuration)
        (world.client.window))


;;;
;;;; World
;;;


(class World extends Component
  
  
  (property title              <string+>         initialize #f              accessors generate)
  (property ambient-gravity    <f64vector>       initialize default-gravity accessors generate)
  (property jump-impulsion     <fl>              initialize default-jump    accessors generate)
  (property start-zone         <string+>         initialize #f              accessors generate)
  (property start-3d?          <bool>            initialize #t              accessors generate)
  (property start-grid?        <bool>            initialize #t              accessors generate)
  (property start-axes?        <bool>            initialize #f              accessors generate)
  (property default-image      <object>          initialize "dirty"         accessors generate)
  (property properties         <object>          initialize '()             accessors generate)
  
  
  (slot window                 <OpenGL-Window>   initialize #f              accessors generate)
  (slot width                  <fl>              initialize #f              accessors generate)
  (slot height                 <fl>              initialize #f              accessors generate)
  (slot boundaries             <f64vector+>      initialize #f              getter generate)
  (slot eye                    <f64vector>       initialize (make-vertex)   getter generate)
  (slot eye-target             <f64vector>       initialize (make-vertex)   getter generate)
  (slot eye-lookat             <LookAt>          initialize (make-lookat)   getter generate)
  (slot frustum-left           <f64vector>       initialize (make-vertex)   getter generate)
  (slot frustum-bottom         <f64vector>       initialize (make-vertex)   getter generate)
  (slot frustum-right          <f64vector>       initialize (make-vertex)   getter generate)
  (slot frustum-top            <f64vector>       initialize (make-vertex)   getter generate)
  (slot frustum-left-dot       <fl>              initialize 0.              getter generate)
  (slot frustum-bottom-dot     <fl>              initialize 0.              getter generate)
  (slot frustum-right-dot      <fl>              initialize 0.              getter generate)
  (slot frustum-top-dot        <fl>              initialize 0.              getter generate)
  (slot world-up               <f64vector>       initialize (make-vertex)   getter generate)
  (slot lighting?              <bool>            initialize #t              getter generate)
  (slot lightmaps?             <bool>            initialize #t              accessors generate)
  (slot shadowmaps?            <bool>            initialize #f              accessors generate)
  (slot mode                   <symbol>          initialize 'explore        getter generate)
  (slot what                   <object>          initialize #f              getter generate)
  (slot target                 <object>          initialize #f              getter generate)
  (slot target-polygon         <object>          initialize #f              getter generate)
  (slot target-face            <object>          initialize #f              getter generate)
  (slot target-face-rank       <fx+>             initialize #f              getter generate)
  (slot target-mode            <object>          initialize 'select         getter generate)
  (slot highlighted-polygons   <list>            initialize '()             getter generate)
  (slot last-point             <object>          initialize #f              getter generate)
  (slot last-time              <object>          initialize #f              getter generate)
  (slot last-recenter          <object>          initialize #f              getter generate)
  (slot camera-distance        <fl>              initialize 60.             getter generate)
  (slot polygon-mode           <fx>              initialize GL_FILL         getter generate)
  (slot window-cursor          <object>          initialize :arrow          getter generate)
  (slot earth?                 <bool>            initialize #t              getter generate)
  (slot interface?             <bool>            initialize #t              accessors generate)
  (slot explore-interface?     <bool>            initialize #f              accessors generate)
  (slot render-ready?          <bool>            initialize #f              accessors generate)
  (slot debugged?              <bool>            initialize #f              accessors generate)
  
  
  (slot version                <object>          initialize #f              getter generate)
  (slot projection             <symbol>          initialize 'orthographic   getter generate)
  (slot zoom-factor            <fl>              initialize 0.              getter generate)
  (slot desired-tilt           <fl>              initialize 0.              getter generate)
  (slot tilt-speed             <fl+>             initialize #f              getter generate)
  (slot last-tilt-time         <fl+>             initialize #f              getter generate)
  (slot 3d?                    <bool>            initialize #f              getter generate)
  (slot eye?                   <bool>            initialize #f              getter generate)
  (slot aim?                   <bool>            initialize #f              getter generate)
  (slot free-aim?              <bool>            initialize #f              getter generate)
  (slot viewing?               <bool>            initialize #f              getter generate)
  (slot moving?                <bool>            initialize #f              getter generate)
  (slot moved?                 <bool>            initialize #f              getter generate)
  (slot preserved-mouse        <object>          initialize #f              getter generate)
  (slot first-person?          <bool>            initialize #f              getter generate)
  (slot max-distance           <fl>              initialize 30.0            getter generate)
  (slot first-distance         <fl>              initialize 3.5             getter generate)
  (slot first-override         <fl+>             initialize #f              getter generate)
  (slot first-occlusion?       <bool>            initialize #f              getter generate)
  (slot first-camera           <object>          initialize #f              getter generate)
  (slot vehicle                <object>          initialize #f              getter generate)
  (slot mount?                 <bool>            initialize #f              getter generate)
  (slot mounts-folio           <Folio>           initialize #f              getter generate)
  (slot fly?                   <bool>            initialize #f              getter generate)
  (slot flyers-folio           <Folio>           initialize #f              getter generate)
  (slot draw-elements?         <bool>            initialize #t              getter generate)
  (slot draw-gadgets?          <bool>            initialize #f              getter generate)
  (slot draw-marks?            <bool>            initialize #t              getter generate)
  (slot draw-normals?          <bool>            initialize #f              getter generate)
  (slot draw-atlas?            <bool>            initialize #f              accessors generate)
  (slot draw-actors-history?   <bool>            initialize #t              getter generate)
  (slot draw-procedures        <object>          initialize '()             getter generate)
  (slot view-distance          <fx>              initialize 7               getter generate)
  (slot view-radius            <fl>              initialize #f              accessors generate)
  (slot idle-rendering         <fx>              initialize #f              accessors generate)
  (slot buzy-rendering         <fx>              initialize #f              accessors generate)
  (slot perspective-fov        <fl>              initialize 45.             accessors generate)
  (slot perspective-near       <fl>              initialize 0.1             accessors generate)
  (slot perspective-far        <fl>              initialize 10000.0         accessors generate)
  (slot dynamic-lights         <fx>              initialize 8               getter generate)
  (slot post-processing?       <bool>            initialize #t              getter generate)
  (slot track-sensitivity      <fl>              initialize 200.            getter generate)
  (slot axes?                  <bool>            initialize #f              accessors generate)
  (slot tick-slice?            <bool>            initialize #t              getter generate)
  (slot tick-pulse             <object>          initialize #f              getter generate)
  (slot last-tick              <fl>              initialize #f              getter generate)
  (slot down?                  <bool>            initialize #f              getter generate)
  (slot down-point             <object>          initialize #f              getter generate)
  (slot drag-tolerance         <object>          initialize 3               getter generate)
  (slot idle?                  <bool>            initialize #t              getter generate)
  (slot paused?                <bool>            initialize #f              getter generate)
  (slot counters               <object>          initialize #f              getter generate)
  (slot tick-procedures        <object>          initialize '()             getter generate)
  (slot tick-no                <object>          initialize 0               getter generate)
  (slot commands               <object>          initialize #f              getter generate)
  (slot base-assets            <object>          initialize #f              getter generate)
  (slot world-assets           <object>          initialize #f              getter generate)
  (slot user-assets            <object>          initialize #f              getter generate)
  (slot all-assets             <object>          initialize #f              getter generate)
  (slot textures               <object>          initialize #f              getter generate)
  (slot models                 <object>          initialize #f              getter generate)
  (slot last-model             <object>          initialize #f              getter generate)
  (slot newable?               <bool>            initialize #f              accessors generate)
  (slot writable?              <bool>            initialize #f              accessors generate)
  (slot music?                 <bool>            initialize #f              getter generate)
  (slot gc-sound?              <bool>            initialize #f              getter generate)
  (slot history?               <bool>            initialize #t              getter generate)
  (slot history                <object>          initialize #f              getter generate)
  (slot message                <object>          initialize #f              getter generate)
  (slot message-time           <object>          initialize #f              getter generate)
  (slot message-color          <object>          initialize #f              getter generate)
  (slot message-texture        <object>          initialize #f              getter generate)
  (slot status                 <object>          initialize #f              getter generate)
  (slot status-time            <object>          initialize #f              getter generate)
  (slot status-color           <object>          initialize #f              getter generate)
  (slot status-texture         <object>          initialize #f              getter generate)
  (slot information            <object>          initialize #f              getter generate)
  (slot interface              <World-Interface> initialize #f              getter generate)
  (slot interface-refresh-rate <fl>              initialize #f              getter generate)
  (slot interface-last-time    <fl>              initialize #f              getter generate)
  (slot last-script            <object>          initialize #f              getter generate)
  
  ;; Shader programs
  (slot mesh-programs          <object>          initialize #f              accessors generate)
  (slot tile-atlas             <object>          initialize #f              accessors generate)
  (slot tile-texture           <object>          initialize #f              accessors generate)
  (slot tile-material          <object>          initialize #f              accessors generate)
  (slot tile-mesh              <object>          initialize #f              accessors generate)
  (slot tile-matrix            <object>          initialize #f              accessors generate)
  (slot tile-program           <object>          initialize #f              accessors generate)
  (slot tile-program-folio     <object>          initialize #f              accessors generate)
  (slot tile-program-atlas?    <bool>            initialize #t              accessors generate)
  @wait
  (slot pp-program             <object>          initialize #f              accessors generate)
  
  ;; Render targets
  (slot render-target          <object>          initialize #f              accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition max-dynamic-lights
    8)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-current-world self)
    (set! view-distance (find-setting 'world.view-distance 7))
    (set! view-radius 200.)
    (set! idle-rendering (find-setting 'world.idle-rendering 5))
    (set! buzy-rendering (find-setting 'world.buzy-rendering 2))
    (set! perspective-fov (find-setting 'world.perspective-fov 45.))
    (set! perspective-near (find-setting 'world.perspective-near 0.1))
    (set! perspective-far (find-setting 'world.perspective-far 10000.0))
    (set! dynamic-lights (min max-dynamic-lights (find-setting 'world.dynamic-lights 8)))
    (set! earth? (find-setting 'world.earth? #t))
    (set! lightmaps? #f @temporary (find-setting 'world.lightmaps? #t))
    (set! shadowmaps? #f @temporary (find-setting 'world.shadowmaps? #f))
    (set! draw-actors-history? (find-setting 'world.actors-history? #t))
    (set! track-sensitivity (find-setting 'world.track-sensitivity 200.))
    (set! post-processing? (find-setting 'world.post-processing? #t))
    (set! interface? (world-setting 'world.start-interface? #t 'default))
    (set! gc-sound? (world-setting 'world.gc-sound? #f 'default))
    (set! history? (find-setting 'world.history? #t))
    (set! evaluate-future? (find-setting 'world.evaluate-future? #t))
    (set! free-aim? (find-setting 'world.free-aim? #f))
    (set-animations? (world-setting 'world.animations? (>= (glGetInteger* GL_MAX_VERTEX_UNIFORM_COMPONENTS) 4096) 'default))
    (set-debug-collisions? (find-setting 'world.debug-collisions? #f))
    (set-collide-max-slide (find-setting 'world.collide-max-slide 5)))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (update-world-up ambient-gravity)
    (when music?
      (change-music)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method (setup-opengl)
    (let ((size (get-size~ window)))
      (set! width (cast <fl> (get-width~ size)))
      (set! height (cast <fl> (get-height~ size))))
    (glFrontFace GL_CW)
    (glPolygonMode GL_FRONT GL_FILL)
    (glMatrixMode GL_MODELVIEW)
    (glEnable GL_NORMALIZE)
    (glEnable GL_LINE_SMOOTH)
    (initialize-camera)
    (prepare-assets)
    (prepare-modules)
    (prepare-models)
    (prepare-textures)
    (prepare-shaders)
    (prepare-editor)
    (initialize-render)
    (reset-commands)
    (gl-check-error))
  
  
  (method (start-world)
    (prepare-tick))
  
  
  (method (initialize-render)
    (when (get-framebuffer-objects?)
      (set! render-target (new Render-Target (fxround width) (fxround height) multisample?: #t))))
  
  
  (method (update-world-up gravity)
    (vertex-copy! world-up (gravity-up gravity)))
  
  
  (method (reset-commands)
    (when (or (not commands) (get-modified?~ commands))
      (set! commands (new Commands)))
    (set-last-no~ commands tick-no)
    (increase! tick-no))
  
  
  (method (reset-last-tick)
    (set! last-tick (current-seconds)))
  
  
  (method (setup-world)
    (reset-last-tick)
    (set! paused? #f))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (method (prepare-assets)
    (define (gather-assets dir)
      (let ((queue (new-queue)))
        (define (try dir)
          (when (exists?~ (new-file~ dir ".assets"))
            (enqueue queue dir)))
        
        (when (and dir (exists?~ dir))
          (try dir)
          (iterate-directory~ dir
            try
            files?: #f
            directories?: #t))
        (queue-list queue)))
    
    (let ((world-directory (get-world-directory)))
      (set! base-assets (gather-assets (new Directory (cons (world-alias) '("lib" "world.client" "assets")))))
      (set! world-assets (gather-assets (and world-directory (new-directory~ world-directory "assets"))))
      (set! user-assets (gather-assets (and (find-setting 'world.user-assets? #t) {Directory Settings "assets"})))
      (set! all-assets (remove-false (append user-assets world-assets base-assets)))))
  
  
  ;; quick solution to loading the same world more than once
  (definition installed-modules
    '())
  
  
  (method (prepare-modules)
    (for-each (lambda (assets)
                (let ((module-dir (new-directory~ assets "module")))
                  (when (exists?~ module-dir)
                    (let ((module-dirname (parse~ module-dir)))
                      (unless (member? module-dirname installed-modules test: filename=?)
                        (install-repository module-dirname)
                        (set! installed-modules (cons module-dirname installed-modules)))))))
              all-assets))
  
  
  (method (prepare-textures)
    (set! message-texture (make-cairo-texture 800 100))
    (set! status-texture (make-cairo-texture 800 35)))
  
  
  (method protected virtual (prepare-tile (adder: adder #f))
    (define (make-tile-atlas)
      (let ((atlas (new Atlas)))
        (for-each (lambda (assets)
                    (add-directory-if-exists~ atlas (new-directory~ assets "tile")))
                  all-assets)
        (when adder
          (adder atlas))
        (complete~ atlas)
        atlas))
    
    (when (or (not tile-atlas) adder)
      (set! tile-atlas (make-tile-atlas))
      (set! tile-texture (find-texture "dirty.png"))
      (set! tile-material (new Material texture: (get-texture~ tile-atlas)))
      (set! tile-mesh (new Mesh material: tile-material))
      (set! tile-matrix (make-identity-matrix))))
  
  
  ;;;
  ;;;; Models
  ;;;
  
  
  (method (prepare-models)
    (set! models (make-table test: equal?)))
  
  
  ;;;
  ;;;; Shaders
  ;;;
  
  
  (method (prepare-shaders)
    ;; shaders
    (setup-phong-shaders (get-texture-arrays?))
    
    ;; mesh
    (set! mesh-programs (make-table test: eq?))
    (table-set! mesh-programs 'color          (new Mesh-Color-Program))
    (table-set! mesh-programs 'dynamic-phong  (new Mesh-Dynamic-Phong-Program))
    (table-set! mesh-programs 'phong          (new Mesh-Phong-Program))
    (table-set! mesh-programs 'wireframe      (new Mesh-Wireframe-Program))
    (table-set! mesh-programs 'radial-blur    (new Mesh-Radial-Blur-Program))
    (table-set! mesh-programs 'motion-blur    (new Mesh-Motion-Blur-Program))
    (table-set! mesh-programs 'water          (new Mesh-Water-Program))
    (table-set! mesh-programs 'julia          (new Mesh-Julia-Program))
    (table-set! mesh-programs 'sierpinski     (new Mesh-Sierpinski-Program))
    (table-set! mesh-programs 'multitexture   (new Mesh-Multitexture-Program))
    (table-set! mesh-programs 'kaleidoscope   (new Mesh-Kaleidoscope-Program))
    (table-set! mesh-programs 'tunnel         (new Mesh-Tunnel-Program))
    (table-set! mesh-programs 'square-tunnel  (new Mesh-Square-Tunnel-Program))
    (table-set! mesh-programs 'fly            (new Mesh-Fly-Program))
    (table-set! mesh-programs 'pulse          (new Mesh-Pulse-Program))
    
    ;; animation
    (when (get-animations?)
      (table-set! mesh-programs 'skeletal-phong (new Mesh-Skeletal-Phong-Program)))

    ;; tile
    (set! tile-program (find-mesh-program (or (find-setting 'world.tile-shader #f) 'phong)))
    (set! tile-program-folio (new Folio 'phong '(phong wireframe radial-blur motion-blur water julia sierpinski multitexture kaleidoscope tunnel square-tunnel fly @buggy pulse)))
    (set! tile-program-atlas? (is-not? tile-program Mesh-Transformation-Program))
    
    ;; pp
    @wait
    (when (get-framebuffer-objects?)
      (set! pp-program (new PP-Program)))
    
    (gl-check-error))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))


  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (when render-target
      (free-resources~ render-target))
    (detach-shaders~ tile-program)
    @wait
    (when pp-program
      (detach-shaders~ pp-program))
    (glDeleteTextures* (get-id~ message-texture))
    (glDeleteTextures* (get-id~ status-texture))
    (close-music "ambiance")
    (close~ tick-pulse))
  
  
  (method public (toggle-gc-sound)
    (set! gc-sound? (not gc-sound?))
    (display-on/off "GC sound" gc-sound?))
  
  
  (method public (garbage-collect)
    (let ((window (current-world-window)))
      (display-message "Garbage collecting")
      (render-scene~ window)
      (gc)
      (gc)
      (display-message "Done" color: {Color Green})
      (render-scene~ window)))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method protected virtual (initialize-world)
    (set! version world-version)
    (set! first-camera 'free)
    (set! grid? start-grid?)
    (set! axes? start-axes?)
    (cond (start-3d?
           (activate-3d))
          (else
           (set! camera-distance 0.6)
           (set! first-distance 7.5)
           (set! editor-mode 'point)))
    (setup-interface)
    (setup-history)
    (setup-gc)
    (update-title))
  
  
  (method (setup-interface)
    (set! interface (new World-Interface))
    (set! interface-refresh-rate (find-setting 'world.interface-refresh-rate 1.))
    (set! interface-last-time -inf.0)
    (new Info-Pane parent: interface name: 'info size: {Dimension 400 1200} location: 'head visible?: #f)
    (new Counters-Pane parent: interface name: 'counters size: {Dimension 400 106} location: '(head -69) visible?: #f)
    (new Character-Pane parent: interface name: 'character size: {Dimension 200 50} location: '(10 10) visible?: #f)
    (set! counters (make-table test: eq?))
    (add-counter 'latency (new Counter title: "Latency"))
    (add-counter 'render (new Counter title: "Render"))
    (add-counter 'tick (new Counter title: "Tick"))
    (add-counter 'memory (new Counter title: "Memory" kind: 'frequency))
    (setup-application-interface~ (get-application))
    (set-root~ window interface offscreen?: #f))
  
  
  (method (is-active?)
    (eq? self (current-world)))
  
  
  (method (is-inactive?)
    (not (is-active?)))
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method (zone-update)
    (enter-zone~ (get-process))
    (set! mounts-folio (new Folio 'wheels '(wheels)))
    (set! flyers-folio (new Folio 'saucer '(saucer)))
    ;; add player when not connected to server
    (when (and (client-side?~ (get-application)) (not (get-world-server~ (get-application))))
      (let ((zone (current-zone)))
        ;; mode
        (let ((start-mode (or (get-start-mode~ zone) 'free-camera)))
          (when (eq? start-mode 'first-person)
            (set! first-person? #t)))
        ;; camera
        (let ((eye (or (get-start-eye~ zone) default-start-eye))
              (eye-sight (or (get-start-eye-sight~ zone) default-start-eye-sight))
              (eye-up (or (get-start-eye-up~ zone) default-start-eye-up)))
          (set-eye eye)
          (set-sight~ eye-lookat eye-sight)
          (set-up~ eye-lookat eye-up)
          (set-right~ eye-lookat (cross-normal& eye-sight eye-up))
          (update-eye-target))
        ;; player
        (let ((position (or (get-start-position~ zone) default-start-position))
              (sight (or (get-start-sight~ zone) default-start-sight))
              (up (or (get-start-up~ zone) default-start-up)))
          (let ((player (new (player-class) name: (effective-player-name~ (get-application)) position: position)))
            (let ((lookat (get-lookat~ player)))
              (set-sight~ lookat sight)
              (set-up~ lookat up)
              (set-right~ lookat (cross-normal& sight up)))
            (add-element~ zone player)
            (set-current-me player))))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (prepare-tick)
    (set! tick-slice? (and (not debug-user?) (not (find-setting 'world.inhibit-slicing? #f))))
    (set! tick-pulse (new Pulse 'tick (find-setting 'world.tick-pulse .01) (lambda () (profiling 'tick (lambda () (tick-world)))))))
  
  
  (method (tick-world)
    (unless (or debugged? paused? (is-inactive?) (not render-ready?))
      (let ((zone (current-zone))
            (me (current-me)))
        (let ((seconds (current-seconds)))
          (let ((elapse (- seconds last-tick))
                (process (get-process)))
            (set! last-tick seconds)
            (when history?
              (add-history elapse))
            (when (get-sun-cycle?~ zone)
              (tick-sun~ zone elapse))
            (complete~ commands)
            (if (client-side?~ process)
                (if (not (get-world-server~ process))
                    (tick-actors commands elapse)
                  (when (get-modified?~ commands)
                    (tick-server~ (get-process) commands elapse)))
              (tick-sliced me commands elapse))
            (reset-commands)
            (when (not-null? tick-procedures)
              (for-each (lambda (proc)
                          (proc elapse))
                        tick-procedures))
            (restore-first-distance elapse)
            (process-tilt me))))))
  
  
  (method (tick-actors commands elapse)
    (let ((counter (find-counter 'tick)))
      (start~ counter)
      (let ((me (current-me)))
        (unless (get-state~ me)
          (let ((zone (current-zone)))
            (for-each (lambda (actor)
                        (tick-sliced actor commands elapse))
                      (get-actors~ zone)))))
      (end~ counter)))
  
  
  (method (reset-tick-procedures)
    (set! tick-procedures '()))
  
  
  (method (register-tick proc)
    (set! tick-procedures (cons proc tick-procedures)))
  
  
  (method (unregister-tick proc)
    (set! tick-procedures (remove! proc tick-procedures)))
  
  
  (method (world-update players)
    (let ((me (current-me)))
      (when (find-setting 'world.client.debug? #f)
        (terminal (effective-player-name~ (get-application)) 'world-update players))
      (for-each (lambda (info)
                  (bind (player-name player-avatar player-position player-sight player-up player-right) info
                    (let ((player (find-named-player player-name)))
                      (if (not player)
                          (add-player player-name player-avatar player-position player-sight player-up player-right)
                        (let ((lookat (get-lookat~ player)))
                          (let ((in-sync? (and (vertex=? (get-position~ player) player-position)
                                               (vertex=? (get-sight~ lookat) player-sight)
                                               (vertex=? (get-up~ lookat) player-up)
                                               (vertex=? (get-right~ lookat) player-right))))
                            (when (not in-sync?)
                              (set-position~ player player-position)
                              (set-sight~ lookat player-sight)
                              (set-up~ lookat player-up)
                              (set-right~ lookat player-right)
                              (when (eq? player me)
                                (camera-behind-player)
                                (follow-player)))))))))
                players)
      (when (find-setting 'world.client.debug? #f)
        (debug-players))))
  
  
  (method (world-enter player-name player-avatar player-position player-lookat)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-enter player-name player-avatar player-position player-lookat))
    (bind (sight up right) player-lookat
      (add-player player-name player-avatar player-position sight up right))
    (display-message (format "{a} entered world" player-name))
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (method (add-player player-name player-avatar player-position player-sight player-up player-right)
    (let ((zone (current-zone)))
      (let ((player (new (player-class) name: player-name position: (vertex 0. 0. 0.))))
        (set-position~ player player-position)
        (let ((lookat (get-lookat~ player)))
          (set-sight~ lookat player-sight)
          (set-up~ lookat player-up)
          (set-right~ lookat player-right))
        (when player-avatar
          (if (dye? player-avatar)
              (set-color~ player player-avatar)
            (set-avatar~ player player-avatar)))
        (add-element~ zone player)
        (when (and (client-side?~ (get-process)) (equal? player-name (get-player-name~ (get-process))))
          (set-current-me player)
          (camera-behind-player)
          (follow-player)))))
  
  
  (method (world-exit player-name)
    (when (find-setting 'world.client.debug? #f)
      (terminal (effective-player-name~ (get-application)) 'world-exit player-name))
    (let ((player (find-named-player player-name)))
      (when player
        (remove-element player))
      (when (and (client-side?~ (get-process)) (equal? player-name (get-player-name~ (get-process))))
        (set-current-me #f))
      (display-message (format "{a} exited world" player-name)))
    (when (find-setting 'world.client.debug? #f)
      (debug-players)))
  
  
  (definition empty-commands
    (let ((commands (new Commands)))
      (complete~ commands)
      commands))
  
  
  (method (server-tick player-commands elapse)
    (let ((zone (current-zone))
          (me (current-me)))
      (unless (null? player-commands)
        (when (find-setting 'world.client.debug? #f)
          (terminal (effective-player-name~ (get-application)) 'server-tick player-commands elapse)))
      (let ((counter (find-counter 'latency)))
        (start~ counter)
        (unless (get-state~ me)
          (for-each (lambda (actor)
                      (let ((name (and (is? actor Player) (get-name~ actor))))
                        (let ((pair (and name (assoc name player-commands))))
                          (let ((commands (if pair (deserialize-commands (cdr pair)) empty-commands)))
                            (tick-sliced actor commands elapse)))))
                    (get-actors~ zone)))
        (end~ counter))
      (unless (null? player-commands)
        (when (find-setting 'world.client.debug? #f)
          (debug-players)))))
  
  
  (method (tick-sliced actor commands elapse)
    (declare (proper-tail-calls))
    (parameterize ((ticked-actor actor))
      (tick-actions~ actor commands)
      (continuation-capture
        (lambda (exit)
          (let ((slice (if (is? actor Player) .01 .05)))
            (if (or (<= elapse slice) (not tick-slice?))
                (tick~ actor commands elapse exit)
              @debug
              (when (> elapse 1.)
                (terminal 'elapse elapse))
              (let (iter (from 0.) (to slice))
                (tick~ actor commands (- to from) exit)
                (when (< to elapse)
                  (iter to (min elapse (+ to slice)))))))))))
  
  
  (method (server-test argument)
    (1)
    (debug 'server-test)
    argument)
  
  
  (method (debug-players)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (unless (equal? (get-name~ player) "Server")
                    (terminal '->
                              (get-name~ player)
                              (get-position~ player)
                              (present-vertex (get-sight~ (get-lookat~ player))))))
                (get-players~ zone))))

  
  ;;;
  ;;;; Circularity
  ;;;
  
  
  ;; quick hacks around circular dependencies
  (method (polygon-class)
    Polygon)
  (method (triangle-class)
    Triangle)
  (method (quad-class)
    Quad)
  (method (missile-class)
    Missile)

  
  ;;;
  ;;;; Events
  ;;;
  
  
  ;; Interface
  (method (on-main-menu evt)
    (main-menu))
  
  (method (on-video-options evt)
    (video-options))
  
  (method (on-audio-options evt)
    (audio-options))
  
  (method (on-interface-options evt)
    (interface-options))
  
  (method (on-view-bindings evt)
    (view-bindings))
  
  (method (on-view-news evt)
    (view-news))
  
  (method (on-view-roadmap evt)
    (view-roadmap))
  
  (method (on-view-help evt)
    (view-help))
  
  (method (on-toggle-mode evt)
    (toggle-mode))
  
  (method (on-toggle-interface evt)
    (toggle-interface))
  
  (method (on-toggle-counters evt)
    (toggle-counters))
  
  (method (on-reset-counters evt)
    (reset-counters)
    (display-message "Counters reset"))
  
  (method (on-exit-world evt)
    (exit-process~ (get-application)))
  
  (method (on-resume-world evt)
    (close-current-popup))
  
  (method (on-change-tile-texture evt)
    (change-tile-texture reversed?: (effective-event-reversed? evt)))
  
  (method (on-change-tile-program evt)
    (change-tile-program reversed?: (effective-event-reversed? evt)))

  (method (on-select/run-script evt)
    (select/run-script))

  (method (on-run-last-script evt)
    (run-last-script))
  
  
  ;; Graphics
  (method (on-toggle-lighting evt)
    (toggle-lighting))
  
  (method (on-toggle-projection evt)
    (toggle-projection))
  
  (method (on-toggle-draw-gadgets evt)
    (toggle-draw-gadgets))
  
  (method (on-toggle-draw-normals evt)
    (toggle-draw-normals))
  
  (method (on-toggle-draw-elements evt)
    (toggle-draw-elements))
  
  (method (on-toggle-post-processing evt)
    (toggle-post-processing))
  
  
  ;; Sounds
  (method (on-change-music evt)
    (change-music))
  
  
  ;; Server
  (method (on-connect-to-server evt)
    (connect-to-server))
  
  (method (on-disconnect-from-server evt)
    (disconnect-from-server))
  
  (method (on-request-server-update evt)
    (request-server-update))
  
  
  ;; World
  (method (on-world-new evt)
    (world-new))
  
  (method (on-world-open evt)
    (world-open))
  
  (method (on-world-save evt)
    (world-save))
  
  (method (on-world-save-as evt)
    (world-save-as))
  
  (method (on-world-revert evt)
    (world-revert))
  
  
  ;; Zone
  (method (on-zone-new evt)
    (zone-new))
  
  (method (on-zone-open evt)
    (zone-open))
  
  (method (on-zone-save evt)
    (zone-save))
  
  (method (on-zone-save-as evt)
    (zone-save-as))
  
  (method (on-save-player&camera evt)
    (save-player&camera))
  
  (method (on-zone-revert evt)
    (zone-revert))
  
  
  ;; Game
  (method (on-mind-control evt)
    (mind-control))
  
  (method (on-toggle-aim evt)
    (toggle-aim))
  
  (method (on-toggle-free-aim evt)
    (toggle-free-aim))
  
  (method (on-toggle-mount evt)
    (toggle-mount))
  
  (method (on-toggle-fly evt)
    (toggle-fly))
  
  (method (on-character-pane evt)
    (character-pane))
  
  
  ;; Camera
  (method (on-toggle-first-person evt)
    (toggle-first-person))
  
  (method (on-toggle-3d evt)
    (toggle-3d))
  
  (method (on-toggle-camera-lock evt)
    (toggle-camera-lock))
  
  
  ;; Movement
  
  
  ;; Edition
  (method (on-import-model evt)
    (import-model))
  
  (method (on-add-last-model evt)
    (add-last-model))
    
  (method (on-change-target-animation evt)
    (change-target-animation reversed?: (effective-event-reversed? evt)))
  
  (method (on-remove-target evt)
    (remove-target))
  
  (method (on-toggle-grid evt)
    (toggle-grid))
  
  (method (on-toggle-grid-plane evt)
    (toggle-grid-plane (get-property~ evt plane:)))
  
  (method (on-decrease-grid evt)
    (decrease-grid))
  
  (method (on-increase-grid evt)
    (increase-grid))
  
  (method (on-change-element-class evt)
    (change-element-class reversed?: (effective-event-reversed? evt)))
  
  (method (on-change-texture evt)
    (change-texture reversed?: (effective-event-reversed? evt)))
  
  (method (on-reload-textures evt)
    (reload-textures)
    (display-message "Textures reloaded"))
  
  (method (on-select-brush evt)
    (select-brush))
  
  (method (on-toggle-brush-mode evt)
    (toggle-brush-mode))
  
  (method (on-change-editor-mode evt)
    (change-editor-mode reversed?: (effective-event-reversed? evt)))
  
  (method (on-change-target-mode evt)
    (change-target-mode reversed?: (effective-event-reversed? evt)))
  
  (method (on-select-template evt)
    (select-template))
  
  (method (on-toggle-template-mode evt)
    (toggle-template-mode))
  
  (method (on-change-skybox evt)
    (change-skybox~ (current-zone) reversed?: (effective-event-reversed? evt)))
  
  
  ;; History
  (method (on-toggle-paused evt)
    (toggle-paused))
  
  (method (on-backward-history evt)
    (backward-history))
  
  (method (on-forward-history evt)
    (forward-history))
  
  (method (on-step-world evt)
    (step-world))
  
  (method (on-toggle-history evt)
    (toggle-history))
  
  (method (on-reset-history evt)
    (reset-history))
  
  (method (on-toggle-evaluate-future evt)
    (toggle-evaluate-future))
  
  
  ;; Window
  (method (on-toggle-windowed-mode evt)
    (toggle-windowed-mode))
  
  (method (on-live-gaia/world evt)
    (live-gaia/world))
  
  (method (on-design-gaia/world evt)
    (design-gaia/world))
  
  (method (on-restore-gaia/world evt)
    (restore-gaia/world))


  ;; Debug
  (method (on-toggle-axes evt)
    (toggle-axes))
  
  (method (on-toggle-info evt)
    (toggle-info))
  
  (method (on-toggle-eye evt)
    (toggle-eye))
  
  (method (on-toggle-debug-sectors evt)
    (toggle-debug-sectors~ (current-zone)))
  
  (method (on-toggle-debug-areas evt)
    (toggle-debug-areas~ (current-zone)))
  
  (method (on-toggle-draw-atlas evt)
    (toggle-draw-atlas))
  
  (method (on-toggle-draw-me evt)
    (toggle-draw-me))
  
  (method (on-change-missile-behavior evt)
    (change-missile-behavior reversed?: (effective-event-reversed? evt)))
  
  (method (on-reset-marks evt)
    (reset-all-marks~ (current-zone)))
  
  (method (on-clear-console evt)
    (if (get-controller-debugger)
        (clear-console)
      (display-error "Not connected to a debugger")))
  
  (method (on-clear-terminal evt)
    (clear-terminal))
  
  (method (on-toggle-gc-sound evt)
    (toggle-gc-sound))

  (method (on-garbage-collect evt)
    (garbage-collect))

  (method (on-explore-interface evt)
    (explore-interface))
  
  (method (on-remove-duplicate-blocks~ evt)
    (remove-duplicate-blocks~ (current-zone)))
  
  (method (on-test1 evt)
    (test1))

  (method (on-test2 evt)
    (test2))

  (method (on-test3 evt)
    (test3))

  (method (on-test4 evt)
    (test4))

  (method (on-test5 evt)
    (test5))

  (method (on-test6 evt)
    (test6))

  (method (on-test7 evt)
    (test7))

  (method (on-test8 evt)
    (test8))

  (method (on-test9 evt)
    (test9))

  (method (on-test0 evt)
    (test0))
  
  
  ;; Collision
  (method (on-setup-collisions evt)
    (set! evaluate-future? #f)
    (set! tick-slice? #f)
    (set! camera-move-speed 0.05)
    (set! camera-strafe-speed 0.02)
    (set! camera-rotate-speed 0.02)
    (set-debug-collisions? #t)
    (when (shift-down?)
      (execute-script "world/generate/stairs"))
    (display-message "Collisions setup"))
  
  (method (on-toggle-debug-collisions evt)
    (set-debug-collisions? (not (get-debug-collisions?)))
    (update-parameter 'debug-collisions)
    (display-on/off "Debug collisions" (get-debug-collisions?)))
  
  (method (on-toggle-radiuses evt)
    (execute-script "world/collision/toggle-radiuses"))
  
  
  ;; Utility
  (method (effective-event-reversed? evt)
    (shift-down?))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (setup-history)
    (set! history (new History (find-setting 'world.history-max 500))))
  
  
  (method (historical-moment n)
    (historical-moment~ history n))
  
  
  (method (add-history elapse)
    (receive (metadata snapshot) (metadata-snapshot-world)
      (let ((moment (new Moment metadata snapshot (object-copy commands) elapse)))
        (add-history~ history moment))))
  
  
  (method (backward-history)
    (backward-history~ history))
  
  
  (method (forward-history)
    (forward-history~ history))
  
  
  (method (slide-history where)
    (slide-history~ history where))
  
  
  (method (truncate-future)
    (truncate-future~ history))
  
  
  (method (toggle-history)
    (set! history? (not history?))
    (when (not history?)
      (setup~ history))
    (update-parameter 'history)
    (display-on/off "History" history?))
  
  
  (method (reset-history)
    (setup~ history)
    (display-message "History reset"))
  
  
  (method (step-world)
    (step-world~ history))
  
  
  (method (recalculate-future)
    (recalculate-future~ history))
  
  
  (method (update-future)
    (when (and history? paused?)
      (recalculate-future)))
  
  
  (method (toggle-evaluate-future)
    (set! evaluate-future? (not evaluate-future?))
    (update-parameter 'evaluate-future)
    (display-on/off "Evaluate future" evaluate-future?))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method (process-idleness flag)
    (set! idle? flag)
    (when idle?
      (idle)))
  
  
  (method (idle)
    (let ((me (current-me)))
      (when (and first-person? (not paused?))
        (idle~ me))))
  
  
  (method (move-forward)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (move-up~ me commands)
        (vertex-copy! eye (vertex+& eye (vertex-scalar*& (get-sight~ eye-lookat) (get-camera-move-speed))))
        (update-eye-target))))
  
  
  (method (move-backward)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (move-down~ me commands)
        (vertex-copy! eye (vertex+& eye (vertex-scalar*& (get-sight~ eye-lookat) (- (get-camera-move-speed)))))
        (update-eye-target))))
  
  
  (method (blink-forward)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (blink-forward~ me commands)
        (vertex-copy! eye (vertex+& eye (vertex-scalar*& (get-sight~ eye-lookat) (get-camera-move-speed))))
        (update-eye-target))))
  
  
  (method (blink-backward)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (blink-backward~ me commands)
        (vertex-copy! eye (vertex+& eye (vertex-scalar*& (get-sight~ eye-lookat) (- (get-camera-move-speed)))))
        (update-eye-target))))
  
  
  (method (strafe-left)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (strafe-left~ me commands)
        (strafe-horizontally (- (* (get-camera-strafe-speed) 2))))))
  
  
  (method (strafe-right)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (strafe-right~ me commands)
        (strafe-horizontally (* (get-camera-strafe-speed) 2)))))
  
  
  (method (strafe-horizontally d)
    (vertex-copy! eye (vertex+& eye (vertex-scalar*& (get-right~ eye-lookat) d)))
    (update-eye-target))
  
  
  (method (strafe-up)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (strafe-up~ me commands)
        (vertex-copy! eye (vertex+& eye (vertex-scalar*& (get-up~ eye-lookat) (* (get-camera-strafe-speed) 2))))
        (update-eye-target))))
  
  
  (method (strafe-down)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (strafe-down~ me commands)
        (vertex-copy! eye (vertex+& eye (vertex-scalar*& (get-up~ eye-lookat) (- (* (get-camera-strafe-speed) 2)))))
        (update-eye-target))))
  
  
  (method (rotate-left)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (rotate-left~ me commands)
        (rotate-horizontal (get-camera-rotate-speed)))))
  
  
  (method (rotate-right)
    (let ((me (current-me)))
      (if (and first-person? (not paused?))
          (rotate-right~ me commands)
        (rotate-horizontal (- (get-camera-rotate-speed))))))
  
  
  (method (rotate-horizontal angle)
    (rotate-lookat! eye-lookat angle world-up)
    (update-eye-target))
  
  
  (method (rotate-up)
    @wrong-number-of-parameters???
    (rotate-vertical (get-camera-rotate-speed) (get-right~ eye-lookat) (get-sight~ eye-lookat)))
  
  
  (method (rotate-down)
    (rotate-vertical (- (get-camera-rotate-speed))))
  
  
  (method (rotate-vertical angle)
    (rotate-lookat-vertical-up! eye-lookat angle world-up)
    (update-eye-target))
  
  
  (method (rotate-vertical-up angle up)
    (rotate-lookat-vertical-up! eye-lookat angle up)
    (update-eye-target))
  
  
  (method (move-left)
    (let ((me (current-me)))
      (move-left~ me commands)))
  
  
  (method (move-right)
    (let ((me (current-me)))
      (move-right~ me commands)))
  
  
  (method (move-down)
    (let ((me (current-me)))
      (move-down~ me commands)))
  
  
  (method (move-up)
    (let ((me (current-me)))
      (move-up~ me commands)))
  
  
  (method (space)
    (let ((me (current-me)))
      (if (and (or first-person? (not 3d?)))
          (space~ me commands)
        (strafe-up))))
  
  
  ;;;
  ;;;; Game
  ;;;
  
  
  (method (fire kind)
    (let ((me (current-controlled)))
      (when (and first-person? (not paused?))
        (fire~ me commands kind))))
  
  
  (method (maybe-fire kind)
    (let ((me (current-controlled)))
      (when (and first-person? (not paused?))
        (maybe-fire~ me commands kind))))
  
  
  (method (maybe-rapid-fire)
    (rapid-fire))
  
  
  (method (rapid-fire)
    (add-action~ commands 'rapid-fire '()))
  
  
  (method (on-warp evt)
    (warp))
  
  
  (method (warp (reversed? #f))
    (let ((me (current-controlled)))
      (if (not first-person?)
          (begin
            (vertex+! eye eye (vertex-scalar*& (get-sight~ eye-lookat) (if reversed? -5. 5.)))
            (update-eye-target))
        (warp~ me reversed?))))
  
  
  (method (on-sprint evt)
    (let ((me (current-controlled)))
      (sprint~ me)))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method (prepare-projection)
    (let ((ratio (/ width height)))
      (glMatrixMode GL_PROJECTION)
      (glLoadIdentity)
      (case projection
        ((perspective)
         (gluPerspective perspective-fov ratio perspective-near perspective-far))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (glOrtho (- width) width (- height) height perspective-near perspective-far)))))))
  
  
  (method (activate-perspective)
    (set! projection 'perspective))
  
  
  (method (activate-orthographic)
    (standardize-lookat! eye-lookat)
    (update-eye-target)
    (set! editor-mode 'point)
    (set! projection 'orthographic))
  
  
  (method (toggle-projection)
    (case projection
      ((perspective) (activate-orthographic))
      ((orthographic) (activate-perspective)))
    (display-message (format "Projection {a}" projection)))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (definition camera-limit <fl>
    5.)
  
  
  (slot camera-move-speed   <fl> initialize .2 accessors generate)
  (slot camera-strafe-speed <fl> initialize 0.1 accessors generate)
  (slot camera-rotate-speed <fl> initialize 0.03 accessors generate)
  
  
  (method (initialize-camera)
    (set! zoom-factor 10.9)
    (set! camera-move-speed (find-setting 'world.camera-move-speed .2))
    (set! camera-strafe-speed (find-setting 'world.camera-strafe-speed 0.1))
    (set! camera-rotate-speed (find-setting 'world.camera-rotate-speed 0.03))
    (prepare-camera)
    (update-eye-target))
  
  
  (method (setup-camera)
    (let ((up (get-up~ eye-lookat)))
      (gluLookAt
        (vertex-x eye) (vertex-y eye) (vertex-z eye)
        (vertex-x eye-target) (vertex-y eye-target) (vertex-z eye-target)
        (vertex-x up) (vertex-y up) (vertex-z up))))
  
  
  (method (prepare-camera)
    (cond ((find-setting 'world.eye #f)
           (vertex-copy! eye (find-setting 'world.eye #f))
           (vertex-copy! eye-target (find-setting 'world.eye-target #f))
           (vertex-copy! (get-sight~ eye-lookat) (find-setting 'world.eye-sight #f))
           (vertex-copy! (get-up~ eye-lookat) (find-setting 'world.eye-up #f))
           (vertex-copy! (get-right~ eye-lookat) (find-setting 'world.eye-right #f)))
          (start-3d?
           (vertex-init! eye 65. 35. 65.)
           (set-sight~ eye-lookat (vertex -.6717990040779114 -.3334861397743225 -.6614174246788025))
           (set-up~ eye-lookat (vertex -.23764048516750336 .9427545070648193 -.23396790027618408))
           (set-right~ eye-lookat (vertex .7015790343284607 -6.643728678312755e-9 -.7125917077064514)))
          (else
           (vertex-init! eye 0.0 7.25 12.)
           (standardize-lookat! eye-lookat))))
  
  
  (method (set-eye vert)
    (vertex-copy! eye vert))
  
  
  (method (update-eye-target)
    (vertex+! eye-target eye (get-sight~ eye-lookat))
    (update-camera))
  
  
  (method (update-camera)
    (let ((zone (current-zone+)))
      ;; quick hack around initialization order
      (let ((radius (if (not zone) 13.856406460551018 (get-sector-radius~ zone))))
        (frustum-normals! frustum-left frustum-bottom frustum-right frustum-top)
        (set! frustum-left-dot (- (f64-ref (dot-product& frustum-left eye)) radius))
        (set! frustum-bottom-dot (- (f64-ref (dot-product& frustum-bottom eye)) radius))
        (set! frustum-right-dot (- (f64-ref (dot-product& frustum-right eye)) radius))
        (set! frustum-top-dot (- (f64-ref (dot-product& frustum-top eye)) radius)))))
  
  
  (method (in-frustum? center <f64vector>) <bool>
    (and (>= (f64-ref (dot-product& frustum-left center)) frustum-left-dot)
         (>= (f64-ref (dot-product& frustum-bottom center)) frustum-bottom-dot)
         (>= (f64-ref (dot-product& frustum-right center)) frustum-right-dot)
         (>= (f64-ref (dot-product& frustum-top center)) frustum-top-dot)))
  
  
  (method (get-camera-me)
    (vertex+ eye (vertex-scalar*& (get-sight~ eye-lookat) camera-distance)))
  
  
  (method (toggle-eye)
    (set! eye? (not eye?))
    (update-parameter 'eye))
  
  
  (method (draw-eye)
    (let ((center (vertex-& (vertex-& (vertex+& eye (vertex-scalar*& (get-sight~ eye-lookat) 5.)) (vertex-scalar*& (get-right~ eye-lookat) 1.5)) (get-up~ eye-lookat))))
      (let ((sight (vertex+& center (get-sight~ eye-lookat)))
            (up (vertex+& center (get-up~ eye-lookat)))
            (right (vertex+& center (get-right~ eye-lookat)))
            (axis-x (vertex+& center (vertex 1. 0. 0.)))
            (axis-y (vertex+& center (vertex 0. 1. 0.)))
            (axis-z (vertex+& center (vertex 0. 0. 1.))))
        (let ((cx (vertex-x center))
              (cy (vertex-y center))
              (cz (vertex-z center)))
          (glLineWidth 2.)
          (glDisable GL_LIGHTING)
          (gl-colorize-dye white-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x sight) (vertex-y sight) (vertex-z sight))
          (glEnd)
          (gl-colorize-dye white-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x right) (vertex-y right) (vertex-z right))
          (glEnd)
          (gl-colorize-dye white-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x up) (vertex-y up) (vertex-z up))
          (glEnd)
          (gl-colorize-dye red-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-x) (vertex-y axis-x) (vertex-z axis-x))
          (glEnd)
          (gl-colorize-dye green-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-y) (vertex-y axis-y) (vertex-z axis-y))
          (glEnd)
          (gl-colorize-dye blue-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-z) (vertex-y axis-z) (vertex-z axis-z))
          (glEnd)
          (glEnable GL_LIGHTING)
          (glLineWidth 1.)))))

  
  (method (zoom-in)
    (if first-person?
        (first-distance-closer)
      (if (eq? projection 'perspective)
          (let ((me (get-camera-me)))
            (increase! camera-distance (- (zoom-speed)))
            (vertex+! eye me (vertex-scalar*& (get-sight~ eye-lookat) (- camera-distance)))
            (update-eye-target))
        (set! zoom-factor (* zoom-factor .75)))))
  
  
  (method (zoom-out)
    (if first-person?
        (first-distance-further)
      (if (eq? projection 'perspective)
          (let ((me (get-camera-me)))
            (increase! camera-distance (zoom-speed))
            (vertex+! eye me (vertex-scalar*& (get-sight~ eye-lookat) (- camera-distance)))
            (update-eye-target))
        (set! zoom-factor (/ zoom-factor .75)))))
  
  
  (method (zoom-speed)
    10.)
  
  
  (method (toggle-camera-lock)
    (let ((camera (next-element '(locked free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'locked)
        (follow-player))
      (update-parameter 'camera-lock)
      (display-message (format "Camera {a}" camera))))
  
  
  (method (current-controlled)
    (let ((me (current-me)))
      (or (get-controlled~ me) me)))
  
  
  (method (follow-player)
    (follow-actor (current-controlled)))
  
  
  (method (follow-actor actor)
    (when (and first-person? (not paused?))
      (unless (or viewing? (eq? first-camera 'free))
        (camera-behind-actor actor))
      (when actor
        (let ((lens (player-lens actor))
              (sight (get-sight~ eye-lookat)))
          (vertex-! eye lens (vertex-scalar*& sight (effective-first-distance)))
          (vertex+! eye-target eye sight)
          (update-camera)
          (remove-eye-occlusion lens)))))
  
  
  (method (camera-behind-player)
    (camera-behind-actor (current-controlled)))
  
  
  (method (camera-behind-actor actor)
    (when (and actor first-person? (not paused?))
      (set-sight~ eye-lookat (get-sight~ (get-lookat~ actor)))
      (set-up~ eye-lookat (get-up~ (get-lookat~ actor)))
      (set-right~ eye-lookat (get-right~ (get-lookat~ actor)))))
  
  
  (method (player-lens player)
    (vertex+ (get-center~ player)
             (let ((y-radius (vertex-y (get-radiuses~ player))))
               (vertex-scalar*& (get-up~ (get-lookat~ player)) (- y-radius (* y-radius 0.25))))))
  
  
  (method (restore-first-distance elapse)
    (let ((me (current-me)))
      (when (and first-override (not first-occlusion?))
        (let ((augmented-override (+ first-override (* elapse 100.))))
          (if (>= augmented-override first-distance)
              (set! first-override #f)
            (set! first-override augmented-override)))
        (occlusion-update-eye (player-lens me))
        (adjust-player-alpha))))
  
  
  (method (remove-eye-occlusion target)
    (define (determine-eye-occlusion target)
      (let ((closest (ray-closest-polygon target (vertex-negate& (get-sight~ eye-lookat)) first-distance ignore-players?: #t)))
        (if (not closest)
            (values #f #f)
          (bind (poly distance) closest
            (values distance (get-normal~ poly))))))
    
    (define (closer-eye-occlusion occlusion normal)
      (let ((trend (inner-product (get-sight~ eye-lookat) normal)))
        (if (= trend 0.)
            occlusion
          (- occlusion (/ .1 trend)))))
    
    (receive (occlusion normal) (determine-eye-occlusion target)
      (unless (eqv? occlusion first-override)
        (if (not occlusion)
            (set! first-occlusion? #f)
          (set! first-override (closer-eye-occlusion occlusion normal))
          (set! first-occlusion? #t)
          (occlusion-update-eye target))
        (adjust-player-alpha))))
  
  
  (method (occlusion-update-eye target)
    (vertex-! eye target (vertex-scalar*& (get-sight~ eye-lookat) (effective-first-distance)))
    (vertex+! eye-target eye (get-sight~ eye-lookat)))
  
  
  (method (mark-eye target)
    (let ((zone (current-zone)))
      (set-marks~ zone
        (list (new Vertex-Mark target color: red-dye)
              (new Vertex-Mark eye-target color: green-dye)
              (new Vertex-Mark eye color: blue-dye)))))
  
  
  (definition current-area-visit <fx>
    -1)
  
  
  (definition travel-triangle
    (new Triangle #f (vector (vertex 0. 0. 0.) (vertex 0. 0. 0.) (vertex 0. 0. 0.))))
  
  (definition travel-quad
    (new Quad #f (vector (vertex 0. 0. 0.) (vertex 0. 0. 0.) (vertex 0. 0. 0.) (vertex 0. 0. 0.))))
  
  
  (method (travel-ray-polygons& proc orig <f64vector> dir <f64vector> radius <fl> breadth <fx> max-distance <fl> sphere-matrix (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f))
    (let ((zone (current-zone)))
      (increase! current-area-visit)
      (let ((step (cast <fl> (get-area-size~ zone))))
        (let ((position (vertex-copy& orig))
              (position-increment (vertex-scalar*& dir step))
              (position-distance 0.))
          (let (iter)
            (or (proc
                  (lambda (proc)
                    (iterate-position-neighbor-areas~ zone position breadth
                      (lambda (area <Area>)
                        (unless (= (get-visit~ area) current-area-visit)
                          (iterate-polygons~ area
                            (lambda (element polygons offset)
                              (let ((poly-center (vertex& (f64vector-ref polygons (+ offset 0)) (f64vector-ref polygons (+ offset 1)) (f64vector-ref polygons (+ offset 2))))
                                    (poly-radius (f64vector-ref polygons (+ offset 15))))
                                (when (ray-intersects-sphere? orig dir poly-center (+ radius poly-radius))
                                  (let ((poly (if (nan? (f64vector-ref polygons (+ offset 12)))
                                                  travel-triangle
                                                travel-quad)))
                                    (polygon-extract!~ poly element polygons offset sphere-matrix)
                                    (proc poly))))))
                          (unless ignore-entities?
                            (iterate-entities~ area
                              (lambda (entity)
                                (unless (or (not (get-visible?~ entity))
                                            (is? entity Missile)
                                            (and ignore-players? (is? entity Player)))
                                  (when (ray-intersects-sphere? orig dir (get-center~ entity) (+ radius (get-radius~ entity)))
                                    (for-each-bounding-quad~ entity sphere-matrix travel-quad
                                      proc))))))
                          (set-visit~ area current-area-visit))))))
                (let ((new-distance (+ position-distance step)))
                  (when (<= new-distance max-distance)
                    (vertex+! position position position-increment)
                    (set! position-distance new-distance)
                    (iter)))))))))
  
  
  (method (ray-closest-polygon orig <f64vector> dir <f64vector> max-distance <fl> (filter: filter #f) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f))
    (travel-ray-polygons&
      (lambda (iterate)
        (let ((closest #f)
              (distance #f))
          (iterate
            (lambda (poly)
              (let ((cls (ray-closest-triangle~ poly orig dir filter)))
                (when cls
                  (bind (poly dist) cls
                    (when (and (or (not distance)
                                   (< dist distance))
                               (< dist max-distance))
                      (set! closest (list (copy-polygon~ poly) dist))
                      (set! distance dist)))))))
          closest))
      orig
      dir
      0.
      1
      max-distance
      #f
      ignore-entities?: ignore-entities?
      ignore-players?: ignore-players?))
  
  
  (method (strafe-camera center-x)
    (let ((eye-x (vertex-x eye)))
      (if (> center-x (+ eye-x camera-limit))
          (strafe-horizontally (- center-x (+ eye-x camera-limit))))
      (if (< center-x (- eye-x camera-limit))
          (strafe-horizontally (- center-x (- eye-x camera-limit))))))
  
  
  (method (camera-center-player)
    (unless paused?
      (case projection
        ((perspective)
         (follow-player))
        ((orthographic)
         (strafe-camera (get-x~ (current-me)))))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method protected virtual (player-class)
    Player)
  
  
  (method (effective-first-distance)
    (or first-override first-distance))
  
  
  (method (first-distance-closer)
    (let ((distance (effective-first-distance)))
      (set! first-override #f)
      (set! first-distance (* distance .75))
      (camera-center-player)
      (adjust-player-alpha)))
  
  
  (method (first-distance-further)
    (let ((distance (effective-first-distance)))
      (set! first-override #f)
      (set! first-distance (min (/ distance .75) max-distance))
      (camera-center-player)
      (adjust-player-alpha)))
  
  
  (method (adjust-player-alpha)
    (let ((me (current-me)))
      (dye-alpha-set! (get-color~ me)
                      (if (contains-vertex?~ me eye)
                          0.
                        (max 0.2 (min 1. (/ (effective-first-distance) 2.)))))))
  
  
  (method (is-moving?)
    moving?)
  
  
  (method (move-player-forward player factor target-velocity)
    (vertex-increase! target-velocity (vertex-scalar*& (get-sight~ (get-lookat~ player)) (* factor (vehicle-speed player)))))
  
  
  (method (move-player-backward player factor target-velocity)
    (vertex-decrease! target-velocity (vertex-scalar*& (get-sight~ (get-lookat~ player)) (* factor (vehicle-speed player)))))
  
  
  (method (blink-player-forward player factor target-velocity)
    (vertex-increase! target-velocity (vertex-scalar*& (get-sight~ eye-lookat) (* factor (vehicle-speed player) (find-setting 'world.blink-speed 5.)))))
  
  
  (method (blink-player-backward player factor target-velocity)
    (vertex-decrease! target-velocity (vertex-scalar*& (get-sight~ eye-lookat) (* factor (vehicle-speed player) (find-setting 'world.blink-speed 5.)))))
  
  
  (method (strafe-player-left player factor target-velocity)
    (vertex-decrease! target-velocity (vertex-scalar*& (get-right~ (get-lookat~ player)) (* factor (vehicle-speed player)))))
  
  
  (method (strafe-player-right player factor target-velocity)
    (vertex-increase! target-velocity (vertex-scalar*& (get-right~ (get-lookat~ player)) (* factor (vehicle-speed player)))))
  
  
  (method (strafe-player-up player factor)
    (strafe-player-vertical player (* (get-camera-strafe-speed) 2)))
  
  
  (method (strafe-player-down player factor)
    (strafe-player-vertical player (- (* (get-camera-strafe-speed) 2))))
  
  
  (method (strafe-player-vertical player distance)
    (vertex-copy! eye (vertex+& eye (vertex-scalar*& (get-up~ (get-lookat~ player)) distance)))
    (update-eye-target)
    (set-y~ player (+ (get-y~ player) distance))
    (follow-player))
  
  
  (definition player-rotation-speed <fl>
    0.02)
  
  
  (method (rotate-player-left player factor)
    (rotate-player-horizontal player (* player-rotation-speed factor))
    @buggy
    (when fly?
      (tilt-player player 1.)))
  
  
  (method (rotate-player-right player factor)
    (rotate-player-horizontal player (- (* player-rotation-speed factor)))
    @buggy
    (when fly?
      (tilt-player player -1.)))
  
  
  (method (rotate-player-horizontal player angle (follow-player?: follow-player? #t))
    (let ((me (current-controlled)))
      (let ((lookat (get-lookat~ player)))
        (let ((up (get-up~ lookat)))
          (rotate-lookat! lookat angle up)
          (update-matrix~ me)
          (when (and (eq? player me) (not paused?))
            (unless (and down? (not moving?))
              (rotate-lookat! eye-lookat angle up))
            (when follow-player?
              (follow-player)))))))
  
  
  (method (rotate-player-vertical player angle (follow-player?: follow-player? #t))
    (let ((me (current-controlled)))
      (let ((lookat (get-lookat~ player)))
        (rotate-lookat! lookat angle (get-right~ lookat))
        (update-matrix~ me))
      (when (and (eq? player me) (not paused?))
        (rotate-lookat! eye-lookat angle (get-right~ eye-lookat))
        (when follow-player?
          (follow-player)))))
  
  
  (method (reset-tilt player)
    (set! desired-tilt 0.)
    (set! tilt-speed .25)
    (process-tilt player))
  
  
  (method (tilt-player player angle)
    (let ((max-tilt PI/4))
      (let ((desired (max (- max-tilt) (min max-tilt (* (- angle) 25.)))))
        (set! desired-tilt desired)
        (set! tilt-speed .25)
        (process-tilt player))))
  
  
  (method (process-tilt player)
    (when (and tilt-speed (or (not last-tilt-time) (> (- (current-seconds) last-tilt-time) .01)))
      (let ((lookat (get-lookat~ player)))
        (let ((current (vertical-angle (get-right~ lookat) world-up)))
          (if (near? current desired-tilt .001)
              (set! tilt-speed #f)
            (let ((damper 10.))
              (let ((target-tilt (/ (+ desired-tilt (* damper current)) (+ 1. damper))))
                (increase-tilt player (max (- tilt-speed) (min tilt-speed (- target-tilt current)))))))))))
  
  
  (method (increase-tilt player inc)
    (let ((lookat (get-lookat~ player)))
      (when (or (not last-tilt-time)
                (> (abs inc) .01)
                (> (- (current-seconds) last-tilt-time) .05))
        (set! last-tilt-time (current-seconds))
        (rotate-lookat! lookat inc (get-sight~ lookat)))))
  
  
  (method (track-actor actor dh dv local-sight local-up local-right first?)
    (if fly?
        (track-actor-fly actor dh dv local-sight local-up local-right first?)
      (track-actor-floor actor dh dv local-sight local-up local-right first?)))
  
  
  (method (track-actor-floor actor dh dv camera-sight camera-up camera-right first?)
    (let ((me (current-controlled)))
      (let ((me? (eq? actor me))
            (angleh (/ (- (cast <fl> dh)) track-sensitivity))
            (anglev (/ (- (cast <fl> dv)) track-sensitivity))
            (actor-lookat (get-lookat~ actor))
            (camera-lookat (lookat camera-sight camera-up camera-right)))
        (let ((pitch (vertical-angle camera-sight world-up)))
          ;; remove pitch
          (when (and me? (not paused?))
            (rotate-lookat-vertical! camera-lookat pitch))
          ;; start from the camera lookat
          (when first?
            (lookat-copy! actor-lookat camera-lookat))
          (rotate-player-horizontal actor angleh follow-player?: #f)
          (when (and me? (not paused?))
            (rotate-vertical-up anglev (get-up~ (get-lookat~ actor))))
          (when (and me? (not paused?))
            (follow-actor actor))))))
  
  
  (method (track-actor-fly actor dh dv camera-sight camera-up camera-right first?)
    (let ((me (current-controlled)))
      (let ((me? (eq? actor me))
            (angleh (/ (- (cast <fl> dh)) track-sensitivity))
            (anglev (/ (- (cast <fl> dv)) track-sensitivity))
            (actor-lookat (get-lookat~ actor))
            (camera-lookat (lookat camera-sight camera-up camera-right)))
        ;; start from the camera lookat
        (when first?
          (lookat-copy! actor-lookat camera-lookat))
        
        ;; adjust pitch
        (let ((actor-horizon (cross-normal& (get-sight~ actor-lookat) world-up)))
          (rotate-lookat! actor-lookat anglev actor-horizon)
          (rotate-lookat! eye-lookat anglev actor-horizon))
        
        ;; adjust tilt
        (tilt-player actor angleh)
        
        ;; adjust rotation
        (rotate-lookat! actor-lookat angleh world-up)
        (rotate-lookat! eye-lookat angleh world-up)

        ;; update matrix
        (update-matrix~ me)
        
        ;; eye follows player
        (when (and me? (not paused?))
          (follow-actor actor)))))
  
  
  (method (mind-control)
    (let ((me (current-me)))
      (let ((controlled (get-controlled~ me)))
        (if (and (is? target Actor)
                 (neq? target controlled))
            (control~ me target)
          (when controlled
            (relinquish-control~ me))))))
  
  
  (method (toggle-aim)
    (set! aim? (not aim?))
    (update-parameter 'aim))
  
  
  (method (toggle-free-aim)
    (set! free-aim? (not free-aim?))
    (update-parameter 'free-aim)
    (display-on/off "Free aim" free-aim?))

  
  (method (draw-aim)
    (let ((me (current-me)))
      (let ((lens (player-lens me)))
        (let ((x (vertex-x lens))
              (y (vertex-y lens))
              (z (vertex-z lens))
              (size .05))
          (glDisable GL_DEPTH_TEST)
          (glDisable GL_LIGHTING)
          (glBegin GL_LINES)
          (gl-colorize-dye white-dye)
          (glVertex3f (- x size) y z)
          (glVertex3f (+ x size) y z)
          (glVertex3f x (- y size) z)
          (glVertex3f x (+ y size) z)
          (glVertex3f x y (- z size))
          (glVertex3f x y (+ z size))
          (glEnd)
          (glEnable GL_LIGHTING)
          (glEnable GL_DEPTH_TEST)))))
  
  
  ;;;
  ;;;; Resize
  ;;;
  
  
  (method protected virtual (resize-scene)
    (let ((width (fxround width))
          (height (fxround height)))
      (when interface
        (set-size~ interface (new Dimension width height)))
      (when render-target
        (resize~ render-target width height))))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (method protected virtual (render-world)
    (when (and render-ready? (not debugged?))
      (let ((counter (find-counter 'render)))
        ;; good idea to make the counter display more what is happening at the
        ;; moment but as it is, it often resets before having been displayed...
        @wait (reset~ counter)
        (start~ counter)
        (when post-processing?
          (prepare-render))
        (prepare-world)
        (unless (get-focus)
          (process-keys))
        (setup-camera)
        (setup-lighting)
        (glEnable GL_DEPTH_TEST)
        (glShadeModel GL_SMOOTH)
        (draw-world)
        (render-interface)
        (when post-processing?
          (post-render))
        (end~ counter)
        (gl-check-error))))
  
  
  (method (prepare-world)
    (glClear (bitwise-ior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
    (prepare-projection)
    (glMatrixMode GL_MODELVIEW)
    (glLoadIdentity)
    (glDisable GL_LIGHTING)
    (glDisable GL_LIGHT0)
    (glDisable GL_LIGHT1)
    (glEnable GL_TEXTURE_2D)
    (glEnable GL_BLEND)
    (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA))
  
  
  (method (prepare-render)
    (when render-target
      (activate~ render-target)
      (glClear GL_COLOR_BUFFER_BIT)
      (glClear GL_DEPTH_BUFFER_BIT)))
  
  
  (method (post-render)
    (when render-target
      (deactivate~ render-target)
      (glClearColor 0. 0. 0. 1.)
      (glClear GL_COLOR_BUFFER_BIT)
      (glClear GL_DEPTH_BUFFER_BIT)
      
      ;; Copy the color buffer from the render target onto the native color buffer (0)
      (blit~ render-target 0)
      
      @transfer-render-target-using-shader (
      (glClearColor 0. 0. 0. 1.)
      (glClear GL_COLOR_BUFFER_BIT)
      (glClear GL_DEPTH_BUFFER_BIT)
      
      (activate~ pp-program)
      (glActiveTexture GL_TEXTURE7)
      (glBindTexture GL_TEXTURE_2D (get-id~ render-target))
      (glUniform1i (get-uniform~ pp-program "fbo_texture") 7)
      
      (glEnableVertexAttribArray (get-attribute~ pp-program "vertex_coord"))
      
      (glBindBuffer GL_ARRAY_BUFFER (get-vbo/fbo-vertices~ pp-program))
      (glVertexAttribPointer (get-attribute~ pp-program "vertex_coord") 2 GL_FLOAT GL_FALSE 0 #f)
      (glDrawArrays GL_TRIANGLE_STRIP 0 4)
      (glDisableVertexAttribArray (get-attribute~ pp-program "vertex_coord"))
      (glBindTexture GL_TEXTURE_2D 0)
      (deactivate~ pp-program))))
  
  
  (method (draw-world)
    (let ((zone (current-zone))
          (me (current-me)))
      (case projection
        ((perspective)
         (if 3d?
             (glEnable GL_DEPTH_TEST)
           (glDisable GL_DEPTH_TEST)))
        ((orthographic)
         (glDisable GL_DEPTH_TEST)))
      (when (not-null? draw-procedures)
        (for-each (lambda (proc)
                    (proc))
                  draw-procedures))
      (draw-zone~ zone)
      (draw-grid)
      (when axes?
        (draw-axes))
      (when (and aim? free-aim?)
        (draw-aim))
      (when eye?
        (draw-eye))
      (when paused?
        (draw-history))
      (when target
        (draw-target~ target)
        (draw-editor-target)
        (when draw-normals?
          (glDisable GL_LIGHTING)
          (for-each (lambda (face)
                      (draw-plane (get-polygon~ face) red-dye #f))
                    (element-faces~ target))
          (glEnable GL_LIGHTING)))
      (when (and target-polygon (not target))
        (glDisable GL_LIGHTING)
        (gl-colorize-dye red-dye)
        (draw-polygon target-polygon)
        (when draw-normals?
          (draw-plane target-polygon red-dye #f))
        (glEnable GL_LIGHTING))
      (when (not-null? highlighted-polygons)
        (gl-colorize-dye blue-dye)
        (for-each draw-polygon highlighted-polygons))))
  
  
  (method (draw-polygon poly)
    (glLineWidth 2.)
    (glBegin GL_LINE_LOOP)
    (loop (for vert in-vector (get-vertices~ poly))
          (glVertex3f (vertex-x vert) (vertex-y vert) (vertex-z vert)))
    (glEnd)
    (glLineWidth 1.))
  
  
  (proclaim (warn optimizations))
  
  
  (method (draw-neighbors proc)
    (let ((zone (current-zone)))
      (draw-eye-neighbors~ zone eye view-distance proc)))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (draw-sectors)
    ;; tiles
    (use~ tile-program)
    (bind-render-uniforms~ tile-program tile-material tile-matrix)
    (bind-uniforms~ tile-program tile-mesh tile-matrix)
    (glEnable GL_ALPHA_TEST)
    (glAlphaFunc GL_GEQUAL .7)
    (draw-neighbors (lambda (sector) (draw-sector sector)))
    (glDisable GL_ALPHA_TEST)
    (unbind-uniforms~ tile-program)
    (unbind-render-uniforms~ tile-program)
    (unuse~ tile-program)
    (draw-neighbors (lambda (sector) (draw-entities sector))))
  
  
  (method (draw-sector sector)
    (let ((mesh (get-mesh~ sector)))
      (unless (empty?~ (get-mesh~ sector))
        (draw-mesh~ tile-program mesh))))
  
  
  (method (draw-entities sector)
    (let ((me (current-me)))
      (for-each (lambda (element)
                  (unless (or (eq? element me) (not (get-visible?~ element)))
                    (draw~ element)))
                (get-entities~ sector))))
  
  
  (method (draw-axes)
    (glLineWidth 5.)
    (glDisable GL_LIGHTING)
    (glBegin GL_LINES)
    ;; X
    (gl-colorize-dye red-dye)
    (glVertex3f -10.0  0.0  0.0)
    (glVertex3f  10.0  0.0  0.0)
    (glVertex3f  10.0  0.0  0.0)
    (glVertex3f   9.5  0.0  0.5)
    (glVertex3f  10.0  0.0  0.0)
    (glVertex3f   9.5  0.0 -0.5)
    
    ;; Y
    (gl-colorize-dye green-dye)
    (glVertex3f  0.0 -10.0  0.0)
    (glVertex3f  0.0  10.0  0.0)
    (glVertex3f  0.0  10.0  0.0)
    (glVertex3f  0.5   9.5  0.0)
    (glVertex3f  0.0  10.0  0.0)
    (glVertex3f -0.5   9.5  0.0)
    
    ;; Z
    (gl-colorize-dye blue-dye)
    (glVertex3f  0.0  0.0 -10.0)
    (glVertex3f  0.0  0.0  10.0)
    (glVertex3f  0.0  0.0  10.0)
    (glVertex3f  0.5  0.0   9.5)
    (glVertex3f  0.0  0.0  10.0)
    (glVertex3f -0.5  0.0   9.5)
    (glEnd)
    
    (glLineWidth 1.)
    
    (when (find-setting 'world.axes-graduation? #f)
      (glBegin GL_LINES)
      ;; X
      (gl-colorize-dye red-dye)
      (loop (for x <fl> from -9. to 9. by 1.)
            (glVertex3f   x  0.0 -0.25)
            (glVertex3f   x  0.0  0.25))
      
      ;; Y
      (gl-colorize-dye green-dye)
      (loop (for y <fl> from -9. to 9. by 1.)
            (glVertex3f  -0.25  y 0.0)
            (glVertex3f   0.25  y 0.0))
      
      ;; Z
      (gl-colorize-dye blue-dye)
      (loop (for z <fl> from -9. to 9. by 1.)
            (glVertex3f  -0.25 0.0 z)
            (glVertex3f   0.25 0.0 z))
      (glEnd))
    
    (glEnable GL_LIGHTING))
  
  
  (method (draw-grid)
    (when grid?
      (let ((index (position-area-index~ (current-zone) eye))
            (size (get-area-size~ (current-zone))))
        (let ((bx (* (vector-ref index 0) size))
              (by (* (vector-ref index 1) size))
              (bz (* (vector-ref index 2) size)))
          (glDisable GL_LIGHTING)
          (glLineWidth 1.)
          (case grid-plane
            ((x)
             (let ((min -500.)
                   (max 500.))
               (gl-colorize-dye yellow-dye)
               (glBegin GL_LINES)
               (loop (for y <fl> from min to max by 1.)
                     (glVertex3f grid-position (+ by y) (+ bz min))
                     (glVertex3f grid-position (+ by y) (+ bz max)))
               (loop (for z <fl> from min to max by 1.)
                     (glVertex3f grid-position (+ by min) (+ bz z))
                     (glVertex3f grid-position (+ by max) (+ bz z)))
               (glEnd)))
            ((y)
             (let ((min -500.)
                   (max 500.))
               (gl-colorize-dye green-dye)
               (glBegin GL_LINES)
               (loop (for x <fl> from min to max by 1.)
                     (glVertex3f (+ bx x) grid-position (+ bz min))
                     (glVertex3f (+ bx x) grid-position (+ bz max)))
               (loop (for z <fl> from min to max by 1.)
                     (glVertex3f (+ bx min) grid-position (+ bz z))
                     (glVertex3f (+ bx max) grid-position (+ bz z)))
               (glEnd)))
            ((z)
             (let ((min -500.)
                   (max 500.))
               (gl-colorize-dye red-dye)
               (glBegin GL_LINES)
               (loop (for x <fl> from min to max by 1.)
                     (glVertex3f (+ bx x) (+ by min) grid-position)
                     (glVertex3f (+ bx x) (+ by max) grid-position))
               (loop (for y <fl> from min to max by 1.)
                     (glVertex3f (+ bx min) (+ by y) grid-position)
                     (glVertex3f (+ bx max) (+ by y) grid-position))
               (glEnd))))
          (glEnable GL_LIGHTING)))))
  
  
  (method (draw-history)
    (draw-history~ history draw-moment))
  
  
  (method (draw-moment n)
    ;; need to generalize to all actors
    (define (draw-metadata bounds)
      (let ((x1 (cuboid-left bounds))
            (x2 (cuboid-right bounds))
            (y1 (cuboid-bottom bounds))
            (y2 (cuboid-top bounds))
            (z1 (cuboid-back bounds))
            (z2 (cuboid-front bounds)))
        (glDisable GL_LIGHTING)
        (gl-colorize-dye (dye .678 .047 .902 .2))
        (render-block x1 x2 y1 y2 z1 z2 GL_LINE_LOOP)
        (glEnable GL_LIGHTING)))
    
    (let ((moment (historical-moment n)))
      (let ((metadata (get-metadata~ moment)))
        (when metadata
          (draw-metadata metadata)))
      @w
      (for-each (lambda (player)
                  (parameterize ((in-history? #t))
                    (draw~ player)))
                (get-actors~ snapshot))))
  
  
  (method (register-draw proc)
    (set! draw-procedures (cons proc draw-procedures)))
  
  
  (method (unregister-draw proc)
    (set! draw-procedures (remove! proc draw-procedures)))
  
  
  ;;;
  ;;;; Generate
  ;;;
  
  
  (method (rendering-threshold)
    (if (get-idle?)
        (get-idle-rendering)
      (get-buzy-rendering)))
  
  
  ;;;
  ;;;; Lighting
  ;;;
  
  
  (method (setup-lighting)
    (let ((zone (current-zone)))
      (setup-lighting~ zone)))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method (render-interface)
    (when interface?
      (glDisable GL_LIGHTING)
      (glMatrixMode GL_MODELVIEW)
      (glLoadIdentity)
      (glMatrixMode GL_PROJECTION)
      (glEnable GL_BLEND)
      (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
      (glPushMatrix)
      (glLoadIdentity)
      (glOrtho 0.0 width 0.0 height -10.0 10.0)
      (draw-interface)
      (glPopMatrix)
      (glEnable GL_LIGHTING)))
  
  
  (method (draw-interface)
    (let ((now (current-seconds)))
      (when (and (> (- now interface-last-time) interface-refresh-rate)
                 (or (get-visible?~ (child~ interface 'info))
                     (get-visible?~ (child~ interface 'counters))))
        (invalidate-view~ interface)
        (set! interface-last-time now)))
    (draw-interface~ interface)
    (when message
      (draw-message))
    (when status
      (draw-status))
    (when (and history? paused?)
      (draw-history-slider))
    (when (and (application-active?) (find-setting 'world.debug-activation? #f))
      (let ((width (fxround width)))
        (let ((h (- width 20))
              (v 20))
          (gl-segment-circle (new Point h v) 7 {Color Light-Blue} 100)))))
  
  
  (method (draw-history-slider)
    (draw-history-slider~ history))
  
  
  (method (explore-interface)
    (set! explore-interface? (not explore-interface?))
    (when explore-interface?
      (set! interface? #t))
    (set-window-cursor~ (current-world-window) (if explore-interface? :spy :arrow)))
  
  
  (method (main-menu)
    (let ((pane (find-if (lambda (pane) (is? pane World-Popup)) (get-children~ interface) reversed?: #t)))
      (if pane
          (close~ pane)
        (open-menu (new World-Main-Menu visible?: #t)))))
  
  
  (method (video-options)
    (open-frame (new World-Video-Options size: {Dimension 366 588} location: 'center)))
  
  
  (method (audio-options)
    (open-frame (new World-Audio-Options size: {Dimension 366 588} location: 'center)))
  
  
  (method (interface-options)
    (open-frame (new World-Interface-Options size: {Dimension 366 588} location: 'center)))
  
  
  (method (view-bindings)
    (open-frame (new World-Bindings-Viewer size: {Dimension 386 588} location: 'center)))
  
  
  (method (view-news)
    (open-document (news-file~ (get-application)) class: World-Formatted-Text-View))
  
  
  (method (view-roadmap)
    (open-document (roadmap-file~ (get-application)) class: World-Formatted-Text-View))
  
  
  (method (view-help)
    (open-document (help-file~ (get-application)) class: World-Formatted-Text-View))
  
  
  (method (close-current-popup)
    (let ((pane (find-if (lambda (pane) (is? pane World-Popup)) (get-children~ interface) reversed?: #t)))
      (when pane
        (close~ pane))))
  
  
  ;;;
  ;;;; Win / Lose
  ;;;
  
  
  (method (win player)
    (let ((zone (current-zone)))
      (win~ player)
      (let ((block (find-element~ zone
                     (lambda (obj)
                       (and (is? obj Block)
                            (eq? (get-user-data~ obj) 'win))))))
        (set-color~ block blue-dye))
      (unless paused?
        (sleep .5)
        (reset-position~ player)
        (reset-state~ player)
        (reset-game))))
  
  
  (method (lose player)
    (lose~ player)
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (reset-game)
    (setup-history))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method (missile-hit missile collision)
    (let ((zone (current-zone))
          (element (get-element~ collision)))
      (cond ((is? element Actor)
             (if (and (eq? (get-actor~ missile) element)
                      (< (get-alive~ missile) (get-self-wound-grace~ element)))
                 'ignore
               (wound~ element)
               'remove))
            (else
             (case (or (and element (get-hit-behavior~ element)) (get-missile-behavior~ zone))
               ((absorb)
                'remove)
               ((rebound)
                (let ((normal (get-normal~ (get-plane~ collision)))
                      (velocity (get-velocity~ missile)))
                  (let ((rebound (dot-product normal velocity)))
                    (set-velocity~ missile (vertex- velocity (vertex-scalar* normal (* 2. rebound))))))
                'stop)
               ((slide)
                'slide)
               ((destroy)
                (when (and element (zone-editable?~ zone))
                  (play-sound-file "sound/explosion")
                  (case (get-kind~ missile)
                    ((bullet)
                     (editor-remove-element element))
                    ((bomb)
                     (let ((center (get-center~ element)))
                       (iterate-position-neighbor-areas~ zone center 1
                         (lambda (area)
                           (for-each (lambda (tile)
                                       (when (< (vertex-distance center (get-center~ tile)) 1.9)
                                         (editor-remove-element tile)))
                                     (get-tiles~ area))))))))
                'remove))))))
  
  
  (method (change-missile-behavior (reversed?: reversed? #f))
    (let ((zone (current-zone))
          (next (if reversed? previous-element next-element)))
      (unimplemented-connected)
      (set-missile-behavior~ zone (next '(destroy absorb rebound slide) (get-missile-behavior~ zone)))
      (display-message (format "{a}" (get-missile-behavior~ zone)))))

  
  ;;;
  ;;;; World
  ;;;

  
  (method (world-new)
    (unimplemented-connected)
    (new-world)
    (display-message "New world"))
  
  
  (method (world-open)
    (unimplemented-connected)
    (let ((pane (find-type~ interface World-Open)))
      (if pane
          (close~ pane)
        (open-frame (new World-Open size: {Dimension 366 588} location: 'center)))))
  
  
  (method (world-save)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (world-save-to moniker)
        (world-save-as))))
  
  
  (method (world-save-as)
    (unimplemented-connected)
    (let ((file (choose-new-file title: "Save New World" default-extension: "world" extensions: '(("World Files" . "world")) directory: {Directory Settings "worlds"})))
      (world-save-to file)))
  
  
  (method (world-save-to file)
    (unimplemented-connected)
    (with-window-cursor :wait
      (lambda ()
        (parameterize ((pretty-print-forms? #f))
          (save-to~ designer file))
        (update-title)
        (display-message "Saved"))))
  
  
  (method (world-revert)
    (unimplemented-connected)
    (let ((moniker (get-moniker)))
      (if moniker
          (open-world moniker)
        (bell))))
  
  
  (method (get-world-directory)
    (let ((moniker (get-moniker)))
      (when moniker
        (get-parent~ moniker))))
  
  
  (method virtual (get-zones-directories)
    (let ((world-directory (get-world-directory)))
      (if world-directory
          (list (new-directory~ world-directory "zones"))
        '())))
  
  
  (method virtual (update-title)
    (define (present-zone)
      (let ((zone (current-zone+)))
        (if (not zone)
            "New"
          (present-title (get-moniker~ zone) (get-modified?~ zone)))))
    
    (define (present-title moniker modified?)
      (format "{a}{a}"
              (present-name moniker)
              (present-modified modified?)))
    
    (define (present-name moniker)
      (if (not moniker)
          "New"
        (get-base~ moniker)))
    
    (define (present-modified modified?)
      (if modified?
          " *"
        ""))
      
    (define (present-directory moniker)
        (if (not moniker)
            ""
          (let ((parent (get-world-directory)))
            (if (not parent)
                ""
              (format " ~{{a}}" (present-location~ parent))))))
    
    (set-title~ window (format "World - {a} {a}"
                               (present-zone)
                               (present-directory (get-moniker)))))
  
  
  (method (get-moniker)
    (get-origin~ (get-form~ designer)))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (when #t @buggy (neq? flag (get-modified?~ designer))
      (set-modified?~ designer flag)
      (update-title)))
  
  
  ;;;
  ;;;; Zone
  ;;;

  
  (method (zone-new)
    (unimplemented-connected)
    (zone-confirm-close
      (lambda ()
        (with-window-cursor :wait
          (lambda ()
            (new-zone)
            (set-grid? #t)
            (update-title)
            (display-message "New zone"))))))
  
  
  (method (zone-open)
    (unimplemented-connected)
    (let ((pane (find-type~ interface Zone-Open)))
      (if pane
          (close~ pane)
        (zone-confirm-close
          (lambda ()
            (open-frame (new Zone-Open size: {Dimension 366 588} location: 'center)))))))
  
  
  (method virtual (zone-writable? moniker)
    (let ((zone (current-zone)))
      (let ((moniker (get-moniker~ zone)))
        (and moniker writable?))))
  
  
  (method virtual (new-zone-file base)
    (let ((directory (or (and newable? (get-world-directory))
                         (let ((dir {Directory Settings "worlds" "user"}))
                           (if (exists?~ dir)
                               dir
                             (create-directories~ dir)
                             (world-save-to (new-file~ dir "_user.world"))
                             dir)))))
      (new-file~ directory (list "zones" (make-filename base "zone")))))
  
  
  (method (zone-save (pre: pre #f) (post: post #f) (feedback?: feedback? #t))
    (unimplemented-connected)
    (let ((zone (current-zone)))
      (let ((moniker (get-moniker~ zone)))
        (if (zone-writable? moniker)
            (begin
              (when pre
                (pre))
              (zone-save-to moniker feedback?: feedback?)
              (when post
                (post)))
          (zone-save-as pre: pre post: post feedback?: feedback?)))))
  
  
  (method (zone-save-as (pre: pre #f) (post: post #f) (feedback?: feedback? #t))
    (unimplemented-connected)
    (open-string
      title: "Choose New Zone"
      prefix: "Zone:"
      initial-value: "new"
      action: (lambda (base)
                (let ((file (new-zone-file base)))
                  (define (create)
                    (create-directories~ file)
                    (when pre
                      (pre))
                    (zone-save-to file feedback?: feedback?)
                    (when post
                      (post)))
                  
                  (if (exists?~ file)
                      (open-message (format "Zone {a} already exists. Do you want to replace it?" base)
                                    caption: "Save"
                                    type: 'confirmation
                                    yes: "Yes"
                                    no: "No"
                                    cancel: "Cancel"
                                    execute: (lambda (evt)
                                               (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog))
                                                     (button (get-property~ evt button:)))
                                                 (close~ dialog)
                                                 (case button
                                                   ((yes) (create))
                                                   ((no))
                                                   ((cancel) (signal-cancel))))))
                    (create))))))
  
  
  (method (zone-save-to file (feedback?: feedback? #t))
    (unimplemented-connected)
    (with-window-cursor :wait
      (lambda ()
        (let ((zone (current-zone))
              (me (current-me)))
          (let ((designer (get-designer~ zone)))
            (when (or (not (get-start-mode~ zone))
                      (not (get-start-eye~ zone))
                      (not (get-start-position~ zone)))
              (save-mode)
              (save-camera)
              (save-player))
            (parameterize ((pretty-print-forms? #f))
              (save-to~ designer file))
            (update-title)
            (when feedback?
              (display-message "Saved")))))))
  
  
  (method (save-mode)
    (unimplemented-connected)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone)))
        (set-property~ designer zone 'start-mode (if first-person? 'first-person 'free-camera)))))
  
  
  (method (save-camera)
    (unimplemented-connected)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone)))
        (set-property~ designer zone 'start-eye eye)
        (set-property~ designer zone 'start-eye-sight (get-sight~ eye-lookat))
        (set-property~ designer zone 'start-eye-up (get-up~ eye-lookat)))))
  
  
  (method (save-player)
    (unimplemented-connected)
    (let ((zone (current-zone))
          (me (current-me)))
      (let ((designer (get-designer~ zone)))
        (set-property~ designer zone 'start-position (get-position~ me))
        (let ((lookat (get-lookat~ me)))
          (set-property~ designer zone 'start-sight (get-sight~ lookat))
          (set-property~ designer zone 'start-up (get-up~ lookat))))))
  
  
  (method (save-player&camera)
    (zone-save
      pre: (lambda ()
             (save-mode)
             (save-camera)
             (save-player))
      post: (lambda ()
              (display-message "Player & camera saved"))
      feedback?: #f))
  
  
  (method (zone-confirm-close post)
    (let ((zone (current-zone)))
      (if (not (get-modified?~ zone))
          (post)
        (open-message "Save changes to zone?"
                      caption: "Save"
                      type: 'confirmation
                      yes: "Yes"
                      no: "No"
                      cancel: "Cancel"
                      execute: (lambda (evt)
                                 (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog))
                                       (button (get-property~ evt button:)))
                                   (close~ dialog)
                                   (case button
                                     ((yes) (zone-save post: post))
                                     ((no) (post))
                                     ((cancel) (signal-cancel)))))))))
  
  
  (method (zone-revert)
    (define (revert)
      (let ((zone (current-zone)))
        (let ((moniker (get-moniker~ zone)))
          (if moniker
              (with-window-cursor :wait
                (lambda ()
                  (unpause-world)
                  (reset-tick-procedures)
                  (initialize-camera)
                  (setup-history)
                  (open-zone moniker)))
            (bell)))))
    
    (unimplemented-connected)
    (if (not (find-setting 'world.confirmation-dialogs? #t))
        (revert)
      (open-message "Revert to saved and lose changes?"
                    caption: "Revert"
                    type: 'question
                    yes: "Yes"
                    no: "No"
                    execute: (lambda (evt)
                               (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog))
                                     (button (get-property~ evt button:)))
                                 (close~ dialog)
                                 (case button
                                   ((yes)
                                    (revert))))))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (definition troposphere
    2.)
  
  (definition stratosphere
    3.)
  
  
  (method public (compute-gravity position)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (let ((gravity (copy-vertex ambient-gravity)))
            (iterate-gravities~ zone
              (lambda (well)
                (let ((center (get-center~ well))
                      (radius (get-radius~ well)))
                  (let ((direction (vertex-normalize& (vertex-& center position)))
                        (distance (max radius (vertex-distance center position))))
                    (let ((well-gravity (vertex-scalar* direction (well-pull well distance))))
                      (if (<= distance (+ radius troposphere))
                          (continuation-return return well-gravity)
                        (vertex+! gravity gravity well-gravity)))))))
            gravity)))))
  
  
  (method public (well-pull well distance)
    (let ((mass (well-mass~ well)))
      (/ mass (* distance distance))))
  
  
  (method public (well-gravity well pos)
    (let ((center (get-center~ well))
          (radius (get-radius~ well)))
      (let ((direction (vertex-normalize& (vertex-& center pos)))
            (distance (max radius (vertex-distance center pos))))
        (vertex-scalar* direction (well-pull well distance)))))
  
  
  (method public (surface-pull well)
    (well-pull well (get-radius~ well)))
  
  
  (method public (inside-stratosphere? well position)
    (let ((center (get-center~ well))
          (radius (get-radius~ well)))
      (let ((distance (max radius (vertex-distance center position))))
        (<= distance (+ radius stratosphere)))))
  
  
  ;;;
  ;;;; Planet
  ;;;
  
  
  (method public (determine-planet pos)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (iterate-gravities~ zone
            (lambda (well)
              (when (and (is? well Planet)
                         (inside-stratosphere? well pos))
                (continuation-return return well))))
          #f))))
  
  
  ;;;
  ;;;; Vehicle
  ;;;
  
  
  (method (activate-vehicle vehi)
    (set! vehicle vehi))
  
  
  (method (vehicle-speed actor)
    (case vehicle
      ((saucer) .3)
      ((wheels) .2)
      (else (ground-speed~ actor))))
  
  
  ;;;
  ;;;; Mount
  ;;;
  
  
  (method (toggle-mount)
    (when (not paused?)
      (unimplemented-connected)
      (activate-first-person)
      (deactivate-fly)
      (if mount?
          (deactivate-mount)
        (activate-mount))))
  
  
  (method (activate-mount)
    (unless mount?
      (set! mount? #t)
      (activate-vehicle 'wheels)
      (update-parameter 'mount)
      (update-parameter 'fly)))
  
  
  (method (deactivate-mount)
    (when mount?
      (set! mount? #f)
      (activate-vehicle #f)
      (update-parameter 'mount)
      (update-parameter 'fly)))
  
  
  ;;;
  ;;;; Fly
  ;;;
  
  
  (method (toggle-fly)
    (unimplemented-connected)
    (activate-first-person)
    (deactivate-mount)
    (if fly?
        (deactivate-fly)
      (activate-fly)))
  
  
  (method (activate-fly)
    (unless fly?
      (let ((me (current-me)))
        (set! fly? #t)
        (set-y~ me (+ (get-y~ me) 2.))
        (activate-vehicle 'saucer)
        (update-parameter 'mount)
        (update-parameter 'fly)
        (follow-player))))
  
  
  (method (deactivate-fly)
    (when fly?
      (let ((me (current-me)))
        (set! fly? #f)
        (activate-vehicle #f)
        (update-parameter 'mount)
        (update-parameter 'fly)
        (let ((lookat (get-lookat~ me)))
          (rotate-player-vertical me (vertical-angle (get-sight~ lookat) (get-up~ lookat)))
          (follow-player)))))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot designer         <object> initialize #f  accessors generate)
  (slot edition?         <bool>   initialize #f  getter generate)
  (slot editor-mode      <object> initialize #f  getter generate)
  (slot editor-anchor    <object> initialize #f  getter generate)
  (slot editor-last      <object> initialize #f  getter generate)
  (slot editor-added     <object> initialize #f  getter generate)
  (slot editor-normal    <object> initialize #f  getter generate)
  (slot editor-from      <object> initialize #f  getter generate)
  (slot editor-floor?    <object> initialize #f  getter generate)
  (slot editing?         <bool>   initialize #f  getter generate)
  (slot adding?          <bool>   initialize #f  getter generate)
  (slot deleting?        <bool>   initialize #f  getter generate)
  (slot template-mode?   <bool>   initialize #f  getter generate)
  (slot template         <object> initialize #f  getter generate)
  (slot brush-mode?      <bool>   initialize #f  getter generate)
  (slot brush            <object> initialize #f  getter generate)
  (slot grid?            <bool>   initialize #f  accessors generate)
  (slot grid-plane       <symbol> initialize 'y  getter generate)
  (slot grid-position    <fl>     initialize 0.  getter generate)
  (slot last-added       <object> initialize #f  getter generate)
  (slot players-folio    <Folio>                 getter generate)
  (slot enemies-folio    <Folio>                 getter generate)
  (slot tiles-folio      <Folio>                 getter generate)
  (slot entities-folio   <Folio>                 getter generate)
  
  
  (method (prepare-editor)
    (set! editor-mode 'block)
    (set! players-folio (new Folio 'player '(player)))
    (set! enemies-folio (new Folio 'wolf '(wolf spider turtle)))
    (set! tiles-folio (new Folio 'block '(block triangle quad)))
    (set! entities-folio (new Folio 'light-point '(light-point light-ambien light-directional pyramid cube sphere gravity @wait template))))
  
  
  (method (change-editor-mode (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          ;; disable non-functional modes in multi-player
          (available-modes '(block column free @comment crazy @comment point @comment rectangle)))
      (let ((new-mode (next available-modes editor-mode)))
        (set! editor-mode new-mode)
        (display-message (capitalize (->string new-mode))))))
  
  
  (method (change-target-mode (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          (available-modes '(select translate rotate scale)))
      (let ((new-mode (next available-modes target-mode)))
        (set! target-mode new-mode)
        (display-message (capitalize (->string new-mode))))))
  
  
  (method (select-template)
    (if (not target)
        (begin
          (bell)
          (display-error "No target selected"))
      (set! template-mode? #t)
      (set! template target)
      (display-message "Template set")))
  
  
  (method (toggle-template-mode)
    (set! template-mode? (not template-mode?))
    (update-parameter 'template-mode)
    (display-on/off "Template mode" template-mode?))
  
  
  (method (select-brush)
    (if (not target-face)
        (begin
          (bell)
          (display-error "No face selected"))
      (set! brush-mode? #t)
      (set! brush (or (get-texture~ target-face) default-image))
      (display-message "Brush set")))
  
  
  (method (toggle-brush-mode)
    (set! brush-mode? (not brush-mode?))
    (update-parameter 'brush-mode)
    (display-on/off "Brush mode" brush-mode?))
  
  
  (method (add-element-class class x y z)
    (let ((zone (current-zone)))
      (define (add class/new (properties '()) (setup #f))
        (let ((properties (append (list position: (vertex x y z)) properties)))
          (let ((obj (if (procedure? class/new) (class/new) (apply new class/new parent: zone properties))))
            (if (is? obj Player)
                (set-name~ obj (effective-player-name~ (get-application)))
              (add-child~ (get-designer~ zone) obj zone import: '(world.data) properties: properties))
            (add-element~ zone obj)
            (when setup
              (setup obj))
            obj)))
      
      (define (add-triangle)
        (add Triangle-Tile (list
                             v1: (vertex x (+ y 1.) z)
                             v2: (vertex (- x .5) y z)
                             v3: (vertex (+ x .5) y z))))
      
      (define (add-quad)
        (add Quad-Tile (list
                         v1: (vertex (- x .5) y z)
                         v2: (vertex (+ x .5) y z)
                         v3: (vertex (+ x .5) (+ y 1.) z)
                         v4: (vertex (- x .5) (+ y 1.) z))))
      
      (define (add-sphere)
        (add Sphere))
      
      (define (add-template)
        (add (lambda ()
               (new-template x y z))
             '()
             set-template-properties))
      
      (let ((element
              (case class
                ((player) (add (player-class)))
                ((turtle) (add Turtle))
                ((wolf) (add Wolf))
                ((spider) (add Spider))
                ((block) (add Block))
                ((triangle) (add-triangle))
                ((quad) (add-quad))
                ((light-point) (add Light-Point))
                ((light-ambien) (add Light-Ambient))
                ((light-directional) (add Light-Directional))
                ((pyramid) (add Pyramid))
                ((cube) (add Cube))
                ((sphere) (add-sphere))
                ((gravity) (add Gravity))
                ((template) (add-template)))))
        (when (is? element Gadget)
          (set! draw-gadgets? #t)
          (update-gadgets))
        element)))
  
  
  (method (editor-add-element mode class vert (force?: force? #f))
    (let ((zone (current-zone))
          (me (current-me)))
      (define (sign r)
        (if (< r 0)
            -1
          1))
      
      (define (sign-test sign)
        (if (= sign -1)
            >=
          <=))
      
      (define (add-at left bottom back)
        (let ((element (add-element-class class left bottom back))
              (designer (get-designer~ zone)))
          (let ((old-position (copy-vertex (get-position~ element))))
            (cond ((is? element Player)
                   (set-position~ element (vertex+& (get-position~ element) (get-radiuses~ element))))
                  (else
                   (set-position~ element (vertex+& (get-position~ element) (get-radiuses~ element)))
                   (set-property~ designer element 'position (get-position~ element))))
            (update-area~ zone element old-position)
            (update-sector~ zone element old-position))
          (when template-mode?
            (copy-template element))
          (when (and (is? element Player) (not (get-world-server~ (get-process))))
            (let ((preserved-lookat (and first-person? (get-lookat~ me))))
              (remove-element me)
              (when (server-side?~ (get-process))
                (set-color~ element white-dye))
              (set-current-me element)
              (set-lookat~ element (or preserved-lookat eye-lookat))))
          (when (eq? element (current-me))
            (follow-player))
          element))
      
      (define (copy-template element)
        (let ((designer (get-designer~ zone)))
          (cond ((and (is? element Block) (is? template Block))
                 (set-property~ designer element 'front-image (get-front-image~ template))
                 (set-property~ designer element 'back-image (get-back-image~ template))
                 (set-property~ designer element 'left-image (get-left-image~ template))
                 (set-property~ designer element 'right-image (get-right-image~ template))
                 (set-property~ designer element 'top-image (get-top-image~ template))
                 (set-property~ designer element 'bottom-image (get-bottom-image~ template)))
                ((and (is? element Light) (is? template Light))
                 (set-property~ designer element 'color (get-color~ template))
                 (set-property~ designer element 'ambient-color (get-ambient-color~ template))
                 (set-property~ designer element 'quadratic-attenuation (get-quadratic-attenuation~ template)))
                ((and (is? element Gravity) (is? template Gravity))
                 (set-property~ designer element 'mass (get-mass~ template))))))
      
      (let ((to-x (floor (vertex-x vert)))
            (to-y (floor (vertex-y vert)))
            (to-z (floor (vertex-z vert))))
        (if (not editor-anchor)
            (let ((element (add-at to-x to-y to-z)))
              (set! last-added element)
              (set! editor-anchor (vertex to-x to-y to-z))
              element)
          (unless (and editor-last
                       (= (vertex-x editor-last) to-x)
                       (= (vertex-y editor-last) to-y)
                       (= (vertex-z editor-last) to-z)
                       (not force?))
            (case mode
              ((block column free crazy)
               (let ((actual (vertex->element~ zone vert)))
                 (unless actual
                   (let ((element (add-at to-x to-y to-z)))
                     (set! last-added element)
                     (set! editor-added (list element))
                     (set! editor-last (vertex to-x to-y to-z))
                     element))))
              ((point)
               (let ((vert (vertex to-x to-y to-z)))
                 (let ((actual (vertex->element~ zone vert)))
                   (unless actual
                     (let ((element (add-at to-x to-y to-z)))
                       (set! last-added element)
                       (set! editor-added (list element))
                       (set! editor-last (vertex to-x to-y to-z))
                       element)))))
              ((line))
              ((rectangle)
               (let ((anchor-x (vertex-x editor-anchor))
                     (anchor-y (vertex-y editor-anchor))
                     (anchor-z (vertex-z editor-anchor))
                     (last-x (vertex-x editor-last))
                     (last-y (vertex-y editor-last))
                     (last-z (vertex-z editor-last)))
                 (let ((sign-x (sign (- to-x anchor-x)))
                       (sign-y (sign (- to-y anchor-y)))
                       (sign-z (sign (- to-z anchor-z))))
                   (let ((step-x (cast <fl> sign-x))
                         (step-y (cast <fl> sign-y))
                         (step-z (cast <fl> sign-z))
                         (test-x (sign-test sign-x))
                         (test-y (sign-test sign-y))
                         (test-z (sign-test sign-z)))
                     (let ((queue (new-queue))
                           (max-size 30))
                       (let (iter-x (x anchor-x) (count-x 0))
                         (when (and (< count-x max-size)
                                    (test-x x to-x))
                           (let (iter-y (y anchor-y) (count-y 0))
                             (when (and (< count-y max-size)
                                        (test-y y to-y))
                               (let (iter-z (z anchor-z) (count-z 0))
                                 (when (and (< count-z max-size)
                                            (test-z z to-z))
                                   (let ((actual (vertex->element~ zone (vertex x y z))))
                                     (if actual
                                         (when (is? actual Tile)
                                           (enqueue queue actual))
                                       (let ((element (add-at x y z)))
                                         (enqueue queue element))))
                                   (iter-z (+ z step-z) (+ count-z 1))))
                               (iter-y (+ y step-y) (+ count-y 1))))
                           (iter-x (+ x step-x) (+ count-x 1))))
                       (let ((added (queue-list queue)))
                         (when editor-added
                           (for-each editor-remove-element (difference editor-added added)))
                         (set! editor-added added)
                         (set! editor-last (vertex to-x to-y to-z))))))))))))))
  
  
  (method (editor-element-class)
    (let ((alt? (alt-down?))
          (shift? (shift-down?)))
      (cond ((and alt? shift?) (get-current~ players-folio))
            (shift? (get-current~ enemies-folio))
            (alt? (get-current~ entities-folio))
            (else (get-current~ tiles-folio)))))
  
  
  (method (element-folio element)
    (typecase element
      ((Player) players-folio)
      ((Enemy) enemies-folio)
      ((Tile) tiles-folio)
      (else entities-folio)))
  
  
  (method (change-element-class (reversed?: reversed? #f))
    (if (not last-added)
        (bell)
      (let ((folio (element-folio last-added)))
        (let ((new-class ((if reversed? previous-element next-element) (get-list~ folio) (get-current~ folio))))
          (set-current~ folio new-class)
          (change-class last-added new-class)
          (display-message (format "{a}" new-class))))))
  
  
  (method (change-class element class)
    (let ((vert (vertex- (get-position~ element) (get-radiuses~ element))))
      (editor-remove-element element)
      (editor-add-element editor-mode class vert force?: #t)))
  
  
  (method (remove-target)
    (let ((zone (current-zone))
          (me (current-me)))
      (unless (is? target Player)
        (cond ((not target)
               (bell))
              (paused?
               (editor-delete (get-position~ target)))
              (else
               ;; quicky copy-pasted from editor-delete
               (if (is? target Entity)
                   (begin
                     (editor-remove-element target)
                     (set-modified?~ zone #t)
                     (update-future))
                 (add-action~ commands 'delete (list (get-position~ target)))))))))
  
  
  (method (remove-element obj)
    (let ((zone (current-zone)))
      (remove-element~ zone obj)
      (when (eq? obj target)
        (set-target #f))))
  
  
  (method (editor-remove-element obj)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone)))
        (remove-child~ designer obj)
        (remove-element obj))))
  
  
  (method (find-mesh-program name)
    (or (table-ref mesh-programs name #f)
        (error "Unknown mesh program: {s}" name)))
  
  
  (method (change-tile-program (reversed?: reversed? #f))
    (let ((zone (current-zone))
          (folio tile-program-folio)
          (next (if reversed? previous-element next-element))
          (atlas? tile-program-atlas?))
      (let ((new-program (next (get-list~ folio) (get-current~ folio))))
        (set-current~ folio new-program)
        (set! tile-program (find-mesh-program new-program))
        (set! tile-program-atlas? (is-not? tile-program Mesh-Transformation-Program))
        (when (neq? tile-program-atlas? atlas?)
          (iterate-sectors-with-tiles~ zone
            (lambda (index sector)
              (set-vertices-uptodate?~ sector #f))))
        (display-message (format "{a}" new-program)))))
  
  
  (method (collect-textures)
    (define (add-files dir table)
      (when (exists?~ dir)
        (iterate-directory~ dir
          (lambda (file)
            (when (extension=? (get-extension~ file) "png")
              (table-set! table (get-name~ file) file)))
          files?: #t
          directories?: #f)))
    
    (when (not textures)
      (let ((table (make-table test: equal?)))
        (for-each (lambda (assets)
                    (add-files (new-directory~ assets "texture") table))
                  all-assets)
        (for-each (lambda (assets)
                    (add-files (new-directory~ assets "tile") table))
                  all-assets)
        (set! textures table)))
    textures)
  
  
  (method (reload-textures)
    (set! textures #f))
  
  
  (method (find-texture name)
    (let ((textures (collect-textures)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((file? value)
               (let ((texture (make-file-texture value)))
                 (table-set! textures name texture)
                 texture))
              (else
               value)))))
  
  
  (method (find-texture-file name)
    (let ((textures (collect-textures)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((file? value)
               value)
              (else
               (get-file~ value))))))
  
  
  (method (change-tile-texture (reversed?: reversed? #f))
    (let ((zone (current-zone)))
      (let ((next (if reversed? previous-element next-element)))
        (if (is? target Sphere)
            (let ((textures (collect-textures))
                  (material (effective-material~ target)))
              (let ((actual-file (get-file~ (get-texture~ material))))
                (let ((name (next (sort di<? (table-keys textures)) (and actual-file (get-name~ actual-file)) test: filename=?)))
                  (let ((texture (find-texture name)))
                    (receive (texture uv) (atlas-texture texture (extract-base name))
                      (set-material~ target (new Material texture: texture))
                      (display-message (format "{a}" name)))))))
          (let ((image (next (image-names~ tile-atlas) default-image test: equal?)))
            (set! default-image image)
            (set! tile-texture (find-texture (get-name~ (image-file~ tile-atlas image))))
            (iterate-sectors-with-tiles~ zone
              (lambda (index sector)
                (set-vertices-uptodate?~ sector #f)))
            (display-message (format "{a}" image)))))))
  
  
  (method (change-texture (reversed?: reversed? #f))
    (if (not target-face)
        (display-error "No face selected")
      (let ((next (if reversed? previous-element next-element)))
        (let ((texture (next (image-names~ tile-atlas) (get-texture~ target-face) test: equal?)))
          (set-face-texture target target-face target-face-rank texture)
          (display-message (format "{a}" texture))))))
  
  
  (method (set-face-texture elem face face-rank texture)
    (let ((zone (current-zone)))
      (update-face-texture~ elem face face-rank texture)
      (when (eq? face target-face)
        ;; refresh target face
        (set! target-face (element (element-faces~ elem) face-rank)))
      (let ((sector (element-sector~ zone elem)))
        (set-vertices-uptodate?~ sector #f)
        (invalidate-lightmaps~ zone elem))))
  
  
  (method (import-model)
    (let ((pane (find-type~ interface Model-Import)))
      (if pane
          (close~ pane)
        (open-frame (new Model-Import size: {Dimension 366 588} location: 'center)))))
  
  
  (method (collect-models)
    (let ((models '()))
      (define (scan-assets)
        (let (iter (scan all-assets))
          (when (not-null? scan)
            (let ((assets (car scan)))
              (scan-directory (new-directory~ assets "model"))
              (iter (cdr scan))))))
      
      (define (scan-directory models-dir)
        (when (exists?~ models-dir)
          (iterate-directory~ models-dir
            (lambda (path kind)
              (let ((dir (new-directory~ models-dir path)))
                (when (or (exists?~ (new-file~ dir (make-filename (get-name~ dir) "ms3d")))
                          (exists?~ (new-file~ dir (make-filename (get-name~ dir) "obj"))))
                  (set! models (cons (join path "/") models)))))
            full?: #f
            files?: #f
            directories?: #t
            recursive?: #t)))
      
      (scan-assets)
      (sort di<? models)))
  
  
  (method (add-model path)
    (let ((me (current-me)))
      (define (determine-position)
        (let ((pos (if first-person? (vertex-& (get-position~ me) (vertex 0. (get-radius-y~ me) 0.)) (vertex-& eye (vertex 0. 1. 0.)))))
          (vertex+ pos (vertex-scalar*& (get-sight~ eye-lookat) 2.))))
      
      (place-model path (determine-position) class: Actor user-origin?: #t)
      (set! last-model path)))
  
  
  (method (add-last-model)
    (if (not last-model)
        (import-model)
      (add-model last-model)))
  
  
  (method public (place-element elem position)
    (let ((zone (current-zone)))
      (let ((properties (list position: position)))
        (add-child~ (get-designer~ zone) elem zone import: '(world.data) properties: properties)
        (add-element~ zone elem)
        elem)))
  
  
  (method public (place-model path position (scale: scale #f) (class: class #f) (animate?: animate? #t) (animation: animation #f) (savable?: savable? #t) (user-origin?: user-origin? #f))
    (let ((zone (current-zone)))
      (let ((scale (or scale (find-setting 'world.import-scale 1.))))
        (let ((scale (if (flonum? scale) (vertex scale scale scale) scale)))
          (let ((class (or class Entity))
                (properties (list path: path scale: scale position: position animate?: animate? animation: animation)))
            (let ((entity (apply new class properties)))
              (when savable?
                (add-child~ (get-designer~ zone) entity zone import: '(world.data) properties: properties))
              (add-element~ zone entity)
              (when user-origin?
                (set-target entity user-origin?: #t))
              entity))))))
  
  
  (method public (find-model path (error?: error? #t))
    (define (search-assets existing-time)
      (let (iter (scan all-assets))
        (if (null? scan)
            (values #f #f)
          (let ((assets (car scan)))
            (or (search-in (new-directory~ assets "model") existing-time)
                (iter (cdr scan)))))))
    
    (define (search-in models-dir existing-time)
      (when (exists?~ models-dir)
        (let ((dir (new-directory~ models-dir path)))
          (when (exists?~ dir)
            (let ((ms3d (new-file~ dir (make-filename (get-name~ dir) "ms3d"))))
              (if (changed? ms3d existing-time)
                  (values ms3d (make-ms3d ms3d))
                #f
                @obj-format-needs-fixing
                (let ((obj (new-file~ dir (make-filename (get-name~ dir) "obj"))))
                  (if (changed? obj existing-time)
                      (values obj (make-obj obj))
                    #f))))))))
    
    (define (changed? file existing-time)
      (and (exists?~ file)
           (or (not existing-time)
               (/= (time->seconds (get-modification-time~ file)) existing-time))))
    
    (define (make-ms3d ms3d)
      (load-ms3d ms3d))
    
    (define (make-obj obj)
      (let ((png (new-brother~ obj (make-filename (get-base~ obj) "png"))))
        (assert (exists?~ png)
          (load-obj obj (make-file-texture png)))))
    
    (let ((existing-model (table-ref models path #f)))
      (let ((existing-time (and existing-model (get-path-time~ existing-model))))
        (receive (file model) (search-assets existing-time)
          (if (not model)
              (or existing-model
                  (if error?
                      (error "Unable to find model: {a}" path)
                    #f))
            (set-file~ model file)
            (set-path~ model path)
            (set-path-time~ model (time->seconds (get-modification-time~ file)))
            (table-set! models path model)
            model)))))
  
  
  (method (reload-model path)
    (table-clear models path))
  
  
  (method (change-target-animation (reversed?: reversed? #f))
    (define (collect-animations)
      (when (and target (is? target Entity))
        (let ((model (get-model~ target)))
          (when model
            (let ((animations (get-animations~ model)))
              (when animations
                (cons #f (sort di<? (table-keys animations)))))))))
    
    (let ((animations (collect-animations)))
      (if animations
          (let ((next (if reversed? previous-element next-element)))
            (let ((new-animation (next animations (get-animation~ target) test: equal?)))
              (set-animation~ target new-animation)
              (transition-morphing~ target new-animation)
              (display-message (or new-animation "Idle"))))
        (bell))))
  
  
  (method (select/run-script)
    (let ((pane (find-type~ interface Script-Run)))
      (if pane
          (close~ pane)
        (open-frame (new Script-Run size: {Dimension 366 588} location: 'center)))))
  
  
  (method (run-last-script)
    (if (not last-script)
        (select/run-script)
      (run-script last-script)))
  
  
  (method (collect-scripts)
    (let ((scripts '()))
      (define (scan-assets)
        (let (iter (scan all-assets))
          (when (not-null? scan)
            (let ((assets (car scan)))
              (scan-directory (new-directory~ assets "script"))
              (iter (cdr scan))))))
      
      (define (scan-directory scripts-dir)
        (when (exists?~ scripts-dir)
          (iterate-directory~ scripts-dir
            (lambda (path kind)
              (set! scripts (cons (cons scripts-dir (join path "/")) scripts)))
            full?: #f
            files?: #t
            directories?: #f
            recursive?: #t)))
      
      (scan-assets)
      (sort di<? scripts key: cdr)))
  
  
  (method (find-script path)
    (find (collect-scripts) path test: equal? key: (lambda (info) (extract-base (cdr info))) return: 'item))
  
  
  (method (run-script script)
    (launch-script script)
    (set! last-script script))
  
  
  (method (launch-script script)
    (bind (dir . path) script
      (load-script (parse~ (new-file~ dir path)))))
  
  
  (method (execute-script path)
    (let ((script (find-script path)))
      (if script
          (launch-script script)
        (display-error (format "Unable to find script: {a}" path))
        (bell))))
  
  
  (method (toggle-grid)
    (set! grid? (not grid?))
    (activate-3d)
    (update-parameter 'grid))
  
  
  (method (toggle-grid-plane plane)
    (if (and grid? (eq? grid-plane plane))
        (set! grid? #f)
      (set! grid? #t)
      (set! grid-plane plane)
      (activate-3d)))
  
  
  (method (decrease-grid)
    (move-grid-by -1))
  
  
  (method (increase-grid)
    (move-grid-by 1))
  
  
  (method (move-grid delta)
    (move-grid-by (fxround/ (- delta) 120)))
  
  
  (method (move-grid-by incr)
    (let ((dist incr))
     (increase! grid-position dist)
     (display-status (format "Grid at {a}" grid-position))))
  
  
  (method (editor-add-at mode vert)
    (let ((zone (current-zone))
          (class (editor-element-class)))
      (let ((element (editor-add-element mode class vert)))
        (set-modified?~ zone #t)
        (update-future)
        element)))
  
  
  (method (editor-add-block mode grid? grid-plane grid-position eye direction first?)
    (let ((zone (current-zone)))
      (define (determine-filter)
        (when (not first?)
          (case mode
            ((block) (block-filter))
            ((column) column-filter)
            ((free) free-filter)
            ((crazy) #f))))
      
      (define (block-filter)
        (let ((accessor (and editor-normal
                             (cond ((/= (vertex-x editor-normal) 0.) vertex-x)
                                   ((/= (vertex-y editor-normal) 0.) vertex-y)
                                   ((/= (vertex-z editor-normal) 0.) vertex-z)))))
          (lambda (poly normal)
            (and editor-normal
                 (vertex=? normal editor-normal)
                 (or (not editor-from)
                     (= (accessor (get-center~ poly)) (accessor editor-from)))))))
      
      (define (column-filter poly normal)
        (and (vertex=? normal editor-normal)
             editor-from
             (let ((center (get-center~ poly)))
               (or (vertex=? center editor-from)
                   (vertex=? (vertex-normalize& (vertex-& center editor-from)) editor-normal)))))
      
      (define (free-filter poly normal)
        (vertex=? normal editor-normal))
      
      (define (add-block vert poly normal)
        (let ((actual (vertex->element~ zone vert)))
          (unless (and (is? actual Block) (vertex=? vert (get-position~ actual)))
            (let ((added (editor-add-at mode vert)))
              (when first?
                (set! editor-normal normal)
                (set! editor-from (if poly
                                      (get-center~ poly)
                                    (vertex+ (get-position~ added) (vertex-scalar*& normal -1.))))
                (set! editor-floor? (boolean (not poly))))))))
      
      (let ((closest (ray-closest-polygon eye direction view-radius filter: (determine-filter) ignore-players?: #t)))
        (if closest
            (bind (poly distance) closest
              (let ((element (get-element~ poly))
                    (normal (get-normal~ poly)))
                (if (and brush-mode? brush)
                    (receive (face face-rank) (find-face~ element poly)
                      (set-face-texture element face face-rank brush)
                      (set! editor-normal normal))
                  (add-block (vertex+ (get-center~ poly) (vertex-scalar*& normal .5)) poly normal))))
          (when (or first? (memq? mode '(free crazy)) (and editor-floor? (neq? mode 'column)))
            (let ((vert (ray-plane-intersection eye direction grid? grid-plane grid-position floor-grid?: #t)))
              (when vert
                (let ((actual (vertex->element~ zone vert)))
                  (unless actual
                    (add-block vert #f world-up))))))))))
  
  
  (method (editor-edit mode grid? grid-plane grid-position eye direction stage)
    (let ((zone (current-zone)))
      (case stage
        ((down)
         (if (memq? mode '(block column free crazy))
             (editor-add-block mode grid? grid-plane grid-position eye direction #t)
           (let ((vert (ray-plane-intersection eye direction grid? grid-plane grid-position)))
             (if (not vert)
                 (begin
                   (unless grid?
                     (display-error "3d edition requires a grid"))
                   (bell))
               (let ((obj (vertex->element~ zone vert)))
                 (cond (obj
                         (show-cursor)
                         (set! preserved-mouse #f)
                         (set! editor-anchor #f)
                         (set! editor-last #f)
                         (set! deleting? #t)
                         (editor-remove-element obj)
                         (set-modified?~ zone #t)
                         (update-future))
                       (else
                        (show-cursor)
                        (set! preserved-mouse #f)
                        (set! editor-anchor #f)
                        (set! editor-last #f)
                        (set! adding? #t)
                        (editor-add-at mode vert)
                        (update-future))))))))
        ((move)
         (if (memq? mode '(block column free crazy))
             (editor-add-block mode grid? grid-plane grid-position eye direction #f)
           (let ((vert (ray-plane-intersection eye direction grid? grid-plane grid-position)))
             (when vert
               (let ((obj (vertex->element~ zone vert)))
                 (cond (obj
                         (if (and adding? (eq? mode 'rectangle))
                             (let ((class (editor-element-class)))
                               (editor-add-element mode class vert)
                               (set-modified?~ zone #t)
                               (update-future))
                           (when deleting?
                             (editor-remove-element obj)
                             (set-modified?~ zone #t)
                             (update-future))))
                       (else
                        (when adding?
                          (let ((class (editor-element-class)))
                            (editor-add-element mode class vert)
                            (set-modified?~ zone #t))
                          (update-future)))))))))
        ((up)
         (set! editing? #f)
         (set! adding? #f)
         (set! deleting? #f)
         (set! editor-normal #f)
         (set! editor-from #f)
         (set! editor-floor? #f)))))
  
  
  (method (warn-non-editable)
    (let ((zone (current-zone)))
      (unless (get-editable-warned?~ zone)
        (set-editable-warned?~ zone #t)
        (open-message "Zone is not editable"
                      caption: "Edition"
                      type: 'message
                      execute: (lambda (evt)
                                 (let ((dialog (find-ascendant~ (get-sender~ evt) World-Dialog)))
                                   (close~ dialog)))))))
  
  
  (method (editor-delete position)
    (let ((zone (current-zone)))
      (if (zone-editable?~ zone)
          (let ((element (element-at~ zone position)))
            (when element
              (editor-remove-element element)
              (set-modified?~ zone #t)
              (update-future)))
        (warn-non-editable))))
  
  
  (method (editor-mouse-down h v)
    (let ((zone (current-zone)))
      (when (control-down?)
        (if (zone-editable?~ zone)
            (let ((me (current-me)))
              (receive (eye direction) (screen->ray h v)
                (if paused?
                    (editor-edit editor-mode grid? grid-plane grid-position eye direction 'down)
                  (add-action~ commands 'edit (list editor-mode grid? grid-plane grid-position eye direction 'down)))
                (set! editing? #t)))
          (warn-non-editable)))))
  
  
  (method (editor-mouse-move h v)
    (when editing?
      (let ((me (current-me)))
        (receive (eye direction) (screen->ray h v)
          (if paused?
              (editor-edit editor-mode grid? grid-plane grid-position eye direction 'move)
            (add-action~ commands 'edit (list editor-mode grid? grid-plane grid-position eye direction 'move)))))))
  
  
  (method (editor-mouse-up h v)
    (let ((zone (current-zone))
          (me (current-me)))
      (receive (eye direction) (screen->ray (get-h~ down-point) (get-v~ down-point))
        (if editing?
            (if paused?
                (editor-edit editor-mode grid? grid-plane grid-position eye direction 'up)
              (add-action~ commands 'edit (list editor-mode grid? grid-plane grid-position eye direction 'up)))
          (case projection
            ((perspective)
             (let ((closest (ray-closest-polygon eye direction view-radius ignore-entities?: #f ignore-players?: #t)))
               (if (not closest)
                   (set-target #f user-origin?: #t)
                 (bind (poly distance) closest
                   (let ((element (get-element~ poly)))
                     (set-target element polygon: poly user-origin?: #t))))))
            (else
             (let ((vert (ray-plane-intersection eye direction grid? grid-plane grid-position)))
               (if (not vert)
                   (set-target #f user-origin?: #t)
                 (set-target (vertex->element~ zone vert) user-origin?: #t)))))))
      (set! editing? #f)
      (set! adding? #f)
      (set! deleting? #f)
      (set! editor-anchor #f)
      (set! editor-last #f)
      (set! editor-added #f)))
  
  
  (method (draw-editor-target)
    (case target-mode
      ((translate) (draw-translater))
      ((rotate) (draw-rotater))
      ((scale) (draw-scaler))))
  
  
  (method (draw-translater)
    (let ((x (get-x~ target))
          (y (get-y~ target))
          (z (get-z~ target))
          (sx (+ 1.5 (get-radius-x~ target)))
          (sy (+ 1.5 (get-radius-y~ target)))
          (sz (+ 1.5 (get-radius-z~ target))))
      (glLineWidth 2.)
      (glDisable GL_LIGHTING)
      (glDisable GL_DEPTH_TEST)
      ;; Axes
      (glBegin GL_LINES)
      ;; X
      (gl-colorize-dye red-dye)
      (glVertex3f (+ x 0.0) y (+ z 0.0))
      (glVertex3f (+ x  sx) y (+ z 0.0))
      
      ;; Y
      (gl-colorize-dye green-dye)
      (glVertex3f (+ x 0.0) (+ y 0.0) z)
      (glVertex3f (+ x 0.0) (+ y  sy) z)
      
      ;; Z
      (gl-colorize-dye blue-dye)
      (glVertex3f (+ x 0.0) y (+ z 0.0))
      (glVertex3f (+ x 0.0) y (+ z  sz))
      (glEnd)
      (glEnable GL_LIGHTING)
      (glLineWidth 1.)
      
      ;; Cone X
      (glPushMatrix)
      (glTranslatef (+ x sx) y z)
      (glRotatef 90.0 0.0 1.0 0.0)
      (glScalef 0.1 0.1 0.1)
      (gl-colorize-dye red-dye)
      (gl-cylinder 1. 0. 2. 26 52)
      (glPopMatrix)
      
      ;; Cone Y
      (glPushMatrix)
      (glTranslatef x (+ y sy) z)
      (glRotatef -90.0 1.0 0.0 0.0)
      (glScalef 0.1 0.1 0.1)
      (gl-colorize-dye green-dye)
      (gl-cylinder 1. 0. 2. 26 52)
      (glPopMatrix)
      
      ;; Cone Z
      (glPushMatrix)
      (glTranslatef x y (+ z sz))
      (glRotatef -90.0 0.0 0.0 1.0)
      (glScalef 0.1 0.1 0.1)
      (gl-colorize-dye blue-dye)
      (gl-cylinder 1. 0. 2. 26 52)
      (glPopMatrix)
      (glEnable GL_DEPTH_TEST)))
  
  
  (method (draw-rotater)
    (let ((x (get-x~ target))
          (y (get-y~ target))
          (z (get-z~ target))
          (radius (+ .5 (get-radius~ target))))
      (glLineWidth 2.)
      (glDisable GL_LIGHTING)
      (glDisable GL_DEPTH_TEST)
      ;; Rotate X
      (glPushMatrix)
      (glTranslatef x y z)
      (glRotatef 90.0 0.0 1.0 0.0)
      (gl-segment-circle {Point 0 0} radius {Color Red} 100)
      (glPopMatrix)
      
      ;; Rotate Y
      (glPushMatrix)
      (glTranslatef x y z)
      (glRotatef 90.0 1.0 0.0 0.0)
      (gl-segment-circle {Point 0 0} radius {Color Green} 100)
      (glPopMatrix)
      
      ;; Rotate Z
      (glPushMatrix)
      (glTranslatef x y z)
      (glRotatef 90.0 0.0 0.0 1.0)
      (gl-segment-circle {Point 0 0} radius {Color Blue} 100)
      (glPopMatrix)
      (glEnable GL_LIGHTING)
      (glEnable GL_DEPTH_TEST)
      (glLineWidth 1.)))
  
  
  (method (draw-scaler)
    (let ((x (get-x~ target))
          (y (get-y~ target))
          (z (get-z~ target))
          (sx (+ 1.5 (get-radius-x~ target)))
          (sy (+ 1.5 (get-radius-y~ target)))
          (sz (+ 1.5 (get-radius-z~ target))))
      (glLineWidth 2.)
      (glDisable GL_LIGHTING)
      (glDisable GL_DEPTH_TEST)
      ;; Axes
      (glBegin GL_LINES)
      ;; X
      (gl-colorize-dye red-dye)
      (glVertex3f (+ x 0.0) y (+ z 0.0))
      (glVertex3f (+ x  sx) y (+ z 0.0))
      
      ;; Y
      (gl-colorize-dye green-dye)
      (glVertex3f (+ x 0.0) (+ y 0.0) z)
      (glVertex3f (+ x 0.0) (+ y  sy) z)
      
      ;; Z
      (gl-colorize-dye blue-dye)
      (glVertex3f (+ x 0.0) y (+ z 0.0))
      (glVertex3f (+ x 0.0) y (+ z  sz))
      (glEnd)
      (glEnable GL_LIGHTING)
      (glLineWidth 1.)
      
      ;; Sphere X
      (glPushMatrix)
      (glTranslatef (+ x sx) y z)
      (glRotatef 90.0 0.0 1.0 0.0)
      (glScalef 0.1 0.1 0.1)
      (gl-colorize-dye red-dye)
      (gl-sphere 1. 26 52)
      (glPopMatrix)
      
      ;; Sphere Y
      (glPushMatrix)
      (glTranslatef x (+ y sy) z)
      (glRotatef -90.0 1.0 0.0 0.0)
      (glScalef 0.1 0.1 0.1)
      (gl-colorize-dye green-dye)
      (gl-sphere 1. 26 52)
      (glPopMatrix)
      
      ;; Sphere Z
      (glPushMatrix)
      (glTranslatef x y (+ z sz))
      (glRotatef -90.0 0.0 0.0 1.0)
      (glScalef 0.1 0.1 0.1)
      (gl-colorize-dye blue-dye)
      (gl-sphere 1. 26 52)
      (glPopMatrix)
      (glEnable GL_DEPTH_TEST)))
  
  
  (method (translate-target delta)
    (when target
      (translate-element target delta)))
  
  
  (method (rotate-target delta)
    (when target
      (rotate-element target delta)))
  
  
  (method (scale-target delta)
    (when target
      (scale-element target delta)))
  
  
  (method (translate-element elem delta)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone))
            (d (- (cast <fl> (/ delta 120.)))))
        (let ((old-position (get-position~ elem))
              (dist (cond ((shift-down?) (vertex 0. 0. d))
                          ((alt-down?) (vertex d 0. 0.))
                          (else (vertex 0. d 0.)))))
          (let ((new-position (vertex+ old-position dist)))
            (set-property~ designer elem 'position new-position)
            (update-area~ zone elem old-position)
            (update-sector~ zone elem old-position)
            (invalidate-lightmaps~ zone elem))))))
  
  
  (method (rotate-element elem delta)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone))
            (d (cast <fl> (/ delta 120.))))
        (let ((inc (* d (/ PI/8 2.))))
          (cond ((shift-down?) (rotate-lookat! (get-lookat~ elem) inc (get-right~ (get-lookat~ elem))))
                ((alt-down?) (rotate-lookat! (get-lookat~ elem) inc (get-sight~ (get-lookat~ elem))))
                (else (rotate-lookat! (get-lookat~ elem) inc (get-up~ (get-lookat~ elem)))))
          (set-property~ designer elem 'lookat (get-lookat~ elem))))))
  
  
  (method (scale-element elem delta)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone))
            (d (cast <fl> (/ delta 120.))))
        (let ((factor (if (< d 0.) 1.1 (/ 1.1))))
          (let ((s (cond ((and (alt-down?) (shift-down?)) (vertex factor factor factor))
                         ((shift-down?) (vertex 1. 1. factor))
                         ((alt-down?) (vertex factor 1. 1.))
                         (else (vertex 1. factor 1.)))))
            (set-property~ designer elem 'scale (vertex* (get-scale~ elem) s)))))))
  
  
  ;;;
  ;;;; Screen
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (frustum-normals! left-normal <f64vector> bottom-normal <f64vector> right-normal <f64vector> top-normal <f64vector>) <void>
    ;; copied from screen->ray for performance
    (let ((ratio (/ width height))
          (half-fov (/ (degree->radian perspective-fov) 2.))
          (eye-up (get-up~ eye-lookat)))
      (let ((cone (tan half-fov))
            (d (f64-ref (vertex-distance& eye eye-target)))
            (right (cross-product& (vertex-& eye-target eye) eye-up)))
        (define (compute-normal! res <f64vector> h <fl> v <fl>) <void>
          (let ((ch (- h (/ width 2.)))
                (cv (- (- height v) (/ height 2.))))
            (let ((target-in-eye-space (vertex+& (vertex-scalar*& eye-up (/ (* cv d cone 2.) height))
                                                 (vertex+& (vertex-scalar*& right (/ (* ch d cone 2. ratio) width))
                                                           eye-target))))
              (vertex-normalize! res (vertex-& target-in-eye-space eye)))))
        
        (let ((r00 (make-vertex&))
              (r01 (make-vertex&))
              (r10 (make-vertex&))
              (r11 (make-vertex&)))
          (compute-normal! r00 0. 0.)
          (compute-normal! r01 0. height)
          (compute-normal! r10 width 0.)
          (compute-normal! r11 width height)
          (cross-product! left-normal r01 r00)
          (cross-product! bottom-normal r00 r10)
          (cross-product! right-normal r10 r11)
          (cross-product! top-normal r11 r01)))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (screen->ray h v)
    (let ((ratio (/ width height))
          (ch (- h (/ width 2)))
          (cv (- (- height v) (/ height 2))))
      (case projection
        ((perspective)
         (let ((half-fov (/ (degree->radian perspective-fov) 2.))
               (eye-up (get-up~ eye-lookat)))
           (let ((cone (tan half-fov))
                 (d (vertex-distance eye eye-target))
                 (right (cross-product& (vertex-& eye-target eye) eye-up)))
             (let ((target-in-eye-space (vertex+& (vertex-scalar*& eye-up (/ (* cv d cone 2.) height))
                                                  (vertex+& (vertex-scalar*& right (/ (* ch d cone 2. ratio) width))
                                                            eye-target))))
               (values (copy-vertex eye) (vertex-normalize (vertex-& target-in-eye-space eye)))))))
        ((orthographic)
         (let ((x (+ (/ (* 2. ch zoom-factor) width) (vertex-x eye)))
               (y (+ (/ (* 2. cv zoom-factor) height ratio) (vertex-y eye))))
           (values (vertex x y (vertex-z eye)) (vertex 0. 0. -1.)))))))
  
  
  (method (world->screen vertex)
    (camera->screen eye eye-lookat vertex))
  
  
  (method (camera->screen eye eye-lookat vertex)
    (let ((projection (make-projection-matrix& perspective-fov (/ width height) perspective-near perspective-far))
          (view (make-view-matrix& eye eye-lookat)))
      (let ((projection/view (matrix-multiply& projection view)))
        (let ((vert (matrix-transform& projection/view vertex)))
          (new Point
            (fxround (* (+ (vertex-x vert) 1.) (/ width 2.)))
            (fxround (* (- 1. (vertex-y vert)) (/ height 2.))))))))
  
  
  (method (ray-plane-intersection eye direction grid? grid-plane grid-position (floor-grid?: floor-grid? #f))
    (let ((zone (current-zone)))
      (define (perspective->world norm plane-k)
        (let ((norm-direction-inner-product (inner-product norm direction)))
          (unless (and (= norm-direction-inner-product 0.)
                       (case grid-plane
                         ((x) (= (vertex-x eye) grid-position))
                         ((y) (= (vertex-y eye) grid-position))
                         ((z) (= (vertex-z eye) grid-position))))
            (let ((intersect (/ (- plane-k (inner-product norm eye))
                                norm-direction-inner-product)))
              (unless (<= intersect 0)
                (let ((point (vertex+ eye (vertex-scalar*& direction intersect))))
                  (if (> norm-direction-inner-product 0.)
                      (values (vertex- point (vertex-scalar*& norm 1.)) (+ grid-position -1.))
                    (values point grid-position))))))))
      
      (if (eq? projection 'orthographic)
          (let ((info (perspective->world (vertex 0. 0. 1.) 0.)))
            (when info
              (receive (vert position) info
                (and vert (vertex
                            (vertex-x vert)
                            (vertex-y vert)
                            position)))))
        (if (not grid?)
            (when floor-grid?
              (let ((floor-level (get-floor-level~ zone)))
                (when floor-level
                  (let ((info (perspective->world (vertex 0. 1. 0.) floor-level)))
                    (when info
                      (receive (vert position) info
                        (and vert (vertex
                                    (vertex-x vert)
                                    position
                                    (vertex-z vert)))))))))
          (case grid-plane
            ((x) (let ((info (perspective->world (vertex 1. 0. 0.) grid-position)))
                   (when info
                     (receive (vert position) info
                       (and vert (vertex
                                   position
                                   (vertex-y vert)
                                   (vertex-z vert)))))))
            ((y) (let ((info (perspective->world (vertex 0. 1. 0.) grid-position)))
                   (when info
                     (receive (vert position) info
                       (and vert (vertex
                                   (vertex-x vert)
                                   position
                                   (vertex-z vert)))))))
            ((z) (let ((info (perspective->world (vertex 0. 0. 1.) grid-position)))
                   (when info
                     (receive (vert position) info
                       (and vert (vertex
                                   (vertex-x vert)
                                   (vertex-y vert)
                                   position)))))))))))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-future? initialize #t getter generate)
  
  
  (method (toggle-paused)
    (unimplemented-connected)
    (if paused?
        (unpause-world)
      (pause-world)))
  
  
  (method (pause-world)
    (when history?
      (set-current~ history (snapshot-world)))
    (set! paused? #t)
    (reset-counters)
    (update-parameter 'paused))
  
  
  (method (unpause-world)
    (truncate-future)
    (set-current~ history #f)
    (set! paused? #f)
    (camera-behind-player)
    (follow-player)
    (reset-last-tick)
    (reset-counters)
    (update-parameter 'paused))
  
  
  (method (snapshot-world)
    (let ((zone (current-zone)))
      (snapshot-zone~ zone)))
  
  
  (method (metadata-snapshot-world)
    ;; need to generalize to all actors
    (define (determine-metadata)
      (let ((me (current-me)))
        (let ((bounds (make-cuboid)))
          (get-bounds!~ me bounds)
          bounds)))
    
    (values (determine-metadata) (snapshot-world)))
  
  
  (method (load-world snapshot)
    (let ((zone (current-zone)))
      (let ((previous-target target))
        (load-zone~ zone snapshot)
        (set-current-me (find-player (get-actors~ zone)))
        (when (is? previous-target Actor)
          (set-target (find-target previous-target (get-actors~ zone)))))))
  
  
  (method (serialize-world)
    (object->u8vector history serialize))
  
  
  (method (deserialize-world content)
    (u8vector->object content deserialize))
  
  
  (method (install-history hist)
    (set! history hist)
    (goto-history~ history (get-now~ history)))
  
  
  (method (find-player actors)
    (find-if (lambda (obj)
               (is? obj Player))
             actors))
  
  
  (method (find-named-player player-name)
    (let ((zone (current-zone)))
      (find-if (lambda (actor)
                 (and (is? actor Player)
                      (equal? (get-name~ actor) player-name)))
               (get-actors~ zone))))
  
  
  (method (find-target target elements)
    (let ((original (get-original~ target)))
      (find-if (lambda (obj)
                 (eq? (get-original~ obj) original))
               elements)))
  
  
  (method (set-target targ (polygon: polygon #f) (user-origin?: user-origin? #f))
    (let ((zone (current-zone)))
      (receive (face face-rank) (if (and targ polygon)
                                    (find-face~ targ polygon)
                                  (values #f #f))
        (when (and user-origin? (neq? targ target) (or (is? targ Actor) (and (is-not? targ Actor) (is? target Actor))))
          (play-sound-file (if (is? targ Actor) "sound/user/selectTarget" "sound/user/deselectTarget")))
        (set! target targ)
        (set! target-polygon polygon)
        (set! target-face face)
        (set! target-face-rank face-rank)
        (target-update target face face-rank polygon)
        (target-update~ zone target face face-rank polygon)
        (invalidate-view~ interface))))
  
  
  (method (toggle-draw-elements)
    (set! draw-elements? (not draw-elements?))
    (update-parameter 'elements)
    (display-on/off "Draw elements" draw-elements?))
  
  
  ;;;
  ;;;; Music
  ;;;
  
  
  (method (change-music)
    (let ((queue (new-queue)))
      (for-each (lambda (assets)
                  (let ((music-dir (new-directory~ assets "music")))
                    (when (exists?~ music-dir)
                      (iterate-directory~ music-dir
                        (lambda (path kind)
                          (let ((path (join path "/")))
                            (when (extension=? (extract-extension path) "mp3")
                              (enqueue queue (extract-base path)))))
                        full?: #f
                        files?: #t
                        directories?: #f))))
                all-assets)
      (let ((music-list (queue-list queue)))
        (if (null? music-list)
            (display-error "No music found")
          (let ((music (random-element music-list)))
            (play-ambiance (concatenate "music/" music)))))))
  
  
  (method (play-intro-music)
    (play-ambiance "music/Intro"))
  
  
  (method (play-ambiance path)
    (play-music-file path "ambiance"))
  
  
  (method (play-music-file path name)
    (let ((file (effective-music-file path)))
      (when file
        (close-music name)
        (open-music file name)
        (play-music name))))
  
  
  (method (effective-music-file path)
    (when path
      (continuation-capture
        (lambda (return)
          (for-each (lambda (assets)
                      (let ((mp3 (new-file~ assets (make-filename path "mp3"))))
                        (if (exists?~ mp3)
                            (continuation-return return mp3)
                          (let ((ogg (new-file~ assets (make-filename path "ogg"))))
                            (when (exists?~ ogg)
                              (continuation-return return ogg))))))
                    all-assets)
          #f))))
  
  
  (method (play-sound-file path)
    (let ((file (effective-sound-file path)))
      (when file
        (play-sound file))))
  
  
  (method (effective-sound-file path)
    (when path
      (continuation-capture
        (lambda (return)
          (for-each (lambda (assets)
                      (let ((wav (new-file~ assets (make-filename path "wav"))))
                        (when (exists?~ wav)
                          (continuation-return return wav))))
                    all-assets)
          #f))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method (evaluate-hook syntax str container line col)
    (let ((zone (current-zone)))
      @test
      (setup-lighting~ zone)
      (when (search container "shaders")
        (let ((new-program (new Mesh-Phong-Program)))
          (table-set! mesh-programs 'phong new-program)
          (when (eq? (get-current~ tile-program-folio) 'phong)
            (set! tile-program new-program))))
      (when (search str "define-block")
        (increase-current-content-revision))
      (when evaluate-future?
        (update-future))
      @test
      (update-world-options~ (get-application))
      @test
      (install-skins~ (get-application))
      @test
      (install-bindings~ (get-application))
      (invalidate-view~ interface)
      (reset-counters)
      (render-scene~ (current-world-window))))
  
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method (test1)
    (dispatch-to (find-setting 'world.test1 'test1)))
  
  
  (method (test2)
    (dispatch-to (find-setting 'world.test2 'test2)))
  
  
  (method (test3)
    (dispatch-to (find-setting 'world.test3 'test3)))
  
  
  (method (test4)
    (dispatch-to (find-setting 'world.test4 'test4)))
  
  
  (method (test5)
    (dispatch-to (find-setting 'world.test5 'test5)))
  
  
  (method (test6)
    (dispatch-to (find-setting 'world.test6 'test6)))
  
  
  (method (test7)
    (dispatch-to (find-setting 'world.test7 'test7)))
  
  
  (method (test8)
    (dispatch-to (find-setting 'world.test8 'test8)))
  
  
  (method (test9)
    (dispatch-to (find-setting 'world.test9 'test9)))
  
  
  (method (test0)
    (dispatch-to (find-setting 'world.test0 'test0)))
  
  
  (method (dispatch-to to)
    (cond ((not to)
           (bell))
          ((symbol? to)
           (let ((profile (get-profile~ (get-application))))
             (if profile
                 (let ((dispatch (find-dispatch (class-of profile) to)))
                   (if dispatch
                       (dispatch profile)
                     (display-error (format "Unable to find method {a} in profile" to))
                     (bell)))
               (bell))))
          ((string? to)
           (execute-script to))
          (else
           (error "Invalid test setting: {a}" to))))
  
  
  ;;;
  ;;;; GC
  ;;;
  
  
  (method (setup-gc)
    (add-gc-interrupt-job!
      (lambda ()
        (when gc-sound?
          (gc-sound))
        (process~ (find-counter 'memory) (last-gc-real-time)))))
  
  
  (cond-expand
    (windows
     (definition (gc-sound)
       (MessageBeep MB_ICONINFORMATION)))
    (else
     (definition (gc-sound)
       (bell))))
  
  
  ;;;
  ;;;; Slider
  ;;;
  
  
  (slot sliding? initialize #f)
  
  
  (method (slider-mouse-down h v)
    (set! sliding? #t)
    (unless (inside-slider-thumb?~ history h v)
      (slide-history (h->where h))))
  
  
  (method (slider-mouse-move h v)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-up h v)
    (set! sliding? #f))
  
  
  (method (h->where h)
    (let ((cx (fxround (/ width 2.))))
      (let ((where (/ (+ (- h cx) 200.) 400.)))
        (max 0. (min 1. where)))))
  
  
  (method (in-slider? v)
    (< v 60))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method protected virtual (mouse-down h v)
    (set! down? #t)
    (set! down-point (new Point h v))
    (cond ((and history? paused? (in-slider? v))
           (slider-mouse-down h v))
          ((and paused? (eq? projection 'perspective))
           (setup-viewing h v)
           (hide/preserve-cursor))
          (else
           (editor-mouse-down h v))))
  
  
  (method protected virtual (mouse-move h v)
    (define (move-camera)
      (when last-point
        (if (and last-recenter
                 (= (get-h~ last-recenter) h)
                 (= (get-v~ last-recenter) v))
            (set! last-recenter #f)
          (let ((new-point (new Point h v))
                (new-time (current-seconds)))
            (let ((elapse (- new-time last-time)))
              (when (> elapse 0)
                (let ((delta (nu- new-point last-point)))
                  (let ((dh (get-h~ delta))
                        (dv (get-v~ delta)))
                    (mouse-track elapse dh dv)))))
            ;; hack
            (if (eq? kernel-windowing 'cocoa)
                (begin
                  (set! last-point (new Point h v) @hack (new Point (fxround (/ width 2)) (fxround (/ height 2))))
                  (set! last-time new-time)
                  (set! last-recenter (new Point (fxround (/ width 2)) (fxround (/ height 2))))
                  @hack
                  (set-mouse-position~ window last-recenter))
              (set! last-point (new Point (fxround (/ width 2)) (fxround (/ height 2))))
              (set! last-time new-time)
              (set! last-recenter (new Point (fxround (/ width 2)) (fxround (/ height 2))))
              (set-mouse-position~ window last-recenter))))))
    
    (cond ((and history? paused? sliding?)
           (slider-mouse-move h v))
          ((and paused? (eq? projection 'perspective))
           (move-camera))
          (last-point
           (move-camera)
           (unless moving?
             (follow-player)))
          (editing?
           (editor-mouse-move h v))
          ((and down? (not (near? (new Point h v) down-point drag-tolerance)))
           (hide/preserve-cursor)
           (set! viewing? #t)
           (setup-viewing h v))))
  
  
  (method protected virtual (mouse-track elapse dh dv)
    (define (track-camera)
      (rotate-horizontal (/ (- (cast <fl> dh)) track-sensitivity))
      (rotate-vertical (/ (- (cast <fl> dv)) track-sensitivity)))
    
    (when (eq? projection 'perspective)
      (let ((me (current-me)))
        (if (and moving? first-person? (or (not paused?) (neq? projection 'perspective)))
            (let ((first? (not moved?)))
              (add-action~ commands 'track (list dh dv (copy-vertex (get-sight~ eye-lookat)) (copy-vertex (get-up~ eye-lookat)) (copy-vertex (get-right~ eye-lookat)) first?))
              (set! moved? #t))
          (track-camera)))))
  
  
  (method protected virtual (mouse-up h v)
    (restore/show-cursor)
    (cond ((and history? paused? sliding?)
           (slider-mouse-up h v))
          ((and paused? (eq? projection 'perspective))
           (reset-viewing))
          (last-point
           (reset-viewing)
           (follow-player))
          (else
           (when down?
             (editor-mouse-up h v))))
    (set! down? #f)
    (set! down-point #f)
    (set! viewing? #f))
  
  
  (method protected virtual (double-click h v)
    (mouse-down h v))
  
  
  (method protected virtual (right-mouse-down h v)
    (hide/preserve-cursor)
    (set! moving? #t)
    (set! moved? #f)
    (setup-viewing h v))
  
  
  (method protected virtual (right-mouse-up h v)
    (let ((me (current-me)))
      (reset-tilt me)
      (restore/show-cursor)
      (set! moving? #f)
      (reset-viewing)))
  
  
  (method (setup-viewing h v)
    (set! last-point (new Point h v))
    (set! last-time (current-seconds)))
  
  
  (method (reset-viewing)
    (set! last-point #f)
    (set! last-time #f))
  
  
  (method (hide/preserve-cursor)
    (hide-cursor)
    (set! preserved-mouse (mouse-position~ window)))
  
  
  (method (restore/show-cursor)
    (when preserved-mouse
      (set-mouse-position~ window preserved-mouse)
      (set! preserved-mouse #f))
    (show-cursor))
  
  
  (method (mouse-wheel h v delta)
    (let ((zone (current-zone))
          (me (current-me)))
      (cond ((control-down?)
             (case target-mode
               ((translate)
                (translate-target delta))
               ((rotate)
                (rotate-target delta))
               ((scale)
                (scale-target delta))
               (else
                (cond ((and first-person? (get-controlled~ me))
                       (scale-element (get-controlled~ me) delta))
                      (grid?
                       (move-grid delta))))))
            ((> delta 0)
             (zoom-in))
            (else
             (zoom-out)))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  ;; quick hack
  (cond-expand
    (windows
     (definition (application-active?)
       (get-active?~ (get-application))))
    (else
     (definition (application-active?)
       #t)))
  
  
  (method protected virtual (process-keys)
    (let ((evt (make-event Keyboard-Event :char self)))
      (process-movement evt allow-space?: paused?)
      (when (application-active?)
        (receive (shift? control? alt?) (modifiers-down)
          (if (and (not control?) (not alt?) (key-down? (char->integer #\5)))
              (warp shift?)
            (unless (or shift? control? alt?)
              (when (key-down? VK_LEFT)
                (move-left))
              (when (key-down? VK_RIGHT)
                (move-right))
              (when (key-down? VK_DOWN)
                (move-down))
              (when (key-down? VK_UP)
                (move-up))
              (when (key-down? (char->integer #\space))
                (if (and first-person? fly?)
                    (strafe-up)
                  (space)))
              (when (key-down? (char->integer #\1))
                (maybe-fire 'bullet))
              (when (key-down? (char->integer #\2))
                (maybe-fire 'bomb))
              (when (key-down? (char->integer #\3))
                (maybe-rapid-fire))
              (when (key-down? (char->integer #\5))
                (on-sprint #f))))))))
  
  
  (method (process-movement evt (allow-space?: allow-space? #t))
    (when (application-active?)
      (let ((shift? (get-shift?~ evt))
            (control? (get-control?~ evt))
            (alt? (get-alt?~ evt)))
        (unless (or shift? control? alt?)
          (let ((w? (key-down? (char->integer #\W)))
                (s? (key-down? (char->integer #\S)))
                (a? (key-down? (char->integer #\A)))
                (d? (key-down? (char->integer #\D)))
                (q? (key-down? (char->integer #\Q)))
                (e? (key-down? (char->integer #\E)))
                (x? (key-down? (char->integer #\X)))
                (r? (key-down? (char->integer #\R)))
                (4? (key-down? (char->integer #\4)))
                (space? (key-down? (char->integer #\space)))
                (right? (key-down? VK_RBUTTON)))
            (process-idleness (and (not w?)
                                   (not s?)
                                   (not a?)
                                   (not d?)
                                   (not q?)
                                   (not e?)
                                   (not x?)
                                   (not r?)
                                   (not 4?)
                                   (not space?)
                                   (not right?)))
            (when 4?
              (if shift?
                  (blink-backward)
                (blink-forward)))
            (when w?
              (move-forward))
            (when s?
              (move-backward))
            (when q?
              (strafe-left))
            (when e?
              (strafe-right))
            (when (or r?
                      (and allow-space? space?))
              (strafe-up))
            (when x?
              (strafe-down))
            (when a?
              (if (is-moving?)
                  (strafe-left)
                (rotate-left)))
            (when d?
              (if (is-moving?)
                  (strafe-right)
                (rotate-right))))))))
  
  
  (method protected virtual (process-shortcut shortcut)
    (if (shortcut=? shortcut {Shortcut Escape})
        (main-menu)
      #f))
  
  
  (method protected virtual (key-down c)
    )
  
  
  (method protected virtual (key-press key)
    )
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method (connect-to-server)
    (let ((process (get-process)))
      (if (get-world-server~ process)
          (display-error "Already connected")
        (connect-server~ process)
        (display-message "Connected" color: {Color Green}))))
  
  
  (method (disconnect-from-server)
    (let ((process (get-process)))
      (if (not (get-world-server~ process))
          (display-error "Not connected")
        (disconnect~ process)
        (display-message "Disconnected"))))
  
  
  (method (request-server-update)
    (let ((process (get-process)))
      (if (not (get-world-server~ process))
          (display-error "Not connected")
        (update-client~ process)
        (display-message "Requesting server update"))))
  
  
  (method (unimplemented-connected)
    (when (get-world-server~ (get-process))
      (display-cancel "Unimplemented when connected")))
  
  
  ;;;
  ;;;; Window
  ;;;
  
  
  (method (live-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error "Not connected to a remote debugger")
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (live-gaia/world~ debugger debuggee)))))
  
  
  (method (design-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error "Not connected to a remote debugger")
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (design-gaia/world~ debugger debuggee)))))
  
  
  (method (restore-gaia/world)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error "Not connected to a remote debugger")
        (let ((debuggee (load-object~ (get-local-register) 'world.debuggee 'world-debuggee))
              (debugger (load-object~ (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (restore-gaia/world~ debugger debuggee)))))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (toggle-mode)
    (set! edition? (not edition?))
    (display-message (format "{a}" (if edition? "Edition" "Game"))))
  
  
  (method (toggle-interface)
    (set! interface? (not interface?))
    (update-parameter 'interface))
  
  
  (method (toggle-polygon-mode)
    (set! polygon-mode (ecase polygon-mode
                         ((GL_POINT) GL_LINE)
                         ((GL_LINE) GL_FILL)
                         ((GL_FILL) GL_POINT)))
    (glPolygonMode GL_FRONT_AND_BACK polygon-mode))
  
  
  (method (toggle-lighting)
    (set! lighting? (not lighting?))
    (update-parameter 'lighting)
    (display-on/off "Lighting" lighting?))
  
  
  (method (toggle-windowed-mode)
    (toggle-windowed-mode~ window)
    (update-parameter 'windowed-mode))
  
  
  (method (toggle-post-processing)
    (set! post-processing? (not post-processing?))
    (update-parameter 'post-processing)
    (display-on/off "Post processing" post-processing?))
  
  
  (method (toggle-first-person)
    (let ((me (current-me)))
      (if first-person?
          (deactivate-first-person)
        (activate-first-person))
      (display-on/off "First person" first-person?)))
  
  
  (method (activate-first-person)
    (unless first-person?
      (set! first-person? #t)
      (camera-center-player)
      (activate-3d)
      (update-parameter 'first-person)))
  
  
  (method (deactivate-first-person)
    (when first-person?
      (set! first-person? #f)
      (update-parameter 'first-person)))
    
  
  (method (toggle-3d)
    (if 3d?
        (deactivate-3d)
      (activate-3d))
    (display-on/off "3d" 3d?))
  
  
  (method (activate-3d)
    (set! 3d? #t)
    (set! lighting? #t)
    (activate-perspective)
    (update-parameter '3d))
  
  
  (method (deactivate-3d)
    (set! 3d? #f)
    (set! lighting? #f)
    (activate-orthographic)
    (update-parameter '3d))
  
  
  (method (toggle-draw-gadgets)
    (set! draw-gadgets? (not draw-gadgets?))
    (update-gadgets)
    (update-parameter 'gadgets)
    (display-on/off "Draw gadgets" draw-gadgets?))
  
  
  (method (toggle-draw-normals)
    (set! draw-normals? (not draw-normals?))
    (update-parameter 'normals)
    (display-on/off "Draw normals" draw-normals?))
  
  
  (method (toggle-draw-atlas)
    (if (get-texture-arrays?)
        (display-error "No atlas")
      (set! draw-atlas? (not draw-atlas?))
      (update-parameter 'draw-atlas)
      (display-on/off "Draw atlas" draw-atlas?)))
  
  
  (method (toggle-draw-me)
    (let ((zone (current-zone)))
      (set-draw-me?~ zone (not (get-draw-me?~ zone)))
      (update-parameter 'draw-me)
      (display-on/off "Draw me" (get-draw-me?~ zone))))
  
  
  (method (update-gadgets)
    (let ((zone (current-zone)))
      (iterate-gadgets~ zone
        (lambda (gadget)
          (set-visible?~ gadget draw-gadgets?)))
      (when (and (is? target Gadget)
                 (not (get-visible?~ target)))
        (set-target #f))))
  
  
  (method (toggle-axes)
    (set! axes? (not axes?))
    (update-parameter 'axes)
    (display-on/off "Axes" axes?))
  
  
  (method (toggle-info)
    (let ((pane (child~ interface 'info)))
      (set-visible?~ pane (not (get-visible?~ pane)))
      (when (get-visible?~ pane)
        (set! interface? #t)))
    (update-parameter 'info))
  
  
  (method (toggle-counters)
    (let ((pane (child~ interface 'counters)))
      (set-visible?~ pane (not (get-visible?~ pane)))
      (when (get-visible?~ pane)
        (set! interface? #t)
        (reset-counters)))
    (update-parameter 'counters))
  
  
  (method (reset-counters)
    (iterate-table counters
      (lambda (name counter)
        (reset~ counter))))
  
  
  (method (character-pane)
    (let ((pane (child~ interface 'character)))
      (set-visible?~ pane (not (get-visible?~ pane)))
      (when (get-visible?~ pane)
        (set! interface? #t)))
    (update-parameter 'character-pane))
  
  
  (method (update-parameter name)
    (when interface
      (invalidate-view~ (parameter-view name))))


  (method (parameter-view name)
    (let ((world (current-world)))
      (let ((interface (get-interface~ world)))
        (when interface
          (let ((parameter (registered-parameter name)))
            (define (find-view)
              (continuation-capture
                (lambda (return)
                  (for-each (lambda (bar)
                              (when (is? bar World-Actionbar)
                                (for-each (lambda (button)
                                            (when (and (is? button World-Parameter-Button)
                                                       (eq? (get-parameter~ button) name))
                                              (continuation-return return button)))
                                          (get-visible-children~ bar))))
                            (get-visible-children~ interface))
                  (error "Unable to find view: {a}" name))))
            
            (define (lookup-view)
              (or (get-view~ parameter)
                  (let ((view (find-view)))
                    (set-view~ parameter view)
                    view)))
            
            (lookup-view))))))
  
  
  (method (display-on/off title flag)
    (display-message (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method (display-message msg (color: color #f))
    (set! message msg)
    (set! message-color color)
    (set! message-time (current-seconds)))
  
  
  (method (draw-message)
    (let ((elapse (- (current-seconds) message-time)))
      (if (> elapse 2.)
          (begin
            (set! message #f)
            (set! message-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ message-texture))
                (font {Font Heading1})
                (color (or message-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 message)
            (map-texture~ message-texture)
            (let ((w (text-width~ font message)))
              (let ((c (center w (fxround width))))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) (cast <fl> (- (fxround height) 200)) 0.0)
                (textured-quad~ message-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 800.0 0.0 0.0))
                  (lambda () (glVertex3f 800.0 100.0 0.0))
                  (lambda () (glVertex3f 0.0 100.0 0.0)))
                (glPopMatrix))))))))
    
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method (display-error msg)
    (display-message msg color: {Color Red}))
  
  
  (method (display-cancel msg)
    (display-message msg color: {Color Red})
    (signal-cancel))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method (display-status msg (color: color #f))
    (set! status msg)
    (set! status-color color)
    (set! status-time (current-seconds)))
  
  
  (method (draw-status)
    (let ((elapse (- (current-seconds) status-time)))
      (if (> elapse 2.)
          (begin
            (set! status #f)
            (set! status-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ status-texture))
                (font {Font Heading2})
                (color (or status-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 status)
            (map-texture~ status-texture)
            (let ((w (text-width~ font status)))
              (let ((c (center w (fxround width))))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) 30.0 0.0)
                (textured-quad~ status-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 800.0 0.0 0.0))
                  (lambda () (glVertex3f 800.0 35.0 0.0))
                  (lambda () (glVertex3f 0.0 35.0 0.0)))
                (glPopMatrix))))))))
  
  
  ;;;
  ;;;; Info
  ;;;
  
  
  (method (debug-info)
    (let ((zone (current-zone))
          (controlled (current-controlled)))
      (define (present-object obj)
        (format "~{{s} #{s}}"
                (reference-name (get-name~ (class-of obj)))
                (object->serial obj)))
      
      (define (present-boolean bool)
        (if bool "true" "false"))
      
      (define (current-zone-version)
        (let ((data (get-data~ (get-form~ zone))))
          (if data
              (get-version~ data)
            zone-version)))
      
      `(,@(if (client-side?~ (get-process))
              `(,(format "{a}" (get-player-name~ (get-process))))
            `("Server"
              ,(format "clients: {a}" (length (get-clients~ (get-process))))
              ,(format "hits: {a}" (get-hits~ (get-process)))))
        ""
        ,(format "window: {a}" (present-object window))
        ,(format "width: {s}" width)
        ,(format "height: {s}" height)
        ""
        ,(format "world: {s}" self)
        ,(format "version: {a}" (present~ version))
        ""
        ,(format "zone: {s}" zone)
        ,(format "version: {a}" (present~ (current-zone-version)))
        ,(format "sectors: {s}, {s} non empty" (table-length (get-sectors~ zone)) (count-non-empty-sectors~ zone))
        ,@(if (nmc?~ zone)
              (present-nmc~ zone)
            '())
        ,(format "areas: {s}" (table-length (get-areas~ zone)))
        ,(format "polygons: {s}" (count-polygons~ zone))
        ,(format "tiles: {s}" (length (get-tiles~ zone)))
        ,(format "entities: {s}" (length (get-entities~ zone)))
        ,(format "actors: {s}" (length (get-actors~ zone)))
        ,(format "gadgets: {s}" (length (get-gadgets~ zone)))
        ,(format "children: {s}" (length (get-children~ zone)))
        ,(format "marks: {s}" (length (get-marks~ zone)))
        ""
        ,@(if information
              `(,@information
                 "")
            '())
        ,@(let* ((floats (compute-floats~ zone))
                 (vertices (/ floats 10))
                 (triangles (/ vertices 3)))
            `(,(format "VBO triangles: {s}" triangles)
              ,(format "VBO vertices: {s}" vertices)
              ,(format "VBO floats: {s}" floats)))
        ""
        ,@(if target
              `(,(format "target: {a}" (present-object target))
                ,(format "  position: {a}" (present-vertex (get-position~ target)))
                ,(format "  center: {a}" (present-vertex (get-center~ target)))
                ,(format "  radiuses: {a}" (present-vertex (get-radiuses~ target)))
                ,(format "  texture: {s}" (get-texture~ target))
                ,(format "  user-data: {s}" (get-user-data~ target))
                ,@(if (is? target Player)
                      (let ((lookat (get-lookat~ target)))
                        `(,(format "  sight: {a}" (present-vertex (get-sight~ lookat)))
                          ,(format "  up: {a}" (present-vertex (get-up~ lookat)))
                          ,(format "  right: {a}" (present-vertex (get-right~ lookat)))))
                    '())
                "")
            '())
        ,(format "server: {s}" (get-world-server~ (get-process)))
        ,(format "client: {s}" (get-world-client~ (get-process)))
        ""
        ,(format "projection: {s}" projection)
        ,(format "eye: {a}" (present-vertex eye))
        ,(format "eye-target: {a}" (present-vertex eye-target))
        ,(format "eye-sight: {a}" (present-vertex (get-sight~ eye-lookat)))
        ,(format "eye-up: {a}" (present-vertex (get-up~ eye-lookat)))
        ,(format "eye-right: {a}" (present-vertex (get-right~ eye-lookat)))
        ,(format "camera-distance: {s}" camera-distance)
        ,(format "zoom-factor: {s}" zoom-factor)
        ,(format "first-distance: {s}" first-distance)
        ,(format "first-override: {s}" first-override)
        ,(format "first-occlusion?: {s}" first-occlusion?)
        ,(format "first-camera: {s}" first-camera)
        ,(format "desired-tilt: {s}" desired-tilt)
        @w (""
        ,(format "ambient-color: {s}" (get-ambient-color~ zone))
        ,(format "material-specular: {s}" (get-material-specular~ zone))
        ,(format "material-shininess: {s}" (get-material-shininess~ zone))
        ,(format "lights: {s}" (count-lights~ zone)))
        ""
        ,@(if controlled
              `(,(format "controlled: {a}" (present-object controlled))
                ,(format "  position: {a}" (present-vertex (get-position~ controlled)))
                ,(format "  center: {a}" (present-vertex (get-center~ controlled)))
                ,(format "  radiuses: {a}" (present-vertex (get-radiuses~ controlled)))
                ,(format "  texture: {s}" (get-texture~ controlled))
                ,(format "  velocity: {a}" (present-vertex (get-velocity~ controlled)))
                ,(format "  user-data: {s}" (get-user-data~ controlled))
                ,(format "  sight: {a}" (present-vertex (get-sight~ (get-lookat~ controlled))))
                ,(format "  up: {a}" (present-vertex (get-up~ (get-lookat~ controlled))))
                ,(format "  right: {a}" (present-vertex (get-right~ (get-lookat~ controlled))))
                ,(format "  jumping?: {a}" (present-boolean (get-jumping?~ controlled)))
                ,(format "  state: {s}" (and (is? controlled Player) (get-state~ controlled)))
                "")
            '())
        ,(format "history: {s}" (history-end~ history))
        ,(format "now: {s}" (get-now~ history))
        ,(format "first: {s}" (get-first~ history))
        ,@(if (and history? paused?)
              (present-history~ history)
            '())
        ""
        ,(format "editor-mode: {a}" (capitalize (->string editor-mode)))
        ,(format "lighting?: {a}" (present-boolean lighting?))
        ,(format "music?: {a}" (present-boolean music?))
        ,(format "3d?: {a}" (present-boolean 3d?))
        ,(format "fly?: {a}" (present-boolean fly?))
        ,(format "first-person?: {a}" (present-boolean first-person?))
        ,(format "paused?: {a}" (present-boolean paused?))
        ""
        ,(format "gc-count: {a}" (gc-count)))))
  
  
  (method (reset-information)
    (set! information #f))
  
  
  (method (set-information info)
    (set! information (map ->string info)))
  
  
  (method (add-information info)
    (set! information (append (or information '()) (list (->string info)))))
  
  
  ;;;
  ;;;; Counters
  ;;;
  
  
  (method (add-counter name counter)
    (table-set! counters name counter))
  
  
  (method (find-counter name)
    (table-ref counters name))))
