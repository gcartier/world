;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.live jazz


(require (jazz.jpeg)
         (world.generation.models))

(import (jazz.action)
        (jazz.application)
        (jazz.associative)
        (jazz.audio)
        (jazz.cairo)
        (jazz.component)
        (jazz.debuggee)
        (jazz.debugger)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.image)
        (jazz.io)
        (jazz.markup)
        (jazz.media)
        (jazz.opengl)
        (jazz.opengl.glew)
        (jazz.opengl.render)
        (jazz.opengl.texture)
        (jazz.platform)
        (jazz.presence)
        (jazz.runtime)
        (jazz.screen)
        (jazz.snapshot)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.tracker)
        (jazz.ui.dialog)
        (jazz.version)
        (jazz.view)
        (jazz.window)
        (jazz.zlib)
        (profiler)
        (gaea.dye)
        (gaea.geometry)
        (gaea.homogeneous)
        (gaea.math)
        (world)
        (world.actor)
        (world.ambience)
        (world.asset)
        (world.assets)
        (world.atlas)
        (world.autoload)
        (world.block)
        (world.buffers)
        (world.camera)
        (world.change)
        (world.changes)
        (world.chronology)
        (world.circle)
        (world.client.tier)
        (world.collision)
        (world.commands)
        (world.configure)
        (world.context)
        (world.creature)
        (world.debug)
        (world.draw)
        (world.dyes)
        (world.element)
        (world.entities)
        (world.entity)
        (world.event)
        (world.external.blender)
        (world.external.milkshape)
        (world.fog)
        (world.folio)
        (world.foreign)
        (world.gadget)
        (world.gc)
        (world.generate)
        (world.generation)
        (world.generation.block)
        (world.generation.building)
        (world.generation.decoration)
        (world.generation.rendering)
        (world.generator)
        (world.gravity)
        (world.grid)
        (world.hardware)
        (world.history)
        (world.horizon)
        (world.id)
        (world.index)
        (world.interface)
        (world.interface.actions)
        (world.interface.animations)
        (world.interface.avatars)
        (world.interface.bindings)
        (world.interface.blocks)
        (world.interface.character)
        (world.interface.chat)
        (world.interface.color)
        (world.interface.combat)
        (world.interface.command)
        (world.interface.compass)
        (world.interface.crafting)
        (world.interface.dialogs)
        (world.interface.documents)
        (world.interface.evolution)
        (world.interface.exception)
        (world.interface.frame)
        (world.interface.gadgets)
        (world.interface.history)
        (world.interface.info)
        (world.interface.inventory)
        (world.interface.mainbar)
        (world.interface.map)
        (world.interface.menu)
        (world.interface.meshes)
        (world.interface.models)
        (world.interface.options)
        (world.interface.paintings)
        (world.interface.panel)
        (world.interface.profiler)
        (world.interface.propagation)
        (world.interface.script)
        (world.interface.scripts)
        (world.interface.shaders)
        (world.interface.sheet)
        (world.interface.showcase)
        (world.interface.skyboxes)
        (world.interface.target)
        (world.interface.templates)
        (world.interface.textures)
        (world.interface.tiles)
        (world.interface.timeline)
        (world.interface.who)
        (world.interface.zones)
        (world.io)
        (world.keys)
        (world.light)
        (world.mark)
        (world.material)
        (world.missile)
        (world.model)
        (world.motion)
        (world.music)
        (world.object)
        (world.painting)
        (world.pane)
        (world.parameters)
        (world.player)
        (world.polygon)
        (world.profile)
        (world.profiling)
        (world.programs)
        (world.quad)
        (world.ray)
        (world.region)
        (world.render)
        (world.renderer)
        (world.renderers)
        (world.rune)
        (world.screenshot)
        (world.script.asset)
        (world.scripts)
        (world.section)
        (world.sector)
        (world.settings)
        (world.shaders)
        (world.skybox)
        (world.sound)
        (world.space)
        (world.spawn)
        (world.sphere)
        (world.support)
        (world.syntax (phase syntax))
        (world.target)
        (world.task)
        (world.texture)
        (world.tier)
        (world.track)
        (world.travel)
        (world.triangle)
        (world.visualization)
        (world.widget)
        (world.window)
        (world.work)
        (world.zone))


;;;
;;;; World
;;;


;; This value is large because alpha to coverage transparency produces
;; visible dithering when alpha is not a multiple of 1/multisampling and
;; so with 8 we get all the multiples of .125 for smooth transparency
(definition default-multisampling
  (cond-expand
    ;; quick hack around what is probably a vmware bug
    (linux 0)
    (else 8)))


(definition (make-eye)
  (let ((camera (make-camera)))
    (setup-area-cube camera 7)
    camera))


(definition tutorial-move?
  (world-setting 'together.tutorial-move? #f))

(definition tutorial-look?
  (world-setting 'together.tutorial-look? #f))

(definition tutorial-menu?
  (world-setting 'together.tutorial-menu? #f))


(class World extends Object
  
  
  (slot width                   <fl>                initialize #f              accessors generate)
  (slot height                  <fl>                initialize #f              accessors generate)
  (slot eye                     <Camera>            initialize #f              getter generate)
  (slot eye-motion              <Motion>            initialize #f              getter generate)
  (slot world-up                <vertex>            initialize (make-vertex)   getter generate)
  (slot what                    <object>            initialize #f              getter generate)
  (slot selection               <object>            initialize '()             getter generate)
  ;; protect from gc
  (slot selection-sections      <object>            initialize '()             getter generate)
  (slot target-polygon          <object>            initialize #f              getter generate)
  (slot target-vertex           <object>            initialize #f              getter generate)
  (slot target-mode             <object>            initialize 'select         getter generate)
  (slot target-widget           <Widget+>           initialize #f              getter generate)
  (slot showcase                <World-Showcase+>   initialize #f              getter generate)
  (slot showcases               <object>            initialize #f              getter generate)
  (slot showcase-down?          <bool>              initialize #f              getter generate)
  (slot polygon-mode            <fx>                initialize GL_FILL         getter generate)
  (slot window-cursor           <object>            initialize :arrow          getter generate)
  (slot earth?                  <bool>              initialize #t              getter generate)
  (slot interface?              <bool>              initialize #t              accessors generate)
  (slot explore-interface?      <bool>              initialize #f              accessors generate)
  (slot ambient-gravity         <vertex>            initialize default-gravity accessors generate)
  (slot jump-impulsion          <fl>                initialize default-jump    accessors generate)
  (slot default-image           <object>            initialize "stone"         accessors generate)
  (slot properties              <object>            initialize '()             accessors generate)
  
  
  (slot version                 <object>            initialize #f              getter generate)
  (slot orientation?            <bool>              initialize #f              getter generate)
  (slot aim?                    <bool>              initialize #f              getter generate)
  (slot free-aim?               <bool>              initialize #f              getter generate)
  (slot realign?                <bool>              initialize #t              getter generate)
  (slot was-autotrack?          <bool>              initialize #f              getter generate)
  (slot tracking?               <bool>              initialize #f              getter generate)
  (slot moving?                 <bool>              initialize #f              getter generate)
  (slot mouse-run?              <bool>              initialize #f              getter generate)
  (slot first-camera            <object>            initialize #f              getter generate)
  (slot riders-folio            <Folio>             initialize #f              getter generate)
  (slot flyers-folio            <Folio>             initialize #f              getter generate)
  (slot x-rays?                 <bool>              initialize #f              getter generate)
  (slot x-rays-category         <symbol+>           initialize #f              getter generate)
  (slot draw-blocks?            <bool>              initialize #t              getter generate)
  (slot draw-entities?          <bool>              initialize #t              getter generate)
  (slot draw-players?           <bool>              initialize #t              accessors generate)
  (slot draw-gadgets?           <bool>              initialize #f              getter generate)
  (slot draw-marks?             <bool>              initialize #t              getter generate)
  (slot draw-normals?           <bool>              initialize #f              getter generate)
  (slot draw-me?                <bool>              initialize #t              accessors generate)
  (slot view-radius             <fl>                initialize #f              accessors generate)
  (slot max-entity-radius       <fl>                initialize 60.             accessors generate)
  (slot render-task             <object>            initialize #f              accessors generate)
  (slot render-thread           <object>            initialize #f              accessors generate)
  (slot render-trim?            <bool>              initialize #f              accessors generate)
  (slot player-task             <object>            initialize #f              accessors generate)
  (slot player-thread           <object>            initialize #f              accessors generate)
  (slot ongoing-key             <object>            initialize #f              accessors generate)
  (slot axes?                   <bool>              initialize #f              accessors generate)
  (slot axes-graduation?        <bool>              initialize #f              accessors generate)
  (slot tick-slice?             <bool>              initialize #t              getter generate)
  (slot down?                   <bool>              initialize #f              getter generate)
  (slot down-point              <object>            initialize #f              getter generate)
  (slot inhibit-up?             <bool>              initialize #f              getter generate)
  (slot double-click?           <bool>              initialize #f              getter generate)
  (slot drag-tolerance          <object>            initialize 5               getter generate)
  (slot tick-procedures         <object>            initialize '()             getter generate)
  (slot tick-no                 <object>            initialize 0               getter generate)
  (slot commands                <object>            initialize #f              getter generate)
  (slot base-assets             <object>            initialize #f              getter generate)
  (slot zone-assets             <object>            initialize #f              getter generate)
  (slot template-assets         <object>            initialize #f              getter generate)
  (slot user-assets             <object>            initialize #f              getter generate)
  (slot textures                <object>            initialize #f              getter generate)
  (slot models                  <object>            initialize #f              getter generate)
  (slot models-mutex            <object>            initialize #f              getter generate)
  (slot paintings               <object>            initialize #f              getter generate)
  (slot paintings-mutex         <object>            initialize #f              getter generate)
  (slot history?                <bool>              initialize #t              getter generate)
  (slot history-trail           <fx>                initialize 250             getter generate)
  (slot history-camera          <Camera>            initialize (make-camera)   getter generate)
  (slot history-camera?         <bool>              initialize #f              getter generate)
  (slot history-motion          <Motion>            initialize #f              getter generate)
  (slot message                 <object>            initialize #f              getter generate)
  (slot message-time            <object>            initialize #f              getter generate)
  (slot message-font            <object>            initialize #f              getter generate)
  (slot message-color           <object>            initialize #f              getter generate)
  (slot message-duration        <object>            initialize #f              getter generate)
  (slot message-sheet           <object>            initialize #f              getter generate)
  (slot status                  <object>            initialize #f              getter generate)
  (slot status-time             <object>            initialize #f              getter generate)
  (slot status-color            <object>            initialize #f              getter generate)
  (slot status-duration         <object>            initialize #f              getter generate)
  (slot status-sheet            <object>            initialize #f              getter generate)
  (slot action                  <object>            initialize #f              getter generate)
  (slot action-time             <object>            initialize #f              getter generate)
  (slot action-duration         <object>            initialize #f              getter generate)
  (slot action-proc             <object>            initialize #f              getter generate)
  (slot action-tutorial         <object>            initialize #f              getter generate)
  (slot tutorial-fade           <object>            initialize #f              getter generate)
  (slot tutorial-again          <object>            initialize #f              getter generate)
  (slot action-sheet            <object>            initialize #f              getter generate)
  (slot working?                <bool>              initialize #f              getter generate)
  (slot working-color           <object>            initialize #f              getter generate)
  (slot working-step            <fx>                initialize 0               getter generate)
  (slot working-message         <object>            initialize #f              getter generate)
  (slot working-percentage      <object>            initialize #f              getter generate)
  (slot working-sheet           <object>            initialize #f              getter generate)
  (slot working-background      <object>            initialize #f              getter generate)
  (slot working-task            <object>            initialize #f              getter generate)
  (slot working-mutex           <object>            initialize #f              getter generate)
  (slot working-done?           <bool>              initialize #f              getter generate)
  (slot compass-sheet           <object>            initialize #f              getter generate)
  (slot compass-visible?        <bool>              initialize #f              accessors generate)
  (slot map-sheet               <object>            initialize #f              getter generate)
  (slot map-visible?            <bool>              initialize #f              getter generate)
  (slot evolution-sheet         <object>            initialize #f              getter generate)
  (slot evolution-visible?      <bool>              initialize #f              getter generate)
  (slot history-sheet           <object>            initialize #f              getter generate)
  (slot history-visible?        <bool>              initialize #f              getter generate)
  (slot interface-refresh?      <bool>              initialize #f              getter generate)
  (slot interface-last-time     <fl>                initialize #f              getter generate)
  (slot interface-target?       <bool>              initialize #f              getter generate)
  (slot show-belt?              <bool>              initialize #f              accessors generate)
  (slot alternate-escape        <object>            initialize #f              getter generate)
  (slot last-script             <object>            initialize #f              getter generate)
  (slot last-whisperer          <object>            initialize #f              accessors generate)
  (slot escape-hook             <object>            initialize #f              accessors generate)
  (slot enter-hook              <object>            initialize #f              accessors generate)
  (slot central-menu            <object>            initialize #f              accessors generate)
  (slot radial-menu             <object>            initialize #f              accessors generate)
  
  ;; Shader programs
  (slot mesh-programs            <object>            initialize #f              accessors generate)
  (slot block-atlas              <Atlas>             initialize #f              accessors generate)
  (slot block-texture            <Image-Texture>     initialize #f              accessors generate)
  (slot block-texture-repeat     <Image-Texture>     initialize #f              accessors generate)
  (slot block-opaque             <object>            initialize #f              accessors generate)
  (slot block-transparent        <object>            initialize #f              accessors generate)
  (slot block-coverage           <object>            initialize #f              accessors generate)
  (slot block-water              <object>            initialize #f              accessors generate)
  (slot block-wet                <object>            initialize #f              accessors generate)
  (slot block-multitexture       <object>            initialize #f              accessors generate)
  (slot block-materials          <object>            initialize #f              accessors generate)
  (slot block-program            <Mesh-Program>      initialize #f              accessors generate)
  (slot texture-program          <Texture-Program>          initialize #f       accessors generate)
  (slot texture-flipped-program  <Texture-Flipped-Program>  initialize #f       accessors generate)
  (slot texture-hardware-program <Texture-Hardware-Program> initialize #f       accessors generate)
  (slot sheet-program            <Sheet-Program>            initialize #f       accessors generate)
  (slot sheet-flipped-program    <Sheet-Flipped-Program>    initialize #f       accessors generate)
  (slot sheet-hardware-program   <Sheet-Hardware-Program>   initialize #f       accessors generate)
  (slot material-opaque          <object>            initialize #f              accessors generate)
  (slot material-transparent     <object>            initialize #f              accessors generate)
  (slot day-lightmap             <object>            initialize #f              accessors generate)
  (slot night-lightmap           <object>            initialize #f              accessors generate)
  (slot multisampled-framebuffer <Multisampled-Framebuffer+> initialize #f              accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (initialize self)
    (nextmethod self)
    (set-current-world self)
    (set! view-radius 200.)
    (when (window?)
      (set! eye (make-eye))
      (set! history-motion (make-free-motion self history-camera))
      (set-callback history-camera (~ camera-callback self))
      (set! eye-motion (make-free-motion self eye))
      (set-callback eye (~ camera-callback self))
      (set-update-callback eye eye-update)
      (set-current-camera eye)
      (set-current-motion eye-motion)
      (set-current-music (new World-Music))
      (set-current-ambience (new World-Ambience))
      (set-current-audio (new World-Audio))
      (set-current-video (new World-Video)))
    (set! earth? (world-setting 'world.earth? #f))
    @needs-a-lot-more-work
    (set-camera-smoothing? (world-setting 'world.camera-smoothing? #t))
    (set-move-steer? (world-setting 'world.move-steer? #f))
    (set-independent-camera? (world-setting 'world.independent-camera? #f))
    (set-track-sensitivity (world-setting 'world.track-sensitivity 200.))
    (set-multisampling? (and (window?) (world-setting 'world.multisampling? #t)))
    (set! interface? (world-setting 'world.start-interface? #t))
    (set! interface-target? (world-setting 'world.interface-target? #f))
    (set-interface-script? (world-setting 'world.interface-script? #f))
    (set! show-belt? (world-setting 'world.show-belt? #f))
    (set! alternate-escape (world-setting 'world.alternate-escape #f))
    (set-gc-sound? (world-setting 'world.gc-sound? #f))
    (set-gc-trace? (world-setting 'world.gc-trace? #f))
    (set! history? (world-setting 'world.history? #t))
    (set! history-trail (world-setting 'world.history-trail 250))
    (set! history-camera? (world-setting 'world.history-camera? #f))
    (set! evaluate-future? (world-setting 'world.evaluate-future? #f))
    (set! free-aim? (world-setting 'world.free-aim? #f))
    (set-fog? (world-setting 'world.fog? #t))
    (set-fog-color (world-setting 'world.fog-color default-fog-color))
    (setup-fog-near/far view-distance)
    (set-animations? (and (window?) (world-setting 'world.animations? (>= (glGetInteger* GL_MAX_VERTEX_UNIFORM_COMPONENTS) 4096))))
    (set-block-pumps? (world-setting 'world.block-pumps? #f))
    (set! tick-slice? (not (world-setting 'world.inhibit-slicing? #f)))
    (set! models (make-table test: equal?))
    (set! models-mutex (make-mutex 'models))
    (set! paintings (make-table test: equal?))
    (set! paintings-mutex (make-mutex 'paintings))
    (when (window?)
      (set! working-task (new Task 'working (~ run-working self) exit: (~ exit-working self) priority: working-priority))
      (set! working-mutex (make-mutex 'working))
      (working-lock! self))
    (update-world-up self ambient-gravity)
    (prepare-sounds self)
    (setup-history)
    ;; not necessary if we are not using message-available?
    ;; (set-ignore-key-repeat? #t)
    (register-keys)
    (setup-info))
  
  
  (method package (setup-opengl self)
    (when (window?)
      (setup-size self)
      (glClear (bitwise-ior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
      (glEnable GL_DEPTH_TEST)
      (glDisable GL_BLEND)
      (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
      (glFrontFace GL_CW)
      (glPolygonMode GL_FRONT_AND_BACK GL_FILL)
      (glEnable GL_LINE_SMOOTH)
      (initialize-eye self))
    (prepare-assets self)
    (when (window?)
      (prepare-showcases self)
      (prepare-shaders self)
      (prepare-renderers)
      (prepare-sheets self)
      (prepare-skyboxes)
      (initialize-multisampled self)
      (reset-commands self)
      (gl-check-error)))
  
  
  (method (setup-size self)
    (let ((window (current-window)))
      (size-change self (get-size window))))
  
  
  (method package (size-change self size)
    (set! width (cast <fl> (get-width size)))
    (set! height (cast <fl> (get-height size)))
    (size-change eye size)
    (size-change history-camera size)
    (size-change (cache-inventory-camera) size)
    (when showcases
      (iterate-table showcases
        (lambda (name showcase)
          (size-change showcase size))))
    (let ((interface (current-interface+)))
      (when interface
        (set-size interface size)
        (interface-layout self)
        (sheets-layout self)))
    (reset-inventory-blocks))
  
  
  (method (initialize-multisampled self)
    (cond-expand
      (linux)
      (else
       (let ((width (fxround width))
             (height (fxround height))
             ;; patch for multisampling > 4 regression
             (multisampling (min 4 (world-setting 'world.multisampling default-multisampling))))
         (set! multisampled-framebuffer (new Multisampled-Framebuffer width height multisampling))))))
  
  
  (method package (update-world-up self gravity)
    (vertex-copy! world-up (gravity-up& gravity)))
  
  
  (method (reset-commands self)
    (when (or (not commands) (get-modified? commands))
      (set! commands (new Commands))))
  
  
  (method package (change-view-distance self distance)
    (let ((old-distance view-distance))
      (set-view-distance distance)
      (setup-fog-near/far distance)
      (view-distance-update (current-zone) old-distance distance)))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (method (prepare-assets self)
    (set! base-assets (make-directory-assets 'base (new-directory (get-world-directory) "assets")))
    (when (client?)
      (let ((dir {Directory Documents "user"}))
        (set! user-assets (and (exists? dir)
                               (make-directory-assets 'user dir))))))
  
  
  (method package (prepare-zone-assets self zone-dir asset-entries)
    (let ((tier (current-tier)))
      (set! zone-assets (make-zone-assets tier zone-dir))
      (when asset-entries
        (setup-remote-index zone-assets asset-entries))))
  
  
  (method package (prepare-template-assets self zone-dir)
    (let ((instance (new-file zone-dir ".instance")))
      (set! template-assets 
            (and (exists? instance)
                 (let ((instance (instantiate (read-form instance))))
                   (let ((template (get-template instance)))
                     (let ((template-dir (new-directory {Directory Application-World "templates"} (append template '("assets")))))
                       (and (exists? template-dir)
                            (make-directory-assets 'template template-dir)))))))))
  
  
  (method package (iterate-assets self proc)
    (when zone-assets
      (proc zone-assets))
    (when (and template-assets (developer?))
      (proc template-assets))
    (proc base-assets)
    (let ((tier (current-tier+)))
      (when tier
        (let ((assets (get-universe-assets tier)))
          (when assets
            (proc assets)))
        (let ((assets (get-world-assets tier)))
          (when assets
            (proc assets)))))
    (when user-assets
      (proc user-assets)))
  
  
  (method (partition-assets self)
    (let ((queue (new-queue)))
      (define (add kind assets)
        (enqueue queue (cons kind assets)))
      
      (when zone-assets
        (add 'zone zone-assets))
      (when (and template-assets (developer?))
        (add 'template template-assets))
      (add 'base base-assets)
      (let ((tier (current-tier+)))
        (when tier
          (let ((assets (get-universe-assets tier)))
            (when assets
              (add (get-where assets) assets)))
          (let ((assets (get-world-assets tier)))
            (when assets
              (add (get-where assets) assets)))))
      (when user-assets
        (add 'user user-assets))
      (queue-list queue)))
  
  
  (method package (find-asset self path)
    (continuation-capture
      (lambda (return)
        (iterate-assets self
          (lambda (assets)
            (when (contains-file? assets path)
              (continuation-return return (new Asset assets path)))))
        #f)))
  
  
  (method package (require-asset self path)
    (or (find-asset self path)
        (error "Unable to find asset: {a}" path)))
  
  
  (method protected virtual (prepare-sheets self)
    (set! message-sheet (make-world-sheet 'message World-Sheet message-size))
    (set! status-sheet (make-world-sheet 'status World-Sheet status-size))
    (set! action-sheet (make-world-sheet 'action World-Sheet action-size))
    (set! working-sheet (make-world-sheet 'working World-Sheet working-size))
    (set! compass-sheet (make-world-sheet 'compass World-Sheet compass-size))
    (set! map-sheet (make-world-sheet 'map World-Sheet map-size))
    (set! evolution-sheet (make-world-sheet 'evolution World-Sheet evolution-size))
    (set! history-sheet (make-world-sheet 'history World-Sheet history-size)))
  
  
  (method protected virtual (resize-sheets self)
    (make-orthographic-matrix! (get-projection-matrix message-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix status-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix action-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix working-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix compass-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix map-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix evolution-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix history-sheet) 0. width 0. height 0. 10.))
  
  
  (method protected (resize-interface self)
    (let ((interface (current-interface+)))
      (when interface
        (make-orthographic-matrix! (get-projection-matrix interface) 0. width 0. height 0. 10.))))

  
  (method package (prepare-block self atlas texture texture-repeat)
    (set! block-atlas atlas)
    (set! block-texture texture)
    (set! block-texture-repeat texture-repeat))
  
  
  (method package (prepare-materials self opaque-material transparent-material coverage-material water-material wet-material multitexture-material)
    (set! block-opaque opaque-material)
    (set! block-transparent transparent-material)
    (set! block-coverage coverage-material)
    (set! block-water water-material)
    (set! block-wet wet-material)
    (set! block-multitexture multitexture-material)
    (set! block-materials (make-table test: eq?))
    (set! material-opaque (get-entity-material (opaque-rendering)))
    (set! material-transparent (get-entity-material (transparent-rendering))))
  
  
  (method package (prepare-lightmaps self)
    (let ((day {File Application-World "assets" "light" "world" "day.png"})
          (night {File Application-World "assets" "light" "world" "night.png"}))
      (define (make-lightmap file)
        (make-png-texture file min-filter: GL_NEAREST mag-filter: GL_NEAREST wrap: GL_CLAMP_TO_EDGE mipmap?: #f))
      
      (set! day-lightmap (make-lightmap day))
      (set! night-lightmap (make-lightmap night))))
  
  
  ;;;
  ;;;; Sounds
  ;;;
  
  
  (method protected virtual (prepare-sounds self)
    (setup-sounds))

  
  ;;;
  ;;;; Modules
  ;;;
  
  
  (slot installed-repositories        initialize (make-table test: equal?) getter generate)
  (slot installed-repositories-assets initialize (make-table test: equal?) getter generate)
  
  
  (method package (prepare-modules self)
    (let ((queue (new-queue))
          (table (make-table test: equal?)))
      (iterate-assets self
        (lambda (assets)
          (when (contains-directory? assets "module")
            ;; module reference isn't hooked into assets
            ;; yet so simply retrieve the whole directory
            (let ((dirname (parse (retrieve-directory assets "module"))))
              (enqueue queue dirname)
              (table-set! table dirname assets)))))
      (let ((new (queue-list queue)))
        (update-repositories installed-repositories new)
        (set-world-repositories new))
      (set! installed-repositories-assets table)))
  
  
  (method package (collect-modules self)
    (let ((modules '()))
      (for-each (lambda (path)
                  (let ((repository (table-ref installed-repositories path))
                        (assets (table-ref installed-repositories-assets path)))
                    (let ((assets-dir (get-directory assets)))
                      (iterate-packages repository
                        (lambda (package)
                          (let ((dir (new Directory (tokenise-filename (package-directory package)))))
                            (let ((asset-root (subpath assets-dir dir)))
                              (iterate-directory dir
                                (lambda (path kind)
                                  (let ((file (new-file dir path)))
                                    (when (extension=? (get-extension file) "jazz")
                                      (unless (member? (get-name file) '(".DS_Store") test: filename=?)
                                        (let ((asset (new Asset assets (append asset-root (subpath dir file)))))
                                          (set! modules (cons asset modules)))))))
                                full?: #f
                                files?: #t
                                directories?: #f
                                recursive?: #t))))))))
                (get-world-repositories))
      modules))

  
  ;;;
  ;;;; Materials
  ;;;
  
  
  (method package (find-block-material self name)
    (or (table-ref block-materials name #f)
        (let ((mat (case name
                     ((opaque) block-opaque)
                     ((transparent) block-transparent)
                     (else (new Material atlas: block-atlas texture: block-texture-repeat renderer: (require-renderer name))))))
          (table-set! block-materials name mat)
          mat)))
  
  
  ;;;
  ;;;; Showcases
  ;;;
  
  
  (method (prepare-showcases self)
    (set! showcases (make-table test: eq?)))
  
  
  ;;;
  ;;;; Shaders
  ;;;
  
  
  (method (prepare-shaders self)
    ;; shaders
    (build-default-shaders)
    (build-hardware-shaders)
    (build-sheet-shaders)
    (build-texture-shaders)
    (build-skybox-shaders)
    (build-horizon-shaders)
    (build-color-shaders)
    (build-mesh-shaders)
    (build-block-shaders)
    (build-model-shaders)
    (build-occlusion-shaders)
    (build-frame-shaders)
    (build-transformation-shaders)

    ;; mesh
    (set! mesh-programs (make-table test: eq?))
    (table-set! mesh-programs 'color              (new Mesh-Color-Program))
    (table-set! mesh-programs 'block              (new Mesh-Block-Program))
    (table-set! mesh-programs 'transparent-block  (new Mesh-Transparent-Block-Program))
    (table-set! mesh-programs 'model              (new Mesh-Model-Program))
    (table-set! mesh-programs 'instance           (new Mesh-Instance-Program))
    (table-set! mesh-programs 'occlusion          (new Mesh-Occlusion-Program))
    (table-set! mesh-programs 'wireframe          (new Mesh-Wireframe-Program))
    (table-set! mesh-programs 'squareframe        (new Mesh-Squareframe-Program))
    (table-set! mesh-programs 'testinstance       (new Mesh-TestInstance-Program))
    (table-set! mesh-programs 'playerframe        (new Mesh-Playerframe-Program))
    (table-set! mesh-programs 'floorframe         (new Mesh-Floorframe-Program))
    (table-set! mesh-programs 'player             (new Mesh-Player-Program))
    (table-set! mesh-programs 'selflit            (new Mesh-Selflit-Program))
    (table-set! mesh-programs 'white              (new Mesh-White-Program))
    (table-set! mesh-programs 'radial-blur        (new Mesh-Radial-Blur-Program))
    (table-set! mesh-programs 'motion-blur        (new Mesh-Motion-Blur-Program))
    (table-set! mesh-programs 'fire               (new Mesh-Fire-Program))
    (table-set! mesh-programs 'water-block        (new Mesh-Water-Block-Program))
    (table-set! mesh-programs 'water              (new Mesh-Water-Program))
    (table-set! mesh-programs 'wet-block          (new Mesh-Wet-Block-Program))
    (table-set! mesh-programs 'julia              (new Mesh-Julia-Program))
    (table-set! mesh-programs 'sierpinski         (new Mesh-Sierpinski-Program))
    (table-set! mesh-programs 'multitexture-block (new Mesh-Multitexture-Block-Program))
    (table-set! mesh-programs 'multitexture       (new Mesh-Multitexture-Program))
    (table-set! mesh-programs 'kaleidoscope       (new Mesh-Kaleidoscope-Program))
    (table-set! mesh-programs 'tunnel             (new Mesh-Tunnel-Program))
    (table-set! mesh-programs 'square-tunnel      (new Mesh-Square-Tunnel-Program))
    (table-set! mesh-programs 'fly                (new Mesh-Fly-Program))
    (table-set! mesh-programs 'pulse              (new Mesh-Pulse-Program))

    ;; block
    (set! block-program (find-mesh-program self 'block))
    
    ;; texture
    (set! texture-program (new Texture-Program))
    (set! texture-flipped-program (new Texture-Flipped-Program))
    (set! texture-hardware-program (new Texture-Hardware-Program))
    
    ;; sheet
    (set! sheet-program (new Sheet-Program))
    (set! sheet-flipped-program (new Sheet-Flipped-Program))
    (set! sheet-hardware-program (new Sheet-Hardware-Program))
    
    (gl-check-error))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (destroy self)
    (when (window?)
      (stop-working self)
      (with-reentrant-render-mutex
        (lambda ()
          (cond-expand
            (linux)
            (else
             (free-resources multisampled-framebuffer)))
          (detach-shaders block-program)
          (close message-sheet)
          (close status-sheet)
          (close action-sheet)
          (close working-sheet)
          (close compass-sheet)
          (close map-sheet)
          (close evolution-sheet)
          (close history-sheet)))
      (close (current-video))
      (close (current-audio))
      (close-music (current-music))))
  
  
  (method public (toggle-gc-sound self)
    (set-gc-sound? (not gc-sound?))
    (display-on/off self "GC sound" gc-sound?))
  
  
  (method public (garbage-collect self)
    (let ((window (current-window)))
      (display-message self "Garbage collecting" color: {Color Red})
      (render-scene window)
      (gc)
      (let ((timer (new Timer)))
        (gc)
        (display-message self (format "Garbage collected ({a}ms)" (real-duration-in-milliseconds timer)) color: {Color Green}))
      (render-scene window)))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method package virtual (initialize-world self)
    (set! version world-version)
    (set! first-camera 'free)
    (set! grid? (world-setting 'world.grid? #f))
    (set! axes? (world-setting 'world.axes? #f))
    (set! axes-graduation? (world-setting 'world.axes-graduation? #f))
    (when (window?)
      (setup-interface self)
      (start-working self)))
  
  
  (method package (setup-interface self)
    (let ((interface (current-interface+)))
      (when interface
        (close interface)))
    (let ((window (current-window)))
      (set-current-interface (make-world-sheet 'interface World-Interface (get-size window)))
      (let ((interface (current-interface)))
        (make-orthographic-matrix! (get-projection-matrix interface) 0. width 0. height 0. 10.)
        (set! interface-last-time -inf.0)
        (new Info-Panel parent: interface name: 'info visible?: #f layouter: (lambda (panel) (info-panel-layouter panel)))
        (new Profiler-Panel parent: interface name: 'profiler visible?: #f layouter: (lambda (panel) (profiler-panel-layouter panel)))
        (new (evolution-panel-class self) parent: interface name: 'evolution visible?: #f layouter: (lambda (panel) (evolution-panel-layouter panel)))
        (new History-Timeline-Panel parent: interface name: 'history visible?: #f layouter: (lambda (panel) (history-panel-layouter panel)))
        (new Color-Panel parent: interface name: 'color visible?: #f layouter: (lambda (panel) (color-panel-layouter panel)))
        (new Target-Panel parent: interface name: 'target visible?: #f layouter: (lambda (panel) (target-panel-layouter panel)))
        (new Compass-Panel parent: interface name: 'compass visible?: #f layouter: (lambda (panel) (compass-panel-layouter panel)))
        (new Map-Panel parent: interface name: 'map visible?: #f layouter: (lambda (panel) (map-panel-layouter panel)))
        (new Combat-Panel parent: interface name: 'combat visible?: #f layouter: (lambda (panel) (combat-panel-layouter panel)))
        (new Character-Panel parent: interface name: 'character visible?: #f layouter: (lambda (panel) (character-panel-layouter panel)))
        (new Bag-Panel parent: interface name: 'bag visible?: #f layouter: (lambda (panel) (bag-panel-layouter panel)))
        (new Belt-Panel parent: interface name: 'belt visible?: #f layouter: (lambda (panel) (belt-panel-layouter panel)))
        (new Chest-Panel parent: interface name: 'chest visible?: #f layouter: (lambda (panel) (chest-panel-layouter panel)))
        (new Crafting-Panel parent: interface name: 'crafting visible?: #f layouter: (lambda (panel) (crafting-panel-layouter panel)))
        (new Chat-Panel parent: interface name: 'chat visible?: #f)
        (new Command-Bar parent: interface name: 'command visible?: #f)
        (new (script-panel-class self) parent: interface name: 'script visible?: #f layouter: (lambda (panel) (script-panel-layouter panel)))
        (setup-application-interface (current-application))
        (set-root window interface)
        (update-background (get-manager (child interface 'script)))
        (setup-script-zoom)
        (interface-layout self)
        (sheets-layout self)
        (acquire-focus interface))))
  
  
  (method protected virtual (script-panel-class self)
    Script-Panel)
  
  
  (method protected virtual (evolution-panel-class self)
    )
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method package (zone-update self)
    (set! riders-folio (new Folio 'Wheels '(Wheels Hummer)))
    (set! flyers-folio (new Folio 'Saucer '(Saucer Rocket)))
    (let ((zone (current-zone))
          (me (current-me+)))
      (when me
        (let ((camera (player-camera me)))
          ;; eye
          (camera-copy! eye camera)
          ;; player
          ;; ride & fly (needs more work for it to reload exactly in the same state)
          (case (get-mount me)
            ((ride)
             (set-mount me #f)
             (ride-change me 'Wheels))
            ((fly)
             (set-mount me #f)
             (fly-change me 'Saucer)))
          ;; eye
          (person-motion self yaw: default-yaw pitch: default-pitch eye-center?: #f feedback?: #f)))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method package (run-tick self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic))
                (duration 0.))
            (let ((elapse (- time previous)))
              (unless (> elapse max-elapse)
                (unless (stopping? task)
                  (increase! duration (tick-world self time elapse))))
              (task-wait task (if application-active? tick-period tick-period-inactive) duration exit)
              (iter time)))))))
  
  
  (method (tick-world self time elapse)
    (let ((duration 0.))
      (let ((zone (current-zone))
            (history (current-history)))
        (increase! duration (tick-scene zone elapse))
        (when showcase
          (increase! duration (tick-scene showcase elapse)))
        (when (not-null? tick-procedures)
          (for-each (lambda (proc)
                      (with-task-mutex
                        (lambda ()
                          (site tick
                            (when (memq? proc tick-procedures)
                              (let ((start (current-monotonic)))
                                (proc elapse)
                                (increase! duration (- (current-monotonic) start))))))))
                    tick-procedures)))
      duration))
  
  
  (method package (register-tick self proc)
    (set! tick-procedures (cons proc tick-procedures)))
  
  
  (method package (unregister-tick self proc)
    (set! tick-procedures (remove! proc tick-procedures)))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  ;; player boost which in turn boosts the render makes it so a mouse-track will
  ;; never go immediately into a render. this is critical especially when strafing
  ;; at the same time as tracking where the alternation of track and player movement
  ;; results in visual vibrations. the player and render boost ensure that the
  ;; mouse track is followed by a player tick and only then the render
  (method (boost-player self)
    (when (and player-thread (not player-boost?) (neq? (current-thread) player-thread))
      (set-player-boost? #t)
      (task-wakeup player-task)))
  
  
  (method (unboost-player self)
    (set-player-boost? #f))
  
  
  (method package (run-player self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (set! player-task task)
          (set! player-thread (current-thread))
          (let (iter (previous (current-monotonic)))
            (let ((time (current-monotonic))
                  (duration 0.))
              (when player-ready?
                (let ((elapse (- time previous)))
                  (unless (> elapse max-elapse)
                    (with-task-mutex
                      (lambda ()
                        (unless (stopping? task)
                          (let ((start (current-monotonic)))
                            (process-player self history time elapse)
                            (increase! duration (- (current-monotonic) start))))))))
                (when player-boost?
                  (unboost-player self)
                  (boost-render self)))
              (task-wait task player-period duration exit)
              (iter time)))))))
  
  
  (method (process-player self history time elapse)
    (site player
      (when (participant?)
        (unless bot?
          (process-mouse-run self)
          (when (world-focused?)
            (process-keys self))
          (unless (get-paused? history)
            (let ((me (current-me)))
              (tick-sliced self me commands time elapse)
              (reset-commands self)
              (animate me elapse)
              (let ((vehicle (get-vehicle me)))
                (when vehicle
                  (animate vehicle elapse (get-position me)))))))
        (update-transformation-time elapse)
        (let ((me (current-me))
              (motion (current-motion)))
          (restore-desired-distance motion elapse)
          (restore-roll motion me)))))
  
  
  (method package (tick-sliced self actor commands time elapse)
    (declare (proper-tail-calls))
    (let ((slice (tick-slice actor)))
      (if (or (not slice) (not tick-slice?) (<= elapse slice))
          (tick-action actor commands time elapse)
        (let (iter (from 0.) (to slice))
          (tick-action actor commands (- time (- elapse to)) (- to from))
          (when (and (< to elapse) (get-alive? actor))
            (iter to (min elapse (+ to slice))))))))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method package (run-missile self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-monotonic)))
            (let ((time (current-monotonic))
                  (duration 0.))
              ;; only server ticks missiles
              (unless (client?)
                (let ((elapse (- time previous)))
                  (unless (or (> elapse max-elapse) 
                              (get-paused? history))
                    (increase! duration (tick-missiles self #f time elapse)))))
              (task-wait task missile-period duration exit)
              (iter time)))))))
  
  
  (method (tick-missiles self commands time elapse)
    (let ((zone (current-zone))
          (history (current-history)))
      (let ((duration 0.))
        (for-each (lambda (actor)
                    (when (is-missile? actor)
                      (with-task-mutex
                        (lambda ()
                          (site missile
                            (unless (get-paused? history)
                              ;; check linked instead of alive because of
                              ;; missiles delayed unlinking until rendered
                              (when (linked? actor)
                                (let ((start (current-monotonic)))
                                  (tick-action actor commands time elapse)
                                  (increase! duration (- (current-monotonic) start))))))))))
                  (get-actors zone))
        duration)))

  
  ;;;
  ;;;; Circularity
  ;;;
  
  
  ;; quick hacks around circular dependencies
  (method (polygon-class self)
    Polygon)
  (method package (triangle-class self)
    Triangle)
  (method package (quad-class self)
    Quad)
  (method (missile-class self)
    Missile)

  
  ;;;
  ;;;; Events
  ;;;
  
  
  ;; Interface
  (method (on-main-menu self evt)
    (main-menu self))
  
  (method (on-graphics-options self evt)
    (graphics-options self))
  
  (method (on-sound-options self evt)
    (sound-options self))
  
  (method (on-interface-options self evt)
    (interface-options self))
  
  (method (on-view-bindings self evt)
    (view-bindings self))
  
  (method (on-view-news self evt)
    (view-news self))
  
  (method (on-view-roadmap self evt)
    (view-roadmap self))
  
  (method (on-view-help self evt)
    (view-help self))
  
  (method (on-open-about self evt)
    (open-about self))
  
  (method (on-unstuck-character self evt)
    (unstuck-character self))
  
  (method (on-toggle-occlusion self evt)
    (toggle-occlusion self))
  
  (method (on-toggle-wireframe self evt)
    (toggle-wireframe self))
  
  (method (on-toggle-profiler self evt)
    (toggle-profiler self))
  
  (method (on-toggle-profiler-all self evt)
    (toggle-profiler-all self))
  
  (method (on-reset-profiler self evt)
    (gc)
    (reset-profiler self)
    (display-message self "Profiler reset"))
  
  (method (on-toggle-evolution self evt)
    (toggle-evolution self))
  
  (method (on-toggle-history self evt)
    (toggle-history self))
  
  (method (on-all-chronology self evt)
    (all-chronology self))
  
  (method (on-open-welcome self evt)
    (open-welcome self))
  
  (method (on-quit-world self evt)
    (quit-process (current-application)))

  (method (on-select/run-script self evt)
    (select/run-script self))

  (method (on-run-last-script self evt)
    (run-last-script self))
  
  (method (on-enter-press self evt)
    (enter-press self))
  
  (method package (on-tab-press self evt)
    (tab-press self))
  
  (method (on-radial-menu self evt)
    (let ((name (get-property evt radial:)))
      (toggle-radial-menu self name)))
  
  
  ;; Graphics
  (method (on-toggle-fog self evt)
    (toggle-fog self))
  
  (method (on-toggle-draw-gadgets self evt)
    (toggle-draw-gadgets self))
  
  (method (on-toggle-draw-normals self evt)
    (toggle-draw-normals self))
  
  (method (on-toggle-x-rays self evt)
    (toggle-x-rays self))
  
  (method (on-toggle-redstone-x-rays self evt)
    (toggle-redstone-x-rays self))
  
  (method (on-toggle-draw-blocks self evt)
    (toggle-draw-blocks self))
  
  (method (on-toggle-draw-models self evt)
    (toggle-draw-models self))
  
  (method (on-toggle-multisampling self evt)
    (toggle-multisampling self))
  
  
  ;; Sound
  (method (on-toggle-sound self evt)
    (toggle-sound self))
  
  
  ;; Server
  (method (on-server-state self evt)
    )
  
  (method (on-server-info self evt)
    )
  
  
  ;; Role
  (method (on-toggle-user self evt)
    (toggle-user self))
  
  
  ;; Zone
  (method (on-zone-open self evt)
    (zone-open self))
  
  (method (on-zone-reload self evt)
    (zone-reload self))
  
  (method (on-zone-regenerate self evt)
    (zone-regenerate self))
  
  
  ;; Game
  (method (on-perform-action self evt)
    (perform-action self))
  
  (method (on-bullet self evt)
    ;; done in process-keys
    )
  
  (method (on-arrow self evt)
    ;; done in process-keys
    )
  
  @wait
  (method (on-rapid-fire evt)
    (maybe-rapid-fire))
  
  (method (on-sprint self evt)
    ;; done in process-keys
    )
  
  (method (on-warp self evt)
    ;; done in process-keys
    )
  
  (method (on-toggle-run self evt)
    (toggle-run self))
  
  (method (on-start-dash self evt)
    (let ((me (current-controlled self)))
      (start-dash me)))
  
  (method (on-mind-control self evt)
    (mind-control self))
  
  (method (on-toggle-aim self evt)
    (toggle-aim self))
  
  (method (on-toggle-free-aim self evt)
    (toggle-free-aim self))
  
  (method (on-toggle-ride self evt)
    (toggle-ride (current-controlled self)))
  
  (method (on-toggle-fly self evt)
    (toggle-fly (current-controlled self)))
  
  (method (on-toggle-vehicle self evt)
    (toggle-vehicle (current-controlled self)))
  
  (method (on-compass-panel self evt)
    (compass-panel self))
  
  (method (on-map-panel self evt)
    (map-panel self))
  
  (method (on-combat-panel self evt)
    (combat-panel self))
  
  (method (on-character-panel self evt)
    (character-panel self))
  
  (method (on-bag-panel self evt)
    (bag-panel self))
  
  (method (on-belt-panel self evt)
    (belt-panel self))
  
  (method (on-who-panel self evt)
    (who-panel self))
  
  (method (on-chat-panel self evt)
    (chat-panel self))
  
  (method (on-command-message self evt)
    (command-message self))
  
  (method (on-command-slash self evt)
    (command-slash self))
  
  (method (on-command-previous self evt)
    (command-previous self))
  
  
  ;; Motion
  (method (on-person-motion self evt)
    (person-motion self))
  
  (method (on-orbit-motion self evt)
    (orbit-motion self))
  
  (method (on-free-motion self evt)
    (free-motion self))
  
  @needs-a-lot-more-work
  (method (on-toggle-camera-smoothing self evt)
    (toggle-camera-smoothing self))
  
  (method (on-toggle-camera-follow self evt)
    (toggle-camera-follow self))
  
  (method (on-toggle-autotrack-mode self evt)
    (toggle-autotrack-mode self))
  
  
  ;; Edition
  (method (on-showcase self evt)
    (let ((show (get-property evt showcase:)))
      (if (not show)
          (no-showcase self)
        (toggle-showcase self show))))
  
  (method (on-delete-target self evt)
    (delete-target self))
  
  (method (on-toggle-grid self evt)
    (toggle-grid self))
  
  (method (on-toggle-grid-plane self evt)
    (toggle-grid-plane self (get-property evt plane:)))
  
  (method (on-decrease-grid self evt)
    (decrease-grid self))
  
  (method (on-increase-grid self evt)
    (increase-grid self))
  
  (method (on-reset-textures self evt)
    (reset-textures self)
    (display-message self "Textures reset"))
  
  (method (on-change-editor-mode self evt)
    (change-editor-mode self reversed?: (effective-event-reversed? self evt)))
  
  (method (on-select-target-mode self evt)
    (select-target-mode self))
  
  (method (on-move-target-mode self evt)
    (move-target-mode self))
  
  (method (on-rotate-target-mode self evt)
    (rotate-target-mode self))
  
  (method (on-scale-target-mode self evt)
    (scale-target-mode self))
  
  (method (on-skeleton-target-mode self evt)
    (skeleton-target-mode self))
  
  
  ;; History
  (method (on-toggle-paused self evt)
    (toggle-paused self))
  
  (method (on-backward-history self evt)
    (backward-history self))
  
  (method (on-forward-history self evt)
    (forward-history self))
  
  (method (on-step-backward self evt)
    (step-backward self))
  
  (method (on-step-forward self evt)
    (step-forward self))
  
  (method (on-step-over self evt)
    (step-over self))
  
  (method (on-toggle-evaluate-future self evt)
    (toggle-evaluate-future self))
  
  
  ;; Window
  (method (on-toggle-windowed-mode self evt)
    (toggle-windowed-mode self))
  
  (method (on-tile-server/clients self evt)
    (tile-server/clients self))
  
  (method (on-restore-server/clients self evt)
    (restore-server/clients self))
  
  (method (on-live-gaia/world self evt)
    (live-gaia/world self))
  
  (method (on-design-gaia/world self evt)
    (design-gaia/world self))
  
  (method (on-restore-gaia/world self evt)
    (restore-gaia/world self))
  
  (method (on-zoom-horizontally self evt)
    (zoom-horizontally self))
  
  (method (on-zoom-vertically self evt)
    (zoom-vertically self))
  
  (method (on-zoom-fullscreen self evt)
    (zoom-fullscreen self))
  
  
  (method (on-zoom-in-script self evt)
    (zoom-in-script self))
  
  (method (on-zoom-out-script self evt)
    (zoom-out-script self))
  
  (method (on-unzoom-script self evt)
    (unzoom-script self))


  ;; Debug
  (method (on-toggle-axes self evt)
    (toggle-axes self))
  
  (method (on-toggle-axes-graduation self evt)
    (toggle-axes-graduation self))
  
  (method (on-toggle-info self evt)
    (toggle-info self))
  
  (method (on-toggle-target self evt)
    (toggle-target self))
  
  (method (on-target-script self evt)
    (toggle-target-script))
  
  (method (on-view-workspace self evt)
    (view-workspace))
  
  (method (on-view-console self evt)
    (view-console))
  
  (method (on-view-script self evt)
    (view-script))
  
  (method (on-view-debugger self evt)
    (view-debugger))
  
  (method (on-view-toolbox self evt)
    (view-toolbox))
  
  (method (on-cycle-panes self evt)
    (let ((target (first-target self)))
      (if (is-not? target Entity)
          (bell)
        (cycle-panes target))))
  
  (method (on-run-selected-script self evt)
    (run-selected-script))
  
  (method (on-toggle-orientation self evt)
    (toggle-orientation self))
  
  (method (on-toggle-debug-sections self evt)
    (toggle-debug-sections (current-zone)))
  
  (method (on-toggle-debug-sectors self evt)
    (toggle-debug-sectors (current-zone)))
  
  (method (on-toggle-debug-areas self evt)
    (toggle-debug-areas (current-zone)))
  
  (method (on-toggle-draw-me self evt)
    (toggle-draw-me self))
  
  (method (on-change-missile-behavior self evt)
    (change-missile-behavior self reversed?: (effective-event-reversed? self evt)))
  
  (method (on-reset-marks self evt)
    (reset-all-marks (current-zone)))
  
  (method (on-clear-terminal self evt)
    (clear-terminal))
  
  (method (on-clear-console self evt)
    (if (get-controller-debugger)
        (clear-debugger-console)
      (display-error self "Not connected to a debugger")))
  
  (method (on-toggle-gc-sound self evt)
    (toggle-gc-sound self))

  (method (on-garbage-collect self evt)
    (garbage-collect self))

  (method (on-explore-interface self evt)
    (explore-interface self))
  
  (method (on-propagation-debugger self evt)
    (propagation-debugger self))
  
  (method (on-test1-script self evt)
    (test1-script))

  (method (on-test2-script self evt)
    (test2-script))

  (method (on-test3-script self evt)
    (test3-script))

  (method (on-test4-script self evt)
    (test4-script))

  (method (on-test5-script self evt)
    (test5-script))

  (method (on-test6-script self evt)
    (test6-script))

  (method (on-test7-script self evt)
    (test7-script))

  (method (on-test8-script self evt)
    (test8-script))

  (method (on-test9-script self evt)
    (test9-script))

  (method (on-test0-script self evt)
    (test0-script))
  
  
  ;; Collision
  (method protected (setup-collisions self)
    (set! evaluate-future? #f)
    (set! tick-slice? #f)
    (set-move-speed history-camera 0.05)
    (set-strafe-speed history-camera 0.02)
    (set-rotate-speed history-camera 0.02)
    (set-debug-collisions? #t)
    (display-message self "Collisions setup"))
  
  
  ;; Utility
  (method (effective-event-reversed? self evt)
    (shift-down?))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (slot evaluate-future?    initialize #t getter generate)
  (slot history-was-shown?  initialize #f getter generate)
  (slot profiler-was-shown? initialize #f getter generate)
  
  
  (method (toggle-paused self)
    (if (not (admin?))
        (unimplemented-connected self)
      (let ((tier (current-tier))
            (history (current-history)))
        (if (get-paused? history)
            (unpause-tier tier)
          (pause-tier tier)))))
  
  
  (method package (pause-world self)
    (let ((interface (current-interface+))
          (history (current-history)))
      (unless (get-paused? history)
        (pause history)
        (when (window?)
          (let ((timeline (child interface 'history))
                (profiler (child interface 'profiler)))
            (set! history-was-shown? (get-visible? timeline))
            (set! profiler-was-shown? (get-visible? profiler))
            (camera-copy! history-camera eye)
            (set-current-camera history-camera)
            (set-current-motion history-motion)
            (preload-sectors (current-zone))
            (update-camera-parameters self)
            (unadvise-sites)
            (setup-copy-information timeline)
            (show-history self)
            @wait-too-much
            (set-profiler-range #f)
            @wait-too-much
            (view-sites profiler)
            @wait-too-much
            (set-visible? profiler #t)
            (interface-layout self)
            (update-parameter self 'paused)))
        (add-snapshot-property 'live.paused? #t))))
  
  
  (method package (unpause-world self)
    (let ((interface (current-interface+))
          (history (current-history)))
      (when (get-paused? history)
        (when (window?)
          (camera-copy! eye history-camera)
          (set-current-camera eye)
          (set-current-motion eye-motion)
          (preload-sectors (current-zone)))
        (unpause history)
        (when (window?)
          (let ((timeline (child interface 'history))
                (profiler (child interface 'profiler)))
            (eye-behind-player self)
            (follow-player self)
            (advise-sites)
            (setup-live-information timeline)
            (if history-was-shown?
                (redraw timeline)
              (hide-history self))
            @wait-too-much
            (set-profiler-range #t)
            @wait-too-much
            (view-sites profiler)
            @wait-too-much
            (when (not profiler-was-shown?)
              (set-visible? profiler #f))
            (interface-layout self)
            (update-parameter self 'paused)))
        (add-snapshot-property 'live.paused? #f))))
  
  
  (method package (backward-history self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (backward-history history #t))))
  
  
  (method package (forward-history self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (forward-history history #t))))
  
  
  (method package (step-backward self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (step-backward history))))
  
  
  (method package (step-forward self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (step-forward history))))
  
  
  (method package (step-over self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (step-over history))))
  
  
  (method package (recalculate-future self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (recalculate-future history))))
  
  
  (method (update-future self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (recalculate-future self))))
  
  
  (method (toggle-evaluate-future self)
    (unimplemented-connected self)
    (set! evaluate-future? (not evaluate-future?))
    (update-parameter self 'evaluate-future)
    (display-on/off self "Evaluate future" evaluate-future?))
  
  
  (method package (snapshot-metadata self entity)
    (and (snapshot-metadata? entity)
         (list entity (cache-model entity) (entity-meshes entity) (copy-matrix (get-matrix entity)))))
  
  
  ;;;
  ;;;; Action
  ;;;
  
  
  (slot commands-hook initialize #f accessors generate)
  (slot action-hook   initialize #f accessors generate)
  
  
  (method package (hook-commands self commands)
    (if commands-hook
        (commands-hook commands)
      #t))
  
  
  (method (hook-action self name arguments)
    (if action-hook
        (action-hook name arguments)
      #t))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method package (process-movement self modifiers)
    (let ((f? (move-forward-down? modifiers))
          (b? (move-backward-down? modifiers))
          (l? (move-left-down? modifiers))
          (r? (move-right-down? modifiers))
          (s? (sprint-down? modifiers))
          (move-steer? (get-move-steer?))
          (mouse-down? (or world-mouse-down? world-right-mouse-down?)))
      (define (strafe?)
        (or (and move-steer?
                 (get-autotrack-camera?))
            mouse-down?))
      
      (define (down-inhibit)
        (when mouse-down?
          (set! inhibit-up? #t)))
      
      (cond ((or f? b? s?)
             (when (not moving?)
               (down-inhibit)
               (when move-steer?
                 (set! was-autotrack? (get-autotrack-mode?))
                 (unless mouse-down?
                   (enable-autotrack-mode self feedback?: #f)))
               (set! realign? #t)
               (set! moving? #t)
               (when (is-tracking? self)
                 (mouse-track self 0. 0.))))
            (else
             (when moving?
               (when (and move-steer? (not was-autotrack?))
                 (disable-autotrack-mode self feedback?: #f))
               (set! moving? #f))))
      (when f?
        (move-forward self)
        (done-move self))
      (when b?
        (move-backward self)
        (done-move self))
      (when l?
        (if (strafe?)
            (begin
              (move-left self)
              (down-inhibit))
          (rotate-left self)
          (done-look self)))
      (when r?
        (if (strafe?)
            (begin
              (move-right self)
              (down-inhibit))
          (rotate-right self)
          (done-look self)))))
  
  
  (method package (move-forward self)
    (unless camera-bound?
      (move-forward (current-motion))))
  
  
  (method package (move-backward self)
    (unless camera-bound?
      (move-backward (current-motion))))
  
  
  (method package (sprint-forward self)
    (sprint-forward (current-motion)))
  
  
  (method package (sprint-backward self)
    (sprint-backward (current-motion)))
  
  
  (method package (warp-forward self)
    (warp-forward (current-motion)))
  
  
  (method package (warp-backward self)
    (warp-backward (current-motion)))
  
  
  (method package (move-left self)
    (unless camera-bound?
      (move-left (current-motion))))
  
  
  (method package (move-right self)
    (unless camera-bound?
      (move-right (current-motion))))
  
  
  (method package (process-move-up self)
    (let ((me (current-me))
          (history (current-history)))
      (if (or (get-paused? history) (and (person-motion?) (flying? me)))
          (move-up self)
        (space self))))
  
  
  (method package (move-up self)
    (unless camera-bound?
      (move-up (current-motion))))
  
  
  (method package (process-move-down self)
    (move-down self))
  
  
  (method package (move-down self)
    (unless camera-bound?
      (move-down (current-motion))))
  
  
  (method package (process-rotate-left self)
    (if (is-tracking? self)
        (move-left self)
      (rotate-left self)))
  
  
  (method package (rotate-left self)
    (unless camera-bound?
      (rotate-left (current-motion))))
  
  
  (method package (process-rotate-right self)
    (if (is-tracking? self)
        (move-right self)
      (rotate-right self)))
  
  
  (method package (rotate-right self)
    (unless camera-bound?
      (rotate-right (current-motion))))
  
  
  (method package (space self)
    (let ((me (current-me+))
          (motion (current-motion)))
      (cond ((person-motion?)
             (space me commands))
            ((orbit-motion?)
             (move-up motion))
            (else
             (move-up self)))))
  
  
  ;;;
  ;;;; Game
  ;;;
  
  
  (method package (fire-aim self kind)
    (let ((me (current-controlled self)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (fire-aim me kind)))))
  
  
  (method package (maybe-fire self kind)
    (let ((me (current-controlled self)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (maybe-fire me kind)))))
  
  
  (method (maybe-rapid-fire self)
    (unless (orbit-motion?)
      (rapid-fire self)))
  
  
  (method (rapid-fire self)
    (let ((me (current-controlled self)))
      (start-rapid-fire me)))
  
  
  (method package (warp self (reversed? #f))
    (if reversed?
        (warp-backward self)
      (warp-forward self)))
  
  
  (method (toggle-run self)
    (let ((me (current-controlled self)))
      (set-motion me (if (eq? (get-motion me) 'run)
                          'walk
                        'run))))
  
  
  ;;;
  ;;;; Eye
  ;;;
  
  
  (method (set-eye self camera)
    (camera-copy! eye camera))
  
  
  (method (initialize-eye self)
    (set-move-speed eye (world-setting 'world.camera-move-speed .5))
    (set-sprint-speed eye (world-setting 'world.camera-sprint-speed 1.5))
    (set-warp-speed eye (world-setting 'world.camera-warp-speed 4.))
    (set-strafe-speed eye (world-setting 'world.camera-strafe-speed .1))
    (set-rotate-speed eye (world-setting 'world.camera-rotate-speed .035)))
  
  
  (method (camera-callback self stable?)
    (when (not stable?)
      (when (and render-thread (not render-trim?))
        ;; sector priorities depend on the camera so we have to trim
        (set! render-trim? #t))))
  
  
  (method (toggle-orientation self)
    (set! orientation? (not orientation?))
    (update-parameter self 'orientation))

  
  (method package (zoom-in self)
    (zoom-in (current-motion)))
  
  
  (method package (zoom-out self)
    (zoom-out (current-motion)))
  
  
  @needs-a-lot-more-work
  (method (toggle-camera-smoothing self)
    (change-camera-smoothing self (not (get-camera-smoothing?)))
    (display-on/off self "Camera smoothing" (get-camera-smoothing?)))
  
  
  @needs-a-lot-more-work
  (method package (change-camera-smoothing self value)
    (set-camera-smoothing? value)
    (update-parameter self 'camera-smoothing))
  
  
  (method (toggle-camera-follow self)
    (let ((camera (next-element '(follow free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'follow)
        (follow-player self))
      (update-parameter self 'camera-follow)
      (display-message self (format "Camera {a}" camera))))
  
  
  (method (toggle-autotrack-mode self)
    (if (get-autotrack-mode?)
        (disable-autotrack-mode self)
      (enable-autotrack-mode self)))
  
  
  (method package virtual (autotrack-inhibit? self from-activate?)
    (or (not (get-autotrack-mode?))
        (and (not from-activate?)
             (not application-active?))
        (top-panel)
        showcase))
  
  
  (method package (enable-autotrack-mode self (feedback?: feedback? #t))
    (unless (get-autotrack-mode?)
      (set-autotrack-mode? #t)
      (maybe-enable-autotrack self)
      (when feedback?
        (display-on/off self "Travel mode" #t))))
  
  
  (method package (disable-autotrack-mode self (feedback?: feedback? #t))
    (when (get-autotrack-mode?)
      (set-autotrack-mode? #f)
      (disable-autotrack self)
      (when feedback?
        (display-on/off self "Travel mode" #f))))
  
  
  (method package (update-autotrack self)
    (when (get-autotrack-mode?)
      (if (get-autotrack-camera?)
          (when (autotrack-inhibit? self #f)
            (disable-autotrack self))
        (maybe-enable-autotrack self #f))))
  
  
  (method package (maybe-enable-autotrack self (from-activate? #f))
    (unless (get-autotrack-camera?)
      (unless (autotrack-inhibit? self from-activate?)
        (enable-autotrack self))))
  
  
  (method package (enable-autotrack self)
    (let ((window (current-window))
          (space (current-space)))
      (unless (get-autotrack-camera?)
        (set-autotrack-camera? #t)
        ;; important to let mouse-moved do the
        ;; track-start and the capture-cursor
        (set! realign? #t)
        (hide-cursor window)
        (close-popups window)
        (maybe-fade-mainbar space))))
  
  
  (method package (disable-autotrack self)
    (let ((window (current-window)))
      (when (get-autotrack-camera?)
        (set-autotrack-camera? #f)
        (release-cursor window)
        (show-cursor window))))
  
  
  (method package (current-controlled self)
    (let ((me (current-me)))
      (effective-controlled me)))
  
  
  (method (current-controlled+ self)
    (let ((me (current-me+)))
      (and me (effective-controlled me))))
  
  
  (method package (follow-player self)
    (follow-player (current-motion)))
  
  
  (method package (follow-actor self actor)
    (follow-actor (current-motion) actor))
  
  
  (method package (eye-behind-player self)
    (eye-behind-player (current-motion)))
  
  
  (method package (eye-behind-actor self actor)
    (eye-behind-actor (current-motion) actor))
  
  
  (method (mark-eye self)
    (let ((zone (current-zone))
          (me (current-me)))
      (add-mark zone (new Position-Mark (lens-center me) color: red-dye))
      (add-mark zone (new Position-Mark (get-position (current-camera)) color: green-dye))
      (add-mark zone (new Position-Mark (get-target (current-camera)) color: blue-dye))))
  
  
  (method (effective-autotrack-camera? self)
    (let ((zone (current-zone)))
      (and (get-autotrack-camera?)
           (world-focused?)
           (not (top-panel))
           (not (login? zone)))))
  
  
  (method package virtual (effective-independent-camera? self)
    (get-independent-camera?))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method package (is-tracking? self)
    (let ((autotrack? (effective-autotrack-camera? self))
          (independent? (effective-independent-camera? self)))
      (or (and moving? autotrack?)
          (and (not moving?) autotrack? (not independent?))
          (and down? (or (and tracking? (or (person-motion?) (free-motion?))) (not independent?))))))
  
  
  (method (mind-control self)
    (let ((me (current-me)))
      (let ((controlled (get-controlled me))
            (target (first-target self)))
        (if (and (is? target Actor)
                 (neq? target controlled))
            (control me target)
          (when controlled
            (relinquish-control me))))))
  
  
  (method (toggle-aim self)
    (set! aim? (not aim?))
    (update-parameter self 'aim))
  
  
  (method (toggle-free-aim self)
    (set! free-aim? (not free-aim?))
    (update-parameter self 'free-aim)
    (display-on/off self "Free aim" free-aim?))

  
  (method (draw-aim self)
    (let ((me (current-me)))
      (let ((lens (lens-center me)))
        (let ((x (vertex-x lens))
              (y (vertex-y lens))
              (z (vertex-z lens))
              (size .05)
              (width .0015))
          (render-line (vertex (- x size) y z)
                       (vertex (+ x size) y z)
                       width
                       white-dye)
          (render-line (vertex x (- y size) z)
                       (vertex x (+ y size) z)
                       width
                       white-dye)
          (render-line (vertex x y (- z size))
                       (vertex x y (+ z size))
                       width
                       white-dye)))))
  
  
  ;;;
  ;;;; Resize
  ;;;
  
  
  (method package virtual (resize-scene self)
    (when (window?)
      (cond-expand
        (linux)
        (else
         (let ((width (fxround width))
               (height (fxround height)))
           (resize multisampled-framebuffer width height))))
      (resize-interface self)
      (resize-sheets self)
      (resize-mainbar width height)
      (resize (current-video))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method package (run-interface self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (let ((time (current-monotonic)))
            (with-task-mutex
              (lambda ()
                (unless (stopping? task)
                  (process-interface self time))))
            (let ((period interface-period)
                  (duration (- (current-monotonic) time)))
              (task-wait task period duration exit)))
          (iter)))))
  
  
  (method (process-interface self time)
    (site interface
      (let ((interface (current-interface)))
        (when (and (view-interface? self) (refresh-interface? self))
          (refresh-interface self)
          (draw-player interface)
          (set! interface-last-time time)
          (set! interface-refresh? #f)))))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (boost-render self)
    (when (and render-thread (not render-boost?))
      (set-render-boost? #t)
      (task-wakeup render-task)))
  
  
  (method (unboost-render self)
    (set-render-boost? #f))
  
  
  (method package (run-render self task <Task>)
    (declare (proper-tail-calls))
    (let ((window (current-window))
          (zone (current-zone)))
      (with-task task
        (lambda (exit)
          (set! render-task task)
          (set! render-thread (current-thread))
          (let (iter)
            (let ((time (current-monotonic))
                  (camera (current-camera)))
              (with-task-mutex
                (lambda ()
                  (unless (stopping? task)
                    (process-render self window zone camera))))
              (unboost-render self)
              (let ((period (if application-active? render-period render-period-inactive))
                    (duration (- (current-monotonic) time)))
                (update-fps duration)
                (task-wait task period duration exit)))
            (iter))))))
  
  
  (method (process-render self window zone camera)
    (site render
      (update-stable camera camera-stable-delay)
      (when render-trim?
        (let ((trimmed (trim-generate)))
          (when (> trimmed 0)
            (decrease-sectors-generating zone trimmed)))
        (set! render-trim? #f)
        (eye-update))
      (render-frame self)
      (render-sync window)))
  
  
  (method package (render-frame self)
    (with-render-mutex
      (lambda ()
        ;; pre
        (when multisampling?
          (preprocess-multisampled self))
        ;; clear
        (glClear (bitwise-ior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
        ;; all
        (render-all self)
        ;; post
        (when multisampling?
          (postprocess-multisampled self))
        (gl-check-error))))
  
  
  (method package (render-all self)
    ;; world
    (render-world self)
    ;; mainbar
    (when (and mainbar-sheet (get-visible? mainbar-sheet) (get-mapped? (get-texture mainbar-sheet)))
      (render-sheet mainbar-sheet))
    ;; interface
    (render-interface self)
    ;; visualizer
    (render-visualizer))
  
  
  (method protected virtual (render-outputs self)
    (let ((video (current-video)))
      (render-outputs video)))
  
  
  (method (preprocess-multisampled self)
    (cond-expand
      (linux)
      (else
       (allege multisampled-framebuffer
         (unless (get-inhibit? multisampled-framebuffer)
           (bind-framebuffer multisampled-framebuffer))))))
  
  
  (method (postprocess-multisampled self)
    (cond-expand
      (linux)
      (else
       ;; copy the render target color buffer onto the native buffer
       (allege multisampled-framebuffer
         (unless (get-inhibit? multisampled-framebuffer)
           (blit multisampled-framebuffer 0)
           (unbind-framebuffer multisampled-framebuffer))))))
  
  
  (definition selection-dyes
    (list red-dye)
    @wait
    (list red-dye (dye .890 .043 .937 1.) blue-dye))
  
  
  (method (render-world self)
    (let ((zone (current-zone))
          (space (current-space))
          (me (current-me+))
          (history (current-history)))
      (let ((only-skybox (only-skybox space)))
        (if only-skybox
            (begin
              (draw-skybox only-skybox)
              (when (get-debug-sections? zone)
                (draw-debug-sections zone))
              (when (and showcase interface?)
                (draw-showcase showcase)))
          (when (draw-skybox? space)
            (let ((skybox (get-skybox zone)))
              (when skybox
                (draw-skybox skybox))))
          (unless (planets? zone)
            (when (draw-horizon? space)
              (draw-horizon)))
          (render-outputs self)
          (when (draw-world? space)
            (draw-zone zone)
            (when (and grid? (get-draw-grid? zone))
              (draw-grid))
            (when axes?
              (draw-axes self))
            (when (and aim? free-aim?)
              (draw-aim self))
            (when (get-paused? history)
              (render-history self))
            (render-opaque)
            (render-transparent)
            (render-orb)
            (render-zone zone)
            ;; draw player last
            (when (and me draw-me? (show-me? space) (participant?))
              (reset-renderers)
              (register-entity me)
              (render-opaque)
              (render-transparent)
              (render-orb))
            (when (and target-widget (not-null? selection) (target-moveable? (cast <Element> (car selection))))
              (draw-widget target-widget))
            ;; useful for debugging
            ;; (draw-bounds me red-dye)
            ;; (draw-collision-bounds me blue-dye)
            (let (iter (scan selection) (dyes selection-dyes))
              (when (not-null? scan)
                (let ((elem <Element> (car scan)))
                  (draw-target elem (car dyes))
                  (when draw-normals?
                    (for-each (lambda (poly)
                                (draw-plane poly red-dye torus-radius: .015))
                              (element-polygons elem)))
                  (iter (cdr scan) (if (null? (cdr dyes)) dyes (cdr dyes))))))
            (when (and target-polygon (null? selection))
              (draw-polygon target-polygon red-dye)
              (when target-vertex
                (draw-polygon-vertex target-polygon target-vertex purple-dye))
              (when draw-normals?
                (draw-plane target-polygon red-dye torus-radius: .015)))
            (when (get-debug-areas? zone)
              (draw-debug-areas zone))
            (when (get-debug-sectors? zone)
              (draw-debug-sectors zone))
            (when (get-debug-sections? zone)
              (draw-debug-sections zone))
            (when orientation?
              (draw-orientation (current-camera)))
            (when (and showcase interface?)
              (draw-showcase showcase))
            (gl-check-error))))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (draw-axes self)
    (let ((rl render-line))
      ;; pragmatic draw above ground
      (define (render-line start end width color)
        (let ((upped (vertex& 0. (+ 4. width) 0.)))
          (rl (vertex+ start upped)
              (vertex+ end upped)
              width
              color)))
      
      ;; X
      (render-line (vertex -10.0   0.0   0.0) (vertex 10.0  0.0  0.0) .05 red-dye)
      (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0  0.5) .05 red-dye)
      (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0 -0.5) .05 red-dye)
      
      ;; Y
      (render-line (vertex   0.0 -10.0   0.0) (vertex  0.0 10.0  0.0) .05 green-dye)
      (render-line (vertex   0.0  10.0   0.0) (vertex  0.5  9.5  0.0) .05 green-dye)
      (render-line (vertex   0.0  10.0   0.0) (vertex -0.5  9.5  0.0) .05 green-dye)
      
      ;; Z
      (render-line (vertex   0.0   0.0 -10.0) (vertex  0.0  0.0 10.0) .05 blue-dye)
      (render-line (vertex   0.0   0.0  10.0) (vertex  0.5  0.0  9.5) .05 blue-dye)
      (render-line (vertex   0.0   0.0  10.0) (vertex -0.5  0.0  9.5) .05 blue-dye)
      
      (when axes-graduation?
        (let ((grad .15))
          ;; X
          (loop (for x <fl> from -9. to 9. by 1.)
                (render-line (vertex x (- grad) 0.0) (vertex x grad 0.0) .01 red-dye))
          
          ;; Y
          (loop (for y <fl> from -9. to 9. by 1.)
                (render-line (vertex (- grad) y 0.0) (vertex grad y 0.0) .01 green-dye))
          
          ;; Z
          (loop (for z <fl> from -9. to 9. by 1.)
                (render-line (vertex 0.0 (- grad) z) (vertex 0.0 grad z) .01 blue-dye))))))
  
  
  (method (render-history self)
    (let ((history (current-history)))
      (define (draw-now metadata)
        (bind (entity model meshes matrix) metadata
          (when (history-draw-now? entity)
            (register-ghost entity model meshes matrix 0))))
        
      (define (draw-metadata metadata)
        (bind (entity model meshes matrix) metadata
          (when (history-draw-trail? entity)
            (register-ghost entity model meshes matrix 1))))
      
      (define (draw-trail from to)
        (let (iter (n from) (count 0))
          (when (and (<= n to) (< count history-trail))
            (let ((metadata (historical-metadata history n)))
              (if (not metadata)
                  (iter (+ n 1) count)
                (draw-metadata metadata)
                (iter (+ n 1) (+ count 1)))))))
      
      (let ((now (get-now history))
            (first (history-first history))
            (last (history-last history)))
        (draw-trail first (- now 1))
        (draw-trail (+ now 1) last)
        (unless (= (get-count history) 0)
          (let ((now-metadata (historical-metadata history now)))
            (when now-metadata
              (draw-now now-metadata)))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method (view-interface? self)
    (let ((interface (current-interface)))
      (define (visible? name)
        (let ((view (child interface name)))
          (get-visible? view)))
      
      (and interface?
           (or (visible? 'info)
               (visible? 'target)
               (visible? 'compass)
               (visible? 'profiler)
               (visible? 'evolution)
               (visible? 'history)
               (call-refresh-interface-hook)))))
  
  
  (method (refresh-interface? self)
    (let ((interface (current-interface)))
      (and interface?
           (let ((now (current-monotonic)))
             (define (visible? name)
               (let ((view (child interface name)))
                 (get-visible? view)))
             
             (and (> (- now interface-last-time) interface-period)
                  (or (visible? 'info)
                      (visible? 'target)
                      (visible? 'compass)
                      (visible? 'profiler)
                      (visible? 'evolution)
                      (visible? 'history)
                      (call-refresh-interface-hook))
                  (not interface-refresh?))))))
  
  
  (method package (refresh-interface self (condition: condition #f))
    (let ((interface (current-interface))
          (history (current-history)))
      (when (or (not condition)
                (some? (lambda (name)
                         (get-visible? (child interface name)))
                       condition)
                (call-refresh-interface-hook))
        (set! interface-refresh? #t)
        (let ((info (child interface 'info)))
          (when (get-visible? info)
            (view-info info)))
        (let ((target (child interface 'target)))
          (when (get-visible? target)
            (view-target target)))
        (let ((target (child interface 'compass)))
          (when (get-visible? target)
            (refresh-compass self)))
        (let ((profiler (child interface 'profiler)))
          (when (get-visible? profiler)
            (unless (get-paused? history)
              (view-sites profiler))))
        (let ((evolution (child interface 'evolution)))
          (when (get-visible? evolution)
            (refresh-evolution)))
        (let ((history (child interface 'history)))
          (when (get-visible? history)
            (refresh-history)))
        (let ((refresh (call-refresh-interface-hook)))
          (when (procedure? refresh)
            (refresh))))))
  
  
  (method package (render-interface self)
    (let ((interface (current-interface))
          (space (current-space)))
      (when interface?
        (when interface-refresh?
          ;; update block at eye information
          @wait
          (target-update (current-zone) #f #f #f #t)
          (set! interface-last-time (current-monotonic))
          (set! interface-refresh? #f))
        (when (draw-world? space)
          ;; removing slots background and drawing them first is
          ;; a quick hack around slots being drawn over everything
          (draw-slots))
        (when (draw-compass? space)
          (when compass-visible?
            (draw-compass)))
        (render-sheet interface)
        (when map-visible?
          (draw-map))
        (when evolution-visible?
          (draw-evolution))
        (when history-visible?
          (draw-history))
        (when message
          (draw-message self))
        (when status
          (draw-status self))
        (when action
          (draw-action self)))))
  
  
  (method (explore-interface self)
    (change-explore-interface? self (not explore-interface?))
    (when explore-interface?
      (set! interface? #t)
      (set-cursor :arrow))
    (update-cursor))
  
  
  (method (change-explore-interface? self flag)
    (set! explore-interface? flag)
    (if explore-interface?
        (display-message self "Explore interface")
      (display-status self "Done")))
  
  
  (method package (refresh-compass self)
    (let ((interface (current-interface+)))
      (when (and interface compass-visible?)
        (let ((panel (child interface 'compass)))
          (set-uptodate? panel #f)))))
  
  
  (method (propagation-debugger self)
    (let ((interface (current-interface)))
      (let ((frame (find-component interface 'propagation)))
        (if frame
            (close frame)
          (let ((size propagation-size)
                (slot-size propagation-slot-size))
            (open-frame
              (new Propagation-Frame
                name: 'propagation
                size: (new Dimension (+ (* slot-size size) 1) (+ 20 (* slot-size size) 1))
                location: '(center -75))))
          (layout-view interface)))))
  
  
  (method package (close-top self)
    (define (top-close)
      (let ((interface (current-interface)))
        (find-if (lambda (obj)
                   (and (is? obj World-Panel)
                        (get-visible? obj)
                        (escape-close? obj)))
                 (get-children interface)
                 reversed?: #t)))
    
    (let ((focus (get-window-focus)))
      (if (is? focus World-Pane)
          (begin
            (leave-pane focus)
            #t)
        (let ((top (top-close)))
          (if top
              ;; quicky
              (begin
                (if (is? top Script-Panel)
                    (interface-script #f)
                  (user-close top)
                  (update-cursor))
                #t)
            #f)))))
  
  
  (method package (toggle-radial-menu self (name #f))
    (let ((window (current-window))
          (interface (current-interface))
          (space (current-space)))
      (unless (close-top self)
        (let ((central (child interface 'central-menu)))
          (let ((wheel (child central 'wheel))
                (radial (child central (or name 'main-menu))))
            (cond ((or (not (get-visible? central))
                       (and name (neq? radial radial-menu)))
                   (central-menu-show space)
                   (when radial-menu
                     (set-visible? radial-menu #f))
                   (when (not name)
                     (push-panel central))
                   (set-visible? central #t)
                   (set! central-menu central)
                   (set! interface? #t)
                   (setup-visibility central)
                   (setup-visibility radial)
                   (set-visible? radial #t)
                   (set! radial-menu radial)
                   (layout-view wheel)
                   (layout-view radial)
                   (layout-view central)
                   (layout-view interface)
                   (simulate-mouse-move window))
                  ((or (not name) (neq? radial radial-menu))
                   (pop-panel central-menu)
                   (set-visible? central #f)
                   (set! central-menu #f)
                   (when (and radial-menu (get-visible? radial-menu))
                     (set-visible? radial-menu #f)
                     (set! radial-menu #f))
                   (central-menu-hide space))))))))
  
  
  (method package (refresh-central-menu self)
    (let ((window (current-window))
          (interface (current-interface))
          (space (current-space)))
      (when (and central-menu radial-menu)
        (let ((central central-menu)
              (radial radial-menu))
          ;; adapted copy of toggle-radial-menu
          (let ((wheel (child central-menu 'wheel)))
            (let ((wheel-button (child wheel (get-name radial))))
              (set-visible? radial #f)
              (setup-visibility central)
              ;; check if wheel button still visible
              (let ((radial (if (get-visible? wheel-button) radial (child central 'main-menu))))
                (setup-visibility radial)
                (set-visible? radial #t)
                (set! radial-menu radial)
                (layout-view wheel)
                (layout-view radial)
                (layout-view central)
                (layout-view interface)
                (simulate-mouse-move window))))))))
  
  
  (method protected (reset-central-menu self)
    (when central-menu
      (set-visible? central-menu #f)
      (set! central-menu #f))
    (when radial-menu
      (set-visible? radial-menu #f)
      (set! radial-menu #f)))
  
  
  (method protected (main-menu self)
    (toggle-radial-menu self 'main-menu))
  
  
  (method protected (close-main-menu self)
    (when radial-menu
      (destack-panel central-menu)
      (toggle-radial-menu self (get-name radial-menu))))
  
  
  (method protected (close-main-menu2 self)
    (when radial-menu
      (destack-panel central-menu)
      (toggle-radial-menu self #f)))
  
  
  (method (graphics-options self)
    (push-panel (open-frame (new World-Graphics-Options size: {Dimension 466 328} location: 'center))))
  
  
  (method (sound-options self)
    (push-panel (open-frame (new World-Sound-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method (interface-options self)
    (push-panel (open-frame (new World-Interface-Options size: {Dimension 466 188} location: 'center))))
  
  
  (method package (view-bindings self)
    (let ((interface (current-interface)))
      (let ((frame (find-component interface 'bindings)))
        (if frame
            (if (get-visible? frame)
                (begin
                  (set-visible? frame #f)
                  (pop-panel frame))
              (update-bindings frame)
              (set-visible? frame #t)
              (push-panel frame))
          (push-panel (open-frame (new World-Bindings-Viewer name: 'bindings size: {Dimension 406 588} location: 'center)))))
      (focus-world)))
  
  
  (method package (view-news self)
    (push-panel (open-world-document (news-file (current-application)) class: World-Formatted-Text-View)))
  
  
  (method package (view-roadmap self)
    (push-panel (open-world-document (roadmap-file (current-application)) class: World-Formatted-Text-View)))
  
  
  (method package (view-help self)
    (push-panel (open-world-document (help-file (current-application)) class: World-Formatted-Text-View)))
  
  
  (method package (open-about self (name: name #f) (title: title #f) (movable?: movable? #t) (closable?: closable? #t) (closer: closer #f) (background: background #f))
    (let ((zone (current-zone)))
      (push-panel (open-world-document (about-file (current-application)) class: World-Formatted-Text-View name: (or name 'about) title: title movable?: movable? closable?: closable? closer: closer size: (about-size zone) background: background selectable?: #f))))
  
  
  (method package (unstuck-character self)
    (let ((zone (current-zone))
          (me (current-me)))
      (let ((pos (get-position me))
            (rx (random-between -5. 5.))
            (rz (random-between -5. 5.)))
        ;; just enough to clear highest summit in la momie
        (let ((unstuck (vertex (+ (vertex-x pos) rx) 195. (+ (vertex-z pos) rz)))
              (unstuck-gravity (vertex 0. -.002 0.)))
          (set-override-gravity unstuck-gravity)
          (teleport zone unstuck)))))
  
  
  (method package (open-welcome self (exception-title: exception-title #f) (exception: exception #f) (exception-stack: exception-stack #f))
    (close-current-top self)
    (set-inhibit-paint? #t)
    (prog1 (open-welcome-zone force-welcome?: #t)
      (when (or exception-title exception)
        (report-exception exception-title exception exception-stack))
      (set-inhibit-paint? #f)))
  
  
  (method (close-current-top self)
    (let ((top (or (top-frame) (top-menu))))
      (when top
        (close top))))
  
  
  (method protected virtual (interface-layout self)
    (let ((interface (current-interface)))
      (define (layout-panel name)
        (let ((panel (find-component interface name)))
          (when panel
            (let ((layouter (get-layouter panel)))
              (when layouter
                (layouter panel))))))
      
      (for-each layout-panel '(info profiler target combat character bag belt chest chat command compass script models blocks))
      (for-each layout-panel '((replay timeline) (replay visualizer) (replay evolution) (replay moments)))
      (let ((panel (find-component interface 'replay)))
        (when panel
          (layout-view panel)))
      (layout-view interface)))
      
  
  (method package (sheets-layout self)
    (layout-message self)
    (layout-status self)
    (layout-action self)
    (layout-working self)
    (layout-compass)
    (layout-map)
    (layout-evolution)
    (layout-history))

  
  (method (enter-press self)
    (if enter-hook
        (enter-hook)
      (command-message self)))
  
  
  (method (tab-press self)
    (when showcase
      (if (shift-down?)
          (previous-category showcase)
        (next-category showcase))))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method package (missile-hit self missile collision)
    (let ((zone (current-zone))
          (poly (get-polygon collision)))
      (let ((element (get-element poly)))
        (cond ((is? element Actor)
               (case (get-kind missile)
                 ((bullet)
                  (let ((inflictor (get-actor missile)))
                    (wound element inflictor (get-power-factor inflictor))))
                 ((arrow)
                  (explode element (get-actor missile))))
               'remove)
              (else
               (case (get-missile-behavior zone)
                 ((absorb)
                  'remove)
                 ((rebound)
                  (let ((normal (get-normal (get-plane collision)))
                        (velocity (get-velocity missile)))
                    (let ((rebound (dot-product& normal velocity)))
                      (set-velocity missile (vertex-& velocity (vertex-scalar*& normal (* 2. rebound))))))
                  'stop)
                 ((slide)
                  'slide)
                 ((destroy)
                  (let ((editable? (zone-editable? zone))
                        (destructible? (zone-destructible? zone)))
                    (define (remove element)
                      (if editable?
                          (editor-remove-element self element)
                        (remove-element self element)))
                    
                    (when (or editable? destructible?)
                      (let ((element (effective-element self poly)))
                        (let ((pos (get-position element)))
                          (case (get-kind missile)
                            ((bullet)
                             (play-3d-sound "warcraft/combat/explosion" pos)
                             (if (virtual-block? self element)
                                 (delete-block-at (current-universe) pos)
                               (remove element)))
                            ((arrow)
                             @wait
                             (if (virtual-block? element)
                                 (explose-blocks-at (current-universe) pos)
                               (play-3d-sound "warcraft/spells/ExplosiveShot" pos)
                               (remove element))))))))
                  'remove)))))))
  
  
  (method (change-missile-behavior self (reversed?: reversed? #f))
    (let ((zone (current-zone))
          (next (if reversed? previous-element next-element)))
      (unimplemented-connected self)
      (set-missile-behavior zone (next '(destroy absorb rebound slide) (get-missile-behavior zone)))
      (display-message self (format "{a}" (capitalize (symbol->string (get-missile-behavior zone)))))))
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method (zone-open self)
    (let ((interface (current-interface)))
      (let ((panel (find-type interface Zone-Open)))
        (if panel
            (close panel)
          (push-panel (open-frame (new Zone-Open size: {Dimension 366 588} location: 'center)))))))
  
  
  (method protected (zone-reload self)
    (let ((zone (current-zone)))
      (reset-profiler self)
      (load-reset)
      (let ((form (get-form zone))
            (path (get-path zone)))
        (let ((file (get-origin form)))
          (close zone)
          (open-zone file form: form path: path)))))
  
  
  (method package (zone-regenerate self)
    (let ((zone (current-zone)))
      (reset-profiler self)
      (load-reset)
      (iterate-regions-dir (get-dimension zone)
        (lambda (file index)
          (when (extension=? (get-extension file) "mca")
            (delete file))))
      (let ((form (get-form zone))
            (path (get-path zone)))
        (let ((file (get-origin form)))
          (close zone)
          (open-zone file form: form path: path)))))
  
  
  (method package (choose-new self title prefix initial-value proc (kind: kind #f) (kind-name: kind-name #f) (exists: exists #f))
    (let ((tier (current-tier)))
      (ask-string
        title: title
        prefix: prefix
        initial-value: initial-value
        action: (lambda (base)
                  (if (not ;; quick hack
                        (if kind
                            (zone-base-available? base kind)
                          (available-zone-base? tier base)))
                      (if exists
                          (exists base proc)
                        (open-message (format "{a} {a} already exists. Do you want to replace it?" (or kind-name "Zone") base)
                                      caption: "Save"
                                      type: 'confirmation
                                      yes: "Yes"
                                      no: "No"
                                      cancel: "Cancel"
                                      execute: (lambda (evt)
                                                 (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                                       (button (get-property evt button:)))
                                                   (close dialog)
                                                   (case button
                                                     ((yes) (proc base))
                                                     ((no))
                                                     ((cancel) (signal-cancel)))))))
                    (proc base))))))
  
  
  ;;;
  ;;;; Role
  ;;;
  
  
  (method public (toggle-user self)
    (change-role self (if (eq? current-role initial-role)
                          'user
                        initial-role)))
  
  
  ;; quicky
  (hub install-zone)
  (hub uninstall-zone)
  (hub refresh-mode)
  (hub refresh-hierarchy)
  (method public (change-role self new-role)
    (let ((interface (current-interface))
          (zone (current-zone)))
      (let ((appl (current-application))
            ;; quicky
            (together (together:current-together))
            (space (current-space))
            (radial radial-menu)
            (bindings (find-component interface 'bindings)))
        (when radial
          (toggle-radial-menu self (get-name radial)))
        (space-deactivate space)
        (space-uninstall space)
        (uninstall-zone together)
        (uninstall-interface zone)
        (updating-actions appl
          (lambda ()
            (set-current-role new-role)
            (add-snapshot-property 'live.current-role current-role)
            (install-bindings appl)
            (install-role appl)))
        (when (eq? new-role 'user)
          (no-showcase self))
        (reset-inventory-blocks)
        (install-interface zone)
        (install-zone together)
        (space-install space)
        (space-activate space)
        (refresh-mode together)
        (refresh-hierarchy together)
        (setup-visibility mainbar)
        (when radial
          (toggle-radial-menu self (get-name radial)))
        (when bindings
          (view-bindings self))
        (layout-interface)
        (update-parameter self 'user))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (definition troposphere
    2.)
  
  (definition stratosphere
    3.)
  
  
  (method public (compute-gravity self position)
    (let ((gravity (make-vertex)))
      (vertex-copy! gravity (compute-gravity& self position))
      gravity))
  
  
  (method public (compute-gravity& self position)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (let ((gravity (vertex-copy& ambient-gravity)))
            @gravity
            (iterate-gravities zone
              (lambda (well)
                (let ((pos (get-position well))
                      (radius (get-radius well)))
                  (let ((direction (vertex-normalize& (vertex-& pos position)))
                        (distance (max radius (vertex-distance pos position))))
                    (let ((well-gravity (vertex-scalar*& direction (well-pull self well distance))))
                      (if (<= distance (+ radius troposphere))
                          (continuation-return return well-gravity)
                        (vertex+! gravity gravity well-gravity)))))))
            gravity)))))
  
  
  (method public (well-pull self well distance)
    (let ((mass (well-mass well)))
      (/ mass (* distance distance))))
  
  
  (method public (well-gravity self well position)
    (let ((pos (get-position well))
          (radius (get-radius well)))
      (let ((direction (vertex-normalize& (vertex-& pos position)))
            (distance (max radius (vertex-distance pos position))))
        (vertex-scalar* direction (well-pull self well distance)))))
  
  
  (method public (surface-pull self well)
    (well-pull self well (get-radius well)))
  
  
  ;;;
  ;;;; Vehicle
  ;;;
  
  
  (method package (vehicle-speed self actor)
    (case (vehicle-name actor)
      ((Wheels) 13.)
      ((Hummer) 19.5)
      ((Saucer) 19.5)
      ((Rocket) 65.)
      (else (ground-speed actor))))
  
  
  ;;;
  ;;;; Action
  ;;;
  
  
  (method package (run-action self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic))
                (duration 0.))
            (let ((elapse (- time previous)))
              (unless (> elapse max-elapse)
                (with-task-mutex
                  (lambda ()
                    (unless (stopping? task)
                      (let ((start (current-monotonic)))
                        (process-action self)
                        (increase! duration (- (current-monotonic) start))))))))
            (task-wait task action-period duration exit)
            (iter time))))))
  
  
  (method (process-action self)
    (site action
      (if (participant?)
          (let ((presence? (and (circling?) (not (avatar-mode?)))))
            (when (or presence? (not (check-action self)))
              (cond (tutorial-fade
                     (when (> (current-seconds) tutorial-fade)
                       (fade-action self)
                       (set! tutorial-fade #f)))
                    (tutorial-again
                     (when (> (current-seconds) tutorial-again)
                       (set! tutorial-again #f)))
                    ((and (not presence?) (not tutorial-move?))
                     (display-action self "W S keys - Move Avatar" (lambda ()) tutorial: 'move))
                    ((and (not presence?) (not tutorial-look?))
                     (display-action self "A D keys - Rotate Avatar" (lambda ()) tutorial: 'look))
                    ((not tutorial-menu?)
                     (display-action self "Esc - Central Menu" (lambda ()) tutorial: 'menu))
                    (else
                     (when action-proc
                       (fade-action self))))))
        (clear-action self))))
  
  
  (method (check-action self)
    (let ((zone (current-zone))
          (universe (current-universe))
          (me (current-me)))
      (let ((origin (transformed-center me))
            (direction (get-sight (get-lookat me)))
            (max-distance 2.5))
        (let ((radiuses (transformed-radiuses me)))
          (let ((wider-radiuses (vertex (max (vertex-x radiuses) .75) ;; for thin models like the fox
                                        (* (vertex-y radiuses) 1.1) ;; so we can stand on top of a block
                                        (vertex-z radiuses))))
            (define (polygon-filter poly)
              (get-action-message (id->block (decode-id (get-data1 poly)))))
            
            (bind-values (center direction collisions) (collide&stop$ origin (vertex+& origin (vertex-scalar*& direction max-distance)) (get-lookat me) wider-radiuses max-distance: max-distance area-cube: (update-area-cube me) polygon-filter: polygon-filter ignore-non-physical?: #f ignore-entities?: #f)
              (if (null? collisions)
                  #f
                (prog1 (let ((poly (get-polygon (car collisions))))
                         ;; quick hack around max-distance not handled correctly for entities
                         (if (> (vertex-distance& origin (get-origin poly)) (+ max-distance 1.5))
                             #f
                           (let ((element (get-element poly)))
                             (if element
                                 (when (get-visible? element)
                                   (check-element-action self element))
                               (with-polygon-interaction universe poly
                                 (lambda (poly clicked fore)
                                   (call-with-position zone clicked
                                     (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                                       (let ((block (id/data-id->block block-id data-id)))
                                         (let ((action-message (get-action-message block)))
                                           (if (not action-message)
                                               #f
                                             (let ((message (action-message block-id data-id))
                                                   (right-mouse (get-right-mouse block)))
                                               (display-action self (format "E : {a}" message)
                                                 (lambda ()
                                                   (right-mouse section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                                                   (let ((history (current-history)))
                                                     (unless (or (and (get-paused? history) (not (stepping-history?)))
                                                                 (id? block-id BedBlock Chest WorkbenchBlock SignPost WallSign))
                                                       (let ((position (vertex& x y z)))
                                                         (bidirectional-change 'action (current-seconds)
                                                           (lambda (store push)
                                                             (store push position))
                                                           (lambda (store push)
                                                             (store push position))
                                                           (lambda (store push)
                                                             (store push)))))))))
                                             #t)))))))))))
                  (free-collisions$ collisions)))))))))
  
  
  (method protected virtual (check-element-action self element)
    #f)
  
  
  (method (clear-action self)
    (set! action #f)
    (set! action-time #f)
    (set! action-proc #f))
  
  
  (method (fade-action self)
    (set! action-time (current-monotonic))
    (set! action-duration 0.)
    (set! action-proc #f))
  
  
  (method (perform-action self)
    (when action-proc
      (action-proc)
      (unless (check-action self)
        (fade-action self))))
  
  
  ;;;
  ;;;; Tutorial
  ;;;
  
  
  (method (fade-tutorial self)
    (let ((now (current-seconds)))
      (set! tutorial-fade (+ now 2.5))
      (set! tutorial-again (+ now 4.5))))
  
  
  (method protected (done-look self)
    (when (and (eq? action-tutorial 'look) (not tutorial-look?))
      (set-setting options-settings 'together.tutorial-look? #t)
      (save-content options-settings)
      (fade-tutorial self)
      (set! tutorial-look? #t)))
  
  
  (method protected (done-move self)
    (when (and (eq? action-tutorial 'move) (not tutorial-move?))
      (set-setting options-settings 'together.tutorial-move? #t)
      (save-content options-settings)
      (fade-tutorial self)
      (set! tutorial-move? #t)))
  
  
  (method protected (done-menu self)
    (when (and (eq? action-tutorial 'menu) (not tutorial-menu?))
      (set-setting options-settings 'together.tutorial-menu? #t)
      (save-content options-settings)
      (fade-tutorial self)
      (set! tutorial-menu? #t)))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot editing?          <bool>   initialize #f     getter generate)
  (slot editor-mode       <object> initialize 'plane getter generate)
  (slot editor-added?     <bool>   initialize #f     getter generate)
  (slot editor-origin     <object> initialize #f     getter generate)
  (slot editor-normal     <object> initialize #f     getter generate)
  (slot editor-direction  <object> initialize #f     getter generate)
  (slot editor-floor?     <bool>   initialize #f     getter generate)
  (slot adding            <object> initialize #f     getter generate)
  (slot adding-properties <object> initialize #f     getter generate)
  (slot adding?           <bool>   initialize #f     getter generate)
  (slot deleting?         <bool>   initialize #f     getter generate)
  (slot removing?         <bool>   initialize #f     getter generate)
  (slot changing?         <bool>   initialize #f     getter generate)
  (slot widget-down       <object> initialize #f     getter generate)
  (slot widget-part       <object> initialize #f     getter generate)
  (slot grid?             <bool>   initialize #f     accessors generate)
  (slot grid-plane        <symbol> initialize 'y     getter generate)
  (slot grid-position     <fl>     initialize 0.     accessors generate)
  
  
  (method (change-editor-mode self (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          (available-modes '(plane column free @comment crazy)))
      (let ((new-mode (next available-modes editor-mode)))
        (set! editor-mode new-mode)
        (display-message self (capitalize (->string new-mode))))))
  
  
  (method (select-target-mode self)
    (set! target-mode 'select)
    (set! target-widget #f)
    (update-target-parameters self)
    (display-message self "Select"))
  
  
  (method (move-target-mode self)
    (if (eq? target-mode 'move)
        (select-target-mode self)
      (set! target-mode 'move)
      (set! target-widget (new Mover))
      (update-target-parameters self)
      (display-message self "Move")))
  
  
  (method (rotate-target-mode self)
    (if (eq? target-mode 'rotate)
        (select-target-mode self)
      (set! target-mode 'rotate)
      (set! target-widget (new Rotater))
      (update-target-parameters self)
      (display-message self "Rotate")))
  
  
  (method (scale-target-mode self)
    (if (eq? target-mode 'scale)
        (select-target-mode self)
      (set! target-mode 'scale)
      (set! target-widget (new Scaler))
      (update-target-parameters self)
      (display-message self "Scale")))
  
  
  (method (skeleton-target-mode self)
    (if (eq? target-mode 'skeleton)
        (select-target-mode self)
      (set! target-mode 'skeleton)
      (set! target-widget (new Skeleton))
      (update-target-parameters self)
      (display-message self "Skeleton")))
  
  
  (method (update-target-parameters self)
    (update-parameter self 'select-target-mode)
    (update-parameter self 'move-target-mode)
    (update-parameter self 'rotate-target-mode)
    (update-parameter self 'scale-target-mode)
    (update-parameter self 'skeleton-target-mode))
  
  
  (method package (find-mesh-program self name)
    (or (table-ref mesh-programs name #f)
        (error "Unknown mesh program: {s}" name)))
  
  
  (method package (collect-textures self)
    (when (not textures)
      (let ((table (make-table test: equal?)))
        (iterate-assets self
          (lambda (assets)
            (iterate-entries assets
              (lambda (path)
                (when (starts-with? path "texture/")
                  (when (member? (filename-extension path) '("png" "tga") test: extension=?)
                    (let ((asset (new Asset assets path)))
                      (table-set! table (asset-path asset) asset))))))))
        (set! textures table)))
    textures)
  
  
  @find-a-better-approach-for-metadata
  (method package (collect-textures self)
    (define (add-files dir table)
      (when (exists? dir)
        (add-subdir dir table)
        (iterate-directory dir
          (lambda (subdir)
            (add-subdir subdir table))
          files?: #f
          directories?: #t)))
    
    (define (add-subdir subdir table)
      (define (load-metadata)
        (let ((file (new-file subdir ".metadata")))
          (and (exists? file)
               (let ((metadata (call-with-input-file (path-settings file) read)))
                 (assert (and (pair? metadata)
                              (pair? (cdr metadata))
                              (eq? (cadr metadata) 'textures)))
                 (cddr metadata)))))
      
      (let ((metadata (load-metadata)))
        (define (texture-metadata file)
          (and metadata
               (let ((pair (associate (get-name file) metadata test: filename=?)))
                 (and pair
                      (cdr pair)))))
        
        (iterate-directory subdir
          (lambda (file)
            (when (member? (get-extension file) '("png" "tga") test: extension=?)
              (let ((metadata (texture-metadata file)))
                (table-set! table (get-base file) (cons metadata file)))))
          files?: #t
          directories?: #f
          recursive?: #f)))
    
    (when (not textures)
      (let ((table (make-table test: equal?)))
        (iterate-assets self
          (lambda (assets)
            (when (is? assets Directory-Assets)
              (add-files (new-directory (get-directory assets) "texture") table))))
        (iterate-assets self
          (lambda (assets)
            (when (is? assets Directory-Assets)
              (add-files (new-directory (get-directory assets) "tile") table))))
        (set! textures table)))
    textures)
  
  
  (method package (reset-textures self)
    (set! textures #f))
  
  
  (method package (find-texture self name)
    (let ((textures (collect-textures self)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((is? value Asset)
               (let ((file (retrieve-file value))
                     ;; need a better approach for metadata
                     (metadata #f))
                 (let ((texture (make-file-texture file metadata: metadata)))
                   (table-set! textures name texture)
                   texture)))
              (else
               value)))))
  
  
  (method (find-texture-metadata self name (error?: error? #t))
    (let ((textures (collect-textures self)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (if error?
                   (error "Unable to find texture: {a}" name)
                 #f))
              ((pair? value)
               (car value))
              (else
               (get-metadata value))))))
  
  
  (method (find-texture-shader self name)
    (let ((metadata (find-texture-metadata self name error?: #f)))
      (and metadata
           (let ((pair (assq 'shader metadata)))
             (and pair
                  (cadr pair))))))
  
  
  (method package (find-texture-asset self name)
    (let ((textures (collect-textures self)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((pair? value)
               (cdr value))
              (else
               value)))))
  
  
  (method (reset-showcases self)
    (register-entity-classes #t)
    (when showcase
      (showcase-deactivate self showcase))
    (set! showcases (make-table test: eq?))
    (set-showcase self (and showcase (find-showcase self (showcase-name self showcase))))
    (when showcase
      (showcase-activate self showcase))
    (unspecified))
  
  
  (method (reset-showcase self name)
    (let ((active? (and showcase (eq? (get-name showcase) name))))
      (when active?
        (showcase-deactivate self showcase))
      (table-clear showcases name)
      (when active?
        (set-showcase self (find-showcase self name))
        (showcase-activate self showcase))))
  
  
  (method (set-showcase self show)
    (let ((space (current-space)))
      (set! showcase show)
      (showcase-change space)))
  
  
  (method package (no-showcase self)
    (when showcase
      (showcase-deactivate self showcase)
      (set-showcase self #f)
      (update-showcase-parameters self)
      (refresh-target self)))
  
  
  (method package (goto-showcase self show)
    (let ((show (find-showcase self show)))
      (when showcase
        (showcase-deactivate self showcase))
      (setup show)
      (set-showcase self show)
      (showcase-activate self showcase)
      (update-showcase-parameters self)
      (refresh-target self)))
  
  
  (method (update-showcase-parameters self)
    (update-parameter self 'no-showcase)
    (update-parameter self 'blocks-showcase)
    (update-parameter self 'models-showcase)
    (update-parameter self 'paintings-showcase)
    (update-parameter self 'animations-showcase)
    (update-parameter self 'shaders-showcase)
    (update-parameter self 'tiles-showcase)
    (update-parameter self 'textures-showcase)
    (update-parameter self 'skyboxes-showcase)
    (update-parameter self 'gadgets-showcase)
    (update-parameter self 'avatars-showcase)
    (update-parameter self 'meshes-showcase))
  
  
  (method package (toggle-showcase self show)
    (let ((actual (showcase-name self showcase)))
      (cond ((eq? show actual)
             (no-showcase self))
            ((and (eq? show 'paintings)
                  (= 0 (vector-length (cache-elements (find-showcase self show)))))
             (display-message self "No paintings found"))
            (else
             (goto-showcase self show)))))
  
  
  (method (showcase-activate self showcase)
    (activate showcase)
    (update-target-panel self)
    (invalidate-belt self)
    (interface-layout self)
    (reset-inventory-blocks))
  
  
  (method (showcase-deactivate self showcase)
    (deactivate showcase)
    (set! self.showcase #f)
    (update-target-panel self)
    (invalidate-belt self)
    (interface-layout self)
    (reset-inventory-blocks))
  
  
  (method package (ref-showcase self name)
    (table-ref showcases name #f))
  
  
  (method package (find-showcase self name)
    (or (table-ref showcases name #f)
        (let ((class (showcase-class self name)))
          (let ((showcase (new class name: name)))
            (table-set! showcases name showcase)
            showcase))))
  
  
  (method (showcase-class self name)
    (case name
      ((tiles) Tiles-Showcase)
      ((textures) Textures-Showcase)
      ((paintings) Paintings-Showcase)
      ((skyboxes) Skyboxes-Showcase)
      ((models) Models-Showcase)
      ((avatars) Avatars-Showcase)
      ((animations) Animations-Showcase)
      ((blocks) Blocks-Showcase)
      ((shaders) Shaders-Showcase)
      ((gadgets) Gadgets-Showcase)
      ((meshes) Meshes-Showcase)))
  
  
  (method package (showcase-name self showcase)
    (typecase showcase
      ((Tiles-Showcase) 'tiles)
      ((Textures-Showcase) 'textures)
      ((Paintings-Showcase) 'paintings)
      ((Skyboxes-Showcase) 'skyboxes)
      ((Models-Showcase) 'models)
      ((Avatars-Showcase) 'avatars)
      ((Animations-Showcase) 'animations)
      ((Blocks-Showcase) 'blocks)
      ((Shaders-Showcase) 'shaders)
      ((Gadgets-Showcase) 'gadgets)
      ((Meshes-Showcase) 'meshes)
      (else #f)))
  
  
  (method package (collect-models self (fullpath?: fullpath? #f))
    (let ((table (make-table test: equal?)))
      (let ((idle "_Idle"))
        (let ((b3d (add-extension idle "b3d"))
              (ms3d (add-extension idle "ms3d")))
          (iterate-assets self
            (lambda (assets)
              (iterate-entries assets
                (lambda (path)
                  (when (starts-with? path "model/")
                    (let ((name (filename-name path)))
                      (let ((kind (cond ((filename=? name b3d) 'b3d)
                                        ((filename=? name ms3d) 'ms3d)
                                        (else #f))))
                        (when kind
                          (let ((path (if fullpath? path (path->model self path))))
                            (unless (table-ref table path #f)
                              (let ((asset (new Asset assets path)))
                                (table-set! table path asset))))))))))))))
      (table-values table)))
  
  
  (method package (path->model self path)
    (let ((dirname (filename-dir path)))
      (remove-trailing #\/ (substring dirname (string-length "model/") (string-length dirname)))))
  
  
  (method package (add-model self path)
    (let ((me (current-me))
          (camera (current-camera)))
      (define (determine-position)
        (let ((pos (if (person-motion?) (vertex-& (get-position me) (vertex 0. (get-radius-y me) 0.)) (vertex-& (get-position camera) (vertex 0. 1. 0.)))))
          (vertex+ pos (vertex-scalar*& (get-sight camera) 2.))))
      
      (place-model self path (determine-position) class: Actor user-origin?: #t)))
  
  
  (method public (place-model self model position (scale: scale #f) (class: class #f) (animate?: animate? #t) (animation: animation #f) (savable?: savable? #t) (user-origin?: user-origin? #f))
    (let ((zone (current-zone)))
      (let ((scale (or scale (world-setting 'world.import-scale 1.))))
        (let ((scale (if (flonum? scale) (vertex scale scale scale) scale)))
          (let ((class (or class (get-entity-class (find-model self model)) Entity))
                (properties (list model: model scale: scale position: position animate?: animate? animation: (or animation "Idle"))))
            (let ((entity (apply new class properties)))
              (add-element zone entity)
              (when savable?
                (with-designer zone entity
                  (lambda (designer container)
                    (add-child designer entity container import: '(world.data) properties: properties))))
              (when user-origin?
                (set-selection self (list entity) user-origin?: #t))
              entity))))))
  
  
  (method package (retrieve-model-safe self asset)
    (catch (Asset-Not-Found-Error err)
      (catch (Model-Import-Error err)
        (catch (Model-Not-Found-Error err)
          (let ((file (retrieve-file asset)))
            (let ((ext (get-extension file)))
              (cond ((extension=? ext "ms3d")
                     (let ((ms3d (read-ms3d file)))
                       (retrieve-textures ms3d asset)))
                    ((extension=? ext "b3d")
                     (let ((b3d (read-b3d file)))
                       (retrieve-textures b3d asset))))))))))
  
  
  (method public (find-model-safe self path class)
    (catch (Asset-Not-Found-Error err
             (values (find-model self "warcraft/base/talktomeexclamationred" class: Problem-Model) (get-message err)))
      (catch (Model-Import-Error err
               (values (find-model self "warcraft/base/talktomeexclamationred" class: Problem-Model) (get-message err)))
        ;; and this is wrong wrong wrong oh so wrong to push dirt
        ;; under the rug like this. it lead to a very nasty bug to
        ;; debug: the dwarfmale was not being found on the processor
        ;; and so it was being replaced by Orb and because the client
        ;; had the correct model there was no way to know that something
        ;; was wrong but buggy collision detection behaviors that
        ;; turned out to be very difficult to debug
        (catch (Model-Not-Found-Error err
                 (values (find-model self "warcraft/base/talktomeexclamationblue" class: Problem-Model) (get-message err)))
          (values (find-model self path class: class) #f)))))
  
  
  (method (with-reentrant-models-mutex self thunk)
    (if (eq? (mutex-state models-mutex) (current-thread))
        (thunk)
      (unwind-protect
          (begin
            (mutex-lock! models-mutex)
            (thunk))
        (mutex-unlock! models-mutex))))
  
  
  (method public (reload-model self path)
    (with-reentrant-models-mutex self
      (lambda ()
        (let ((model-key (cons path #f)))
          (table-clear models model-key)))))
  
  
  (method public (loaded-model self path)
    (with-reentrant-models-mutex self
      (lambda ()
        (let ((model-key (cons path #f)))
          (table-ref models model-key #f)))))
  
  
  (method public (search-model self path) <Asset+>
    (define (search-assets)
      (continuation-capture
        (lambda (return)
          (iterate-assets self
            (lambda (assets)
              (let ((info (search-in assets)))
                (when info
                  (continuation-return return info)))))
          #f)))
    
    (define (search-in assets)
      ;; bantoo not sure about the ->string
      (let ((dirpath (string-append "model/" (->string path) "/"))
            (idle "_Idle"))
        (define (try ext)
          (let ((model-path (add-extension (string-append dirpath idle) ext)))
            (and (contains-file? assets model-path)
                 (new Asset assets dirpath))))
        
        (or (try "b3d")
            (try "ms3d"))))
    
    (search-assets))
  
  
  (method public (find-model self path (class: class #f) (error?: error? #t))
    (define (search-assets)
      (continuation-capture
        (lambda (return)
          (iterate-assets self
            (lambda (assets)
              (let ((info (search-in assets)))
                (when info
                  (continuation-return return info)))))
          (values #f #f))))
    
    (define (search-in assets)
      (let ((dirpath (string-append "model/" path "/"))
            (idle "_Idle"))
        (define (try ext import)
          (let ((model-path (add-extension (string-append dirpath idle) ext)))
            (and (contains-file? assets model-path)
                 (let ((metadata-name (filename-name path))
                       (metadata-path (string-append dirpath ".model")))
                   (let ((asset (new Asset assets model-path))
                         (metadata-asset (and (contains-file? assets metadata-path) (new Asset assets metadata-path))))
                     (let ((file (retrieve-file asset))
                           (metadata (and metadata-asset (load-model-metadata metadata-name (retrieve-file metadata-asset)))))
                       (values file (import asset metadata: metadata class: class))))))))
        
        (or (try "b3d" import-b3d)
            (try "ms3d" import-ms3d))))
    
    (with-reentrant-models-mutex self
      (lambda ()
        (if (symbol? path)
            (registered-model path)
          (let ((model-key (cons path class)))
            (or (table-ref models model-key #f)
                (bind-values (file model) (search-assets)
                  (if (not model)
                      (if (not error?)
                          #f
                        (signal (new Model-Not-Found-Error message: (format "Unable to find model: {a}" path))))
                    (set-file model file)
                    (table-set! models model-key model)
                    model))))))))
  
  
  (method package (reset-models self)
    (with-reentrant-models-mutex self
      (lambda ()
        (set! models (make-table test: equal?)))))
  
  
  (method package (collect-paintings self)
    (let ((table (make-table test: equal?)))
      (iterate-assets self
        (lambda (assets)
          (iterate-entries assets
            (lambda (path)
              (when (starts-with? path "painting/")
                (when (member? (filename-extension path) '("png" "tga" "jpg" "jpeg") test: extension=?)
                  (let ((path (path->painting self path)))
                    (unless (table-ref table path #f)
                      (let ((asset (new Asset assets path)))
                        (table-set! table path asset))))))))))
      (table-values table)))
  
  
  (method package (path->painting self path)
    (substring path (string-length "painting/") (string-length path)))
  
  
  (method (with-reentrant-paintings-mutex self thunk)
    (if (eq? (mutex-state paintings-mutex) (current-thread))
        (thunk)
      (unwind-protect
          (begin
            (mutex-lock! paintings-mutex)
            (thunk))
        (mutex-unlock! paintings-mutex))))
  
  
  (method public (reload-painting self path)
    (with-reentrant-paintings-mutex self
      (lambda ()
        (table-clear paintings path))))
  
  
  (method public (loaded-painting self path)
    (with-reentrant-paintings-mutex self
      (lambda ()
        (table-ref paintings path #f))))
  
  
  (method package (reset-paintings self)
    (with-reentrant-paintings-mutex self
      (lambda ()
        (set! paintings (make-table test: equal?)))))
  
  
  (method public (find-painting-safe self path)
    (catch (Asset-Not-Found-Error err
             (values (find-model self "warcraft/base/talktomeexclamationred" class: Problem-Model) (get-message err)))
      (catch (Image-Import-Error err
               (values (find-model self "warcraft/base/talktomeexclamationred" class: Problem-Model) (get-message err)))
        (catch (Model-Not-Found-Error err
                 (values (find-model self "warcraft/base/talktomeexclamationblue" class: Problem-Model) (get-message err)))
          (values (find-painting self path) #f)))))
  
  
  (method package (find-painting self path)
    (define (search-assets)
      (continuation-capture
        (lambda (return)
          (iterate-assets self
            (lambda (assets)
              (let ((info (search-in assets)))
                (when info
                  (continuation-return return info)))))
          (values #f #f))))
    
    (define (search-in assets)
      (let ((path (string-append "painting/" path)))
        (and (contains-file? assets path)
             (let ((asset (new Asset assets path)))
               (let ((file (retrieve-file asset))
                     ;; need a better approach for metadata
                     (metadata #f))
                 (let ((texture (make-file-texture file metadata: metadata)))
                   (bind-values (atlas texture uv) (atlas-texture texture)
                     (let ((material (new Material atlas: atlas texture: texture)))
                       (let ((model (make-painting-model material uv)))
                         (values file model))))))))))
    
    (with-reentrant-paintings-mutex self
      (lambda ()
        (or (table-ref paintings path #f)
            (bind-values (file painting) (search-assets)
              (if (not painting)
                  (signal (new Model-Not-Found-Error message: (format "Unable to find painting: {a}" path)))
                (set-file painting file)
                (table-set! paintings path painting)
                painting))))))
  
  
  (method (collect-events self)
    (let ((queue (new-queue)))
      (for-each (lambda (partition)
                  (bind (kind . assets) partition
                    (when (contains-directory? assets "event")
                      (let ((events '()))
                        (let ((events-dir (retrieve-directory assets "event")))
                          (iterate-directory events-dir
                            (lambda (path kind)
                              (unless (member? (last path) '(".DS_Store" "README") test: filename=?)
                                (set! events (cons (new Asset assets (append '("event") path)) events))))
                            full?: #f
                            files?: #t
                            directories?: #f
                            recursive?: #t))
                        (for-each (lambda (event)
                                    (enqueue queue event))
                                  (sort di<? events key: get-path))))))
                  (partition-assets self))
      (queue-list queue)))
  
  
  (method (find-event self path)
    (find (collect-events self) path test: equal? key: asset-path return: 'item))
  
  
  (method package (launch-event self path)
    (let ((script (find-event self path)))
      (when script
        ;; quick hack to always reload
        (unregister-asset script)
        (run-asset-script script))))
  
  
  (method (select/run-script self)
    (let ((interface (current-interface)))
      (let ((panel (find-type interface Script-Run)))
        (if panel
            (close panel)
          (open-frame (new Script-Run size: {Dimension 366 588} location: 'center))))))
  
  
  (method (run-last-script self)
    (if (not last-script)
        (select/run-script self)
      (run-script self last-script)))
  
  
  (method package (collect-scripts self)
    (let ((queue (new-queue)))
      (for-each (lambda (partition)
                  (bind (kind . assets) partition
                    (when (contains-directory? assets "script")
                      (let ((scripts '()))
                        (let ((scripts-dir (retrieve-directory assets "script")))
                          (iterate-directory scripts-dir
                            (lambda (path kind)
                              (unless (member? (last path) '(".DS_Store" "README") test: filename=?)
                                (set! scripts (cons (new Asset assets (append '("script") path)) scripts))))
                            full?: #f
                            files?: #t
                            directories?: #f
                            recursive?: #t))
                        (for-each (lambda (script)
                                    (enqueue queue script))
                                  (sort di<? scripts key: get-path))))))
                  (partition-assets self))
      (queue-list queue)))
  
  
  (method package (partition-scripts self scripts)
    (partition scripts key: (lambda (asset)
                              (let ((path (get-path asset)))
                                (if (> (length path) 2)
                                    (cadr path)
                                  "")))
      test: filename=?))
  
  
  (method package (find-script self path)
    (find (collect-scripts self) path test: equal? key: asset-path return: 'item))
  
  
  (method package (find-script-no self no)
    (let ((path (case no
                  ((1) (world-setting 'world.test1-script "test/test1"))
                  ((2) (world-setting 'world.test2-script "test/test2"))
                  ((3) (world-setting 'world.test3-script "test/test3"))
                  ((4) (world-setting 'world.test4-script "test/test4"))
                  ((5) (world-setting 'world.test5-script "test/test5"))
                  ((6) (world-setting 'world.test6-script "test/test6"))
                  ((7) (world-setting 'world.test7-script "test/test7"))
                  ((8) (world-setting 'world.test8-script "test/test8"))
                  ((9) (world-setting 'world.test9-script "test/test9"))
                  ((0) (world-setting 'world.test0-script "test/test0"))
                  (else (error "Unknown script no: {s}" no)))))
      (find-script self path)))
  
  
  (method package (run-script self script)
    ;; quick hack to always reload
    (unregister-asset script)
    (run-asset-script script)
    (set! last-script script))
  
  
  (method package (execute-script self path (synchronous?: synchronous? #f))
    (let ((script (find-script self path)))
      (if (not script)
          (display-message self (format "Unable to find script {a}" path))
        ;; quick hack to always reload
        (unregister-asset script)
        (run-asset-script script synchronous?: synchronous?))))
  
  
  (method (toggle-grid self)
    (set! grid? (not grid?))
    (display-on/off self "Grid" grid?)
    (update-parameter self 'grid))
  
  
  (method (toggle-grid-plane self plane)
    (if (and grid? (eq? grid-plane plane))
        (set! grid? #f)
      (set! grid? #t)
      (set! grid-plane plane))
    (update-parameter self 'grid))
  
  
  (method (decrease-grid self)
    (move-grid-by self -1))
  
  
  (method (increase-grid self)
    (move-grid-by self 1))
  
  
  (cond-expand
    (cocoa
      (method (move-grid self delta)
        (move-grid-by self (fxround/ (- delta) 5))))
    (else
     (method (move-grid self delta)
       (move-grid-by self (fxround/ (- delta) 120)))))
  
  
  (method (move-grid-by self incr)
    (let ((dist incr))
     (increase! grid-position dist)
     (display-status self (format "Grid at {a}" grid-position))))
  
  
  (method (effective-element self poly)
    (let ((zone (current-zone)))
      (or (get-element poly)
          (bind-values (id variant-id) (decode-id/variant-id (get-data1 poly))
            (let ((block (id/variant-id->block id variant-id)))
              (create-block-entity zone (get-name block) (polygon-position poly)))))))
  
  
  (method (virtual-block? self elem)
    (and (is? elem Block-Entity)
         (not (get-parent elem))))
  
  
  (method protected virtual (floor-level self)
    (and grid? (eq? grid-plane 'y) grid-position))
    
  
  ;; editor-mouse-down
  ;; editor-mouse-move
  ;; editor-mouse-up
  ;; - editor-add / action 'add
  ;;   - editor-add-at
  ;;     - editor-add-element
  ;;       - add-element-class
  ;; - editor-remove
  ;; - editor-change

  
  (method (editor-add self mode class grid? grid-plane grid-position position direction stage)
    (let ((zone (current-zone)))
      (case stage
        ((down move)
         (editor-add-at self mode class grid? grid-plane grid-position position direction))
        ((up)
         (editor-up self)))))
  
  
  (method (editor-add-at self mode class grid? grid-plane grid-position position direction)
    (let ((zone (current-zone))
          (me (current-me+)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-direction) 0.) vertex-x)
                                ((/= (vertex-y editor-direction) 0.) vertex-y)
                                ((/= (vertex-z editor-direction) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& center editor-origin)) editor-normal))))))
        
        (define (free-filter poly)
          (let ((normal (get-normal poly)))
            (vertex=? normal editor-normal)))
        
        (and editor-added?
             (case mode
               ((plane) (plane-filter))
               ((column) column-filter)
               ((free) free-filter)
               ((crazy) #f))))
      
      (define (add-at origin normal poly)
        (define (collision-quad origin normal)
          (let ((inside (vertex+ origin (vertex-scalar* normal -.01))))
            (let ((cube (unit-cube inside)))
              (ray-closest-cuboid-inner-quad inside normal cube))))
        
        (define (determine-anchor element origin normal)
          (let ((bounds (transformed-bounds element)))
            (let ((radiuses (cuboid-radiuses bounds)))
              (cond ((float-near? (vertex-y normal) 1.)
                     origin)
                    ((float-near? (vertex-y normal) -1.)
                     (vertex- origin (vertex 0. (cuboid-height bounds) 0.)))
                    (else
                     (vertex+ (vertex- origin (vertex 0. .5 0.))
                              (vertex-scalar* normal (if (/= (vertex-x normal) 0.)
                                                         (vertex-x radiuses)
                                                       (vertex-z radiuses)))))))))
        
        (define (determine-anchor/position element origin normal)
          (if (or (is? class Block-Entity)
                  (is? class Painting))
              (values origin origin)
            (let ((anchor (determine-anchor element origin normal)))
              (let ((position (anchor->position element anchor)))
                (values anchor position)))))
        
        (define (determine-polygon)
          (if (and (is? class Block-Entity) (not poly))
              (let ((closest (collision-quad origin normal)))
                (and closest
                     (bind (quad dist) closest
                       (let ((origin (get-origin quad))
                             (normal (vertex-scalar* (get-normal quad) -1.)))
                         (values (vertex+ origin (vertex-scalar*& normal .5)) normal)))))
            (values origin normal)))
        
        (let ((info (determine-polygon)))
          (when info
            (bind-values (origin normal) info
              (when (or (not editor-added?) (vertex=? normal editor-direction))
                (let ((player? (eq? class 'player)))
                  (unless player?
                    (instantiate-element-class self class))
                  (let ((element (if player? me adding)))
                    (when player?
                      (trek-change element))
                    (bind-values (anchor position) (determine-anchor/position element origin normal)
                      (let ((actual (if (is? class Block-Entity)
                                        (or (not (id? (block-at zone position) Air Water StationaryWater Lava StationaryLava))
                                            (element-near zone position))
                                      (element-near zone position))))
                        (unless actual
                          (if player?
                              (begin
                                (set-position me position)
                                (unless (person-motion?)
                                  (set-lookat me (get-lookat (current-camera))))
                                (follow-player self)
                                (unless (person-motion?)
                                  (person-motion self feedback?: #f))
                                #f)
                            (let ((added (editor-add-element self mode class poly anchor)))
                              (if editor-added?
                                  (add-target self added)
                                (set! editor-added? #t)
                                (set! editor-origin (if poly (get-center poly) origin))
                                (set! editor-normal (if poly (get-normal poly) normal))
                                (set! editor-direction normal)
                                (set! editor-floor? (not poly))
                                (set-selection self (list added))) 
                              added))))))))))))
      
      (let ((filter (determine-filter)))
        (let ((poly-closest (ray-closest-polygon position direction view-radius filter: filter ignore-non-physical?: #f ignore-players?: #t water-filter: (if (and (is? class Block-Entity) (eq? (get-model class) 'LilyPad)) only-water-filter liquid-filter)))
              (grid-closest (and (or (not editor-added?) (memq? mode '(free crazy)) (and editor-floor? (neq? mode 'column)))
                                 (bind-values (vert normal) (ray-grid-intersection self position direction grid? grid-plane grid-position)
                                   (and vert
                                        (cons vert normal))))))
          (let ((poly-distance (and poly-closest (second poly-closest)))
                (grid-distance (and grid-closest (vertex-distance position (car grid-closest)))))
            (if (and poly-closest (or (not grid-closest) (<= poly-distance grid-distance)))
                (bind (poly distance) poly-closest
                  (if (is? class Block-Entity)
                      (with-polygon-interaction (current-universe) poly
                        (lambda (poly block fore)
                          (add-at fore (get-normal poly) poly)))
                    (let ((element (get-element poly))
                          (normal (get-normal poly)))
                      (let ((target (vertex+ position (vertex-scalar* direction view-radius)))
                            (lookat (get-lookat (current-camera)))
                            (radiuses (vertex .001 .001 .001)))
                        (bind-values (new-position new-direction collisions) (collide&stop$ position target lookat radiuses max-distance: view-radius polygon-filter: filter ignore-entities?: #t ignore-players?: #t)
                          (when (not-null? collisions)
                            (let ((coll (car collisions)))
                              (let ((plane (get-plane coll)))
                                (add-at (get-origin plane) (get-normal plane) poly)))
                            (free-collisions$ collisions)))))))
              (when grid-closest
                (bind (vert . normal) grid-closest
                  (let ((normal (if (and (is? class Block-Entity)
                                         (get-flat? (cache-model class)))
                                    (vertex-negate normal)
                                  normal)))
                    (add-at vert normal #f))))))))))
  
  
  (method (editor-add-element self mode class poly anchor)
    (let ((zone (current-zone))
          (universe (current-universe))
          (camera (current-camera)))
      (define (place-element)
        (let ((pos (anchor->position adding anchor)))
          (if (is? class Painting)
              (let ((normal (get-normal poly)))
                (let ((horizontal? (or (vertex=? normal (vertex&  0. 0.  1.))
                                       (vertex=? normal (vertex&  0. 0. -1.))
                                       (vertex=? normal (vertex&  1. 0.  0.))
                                       (vertex=? normal (vertex& -1. 0.  0.)))))
                  (values (if horizontal?
                              (vertex+ anchor (vertex-scalar* normal .01))
                            (vertex+ pos (vertex 0. painting-spacer 0.)))
                          (rotate-lookat (if horizontal?
                                             (horizon-lookat (vertex-negate normal))
                                           (horizon-lookat (horizon-sight (get-sight (get-lookat camera)))))
                                          PI/2
                                          world-up))))
            (values (if (is? class Rune)
                        (vertex+ pos (vertex 0. .01 0.))
                      pos)
                    (make-standard-lookat)))))
      
      (if (is? class Block-Entity)
          (let ((pos anchor)
                (block (name->block (get-name (cache-model class)))))
            (add-block-at universe poly pos block)
            (create-block-entity zone (get-name block) pos))
        (receive (position lookat) (place-element)
          (let ((element adding)
                (name #f)
                (scale (get-scale adding))
                (color (get-color adding))
                (properties adding-properties))
            (add-element universe #f element name position lookat scale color #f #f properties)
            (bake-entity-lighting zone element)
            (update-future self)
            (set! adding #f)
            (set! adding-properties #f)
            element)))))
  
  
  (method (instantiate-element-class self class)
    (define (instantiate class/new (properties '()))
      (let ((elem (if (procedure? class/new) (class/new) (apply new class/new properties))))
        (set! adding elem)
        (set! adding-properties properties)))
    
    (define (instantiate-block block)
      (set! adding (new Block-Entity model: (get-name (cache-model block))))
      (set! adding-properties #f))
    
    (define (instantiate-entity entity)
      (let ((model (cache-model entity)))
        (let ((class (or (get-entity-class model) (class-of entity))))
          (let ((properties (registered-gadget class)))
            (if properties
                (let ((properties (properties)))
                  (instantiate (lambda ()
                                 (new class))
                               properties))
              (let ((model (or (get-model entity) (and model (get-name model))))
                    (meshes-mask (get-meshes-mask entity))
                    (animation (get-animation entity))
                    (animate? (get-animate? entity))
                    (queue (new-queue)))
                (define (enqueue-if property value (default #f))
                  (when (neq? value default)
                    (enqueue queue property)
                    (enqueue queue value)))
                
                (enqueue-if model: model)
                (enqueue-if meshes-mask: meshes-mask)
                (enqueue-if animation: animation)
                (enqueue-if animate?: animate?)
                (instantiate (lambda ()
                               (new class model: model))
                             (queue-list queue))))))))
    
    (when (not adding)
      (typecase class
        ((Block-Entity)
         (instantiate-block class))
        ((Entity)
         (instantiate-entity class))
        (else
         (case class
           ((block) (instantiate Block-Entity)))))))
  
  
  (method (editor-remove self mode position direction stage)
    (let ((zone (current-zone)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-normal) 0.) vertex-x)
                                ((/= (vertex-y editor-normal) 0.) vertex-y)
                                ((/= (vertex-z editor-normal) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& editor-origin center)) editor-normal))))))
        
        (case mode
          ((plane) (plane-filter))
          ((column) column-filter)
          ((free) #f)))
      
      (case stage
        ((down)
         (let ((closest (ray-closest-polygon position direction view-radius ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
           (when closest
             (bind (poly distance) closest
               (let ((element (effective-element self poly)))
                 (when (and element (editor-editable? self element))
                   (let ((center (get-center poly))
                         (normal (get-normal poly)))
                     (editor-remove-element self element)
                     (set! editor-origin center)
                     (set! editor-normal normal))))))))
        ((move)
         (when editor-origin
           (let ((closest (ray-closest-polygon position direction view-radius filter: (determine-filter) ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
             (when closest
               (bind (poly distance) closest
                 (let ((element (effective-element self poly)))
                   (when (and element (editor-editable? self element))
                     (editor-remove-element self element))))))))
        ((up)
         (set! editing? #f)
         (set! removing? #f)
         (set! editor-added? #f)
         (set! editor-origin #f)
         (set! editor-normal #f)
         (set! editor-direction #f)))))
  
  
  (method (editor-delete self position)
    (let ((zone (current-zone)))
      (if (zone-editable? zone)
          (let ((element (element-at zone position)))
            (when element
              (editor-remove-element self element)
              (set-modified? zone #t)))
        (warn-non-editable self))))
  
  
  (method (editor-remove-element self elem)
    (let ((universe (current-universe)))
      (if (virtual-block? self elem)
          (delete-block-at universe (get-position elem))
        ;; quick patch around entities needing more work where
        ;; this can fail where a different section is found
        ;; with a different element resulting in the dreaded
        ;; is not a descendant of the reference component error
        @wait
        (remove-element universe #f elem)
        (begin
          (let ((id (get-id elem))
                (position (get-position elem)))
            (remove-element self elem close?: #f)
            (let ((sector (element-sector (current-zone) elem)))
              (when sector
                (remove-element sector elem)))
            (let ((section-index (position->section-index position)))
              (let ((section (index-section-if universe section-index)))
                (when section
                  (let ((entity (find-entity-by-id section id)))
                    (when entity
                      (remove-element universe #f entity)))))))))
      (update-future self)))
  
  
  (method package (remove-element self elem (close?: close? #t))
    (let ((zone (current-zone)))
      (remove-element zone elem close?: close?)
      (when (memq? elem selection)
        (remove-target self elem))))
  
  
  (method (delete-target self)
    (let ((zone (current-zone))
          (history (current-history)))
      (define (delete)
        (for-each (lambda (elem)
                    (unless (is? elem Player)
                      (cond ((get-paused? history)
                             (editor-delete self (get-position elem)))
                            (else
                             ;; quicky copy-pasted from editor-delete
                             (editor-remove-element self elem)
                             (set-modified? zone #t)))))
                  selection))
      
      (let ((selection (collect-if (lambda (elem)
                                     (is-not? elem Spawn))
                                   selection)))
        (when (not-null? selection)
          (if (some? get-script selection)
              (open-message (if (= 1 (length selection))
                                "Entity has a script. Delete anyways?"
                              "Some entities have scripts. Delete anyways?")
                            caption: "Delete"
                            type: 'question
                            yes: "Yes"
                            no: "No"
                            execute: (lambda (evt)
                                       (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                             (button (get-property evt button:)))
                                         (close dialog)
                                         (case button
                                           ((yes)
                                            (delete))))))
            
            (delete))))))
  
  
  (method (editor-change self position direction stage)
    (case stage
      ((down move)
       (let ((class (editor-element-class self)))
         (when class
           (let ((to-block? (is? class Block-Entity)))
             (let ((closest (ray-closest-polygon position direction view-radius ignore-non-physical?: #f ignore-entities?: to-block? ignore-players?: #t)))
               (when closest
                 (bind (poly distance) closest
                   (let ((element (effective-element self poly)))
                     (let ((element-block? (is? element Block-Entity)))
                       (when (or (and element-block? to-block?)
                                 (and (not element-block?) (not to-block?)))
                         (change-class self element class)))))))))))
      ((up)
       (set! editing? #f)
       (set! changing? #f))))
  
  
  (method (change-class self element class)
    (let ((zone (current-zone))
          (universe (current-universe)))
      (let ((anchor (position->anchor element (get-position element))))
        (if (virtual-block? self element)
            (let ((pos (get-position element))
                  (block (name->block (get-name (cache-model class)))))
              (let ((id (get-id block)))
                (unless (if (get-generic? (id->block id))
                            (equal? (block/data-at zone pos) (cons id (get-variant-id block)))
                          (= (block-at zone pos) id))
                  (updating-sections zone
                    (lambda (add-section)
                      (delete-block-at-updating universe pos add-section)
                      (add-block-at-updating universe #f pos block add-section))))))
          (editor-remove-element self element)
          (instantiate-element-class self class)
          (editor-add-element self editor-mode class #f anchor)))))
  
  
  (method (editor-add-class self)
    (if (shift-down?)
        'player
      (editor-element-class self)))
  
  
  (method (editor-element-class self)
    (let ((interface (current-interface)))
      (if showcase
          (and (selection-addable? showcase)
               (get-selection showcase))
        (let ((slot (selected-slot (child interface 'belt))))
          (let ((id (get-id slot)))
            (and id (block-id? id)
              (new Block-Entity model: (get-name (id/durability->block id (get-durability slot))))))))))
  
  
  (method (mouse-change self h v)
    (let ((zone (current-zone))
          (camera (current-camera)))
      (if (zone-editable? zone)
          (when (can-build?)
            (bind-values (position direction) (screen->world camera h v)
              (editor-change self position direction 'down)
              (set! editing? #t)
              (set! changing? #t)))
        (warn-non-editable self))))
  
  
  (method (mouse-add self h v)
    (let ((zone (current-zone))
          (camera (current-camera))
          (history (current-history)))
      (let ((player? (shift-down?)))
        (if (or (zone-editable? zone)
                player?)
            (unless (or (not (can-build?)) (and player? (not (admin?))))
              (bind-values (position direction) (screen->world camera h v)
                (let ((class (editor-add-class self)))
                  (when class
                    (editor-add self editor-mode class grid? grid-plane grid-position position direction 'down)
                    (set! editing? #t)))))
          (warn-non-editable self)))))
  
  
  (method (mouse-remove self h v)
    (let ((zone (current-zone))
          (camera (current-camera)))
      (if (zone-editable? zone)
          (when (can-build?)
            (bind-values (position direction) (screen->world camera h v)
              (editor-remove self editor-mode position direction 'down)
              (set! editing? #t)
              (set! removing? #t)))
        (warn-non-editable self))))
  
  
  (method (editor-mouse-down self h v)
    (let ((camera (current-camera)))
      (let ((control? (control-down?))
            (alt? (alt-down?))
            (shift? (shift-down?)))
        (cond ((and control? alt? (not shift?))
               (mouse-change self h v))
              (control?
               (mouse-add self h v))
              (alt?
               (mouse-remove self h v))
              (else
               (when target-widget
                 (bind-values (position direction) (screen->world camera h v)
                   (let ((closest (ray-closest-widget position direction target-widget)))
                     (when closest
                       (bind (poly distance) closest
                         (bind (widget . part) (get-element poly)
                           (set! widget-down widget)
                           (set! widget-part part)
                           (widget-mouse-down widget-down h v))))))))))))
  
  
  (method (editor-mouse-move self h v)
    (let ((camera (current-camera))
          (history (current-history)))
      (when editing?
        (cond (removing?
               (bind-values (position direction) (screen->world camera h v)
                 (editor-remove self editor-mode position direction 'move)))
              (changing?
               (bind-values (position direction) (screen->world camera h v)
                 (editor-change self position direction 'move)))
              (else
               (let ((player? (shift-down?)))
                 (unless player?
                   (bind-values (position direction) (screen->world camera h v)
                     (let ((class (editor-add-class self)))
                       (when class
                         (editor-add self editor-mode class grid? grid-plane grid-position position direction 'move)))))))))))
  
  
  (method (editor-mouse-up self h v)
    (let ((zone (current-zone))
          (camera (current-camera))
          (history (current-history))
          (universe (current-universe)))
      (bind-values (position direction) (screen->world camera (get-h down-point) (get-v down-point))
        (if editing?
            (when (zone-editable? zone)
              (cond (removing?
                     (editor-remove self editor-mode position direction 'up))
                    (changing?
                     (editor-change self position direction 'up))
                    (else
                     (let ((class (editor-add-class self)))
                       (when class
                         (editor-add self editor-mode class grid? grid-plane grid-position position direction 'up))))))
          (let ((origin (get-position (current-camera))))
            (let ((closest (ray-closest-polygon origin direction view-radius ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #f ignore-me?: #t)))
              (if (not closest)
                  (begin
                    (reset-selection self user-origin?: #t)
                    (focus-world))
                (bind (poly distance) closest
                  (let ((element (effective-element self poly))
                        (vertex (ray/distance-closest-vertex poly origin direction distance))
                        (shift? (shift-down?)))
                    (define (select)
                      (if shift?
                          (if (member? element selection test: (~ target=? self))
                              (remove-target self element user-origin?: #t)
                            (add-target self element polygon: poly vertex: vertex user-origin?: #t))
                        (set-selection self (list element) polygon: poly vertex: vertex user-origin?: #t)
                        (focus-world)))
                   
                    (when (editor-editable? self element)
                      (if (not shift?)
                          (unless (mouse-up universe h v)
                            (if double-click?
                                (double-click universe h v)
                              (select)))
                        (select))))))))))
      (editor-up self)))
  
  
  (method (editor-up self)
    (set! editing? #f)
    (set! adding? #f)
    (set! deleting? #f)
    (set! removing? #f)
    (set! changing? #f)
    (set! editor-added? #f)
    (set! editor-origin #f)
    (set! editor-normal #f)
    (set! editor-direction #f)
    (set! editor-floor? #f)
    (set! adding #f)
    (set! adding-properties #f))
  
  
  (method (editor-editable? self element)
    (cond ((admin?) #t)
          ((not (can-build?)) #f)
          (else (is-not? element Circle-Stone))))
  
  
  (method protected virtual (warn-non-editable self)
    (let ((zone (current-zone)))
      (unless (get-editable-warned? zone)
        (set-editable-warned? zone #t)
        (open-message "Zone is not editable"
                      caption: "Edition"
                      type: 'message
                      execute: (lambda (evt)
                                 (let ((dialog (find-ascendant (get-sender evt) World-Dialog)))
                                   (close dialog)))))))
  
  
  ;;;
  ;;;; Change
  ;;;
  
  
  ;; quick hack
  (method package (class->class-name self class)
    (category-name class))
  
  
  ;; quick hack
  (method package (class-name->class self class-name)
    (case class-name
      ((Sphere) Sphere)
      ((Spawner) Spawner)
      ((Wolf) Wolf)
      ((Spider) Spider)
      ((Jumper) Jumper)
      ((Creature) Creature)
      ((Missile) Missile)
      ((Actor) Actor)
      ((Gravity) Gravity)
      ((Painting) Painting)
      ((Rune) Rune)
      ((Circle-Stone) Circle-Stone)
      (else Entity)))
  
  
  ;;;
  ;;;; Grid
  ;;;
  
  
  (method package (ray-grid-intersection self position direction grid? grid-plane grid-position)
    (let ((zone (current-zone)))
      (define (perspective->world normal distance)
        (let ((norm-direction-dot-product (dot-product normal direction)))
          (and (not (and (= norm-direction-dot-product 0.)
                         (case grid-plane
                           ((x) (= (vertex-x position) grid-position))
                           ((y) (= (vertex-y position) grid-position))
                           ((z) (= (vertex-z position) grid-position)))))
               (let ((intersect (/ (- distance (dot-product normal position))
                                   norm-direction-dot-product)))
                 (and (> intersect 0.)
                      (let ((point (vertex+ position (vertex-scalar*& direction intersect))))
                        (if (> norm-direction-dot-product 0.)
                            (values point grid-position (vertex-negate normal))
                          (values point grid-position normal))))))))
      
      (if (not grid?)
          (values #f #f)
        (case grid-plane
          ((x) (let ((info (perspective->world (vertex 1. 0. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         pos
                                         (vertex-y vert)
                                         (vertex-z vert)))
                             normal)))))
          ((y) (let ((info (perspective->world (vertex 0. 1. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         pos
                                         (vertex-z vert)))
                             normal)))))
          ((z) (let ((info (perspective->world (vertex 0. 0. 1.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         (vertex-y vert)
                                         pos))
                             normal)))))))))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (method package (first-target self)
    (and (not-null? selection) (first selection)))
  
  
  (method package (set-selection self sel (polygon: polygon #f) (vertex: vertex #f) (user-origin?: user-origin? #f))
    (when (window?)
      (let ((interface (current-interface))
            (zone (current-zone)))
        (when (not-null? selection)
          (deactivate-target (first selection)))
        (set! selection sel)
        (set! selection-sections (map (lambda (elem) (element-section zone elem)) sel))
        (set! target-polygon polygon)
        (set! target-vertex vertex)
        (target-updated selection polygon vertex)
        (target-update zone selection polygon vertex)
        (invalidate-view interface)
        ;; quick try see below
        (when (null? sel)
          (reset-edited-entity))
        ;; quick hack to not have the script panel close
        ;; but this hack will stop editing script of a block
        (let ((only-block? (and (= 1 (length sel)) (is? (car sel) Block-Entity))))
          @w(unless only-block?
            (if (null? sel)
                (restore-edited-entity)
              (reset-edited-entity)))
          (update-color-panel self)
          (update-target-panel self)
          @w(unless only-block?
            (update-script-panel)))
        (when (not-null? selection)
          (activate-target (first selection)))
        (refresh-interface self condition: '(info target)))))
  
  
  (method package (reset-selection self (user-origin?: user-origin? #f))
    (set-selection self '() user-origin?: user-origin?))
  
  
  (method package (shutdown-selection self)
    (set! selection '())
    (set! selection-sections '())
    (set! target-polygon #f)
    (set! target-vertex #f)
    (set! target-mode #f)
    (set! target-widget #f))
  
  
  (method (selection=? self sx sy)
    (and (= (length sx) (length sy))
         (every? (~ target=? self)
                 sx
                 sy)))
  
  
  (method (target=? self x y)
    (if (and (is? x Block-Entity)
             (is? y Block-Entity))
        (vertex=? (get-position x) (get-position y))
      (equal? x y)))
  
  
  (method (add-target self elem (polygon: polygon #f) (vertex: vertex #f) (user-origin?: user-origin? #f))
    (set-selection self (append! selection (list elem)) polygon: polygon vertex: vertex user-origin?: user-origin?))
  
  
  (method (remove-target self elem (user-origin?: user-origin? #f))
    (let ((new-selection (remove elem selection test: (~ target=? self))))
      (set-selection self new-selection user-origin?: user-origin?)))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method package (x-rays-mode? self)
    (and x-rays? (not x-rays-category)))
  
  
  (method (toggle-x-rays self)
    (cond ((x-rays-mode? self)
           (set! x-rays? #f)
           (set! x-rays-category #f))
          (else
           (set! x-rays? #t)
           (set! x-rays-category #f)))
    (update-parameter self 'x-rays)
    (display-on/off self "X-rays" x-rays?))
  
  
  (method package (redstone-x-rays-mode? self)
    (and x-rays? (eq? x-rays-category 'redstone)))
  
  
  (method (toggle-redstone-x-rays self)
    (cond ((redstone-x-rays-mode? self)
           (set! x-rays? #f)
           (set! x-rays-category #f))
          (else
           (set! x-rays? #t)
           (set! x-rays-category 'redstone)))
    (update-parameter self 'redstone-x-rays)
    (display-on/off self "Redstone X-rays" x-rays?))
  
  
  (method (toggle-draw-blocks self)
    (set! draw-blocks? (not draw-blocks?))
    (update-parameter self 'blocks)
    (display-on/off self "Draw blocks" draw-blocks?))
  
  
  (method (toggle-draw-models self)
    (set! draw-entities? (not draw-entities?))
    ;(update-parameter 'models)
    (display-on/off self "Draw models" draw-entities?))
  
  
  ;;;
  ;;;; Changes
  ;;;
  
  
  (method package (changes-update self changes)
    (let ((models-post (models-update self changes))
          (paintings-post (paintings-update self changes)))
      (lambda ()
        (models-post)
        (paintings-post))))
  
  
  (method (models-update self changes)
    (let ((zone (current-zone)))
      (let ((models-reload (make-table test: equal?))
            (models-showcase? #f)
            (rebake '())
            (showcase-rebake '())
            (showcase (ref-showcase self 'models)))
        (define (update-model what path)
          (let ((name (filename-name path))
                (path (path->model self path)))
            (when (or (filename=? name "_Idle.b3d")
                      (filename=? name "_Idle.ms3d"))
              (table-set! models-reload path #t)
              (when (or (eq? what 'added)
                        (eq? what 'removed))
                (set! models-showcase? #t)))
            (when (loaded-model self path)
              (table-set! models-reload path #t))))
        
        (define (maybe-reload-model entity path)
          (cond ((equal? (get-model entity) path)
                 (reload-model entity)
                 #t)
                (else
                 #f)))
        
        (for-each (lambda (change)
                    (bind (what path) change
                      (when (starts-with? path "model/")
                        (update-model what path))))
                  changes)
        (when (> (table-length models-reload) 0)
          (let ((entities (get-entities zone))
                (showcase-entities (and showcase (cache-elements showcase))))
            (iterate-table models-reload
              (lambda (path ignore)
                (reload-model self path)
                (for-each (lambda (entity)
                            (when (maybe-reload-model entity path)
                              (set! rebake (cons entity rebake))))
                          entities)
                (when showcase-entities
                  (loop (for entity in-vector showcase-entities)
                        (when (maybe-reload-model entity path)
                          (set! showcase-rebake (cons entity showcase-rebake))))))))
          (when (and models-showcase? showcase)
            (reset-showcase self 'models)))
        (lambda ()
          (for-each (lambda (entity)
                      (bake-entity-lighting zone entity))
                    rebake)
          (for-each (lambda (entity)
                      (rebake-element showcase entity))
                    showcase-rebake)
          (when (not-null? rebake)
            (refresh-target self))))))
  
  
  (method (paintings-update self changes)
    (let ((zone (current-zone)))
      (let ((paintings-reload (make-table test: equal?))
            (paintings-showcase? #f)
            (rebake '())
            (showcase-rebake '())
            (showcase (ref-showcase self 'paintings)))
        (define (update-painting what path)
          (let ((name (filename-name path))
                (path (path->painting self path)))
            (table-set! paintings-reload path #t)
            (when (or (eq? what 'added)
                      (eq? what 'removed))
              (set! paintings-showcase? #t))
            (when (loaded-painting self path)
              (table-set! paintings-reload path #t))))
        
        (define (maybe-reload-painting entity path)
          (cond ((equal? (get-model entity) path)
                 (reload-model entity)
                 #t)
                (else
                 #f)))
        
        (for-each (lambda (change)
                    (bind (what path) change
                      (when (starts-with? path "painting/")
                        (update-painting what path))))
                  changes)
        (when (> (table-length paintings-reload) 0)
          (let ((entities (get-entities zone))
                (showcase-entities (and showcase (cache-elements showcase))))
            (iterate-table paintings-reload
              (lambda (path ignore)
                (reload-painting self path)
                (for-each (lambda (entity)
                            (when (maybe-reload-painting entity path)
                              (set! rebake (cons entity rebake))))
                          entities)
                (when showcase-entities
                  (loop (for entity in-vector showcase-entities)
                        (when (maybe-reload-painting entity path)
                          (set! showcase-rebake (cons entity showcase-rebake))))))))
          (when (and paintings-showcase? showcase)
            (reset-showcase self 'paintings)))
        (lambda ()
          (for-each (lambda (entity)
                      (bake-entity-lighting zone entity))
                    rebake)
          (for-each (lambda (entity)
                      (rebake-element showcase entity))
                    showcase-rebake)
          (when (not-null? rebake)
            (refresh-target self))))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (slot evaluate-hooks <object> initialize '() getter generate)
  
  
  (method (register-evaluate-hook self proc)
    (set! evaluate-hooks (cons proc evaluate-hooks)))
  
  
  (method (unregister-evaluate-hook self proc)
    (set! evaluate-hooks (remove! proc evaluate-hooks)))
  
  
  (method package (evaluate-world-hook self forms syntax str container line col)
    (let ((interface (current-interface))
          (zone (current-zone)))
      (evaluate-zone-hook zone forms syntax str container line col)
      (when (or (search container "shaders")
                (search str "baked-light"))
        (reload-programs self str)
        (target-update zone selection target-polygon target-vertex))
      @test
      (when (search str "read-b3d")
        (let ((entities (get-entities zone))
              (reloaded '()))
          (for-each (lambda (entity)
                      (let ((model (cached-model entity)))
                        (when model
                          (let ((file (get-file model)))
                            (when (and file (extension=? (get-extension file) "b3d"))
                              (reload-model entity)
                              (set! reloaded (cons model reloaded)))))))
                    entities)
          (let ((count (length reloaded)))
            (when (> count 0)
              (display-status self (if (= count 1)
                                       (format "Model {a} reloaded" (car reloaded))
                                     (format "{a} models reloaded" count)))))))
      @test
      (when (search container "procedural")
        (increase-revision (get-generator zone))
        (reset-selection))
      (when evaluate-future?
        (update-future self))
      (for-each (lambda (proc)
                  (proc forms syntax str container line col))
                evaluate-hooks)
      @test
      (update-world-options (current-application))
      @test
      (install-skins (current-application))
      @test
      (install-bindings (current-application))
      (invalidate-view interface)
      (when (developer?)
        (set-uptodate? (child interface 'evolution) #f)
        (set-uptodate? (child interface 'history) #f))
      (render-scene (current-window))))
  
  
  (method (reload-programs self str)
    (cond ((or (search str "block")
               (search str "model")
               (search str "baked-light")
               (search str "mesh-header-fs")
               (search str "mesh-main-fs")
               (search str "build-mesh-fs"))
           (reload-block-programs self)
           (reload-model-programs self))
          ((search str "horizon")
           (reload-horizon-programs self))
          ((search str "frame")
           (reload-frame-programs self))
          (else
           (reload-transformation-programs self)
           (reload-other-programs self))))
  
  
  (method (reload-block-programs self)
    (build-mesh-shaders)
    (build-block-shaders)
    (relink-program self 'block)
    (relink-program self 'wet-block))
  
  
  (method (reload-model-programs self)
    (build-mesh-shaders)
    (build-model-shaders)
    (relink-program self 'model))
  
  
  (method (reload-frame-programs self)
    (build-frame-shaders)
    (relink-program self 'wireframe)
    (relink-program self 'squareframe)
    (relink-program self 'playerframe)
    (relink-program self 'floorframe))
  
  
  (method (reload-transformation-programs self)
    (build-transformation-shaders)
    (relink-program self 'radial-blur)
    (relink-program self 'motion-blur)
    (relink-program self 'water)
    (relink-program self 'julia)
    (relink-program self 'sierpinski)
    (relink-program self 'multitexture)
    (relink-program self 'kaleidoscope)
    (relink-program self 'tunnel)
    (relink-program self 'square-tunnel)
    (relink-program self 'fly)
    (relink-program self 'pulse))
  
  
  (method (reload-horizon-programs self)
    (build-horizon-shaders)
    (relink-horizon-program))
  
  
  (method (reload-other-programs self)
    (build-occlusion-shaders)
    (relink-program self 'occlusion))
  
  
  (method (relink-program self name)
    (let ((program (find-mesh-program self name)))
      (relink program)))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method (effective-playable? self)
    (let ((zone (current-zone)))
      (or (participant?)
          (login? zone))))
  
  
  (method package virtual (mouse-down self h v (double? #f))
    (when (and (effective-playable? self)
               (not camera-bound?)
               (not (get-autotrack-camera?)))
      (set! down? #t)
      (set! down-point (new Point h v))
      (set! double-click? double?)
      (track-down)
      (if (and showcase (in-showcase? showcase v))
          (begin
            (set! showcase-down? #t)
            (showcase-mouse-down showcase h v))
        (when (participant?)
          (editor-mouse-down self h v)))))
  
  
  (method package virtual (mouse-moved self x y)
    (let ((window (current-window))
          (space (current-space))
          (history (current-history))
          (me (current-me)))
      (mouse-moved space x y)
      (when (effective-playable? self)
        (let ((h (fxround x))
              (v (fxround y)))
          (cond (showcase-down?
                 (showcase-mouse-drag showcase h v))
                ((get-cursor-captured? window)
                 (track-move self x y)
                 (unless (or (is-tracking? self) (get-paused? history))
                   (follow-player self)))
                (widget-down
                 (widget-mouse-move widget-down h v))
                (editing?
                 (editor-mouse-move self h v))
                ((effective-autotrack-camera? self)
                 (track-start x y)
                 (capture-cursor window)
                 (track-move self x y))
                ((or (and down? (not (near? (new Point h v) down-point drag-tolerance))) (get-autotrack-camera?))
                 (track-start x y)
                 (capture-cursor window)))))))
  
  
  (method package virtual (mouse-track self dx dy)
    (let ((space (current-space))
          (me (current-controlled+ self))
          (motion (current-motion)))
      (unless (mouse-track space dx dy)
        (cond ((and (is-tracking? self) (person-motion?))
               (track-actor motion me dx dy realign?)
               (boost-player self)
               (set! realign? #f))
              (else
               (track-camera motion dx dy))))))
  
  
  (method package virtual (mouse-up self h v)
    (let ((window (current-window)))
      (if (not (effective-playable? self))
          (focus-world)
        (if mouse-run?
            (begin
              (set! tracking? #t)
              (set! mouse-run? #f))
          (cond (showcase-down?
                 (showcase-mouse-up showcase h v)
                 (set! showcase-down? #f))
                ((and (get-cursor-captured? window) (not (get-autotrack-camera?)))
                 (release-cursor window)
                 (follow-player self))
                (widget-down
                 (widget-mouse-up widget-down h v)
                 (set! widget-down #f)
                 (set! widget-part #f))
                (else
                 (when (and down? (not inhibit-up?))
                   (if (can-build?)
                       (when (participant?)
                         (editor-mouse-up self h v))
                     (mouse-up (current-space) h v)
                     (focus-world)))))
          (set! down? #f)
          (set! down-point #f)))
      (set! inhibit-up? #f)))
  
  
  (method package virtual (double-click self h v)
    (let ((me (current-me)))
      (when (effective-playable? self)
        (cond ((and showcase (in-showcase? showcase v))
               (showcase-double-click showcase h v))
              (else
               (mouse-down self h v #t))))))
  
  
  (method package virtual (right-mouse-down self h v)
    (when (and (participant?)
               (not camera-bound?)
               (not (get-autotrack-camera?)))
      (set! down? #t)
      (set! down-point (new Point h v))
      (set! tracking? #t)
      (set! realign? #t)
      (track-down)))
  
  
  (method package virtual (right-mouse-up self h v)
    (let ((window (current-window))
          (me (current-me))
          (motion (current-motion))
          (universe (current-universe)))
      (when (participant?)
        (if mouse-run?
            (begin
              (set! tracking? #f)
              (set! mouse-run? #f))
          (reset-roll motion me)
          (unless (or inhibit-up? (get-cursor-captured? window))
            (if (or (not (can-build?))
                    (let ((elem (interaction-element universe h v)))
                      (or (and (is? elem Block-Entity)
                               (get-right-mouse (name->block (get-name (cache-model elem)))))
                          (is? elem Actor))))
                (right-mouse-up universe h v)
              (mouse-add self h v)
              (editor-up self)))
          (set! down? #f)
          (set! down-point #f)
          (set! tracking? #f)
          (set! mouse-run? #f)
          (when (and (get-cursor-captured? window) (not (get-autotrack-camera?)))
            (release-cursor window)))
        (set! inhibit-up? #f))))
  
  
  (method package (mouse-wheel self h v delta)
    (let ((interface (current-interface)))
      (when (participant?)
        (let ((d (if (shift-down?) (get-h delta) (get-v delta))))
          (cond ((and grid? (alt-down?))
                 (move-grid self d))
                ((xor (shift-down?) (world-setting 'world.wheel-zoom? #t))
                 (cond ((> d 0)
                        (zoom-in self))
                       ((< d 0)
                        (zoom-out self))))
                (showcase
                 (showcase-wheel showcase (> d 0)))
                (else
                 (cycle-selection (child interface 'belt) d)))))))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  ;; left+right mouse run
  (method (process-mouse-run self)
    (when (and application-active?
               world-mouse-down?
               world-right-mouse-down?
               (null? (modifiers-keys)))
      (unless mouse-run?
        (set! realign? #t)
        (set! mouse-run? #t)
        (mouse-track self 0. 0.))
      (move-forward self)))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method (process-keys self)
    (site process-keys
      (when application-active?
        (when (participant?)
          (let ((modifiers (modifiers-mask)))
            (process-movement self modifiers)
            (let ((modifiers (modifiers->keys modifiers)))
              (iterate-keys
                (lambda (shortcut proc)
                  (when (and (equal? (get-modifiers shortcut) modifiers)
                             (let ((key (get-key shortcut)))
                               (or (eqv? key ongoing-key)
                                   (key-down? (if (char? key)
                                                  key
                                                (symbolic-key->code key))))))
                    (proc self))))))))))
  
  
  (method package virtual (process-shortcut self shortcut)
    (if (or (shortcut=? shortcut {Shortcut Escape})
            (and alternate-escape (shortcut=? shortcut alternate-escape)))
        (if escape-hook
            (escape-hook)
          (main-menu self))
      #f))
  
  
  (method package virtual (key-down self c)
    )
  
  
  (method package virtual (key-press self key)
    )
  
  
  (method package virtual (key-up self c)
    )
  
  
  ;;;
  ;;;; Sound
  ;;;
  
  
  (method (toggle-sound self)
    (set-sounds? (not sounds?))
    (update-parameter self 'sound)
    (display-on/off self "Sound" sounds?))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method package (unimplemented-connected self)
    (unless (world-setting 'world.allow-connected? #f)
      (display-cancel self "Unimplemented when connected")))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method (tile-server/clients self)
    (tile (current-tier)))
  
  
  (method (restore-server/clients self)
    (restore (current-tier)))
  
  
  ;;;
  ;;;; Live
  ;;;
  
  
  (method package (live-gaia/world self)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error self "Not connected to a remote debugger")
        (let ((debuggee (load-object (get-local-register 'debugging) 'world.debuggee 'world-debuggee))
              (debugger (load-object (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (live-gaia/world debugger debuggee)))))
  
  
  (method package (design-gaia/world self)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error self "Not connected to a remote debugger")
        (let ((debuggee (load-object (get-local-register 'debugging) 'world.debuggee 'world-debuggee))
              (debugger (load-object (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (design-gaia/world debugger debuggee)))))
  
  
  (method package (restore-gaia/world self)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error self "Not connected to a remote debugger")
        (let ((debuggee (load-object (get-local-register 'debugging) 'world.debuggee 'world-debuggee))
              (debugger (load-object (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (restore-gaia/world debugger debuggee)))))
  
  
  ;;;
  ;;;; Zoom
  ;;;
  
  
  (method (zoom-horizontally self)
    (set-setting options-settings 'world.script-horizontal? (not (world-setting 'world.script-horizontal? #f)))
    (save-content options-settings)
    (update-background (get-manager (child (current-interface) 'script)))
    (interface-layout self))
  
  
  (method (zoom-vertically self)
    (set-setting options-settings 'world.script-vertical? (not (world-setting 'world.script-vertical? #f)))
    (save-content options-settings)
    (update-background (get-manager (child (current-interface) 'script)))
    (interface-layout self))
  
  
  (method (zoom-fullscreen self)
    (set-setting options-settings 'world.script-fullscreen? (not (world-setting 'world.script-fullscreen? #f)))
    (save-content options-settings)
    (update-background (get-manager (child (current-interface) 'script)))
    (interface-layout self))
  
  
  (method (zoom-in-script self)
    (script-zoom-in))
  
  
  (method (zoom-out-script self)
    (script-zoom-out))
  
  
  (method (unzoom-script self)
    (script-unzoom))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (toggle-interface self)
    (set! interface? (not interface?))
    (focus-world)
    (update-parameter self 'interface))
  
  
  (method package (toggle-occlusion self (force? #f))
    (set-wireframe? #f)
    (let ((occlusion? (or (not (get-occlusion?)) force?)))
      (set-occlusion? occlusion?)
      (set-override-renderer (and occlusion? occlusion-renderer))
      (set-block-program self (find-mesh-program self (if occlusion? 'occlusion 'block)))
      (update-parameter self 'occlusion)
      (update-parameter self 'wireframe)))
  
  
  (method package (toggle-wireframe self (force? #f))
    (set-occlusion? #f)
    (let ((wireframe? (or (not (get-wireframe?)) force?)))
      (set-wireframe? wireframe?)
      (set-override-renderer (and wireframe? wireframe-renderer))
      (set-block-program self (find-mesh-program self (if wireframe? 'wireframe 'block)))
      (update-parameter self 'occlusion)
      (update-parameter self 'wireframe)))
  
  
  (method (toggle-polygon-mode self)
    (set! polygon-mode (ecase polygon-mode
                         ((GL_POINT) GL_LINE)
                         ((GL_LINE) GL_FILL)
                         ((GL_FILL) GL_POINT)))
    (glPolygonMode GL_FRONT_AND_BACK polygon-mode))
  
  
  (method (toggle-fog self)
    (set-fog? (not fog?))
    (reload-block-programs self)
    (update-parameter self 'fog)
    (display-on/off self "Fog" fog?))
  
  
  (method package (toggle-windowed-mode self)
    (let ((window (current-window)))
      (toggle-windowed-mode window)))
  
  
  (method (toggle-multisampling self)
    (change-multisampling self (not multisampling?))
    (display-on/off self "Multisampling" multisampling?))
  
  
  (method package (change-multisampling self value)
    (set-multisampling? value)
    (update-parameter self 'multisampling))
  
  
  (method package (person-motion self (yaw: yaw #f) (pitch: pitch #f) (eye-center?: eye-center? #t) (force?: force? #f) (feedback?: feedback? #t))
    (unless (and (person-motion?) (eq? (current-me) (get-target-me (current-motion))) (not force?))
      (set! eye-motion (make-person-motion self eye yaw: yaw pitch: pitch))
      (set-current-motion eye-motion)
      (preload-sectors (current-zone))
      (when eye-center?
        (eye-center-player eye-motion))
      (update-camera-parameters self)
      (when feedback?
        (display-message self "First person"))))
  
  
  (method (orbit-motion self (feedback?: feedback? #t))
    (unless (orbit-motion?)
      (set! eye-motion (make-orbit-motion self eye #f))
      (set-current-motion eye-motion)
      (preload-sectors (current-zone))
      (orbit-behind eye-motion (motion-target eye-motion))
      (update-camera-parameters self)
      (when feedback?
        (display-message self "Orbit around"))))
  
  
  (method package (free-motion self (feedback?: feedback? #t))
    (unless (free-motion?)
      (set! eye-motion (make-free-motion self eye))
      (set-current-motion eye-motion)
      (preload-sectors (current-zone))
      (update-camera-parameters self)
      (when feedback?
        (display-message self "Free camera"))))
  
  
  (method package (vista-motion self target)
    (unless (and (vista-motion?)
                 (index=? (motion-sector-index (current-motion)) (position-sector-index target)))
      (set! eye-motion (make-vista-motion self eye target))
      (set-current-motion eye-motion)
      (preload-sectors (current-zone))
      (update-camera-parameters self)))
  
  
  (method (update-camera-parameters self)
    (update-parameter self 'person-motion)
    (update-parameter self 'orbit-motion)
    (update-parameter self 'free-motion))
  
  
  (method package (effective-draw-gadgets? self)
    (or draw-gadgets? (is? showcase Gadgets-Showcase)))
  
  
  (method package (toggle-draw-gadgets self)
    (set! draw-gadgets? (not draw-gadgets?))
    (update-gadgets self)
    (update-parameter self 'gadgets)
    (display-on/off self "Draw gadgets" draw-gadgets?))
  
  
  (method package (toggle-draw-normals self)
    (set! draw-normals? (not draw-normals?))
    (update-parameter self 'normals)
    (display-on/off self "Draw normals" draw-normals?))
  
  
  (method package (toggle-draw-me self)
    (set! draw-me? (not draw-me?))
    (update-parameter self 'draw-me)
    (display-on/off self "Draw me" draw-me?))
  
  
  (method package (update-gadgets self (draw-gadgets? (effective-draw-gadgets? self)))
    (when (not draw-gadgets?)
      (for-each (lambda (elem)
                  (when (is? elem Gadget)
                    (remove-target self elem)))
                selection)))
  
  
  (method package (toggle-axes self)
    (set! axes? (not axes?))
    (update-parameter self 'axes)
    (display-on/off self "Axes" axes?))
  
  
  (method package (toggle-axes-graduation self)
    (set! axes-graduation? (not axes-graduation?))
    (display-on/off self "Axes graduation" axes-graduation?))
  
  
  (method package (toggle-info self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'info)))
        (set-visible? panel (not (get-visible? panel)))
        (when (get-visible? panel)
          (bring-to-front panel)
          (set! interface? #t)))
      (update-parameter self 'info)))
  
  
  (method package (toggle-profiler self)
    (let ((interface (current-interface))
          (history (current-history)))
      (let ((panel (child interface 'profiler)))
        (let ((visible? (not (get-visible? panel))))
          (unless (get-paused? history)
            (when visible?
              (reset-profiles)
              (reset-trackings)
              (reset-chronology)))
          (set-visible? panel visible?)
          (set-profiler-active? visible?)
          (when visible?
            (bring-to-front panel)
            (set! interface? #t))))
      (update-parameter self 'profiler)))
  
  
  (method (toggle-profiler-all self)
    (toggle-profiler-all?))
  
  
  (method (reset-profiler self)
    (reset-chronology))
  
  
  (method package (toggle-evolution self)
    (when (developer?)
      (if evolution-visible?
          (hide-evolution self)
        (show-evolution self))))
  
  
  (method (show-evolution self)
    (when (developer?)
      (set! evolution-visible? #t)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'evolution)))
          (bring-to-front panel)
          (refresh-evolution)
          (set-visible? panel #t))
        (update-parameter self 'evolution))))
  
  
  (method (hide-evolution self)
    (when (developer?)
      (set! evolution-visible? #f)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'evolution)))
          (set-visible? panel #f))
        (update-parameter self 'evolution))))
  
  
  (method (toggle-history self)
    (when (developer?)
      (if history-visible?
          (hide-history self)
        (show-history self))))
  
  
  (method (show-history self)
    (when (developer?)
      (set! history-visible? #t)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'history)))
          (bring-to-front panel)
          (refresh-history)
          (set-visible? panel #t))
        (update-parameter self 'history))))
  
  
  (method (hide-history self)
    (when (developer?)
      (set! history-visible? #f)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'history)))
          (set-visible? panel #f))
        (update-parameter self 'history))))
  
  
  (method (all-chronology self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'history)))
        (when (get-visible? panel)
          (set-all-chronology? (not all-chronology?))
          (redraw panel)))))
  
  
  (method (update-color-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'color)))
        (set-visible? panel (some? (lambda (element)
                                     (is? element Light))
                                   selection)))))
  
  
  (method (toggle-target self)
    (set! interface-target? (not interface-target?))
    (update-target-panel self)
    (update-parameter self 'target))
  
  
  (method package (update-target-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'target)))
        (if (not interface-target?)
            (set-visible? panel #f)
          (set-visible? panel (or (not-null? selection)
                                  (and showcase (get-selection showcase))))
          (refresh-target self)))))
  
  
  (method (refresh-target self)
    (let ((interface (current-interface)))
      (let ((target (child interface 'target)))
        (when (get-visible? target)
          (view-target target)))))
  
  
  (method (compass-panel self)
    (if compass-visible?
        (hide-compass self)
      (show-compass self)))
  
  
  (method package (show-compass self)
    (set! compass-visible? #t)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'compass)))
        (set-uptodate? panel #f)
        (set-visible? panel #t))))
  
  
  (method package (hide-compass self)
    (set! compass-visible? #f)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'compass)))
        (set-visible? panel #f))))
  
  
  (method (map-panel self)
    (let ((zone (current-zone)))
      (when (is? (get-generator zone) World-Generator)
        (set! map-visible? (not map-visible?))
        (let ((interface (current-interface)))
          (let ((panel (child interface 'map)))
            (set-visible? panel map-visible?))))))
  
  
  (method (combat-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'combat)))
        (set-visible? panel (not (get-visible? panel))))))
  
  
  (method (character-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'character)))
        (if (get-visible? panel)
            (hide-character self)
          (show-character self)))))
  
  
  (method package (show-character self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'character)))
        (unless (get-visible? panel)
          (set-visible? panel #t)
          (view-inventory panel)
          (set! interface? #t)
          (update-parameter self 'character-panel)))))
  
  
  (method package (hide-character self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'character)))
        (when (get-visible? panel)
          (set-visible? panel #f)
          (save-inventory)
          (update-parameter self 'character-panel)))))
  
  
  (method package (crafting-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'crafting)))
        (if (get-visible? panel)
            (hide-crafting self)
          (show-crafting self)))))
  
  
  (method (show-crafting self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'crafting)))
        (unless (get-visible? panel)
          (set-visible? panel #t)
          @wait-hide-should-put-it-back-the-way-it-was
          (show-belt self)
          (show-bag self blocks?: #f)
          (hide-chest self)
          (set! interface? #t)))))
  
  
  (method (hide-crafting self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'crafting)))
        (when (get-visible? panel)
          (set-visible? panel #f)
          (hide-bag self)))))
  
  
  (method (bag-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'bag)))
        (if (get-visible? panel)
            (hide-bag self)
          (show-bag self)))))
  
  
  (method package (show-bag self (blocks?: blocks? #t))
    (let ((interface (current-interface)))
      (let ((panel (child interface 'bag)))
        (unless (get-visible? panel)
          (set-visible? panel #t)
          (view-inventory panel)
          (set! interface? #t)
          (update-parameter self 'bag-panel)
          (when (and blocks? (can-build?))
            (goto-showcase self 'blocks))))))
  
  
  (method package (hide-bag self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'bag)))
        (when (get-visible? panel)
          (save-inventory)
          (set-visible? panel #f)
          (hide-crafting self)
          (update-parameter self 'bag-panel)
          (no-showcase self)))))
  
  
  (method (belt-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'belt)))
        (if (get-visible? panel)
            (hide-belt self)
          (show-belt self)))))
  
  
  (method (show-belt self)
    (let ((panel (child (current-interface) 'belt)))
      (set-visible? panel #t)))
  
  
  (method (hide-belt self)
    (let ((panel (child (current-interface) 'belt)))
      (set-visible? panel #f)))
  
  
  (method (who-panel self)
    (let ((interface (current-interface)))
      (let ((panel (find-type interface Who-Panel)))
        (if panel
            (close panel)
          (open-frame (new Who-Panel size: {Dimension 200 400} location: 'center))))))
  
  
  (method (chat-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'chat)))
        (if (get-visible? panel)
            (set-visible? panel #f)
          (set-visible? panel #t)))))
  
  
  ;; quicky
  (hub chat-message)
  (method (command-message self)
    (let ((together (together:current-together)))
      ;; quicky
      (chat-message together)))
  
  
  ;; quicky
  (hub chat-slash)
  (method package (command-slash self)
    (let ((together (together:current-together)))
      ;; quicky
      (chat-slash together)))
  
  
  ;; quicky
  (hub chat-previous)
  (method package (command-previous self)
    (let ((together (together:current-together)))
      ;; quicky
      (chat-previous together)))
  
  
  ;; quicky
  (hub show-chat)
  (method package (show-chat-message self sender kind message)
    (let ((together (together:current-together)))
      (show-chat together))
    (let ((interface (current-interface)))
      (let ((panel (child interface 'chat)))
        (show-message panel sender kind message))))
  
  
  (method package (chat-show self message)
    (show-chat-message self #f 'show message))
  
  
  (method package (chat-problem self message)
    (show-chat-message self #f 'problem message))
  
  
  (method package (hide-command self)
    (let ((interface (current-interface)))
      (set-visible? (child interface 'command) #f)
      (set-visible? (child interface 'command-to) #f)
      (focus-world)
      (interface-layout self)))
  
  
  (method (invalidate-belt self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'belt)))
        (when (get-visible? panel)
          (invalidate-view panel)))))
  
  
  (method package (show-chest self section data)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'chest)))
        (set-visible? panel #t)
        (hide-crafting self)
        (view-chest panel section data)
        (set! interface? #t))))
  
  
  (method package (hide-chest self)
    (let ((interface (current-interface)))
      (save-chest)
      (let ((panel (child interface 'chest)))
        (set-visible? panel #f))))
  
  
  (method package (update-parameter self name)
    (let ((interface (current-interface+)))
      (when interface
        (let ((view (parameter-view self name)))
          ;; yownu
          (when view
            (invalidate-view view))))))


  (method (parameter-view self name)
    (let ((interface (current-interface+)))
      (and interface
           (let ((parameter (registered-parameter name)))
             (define (find-view)
               (continuation-capture
                 (lambda (return)
                   (define (find-in bar)
                     (when (is? bar World-Actionbar)
                       (for-each (lambda (button)
                                   (when (and (is? button World-Parameter-Button)
                                              (eq? (get-parameter button) name))
                                     (continuation-return return button)))
                                 (get-children bar))))
                   
                   (find-in radial-menu)
                   (for-each find-in (get-children interface))
                   (when mainbar
                     (find-in mainbar))
                   #f)))
             
             (or (get-view parameter)
                 (let ((view (find-view)))
                   (if (not view)
                       #f
                       @yownu
                       (error "Unable to find view: {a}" name)
                     (set-view parameter view)
                     view)))))))
  
  
  (method package (display-on/off self title flag)
    (display-message self (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method package (display-message self msg (font: font #f) (color: color #f) (duration: duration #f))
    (assert (or (string? msg)
                (and (pair? msg)
                     (every? string? msg))))
    (set! message msg)
    (set! message-font font)
    (set! message-color color)
    (set! message-duration duration)
    (set! message-time (current-monotonic)))
  
  
  (method package (clear-message self)
    (set! message #f)
    (set! message-time #f))
  
  
  (method package (layout-message self)
    (let ((window (current-window)))
      (let ((world-width (get-width window))
            (world-height (get-height window)))
        (let ((h (center (get-width message-sheet) world-width))
              (v (draw-message-offset self)))
          (set-position message-sheet (new Point h v))))))
  
  
  (method (draw-message self)
    (let ((elapse (- (current-monotonic) message-time))
          (duration (or message-duration 1.)))
      (let ((fade duration)
            (done (+ duration 1.)))
        (if (> elapse done)
            (begin
              (set! message #f)
              (set! message-time #f))
          (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f))
                (multiline? (pair? message)))
            (let ((surface (get-surface (get-texture message-sheet)))
                  (font (or message-font (if multiline? {Font Message-Small} {Font Message})))
                  (incr (if multiline? 24 30))
                  (color (or message-color {Color World-Message}))
                  (first (if multiline? (car message) message))
                  (all (if multiline? message (list message))))
              (clear surface)
              (set-font surface font)
              (let ((color (if (not alpha)
                               color
                             (let ((color (copy-object color #f)))
                               (set-alpha color alpha)
                               color)))
                    (shadow-color (if (not alpha)
                                      {Color Black}
                                    (let ((color (copy-object {Color Black} #f)))
                                      (set-alpha color alpha)
                                      color)))
                    (h (center (text-width font first) (get-width message-sheet)))
                    (v 10))
                (for-each (lambda (message)
                            (draw-text surface h v message color shadow-color: shadow-color)
                            (increase! v incr))
                          all))
              (flush surface)
              (map-texture (get-texture message-sheet))
              (render-sheet message-sheet)))))))
  
  
  (method protected virtual (draw-message-offset self)
    80)
  
  
  (method protected virtual (draw-working-offset self)
    120)
  
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method package (display-error self msg (duration: duration 5.))
    (display-message self msg color: {Color Red} duration: duration))
  
  
  (method package (display-cancel self msg (duration: duration #f))
    (display-message self msg color: {Color Red} duration: duration)
    (signal-cancel))
  
  
  (method package (display-walk-problems self detail)
    (open-message (walk-problems-message detail)
                  caption: "Problems"
                  type: 'message
                  execute: (lambda (evt)
                             (let ((dialog (find-ascendant (get-sender evt) World-Dialog)))
                               (close dialog)))))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method package (display-status self msg (color: color #f) (duration: duration #f))
    (set! status msg)
    (set! status-color color)
    (set! status-duration duration)
    (set! status-time (current-monotonic)))
  
  
  (method (layout-status self)
    (let ((window (current-window)))
      (let ((world-width (get-width window))
            (world-height (get-height window)))
        (let ((h (center (get-width status-sheet) world-width))
              (v (- world-height 70 (get-height status-size))))
          (set-position status-sheet (new Point h v))))))
  
  
  (method (draw-status self)
    (let ((elapse (- (current-monotonic) status-time))
          (duration (or status-duration 1.)))
      (let ((fade duration)
            (done (+ duration 1.)))
        (if (> elapse done)
            (begin
              (set! status #f)
              (set! status-time #f))
          (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f)))
            (let ((surface (get-surface (get-texture status-sheet)))
                  (font {Font Status})
                  (color (or status-color {Color World-Message})))
              (clear surface)
              (set-font surface font)
              (let ((color (if (not alpha)
                               color
                             (let ((color (copy-object color #f)))
                               (set-alpha color alpha)
                               color)))
                    (shadow-color (if (not alpha)
                                      {Color Black}
                                    (let ((color (copy-object {Color Black} #f)))
                                      (set-alpha color alpha)
                                      color)))
                    (h (center (text-width font status) (get-width status-sheet))))
                (draw-text surface h 0 status color shadow-color: shadow-color))
              (flush surface)
              (map-texture (get-texture status-sheet))
              (render-sheet status-sheet)))))))

  
  ;;;
  ;;;; Action
  ;;;
  
  
  (method package (display-action self msg proc (tutorial: tutorial #f))
    (set! action msg)
    (set! action-duration +inf.0)
    (set! action-time (current-monotonic))
    (set! action-proc proc)
    (set! action-tutorial tutorial))
  
  
  (method (layout-action self)
    (let ((window (current-window)))
      (let ((world-width (get-width window))
            (world-height (get-height window)))
        (let ((h (center (get-width action-sheet) world-width))
              (v (- world-height 70 (get-height action-size))))
          (set-position action-sheet (new Point h v))))))
  
  
  (method (draw-action self)
    (let ((elapse (- (current-monotonic) action-time))
          (duration action-duration))
      (let ((fade duration)
            (done (+ duration .25)))
        (if (> elapse done)
            (begin
              (set! action #f)
              (set! action-time #f))
          (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f)))
            (let ((surface (get-surface (get-texture action-sheet)))
                  (font {Font Action})
                  (color {Color Gray})
                  (faded {Color red: 0 green: 0 blue: 0 alpha: 0.})
                  (background (if (not alpha)
                                  {Color red: 0 green: 0 blue: 0 alpha: .5}
                                (new Color red: 0 green: 0 blue: 0 alpha: (* .5 alpha)))))
              (clear surface)
              (gradient-fill-rect surface (new Rect 0 0 400 80)
                (list (list 0 faded)
                      (list 1 background))
                direction: 'horizontal)
              (gradient-fill-rect surface (new Rect 400 0 800 80)
                (list (list 0 background)
                      (list 1 faded))
                direction: 'horizontal)
              (set-font surface font)
              (let ((color (if (not alpha)
                               color
                             (let ((color (copy-object color #f)))
                               (set-alpha color alpha)
                               color)))
                    (shadow-color (if (not alpha)
                                      {Color Black}
                                    (let ((color (copy-object {Color Black} #f)))
                                      (set-alpha color alpha)
                                      color)))
                    (h (center (text-width font action) (get-width action-sheet))))
                (draw-text surface h 26 action color shadow-color: shadow-color))
              (flush surface)
              (map-texture (get-texture action-sheet))
              (render-sheet action-sheet)))))))

  
  ;;;
  ;;;; Working
  ;;;
  
  
  (method (start-working self)
    (start-task working-task))
  
  
  (method (stop-working self)
    (stop-task working-task))
  
  
  (method (run-working self task <Task>)
    (declare (proper-tail-calls))
    (let ((window (current-window)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (working-lock! self)
            (if working-done?
                (continuation-return exit #f)
              (render-working self)
              (render-sync window)
              (working-unlock! self)
              (sleep .05)
              (set! working-step (modulo (+ working-step 1) 20))
              (iter)))))))
  
  
  (method (exit-working self task <Task>)
    (set! working-done? #t)
    (working-unlock! self))
  
  
  (method (render-working self)
    (with-render-mutex
      (lambda ()
        ;; pre
        (when multisampling?
          (preprocess-multisampled self))
        ;; clear
        (glClear (bitwise-ior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
        (let ((interface (current-interface)))
          (render-texture interface working-background)
          (draw-working self))
        ;; post
        (when multisampling?
          (postprocess-multisampled self))
        (gl-check-error))))
  
  
  (method (working-lock! self)
    (mutex-lock! working-mutex #f #f))
  
  
  (method (working-unlock! self)
    (mutex-unlock! working-mutex))


  (method package (working-wait self message delay thunk)
    (working self
      (lambda ()
        (working-progress self message #f)
        (sleep delay)))
    (thunk))
  
  
  (method package (working self thunk (color: color #f))
    (let ((zone (current-zone+)))
      (if (or (inhibit-working?) (not zone) (not (get-ready? zone)))
          (thunk)
        (assert (task-mutex-owner?))
        (if working?
            (thunk)
          (set! working? #t)
          (set! working-color color)
          (set! working-message #f)
          (set! working-percentage #f)
          (set! working-background (render-window-to-texture))
          (working-unlock! self)
          (prog1 (thunk)
            (working-lock! self)
            (set! working? #f)
            (close working-background)
            (set! working-background #f))))))
  
  
  (method package (working-progress self message percentage)
    (set! working-message message)
    (set! working-percentage percentage))
  
  
  (method (layout-working self)
    (let ((window (current-window)))
      (let ((world-width (get-width window))
            (world-height (get-height window)))
        (let ((h (center (get-width working-sheet) world-width))
              (v (draw-working-offset self)))
          (set-position working-sheet (new Point h v))))))
  
  
  (method (draw-working self)
    (let ((surface (get-surface (get-texture working-sheet))))
      (clear surface)
      (let ((context (get-context surface))
            (color (or working-color {Color World-Green}))
            (working-angle (* (cast <fl> working-step) (/ PI*2 20.))))
        (loop (for n from 0 below 20)
              (let ((angle (* (cast <fl> n) (/ PI*2 20.)))
                    (alpha (- 1. (/ (cast <fl> n) 35.))))
                (with-preserved-matrix surface
                  (lambda ()
                    (cairo_translate context 400. 30.)
                    (cairo_rotate context (- working-angle angle))
                    (fill-rect surface (new Rect 18 0 30 3)
                      (new Color red: (get-red color) green: (get-green color) blue: (get-blue color) alpha: alpha))))))
        (set-font surface {Font font-name: tahoma point-size: 16 shadow: thin})
        (when working-message
          (let ((width (get-text-width surface (if (not working-percentage)
                                                   working-message
                                                 (format "{a} ( %)" working-message)))))
            (let ((h (center width 800))
                  (str (if (not working-percentage)
                           working-message
                         (format "{a} ({r precision: 0}%)" working-message working-percentage))))
              (draw-text surface h 70 str color)))))
      (flush surface)
      (map-texture (get-texture working-sheet))
      (render-sheet working-sheet)))))
