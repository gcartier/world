;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.live jazz


(require (jazz.jpeg)
         (world.generation.models))

(import (jazz.action)
        (jazz.application)
        (jazz.associative)
        (jazz.audio)
        (jazz.cairo)
        (jazz.component)
        (jazz.debuggee)
        (jazz.debugger)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.media)
        (jazz.opengl)
        (jazz.opengl.glew)
        (jazz.opengl.texture)
        (jazz.platform)
        (jazz.presence)
        (jazz.runtime)
        (jazz.screen)
        (jazz.snapshot)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.tracker)
        (jazz.ui.dialog)
        (jazz.version)
        (jazz.view)
        (jazz.window)
        (jazz.zlib)
        (profiler)
        (world)
        (world.actor)
        (world.ambience)
        (world.asset)
        (world.assets)
        (world.atlas)
        (world.autoload)
        (world.block)
        (world.buffers)
        (world.camera)
        (world.change)
        (world.changes)
        (world.chronology)
        (world.circle)
        (world.client.tier)
        (world.collision)
        (world.commands)
        (world.configure)
        (world.context)
        (world.creature)
        (world.debug)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.entities)
        (world.entity)
        (world.event)
        (world.external.blender)
        (world.external.milkshape)
        @needs-fixing
        (world.external.obj)
        (world.fog)
        (world.folio)
        (world.foreign)
        (world.gadget)
        (world.generate)
        (world.generation)
        (world.generation.block)
        (world.generation.building)
        (world.generation.decoration)
        (world.generation.rendering)
        (world.geometry)
        (world.gravity)
        (world.grid)
        (world.history)
        (world.homogeneous)
        (world.interface)
        (world.interface.actions)
        (world.interface.animations)
        (world.interface.avatars)
        (world.interface.bindings)
        (world.interface.blocks)
        (world.interface.character)
        (world.interface.chat)
        (world.interface.color)
        (world.interface.combat)
        (world.interface.command)
        (world.interface.compass)
        (world.interface.crafting)
        (world.interface.dialogs)
        (world.interface.documents)
        (world.interface.evolution)
        (world.interface.exception)
        (world.interface.frame)
        (world.interface.gadgets)
        (world.interface.history)
        (world.interface.info)
        (world.interface.inventory)
        (world.interface.mainbar)
        (world.interface.map)
        (world.interface.menu)
        (world.interface.meshes)
        (world.interface.models)
        (world.interface.options)
        (world.interface.panel)
        (world.interface.profiler)
        (world.interface.propagation)
        (world.interface.script)
        (world.interface.scripts)
        (world.interface.shaders)
        (world.interface.sheet)
        (world.interface.showcase)
        (world.interface.skyboxes)
        (world.interface.target)
        (world.interface.templates)
        (world.interface.textures)
        (world.interface.tiles)
        (world.interface.timeline)
        (world.interface.who)
        (world.io)
        (world.keys)
        (world.light)
        (world.mark)
        (world.material)
        (world.missile)
        (world.model)
        (world.motion)
        (world.music)
        (world.pane)
        (world.parameters)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.profile)
        (world.profiling)
        (world.programs)
        (world.quad)
        (world.ray)
        (world.region)
        (world.render)
        (world.renderer)
        (world.renderers)
        (world.script.asset)
        (world.scripts)
        (world.sector)
        (world.settings)
        (world.shaders)
        (world.skybox)
        (world.sound)
        (world.space)
        (world.spawn)
        (world.sphere)
        (world.support)
        (world.syntax (phase syntax))
        (world.target)
        (world.task)
        (world.texture)
        (world.tier)
        (world.travel)
        (world.triangle)
        (world.visualization)
        @needs-work
        (world.w3d)
        (world.widget)
        (world.window)
        (world.work)
        (world.zone))


;;;
;;;; World
;;;


;; This value is large because alpha to coverage transparency produces
;; visible dithering when alpha is not a multiple of 1/multisampling and
;; so with 8 we get all the multiples of .125 for smooth transparency
(definition default-multisampling
  (cond-expand
    ;; quick hack around what is probably a vmware bug
    (linux 0)
    (else 8)))


(definition (make-eye)
  (let ((camera (make-camera)))
    (setup-area-cube camera 7)
    camera))


(class World extends Object
  
  
  (slot width                  <fl>                initialize #f              accessors generate)
  (slot height                 <fl>                initialize #f              accessors generate)
  (slot eye                    <Camera>            initialize (make-eye)      getter generate)
  (slot eye-motion             <Motion>            initialize #f              getter generate)
  (slot eye-hook               <object>            initialize #f              accessors generate)
  (slot world-up               <vertex>            initialize (make-vertex)   getter generate)
  (slot what                   <object>            initialize #f              getter generate)
  (slot selection              <object>            initialize '()             getter generate)
  (slot target-polygon         <object>            initialize #f              getter generate)
  (slot target-vertex          <object>            initialize #f              getter generate)
  (slot target-mode            <object>            initialize 'select         getter generate)
  (slot target-widget          <Widget+>           initialize #f              getter generate)
  (slot last-point             <object>            initialize #f              getter generate)
  (slot last-time              <object>            initialize #f              getter generate)
  (slot track?                 <bool>              initialize #f              getter generate)
  (slot showcase               <World-Showcase+>   initialize #f              getter generate)
  (slot showcases              <object>            initialize #f              getter generate)
  (slot showcase-down?         <bool>              initialize #f              getter generate)
  (slot polygon-mode           <fx>                initialize GL_FILL         getter generate)
  (slot window-cursor          <object>            initialize :arrow          getter generate)
  (slot earth?                 <bool>              initialize #t              getter generate)
  (slot interface?             <bool>              initialize #t              accessors generate)
  (slot explore-interface?     <bool>              initialize #f              accessors generate)
  (slot ambient-gravity         <vertex>           initialize default-gravity accessors generate)
  (slot jump-impulsion          <fl>               initialize default-jump    accessors generate)
  (slot default-image           <object>           initialize "stone"         accessors generate)
  (slot properties              <object>           initialize '()             accessors generate)
  
  
  (slot version                <object>            initialize #f              getter generate)
  (slot orientation?           <bool>              initialize #f              getter generate)
  (slot aim?                   <bool>              initialize #f              getter generate)
  (slot free-aim?              <bool>              initialize #f              getter generate)
  (slot viewing?               <bool>              initialize #f              getter generate)
  (slot moving?                <bool>              initialize #f              getter generate)
  (slot moved?                 <bool>              initialize #f              getter generate)
  (slot first-camera           <object>            initialize #f              getter generate)
  (slot riders-folio           <Folio>             initialize #f              getter generate)
  (slot flyers-folio           <Folio>             initialize #f              getter generate)
  (slot x-rays?                <bool>              initialize #f              getter generate)
  (slot x-rays-category        <symbol+>           initialize #f              getter generate)
  (slot draw-blocks?           <bool>              initialize #t              getter generate)
  (slot draw-entities?         <bool>              initialize #t              getter generate)
  (slot draw-gadgets?          <bool>              initialize #f              getter generate)
  (slot draw-marks?            <bool>              initialize #t              getter generate)
  (slot draw-normals?          <bool>              initialize #f              getter generate)
  (slot draw-atlas?            <bool>              initialize #f              accessors generate)
  (slot draw-me?               <bool>              initialize #t              accessors generate)
  (slot view-distance          <fx>                initialize 7               getter generate)
  (slot view-radius            <fl>                initialize #f              accessors generate)
  (slot max-entity-radius      <fl>                initialize 60.             accessors generate)
  (slot render-thread          <object>            initialize #f              accessors generate)
  (slot render-trim?           <bool>              initialize #f              accessors generate)
  (slot dynamic-lights         <fx>                initialize 8               getter generate)
  (slot post-processing?       <bool>              initialize #t              getter generate)
  (slot player-thread          <object>            initialize #f              accessors generate)
  (slot ongoing-key            <object>            initialize #f              accessors generate)
  (slot axes?                  <bool>              initialize #f              accessors generate)
  (slot axes-graduation?       <bool>              initialize #f              accessors generate)
  (slot tick-slice?            <bool>              initialize #t              getter generate)
  (slot down?                  <bool>              initialize #f              getter generate)
  (slot down-point             <object>            initialize #f              getter generate)
  (slot double-click?          <bool>              initialize #f              getter generate)
  (slot drag-tolerance         <object>            initialize 5               getter generate)
  (slot tick-procedures        <object>            initialize '()             getter generate)
  (slot tick-no                <object>            initialize 0               getter generate)
  (slot commands               <object>            initialize #f              getter generate)
  (slot base-assets            <object>            initialize #f              getter generate)
  (slot zone-assets            <object>            initialize #f              getter generate)
  (slot template-assets        <object>            initialize #f              getter generate)
  (slot user-assets            <object>            initialize #f              getter generate)
  (slot textures               <object>            initialize #f              getter generate)
  (slot models                 <object>            initialize #f              getter generate)
  (slot gc-sound?              <bool>              initialize #f              getter generate)
  (slot gc-trace?              <bool>              initialize #f              getter generate)
  (slot history?               <bool>              initialize #t              getter generate)
  (slot history-trail          <fx>                initialize 250             getter generate)
  (slot history-camera         <Camera>            initialize (make-camera)   getter generate)
  (slot history-camera?        <bool>              initialize #f              getter generate)
  (slot history-motion         <Motion>            initialize #f              getter generate)
  (slot message                <object>            initialize #f              getter generate)
  (slot message-time           <object>            initialize #f              getter generate)
  (slot message-font           <object>            initialize #f              getter generate)
  (slot message-color          <object>            initialize #f              getter generate)
  (slot message-duration       <object>            initialize #f              getter generate)
  (slot message-sheet          <object>            initialize #f              getter generate)
  (slot status                 <object>            initialize #f              getter generate)
  (slot status-time            <object>            initialize #f              getter generate)
  (slot status-color           <object>            initialize #f              getter generate)
  (slot status-duration        <object>            initialize #f              getter generate)
  (slot status-sheet           <object>            initialize #f              getter generate)
  (slot working?               <bool>              initialize #f              getter generate)
  (slot working-color          <object>            initialize #f              getter generate)
  (slot working-step           <fx>                initialize 0               getter generate)
  (slot working-message        <object>            initialize #f              getter generate)
  (slot working-percentage     <object>            initialize #f              getter generate)
  (slot working-result         <object>            initialize #f              getter generate)
  (slot working-sheet          <object>            initialize #f              getter generate)
  (slot compass-sheet          <object>            initialize #f              getter generate)
  (slot compass-visible?       <bool>              initialize #f              accessors generate)
  (slot map-sheet              <object>            initialize #f              getter generate)
  (slot map-visible?           <bool>              initialize #f              getter generate)
  (slot evolution-sheet        <object>            initialize #f              getter generate)
  (slot evolution-visible?     <bool>              initialize #f              getter generate)
  (slot history-sheet          <object>            initialize #f              getter generate)
  (slot history-visible?       <bool>              initialize #f              getter generate)
  (slot interface-refresh?     <bool>              initialize #f              getter generate)
  (slot interface-refresh-rate <fl>                initialize #f              getter generate)
  (slot interface-last-time    <fl>                initialize #f              getter generate)
  (slot interface-target?      <bool>              initialize #f              getter generate)
  (slot show-belt?             <bool>              initialize #f              accessors generate)
  (slot last-script            <object>            initialize #f              getter generate)
  (slot last-whisperer         <object>            initialize #f              accessors generate)
  (slot escape-hook            <object>            initialize #f              accessors generate)
  (slot enter-hook             <object>            initialize #f              accessors generate)
  (slot central-menu           <object>            initialize #f              accessors generate)
  (slot radial-menu            <object>            initialize #f              accessors generate)
  
  ;; Shader programs
  (slot mesh-programs          <object>            initialize #f              accessors generate)
  (slot block-atlas            <Atlas>             initialize #f              accessors generate)
  (slot block-texture          <Image-Texture>     initialize #f              accessors generate)
  (slot block-texture-repeat   <Image-Texture>     initialize #f              accessors generate)
  (slot block-opaque           <object>            initialize #f              accessors generate)
  (slot block-transparent      <object>            initialize #f              accessors generate)
  (slot block-coverage         <object>            initialize #f              accessors generate)
  (slot block-water            <object>            initialize #f              accessors generate)
  (slot block-wet              <object>            initialize #f              accessors generate)
  (slot block-multitexture     <object>            initialize #f              accessors generate)
  (slot block-materials        <object>            initialize #f              accessors generate)
  (slot block-program          <Mesh-Program>      initialize #f              accessors generate)
  (slot texture-program        <Texture-Program>   initialize #f              accessors generate)
  (slot sheet-program          <Sheet-Program>     initialize #f              accessors generate)
  (slot material-opaque        <object>            initialize #f              accessors generate)
  (slot material-transparent   <object>            initialize #f              accessors generate)
  (slot day-lightmap           <object>            initialize #f              accessors generate)
  (slot night-lightmap         <object>            initialize #f              accessors generate)
  
  ;; Render targets
  (slot render-target          <Render-Target+>    initialize #f              accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition max-dynamic-lights
    8)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set-current-world self)
    (set! view-distance (world-setting 'world.view-distance 9))
    (set! view-radius 200.)
    (set! history-motion (make-free-motion self history-camera))
    (set-callback history-camera (~ camera-callback self))
    (set! eye-motion (make-free-motion self eye))
    (set-callback eye (~ camera-callback self))
    (set-current-camera eye)
    (set-current-motion eye-motion)
    (set-current-music (new World-Music))
    (set-current-ambience (new World-Ambience))
    (when (window?)
      (set-current-audio (new World-Audio))
      (set-current-video (new World-Video)))
    (set! dynamic-lights (min max-dynamic-lights (world-setting 'world.dynamic-lights 4)))
    (set! earth? (world-setting 'world.earth? #f))
    (set-camera-smoothing? (world-setting 'world.camera-smoothing? #t))
    (set-independent-camera? (world-setting 'world.independent-camera? #t))
    (set-autotrack-camera? (world-setting 'world.autotrack-camera? #f))
    (set-track-sensitivity (world-setting 'world.track-sensitivity 200.))
    (set! post-processing? (and (window?) (world-setting 'world.post-processing? #t)))
    (set! interface? (world-setting 'world.start-interface? #t))
    (set! interface-target? (world-setting 'world.interface-target? #f))
    (set-interface-script? (world-setting 'world.interface-script? #f))
    (set! show-belt? (world-setting 'world.show-belt? #t))
    (set! gc-sound? (world-setting 'world.gc-sound? #f))
    (set! gc-trace? (world-setting 'world.gc-trace? #f))
    (set! history? (world-setting 'world.history? #t))
    (set! history-trail (world-setting 'world.history-trail 250))
    (set! history-camera? (world-setting 'world.history-camera? #f))
    (set! evaluate-future? (world-setting 'world.evaluate-future? #f))
    (set! free-aim? (world-setting 'world.free-aim? #f))
    (set-fog? #f @until-for-is-really-nice (world-setting 'world.fog? #t))
    (set-fog-density (world-setting 'world.fog-density default-fog-density))
    (set-fog-color (world-setting 'world.fog-color default-fog-color))
    ;; aec quick hack
    (set-animations? (and (window?) (world-setting 'world.animations? (>= (glGetInteger* GL_MAX_VERTEX_UNIFORM_COMPONENTS) 4096))))
    (set-block-pumps? (world-setting 'world.block-pumps? #f))
    (set! tick-slice? (not (world-setting 'world.inhibit-slicing? #f)))
    (set! models (make-table test: equal?))
    (update-world-up self ambient-gravity)
    (prepare-sounds self)
    (setup-history)
    ;; not necessary if we are not using message-available?
    ;; (set-ignore-key-repeat? #t)
    (register-keys)
    (setup-info))
  
  
  (method package (setup-opengl self)
    (when (window?)
      (setup-size self)
      (glClear GL_COLOR_BUFFER_BIT)
      (glClear GL_DEPTH_BUFFER_BIT)
      (glEnable GL_DEPTH_TEST)
      (glDisable GL_BLEND)
      (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
      (glFrontFace GL_CW)
      (glPolygonMode GL_FRONT_AND_BACK GL_FILL)
      (glEnable GL_LINE_SMOOTH)
      (initialize-eye self))
    (prepare-assets self)
    (when (window?)
      (prepare-showcases self)
      (prepare-shaders self)
      (prepare-renderes)
      (prepare-sheets self)
      (prepare-skyboxes)
      (initialize-render self)
      (reset-commands self)
      (gl-check-error)))
  
  
  (method (setup-size self)
    (let ((window (current-window)))
      (size-change self (get-size window))))
  
  
  (method package (size-change self size)
    (set! width (cast <fl> (get-width size)))
    (set! height (cast <fl> (get-height size)))
    (size-change eye size)
    (size-change history-camera size)
    (size-change (cache-inventory-camera) size)
    (when showcases
      (iterate-table showcases
        (lambda (name showcase)
          (size-change showcase size))))
    (let ((interface (current-interface+)))
      (when interface
        (set-size interface size)
        (interface-layout self)
        (sheets-layout self)))
    (reset-inventory-blocks))
  
  
  (method (initialize-render self)
    (let ((width (fxround width))
          (height (fxround height))
          (multisampling (world-setting 'world.multisampling (if (eq? graphic-profile 'poor) 2 default-multisampling))))
      (set! render-target (new Render-Target width height multisampling))))
  
  
  (method package (update-world-up self gravity)
    (vertex-copy! world-up (gravity-up& gravity)))
  
  
  (method (reset-commands self)
    (when (or (not commands) (get-modified? commands))
      (set! commands (new Commands))))
  
  
  (method package (change-view-distance self distance)
    (let ((old-distance view-distance))
      (set! view-distance distance)
      (update-view-distance (current-zone) old-distance distance)))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (method (prepare-assets self)
    (set! base-assets (make-directory-assets 'base (new-directory (get-world-directory) "assets")))
    (when (client?)
      (let ((dir {Directory Documents "user"}))
        (set! user-assets (and (exists? dir)
                               (make-directory-assets 'user dir))))))
  
  
  (method package (prepare-zone-assets self zone-dir asset-entries)
    (let ((tier (current-tier)))
      (set! zone-assets (make-zone-assets tier zone-dir))
      (when asset-entries
        (setup-remote-index zone-assets asset-entries))))
  
  
  (method package (prepare-template-assets self zone-dir)
    (let ((instance (new-file zone-dir ".instance")))
      (set! template-assets 
            (and (exists? instance)
                 (let ((instance (instantiate (read-form instance))))
                   (let ((template (get-template instance)))
                     (let ((template-dir (new-directory {Directory Application-World "templates"} (append template '("assets")))))
                       (and (exists? template-dir)
                            (make-directory-assets 'template template-dir)))))))))
  
  
  (method package (iterate-assets self proc)
    (when zone-assets
      (proc zone-assets))
    (when (and template-assets (developer?))
      (proc template-assets))
    (proc base-assets)
    (let ((tier (current-tier+)))
      (when tier
        (let ((assets (get-universe-assets tier)))
          (when assets
            (proc assets)))
        (let ((assets (get-world-assets tier)))
          (when assets
            (proc assets)))))
    (when user-assets
      (proc user-assets)))
  
  
  (method (partition-assets self)
    (let ((queue (new-queue)))
      (define (add kind assets)
        (enqueue queue (cons kind assets)))
      
      (when zone-assets
        (add 'zone zone-assets))
      (when (and template-assets (developer?))
        (add 'template template-assets))
      (add 'base base-assets)
      (let ((tier (current-tier+)))
        (when tier
          (let ((assets (get-universe-assets tier)))
            (when assets
              (add (get-where assets) assets)))
          (let ((assets (get-world-assets tier)))
            (when assets
              (add (get-where assets) assets)))))
      (when user-assets
        (add 'user user-assets))
      (queue-list queue)))
  
  
  (method package (find-asset self path)
    (continuation-capture
      (lambda (return)
        (iterate-assets self
          (lambda (assets)
            (when (contains-file? assets path)
              (continuation-return return (new Asset assets path)))))
        #f)))
  
  
  (method package (require-asset self path)
    (or (find-asset self path)
        (error "Unable to find asset: {a}" path)))
  
  
  (method protected virtual (prepare-sheets self)
    (set! message-sheet (make-world-sheet 'message World-Sheet message-size))
    (set! status-sheet (make-world-sheet 'status World-Sheet status-size))
    (set! working-sheet (make-world-sheet 'working World-Sheet working-size))
    (set! compass-sheet (make-world-sheet 'compass World-Sheet compass-size))
    (set! map-sheet (make-world-sheet 'map World-Sheet map-size))
    (set! evolution-sheet (make-world-sheet 'evolution World-Sheet evolution-size))
    (set! history-sheet (make-world-sheet 'history World-Sheet history-size)))
  
  
  (method protected virtual (resize-sheets self)
    (make-orthographic-matrix! (get-projection-matrix message-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix status-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix working-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix compass-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix map-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix evolution-sheet) 0. width 0. height 0. 10.)
    (make-orthographic-matrix! (get-projection-matrix history-sheet) 0. width 0. height 0. 10.))
  
  
  (method protected (resize-interface self)
    (let ((interface (current-interface+)))
      (when interface
        (make-orthographic-matrix! (get-projection-matrix interface) 0. width 0. height 0. 10.))))

  
  (method package (prepare-block self atlas texture texture-repeat)
    (set! block-atlas atlas)
    (set! block-texture texture)
    (set! block-texture-repeat texture-repeat))
  
  
  (method package (prepare-materials self opaque-material transparent-material coverage-material water-material wet-material multitexture-material)
    (set! block-opaque opaque-material)
    (set! block-transparent transparent-material)
    (set! block-coverage coverage-material)
    (set! block-water water-material)
    (set! block-wet wet-material)
    (set! block-multitexture multitexture-material)
    (set! block-materials (make-table test: eq?))
    (set! material-opaque (get-entity-material (opaque-rendering)))
    (set! material-transparent (get-entity-material (transparent-rendering))))
  
  
  (method package (prepare-lightmaps self)
    (let ((day {File Application-World "assets" "light" "world" "day.png"})
          (night {File Application-World "assets" "light" "world" "night.png"}))
      (define (make-lightmap file)
        (make-png-texture file min-filter: GL_NEAREST mag-filter: GL_NEAREST wrap: GL_CLAMP_TO_EDGE mipmap?: #f))
      
      (set! day-lightmap (make-lightmap day))
      (set! night-lightmap (make-lightmap night))))
  
  
  ;;;
  ;;;; Sounds
  ;;;
  
  
  (method protected virtual (prepare-sounds self)
    (setup-sounds))

  
  ;;;
  ;;;; Modules
  ;;;
  
  
  (slot installed-repositories        initialize (make-table test: equal?) getter generate)
  (slot installed-repositories-assets initialize (make-table test: equal?) getter generate)
  
  
  (method package (prepare-modules self)
    (when (scripting-available?)
      (let ((queue (new-queue))
            (table (make-table test: equal?)))
        (iterate-assets self
          (lambda (assets)
            (when (contains-directory? assets "module")
              ;; module reference isn't hooked into assets
              ;; yet so simply retrieve the whole directory
              (let ((dirname (parse (retrieve-directory assets "module"))))
                (enqueue queue dirname)
                (table-set! table dirname assets)))))
        (let ((new (queue-list queue)))
          (update-repositories installed-repositories new)
          (set-world-repositories new))
        (set! installed-repositories-assets table))))
  
  
  (method package (collect-modules self)
    (let ((modules '()))
      (for-each (lambda (path)
                  (let ((repository (table-ref installed-repositories path))
                        (assets (table-ref installed-repositories-assets path)))
                    (let ((assets-dir (get-directory assets)))
                      (iterate-packages repository
                        (lambda (package)
                          (let ((dir (new Directory (tokenise-filename (package-directory package)))))
                            (let ((asset-root (subpath assets-dir dir)))
                              (iterate-directory dir
                                (lambda (path kind)
                                  (let ((file (new-file dir path)))
                                    (when (extension=? (get-extension file) "jazz")
                                      (unless (member? (get-name file) '(".DS_Store") test: filename=?)
                                        (let ((asset (new Asset assets (append asset-root (subpath dir file)))))
                                          (set! modules (cons asset modules)))))))
                                full?: #f
                                files?: #t
                                directories?: #f
                                recursive?: #t))))))))
                (get-world-repositories))
      modules))

  
  ;;;
  ;;;; Materials
  ;;;
  
  
  (method package (find-block-material self name)
    (or (table-ref block-materials name #f)
        (let ((mat (case name
                     ((opaque) block-opaque)
                     ((transparent) block-transparent)
                     (else (new Material atlas: block-atlas texture: block-texture-repeat renderer: (require-renderer name))))))
          (table-set! block-materials name mat)
          mat)))
  
  
  ;;;
  ;;;; Showcases
  ;;;
  
  
  (method (prepare-showcases self)
    (set! showcases (make-table test: eq?)))
  
  
  ;;;
  ;;;; Shaders
  ;;;
  
  
  (method (prepare-shaders self)
    ;; shaders
    (build-default-shaders)
    (build-sheet-shaders)
    (build-texture-shaders)
    (build-skybox-shaders)
    (build-color-shaders)
    (build-mesh-shaders)
    (build-block-shaders)
    (build-model-shaders)
    (build-occlusion-shaders)
    (build-frame-shaders)
    (build-transformation-shaders)

    ;; mesh
    (set! mesh-programs (make-table test: eq?))
    (table-set! mesh-programs 'color              (new Mesh-Color-Program))
    (table-set! mesh-programs 'block              (new Mesh-Block-Program))
    (table-set! mesh-programs 'model              (new Mesh-Model-Program))
    (table-set! mesh-programs 'occlusion          (new Mesh-Occlusion-Program))
    (table-set! mesh-programs 'wireframe          (new Mesh-Wireframe-Program))
    (table-set! mesh-programs 'squareframe        (new Mesh-Squareframe-Program))
    (table-set! mesh-programs 'testinstance       (new Mesh-TestInstance-Program))
    (table-set! mesh-programs 'playerframe        (new Mesh-Playerframe-Program))
    (table-set! mesh-programs 'floorframe         (new Mesh-Floorframe-Program))
    (table-set! mesh-programs 'player             (new Mesh-Player-Program))
    (table-set! mesh-programs 'white              (new Mesh-White-Program))
    (table-set! mesh-programs 'radial-blur        (new Mesh-Radial-Blur-Program))
    (table-set! mesh-programs 'motion-blur        (new Mesh-Motion-Blur-Program))
    (table-set! mesh-programs 'fire               (new Mesh-Fire-Program))
    (table-set! mesh-programs 'water-block        (new Mesh-Water-Block-Program))
    (table-set! mesh-programs 'water              (new Mesh-Water-Program))
    (table-set! mesh-programs 'wet-block          (new Mesh-Wet-Block-Program))
    (table-set! mesh-programs 'julia              (new Mesh-Julia-Program))
    (table-set! mesh-programs 'sierpinski         (new Mesh-Sierpinski-Program))
    (table-set! mesh-programs 'multitexture-block (new Mesh-Multitexture-Block-Program))
    (table-set! mesh-programs 'multitexture       (new Mesh-Multitexture-Program))
    (table-set! mesh-programs 'kaleidoscope       (new Mesh-Kaleidoscope-Program))
    (table-set! mesh-programs 'tunnel             (new Mesh-Tunnel-Program))
    (table-set! mesh-programs 'square-tunnel      (new Mesh-Square-Tunnel-Program))
    (table-set! mesh-programs 'fly                (new Mesh-Fly-Program))
    (table-set! mesh-programs 'pulse              (new Mesh-Pulse-Program))

    ;; block
    (set! block-program (find-mesh-program self 'block))
    
    ;; texture
    (set! texture-program (new Texture-Program))
    
    ;; sheet
    (set! sheet-program (new Sheet-Program))
    
    (gl-check-error))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (destroy self)
    (when (window?)
      (free-resources render-target)
      (detach-shaders block-program)
      (close message-sheet)
      (close status-sheet)
      (close working-sheet)
      (close compass-sheet)
      (close map-sheet)
      (close evolution-sheet)
      (close history-sheet)
      (close (current-video))
      (close (current-audio))
      (close-music (current-music))))
  
  
  (method public (toggle-gc-sound self)
    (set! gc-sound? (not gc-sound?))
    (display-on/off self "GC sound" gc-sound?))
  
  
  (method public (garbage-collect self)
    (let ((window (current-window)))
      (display-message self "Garbage collecting" color: {Color Red})
      (render-scene window)
      (gc)
      (let ((timer (new Timer)))
        (gc)
        (display-message self (format "Garbage collected ({a}ms)" (real-duration-in-milliseconds timer)) color: {Color Green}))
      (render-scene window)))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method package virtual (initialize-world self)
    (set! version world-version)
    (set! first-camera 'free)
    (set! grid? (world-setting 'world.grid? #f))
    (set! axes? (world-setting 'world.axes? #f))
    (set! axes-graduation? (world-setting 'world.axes-graduation? #f))
    (setup-gc self)
    (when (window?)
      (setup-interface self)))
  
  
  (method package (setup-interface self)
    (let ((interface (current-interface+)))
      (when interface
        (close interface)))
    (let ((window (current-window)))
      (set-current-interface (make-world-sheet 'interface World-Interface (get-size window)))
      (let ((interface (current-interface)))
        (make-orthographic-matrix! (get-projection-matrix interface) 0. width 0. height 0. 10.)
        (set! interface-refresh-rate (world-setting 'world.interface-refresh-rate 1.))
        (set! interface-last-time -inf.0)
        (new Info-Panel parent: interface name: 'info visible?: #f layouter: (lambda (panel) (info-panel-layouter panel)))
        (new Profiler-Panel parent: interface name: 'profiler visible?: #f layouter: (lambda (panel) (profiler-panel-layouter panel)))
        (new (evolution-panel-class self) parent: interface name: 'evolution visible?: #f layouter: (lambda (panel) (evolution-panel-layouter panel)))
        (new History-Timeline-Panel parent: interface name: 'history visible?: #f layouter: (lambda (panel) (history-panel-layouter panel)))
        (new Color-Panel parent: interface name: 'color visible?: #f layouter: (lambda (panel) (color-panel-layouter panel)))
        (new Target-Panel parent: interface name: 'target visible?: #f layouter: (lambda (panel) (target-panel-layouter panel)))
        (new Compass-Panel parent: interface name: 'compass visible?: #f layouter: (lambda (panel) (compass-panel-layouter panel)))
        (new Map-Panel parent: interface name: 'map visible?: #f layouter: (lambda (panel) (map-panel-layouter panel)))
        (new Combat-Panel parent: interface name: 'combat visible?: #f layouter: (lambda (panel) (combat-panel-layouter panel)))
        (new Character-Panel parent: interface name: 'character visible?: #f layouter: (lambda (panel) (character-panel-layouter panel)))
        (new Bag-Panel parent: interface name: 'bag visible?: #f layouter: (lambda (panel) (bag-panel-layouter panel)))
        (new Belt-Panel parent: interface name: 'belt visible?: #f layouter: (lambda (panel) (belt-panel-layouter panel)))
        (new Chest-Panel parent: interface name: 'chest visible?: #f layouter: (lambda (panel) (chest-panel-layouter panel)))
        (new Crafting-Panel parent: interface name: 'crafting visible?: #f layouter: (lambda (panel) (crafting-panel-layouter panel)))
        (new Chat-Panel parent: interface name: 'chat visible?: #f)
        (new Command-Bar parent: interface name: 'command visible?: #f)
        (new (script-panel-class self) parent: interface name: 'script visible?: #f layouter: (lambda (panel) (script-panel-layouter panel)))
        (setup-application-interface (current-application))
        (set-root window interface offscreen?: #f)
        (update-background (get-manager (child interface 'script)))
        (setup-script-zoom)
        (interface-layout self)
        (sheets-layout self)
        (acquire-focus interface))))
  
  
  (method protected virtual (script-panel-class self)
    Script-Panel)
  
  
  (method protected virtual (evolution-panel-class self)
    )
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method package (zone-update self)
    (set! riders-folio (new Folio 'Wheels '(Wheels Hummer)))
    (set! flyers-folio (new Folio 'Saucer '(Saucer Rocket)))
    (let ((zone (current-zone))
          (me (current-me+)))
      (when me
        (let ((camera (player-camera me)))
          ;; eye
          (camera-copy! eye camera)
          ;; player
          ;; ride & fly (needs more work for it to reload exactly in the same state)
          (case (get-mount me)
            ((ride)
             (set-mount me #f)
             (ride-change me 'Wheels))
            ((fly)
             (set-mount me #f)
             (fly-change me 'Saucer)))
          ;; eye
          (let ((start-mode (or (get-start-mode zone) 'first-person)))
            (if (neq? start-mode 'first-person)
                (free-motion self feedback?: #f)
              (person-motion self eye-center?: #f feedback?: #f)
              (let ((distance (or (get-start-distance zone) 3.5)))
                ;; YOWNU quick hack current-motion was a free motion
                (when (is? (current-motion) Target-Motion)
                  (setup-motion (current-motion) distance)))))))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method package (tick-task self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic))
                (duration 0.))
            (let ((elapse (- time previous)))
              (unless (> elapse max-elapse)
                (unless (stopping? task)
                  (increase! duration (tick-world self time elapse))))
              (task-wait task tick-period duration exit)
              (iter time)))))))
  
  
  (method (tick-world self time elapse)
    (let ((duration 0.))
      (site tick
        (let ((zone (current-zone))
              (history (current-history)))
          (increase! duration (tick-scene zone elapse))
          (when showcase
            (increase! duration (tick-scene showcase elapse)))
          (when (not-null? tick-procedures)
            (for-each (lambda (proc)
                        (with-task-mutex
                          (lambda ()
                            (when (memq? proc tick-procedures)
                              (let ((start (current-monotonic)))
                                (proc elapse)
                                (increase! duration (- (current-monotonic) start)))))))
                      tick-procedures))))
      duration))
  
  
  (method package (register-tick self proc)
    (set! tick-procedures (cons proc tick-procedures)))
  
  
  (method package (unregister-tick self proc)
    (set! tick-procedures (remove! proc tick-procedures)))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (boost-player self)
    (when (and player-thread (not player-boost?) (neq? (current-thread) player-thread))
      (set-player-boost? #t)
      (thread-base-priority-set! player-thread priority-boost)))
  
  
  (method (unboost-player self)
    (set-player-boost? #f)
    (thread-base-priority-set! player-thread player-priority))
  
  
  (method package (player-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (set! player-thread (current-thread))
          (let (iter (previous (current-monotonic)))
            (let ((time (current-monotonic))
                  (duration 0.))
              (let ((elapse (- time previous)))
                (unless (> elapse max-elapse)
                  (with-task-mutex
                    (lambda ()
                      (unless (stopping? task)
                        (let ((start (current-monotonic)))
                          (site player
                            (unless bot?
                              (process-mouse-run self)
                              (when (world-focused?)
                                (process-keys self))
                              (unless (get-paused? history)
                                (let ((me (current-me)))
                                  (when (eq? (get-mode me) 'player)
                                    (tick-sliced self me commands time elapse)
                                    (reset-commands self)
                                    (animate me elapse)
                                    (let ((vehicle (get-vehicle me)))
                                      (when vehicle
                                        (animate vehicle elapse (get-position me))))))))
                            (update-transformation-time elapse)
                            (let ((me (current-me))
                                  (motion (current-motion)))
                              (restore-desired-distance motion elapse)
                              (restore-roll motion me)))
                          (increase! duration (- (current-monotonic) start))))))))
              (unboost-player self)
              (boost-render self)
              (task-wait task player-period duration exit)
              (iter time)))))))
  
  
  (method package (tick-sliced self actor commands time elapse)
    (declare (proper-tail-calls))
    (let ((slice (tick-slice actor)))
      (if (or (not slice) (not tick-slice?) (<= elapse slice))
          (tick-action actor commands time elapse)
        (let (iter (from 0.) (to slice))
          (tick-action actor commands (- time (- elapse to)) (- to from))
          (when (and (< to elapse) (get-alive? actor))
            (iter to (min elapse (+ to slice))))))))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method package (missile-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-monotonic)))
            (let ((time (current-monotonic))
                  (duration 0.))
              ;; only server ticks missiles
              (unless (client?)
                (let ((elapse (- time previous)))
                  (unless (or (> elapse max-elapse) 
                              (get-paused? history))
                    (increase! duration (tick-missiles self #f time elapse)))))
              (task-wait task missile-period duration exit)
              (iter time)))))))
  
  
  (method (tick-missiles self commands time elapse)
    (let ((zone (current-zone))
          (history (current-history)))
      (let ((duration 0.))
        (for-each (lambda (actor)
                    (when (is-missile? actor)
                      (with-task-mutex
                        (lambda ()
                          (site missile
                            (unless (get-paused? history)
                              ;; check linked instead of alive because of
                              ;; missiles delayed unlinking until rendered
                              (when (linked? actor)
                                (let ((start (current-monotonic)))
                                  (tick-action actor commands time elapse)
                                  (increase! duration (- (current-monotonic) start))))))))))
                  (get-actors zone))
        duration)))

  
  ;;;
  ;;;; Circularity
  ;;;
  
  
  ;; quick hacks around circular dependencies
  (method (polygon-class self)
    Polygon)
  (method package (triangle-class self)
    Triangle)
  (method package (quad-class self)
    Quad)
  (method (missile-class self)
    Missile)

  
  ;;;
  ;;;; Events
  ;;;
  
  
  ;; Interface
  (method (on-main-menu self evt)
    (main-menu self))
  
  (method (on-video-options self evt)
    (video-options self))
  
  (method (on-audio-options self evt)
    (audio-options self))
  
  (method (on-interface-options self evt)
    (interface-options self))
  
  (method (on-view-bindings self evt)
    (view-bindings self))
  
  (method (on-view-news self evt)
    (view-news self))
  
  (method (on-view-roadmap self evt)
    (view-roadmap self))
  
  (method (on-view-help self evt)
    (view-help self))
  
  (method (on-open-about self evt)
    (open-about self))
  
  (method (on-toggle-occlusion self evt)
    (toggle-occlusion self))
  
  (method (on-toggle-wireframe self evt)
    (toggle-wireframe self))
  
  (method (on-toggle-profiler self evt)
    (toggle-profiler self))
  
  (method (on-reset-profiler self evt)
    (gc)
    (reset-profiler self)
    (display-message self "Profiler reset"))
  
  (method (on-toggle-evolution self evt)
    (toggle-evolution self))
  
  (method (on-toggle-history self evt)
    (toggle-history self))
  
  (method (on-all-chronology self evt)
    (all-chronology self))
  
  (method (on-open-welcome self evt)
    (open-welcome self))
  
  (method (on-quit-world self evt)
    (quit-process (current-application)))

  (method (on-select/run-script self evt)
    (select/run-script self))

  (method (on-run-last-script self evt)
    (run-last-script self))
  
  (method (on-enter-press self evt)
    (enter-press self))
  
  (method package (on-tab-press self evt)
    (tab-press self))
  
  (method (on-radial-menu self evt)
    (let ((name (get-property evt radial:)))
      (toggle-radial-menu self name)))
  
  
  ;; Graphics
  (method (on-toggle-fog self evt)
    (toggle-fog self))
  
  (method (on-toggle-draw-gadgets self evt)
    (toggle-draw-gadgets self))
  
  (method (on-toggle-draw-normals self evt)
    (toggle-draw-normals self))
  
  (method (on-toggle-x-rays self evt)
    (toggle-x-rays self))
  
  (method (on-toggle-redstone-x-rays self evt)
    (toggle-redstone-x-rays self))
  
  (method (on-toggle-draw-blocks self evt)
    (toggle-draw-blocks self))
  
  (method (on-toggle-draw-models self evt)
    (toggle-draw-models self))
  
  (method (on-toggle-post-processing self evt)
    (toggle-post-processing self))
  
  
  ;; Sound
  (method (on-toggle-sound self evt)
    (toggle-sound self))
  
  
  ;; Server
  (method (on-server-state self evt)
    )
  
  (method (on-server-info self evt)
    )
  
  
  ;; Role
  (method (on-toggle-user self evt)
    (toggle-user self))
  
  
  ;; Zone
  (method (on-zone-reload self evt)
    (zone-reload self))
  
  (method (on-zone-regenerate self evt)
    (zone-regenerate self))
  
  
  ;; Game
  (method (on-bullet self evt)
    ;; done in process-keys
    )
  
  (method (on-arrow self evt)
    ;; done in process-keys
    )
  
  @wait
  (method (on-rapid-fire evt)
    (maybe-rapid-fire))
  
  (method (on-sprint self evt)
    ;; done in process-keys
    )
  
  (method (on-warp self evt)
    ;; done in process-keys
    )
  
  (method (on-toggle-run self evt)
    (toggle-run self))
  
  (method (on-start-dash self evt)
    (let ((me (current-controlled self)))
      (start-dash me)))
  
  (method (on-mind-control self evt)
    (mind-control self))
  
  (method (on-toggle-aim self evt)
    (toggle-aim self))
  
  (method (on-toggle-free-aim self evt)
    (toggle-free-aim self))
  
  (method (on-toggle-ride self evt)
    (toggle-ride (current-controlled self)))
  
  (method (on-toggle-fly self evt)
    (toggle-fly (current-controlled self)))
  
  (method (on-toggle-vehicle self evt)
    (toggle-vehicle (current-controlled self)))
  
  (method (on-compass-panel self evt)
    (compass-panel self))
  
  (method (on-map-panel self evt)
    (map-panel self))
  
  (method (on-combat-panel self evt)
    (combat-panel self))
  
  (method (on-character-panel self evt)
    (character-panel self))
  
  (method (on-bag-panel self evt)
    (bag-panel self))
  
  (method (on-belt-panel self evt)
    (belt-panel self))
  
  (method (on-who-panel self evt)
    (who-panel self))
  
  (method (on-chat-panel self evt)
    (chat-panel self))
  
  (method (on-command-message self evt)
    (command-message self))
  
  (method (on-command-slash self evt)
    (command-slash self))
  
  (method (on-command-previous self evt)
    (command-previous self))
  
  
  ;; Motion
  (method (on-person-motion self evt)
    (person-motion self))
  
  (method (on-orbit-motion self evt)
    (orbit-motion self))
  
  (method (on-free-motion self evt)
    (free-motion self))
  
  (method (on-toggle-camera-smoothing self evt)
    (toggle-camera-smoothing self))
  
  (method (on-toggle-camera-follow self evt)
    (toggle-camera-follow self))
  
  (method (on-toggle-cursor-track self evt)
    (toggle-cursor-track self))
  
  
  (method (on-move-forward self evt)
    ;; done in process-keys
    )
  
  (method (on-move-backward self evt)
    )
  
  (method (on-rotate-left self evt)
    )
  
  (method (on-rotate-right self evt)
    )
  
  
  ;; Edition
  (method (on-showcase self evt)
    (let ((show (get-property evt showcase:)))
      (if (not show)
          (no-showcase self)
        (toggle-showcase self show))))
  
  (method (on-delete-target self evt)
    (delete-target self))
  
  (method (on-toggle-grid self evt)
    (toggle-grid self))
  
  (method (on-toggle-grid-plane self evt)
    (toggle-grid-plane self (get-property evt plane:)))
  
  (method (on-decrease-grid self evt)
    (decrease-grid self))
  
  (method (on-increase-grid self evt)
    (increase-grid self))
  
  (method (on-reset-textures self evt)
    (reset-textures self)
    (display-message self "Textures reset"))
  
  (method (on-change-editor-mode self evt)
    (change-editor-mode self reversed?: (effective-event-reversed? self evt)))
  
  (method (on-select-target-mode self evt)
    (select-target-mode self))
  
  (method (on-move-target-mode self evt)
    (move-target-mode self))
  
  (method (on-rotate-target-mode self evt)
    (rotate-target-mode self))
  
  (method (on-scale-target-mode self evt)
    (scale-target-mode self))
  
  (method (on-skeleton-target-mode self evt)
    (skeleton-target-mode self))
  
  
  ;; History
  (method (on-toggle-paused self evt)
    (toggle-paused self))
  
  (method (on-backward-history self evt)
    (backward-history self))
  
  (method (on-forward-history self evt)
    (forward-history self))
  
  (method (on-step-backward self evt)
    (step-backward self))
  
  (method (on-step-forward self evt)
    (step-forward self))
  
  (method (on-step-over self evt)
    (step-over self))
  
  (method (on-toggle-evaluate-future self evt)
    (toggle-evaluate-future self))
  
  
  ;; Window
  (method (on-toggle-windowed-mode self evt)
    (toggle-windowed-mode self))
  
  (method (on-tile-server/clients self evt)
    (tile-server/clients self))
  
  (method (on-restore-server/clients self evt)
    (restore-server/clients self))
  
  (method (on-live-gaia/world self evt)
    (live-gaia/world self))
  
  (method (on-design-gaia/world self evt)
    (design-gaia/world self))
  
  (method (on-restore-gaia/world self evt)
    (restore-gaia/world self))
  
  (method (on-zoom-horizontally self evt)
    (zoom-horizontally self))
  
  (method (on-zoom-vertically self evt)
    (zoom-vertically self))
  
  (method (on-zoom-fullscreen self evt)
    (zoom-fullscreen self))
  
  
  (method (on-zoom-in-script self evt)
    (zoom-in-script self))
  
  (method (on-zoom-out-script self evt)
    (zoom-out-script self))
  
  (method (on-unzoom-script self evt)
    (unzoom-script self))


  ;; Debug
  (method (on-toggle-axes self evt)
    (toggle-axes self))
  
  (method (on-toggle-axes-graduation self evt)
    (toggle-axes-graduation self))
  
  (method (on-toggle-info self evt)
    (toggle-info self))
  
  (method (on-toggle-target self evt)
    (toggle-target self))
  
  (method (on-target-script self evt)
    (toggle-target-script))
  
  (method (on-view-workspace self evt)
    (view-workspace))
  
  (method (on-view-console self evt)
    (view-console))
  
  (method (on-view-script self evt)
    (view-script))
  
  (method (on-view-debugger self evt)
    (view-debugger))
  
  (method (on-view-toolbox self evt)
    (view-toolbox))
  
  (method (on-cycle-panes self evt)
    (let ((target (first-target self)))
      (if (is-not? target Entity)
          (bell)
        (cycle-panes target))))
  
  (method (on-run-selected-script self evt)
    (run-selected-script))
  
  (method (on-toggle-orientation self evt)
    (toggle-orientation self))
  
  (method (on-toggle-debug-sections self evt)
    (toggle-debug-sections (current-zone)))
  
  (method (on-toggle-debug-sectors self evt)
    (toggle-debug-sectors (current-zone)))
  
  (method (on-toggle-debug-areas self evt)
    (toggle-debug-areas (current-zone)))
  
  (method (on-toggle-draw-atlas self evt)
    (toggle-draw-atlas self))
  
  (method (on-toggle-draw-me self evt)
    (toggle-draw-me self))
  
  (method (on-change-missile-behavior self evt)
    (change-missile-behavior self reversed?: (effective-event-reversed? self evt)))
  
  (method (on-reset-marks self evt)
    (reset-all-marks (current-zone)))
  
  (method (on-clear-terminal self evt)
    (clear-terminal))
  
  (method (on-clear-console self evt)
    (if (get-controller-debugger)
        (clear-debugger-console)
      (display-error self "Not connected to a debugger")))
  
  (method (on-toggle-gc-sound self evt)
    (toggle-gc-sound self))

  (method (on-garbage-collect self evt)
    (garbage-collect self))

  (method (on-explore-interface self evt)
    (explore-interface self))
  
  (method (on-propagation-debugger self evt)
    (propagation-debugger self))
  
  (method (on-test1-script self evt)
    (test1-script))

  (method (on-test2-script self evt)
    (test2-script))

  (method (on-test3-script self evt)
    (test3-script))

  (method (on-test4-script self evt)
    (test4-script))

  (method (on-test5-script self evt)
    (test5-script))

  (method (on-test6-script self evt)
    (test6-script))

  (method (on-test7-script self evt)
    (test7-script))

  (method (on-test8-script self evt)
    (test8-script))

  (method (on-test9-script self evt)
    (test9-script))

  (method (on-test0-script self evt)
    (test0-script))
  
  
  ;; Collision
  (method protected (setup-collisions self)
    (set! evaluate-future? #f)
    (set! tick-slice? #f)
    (set-move-speed history-camera 0.05)
    (set-strafe-speed history-camera 0.02)
    (set-rotate-speed history-camera 0.02)
    (set-debug-collisions? #t)
    (display-message self "Collisions setup"))
  
  
  ;; Utility
  (method (effective-event-reversed? self evt)
    (shift-down?))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (slot evaluate-future?    initialize #t getter generate)
  (slot history-was-shown?  initialize #f getter generate)
  (slot profiler-was-shown? initialize #f getter generate)
  
  
  (method (toggle-paused self)
    (if (not (admin?))
        (unimplemented-connected self)
      (let ((tier (current-tier))
            (history (current-history)))
        (if (get-paused? history)
            (unpause-tier tier)
          (pause-tier tier)))))
  
  
  (method package (pause-world self)
    (let ((interface (current-interface+))
          (history (current-history)))
      (unless (get-paused? history)
        (pause history)
        (when (window?)
          (let ((timeline (child interface 'history))
                (profiler (child interface 'profiler)))
            (set! history-was-shown? (get-visible? timeline))
            (set! profiler-was-shown? (get-visible? profiler))
            (camera-copy! history-camera eye)
            (set-current-camera history-camera)
            (set-current-motion history-motion)
            (update-camera-parameters self)
            (unadvise-sites)
            (setup-copy-information timeline)
            (show-history self)
            (set-profiler-range #f)
            (view-sites profiler)
            (set-visible? profiler #t)
            (interface-layout self)
            (update-parameter self 'paused)))
        (add-snapshot-property 'live.paused? #t))))
  
  
  (method package (unpause-world self)
    (let ((interface (current-interface+))
          (history (current-history)))
      (when (get-paused? history)
        (when (window?)
          (camera-copy! eye history-camera)
          (set-current-camera eye)
          (set-current-motion eye-motion))
        (unpause history)
        (when (window?)
          (let ((timeline (child interface 'history))
                (profiler (child interface 'profiler)))
            (eye-behind-player self)
            (follow-player self)
            (advise-sites)
            (setup-live-information timeline)
            (if history-was-shown?
                (redraw timeline)
              (hide-history self))
            (set-profiler-range #t)
            (view-sites profiler)
            (when (not profiler-was-shown?)
              (set-visible? profiler #f))
            (interface-layout self)
            (update-parameter self 'paused)))
        (add-snapshot-property 'live.paused? #f))))
  
  
  (method package (backward-history self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (backward-history history #t))))
  
  
  (method package (forward-history self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (forward-history history #t))))
  
  
  (method package (step-backward self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (step-backward history))))
  
  
  (method package (step-forward self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (step-forward history))))
  
  
  (method package (step-over self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (step-over history))))
  
  
  (method package (recalculate-future self)
    (unimplemented-connected self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (recalculate-future history))))
  
  
  (method (update-future self)
    (let ((history (current-history)))
      (when (get-paused? history)
        (recalculate-future self))))
  
  
  (method (toggle-evaluate-future self)
    (unimplemented-connected self)
    (set! evaluate-future? (not evaluate-future?))
    (update-parameter self 'evaluate-future)
    (display-on/off self "Evaluate future" evaluate-future?))
  
  
  (method package (snapshot-metadata self entity)
    (and (snapshot-metadata? entity)
         (list entity (cache-model entity) (entity-meshes entity) (copy-matrix (get-matrix entity)))))
  
  
  ;;;
  ;;;; Action
  ;;;
  
  
  (slot commands-hook initialize #f accessors generate)
  (slot action-hook   initialize #f accessors generate)
  
  
  (method package (hook-commands self commands)
    (if commands-hook
        (commands-hook commands)
      #t))
  
  
  (method (hook-action self name arguments)
    (if action-hook
        (action-hook name arguments)
      #t))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method package (move-forward self)
    (when unbind-camera?
      (move-forward (current-motion))
      (unbind-camera)))
  
  
  (method package (move-backward self)
    (when unbind-camera?
      (move-backward (current-motion))
      (unbind-camera)))
  
  
  (method package (sprint-forward self)
    (sprint-forward (current-motion)))
  
  
  (method package (sprint-backward self)
    (sprint-backward (current-motion)))
  
  
  (method package (warp-forward self)
    (warp-forward (current-motion)))
  
  
  (method package (warp-backward self)
    (warp-backward (current-motion)))
  
  
  (method package (move-left self)
    (when unbind-camera?
      (move-left (current-motion))
      (unbind-camera)))
  
  
  (method package (move-right self)
    (when unbind-camera?
      (move-right (current-motion))
      (unbind-camera)))
  
  
  (method package (process-move-up self)
    (let ((me (current-me))
          (history (current-history)))
      (if (or (get-paused? history) (and (person-motion?) (flying? me)))
          (move-up self)
        (space self))))
  
  
  (method package (move-up self)
    (when unbind-camera?
      (move-up (current-motion))
      (unbind-camera)))
  
  
  (method package (process-move-down self)
    (move-down self))
  
  
  (method package (move-down self)
    (when unbind-camera?
      (move-down (current-motion))
      (unbind-camera)))
  
  
  (method package (process-rotate-left self)
    (if (is-moving? self)
        (move-left self)
      (rotate-left self)))
  
  
  (method package (rotate-left self)
    (when unbind-camera?
      (rotate-left (current-motion))
      (unbind-camera)))
  
  
  (method package (process-rotate-right self)
    (if (is-moving? self)
        (move-right self)
      (rotate-right self)))
  
  
  (method package (rotate-right self)
    (when unbind-camera?
      (rotate-right (current-motion))
      (unbind-camera)))
  
  
  (method package (space self)
    (let ((me (current-me+))
          (motion (current-motion)))
      (cond ((person-motion?)
             (space me commands))
            ((orbit-motion?)
             (move-up motion))
            (else
             (move-up self)))))
  
  
  ;;;
  ;;;; Game
  ;;;
  
  
  (method package (fire-aim self kind)
    (let ((me (current-controlled self)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (fire-aim me kind)))))
  
  
  (method package (maybe-fire self kind)
    (let ((me (current-controlled self)))
      (cond ((orbit-motion?))
            ((person-motion?)
             (maybe-fire me kind)))))
  
  
  (method (maybe-rapid-fire self)
    (unless (orbit-motion?)
      (rapid-fire self)))
  
  
  (method (rapid-fire self)
    (let ((me (current-controlled self)))
      (start-rapid-fire me)))
  
  
  (method package (warp self (reversed? #f))
    (if reversed?
        (warp-backward self)
      (warp-forward self)))
  
  
  (method (toggle-run self)
    (let ((me (current-controlled self)))
      (set-motion me (if (eq? (get-motion me) 'run)
                          'walk
                        'run))))
  
  
  ;;;
  ;;;; Eye
  ;;;
  
  
  (method (set-eye self camera)
    (camera-copy! eye camera))
  
  
  (method (initialize-eye self)
    (set-move-speed eye (world-setting 'world.camera-move-speed .5))
    (set-sprint-speed eye (world-setting 'world.camera-sprint-speed 1.5))
    (set-warp-speed eye (world-setting 'world.camera-warp-speed 4.))
    (set-strafe-speed eye (world-setting 'world.camera-strafe-speed .1))
    (set-rotate-speed eye (world-setting 'world.camera-rotate-speed .035)))
  
  
  (method package (prepare-motion self)
    (let ((motion (current-motion)))
      (when (is? motion Target-Motion)
        (remove-eye-occlusion motion (lens-center (motion-target motion))))))
  
  
  (method package (hook-eye self)
    (if eye-hook
        (eye-hook)
      #t))
  
  
  (method (camera-callback self stable?)
    (when (not stable?)
      (when (and render-thread (not render-trim?))
        (boost-player self)
        ;; sector priorities depend on the camera so we have to trim
        (set! render-trim? #t))))
  
  
  (method (toggle-orientation self)
    (set! orientation? (not orientation?))
    (update-parameter self 'orientation))

  
  (method package (zoom-in self)
    (zoom-in (current-motion)))
  
  
  (method package (zoom-out self)
    (zoom-out (current-motion)))
  
  
  (method (toggle-camera-smoothing self)
    (change-camera-smoothing self (not (get-camera-smoothing?)))
    (display-on/off self "Camera smoothing" (get-camera-smoothing?)))
  
  
  (method package (change-camera-smoothing self value)
    (set-camera-smoothing? value)
    (update-parameter self 'camera-smoothing))
  
  
  (method (toggle-camera-follow self)
    (let ((camera (next-element '(follow free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'follow)
        (follow-player self))
      (update-parameter self 'camera-follow)
      (display-message self (format "Camera {a}" camera))))
  
  
  (method (toggle-cursor-track self)
    (if (get-autotrack-camera?)
        (disable-autotrack self)
      (enable-autotrack self)))
  
  
  (method package (enable-autotrack self (feedback?: feedback? #t))
    (let ((window (current-window)))
      (unless (get-autotrack-camera?)
        (set-autotrack-camera? #t)
        ;; important to let mouse-moved do the
        ;; setup-cursor and the capture-cursor
        (set! track? #t)
        (set! moved? #f)
        (set-window-cursor window :cross)
        (when feedback?
          (display-message self "Track")))))
  
  
  (method package (disable-autotrack self (feedback?: feedback? #t))
    (let ((window (current-window)))
      (when (get-autotrack-camera?)
        (set-autotrack-camera? #f)
        (set-window-cursor window :arrow)
        (release-cursor window)
        (set! track? #f)
        (set! viewing? #f)
        (when feedback?
          (display-message self "Select")))))
  
  
  (method package (current-controlled self)
    (let ((me (current-me)))
      (effective-controlled me)))
  
  
  (method (current-controlled+ self)
    (let ((me (current-me+)))
      (and me (effective-controlled me))))
  
  
  (method package (follow-player self)
    (follow-player (current-motion)))
  
  
  (method package (follow-actor self actor)
    (follow-actor (current-motion) actor))
  
  
  (method package (eye-behind-player self)
    (eye-behind-player (current-motion)))
  
  
  (method package (eye-behind-actor self actor)
    (eye-behind-actor (current-motion) actor))
  
  
  (method (mark-eye self)
    (let ((zone (current-zone))
          (me (current-me)))
      (add-mark zone (new Position-Mark (lens-center me) color: red-dye))
      (add-mark zone (new Position-Mark (get-position (current-camera)) color: green-dye))
      (add-mark zone (new Position-Mark (get-target (current-camera)) color: blue-dye))))
  
  
  (method (effective-autotrack-camera? self)
    (let ((zone (current-zone)))
      (and (get-autotrack-camera?)
           (world-focused?)
           (not (top-panel))
           (not (login? zone)))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method package (is-moving? self)
    (or (effective-autotrack-camera? self)
        (and down? (or (and moving? (or (person-motion?) (free-motion?))) (not (get-independent-camera?))))))
  
  
  (method (mind-control self)
    (let ((me (current-me)))
      (let ((controlled (get-controlled me))
            (target (first-target self)))
        (if (and (is? target Actor)
                 (neq? target controlled))
            (control me target)
          (when controlled
            (relinquish-control me))))))
  
  
  (method (toggle-aim self)
    (set! aim? (not aim?))
    (update-parameter self 'aim))
  
  
  (method (toggle-free-aim self)
    (set! free-aim? (not free-aim?))
    (update-parameter self 'free-aim)
    (display-on/off self "Free aim" free-aim?))

  
  (method (draw-aim self)
    (let ((me (current-me)))
      (let ((lens (lens-center me)))
        (let ((x (vertex-x lens))
              (y (vertex-y lens))
              (z (vertex-z lens))
              (size .05)
              (width .0015))
          (render-line (vertex (- x size) y z)
                       (vertex (+ x size) y z)
                       width
                       white-dye)
          (render-line (vertex x (- y size) z)
                       (vertex x (+ y size) z)
                       width
                       white-dye)
          (render-line (vertex x y (- z size))
                       (vertex x y (+ z size))
                       width
                       white-dye)))))
  
  
  ;;;
  ;;;; Resize
  ;;;
  
  
  (method package virtual (resize-scene self)
    (when (window?)
      (let ((width (fxround width))
            (height (fxround height)))
        (resize render-target width height))
      (resize-interface self)
      (resize-sheets self)
      (resize-mainbar width height)
      (resize (current-video))))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (boost-render self)
    (when (and render-thread (not render-boost?))
      (set-render-boost? #t)
      (thread-base-priority-set! render-thread priority-boost)))
  
  
  (method (unboost-render self)
    (when render-boost?
      (set-render-boost? #f)
      (thread-base-priority-set! render-thread render-priority)))
  
  
  (method package (render-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((interface (current-interface))
          (window (current-window))
          (zone (current-zone)))
      (with-task task
        (lambda (exit)
          (set! render-thread (current-thread))
          (let (iter)
            (let ((time (current-monotonic))
                  (camera (current-camera)))
              (with-task-mutex
                (lambda ()
                  (unless (stopping? task)
                    (let ((view? (view-interface? self))
                          (valid? (sheet-valid? interface)))
                      ;; done outside of render site to
                      ;; not impact profiler measurements
                      (when (and view? (refresh-interface? self))
                        (refresh-interface self)
                        (when (and interface-shown? valid?)
                          (draw-player interface))
                        (set! interface-last-time time)
                        (set! interface-refresh? #f))
                      (site render
                        (update-stable camera camera-stable-delay)
                        (when render-trim?
                          (let ((trimmed (trim-generate 0)))
                            (when (> trimmed 0)
                              (decrease-sectors-generating zone trimmed)))
                          (set! render-trim? #f))
                        (render-frame self)
                        (site render-sync
                          (unless (and view? (not interface-shown?))
                            (render-sync window))))
                      ;; done outside of render site to
                      ;; not impact profiler measurements
                      (when (and view? (not interface-shown?))
                        (render-sheet interface)
                        (when evolution-visible?
                          (draw-evolution))
                        (when history-visible?
                          (draw-history))
                        (render-sync window))))))
              (unboost-render self)
              (let ((period (if application-active? render-period render-period-inactive))
                    (duration (- (current-monotonic) time)))
                (task-wait task period duration exit)))
            (iter))))))
  
  
  (method package (render-frame self)
    (let ((zone (current-zone)))
      (with-render-mutex
        (lambda ()
          (when post-processing?
            (preprocess-render self))
          (glClear GL_COLOR_BUFFER_BIT)
          (glClear GL_DEPTH_BUFFER_BIT)
          (render-world self)
          (render-outputs self)
          (when (and mainbar-sheet (get-visible? mainbar-sheet))
            (render-sheet mainbar-sheet))
          (render-interface self)
          (render-visualizer)
          (when post-processing?
            (postprocess-render self))
          (gl-check-error)))))
  
  
  (method protected virtual (render-outputs self)
    (let ((video (current-video)))
      (render-outputs video)))
  
  
  (method (preprocess-render self)
    (allege render-target
      (unless (get-inhibit? render-target)
        (bind-framebuffer render-target))))
  
  
  (method (postprocess-render self)
    ;; copy the render target color buffer onto the native buffer
    (allege render-target
      (unless (get-inhibit? render-target)
        (blit render-target 0)
        (unbind-framebuffer render-target))))
  
  
  (definition selection-dyes
    (list red-dye)
    @wait
    (list red-dye (dye .890 .043 .937 1.) blue-dye))
  
  
  (method (render-world self)
    (site render-world
      (let ((zone (current-zone))
            (space (current-space))
            (me (current-me+))
            (history (current-history)))
        (if (only-skybox? space)
            (let ((skybox (get-skybox zone)))
              (when skybox
                (draw-skybox skybox)))
          (when (draw-world? space)
            (draw-zone zone)
            (when (and grid? (get-draw-grid? zone))
              (draw-grid))
            (when axes?
              (draw-axes self))
            (when (and aim? free-aim?)
              (draw-aim self))
            (when (get-paused? history)
              (render-history self))
            (let ((skybox (get-skybox zone)))
              (when skybox
                (draw-skybox skybox)))
            (render-opaque)
            (render-transparent)
            (render-orb)
            ;; draw player last
            (when (and me draw-me? (show-me? space) (eq? (get-mode me) 'player))
              (reset-renderers)
              ;; aec quicky
              (let ((renderer (and (not translucent-players?) (< (dye-alpha (get-overlay me)) 1.) (get-culled-transparent-renderer))))
                (register-entity me #f renderer))
              (render-opaque)
              (render-transparent)
              (render-orb))
            (when (and target-widget (not-null? selection) (target-moveable? (cast <Element> (car selection))))
              (draw-widget target-widget))
            ;; useful for debugging
            ;; (draw-bounds me red-dye)
            ;; (draw-collision-bounds me blue-dye)
            (let (iter (scan selection) (dyes selection-dyes))
              (when (not-null? scan)
                (let ((elem <Element> (car scan)))
                  (draw-target elem (car dyes))
                  (when draw-normals?
                    (for-each (lambda (poly)
                                (draw-plane poly red-dye torus-radius: .015))
                              (element-polygons elem)))
                  (iter (cdr scan) (if (null? (cdr dyes)) dyes (cdr dyes))))))
            (when (and target-polygon (null? selection))
              (draw-polygon target-polygon red-dye)
              (when target-vertex
                (draw-polygon-vertex target-polygon target-vertex purple-dye))
              (when draw-normals?
                (draw-plane target-polygon red-dye torus-radius: .015)))
            (when (get-debug-areas? zone)
              (draw-debug-areas zone))
            (when (get-debug-sectors? zone)
              (draw-debug-sectors zone))
            (when (get-debug-sections? zone)
              (draw-debug-sections zone))
            (when orientation?
              (draw-orientation (current-camera)))
            (when (and showcase interface?)
              (draw-showcase showcase))
            (gl-check-error))))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (draw-axes self)
    ;; X
    (render-line (vertex -10.0   0.0   0.0) (vertex 10.0  0.0  0.0) .05 red-dye)
    (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0  0.5) .05 red-dye)
    (render-line (vertex  10.0   0.0   0.0) (vertex  9.5  0.0 -0.5) .05 red-dye)
    
    ;; Y
    (render-line (vertex   0.0 -10.0   0.0) (vertex  0.0 10.0  0.0) .05 green-dye)
    (render-line (vertex   0.0  10.0   0.0) (vertex  0.5  9.5  0.0) .05 green-dye)
    (render-line (vertex   0.0  10.0   0.0) (vertex -0.5  9.5  0.0) .05 green-dye)
    
    ;; Z
    (render-line (vertex   0.0   0.0 -10.0) (vertex  0.0  0.0 10.0) .05 blue-dye)
    (render-line (vertex   0.0   0.0  10.0) (vertex  0.5  0.0  9.5) .05 blue-dye)
    (render-line (vertex   0.0   0.0  10.0) (vertex -0.5  0.0  9.5) .05 blue-dye)
    
    (when axes-graduation?
      (let ((grad .15))
        ;; X
        (loop (for x <fl> from -9. to 9. by 1.)
              (render-line (vertex x (- grad) 0.0) (vertex x grad 0.0) .01 red-dye))
        
        ;; Y
        (loop (for y <fl> from -9. to 9. by 1.)
              (render-line (vertex (- grad) y 0.0) (vertex grad y 0.0) .01 green-dye))
        
        ;; Z
        (loop (for z <fl> from -9. to 9. by 1.)
              (render-line (vertex 0.0 (- grad) z) (vertex 0.0 grad z) .01 blue-dye)))))
  
  
  (method (render-history self)
    (let ((history (current-history)))
      (define (draw-now metadata)
        (bind (entity model meshes matrix) metadata
          (when (history-draw-now? entity)
            (register-ghost entity model meshes matrix 0))))
        
      (define (draw-metadata metadata)
        (bind (entity model meshes matrix) metadata
          (when (history-draw-trail? entity)
            (register-ghost entity model meshes matrix 1))))
      
      (define (draw-trail from to)
        (let (iter (n from) (count 0))
          (when (and (<= n to) (< count history-trail))
            (let ((metadata (historical-metadata history n)))
              (if (not metadata)
                  (iter (+ n 1) count)
                (draw-metadata metadata)
                (iter (+ n 1) (+ count 1)))))))
      
      (let ((now (get-now history))
            (first (history-first history))
            (last (history-last history)))
        (draw-trail first (- now 1))
        (draw-trail (+ now 1) last)
        (unless (= (get-count history) 0)
          (let ((now-metadata (historical-metadata history now)))
            (when now-metadata
              (draw-now now-metadata)))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method (view-interface? self)
    (let ((interface (current-interface)))
      (define (visible? name)
        (let ((view (child interface name)))
          (get-visible? view)))
      
      (and interface?
           (or (visible? 'info)
               (visible? 'target)
               (visible? 'compass)
               (visible? 'profiler)
               (visible? 'evolution)
               (visible? 'history)
               (refresh-interface-view)))))
  
  
  (method (refresh-interface? self)
    (let ((interface (current-interface)))
      (and interface?
           (let ((now (current-monotonic)))
             (define (visible? name)
               (let ((view (child interface name)))
                 (get-visible? view)))
             
             (and (> (- now interface-last-time) interface-refresh-rate)
                  (or (visible? 'info)
                      (visible? 'target)
                      (visible? 'compass)
                      (visible? 'profiler)
                      (visible? 'evolution)
                      (visible? 'history)
                      (refresh-interface-view))
                  (not interface-refresh?))))))
  
  
  (method package (refresh-interface self (condition: condition #f))
    (let ((interface (current-interface))
          (history (current-history)))
      (when (or (not condition)
                (some? (lambda (name)
                         (get-visible? (child interface name)))
                       condition)
                (refresh-interface-view))
        (set! interface-refresh? #t)
        (let ((info (child interface 'info)))
          (when (get-visible? info)
            (view-info info)))
        (let ((target (child interface 'target)))
          (when (get-visible? target)
            (view-target target)))
        (let ((target (child interface 'compass)))
          (when (get-visible? target)
            (refresh-compass self)))
        (let ((profiler (child interface 'profiler)))
          (when (get-visible? profiler)
            (unless (get-paused? history)
              (view-sites profiler))))
        (let ((evolution (child interface 'evolution)))
          (when (get-visible? evolution)
            (refresh-evolution)))
        (let ((history (child interface 'history)))
          (when (get-visible? history)
            (refresh-history)))
        (let ((refresh (refresh-interface-view)))
          (when (procedure? refresh)
            (refresh))
          (invalidate-view interface)))))
  
  
  (method package (render-interface self)
    (let ((interface (current-interface)))
      (when interface?
        (site render-interface
          (when interface-shown?
            (when interface-refresh?
              ;; update block at eye information
              @wait
              (target-update (current-zone) #f #f #f #t)
              (set! interface-last-time (current-monotonic))
              (set! interface-refresh? #f))
            ;; removing slots background and drawing them first is
            ;; a quick hack around slots being drawn over everything
            (draw-slots)
            (render-sheet interface)
            (when compass-visible?
              (draw-compass))
            (when map-visible?
              (draw-map))
            (when evolution-visible?
              (draw-evolution))
            (when history-visible?
              (draw-history))
            (when message
              (draw-message self))
            (when status
              (draw-status self))
            (when working?
              (draw-working self)))))))
  
  
  (method (explore-interface self)
    (set! explore-interface? (not explore-interface?))
    (when explore-interface?
      (set! interface? #t))
    (set-window-cursor (current-window) (if explore-interface? :spy :arrow)))
  
  
  (method package (refresh-compass self)
    (let ((interface (current-interface+)))
      (when (and interface compass-visible?)
        (let ((panel (child interface 'compass)))
          (set-uptodate? panel #f)))))
  
  
  (method (propagation-debugger self)
    (let ((interface (current-interface)))
      (let ((frame (find-component interface 'propagation)))
        (if frame
            (close frame)
          (let ((size propagation-size)
                (slot-size propagation-slot-size))
            (open-frame
              (new Propagation-Frame
                name: 'propagation
                size: (new Dimension (+ (* slot-size size) 1) (+ 20 (* slot-size size) 1))
                location: '(center -75))))
          (layout-view interface)))))
  
  
  (method package (close-top self)
    (define (top-close)
      (let ((interface (current-interface)))
        (find-if (lambda (obj)
                   (and (is? obj World-Panel)
                        (get-visible? obj)
                        (escape-close? obj)))
                 (get-children interface)
                 reversed?: #t)))
    
    (let ((focus (get-window-focus)))
      (if (is? focus World-Pane)
          (begin
            (leave-pane focus)
            #t)
        (let ((top (top-close)))
          (if top
              ;; quicky
              (begin
                (if (is? top Script-Panel)
                    (interface-script #f)
                  (user-close top))
                #t)
            #f)))))
  
  
  (method package (toggle-radial-menu self (name #f))
    (let ((window (current-window))
          (interface (current-interface))
          (space (current-space)))
      (unless (close-top self)
        (let ((central (child interface 'central-menu)))
          (let ((wheel (child central 'wheel))
                (radial (child central (or name 'main-menu))))
            (cond ((or (not (get-visible? central))
                       (and name (neq? radial radial-menu)))
                   (when (fade-mainbar? space)
                     (set-fade mainbar-pane #f)
                     (invalidate-view mainbar))
                   (when radial-menu
                     (set-visible? radial-menu #f))
                   (when (not name)
                     (push-panel central))
                   (set-visible? central #t)
                   (set! central-menu central)
                   (set! interface? #t)
                   (setup-visibility central)
                   (setup-visibility radial)
                   (setup-alpha wheel radial)
                   (set-visible? radial #t)
                   (set! radial-menu radial)
                   (layout-view wheel)
                   (layout-view radial)
                   (layout-view central)
                   (layout-view interface)
                   (simulate-mouse-move window)
                   (central-menu-show space))
                  (else
                   (pop-panel central-menu)
                   (set-visible? central #f)
                   (set! central-menu #f)
                   (when (and radial-menu (get-visible? radial-menu))
                     (set-visible? radial-menu #f)
                     (set! radial-menu #f))
                   (when (fade-mainbar? space)
                     (fade-mainbar (point->point$fl$ (mouse-position window)) #t))
                   (central-menu-hide space))))))))
  
  
  (method protected (main-menu self)
    (toggle-radial-menu self 'main-menu))
  
  
  (method protected (close-main-menu self)
    (when radial-menu
      (destack-panel central-menu)
      (toggle-radial-menu self (get-name radial-menu))))
  
  
  (method (video-options self)
    (push-panel (open-frame (new World-Video-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method (audio-options self)
    (push-panel (open-frame (new World-Audio-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method (interface-options self)
    (push-panel (open-frame (new World-Interface-Options size: {Dimension 466 288} location: 'center))))
  
  
  (method (view-bindings self)
    (let ((interface (current-interface)))
      (let ((frame (find-component interface 'bindings)))
        (if frame
            (if (get-visible? frame)
                (begin
                  (set-visible? frame #f)
                  (pop-panel frame))
              (update-bindings frame)
              (set-visible? frame #t)
              (push-panel frame))
          (push-panel (open-frame (new World-Bindings-Viewer name: 'bindings size: {Dimension 406 588} location: 'center)))))
      (focus-world)))
  
  
  (method (view-news self)
    (push-panel (open-world-document (news-file (current-application)) class: World-Formatted-Text-View)))
  
  
  (method (view-roadmap self)
    (push-panel (open-world-document (roadmap-file (current-application)) class: World-Formatted-Text-View)))
  
  
  (method (view-help self)
    (push-panel (open-world-document (help-file (current-application)) class: World-Formatted-Text-View)))
  
  
  (method package (open-about self (name: name #f) (title: title #f) (movable?: movable? #t) (closable?: closable? #t) (closer: closer #f) (background: background #f))
    (let ((zone (current-zone)))
      (push-panel (open-world-document (about-file (current-application)) class: World-Formatted-Text-View name: (or name 'about) title: title movable?: movable? closable?: closable? closer: closer size: (about-size zone) background: background selectable?: #f))))
  
  
  (method package (open-welcome self (exception-title: exception-title #f) (exception: exception #f) (exception-stack: exception-stack #f))
    (close-current-top self)
    (set-inhibit-paint? #t)
    (prog1 (open-welcome-zone force-welcome?: #t)
      (when (or exception-title exception)
        (report-exception exception-title exception exception-stack))
      (set-inhibit-paint? #f)))
  
  
  (method (close-current-top self)
    (let ((top (or (top-frame) (top-menu))))
      (when top
        (close top))))
  
  
  (method package (interface-layout self)
    (let ((interface (current-interface)))
      (define (layout-panel name)
        (let ((panel (find-component interface name)))
          (when panel
            (let ((layouter (get-layouter panel)))
              (when layouter
                (layouter panel))))))
      
      (for-each layout-panel '(info profiler target combat character bag belt chest chat command compass script models blocks))
      (for-each layout-panel '((replay timeline) (replay visualizer) (replay evolution)))
      (let ((panel (find-component interface 'replay)))
        (when panel
          (layout-view panel)))
      (layout-view interface)))
      
  
  (method package (sheets-layout self)
    (layout-message self)
    (layout-status self)
    (layout-working self)
    (layout-compass)
    (layout-map)
    (layout-evolution)
    (layout-history))

  
  (method (enter-press self)
    (if enter-hook
        (enter-hook)
      (command-message self)))
  
  
  (method (tab-press self)
    (when showcase
      (if (shift-down?)
          (previous-category showcase)
        (next-category showcase))))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method package (missile-hit self missile collision)
    (let ((zone (current-zone))
          (poly (get-polygon collision)))
      (let ((element (get-element poly)))
        (cond ((is? element Actor)
               (case (get-kind missile)
                 ((bullet)
                  (let ((inflictor (get-actor missile)))
                    (wound element inflictor (get-power-factor inflictor))))
                 ((arrow)
                  (explode element (get-actor missile))))
               'remove)
              (else
               (case (get-missile-behavior zone)
                 ((absorb)
                  'remove)
                 ((rebound)
                  (let ((normal (get-normal (get-plane collision)))
                        (velocity (get-velocity missile)))
                    (let ((rebound (dot-product& normal velocity)))
                      (set-velocity missile (vertex-& velocity (vertex-scalar*& normal (* 2. rebound))))))
                  'stop)
                 ((slide)
                  'slide)
                 ((destroy)
                  (let ((editable? (zone-editable? zone))
                        (destructible? (zone-destructible? zone)))
                    (define (remove element)
                      (if editable?
                          (editor-remove-element self element)
                        (remove-element self element)))
                    
                    (when (or editable? destructible?)
                      (let ((element (effective-element self poly)))
                        (let ((pos (get-position element)))
                          (case (get-kind missile)
                            ((bullet)
                             (play-3d-sound "warcraft/combat/explosion" pos)
                             (if (virtual-block? self element)
                                 (delete-block-at (current-universe) pos)
                               (remove element)))
                            ((arrow)
                             @wait
                             (if (virtual-block? element)
                                 (explose-blocks-at (current-universe) pos)
                               (play-3d-sound "warcraft/spells/ExplosiveShot" pos)
                               (remove element))))))))
                  'remove)))))))
  
  
  (method (change-missile-behavior self (reversed?: reversed? #f))
    (let ((zone (current-zone))
          (next (if reversed? previous-element next-element)))
      (unimplemented-connected self)
      (set-missile-behavior zone (next '(destroy absorb rebound slide) (get-missile-behavior zone)))
      (display-message self (format "{a}" (capitalize (symbol->string (get-missile-behavior zone)))))))
  
  
  ;;;
  ;;;; Zone
  ;;;
  
  
  (method protected (zone-reload self)
    (let ((zone (current-zone))
          (me (current-me)))
      (reset-profiler self)
      (load-reset)
      (let ((form (get-form zone))
            (path (get-path zone))
            (mode (get-mode me)))
        (let ((file (get-origin form)))
          (close zone)
          (open-zone file form: form path: path)
          (set-mode (current-me) mode)))))
  
  
  (method package (zone-regenerate self)
    (let ((zone (current-zone))
          (me (current-me)))
      (reset-profiler self)
      (load-reset)
      (iterate-regions-dir (get-dimension zone)
        (lambda (file index)
          (when (extension=? (get-extension file) "mca")
            (delete file))))
      (let ((form (get-form zone))
            (path (get-path zone))
            (mode (get-mode me)))
        (let ((file (get-origin form)))
          (close zone)
          (open-zone file form: form path: path)
          (set-mode (current-me) mode)))))
  
  
  (method package (choose-new self title prefix initial-value proc (kind: kind #f) (kind-name: kind-name #f) (exists: exists #f))
    (let ((tier (current-tier)))
      (ask-string
        title: title
        prefix: prefix
        initial-value: initial-value
        action: (lambda (base)
                  (if (not ;; quick hack
                        (if kind
                            (zone-base-available? base kind)
                          (available-zone-base? tier base)))
                      (if exists
                          (exists base proc)
                        (open-message (format "{a} {a} already exists. Do you want to replace it?" (or kind-name "Zone") base)
                                      caption: "Save"
                                      type: 'confirmation
                                      yes: "Yes"
                                      no: "No"
                                      cancel: "Cancel"
                                      execute: (lambda (evt)
                                                 (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                                       (button (get-property evt button:)))
                                                   (close dialog)
                                                   (case button
                                                     ((yes) (proc base))
                                                     ((no))
                                                     ((cancel) (signal-cancel)))))))
                    (proc base))))))
  
  
  ;;;
  ;;;; Role
  ;;;
  
  
  (method public (toggle-user self)
    (change-role self (if (eq? current-role initial-role)
                          'user
                        initial-role)))
  
  
  ;; quicky
  (hub install-zone)
  (hub uninstall-zone)
  (hub view-people)
  (method public (change-role self new-role)
    (let ((interface (current-interface))
          (zone (current-zone)))
      (let ((appl (current-application))
            ;; quicky
            (together (together:current-together))
            (space (current-space))
            (radial radial-menu)
            (bindings (find-component interface 'bindings)))
        (when radial
          (toggle-radial-menu self (get-name radial)))
        (space-deactivate space)
        (space-uninstall space)
        (uninstall-zone together)
        (uninstall-interface zone)
        (updating-actions appl
          (lambda ()
            (set-current-role new-role)
            (add-snapshot-property 'live.current-role current-role)
            (install-bindings appl)
            (install-role appl)))
        (when (eq? new-role 'user)
          (no-showcase self))
        (reset-inventory-blocks)
        (install-interface zone)
        (install-zone together)
        (space-install space)
        (space-activate space)
        (view-people together)
        (when radial
          (toggle-radial-menu self (get-name radial)))
        (when bindings
          (view-bindings self))
        (layout-interface)
        (update-parameter self 'user)
        (display-message self (capitalize (symbol->string new-role))))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (definition troposphere
    2.)
  
  (definition stratosphere
    3.)
  
  
  (method public (planet-troposphere self)
    troposphere)
  
  (method public (planet-stratosphere self)
    stratosphere)
  
  
  (method public (compute-gravity self position)
    (let ((gravity (make-vertex)))
      (vertex-copy! gravity (compute-gravity& self position))
      gravity))
  
  
  (method public (compute-gravity& self position)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (let ((gravity (vertex-copy& ambient-gravity)))
            @PLANETS
            (iterate-gravities zone
              (lambda (well)
                (let ((pos (get-position well))
                      (radius (get-radius well)))
                  (let ((direction (vertex-normalize& (vertex-& pos position)))
                        (distance (max radius (vertex-distance pos position))))
                    (let ((well-gravity (vertex-scalar*& direction (well-pull self well distance))))
                      (if (<= distance (+ radius troposphere))
                          (continuation-return return well-gravity)
                        (vertex+! gravity gravity well-gravity)))))))
            gravity)))))
  
  
  (method public (well-pull self well distance)
    (let ((mass (well-mass well)))
      (/ mass (* distance distance))))
  
  
  (method public (well-gravity self well position)
    (let ((pos (get-position well))
          (radius (get-radius well)))
      (let ((direction (vertex-normalize& (vertex-& pos position)))
            (distance (max radius (vertex-distance pos position))))
        (vertex-scalar* direction (well-pull self well distance)))))
  
  
  (method public (surface-pull self well)
    (well-pull self well (get-radius well)))
  
  
  (method public (inside-stratosphere? self well position)
    (let ((pos (get-position well))
          (radius (get-radius well)))
      (let ((distance (max radius (vertex-distance pos position))))
        (<= distance (+ radius stratosphere)))))
  
  
  ;;;
  ;;;; Planet
  ;;;
  
  
  (method public (determine-planet self pos)
    (let ((zone (current-zone)))
      (continuation-capture
        (lambda (return)
          (iterate-gravities zone
            (lambda (well)
              (when (and (is? well Planet)
                         (inside-stratosphere? self well pos))
                (continuation-return return well))))
          #f))))
  
  
  ;;;
  ;;;; Vehicle
  ;;;
  
  
  (method package (vehicle-speed self actor)
    (case (vehicle-name actor)
      ((Wheels) 13.)
      ((Hummer) 19.5)
      ((Saucer) 19.5)
      ((Rocket) 65.)
      (else (ground-speed actor))))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot editing?          <bool>   initialize #f     getter generate)
  (slot editor-mode       <object> initialize 'plane getter generate)
  (slot editor-added?     <bool>   initialize #f     getter generate)
  (slot editor-origin     <object> initialize #f     getter generate)
  (slot editor-normal     <object> initialize #f     getter generate)
  (slot editor-direction  <object> initialize #f     getter generate)
  (slot editor-floor?     <bool>   initialize #f     getter generate)
  (slot adding            <object> initialize #f     getter generate)
  (slot adding-properties <object> initialize #f     getter generate)
  (slot adding?           <bool>   initialize #f     getter generate)
  (slot deleting?         <bool>   initialize #f     getter generate)
  (slot removing?         <bool>   initialize #f     getter generate)
  (slot changing?         <bool>   initialize #f     getter generate)
  (slot mouse-run?        <bool>   initialize #f     getter generate)
  (slot widget-down       <object> initialize #f     getter generate)
  (slot widget-part       <object> initialize #f     getter generate)
  (slot grid?             <bool>   initialize #f     accessors generate)
  (slot grid-plane        <symbol> initialize 'y     getter generate)
  (slot grid-position     <fl>     initialize 0.     accessors generate)
  
  
  (method (change-editor-mode self (reversed?: reversed? #f))
    (let ((next (if reversed? previous-element next-element))
          (available-modes '(plane column free @comment crazy)))
      (let ((new-mode (next available-modes editor-mode)))
        (set! editor-mode new-mode)
        (display-message self (capitalize (->string new-mode))))))
  
  
  (method (select-target-mode self)
    (set! target-mode 'select)
    (set! target-widget #f)
    (update-target-parameters self)
    (display-message self "Select"))
  
  
  (method (move-target-mode self)
    (if (eq? target-mode 'move)
        (select-target-mode self)
      (set! target-mode 'move)
      (set! target-widget (new Mover))
      (update-target-parameters self)
      (display-message self "Move")))
  
  
  (method (rotate-target-mode self)
    (if (eq? target-mode 'rotate)
        (select-target-mode self)
      (set! target-mode 'rotate)
      (set! target-widget (new Rotater))
      (update-target-parameters self)
      (display-message self "Rotate")))
  
  
  (method (scale-target-mode self)
    (if (eq? target-mode 'scale)
        (select-target-mode self)
      (set! target-mode 'scale)
      (set! target-widget (new Scaler))
      (update-target-parameters self)
      (display-message self "Scale")))
  
  
  (method (skeleton-target-mode self)
    (if (eq? target-mode 'skeleton)
        (select-target-mode self)
      (set! target-mode 'skeleton)
      (set! target-widget (new Skeleton))
      (update-target-parameters self)
      (display-message self "Skeleton")))
  
  
  (method (update-target-parameters self)
    (update-parameter self 'select-target-mode)
    (update-parameter self 'move-target-mode)
    (update-parameter self 'rotate-target-mode)
    (update-parameter self 'scale-target-mode)
    (update-parameter self 'skeleton-target-mode))
  
  
  (method package (find-mesh-program self name)
    (or (table-ref mesh-programs name #f)
        (error "Unknown mesh program: {s}" name)))
  
  
  (method package (collect-textures self)
    (when (not textures)
      (let ((table (make-table test: equal?)))
        (iterate-assets self
          (lambda (assets)
            (iterate-entries assets
              (lambda (path)
                (when (starts-with? path "texture/")
                  (when (member? (filename-extension path) '("png" "tga") test: extension=?)
                    (let ((asset (new Asset assets path)))
                      (table-set! table (asset-path asset) asset))))))))
        (set! textures table)))
    textures)
  
  
  @find-a-better-approach-for-metadata
  (method package (collect-textures self)
    (define (add-files dir table)
      (when (exists? dir)
        (add-subdir dir table)
        (iterate-directory dir
          (lambda (subdir)
            (add-subdir subdir table))
          files?: #f
          directories?: #t)))
    
    (define (add-subdir subdir table)
      (define (load-metadata)
        (let ((file (new-file subdir ".metadata")))
          (and (exists? file)
               (let ((metadata (call-with-input-file (path-settings file) read)))
                 (assert (and (pair? metadata)
                              (pair? (cdr metadata))
                              (eq? (cadr metadata) 'textures)))
                 (cddr metadata)))))
      
      (let ((metadata (load-metadata)))
        (define (texture-metadata file)
          (and metadata
               (let ((pair (associate (get-name file) metadata test: filename=?)))
                 (and pair
                      (cdr pair)))))
        
        (iterate-directory subdir
          (lambda (file)
            (when (member? (get-extension file) '("png" "tga") test: extension=?)
              (let ((metadata (texture-metadata file)))
                (table-set! table (get-base file) (cons metadata file)))))
          files?: #t
          directories?: #f
          recursive?: #f)))
    
    (when (not textures)
      (let ((table (make-table test: equal?)))
        (iterate-assets self
          (lambda (assets)
            (when (is? assets Directory-Assets)
              (add-files (new-directory (get-directory assets) "texture") table))))
        (iterate-assets self
          (lambda (assets)
            (when (is? assets Directory-Assets)
              (add-files (new-directory (get-directory assets) "tile") table))))
        (set! textures table)))
    textures)
  
  
  (method package (reset-textures self)
    (set! textures #f))
  
  
  (method package (find-texture self name)
    (let ((textures (collect-textures self)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((is? value Asset)
               (let ((file (retrieve-file value))
                     ;; need a better approach for metadata
                     (metadata #f))
                 (let ((texture (make-file-texture file metadata: metadata)))
                   (table-set! textures name texture)
                   texture)))
              (else
               value)))))
  
  
  (method (find-texture-metadata self name (error?: error? #t))
    (let ((textures (collect-textures self)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (if error?
                   (error "Unable to find texture: {a}" name)
                 #f))
              ((pair? value)
               (car value))
              (else
               (get-metadata value))))))
  
  
  (method (find-texture-shader self name)
    (let ((metadata (find-texture-metadata self name error?: #f)))
      (and metadata
           (let ((pair (assq 'shader metadata)))
             (and pair
                  (cadr pair))))))
  
  
  (method package (find-texture-file self name)
    (let ((textures (collect-textures self)))
      (let ((value (table-ref textures name #f)))
        (cond ((not value)
               (error "Unable to find texture: {a}" name))
              ((pair? value)
               (cdr value))
              (else
               (get-file value))))))
  
  
  (method (reset-showcases self)
    (register-entity-classes #t)
    (when showcase
      (showcase-deactivate self showcase))
    (set! showcases (make-table test: eq?))
    (set! showcase (and showcase (find-showcase self (showcase-name self showcase))))
    (when showcase
      (showcase-activate self showcase))
    (unspecified))
  
  
  (method (reset-showcase self name)
    (let ((active? (and showcase (eq? (get-name showcase) name))))
      (when active?
        (showcase-deactivate self showcase))
      (table-clear showcases name)
      (when active?
        (set! showcase (find-showcase self name))
        (showcase-activate self showcase))))
  
  
  (method (set-showcase self show)
    (set! showcase show))
  
  
  (method package (no-showcase self)
    (when showcase
      (showcase-deactivate self showcase)
      (set! showcase #f)
      (refresh-target self)))
  
  
  (method package (goto-showcase self show)
    (let ((show (find-showcase self show)))
      (when showcase
        (showcase-deactivate self showcase))
      (setup show)
      (set! showcase show)
      (showcase-activate self showcase)
      (update-parameter self 'no-showcase)
      (update-parameter self 'blocks-showcase)
      (update-parameter self 'models-showcase)
      (update-parameter self 'animations-showcase)
      (update-parameter self 'shaders-showcase)
      (update-parameter self 'tiles-showcase)
      (update-parameter self 'textures-showcase)
      (update-parameter self 'skyboxes-showcase)
      (update-parameter self 'gadgets-showcase)
      (update-parameter self 'avatars-showcase)
      (update-parameter self 'meshes-showcase)
      (refresh-target self)))
  
  
  (method package (toggle-showcase self show)
    (let ((actual (showcase-name self showcase)))
      (if (eq? show actual)
          (no-showcase self)
        (goto-showcase self show))))
  
  
  (method (refresh-target self)
    (let ((interface (current-interface)))
      (let ((target (child interface 'target)))
        (when (get-visible? target)
          (view-target target)))))
  
  
  (method (showcase-activate self showcase)
    (activate showcase)
    (update-target-panel self)
    (invalidate-belt self)
    (interface-layout self)
    (reset-inventory-blocks))
  
  
  (method (showcase-deactivate self showcase)
    (deactivate showcase)
    (set! self.showcase #f)
    (update-target-panel self)
    (invalidate-belt self)
    (interface-layout self)
    (reset-inventory-blocks))
  
  
  (method package (ref-showcase self name)
    (table-ref showcases name #f))
  
  
  (method package (find-showcase self name)
    (or (table-ref showcases name #f)
        (let ((class (showcase-class self name)))
          (let ((showcase (new class name: name)))
            (table-set! showcases name showcase)
            showcase))))
  
  
  (method (showcase-class self name)
    (case name
      ((tiles) Tiles-Showcase)
      ((textures) Textures-Showcase)
      ((skyboxes) Skyboxes-Showcase)
      ((models) Models-Showcase)
      ((avatars) Avatars-Showcase)
      ((animations) Animations-Showcase)
      ((blocks) Blocks-Showcase)
      ((shaders) Shaders-Showcase)
      ((gadgets) Gadgets-Showcase)
      ((meshes) Meshes-Showcase)))
  
  
  (method package (showcase-name self showcase)
    (typecase showcase
      ((Tiles-Showcase) 'tiles)
      ((Textures-Showcase) 'textures)
      ((Skyboxes-Showcase) 'skyboxes)
      ((Models-Showcase) 'models)
      ((Avatars-Showcase) 'avatars)
      ((Animations-Showcase) 'animations)
      ((Blocks-Showcase) 'blocks)
      ((Shaders-Showcase) 'shaders)
      ((Gadgets-Showcase) 'gadgets)
      ((Meshes-Showcase) 'meshes)
      (else #f)))
  
  
  (method package (collect-models self (fullpath?: fullpath? #f))
    (let ((models (make-table test: equal?)))
      (let ((idle "_Idle"))
        (let ((b3d (add-extension idle "b3d"))
              (ms3d (add-extension idle "ms3d")))
          (iterate-assets self
            (lambda (assets)
              (iterate-entries assets
                (lambda (path)
                  (when (starts-with? path "model/")
                    (let ((name (filename-name path)))
                      (let ((kind (cond ((filename=? name b3d) 'b3d)
                                        ((filename=? name ms3d) 'ms3d)
                                        (else #f))))
                        (when kind
                          (let ((path (if fullpath? path (path->model self path))))
                            (unless (table-ref models path #f)
                              (let ((asset (new Asset assets path)))
                                (table-set! models path asset))))))))))))))
      (table-values models)))
  
  
  (method package (path->model self path)
    (let ((dirname (filename-dir path)))
      (remove-trailing #\/ (substring dirname (string-length "model/") (string-length dirname)))))
  
  
  (method package (add-model self path)
    (let ((me (current-me))
          (camera (current-camera)))
      (define (determine-position)
        (let ((pos (if (person-motion?) (vertex-& (get-position me) (vertex 0. (get-radius-y me) 0.)) (vertex-& (get-position camera) (vertex 0. 1. 0.)))))
          (vertex+ pos (vertex-scalar*& (get-sight camera) 2.))))
      
      (place-model self path (determine-position) class: Actor user-origin?: #t)))
  
  
  (method public (place-model self model position (scale: scale #f) (class: class #f) (animate?: animate? #t) (animation: animation #f) (savable?: savable? #t) (user-origin?: user-origin? #f))
    (let ((zone (current-zone)))
      (let ((scale (or scale (world-setting 'world.import-scale 1.))))
        (let ((scale (if (flonum? scale) (vertex scale scale scale) scale)))
          (let ((class (or class (get-entity-class (find-model self model)) Entity))
                (properties (list model: model scale: scale position: position animate?: animate? animation: (or animation "Idle"))))
            (let ((entity (apply new class properties)))
              (add-element zone entity)
              (when savable?
                (with-designer zone entity
                  (lambda (designer container)
                    (add-child designer entity container import: '(world.data) properties: properties))))
              (when user-origin?
                (set-selection self (list entity) user-origin?: #t))
              entity))))))
  
  
  (method package (retrieve-model-safe self asset)
    (catch (Asset-Not-Found-Error err)
      (catch (Model-Import-Error err)
        (catch (Model-Not-Found-Error err)
          (let ((file (retrieve-file asset)))
            (let ((ext (get-extension file)))
              (cond ((extension=? ext "ms3d")
                     (let ((ms3d (read-ms3d file)))
                       (retrieve-textures ms3d asset)))
                    ((extension=? ext "b3d")
                     (let ((b3d (read-b3d file)))
                       (retrieve-textures b3d asset))))))))))
  
  
  (method public (find-model-safe self path class)
    (catch (Asset-Not-Found-Error err
             (values (find-model self "warcraft/base/talktomeexclamationred") (get-message err)))
      (catch (Model-Import-Error err
               (values (find-model self "warcraft/base/talktomeexclamationred") (get-message err)))
        ;; and this is wrong wrong wrong oh so wrong to push dirt
        ;; under the rug like this. it lead to a very nasty bug to
        ;; debug: the dwarfmale was not being found on the processor
        ;; and so it was being replaced by Orb and because the client
        ;; had the correct model there was no way to know that something
        ;; was wrong but buggy collision detection behaviors that
        ;; turned out to be very difficult to debug
        (catch (Model-Not-Found-Error err
                 (values (find-model self "warcraft/base/talktomeexclamationblue") (get-message err)))
          (values (find-model self path class: class) #f)))))
  
  
  (method public (find-model self path (class: class #f) (error?: error? #t))
    (define (search-assets)
      (continuation-capture
        (lambda (return)
          (iterate-assets self
            (lambda (assets)
              (let ((info (search-in assets)))
                (when info
                  (continuation-return return info)))))
          (values #f #f))))
    
    (define (search-in assets)
      (let ((dirpath (string-append "model/" path "/"))
            (idle "_Idle"))
        (define (try ext import)
          (let ((model-path (add-extension (string-append dirpath idle) ext)))
            (and (contains-file? assets model-path)
                 (let ((metadata-name (filename-name path))
                       (metadata-path (string-append dirpath ".model")))
                   (let ((asset (new Asset assets model-path))
                         (metadata-asset (new Asset assets metadata-path)))
                     (let ((file (retrieve-file asset))
                           (metadata (and (contains-file? assets metadata-path) (load-model-metadata metadata-name (retrieve-file metadata-asset)))))
                       (values file (import asset metadata: metadata class: class))))))))
        
        (or (try "b3d" import-b3d)
            (try "ms3d" import-ms3d))))
    
    (if (symbol? path)
        (registered-model path)
      (or (table-ref models path #f)
          (bind-values (file model) (search-assets)
            (if (not model)
                (if (not error?)
                    #f
                  (signal (new Model-Not-Found-Error message: (format "Unable to find model: {a}" path))))
              (set-file model file)
              (table-set! models path model)
              model)))))
  
  
  (method package (reset-models self)
    (set! models (make-table test: equal?)))
  
  
  (method (collect-events self)
    (let ((queue (new-queue)))
      (for-each (lambda (partition)
                  (bind (kind . assets) partition
                    (when (contains-directory? assets "event")
                      (let ((events '()))
                        (let ((events-dir (retrieve-directory assets "event")))
                          (iterate-directory events-dir
                            (lambda (path kind)
                              (unless (member? (last path) '(".DS_Store" "README") test: filename=?)
                                (set! events (cons (new Asset assets (append '("event") path)) events))))
                            full?: #f
                            files?: #t
                            directories?: #f
                            recursive?: #t))
                        (for-each (lambda (event)
                                    (enqueue queue event))
                                  (sort di<? events key: get-path))))))
                  (partition-assets self))
      (queue-list queue)))
  
  
  (method (find-event self path)
    (find (collect-events self) path test: equal? key: asset-path return: 'item))
  
  
  (method package (launch-event self path)
    (let ((script (find-event self path)))
      (when script
        ;; quick hack to always reload
        (unregister-asset script)
        (run-asset-script script))))
  
  
  (method (select/run-script self)
    (let ((interface (current-interface)))
      (let ((panel (find-type interface Script-Run)))
        (if panel
            (close panel)
          (open-frame (new Script-Run size: {Dimension 366 588} location: 'center))))))
  
  
  (method (run-last-script self)
    (if (not last-script)
        (select/run-script self)
      (run-script self last-script)))
  
  
  (method package (collect-scripts self)
    (let ((queue (new-queue)))
      (for-each (lambda (partition)
                  (bind (kind . assets) partition
                    (when (contains-directory? assets "script")
                      (let ((scripts '()))
                        (let ((scripts-dir (retrieve-directory assets "script")))
                          (iterate-directory scripts-dir
                            (lambda (path kind)
                              (unless (member? (last path) '(".DS_Store" "README") test: filename=?)
                                (set! scripts (cons (new Asset assets (append '("script") path)) scripts))))
                            full?: #f
                            files?: #t
                            directories?: #f
                            recursive?: #t))
                        (for-each (lambda (script)
                                    (enqueue queue script))
                                  (sort di<? scripts key: get-path))))))
                  (partition-assets self))
      (queue-list queue)))
  
  
  (method package (partition-scripts self scripts)
    (partition scripts key: (lambda (asset)
                              (let ((path (get-path asset)))
                                (if (> (length path) 2)
                                    (cadr path)
                                  "")))
      test: filename=?))
  
  
  (method package (find-script self path)
    (find (collect-scripts self) path test: equal? key: asset-path return: 'item))
  
  
  (method package (find-script-no self no)
    (let ((path (case no
                  ((1) (world-setting 'world.test1-script "test/test1"))
                  ((2) (world-setting 'world.test2-script "test/test2"))
                  ((3) (world-setting 'world.test3-script "test/test3"))
                  ((4) (world-setting 'world.test4-script "test/test4"))
                  ((5) (world-setting 'world.test5-script "test/test5"))
                  ((6) (world-setting 'world.test6-script "test/test6"))
                  ((7) (world-setting 'world.test7-script "test/test7"))
                  ((8) (world-setting 'world.test8-script "test/test8"))
                  ((9) (world-setting 'world.test9-script "test/test9"))
                  ((0) (world-setting 'world.test0-script "test/test0"))
                  (else (error "Unknown script no: {s}" no)))))
      (find-script self path)))
  
  
  (method package (run-script self script)
    ;; quick hack to always reload
    (unregister-asset script)
    (run-asset-script script)
    (set! last-script script))
  
  
  (method package (execute-script self path (synchronous?: synchronous? #f))
    (let ((script (find-script self path)))
      (if (not script)
          (display-message self (format "Unable to find script {a}" path))
        ;; quick hack to always reload
        (unregister-asset script)
        (run-asset-script script synchronous?: synchronous?))))
  
  
  (method (toggle-grid self)
    (set! grid? (not grid?))
    (update-parameter self 'grid))
  
  
  (method (toggle-grid-plane self plane)
    (if (and grid? (eq? grid-plane plane))
        (set! grid? #f)
      (set! grid? #t)
      (set! grid-plane plane))
    (update-parameter self 'grid))
  
  
  (method (decrease-grid self)
    (move-grid-by self -1))
  
  
  (method (increase-grid self)
    (move-grid-by self 1))
  
  
  (cond-expand
    (cocoa
      (method (move-grid self delta)
        (move-grid-by self (fxround/ (- delta) 5))))
    (else
     (method (move-grid self delta)
       (move-grid-by self (fxround/ (- delta) 120)))))
  
  
  (method (move-grid-by self incr)
    (let ((dist incr))
     (increase! grid-position dist)
     (display-status self (format "Grid at {a}" grid-position))))
  
  
  (method (effective-element self poly)
    (let ((zone (current-zone)))
      (or (get-element poly)
          (bind-values (id variant-id) (decode-id/variant-id (get-data1 poly))
            (let ((block (id/variant-id->block id variant-id)))
              (create-block-entity zone (get-name block) (polygon-position poly)))))))
  
  
  (method (virtual-block? self elem)
    (and (is? elem Block-Entity)
         (not (get-parent elem))))
  
  
  (method protected virtual (floor-level self)
    (and grid? (eq? grid-plane 'y) grid-position))
    
  
  ;; editor-mouse-down
  ;; editor-mouse-move
  ;; editor-mouse-up
  ;; - editor-add / action 'add
  ;;   - editor-add-at
  ;;     - editor-add-element
  ;;       - add-element-class
  ;; - editor-remove
  ;; - editor-change

  
  (method (editor-add self mode class grid? grid-plane grid-position position direction stage)
    (let ((zone (current-zone)))
      (case stage
        ((down move)
         (editor-add-at self mode class grid? grid-plane grid-position position direction))
        ((up)
         (editor-up self)))))
  
  
  (method (editor-add-at self mode class grid? grid-plane grid-position position direction)
    (let ((zone (current-zone))
          (me (current-me+)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-direction) 0.) vertex-x)
                                ((/= (vertex-y editor-direction) 0.) vertex-y)
                                ((/= (vertex-z editor-direction) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& center editor-origin)) editor-normal))))))
        
        (define (free-filter poly)
          (let ((normal (get-normal poly)))
            (vertex=? normal editor-normal)))
        
        (and editor-added?
             (case mode
               ((plane) (plane-filter))
               ((column) column-filter)
               ((free) free-filter)
               ((crazy) #f))))
      
      (define (add-at origin normal poly)
        (define (collision-quad origin normal)
          (let ((inside (vertex+ origin (vertex-scalar* normal -.01))))
            (let ((cube (unit-cube inside)))
              (ray-closest-cuboid-inner-quad inside normal cube))))
        
        (define (determine-anchor element origin normal)
          (let ((bounds (transformed-bounds element)))
            (let ((radiuses (cuboid-radiuses bounds)))
              (cond ((float-near? (vertex-y normal) 1.)
                     origin)
                    ((float-near? (vertex-y normal) -1.)
                     (vertex- origin (vertex 0. (cuboid-height bounds) 0.)))
                    (else
                     (vertex+ (vertex- origin (vertex 0. .5 0.))
                              (vertex-scalar* normal (if (/= (vertex-x normal) 0.)
                                                         (vertex-x radiuses)
                                                       (vertex-z radiuses)))))))))
        
        (define (determine-anchor/position element origin normal)
          (if (is? class Block-Entity)
              (values origin origin)
            (let ((anchor (determine-anchor element origin normal)))
              (let ((position (anchor->position element anchor)))
                (values anchor position)))))
        
        (define (determine-polygon)
          (if (and (is? class Block-Entity) (not poly))
              (let ((closest (collision-quad origin normal)))
                (and closest
                     (bind (quad dist) closest
                       (let ((origin (get-origin quad))
                             (normal (vertex-scalar* (get-normal quad) -1.)))
                         (values (vertex+ origin (vertex-scalar*& normal .5)) normal)))))
            (values origin normal)))
        
        (let ((info (determine-polygon)))
          (when info
            (bind-values (origin normal) info
              (when (or (not editor-added?) (vertex=? normal editor-direction))
                (let ((player? (eq? class 'player)))
                  (unless player?
                    (instantiate-element-class self class))
                  (let ((element (if player? me adding)))
                    (when player?
                      (trek-change element))
                    (bind-values (anchor position) (determine-anchor/position element origin normal)
                      (let ((actual (if (is? class Block-Entity)
                                        (or (not (id? (block-at zone position) Air Water StationaryWater Lava StationaryLava))
                                            (element-near zone position))
                                      (element-near zone position))))
                        (unless actual
                          (if player?
                              (begin
                                (set-position me position)
                                (unless (person-motion?)
                                  (set-lookat me (get-lookat (current-camera))))
                                (follow-player self)
                                (unless (person-motion?)
                                  (person-motion self feedback?: #f))
                                #f)
                            (let ((added (editor-add-element self mode class poly anchor)))
                              (if editor-added?
                                  (add-target self added)
                                (set! editor-added? #t)
                                (set! editor-origin (if poly (get-center poly) origin))
                                (set! editor-normal (if poly (get-normal poly) normal))
                                (set! editor-direction normal)
                                (set! editor-floor? (not poly))
                                (set-selection self (list added))) 
                              added))))))))))))
      
      (let ((filter (determine-filter)))
        (let ((poly-closest (ray-closest-polygon position direction view-radius filter: filter ignore-non-physical?: #f ignore-players?: #t water-filter: (if (and (is? class Block-Entity) (eq? (get-model class) 'LilyPad)) only-water-filter liquid-filter)))
              (grid-closest (and (or (not editor-added?) (memq? mode '(free crazy)) (and editor-floor? (neq? mode 'column)))
                                 (bind-values (vert normal) (ray-grid-intersection self position direction grid? grid-plane grid-position)
                                   (and vert
                                        (cons vert normal))))))
          (let ((poly-distance (and poly-closest (second poly-closest)))
                (grid-distance (and grid-closest (vertex-distance position (car grid-closest)))))
            (if (and poly-closest (or (not grid-closest) (<= poly-distance grid-distance)))
                (bind (poly distance) poly-closest
                  (if (is? class Block-Entity)
                      (with-polygon-interaction (current-universe) poly
                        (lambda (poly block fore)
                          (add-at fore (get-normal poly) poly)))
                    (let ((element (get-element poly))
                          (normal (get-normal poly)))
                      (let ((target (vertex+ position (vertex-scalar* direction view-radius)))
                            (lookat (get-lookat (current-camera)))
                            (radiuses (vertex .001 .001 .001)))
                        (bind-values (new-position new-direction collisions) (collide&stop$ position target lookat radiuses max-distance: view-radius polygon-filter: filter ignore-entities?: #t ignore-players?: #t)
                          (when (not-null? collisions)
                            (let ((coll (car collisions)))
                              (let ((plane (get-plane coll)))
                                (add-at (get-origin plane) (get-normal plane) poly)))
                            (free-collisions$ collisions)))))))
              (when grid-closest
                (bind (vert . normal) grid-closest
                  (let ((normal (if (and (is? class Block-Entity)
                                         (get-flat? (cache-model class)))
                                    (vertex-negate normal)
                                  normal)))
                    (add-at vert normal #f))))))))))
  
  
  (method (editor-add-element self mode class poly anchor)
    (let ((zone (current-zone))
          (universe (current-universe)))
      (if (is? class Block-Entity)
          (let ((pos anchor)
                (block (name->block (get-name (cache-model class)))))
            (add-block-at universe poly pos block)
            (create-block-entity zone (get-name block) pos))
        (let ((element adding)
              (name #f)
              (position (anchor->position adding anchor))
              (lookat (make-standard-lookat))
              (scale (get-scale adding))
              (color (get-color adding))
              (properties adding-properties))
          (add-element universe #f element name position lookat scale color #f #f properties)
          (update-future self)
          (set! adding #f)
          (set! adding-properties #f)
          element))))
  
  
  (method (instantiate-element-class self class)
    (define (instantiate class/new (properties '()))
      (let ((elem (if (procedure? class/new) (class/new) (apply new class/new properties))))
        (set! adding elem)
        (set! adding-properties properties)))
    
    (define (instantiate-block block)
      (set! adding (new Block-Entity model: (get-name (cache-model block))))
      (set! adding-properties #f))
    
    (define (instantiate-entity entity)
      (let ((model (cache-model entity)))
        (let ((class (or (get-entity-class model) (class-of entity))))
          (let ((properties (registered-gadget class)))
            (if properties
                (let ((properties (properties)))
                  (instantiate (lambda ()
                                 (new class))
                               properties))
              (let ((model (or (get-model entity) (and model (get-name model))))
                    (meshes-mask (get-meshes-mask entity))
                    (animation (get-animation entity))
                    (animate? (get-animate? entity))
                    (queue (new-queue)))
                (define (enqueue-if property value (default #f))
                  (when (neq? value default)
                    (enqueue queue property)
                    (enqueue queue value)))
                
                (enqueue-if model: model)
                (enqueue-if meshes-mask: meshes-mask)
                (enqueue-if animation: animation)
                (enqueue-if animate?: animate?)
                (instantiate (lambda ()
                               (new class model: model))
                             (queue-list queue))))))))
    
    (when (not adding)
      (typecase class
        ((Block-Entity)
         (instantiate-block class))
        ((Entity)
         (instantiate-entity class))
        (else
         (case class
           ((block) (instantiate Block-Entity)))))))
  
  
  (method (editor-remove self mode position direction stage)
    (let ((zone (current-zone)))
      (define (determine-filter)
        (define (plane-filter)
          (let ((accessor (cond ((/= (vertex-x editor-normal) 0.) vertex-x)
                                ((/= (vertex-y editor-normal) 0.) vertex-y)
                                ((/= (vertex-z editor-normal) 0.) vertex-z))))
            (lambda (poly)
              (let ((normal (get-normal poly)))
                (and editor-normal
                     (vertex=? normal editor-normal)
                     (or (not editor-origin)
                         (= (accessor (get-center poly)) (accessor editor-origin))))))))
        
        (define (column-filter poly)
          (let ((normal (get-normal poly)))
            (and (vertex=? normal editor-normal)
                 editor-origin
                 (let ((center (get-center poly)))
                   (or (vertex=? center editor-origin)
                       (vertex=? (vertex-normalize& (vertex-& editor-origin center)) editor-normal))))))
        
        (case mode
          ((plane) (plane-filter))
          ((column) column-filter)
          ((free) #f)))
      
      (case stage
        ((down)
         (let ((closest (ray-closest-polygon position direction view-radius ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
           (when closest
             (bind (poly distance) closest
               (let ((element (effective-element self poly)))
                 (when element
                   (let ((center (get-center poly))
                         (normal (get-normal poly)))
                     (editor-remove-element self element)
                     (set! editor-origin center)
                     (set! editor-normal normal))))))))
        ((move)
         (when editor-origin
           (let ((closest (ray-closest-polygon position direction view-radius filter: (determine-filter) ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
             (when closest
               (bind (poly distance) closest
                 (let ((element (effective-element self poly)))
                   (when element
                     (editor-remove-element self element))))))))
        ((up)
         (set! editing? #f)
         (set! removing? #f)
         (set! editor-added? #f)
         (set! editor-origin #f)
         (set! editor-normal #f)
         (set! editor-direction #f)))))
  
  
  (method (editor-delete self position)
    (let ((zone (current-zone)))
      (if (zone-editable? zone)
          (let ((element #f @convert^^^ (element-at zone position)))
            (when element
              (editor-remove-element self element)
              (set-modified? zone #t)))
        (warn-non-editable self))))
  
  
  (method (editor-remove-element self elem)
    (let ((universe (current-universe)))
      (if (virtual-block? self elem)
          (delete-block-at universe (get-position elem))
        (remove-element universe #f elem))
      (update-future self)))
  
  
  (method package (remove-element self elem)
    (let ((zone (current-zone)))
      (remove-element zone elem)
      (when (memq? elem selection)
        (remove-target self elem))))
  
  
  (method (delete-target self)
    (let ((zone (current-zone))
          (history (current-history)))
      (define (delete)
        (for-each (lambda (elem)
                    (unless (is? elem Player)
                      (cond ((get-paused? history)
                             (editor-delete self (get-position elem)))
                            (else
                             ;; quicky copy-pasted from editor-delete
                             (editor-remove-element self elem)
                             (set-modified? zone #t)))))
                  selection))
      
      (let ((selection (collect-if (lambda (elem)
                                     (is-not? elem Spawn))
                                   selection)))
        (when (not-null? selection)
          (if (some? get-script selection)
              (push-panel
                (open-message (if (= 1 (length selection))
                                  "Entity has a script. Delete anyways?"
                                "Some entities have scripts. Delete anyways?")
                              caption: "Delete"
                              type: 'question
                              yes: "Yes"
                              no: "No"
                              execute: (lambda (evt)
                                         (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                               (button (get-property evt button:)))
                                           (close dialog)
                                           (case button
                                             ((yes)
                                              (delete)))))))
            
            (delete))))))
  
  
  (method (editor-change self position direction stage)
    (case stage
      ((down move)
       (let ((class (editor-element-class self)))
         (when class
           (let ((to-block? (is? class Block-Entity)))
             (let ((closest (ray-closest-polygon position direction view-radius ignore-non-physical?: #f ignore-entities?: to-block? ignore-players?: #t)))
               (when closest
                 (bind (poly distance) closest
                   (let ((element (effective-element self poly)))
                     (let ((element-block? (is? element Block-Entity)))
                       (when (or (and element-block? to-block?)
                                 (and (not element-block?) (not to-block?)))
                         (change-class self element class)))))))))))
      ((up)
       (set! editing? #f)
       (set! changing? #f))))
  
  
  (method (change-class self element class)
    (let ((zone (current-zone))
          (universe (current-universe)))
      (let ((anchor (position->anchor element (get-position element))))
        (if (virtual-block? self element)
            (let ((pos (get-position element))
                  (block (name->block (get-name (cache-model class)))))
              (let ((id (get-id block)))
                (unless (if (get-generic? (id->block id))
                            (equal? (block/data-at zone pos) (cons id (get-variant-id block)))
                          (= (block-at zone pos) id))
                  (updating-sections zone
                    (lambda (add-section)
                      (delete-block-at-updating universe pos add-section)
                      (add-block-at-updating universe #f pos block add-section))))))
          (editor-remove-element self element)
          (instantiate-element-class self class)
          (editor-add-element self editor-mode class #f anchor)))))
  
  
  (method (editor-add-class self)
    (if (shift-down?)
        'player
      (editor-element-class self)))
  
  
  (method (editor-element-class self)
    (let ((interface (current-interface)))
      (if showcase
          (and (selection-addable? showcase)
               (get-selection showcase))
        (let ((slot (selected-slot (child interface 'belt))))
          (let ((id (get-id slot)))
            (and id (block-id? id)
              (new Block-Entity model: (get-name (id/durability->block id (get-durability slot))))))))))
  
  
  (method (mouse-change self h v)
    (let ((zone (current-zone))
          (camera (current-camera)))
      (if (zone-editable? zone)
          (unless (user?)
            (bind-values (position direction) (screen->world camera h v)
              (editor-change self position direction 'down)
              (set! editing? #t)
              (set! changing? #t)))
        (warn-non-editable self))))
  
  
  (method (mouse-add self h v)
    (let ((zone (current-zone))
          (camera (current-camera))
          (history (current-history)))
      (let ((player? (shift-down?)))
        (if (or (zone-editable? zone)
                player?)
            (unless (or (user?) (and player? (not (admin?))))
              (bind-values (position direction) (screen->world camera h v)
                (let ((class (editor-add-class self)))
                  (when class
                    (editor-add self editor-mode class grid? grid-plane grid-position position direction 'down)
                    (set! editing? #t)))))
          (warn-non-editable self)))))
  
  
  (method (mouse-remove self h v)
    (let ((zone (current-zone))
          (camera (current-camera)))
      (if (zone-editable? zone)
          (unless (user?)
            (bind-values (position direction) (screen->world camera h v)
              (editor-remove self editor-mode position direction 'down)
              (set! editing? #t)
              (set! removing? #t)))
        (warn-non-editable self))))
  
  
  (method (editor-mouse-down self h v)
    (let ((camera (current-camera)))
      (let ((control? (control-down?))
            (alt? (alt-down?))
            (shift? (shift-down?)))
        (cond ((and control? alt? (not shift?))
               (mouse-change self h v))
              (control?
               (mouse-add self h v))
              (alt?
               (mouse-remove self h v))
              (else
               (when target-widget
                 (bind-values (position direction) (screen->world camera h v)
                   (let ((closest (ray-closest-widget position direction target-widget)))
                     (when closest
                       (bind (poly distance) closest
                         (bind (widget . part) (get-element poly)
                           (set! widget-down widget)
                           (set! widget-part part)
                           (widget-mouse-down widget-down h v))))))))))))
  
  
  (method (editor-mouse-move self h v)
    (let ((camera (current-camera))
          (history (current-history)))
      (when editing?
        (cond (removing?
               (bind-values (position direction) (screen->world camera h v)
                 (editor-remove self editor-mode position direction 'move)))
              (changing?
               (bind-values (position direction) (screen->world camera h v)
                 (editor-change self position direction 'move)))
              (else
               (let ((player? (shift-down?)))
                 (unless player?
                   (bind-values (position direction) (screen->world camera h v)
                     (let ((class (editor-add-class self)))
                       (when class
                         (editor-add self editor-mode class grid? grid-plane grid-position position direction 'move)))))))))))
  
  
  (method (editor-mouse-up self h v)
    (let ((zone (current-zone))
          (camera (current-camera))
          (history (current-history))
          (universe (current-universe)))
      (bind-values (position direction) (screen->world camera (get-h down-point) (get-v down-point))
        (if editing?
            (when (zone-editable? zone)
              (cond (removing?
                     (editor-remove self editor-mode position direction 'up))
                    (changing?
                     (editor-change self position direction 'up))
                    (else
                     (let ((class (editor-add-class self)))
                       (when class
                         (editor-add self editor-mode class grid? grid-plane grid-position position direction 'up))))))
          (let ((origin (get-position (current-camera))))
            (let ((closest (ray-closest-polygon origin direction view-radius ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #f ignore-me?: #t)))
              (if (not closest)
                  (begin
                    (reset-selection self user-origin?: #t)
                    (focus-world))
                (bind (poly distance) closest
                  (let ((element (effective-element self poly))
                        (vertex (ray/distance-closest-vertex poly origin direction distance))
                        (shift? (shift-down?)))
                    (define (select)
                      (if shift?
                          (if (member? element selection test: (~ target=? self))
                              (remove-target self element user-origin?: #t)
                            (add-target self element polygon: poly vertex: vertex user-origin?: #t))
                        (set-selection self (list element) polygon: poly vertex: vertex user-origin?: #t)
                        (focus-world)))
                    
                    (if (not shift?)
                        (unless (mouse-up universe h v)
                          (if double-click?
                              (double-click universe h v)
                            (select)))
                      (select)))))))))
      (editor-up self)))
  
  
  (method (editor-up self)
    (set! editing? #f)
    (set! adding? #f)
    (set! deleting? #f)
    (set! removing? #f)
    (set! changing? #f)
    (set! editor-added? #f)
    (set! editor-origin #f)
    (set! editor-normal #f)
    (set! editor-direction #f)
    (set! editor-floor? #f)
    (set! adding #f)
    (set! adding-properties #f))
  
  
  (method protected virtual (warn-non-editable self)
    (let ((zone (current-zone)))
      (unless (get-editable-warned? zone)
        (set-editable-warned? zone #t)
        (open-message "Zone is not editable"
                      caption: "Edition"
                      type: 'message
                      execute: (lambda (evt)
                                 (let ((dialog (find-ascendant (get-sender evt) World-Dialog)))
                                   (close dialog)))))))
  
  
  ;;;
  ;;;; Change
  ;;;
  
  
  ;; quick hack
  (method package (class->class-name self class)
    (category-name class))
  
  
  ;; quick hack
  (method package (class-name->class self class-name)
    (case class-name
      ((Sphere) Sphere)
      ((Spawner) Spawner)
      ((Wolf) Wolf)
      ((Spider) Spider)
      ((Jumper) Jumper)
      ((Creature) Creature)
      ((Missile) Missile)
      ((Actor) Actor)
      ((Point-Light) Point-Light)
      ((Directional-Light) Directional-Light)
      ((Ambient-Light) Ambient-Light)
      ((Gravity) Gravity)
      @bazoo
      ((Circle-Stone) Circle-Stone)
      (else Entity)))
  
  
  ;;;
  ;;;; Grid
  ;;;
  
  
  (method package (ray-grid-intersection self position direction grid? grid-plane grid-position)
    (let ((zone (current-zone)))
      (define (perspective->world normal distance)
        (let ((norm-direction-dot-product (dot-product normal direction)))
          (and (not (and (= norm-direction-dot-product 0.)
                         (case grid-plane
                           ((x) (= (vertex-x position) grid-position))
                           ((y) (= (vertex-y position) grid-position))
                           ((z) (= (vertex-z position) grid-position)))))
               (let ((intersect (/ (- distance (dot-product normal position))
                                   norm-direction-dot-product)))
                 (and (> intersect 0.)
                      (let ((point (vertex+ position (vertex-scalar*& direction intersect))))
                        (if (> norm-direction-dot-product 0.)
                            (values point grid-position (vertex-negate normal))
                          (values point grid-position normal))))))))
      
      (if (not grid?)
          (values #f #f)
        (case grid-plane
          ((x) (let ((info (perspective->world (vertex 1. 0. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         pos
                                         (vertex-y vert)
                                         (vertex-z vert)))
                             normal)))))
          ((y) (let ((info (perspective->world (vertex 0. 1. 0.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         pos
                                         (vertex-z vert)))
                             normal)))))
          ((z) (let ((info (perspective->world (vertex 0. 0. 1.) grid-position)))
                 (if (not info)
                     (values #f #f)
                   (bind-values (vert pos normal) info
                     (values (and vert (vertex
                                         (vertex-x vert)
                                         (vertex-y vert)
                                         pos))
                             normal)))))))))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (method package (first-target self)
    (and (not-null? selection) (first selection)))
  
  
  (method package (set-selection self sel (polygon: polygon #f) (vertex: vertex #f) (user-origin?: user-origin? #f))
    (when (window?)
      (let ((interface (current-interface))
            (zone (current-zone)))
        (when (not-null? selection)
          (deactivate-target (first selection)))
        (set! selection sel)
        (set! target-polygon polygon)
        (set! target-vertex vertex)
        (target-updated selection polygon vertex)
        (target-update zone selection polygon vertex)
        (invalidate-view interface)
        ;; quick try see below
        (when (null? sel)
          (reset-edited-entity))
        ;; quick hack to not have the script panel close
        ;; but this hack will stop editing script of a block
        (let ((only-block? (and (= 1 (length sel)) (is? (car sel) Block-Entity))))
          @w(unless only-block?
            (if (null? sel)
                (restore-edited-entity)
              (reset-edited-entity)))
          (update-color-panel self)
          (update-target-panel self)
          @w(unless only-block?
            (update-script-panel)))
        (when (not-null? selection)
          (activate-target (first selection)))
        (refresh-interface self condition: '(info target)))))
  
  
  (method package (reset-selection self (user-origin?: user-origin? #f))
    (set-selection self '() user-origin?: user-origin?))
  
  
  (method package (shutdown-selection self)
    (set! selection '())
    (set! target-polygon #f)
    (set! target-vertex #f)
    (set! target-mode #f)
    (set! target-widget #f))
  
  
  (method (selection=? self sx sy)
    (and (= (length sx) (length sy))
         (every? (~ target=? self)
                 sx
                 sy)))
  
  
  (method (target=? self x y)
    (if (and (is? x Block-Entity)
             (is? y Block-Entity))
        (vertex=? (get-position x) (get-position y))
      (equal? x y)))
  
  
  (method (add-target self elem (polygon: polygon #f) (vertex: vertex #f) (user-origin?: user-origin? #f))
    (set-selection self (append! selection (list elem)) polygon: polygon vertex: vertex user-origin?: user-origin?))
  
  
  (method (remove-target self elem (user-origin?: user-origin? #f))
    (let ((new-selection (remove elem selection test: (~ target=? self))))
      (set-selection self new-selection user-origin?: user-origin?)))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method package (x-rays-mode? self)
    (and x-rays? (not x-rays-category)))
  
  
  (method (toggle-x-rays self)
    (cond ((x-rays-mode? self)
           (set! x-rays? #f)
           (set! x-rays-category #f))
          (else
           (set! x-rays? #t)
           (set! x-rays-category #f)))
    (update-parameter self 'x-rays)
    (display-on/off self "X-rays" x-rays?))
  
  
  (method package (redstone-x-rays-mode? self)
    (and x-rays? (eq? x-rays-category 'redstone)))
  
  
  (method (toggle-redstone-x-rays self)
    (cond ((redstone-x-rays-mode? self)
           (set! x-rays? #f)
           (set! x-rays-category #f))
          (else
           (set! x-rays? #t)
           (set! x-rays-category 'redstone)))
    (update-parameter self 'redstone-x-rays)
    (display-on/off self "Redstone X-rays" x-rays?))
  
  
  (method (toggle-draw-blocks self)
    (set! draw-blocks? (not draw-blocks?))
    (update-parameter self 'blocks)
    (display-on/off self "Draw blocks" draw-blocks?))
  
  
  (method (toggle-draw-models self)
    (set! draw-entities? (not draw-entities?))
    ;(update-parameter 'models)
    (display-on/off self "Draw models" draw-entities?))
  
  
  ;;;
  ;;;; Changes
  ;;;
  
  
  (method package (update-changes self changes)
    (update-models self changes))
  
  
  (method (update-models self changes)
    (let ((zone (current-zone)))
      (let ((models-reload (make-table test: equal?))
            (models-showcase? #f))
        (define (update-model what path rest)
          (let ((name (filename-name path))
                (path (path->model self path)))
            (when (or (filename=? name "_Idle.b3d")
                      (filename=? name "_Idle.ms3d"))
              (table-set! models-reload path #t)
              (when (or (eq? what 'added)
                        (eq? what 'removed))
                (set! models-showcase? #t)))
            (when (table-ref models path #f)
              (table-set! models-reload path #t))))
        
        (define (maybe-reload-model entity path)
          (when (equal? (get-model entity) path)
            (reload-model entity)))
        
        (for-each (lambda (change)
                    (bind (what path . rest) change
                      (when (starts-with? path "model/")
                        (update-model what path rest))))
                  changes)
        (when (> (table-length models-reload) 0)
          (let ((showcase (ref-showcase self 'models)))
            (let ((entities (get-entities zone))
                  (showcase-entities (and showcase (cache-elements showcase))))
              (iterate-table models-reload
                (lambda (path ignore)
                  (table-clear models path)
                  (for-each (lambda (entity)
                              (maybe-reload-model entity path))
                            entities)
                  (when showcase-entities
                    (loop (for entity in-vector showcase-entities)
                          (maybe-reload-model entity path))))))
            (when (and models-showcase? showcase)
              (reset-showcase self 'models)))))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (slot evaluate-hooks <object> initialize '() getter generate)
  
  
  (method (register-evaluate-hook self proc)
    (set! evaluate-hooks (cons proc evaluate-hooks)))
  
  
  (method (unregister-evaluate-hook self proc)
    (set! evaluate-hooks (remove! proc evaluate-hooks)))
  
  
  (method package (evaluate-world-hook self forms syntax str container line col)
    (let ((interface (current-interface))
          (zone (current-zone)))
      (evaluate-zone-hook zone forms syntax str container line col)
      (when (or (search container "shaders")
                (search str "baked-light"))
        (reload-programs self str)
        (target-update zone selection target-polygon target-vertex))
      @test
      (when (search str "read-b3d")
        (let ((entities (get-entities zone))
              (reloaded '()))
          (for-each (lambda (entity)
                      (let ((model (get-model-cache entity)))
                        (when model
                          (let ((file (get-file model)))
                            (when (and file (extension=? (get-extension file) "b3d"))
                              (reload-model entity)
                              (set! reloaded (cons model reloaded)))))))
                    entities)
          (let ((count (length reloaded)))
            (when (> count 0)
              (display-status self (if (= count 1)
                                       (format "Model {a} reloaded" (car reloaded))
                                     (format "{a} models reloaded" count)))))))
      @test
      (when (search container "procedural")
        (increase-revision (get-generator zone))
        (reset-selection))
      (when evaluate-future?
        (update-future self))
      (for-each (lambda (proc)
                  (proc forms syntax str container line col))
                evaluate-hooks)
      @test
      (update-world-options (current-application))
      @test
      (install-skins (current-application))
      @test
      (install-bindings (current-application))
      (invalidate-view interface)
      (when (developer?)
        (set-uptodate? (child interface 'evolution) #f)
        (set-uptodate? (child interface 'history) #f))
      (render-scene (current-window))))
  
  
  (method (reload-programs self str)
    (cond ((or (search str "block")
               (search str "model")
               (search str "baked-light")
               (search str "mesh-header-fs")
               (search str "mesh-main-fs")
               (search str "build-mesh-fs"))
           (reload-block-programs self)
           (reload-model-programs self))
          ((search str "frame")
           (reload-frame-programs self))
          (else
           (reload-transformation-programs self)
           (reload-other-programs self))))
  
  
  (method (reload-block-programs self)
    (build-mesh-shaders)
    (build-block-shaders)
    (relink-program self 'block)
    (relink-program self 'wet-block))
  
  
  (method (reload-model-programs self)
    (build-mesh-shaders)
    (build-model-shaders)
    (relink-program self 'model))
  
  
  (method (reload-frame-programs self)
    (build-frame-shaders)
    (relink-program self 'wireframe)
    (relink-program self 'squareframe)
    (relink-program self 'playerframe)
    (relink-program self 'floorframe))
  
  
  (method (reload-transformation-programs self)
    (build-transformation-shaders)
    (relink-program self 'radial-blur)
    (relink-program self 'motion-blur)
    (relink-program self 'water)
    (relink-program self 'julia)
    (relink-program self 'sierpinski)
    (relink-program self 'multitexture)
    (relink-program self 'kaleidoscope)
    (relink-program self 'tunnel)
    (relink-program self 'square-tunnel)
    (relink-program self 'fly)
    (relink-program self 'pulse))
  
  
  (method (reload-other-programs self)
    (build-occlusion-shaders)
    (relink-program self 'occlusion))
  
  
  (method (relink-program self name)
    (let ((program (find-mesh-program self name)))
      (relink program)))
  
  
  ;;;
  ;;;; GC
  ;;;
  
  
  (definition memory-site
    (register-site '(memory) '() '(kind: memory)))
  
  
  (method (setup-gc self)
    (proclaim (not check bounds))
    (add-gc-interrupt-job!
      (lambda ()
        (when gc-sound?
          (gc-sound))
        (when gc-trace?
          (terminal 'garbage-collect (last-gc-real-time)))
        ;; simulate call
        (let ((chronology (current-chronology)))
          (define (add-entries)
            (let ((running (last-gc-real-time))
                  (content (get-content chronology))
                  (id <fx> (get-id memory-site))
                  ;; dummy thread so all gc calls end up together in the profiler
                  (thread -1.)
                  (marker (next-marker! chronology))
                  (seconds (current-seconds)))
              ;; start
              (let ((index (index-now chronology)))
                (f64vector-set! content index (cast <fl> id))
                (f64vector-set! content (+ index 1) (cast <fl> marker))
                (f64vector-set! content (+ index 2) (- seconds running))
                (f64vector-set! content (+ index 3) 0.)
                (f64vector-set! content (+ index 4) thread)
                (advance! chronology))
              ;; end
              (let ((index (index-now chronology)))
                (f64vector-set! content index (cast <fl> id))
                (f64vector-set! content (+ index 1) (cast <fl> (+ marker 1)))
                (f64vector-set! content (+ index 2) seconds)
                (f64vector-set! content (+ index 3) 0.)
                (f64vector-set! content (+ index 4) thread)
                (advance! chronology))))
          
          (let ((mutex (get-mutex chronology)))
            (if (eq? (mutex-state mutex) (current-thread))
                (add-entries)
              (mutex-lock! mutex)
              (add-entries)
              (mutex-unlock! mutex))))
        ;; record event
        (record-event udp-id-garbage-collect
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.))))
  
  
  (cond-expand
    (windows
     (definition (gc-sound)
       (MessageBeep MB_ICONINFORMATION)))
    (cocoa
     (definition (gc-sound)
       (play-sound "Submarine" volume: .25)))
    (else
     (definition (gc-sound)
       (bell))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (slot previous-mouses initialize '())
  
  
  (method (effective-playable? self)
    (let ((zone (current-zone))
          (me (current-me)))
      (or (eq? (get-mode me) 'player)
          (login? zone))))
  
  
  (method package virtual (mouse-down self h v (double? #f))
    (let ((me (current-me)))
      (when (effective-playable? self)
        (set! down? #t)
        (set! down-point (new Point h v))
        (set! double-click? double?)
        (set! previous-mouses '())
        (if (and showcase (in-showcase? showcase v))
            (begin
              (set! showcase-down? #t)
              (showcase-mouse-down showcase h v))
          (when (eq? (get-mode me) 'player)
            (editor-mouse-down self h v))))))
  
  
  (method package virtual (mouse-moved self x y)
    (define (setup-cursor)
      (set! last-point (new Point$fl$ x y))
      (set! last-time (current-monotonic)))
    
    (define (move-camera)
      (define (scalarproduct a <Point$fl$> b <Point$fl$>) <fl>
        (+ (* (get-h a) (get-h b)) (* (get-v a) (get-v b))))
      
      (let ((new-point (new Point$fl$ x y))
            (new-time (current-monotonic)))
        (movecamera self new-point new-time last-point last-time previous-mouses)
        @wait
        (let ((poschange (nu- new-point last-point))
              (elapse (- new-time last-time)))
          (let ((delta (if (null? previous-mouses)
                           poschange
                         (let ((dirchange (if (null? (cdr previous-mouses)) -1. (scalarproduct poschange (nu- last-point (caadr previous-mouses))))))
                           (let ((ponderation (if (and (< (norm poschange) 5.)
                                                       (>= dirchange 0.))
                                                  .5
                                                1.)))
                             (bind (furthest-point . furthest-time) (last previous-mouses)
                               (nu+ (nu* (nu- new-point furthest-point) (* (/ elapse (- new-time furthest-time)) (- 1. ponderation)))
                                    (nu* poschange ponderation))))))))
            (let ((dx (get-h delta))
                  (dy (get-v delta)))
              (mouse-track elapse dx dy))))
        (set! last-point new-point)
        (set! last-time new-time)
        (when (get-camera-smoothing?)
          (let ((max-moves 5))
            (set! previous-mouses (cons (cons new-point new-time) previous-mouses))
            (when (> (length previous-mouses) max-moves)
              (set-cdr! (tail previous-mouses (- max-moves 1)) '()))))))
    
    (let ((window (current-window))
          (space (current-space))
          (history (current-history))
          (me (current-me)))
      (mouse-moved space x y)
      (when (effective-playable? self)
        (let ((h (fxround x))
              (v (fxround y)))
          (cond (showcase-down?
                 (showcase-mouse-drag showcase h v))
                ;; adding a test for last-point is a quick hack until major cleanup
                ((and (get-cursor-captured? window) last-point)
                 (move-camera)
                 (unless (or (is-moving? self) (get-paused? history))
                   (follow-player self)))
                (widget-down
                 (widget-mouse-move widget-down h v))
                (editing?
                 (editor-mouse-move self h v))
                ((effective-autotrack-camera? self)
                 (setup-cursor)
                 (capture-cursor window)
                 (move-camera))
                ((or (and down? (not (near? (new Point h v) down-point drag-tolerance))) track?)
                 (set! viewing? #t)
                 (setup-cursor)
                 (capture-cursor window)))))))
  
  
  (method package virtual (mouse-track self elapse dx dy)
    (let ((space (current-space))
          (me (current-controlled+ self))
          (motion (current-motion))
          (camera (current-camera))
          (history (current-history)))
      (unless (mouse-track space elapse dx dy)
        (cond ((and (is-moving? self) (person-motion?))
               (let ((sight (copy-vertex (get-sight camera)))
                     (up (copy-vertex (get-up camera)))
                     (right (copy-vertex (get-right camera)))
                     (first? (not moved?)))
                 (track-actor motion me dx dy sight up right first?)
                 (boost-player self)
                 (set! moved? #t)))
              (else
               (when unbind-camera?
                 (track-camera motion dx dy)
                 (unbind-camera)))))))
  
  
  (method package virtual (mouse-up self h v)
    (let ((window (current-window))
          (me (current-me)))
      (if (not (effective-playable? self))
          (focus-world)
        (if mouse-run?
            (begin
              (set! viewing? #f)
              (set! moving? #t)
              (set! mouse-run? #f))
          (cond (showcase-down?
                 (showcase-mouse-up showcase h v)
                 (set! showcase-down? #f))
                ((get-cursor-captured? window)
                 (release-cursor window)
                 (follow-player self))
                (widget-down
                 (widget-mouse-up widget-down h v)
                 (set! widget-down #f)
                 (set! widget-part #f))
                (else
                 (when down?
                   (if (user?)
                       (begin
                         (mouse-up (current-space) h v)
                         (focus-world))
                     (when (eq? (get-mode me) 'player)
                       (editor-mouse-up self h v))))))
          (set! down? #f)
          (set! down-point #f)
          (set! viewing? #f)))))
  
  
  (method package virtual (double-click self h v)
    (let ((me (current-me)))
      (when (effective-playable? self)
        (cond ((and showcase (in-showcase? showcase v))
               (showcase-double-click showcase h v))
              (else
               (mouse-down self h v #t))))))
  
  
  (method package virtual (right-mouse-down self h v)
    (let ((me (current-me)))
      (when (eq? (get-mode me) 'player)
        (set! down? #t)
        (set! down-point (new Point h v))
        (set! previous-mouses '())
        (set! moving? #t)
        (set! moved? #f))))
  
  
  (method package virtual (right-mouse-up self h v)
    (let ((window (current-window))
          (me (current-me))
          (motion (current-motion))
          (universe (current-universe)))
      
      (when (eq? (get-mode me) 'player)
        (if mouse-run?
            (begin
              (set! viewing? #t)
              (set! moving? #f)
              (set! mouse-run? #f))
          (reset-roll motion me)
          (unless (get-cursor-captured? window)
            (if (or (user?) (let ((elem (interaction-element universe h v)))
                              (or (and (is? elem Block-Entity)
                                       (get-right-mouse (name->block (get-name (cache-model elem)))))
                                  (is? elem Actor))))
                (right-mouse-up universe h v)
              (mouse-add self h v)
              (editor-up self)))
          (set! down? #f)
          (set! down-point #f)
          (set! moving? #f)
          (set! mouse-run? #f)
          (release-cursor window)))))
  
  
  (method package (mouse-wheel self h v delta)
    (let ((interface (current-interface))
          (me (current-me)))
      (when (eq? (get-mode me) 'player)
        (let ((d (if (shift-down?) (get-h delta) (get-v delta))))
          (cond ((and grid? (alt-down?))
                 (move-grid self d))
                ((xor (shift-down?) (world-setting 'world.wheel-zoom? #t))
                 (cond ((> d 0)
                        (zoom-in self))
                       ((< d 0)
                        (zoom-out self))))
                (showcase
                 (showcase-wheel showcase (> d 0)))
                (else
                 (cycle-selection (child interface 'belt) d)))))))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  ;; left+right mouse run
  (method (process-mouse-run self)
    (when (and application-active?
               world-mouse-down?
               world-right-mouse-down?
               (null? (modifiers-keys)))
      (unless mouse-run?
        (set! mouse-run? #t)
        (mouse-track self 0. 0. 0.))
      (move-forward self)))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method (process-keys self)
    (site process-keys
      (when application-active?
        (let ((me (current-me)))
          (when (eq? (get-mode me) 'player)
            ;; to optimize by using modifiers-mask
            (let ((modifiers (modifiers-keys)))
              (iterate-keys
                (lambda (shortcut proc)
                  (when (and (equal? (get-modifiers shortcut) modifiers)
                             (let ((key (get-key shortcut)))
                               (or (eqv? key ongoing-key)
                                   (key-down? (if (char? key)
                                                  key
                                                (symbolic-key->code key))))))
                    (proc self))))))))))
  
  
  (method package virtual (process-shortcut self shortcut)
    (if (shortcut=? shortcut {Shortcut Escape})
        (if escape-hook
            (escape-hook)
          (main-menu self))
      #f))
  
  
  (method package virtual (key-down self c)
    )
  
  
  (method package virtual (key-press self key)
    )
  
  
  (method package virtual (key-up self c)
    )
  
  
  ;;;
  ;;;; Sound
  ;;;
  
  
  (method (toggle-sound self)
    (set-sounds? (not sounds?))
    (update-parameter self 'sound)
    (display-on/off self "Sound" sounds?))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method package (unimplemented-connected self)
    (unless (world-setting 'world.allow-connected? #f)
      (display-cancel self "Unimplemented when connected")))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method (tile-server/clients self)
    (tile (current-tier)))
  
  
  (method (restore-server/clients self)
    (restore (current-tier)))
  
  
  ;;;
  ;;;; Live
  ;;;
  
  
  (method package (live-gaia/world self)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error self "Not connected to a remote debugger")
        (let ((debuggee (load-object (get-local-register 'debugging) 'world.debuggee 'world-debuggee))
              (debugger (load-object (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (live-gaia/world debugger debuggee)))))
  
  
  (method package (design-gaia/world self)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error self "Not connected to a remote debugger")
        (let ((debuggee (load-object (get-local-register 'debugging) 'world.debuggee 'world-debuggee))
              (debugger (load-object (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (design-gaia/world debugger debuggee)))))
  
  
  (method package (restore-gaia/world self)
    (let ((controller-debugger (get-controller-debugger)))
      (if (not controller-debugger)
          (display-error self "Not connected to a remote debugger")
        (let ((debuggee (load-object (get-local-register 'debugging) 'world.debuggee 'world-debuggee))
              (debugger (load-object (get-remote-register controller-debugger) 'gaia.debugger 'gaia-debugger)))
          (restore-gaia/world debugger debuggee)))))
  
  
  ;;;
  ;;;; Zoom
  ;;;
  
  
  (method (zoom-horizontally self)
    (set-setting options-settings 'world.script-horizontal? (not (world-setting 'world.script-horizontal? #f)))
    (save-content options-settings)
    (update-background (get-manager (child (current-interface) 'script)))
    (interface-layout self))
  
  
  (method (zoom-vertically self)
    (set-setting options-settings 'world.script-vertical? (not (world-setting 'world.script-vertical? #f)))
    (save-content options-settings)
    (update-background (get-manager (child (current-interface) 'script)))
    (interface-layout self))
  
  
  (method (zoom-fullscreen self)
    (set-setting options-settings 'world.script-fullscreen? (not (world-setting 'world.script-fullscreen? #f)))
    (save-content options-settings)
    (update-background (get-manager (child (current-interface) 'script)))
    (interface-layout self))
  
  
  (method (zoom-in-script self)
    (script-zoom-in))
  
  
  (method (zoom-out-script self)
    (script-zoom-out))
  
  
  (method (unzoom-script self)
    (script-unzoom))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (toggle-interface self)
    (set! interface? (not interface?))
    (focus-world)
    (update-parameter self 'interface))
  
  
  (method (toggle-occlusion self (force? #f))
    (set-wireframe? #f)
    (let ((occlusion? (or (not (get-occlusion?)) force?)))
      (set-occlusion? occlusion?)
      (set-override-renderer (and occlusion? (get-occlusion-renderer)))
      (set-block-program self (find-mesh-program self (if occlusion? 'occlusion 'block)))
      (update-parameter self 'occlusion)
      (update-parameter self 'wireframe)))
  
  
  (method (toggle-wireframe self (force? #f))
    (set-occlusion? #f)
    (let ((wireframe? (or (not (get-wireframe?)) force?)))
      (set-wireframe? wireframe?)
      (set-override-renderer (and wireframe? (get-wireframe-renderer)))
      (set-block-program self (find-mesh-program self (if wireframe? 'wireframe 'block)))
      (update-parameter self 'occlusion)
      (update-parameter self 'wireframe)))
  
  
  (method (toggle-polygon-mode self)
    (set! polygon-mode (ecase polygon-mode
                         ((GL_POINT) GL_LINE)
                         ((GL_LINE) GL_FILL)
                         ((GL_FILL) GL_POINT)))
    (glPolygonMode GL_FRONT_AND_BACK polygon-mode))
  
  
  (method (toggle-fog self)
    (set-fog? (not fog?))
    (reload-block-programs self)
    (update-parameter self 'fog)
    (display-on/off self "Fog" fog?))
  
  
  (method package (toggle-windowed-mode self)
    (let ((window (current-window)))
      (toggle-windowed-mode window)))
  
  
  (method (toggle-post-processing self)
    (change-post-processing self (not post-processing?))
    (display-on/off self "Post processing" post-processing?))
  
  
  (method package (change-post-processing self value)
    (set! post-processing? value)
    (update-parameter self 'post-processing))
  
  
  (method package (person-motion self (eye-center?: eye-center? #t) (feedback?: feedback? #t))
    (when unbind-camera?
      (unless (person-motion?)
        (set! eye-motion (make-person-motion self eye #f))
        (set-current-motion eye-motion)
        (when eye-center?
          (eye-center-player eye-motion))
        (update-camera-parameters self)
        (unbind-camera)
        (when feedback?
          (display-message self "First person")))))
  
  
  (method (orbit-motion self (feedback?: feedback? #t))
    (when unbind-camera?
      (unless (orbit-motion?)
        (set! eye-motion (make-orbit-motion self eye #f))
        (set-current-motion eye-motion)
        (orbit-behind eye-motion (motion-target eye-motion))
        (update-camera-parameters self)
        (unbind-camera)
        (when feedback?
          (display-message self "Orbit around")))))
  
  
  (method package (free-motion self (feedback?: feedback? #t))
    (when unbind-camera?
      (unless (free-motion?)
        (set! eye-motion (make-free-motion self eye))
        (set-current-motion eye-motion)
        (update-camera-parameters self)
        (unbind-camera)
        (when feedback?
          (display-message self "Free camera")))))
  
  
  (method (update-camera-parameters self)
    (update-parameter self 'person-motion)
    (update-parameter self 'orbit-motion)
    (update-parameter self 'free-motion))
  
  
  (method package (effective-draw-gadgets? self)
    (or draw-gadgets? (is? showcase Gadgets-Showcase)))
  
  
  (method (toggle-draw-gadgets self)
    (set! draw-gadgets? (not draw-gadgets?))
    (update-gadgets self)
    (update-parameter self 'gadgets)
    (display-on/off self "Draw gadgets" draw-gadgets?))
  
  
  (method (toggle-draw-normals self)
    (set! draw-normals? (not draw-normals?))
    (update-parameter self 'normals)
    (display-on/off self "Draw normals" draw-normals?))
  
  
  (method (toggle-draw-atlas self)
    (if texture-arrays?
        (display-error self "No atlas")
      (set! draw-atlas? (not draw-atlas?))
      (update-parameter self 'draw-atlas)
      (display-on/off self "Draw atlas" draw-atlas?)))
  
  
  (method (toggle-draw-me self)
    (set! draw-me? (not draw-me?))
    (update-parameter self 'draw-me)
    (display-on/off self "Draw me" draw-me?))
  
  
  (method package (update-gadgets self (draw-gadgets? (effective-draw-gadgets? self)))
    (when (not draw-gadgets?)
      (for-each (lambda (elem)
                  (when (is? elem Gadget)
                    (remove-target self elem)))
                selection)))
  
  
  (method (toggle-axes self)
    (set! axes? (not axes?))
    (update-parameter self 'axes)
    (display-on/off self "Axes" axes?))
  
  
  (method (toggle-axes-graduation self)
    (set! axes-graduation? (not axes-graduation?))
    (display-on/off self "Axes graduation" axes-graduation?))
  
  
  (method (toggle-info self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'info)))
        (set-visible? panel (not (get-visible? panel)))
        (when (get-visible? panel)
          (bring-to-front panel)
          (set! interface? #t)))
      (update-parameter self 'info)))
  
  
  (method (toggle-profiler self)
    (let ((interface (current-interface))
          (history (current-history)))
      (let ((panel (child interface 'profiler)))
        (let ((visible? (not (get-visible? panel))))
          (unless (get-paused? history)
            (when visible?
              (reset-profiles)
              (reset-trackings)
              (reset-chronology)))
          (set-visible? panel visible?)
          (set-force-generate-acquire-task-mutex? visible?)
          (when visible?
            (bring-to-front panel)
            (set! interface? #t))))
      (update-parameter self 'profiler)))
  
  
  (method (reset-profiler self)
    (reset-chronology))
  
  
  (method (toggle-evolution self)
    (when (developer?)
      (if evolution-visible?
          (hide-evolution self)
        (show-evolution self))))
  
  
  (method (show-evolution self)
    (when (developer?)
      (set! evolution-visible? #t)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'evolution)))
          (bring-to-front panel)
          (refresh-evolution)
          (set-visible? panel #t))
        (update-parameter self 'evolution))))
  
  
  (method (hide-evolution self)
    (when (developer?)
      (set! evolution-visible? #f)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'evolution)))
          (set-visible? panel #f))
        (update-parameter self 'evolution))))
  
  
  (method (toggle-history self)
    (when (developer?)
      (if history-visible?
          (hide-history self)
        (show-history self))))
  
  
  (method (show-history self)
    (when (developer?)
      (set! history-visible? #t)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'history)))
          (bring-to-front panel)
          (refresh-history)
          (set-visible? panel #t))
        (update-parameter self 'history))))
  
  
  (method (hide-history self)
    (when (developer?)
      (set! history-visible? #f)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'history)))
          (set-visible? panel #f))
        (update-parameter self 'history))))
  
  
  (method (all-chronology self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'history)))
        (when (get-visible? panel)
          (set-all-chronology? (not all-chronology?))
          (redraw panel)))))
  
  
  (method (update-color-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'color)))
        (set-visible? panel (some? (lambda (element)
                                     (is? element Light))
                                   selection)))))
  
  
  (method (toggle-target self)
    (set! interface-target? (not interface-target?))
    (update-target-panel self)
    (update-parameter self 'target))
  
  
  (method package (update-target-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'target)))
        (if (not interface-target?)
            (set-visible? panel #f)
          (set-visible? panel (or (not-null? selection)
                                  (and showcase (get-selection showcase))))))))
  
  
  (method (compass-panel self)
    (if compass-visible?
        (hide-compass self)
      (show-compass self)))
  
  
  (method package (show-compass self)
    (set! compass-visible? #t)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'compass)))
        (set-uptodate? panel #f)
        (set-visible? panel #t))))
  
  
  (method package (hide-compass self)
    (set! compass-visible? #f)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'compass)))
        (set-visible? panel #f))))
  
  
  (method (map-panel self)
    (let ((zone (current-zone)))
      (when (is? (get-generator zone) World-Generator)
        (set! map-visible? (not map-visible?))
        (let ((interface (current-interface)))
          (let ((panel (child interface 'map)))
            (set-visible? panel map-visible?))))))
  
  
  (method (combat-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'combat)))
        (set-visible? panel (not (get-visible? panel))))))
  
  
  (method (character-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'character)))
        (if (get-visible? panel)
            (hide-character self)
          (show-character self)))))
  
  
  (method package (show-character self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'character)))
        (unless (get-visible? panel)
          (set-visible? panel #t)
          (view-inventory panel)
          (set! interface? #t)
          (update-parameter self 'character-panel)))))
  
  
  (method package (hide-character self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'character)))
        (when (get-visible? panel)
          (set-visible? panel #f)
          (save-inventory)
          (update-parameter self 'character-panel)))))
  
  
  (method package (crafting-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'crafting)))
        (if (get-visible? panel)
            (hide-crafting self)
          (show-crafting self)))))
  
  
  (method (show-crafting self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'crafting)))
        (unless (get-visible? panel)
          (set-visible? panel #t)
          (show-belt self)
          (show-bag self blocks?: #f)
          (hide-chest self)
          (set! interface? #t)))))
  
  
  (method (hide-crafting self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'crafting)))
        (when (get-visible? panel)
          (set-visible? panel #f)
          (hide-bag self)))))
  
  
  (method (bag-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'bag)))
        (if (get-visible? panel)
            (hide-bag self)
          (show-bag self)))))
  
  
  (method package (show-bag self (blocks?: blocks? #t))
    (let ((interface (current-interface)))
      (let ((panel (child interface 'bag)))
        (unless (get-visible? panel)
          (set-visible? panel #t)
          (view-inventory panel)
          (set! interface? #t)
          (update-parameter self 'bag-panel)
          (when (and blocks? (not (user?)))
            (goto-showcase self 'blocks))))))
  
  
  (method package (hide-bag self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'bag)))
        (when (get-visible? panel)
          (save-inventory)
          (set-visible? panel #f)
          (hide-crafting self)
          (update-parameter self 'bag-panel)
          (no-showcase self)))))
  
  
  (method (belt-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'belt)))
        (if (get-visible? panel)
            (hide-belt self)
          (show-belt self)))))
  
  
  (method (show-belt self)
    (let ((panel (child (current-interface) 'belt)))
      (set-visible? panel #t)))
  
  
  (method (hide-belt self)
    (let ((panel (child (current-interface) 'belt)))
      (set-visible? panel #f)))
  
  
  (method (who-panel self)
    (let ((interface (current-interface)))
      (let ((panel (find-type interface Who-Panel)))
        (if panel
            (close panel)
          (open-frame (new Who-Panel size: {Dimension 200 400} location: 'center))))))
  
  
  (method (chat-panel self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'chat)))
        (if (get-visible? panel)
            (set-visible? panel #f)
          (set-visible? panel #t)))))
  
  
  ;; quicky
  (hub chat-message)
  (method (command-message self)
    (let ((together (together:current-together)))
      ;; quicky
      (chat-message together)))
  
  
  ;; quicky
  (hub chat-slash)
  (method package (command-slash self)
    (let ((together (together:current-together)))
      ;; quicky
      (chat-slash together)))
  
  
  ;; quicky
  (hub chat-previous)
  (method package (command-previous self)
    (let ((together (together:current-together)))
      ;; quicky
      (chat-previous together)))
  
  
  ;; quicky
  (hub show-chat/command)
  (method package (show-chat-message self sender kind message)
    (let ((together (together:current-together)))
      (show-chat/command together))
    (let ((interface (current-interface)))
      (let ((panel (child interface 'chat)))
        (show-message panel sender kind message))))
  
  
  (method package (chat-show self message)
    (show-chat-message self #f 'show message))
  
  
  (method package (chat-problem self message)
    (show-chat-message self #f 'problem message))
  
  
  (method package (hide-command self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'command)))
        (set-visible? panel #f)
        (focus-world)
        (interface-layout self))))
  
  
  (method (invalidate-belt self)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'belt)))
        (when (get-visible? panel)
          (invalidate-view panel)))))
  
  
  (method package (show-chest self section data)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'chest)))
        (set-visible? panel #t)
        (hide-crafting self)
        (view-chest panel section data)
        (set! interface? #t))))
  
  
  (method package (hide-chest self)
    (let ((interface (current-interface)))
      (save-chest)
      (let ((panel (child interface 'chest)))
        (set-visible? panel #f))))
  
  
  (method package (update-parameter self name)
    (let ((interface (current-interface+)))
      (when interface
        (let ((view (parameter-view self name)))
          ;; YOWNU
          (when view
            (invalidate-view view))))))


  (method (parameter-view self name)
    (let ((interface (current-interface+)))
      (and interface
           (let ((parameter (registered-parameter name)))
             (define (find-view)
               (continuation-capture
                 (lambda (return)
                   (define (find-in bar)
                     (when (is? bar World-Actionbar)
                       (for-each (lambda (button)
                                   (when (and (is? button World-Parameter-Button)
                                              (eq? (get-parameter button) name))
                                     (continuation-return return button)))
                                 (get-children bar))))
                   
                   (find-in radial-menu)
                   (for-each find-in (get-children interface))
                   (when mainbar
                     (find-in mainbar))
                   #f)))
             
             (or (get-view parameter)
                 (let ((view (find-view)))
                   (if (not view)
                       #f
                       @YOWNU
                       (error "Unable to find view: {a}" name)
                     (set-view parameter view)
                     view)))))))
  
  
  (method package (display-on/off self title flag)
    (display-message self (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method package (display-message self msg (font: font #f) (color: color #f) (duration: duration #f))
    (assert (or (string? msg)
                (and (pair? msg)
                     (every? string? msg))))
    (set! message msg)
    (set! message-font font)
    (set! message-color color)
    (set! message-duration duration)
    (set! message-time (current-monotonic)))
  
  
  (method package (clear-message self)
    (set! message #f)
    (set! message-time #f))
  
  
  (method package (layout-message self)
    (let ((window (current-window)))
      (let ((world-width (get-width window))
            (world-height (get-height window)))
        (let ((h (center (get-width message-sheet) world-width))
              (v (draw-message-offset self)))
          (set-position message-sheet (new Point h v))))))
  
  
  (method (draw-message self)
    (let ((elapse (- (current-monotonic) message-time))
          (duration (or message-duration 1.)))
      (let ((fade duration)
            (done (+ duration 1.)))
        (if (> elapse done)
            (begin
              (set! message #f)
              (set! message-time #f))
          (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f))
                (multiline? (pair? message)))
            (let ((surface (get-surface (get-texture message-sheet)))
                  (font (or message-font (if multiline? {Font Message-Small} {Font Message})))
                  (incr (if multiline? 24 30))
                  (color (or message-color {Color World-Message}))
                  (first (if multiline? (car message) message))
                  (all (if multiline? message (list message))))
              (clear surface)
              (set-font surface font)
              (let ((color (if (not alpha)
                               color
                             (let ((color (copy-object color #f)))
                               (set-alpha color alpha)
                               color)))
                    (shadow-color (if (not alpha)
                                      {Color Black}
                                    (let ((color (copy-object {Color Black} #f)))
                                      (set-alpha color alpha)
                                      color)))
                    (h (center (text-width font first) (get-width message-sheet)))
                    (v 10))
                (for-each (lambda (message)
                            (draw-text surface h v message color shadow-color: shadow-color)
                            (increase! v incr))
                          all))
              (flush surface)
              (map-texture (get-texture message-sheet))
              (render-sheet message-sheet)))))))
  
  
  (method protected virtual (draw-message-offset self)
    80)
  
  
  (method protected virtual (draw-working-offset self)
    120)
  
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method package (display-error self msg (duration: duration 5.))
    (display-message self msg color: {Color Red} duration: duration))
  
  
  (method package (display-cancel self msg (duration: duration #f))
    (display-message self msg color: {Color Red} duration: duration)
    (signal-cancel))
  
  
  (method package (display-walk-problems self detail)
    (open-message (walk-problems-message detail)
                  caption: "Problems"
                  type: 'message
                  execute: (lambda (evt)
                             (let ((dialog (find-ascendant (get-sender evt) World-Dialog)))
                               (close dialog)))))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method package (display-status self msg (color: color #f) (duration: duration #f))
    (set! status msg)
    (set! status-color color)
    (set! status-duration duration)
    (set! status-time (current-monotonic)))
  
  
  (method (layout-status self)
    (let ((window (current-window)))
      (let ((world-width (get-width window))
            (world-height (get-height window)))
        (let ((h (center (get-width status-sheet) world-width))
              (v (- world-height 70 (get-height status-size))))
          (set-position status-sheet (new Point h v))))))
  
  
  (method (draw-status self)
    (let ((elapse (- (current-monotonic) status-time))
          (duration (or status-duration 1.)))
      (let ((fade duration)
            (done (+ duration 1.)))
        (if (> elapse done)
            (begin
              (set! status #f)
              (set! status-time #f))
          (let ((alpha (if (> elapse fade) (/ (- done elapse) (- done fade)) #f)))
            (let ((surface (get-surface (get-texture status-sheet)))
                  (font {Font Status})
                  (color (or status-color {Color World-Message})))
              (clear surface)
              (set-font surface font)
              (let ((color (if (not alpha)
                               color
                             (let ((color (copy-object color #f)))
                               (set-alpha color alpha)
                               color)))
                    (shadow-color (if (not alpha)
                                      {Color Black}
                                    (let ((color (copy-object {Color Black} #f)))
                                      (set-alpha color alpha)
                                      color)))
                    (h (center (text-width font status) (get-width status-sheet))))
                (draw-text surface h 0 status color shadow-color: shadow-color))
              (flush surface)
              (map-texture (get-texture status-sheet))
              (render-sheet status-sheet)))))))

  
  ;;;
  ;;;; Working
  ;;;
  
  
  (method package (working self thunk (color: color #f))
    (assert (task-mutex-owner?))
    ;; quick solution
    (if (render-mutex-owner?)
        (begin
          ;; (terminal '***WARNING*** 'working 'called 'from 'render (execution-stack))
          (thunk))
      (set! working? #t)
      (set! working-color color)
      (set! working-message #f)
      (set! working-percentage #f)
      (set! working-result #f)
      (thread-start!
        (new-thread
          (lambda ()
            (unwind-protect
                (set! working-result (thunk))
              (set! working? #f)))
          'working))
      (working-loop self)
      working-result))
  
  
  (method package (working-progress self message percentage)
    (set! working-message message)
    (set! working-percentage percentage))
  
  
  (method (working-loop self)
    (declare (proper-tail-calls))
    (let ((window (current-window)))
      (let (loop)
        (sleep .05)
        (set! working-step (modulo (+ working-step 1) 20))
        (when working?
          (render-now window)
          (loop)))))
  
  
  (method (layout-working self)
    (let ((window (current-window)))
      (let ((world-width (get-width window))
            (world-height (get-height window)))
        (let ((h (center (get-width working-sheet) world-width))
              (v (draw-working-offset self)))
          (set-position working-sheet (new Point h v))))))
  
  
  (method (draw-working self)
    (let ((surface (get-surface (get-texture working-sheet))))
      (clear surface)
      (let ((context (get-context surface))
            (color (or working-color {Color World-Green}))
            (working-angle (- (* (cast <fl> working-step) (/ PI*2 20.)))))
        (loop (for n from 0 below 20)
              (let ((angle (* (cast <fl> n) (/ PI*2 20.)))
                    (alpha (- 1. (/ (cast <fl> n) 35.))))
                (with-preserved-matrix surface
                  (lambda ()
                    (cairo_translate context 400. 30.)
                    (cairo_rotate context (+ working-angle angle))
                    (fill-rect surface (new Rect 18 0 30 3)
                      (new Color red: (get-red color) green: (get-green color) blue: (get-blue color) alpha: alpha))))))
        (set-font surface {Font font-name: tahoma point-size: 16 shadow: thin})
        (when working-message
          (let ((width (get-text-width surface (if (not working-percentage)
                                                   working-message
                                                 (format "{a} ( %)" working-message)))))
            (let ((h (center width 800))
                  (str (if (not working-percentage)
                           working-message
                         (format "{a} ({r precision: 0}%)" working-message working-percentage))))
              (draw-text surface h 70 str color)))))
      (flush surface)
      (map-texture (get-texture working-sheet))
      (render-sheet working-sheet)))))
