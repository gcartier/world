;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Collision Detection
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.collision jazz


(import (jazz.math)
        (jazz.syntax (phase syntax))
        (gaea.geometry)
        (gaea.homogeneous)
        (gaea.lookat)
        (gaea.movement)
        (gaea.plane)
        (world)
        (world.area)
        (world.autoload)
        (world.context)
        (world.draw)
        (world.dyes)
        (world.mark)
        (world.polygon)
        (world.queue)
        (world.settings)
        (world.travel))


(proclaim (not check bounds)
          (warn optimizations))


(definition debug?
  #f)

(definition (debugging . rest)
  (when debug?
    (apply debug rest)))


;;;
;;;; Collision
;;;


(class Collision extends Object
  
  
  (slot polygon      <Polygon>                      getter generate)
  (slot colliders    <list>    initialize '()       accessors generate)
  (slot plane        <Plane>                        getter generate)
  (slot distance     <fl>      initialize (make-fl) getter generate)
  (slot back-facing? <bool>                         getter generate)
  (slot type         <symbol>                       getter generate)
  
  
  (method override (initialize self polygon plane distance <fv> back-facing? type)
    (nextmethod self)
    (set! self.polygon polygon)
    (set! self.plane plane)
    (fl! self.distance distance)
    (set! self.back-facing? back-facing?)
    (set! self.type type))
  
  
  (method override (assemble self polygon colliders plane distance <fv> back-facing? type)
    (set! self.polygon polygon)
    (set! self.colliders colliders)
    (set! self.plane plane)
    (fl! self.distance distance)
    (set! self.back-facing? back-facing?)
    (set! self.type type))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a} {a}" colliders plane distance back-facing? type))))
  
  
  (method public (get-element self)
    (get-element polygon)))


(definition (allocate-collision)
  (allocate Collision
            #f
            '()
            #f
            (make-fl)
            #f
            #f))


(definition (transform-collisions$ cl matrix inverse-matrix)
  (map (lambda (coll)
         (transform-collision$ coll matrix inverse-matrix))
       cl))


(definition (transform-collision$ coll <Collision> matrix <matrix> inverse-matrix <matrix>) <Collision>
  (make-collision$
    (transform-polygon$ (get-polygon coll) matrix inverse-matrix)
    (map (lambda (poly <Polygon>) (transform-polygon$ poly matrix inverse-matrix)) (get-colliders coll))
    (transform-plane$ (get-plane coll) matrix inverse-matrix)
    (get-distance coll)
    (get-back-facing? coll)
    (get-type coll)))


;;;
;;;; Detection
;;;


(definition -EPSILON <fl>
  (- EPSILON))

(definition -2*EPSILON <fl>
  (* -EPSILON 2.))

(definition 1-EPSILON <fl>
  (- 1. EPSILON))

(definition 1+EPSILON <fl>
  (+ 1. EPSILON))


(definition sphere-radius <fl>
  1.)


(definition public (calculate-colliders$ sphere-matrix <matrix> inverse-matrix <matrix> mvt <Movement> travel-breadth <fx> max-distance <fl+> area-cube <Area-Cube+> polygon-filter <procedure+> skip-list <list> include-back-facing? <bool> ignore-non-physical? <bool> ignore-entities? <bool> ignore-players? <bool> ignore-me? <bool> megahack? <bool>) <list>
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  (let ()
    (define (collide poly <Polygon> result)
      (define (add-collision collision)
        (enqueue result collision))
      
      (if (member? poly skip-list test: polygon=?)
          (return-polygon$ poly)
        (let ((collision (collide-polygon$ poly mvt include-back-facing? megahack?)))
          (if (not collision)
              (return-polygon$ poly)
            (if (skimming-surface? collision)
                (free-collision$ collision)
              (if (null? (queue-list result))
                  (add-collision collision)
                (let ((collision-distance (get-distance collision))
                      (result0 <Collision> (car (queue-list result))))
                  (let ((d <fl> (abs (- collision-distance (get-distance result0)))))
                    (if (> d EPSILON)
                        (if (>= collision-distance (get-distance result0))
                            (free-collision$ collision)
                          (free-collisions$ (queue-list result))
                          (reset-queue result)
                          (add-collision collision))
                      ;; Make sure it's not already in the list (this plane's normal)
                      (let ((collision-normal (get-normal (get-plane collision))))
                        (let ((old-coll <Collision+>
                                (find-if (lambda (coll <Collision>)
                                           (and (> (dot-product& (get-normal (get-plane coll)) collision-normal) 1-EPSILON)
                                                coll))
                                         (queue-list result))))
                          (if old-coll
                              (begin
                                (free-collision-not-polygon$ collision)
                                (set-colliders old-coll (cons poly (get-colliders old-coll))))
                            (add-collision collision)))))))))))))
    
    (define (skimming-surface? collision <Collision>)
      (let ((contact-point (get-origin (get-plane collision)))
            (contact-position (movement-end-to& mvt (get-distance collision))))
        (< (abs (dot-product& (vertex-& contact-point contact-position) (get-normal mvt))) EPSILON)))
    
    ;; Go through our list of potential colliders
    (site calculate-colliders$
      (let ((zone (current-zone)))
        (bind-values (orig dir) (transform-ray& (get-origin mvt) (get-vector mvt) inverse-matrix)
          (or (travel-ray-polygons$
                (lambda (iterate)
                  (let ((result (make-queue$)))
                    (iterate
                      (lambda (poly <Polygon>)
                        @show-collision-polygons
                        (when (testing?)
                          (add-mark zone (new Polygon-Mark (transform-polygon$ poly inverse-matrix sphere-matrix))))
                        (if (let ((lst (queue-list result)))
                              (or (null? lst)
                                  (>= (+ sphere-radius (get-radius poly) (get-distance (cast <Collision> (car lst))) EPSILON)
                                      (vertex-distance& (get-origin mvt) (get-center poly)))))
                            (collide poly result)
                          (return-polygon$ poly))))
                    (let ((cl (queue-list result)))
                      (return-queue$ result)
                      (and (not-null? cl) cl))))
                orig
                dir
                sphere-radius
                travel-breadth
                (or max-distance (+ (get-subarea-size zone) sphere-radius))
                sphere-matrix
                area-cube: area-cube
                filter: polygon-filter
                ignore-non-physical?: ignore-non-physical?
                ignore-entities?: ignore-entities?
                ignore-players?: ignore-players?
                ignore-me?: ignore-me?)
              '()))))))


(definition (collide-polygon$ poly <Polygon> mvt <Movement> include-back-facing? <bool> megahack? <bool>) <Collision+>
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  ;; The goal is to calculate the collision plane
  (let ((back-facing? (<= (plane-to-point-distance& poly (get-origin mvt)) 0.)))
    ;; Ignore back-facing polygons
    (if (and back-facing? (not include-back-facing?))
        #f
      (let ((poly (if back-facing? (flip-polygon poly) poly)))
        (define (find-edge/point-collision)
          (let ((edge-collision (find-edge-collision$ poly mvt back-facing? megahack?))
                (point-collision (find-point-collision$ poly mvt back-facing? megahack?)))
            (cond ((not edge-collision) point-collision)
                  ((not point-collision) edge-collision)
                  (else
                   (if (< (get-distance edge-collision) (get-distance point-collision))
                       (begin
                         (free-collision-not-polygon$ point-collision)
                         edge-collision)
                     (begin
                       (free-collision-not-polygon$ edge-collision)
                       point-collision))))))
        
        ;; Ignore polygons parallel to movement
        @introduces-a-regression-in-the-stairs (if (< (abs (dot-product& (get-normal mvt) (get-normal poly))) EPSILON) #f)
        ;; Find the point on the sphere that will eventually collide with the polygon's plane
        (let ((sphere-intersection-point (vertex-& (get-origin mvt) (get-normal poly))))
          ;; At this point we know we're in front of the current plane and we're heading toward it
          ;; Trace a ray to the plane
          (let ((sphere-intersection-ray (make-movement& sphere-intersection-point (get-normal mvt)))
                (collision-distance (make-f64&)))
            (let ((intersect? (intersect-plane! collision-distance poly sphere-intersection-ray)))
              (if (not intersect?)
                  (find-edge/point-collision)
                ;; If the polygon is embedded set the collision type and define a collision plane that is perpendicular
                ;; to the direction that the sphere must travel to be un-embedded
                (let ((inner-most-point (is-embedded poly (get-origin mvt))))
                  (if (and inner-most-point (not megahack?))
                      (let ((collision-distance (f64& (- (vertex-distance& inner-most-point (get-origin mvt)) sphere-radius)))
                            (collision-plane (make-plane$ inner-most-point (vertex-normalize-safe& (vertex-& (get-origin mvt) inner-most-point)))))
                        (make-collision$ poly '() collision-plane collision-distance back-facing? 'embedded))
                    ;; Surface/Edge/Point collision
                    (let ((plane-intersection-point (vertex+& sphere-intersection-point (vertex-scalar*& (get-normal mvt) collision-distance))))
                      ;; Surface collision?
                      (if (inside? poly plane-intersection-point EPSILON)
                          (let (;; Our collision plane is our polygon's plane
                                (collision-plane (make-plane$ plane-intersection-point (get-normal poly))))
                            (if (or
                                  ;; Is this a valid collision?
                                  (< collision-distance -2*EPSILON)
                                  ;; Was it an actual collision?
                                  (> collision-distance (get-length mvt))
                                  ;; Ignore collision planes that we're traveling away from
                                  (>= (dot-product& (get-normal collision-plane) (get-normal mvt)) 0.))
                                (begin
                                  (return-plane$ collision-plane)
                                  #f)
                              ;; Is it closer farther away or the same distance as what we've found so far?
                              (make-collision$ poly '() collision-plane collision-distance back-facing? 'surface)))
                        ;; Edge/Point collision
                        (find-edge/point-collision)))))))))))))


;;;
;;;; Response
;;;


(definition (collide-movement& sphere-matrix <matrix> origin <vertex> target <vertex>) <Movement>
  (let ((origin (matrix-transform-3x4& sphere-matrix origin))
        (target (matrix-transform-3x4& sphere-matrix target)))
    (let ((vector (vertex-& target origin)))
      (assert (not (vertex-zero? vector)))
      (make-movement& origin vector))))


(definition (determine-travel-breadth radiuses <vertex>) <fx>
  1
  @seems-1-is-sufficient-as-breadth-is-in-area-units-e-g-2
  ;; quick try with a heuristic
  ;; max it at 2 for now since it has a huge impact on performance
  ;; could we limit breadth to the radius in the direction of our movement!?
  ;; would this work with rotation?
  (min 2 (fxceiling (vertex-norm& radiuses))))


(definition protected collide-mutex
  (make-mutex 'collide))


(definition protected (with-collide-mutex thunk)
  (prog1 (begin
           (mutex-lock! collide-mutex)
           (thunk))
    (mutex-unlock! collide-mutex)))


(definition public (collide&stop$ origin <vertex> target <vertex> lookat <LookAt> radiuses <vertex> (max-distance: max-distance #f) (area-cube: area-cube #f) (polygon-filter: polygon-filter #f) (include-back-facing?: include-back-facing? #f) (ignore-non-physical?: ignore-non-physical? #t) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f) (ignore-me?: ignore-me? #f) (proportional-slide?: proportional-slide? #t) (debuggable-collisions?: debuggable-collisions? #f) (megahack?: megahack? #f))
  (if (vertex=? origin target)
      (values origin (get-sight lookat) '())
    @show-collision-line
    (when (testing?)
      (reset-marks (current-zone))
      (add-mark (current-zone) (new Line-Mark origin target)))
    (with-collide-mutex
      (lambda ()
        (let ((zone (current-zone))
              (sphere-matrix (make-matrix&))
              (inverse-matrix (make-matrix&))
              (travel-breadth (determine-travel-breadth radiuses)))
          (sphere-matrices! sphere-matrix inverse-matrix origin lookat radiuses)
          (let ((mvt (collide-movement& sphere-matrix origin target)))
            (let ((cl (calculate-colliders$ sphere-matrix inverse-matrix mvt travel-breadth max-distance area-cube polygon-filter '() include-back-facing? ignore-non-physical? ignore-entities? ignore-players? ignore-me? megahack?)))
              (when (and debug-collisions? debuggable-collisions? (not-null? cl))
                (add-mark zone
                  (new Collisions-Mark (transform-collisions$ cl inverse-matrix sphere-matrix) #f)))
              (let ((dest (if (null? cl)
                              (movement-end& mvt)
                            (let ((cl0 <Collision> (car cl)))
                              ;; quick hack for a case that should only happen if the player is moved without
                              ;; going through collide&slide$ logic which is the case when we rotate the player
                              (if (eq? (get-type cl0) 'embedded)
                                  (vertex-& (get-origin mvt) (vertex-scalar*& (get-normal (get-plane cl0)) (get-distance cl0)))
                                (let ((dist (get-distance cl0)))
                                  (if (< dist (get-length mvt))
                                      (movement-end-to& mvt dist)
                                    (movement-end& mvt))))))))
                (bind-values (dest dir) (transform-ray& dest (get-vector mvt) inverse-matrix)
                  (let ((collisions (transform-collisions$ cl inverse-matrix sphere-matrix)))
                    (free-collisions$ cl)
                    (values dest
                            dir
                            collisions)))))))))))


(definition collide-max-slide <fx>
  (world-setting 'world.collide-max-slide 5))

(definition public (get-collide-max-slide) <fx>
  collide-max-slide)

(definition public (set-collide-max-slide max-slide <fx>) <void>
  (set! collide-max-slide max-slide))


(definition debug-collisions?
  (world-setting 'world.debug-collisions? #f))

(definition public (get-debug-collisions?)
  debug-collisions?)

(definition public (set-debug-collisions? flag)
  (set! debug-collisions? flag))


(definition public (collide&slide$ origin <vertex> target <vertex> lookat <LookAt> radiuses <vertex> (max-distance: max-distance #f) (area-cube: area-cube #f) (polygon-filter: polygon-filter #f) (include-back-facing?: include-back-facing? #f) (ignore-non-physical?: ignore-non-physical? #t) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f) (ignore-me?: ignore-me? #f) (proportional-slide?: proportional-slide? #t) (debuggable-collisions?: debuggable-collisions? #f))
  (if (vertex=? origin target)
      (values origin (get-sight lookat) '())
    @show-collision-line
    (when (testing?)
      (reset-marks (current-zone))
      (add-mark (current-zone) (new Line-Mark origin target)))
    (with-collide-mutex
      (lambda ()
        (let ((world (current-world))
              (zone (current-zone))
              (sphere-matrix (make-matrix&))
              (inverse-matrix (make-matrix&))
              (travel-breadth (determine-travel-breadth radiuses)))
          (sphere-matrices! sphere-matrix inverse-matrix origin lookat radiuses)
          (let ((ray (collide-movement& sphere-matrix origin target)))
            (let ((dist (get-length ray))
                  (max-loops collide-max-slide)
                  (current-direction (copy-vertex (get-vector ray)))
                  (current-cl '())
                  (world-current '())
                  (world-last '())
                  (skip-list <list> '()))
              (define (skip-polygons coll <Collision>)
                (set! skip-list (cons (get-polygon coll) skip-list))
                (for-each (lambda (poly)
                            (set! skip-list (cons poly skip-list)))
                          (get-colliders coll)))
              
              ;; Sliding is an iterative process
              (let (iter (loop-no 0))
                (when (and (< loop-no max-loops)
                           (not (vertex-near-zero? (get-vector ray)))
                           (> (get-length ray) EPSILON))
                  ;; This is handy
                  (vertex-copy! current-direction (get-vector ray))
                  ;; Quicky to not redo the sphere-matrices! we did above
                  (when (> loop-no 0)
                    (movement-transform-3x4! ray inverse-matrix)
                    (sphere-matrices! sphere-matrix inverse-matrix (get-origin ray) lookat radiuses)
                    (movement-transform-3x4! ray sphere-matrix))
                  (let (;; Get the colliders
                        (cl <list> (calculate-colliders$ sphere-matrix inverse-matrix ray travel-breadth max-distance area-cube polygon-filter skip-list include-back-facing? ignore-non-physical? ignore-entities? ignore-players? ignore-me? #f)))
                    (when (and debug-collisions? debuggable-collisions? (not-null? cl))
                      (add-mark zone
                        (new Collisions-Mark (transform-collisions$ cl inverse-matrix sphere-matrix) loop-no)))
                    ;; We can consider these polygons again
                    (set! skip-list '())
                    ;; If we didn't hit anything just return the destination
                    (if (null? cl)
                        (set-origin ray (movement-end& ray))
                      (free-collisions$ current-cl)
                      (set! current-cl cl)
                      (free-collisions$ world-last)
                      (set! world-last world-current)
                      ;; Transform now with these iteration matrices
                      (set! world-current (transform-collisions$ cl inverse-matrix sphere-matrix))
                      (let ((hit-count <fx> (length cl))
                            (hit-list cl)
                            (cl0 <Collision> (car cl)))
                        ;; If it was embedded push away
                        (if (eq? (get-type cl0) 'embedded)
                            ;; If it's embedded back up along the collision plane normal
                            (begin
                              (set-origin ray (vertex-& (get-origin ray) (vertex-scalar*& (get-normal (get-plane cl0)) (get-distance cl0))))
                              (iter (+ loop-no 1)))
                          (let (@new (world-plane (transform-plane$ (get-plane cl0) inverse-matrix sphere-matrix))
                                @new (world-ray (movement-transform-3x4 ray inverse-matrix)))
                            (let (@new (plane-slide-dst (plane-closest& world-plane (movement-end& world-ray)))
                                  @new (up (get-up lookat))
                                  (plane-slide-dst (plane-closest& (get-plane cl0) (movement-end& ray)))
                                  (up (get-up lookat)))
                              (let (@new
                                    (slide-dst (if (< (abs (dot-product& (get-normal world-plane) up)) EPSILON)
                                                   (matrix-transform-3x4& sphere-matrix plane-slide-dst)
                                                 (let ((mvt (make-movement& (vertex+& (vertex-& (movement-end& world-ray) (get-origin world-ray)) (get-origin world-plane)) up))
                                                       (collision-distance (make-f64&)))
                                                   (let ((intersect? (intersect-plane! collision-distance world-plane mvt)))
                                                     (let ((xz-dst (movement-end-to& mvt collision-distance)))
                                                       ;; could have a percentage here...
                                                       (matrix-transform-3x4& sphere-matrix (vertex+& (get-origin world-plane) (vertex-scalar*& (vertex-normalize-safe& (vertex-& xz-dst (get-origin world-plane))) (get-length world-ray)))))))))
                                    (slide-dst (if (< (abs (dot-product& (get-normal (get-plane cl0)) up)) EPSILON)
                                                   plane-slide-dst
                                                 (let ((mvt (make-movement& (vertex+& (vertex-& (movement-end& ray) (get-origin ray)) (get-origin (get-plane cl0))) up))
                                                       (collision-distance (make-f64&)))
                                                   (let ((intersect? (intersect-plane! collision-distance (get-plane cl0) mvt)))
                                                     (let ((xz-dst (movement-end-to& mvt collision-distance)))
                                                       ;; could have a percentage here...
                                                       (vertex+& (get-origin (get-plane cl0)) (vertex-scalar*& (vertex-normalize-safe& (vertex-& xz-dst (get-origin (get-plane cl0)))) (get-length ray)))))))))
                                @new (return-plane$ world-plane)
                                ;; We hit something -- move as far as we can
                                (set-origin ray (vertex+& (get-origin ray) (vertex-scalar*& (get-normal ray) (get-distance cl0))))
                                ;; If we hit two or more find the two with the most "pressure"
                                (if (>= hit-count 2)
                                    (let ((c0 0)
                                          (d0 (f64& 2.)))
                                      (loop (for i from 0 below hit-count)
                                            (let ((dot (dot-product& (get-normal (get-plane (cast <Collision> (element hit-list i)))) (get-normal ray))))
                                              (when (< dot d0)
                                                (set! d0 dot)
                                                (set! c0 i))))
                                      (let ((c1 0)
                                            (d1 (f64& 2.)))
                                        (loop (for j from 0 below hit-count)
                                              (when (/= j c0)
                                                (let ((dot (dot-product& (get-normal (get-plane (cast <Collision> (element hit-list j)))) (get-normal ray))))
                                                  (when (< dot d1)
                                                    (set! d1 dot)
                                                    (set! c1 j)))))
                                        ;; Temp vector
                                        (let ((temp-v (get-vector ray))
                                              ;; Point along the crease
                                              (perp (vertex-abs& (cross-product& (get-normal (get-plane (cast <Collision> (element hit-list c1))))
                                                                                 (get-normal (get-plane (cast <Collision> (element hit-list c0))))))))
                                          (set! temp-v (vertex* temp-v perp))
                                          (if (< (vertex-norm& temp-v) EPSILON)
                                              (iter (+ loop-no 1))
                                            (vertex-normalize! temp-v temp-v)
                                            (vertex-scalar*! temp-v temp-v (vertex-norm& (get-vector ray)))
                                            ;; Find out how much to scale our vector that points along the crease
                                            (let ((n1 (vertex-normalize& temp-v))
                                                  (n2 (vertex-normalize& (get-vector ray))))
                                              (let ((scalar (dot-product& n1 n2)))
                                                ;; New vector is new direction vector scaled
                                                (set-vector ray (vertex-scalar*& temp-v scalar))))
                                            (vertex-copy! current-direction (get-vector ray))
                                            ;; Don't collide with these next time
                                            (skip-polygons (cast <Collision> (element hit-list c0)))
                                            (skip-polygons (cast <Collision> (element hit-list c1)))
                                            (iter (+ loop-no 1))))))
                                  ;; Otherwise we slide
                                  (let ((slide-src (plane-closest& (get-plane cl0) (get-origin ray))))
                                    (let ((vector (vertex-& slide-dst slide-src)))
                                      (let ((new-vector
                                              (if proportional-slide?
                                                  vector
                                                (let ((norm (vertex-norm& vector)))
                                                  ;; Adjusting slide to dist can create artefacts if norm is too small
                                                  (if (< norm .001)
                                                      vector
                                                    (vertex-scalar*& (vertex-normalize& vector) dist))))))
                                        (unless (vertex-near-zero? new-vector)
                                          (set-vector ray new-vector)
                                          (vertex-copy! current-direction new-vector)
                                          ;; Don't collide with this one next time
                                          (skip-polygons cl0)
                                          (iter (+ loop-no 1))))))))))))))))
              (free-collisions$ current-cl)
              (bind-values (dest dir) (transform-ray& (get-origin ray) current-direction inverse-matrix)
                (values dest
                        dir
                        (append world-current world-last))))))))))


;;;
;;;; Utility
;;;


(definition (find-edge-collision$ poly <Polygon> mvt <Movement> back-facing? <bool> megahack? <bool>) <Collision+>
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  (if megahack?
      #f
  (let ((closest-contact-point (make-vertex&))
        (closest-contact-position (make-vertex&))
        (closest-distance (f64& +inf.0 @w (get-length mvt)))
        (closest? (box& #f))
        (vertices (get-vertices poly)))
    (let ((vertex-count <fx> (length vertices)))
      (loop (for i from 0 below vertex-count)
            (let ((p1 (vector-ref vertices i))
                  (p0 (vector-ref vertices (cast <fx> (let ((j (- i 1))) (if (< j 0) (- vertex-count 1) j))))))
              (edge-sphere-collision& p0 p1 mvt closest-contact-point closest-contact-position closest-distance closest?
                (lambda (contact-dist <fv> contact-point <vertex> contact-position <vertex> closest-contact-point <vertex> closest-contact-position <vertex> closest-distance <fv> closest?)
                  (when (< contact-dist closest-distance)
                    (vertex-copy! closest-contact-point contact-point)
                    (vertex-copy! closest-contact-position contact-position)
                    (f64-copy! closest-distance contact-dist)
                    (set-box! closest? #t)))))))
    (and (unbox closest?)
         (< closest-distance (get-length mvt))
         (make-collision$ poly '() (make-plane$ closest-contact-point (vertex-normalize& (vertex-& closest-contact-position closest-contact-point))) closest-distance back-facing? 'edge)))))


(definition (edge-sphere-collision& p1 <vertex> p2 <vertex> mvt <Movement> closest-contact-point closest-contact-position closest-distance closest? proc) <void>
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  ;; finds the time of collision of the sphere with the edge
  ;; if the sphere is moving towards the edge line in the working plane (*).
  ;; and if the sphere intersects this plane (there is obviously no collision if the later condition doesn't hold)
  ;; #f otherwise
  ;; (*) the plane parallel to the movement and where the edge lies is called the working plane
  ;; the case where the sphere would collide with an edge is not covered here (yet)
  ;; edge or movement line refers to the infinite line covering the edge or the movement respectively.
  (let ((normal (cross-normal-safe& (vertex-& p1 p2) (get-vector mvt))) ;; normal to the working plane
        (origin (get-origin mvt)))
    (let ((line-dist (let ((dist (dot-product& normal (vertex-& p1 origin)))) ;; minimal distance between the movement line and the edge line.
                       (if (<= 1-EPSILON (abs dist) 1+EPSILON)
                           (f64& (flsign dist))
                         dist))))
      (unless (or (vertex-zero? normal)
                  (> (abs line-dist) sphere-radius)) ;; testing for the second condition
        (let ((radius-secant (f64& (sqrt (- 1. (* line-dist line-dist))))) ;; radius of the cercle : intersection of the sphere and the working plane
              (origin-secant (vertex+& origin (vertex-scalar*& normal line-dist))) ;; projection of the origin of the movement on the working-plane
              (perpendicular (cross-normal-safe& normal (vertex-& p1 p2)))) ;; perpendicular to the edge in the working plane
          (let ((distance-secant (dot-product& perpendicular (vertex-& origin-secant p1))) ;; distance between the edge line and the projection of the origin
                (closing-speed (dot-product& perpendicular (get-vector mvt)))) ;; component of vector (displacement) moving towards the edge line.
            ;; the first condition doesn't hold, the circle is not moving toward the edge line
            ;; either it is moving away or the cercle is already touching the edge line - the later is not yet covered here
            (when (or (and (> closing-speed 0.) (< distance-secant (- EPSILON radius-secant)))
                      (and (< closing-speed 0.) (> distance-secant (- radius-secant EPSILON))))
              (let ((contact-dist (f64& (* (get-length mvt) (/ (- (abs distance-secant) radius-secant) (abs closing-speed)))))
                    (radius-direction (if (> distance-secant 0.) (f64& (- radius-secant)) radius-secant)))
                (let ((contact-position (movement-end-to& mvt contact-dist)))
                  (let ((contact-point (vertex+& (vertex-& contact-position origin)
                                                 (vertex+& origin-secant (vertex-scalar*& perpendicular radius-direction)))))
                    (when (is-point-inside-edge? p1 p2 contact-point)
                      (proc contact-dist contact-point contact-position closest-contact-point closest-contact-position closest-distance closest?))))))))))))


(definition (find-point-collision$ poly <Polygon> mvt <Movement> back-facing? <bool> megahack? <bool>) <Collision+>
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  (if megahack?
      #f
  (let ((closest-contact-point (make-vertex&))
        (closest-contact-position (make-vertex&))
        (closest-distance (f64& (get-length mvt)))
        (closest? (box& #f))
        (vertices (get-vertices poly)))
    (let ((vertex-count <fx> (length vertices)))
      (loop (for i from 0 below vertex-count)
            (let ((pt (vector-ref vertices i)))
              (point-sphere-collision& pt mvt closest-contact-point closest-contact-position closest-distance closest?
                (lambda (contact-dist <fv> contact-point <vertex> contact-position <vertex> closest-contact-point <vertex> closest-contact-position <vertex> closest-distance <fv> closest?)
                  (when (< contact-dist closest-distance)
                    (vertex-copy! closest-contact-point contact-point)
                    (vertex-copy! closest-contact-position contact-position)
                    (f64-copy! closest-distance contact-dist)
                    (set-box! closest? #t)))))))
    (and (unbox closest?)
         (make-collision$ poly '() (make-plane$ closest-contact-point (vertex-normalize& (vertex-& closest-contact-position closest-contact-point))) closest-distance back-facing? 'point)))))


(definition (point-sphere-collision& pt <vertex> mvt <Movement> closest-contact-point closest-contact-position closest-distance closest? proc) <void>
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  (let ((mvt-normalized (get-normal mvt))
        (origin (get-origin mvt)))
    (let ((dist (dot-product& mvt-normalized (vertex-& pt origin))))
      (when (>= dist 0.)
        (let ((perpendicular-position (vertex+& origin (vertex-scalar*& mvt-normalized dist))))
          (let ((perpendicular-radius (vertex-& pt perpendicular-position)))
            (let ((perpendicular-distance (vertex-norm& perpendicular-radius)))
              (cond ((< 1+EPSILON perpendicular-distance)
                     )
                    ((<= 1-EPSILON perpendicular-distance 1+EPSILON)
                     (proc (vertex-norm& (vertex-& perpendicular-position origin)) pt perpendicular-position closest-contact-point closest-contact-position closest-distance closest?))
                    (else 
                     (let ((contact-position (vertex-& perpendicular-position (vertex-scalar*& mvt-normalized (sqrt (- 1. (* perpendicular-distance perpendicular-distance)))))))
                       (proc (vertex-norm& (vertex-& contact-position origin)) pt contact-position closest-contact-point closest-contact-position closest-distance closest?)))))))))))


(definition (unit-sphere-intersection center <vertex> mvt <Movement>) <values>
  (let ((q (vertex-& center (get-origin mvt))))
    (let ((c (vertex-norm& q))
          (v (dot-product& q (get-normal mvt))))
      (let ((d (- 1. (- (* c c) (* v v)))))
        ;; Was there an intersection?
        (if (< d 0.)
            (values 0. #f)
          ;; Return the distance to the [first] intersecting point
          (values (- v (sqrt d)) #t))))))


(definition (is-embedded poly <Polygon> sphere-center <vertex>) <vertex+>
  ;; How far is the sphere from the plane?
  (let ((t (plane-to-point-distance& poly sphere-center)))
    ;; If the plane is farther than the radius of the sphere it's not embedded
    (if (> t 1-EPSILON)
        #f
      ;; Find the closest point on the polygon to the center of the sphere
      (let ((inner-most-point (vertex-& sphere-center (vertex-scalar*& (get-normal poly) t))))
        ;; If the closest point on the plane is within the polygon the polygon is embedded
        (if (not (inside? poly inner-most-point EPSILON))
            (let ((inner-most (make-vertex&))
                  (e0 (make-vertex&))
                  (e1 (make-vertex&)))
              (let ((edge? (closest-point-on-perimeter! poly inner-most-point inner-most e0 e1)))
                (if (> (vertex-distance& inner-most sphere-center) 1-EPSILON)
                    #f
                  (copy-vertex inner-most))))
          (copy-vertex inner-most-point))))))


(definition (is-point-inside-edge? a <vertex> b <vertex> p <vertex>) <bool>
  (<= (dot-product& (vertex-& a p) (vertex-& b p)) 0.))


;;;
;;;; Pool
;;;


(define-pool collision$
  allocate-collision Collision)


(definition protected (make-collision$ polygon colliders plane distance back-facing? type) <Collision>
  (let ((coll (need-collision$)))
    (assemble coll polygon colliders plane distance back-facing? type)
    coll))


(definition protected (free-collision$ collision <Collision>) <void>
  (return-polygon$ (get-polygon collision))
  (free-collision-not-polygon$ collision))


(definition protected (free-collision-not-polygon$ collision <Collision>) <void>
  (for-each (lambda (poly <Polygon>)
              (return-polygon$ poly))
            (get-colliders collision))
  (return-plane$ (get-plane collision))
  (return-collision$ collision))


(definition protected (free-collisions$ cl <list>)
  (for-each free-collision$ cl))


;;;
;;;; Collisions-Mark
;;;


(proclaim (not warn optimizations))


(class Collisions-Mark extends Mark
  
  
  (slot collisions initialize #f accessors generate)
  (slot loop-no    initialize #f accessors generate)
  
  
  (method override (initialize self collisions loop-no)
    (nextmethod self)
    (set! self.collisions collisions)
    (set! self.loop-no loop-no))
  
  
  (method meta override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (map serialize (get-collisions object)))
                              (serialize (get-loop-no object)))))
  
  
  (method meta override (unmarshall-object self content)
    (bind-vector (collisions loop-no) content
      (allocate self
                (deserialize (map deserialize collisions))
                (deserialize loop-no))))
  
  
  (method override (draw self)
    (define (draw-polygons)
      (for-each (lambda (collision)
                  (let ((dye green-dye))
                    (for-each (lambda (poly)
                                (draw-polygon poly dye)
                                (set! dye yellow-dye))
                              (cons (get-polygon collision)
                                    (reverse (get-colliders collision))))))
                collisions))
    
    (define (draw-planes)
      (let ((dye (if (not loop-no)
                     green-dye
                   (case loop-no
                     ((0) red-dye)
                     ((1) purple-dye)
                     (else blue-dye)))))
        (for-each (lambda (collision)
                    (let ((plane (get-plane collision)))
                      (draw-plane plane dye)))
                  collisions)))
    
    (draw-polygons)
    (draw-planes))))
