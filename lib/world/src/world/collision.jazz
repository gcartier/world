;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Collision Detection
;;;


(module world.collision jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.literals)
        (jazz.logger)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.autoload)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.foreign)
        (world.geometry)
        (world.homogeneous)
        (world.lookat)
        (world.mark)
        (world.movement)
        (world.object)
        (world.opengl)
        (world.plane)
        (world.polygon)
        (world.serialization)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile)
        (world.triangle)
        (world.window))


(proclaim (warn optimizations))


(definition debug?
  #f)

(definition (debugging . rest)
  (when debug?
    (apply debug rest)))


;;;
;;;; Collision
;;;


(class Collision extends Object
  
  
  (slot polygon   <Polygon> getter generate)
  (slot colliders <object>  accessors generate)
  (slot plane     <Plane>   getter generate)
  (slot distance  <fl>      getter generate)
  (slot type      <symbol>  getter generate)
  
  
  (method override (initialize polygon plane distance type)
    (debug-allocation Collision)
    (nextmethod)
    (set! polygon~self polygon)
    (set! colliders~self (list polygon))
    (set! plane~self plane)
    (set! distance~self distance)
    (set! type~self type))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a}" colliders plane distance type))))
  
  
  (method meta override (marshall-object object)
    (serialize-object (class-of object)
                      (vector (serialize (get-polygon~ object))
                              (serialize (map serialize (get-colliders~ object)))
                              (serialize (get-plane~ object))
                              (serialize (get-distance~ object))
                              (serialize (get-type~ object)))))
  
  
  (method meta override (unmarshall-object content)
    (bind-vector (polygon colliders plane distance type) content
      (allocate self
                (deserialize polygon)
                (deserialize (map deserialize colliders))
                (deserialize plane)
                (deserialize distance)
                (deserialize type))))
  
  
  (method public (get-element)
    (get-element~ polygon)))


;;;
;;;; Collisions-Mark
;;;


(definition highlighted
  '())

(definition public (get-highlighted)
  highlighted)

(definition public (set-highlighted lst)
  (set! highlighted lst))


(definition draw-highlighted?
  #t)

(definition public (get-draw-highlighted?)
  draw-highlighted?)

(definition public (set-draw-highlighted? flag)
  (set! draw-highlighted? flag))


@integrate
(definition (draw-collisions collisions loop-no)
  (define (draw obj dye)
    (typecase obj
      ((Polygon) (draw-polygon obj dye))
      ((Collision) (draw-collision obj dye))))
  
  (define (draw-polygon polygon dye)
    (glLineWidth 3.)
    (gl-colorize-dye dye)
    (glBegin GL_LINE_LOOP)
    (loop (for vert in-vector (get-vertices~ polygon))
          (glVertex3f (vertex-x vert) (vertex-y vert) (vertex-z vert)))
    (glEnd))
  
  (define (draw-collision coll dye)
    (gl-colorize-dye dye)
    (let ((color (dye->color dye))
          (plane (get-plane~ coll)))
      (let ((origin (get-origin~ plane))
            (normal (get-normal~ plane)))
        (let ((other (vertex (vertex-y origin) (vertex-z origin) (vertex-x origin))))
          (let ((right (vertex-normalize (cross-product other normal))))
            (let ((sight (vertex-normalize (cross-product right normal))))
              (glPushMatrix)
              (glMultMatrixv
                (vertex-x right) (vertex-x normal) (vertex-x sight) (vertex-x origin)
                (vertex-y right) (vertex-y normal) (vertex-y sight) (vertex-y origin)
                (vertex-z right) (vertex-z normal) (vertex-z sight) (vertex-z origin)
                0. 0. 0. 1.)
              (glLineWidth 2.)
              (gl-horizontal-circle (vertex 0. 0. 0.) .5 color)
              (glBegin GL_LINES)
              (glVertex3f 0.0 0.0 0.0)
              (glVertex3f 0.0 .75 0.0)
              (glEnd)
              (glLineWidth 1.)
              (glPopMatrix)))))))
  
  (define (draw-polygons polygons)
    (glDisable GL_LIGHTING)
    (for-each (lambda (poly)
                (draw-polygon poly green-dye))
              polygons)
    (glEnable GL_LIGHTING))
  
  (define (draw-collisions collisions)
    (let ((dye (case loop-no
                 ((0) red-dye)
                 ((1) purple-dye)
                 (else blue-dye))))
      (let ((color (dye->color dye)))
        (gl-colorize-dye dye)
        (for-each (lambda (coll)
                    (draw-collision coll dye))
                  collisions))))
  
  (define (draw-highlighted)
    (for-each (lambda (obj)
                (draw obj blue-dye))
              highlighted))
  
  (draw-polygons (apply append (map get-colliders~ collisions)))
  (draw-collisions collisions)
  (when draw-highlighted?
    (draw-highlighted))
  (glLineWidth 1.))


(class Collisions-Mark extends Mark
  
  
  (slot inverse-matrix initialize #f accessors generate)
  (slot collisions     initialize #f accessors generate)
  (slot loop-no        initialize #f accessors generate)
  
  
  (method override (initialize inverse-matrix collisions loop-no)
    (nextmethod)
    (set! inverse-matrix~self (copy-matrix inverse-matrix))
    (set! collisions~self collisions)
    (set! loop-no~self loop-no))
  
  
  (method meta override (marshall-object object)
    (serialize-object (class-of object)
                      (vector (serialize (get-inverse-matrix~ object))
                              (serialize (map serialize (get-collisions~ object)))
                              (serialize (get-loop-no~ object)))))
  
  
  (method meta override (unmarshall-object content)
    (bind-vector (inverse-matrix collisions loop-no) content
      (allocate self
                (deserialize inverse-matrix)
                (deserialize (map deserialize collisions))
                (deserialize loop-no))))
  
  
  (method override (draw)
    (define (draw-polygon polygon)
      (glBegin GL_LINE_LOOP)
      (loop (for vert in-vector (get-vertices~ polygon))
            (let ((vert (matrix-transform-3x4 inverse-matrix vert)))
              (glVertex3f (vertex-x vert) (vertex-y vert) (vertex-z vert))))
      (glEnd))
    
    (define (draw-polygons)
      (let ((polygons (apply append (map get-colliders~ collisions))))
        (glLineWidth 3.)
        (glDisable GL_LIGHTING)
        (gl-colorize-dye green-dye)
        (for-each draw-polygon polygons)
        (glEnable GL_LIGHTING)
        (glLineWidth 1.)))
    
    (define (draw-planes)
      (let ((dye (case loop-no
                   ((0) red-dye)
                   ((1) purple-dye)
                   (else blue-dye))))
        (let ((color (dye->color dye)))
          (gl-colorize-dye dye)
          (for-each (lambda (collision)
                      (let ((plane (get-plane~ collision)))
                        (let ((origin (matrix-transform-3x4 inverse-matrix (get-origin~ plane)))
                              (normal (vertex-normalize (vertex- (matrix-transform-3x4 inverse-matrix (vertex+ (get-origin~ plane) (get-normal~ plane)))
                                                                 (matrix-transform-3x4 inverse-matrix (get-origin~ plane))))))
                          (let ((other (vertex (vertex-y origin) (vertex-z origin) (vertex-x origin))))
                            (let ((right (vertex-normalize (cross-product other normal))))
                              (let ((sight (vertex-normalize (cross-product right normal))))
                                (glPushMatrix)
                                (glMultMatrixv
                                  (vertex-x right) (vertex-x normal) (vertex-x sight) (vertex-x origin)
                                  (vertex-y right) (vertex-y normal) (vertex-y sight) (vertex-y origin)
                                  (vertex-z right) (vertex-z normal) (vertex-z sight) (vertex-z origin)
                                  0. 0. 0. 1.)
                                (glLineWidth 2.)
                                (gl-horizontal-circle (vertex 0. 0. 0.) .15 color)
                                (glBegin GL_LINES)
                                (glVertex3f 0.0 0.0 0.0)
                                (glVertex3f 0.0 .75 0.0)
                                (glEnd)
                                (glLineWidth 1.)
                                (glPopMatrix)))))))
                    collisions))))
    
    (draw-polygons)
    (draw-planes)))


;;;
;;;; Detection
;;;


(definition EPSILON <fl>
  1e-5)

(definition -EPSILON <fl>
  (- EPSILON))

(definition -2*EPSILON <fl>
  (* -EPSILON 2.))

(definition 1-EPSILON <fl>
  (- 1. EPSILON))

(definition 1+EPSILON <fl>
  (+ 1. EPSILON))


(definition sphere-radius <fl>
  1.)


(definition public (calculate-colliders sphere-matrix <f64vector> inverse-matrix <f64vector> mvt <Movement> skip-list <list>) <list+>
  (define (collide polygon <Polygon> result)
    (define (add-collision collision)
      (enqueue result collision))
    
    (unless (memq? polygon skip-list)
      (let ((collision (collide-polygon polygon mvt)))
        (when (and collision (not (skimming-surface? collision)))
          (if (null? (queue-list result))
              (add-collision collision)
            (let ((collision-distance (get-distance~ collision))
                  (result0 <Collision> (car (queue-list result))))
              (let ((d <fl> (abs (- collision-distance (get-distance~ result0)))))
                (if (> d EPSILON)
                    (when (< collision-distance (get-distance~ result0))
                      (reset-queue result)
                      (add-collision collision))
                  ;; Make sure it's not already in the list (this plane's normal)
                  (let ((collision-normal (get-normal~ (get-plane~ collision))))
                    (let ((old-coll <Collision+>
                            (find-if (lambda (coll <Collision>)
                                       (when (> (f64-ref (dot-product& (get-normal~ (get-plane~ coll)) collision-normal)) 1-EPSILON)
                                         coll))
                                     (queue-list result))))
                      (if old-coll
                          (set-colliders~ old-coll (cons polygon (get-colliders~ old-coll)))
                        (add-collision collision))))))))))))
  
  (define (skimming-surface? collision)
    (let ((contact-point (get-origin~ (get-plane~ collision)))
          (contact-position (movement-end-to mvt (get-distance~ collision))))
      (< (abs (dot-product (vertex- contact-point contact-position) (get-normal~ mvt))) EPSILON)))
  
  ;; Go through our list of potential colliders
  (let ((world (current-world))
        (zone (current-zone)))
    (receive (orig dir) (inverse-movement inverse-matrix (get-origin~ mvt) (get-vector~ mvt))
      (travel-ray-polygons~ world
        (lambda (iterate)
          (let ((result (new-queue)))
            (iterate
              (lambda (poly <Polygon>)
                (when (let ((lst (queue-list result)))
                        (or (null? lst)
                            (>= (+ sphere-radius (get-radius~ poly) (get-distance~ (cast <Collision> (car lst))) EPSILON)
                                (vertex-distance (get-origin~ mvt) (get-center~ poly)))))
                  (collide poly result))))
            (let ((result (queue-list result)))
              (and (not-null? result) result))))
        orig
        dir
        sphere-radius
        1
        (+ (get-area-size~ zone) sphere-radius)
        sphere-matrix))))


(definition (collide-polygon poly <Polygon> mvt <Movement>) <Collision+>
  ;; The goal through this loop is to calculate the collision plane
  (continuation-capture
    (lambda (return)
      (define (continue)
        (continuation-return return #f))
      
      (define (find-edge/point-collision)
        (let ((edge-collision (find-edge-collision poly mvt))
              (point-collision (find-point-collision poly mvt)))
          (cond ((not edge-collision) point-collision)
                ((not point-collision) edge-collision)
                (else
                 (if (< (get-distance~ edge-collision) (get-distance~ point-collision))
                     edge-collision
                   point-collision)))))
      
      ;; Ignore back-facing polygons
      (if (<= (plane-to-point-distance poly (get-origin~ mvt)) 0.) (continue))
      ;; Ignore polygons parallel to movement
      @introduces-a-regression-in-the-stairs (if (< (abs (dot-product (get-normal~ mvt) (get-normal~ poly))) EPSILON) (continue))
      ;; Find the point on the sphere that will eventually collide with the polygon's plane
      (let ((sphere-intersection-point (vertex-& (get-origin~ mvt) (get-normal~ poly))))
        ;; At this point we know we're in front of the current plane and we're heading toward it
        ;; Trace a ray to the plane
        (let ((sphere-intersection-ray (make-movement& sphere-intersection-point (get-normal~ mvt))))
          (receive (collision-distance intersect?) (intersect-plane poly sphere-intersection-ray)
            (if (not intersect?)
                (find-edge/point-collision)
              ;; If the polygon is embedded set the collision type and define a collision plane that is perpendicular
              ;; to the direction that the sphere must travel to be un-embedded
              (let ((inner-most-point (is-embedded poly (get-origin~ mvt))))
                (if inner-most-point
                    (let ((collision-distance (- (f64-ref (vertex-distance& inner-most-point (get-origin~ mvt))) sphere-radius))
                          (collision-plane (new Plane inner-most-point (vertex-normalize-safe (vertex-& (get-origin~ mvt) inner-most-point)))))
                      (new Collision poly collision-plane collision-distance 'CT_EMBEDDED))
                  ;; Surface/Edge/Point collision
                  (let ((plane-intersection-point (vertex+& sphere-intersection-point (vertex-scalar*& (get-normal~ mvt) collision-distance))))
                    ;; Surface collision?
                    (if (inside?~ poly plane-intersection-point EPSILON)
                        (let (;; Our collision plane is our polygon's plane
                              (collision-plane (new Plane plane-intersection-point (get-normal~ poly))))
                          ;; Is this a valid collision?
                          (when (< collision-distance -2*EPSILON) (continue))
                          ;; Was it an actual collision?
                          (when (> collision-distance (get-length~ mvt)) (continue))
                          ;; Ignore collision planes that we're traveling away from
                          (when (>= (f64-ref (dot-product& (get-normal~ collision-plane) (get-normal~ mvt))) 0.) (continue))
                          ;; Is it closer farther away or the same distance as what we've found so far?
                          (new Collision poly collision-plane collision-distance 'CT_SURFACE))
                      ;; Edge/Point collision
                      (find-edge/point-collision))))))))))))


;;;
;;;; Response
;;;


(definition debug-embedded?
  #f)

(definition public (get-debug-embedded?)
  debug-embedded?)

(definition public (set-debug-embedded? debug?)
  (set! debug-embedded? debug?))


(definition sanity-check?
  #f)

(definition (sanity-check dest cl)
  (for-each (lambda (coll <Collision>)
              (assert (>= (vertex-distance (get-origin~ (get-plane~ coll)) dest) 1-EPSILON)))
            cl))


(definition (collision-movement sphere-matrix <f64vector> origin <f64vector> target <f64vector>) <Movement>
  (let ((origin (matrix-transform-3x4 sphere-matrix origin))
        (target (matrix-transform-3x4 sphere-matrix target)))
    (new Movement origin (vertex- target origin))))


(definition (inverse-movement inverse-matrix <f64vector> origin <f64vector> dir <f64vector>)
  (let ((origin (matrix-transform-3x4 inverse-matrix origin))
        (target (matrix-transform-3x4 inverse-matrix (vertex+ origin dir))))
    (values origin
            (vertex- target origin))))


(definition public (collide&stop origin <f64vector> target <f64vector> lookat <LookAt> radiuses <f64vector> (filter-pulse-jumps: filter-pulse-jumps #f))
  (let ((sphere-matrix (make-matrix&))
        (inverse-matrix (make-matrix&)))
    ;; quick for tests
    (if (vertex=? origin target)
        (values origin (vertex 0. 0. 1.) '())
    (sphere-matrices! sphere-matrix inverse-matrix origin lookat radiuses)
    (let ((mvt (collision-movement sphere-matrix origin target)))
      (let ((cl <list> (or (calculate-colliders sphere-matrix inverse-matrix mvt '()) '())))
        (let ((dest (if (null? cl)
                        (movement-end mvt)
                      (let ((cl0 (car cl)))
                        (when (eq? (get-type~ cl0) 'CT_EMBEDDED)
                          (let ((world (current-world)))
                            (when debug-embedded?
                              (display-message~ world "STOP_EMBEDDED")
                              (unless (get-paused?~ world)
                                (pause-world~ world)))))
                        (let ((dist (get-distance~ (cast <Collision> cl0))))
                          (if (< dist (get-length~ mvt))
                              (movement-end-to mvt dist)
                            (movement-end mvt)))))))
          (when sanity-check?
            (sanity-check dest cl))
          (receive (dest dir) (inverse-movement inverse-matrix dest (get-normal~ mvt))
            (values dest
                    dir
                    cl))))))))


(definition collide-max-slide <fx>
  5)

(definition public (get-collide-max-slide) <fx>
  collide-max-slide)

(definition public (set-collide-max-slide max-slide <fx>) <void>
  (set! collide-max-slide max-slide))


(definition public (collide&slide origin <f64vector> target <f64vector> lookat <LookAt> radiuses <f64vector> (filter-pulse-jumps: filter-pulse-jumps #f) (debug-collisions?: debug-collisions? (find-setting 'world.debug-collisions? #f)))
  ;(debug (vertex-distance origin target))
  (let ((world (current-world))
        (zone (current-zone))
        (sphere-matrix (make-matrix&))
        (inverse-matrix (make-matrix&))
        (dir (vertex-normalize-safe& (vertex-& target origin))))
    ;; quick for tests
    (if (vertex=? origin target)
        (values origin (vertex 0. 0. 1.) '())
    (sphere-matrices! sphere-matrix inverse-matrix origin lookat radiuses)
    (let ((mvt (collision-movement sphere-matrix origin target)))
      (let ((max-loops collide-max-slide)
            (last-direction (vertex 0. 0. 0.))
            (last-cl <list> '())
            (input-ray <Movement> (copy-movement mvt))
            (output-ray <Movement> (copy-movement mvt))
            (skip-list <list> '()))
        (define (skip-polygons coll <Collision>)
          (for-each (lambda (poly)
                      (set! skip-list (cons poly skip-list)))
                    (get-colliders~ coll)))
        
        (when debug-collisions?
          (reset-marks~ zone))
        ;; Sliding is an iterative process
        (let (iter (loop-no 0))
          (when (and (< loop-no max-loops)
                     (not (vertex-zero? (get-vector~ output-ray)))
                     (> (get-length~ output-ray) EPSILON))
            ;; This is handy
            (vertex-copy! last-direction (get-vector~ output-ray))
            ;; Quicky to not redo the sphere-matrices! we did above
            (when (> loop-no 0)
              (movement-transform-3x4 output-ray inverse-matrix)
              (sphere-matrices! sphere-matrix inverse-matrix (get-origin~ output-ray) lookat radiuses)
              (movement-transform-3x4 output-ray sphere-matrix))
            (let (;; Get the colliders
                  (cl <list> (or (calculate-colliders sphere-matrix inverse-matrix output-ray skip-list) '())))
              (when debug-collisions?
                (add-mark~ zone
                  (new Collisions-Mark inverse-matrix cl loop-no)))
              (set! last-cl cl)
              ;; We can consider these polygons again
              (set! skip-list '())
              ;; If we didn't hit anything just return the destination
              (if (null? cl)
                  (begin
                    (set-origin~ output-ray (movement-end output-ray))
                    (when sanity-check?
                      (sanity-check (get-origin~ output-ray) cl)))
                (let ((hit-count <fx> (length cl))
                      (hit-list cl)
                      (cl0 <Collision> (car cl)))
                  ;; If it was embedded push away
                  (if (eq? (get-type~ cl0) 'CT_EMBEDDED)
                      ;; If it's embedded back up along the collision plane normal
                      (begin
                        (when debug-embedded?
                          (display-message~ world "SLIDE_EMBEDDED")
                          (unless (get-paused?~ world)
                            (pause-world~ world)))
                        (set-origin~ output-ray (vertex-& (get-origin~ output-ray) (vertex-scalar*& (get-normal~ (get-plane~ cl0)) (get-distance~ cl0))))
                        (when sanity-check?
                          (sanity-check (get-origin~ output-ray) cl))
                        (iter (+ loop-no 1)))
                    (let ((plane-slide-dst (plane-closest& (get-plane~ cl0) (movement-end output-ray)))
                          (world-up (get-world-up~ world)))
                      (let ((slide-dst (if (< (abs (dot-product (get-normal~ (get-plane~ cl0)) world-up)) EPSILON)
                                           plane-slide-dst
                                         (let ((mvt (new Movement (vertex+ (vertex- (movement-end output-ray) (get-origin~ output-ray)) (get-origin~ (get-plane~ cl0))) world-up)))
                                           (receive (collision-distance intersect?) (intersect-plane (get-plane~ cl0) mvt)
                                             (let ((xz-dst (movement-end-to mvt collision-distance)))
                                               ;; could have a percentage here...
                                               (vertex+ (get-origin~ (get-plane~ cl0)) (vertex-scalar* (vertex-normalize-safe (vertex- xz-dst (get-origin~ (get-plane~ cl0)))) (get-length~ output-ray)))))))))
                        (when debug-collisions?
                          (add-mark~ zone (new Vertex-Mark (matrix-transform-3x4 inverse-matrix slide-dst) color: blue-dye)))
                        ;; We hit something -- move as far as we can
                        (set-origin~ output-ray (vertex+& (get-origin~ output-ray) (vertex-scalar*& (get-normal~ output-ray) (get-distance~ cl0))))
                        (when sanity-check?
                          (sanity-check (get-origin~ output-ray) cl))
                        ;; If we hit two or more find the two with the most "pressure"
                        (if (>= hit-count 2)
                            (let ((c0 0)
                                  (d0 2.))
                              (for (i 0 hit-count)
                                   (let ((dot (f64-ref (dot-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list i)))) (get-normal~ output-ray)))))
                                     (when (< dot d0)
                                       (set! d0 dot)
                                       (set! c0 i))))
                              (let ((c1 0)
                                    (d1 2.))
                                (for (j 0 hit-count)
                                     (when (/= j c0)
                                       (let ((dot (f64-ref (dot-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list j)))) (get-normal~ output-ray)))))
                                         (when (< dot d1)
                                           (set! d1 dot)
                                           (set! c1 j)))))
                                ;; Temp vector
                                (let ((temp-v (get-vector~ output-ray))
                                      ;; Point along the crease
                                      (perp (vertex-abs& (cross-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list c1))))
                                                                         (get-normal~ (get-plane~ (cast <Collision> (element hit-list c0))))))))
                                  (set! temp-v (vertex* temp-v perp))
                                  (if (< (f64-ref (vertex-norm& temp-v)) EPSILON)
                                      (iter (+ loop-no 1))
                                    (vertex-normalize! temp-v temp-v)
                                    (vertex-scalar*! temp-v temp-v (f64-ref (vertex-norm& (get-vector~ output-ray))))
                                    ;; Find out how much to scale our vector that points along the crease
                                    (let ((n1 (vertex-normalize& temp-v))
                                          (n2 (vertex-normalize& (get-vector~ output-ray))))
                                      (let ((scalar (f64-ref (dot-product& n1 n2))))
                                        ;; New vector is new direction vector scaled
                                        (set-vector~ output-ray (vertex-scalar*& temp-v scalar))))
                                    (when (and filter-pulse-jumps (< (f64-ref (dot-product& (get-vector~ output-ray) (get-vector~ input-ray))) 0.))
                                      (set-vector~ output-ray (static (vertex 0. 0. 0.))))
                                    (vertex-copy! last-direction (get-vector~ output-ray))
                                    ;; Don't collide with these next time
                                    (skip-polygons (cast <Collision> (element hit-list c0)))
                                    (skip-polygons (cast <Collision> (element hit-list c1)))
                                    (iter (+ loop-no 1))))))
                          ;; Otherwise we slide
                          (let ((slide-src (plane-closest& (get-plane~ cl0) (get-origin~ output-ray))))
                            (set-vector~ output-ray (vertex-& slide-dst slide-src)))
                          (when (and filter-pulse-jumps (< (f64-ref (dot-product& (get-vector~ output-ray) (get-vector~ input-ray))) 0.))
                            (set-vector~ output-ray (static (vertex 0. 0. 0.))))
                          (vertex-copy! last-direction (get-vector~ output-ray))
                          ;; Don't collide with this one next time
                          (skip-polygons cl0)
                          (iter (+ loop-no 1)))))))))))
        (receive (dest dir) (inverse-movement inverse-matrix (get-origin~ output-ray) last-direction)
          (values dest
                  dir
                  last-cl)))))))


;;;
;;;; Utility
;;;


(definition (find-edge-collision poly <Polygon> mvt <Movement>) <Collision+>
  (let ((closest-contact-point #f)
        (closest-contact-position #f)
        (closest-distance +inf.0 @w (get-length~ mvt))
        (vertices (get-vertices~ poly)))
    (let ((vertex-count <fx> (length vertices)))
      (for (i 0 vertex-count)
           (let ((p1 (vector-ref vertices i))
                 (p0 (vector-ref vertices (let ((j (- i 1))) (if (< j 0) (- vertex-count 1) j)))))
             (let ((info (edge-sphere-collision p0 p1 mvt)))
               (when info
                 (receive (contact-dist contact-point contact-position) info
                   (when (< contact-dist closest-distance)
                     (set! closest-contact-point contact-point)
                     (set! closest-contact-position contact-position)
                     (set! closest-distance contact-dist))))))))
    (and closest-contact-point
         (< closest-distance (get-length~ mvt))
         (new Collision poly (new Plane closest-contact-point (vertex-normalize (vertex- closest-contact-position closest-contact-point))) closest-distance 'CT_EDGE))))


(definition (edge-sphere-collision p1 <f64vector> p2 <f64vector> mvt <Movement>) <fl+>
  ;; finds the time of collision of the sphere with the edge
  ;; if the sphere is moving towards the edge line in the working plane (*).
  ;; and if the sphere intersects this plane (there is obviously no collision if the later condition doesn't hold)
  ;; #f otherwise
  ;; (*) the plane parallel to the movement and where the edge lies is called the working plane
  ;; the case where the sphere would collide with an edge is not covered here (yet)
  ;; edge or movement line refers to the infinite line covering the edge or the movement respectively.
  (let ((normal (vertex-normalize-safe (cross-product (vertex- p1 p2) (get-vector~ mvt)))) ;; normal to the working plane
        (origin (get-origin~ mvt)))
    (let ((line-dist (let ((dist (dot-product normal (vertex- p1 origin)))) ;; minimal distance between the movement line and the edge line.
                       (if (<= 1-EPSILON (abs dist) 1+EPSILON)
                           (cast <fl> (sign dist))
                         dist))))
      (if (or (vertex-zero? normal)
              (> (abs line-dist) sphere-radius)) ;; testing for the second condition
          #f
        (let ((radius-secant (sqrt (- 1. (* line-dist line-dist)))) ;; radius of the cercle : intersection of the sphere and the working plane
              (origin-secant (vertex+ origin (vertex-scalar* normal line-dist))) ;; projection of the origin of the movement on the working-plane
              (perpendicular (vertex-normalize-safe (cross-product normal (vertex- p1 p2))))) ;; perpendicular to the edge in the working plane
          (let ((distance-secant (dot-product perpendicular (vertex- origin-secant p1))) ;; distance between the edge line and the projection of the origin
                (closing-speed (dot-product perpendicular (get-vector~ mvt)))) ;; component of vector (displacement) moving towards the edge line.
            (if (or (and (> closing-speed 0.) (< distance-secant (- EPSILON radius-secant)))
                    (and (< closing-speed 0.) (> distance-secant (- radius-secant EPSILON))))
                (let ((contact-dist (* (get-length~ mvt) (/ (- (abs distance-secant) radius-secant) (abs closing-speed))))
                      (radius-direction (if (> distance-secant 0.) (- radius-secant) radius-secant)))
                  (let ((contact-position (movement-end-to mvt contact-dist)))
                    (let ((contact-point (vertex+ (vertex- contact-position origin)
                                                  (vertex+ origin-secant (vertex-scalar* perpendicular radius-direction)))))
                      (if (is-point-inside-edge? p1 p2 contact-point)
                          (values contact-dist contact-point contact-position)
                        #f))))
              ;; the first condition doesn't hold, the circle is not moving toward the edge line
              ;; either it is moving away or the cercle is already touching the edge line - the later is not yet covered here
              #f)))))))


(definition (find-point-collision poly <Polygon> mvt <Movement>) <Collision+>
  (let ((closest-contact-point #f)
        (closest-contact-position #f)
        (closest-distance (get-length~ mvt))
        (vertices (get-vertices~ poly)))
    (let ((vertex-count <fx> (length vertices)))
      (for (i 0 vertex-count)
           (let ((p1 (vector-ref vertices i)))
             (let ((info (point-sphere-collision p1 mvt)))
               (when info
                 (receive (contact-dist contact-point contact-position) info
                   (when (< contact-dist closest-distance)
                     (set! closest-contact-point contact-point)
                     (set! closest-contact-position contact-position)
                     (set! closest-distance contact-dist))))))))
    (and closest-contact-point
         (new Collision poly (new Plane closest-contact-point (vertex-normalize (vertex- closest-contact-position closest-contact-point))) closest-distance 'CT_POINT))))


(definition (point-sphere-collision p1 <f64vector> mvt <Movement>)
  (let ((mvt-normalized (get-normal~ mvt))
        (origin (get-origin~ mvt)))
    (let ((perpendicular-position (vertex+ origin (vertex-scalar* mvt-normalized (dot-product mvt-normalized (vertex- p1 origin))))))
      (let ((perpendicular-radius (vertex- p1 perpendicular-position)))
        (let ((perpendicular-distance (vertex-norm perpendicular-radius)))
          (cond ((< 1+EPSILON perpendicular-distance)
                 #f)
                ((<= 1-EPSILON perpendicular-distance 1+EPSILON)
                 (values (vertex-norm (vertex- perpendicular-position origin)) p1 perpendicular-position))
                (else 
                 (let ((contact-position (vertex- perpendicular-position (vertex-scalar* mvt-normalized (sqrt (- 1. (* perpendicular-distance perpendicular-distance)))))))
                   (values (vertex-norm (vertex- contact-position origin)) p1 contact-position)))))))))


(definition (unit-sphere-intersection center <f64vector> mvt <Movement>) <values>
  (let ((q (vertex-& center (get-origin~ mvt))))
    (let ((c (f64-ref (vertex-norm& q)))
          (v (f64-ref (dot-product& q (get-normal~ mvt)))))
      (let ((d (- 1. (- (* c c) (* v v)))))
        ;; Was there an intersection?
        (if (< d 0.)
            (values 0. #f)
          ;; Return the distance to the [first] intersecting point
          (values (- v (sqrt d)) #t))))))


(definition (is-embedded poly <Polygon> sphere-center <f64vector>) <f64vector+>
  ;; How far is the sphere from the plane?
  (let ((t (plane-to-point-distance poly sphere-center)))
    ;; If the plane is farther than the radius of the sphere it's not embedded
    (if (> t 1-EPSILON)
        #f
      ;; Find the closest point on the polygon to the center of the sphere
      (let ((inner-most-point (vertex-& sphere-center (vertex-scalar*& (get-normal~ poly) t))))
        ;; If the closest point on the plane is within the polygon the polygon is embedded
        (if (not (inside?~ poly inner-most-point EPSILON))
            (let ((inner-most (make-vertex&))
                  (e0 (make-vertex&))
                  (e1 (make-vertex&)))
              (let ((edge? (closest-point-on-perimeter!~ poly inner-most-point inner-most e0 e1)))
                (if (> (f64-ref (vertex-distance& inner-most sphere-center)) 1-EPSILON)
                    #f
                  (copy-vertex inner-most))))
          (copy-vertex inner-most-point))))))


(definition (is-point-inside-edge? a <f64vector> b <f64vector> p <f64vector>) <bool>
  (<= (f64-ref (dot-product& (vertex-& a p) (vertex-& b p))) 0.)))
