;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Collision Detection
;;;


(module world.collision jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.autoload)
        (world.draw)
        (world.element)
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.mark)
        (world.movement)
        (world.object)
        (world.plane)
        (world.polygon)
        (world.texture)
        (world.tile)
        (world.triangle)
        (world.window))


(proclaim (warn optimizations))


;;;
;;;; Collision
;;;


(class Collision extends Object
  
  
  (slot collider <Polygon> initialize #f getter generate)
  (slot plane    <Plane>   initialize #f getter generate)
  (slot distance <fl>      initialize #f getter generate)
  (slot type     <symbol>  initialize #f getter generate)
  
  
  (method override (initialize collider plane distance type)
    (nextmethod)
    (set! collider~self collider)
    (set! plane~self plane)
    (set! distance~self distance)
    (set! type~self type))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a}" collider plane distance type)))))


;;;
;;;; Detection
;;;


(definition EPSILON <fl>
  1e-3)


(definition public (calc-colliders sphere-radius <fl> mvt <Movement> skip-list <list>) <list+>
  (define (collide polygon <Polygon> result)
    (unless (memq? polygon skip-list)
      (let ((collision (collide-polygon sphere-radius polygon mvt)))
        (when collision
          (if (null? (queue-list result))
              (enqueue result collision)
            (let ((collision-distance (get-distance~ collision))
                  (result0 <Collision> (car (queue-list result))))
              (let ((d <fl> (abs (- collision-distance (get-distance~ result0)))))
                (when (> d EPSILON)
                  (cond ((< collision-distance (get-distance~ result0))
                         (reset-queue result)
                         (enqueue result collision))
                        ((> collision-distance (get-distance~ result0))
                         )
                        (else
                         ;; Make sure it's not already in the list (this plane's normal)
                         (let ((collision-normal (get-normal~ (get-plane~ collision))))
                           (unless (some? (lambda (coll <Collision>)
                                            (> (dot-product (get-normal~ (get-plane~ coll)) collision-normal) (- 1. EPSILON)))
                                          (queue-list result))
                             (enqueue result collision)))))))))))))
  
  ;; Go through our list of potential colliders
  (if (find-setting 'world.collide-all? #f)
      (let ((result (new-queue)))
        (for-each (lambda (tile <Tile>)
                    (when (get-visible?~ tile)
                      (for-each-triangle~ tile
                        (lambda (face <Face> triangle <Triangle>)
                          (let ((polygon triangle))
                            (collide polygon result))))))
                  (get-tiles~ zone))
        (let ((result (queue-list result)))
          (and (not-null? result) result)))
    (travel-ray-elements~ world
      (lambda (iterate)
        (let ((result (new-queue)))
          (iterate
            (lambda (targ <Element>)
              (for-each-triangle~ targ
                (lambda (face <Face> triangle <Triangle>)
                  (let ((polygon triangle))
                    (collide polygon result))))))
          (let ((result (queue-list result)))
            (and (not-null? result) result))))
      (get-origin~ mvt)
      (get-vector~ mvt)
      (get-radius~ zone)
      filter: #f
      ignore-players?: #t)))


(definition (collide-polygon sphere-radius <fl> poly <Polygon> mvt <Movement>) <Collision+>
  ;; The goal through this loop is to calculate the collision plane
  (let ((collision-plane (new Plane (vertex 0. 0. 0.) (vertex 0. 1. 0.)))
        (collision-type 'CT_NONE)
        (collision-distance <fl> 0.))
    (continuation-capture
      (lambda (return)
        (define (continue)
          (continuation-return return #f))
        
        ;; Ignore back-facing polygons
        (if (<= (distance-to-point~ (get-plane~ poly) (get-origin~ mvt)) 0.) (continue))
        ;; Find the point on the sphere that will eventually collide with the polygon's plane
        (let ((sphere-intersection-point (vertex- (get-origin~ mvt) (vertex-scalar* (get-normal~ (get-plane~ poly)) sphere-radius))))
          ;; At this point we know we're in front of the current plane and we're heading toward it
          ;; Trace a ray to the plane
          (let ((sphere-intersection-ray (new Movement sphere-intersection-point (get-normal~ mvt))))
            (receive (intersect? dist) (intersect~ (get-plane~ poly) sphere-intersection-ray)
              (set! collision-distance dist)
              (when (not intersect?)
                (continue))
              ;; If the polygon is embedded set the collision type and define a collision plane that is perpendicular
              ;; to the direction that the sphere must travel to be un-embedded
              (let ((inner-most-point (is-embedded sphere-radius poly (get-origin~ mvt))))
                (if inner-most-point
                    (begin
                      (set! collision-distance (- (vertex-distance inner-most-point (get-origin~ mvt)) sphere-radius))
                      (set-origin~ collision-plane inner-most-point)
                      (set-vector~ collision-plane (vertex- (get-origin~ mvt) inner-most-point))
                      (set! collision-type 'CT_EMBEDDED))
                  ;; Surface/Edge/Point collision
                  (let (;; The plane intersection point
                        (plane-intersection-point (vertex+ sphere-intersection-point (vertex-scalar* (get-normal~ mvt) collision-distance))))
                    ;; Surface collision?
                    (if (inside?~ poly plane-intersection-point EPSILON)
                        (begin
                          ;; Is this a valid collision?
                          (when (< collision-distance (* (- EPSILON) 2.)) (continue))
                          ;; Our collision plane is our polygon's plane
                          (set! collision-plane (get-plane~ poly))
                          (set! collision-type 'CT_SURFACE))
                      ;; Edge/Point collision
                      (begin
                        ;; New collision plane origin
                        (receive (origin e0 e1 edge-flag) (closest-point-on-perimeter~ poly plane-intersection-point)
                          (set-origin~ collision-plane origin)
                          ;; Point collision?
                          (if (not edge-flag)
                              (let ((to-sphere (new Movement (get-origin~ collision-plane) (vertex-negate (get-normal~ mvt)))))
                                (receive (intersection? dist) (unit-sphere-intersection sphere-radius (get-origin~ mvt) to-sphere)
                                  (set! collision-distance dist)
                                  (when (not intersection?) (continue))
                                  ;; The collision plane
                                  (let ((sphere-intersection-point (vertex- (get-origin~ collision-plane) (vertex-scalar* (get-normal~ mvt) collision-distance))))
                                    (set-vector~ collision-plane (vertex- (get-origin~ mvt) sphere-intersection-point))
                                    ;; Generate a vector that points from the vertex at the sphere
                                    (let ((at-sphere (vertex- (get-origin~ mvt) (get-origin~ collision-plane))))
                                      ;; We must be headed at the collision plane
                                      (when (> (dot-product (get-vector~ mvt) at-sphere) 0.) (continue))
                                      ;; The plane is not allowed to face away from the normal of the polygon
                                      (when (< (dot-product (get-normal~ collision-plane) (get-normal~ (get-plane~ poly))) 0.) (continue))
                                      ;; The plane is not allowed to face the interior of the polygon
                                      (when (> (distance-to-point~ collision-plane e0) 0.) (continue))
                                      (when (> (distance-to-point~ collision-plane e1) 0.) (continue))
                                      (set! collision-type 'CT_POINT)))))
                            ;; Edge collision
                            (let ;; Find the plane defined by the edge and the velocity vector (cross product)
                                ;; This plane will be used to bisect the sphere
                                ((edge-normal (vertex-normalize (vertex- e1 e0))))
                              (let ((edge-dot <fl> (abs (dot-product (get-normal~ mvt) edge-normal))))
                                (when (> edge-dot (- 1. EPSILON)) (continue))
                                (let ((bisection-plane (new Plane e1 (cross-product (get-normal~ mvt) edge-normal))))
                                  ;; The intersection of a plane and a sphere is a disc. We want to find the center
                                  ;; of that disc. The center of that disc is the closest point on the bisection plane
                                  ;; to the center of the sphere.
                                  (let ((disc-center (closest~ bisection-plane (get-origin~ mvt))))
                                    ;; If the center of the disc is outside the sphere then the sphere does not intersect
                                    ;; the bisection plane and therefore will never collide with the edge
                                    (when (> (vertex-distance disc-center (get-origin~ mvt)) (- sphere-radius EPSILON)) (continue))
                                    ;; Find the closest point on the edge to the center of the disc
                                    (let ((edge-point (closest-point-on-line e0 e1 disc-center)))
                                      ;; Generate a ray that traces back toward the sphere
                                      (let ((to-sphere (new Movement edge-point (vertex- disc-center edge-point))))
                                        ;; Trace from the edge-point back to the sphere.
                                        ;; This will be the sphere-intersection-point
                                        (receive (intersection? t) (unit-sphere-intersection sphere-radius (get-origin~ mvt) to-sphere)
                                          (when (not intersection?) (continue))
                                          (let ((sphere-intersection-point (end-to~ to-sphere t)))
                                            ;; Will the sphere intersection point when travelling along 'mvt' ever intersect the actual edge?
                                            ;; In order to determine this we'll start by defining a plane that lies on the edge but is perpendicular to 'mvt'.
                                            (let ((edge-vect (vertex-normalize (cross-product (cross-product (vertex- e1 e0) (get-normal~ mvt)) (vertex- e1 e0)))))
                                              (let ((edge-plane (new Plane e0 edge-vect)))
                                                ;; Next we'll intersect the edge-vect ray with the plane
                                                (let ((to-line (new Movement sphere-intersection-point (get-normal~ mvt))))
                                                  (receive (intersect? t) (intersect~ edge-plane to-line)
                                                    ;; Finally does the result end up with a point inside the line segment defined by the
                                                    ;; two edge points? If not then the sphere won't intersect the edge.
                                                    (when (not (is-point-inside-edge? e0 e1 (end-to~ to-line t))) (continue))))
                                                ;; Our collision plane is the tangent plane at the sphere-intersection-point
                                                (set-vector~ collision-plane (vertex- (get-origin~ mvt) sphere-intersection-point))
                                                ;; The plane is not allowed to face the interior of the polygon...
                                                (when (> (distance-to-point~ collision-plane (calc-center-of-mass~ poly)) -0.) (continue))
                                                ;; The plane is not allowed to face away from the normal of the polygon
                                                (when (< (dot-product (get-normal~ collision-plane) (get-normal~ (get-plane~ poly))) 0.) (continue))
                                                ;; Trace from the sphere-intersection-point to the plane to find the collision-distance
                                                (let ((from-sphere (new Movement sphere-intersection-point (get-normal~ mvt))))
                                                  (receive (intersect? dist) (intersect~ collision-plane from-sphere)
                                                    (set! collision-distance dist)
                                                    (assert intersect?)))
                                                ;; Don't allow collisions behind us
                                                (when (< collision-distance -1.) (continue))
                                                (set! collision-type 'CT_EDGE))))))))))))))))))
              ;; Was it an actual collision?
              (when (and (neq? collision-type 'CT_EMBEDDED) (> collision-distance (get-length~ mvt))) (continue))
              ;; Ignore collision planes that we're traveling away from
              (when (and (neq? collision-type 'CT_EMBEDDED) (>= (dot-product (get-normal~ collision-plane) (get-normal~ mvt)) 0.)) (continue))
              ;; Is it closer farther away or the same distance as what we've found so far?
              (new Collision poly collision-plane collision-distance collision-type))))))))


;;;
;;;; Response
;;;


(define debug-collisions?
  #f)

(define debug-polygons?
  #f)


(definition public (collide&slide sphere-radius <fl> mvt <Movement> filter-pulse-jumps (debug-collisions?: debug-collisions? debug-collisions?))
  (let ((last-direction (vertex 0. 0. 0.))
        (last-cl #f)
        (input-ray <Movement> mvt)
        (output-ray <Movement> mvt)
        (skip (new-queue)))
    ;; Sliding is an iterative process
    (let (iter (max-loops 30))
      (when debug-collisions?
        (add-mark~ zone (new Mark (get-origin~ output-ray))))
      (when (and (> max-loops 0)
                 (vertex/=? (get-vector~ output-ray) (vertex 0. 0. 0.))
                 (> (get-length~ output-ray) EPSILON))
        ;; This is handy
        (set! last-direction (get-vector~ output-ray))
        (let (;; Get the colliders
             (cl <list> (or (calc-colliders sphere-radius output-ray (queue-list skip)) '())))
          (set! last-cl cl)
          ;; We can consider these polygons again
          (reset-queue skip)
          ;; If we didn't hit anything just return the destination
          (if (null? cl)
              (set-origin~ output-ray (end~ output-ray))
            (let ((hit-count <fx> (length cl))
                  (hit-list cl)
                  (cl0 <Collision> (car cl)))
            ;; If it was embedded push away
            (if (eq? (get-type~ cl0) 'CT_EMBEDDED)
                ;; If it's embedded back up along the collision plane normal
                (set-origin~ output-ray (vertex- (get-origin~ output-ray) (vertex-scalar* (get-normal~ (get-plane~ cl0)) (get-distance~ cl0))))
              (begin
                ;; We hit something -- move as far as we can
                (set-origin~ output-ray (vertex+ (get-origin~ output-ray) (vertex-scalar* (get-normal~ output-ray) (get-distance~ cl0))))
                ;; If we hit two or more find the two with the most "pressure"
                (if (>= hit-count 2)
                    (let ((c0 0)
                          (d0 2.))
                      (loop (for i from 0 below hit-count)
                            (let ((dot (dot-product (get-normal~ (get-plane~ (cast <Collision> (element hit-list i)))) (get-normal~ output-ray))))
                              (when (< dot d0)
                                (set! d0 dot)
                                (set! c0 i))))
                      (let ((c1 0)
                            (d1 2.))
                        (loop (for j from 0 below hit-count)
                              (when (/= j c0)
                                (let ((dot (dot-product (get-normal~ (get-plane~ (cast <Collision> (element hit-list j)))) (get-normal~ output-ray))))
                                  (when (< dot d1)
                                    (set! d1 dot)
                                    (set! c1 j)))))
                        ;; Temp vector
                        (let ((temp-v (get-vector~ output-ray))
                              ;; Point along the crease
                              (perp (vertex-abs (cross-product (get-normal~ (get-plane~ (cast <Collision> (element hit-list c1))))
                                                               (get-normal~ (get-plane~ (cast <Collision> (element hit-list c0))))))))
                          (set! temp-v (vertex* temp-v perp))
                          (if (< (vertex-norm temp-v) EPSILON)
                              (iter (- max-loops 1))
                            (vertex-normalize! temp-v temp-v)
                            (vertex-scalar*! temp-v temp-v (vertex-norm (get-vector~ output-ray)))
                            ;; Find out how much to scale our vector that points along the crease
                            (let ((n1 (vertex-normalize temp-v))
                                  (n2 (vertex-normalize (get-vector~ output-ray))))
                              (let ((scalar (dot-product n1 n2)))
                                ;; New vector is new direction vector scaled
                                (set-vector~ output-ray (vertex-scalar* temp-v scalar))))
                            (when (and filter-pulse-jumps (< (dot-product (get-vector~ output-ray) (get-vector~ input-ray)) 0.))
                              (set-vector~ output-ray (vertex 0. 0. 0.)))
                            (set! last-direction (get-vector~ output-ray))
                            ;; Don't collide with these next time
                            (enqueue skip (get-collider~ (cast <Collision> (element hit-list c0))))
                            (enqueue skip (get-collider~ (cast <Collision> (element hit-list c1))))
                            (iter (- max-loops 1))))))
                  ;; Otherwise we slide
                  (let ((slide-src (closest~ (get-plane~ cl0) (get-origin~ output-ray)))
                        (slide-dst (closest~ (get-plane~ cl0) (end~ output-ray))))
                    (set-vector~ output-ray (vertex- slide-dst slide-src)))
                  (when (and filter-pulse-jumps (< (dot-product (get-vector~ output-ray) (get-vector~ input-ray)) 0.))
                    (set-vector~ output-ray (vertex 0. 0. 0.)))
                  (set! last-direction (get-vector~ output-ray))
                  ;; Don't collide with this one next time
                  (enqueue skip (get-collider~ cl0))
                  (iter (- max-loops 1))))))))))
    (when debug-collisions?
      (add-mark~ zone (new Mark (get-origin~ output-ray))))
    (when debug-polygons?
      (when (and last-cl (not-null? last-cl))
        (set-?p (get-collider~ (cast <Collision> (car last-cl)))))
      (set-target-polygons~ (get-interface~ world) (map get-collider~ last-cl))
      (invalidate-view~ (get-interface~ world)))
    (values (get-origin~ output-ray) last-direction)))


;;;
;;;; Utility
;;;


(definition (unit-sphere-intersection sphere-radius <fl> center <f32vector> mvt <Movement>)
  (let ((q (vertex-& center (get-origin~ mvt))))
    (let ((c (f32-ref (vertex-norm& q)))
          (v (f32-ref (dot-product& q (get-normal~ mvt)))))
      (let ((d (- (* sphere-radius sphere-radius) (- (* c c) (* v v)))))
        ;; Was there an intersection?
        (if (< d 0.)
            (values #f 0.)
          ;; Return the distance to the [first] intersecting point
          (values #t (- v (sqrt d))))))))


(definition (is-embedded sphere-radius <fl> poly <Polygon> sphere-center <f32vector>) <f32vector+>
  ;; How far is the sphere from the plane?
  (let ((t (distance-to-point~ (get-plane~ poly) sphere-center)))
    ;; If the plane is farther than the radius of the sphere it's not embedded
    (if (> t (- sphere-radius EPSILON))
        #f
      ;; Find the closest point on the polygon to the center of the sphere
      (let ((inner-most-point (vertex-& sphere-center (vertex-scalar* (get-normal~ (get-plane~ poly)) t))))
        ;; If the closest point on the plane is within the polygon the polygon is embedded
        (if (not (inside?~ poly inner-most-point EPSILON))
            (receive (inner-most-point e0 e1 ef) (closest-point-on-perimeter~ poly inner-most-point)
              (if (> (vertex-distance inner-most-point sphere-center) (- sphere-radius EPSILON))
                  #f
                inner-most-point))
          inner-most-point)))))


(definition (is-point-inside-edge? a <f32vector> b <f32vector> p <f32vector>) <bool>
  (<= (dot-product (vertex-& a p) (vertex-& b p)) 0.)))
