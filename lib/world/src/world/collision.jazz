;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Collision Detection
;;;


(module world.collision jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.autoload)
        (world.draw)
        (world.element)
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.homogeneous)
        (world.mark)
        (world.movement)
        (world.object)
        (world.plane)
        (world.polygon)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile)
        (world.triangle)
        (world.window))


(proclaim (warn optimizations))


;;;
;;;; Collision
;;;


(class Collision extends Object
  
  
  (slot element   <Element> initialize #f getter generate)
  (slot colliders <object>  initialize #f accessors generate)
  (slot plane     <Plane>   initialize #f getter generate)
  (slot distance  <fl>      initialize #f getter generate)
  (slot type      <symbol>  initialize #f getter generate)
  
  
  (method override (initialize element colliders plane distance type)
    (debug-allocation Collision)
    (nextmethod)
    (set! element~self element)
    (set! colliders~self colliders)
    (set! plane~self plane)
    (set! distance~self distance)
    (set! type~self type))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a} {a}" element colliders plane distance type)))))


;;;
;;;; Detection
;;;


(definition EPSILON <fl>
  1e-3)

(definition -EPSILON <fl>
  (- EPSILON))

(definition -2*EPSILON <fl>
  (* -EPSILON 2.))

(definition 1-EPSILON <fl>
  (- 1. EPSILON))


(definition public (calculate-colliders sphere-radius <fl> mvt <Movement> skip-list <list>) <list+>
  (define (collide element <Element> polygon <Polygon> result)
    (unless (memq? polygon skip-list)
      (let ((collision (collide-polygon sphere-radius element polygon mvt)))
        (when collision
          (if (null? (queue-list result))
              (enqueue result collision)
            (let ((collision-distance (get-distance~ collision))
                  (result0 <Collision> (car (queue-list result))))
              (let ((d <fl> (abs (- collision-distance (get-distance~ result0)))))
                (if (> d EPSILON)
                    (when (< collision-distance (get-distance~ result0))
                      (reset-queue result)
                      (enqueue result collision))
                  ;; Make sure it's not already in the list (this plane's normal)
                  (let ((collision-normal (get-normal~ (get-plane~ collision))))
                    (let ((old-coll <Collision+>
                            (find-if (lambda (coll <Collision>)
                                       (when (> (f32-ref (dot-product& (get-normal~ (get-plane~ coll)) collision-normal)) 1-EPSILON)
                                         coll))
                                     (queue-list result))))
                      (if old-coll
                          (set-colliders~ old-coll (cons polygon (get-colliders~ old-coll)))
                        (enqueue result collision))))))))))))
  
  ;; Go through our list of potential colliders
  (let ((world (current-world))
        (zone (current-zone)))
    (travel-ray-elements~ world
      (lambda (iterate)
        (let ((result (new-queue)))
          (iterate
            (lambda (targ <Element>)
              (when (let ((lst (queue-list result)))
                      (or (null? lst)
                          (>= (+ sphere-radius (get-radius~ targ) (get-distance~ (cast <Collision> (car lst))) EPSILON)
                              (vertex-distance (get-origin~ mvt) (get-position~ targ)))))
                (for-each-triangle~ targ
                  (lambda (face <Face> triangle <Triangle>)
                    (let ((polygon triangle))
                      (collide targ polygon result)))))))
          (let ((result (queue-list result)))
            (and (not-null? result) result))))
      (get-origin~ mvt)
      (get-vector~ mvt)
      sphere-radius
      1
      (+ (get-area-size~ zone) sphere-radius)
      filter: #f
      ignore-players?: #t)))


(definition (collide-polygon sphere-radius <fl> element <Element> poly <Polygon> mvt <Movement>) <Collision+>
  ;; The goal through this loop is to calculate the collision plane
  (let ((collision-plane (new Plane (vertex 0. 0. 0.) (vertex 0. 1. 0.)))
        (collision-type 'CT_NONE)
        (collision-distance <fl> 0.))
    (continuation-capture
      (lambda (return)
        (define (continue)
          (continuation-return return #f))
        
        ;; Ignore back-facing polygons
        (if (<= (plane-to-point-distance (get-plane~ poly) (get-origin~ mvt)) 0.) (continue))
        ;; Find the point on the sphere that will eventually collide with the polygon's plane
        (let ((sphere-intersection-point (vertex-& (get-origin~ mvt) (vertex-scalar*& (get-normal~ (get-plane~ poly)) sphere-radius))))
          ;; At this point we know we're in front of the current plane and we're heading toward it
          ;; Trace a ray to the plane
          (let ((sphere-intersection-ray (make-movement& sphere-intersection-point (get-normal~ mvt))))
            (receive (dist intersect?) (intersect-plane (get-plane~ poly) sphere-intersection-ray)
              (set! collision-distance dist)
              (when (not intersect?)
                (continue))
              ;; If the polygon is embedded set the collision type and define a collision plane that is perpendicular
              ;; to the direction that the sphere must travel to be un-embedded
              (let ((inner-most-point (is-embedded sphere-radius poly (get-origin~ mvt))))
                (if inner-most-point
                    (begin
                      (set! collision-distance (- (f32-ref (vertex-distance& inner-most-point (get-origin~ mvt))) sphere-radius))
                      (set-origin~ collision-plane inner-most-point)
                      (set-vector~ collision-plane (vertex-& (get-origin~ mvt) inner-most-point))
                      (set! collision-type 'CT_EMBEDDED))
                  ;; Surface/Edge/Point collision
                  (let (;; The plane intersection point
                        (plane-intersection-point (vertex+& sphere-intersection-point (vertex-scalar*& (get-normal~ mvt) collision-distance))))
                    ;; Surface collision?
                    (if (inside?~ poly plane-intersection-point EPSILON)
                        (begin
                          ;; Is this a valid collision?
                          (when (< collision-distance -2*EPSILON) (continue))
                          ;; Our collision plane is our polygon's plane
                          (set! collision-plane (get-plane~ poly))
                          (set! collision-type 'CT_SURFACE))
                      ;; Edge/Point collision
                      (let ((origin (make-vertex&))
                            (e0 (make-vertex&))
                            (e1 (make-vertex&)))
                        ;; New collision plane origin
                        (let ((edge-flag (closest-point-on-perimeter!~ poly plane-intersection-point origin e0 e1)))
                          (set-origin~ collision-plane origin)
                          ;; Point collision?
                          (if (not edge-flag)
                              (let ((to-sphere (make-movement& (get-origin~ collision-plane) (vertex-negate& (get-normal~ mvt)))))
                                (receive (dist intersection?) (unit-sphere-intersection sphere-radius (get-origin~ mvt) to-sphere)
                                  (set! collision-distance dist)
                                  (when (not intersection?) (continue))
                                  ;; The collision plane
                                  (let ((sphere-intersection-point (vertex-& (get-origin~ collision-plane) (vertex-scalar*& (get-normal~ mvt) collision-distance))))
                                    (set-vector~ collision-plane (vertex-& (get-origin~ mvt) sphere-intersection-point))
                                    ;; Generate a vector that points from the vertex at the sphere
                                    (let ((at-sphere (vertex-& (get-origin~ mvt) (get-origin~ collision-plane))))
                                      ;; We must be headed at the collision plane
                                      (when (> (f32-ref (dot-product& (get-vector~ mvt) at-sphere)) 0.) (continue))
                                      ;; The plane is not allowed to face away from the normal of the polygon
                                      (when (< (f32-ref (dot-product& (get-normal~ collision-plane) (get-normal~ (get-plane~ poly)))) 0.) (continue))
                                      ;; The plane is not allowed to face the interior of the polygon
                                      (when (> (plane-to-point-distance collision-plane e0) 0.) (continue))
                                      (when (> (plane-to-point-distance collision-plane e1) 0.) (continue))
                                      (set! collision-type 'CT_POINT)))))
                            ;; Edge collision
                            (let ;; Find the plane defined by the edge and the velocity vector (cross product)
                                 ;; This plane will be used to bisect the sphere
                                 ((edge-normal (vertex-normalize& (vertex-& e1 e0))))
                              (let ((edge-dot <fl> (abs (f32-ref (dot-product& (get-normal~ mvt) edge-normal)))))
                                (when (> edge-dot 1-EPSILON) (continue))
                                (let ((bisection-plane (make-plane& e1 (cross-product& (get-normal~ mvt) edge-normal))))
                                  ;; The intersection of a plane and a sphere is a disc. We want to find the center
                                  ;; of that disc. The center of that disc is the closest point on the bisection plane
                                  ;; to the center of the sphere.
                                  (let ((disc-center (plane-closest& bisection-plane (get-origin~ mvt))))
                                    ;; If the center of the disc is outside the sphere then the sphere does not intersect
                                    ;; the bisection plane and therefore will never collide with the edge
                                    (when (> (f32-ref (vertex-distance& disc-center (get-origin~ mvt))) (- sphere-radius EPSILON)) (continue))
                                    ;; Find the closest point on the edge to the center of the disc
                                    (let ((edge-point (closest-point-on-line& e0 e1 disc-center)))
                                      ;; Generate a ray that traces back toward the sphere
                                      (let ((to-sphere (make-movement& edge-point (vertex-& disc-center edge-point))))
                                        ;; Trace from the edge-point back to the sphere.
                                        ;; This will be the sphere-intersection-point
                                        (receive (t intersection?) (unit-sphere-intersection sphere-radius (get-origin~ mvt) to-sphere)
                                          (when (not intersection?) (continue))
                                          (let ((sphere-intersection-point (movement-end-to to-sphere t)))
                                            ;; Will the sphere intersection point when travelling along 'mvt' ever intersect the actual edge?
                                            ;; In order to determine this we'll start by defining a plane that lies on the edge but is perpendicular to 'mvt'.
                                            (let ((edge-vect (vertex-normalize& (cross-product& (cross-product& (vertex-& e1 e0) (get-normal~ mvt)) (vertex-& e1 e0)))))
                                              (let ((edge-plane (make-plane& e0 edge-vect)))
                                                ;; Next we'll intersect the edge-vect ray with the plane
                                                (let ((to-line (make-movement& sphere-intersection-point (get-normal~ mvt))))
                                                  (receive (t intersect?) (intersect-plane edge-plane to-line)
                                                    ;; Finally does the result end up with a point inside the line segment defined by the
                                                    ;; two edge points? If not then the sphere won't intersect the edge.
                                                    (when (not (is-point-inside-edge? e0 e1 (movement-end-to to-line t))) (continue))))
                                                ;; Our collision plane is the tangent plane at the sphere-intersection-point
                                                (set-vector~ collision-plane (vertex-& (get-origin~ mvt) sphere-intersection-point))
                                                ;; The plane is not allowed to face the interior of the polygon...
                                                (when (> (plane-to-point-distance collision-plane (get-center~ poly)) -0.) (continue))
                                                ;; The plane is not allowed to face away from the normal of the polygon
                                                (when (< (f32-ref (dot-product& (get-normal~ collision-plane) (get-normal~ (get-plane~ poly)))) 0.) (continue))
                                                ;; Trace from the sphere-intersection-point to the plane to find the collision-distance
                                                (let ((from-sphere (make-movement& sphere-intersection-point (get-normal~ mvt))))
                                                  (receive (dist intersect?) (intersect-plane collision-plane from-sphere)
                                                    (set! collision-distance dist)
                                                    (assert intersect?)))
                                                ;; Don't allow collisions behind us
                                                (when (< collision-distance -1.) (continue))
                                                (set! collision-type 'CT_EDGE))))))))))))))))))
              ;; Was it an actual collision?
              (when (and (neq? collision-type 'CT_EMBEDDED) (> collision-distance (get-length~ mvt))) (continue))
              ;; Ignore collision planes that we're traveling away from
              (when (and (neq? collision-type 'CT_EMBEDDED) (>= (f32-ref (dot-product& (get-normal~ collision-plane) (get-normal~ mvt))) 0.)) (continue))
              ;; Is it closer farther away or the same distance as what we've found so far?
              (new Collision element (list poly) collision-plane collision-distance collision-type))))))))


;;;
;;;; Response
;;;


(define debug-collisions?
  #f)

(define debug-polygons?
  #f)


(definition public debug-slides-max
  -1)


(definition public (collide&stop sphere-radius <fl> mvt <Movement> filter-pulse-jumps)
  (let ((cl <list> (or (calculate-colliders sphere-radius mvt '()) '())))
    (values (if (null? cl)
                (movement-end mvt)
              (let ((dist (get-distance~ (cast <Collision> (car cl)))))
                (if (< dist (get-length~ mvt))
                    (movement-end-to mvt dist)
                  (movement-end mvt))))
            (get-normal~ mvt)
            cl)))


(definition public (collide&slide sphere-radius <fl> mvt <Movement> filter-pulse-jumps (debug-collisions?: debug-collisions? debug-collisions?))
  (let ((world (current-world))
        (zone (current-zone))
        (max-loops 3)
        (last-direction (vertex 0. 0. 0.))
        (last-cl <list> '())
        (input-ray <Movement> mvt)
        (output-ray <Movement> mvt)
        (skip-list <list> '()))
    (define (skip-polygons coll <Collision>)
      (for-each (lambda (poly)
                  (set! skip-list (cons poly skip-list)))
                (get-colliders~ coll)))
    
    ;; Sliding is an iterative process
    (let (iter (loop-no 0))
      (when debug-collisions?
        (add-mark~ zone (new Mark (get-origin~ output-ray))))
      (when (and (< loop-no max-loops)
                 (not (vertex-zero? (get-vector~ output-ray)))
                 (> (get-length~ output-ray) EPSILON))
        @w
        (when (> loop-no 2)
          (terminal skip-list))
        @w
        (when (> loop-no 5)
          (terminal loop-no (get-length~ output-ray)))
        @debug-slides
        (when (> loop-no debug-slides-max)
          (terminal 'slide loop-no)
          (if (>= loop-no (- max-loops 1))
              (set! debug-slides-max -1)
            (set! debug-slides-max loop-no)))
        ;; This is handy
        (vertex-copy! last-direction (get-vector~ output-ray))
        (let (;; Get the colliders
              (cl <list> (or (calculate-colliders sphere-radius output-ray skip-list) '())))
          @debug
          (when (= loop-no 20)
            (debug (map object->serial skip-list))
            (debug (map (lambda (c) (list (map object->serial (get-colliders~ c)) (get-distance~ c))) cl)))
          @debug
          (when (= loop-no 24)
            (break))
          (set! last-cl cl)
          ;; We can consider these polygons again
          (set! skip-list '())
          ;; If we didn't hit anything just return the destination
          (if (null? cl)
              (set-origin~ output-ray (movement-end output-ray))
            (let ((hit-count <fx> (length cl))
                  (hit-list cl)
                  (cl0 <Collision> (car cl)))
            ;; If it was embedded push away
            (if (eq? (get-type~ cl0) 'CT_EMBEDDED)
                ;; If it's embedded back up along the collision plane normal
                (set-origin~ output-ray (vertex-& (get-origin~ output-ray) (vertex-scalar*& (get-normal~ (get-plane~ cl0)) (get-distance~ cl0))))
              (let ((slide-dst (plane-closest& (get-plane~ cl0) (movement-end output-ray))))
                ;; We hit something -- move as far as we can
                (set-origin~ output-ray (vertex+& (get-origin~ output-ray) (vertex-scalar*& (get-normal~ output-ray) (get-distance~ cl0))))
                ;; If we hit two or more find the two with the most "pressure"
                (if (>= hit-count 2)
                    (let ((c0 0)
                          (d0 2.))
                      (loop (for i from 0 below hit-count)
                            (let ((dot (f32-ref (dot-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list i)))) (get-normal~ output-ray)))))
                              (when (< dot d0)
                                (set! d0 dot)
                                (set! c0 i))))
                      (let ((c1 0)
                            (d1 2.))
                        (loop (for j from 0 below hit-count)
                              (when (/= j c0)
                                (let ((dot (f32-ref (dot-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list j)))) (get-normal~ output-ray)))))
                                  (when (< dot d1)
                                    (set! d1 dot)
                                    (set! c1 j)))))
                        ;; Temp vector
                        (let ((temp-v (get-vector~ output-ray))
                              ;; Point along the crease
                              (perp (vertex-abs& (cross-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list c1))))
                                                                 (get-normal~ (get-plane~ (cast <Collision> (element hit-list c0))))))))
                          (set! temp-v (vertex* temp-v perp))
                          (if (< (f32-ref (vertex-norm& temp-v)) EPSILON)
                              (iter (+ loop-no 1))
                            (vertex-normalize! temp-v temp-v)
                            (vertex-scalar*! temp-v temp-v (f32-ref (vertex-norm& (get-vector~ output-ray))))
                            ;; Find out how much to scale our vector that points along the crease
                            (let ((n1 (vertex-normalize& temp-v))
                                  (n2 (vertex-normalize& (get-vector~ output-ray))))
                              (let ((scalar (f32-ref (dot-product& n1 n2))))
                                ;; New vector is new direction vector scaled
                                (set-vector~ output-ray (vertex-scalar*& temp-v scalar))))
                            (when (and filter-pulse-jumps (< (f32-ref (dot-product& (get-vector~ output-ray) (get-vector~ input-ray))) 0.))
                              (set-vector~ output-ray (static (vertex 0. 0. 0.))))
                            (vertex-copy! last-direction (get-vector~ output-ray))
                            ;; Don't collide with these next time
                            (skip-polygons (cast <Collision> (element hit-list c0)))
                            (skip-polygons (cast <Collision> (element hit-list c1)))
                            (iter (+ loop-no 1))))))
                  ;; Otherwise we slide
                  (let ((slide-src (plane-closest& (get-plane~ cl0) (get-origin~ output-ray))))
                    (set-vector~ output-ray (vertex-& slide-dst slide-src)))
                  (when (and filter-pulse-jumps (< (f32-ref (dot-product& (get-vector~ output-ray) (get-vector~ input-ray))) 0.))
                    (set-vector~ output-ray (static (vertex 0. 0. 0.))))
                  (vertex-copy! last-direction (get-vector~ output-ray))
                  ;; Don't collide with this one next time
                  (skip-polygons cl0)
                  (iter (+ loop-no 1))))))))))
    (when debug-collisions?
      (add-mark~ zone (new Mark (get-origin~ output-ray))))
    (when debug-polygons?
      (when (not-null? last-cl)
        (set-?p (get-colliders~ (cast <Collision> (car last-cl)))))
      (set-target-polygons~ (get-interface~ world) (map get-colliders~ last-cl))
      (invalidate-view~ (get-interface~ world)))
    (values (get-origin~ output-ray) last-direction last-cl)))


;;;
;;;; Utility
;;;


(definition (unit-sphere-intersection sphere-radius <fl> center <f32vector> mvt <Movement>) <values>
  (let ((q (vertex-& center (get-origin~ mvt))))
    (let ((c (f32-ref (vertex-norm& q)))
          (v (f32-ref (dot-product& q (get-normal~ mvt)))))
      (let ((d (- (* sphere-radius sphere-radius) (- (* c c) (* v v)))))
        ;; Was there an intersection?
        (if (< d 0.)
            (values 0. #f)
          ;; Return the distance to the [first] intersecting point
          (values (- v (sqrt d)) #t))))))


(definition (is-embedded sphere-radius <fl> poly <Polygon> sphere-center <f32vector>) <f32vector+>
  ;; How far is the sphere from the plane?
  (let ((t (plane-to-point-distance (get-plane~ poly) sphere-center)))
    ;; If the plane is farther than the radius of the sphere it's not embedded
    (if (> t (- sphere-radius EPSILON))
        #f
      ;; Find the closest point on the polygon to the center of the sphere
      (let ((inner-most-point (vertex-& sphere-center (vertex-scalar*& (get-normal~ (get-plane~ poly)) t))))
        ;; If the closest point on the plane is within the polygon the polygon is embedded
        (if (not (inside?~ poly inner-most-point EPSILON))
            (let ((inner-most (make-vertex&))
                  (e0 (make-vertex&))
                  (e1 (make-vertex&)))
              (let ((edge? (closest-point-on-perimeter!~ poly inner-most-point inner-most e0 e1)))
                (if (> (f32-ref (vertex-distance& inner-most sphere-center)) (- sphere-radius EPSILON))
                    #f
                  (copy-vertex inner-most))))
          (copy-vertex inner-most-point))))))


(definition (is-point-inside-edge? a <f32vector> b <f32vector> p <f32vector>) <bool>
  (<= (f32-ref (dot-product& (vertex-& a p) (vertex-& b p))) 0.)))
