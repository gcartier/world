;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Collision Detection
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.collision jazz


(import (jazz.debuggee)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.draw)
        (world.dyes)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.lookat)
        (world.mark)
        (world.movement)
        (world.plane)
        (world.polygon)
        (world.settings)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))


(definition debug?
  #f)

(definition (debugging . rest)
  (when debug?
    (apply debug rest)))


;;;
;;;; Collision
;;;


(proclaim (not warn optimizations))


(class Collision-Class extends (:class Object)
  
  
  (method override (marshall-object object)
    (serialize-object (class-of object)
                      (vector (serialize (get-polygon~ object))
                              (serialize (map serialize (get-colliders~ object)))
                              (serialize (get-plane~ object))
                              (serialize (get-distance~ object))
                              (serialize (get-type~ object)))))
  
  
  (method override (unmarshall-object content)
    (bind-vector (polygon colliders plane distance type) content
      (allocate self
                (deserialize polygon)
                (deserialize (map deserialize colliders))
                (deserialize plane)
                (deserialize distance)
                (deserialize type)))))


(proclaim (warn optimizations))


(class Collision metaclass Collision-Class extends Object
  
  
  (slot polygon      <Polygon> getter generate)
  (slot colliders    <object>  accessors generate)
  (slot plane        <Plane>   getter generate)
  (slot distance     <fl>      getter generate)
  (slot back-facing? <bool>    getter generate)
  (slot type         <symbol>  getter generate)
  
  
  (method override (initialize polygon plane distance back-facing? type)
    (debug-allocation Collision)
    (nextmethod)
    (set! polygon~self polygon)
    (set! colliders~self (list polygon))
    (set! plane~self plane)
    (set! distance~self distance)
    (set! back-facing?~self back-facing?)
    (set! type~self type))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a} {a}" colliders plane distance back-facing? type))))
  
  
  (method public (get-element)
    (get-element~ polygon)))


(definition public (copy-collision coll <Collision>) <Collision>
  (allocate Collision
            (copy-polygon~ (get-polygon~ coll))
            (map copy-polygon~ (get-colliders~ coll))
            (copy-plane (get-plane~ coll))
            (get-distance~ coll)
            (get-type~ coll)))

(definition public (copy-collisions cl)
  (map copy-collision cl))


(definition (transform-collisions cl matrix inverse-matrix)
  (map (lambda (coll)
         (transform-collision coll matrix inverse-matrix))
       cl))


(definition (transform-collision coll <Collision> matrix <f64vector> inverse-matrix <f64vector>) <Collision>
  (let ((poly (transform-polygon~ (get-polygon~ coll) matrix inverse-matrix))
        (colliders (map (lambda (poly <Polygon>) (transform-polygon~ poly matrix inverse-matrix)) (get-colliders~ coll)))
        (plane (transform-plane (get-plane~ coll) matrix inverse-matrix))
        (distance (get-distance~ coll))
        (back-facing? (get-back-facing?~ coll))
        (type (get-type~ coll)))
    (let ((new-coll (new Collision poly plane distance back-facing? type)))
      (set-colliders~ new-coll colliders)
      new-coll)))


;;;
;;;; Detection
;;;


(definition -EPSILON <fl>
  (- EPSILON))

(definition -2*EPSILON <fl>
  (* -EPSILON 2.))

(definition 1-EPSILON <fl>
  (- 1. EPSILON))

(definition 1+EPSILON <fl>
  (+ 1. EPSILON))


(definition sphere-radius <fl>
  1.)


(definition public (calculate-colliders sphere-matrix <f64vector> inverse-matrix <f64vector> mvt <Movement> travel-breadth <fx> max-distance <fl+> polygon-filter <procedure+> skip-list <list> include-back-facing? <bool> ignore-entities? <bool> ignore-players? <bool>) <list>
  (define (collide poly <Polygon> result)
    (define (add-collision collision)
      (enqueue result collision))
    
    (unless (memq? poly skip-list)
      (let ((collision (collide-polygon poly mvt include-back-facing?)))
        (when collision
          (unless (skimming-surface? collision)
            (if (null? (queue-list result))
                (add-collision collision)
              (let ((collision-distance (get-distance~ collision))
                    (result0 <Collision> (car (queue-list result))))
                (let ((d <fl> (abs (- collision-distance (get-distance~ result0)))))
                  (if (> d EPSILON)
                      (when (< collision-distance (get-distance~ result0))
                        (reset-queue result)
                        (add-collision collision))
                    ;; Make sure it's not already in the list (this plane's normal)
                    (let ((collision-normal (get-normal~ (get-plane~ collision))))
                      (let ((old-coll <Collision+>
                              (find-if (lambda (coll <Collision>)
                                         (when (> (f64-ref (dot-product& (get-normal~ (get-plane~ coll)) collision-normal)) 1-EPSILON)
                                           coll))
                                       (queue-list result))))
                        (if old-coll
                            (set-colliders~ old-coll (cons (copy-polygon~ poly) (get-colliders~ old-coll)))
                          (add-collision collision)))))))))))))
  
  (define (skimming-surface? collision <Collision>)
    (let ((contact-point (get-origin~ (get-plane~ collision)))
          (contact-position (movement-end-to& mvt (get-distance~ collision))))
      (< (abs (dot-product (vertex-& contact-point contact-position) (get-normal~ mvt))) EPSILON)))
  
  ;; Go through our list of potential colliders
  (site (calculate-colliders on?: #f)
    (let ((world (current-world))
          (zone (current-zone)))
      (receive (orig dir) (transform-ray/normalize (get-origin~ mvt) (get-vector~ mvt) inverse-matrix)
        (or (travel-ray-polygons&~ world
              (lambda (iterate)
                (site (collide on?: #f parent: calculate-colliders)
                  (let ((result (new-queue)))
                    (iterate
                      (lambda (poly <Polygon>)
                        (when (let ((lst (queue-list result)))
                                (or (null? lst)
                                    (>= (+ sphere-radius (get-radius~ poly) (get-distance~ (cast <Collision> (car lst))) EPSILON)
                                        (vertex-distance (get-origin~ mvt) (get-center~ poly)))))
                          (collide poly result))))
                    (let ((result (queue-list result)))
                      (and (not-null? result) result)))))
              orig
              dir
              sphere-radius
              travel-breadth
              (or max-distance (+ (get-area-size~ zone) sphere-radius))
              sphere-matrix
              filter: polygon-filter
              ignore-entities?: ignore-entities?
              ignore-players?: ignore-players?)
            '())))))


(definition (collide-polygon poly <Polygon> mvt <Movement> include-back-facing? <bool>) <Collision+>
  ;; The goal through this loop is to calculate the collision plane
  (continuation-capture
    (lambda (return)
      (define (continue)
        (continuation-return return #f))
      
      (let ((back-facing? (<= (plane-to-point-distance poly (get-origin~ mvt)) 0.)))
        ;; Ignore back-facing polygons
        (unless include-back-facing?
          (when back-facing?
            (continue)))
        (let ((poly (if back-facing? (flip-polygon~ poly) poly)))
          (define (find-edge/point-collision)
            (let ((edge-collision (find-edge-collision poly mvt back-facing?))
                  (point-collision (find-point-collision poly mvt back-facing?)))
              (cond ((not edge-collision) point-collision)
                    ((not point-collision) edge-collision)
                    (else
                     (if (< (get-distance~ edge-collision) (get-distance~ point-collision))
                         edge-collision
                       point-collision)))))
          
          ;; Ignore polygons parallel to movement
          @introduces-a-regression-in-the-stairs (if (< (abs (dot-product (get-normal~ mvt) (get-normal~ poly))) EPSILON) (continue))
          ;; Find the point on the sphere that will eventually collide with the polygon's plane
          (let ((sphere-intersection-point (vertex-& (get-origin~ mvt) (get-normal~ poly))))
            ;; At this point we know we're in front of the current plane and we're heading toward it
            ;; Trace a ray to the plane
            (let ((sphere-intersection-ray (make-movement& sphere-intersection-point (get-normal~ mvt))))
              (receive (collision-distance <fl> intersect?) (intersect-plane poly sphere-intersection-ray)
                (if (not intersect?)
                    (find-edge/point-collision)
                  ;; If the polygon is embedded set the collision type and define a collision plane that is perpendicular
                  ;; to the direction that the sphere must travel to be un-embedded
                  (let ((inner-most-point (is-embedded poly (get-origin~ mvt))))
                    (if (and inner-most-point (not (megahack)))
                        (let ((collision-distance (- (f64-ref (vertex-distance& inner-most-point (get-origin~ mvt))) sphere-radius))
                              (collision-plane (new Plane inner-most-point (vertex-normalize-safe& (vertex-& (get-origin~ mvt) inner-most-point)))))
                          (new Collision (copy-polygon~ poly) collision-plane collision-distance back-facing? 'embedded))
                      ;; Surface/Edge/Point collision
                      (let ((plane-intersection-point (vertex+& sphere-intersection-point (vertex-scalar*& (get-normal~ mvt) collision-distance))))
                        ;; Surface collision?
                        (if (inside?~ poly plane-intersection-point EPSILON)
                            (let (;; Our collision plane is our polygon's plane
                                  (collision-plane (new Plane plane-intersection-point (get-normal~ poly))))
                              ;; Is this a valid collision?
                              (when (< collision-distance -2*EPSILON) (continue))
                              ;; Was it an actual collision?
                              (when (> collision-distance (get-length~ mvt)) (continue))
                              ;; Ignore collision planes that we're traveling away from
                              (when (>= (f64-ref (dot-product& (get-normal~ collision-plane) (get-normal~ mvt))) 0.) (continue))
                              ;; Is it closer farther away or the same distance as what we've found so far?
                              (new Collision (copy-polygon~ poly) collision-plane collision-distance back-facing? 'surface))
                          ;; Edge/Point collision
                          (find-edge/point-collision))))))))))))))


;;;
;;;; Response
;;;


(definition (collide-movement& sphere-matrix <f64vector> origin <f64vector> target <f64vector>) <Movement>
  (let ((origin (matrix-transform-3x4 sphere-matrix origin))
        (target (matrix-transform-3x4 sphere-matrix target)))
    (make-movement& origin (vertex-& target origin))))


(definition (determine-travel-breadth radiuses <f64vector>) <fx>
  ;; quick try with a heuristic
  ;; max it at 2 for now since it has a huge impact on performance
  ;; could we limit breadth to the radius in the direction of our movement!?
  ;; would this work with rotation?
  (min 2 (fxceiling (vertex-norm radiuses))))


(definition collide-mutex
  (make-mutex 'collide))


(definition protected (with-collide-mutex thunk)
  (mutex-lock! collide-mutex)
  (prog1 (thunk)
    (mutex-unlock! collide-mutex)))


@wait
(add-debugger-release 'collide-mutex
  (lambda ()
    (when (and (primordial-thread?)
               (eq? (mutex-owner collide-mutex) (current-thread)))
      (mutex-unlock! collide-mutex))))


(definition public (collide&stop origin <f64vector> target <f64vector> lookat <LookAt> radiuses <f64vector> (max-distance: max-distance #f) (polygon-filter: polygon-filter #f) (include-back-facing?: include-back-facing? #f) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f) (proportional-slide?: proportional-slide? #t) (debuggable-collisions?: debuggable-collisions? #f))
  (if (vertex=? origin target)
      (values origin (get-sight~ lookat) '())
    (with-collide-mutex
      (lambda ()
        (let ((zone (current-zone))
              (sphere-matrix (make-matrix&))
              (inverse-matrix (make-matrix&))
              (travel-breadth (determine-travel-breadth radiuses)))
          (sphere-matrices! sphere-matrix inverse-matrix origin lookat radiuses)
          (let ((mvt (collide-movement& sphere-matrix origin target)))
            (let ((cl (site (calculate-stop-colliders on?: #f parent: collide&stop) (calculate-colliders sphere-matrix inverse-matrix mvt travel-breadth max-distance polygon-filter '() include-back-facing? ignore-entities? ignore-players?))))
              (when (and debug-collisions? debuggable-collisions? (not-null? cl))
                (add-mark~ zone
                  (new Collisions-Mark (transform-collisions cl inverse-matrix sphere-matrix) #f)))
              (let ((dest (if (null? cl)
                              (movement-end mvt)
                            (let ((cl0 <Collision> (car cl)))
                              ;; quick hack for a case that should only happen if the player is moved without
                              ;; going through collide&slide logic which is the case when we rotate the player
                              (if (eq? (get-type~ cl0) 'embedded)
                                  (vertex- (get-origin~ mvt) (vertex-scalar*& (get-normal~ (get-plane~ cl0)) (get-distance~ cl0)))
                                (let ((dist (get-distance~ cl0)))
                                  (if (< dist (get-length~ mvt))
                                      (movement-end-to mvt dist)
                                    (movement-end mvt))))))))
                (receive (dest dir) (transform-ray/normalize dest (get-vector~ mvt) inverse-matrix)
                  (values dest
                          dir
                          (transform-collisions cl inverse-matrix sphere-matrix)))))))))))


(definition collide-max-slide <fx>
  (world-setting 'world.collide-max-slide 5))

(definition public (get-collide-max-slide) <fx>
  collide-max-slide)

(definition public (set-collide-max-slide max-slide <fx>) <void>
  (set! collide-max-slide max-slide))


(definition debug-collisions?
  (world-setting 'world.debug-collisions? #f))

(definition public (get-debug-collisions?)
  debug-collisions?)

(definition public (set-debug-collisions? flag)
  (set! debug-collisions? flag))


(definition public (collide&slide origin <f64vector> target <f64vector> lookat <LookAt> radiuses <f64vector> (max-distance: max-distance #f) (polygon-filter: polygon-filter #f) (include-back-facing?: include-back-facing? #f) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f) (proportional-slide?: proportional-slide? #t) (debuggable-collisions?: debuggable-collisions? #f))
  (if (vertex=? origin target)
      (values origin (get-sight~ lookat) '())
    (with-collide-mutex
      (lambda ()
        (let ((world (current-world))
              (zone (current-zone))
              (sphere-matrix (make-matrix&))
              (inverse-matrix (make-matrix&))
              (travel-breadth (determine-travel-breadth radiuses)))
          (sphere-matrices! sphere-matrix inverse-matrix origin lookat radiuses)
          (let ((ray (collide-movement& sphere-matrix origin target)))
            (let ((dist (get-length~ ray))
                  (max-loops collide-max-slide)
                  (last-direction (vertex 0. 0. 0.))
                  (last-cl '())
                  (second-to-last-cl '())
                  (skip-list <list> '()))
              (define (skip-polygons coll <Collision>)
                (for-each (lambda (poly)
                            (set! skip-list (cons poly skip-list)))
                          (get-colliders~ coll)))
              
              ;; Sliding is an iterative process
              (let (iter (loop-no 0))
                (when (and (< loop-no max-loops)
                           (not (vertex-zero? (get-vector~ ray)))
                           (> (get-length~ ray) EPSILON))
                  ;; This is handy
                  (vertex-copy! last-direction (get-vector~ ray))
                  ;; Quicky to not redo the sphere-matrices! we did above
                  (when (> loop-no 0)
                    (movement-transform-3x4! ray inverse-matrix)
                    (sphere-matrices! sphere-matrix inverse-matrix (get-origin~ ray) lookat radiuses)
                    (movement-transform-3x4! ray sphere-matrix))
                  (let (;; Get the colliders
                        (cl (site (calculate-slide-colliders on?: #f parent: collide&slide) (calculate-colliders sphere-matrix inverse-matrix ray travel-breadth max-distance polygon-filter skip-list include-back-facing? ignore-entities? ignore-players?))))
                    (when (and debug-collisions? debuggable-collisions? (not-null? cl))
                      (add-mark~ zone
                        (new Collisions-Mark (transform-collisions cl inverse-matrix sphere-matrix) loop-no)))
                    (when (not-null? cl)
                      (set! second-to-last-cl last-cl)
                      ;; Transform now with this iteration matrices
                      (set! last-cl (transform-collisions cl inverse-matrix sphere-matrix)))
                    ;; We can consider these polygons again
                    (set! skip-list '())
                    ;; If we didn't hit anything just return the destination
                    (if (null? cl)
                        (set-origin~ ray (movement-end& ray))
                      (let ((hit-count <fx> (length cl))
                            (hit-list cl)
                            (cl0 <Collision> (car cl)))
                        ;; If it was embedded push away
                        (if (eq? (get-type~ cl0) 'embedded)
                            ;; If it's embedded back up along the collision plane normal
                            (begin
                              (set-origin~ ray (vertex-& (get-origin~ ray) (vertex-scalar*& (get-normal~ (get-plane~ cl0)) (get-distance~ cl0))))
                              (iter (+ loop-no 1)))
                          (let ((world-plane (transform-plane (get-plane~ cl0) inverse-matrix sphere-matrix))
                                (world-ray (movement-transform-3x4 ray inverse-matrix)))
                            (let (@new (plane-slide-dst (plane-closest& world-plane (movement-end& world-ray)))
                                  @new (up (get-up~ lookat))
                                  (plane-slide-dst (plane-closest& (get-plane~ cl0) (movement-end& ray)))
                                  (up (get-up~ lookat)))
                              (let (@new
                                    (slide-dst (if (< (abs (dot-product (get-normal~ world-plane) up)) EPSILON)
                                                   (matrix-transform-3x4 sphere-matrix plane-slide-dst)
                                                 (let ((mvt (make-movement& (vertex+& (vertex-& (movement-end& world-ray) (get-origin~ world-ray)) (get-origin~ world-plane)) up)))
                                                   (receive (collision-distance intersect?) (intersect-plane world-plane mvt)
                                                     (let ((xz-dst (movement-end-to& mvt collision-distance)))
                                                       ;; could have a percentage here...
                                                       (matrix-transform-3x4 sphere-matrix (vertex+& (get-origin~ world-plane) (vertex-scalar*& (vertex-normalize-safe& (vertex-& xz-dst (get-origin~ world-plane))) (get-length~ world-ray)))))))))
                                    (slide-dst (if (< (abs (dot-product (get-normal~ (get-plane~ cl0)) up)) EPSILON)
                                                   plane-slide-dst
                                                 (let ((mvt (make-movement& (vertex+& (vertex-& (movement-end& ray) (get-origin~ ray)) (get-origin~ (get-plane~ cl0))) up)))
                                                   (receive (collision-distance intersect?) (intersect-plane (get-plane~ cl0) mvt)
                                                     (let ((xz-dst (movement-end-to& mvt collision-distance)))
                                                       ;; could have a percentage here...
                                                       (vertex+& (get-origin~ (get-plane~ cl0)) (vertex-scalar*& (vertex-normalize-safe& (vertex-& xz-dst (get-origin~ (get-plane~ cl0)))) (get-length~ ray)))))))))
                                ;; We hit something -- move as far as we can
                                (set-origin~ ray (vertex+& (get-origin~ ray) (vertex-scalar*& (get-normal~ ray) (get-distance~ cl0))))
                                ;; If we hit two or more find the two with the most "pressure"
                                (if (>= hit-count 2)
                                    (let ((c0 0)
                                          (d0 2.))
                                      (loop (for i from 0 below hit-count)
                                            (let ((dot (f64-ref (dot-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list i)))) (get-normal~ ray)))))
                                              (when (< dot d0)
                                                (set! d0 dot)
                                                (set! c0 i))))
                                      (let ((c1 0)
                                            (d1 2.))
                                        (loop (for j from 0 below hit-count)
                                              (when (/= j c0)
                                                (let ((dot (f64-ref (dot-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list j)))) (get-normal~ ray)))))
                                                  (when (< dot d1)
                                                    (set! d1 dot)
                                                    (set! c1 j)))))
                                        ;; Temp vector
                                        (let ((temp-v (get-vector~ ray))
                                              ;; Point along the crease
                                              (perp (vertex-abs& (cross-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list c1))))
                                                                                 (get-normal~ (get-plane~ (cast <Collision> (element hit-list c0))))))))
                                          (set! temp-v (vertex* temp-v perp))
                                          (if (< (f64-ref (vertex-norm& temp-v)) EPSILON)
                                              (iter (+ loop-no 1))
                                            (vertex-normalize! temp-v temp-v)
                                            (vertex-scalar*! temp-v temp-v (f64-ref (vertex-norm& (get-vector~ ray))))
                                            ;; Find out how much to scale our vector that points along the crease
                                            (let ((n1 (vertex-normalize& temp-v))
                                                  (n2 (vertex-normalize& (get-vector~ ray))))
                                              (let ((scalar (f64-ref (dot-product& n1 n2))))
                                                ;; New vector is new direction vector scaled
                                                (set-vector~ ray (vertex-scalar*& temp-v scalar))))
                                            (vertex-copy! last-direction (get-vector~ ray))
                                            ;; Don't collide with these next time
                                            (skip-polygons (cast <Collision> (element hit-list c0)))
                                            (skip-polygons (cast <Collision> (element hit-list c1)))
                                            (iter (+ loop-no 1))))))
                                  ;; Otherwise we slide
                                  (let ((slide-src (plane-closest& (get-plane~ cl0) (get-origin~ ray))))
                                    (let ((vector (vertex-& slide-dst slide-src)))
                                      (unless (vertex-zero? vector)
                                        (if proportional-slide?
                                            (set-vector~ ray vector)
                                          (set-vector~ ray (vertex-scalar*& (vertex-normalize& vector) dist))))))
                                  (vertex-copy! last-direction (get-vector~ ray))
                                  ;; Don't collide with this one next time
                                  (skip-polygons cl0)
                                  (iter (+ loop-no 1))))))))))))
              (receive (dest dir) (transform-ray/normalize (get-origin~ ray) last-direction inverse-matrix)
                (values dest
                        dir
                        (append last-cl second-to-last-cl))))))))))


;;;
;;;; Utility
;;;


;; megahack around many edge / point collision snags with the bloodelffemale jumping next to blocks (AM)
(definition protected megahack
  (make-parameter #f))


(definition (find-edge-collision poly <Polygon> mvt <Movement> back-facing? <bool>) <Collision+>
  (if (megahack)
      #f
  (let ((closest-contact-point #f)
        (closest-contact-position #f)
        (closest-distance +inf.0 @w (get-length~ mvt))
        (vertices (get-vertices~ poly)))
    (let ((vertex-count <fx> (length vertices)))
      (loop (for i from 0 below vertex-count)
            (let ((p1 (vector-ref vertices i))
                  (p0 (vector-ref vertices (cast <fx> (let ((j (- i 1))) (if (< j 0) (- vertex-count 1) j))))))
              (edge-sphere-collision& p0 p1 mvt
                (lambda (contact-dist <fl> contact-point <f64vector> contact-position <f64vector>)
                  (when (< contact-dist closest-distance)
                    (set! closest-contact-point (copy-vertex contact-point))
                    (set! closest-contact-position (copy-vertex contact-position))
                    (set! closest-distance contact-dist)))))))
    (and closest-contact-point
         (< closest-distance (get-length~ mvt))
         (new Collision (copy-polygon~ poly) (new Plane closest-contact-point (vertex-normalize& (vertex-& closest-contact-position closest-contact-point))) closest-distance back-facing? 'edge)))))


(definition (edge-sphere-collision& p1 <f64vector> p2 <f64vector> mvt <Movement> proc) <void>
  ;; finds the time of collision of the sphere with the edge
  ;; if the sphere is moving towards the edge line in the working plane (*).
  ;; and if the sphere intersects this plane (there is obviously no collision if the later condition doesn't hold)
  ;; #f otherwise
  ;; (*) the plane parallel to the movement and where the edge lies is called the working plane
  ;; the case where the sphere would collide with an edge is not covered here (yet)
  ;; edge or movement line refers to the infinite line covering the edge or the movement respectively.
  (let ((normal (cross-normal-safe& (vertex-& p1 p2) (get-vector~ mvt))) ;; normal to the working plane
        (origin (get-origin~ mvt)))
    (let ((line-dist <fl> (let ((dist (dot-product normal (vertex-& p1 origin)))) ;; minimal distance between the movement line and the edge line.
                            (if (<= 1-EPSILON (abs dist) 1+EPSILON)
                                (cast <fl> (sign dist))
                              dist))))
      (unless (or (vertex-zero? normal)
                  (> (abs line-dist) sphere-radius)) ;; testing for the second condition
        (let ((radius-secant (sqrt (- 1. (* line-dist line-dist)))) ;; radius of the cercle : intersection of the sphere and the working plane
              (origin-secant (vertex+& origin (vertex-scalar*& normal line-dist))) ;; projection of the origin of the movement on the working-plane
              (perpendicular (cross-normal-safe& normal (vertex-& p1 p2)))) ;; perpendicular to the edge in the working plane
          (let ((distance-secant (dot-product perpendicular (vertex-& origin-secant p1))) ;; distance between the edge line and the projection of the origin
                (closing-speed (dot-product perpendicular (get-vector~ mvt)))) ;; component of vector (displacement) moving towards the edge line.
            ;; the first condition doesn't hold, the circle is not moving toward the edge line
            ;; either it is moving away or the cercle is already touching the edge line - the later is not yet covered here
            (when (or (and (> closing-speed 0.) (< distance-secant (- EPSILON radius-secant)))
                      (and (< closing-speed 0.) (> distance-secant (- radius-secant EPSILON))))
              (let ((contact-dist (* (get-length~ mvt) (/ (- (abs distance-secant) radius-secant) (abs closing-speed))))
                    (radius-direction (if (> distance-secant 0.) (- radius-secant) radius-secant)))
                (let ((contact-position (movement-end-to& mvt contact-dist)))
                  (let ((contact-point (vertex+& (vertex-& contact-position origin)
                                                 (vertex+& origin-secant (vertex-scalar*& perpendicular radius-direction)))))
                    (when (is-point-inside-edge? p1 p2 contact-point)
                      (proc contact-dist contact-point contact-position))))))))))))


(definition (find-point-collision poly <Polygon> mvt <Movement> back-facing? <bool>) <Collision+>
  (if (megahack)
      #f
  (let ((closest-contact-point #f)
        (closest-contact-position #f)
        (closest-distance (get-length~ mvt))
        (vertices (get-vertices~ poly)))
    (let ((vertex-count <fx> (length vertices)))
      (loop (for i from 0 below vertex-count)
            (let ((pt (vector-ref vertices i)))
              (point-sphere-collision& pt mvt
                (lambda (contact-dist <fl> contact-point <f64vector> contact-position <f64vector>)
                  (when (< contact-dist closest-distance)
                    (set! closest-contact-point (copy-vertex contact-point))
                    (set! closest-contact-position (copy-vertex contact-position))
                    (set! closest-distance contact-dist)))))))
    (and closest-contact-point
         (new Collision (copy-polygon~ poly) (new Plane closest-contact-point (vertex-normalize& (vertex-& closest-contact-position closest-contact-point))) closest-distance back-facing? 'point)))))


(definition (point-sphere-collision& pt <f64vector> mvt <Movement> proc) <void>
  (let ((mvt-normalized (get-normal~ mvt))
        (origin (get-origin~ mvt)))
    (let ((dist (dot-product mvt-normalized (vertex-& pt origin))))
      (when (>= dist 0.)
        (let ((perpendicular-position (vertex+& origin (vertex-scalar*& mvt-normalized dist))))
          (let ((perpendicular-radius (vertex-& pt perpendicular-position)))
            (let ((perpendicular-distance (vertex-norm perpendicular-radius)))
              (cond ((< 1+EPSILON perpendicular-distance)
                     )
                    ((<= 1-EPSILON perpendicular-distance 1+EPSILON)
                     (proc (vertex-norm (vertex-& perpendicular-position origin)) pt perpendicular-position))
                    (else 
                     (let ((contact-position (vertex- perpendicular-position (vertex-scalar*& mvt-normalized (sqrt (- 1. (* perpendicular-distance perpendicular-distance)))))))
                       (proc (vertex-norm (vertex-& contact-position origin)) pt contact-position)))))))))))


(definition (unit-sphere-intersection center <f64vector> mvt <Movement>) <values>
  (let ((q (vertex-& center (get-origin~ mvt))))
    (let ((c (f64-ref (vertex-norm& q)))
          (v (f64-ref (dot-product& q (get-normal~ mvt)))))
      (let ((d (- 1. (- (* c c) (* v v)))))
        ;; Was there an intersection?
        (if (< d 0.)
            (values 0. #f)
          ;; Return the distance to the [first] intersecting point
          (values (- v (sqrt d)) #t))))))


(definition (is-embedded poly <Polygon> sphere-center <f64vector>) <f64vector+>
  ;; How far is the sphere from the plane?
  (let ((t (plane-to-point-distance poly sphere-center)))
    ;; If the plane is farther than the radius of the sphere it's not embedded
    (if (> t 1-EPSILON)
        #f
      ;; Find the closest point on the polygon to the center of the sphere
      (let ((inner-most-point (vertex-& sphere-center (vertex-scalar*& (get-normal~ poly) t))))
        ;; If the closest point on the plane is within the polygon the polygon is embedded
        (if (not (inside?~ poly inner-most-point EPSILON))
            (let ((inner-most (make-vertex&))
                  (e0 (make-vertex&))
                  (e1 (make-vertex&)))
              (let ((edge? (closest-point-on-perimeter!~ poly inner-most-point inner-most e0 e1)))
                (if (> (f64-ref (vertex-distance& inner-most sphere-center)) 1-EPSILON)
                    #f
                  (copy-vertex inner-most))))
          (copy-vertex inner-most-point))))))


(definition (is-point-inside-edge? a <f64vector> b <f64vector> p <f64vector>) <bool>
  (<= (f64-ref (dot-product& (vertex-& a p) (vertex-& b p))) 0.))


;;;
;;;; Collisions-Mark
;;;


(proclaim (not warn optimizations))


(class Collisions-Mark extends Mark
  
  
  (slot collisions initialize #f accessors generate)
  (slot loop-no    initialize #f accessors generate)
  
  
  (method override (initialize collisions loop-no)
    (nextmethod)
    (set! collisions~self collisions)
    (set! loop-no~self loop-no))
  
  
  (method meta override (marshall-object object)
    (serialize-object (class-of object)
                      (vector (serialize (map serialize (get-collisions~ object)))
                              (serialize (get-loop-no~ object)))))
  
  
  (method meta override (unmarshall-object content)
    (bind-vector (collisions loop-no) content
      (allocate self
                (deserialize (map deserialize collisions))
                (deserialize loop-no))))
  
  
  (method override (draw)
    (define (draw-polygons)
      (for-each (lambda (collision)
                  (let ((dye green-dye))
                    (for-each (lambda (poly)
                                (draw-polygon poly dye)
                                (set! dye yellow-dye))
                              (reverse (get-colliders~ collision)))))
                collisions))
    
    (define (draw-planes)
      (let ((dye (if (not loop-no)
                     green-dye
                   (case loop-no
                     ((0) red-dye)
                     ((1) purple-dye)
                     (else blue-dye)))))
        (for-each (lambda (collision)
                    (let ((plane (get-plane~ collision)))
                      (draw-plane plane dye)))
                  collisions)))
    
    (draw-polygons)
    (draw-planes))))
