;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Collision Detection
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.collision jazz


(import (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.draw)
        (world.dyes)
        (world.geometry)
        (world.homogeneous)
        (world.lookat)
        (world.mark)
        (world.movement)
        (world.plane)
        (world.polygon)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))


(definition debug?
  #f)

(definition (debugging . rest)
  (when debug?
    (apply debug rest)))


;;;
;;;; Collision
;;;


(proclaim (not warn optimizations))


(class Collision-Class extends (:class Object)
  
  
  (method override (marshall-object object)
    (serialize-object (class-of object)
                      (vector (serialize (get-polygon~ object))
                              (serialize (map serialize (get-colliders~ object)))
                              (serialize (get-plane~ object))
                              (serialize (get-distance~ object))
                              (serialize (get-type~ object)))))
  
  
  (method override (unmarshall-object content)
    (bind-vector (polygon colliders plane distance type) content
      (allocate self
                (deserialize polygon)
                (deserialize (map deserialize colliders))
                (deserialize plane)
                (deserialize distance)
                (deserialize type)))))


(proclaim (warn optimizations))


(class Collision metaclass Collision-Class extends Object
  
  
  (slot polygon   <Polygon> getter generate)
  (slot colliders <object>  accessors generate)
  (slot plane     <Plane>   getter generate)
  (slot distance  <fl>      getter generate)
  (slot type      <symbol>  getter generate)
  
  
  (method override (initialize polygon plane distance type)
    (debug-allocation Collision)
    (nextmethod)
    (set! polygon~self polygon)
    (set! colliders~self (list polygon))
    (set! plane~self plane)
    (set! distance~self distance)
    (set! type~self type))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a}" colliders plane distance type))))
  
  
  (method public (get-element)
    (get-element~ polygon)))


(definition public (copy-collision coll <Collision>) <Collision>
  (allocate Collision
            (copy-polygon~ (get-polygon~ coll))
            (map copy-polygon~ (get-colliders~ coll))
            (copy-plane (get-plane~ coll))
            (get-distance~ coll)
            (get-type~ coll)))

(definition public (copy-collisions cl)
  (map copy-collision cl))


(definition (transform-collisions cl matrix inverse-matrix)
  (map (lambda (coll)
         (transform-collision coll matrix inverse-matrix))
       cl))


(definition (transform-collision coll <Collision> matrix <f64vector> inverse-matrix <f64vector>) <Collision>
  (let ((poly (transform-polygon~ (get-polygon~ coll) matrix inverse-matrix))
        (colliders (map (lambda (poly <Polygon>) (transform-polygon~ poly matrix inverse-matrix)) (get-colliders~ coll)))
        (plane (transform-plane (get-plane~ coll) matrix inverse-matrix))
        (distance (get-distance~ coll))
        (type (get-type~ coll)))
    (let ((new-coll (new Collision poly plane distance type)))
      (set-colliders~ new-coll colliders)
      new-coll)))


;;;
;;;; Detection
;;;


(definition -EPSILON <fl>
  (- EPSILON))

(definition -2*EPSILON <fl>
  (* -EPSILON 2.))

(definition 1-EPSILON <fl>
  (- 1. EPSILON))

(definition 1+EPSILON <fl>
  (+ 1. EPSILON))


(definition sphere-radius <fl>
  1.)


(definition public (calculate-colliders sphere-matrix <f64vector> inverse-matrix <f64vector> mvt <Movement> travel-breadth <fx> max-distance <fl+> polygon-filter <procedure+> skip-list <list> ignore-entities? <bool> ignore-players? <bool>) <list>
  (define (collide poly <Polygon> result)
    (define (add-collision collision)
      (enqueue result collision))
    
    (unless (memq? poly skip-list)
      (let ((collision (collide-polygon poly mvt)))
        (when collision
          @debug-embedded
          (when (eq? (get-type~ collision) 'embedded)
            (debug 'embedded collision-distance))
          (unless (skimming-surface? collision)
            (if (null? (queue-list result))
                (add-collision collision)
              (let ((collision-distance (get-distance~ collision))
                    (result0 <Collision> (car (queue-list result))))
                (let ((d <fl> (abs (- collision-distance (get-distance~ result0)))))
                  (if (> d EPSILON)
                      (when (< collision-distance (get-distance~ result0))
                        (reset-queue result)
                        (add-collision collision))
                    ;; Make sure it's not already in the list (this plane's normal)
                    (let ((collision-normal (get-normal~ (get-plane~ collision))))
                      (let ((old-coll <Collision+>
                              (find-if (lambda (coll <Collision>)
                                         (when (> (f64-ref (dot-product& (get-normal~ (get-plane~ coll)) collision-normal)) 1-EPSILON)
                                           coll))
                                       (queue-list result))))
                        (if old-coll
                            (set-colliders~ old-coll (cons (copy-polygon~ poly) (get-colliders~ old-coll)))
                          (add-collision collision)))))))))))))
  
  (define (skimming-surface? collision <Collision>)
    (let ((contact-point (get-origin~ (get-plane~ collision)))
          (contact-position (movement-end-to& mvt (get-distance~ collision))))
      (< (abs (dot-product (vertex-& contact-point contact-position) (get-normal~ mvt))) EPSILON)))
  
  ;; Go through our list of potential colliders
  (site (calculate-colliders on?: #f)
    (let ((world (current-world))
          (zone (current-zone)))
      (receive (orig dir) (transform-ray/normalize (get-origin~ mvt) (get-vector~ mvt) inverse-matrix)
        (or (travel-ray-polygons&~ world
              (lambda (iterate)
                (site (collide on?: #f parent: calculate-colliders)
                  (let ((result (new-queue)))
                    (iterate
                      (lambda (poly <Polygon>)
                        (when (let ((lst (queue-list result)))
                                (or (null? lst)
                                    (>= (+ sphere-radius (get-radius~ poly) (get-distance~ (cast <Collision> (car lst))) EPSILON)
                                        (vertex-distance (get-origin~ mvt) (get-center~ poly)))))
                          (collide poly result))))
                    (let ((result (queue-list result)))
                      (and (not-null? result) result)))))
              orig
              dir
              sphere-radius
              travel-breadth
              (or max-distance (+ (get-area-size~ zone) sphere-radius))
              sphere-matrix
              filter: polygon-filter
              ignore-entities?: ignore-entities?
              ignore-players?: ignore-players?)
            '())))))


(definition (collide-polygon poly <Polygon> mvt <Movement>) <Collision+>
  ;; The goal through this loop is to calculate the collision plane
  (continuation-capture
    (lambda (return)
      (define (continue)
        (continuation-return return #f))
      
      (define (find-edge/point-collision)
        (let ((edge-collision (find-edge-collision poly mvt))
              (point-collision (find-point-collision poly mvt)))
          (cond ((not edge-collision) point-collision)
                ((not point-collision) edge-collision)
                (else
                 (if (< (get-distance~ edge-collision) (get-distance~ point-collision))
                     edge-collision
                   point-collision)))))
      
      ;; Ignore back-facing polygons
      (if (<= (plane-to-point-distance poly (get-origin~ mvt)) 0.) (continue))
      ;; Ignore polygons parallel to movement
      @introduces-a-regression-in-the-stairs (if (< (abs (dot-product (get-normal~ mvt) (get-normal~ poly))) EPSILON) (continue))
      ;; Find the point on the sphere that will eventually collide with the polygon's plane
      (let ((sphere-intersection-point (vertex-& (get-origin~ mvt) (get-normal~ poly))))
        ;; At this point we know we're in front of the current plane and we're heading toward it
        ;; Trace a ray to the plane
        (let ((sphere-intersection-ray (make-movement& sphere-intersection-point (get-normal~ mvt))))
          (receive (collision-distance <fl> intersect?) (intersect-plane poly sphere-intersection-ray)
            (if (not intersect?)
                (find-edge/point-collision)
              ;; If the polygon is embedded set the collision type and define a collision plane that is perpendicular
              ;; to the direction that the sphere must travel to be un-embedded
              (let ((inner-most-point (is-embedded poly (get-origin~ mvt))))
                (if inner-most-point
                    (let ((collision-distance (- (f64-ref (vertex-distance& inner-most-point (get-origin~ mvt))) sphere-radius))
                          (collision-plane (new Plane inner-most-point (vertex-normalize-safe& (vertex-& (get-origin~ mvt) inner-most-point)))))
                      (new Collision (copy-polygon~ poly) collision-plane collision-distance 'embedded))
                  ;; Surface/Edge/Point collision
                  (let ((plane-intersection-point (vertex+& sphere-intersection-point (vertex-scalar*& (get-normal~ mvt) collision-distance))))
                    ;; Surface collision?
                    (if (inside?~ poly plane-intersection-point EPSILON)
                        (let (;; Our collision plane is our polygon's plane
                              (collision-plane (new Plane plane-intersection-point (get-normal~ poly))))
                          ;; Is this a valid collision?
                          (when (< collision-distance -2*EPSILON) (continue))
                          ;; Was it an actual collision?
                          (when (> collision-distance (get-length~ mvt)) (continue))
                          ;; Ignore collision planes that we're traveling away from
                          (when (>= (f64-ref (dot-product& (get-normal~ collision-plane) (get-normal~ mvt))) 0.) (continue))
                          ;; Is it closer farther away or the same distance as what we've found so far?
                          (new Collision (copy-polygon~ poly) collision-plane collision-distance 'surface))
                      ;; Edge/Point collision
                      (find-edge/point-collision))))))))))))


;;;
;;;; Response
;;;


(definition (collide-movement& sphere-matrix <f64vector> origin <f64vector> target <f64vector>) <Movement>
  (let ((origin (matrix-transform-3x4 sphere-matrix origin))
        (target (matrix-transform-3x4 sphere-matrix target)))
    (make-movement& origin (vertex-& target origin))))


(definition (determine-travel-breadth radiuses <f64vector>) <fx>
  ;; quick try with a heuristic
  ;; max it at 2 for now since it has a huge impact on performance
  ;; could we limit breadth to the radius in the direction of our movement!?
  ;; would this work with rotation?
  (min 2 (fxceiling (vertex-norm radiuses))))


(definition collide-mutex
  (make-mutex 'collide))

(definition (with-collide-mutex thunk)
  (dynamic-wind
    (lambda () (mutex-lock! collide-mutex))
    thunk
    (lambda () (mutex-unlock! collide-mutex))))


(definition public (collide&stop origin <f64vector> target <f64vector> lookat <LookAt> radiuses <f64vector> (max-distance: max-distance #f) (polygon-filter: polygon-filter #f) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f) (debuggable-collisions?: debuggable-collisions? #f))
  (if (vertex=? origin target)
      (values origin (get-sight~ lookat) '())
    (with-collide-mutex
      (lambda ()
        (let ((zone (current-zone))
              (sphere-matrix (make-matrix&))
              (inverse-matrix (make-matrix&))
              (travel-breadth (determine-travel-breadth radiuses)))
          (sphere-matrices! sphere-matrix inverse-matrix origin lookat radiuses)
          (let ((mvt (collide-movement& sphere-matrix origin target)))
            (let ((cl (site (calculate-stop-colliders on?: #f parent: collide&stop) (calculate-colliders sphere-matrix inverse-matrix mvt travel-breadth max-distance polygon-filter '() ignore-entities? ignore-players?))))
              (when (and debug-collisions? debuggable-collisions? (not-null? cl))
                (add-mark~ zone
                  (new Collisions-Mark (transform-collisions cl inverse-matrix sphere-matrix) #f)))
              (let ((dest (if (null? cl)
                              (movement-end mvt)
                            (let ((cl0 <Collision> (car cl)))
                              ;; quick hack for a case that should only happen if the player is moved without
                              ;; going through collide&slide logic which is the case when we rotate the player
                              (if (eq? (get-type~ cl0) 'embedded)
                                  (vertex- (get-origin~ mvt) (vertex-scalar*& (get-normal~ (get-plane~ cl0)) (get-distance~ cl0)))
                                (let ((dist (get-distance~ cl0)))
                                  (if (< dist (get-length~ mvt))
                                      (movement-end-to mvt dist)
                                    (movement-end mvt))))))))
                (receive (dest dir) (transform-ray/normalize dest (get-vector~ mvt) inverse-matrix)
                  (values dest
                          dir
                          (transform-collisions cl inverse-matrix sphere-matrix)))))))))))


(definition collide-max-slide <fx>
  5)

(definition public (get-collide-max-slide) <fx>
  collide-max-slide)

(definition public (set-collide-max-slide max-slide <fx>) <void>
  (set! collide-max-slide max-slide))


(definition debug-collisions?
  #f)

(definition public (get-debug-collisions?)
  debug-collisions?)

(definition public (set-debug-collisions? flag)
  (set! debug-collisions? flag))


(definition public (collide&slide origin <f64vector> target <f64vector> lookat <LookAt> radiuses <f64vector> (max-distance: max-distance #f) (polygon-filter: polygon-filter #f) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f) (debuggable-collisions?: debuggable-collisions? #f))
  (if (vertex=? origin target)
      (values origin (get-sight~ lookat) '())
    (with-collide-mutex
      (lambda ()
        (let ((world (current-world))
              (zone (current-zone))
              (sphere-matrix (make-matrix&))
              (inverse-matrix (make-matrix&))
              (travel-breadth (determine-travel-breadth radiuses))
              (dir (vertex-normalize-safe& (vertex-& target origin))))
          (sphere-matrices! sphere-matrix inverse-matrix origin lookat radiuses)
          (let ((mvt (collide-movement& sphere-matrix origin target)))
            (let ((max-loops collide-max-slide)
                  (last-direction (vertex 0. 0. 0.))
                  (last-cl <list> '())
                  (second-to-last-cl <list> '())
                  (input-ray <Movement> (copy-movement& mvt))
                  (output-ray <Movement> (copy-movement& mvt))
                  (skip-list <list> '()))
              (define (skip-polygons coll <Collision>)
                (for-each (lambda (poly)
                            (set! skip-list (cons poly skip-list)))
                          (get-colliders~ coll)))
              
              ;; Sliding is an iterative process
              (let (iter (loop-no 0))
                (when (and (< loop-no max-loops)
                           (not (vertex-zero? (get-vector~ output-ray)))
                           (> (get-length~ output-ray) EPSILON))
                  ;; This is handy
                  (vertex-copy! last-direction (get-vector~ output-ray))
                  ;; Quicky to not redo the sphere-matrices! we did above
                  (when (> loop-no 0)
                    (movement-transform-3x4! output-ray inverse-matrix)
                    (sphere-matrices! sphere-matrix inverse-matrix (get-origin~ output-ray) lookat radiuses)
                    (movement-transform-3x4! output-ray sphere-matrix))
                  (let (;; Get the colliders
                        (cl (site (calculate-slide-colliders on?: #f parent: collide&slide) (calculate-colliders sphere-matrix inverse-matrix output-ray travel-breadth max-distance polygon-filter skip-list ignore-entities? ignore-players?))))
                    (when (and debug-collisions? debuggable-collisions? (not-null? cl))
                      (add-mark~ zone
                        (new Collisions-Mark (transform-collisions cl inverse-matrix sphere-matrix) loop-no)))
                    (when (not-null? cl)
                      (set! second-to-last-cl last-cl)
                      (set! last-cl cl))
                    ;; We can consider these polygons again
                    (set! skip-list '())
                    ;; If we didn't hit anything just return the destination
                    (if (null? cl)
                        (set-origin~ output-ray (movement-end& output-ray))
                      (let ((hit-count <fx> (length cl))
                            (hit-list cl)
                            (cl0 <Collision> (car cl)))
                        ;; If it was embedded push away
                        (if (eq? (get-type~ cl0) 'embedded)
                            ;; If it's embedded back up along the collision plane normal
                            (begin
                              (set-origin~ output-ray (vertex-& (get-origin~ output-ray) (vertex-scalar*& (get-normal~ (get-plane~ cl0)) (get-distance~ cl0))))
                              (iter (+ loop-no 1)))
                          (let ((world-plane (transform-plane (get-plane~ cl0) inverse-matrix sphere-matrix))
                                (world-ray (movement-transform-3x4 output-ray inverse-matrix)))
                            (let (@new (plane-slide-dst (plane-closest& world-plane (movement-end& world-ray)))
                                  @new (up (get-up~ lookat))
                                  (plane-slide-dst (plane-closest& (get-plane~ cl0) (movement-end& output-ray)))
                                  (up (get-up~ lookat)))
                              @debug
                              (terminal (< (abs (dot-product (get-normal~ world-plane) up)) EPSILON))
                              (let (@new
                                    (slide-dst (if (< (abs (dot-product (get-normal~ world-plane) up)) EPSILON)
                                                   (matrix-transform-3x4 sphere-matrix plane-slide-dst)
                                                 (let ((mvt (make-movement& (vertex+& (vertex-& (movement-end& world-ray) (get-origin~ world-ray)) (get-origin~ world-plane)) up)))
                                                   (receive (collision-distance intersect?) (intersect-plane world-plane mvt)
                                                     (let ((xz-dst (movement-end-to& mvt collision-distance)))
                                                       ;; could have a percentage here...
                                                       (matrix-transform-3x4 sphere-matrix (vertex+& (get-origin~ world-plane) (vertex-scalar*& (vertex-normalize-safe& (vertex-& xz-dst (get-origin~ world-plane))) (get-length~ world-ray)))))))))
                                    (slide-dst (if (< (abs (dot-product (get-normal~ (get-plane~ cl0)) up)) EPSILON)
                                                   plane-slide-dst
                                                 (let ((mvt (make-movement& (vertex+& (vertex-& (movement-end& output-ray) (get-origin~ output-ray)) (get-origin~ (get-plane~ cl0))) up)))
                                                   (receive (collision-distance intersect?) (intersect-plane (get-plane~ cl0) mvt)
                                                     (let ((xz-dst (movement-end-to& mvt collision-distance)))
                                                       ;; could have a percentage here...
                                                       (vertex+& (get-origin~ (get-plane~ cl0)) (vertex-scalar*& (vertex-normalize-safe& (vertex-& xz-dst (get-origin~ (get-plane~ cl0)))) (get-length~ output-ray)))))))))
                                @debug (
                                        (terminal '********)
                                        (terminal world-plane)
                                        (terminal (get-plane~ cl0))
                                        (format :terminal "{a}{%}" (present-vertex plane-slide-dst))
                                        (format :terminal "{a}{%}" (present-vertex (movement-end& world-ray)))
                                        (format :terminal "{a}{%}" (vertex-distance plane-slide-dst (movement-end& world-ray)))
                                        (format :terminal "{a}{%}" (present-vertex slide-dst))
                                        (format :terminal "{a}{%}" (present-vertex (movement-end& output-ray)))
                                        (format :terminal "{a}{%}" (vertex-distance slide-dst (movement-end& output-ray))))
                                (when (and debug-collisions? debuggable-collisions?)
                                  (add-mark~ zone (new Vertex-Mark (matrix-transform-3x4 inverse-matrix slide-dst) color: blue-dye)))
                                ;; We hit something -- move as far as we can
                                (set-origin~ output-ray (vertex+& (get-origin~ output-ray) (vertex-scalar*& (get-normal~ output-ray) (get-distance~ cl0))))
                                ;; If we hit two or more find the two with the most "pressure"
                                (if (>= hit-count 2)
                                    (let ((c0 0)
                                          (d0 2.))
                                      (loop (for i from 0 below hit-count)
                                            (let ((dot (f64-ref (dot-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list i)))) (get-normal~ output-ray)))))
                                              (when (< dot d0)
                                                (set! d0 dot)
                                                (set! c0 i))))
                                      (let ((c1 0)
                                            (d1 2.))
                                        (loop (for j from 0 below hit-count)
                                              (when (/= j c0)
                                                (let ((dot (f64-ref (dot-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list j)))) (get-normal~ output-ray)))))
                                                  (when (< dot d1)
                                                    (set! d1 dot)
                                                    (set! c1 j)))))
                                        ;; Temp vector
                                        (let ((temp-v (get-vector~ output-ray))
                                              ;; Point along the crease
                                              (perp (vertex-abs& (cross-product& (get-normal~ (get-plane~ (cast <Collision> (element hit-list c1))))
                                                                                 (get-normal~ (get-plane~ (cast <Collision> (element hit-list c0))))))))
                                          (set! temp-v (vertex* temp-v perp))
                                          (if (< (f64-ref (vertex-norm& temp-v)) EPSILON)
                                              (iter (+ loop-no 1))
                                            (vertex-normalize! temp-v temp-v)
                                            (vertex-scalar*! temp-v temp-v (f64-ref (vertex-norm& (get-vector~ output-ray))))
                                            ;; Find out how much to scale our vector that points along the crease
                                            (let ((n1 (vertex-normalize& temp-v))
                                                  (n2 (vertex-normalize& (get-vector~ output-ray))))
                                              (let ((scalar (f64-ref (dot-product& n1 n2))))
                                                ;; New vector is new direction vector scaled
                                                (set-vector~ output-ray (vertex-scalar*& temp-v scalar))))
                                            (vertex-copy! last-direction (get-vector~ output-ray))
                                            ;; Don't collide with these next time
                                            (skip-polygons (cast <Collision> (element hit-list c0)))
                                            (skip-polygons (cast <Collision> (element hit-list c1)))
                                            (iter (+ loop-no 1))))))
                                  ;; Otherwise we slide
                                  (let ((slide-src (plane-closest& (get-plane~ cl0) (get-origin~ output-ray))))
                                    (set-vector~ output-ray (vertex-& slide-dst slide-src)))
                                  (vertex-copy! last-direction (get-vector~ output-ray))
                                  ;; Don't collide with this one next time
                                  (skip-polygons cl0)
                                  (iter (+ loop-no 1))))))))))))
              (receive (dest dir) (transform-ray/normalize (get-origin~ output-ray) last-direction inverse-matrix)
                (values dest
                        dir
                        (transform-collisions (union last-cl second-to-last-cl) inverse-matrix sphere-matrix))))))))))


;;;
;;;; Utility
;;;


(definition (find-edge-collision poly <Polygon> mvt <Movement>) <Collision+>
  (let ((closest-contact-point #f)
        (closest-contact-position #f)
        (closest-distance +inf.0 @w (get-length~ mvt))
        (vertices (get-vertices~ poly)))
    (let ((vertex-count <fx> (length vertices)))
      (loop (for i from 0 below vertex-count)
            (let ((p1 (vector-ref vertices i))
                  (p0 (vector-ref vertices (cast <fx> (let ((j (- i 1))) (if (< j 0) (- vertex-count 1) j))))))
              (edge-sphere-collision& p0 p1 mvt
                (lambda (contact-dist <fl> contact-point <f64vector> contact-position <f64vector>)
                  (when (< contact-dist closest-distance)
                    (set! closest-contact-point (copy-vertex contact-point))
                    (set! closest-contact-position (copy-vertex contact-position))
                    (set! closest-distance contact-dist)))))))
    (and closest-contact-point
         (< closest-distance (get-length~ mvt))
         (new Collision (copy-polygon~ poly) (new Plane closest-contact-point (vertex-normalize& (vertex-& closest-contact-position closest-contact-point))) closest-distance 'edge))))


(definition (edge-sphere-collision& p1 <f64vector> p2 <f64vector> mvt <Movement> proc) <void>
  ;; finds the time of collision of the sphere with the edge
  ;; if the sphere is moving towards the edge line in the working plane (*).
  ;; and if the sphere intersects this plane (there is obviously no collision if the later condition doesn't hold)
  ;; #f otherwise
  ;; (*) the plane parallel to the movement and where the edge lies is called the working plane
  ;; the case where the sphere would collide with an edge is not covered here (yet)
  ;; edge or movement line refers to the infinite line covering the edge or the movement respectively.
  (let ((normal (cross-normal-safe& (vertex-& p1 p2) (get-vector~ mvt))) ;; normal to the working plane
        (origin (get-origin~ mvt)))
    (let ((line-dist <fl> (let ((dist (dot-product normal (vertex-& p1 origin)))) ;; minimal distance between the movement line and the edge line.
                            (if (<= 1-EPSILON (abs dist) 1+EPSILON)
                                (cast <fl> (sign dist))
                              dist))))
      (unless (or (vertex-zero? normal)
                  (> (abs line-dist) sphere-radius)) ;; testing for the second condition
        (let ((radius-secant (sqrt (- 1. (* line-dist line-dist)))) ;; radius of the cercle : intersection of the sphere and the working plane
              (origin-secant (vertex+& origin (vertex-scalar*& normal line-dist))) ;; projection of the origin of the movement on the working-plane
              (perpendicular (cross-normal-safe& normal (vertex-& p1 p2)))) ;; perpendicular to the edge in the working plane
          (let ((distance-secant (dot-product perpendicular (vertex-& origin-secant p1))) ;; distance between the edge line and the projection of the origin
                (closing-speed (dot-product perpendicular (get-vector~ mvt)))) ;; component of vector (displacement) moving towards the edge line.
            ;; the first condition doesn't hold, the circle is not moving toward the edge line
            ;; either it is moving away or the cercle is already touching the edge line - the later is not yet covered here
            (when (or (and (> closing-speed 0.) (< distance-secant (- EPSILON radius-secant)))
                      (and (< closing-speed 0.) (> distance-secant (- radius-secant EPSILON))))
              (let ((contact-dist (* (get-length~ mvt) (/ (- (abs distance-secant) radius-secant) (abs closing-speed))))
                    (radius-direction (if (> distance-secant 0.) (- radius-secant) radius-secant)))
                (let ((contact-position (movement-end-to& mvt contact-dist)))
                  (let ((contact-point (vertex+& (vertex-& contact-position origin)
                                                 (vertex+& origin-secant (vertex-scalar*& perpendicular radius-direction)))))
                    (when (is-point-inside-edge? p1 p2 contact-point)
                      (proc contact-dist contact-point contact-position))))))))))))


(definition (find-point-collision poly <Polygon> mvt <Movement>) <Collision+>
  (let ((closest-contact-point #f)
        (closest-contact-position #f)
        (closest-distance (get-length~ mvt))
        (vertices (get-vertices~ poly)))
    (let ((vertex-count <fx> (length vertices)))
      (loop (for i from 0 below vertex-count)
            (let ((pt (vector-ref vertices i)))
              (point-sphere-collision& pt mvt
                (lambda (contact-dist <fl> contact-point <f64vector> contact-position <f64vector>)
                  (when (< contact-dist closest-distance)
                    (set! closest-contact-point (copy-vertex contact-point))
                    (set! closest-contact-position (copy-vertex contact-position))
                    (set! closest-distance contact-dist)))))))
    (and closest-contact-point
         (new Collision (copy-polygon~ poly) (new Plane closest-contact-point (vertex-normalize& (vertex-& closest-contact-position closest-contact-point))) closest-distance 'point))))


(definition (point-sphere-collision& pt <f64vector> mvt <Movement> proc) <void>
  (let ((mvt-normalized (get-normal~ mvt))
        (origin (get-origin~ mvt)))
    (let ((dist (dot-product mvt-normalized (vertex-& pt origin))))
      (when (>= dist 0.)
        (let ((perpendicular-position (vertex+& origin (vertex-scalar*& mvt-normalized dist))))
          (let ((perpendicular-radius (vertex-& pt perpendicular-position)))
            (let ((perpendicular-distance (vertex-norm perpendicular-radius)))
              (cond ((< 1+EPSILON perpendicular-distance)
                     )
                    ((<= 1-EPSILON perpendicular-distance 1+EPSILON)
                     (proc (vertex-norm (vertex-& perpendicular-position origin)) pt perpendicular-position))
                    (else 
                     (let ((contact-position (vertex- perpendicular-position (vertex-scalar*& mvt-normalized (sqrt (- 1. (* perpendicular-distance perpendicular-distance)))))))
                       (proc (vertex-norm (vertex-& contact-position origin)) pt contact-position)))))))))))


(definition (unit-sphere-intersection center <f64vector> mvt <Movement>) <values>
  (let ((q (vertex-& center (get-origin~ mvt))))
    (let ((c (f64-ref (vertex-norm& q)))
          (v (f64-ref (dot-product& q (get-normal~ mvt)))))
      (let ((d (- 1. (- (* c c) (* v v)))))
        ;; Was there an intersection?
        (if (< d 0.)
            (values 0. #f)
          ;; Return the distance to the [first] intersecting point
          (values (- v (sqrt d)) #t))))))


(definition (is-embedded poly <Polygon> sphere-center <f64vector>) <f64vector+>
  ;; How far is the sphere from the plane?
  (let ((t (plane-to-point-distance poly sphere-center)))
    ;; If the plane is farther than the radius of the sphere it's not embedded
    (if (> t 1-EPSILON)
        #f
      ;; Find the closest point on the polygon to the center of the sphere
      (let ((inner-most-point (vertex-& sphere-center (vertex-scalar*& (get-normal~ poly) t))))
        ;; If the closest point on the plane is within the polygon the polygon is embedded
        (if (not (inside?~ poly inner-most-point EPSILON))
            (let ((inner-most (make-vertex&))
                  (e0 (make-vertex&))
                  (e1 (make-vertex&)))
              (let ((edge? (closest-point-on-perimeter!~ poly inner-most-point inner-most e0 e1)))
                (if (> (f64-ref (vertex-distance& inner-most sphere-center)) 1-EPSILON)
                    #f
                  (copy-vertex inner-most))))
          (copy-vertex inner-most-point))))))


(definition (is-point-inside-edge? a <f64vector> b <f64vector> p <f64vector>) <bool>
  (<= (f64-ref (dot-product& (vertex-& a p) (vertex-& b p))) 0.))


;;;
;;;; Collisions-Mark
;;;


(proclaim (not warn optimizations))


(class Collisions-Mark extends Mark
  
  
  (slot collisions initialize #f accessors generate)
  (slot loop-no    initialize #f accessors generate)
  
  
  (method override (initialize collisions loop-no)
    (nextmethod)
    (set! collisions~self collisions)
    (set! loop-no~self loop-no))
  
  
  (method meta override (marshall-object object)
    (serialize-object (class-of object)
                      (vector (serialize (map serialize (get-collisions~ object)))
                              (serialize (get-loop-no~ object)))))
  
  
  (method meta override (unmarshall-object content)
    (bind-vector (collisions loop-no) content
      (allocate self
                (deserialize (map deserialize collisions))
                (deserialize loop-no))))
  
  
  (method override (draw)
    (define (draw-polygons)
      (let ((polygons (apply append (map get-colliders~ collisions))))
        (for-each (lambda (poly)
                    (draw-polygon poly green-dye))
                  polygons)))
    
    (define (draw-planes)
      (let ((dye (if (not loop-no)
                     green-dye
                   (case loop-no
                     ((0) red-dye)
                     ((1) purple-dye)
                     (else blue-dye)))))
        (for-each (lambda (collision)
                    (let ((plane (get-plane~ collision)))
                      (draw-plane plane dye)))
                  collisions)))
    
    (draw-polygons)
    (draw-planes))))
