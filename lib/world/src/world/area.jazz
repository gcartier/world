;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Areas
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.area jazz


(import (world.polygon)
        (world.syntax (phase syntax)))


;;;
;;;; Area
;;;


(class Area extends Object
  
  
  (slot index             <vector>                 getter generate)
  (slot polygons          <vector+> initialize #f  accessors generate)
  (slot polygons-elements <vector+> initialize #f  accessors generate)
  (slot blocks            <list>    initialize '() accessors generate)
  (slot actors            <list>    initialize '() accessors generate)
  (slot entities          <list>    initialize '() accessors generate)
  (slot gadgets           <list>    initialize '() accessors generate)
  (slot visit             <fx>      initialize -1  accessors generate)
  
  
  (method override (initialize index)
    (set! index~self index))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((polygons (if (not polygons) 0 (/ (vector-length polygons) polygon-float-size)))
              (actors (length actors))
              (gadgets (length gadgets)))
          (format output
                  "{a}{a}{a}{a}"
                  (format "{a}, {a}, {a}{a}" (vector-ref index 0) (vector-ref index 1) (vector-ref index 2) (if (or (/= polygons 0) (/= actors 0)) " with " ""))
                  (if (= polygons 0) "" (format "{a} polygon{a}" polygons (format-plural polygons)))
                  (if (= actors 0) "" (format "{a}{a} actor{a}" (if (= polygons 0) "" ", ") actors (format-plural actors)))
                  (if (= gadgets 0) "" (format "{a}{a} gadget{a}" (if (and (= polygons 0) (= actors 0)) "" ", ") gadgets (format-plural gadgets))))))))
  
  
  (method (iterate-polygons proc)
    (when polygons
      (loop (for i from 0 below (/ (f64vector-length polygons) polygon-float-size))
            (let ((offset (* i polygon-float-size)))
              (proc (and polygons-elements (vector-ref polygons-elements i))
                    polygons
                    offset)))))
  
  
  (method (add-polygons element lst matrix)
    (define (add-at vect offset)
      (for-each (lambda (poly)
                  (polygon-move!~ poly vect offset matrix)
                  (increase! offset polygon-float-size))
                lst))
    
    (let ((count (length lst)))
      (let ((add (* count polygon-float-size)))
        (cond ((not polygons)
               (let ((vect (make-f64vector add)))
                 (add-at vect 0)
                 (set! polygons vect))
               (when element
                 (set! polygons-elements (make-vector count element))))
              (else
               (let ((actual (f64vector-length polygons)))
                 (let ((vect (make-f64vector (+ actual add))))
                   (subf64vector-move! polygons 0 actual vect 0)
                   (add-at vect actual)
                   (set! polygons vect))
                 (when (or polygons-elements element)
                   (let ((actual-count (/ actual polygon-float-size)))
                     (let ((vect (make-vector (+ actual-count count) element)))
                       (if (not polygons-elements)
                           (subvector-fill! vect 0 actual-count #f)
                         (subvector-move! polygons-elements 0 actual-count vect 0))
                       (set! polygons-elements vect))))))))))
  
  
  (method (remove-polygons element)
    (when polygons
      (let ((count 0))
        (iterate-polygons
          (lambda (elem vect offset)
            (when (neq? elem element)
              (increase! count))))
        (let ((vect (make-f64vector (* count polygon-float-size)))
              (vect-offset 0)
              (vect-elements (and polygons-elements (make-vector count)))
              (vect-elements-offset 0))
          (iterate-polygons
            (lambda (elem polygons offset)
              (when (neq? elem element)
                (subf64vector-move! polygons offset (+ offset polygon-float-size) vect vect-offset)
                (increase! vect-offset polygon-float-size)
                (when vect-elements
                  (vector-set! vect-elements vect-elements-offset elem)
                  (increase! vect-elements-offset)))))
          (set! polygons vect)
          (set! polygons-elements vect-elements)))))
  
  
  (method (clear-polygons)
    (set! polygons #f)
    (set! polygons-elements #f))
  
  
  (method (iterate-entities proc)
    (for-each proc actors)
    (for-each proc entities)
    (for-each proc gadgets))))
