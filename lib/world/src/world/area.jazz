;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Areas
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.area jazz


(import (world)
        (world.autoload)
        (world.index)
        (world.polygon)
        (world.syntax (phase syntax)))


;;;
;;;; Area
;;;


(class Area extends Object
  
  
  (slot index             <vector>                    getter generate)
  (slot sector            <Sector>                    getter generate)
  (slot polygons          <f64vector+> initialize #f  accessors generate)
  (slot polygons-elements <vector+>    initialize #f  accessors generate)
  (slot actors            <list>       initialize '() accessors generate)
  (slot entities          <list>       initialize '() accessors generate)
  (slot gadgets           <list>       initialize '() accessors generate)
  (slot visit             <fx>         initialize -1  accessors generate)
  
  
  (method override (initialize index sector)
    (set! index~self index)
    (set! sector~self sector))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((polygons (if (not polygons) 0 (fxround/ (vector-length polygons) polygon-float-size)))
              (actors (length actors))
              (gadgets (length gadgets)))
          (format output
                  "{a}{a}{a}{a}"
                  (format "{a}, {a}, {a}{a}" (vector-ref index 0) (vector-ref index 1) (vector-ref index 2) (if (or (/= polygons 0) (/= actors 0)) " with " ""))
                  (if (= polygons 0) "" (format "{a} polygon{a}" polygons (format-plural polygons)))
                  (if (= actors 0) "" (format "{a}{a} actor{a}" (if (= polygons 0) "" ", ") actors (format-plural actors)))
                  (if (= gadgets 0) "" (format "{a}{a} gadget{a}" (if (and (= polygons 0) (= actors 0)) "" ", ") gadgets (format-plural gadgets))))))))
  
  
  (proclaim (warn optimizations))
  
  
  (method (iterate-polygons env proc)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (when polygons
      (loop (for i from 0 below (fxround/ (f64vector-length polygons) polygon-float-size))
            (let ((offset (* i polygon-float-size)))
              (proc env
                    (and polygons-elements (vector-ref polygons-elements i))
                    polygons
                    offset)))))


  (proclaim (not warn optimizations))
  
  
  (method (add-polygons element lst matrix)
    (define (add-at vect offset)
      (for-each (lambda (poly)
                  (polygon-move!~ poly vect offset matrix)
                  (increase! offset polygon-float-size))
                lst))
    
    (let ((count (length lst)))
      (let ((add (* count polygon-float-size)))
        (cond ((not polygons)
               (let ((vect (make-f64vector add)))
                 (add-at vect 0)
                 (set! polygons vect))
               (when element
                 (set! polygons-elements (make-vector count element))))
              (else
               (let ((actual (f64vector-length polygons)))
                 (let ((vect (make-f64vector (+ actual add))))
                   (subf64vector-move! polygons 0 actual vect 0)
                   (add-at vect actual)
                   (set! polygons vect))
                 (when (or polygons-elements element)
                   (let ((actual-count (fxround/ actual polygon-float-size)))
                     (let ((vect (make-vector (+ actual-count count) element)))
                       (if (not polygons-elements)
                           (subvector-fill! vect 0 actual-count #f)
                         (subvector-move! polygons-elements 0 actual-count vect 0))
                       (set! polygons-elements vect))))))))))
  
  
  (method (remove-polygons element)
    (when polygons
      (let ((count 0))
        (iterate-polygons #f
          (lambda (env elem vect offset)
            (when (neq? elem element)
              (increase! count))))
        (let ((vect (make-f64vector (* count polygon-float-size)))
              (vect-offset 0)
              (vect-elements (and polygons-elements (make-vector count)))
              (vect-elements-offset 0))
          (iterate-polygons #f
            (lambda (env elem polygons offset)
              (when (neq? elem element)
                (subf64vector-move! polygons offset (+ offset polygon-float-size) vect vect-offset)
                (increase! vect-offset polygon-float-size)
                (when vect-elements
                  (vector-set! vect-elements vect-elements-offset elem)
                  (increase! vect-elements-offset)))))
          (set! polygons vect)
          (set! polygons-elements vect-elements)))))
  
  
  (method (clear-polygons)
    (set! polygons #f)
    (set! polygons-elements #f))
  
  
  (method (iterate-entities proc)
    (for-each proc actors)
    (for-each proc entities)
    (for-each proc gadgets)))


;;;
;;;; Area Cube
;;;


(proclaim (warn optimizations))


(class Area-Cube extends Object
  
  
  (slot cube-radius     <fx>     getter generate)
  (slot cube-diameter   <fx>     getter generate)
  (slot cube-diameter^2 <fx>     getter generate)
  (slot cube-diameter^3 <fx>     getter generate)
  (slot cube-areas      <vector> getter generate)
  (slot cube-index      <vector> getter generate)
  (slot cube-inited?    <bool>   getter generate)
  
  
  (method override (initialize radius)
    (set! cube-radius radius)
    (set! cube-diameter (+ cube-radius 1 cube-radius))
    (set! cube-diameter^2 (expt cube-diameter 2))
    (set! cube-diameter^3 (expt cube-diameter 3))
    (set! cube-areas (make-vector cube-diameter^3 #f))
    (set! cube-index (make-index))
    (set! cube-inited? #f))
  
  
  (method (areas-index i <fx> j <fx> k <fx>) <fx>
    (+ (* j cube-diameter^2) (* k cube-diameter) i))
  
  
  (method (get-areas pos) <vector>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((zone (current-zone)))
      (let ((index (position-area-index&~ zone pos)))
        (if (and cube-inited? (equal? index cube-index))
            cube-areas
          ;; update areas
          (let ((areas cube-areas)
                (a (- (index-x index) cube-radius))
                (b (- (index-y index) cube-radius))
                (c (- (index-z index) cube-radius)))
            (define (area-new i j k)
              ;; commented until cleanup finished
              ;; (new-area (vector i j k))
              (coordinates-area~ zone i j k))
            
            (define (area-free area)
              ;; commented until cleanup finished
              ;; (close~ area)
              )
            
            (if (not cube-inited?)
                (begin
                  (loop (for i from 0 below cube-diameter)
                        (loop (for j from 0 below cube-diameter)
                              (loop (for k from 0 below cube-diameter)
                                    (vector-set! areas (areas-index i j k)
                                      (area-new (+ a i)
                                                (+ b j)
                                                (+ c k))))))
                  (set! cube-inited? #t))
              (let ((last (- cube-diameter 1))
                    (dx (- (index-x index) (index-x cube-index)))
                    (dy (- (index-y index) (index-y cube-index)))
                    (dz (- (index-z index) (index-z cube-index))))
                (define (by delta <fx>)
                  (if (>= delta 0)
                      1
                    -1))
                
                (loop (for x start 0 end last by (by dx))
                      (let ((fx (+ x dx))
                            (tx x))
                        (loop (for y start 0 end last by (by dy))
                              (let ((fy (+ y dy))
                                    (ty y))
                                (loop (for z start 0 end last by (by dz))
                                      (let ((fz (+ z dz))
                                            (tz z))
                                        (let ((fi (and (between? fx 0 last)
                                                       (between? fy 0 last)
                                                       (between? fz 0 last)
                                                       (areas-index fx fy fz)))
                                              (ti (areas-index tx ty tz)))
                                          (let ((area (vector-ref areas ti)))
                                            (when area
                                              ;; free
                                              (area-free area)))
                                          (if fi
                                              (begin
                                                ;; move
                                                (vector-set! areas ti (vector-ref areas fi))
                                                (vector-set! areas fi #f))
                                            ;; new
                                            (vector-set! areas ti (area-new (+ a tx) (+ b ty) (+ c tz))))))))))))))
          ;; return areas
          (index-copy! cube-index index)
          cube-areas))))
  
  
  (method (iterate-neighbor-areas pos distance <fx> proc)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((zone (current-zone)))
      (let ((index (position-area-index&~ zone pos)))
        (let ((di (- (index-x index) (index-x cube-index)))
              (dj (- (index-y index) (index-y cube-index)))
              (dk (- (index-z index) (index-z cube-index)))
              (lower (- cube-radius distance))
              (upper (+ cube-radius distance))
              (last (- cube-diameter 1)))
          (loop (for i from lower to upper)
                (loop (for j from lower to upper)
                      (loop (for k from lower to upper)
                            (let ((a (+ i di))
                                  (b (+ j dj))
                                  (c (+ k dk)))
                              (let ((area <Area> (if (and (between? a 0 last)
                                                          (between? b 0 last)
                                                          (between? c 0 last))
                                                     (vector-ref cube-areas (areas-index a b c))
                                                   (index-area~ zone index))))
                                (update-physical~ (get-sector~ area))
                                (proc area))))))))))))
