;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Areas
;;;


(module world.area jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.actor)
        (world.autoload)
        (world.block)
        (world.element)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.polygon)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle)
        (world.window)
        (world.client.window))


;;;
;;;; Area
;;;


(class Area extends Object
  
  
  (slot index    <vector>                 getter generate)
  (slot elements <vector+> initialize #f  accessors generate)
  (slot polygons <vector+> initialize #f  accessors generate)
  (slot tiles    <list>    initialize '() accessors generate)
  (slot actors   <list>    initialize '() accessors generate)
  (slot gadgets  <list>    initialize '() accessors generate)
  (slot visit    <fx>      initialize -1  accessors generate)
  
  
  (method override (initialize index)
    (set! index~self index))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((polygons (if (not polygons) 0 (vector-length polygons)))
              (actors (length actors))
              (gadgets (length gadgets)))
          (format output
                  "{a}{a}{a}{a}"
                  (format "{a}, {a}, {a}{a}" (vector-ref index 0) (vector-ref index 1) (vector-ref index 2) (if (or (/= polygons 0) (/= actors 0)) " with " ""))
                  (if (= polygons 0) "" (format "{a} polygon{a}" polygons (format-plural polygons)))
                  (if (= actors 0) "" (format "{a}{a} actor{a}" (if (= polygons 0) "" ", ") actors (format-plural actors)))
                  (if (= gadgets 0) "" (format "{a}{a} gadget{a}" (if (and (= polygons 0) (= actors 0)) "" ", ") gadgets (format-plural gadgets))))))))
  
  
  (method (iterate-polygons proc)
    (when polygons
      (for (i 0 (/ (f64vector-length polygons) polygon-float-size))
           (let ((offset (* i polygon-float-size)))
             (proc (and elements (vector-ref elements i))
                   polygons
                   offset)))))
  
  
  (method (add-polygons element lst)
    (define (add-at vect offset)
      (for-each (lambda (poly)
                    (polygon-move!~ poly vect offset)
                    (increase! offset polygon-float-size))
                  lst))
    
    (let ((count (length lst)))
      (let ((add (* count polygon-float-size)))
        (cond ((not polygons)
               (let ((vect (make-f64vector add)))
                 (add-at vect 0)
                 (set! polygons vect))
               (when element
                 (set! elements (make-vector count element))))
              (else
               (let ((actual (f64vector-length polygons)))
                 (let ((vect (make-f64vector (+ actual add))))
                   (subf64vector-move! polygons 0 actual vect 0)
                   (add-at vect actual)
                   (set! polygons vect))
                 (when (or elements element)
                   (let ((actual-count (/ actual polygon-float-size)))
                     (let ((vect (make-vector (+ actual-count count) element)))
                       (when elements
                         (subvector-move! elements 0 actual-count vect 0))
                       (set! elements vect))))))))))
  
  
  (method (remove-polygons element)
    (when polygons
      (let ((count 0))
        (iterate-polygons
          (lambda (elem vect offset)
            (when (neq? elem element)
              (increase! count))))
        (let ((vect (make-f64vector (* count polygon-float-size)))
              (vect-offset 0)
              (vect-elements (and elements (make-vector count)))
              (vect-elements-offset 0))
          (iterate-polygons
            (lambda (elem polygons offset)
              (when (neq? elem element)
                (subf64vector-move! polygons offset (+ offset polygon-float-size) vect vect-offset)
                (increase! vect-offset polygon-float-size)
                (when vect-elements
                  (vector-set! vect-elements vect-elements-offset elem)
                  (increase! vect-elements-offset)))))
          (set! polygons vect)
          (set! elements vect-elements))))))


;;;
;;;; Polygon
;;;


(definition public (f64vector->polygon elem vect <f64vector> offset <fx> sphere-matrix)
  (if (nan? (f64vector-ref vect (+ offset 15)))
      (f64vector->triangle elem vect offset sphere-matrix)
    (f64vector->quad elem vect offset sphere-matrix))))
