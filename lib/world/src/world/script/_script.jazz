;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Scripts
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.script jazz


(export (world)
        (world.audio)
        (world.autoload)
        (world.commands)
        (world.draw)
        (world.dyes)
        (world.geometry)
        (world.mark)
        (world.scripting)
        (world.script.syntax (phase syntax))
        (world.syntax (phase syntax))
        (world.travel))

(import (jazz.geometry)
        (jazz.graphic)
        (world)
        (world.actor)
        (world.audio)
        (world.autoload)
        (world.billboard)
        (world.commands)
        (world.creature)
        (world.entity)
        (world.generation)
        (world.geometry)
        (world.mark)
        (world.homogeneous)
        (world.model)
        (world.scripting)
        (world.syntax (phase syntax))
        (world.travel))


(definition public (animate actor animation (next: next #f))
  (assert (find-animation~ (cache-model~ actor) animation))
  (transition-morphing~ actor animation next: (or next "Idle"))
  (set-animation-active~ actor animation))


(definition public (creatures)
  (let ((zone (current-zone)))
    (get-creatures~ zone)))


(definition public (block-interact a b c)
  (let ((game (current-game)))
    (interact-at~ game (location->position (vector a b c)))))

(definition public (set-block-data a b c data)
  (let ((game (current-game))
        (zone (current-zone)))
    (updating-sectors~ zone
      (lambda (add-sector)
        (call-with-position~ zone (location->position (vector a b c))
          (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
            (with-field i j k
              (lambda (section index)
                (data-set! section index data)
                (add-sector sector)))))))))


;;;
;;;; World
;;;


(definition public (message msg)
  (let ((world (current-world)))
    (display-message~ world msg)))


;;;
;;;; Sound
;;;


(definition public bark
  "sound/random/dog_barking")


(definition public (sound path (volume: volume #f))
  (when sounds?
    (let ((sound (cache-stream-sound path)))
      (unless (playing?~ sound)
        (when volume
          (set-volume~ sound volume))
        (play~ sound)))))


;;;
;;;; Actor
;;;


(definition public (current-actor)
  (if (current-event)
      (get-actor~ (current-event))
    (current-instance)))


(definition public (event-me)
  (get-actor~ (current-event)))

(definition public (event-time)
  (get-time~ (current-event)))

(definition public (event-elapse)
  (get-elapse~ (current-event)))


(definition public (lookat-horizon dir)
  (horizon-lookat (vertex-normalize& (vertex& (vertex-x dir) 0. (vertex-z dir)))))


(definition public (near-player? (actor #f) (distance #f))
  (let ((actor (or actor (current-actor)))
        (distance (or distance 5.)))
    (<= (vertex-distance (get-position~ actor) (get-position~ (current-me))) distance)))


(definition public (lookat-player (actor #f))
  (let ((actor (or actor (current-actor))))
    (let ((dir (vertex-& (get-position~ (current-me)) (get-position~ actor))))
      (set-lookat actor (lookat-horizon dir)))))

(definition public (lookat-target target (actor #f))
  (let ((actor (or actor (current-actor))))
    (let ((dir (vertex- target (get-position~ actor))))
      (set-lookat actor (lookat-horizon dir)))))


(definition public (lookat-rotate element angle)
  (set-lookat~ element (rotate-lookat (get-lookat~ element) (degree->radian angle) (vertex 0. 1. 0.))))


(definition public stay-commands
  (new Commands))

(definition public move-commands
  (let ((commands (new Commands)))
    (move-forward~ commands)
    commands))

(definition public sprint-commands
  (let ((commands (new Commands)))
    (sprint-forward~ commands)
    commands))

(definition public jump-commands
  (let ((commands (new Commands)))
    (jump~ commands)
    commands))


(definition public (move-to target)
  )


(definition public (stay)
  (perform stay-commands))

(definition public (move)
  (perform move-commands))

(definition public (sprint)
  (perform sprint-commands))

(definition public (hover)
  (perform move-commands gravity?: #f))

(definition public (jump)
  (perform jump-commands))

(definition public (hostile)
  (let ((event (current-event)))
    (tick-hostile~ (get-actor~ event)
      (get-time~ event)
      (get-elapse~ event)
      (get-exit~ event))))


(definition public (get-position element)
  (assert (is? element Element))
  (get-position~ element))


(definition public (set-position element position)
  (assert (is? element Element))
  (set-position~ element position))

(definition public (set-lookat element direction/lookat)
  (assert (is? element Element))
  (let ((lookat (if (f64vector? direction/lookat)
                    (lookat-horizon direction/lookat)
                  direction/lookat)))
    (set-lookat~ element lookat)))

(definition public (set-speed element speed)
  (assert (is? element Element))
  (set-speed~ element speed))


(definition public (set-motion actor motion)
  (assert (is? actor Actor))
  (set-motion~ actor motion))


(definition public (set-hover? actor flag)
  (assert (is? actor Actor))
  (set-hover?~ actor flag))


(definition public (set-tick-handler actor handler)
  (set-script-tick~ actor handler))

(definition public (set-idle-handler actor handler)
  (set-script-idle~ actor handler))

(definition public (set-interact-handler actor handler)
  (set-script-interact~ actor handler))


(definition public (perform commands (gravity?: gravity? #t))
  (assert (is? commands Commands))
  (let ((event (current-event)))
    (let ((actor (get-actor~ event))
          (time (get-time~ event))
          (elapse (get-elapse~ event)))
      (tick-actor~ actor commands time elapse gravity? 'slide))))


(definition public (set-billboard actor text)
  (set-billboard-texture~ actor (make-billboard-element (list text {Font font-name: tahoma point-size: 36 hint-style: slight hint-metrics: on} {Color World-Yellow} 2.))))


;;;
;;;; Model
;;;


(definition public (get-model entity)
  (assert (is? entity Entity))
  (cache-model~ entity))


(definition public (set-run-speed model speed)
  (assert (is? model Model))
  (set-run-speed~ model speed))


;;;
;;;; Pathing
;;;


(definition protected (tick-dwarf)
  (when (and #t (< (get-velocity-angle~ (self)) 1.5))
    (debug (get-velocity-angle~ (self)))
    (get-stuck))
  (if moving-to-player?
      (begin
        (lookat-player)
        (if (near-player? (self) 3.)
            (stay)
          (move)))
    (lookat-target (car target-pos))
    (move))
  (unless moving-to-player?
    (when (near-target? (self) (car target-pos) 0.1)
      (reach-target))))

(definition protected (self)
  (current-actor))

(definition protected (player)
  (current-me))

(definition protected toggle-locations
  (let ((show-locations? #f))
    (lambda ()
      (let ((zone (current-zone)))
        (if show-locations?
            (begin
              (reset-marks~ zone)
              (set! show-locations? #f))
          (for-each
            (lambda (location)
              (add-mark~ zone (new Position-Mark (car location))))
            locations)
          (set! show-locations? #t))))))

(definition protected locations
  '((#f64(-148. 99. 104.) . #f)
    (#f64(-145.5 99. 104.) . #t)
    (#f64(-138. 98. 100.) . #f)
    (#f64(-138. 98. 104.) . #t)
    (#f64(-142. 96. 112.) . #f)
    (#f64(-138. 96. 112.) . #t)
    (#f64(-134. 96. 114.) . #f)
    (#f64(-138. 96. 114.) . #t)
    (#f64(-138. 96. 118.) . #t)
    (#f64(-134. 96. 118.) . #t)
    (#f64(-128. 92. 118.) . #t)
    (#f64(-128. 89. 125.) . #t)
    (#f64(-128. 88.5 129.) . #t)
    (#f64(-129. 88.5 129.) . #t)
    (#f64(-129. 88.5 135.) . #t)))

(definition protected (near-target? actor target distance)
  (<= (vertex-distance (get-position~ actor) target) distance))

(definition protected target-pos
  #f)

(definition protected moving-to-player?
  #t)

(definition protected by-sight?
  #f)

(definition protected direction
  0)

(definition protected (find-closest-location (actor (self)))
  (let ((pos (get-position~ actor))
        (closest #f)
        (distance #f))
    (let (iter (index 0))
      (unless (>= index (length locations))
        (let ((location (car (list-ref locations index))))
          (let ((dist (vertex-distance location pos)))
            (when (or (not distance) (< dist distance))
              (set! closest index)
              (set! distance dist))
            (iter (+ index 1))))))
    closest))

(definition protected (get-stuck)
  (let ((closest (find-closest-location)))
    (if moving-to-player?
        (let ((location (list-ref locations closest)))
          (if (or (not (cdr location)) (< (vertex-distance (car location) (player)) (vertex-distance (self) (player))))
              (set! target-pos (cons (car location) closest))
            (let ((player-closest (find-closest-location (player))))
              (set! direction (find-direction closest player-closest))
              (let (iter (index (+ closest direction)))
                (if (or (= index 0) (= (+ index 1) (length locations)) (cdr (list-ref locations index)))
                    (set! target-pos (cons (car (list-ref locations index)) index))
                  (iter (+ index direction))))))
          (set! moving-to-player? #f))
      (set! target-pos (cons (car (list-ref locations closest)) closest)))))

(definition protected (find-direction (closest #f) (player-closest #f))
  (let ((closest (or closest (find-closest-location)))
        (player-closest (or player-closest (find-closest-location (player)))))
    (if (> player-closest closest)
        1
      (if (= player-closest closest)
          0
        -1))))

(definition protected (reach-target)
  (if (and (can-see-player?) (not by-sight?))
      (goto-player #t)
    (let ((player-closest (find-closest-location (player)))
          (closest (cdr target-pos)))
      (define (correct-branch? index)
        (let (iter (i index))
          (cond ((or (= i 0) (= (+ i 1) (length locations)) (= i player-closest))
                 #t)
                ((cdr (list-ref locations i))
                 #f)
                (else
                 (iter (+ i direction))))))
      
      (if (cdr (list-ref locations closest)) ;; you are on #t
          (begin
            (set! direction (find-direction closest player-closest)) ;; if direction = 0
            (if (= direction 0)
                (goto-player)
              (if (cdr (list-ref locations player-closest)) ;; player on #t
                  (set! target-pos (let (iter (index (+ closest direction)))
                                     (if (or (= index 0) (= (+ index 1) (length locations)) (cdr (list-ref locations index)))
                                         (cons (car (list-ref locations index)) index)
                                       (iter (+ index direction)))))
                (set! target-pos (let ((index (+ closest direction))) ;; player on #f
                                   (if (cdr (list-ref locations index))
                                       (cons (car (list-ref locations index)) index)
                                     (if (correct-branch? index)
                                         (if (> direction 0)
                                             (let (iter (i (+ index 1)))
                                               (if (or (cdr (list-ref locations i)) (= (+ i 1) (length locations)))
                                                   (begin
                                                     (set! direction -1)
                                                     (cons (car (list-ref locations i)) i))
                                                 (iter (+ i 1))))
                                           (cons (car (list-ref locations index)) index))
                                       (let (iter (i (+ index direction)))
                                         (if (or (cdr (list-ref locations i)) (= i 0) (= (+ i 1) (length locations)))
                                             (cons (car (list-ref locations i)) i)
                                           (iter (+ i direction)))))))))))
        (if (or (cdr (list-ref locations player-closest)) (not (correct-branch? closest))) ;; you are on #f
            (if (< (+ closest 1) (length locations))
                (let ((next (+ closest 1)))
                  (set! target-pos (cons (car (list-ref locations next)) next)))
              (goto-player))
          (set! direction (find-direction (cdr target-pos) player-closest))
          (if (= direction 0)
              (goto-player)
            (let ((next (+ closest direction)))
              (set! target-pos (cons (car (list-ref locations next)) next)))))))
    (when by-sight?
      (set! by-sight? #f))))

(definition protected (goto-player (sight? #f))
  (when sight?
    (set! by-sight? #t))
  (set! moving-to-player? #t)
  (set! target-pos #f)
  (set! direction #f))

(definition protected (can-see-player?)
  (define (polygon-filter poly)
    (let ((element (get-element~ poly)))
      (and (not (eq? element (self)))
           (or (eq? element (player)) (is-not? element world.creature:Creature))
           (world.generation:liquid-filter poly))))
  
  (let ((position (lens-center~ (self)))
        (pos (lens-center~ (player))))
    (let ((dir (vertex-& pos position)))
      (or (vertex-zero? dir)
          (let ((closest (ray-closest-polygon position (vertex-normalize dir) (vertex-distance position pos) filter: polygon-filter ignore-entities?: #f)))
            (and closest (equal? (get-element~ (first closest)) (player))))))))


;;;
;;;; Move
;;;


#/Jazz/
(handle (tick)
  (move))
//#


;;;
;;;; Happy
;;;


#/Jazz/
(define happy?
  #f)

(handle (tick)
  (if (near-player? me)
      (begin
        (when (not happy?)
          (sound bark volume: .25))
        (lookat-player me)
        (jump)
        (set! happy? #t))
    (move)
    (set! happy? #f)))
//#


;;;
;;;; Speed
;;;


#/Jazz/
(when (get first-time? #t)
  (set-position me (vertex 0. -60. 0.))
  (set-lookat me (lookat-horizon (vertex 0. 0. 1.)))
  (set first-time? #f))

(set-motion me 'run)

(handle (tick)
  (let ((z (vertex-z (get-position me))))
    (cond ((> z 20.)
           (set-lookat me (lookat-horizon (vertex 0. 0. -1.))))
          ((< z 0.)
           (set-lookat me (lookat-horizon (vertex 0. 0. 1.))))))
  (move))
//#


;;;
;;;; Run
;;;


#/Jazz/
(when (not (get stage))
  (set stage 0))

(set stage (+ (get stage) 1))

(case (get stage)
  ((1)
   (set-all-motion 'walk))
  ((2)
   (set-all-motion 'run)
   (sound "sound/Rocky"))
  ((3)
   (handle (tick)
     (debug 'tick))))
//#


;;;
;;;; Dialog
;;;


#/Jazz/
(handle (tick)
  (if fly
      (my-people)
    (lookat-player)
    (if (near-player? self 3.)
        (stay)
      (move))
    (let ((time (current-seconds)))
      (let ((elapse (- time previous)))
        (set! previous time)
        (tick-msgs elapse)))))

(definition self
  (current-actor))

(definition previous
  0.)

(definition timer
  #f)

(definition (stop)
  (stay))

(definition fly
  #f)

(definition msg-index
  0)

(definition msgs
  (list (cons "Hi" 3.)
        (cons "I am Groot" 3.)
        (cons "My people need me!" 0.)))

(definition (tick-msgs elapse)
  (if (< msg-index (length msgs))
      (begin
        (when timer
          (decrease! timer elapse))
        (when (or (not timer) (< timer 0.))
          (message (car (list-ref msgs msg-index)))
          (set! timer (cdr (list-ref msgs msg-index)))
          (increase! msg-index)))
    (set! fly #t)))
//#
)
