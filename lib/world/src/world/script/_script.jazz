;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Scripts
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.script jazz


(export (jazz.optimize (phase syntax)) ;; for
        (world)
        (world.audio)
        (world.autoload)
        (world.commands)
        (world.draw)
        (world.dyes)
        (world.generation.building)
        (world.geometry)
        (world.mark)
        (world.scripting)
        (world.script.syntax (phase syntax))
        (world.syntax (phase syntax))
        (world.travel))

(import (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (world)
        (world.actor)
        (world.audio)
        (world.autoload)
        (world.billboard)
        (world.commands)
        (world.contour)
        (world.creature)
        (world.draw)
        (world.dyes)
        (world.entity)
        (world.generation)
        (world.generation.block)
        (world.geometry)
        (world.mark)
        (world.homogeneous)
        (world.model)
        (world.scripter)
        (world.scripting)
        (world.syntax (phase syntax))
        (world.task)
        (world.travel))


;;;
;;;; Contour
;;;


(define-contour handle)
(define-contour tick)
(define-contour interact)
(define-contour move)
(define-contour move-to)
(define-contour rotate)
(define-contour looping)
(define-contour lambda)
(define-contour stop)
(define-contour trail)
(define-contour run)
(define-contour sprint)


;;;
;;;; World
;;;


(definition public (message msg)
  (let ((world (current-world)))
    (display-message~ world (->string msg))))


;;;
;;;; Sound
;;;


(definition public bark
  "sound/random/dog_barking")


(definition public (sound path (volume: volume #f))
  (when sounds?
    (let ((sound (cache-stream-sound path)))
      (unless (playing?~ sound)
        (when volume
          (set-volume~ sound volume))
        (play~ sound)))))


;;;
;;;; Script
;;;


(definition public (script-sleep period)
  (let ((task (current-task))
        (exit (current-exit)))
    (task-sleep task period 0. exit)))


;;;
;;;; Actor
;;;


(definition public (current-actor)
  (%%current-actor))


(definition public (event-me)
  (get-actor~ (current-event)))

(definition public (event-time)
  (get-time~ (current-event)))

(definition public (event-elapse)
  (get-elapse~ (current-event)))


(definition public (lookat-horizon dir)
  (horizon-lookat (vertex-normalize& (vertex& (vertex-x dir) 0. (vertex-z dir)))))


(definition public (near-player? (actor #f) (distance #f))
  (let ((actor (or actor (current-actor)))
        (distance (or distance 5.)))
    (<= (vertex-distance (get-position~ actor) (get-position~ (current-me))) distance)))


(definition public (lookat-player (actor #f))
  (let ((actor (or actor (current-actor))))
    (let ((dir (vertex-& (get-position~ (current-me)) (get-position~ actor))))
      (set-lookat actor (lookat-horizon dir)))))

(definition public (lookat-target target (actor #f))
  (let ((actor (or actor (current-actor))))
    (let ((dir (vertex- target (get-position~ actor))))
      (set-lookat actor (lookat-horizon dir)))))


(definition public (lookat-rotate element angle)
  (set-lookat~ element (rotate-lookat (get-lookat~ element) (degree->radian angle) (vertex 0. 1. 0.))))


(definition public move-commands
  (let ((commands (new Commands)))
    (move-forward~ commands)
    commands))

(definition public sprint-commands
  (let ((commands (new Commands)))
    (sprint-forward~ commands)
    commands))

(definition public rotate-left-commands
  (let ((commands (new Commands)))
    (rotate-left~ commands)
    commands))

(definition public rotate-right-commands
  (let ((commands (new Commands)))
    (rotate-right~ commands)
    commands))

(definition public jump-commands
  (let ((commands (new Commands)))
    (jump~ commands)
    commands))


(definition public (perform-stay)
  (perform stay-commands))

(definition public (perform-move)
  (perform (if (get-sprint?~ (current-actor)) sprint-commands move-commands)))

(definition public (perform-sprint)
  (perform sprint-commands))

(definition public (perform-rotate-left)
  (perform rotate-left-commands))

(definition public (perform-rotate-right)
  (perform rotate-right-commands))

(definition public (perform-hover)
  (perform move-commands gravity?: #f))

(definition public (perform-jump)
  (perform jump-commands))


(definition public (perform commands (gravity?: gravity? #t))
  (let ((actor (event-me))
        (time (event-time))
        (elapse (event-elapse)))
    (tick-actor~ actor commands time elapse gravity? 'slide)))


(definition public (hostile)
  (let ((event (current-event)))
    (tick-hostile~ (get-actor~ event)
      (get-time~ event)
      (get-elapse~ event))))


(definition public (get-position element)
  (assert (is? element Element))
  (get-position~ element))


(definition public (set-position element position)
  (assert (is? element Element))
  (set-position~ element position))


(definition public (set-lookat element direction/lookat)
  (assert (is? element Element))
  (let ((lookat (if (f64vector? direction/lookat)
                    (lookat-horizon direction/lookat)
                  direction/lookat)))
    (set-lookat~ element lookat)))


(definition public (set-speed element speed)
  (assert (is? element Element))
  (set-speed~ element speed))


(definition public (set-motion actor motion)
  (assert (is? actor Actor))
  (set-motion~ actor motion))


(definition public (walk)
  (let ((actor (current-actor)))
    (let ((script (get-script~ actor)))
      (set-sprint?~ actor #f)
      (set-motion actor 'walk))))

(definition public (run)
  (let ((actor (current-actor)))
    (let ((script (get-script~ actor)))
      (set-sprint?~ actor #f)
      (set-motion actor 'run))))


(definition public (sprint)
  (let ((actor (current-actor)))
    (let ((script (get-script~ actor)))
      (set-sprint?~ actor #t)
      (set-motion actor 'run))))


(definition public (set-hover? actor flag)
  (assert (is? actor Actor))
  (set-hover?~ actor flag))


(definition public (set-tick-handler actor handler)
  (set-tick~ (get/create-script actor) handler))

(definition public (set-interact-handler actor handler)
  (set-interact~ (get/create-script actor) handler))

(definition public (set-double-click-handler actor handler)
  (set-double-click~ (get/create-script actor) handler))

(definition public (set-hit-handler actor handler)
  (set-hit~ (get/create-script actor) handler))


(definition public (set-billboard actor name)
  (set-billboard-name~ actor name))


(definition public (teleport position)
  (let ((zone (current-zone)))
    (teleport~ zone position)))


(definition public (jump (impulsion #f))
  (let ((me (current-me)))
    (set-jump?~ me #t)
    (set-jump-impulsion~ me impulsion)))


(definition public (zone-in zone)
  (delay-event
    (lambda ()
      (change-zone~ (current-tier) zone))))


(definition public (zone-out)
  (delay-event
    (lambda ()
      (change-zone~ (current-tier) 'start))))


;;;
;;;; Model
;;;


(definition public (get-model entity)
  (assert (is? entity Entity))
  (cache-model~ entity))


(definition public (set-run-speed model speed)
  (assert (is? model Model))
  (set-run-speed~ model speed))


;;;
;;;; Life
;;;


;; for testing hit event
(definition public (full-life)
  (set-life~ (event-me) 100.))


;;;
;;;; Pause
;;;


(definition public (paused?)
  (%%paused?))


(definition public (pause)
  (%%pause))


(definition public (unpause)
  (%%unpause))


(definition public (toggle-paused)
  (%%toggle-paused))


;;;
;;;; Tick
;;;


(definition public (looping proc)
  (declare (proper-tail-calls))
  (with-tick
    (lambda (actor script time elapse iter)
      (let ((stop? #f))
        (define (stop)
          (set! stop? #t))
        
        (proc stop)
        (unless stop?
          (iter))))))


;;;
;;;; Move
;;;


(definition public (stay)
  (%%stay))


(definition public (move distance)
  (declare (proper-tail-calls))
  (let ((distance (cast <fl> distance))
        (actor (current-actor)))
    (let ((start (copy-vertex (get-position~ actor)))
          (target (vertex+ (get-position~ actor) (vertex-scalar*& (get-sight~ actor) distance)))
          (line #f))
      (with-tick
        (lambda (actor script time elapse iter)
          (tick-actor~ actor (if (get-sprint?~ actor) sprint-commands move-commands) time elapse #t 'slide)
          (let ((traveled (vertex-distance& (get-position~ actor) start)))
            (when (get-trail?~ script)
              (let ((end (copy-vertex (get-position~ actor))))
                (if (not line)
                    (let ((l (list start end (get-trail-color~ script))))
                      (trail-line actor l)
                      (set! line l))
                  (set-second! line end))))
            (if (< traveled distance)
                (iter)
              (set-position~ actor target)
              (when line
                (set-second! line target)))))))))


(definition public (move-to . rest)
  (declare (proper-tail-calls))
  (let ((target (if (= (length rest) 1)
                    (car rest)
                  (bind (x y z) rest
                    (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z)))))
        (actor (current-actor)))
    (let ((start (copy-vertex (get-position~ actor)))
          (distance (vertex-distance (get-position~ actor) target))
          (line #f))
      (set-lookat actor (horizon-lookat (vertex-normalize& (vertex-& target (get-position~ actor)))))
      (with-tick
        (lambda (actor script time elapse iter)
          (tick-actor~ actor (if (get-sprint?~ actor) sprint-commands move-commands) time elapse #t 'slide)
          (let ((traveled (vertex-distance& (get-position~ actor) start)))
            (when (get-trail?~ script)
              (let ((end (copy-vertex (get-position~ actor))))
                (if (not line)
                    (let ((l (list start end (get-trail-color~ script))))
                      (trail-line actor l)
                      (set! line l))
                  (set-second! line end))))
            (if (< traveled distance)
                (iter)
              (set-position~ actor target)
              (when line
                (set-second! line target)))))))))


(definition public (rotate angle)
  (declare (proper-tail-calls))
  (let ((angle (degree->radian (cast <fl> angle)))
        (actor (current-actor)))
    (unless (= angle 0.)
      (let ((start (copy-vertex (get-sight~ actor)))
            (target (rotate-upon angle (vertex& 0. 1. 0.) (get-sight~ actor)))
            (commands (if (> angle 0.) rotate-left-commands rotate-right-commands))
            (test (if (> angle 0.) > <)))
        (with-tick
          (lambda (actor script time elapse iter)
            (tick-actor~ actor commands time elapse #t 'slide)
            (let ((traveled (vector-signed-angle start (get-sight~ actor) (vertex& 0. 1. 0.))))
              (if (not (test traveled angle))
                  (iter)
                (set-lookat~ actor (horizon-lookat target))))))))))


;;;
;;;; Block
;;;


@too-much-for-now-to-be-obstructed-by-blocks
(definition public (with-script-interaction position proc)
  (let ((world (current-world))
        (game (current-game))
        (actor (current-actor)))
    (let ((max-distance (get-view-radius~ world))
          (lens (lens-center~ actor)))
      (let ((direction (vertex-normalize (vertex- position lens))))
        (let ((closest (ray-closest-polygon lens direction max-distance ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
          (when closest
            (let ((poly (car closest)))
              (when poly
                (with-polygon-interaction~ game poly
                  (lambda (poly block fore)
                    (proc poly fore)))))))))))


(definition public (add-block position block-id)
  (let ((game (current-game)))
    (apply-add-block~ game position block-id 0)))


(definition public (delete-block position)
  )


(definition public (change-block position block-id)
  )


;;;
;;;; Trail
;;;


(definition public (trail (color #f))
  (let ((zone (current-zone)))
    (let ((actor (current-actor)))
      (let ((script (get-script~ actor)))
        (set-trail?~ script #t)
        (when (not (get-trail~ script))
          (set-trail~ script (new-queue)))
        (when color
          (set-trail-color~ script (case color
                                     ((red) red-dye)
                                     ((green) green-dye)
                                     (else blue-dye))))
        (register-draw~ zone actor
          (lambda ()
            (draw-trail actor)))))))


(definition public (untrail)
  (let ((zone (current-zone)))
    (let ((actor (current-actor)))
      (let ((script (get-script~ actor)))
        (set-trail?~ script #f)
        @w
        (unregister-draw~ zone actor)))))


(definition public (trail-color color)
  (let ((zone (current-zone)))
    (let ((actor (current-actor)))
      (let ((script (get-script~ actor)))
        (set-trail-color~ script (case color
                                   ((red) red-dye)
                                   ((green) green-dye)
                                   (else blue-dye)))))))


(definition public (clear-trail)
  (let ((actor (current-actor)))
    (let ((script (get-script~ actor)))
      (set-trail~ script (new-queue)))))


(definition (trail-line actor line)
  (let ((script (get-script~ actor)))
    (enqueue (get-trail~ script) line)))


(definition (draw-trail actor)
  (let ((script (get-script~ actor)))
    (for-each (lambda (line)
                (bind (start end color) line
                  (render-line start
                               end
                               .04
                               (or color blue-dye))))
              (queue-list (get-trail~ script)))))


(definition public (plot-axes (dx 0) (dz 0))
  (let ((dx (cast <fl> dx))
        (dz (cast <fl> dz)))
    (plot-line (vertex (+ -10. dx) 4. (+ 0. dz)) (vertex (+ 10. dx) 4. (+ 0. dz)) 'blue)
    (plot-line (vertex (+ 0. dx) 4. (+ -10. dz)) (vertex (+ 0. dx) 4. (+ 10. dz)) 'blue)
    (loop (for x <fl> from -10. to 10. by 1.)
          (plot-line (vertex (+ x dx) 4. (+ -.5 dz)) (vertex (+ x dx) 4. (+ .5 dz)) 'blue))
    (loop (for z <fl> from -10. to 10. by 1.)
          (plot-line (vertex (+ -.5 dx) 4. (+ z dz)) (vertex (+ .5 dx) 4. (+ z dz)) 'blue))))


(definition public (plot-line from to (color 'red))
  (untrail)
  (move-to from)
  (trail color)
  (move-to to))


;;;
;;;; Pathing
;;;


(definition protected (tick-dwarf)
  (when (and #t (< (get-velocity-angle~ (self)) 1.5))
    (debug (get-velocity-angle~ (self)))
    (get-stuck))
  (if moving-to-player?
      (begin
        (lookat-player)
        (if (near-player? (self) 3.)
            (perform-stay)
          (perform-move)))
    (lookat-target (car target-pos))
    (perform-move))
  (unless moving-to-player?
    (when (near-target? (self) (car target-pos) 0.1)
      (reach-target))))

(definition protected (self)
  (current-actor))

(definition protected (player)
  (current-me))

(definition protected toggle-locations
  (let ((show-locations? #f))
    (lambda ()
      (let ((zone (current-zone)))
        (if show-locations?
            (begin
              (reset-marks~ zone)
              (set! show-locations? #f))
          (for-each
            (lambda (location)
              (add-mark~ zone (new Position-Mark (car location))))
            locations)
          (set! show-locations? #t))))))

(definition protected locations
  '((#f64(-148. 99. 104.) . #f)
    (#f64(-145.5 99. 104.) . #t)
    (#f64(-138. 98. 100.) . #f)
    (#f64(-138. 98. 104.) . #t)
    (#f64(-142. 96. 112.) . #f)
    (#f64(-138. 96. 112.) . #t)
    (#f64(-134. 96. 114.) . #f)
    (#f64(-138. 96. 114.) . #t)
    (#f64(-138. 96. 118.) . #t)
    (#f64(-134. 96. 118.) . #t)
    (#f64(-128. 92. 118.) . #t)
    (#f64(-128. 89. 125.) . #t)
    (#f64(-128. 88.5 129.) . #t)
    (#f64(-129. 88.5 129.) . #t)
    (#f64(-129. 88.5 135.) . #t)))

(definition protected (near-target? actor target distance)
  (<= (vertex-distance (get-position~ actor) target) distance))

(definition protected target-pos
  #f)

(definition protected moving-to-player?
  #t)

(definition protected by-sight?
  #f)

(definition protected direction
  0)

(definition protected (find-closest-location (actor (self)))
  (let ((pos (get-position~ actor))
        (closest #f)
        (distance #f))
    (let (iter (index 0))
      (unless (>= index (length locations))
        (let ((location (car (list-ref locations index))))
          (let ((dist (vertex-distance location pos)))
            (when (or (not distance) (< dist distance))
              (set! closest index)
              (set! distance dist))
            (iter (+ index 1))))))
    closest))

(definition protected (get-stuck)
  (let ((closest (find-closest-location)))
    (if moving-to-player?
        (let ((location (list-ref locations closest)))
          (if (or (not (cdr location)) (< (vertex-distance (car location) (player)) (vertex-distance (self) (player))))
              (set! target-pos (cons (car location) closest))
            (let ((player-closest (find-closest-location (player))))
              (set! direction (find-direction closest player-closest))
              (let (iter (index (+ closest direction)))
                (if (or (= index 0) (= (+ index 1) (length locations)) (cdr (list-ref locations index)))
                    (set! target-pos (cons (car (list-ref locations index)) index))
                  (iter (+ index direction))))))
          (set! moving-to-player? #f))
      (set! target-pos (cons (car (list-ref locations closest)) closest)))))

(definition protected (find-direction (closest #f) (player-closest #f))
  (let ((closest (or closest (find-closest-location)))
        (player-closest (or player-closest (find-closest-location (player)))))
    (if (> player-closest closest)
        1
      (if (= player-closest closest)
          0
        -1))))

(definition protected (reach-target)
  (if (and (can-see-player?) (not by-sight?))
      (goto-player #t)
    (let ((player-closest (find-closest-location (player)))
          (closest (cdr target-pos)))
      (define (correct-branch? index)
        (let (iter (i index))
          (cond ((or (= i 0) (= (+ i 1) (length locations)) (= i player-closest))
                 #t)
                ((cdr (list-ref locations i))
                 #f)
                (else
                 (iter (+ i direction))))))
      
      (if (cdr (list-ref locations closest)) ;; you are on #t
          (begin
            (set! direction (find-direction closest player-closest)) ;; if direction = 0
            (if (= direction 0)
                (goto-player)
              (if (cdr (list-ref locations player-closest)) ;; player on #t
                  (set! target-pos (let (iter (index (+ closest direction)))
                                     (if (or (= index 0) (= (+ index 1) (length locations)) (cdr (list-ref locations index)))
                                         (cons (car (list-ref locations index)) index)
                                       (iter (+ index direction)))))
                (set! target-pos (let ((index (+ closest direction))) ;; player on #f
                                   (if (cdr (list-ref locations index))
                                       (cons (car (list-ref locations index)) index)
                                     (if (correct-branch? index)
                                         (if (> direction 0)
                                             (let (iter (i (+ index 1)))
                                               (if (or (cdr (list-ref locations i)) (= (+ i 1) (length locations)))
                                                   (begin
                                                     (set! direction -1)
                                                     (cons (car (list-ref locations i)) i))
                                                 (iter (+ i 1))))
                                           (cons (car (list-ref locations index)) index))
                                       (let (iter (i (+ index direction)))
                                         (if (or (cdr (list-ref locations i)) (= i 0) (= (+ i 1) (length locations)))
                                             (cons (car (list-ref locations i)) i)
                                           (iter (+ i direction)))))))))))
        (if (or (cdr (list-ref locations player-closest)) (not (correct-branch? closest))) ;; you are on #f
            (if (< (+ closest 1) (length locations))
                (let ((next (+ closest 1)))
                  (set! target-pos (cons (car (list-ref locations next)) next)))
              (goto-player))
          (set! direction (find-direction (cdr target-pos) player-closest))
          (if (= direction 0)
              (goto-player)
            (let ((next (+ closest direction)))
              (set! target-pos (cons (car (list-ref locations next)) next)))))))
    (when by-sight?
      (set! by-sight? #f))))

(definition protected (goto-player (sight? #f))
  (when sight?
    (set! by-sight? #t))
  (set! moving-to-player? #t)
  (set! target-pos #f)
  (set! direction #f))

(definition protected (can-see-player?)
  (define (polygon-filter poly)
    (let ((element (get-element~ poly)))
      (and (not (eq? element (self)))
           (or (eq? element (player)) (is-not? element Creature))
           (liquid-filter poly))))
  
  (let ((position (lens-center~ (self)))
        (pos (lens-center~ (player))))
    (let ((dir (vertex-& pos position)))
      (or (vertex-zero? dir)
          (let ((closest (ray-closest-polygon position (vertex-normalize dir) (vertex-distance position pos) filter: polygon-filter ignore-entities?: #f)))
            (and closest (equal? (get-element~ (first closest)) (player))))))))


;;;
;;;; Various
;;;


(definition public (animate actor animation (next: next #f))
  (assert (find-animation~ (cache-model~ actor) animation))
  (transition-morphing~ actor animation next: (or next "Idle"))
  (set-animation-active~ actor animation))


(definition public (creatures)
  (let ((zone (current-zone)))
    (get-creatures~ zone)))


(definition public (block-interact a b c)
  (let ((game (current-game)))
    (interact-at~ game (location->position (vector a b c)))))


(definition public (set-block-data a b c data)
  (let ((game (current-game))
        (zone (current-zone)))
    (updating-sections~ zone
      (lambda (add-section)
        (call-with-position~ zone (location->position (vector a b c))
          (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
            (with-field i j k
              (lambda (section index)
                (data-set! section index data)
                (add-section section))))))))))
