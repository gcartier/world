;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Scripts
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.script jazz


(export (world)
        (world.audio)
        (world.autoload)
        (world.commands)
        (world.draw)
        (world.dyes)
        (world.geometry)
        (world.mark)
        (world.scripting)
        (world.script.syntax (phase syntax))
        (world.syntax (phase syntax))
        (world.travel))

(import (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (world)
        (world.actor)
        (world.audio)
        (world.autoload)
        (world.billboard)
        (world.commands)
        (world.contour)
        (world.creature)
        (world.draw)
        (world.dyes)
        (world.entity)
        (world.generation)
        (world.geometry)
        (world.mark)
        (world.homogeneous)
        (world.model)
        (world.scripter)
        (world.scripting)
        (world.syntax (phase syntax))
        (world.travel))


;;;
;;;; Contour
;;;


(define-contour handle)
(define-contour tick)
(define-contour idle)
(define-contour interact)
(define-contour move)
(define-contour rotate)


;;;
;;;; World
;;;


(definition public (message msg)
  (let ((world (current-world)))
    (display-message~ world (->string msg))))


;;;
;;;; Sound
;;;


(definition public bark
  "sound/random/dog_barking")


(definition public (sound path (volume: volume #f))
  (when sounds?
    (let ((sound (cache-stream-sound path)))
      (unless (playing?~ sound)
        (when volume
          (set-volume~ sound volume))
        (play~ sound)))))


;;;
;;;; Actor
;;;


(definition public (current-actor)
  (if (current-event)
      (get-actor~ (current-event))
    (current-instance)))


(definition public (event-me)
  (get-actor~ (current-event)))

(definition public (event-time)
  (get-time~ (current-event)))

(definition public (event-elapse)
  (get-elapse~ (current-event)))


(definition public (lookat-horizon dir)
  (horizon-lookat (vertex-normalize& (vertex& (vertex-x dir) 0. (vertex-z dir)))))


(definition public (near-player? (actor #f) (distance #f))
  (let ((actor (or actor (current-actor)))
        (distance (or distance 5.)))
    (<= (vertex-distance (get-position~ actor) (get-position~ (current-me))) distance)))


(definition public (lookat-player (actor #f))
  (let ((actor (or actor (current-actor))))
    (let ((dir (vertex-& (get-position~ (current-me)) (get-position~ actor))))
      (set-lookat actor (lookat-horizon dir)))))

(definition public (lookat-target target (actor #f))
  (let ((actor (or actor (current-actor))))
    (let ((dir (vertex- target (get-position~ actor))))
      (set-lookat actor (lookat-horizon dir)))))


(definition public (lookat-rotate element angle)
  (set-lookat~ element (rotate-lookat (get-lookat~ element) (degree->radian angle) (vertex 0. 1. 0.))))


(definition public stay-commands
  (new Commands))

(definition public move-commands
  (let ((commands (new Commands)))
    (move-forward~ commands)
    commands))

(definition public sprint-commands
  (let ((commands (new Commands)))
    (sprint-forward~ commands)
    commands))

(definition public rotate-left-commands
  (let ((commands (new Commands)))
    (rotate-left~ commands)
    commands))

(definition public rotate-right-commands
  (let ((commands (new Commands)))
    (rotate-right~ commands)
    commands))

(definition public jump-commands
  (let ((commands (new Commands)))
    (jump~ commands)
    commands))


(definition public (perform-stay)
  (perform stay-commands))

(definition public (perform-move)
  (perform (if sprint? sprint-commands move-commands)))

(definition public (perform-sprint)
  (perform sprint-commands))

(definition public (perform-rotate-left)
  (perform rotate-left-commands))

(definition public (perform-rotate-right)
  (perform rotate-right-commands))

(definition public (perform-hover)
  (perform move-commands gravity?: #f))

(definition public (perform-jump)
  (perform jump-commands))


(definition public (hostile)
  (let ((event (current-event)))
    (tick-hostile~ (get-actor~ event)
      (get-time~ event)
      (get-elapse~ event))))


(definition public (get-position element)
  (assert (is? element Element))
  (get-position~ element))


(definition public (set-position element position)
  (assert (is? element Element))
  (set-position~ element position))


(definition public (set-lookat element direction/lookat)
  (assert (is? element Element))
  (let ((lookat (if (f64vector? direction/lookat)
                    (lookat-horizon direction/lookat)
                  direction/lookat)))
    (set-lookat~ element lookat)))


(definition public (set-speed element speed)
  (assert (is? element Element))
  (set-speed~ element speed))


(definition public (set-motion actor motion)
  (assert (is? actor Actor))
  (set-motion~ actor motion))


(definition public (walk)
  (let ((actor (current-actor)))
    (let ((script (get-script~ actor)))
      (add-objective~ script
        (lambda ()
          (lambda ()
            (set! sprint? #f)
            (set-motion (current-actor) 'walk)
            (objective-done~ script)))))))

(definition public (run)
  (let ((actor (current-actor)))
    (let ((script (get-script~ actor)))
      (add-objective~ script
        (lambda ()
          (lambda ()
            (set! sprint? #f)
            (set-motion (current-actor) 'run)
            (objective-done~ script)))))))


;; hack
(definition sprint?
  #f)

(definition public (sprint)
  (let ((actor (current-actor)))
    (let ((script (get-script~ actor)))
      (add-objective~ script
        (lambda ()
          (lambda ()
            (set! sprint? #t)
            (set-motion (current-actor) 'run)
            (objective-done~ script)))))))


(definition public (set-hover? actor flag)
  (assert (is? actor Actor))
  (set-hover?~ actor flag))


(definition public (set-tick-handler actor handler)
  (set-tick~ (get/create-script actor) handler))

(definition public (set-idle-handler actor handler)
  (set-idle~ (get/create-script actor) handler))

(definition public (set-interact-handler actor handler)
  (set-interact~ (get/create-script actor) handler))


(definition public (perform commands (gravity?: gravity? #t))
  (assert (is? commands Commands))
  (let ((event (current-event)))
    (let ((actor (get-actor~ event))
          (time (get-time~ event))
          (elapse (get-elapse~ event)))
      (tick-actor~ actor commands time elapse gravity? 'slide))))


(definition public (set-billboard actor name)
  (set-billboard-name~ actor name))


(definition public (teleport position)
  (let ((zone (current-zone)))
    (teleport~ zone position)))


(definition public (jump (impulsion #f))
  (let ((me (current-me)))
    (set-jump?~ me #t)
    (set-jump-impulsion~ me impulsion)))


(definition public (zone-in zone)
  (delay-event
    (lambda ()
      (change-zone~ (current-tier) zone))))


(definition public (zone-out)
  (delay-event
    (lambda ()
      (change-zone~ (current-tier) 'start))))


;;;
;;;; Model
;;;


(definition public (get-model entity)
  (assert (is? entity Entity))
  (cache-model~ entity))


(definition public (set-run-speed model speed)
  (assert (is? model Model))
  (set-run-speed~ model speed))


;;;
;;;; Objective
;;;


(definition public (move distance)
  (let ((distance (cast <fl> distance))
        (actor (current-actor)))
    (let ((script (get-script~ actor)))
      (add-objective~ script
        (lambda ()
          (let ((start (copy-vertex (get-position~ actor)))
                (target (vertex+ (get-position~ actor) (vertex-scalar*& (get-sight~ actor) distance)))
                (line #f))
            (lambda ()
              (perform-move)
              (let ((traveled (vertex-distance& (get-position~ actor) start)))
                (when (get-trail?~ script)
                  (let ((end (copy-vertex (get-position~ actor))))
                    (if (not line)
                        (let ((l (list start end (get-trail-color~ script))))
                          (trail-line actor l)
                          (set! line l))
                      (set-second! line end))))
                (when (> traveled distance)
                  (set-position~ actor target)
                  (when line
                    (set-second! line target))
                  (when (objectiveless?~ script)
                    (animate actor "Idle"))
                  (objective-done~ script))))))))))


(definition public (move-to . rest)
  (let ((actor (current-actor))
        (target (if (= (length rest) 1)
                    (car rest)
                  (bind (x y z) rest
                    (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z))))))
    (let ((script (get-script~ actor)))
      (add-objective~ script
        (lambda ()
          (let ((start (copy-vertex (get-position~ actor)))
                (distance (vertex-distance (get-position~ actor) target))
                (line #f))
            (set-lookat actor (horizon-lookat (vertex-normalize& (vertex-& target (get-position~ actor)))))
            (lambda ()
              (perform-move)
              (let ((traveled (vertex-distance& (get-position~ actor) start)))
                (when (get-trail?~ script)
                  (let ((end (copy-vertex (get-position~ actor))))
                    (if (not line)
                        (let ((l (list start end (get-trail-color~ script))))
                          (trail-line actor l)
                          (set! line l))
                      (set-second! line end))))
                (when (> traveled distance)
                  (set-position~ actor target)
                  (when line
                    (set-second! line target))
                  (when (objectiveless?~ script)
                    (animate actor "Idle"))
                  (objective-done~ script))))))))))


(definition public (rotate angle)
  (let ((angle (degree->radian (cast <fl> angle)))
        (actor (current-actor)))
    (let ((script (get-script~ actor)))
      (unless (= angle 0.)
        (add-objective~ script
          (lambda ()
            (let ((start (copy-vertex (get-sight~ actor)))
                  (target (rotate-upon angle (vertex& 0. 1. 0.) (get-sight~ actor)))
                  (perform (if (> angle 0.) perform-rotate-left perform-rotate-right))
                  (test (if (> angle 0.) > <)))
              (lambda ()
                (set-lookat~ actor (horizon-lookat target))
                (objective-done~ script)
                @w
                (perform)
                @w
                (let ((traveled (vector-signed-angle start (get-sight~ actor) (vertex& 0. 1. 0.))))
                  (when (test traveled angle)
                    (set-lookat~ actor (horizon-lookat target))
                    (when (objectiveless?~ script)
                      (animate actor "Idle"))
                    (objective-done~ script)))))))))))


;;;
;;;; Trail
;;;


@w (
(clear-trail)
(run)

(define (plot function)
  (untrail)
  (loop (for x <fl> from -5. to 5. by .5)
        (let ((y (function x)))
          (move-to x 4. y)
          (trail))))

(plot (lambda (x) (* x x)))
(plot sin))


(definition public (trail (color #f))
  (let ((zone (current-zone)))
    (let ((actor (current-actor)))
      (let ((script (get-script~ actor)))
        (add-objective~ script
          (lambda ()
            (lambda ()
              (set-trail?~ script #t)
              (when (not (get-trail~ script))
                (set-trail~ script (new-queue)))
              (when color
                (set-trail-color~ script (case color
                                           ((red) red-dye)
                                           ((green) green-dye)
                                           (else blue-dye))))
              (register-draw~ zone actor
                (lambda ()
                  (draw-trail actor)))
              (objective-done~ script))))))))


(definition public (untrail)
  (let ((zone (current-zone)))
    (let ((actor (current-actor)))
      (let ((script (get-script~ actor)))
        (add-objective~ script
          (lambda ()
            (lambda ()
              (set-trail?~ script #f)
              @w
              (unregister-draw~ zone actor)
              (objective-done~ script))))))))


(definition public (trail-color color)
  (let ((zone (current-zone)))
    (let ((actor (current-actor)))
      (let ((script (get-script~ actor)))
        (add-objective~ script
          (lambda ()
            (lambda ()
              (set-trail-color~ script (case color
                                         ((red) red-dye)
                                         ((green) green-dye)
                                         (else blue-dye)))
              (objective-done~ script))))))))


(definition public (clear-trail)
  (let ((actor (current-actor)))
    (let ((script (get-script~ actor)))
      (add-objective~ script
        (lambda ()
          (lambda ()
            (set-trail~ script (new-queue))
            (objective-done~ script)))))))


(definition public (plot-axes (dx 0) (dz 0))
  (let ((dx (cast <fl> dx))
        (dz (cast <fl> dz)))
    (plot-line (vertex (+ -10. dx) 4. (+ 0. dz)) (vertex (+ 10. dx) 4. (+ 0. dz)) 'blue)
    (plot-line (vertex (+ 0. dx) 4. (+ -10. dz)) (vertex (+ 0. dx) 4. (+ 10. dz)) 'blue)
    (loop (for x <fl> from -10. to 10. by 1.)
          (plot-line (vertex (+ x dx) 4. (+ -.5 dz)) (vertex (+ x dx) 4. (+ .5 dz)) 'blue))
    (loop (for z <fl> from -10. to 10. by 1.)
          (plot-line (vertex (+ -.5 dx) 4. (+ z dz)) (vertex (+ .5 dx) 4. (+ z dz)) 'blue))))


(definition public (plot-line from to (color 'red))
  (untrail)
  (move-to from)
  (trail color)
  (move-to to))


(definition (trail-line actor line)
  (let ((script (get-script~ actor)))
    (enqueue (get-trail~ script) line)))


(definition (draw-trail actor)
  (let ((script (get-script~ actor)))
    (for-each (lambda (line)
                (bind (start end color) line
                  (render-line start
                               end
                               .04
                               (or color blue-dye))))
              (queue-list (get-trail~ script)))))


;;;
;;;; Pathing
;;;


(definition protected (tick-dwarf)
  (when (and #t (< (get-velocity-angle~ (self)) 1.5))
    (debug (get-velocity-angle~ (self)))
    (get-stuck))
  (if moving-to-player?
      (begin
        (lookat-player)
        (if (near-player? (self) 3.)
            (perform-stay)
          (perform-move)))
    (lookat-target (car target-pos))
    (perform-move))
  (unless moving-to-player?
    (when (near-target? (self) (car target-pos) 0.1)
      (reach-target))))

(definition protected (self)
  (current-actor))

(definition protected (player)
  (current-me))

(definition protected toggle-locations
  (let ((show-locations? #f))
    (lambda ()
      (let ((zone (current-zone)))
        (if show-locations?
            (begin
              (reset-marks~ zone)
              (set! show-locations? #f))
          (for-each
            (lambda (location)
              (add-mark~ zone (new Position-Mark (car location))))
            locations)
          (set! show-locations? #t))))))

(definition protected locations
  '((#f64(-148. 99. 104.) . #f)
    (#f64(-145.5 99. 104.) . #t)
    (#f64(-138. 98. 100.) . #f)
    (#f64(-138. 98. 104.) . #t)
    (#f64(-142. 96. 112.) . #f)
    (#f64(-138. 96. 112.) . #t)
    (#f64(-134. 96. 114.) . #f)
    (#f64(-138. 96. 114.) . #t)
    (#f64(-138. 96. 118.) . #t)
    (#f64(-134. 96. 118.) . #t)
    (#f64(-128. 92. 118.) . #t)
    (#f64(-128. 89. 125.) . #t)
    (#f64(-128. 88.5 129.) . #t)
    (#f64(-129. 88.5 129.) . #t)
    (#f64(-129. 88.5 135.) . #t)))

(definition protected (near-target? actor target distance)
  (<= (vertex-distance (get-position~ actor) target) distance))

(definition protected target-pos
  #f)

(definition protected moving-to-player?
  #t)

(definition protected by-sight?
  #f)

(definition protected direction
  0)

(definition protected (find-closest-location (actor (self)))
  (let ((pos (get-position~ actor))
        (closest #f)
        (distance #f))
    (let (iter (index 0))
      (unless (>= index (length locations))
        (let ((location (car (list-ref locations index))))
          (let ((dist (vertex-distance location pos)))
            (when (or (not distance) (< dist distance))
              (set! closest index)
              (set! distance dist))
            (iter (+ index 1))))))
    closest))

(definition protected (get-stuck)
  (let ((closest (find-closest-location)))
    (if moving-to-player?
        (let ((location (list-ref locations closest)))
          (if (or (not (cdr location)) (< (vertex-distance (car location) (player)) (vertex-distance (self) (player))))
              (set! target-pos (cons (car location) closest))
            (let ((player-closest (find-closest-location (player))))
              (set! direction (find-direction closest player-closest))
              (let (iter (index (+ closest direction)))
                (if (or (= index 0) (= (+ index 1) (length locations)) (cdr (list-ref locations index)))
                    (set! target-pos (cons (car (list-ref locations index)) index))
                  (iter (+ index direction))))))
          (set! moving-to-player? #f))
      (set! target-pos (cons (car (list-ref locations closest)) closest)))))

(definition protected (find-direction (closest #f) (player-closest #f))
  (let ((closest (or closest (find-closest-location)))
        (player-closest (or player-closest (find-closest-location (player)))))
    (if (> player-closest closest)
        1
      (if (= player-closest closest)
          0
        -1))))

(definition protected (reach-target)
  (if (and (can-see-player?) (not by-sight?))
      (goto-player #t)
    (let ((player-closest (find-closest-location (player)))
          (closest (cdr target-pos)))
      (define (correct-branch? index)
        (let (iter (i index))
          (cond ((or (= i 0) (= (+ i 1) (length locations)) (= i player-closest))
                 #t)
                ((cdr (list-ref locations i))
                 #f)
                (else
                 (iter (+ i direction))))))
      
      (if (cdr (list-ref locations closest)) ;; you are on #t
          (begin
            (set! direction (find-direction closest player-closest)) ;; if direction = 0
            (if (= direction 0)
                (goto-player)
              (if (cdr (list-ref locations player-closest)) ;; player on #t
                  (set! target-pos (let (iter (index (+ closest direction)))
                                     (if (or (= index 0) (= (+ index 1) (length locations)) (cdr (list-ref locations index)))
                                         (cons (car (list-ref locations index)) index)
                                       (iter (+ index direction)))))
                (set! target-pos (let ((index (+ closest direction))) ;; player on #f
                                   (if (cdr (list-ref locations index))
                                       (cons (car (list-ref locations index)) index)
                                     (if (correct-branch? index)
                                         (if (> direction 0)
                                             (let (iter (i (+ index 1)))
                                               (if (or (cdr (list-ref locations i)) (= (+ i 1) (length locations)))
                                                   (begin
                                                     (set! direction -1)
                                                     (cons (car (list-ref locations i)) i))
                                                 (iter (+ i 1))))
                                           (cons (car (list-ref locations index)) index))
                                       (let (iter (i (+ index direction)))
                                         (if (or (cdr (list-ref locations i)) (= i 0) (= (+ i 1) (length locations)))
                                             (cons (car (list-ref locations i)) i)
                                           (iter (+ i direction)))))))))))
        (if (or (cdr (list-ref locations player-closest)) (not (correct-branch? closest))) ;; you are on #f
            (if (< (+ closest 1) (length locations))
                (let ((next (+ closest 1)))
                  (set! target-pos (cons (car (list-ref locations next)) next)))
              (goto-player))
          (set! direction (find-direction (cdr target-pos) player-closest))
          (if (= direction 0)
              (goto-player)
            (let ((next (+ closest direction)))
              (set! target-pos (cons (car (list-ref locations next)) next)))))))
    (when by-sight?
      (set! by-sight? #f))))

(definition protected (goto-player (sight? #f))
  (when sight?
    (set! by-sight? #t))
  (set! moving-to-player? #t)
  (set! target-pos #f)
  (set! direction #f))

(definition protected (can-see-player?)
  (define (polygon-filter poly)
    (let ((element (get-element~ poly)))
      (and (not (eq? element (self)))
           (or (eq? element (player)) (is-not? element world.creature:Creature))
           (liquid-filter poly))))
  
  (let ((position (lens-center~ (self)))
        (pos (lens-center~ (player))))
    (let ((dir (vertex-& pos position)))
      (or (vertex-zero? dir)
          (let ((closest (ray-closest-polygon position (vertex-normalize dir) (vertex-distance position pos) filter: polygon-filter ignore-entities?: #f)))
            (and closest (equal? (get-element~ (first closest)) (player))))))))


;;;
;;;; Various
;;;


(definition public (animate actor animation (next: next #f))
  (assert (find-animation~ (cache-model~ actor) animation))
  (transition-morphing~ actor animation next: (or next "Idle"))
  (set-animation-active~ actor animation))


;; quick hack
(definition public (refresh)
  (let ((actor (current-actor)))
    (let ((script (get-script~ actor)))
      (add-objective~ script
        (lambda ()
          (lambda ()
            (animate actor "Idle")
            (objective-done~ script)))))))


(definition public (creatures)
  (let ((zone (current-zone)))
    (get-creatures~ zone)))


(definition public (block-interact a b c)
  (let ((game (current-game)))
    (interact-at~ game (location->position (vector a b c)))))


(definition public (set-block-data a b c data)
  (let ((game (current-game))
        (zone (current-zone)))
    (updating-sectors~ zone
      (lambda (add-sector)
        (call-with-position~ zone (location->position (vector a b c))
          (lambda (region sector block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
            (with-field i j k
              (lambda (section index)
                (data-set! section index data)
                (add-sector sector)))))))))


;;;
;;;; Move
;;;


#/Jazz/
(handle (tick)
  (move))
//#


;;;
;;;; Happy
;;;


#/Jazz/
(define happy?
  #f)

(handle (tick)
  (if (near-player? me)
      (begin
        (when (not happy?)
          (sound bark volume: .25))
        (lookat-player me)
        (jump)
        (set! happy? #t))
    (move)
    (set! happy? #f)))
//#


;;;
;;;; Speed
;;;


#/Jazz/
(when (get first-time? #t)
  (set-position me (vertex 0. -60. 0.))
  (set-lookat me (lookat-horizon (vertex 0. 0. 1.)))
  (set first-time? #f))

(set-motion me 'run)

(handle (tick)
  (let ((z (vertex-z (get-position me))))
    (cond ((> z 20.)
           (set-lookat me (lookat-horizon (vertex 0. 0. -1.))))
          ((< z 0.)
           (set-lookat me (lookat-horizon (vertex 0. 0. 1.))))))
  (move))
//#


;;;
;;;; Run
;;;


#/Jazz/
(when (not (get stage))
  (set stage 0))

(set stage (+ (get stage) 1))

(case (get stage)
  ((1)
   (set-all-motion 'walk))
  ((2)
   (set-all-motion 'run)
   (sound "sound/Rocky"))
  ((3)
   (handle (tick)
     (debug 'tick))))
//#


;;;
;;;; Dialog
;;;


#/Jazz/
(handle (tick)
  (if fly
      (my-people)
    (lookat-player)
    (if (near-player? self 3.)
        (stay)
      (move))
    (let ((time (current-seconds)))
      (let ((elapse (- time previous)))
        (set! previous time)
        (tick-msgs elapse)))))

(definition self
  (current-actor))

(definition previous
  0.)

(definition timer
  #f)

(definition (stop)
  (stay))

(definition fly
  #f)

(definition msg-index
  0)

(definition msgs
  (list (cons "Hi" 3.)
        (cons "I am Groot" 3.)
        (cons "My people need me!" 0.)))

(definition (tick-msgs elapse)
  (if (< msg-index (length msgs))
      (begin
        (when timer
          (decrease! timer elapse))
        (when (or (not timer) (< timer 0.))
          (message (car (list-ref msgs msg-index)))
          (set! timer (cdr (list-ref msgs msg-index)))
          (increase! msg-index)))
    (set! fly #t)))
//#
)
