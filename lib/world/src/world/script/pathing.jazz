;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Script Pathing
;;;
;;;  The Initial Developer of the Original Code is Edouard Hebert.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.script.pathing jazz


(import (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (world)
        (world.actor)
        (world.autoload)
        (world.billboard)
        (world.commands)
        (world.context)
        (world.contour)
        (world.creature)
        (world.draw)
        (world.dyes)
        (world.entity)
        (world.generation)
        (world.generation.block)
        (world.geometry)
        (world.mark)
        (world.homogeneous)
        (world.model)
        (world.scripter)
        (world.scripting)
        (world.scriptum)
        (world.sound)
        (world.syntax (phase syntax))
        (world.task)
        (world.travel))


(definition protected (tick-dwarf)
  (when (and #t (< (get-velocity-angle (self)) 1.5))
    (get-stuck))
  (if moving-to-player?
      (begin
        (%%lookat-player (self))
        (if (%%near-player? (self) 3.)
            (perform-stay)
          (perform-move)))
    (%%lookat-target (car target-pos) (self))
    (perform-move))
  (unless moving-to-player?
    (when (near-target? (self) (car target-pos) 0.1)
      (reach-target))))


(definition protected (self)
  (%%current-entity))

(definition protected (player)
  (current-me))


(definition protected toggle-locations
  (let ((show-locations? #f))
    (lambda ()
      (let ((zone (current-zone)))
        (if show-locations?
            (begin
              (reset-marks zone)
              (set! show-locations? #f))
          (for-each
            (lambda (location)
              (add-mark zone (new Position-Mark (car location))))
            locations)
          (set! show-locations? #t))))))


(definition protected locations
  '((#f64(-148. 99. 104.) . #f)
    (#f64(-145.5 99. 104.) . #t)
    (#f64(-138. 98. 100.) . #f)
    (#f64(-138. 98. 104.) . #t)
    (#f64(-142. 96. 112.) . #f)
    (#f64(-138. 96. 112.) . #t)
    (#f64(-134. 96. 114.) . #f)
    (#f64(-138. 96. 114.) . #t)
    (#f64(-138. 96. 118.) . #t)
    (#f64(-134. 96. 118.) . #t)
    (#f64(-128. 92. 118.) . #t)
    (#f64(-128. 89. 125.) . #t)
    (#f64(-128. 88.5 129.) . #t)
    (#f64(-129. 88.5 129.) . #t)
    (#f64(-129. 88.5 135.) . #t)))


(definition protected (near-target? actor target distance)
  (<= (vertex-distance (get-position actor) target) distance))


(definition protected target-pos
  #f)

(definition protected moving-to-player?
  #t)

(definition protected by-sight?
  #f)

(definition protected direction
  0)


(definition protected (find-closest-location (actor (self)))
  (let ((pos (get-position actor))
        (closest #f)
        (distance #f))
    (let (iter (index 0))
      (unless (>= index (length locations))
        (let ((location (car (list-ref locations index))))
          (let ((dist (vertex-distance location pos)))
            (when (or (not distance) (< dist distance))
              (set! closest index)
              (set! distance dist))
            (iter (+ index 1))))))
    closest))


(definition protected (get-stuck)
  (let ((closest (find-closest-location)))
    (if moving-to-player?
        (let ((location (list-ref locations closest)))
          (if (or (not (cdr location)) (< (vertex-distance (car location) (player)) (vertex-distance (self) (player))))
              (set! target-pos (cons (car location) closest))
            (let ((player-closest (find-closest-location (player))))
              (set! direction (find-direction closest player-closest))
              (let (iter (index (+ closest direction)))
                (if (or (= index 0) (= (+ index 1) (length locations)) (cdr (list-ref locations index)))
                    (set! target-pos (cons (car (list-ref locations index)) index))
                  (iter (+ index direction))))))
          (set! moving-to-player? #f))
      (set! target-pos (cons (car (list-ref locations closest)) closest)))))


(definition protected (find-direction (closest #f) (player-closest #f))
  (let ((closest (or closest (find-closest-location)))
        (player-closest (or player-closest (find-closest-location (player)))))
    (if (> player-closest closest)
        1
      (if (= player-closest closest)
          0
        -1))))


(definition protected (reach-target)
  (if (and (can-see-player?) (not by-sight?))
      (goto-player #t)
    (let ((player-closest (find-closest-location (player)))
          (closest (cdr target-pos)))
      (define (correct-branch? index)
        (let (iter (i index))
          (cond ((or (= i 0) (= (+ i 1) (length locations)) (= i player-closest))
                 #t)
                ((cdr (list-ref locations i))
                 #f)
                (else
                 (iter (+ i direction))))))
      
      (if (cdr (list-ref locations closest)) ;; you are on #t
          (begin
            (set! direction (find-direction closest player-closest)) ;; if direction = 0
            (if (= direction 0)
                (goto-player)
              (if (cdr (list-ref locations player-closest)) ;; player on #t
                  (set! target-pos (let (iter (index (+ closest direction)))
                                     (if (or (= index 0) (= (+ index 1) (length locations)) (cdr (list-ref locations index)))
                                         (cons (car (list-ref locations index)) index)
                                       (iter (+ index direction)))))
                (set! target-pos (let ((index (+ closest direction))) ;; player on #f
                                   (if (cdr (list-ref locations index))
                                       (cons (car (list-ref locations index)) index)
                                     (if (correct-branch? index)
                                         (if (> direction 0)
                                             (let (iter (i (+ index 1)))
                                               (if (or (cdr (list-ref locations i)) (= (+ i 1) (length locations)))
                                                   (begin
                                                     (set! direction -1)
                                                     (cons (car (list-ref locations i)) i))
                                                 (iter (+ i 1))))
                                           (cons (car (list-ref locations index)) index))
                                       (let (iter (i (+ index direction)))
                                         (if (or (cdr (list-ref locations i)) (= i 0) (= (+ i 1) (length locations)))
                                             (cons (car (list-ref locations i)) i)
                                           (iter (+ i direction)))))))))))
        (if (or (cdr (list-ref locations player-closest)) (not (correct-branch? closest))) ;; you are on #f
            (if (< (+ closest 1) (length locations))
                (let ((next (+ closest 1)))
                  (set! target-pos (cons (car (list-ref locations next)) next)))
              (goto-player))
          (set! direction (find-direction (cdr target-pos) player-closest))
          (if (= direction 0)
              (goto-player)
            (let ((next (+ closest direction)))
              (set! target-pos (cons (car (list-ref locations next)) next)))))))
    (when by-sight?
      (set! by-sight? #f))))


(definition protected (goto-player (sight? #f))
  (when sight?
    (set! by-sight? #t))
  (set! moving-to-player? #t)
  (set! target-pos #f)
  (set! direction #f))


(definition protected (can-see-player?)
  (define (polygon-filter poly)
    (let ((element (get-element poly)))
      (and (not (eq? element (self)))
           (or (eq? element (player)) (is-not? element Creature))
           (liquid-filter poly))))
  
  (let ((position (lens-center (self)))
        (pos (lens-center (player))))
    (let ((dir (vertex-& pos position)))
      (or (vertex-zero? dir)
          (let ((closest (ray-closest-polygon position (vertex-normalize dir) (vertex-distance position pos) filter: polygon-filter ignore-entities?: #f)))
            (and closest (equal? (get-element (first closest)) (player)))))))))
