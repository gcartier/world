;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Change Parts
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.parts jazz


(import (world)
        (world.autoload)
        (world.commands)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.id)
        (world.index)
        (world.log)
        (world.lookat)
        (world.part)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))


;;;
;;;; Float
;;;


(define-part float
  1)


(definition protected (push-float push val <fl>)
  (push val))


(definition protected (pop-float pop <:fl>) <fl>
  (pop))


;;;
;;;; Integer
;;;


(define-part integer
  1)


(definition protected (push-integer push val <fx>)
  (push (cast <fl> val)))


(definition protected (pop-integer pop <:fl>) <fx>
  (let ((fl (pop)))
    (flonum->fixnum fl)))


;;;
;;;; Vertex
;;;


(define-part vertex
  3)


(definition protected (push-vertex push vert <vertex>)
  (push (vertex-x vert))
  (push (vertex-y vert))
  (push (vertex-z vert)))


(definition protected (pop-vertex! vert pop <:fl>) <vertex>
  (let* ((x (pop))
         (y (pop))
         (z (pop)))
    (vertex! vert x y z)))


;;;
;;;; LookAt
;;;


(define-part lookat
  9)


(definition protected (push-lookat push lookat <LookAt>)
  (let ((sight (get-sight~ lookat))
        (up (get-up~ lookat))
        (right (get-right~ lookat)))
    (push (vertex-x sight))
    (push (vertex-y sight))
    (push (vertex-z sight))
    (push (vertex-x up))
    (push (vertex-y up))
    (push (vertex-z up))
    (push (vertex-x right))
    (push (vertex-y right))
    (push (vertex-z right))))


(definition protected (pop-lookat! lookat pop <:fl>) <LookAt>
  (let* ((sx (pop))
         (sy (pop))
         (sz (pop))
         (ux (pop))
         (uy (pop))
         (uz (pop))
         (rx (pop))
         (ry (pop))
         (rz (pop)))
    (lookat! lookat
             (vertex& sx sy sz)
             (vertex& ux uy uz)
             (vertex& rx ry rz))))


;;;
;;;; Literal
;;;


(define-part literal
  1)


(definition protected (push-literal push literal)
  (push (cast <fl> (literal->id literal))))


(definition protected (pop-literal pop <:fl>)
  (let ((literal-id (pop)))
    (id->literal (flonum->fixnum literal-id))))


;;;
;;;; Id
;;;


(define-part id
  1)


(definition protected (push-id push id)
  (push-literal push id))


(definition protected (pop-id pop <:fl>)
  (pop-literal pop))


;;;
;;;; Class
;;;


(define-part class
  1)


(definition protected (push-class push class)
  (push-literal push (category-name class)))


(definition protected (pop-class pop <:fl>)
  (let ((world (current-world)))
    (let ((class-name (pop-literal pop)))
      (class-name->class~ world class-name))))


;;;
;;;; Entity
;;;


(define-part entity
  1)


(definition protected (push-entity push entity <Entity>)
  ;; a try
  (assert (get-id~ entity))
  (push (cast <fl> (literal->id (get-id~ entity)))))


(definition protected (pop-entity pop <:fl>) <Entity>
  (let ((id (pop)))
    (let ((id (flonum->fixnum id)))
      (let ((entity (find-entity (id->literal id))))
        (assert entity)
        @debug
        (when (not entity)
          (log-server (format "Unable to find entity #{s}" id)))
        entity))))


(definition protected (pop-entity/id pop <:fl>)
  (let ((id (pop)))
    (let ((id (flonum->fixnum id)))
      (let ((entity (find-entity (id->literal id))))
        (or entity id)))))


(define-part chunk-entity
  3)


(definition protected (push-chunk-entity push entity <Entity>)
  (let ((chunk (get-designer-chunk~ entity)))
    ;; devel assertion until fully debugged
    (assert chunk
      (let ((section-x (section-x~ chunk))
            (section-z (section-z~ chunk)))
        (push-integer push section-x)
        (push-integer push section-z)
        (push-id push (get-id~ entity))))))


(definition protected (pop-chunk-entity pop <:fl>) <Entity>
  (let ((zone (current-zone)))
    (let* ((section-x (pop-integer pop))
           (section-z (pop-integer pop))
           (id (pop-id pop)))
      ;; collabo quick test
      (let ((section-y 0))
        (index-chunk~ zone (indexed section-x section-y section-z))
        (let ((entity (find-entity id)))
          (assert entity)
          @debug
          (when (not entity)
            (log-server (format "Unable to find chunk entity #{s}" id)))
          entity)))))


;;;
;;;; Commands
;;;


(define-part commands
  1)


(definition protected (push-commands push commands <Commands+>)
  (push ;; quick hack for track-ground
        (if commands
            (cast <fl> (encode~ commands))
          -1.)))


(definition protected (pop-commands pop <:fl>) <Commands+>
  (let ((commands-encoded (pop)))
    ;; quick hack for track-ground
    (if (= commands-encoded -1.)
        #f
      (let ((commands (new Commands)))
        (decode~ commands (flonum->fixnum commands-encoded))
        commands)))))
