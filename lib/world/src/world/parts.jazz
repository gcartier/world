;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Change Parts
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.parts jazz


(import (world)
        (world.autoload)
        (world.binary)
        (world.commands)
        (world.context)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.lookat)
        (world.part)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))


;;;
;;;; Double
;;;


(define-part double
  1)


(definition protected (push-double push val <fl>)
  (push val))


(definition protected (pop-double pop <:fl>) <fl>
  (pop))


;;;
;;;; Integer
;;;


(define-part integer
  1)


(definition protected (push-integer push val <fx>)
  (push (cast <fl> val)))


(definition protected (pop-integer pop <:fl>) <fx>
  (let ((fl (pop)))
    (flonum->fixnum fl)))


;;;
;;;; Boolean
;;;


(define-part boolean
  1)


(definition protected (push-boolean push val <bool>)
  (push (if val 1. 0.)))


(definition protected (pop-boolean pop <:fl>) <bool>
  (let ((fl (pop)))
    (/= fl 0.)))


;;;
;;;; Vertex
;;;


(define-part vertex
  3)


(definition protected (push-vertex push vert <vertex>)
  (push (vertex-x vert))
  (push (vertex-y vert))
  (push (vertex-z vert)))


(definition protected (pop-vertex pop <:fl>) <vertex>
  (pop-vertex! (make-vertex) pop))


(definition protected (pop-vertex! vert pop <:fl>) <vertex>
  (let* ((x (pop))
         (y (pop))
         (z (pop)))
    (vertex! vert x y z)))


;;;
;;;; LookAt
;;;


(define-part lookat
  9)


(definition protected (push-lookat push lookat <LookAt>)
  (let ((sight (get-sight lookat))
        (up (get-up lookat))
        (right (get-right lookat)))
    (push (vertex-x sight))
    (push (vertex-y sight))
    (push (vertex-z sight))
    (push (vertex-x up))
    (push (vertex-y up))
    (push (vertex-z up))
    (push (vertex-x right))
    (push (vertex-y right))
    (push (vertex-z right))))


(definition protected (pop-lookat pop <:fl>) <LookAt>
  (pop-lookat! (make-lookat) pop))


(definition protected (pop-lookat! lookat pop <:fl>) <LookAt>
  (let* ((sx (pop))
         (sy (pop))
         (sz (pop))
         (ux (pop))
         (uy (pop))
         (uz (pop))
         (rx (pop))
         (ry (pop))
         (rz (pop)))
    (lookat! lookat
             (vertex& sx sy sz)
             (vertex& ux uy uz)
             (vertex& rx ry rz))))


;;;
;;;; Literal
;;;


(define-part literal
  1)


(definition protected (push-literal push literal)
  (push (cast <fl> (literal->id literal))))


(definition protected (pop-literal pop <:fl>)
  (let ((literal-id (pop)))
    (id->literal (flonum->fixnum literal-id))))


;;;
;;;; Id
;;;


(define-part id
  2)


(definition protected (push-id push id <f64vector>)
  (push (f64vector-ref id 0))
  (push (f64vector-ref id 1)))


(definition protected (pop-id pop <:fl>) <f64vector>
  (let* ((d0 (pop))
         (d1 (pop)))
    (f64vector d0 d1)))


;;;
;;;; Digest
;;;


(define-part digest
  3)


(definition protected (push-digest push digest <u8vector>)
  (let ((vec (digest->f64vector digest)))
    (push (f64vector-ref vec 0))
    (push (f64vector-ref vec 1))
    (push (f64vector-ref vec 2))))


(definition protected (pop-digest pop <:fl>) <u8vector>
  (let* ((d0 (pop))
         (d1 (pop))
         (d2 (pop)))
    (f64vector->digest (f64vector d0 d1 d2))))


(definition protected (digest->f64vector digest <u8vector>) <f64vector>
  (let ((bytes (make-u8vector 24 0)))
    (subu8vector-move! digest 0 20 bytes 0)
    (f64vector
      (scan-double bytes 0)
      (scan-double bytes 8)
      (scan-double bytes 16))))


(definition protected (f64vector->digest vec <f64vector>) <u8vector>
  (let ((bytes (make-u8vector 24 0)))
    (put-double bytes 0 (f64vector-ref vec 0))
    (put-double bytes 8 (f64vector-ref vec 1))
    (put-double bytes 16 (f64vector-ref vec 2))
    (let ((digest (make-u8vector 20 0)))
      (subu8vector-move! bytes 0 20 digest 0)
      digest)))


;;;
;;;; Class
;;;


(define-part class
  1)


(definition protected (push-class push class)
  (let ((world (current-world)))
    (push-literal push (class->class-name world class))))


(definition protected (pop-class pop <:fl>)
  (let ((world (current-world)))
    (let ((class-name (pop-literal pop)))
      (class-name->class world class-name))))


;;;
;;;; Entity
;;;


(define-part entity
  2)


(definition protected (push-entity push entity <Entity>)
  (let ((id (get-id entity)))
    (assert id
      (push-id push id))))


(definition protected (pop-entity pop <:fl>) <Entity>
  (let ((id (pop-id pop)))
    (let ((entity (retrieve-entity (current-tier) id)))
      ;; sejour quicky
      (if (not entity)
          #f
        (assert entity)
        entity))))


;;;
;;;; Commands
;;;


(define-part commands
  1)


(definition protected (push-commands push commands <Commands+>)
  (push ;; quick hack for track-ground
        (if commands
            (cast <fl> (encode commands))
          -1.)))


(definition protected (pop-commands pop <:fl>) <Commands+>
  (let ((commands-encoded (pop)))
    ;; quick hack for track-ground
    (if (= commands-encoded -1.)
        #f
      (let ((commands (new Commands)))
        (decode commands (flonum->fixnum commands-encoded))
        commands)))))
