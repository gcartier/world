;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Profiling
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.profiling jazz


(import (jazz.tracker)
        (profiler)
        (world))


(proclaim (not check bounds zero)
          (warn optimizations))

(declare (optimize-dead-local-variables))


(definition protected current-advise
  #f)


(definition public (setup-profiling)
  (iterate-table (registered-sites)
    (lambda (identifier site)
      (setup-site site)))
  (set-site-callback
    (lambda (site)
      (setup-site site)
      (when current-advise
        (current-advise site)))))


;;;
;;;; Profile
;;;


(definition public (advise-profile what)
  (let ((identifier (enumerator->symbol what)))
    (advise what
            (lambda (field locator original set)
              (let ((original (original)))
                (when (procedure? original)
                  (set (lambda rest
                         (with-profile identifier
                           (lambda ()
                             (apply original rest)))))))))))


;;;
;;;; Chronology
;;;


(definition sample-size <fx>
  4)


(class Chronology-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-size object))
                              (serialize (get-content-size object))
                              (serialize (get-content object))
                              (serialize (get-next-marker object))
                              (serialize (get-now object))
                              (serialize (get-head object))
                              (serialize (get-count object)))))
  
  
  (method override (unmarshall-object self content)
    (bind-vector (size content-size content next-marker now head count) content
      (allocate self
                (deserialize size)
                (deserialize content-size)
                (deserialize content)
                (make-mutex 'chronology)
                (deserialize next-marker)
                (deserialize now)
                (deserialize head)
                (deserialize count)))))


(class Chronology metaclass Chronology-Class extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot content-size <fx>        getter generate)
  (slot content      <f64vector> getter generate)
  (slot mutex        <object>    getter generate)
  (slot next-marker  <fx>        getter generate)
  (slot now          <fx>        accessors generate)
  (slot head         <fx>        accessors generate)
  (slot count        <fx>        accessors generate)
  
  
  (method override (initialize self size <fx>)
    (nextmethod self)
    (set! self.size size)
    (set! content-size (* size sample-size))
    (set! content (make-f64vector content-size))
    (set! mutex (make-mutex 'chronology))
    (set! next-marker 0)
    (set! now 0)
    (set! head 0)
    (set! count 0))
  
  
  (method package (reset self)
    (mutex-lock! mutex)
    (f64vector-fill! content 0.)
    (set! next-marker 0)
    (set! now 0)
    (set! head 0)
    (set! count 0)
    (mutex-unlock! mutex))
  
  
  (method package (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  (method package (next-marker! self) <fx>
    (prog1 next-marker
      (increase! next-marker 2)))

  
  (method package inline (start-position self) <fx>
    0)
  
  
  (method package inline (end-position self) <fx>
    count)
  
  
  (method package inline (first-position self) <fx>
    0)
  
  
  (method package inline (last-position self) <fx>
    (- (end-position self) 1))
  
  
  (method package inline (index self n <fx>) <fx>
    (modulo (+ head (* n sample-size)) content-size))
  
  
  (method package inline (index-now self) <fx>
    (index self now))
  
  
  (method package (chronological-id self n <fx>) <fl>
    (f64vector-ref content (index self n)))
  
  (method package (chronological-marker self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 1)))
  
  (method package (chronological-time self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 2)))
  
  (method package (chronological-memory self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 3)))
  
  
  (method package inline (advance! self)
    (if (< count size)
        (begin
          (increase! count)
          (increase! now))
      (set! head (modulo (+ head sample-size) content-size)))))


;; about one minute of recorded chronology
(definition chronology <Chronology>
  (new Chronology 90000))


(definition public inline (current-chronology) <Chronology>
  chronology)


(definition protected (copy-chronology chronology <Chronology>) <Chronology>
  (let ((copy (new Chronology (get-size chronology))))
    (mutex-lock! (get-mutex copy))
    (mutex-lock! (get-mutex chronology))
    (subf64vector-move! (get-content chronology) 0 (get-content-size chronology) (get-content copy) 0)
    (set-now copy (get-now chronology))
    (set-head copy (get-head chronology))
    (set-count copy (get-count chronology))
    (mutex-unlock! (get-mutex copy))
    (mutex-unlock! (get-mutex chronology))
    copy))


(definition protected (reset-chronology)
  (reset (current-chronology)))


(definition protected (determine-cpu% chronology)
  (with-mutex chronology
    (lambda ()
      (let ((first (first-position chronology))
            (last (last-position chronology)))
        (let ((first-time (chronological-time chronology first))
              (last-time (chronological-time chronology last)))
          (let ((last-end first-time))
            (define (count-already-in)
              (let ((count 0)
                    (starts (make-vector (site-id-count) #f)))
                (loop (for n from first to last)
                      (let ((id (flonum->fixnum (chronological-id chronology n))))
                        (when (not (vector-ref starts id))
                          (vector-set! starts id #t)
                          (let ((end? (odd? (flonum->fixnum (chronological-marker chronology n)))))
                            (when end?
                              (set! last-end (chronological-time chronology n))
                              (increase! count))))))
                count))
            
            (let ((in (count-already-in))
                  (idle 0.))
              (loop (for n from first to last)
                    (let ((marker (chronological-marker chronology n))
                          (time (chronological-time chronology n)))
                      (let ((start? (even? (flonum->fixnum marker))))
                        (cond (start?
                               (when (= in 0)
                                 (increase! idle (- time last-end)))
                               (increase! in))
                              (else
                               (decrease! in)
                               (when (= in 0)
                                 (set! last-end time)))))))
              (let ((elapsed (- last-time first-time)))
                (let ((cpu (- elapsed idle)))
                  (percentage cpu elapsed))))))))))


(definition protected (update-sites! chronology)
  (with-mutex chronology
    (lambda ()
      (let ((first (first-position chronology))
            (last (last-position chronology)))
        (iterate-table (registered-sites)
          (lambda (identifier site)
            (site-profile-reset (get-profile site))))
        (let ((starts (make-vector (site-id-count) #f)))
          (loop (for n from first to last)
                (let ((id (flonum->fixnum (chronological-id chronology n)))
                      (marker (chronological-marker chronology n)))
                  (let ((start? (even? (flonum->fixnum marker))))
                    (cond (start?
                           (vector-set! starts id n))
                          (else
                           (let ((start (vector-ref starts id)))
                             (when start
                               (let ((start-time (chronological-time chronology start))
                                     (start-memory (chronological-memory chronology start)))
                                 (let ((running (- (chronological-time chronology n) start-time))
                                       (allocated (- (chronological-memory chronology n) start-memory))
                                       (profile (get-profile (id->site id))))
                                   (site-profile-running-set! profile (+ (site-profile-running profile) running))
                                   (site-profile-allocated-set! profile (+ (site-profile-allocated profile) allocated))
                                   (site-profile-called-set! profile (+ (site-profile-called profile) 1.))
                                   (vector-set! starts id #f)))))))))))
        (- (chronological-time chronology last)
           (chronological-time chronology first))))))


;;;
;;;; Site
;;;


(definition inline (make-site-profile) <f64vector>
  (f64vector 0. 0. 0.))


(definition protected inline (site-profile-running profile <f64vector>) <fl>
  (f64vector-ref profile 0))

(definition protected inline (site-profile-allocated profile <f64vector>) <fl>
  (f64vector-ref profile 1))

(definition protected inline (site-profile-called profile <f64vector>) <fl>
  (f64vector-ref profile 2))


(definition protected inline (site-profile-running-set! profile <f64vector> running <fl>) <void>
  (f64vector-set! profile 0 running))

(definition protected inline (site-profile-allocated-set! profile <f64vector> allocated <fl>) <void>
  (f64vector-set! profile 1 allocated))

(definition protected inline (site-profile-called-set! profile <f64vector> called <fl>) <void>
  (f64vector-set! profile 2 called))


(definition protected (site-profile-reset profile <f64vector>) <void>
  (site-profile-running-set! profile 0.)
  (site-profile-allocated-set! profile 0.)
  (site-profile-called-set! profile 0.))


(definition public (iterate-sites proc)
  (iterate-table-safe (registered-sites)
    (lambda (identifier site)
      (proc (symbol->enumerator identifier)))))


(definition public (advise-sites)
  (iterate-sites advise-site)
  (set! current-advise (lambda (site <Call-Site>)
                         (let ((identifier (get-identifier site)))
                           (let ((what (symbol->enumerator identifier)))
                             (advise-site what))))))

(definition public (unadvise-sites)
  (iterate-sites unadvise)
  (set! current-advise #f))


(definition (setup-site site <Call-Site>)
  (set-profile site (make-site-profile)))


(definition public (advise-site what)
  (let ((identifier (enumerator->symbol what)))
    (advise what
            (lambda (field locator original set)
              (let ((original (original)))
                (when (procedure? original)
                  (set (lambda (site thunk)
                         ;; pass original and thunk as parameters instead of
                         ;; using a closure that would allocate some memory
                         (with-site identifier site original thunk)))))))))


(definition public (with-site identifier site <Call-Site> procedure thunk)
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  (let ((chronology (current-chronology)))
    (let ((profile (get-profile site))
          (content (get-content chronology))
          (mutex (get-mutex chronology))
          (id <fx> (get-id site)))
      (mutex-lock! mutex)
      (let ((marker (next-marker! chronology)))
        (let ((index (index-now chronology)))
          (f64vector-set! content index (cast <fl> id))
          (f64vector-set! content (+ index 1) (cast <fl> marker))
          (current-seconds! content (+ index 2))
          (bytes-allocated! content (+ index 3))
          (advance! chronology))
        (mutex-unlock! mutex)
        (prog1 (case (get-monitor site)
                 ((performance)
                  (with-profile identifier thunk))
                 ((memory)
                  (with-tracking identifier thunk))
                 (else
                  (procedure site thunk)))
          (mutex-lock! mutex)
          (let ((index (index-now chronology)))
            (f64vector-set! content index (cast <fl> id))
            (f64vector-set! content (+ index 1) (cast <fl> (+ marker 1)))
            (current-seconds! content (+ index 2))
            (bytes-allocated! content (+ index 3))
            (advance! chronology))
          (mutex-unlock! mutex))))))


(proclaim (not warn optimizations))


(definition debug-bug?
  #f)


(definition public (root-sites)
  (let ((queue (new-queue)))
    (iterate-table (registered-sites)
      (lambda (name site)
        (when (not (get-parent site))
          (enqueue queue site))))
    (queue-list queue)))


(definition public (sites-tree)
  (let ((root (list #f))
        (nodes (make-table test: eq?)))
    (define (site-node site)
      (or (table-ref nodes site #f)
          (let ((node (list site)))
            (table-set! nodes site node)
            (let ((parent (get-parent site)))
              (let ((parent-node (if (not parent)
                                     root
                                   (site-node (registered-site parent)))))
                (set-cdr! parent-node (insert-ordered! node (cdr parent-node)
                                        key: (lambda (node) (get-identifier (car node)))
                                        test: (lambda (x y)
                                                ;; quicky to put memory at the top
                                                (cond ((eq? x 'memory) #t)
                                                      ((eq? y 'memory) #f)
                                                      (else (nu<? x y))))))))
            node)))
    
    (iterate-table-safe (registered-sites)
      (lambda (identifier site)
        (site-node site)))
    root))


@wait
(definition public (sites-tree)
  (when debug-bug?
  (terminal '********))
  (let ((root (list #f))
        (nodes (make-table test: eq?)))
    (define (site-node site)
      (or (table-ref nodes site #f)
          (let ((node (list site)))
            (table-set! nodes site node)
            (let ((parent (get-parent site)))
              (let ((parent-node (if (not parent)
                                     root
                                   (site-node (registered-site parent)))))
                (set-cdr! parent-node (insert-ordered! node (cdr parent-node)
                                        key: (lambda (node) (get-identifier (car node)))
                                        test: (lambda (x y)
                                                ;; quicky to put memory at the top
                                                (cond ((eq? x 'memory) #t)
                                                      ((eq? y 'memory) #f)
                                                      (else (nu<? x y))))))))
            node)))
    
    (iterate-table-safe (registered-sites)
      (lambda (identifier site)
        (when debug-bug?
        (when (eq? identifier 'read-chunk)
          (terminal 'GAZ)))
        (site-node site)))
    (when debug-bug?
    (let ()
      (continuation-capture
        (lambda (return)
          (define (p node)
            (if (and (car node) (eq? (get-identifier (car node)) 'read-chunk))
                (continuation-return return #f)
              (for-each p (cdr node))))
          
          (p root)
          (bell)(bell)(bell)
          (terminal 'NOT-FOUND (registered-site 'read-chunk))))))
    root))


(definition public (describe-sites)
  (let ((root (sites-tree)))
    (define (describe nodes level)
      (for-each (lambda (node)
                  (let ((site (car node))
                        (children (cdr node)))
                    (let ((profile (get-profile site)))
                      (let ((called (site-profile-called profile)))
                        (format :console "{_ :v}{a} {a}{%}" (* level 2) (get-name site) called)))
                    (describe children (+ level 1))))
                nodes))
    
    (describe (cdr root) 0))))
