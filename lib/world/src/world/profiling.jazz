;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Profiling
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.profiling jazz


(import (jazz.tracker)
        (profiler)
        (world)
        (world.chronology))


(proclaim (not check bounds zero)
          (warn optimizations))

(declare (optimize-dead-local-variables))


(definition protected current-advise
  #f)


(definition public (setup-profiling)
  (table-iterate (registered-sites)
    (lambda (identifier site)
      (setup-site site)))
  (set-site-callback
    (lambda (site)
      (setup-site site)
      (when current-advise
        (current-advise site)))))


;;;
;;;; Profile
;;;


(definition public (advise-profile what)
  (let ((identifier (enumerator->symbol what)))
    (advise what
            (lambda (field locator original set)
              (let ((original (original)))
                (when (procedure? original)
                  (set (lambda rest
                         (with-profile identifier
                           (lambda ()
                             (apply original rest)))))))))))


(definition protected (update-sites! chronology)
  0.
  @convert
  (with-mutex chronology
    (lambda ()
      (let ((first (first-position chronology))
            (last (last-position chronology)))
        (table-iterate (registered-sites)
          (lambda (identifier site)
            (site-profile-reset (get-profile site))))
        (let ((starts (make-vector (site-id-count) #f)))
          (loop (for n from first to last)
                (let ((id (flonum->fixnum (chronological-id chronology n)))
                      (marker (chronological-marker chronology n)))
                  (let ((start? (even? (flonum->fixnum marker))))
                    (cond (start?
                           (vector-set! starts id n))
                          (else
                           (let ((start (vector-ref starts id)))
                             (when start
                               (let ((start-time (chronological-time chronology start))
                                     (start-memory (chronological-memory chronology start)))
                                 (let ((running (- (chronological-time chronology n) start-time))
                                       (allocated (- (chronological-memory chronology n) start-memory))
                                       (profile (get-profile (id->site id))))
                                   (site-profile-running-set! profile (+ (site-profile-running profile) running))
                                   (site-profile-allocated-set! profile (+ (site-profile-allocated profile) allocated))
                                   (site-profile-called-set! profile (+ (site-profile-called profile) 1.))
                                   (vector-set! starts id #f)))))))))))
        (- (chronological-time chronology last)
           (chronological-time chronology first))))))


;;;
;;;; Site
;;;


(definition inline (make-site-profile) <f64vector>
  (f64vector 0. 0. 0.))


(definition protected inline (site-profile-running profile <f64vector>) <fl>
  (f64vector-ref profile 0))

(definition protected inline (site-profile-allocated profile <f64vector>) <fl>
  (f64vector-ref profile 1))

(definition protected inline (site-profile-called profile <f64vector>) <fl>
  (f64vector-ref profile 2))


(definition protected inline (site-profile-running-set! profile <f64vector> running <fl>) <void>
  (f64vector-set! profile 0 running))

(definition protected inline (site-profile-allocated-set! profile <f64vector> allocated <fl>) <void>
  (f64vector-set! profile 1 allocated))

(definition protected inline (site-profile-called-set! profile <f64vector> called <fl>) <void>
  (f64vector-set! profile 2 called))


(definition protected (site-profile-reset profile <f64vector>) <void>
  (site-profile-running-set! profile 0.)
  (site-profile-allocated-set! profile 0.)
  (site-profile-called-set! profile 0.))


(definition public (iterate-sites proc)
  (iterate-table (registered-sites)
    (lambda (identifier site)
      (proc (symbol->enumerator identifier)))))


(definition public (advise-sites)
  (iterate-sites advise-site)
  (set! current-advise (lambda (site <Call-Site>)
                         (let ((name (get-name site)))
                           (let ((what (symbol->enumerator name)))
                             (advise-site what))))))

(definition public (unadvise-sites)
  (iterate-sites unadvise)
  (set! current-advise #f))


(definition (setup-site site <Call-Site>)
  @convert
  (set-profile site (make-site-profile)))


(definition public (advise-site what)
  (let ((identifier (enumerator->symbol what)))
    (advise what
            (lambda (field locator original set)
              (let ((original (original)))
                (when (procedure? original)
                  (set (lambda (site thunk)
                         ;; pass original and thunk as parameters instead of
                         ;; using a closure that would allocate some memory
                         (with-site identifier site original thunk)))))))))


(definition public (with-site identifier site <Call-Site> procedure thunk)
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  (thunk)
  @convert
  (let ((chronology (current-chronology)))
    (let ((profile (get-profile site))
          (content (get-content chronology))
          (mutex (get-mutex chronology))
          (id <fx> (get-id site)))
      (mutex-lock! mutex)
      (let ((marker (next-marker! chronology)))
        (let ((index (index-now chronology)))
          (f64vector-set! content index (cast <fl> id))
          (f64vector-set! content (+ index 1) (cast <fl> marker))
          (current-seconds! content (+ index 2))
          (bytes-allocated! content (+ index 3))
          (advance! chronology))
        (mutex-unlock! mutex)
        (prog1 (case (get-monitor site)
                 ((performance)
                  (with-profile identifier thunk))
                 ((memory)
                  (with-tracking identifier thunk))
                 (else
                  (procedure site thunk)))
          (mutex-lock! mutex)
          (let ((index (index-now chronology)))
            (f64vector-set! content index (cast <fl> id))
            (f64vector-set! content (+ index 1) (cast <fl> (+ marker 1)))
            (current-seconds! content (+ index 2))
            (bytes-allocated! content (+ index 3))
            (advance! chronology))
          (mutex-unlock! mutex))))))


(proclaim (not warn optimizations))


(definition public (sites-metadata)
  (let ((queue (new-queue)))
    (table-iterate (registered-sites)
      (lambda (name site)
        (enqueue queue (cons (get-id site) name))))
    (queue-list queue)))


(definition debug-bug?
  #f)


(definition public (root-sites)
  (let ((queue (new-queue)))
    (table-iterate (registered-sites)
      (lambda (name site)
        (when (not (get-parent site))
          (enqueue queue site))))
    (queue-list queue)))


(definition public (sites-tree)
  (let ((root (list #f))
        (nodes (make-table test: eq?)))
    (define (site-node site)
      (or (table-ref nodes site #f)
          (let ((node (list site)))
            (table-set! nodes site node)
            (let ((parent (get-parent site)))
              (let ((parent-node (if (not parent)
                                     root
                                   (site-node (registered-site parent)))))
                (set-cdr! parent-node (insert-ordered! node (cdr parent-node)
                                        key: (lambda (node) (get-identifier (car node)))
                                        test: (lambda (x y)
                                                ;; quicky to put memory at the top
                                                (cond ((eq? x 'memory) #t)
                                                      ((eq? y 'memory) #f)
                                                      (else (nu<? x y))))))))
            node)))
    
    (iterate-table (registered-sites)
      (lambda (identifier site)
        (site-node site)))
    root))


@wait
(definition public (sites-tree)
  (when debug-bug?
  (terminal '********))
  (let ((root (list #f))
        (nodes (make-table test: eq?)))
    (define (site-node site)
      (or (table-ref nodes site #f)
          (let ((node (list site)))
            (table-set! nodes site node)
            (let ((parent (get-parent site)))
              (let ((parent-node (if (not parent)
                                     root
                                   (site-node (registered-site parent)))))
                (set-cdr! parent-node (insert-ordered! node (cdr parent-node)
                                        key: (lambda (node) (get-identifier (car node)))
                                        test: (lambda (x y)
                                                ;; quicky to put memory at the top
                                                (cond ((eq? x 'memory) #t)
                                                      ((eq? y 'memory) #f)
                                                      (else (nu<? x y))))))))
            node)))
    
    (iterate-table (registered-sites)
      (lambda (identifier site)
        (when debug-bug?
        (when (eq? identifier 'read-chunk)
          (terminal 'GAZ)))
        (site-node site)))
    (when debug-bug?
    (let ()
      (continuation-capture
        (lambda (return)
          (define (p node)
            (if (and (car node) (eq? (get-identifier (car node)) 'read-chunk))
                (continuation-return return #f)
              (for-each p (cdr node))))
          
          (p root)
          (bell)(bell)(bell)
          (terminal 'NOT-FOUND (registered-site 'read-chunk))))))
    root))


(definition public (describe-sites)
  (let ((root (sites-tree)))
    (define (describe nodes level)
      (for-each (lambda (node)
                  (let ((site (car node))
                        (children (cdr node)))
                    (let ((profile (get-profile site)))
                      (let ((called (site-profile-called profile)))
                        (format :console "{_ :v}{a} {a}{%}" (* level 2) (get-name site) called)))
                    (describe children (+ level 1))))
                nodes))
    
    (describe (cdr root) 0))))
