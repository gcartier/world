;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Profiling
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.profiling jazz


(import (jazz.tracker)
        (profiler)
        (world)
        (world.chronology))


(proclaim (not check bounds zero)
          (warn optimizations))

(declare (optimize-dead-local-variables))


(definition protected current-advise
  #f)


(definition public (setup-profiling)
  (set-site-callback
    (lambda (site)
      (when current-advise
        (current-advise site)))))


;;;
;;;; Profile
;;;


(class Profile-Site extends Object
  
  
  (slot parent         initialize #f                     getter generate)
  (slot children       initialize (make-table test: eq?) getter generate)
  (slot start          initialize #f                     accessors generate)
  (slot running   <fl> initialize 0.                     accessors generate)
  (slot allocated <fl> initialize 0.                     accessors generate)
  (slot called    <fx> initialize 0                      accessors generate)
  
  
  (method override (initialize self parent)
    (nextmethod self)
    (set! self.parent parent)))


(definition protected (profile-sites chronology)
  (with-mutex chronology
    (lambda ()
      (let ((first (first-position chronology))
            (last (last-position chronology))
            (threads (make-table test: eqv?)))
        (loop (for n from first to last)
              (let ((id (flonum->fixnum (chronological-id chronology n)))
                    (marker (chronological-marker chronology n))
                    (thread (chronological-thread chronology n)))
                (let ((current (or (table-ref threads thread #f)
                                   (let ((p (new Profile-Site #f)))
                                     (table-set! threads thread p)
                                     p)))
                      (start? (even? (flonum->fixnum marker))))
                  (cond (start?
                         (let ((profile (or (table-ref (get-children current) id #f)
                                            (let ((p (new Profile-Site current)))
                                              (table-set! (get-children current) id p)
                                              p))))
                           (set-start profile n)
                           (table-set! threads thread profile)))
                        (else
                         (let ((profile current))
                           (let ((start (get-start profile)))
                             ;; TRUNC
                             (when start
                             (let ((start-time (chronological-time chronology start))
                                   (start-memory (chronological-memory chronology start)))
                               (let ((running (- (chronological-time chronology n) start-time))
                                     (allocated (- (chronological-memory chronology n) start-memory)))
                                 (set-running profile (+ (get-running profile) running))
                                 (set-allocated profile (+ (get-allocated profile) allocated))
                                 (set-called profile (+ (get-called profile) 1))
                                 (set-start profile #f)))
                           (table-set! threads thread (get-parent profile))))))))))
        (values threads (- (chronological-time chronology last)
                           (chronological-time chronology first)))))))


;;;
;;;; Site
;;;


(definition public (iterate-sites proc)
  (iterate-table-safe (registered-sites)
    (lambda (identifier site)
      (proc (symbol->enumerator identifier)))))


(definition public (advise-sites)
  (iterate-sites advise-site)
  (set! current-advise (lambda (site <Call-Site>)
                         (let ((identifier (get-identifier site)))
                           (let ((what (symbol->enumerator identifier)))
                             (advise-site what))))))

(definition public (unadvise-sites)
  (iterate-sites unadvise)
  (set! current-advise #f))


(definition public (advise-site what)
  (let ((identifier (enumerator->symbol what)))
    (advise what
            (lambda (field locator original set)
              (let ((original (original)))
                (when (procedure? original)
                  (set (lambda (site thunk)
                         ;; pass original and thunk as parameters instead of
                         ;; using a closure that would allocate some memory
                         (with-site identifier site original thunk)))))))))


(definition public (with-site identifier site <Call-Site> procedure thunk)
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  (let ((chronology (current-chronology)))
    (let ((content (get-content chronology))
          (mutex (get-mutex chronology))
          (id <fx> (get-id site))
          (thread (fixnum->flonum (object->serial (current-thread)))))
      (mutex-lock! mutex)
      (let ((marker (next-marker! chronology)))
        (let ((index (index-now chronology)))
          (f64vector-set! content index (cast <fl> id))
          (f64vector-set! content (+ index 1) (cast <fl> marker))
          (current-seconds! content (+ index 2))
          (bytes-allocated! content (+ index 3))
          (f64vector-set! content (+ index 4) thread)
          (advance! chronology))
        (mutex-unlock! mutex)
        (prog1 (case (get-monitor site)
                 ((performance)
                  (with-profile identifier thunk))
                 ((memory)
                  (with-tracking identifier thunk))
                 (else
                  (procedure site thunk)))
          (mutex-lock! mutex)
          (let ((index (index-now chronology)))
            (f64vector-set! content index (cast <fl> id))
            (f64vector-set! content (+ index 1) (cast <fl> (+ marker 1)))
            (current-seconds! content (+ index 2))
            (bytes-allocated! content (+ index 3))
            (f64vector-set! content (+ index 4) thread)
            (advance! chronology))
          (mutex-unlock! mutex))))))


(definition public (sites-metadata)
  (let ((queue (new-queue)))
    (iterate-table (registered-sites)
      (lambda (name site)
        (enqueue queue (cons (get-id site) name))))
    (queue-list queue))))
