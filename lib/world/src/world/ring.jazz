;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Ring
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.ring jazz


(import (jazz.geometry))


(proclaim (not check bounds zero)
          (warn optimizations))


;;  take +----+----+----+----+----+ give
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL


(class Ring extends Object
  
  
  (slot size         <fx>     getter generate)
  (slot max-size     <fx>     getter generate)
  (slot content      <vector> getter generate)
  (slot mutex        <object> getter generate)
  (slot take-condvar <object> getter generate)
  (slot head         <fx>     getter generate)
  (slot tail         <fx>     getter generate)
  (slot count        <fx>     getter generate)
  
  
  (method override (initialize self size <fx> (max-size: max-size #f))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.content (make-vector size))
    (set! self.mutex (make-mutex 'ring))
    (set! self.take-condvar (make-condition-variable 'take))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0))
  
  
  (method public (give self obj)
    (mutex-lock! mutex)
    (cond ((< count size)
           (vector-set! content tail obj)
           (set! tail (modulo (+ tail 1) size))
           (increase! count))
          ((= size max-size)
           (vector-set! content tail obj)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail))
          (else
           (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
             (let ((new-content (make-vector new-size))
                   (growth (- new-size size)))
               (subvector-move! content 0 tail new-content 0)
               (subvector-move! content tail size new-content (+ tail growth))
               (set! size new-size)
               (set! content new-content)
               (vector-set! content tail obj)
               (set! tail (modulo (+ tail 1) size))
               (set! head (modulo (+ head growth) size))
               (increase! count)))))
    (condition-variable-signal! take-condvar)
    (mutex-unlock! mutex))
  
  
  (method public (take self)
    (define (get)
      (prog1 (vector-ref content head)
        (set! head (modulo (+ head 1) size))
        (decrease! count)))
    
    (mutex-lock! mutex)
    (prog1 (if (> count 0)
               (get)
             (mutex-unlock! mutex take-condvar)
             (mutex-lock! mutex)
             (assert (> count 0)
               (get)))
      (mutex-unlock! mutex))))


;;;
;;;; Time Ring
;;;


;;               ---> time
;;  wait +----+----+----+----+----+ insert
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL
;;   (earliest)                (latest)


;; to convert to a full ring at a later stage


(class Time-Ring extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot times        <f64vector> getter generate)
  (slot content      <vector>    getter generate)
  (slot mutex        <object>    getter generate)
  (slot wait-condvar <object>    getter generate)
  (slot head         <fx>        getter generate)
  (slot tail         <fx>        getter generate)
  (slot count        <fx>        getter generate)
  (slot now-proc                 getter generate)
  
  
  (method override (initialize self size <fx> (now-proc: now-proc current-seconds))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.times (make-f64vector size))
    (set! self.content (make-vector size))
    (set! self.mutex (make-mutex 'ring))
    (set! self.wait-condvar (make-condition-variable 'wait))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.now-proc now-proc))
  
  
  (method public (insert self time obj)
    (define (insert-at n)
      (cond ((< count size)
             (if (= n count)
                 (begin
                   (f64vector-set! times n time)
                   (vector-set! content n obj))
               (subf64vector-shift! times n count 1)
               (f64vector-set! times n time)
               (subvector-shift! content n count 1)
               (vector-set! content n obj)))
            (else
             (let ((new-size (fxround (* size GOLDEN_GROWTH))))
               (let ((new-times (make-f64vector new-size))
                     (new-content (make-vector new-size))
                     (growth (- new-size size)))
                 (subvector-move! times 0 tail new-times 0)
                 (subvector-move! times tail size new-times (+ tail growth))
                 (subvector-move! content 0 tail new-content 0)
                 (subvector-move! content tail size new-content (+ tail growth))
                 (set! size new-size)
                 (set! times new-times)
                 (set! content new-content)
                 (vector-set! times tail time)
                 (vector-set! content tail obj)
                 (set! tail (modulo (+ tail 1) size))
                 (set! head (modulo (+ head growth) size))
                 (increase! count)))))
      (increase! count)
      #t)
    
    (mutex-lock! mutex)
    (prog1 (let ((now (now-proc)))
             (if (>= time now)
                 (let (loop (scan count))
                   (if (= scan 0)
                       (begin
                         (insert-at scan)
                         (condition-variable-signal! wait-condvar))
                     (let ((candidate (f64vector-ref times (- scan 1))))
                       (if (<= candidate time)
                           (insert-at scan)
                         (loop (- scan 1))))))
               #f))
      (mutex-unlock! mutex)))
  
  
  (method public (locate self predicate)
    (mutex-lock! mutex)
    (prog1 (let (loop (pos 0))
             (if (>= pos count)
                 #f
               (let ((obj (vector-ref content pos)))
                 (if (predicate obj)
                     obj
                   (loop (+ pos 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (wait self)
    (declare (proper-tail-calls))
    (let (loop)
      (mutex-lock! mutex)
      (if (= count 0)
          (begin
            (mutex-unlock! mutex wait-condvar)
            (loop))
        (let ((now (now-proc))
              (earliest-time (f64vector-ref times 0))
              (earliest (vector-ref content 0)))
          (let ((wait-duration (- earliest-time now)))
            (if (<= wait-duration 0)
                (prog1 earliest
                  (subf64vector-shift! times 1 count -1)
                  (subf64vector-fill! times (- count 1) count 0.)
                  (subvector-shift! content 1 count -1)
                  (subvector-fill! content (- count 1) count #f)
                  (decrease! count)
                  (mutex-unlock! mutex))
              (mutex-unlock! mutex wait-condvar wait-duration)
              (loop)))))))
  
  
  (method public (wait-all self)
    (declare (proper-tail-calls))
    (let (loop)
      (mutex-lock! mutex)
      (if (= count 0)
          (begin
            (mutex-unlock! mutex wait-condvar)
            (loop))
        (let ((now (now-proc))
              (earliest-time (f64vector-ref times 0))
              (earliest (vector-ref content 0)))
          (let ((wait-duration (- earliest-time now)))
            (if (<= wait-duration 0)
                (let (collect (pos 1) (card 1) (result (list earliest)))
                  (let ((next (and (< pos count)
                                   (let ((next-time (f64vector-ref times pos))
                                         (next (vector-ref content pos)))
                                     (let ((wait-duration (- next-time now)))
                                       (and (<= wait-duration 0)
                                            next))))))
                    (if next
                        (collect (+ pos 1) (+ card 1) (cons next result))
                      (prog1 result
                        (subf64vector-shift! times card count (- card))
                        (subf64vector-fill! times (- count card) count 0.)
                        (subvector-shift! content card count (- card))
                        (subvector-fill! content (- count card) count #f)
                        (decrease! count card)
                        (mutex-unlock! mutex)))))
              (mutex-unlock! mutex wait-condvar wait-duration)
              (loop)))))))))
