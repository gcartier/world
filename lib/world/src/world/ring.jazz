;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Ring
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.ring jazz


(import (jazz.geometry)
        (world.settings))


(proclaim (not check bounds zero)
          (warn optimizations))


;;  take +----+----+----+----+----+ give
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL


(class Ring extends Object
  
  
  (slot size         <fx>     getter generate)
  (slot max-size     <fx>     getter generate)
  (slot content      <vector> getter generate)
  (slot mutex        <object> getter generate)
  (slot take-condvar <object> getter generate)
  (slot head         <fx>     getter generate)
  (slot tail         <fx>     getter generate)
  (slot count        <fx>     getter generate)
  
  
  (method override (initialize self size <fx> (max-size: max-size #f))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.content (make-vector size))
    (set! self.mutex (make-mutex 'ring))
    (set! self.take-condvar (make-condition-variable 'take))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0))
  
  
  (method public (give self obj)
    (mutex-lock! mutex)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-content (make-vector new-size))
              (growth (- new-size size)))
          (subvector-move! content 0 tail new-content 0)
          (subvector-move! content tail size new-content (+ tail growth))
          (set! size new-size)
          (set! content new-content)
          (set! head (modulo (+ head growth) size)))))
    ;; insert
    (cond ((< count size)
           (vector-set! content tail obj)
           (set! tail (modulo (+ tail 1) size))
           (increase! count))
          (else
           (vector-set! content tail obj)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail)))
    (condition-variable-signal! take-condvar)
    (mutex-unlock! mutex))
  
  
  (method public (take self)
    (define (get)
      (prog1 (vector-ref content head)
        (set! head (modulo (+ head 1) size))
        (decrease! count)))
    
    (mutex-lock! mutex)
    (prog1 (if (> count 0)
               (get)
             (mutex-unlock! mutex take-condvar)
             (mutex-lock! mutex)
             (get))
      (mutex-unlock! mutex))))


;;;
;;;; Time Ring
;;;


;;               ---> time
;;  wait +----+----+----+----+----+ insert
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL
;;   (earliest)                (latest)


(class Time-Ring extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot max-size     <fx>        getter generate)
  (slot times        <f64vector> getter generate)
  (slot content      <vector>    getter generate)
  (slot mutex        <object>    getter generate)
  (slot wait-condvar <object>    getter generate)
  (slot head         <fx>        getter generate)
  (slot tail         <fx>        getter generate)
  (slot count        <fx>        getter generate)
  (slot terminate?               getter generate)
  (slot invalid-proc             getter generate)
  (slot overflow-proc            getter generate)
  
  
  (method override (initialize self size <fx> (max-size: max-size #f) (invalid-proc: invalid-proc #f) (overflow-proc: overflow-proc #f))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.times (make-f64vector size +nan.0))
    (set! self.content (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.wait-condvar (make-condition-variable 'wait))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.terminate? #f)
    (set! self.invalid-proc invalid-proc)
    (set! self.overflow-proc overflow-proc))
  
  
  (method public (terminate self)
    (mutex-lock! mutex)
    (set! terminate? #t)
    (condition-variable-signal! wait-condvar)
    (mutex-unlock! mutex))
  
  
  (method public (empty self)
    (f64vector-fill! self.times +nan.0)
    (vector-fill! self.content #f)
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0))
  
  
  (method public (insert self time obj)
    (declare (proper-tail-calls))
    (mutex-lock! mutex)
    (prog1 (let (loop (n count))
             (if (= n 0)
                 (begin
                   (insert-before self head time obj)
                   (condition-variable-signal! wait-condvar)
                   #f)
               (let ((before (modulo (- (+ head n) 1) size)))
                 (let ((before-time (f64vector-ref times before)))
                   (if (> time before-time)
                       (let ((pos (modulo (+ head n) size)))
                         (insert-before self pos time obj)
                         #f)
                     (loop (- n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (insert-before self pos time obj)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-times (make-f64vector new-size +nan.0))
              (new-content (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subf64vector-move! times 0 tail new-times 0)
          (subf64vector-move! times tail size new-times head)
          (subvector-move! content 0 tail new-content 0)
          (subvector-move! content tail size new-content head)
          (set! size new-size)
          (set! times new-times)
          (set! content new-content))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (f64vector-set! times head time)
                  (vector-set! content head obj)
                  (increase! count))
                 ((= pos tail)
                  (f64vector-set! times tail time)
                  (vector-set! content tail obj)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subf64vector-shift! times head pos -1)
                        (subvector-shift! content head pos -1)
                        (f64vector-set! times (- pos 1) time)
                        (vector-set! content (- pos 1) obj)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subf64vector-shift! times pos tail 1)
                    (subvector-shift! content pos tail 1)
                    (f64vector-set! times pos time)
                    (vector-set! content pos obj)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (if overflow-proc
               (overflow-proc self obj)
             (let ((obj (vector-ref content tail)))
               (f64vector-set! times tail time)
               (vector-set! content tail obj)
               (set! tail (modulo (+ tail 1) size))
               (set! head tail))))))
  
  
  (method public (wait self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          #f
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((now (current-seconds))
                (earliest-time (f64vector-ref times head))
                (earliest (vector-ref content head)))
            (let ((earliest-duration (- earliest-time now)))
              (if (<= earliest-duration 0.)
                  (prog1 earliest
                    (f64vector-set! times head +nan.0)
                    (vector-set! content head #f)
                    (set! head (modulo (+ head 1) size))
                    (decrease! count)
                    (mutex-unlock! mutex))
                (mutex-unlock! mutex wait-condvar earliest-duration)
                (loop-wait))))))))
  
  
  (method public (wait-all self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          (values 'terminate #f)
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((now (current-seconds)))
            (let ((earliest-time (f64vector-ref times head)))
              (let ((earliest-duration (- earliest-time now)))
                (if (<= earliest-duration 0.)
                    (let ((avail (let (scan (n 1))
                                   (if (>= n count)
                                       n
                                     (let ((time (f64vector-ref times (modulo (+ head n) size))))
                                       (let ((duration (- time now)))
                                         (if (<= duration 0.)
                                             (scan (+ n 1))
                                           n)))))))
                      (prog1 (loop (for n from 0 below avail)
                                   (collect
                                     (let ((pos (modulo (+ head n) size)))
                                       (let ((obj (vector-ref content pos)))
                                         (f64vector-set! times pos +nan.0)
                                         (vector-set! content pos #f)
                                         obj))))
                        (set! head (modulo (+ head avail) size))
                        (decrease! count avail)
                        (mutex-unlock! mutex)))
                  (mutex-unlock! mutex wait-condvar earliest-duration)
                  (loop-wait)))))))))
  
  
  (method public (locate-earliest self predicate)
    (mutex-lock! mutex)
    (prog1 (let (loop (n 0))
             (if (>= n count)
                 #f
               (let ((pos (modulo (+ head n) size)))
                 (let ((obj (vector-ref content pos)))
                   (if (predicate obj)
                       obj
                     (loop (+ n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-latest self predicate)
    (mutex-lock! mutex)
    (prog1 (let (loop (n (- count 1)))
             (if (< n 0)
                 #f
               (let ((pos (modulo (+ head n) size)))
                 (let ((obj (vector-ref content pos)))
                   (if (predicate obj)
                       obj
                     (loop (- n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-earliest self proc)
    (mutex-lock! mutex)
    (prog1 (let (loop (n 0))
             (when (< n count)
               (let ((pos (modulo (+ head n) size)))
                 (let ((time (f64vector-ref times pos))
                       (obj (vector-ref content pos)))
                   (proc time obj)
                   (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-latest self proc)
    (mutex-lock! mutex)
    (prog1 (let (loop (n (- count 1)))
             (when (>= n 0)
               (let ((pos (modulo (+ head n) size)))
                 (let ((time (f64vector-ref times pos))
                       (obj (vector-ref content pos)))
                   (proc time obj)
                   (loop (- n 1))))))
      (mutex-unlock! mutex)))))
