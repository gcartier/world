;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Ring
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.ring jazz


(import (jazz.geometry)
        (world.settings))


(proclaim (not check bounds zero)
          (warn optimizations))


;;  take +----+----+----+----+----+ give
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL


(class Ring extends Object
  
  
  (slot size         <fx>     getter generate)
  (slot max-size     <fx>     getter generate)
  (slot content      <vector> getter generate)
  (slot mutex        <object> getter generate)
  (slot take-condvar <object> getter generate)
  (slot head         <fx>     getter generate)
  (slot tail         <fx>     getter generate)
  (slot count        <fx>     getter generate)
  
  
  (method override (initialize self size <fx> (max-size: max-size #f))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.content (make-vector size))
    (set! self.mutex (make-mutex 'ring))
    (set! self.take-condvar (make-condition-variable 'take))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0))
  
  
  (method public (give self obj)
    (mutex-lock! mutex)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-content (make-vector new-size))
              (growth (- new-size size)))
          (subvector-move! content 0 tail new-content 0)
          (subvector-move! content tail size new-content (+ tail growth))
          (set! size new-size)
          (set! content new-content)
          (set! head (modulo (+ head growth) size)))))
    ;; insert
    (cond ((< count size)
           (vector-set! content tail obj)
           (set! tail (modulo (+ tail 1) size))
           (increase! count))
          (else
           (vector-set! content tail obj)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail)))
    (condition-variable-signal! take-condvar)
    (mutex-unlock! mutex))
  
  
  (method public (take self)
    (define (get)
      (prog1 (vector-ref content head)
        (set! head (modulo (+ head 1) size))
        (decrease! count)))
    
    (mutex-lock! mutex)
    (prog1 (if (> count 0)
               (get)
             (mutex-unlock! mutex take-condvar)
             (mutex-lock! mutex)
             (get))
      (mutex-unlock! mutex))))


;;;
;;;; Time Ring
;;;


;;               ---> time
;;  wait +----+----+----+----+----+ insert
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL
;;   (earliest)                (latest)


(class Time-Ring extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot max-size     <fx>        getter generate)
  (slot times        <f64vector> getter generate)
  (slot content      <vector>    getter generate)
  (slot mutex        <object>    getter generate)
  (slot wait-condvar <object>    getter generate)
  (slot head         <fx>        getter generate)
  (slot tail         <fx>        getter generate)
  (slot count        <fx>        getter generate)
  (slot key-proc                 getter generate)
  (slot overflow-proc            getter generate)
  
  
  (method override (initialize self size <fx> (max-size: max-size #f) (key-proc: key-proc #f) (overflow-proc: overflow-proc #f))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.times (make-f64vector size +nan.0))
    (set! self.content (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.wait-condvar (make-condition-variable 'wait))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.key-proc key-proc)
    (set! self.overflow-proc overflow-proc))
  
  
  (method public (empty self)
    (f64vector-fill! self.times +nan.0)
    (vector-fill! self.content #f)
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0))
  
  
  (method public (insert self time obj)
    (mutex-lock! mutex)
    (prog1 (if (not key-proc)
               (insert-time self time obj)
             (insert-key self time obj key-proc))
      (mutex-unlock! mutex)))
  
  
  (method public (insert-time self time obj)
    (declare (proper-tail-calls))
    (let ((now (current-seconds)))
      (if (< time now)
          'discard
        (let (loop (n count))
          (if (= n 0)
              (begin
                (insert-before self head time obj)
                (condition-variable-signal! wait-condvar))
            (let ((before (modulo (- (+ head n) 1) size)))
              (let ((before-time (f64vector-ref times before)))
                (if (> time before-time)
                    (let ((pos (modulo (+ head n) size)))
                      (insert-before self pos time obj))
                  (loop (- n 1)))))))
        #f)))
  
  
  (method public (insert-key self time obj key-proc)
    (declare (proper-tail-calls))
    (let ((now (current-seconds)))
      (if (< time now)
          'discard
        (let ((key (key-proc obj)))
          ;; validate that key preserves time
          (define (invalid-time n)
            (if (= count 0)
                #f
              (or ;; before
                  (and (> n 0)
                       (let ((before (modulo (- (+ head n) 1) size)))
                         (let ((before-time (f64vector-ref times before)))
                           (and (< time before-time)
                                (let ((before-key (key-proc (vector-ref content before))))
                                  (world.udp:record-event world.udp:udp-id-debug1
                                                          -1.
                                                          -1.
                                                          (fixnum->flonum key)
                                                          (fixnum->flonum before-key)
                                                          time
                                                          before-time)
                                  (when (developer?)
                                    (terminal 'TIME 'SMALLER key before-key (- time before-time)))
                                  'invalid)))))
                  ;; after
                  (and (< n count)
                       (let ((after (modulo (+ head n) size)))
                         (let ((after-time (f64vector-ref times after)))
                           (and (> time after-time)
                                (let ((after-key (key-proc (vector-ref content after))))
                                  (world.udp:record-event world.udp:udp-id-debug2
                                                          -1.
                                                          -1.
                                                          (fixnum->flonum key)
                                                          (fixnum->flonum after-key)
                                                          time
                                                          after-time)
                                  (when (developer?)
                                    (terminal 'TIME 'GREATER key after-key (- time after-time)))
                                  'invalid))))))))
          
          (let (loop (n count))
            (if (= n 0)
                (or (invalid-time n)
                    (begin
                      (insert-before self head time obj)
                      (condition-variable-signal! wait-condvar)
                      #f))
              (let ((before (modulo (- (+ head n) 1) size)))
                (let ((before-key (key-proc (vector-ref content before))))
                  (if (> key before-key)
                      (or (invalid-time n)
                          (begin
                            (let ((pos (modulo (+ head n) size)))
                              (insert-before self pos time obj))
                            #f))
                    (if (= key before-key)
                        'duplicate
                      (loop (- n 1))))))))))))
  
  
  (method public (insert-earliest self obj)
    (mutex-lock! mutex)
    (insert-before self head (current-seconds) obj)
    (condition-variable-signal! wait-condvar)
    (mutex-unlock! mutex))
  
  
  (method public (insert-before self pos time obj)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-times (make-f64vector new-size +nan.0))
              (new-content (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subf64vector-move! times 0 tail new-times 0)
          (subf64vector-move! times tail size new-times head)
          (subvector-move! content 0 tail new-content 0)
          (subvector-move! content tail size new-content head)
          (set! size new-size)
          (set! times new-times)
          (set! content new-content))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (f64vector-set! times head time)
                  (vector-set! content head obj)
                  (increase! count))
                 ((= pos tail)
                  (f64vector-set! times tail time)
                  (vector-set! content tail obj)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subf64vector-shift! times head pos -1)
                        (subvector-shift! content head pos -1)
                        (f64vector-set! times (- pos 1) time)
                        (vector-set! content (- pos 1) obj)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subf64vector-shift! times pos tail 1)
                    (subvector-shift! content pos tail 1)
                    (f64vector-set! times pos time)
                    (vector-set! content pos obj)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (if overflow-proc
               (overflow-proc self obj)
             (let ((obj (vector-ref content tail)))
               (f64vector-set! times tail time)
               (vector-set! content tail obj)
               (set! tail (modulo (+ tail 1) size))
               (set! head tail))))))
  
  
  (method public (wait self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (mutex-lock! mutex)
      (if (= count 0)
          (begin
            (mutex-unlock! mutex wait-condvar)
            (loop-wait))
        (let ((now (current-seconds))
              (earliest-time (f64vector-ref times head))
              (earliest (vector-ref content head)))
          (let ((earliest-duration (- earliest-time now)))
            (if (<= earliest-duration 0.)
                (prog1 earliest
                  (f64vector-set! times head +nan.0)
                  (vector-set! content head #f)
                  (set! head (modulo (+ head 1) size))
                  (decrease! count)
                  (mutex-unlock! mutex))
              (mutex-unlock! mutex wait-condvar earliest-duration)
              (loop-wait)))))))
  
  
  (method public (wait-all self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (mutex-lock! mutex)
      (if (= count 0)
          (begin
            (mutex-unlock! mutex wait-condvar)
            (loop-wait))
        (let ((now (current-seconds)))
          (let ((earliest-time (f64vector-ref times head)))
            (let ((earliest-duration (- earliest-time now)))
              (if (<= earliest-duration 0.)
                  (let ((avail (let (scan (n 1))
                                 (if (>= n count)
                                     n
                                   (let ((time (f64vector-ref times (modulo (+ head n) size))))
                                     (let ((duration (- time now)))
                                       (if (<= duration 0.)
                                           (scan (+ n 1))
                                         n)))))))
                    (prog1 (loop (for n from 0 below avail)
                                 (collect
                                   (let ((pos (modulo (+ head n) size)))
                                     (let ((obj (vector-ref content pos)))
                                       (f64vector-set! times pos +nan.0)
                                       (vector-set! content pos #f)
                                       obj))))
                      (set! head (modulo (+ head avail) size))
                      (decrease! count avail)
                      (mutex-unlock! mutex)))
                (mutex-unlock! mutex wait-condvar earliest-duration)
                (loop-wait))))))))
  
  
  (method public (locate self predicate)
    (mutex-lock! mutex)
    (prog1 (let (loop (n 0))
             (if (>= n count)
                 #f
               (let ((pos (modulo (+ head n) size)))
                 (let ((obj (vector-ref content pos)))
                   (if (predicate obj)
                       obj
                     (loop (+ n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-content self proc)
    (mutex-lock! mutex)
    (prog1 (let (loop (n 0))
             (when (< n count)
               (let ((pos (modulo (+ head n) size)))
                 (let ((time (f64vector-ref times pos))
                       (obj (vector-ref content pos)))
                   (proc time obj)
                   (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (updating self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (condition-variable-signal! wait-condvar)
      (mutex-unlock! mutex)))
  
  
  (method public (update self proc)
    (let (loop (n 0))
      (if (>= n count)
          #f
        (let ((pos (modulo (+ head n) size)))
          (let ((time (f64vector-ref times pos))
                (obj (vector-ref content pos)))
            (proc
              time
              obj
              (lambda (new-time new-obj)
                (f64vector-set! times pos new-time)
                (vector-set! content pos new-obj)))
            (loop (+ n 1)))))))))
