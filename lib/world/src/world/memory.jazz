;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Memory
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.memory jazz


@permanent-memory (


(import (gambit.walk)
        (jazz.debuggee)
        (jazz.io)
        (jazz.platform)
        (world)
        (world.autoload)
        (world.syntax (phase syntax)))


;;;
;;;; Setup
;;;


(definition public (setup-memory (feedback?: feedback? #f))
  (define (catalog-prune? obj)
    (or (permanent? obj)
        (kind? obj)
        (category? obj)
        (is? obj Dialect)))
  
  (set-outline-hook
    (lambda (unit-name declaration)
      (terminal unit-name)
      (let ((kind PERM)
            (domain (make-domain)))
        (copy-to declaration kind domain
          copy?: (lambda (obj)
                   (not (catalog-prune? obj))))))))


@old
(definition public (setup-memory (feedback?: feedback? #f))
  (declare (optimize-dead-local-variables))
  (let ((kind PERM)
        (domain (make-domain)))
    (define (prune? obj)
      (or (kind? obj)
          (class? obj)
          (table? obj)))
    
    (copy-to (outline-unit 'jazz.graphic.Color) kind domain
      copy?: (lambda (obj)
               (not (prune? obj))))
    (walk-object!
      (lambda (container i obj)
        (if (prune? obj)
            walk-prune
          walk-continue))
      (lambda (container i obj)
        (or (register-ref (domain-copies domain) obj #f)
            obj))
      feedback?: feedback?)
    (when feedback?
      (terminal 'bytes-copied= (domain-bytes-copied domain)))))


;;;
;;;; Monitored
;;;


(class Monitored extends Object
  
  
  (slot content accessors generate)
  
  
  (method override (initialize content)
    (set! content~self content)))


(definition inline (monitored? obj)
  (eq? (class-of obj) Monitored))


(definition inline (make-monitored content)
  (new Monitored content))


(definition inline (monitored-content monitored)
  (get-content~ monitored))

(definition inline (monitored-content-set! monitored content)
  (set-content~ monitored content))


;;;
;;;; Region
;;;


(class Region-Snapshot extends Object
  
  
  (slot name     getter generate)
  (slot object   getter generate)
  (slot roots    getter generate)
  (slot prune?   getter generate)
  (slot content  getter generate)
  (slot outgoing getter generate)
  (slot incoming initialize #f accessors generate)
  (slot mutated  initialize #f accessors generate)
  (slot removed  initialize #f accessors generate)
  (slot added    initialize #f accessors generate)
  
  
  (method override (initialize name object roots prune? content outgoing)
    (set! name~self name)
    (set! object~self object)
    (set! roots~self roots)
    (set! prune?~self prune?)
    (set! content~self content)
    (set! outgoing~self outgoing))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition snapshots
  '())

(definition public (get-snapshots)
  snapshots)


(definition permanent
  (make-monitored (new-register)))

(definition public (get-permanent)
  (monitored-content permanent))

(definition public (copied-permanent? obj)
  (register-ref (monitored-content permanent) obj #f))


(definition test-object
  (list (vector 1 2 (list 'a 'b))))


(definition public (permanent? obj)
  (and (mem-allocated? obj)
       (eq? (mem-allocated-kind obj) 'PERM)))
  

(definition snapshot-targets
  '(@w unit outline @w modules @w catalog @w test))


(definition public (setup-memory-debug)
  (define (snap-when name prune? obj)
    (when (memq? name snapshot-targets)
      (format :terminal "snapshot {a} " name)
      (receive (roots content outgoing) (snapshot-object obj prune?: prune?)
        (format :terminal "done{%}")
        (new Region-Snapshot name obj roots prune? content outgoing))))
  
  (define (modules-prune? obj)
    (or (permanent? obj)
        (copied-permanent? obj)
        (kind? obj)
        (category? obj)))
  
  (define (catalog-prune? obj)
    (or (permanent? obj)
        (copied-permanent? obj)
        (kind? obj)
        (category? obj)
        (is? obj Dialect)))
  
  (define (test-prune? obj)
    (or (permanent? obj)
        (copied-permanent? obj)))
  
  (let ((unit (snap-when 'unit modules-prune? (require-module 'world.test.x)))
        (outline (snap-when 'outline catalog-prune? (outline-unit 'world.test.x)))
        (modules (snap-when 'modules modules-prune? (get-modules)))
        (catalog (snap-when 'catalog catalog-prune? (get-catalog)))
        (test (snap-when 'test test-prune? (car test-object))))
    (set! snapshots (remove-false (list unit
                                        outline
                                        modules
                                        catalog
                                        test))))
  (set-%s snapshots)
  (set-%p permanent)
  (for-each (lambda (snapshot)
              (let ((content (get-content~ snapshot))
                    (outgoing (get-outgoing~ snapshot)))
                (set-%c content)
                (set-%o outgoing)))
            snapshots))


(definition public (setup-memory-compare (present: present #f))
  (for-each (lambda (snapshot)
              (let ((name (get-name~ snapshot))
                    (object (get-object~ snapshot))
                    (roots (get-roots~ snapshot))
                    (prune? (get-prune?~ snapshot))
                    (content (get-content~ snapshot))
                    (outgoing (get-outgoing~ snapshot)))
                (receive (roots mutated outgoing) (snapshot-object object roots: roots prune?: prune?)
                  (newline)
                  (debug name)
                  (set-mutated~ snapshot mutated)
                  (receive (removed added) (compare-snapshots content mutated present: present max: 16)
                    (set-removed~ snapshot removed)
                    (set-added~ snapshot added)
                    (set-%m mutated)
                    (set-%r removed)
                    (set-%a added)))))
            snapshots))


(definition public (setup-memory-test)
  (loop (repeat 100)
        (ir %i)))


;;;
;;;; Snapshot
;;;


(definition public (snapshot-object obj (roots: roots #f) (prune?: prune? #f) (feedback?: feedback? #t))
  (cond ((table? obj)
         (snapshot-table obj roots: roots prune?: prune? feedback?: feedback?))
        ((is? obj Module)
         (snapshot-module obj roots: roots prune?: prune? feedback?: feedback?))
        (else
         (snapshot-value obj roots: roots prune?: prune? feedback?: feedback?))))


(definition (snapshot-table table (roots: roots #f) (prune?: prune? #f) (feedback?: feedback? #t))
  (let ((seen (new-register))
        (content (new-register))
        (outgoing (new-register))
        (roots (or roots (table-keys table))))
    (for-each (lambda (root)
                (let ((value (table-ref table root)))
                  (snapshot-to! value seen content outgoing root prune?: prune? feedback?: feedback?)))
              roots)
    (values roots content outgoing)))


(definition (snapshot-module module (roots: roots #f) (prune?: prune? #f) (feedback?: feedback? #t))
  (let ((seen (new-register))
        (content (new-register))
        (outgoing (new-register)))
    ;; we need to traverse entries first else they will already have
    ;; been pruned and added to the seen register by the module traversal
    (for-each (lambda (value)
                (snapshot-to! value seen content outgoing #f prune?: prune? feedback?: feedback?))
              (table-values (get-entries~ module)))
    (snapshot-to! module seen content outgoing #f prune?: prune? feedback?: feedback?)
    (values #f content outgoing)))


(definition (snapshot-value value (roots: roots #f) (prune?: prune? #f) (feedback?: feedback? #t))
  (let ((seen (new-register))
        (content (new-register))
        (outgoing (new-register)))
    (snapshot-to! value seen content outgoing #f prune?: prune? feedback?: feedback?)
    (values #f content outgoing)))


(definition public (snapshot-to! root seen content outgoing data (prune?: prune? #f) (feedback?: feedback? #t))
  (walk-object!
    (lambda (container i obj)
      (containment-sanity container obj)
      (cond ((or (not (mem-allocated? obj))
                 (eq? (mem-allocated-kind obj) 'PERM))
             walk-prune)
            ((and prune? (prune? obj) (neq? obj root))
             (unless (register-ref outgoing obj #f)
               (register-set! outgoing obj (make-monitored (vector container i data))))
             walk-prune)
            (else
             (unless (register-ref content obj #f)
               (let ((index (container-index container i)))
                 (let ((info (make-monitored (vector container index data))))
                   (register-set! content obj info))))
             (unless (register-ref (monitored-content permanent) obj #f)
               (register-set! (monitored-content permanent) obj #t))
             walk-continue)))
    (lambda (container i obj)
      obj)
    root: root
    seen: seen
    feedback?: feedback?))


(definition (container-index container i)
  (if (object? container)
      (if (= i 0)
          'class
        (get-name~ (list-ref (get-instance-slots~ (class-of container)) (- i 1))))
    i))


(definition (containment-sanity container obj)
  (when (and (gc-hash-table? obj)
             (not (table? container)))
    (break)))


;;;
;;;; Heap
;;;


(class Heap-Snapshot extends Object
  
  
  (slot objects    getter generate)
  (slot containers getter generate)
  
  
  (method override (initialize objects containers)
    (set! objects~self objects)
    (set! containers~self containers)))


(definition heap-snapshot
  #f)


(definition public (snapshot-heap (feedback?: feedback? #t))
  (format :terminal "snapshot heap ")
  (let ((objects (new-register))
        (containers (new-register)))
    (walk-object!
      (lambda (container i obj)
        (if (or (monitored? container)
                (not (mem-allocated? obj))
                (eq? (mem-allocated-kind obj) 'PERM))
            walk-prune
          walk-continue))
      (lambda (container i obj)
        (containment-sanity container obj)
        (when (mem-allocated? obj)
          (unless (eq? (mem-allocated-kind obj) 'PERM)
            (unless (monitored? container)
              (let ((index (container-index container i)))
                (let ((info (cons container index))
                      (monitored (register-ref objects obj #f)))
                  (if (not monitored)
                      (register-set! objects obj (make-monitored (list info)))
                    (monitored-content-set! monitored (cons info (monitored-content monitored)))))
                (let ((info (cons obj index))
                      (monitored (register-ref containers container #f)))
                  (if (not monitored)
                      (register-set! containers container (make-monitored (list info)))
                    (monitored-content-set! monitored (cons info (monitored-content monitored)))))))))
        obj)
      feedback?: feedback?)
    (format :terminal "done{%}")
    (set! heap-snapshot (make-monitored (new Heap-Snapshot objects containers)))
    (debug heap-snapshot)
    (set-%h heap-snapshot)))


;;;
;;;; Incoming
;;;


(definition protected outline-snapshots
  (make-monitored (make-table test: eq?)))


(definition public (setup-outline-hook unit-name)
  (define (catalog-prune? obj)
    (or (permanent? obj)
        (copied-permanent? obj)
        (kind? obj)
        (category? obj)
        (is? obj Dialect)))
  
  (set-outline-hook
    (lambda (unit-name declaration)
      (format :terminal "{a} " unit-name)
      (receive (roots content outgoing) (snapshot-object declaration prune?: catalog-prune?)
        (let ((snapshot (new Region-Snapshot unit-name declaration roots catalog-prune? content outgoing)))
          (table-set! (monitored-content outline-snapshots) unit-name snapshot)))
      declaration))
  (outline-unit unit-name)
  (set-outline-hook
    #f))


(definition public (analyse-incoming (unit-name: unit-name #f) (feedback?: feedback? #t))
  (define (analyse content)
    (let ((incoming (new-register)))
      (iterate-register (get-containers~ (monitored-content %h))
        (lambda (container monitored)
          (unless (register-ref incoming container #f)
            (when (not (register-ref content container #f))
              (for-each (lambda (info)
                          (bind (obj . index) info
                            (when (register-ref content obj #f)
                              (let ((monitored (make-monitored (vector obj index #f))))
                                (register-set! incoming container monitored)))))
                        (monitored-content monitored))))))
      incoming))
  
  (format :terminal "analyse incoming ")
  (let ((snapshot (and unit-name (table-ref (monitored-content outline-snapshots) unit-name))))
    (let ((incoming (analyse (if unit-name
                                 (get-content~ snapshot)
                               (monitored-content permanent)))))
      (when unit-name
        (set-incoming~ snapshot incoming))
      (debug incoming)
      (set-%i incoming)))
  (format :terminal "done{%}"))


;;;
;;;; Compare
;;;


(definition public (compare-snapshots content mutated (present: present #f) (max: max #f))
  (define (present-table table register)
    (let ((count 0))
      (iterate-table table
        (lambda (obj monitored)
          (when (or (not max) (< count max))
            (present-object obj register present: present)
            (increase! count))))))
  
  (let ((removed (make-table test: eq?))
        (added (make-table test: eq?)))
    ;; removed
    (iterate-register content
      (lambda (obj monitored)
        ;; found diff
        (when (not (register-ref mutated obj #f))
          (let ((container (vector-ref (monitored-content monitored) 0)))
            ;; only keep root diffs
            (when (register-ref mutated container #f)
              (table-set! removed obj monitored))))))
    ;; added
    (iterate-register mutated
      (lambda (obj monitored)
        ;; found diff
        (when (not (register-ref content obj #f))
          (let ((container (vector-ref (monitored-content monitored) 0)))
            ;; only keep root diffs
            (when (register-ref content container #f)
              (table-set! added obj monitored))))))
    (debug 'content (register-length content))
    (debug 'mutated (register-length mutated))
    (newline)
    (debug 'removed (table-length removed))
    (debug 'added (table-length added))
    (newline)
    (when present
      (when (> (table-length removed) 0)
        (debug removed:)
        (present-table removed content)
        (newline))
      (when (> (table-length added) 0)
        (debug added:)
        (present-table added mutated)
        (newline)))
    (values removed added)))


(definition (present-object obj register (present: present #f) (depth: depth #f))
  (let ((present (or present 'container))
        (max-depth (or depth 10)))
    (define (present-obj obj)
      (write obj)
      (newline)
      (when (eq? present 'container)
        (let ((info (register-ref register obj #f)))
          (when info
            (present-container info))))
      (newline))
    
    (define (present-container info)
      (let (iter (scan info) (depth 0))
        (if (>= depth max-depth)
            (begin
              (display "  ...")
              (newline))
          (bind (container i data) scan
            (display "  ")
            (write i)
            (display " ")
            (write container)
            (newline)
            (let ((parent (register-ref register container #f)))
              (when parent
                (iter parent (+ depth 1))))))))
    
    (present-obj obj)))


(definition public (c obj)
  (present-object obj %c))


(definition public (m obj)
  (present-object obj %m))


(definition public (dl)
  (debug (table-length (get-modules)))
  (debug (table-length (get-catalog))))


(definition public (ir register)
  (inspect (register->table register)))


(definition public (ti target)
  (table-search (lambda (container monitored)
                  (when (eq? monitored target)
                    container))
                (register->table %i)))


(definition public (object-ref obj)
  (let ((monitored (register-ref (get-objects~ (monitored-content %h)) obj #f)))
    (if monitored
        (car (first (monitored-content monitored)))
      #f)))


(definition public (container-ref container)
  (let ((monitored (register-ref (get-containers~ (monitored-content %h)) container #f)))
    (if monitored
        (car (first (monitored-content monitored)))
      #f)))


;;;
;;;; Evaluate
;;;


(definition temporary-evaluation-file
  #f)

(definition (get-temporary-evaluation-file)
  (or temporary-evaluation-file (let ((file (get-temporary-file)))
                                  ;; changing the extension to jazz is a quick hack for debugger highlight
                                  ;; the right solution is to do the same thing as (read-source-all port container line col)
                                  ;; e.g. make it so compilation locations point to the original source file
                                  (set! temporary-evaluation-file (new-brother~ file (make-filename (get-base~ file) "jazz")))
                                  file)))


(definition public (evaluate-code code (evaluation-mode: evaluation-mode 'compile))
  (let ((unit-name (second code)))
    (load-unit unit-name)
    (outline-unit unit-name)
    (case evaluation-mode
      ((compile)
       (let ((file (get-temporary-evaluation-file)))
         (call-with-output-file (path-settings file char-encoding: 'UTF-8)
           (lambda (output)
             (pp code output)
             (newline output)))
         (let ((path (parse~ file)))
           (let ((pathname (parameterize ((requested-unit-name unit-name)
                                          (jazz:walk-for 'compile)
                                          (generate-symbol-for "&")
                                          (generate-symbol-context unit-name)
                                          (generate-symbol-counter 0)
                                          (path->container-override
                                            (lambda (target)
                                              (and (equal? target path)
                                                   unit-name))))
                             (with-jazz-readtable
                               (lambda ()
                                 (compile-file path options: compile-options))))))
             (load-file (list path: pathname char-encoding: 'UTF) #f)))))
      (else
       (parameterize ((requested-unit-name unit-name)
                      (walk-for 'eval)
                      (generate-symbol-for (format "%{a}&" (eval-count)))
                      (generate-symbol-context unit-name)
                      (generate-symbol-counter 0))
         (eval code))))))


(definition public (analyse-evaluate code (present: present #f))
  (let ((unit-name (second code)))
    (load-unit unit-name)
    (outline-unit unit-name)
    (let ((target (list (get-catalog) (get-modules))))
      (receive (content outgoing) (snapshot-object target)
        (evaluate-code code)
        (receive (mutated outgoing) (snapshot-object target)
          (compare-snapshots content mutated present: present))))))


;;;
;;;; Regions
;;;


(definition public (analyse-regions (members?: members? #f) (orphans?: orphans? #f) (feedback?: feedback? #t))
  (let ((world (current-world))
        (zone (current-zone))
        (kind MOVABLE0)
        (domain (make-domain))
        (regions (new-queue))
        (orphans (and orphans? (make-table test: eq?))))
    (receive (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
      (define (analyse-strings)
        (let ((size 0))
          (walk-interned-symbols
            (lambda (sym)
              (let ((name (symbol-name sym)))
                (when (string? name)
                  (register-set! (domain-copies domain) name name)
                  (increase! size (mem-allocated-size name))))
              #f))
          (enqueue regions (list 'strings size #f))))
      
      (define (analyse region obj)
        (let ((members (and members? (make-table test: eq?))))
          (domain-bytes-copied-set! domain 0)
          (copy-to obj kind domain
            visit: (lambda (obj)
                     (when members?
                       (let ((class (class-of obj)))
                         (table-set! members class (+ (table-ref members class 0) 1))))))
          (enqueue regions (list region (memory-copied domain) members))))
      
      (define (memory-copied domain)
        (* 2 (domain-bytes-copied domain)))
      
      (define (report-memory)
        (format :terminal "{%}live : {a}m ({a} + {a}){%}" (meg last-gc-live) (meg last-gc-movable) (meg last-gc-nonmovable)))
      
      (define (report-regions regions)
        (let ((total (apply + (map second regions))))
          (format :terminal "{%}total : {a}m (- {a}m){%}" (meg total) (meg (- last-gc-live total))))
        (for-each (lambda (info)
                    (bind (region bytes members) info
                      (format :terminal "{%}{a} : {a}m" region (meg bytes))
                      (when members
                        (for-each (lambda (info)
                                    (bind (class . count) info
                                      (format :terminal "{%}  {a} : {a}" (category-name class) count)))
                                  (sort > (table->list members) key: cdr)))))
                  regions))
      
      (define (meg bytes)
        (fxround (/ (cast <fl> bytes) 1024. 1024.)))
      
      (define (analyse-orphans regions)
        (format :terminal "{%}{%}")
        (walk-object!
          (lambda (container i obj)
            walk-continue)
          (lambda (container i obj)
            (when (mem-allocated? obj)
              (unless (eq? (mem-allocated-kind obj) 'PERM)
                (unless (register-ref (domain-copies domain) obj #f)
                  (let ((class (class-of obj)))
                    (table-set! orphans class (+ (table-ref orphans class 0) 1))))))
            obj)
          feedback?: feedback?)
        (format :terminal "{%}")
        (for-each (lambda (info)
                    (bind (class . count) info
                      (format :terminal "{%}{a} : {a}" (category-name class) count)))
                  (sort > (table->list orphans) key: cdr)))
      
      (report-memory)
      (analyse-strings)
      (analyse 'modules (get-modules))
      (analyse 'catalog (get-catalog))
      ;(analyse 'sectors (get-sectors~ zone))
      ;(analyse 'areas (get-areas~ zone))
      ;(analyse 'world world)
      ;(analyse 'zone zone)
      (let ((regions (queue-list regions)))
        (report-regions regions)
        (when orphans?
          (format :terminal "{%}{%}")
          (analyse-types ignore: (domain-copies domain))))
      (format :terminal "{%}{%}{%}"))))


;;;
;;;; Types
;;;


(definition public (analyse-types (ignore: ignore #f) (sample: sample #f) (threshold: threshold #f) (feedback?: feedback? #t))
  (let ((seen (new-register))
        (movable (make-table test: eq?))
        (still (make-table test: eq?))
        (perm (make-table test: eq?))
        (samples '())
        (threshold (* (or threshold 100) 1024)))
    (receive (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
      (define (add-size table obj class size)
        (when (eq? sample class)
          (set! samples (cons obj samples)))
        (table-set! table class (+ (table-ref table class 0) size)))
      
      (define (kb bytes)
        (fxround (/ (cast <fl> bytes) 1024.)))
      
      (define (meg bytes)
        (fxround (/ (cast <fl> bytes) 1024. 1024.)))
      
      (define (mem bytes)
        (if (>= bytes 1048576)
            (format "{a}m" (meg bytes))
          (format "{a}k" (kb bytes))))
      
      (define (report-memory)
        (format :terminal "Live : {a}m ({a} + {a}){%}{%}" (meg last-gc-live) (meg last-gc-movable) (meg last-gc-nonmovable)))
      
      (define (report-region name region (factor 1))
        (let ((live (case name
                      ((MOVA) last-gc-movable)
                      ((STIL) last-gc-nonmovable)
                      (else #f)))
              (total (apply + (map (lambda (info) (* factor (cdr info))) region))))
          (let ((missing (and live (- live total))))
            (format :terminal "{a}: {a}{? (- {a})~}{%}" name (mem total) (and (not ignore) missing (mem missing))))))
      
      (define (report-content name region (factor 1))
        (format :terminal "{%}{a}{%}" name)
        (for-each (lambda (info)
                    (let ((class (car info))
                          (size (* factor (cdr info))))
                      (when (>= size threshold)
                        (format :terminal "{a} {a}{%}" class (mem size)))))
                  (sort > region key: cdr)))
      
      (unless ignore
        (report-memory))
      (walk-object!
        (lambda (container i obj)
          walk-continue)
        (lambda (container i obj)
          (unless (register-ref seen obj #f)
            (unless (and ignore (register-ref ignore obj #f))
              (let ((table (and (mem-allocated? obj)
                                (case (mem-allocated-kind obj)
                                  ((PERM) perm)
                                  ((STILL) still)
                                  (else movable)))))
                (when table
                  (cond ((pair? obj)
                         (add-size table obj 'Pair 12))
                        ((symbol? obj)
                         (add-size table obj 'Symbol 16))
                        ((source? obj)
                         (add-size table obj 'Source (mem-allocated-size obj)))
                        ((or (table? obj)
                             (gc-hash-table? obj))
                         (add-size table obj 'Table (mem-allocated-size obj)))
                        (else
                         (add-size table obj (category-name (class-of obj)) (mem-allocated-size obj)))))))
            (register-set! seen obj #t))
          obj)
        feedback?: feedback?)
      (when feedback?
        (format :terminal "{%}{%}"))
      (let ((movable (table->list movable))
            (still (table->list still))
            (perm (table->list perm)))
        (report-region 'MOVA movable 2)
        (report-region 'STIL still)
        (unless ignore
          (report-region 'PERM perm))
        (report-content 'MOVA movable 2)
        (report-content 'STIL still)
        (unless ignore
          (report-content 'PERM perm))
        (when sample
          (format :terminal "{%}{%}")
          (terminal (subseq samples 0 (min (length samples) 1000)))
          (set-%a samples))
        (unless ignore
          (format :terminal "{%}{%}{%}"))
        (set-%m movable)
        (set-%s still)
        (set-%p perm)))))))
