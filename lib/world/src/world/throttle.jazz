;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World UDP Throttle
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.throttle jazz


(class UDP-Throttle extends Object
  
  
  (slot mutex                       getter generate)
  (slot last-sequence initialize #f getter generate)
  (slot last-gap-time initialize #f getter generate)
  (slot next-increase initialize #f getter generate)
  (slot multiplier    initialize 1. getter generate)
  
  
  (method override (initialize self)
    (set! mutex (make-mutex 'throttle)))
  
  
  (method (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  (method public (effective-rate self rate)
    (* rate multiplier))
  
  
  (method public (noack-received self adjust)
    (with-mutex self
      (lambda ()
        (let ((now (current-seconds))
              (dec .1))
          (let ((adjustment (- (* multiplier dec))))
            (set! multiplier (+ multiplier adjustment))
            (set! last-gap-time now)
            (set! next-increase 1.)
            (adjust adjustment))))))
  
  
  (method public (received-ack self sent sequence adjust)
    (with-mutex self
      (lambda ()
        (when last-sequence
          (let ((now (current-seconds))
                (expected (+ last-sequence 1)))
            (let ((gap (- sequence expected)))
              (cond ((> gap 0)
                     (let ((dec (if (= gap 1) .1 .2)))
                       (let ((adjustment (- (* multiplier dec))))
                         (set! multiplier (+ multiplier adjustment))
                         (set! last-gap-time now)
                         (set! next-increase 1.)
                         (adjust adjustment))))
                    (else
                     (when last-gap-time
                       (let ((elapsed (- now last-gap-time)))
                         (when (> elapsed next-increase)
                           (let ((inc .1))
                             (let ((new-multiplier (+ multiplier inc)))
                               (cond ((< new-multiplier 1.)
                                      (set! multiplier new-multiplier)
                                      (set! last-gap-time now)
                                      (set! next-increase (case next-increase
                                                            ((1.) 10.)
                                                            ((10.) 20.)
                                                            (else 30.))))
                                     (else
                                      (set! multiplier 1.)
                                      (set! last-gap-time #f)
                                      (set! next-increase #f)))
                               (let ((adjustment (- new-multiplier multiplier)))
                                 (adjust adjustment))))))))))))
        (set! last-sequence sequence))))))
