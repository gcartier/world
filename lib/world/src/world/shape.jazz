;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Shapes
;;;


(module world.shape jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.area)
        (world.autoload)
        (world.generate)
        (world.geometry)
        (world.mesh)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile))


;;;
;;;; Cone
;;;


@finish-conversion
(definition public (generate-cone p1 <f64vector> p2 <f64vector> r1 <fl> r2 <fl> m <fx> theta1 <fl> theta2 <fl>)
  (let ;; Normal pointing from p1 to p2
      ((n (vertex- p1 p2)))
    ;; Create two perpendicular vectors perp and q on the plane of the disk
    (let ((perp n))
      (if (and (= (vertex-x n) 0.) (= (vertex-z n) 0.))
          (vertex-x-set! n (+ (vertex-x n) 1))
        (vertex-y-set! n (+ (vertex-y n) 1)))
      (let ((perp (cross-product n q)))
        (let ((n (cross-product q perp)))
          (vertex-normalize! perp perp)
          (vertex-normalize! q q)
          (glBegin GL_QUAD_STRIP)
          (loop (for i from 0 to m)
                (let ((theta (+ theta1 (/ (* i (- theta2 theta1)) m))))
                  (vertex-x-set! n (+ (* (cos theta) perp.x) (* (sin theta) q.x)))
                  (vertex-y-set! n (+ (* (cos theta) perp.y) (* (sin theta) q.y)))
                  (vertex-z-set! n (+ (* (cos theta) perp.z) (* (sin theta) q.z)))
                  (vertex-normalize! n n)
                  
                  p.x = p2.x + r2 * n.x
                  p.y = p2.y + r2 * n.y
                  p.z = p2.z + r2 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 1.0)
                  glVertex3f(p.x p.y p.z)
                  
                  p.x = p1.x + r1 * n.x
                  p.y = p1.y + r1 * n.y
                  p.z = p1.z + r1 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 0.0)
                  glVertex3f(p.x p.y p.z)))
          (glEnd))))))


;;;
;;;; Sphere
;;;


(definition public (uv-sphere-generator slices stacks uv (matrix: matrix #f))
  (lambda (setup-proc triangle-proc quad-proc)
    (let ((dphi (/ 360. slices))
          (dtheta (/ 180. stacks)))
      (define (count-sphere)
        (let ((triangles 0)
              (quads 0))
          (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
                (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                      (if (and (> theta -90.) (< theta 90.))
                          (increase! quads)
                        (increase! triangles))))
          (setup-proc triangles quads)))
      
      (let ((DTOR (/ PI*2 360.))
            (tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv)))
        (define (add-triangle v1 v2 v3)
          (triangle-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            texture-depth))
        
        (define (add-quad v1 v2 v3 v4)
          (quad-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            v4 #f tl tt
            texture-depth))
        
        (define (transform-vertex x y z)
          (matrix+-transform-3x4 matrix (vertex x y z)))
        
        (count-sphere)
        (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
              (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                    (let ((v1 (transform-vertex (* (cos (* theta DTOR)) (cos (* phi DTOR)))
                                                (* (cos (* theta DTOR)) (sin (* phi DTOR)))
                                                (sin (* theta DTOR))))
                          (v2 (transform-vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* phi DTOR)))
                                                (* (cos (* (+ theta dtheta) DTOR)) (sin (* phi DTOR)))
                                                (sin (* (+ theta dtheta) DTOR))))
                          (v3 (transform-vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* (+ phi dphi) DTOR)))
                                                (* (cos (* (+ theta dtheta) DTOR)) (sin (* (+ phi dphi) DTOR)))
                                                (sin (* (+ theta dtheta) DTOR))))
                          (v4 (when (and (> theta -90.) (< theta 90.))
                                (transform-vertex (* (cos (* theta DTOR)) (cos (* (+ phi dphi) DTOR)))
                                                  (* (cos (* theta DTOR)) (sin (* (+ phi dphi) DTOR)))
                                                  (sin (* theta DTOR))))))
                      (if v4
                          (add-quad v1 v2 v3 v4)
                        (add-triangle v1 v2 v3)))))))))


(definition public (generate-sphere slices stacks uv what (smooth-normals?: smooth-normals? #f) (matrix: matrix #f) (material: material #f))
  (let ((generator (uv-sphere-generator slices stacks uv)))
    (case what
      ((render)
       (generate-mesh generator smooth-normals?: smooth-normals? matrix: matrix material: material))
      ((physical)
       (generate-polygons generator matrix: matrix)))))


;;;
;;;; Floor
;;;


(definition public (generate-floor x y z width depth)
  (let ((zone (current-zone)))
    (loop (for i from (- width) to width)
          (loop (for j from (- depth) to depth)
                (let ((x (+ x i))
                      (z (+ z j)))
                  (add-element~ zone
                    (new Quad-Tile
                      v1: (vertex x y (+ z 1.))
                      v2: (vertex (+ x 1.) y (+ z 1.))
                      v3: (vertex (+ x 1.) y z)
                      v4: (vertex x y z)
                      parent: zone)))))))


;;;
;;;; Wall
;;;


(definition public (generate-wall x y z width height)
  (let ((zone (current-zone)))
    (loop (for i from (- width) to width)
          (loop (for j from (- height) to height)
                (let ((x (+ x i))
                      (y (+ y j)))
                  (add-element~ zone
                    (new Quad-Tile
                      v1: (vertex x (+ y 1.) z)
                      v2: (vertex (+ x 1.) (+ y 1.) z)
                      v3: (vertex (+ x 1.) y z)
                      v4: (vertex x y z)
                      parent: zone)))))))


;;;
;;;; Slope
;;;


(definition public (generate-slope x y z height x-count z-count)
  (let ((zone (current-zone)))
    (let ((width 1.)
          (depth 1.))
      (loop (for d from 0 below z-count)
            (loop (for i from 0 below x-count)
                  (let ((x (+ x (* i width)))
                        (y (+ y (* d height)))
                        (z (+ z (* d depth))))
                    (add-element~ zone
                      (new Quad-Tile
                        v1: (vertex x (+ y height) (+ z depth))
                        v2: (vertex (+ x width) (+ y height) (+ z depth))
                        v3: (vertex (+ x width) y z)
                        v4: (vertex x y z)
                        parent: zone))))))))


;;;
;;;; Stairs
;;;


(definition public (generate-stairs stairs x y z width height depth x-count y-count z-count)
  (let ((zone (current-zone)))
    (loop (for d from 0 below stairs)
          (loop (for i from (- x-count) to x-count)
                (let ((x (+ x (* i width)))
                      (y (+ y (* d height)))
                      (z (+ z (* d (* depth z-count)))))
                  ;; front
                  (add-element~ zone
                    (new Quad-Tile
                      v1: (vertex x (+ y height) z)
                      v2: (vertex (+ x width) (+ y height) z)
                      v3: (vertex (+ x width) y z)
                      v4: (vertex x y z)
                      parent: zone))
                  ;; flat
                  (loop (for n from 0 below z-count)
                        (let ((z (+ z (* n depth))))
                          (add-element~ zone
                            (new Quad-Tile
                              v1: (vertex x (+ y height) (+ z depth))
                              v2: (vertex (+ x width) (+ y height) (+ z depth))
                              v3: (vertex (+ x width) (+ y height) z)
                              v4: (vertex x (+ y height) z)
                              parent: zone))))))))))
