;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Shapes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.shape jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.area)
        (world.autoload)
        (world.generate)
        (world.geometry)
        (world.mesh)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Cone
;;;


@finish-conversion
(definition public (generate-cone p1 <f64vector> p2 <f64vector> r1 <fl> r2 <fl> m <fx> theta1 <fl> theta2 <fl>)
  (let ;; Normal pointing from p1 to p2
      ((n (vertex- p1 p2)))
    ;; Create two perpendicular vectors perp and q on the plane of the disk
    (let ((perp n))
      (if (and (= (vertex-x n) 0.) (= (vertex-z n) 0.))
          (vertex-x-set! n (+ (vertex-x n) 1))
        (vertex-y-set! n (+ (vertex-y n) 1)))
      (let ((perp (cross-product n q)))
        (let ((n (cross-product q perp)))
          (vertex-normalize! perp perp)
          (vertex-normalize! q q)
          (glBegin GL_QUAD_STRIP)
          (loop (for i from 0 to m)
                (let ((theta (+ theta1 (/ (* i (- theta2 theta1)) m))))
                  (vertex-x-set! n (+ (* (cos theta) perp.x) (* (sin theta) q.x)))
                  (vertex-y-set! n (+ (* (cos theta) perp.y) (* (sin theta) q.y)))
                  (vertex-z-set! n (+ (* (cos theta) perp.z) (* (sin theta) q.z)))
                  (vertex-normalize! n n)
                  
                  p.x = p2.x + r2 * n.x
                  p.y = p2.y + r2 * n.y
                  p.z = p2.z + r2 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 1.0)
                  glVertex3f(p.x p.y p.z)
                  
                  p.x = p1.x + r1 * n.x
                  p.y = p1.y + r1 * n.y
                  p.z = p1.z + r1 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 0.0)
                  glVertex3f(p.x p.y p.z)))
          (glEnd))))))


;;;
;;;; Triangle
;;;


;; for tests
(definition public (triangle-generator (matrix: matrix #f))
  (let ((world (current-world)))
    (let ((uv (image-rect~ (get-tile-atlas~ world) "dirty")))
      (lambda (setup-proc triangle-proc quad-proc)
        (setup-proc 1 0)
        (let ((v1 (vertex -1. 0. 0.))
              (v2 (vertex  1. 0. 0.))
              (v3 (vertex  0. 1. 0.))
              (tl (uv-left uv))
              (tt (uv-top uv))
              (tr (uv-right uv))
              (tb (uv-bottom uv))
              (tdepth (uv-depth uv)))
          (triangle-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            tdepth))))))


;;;
;;;; Sphere
;;;


(definition public (uv-sphere-generator slices stacks uv <f32vector>)
  (lambda (setup-proc triangle-proc quad-proc)
    (let ((dphi <fl> (/ 360. slices))
          (dtheta <fl> (/ 180. stacks)))
      (define (count-sphere)
        (let ((triangles 0)
              (quads 0))
          (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
                (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                      (if (and (> theta -90.) (< theta 90.))
                          (increase! quads)
                        (increase! triangles))))
          (setup-proc triangles quads)))
      
      (let ((DTOR (/ PI*2 360.))
            (tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv)))
        (define (add-triangle v1 v2 v3)
          (triangle-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            texture-depth))
        
        (define (add-quad v1 v2 v3 v4)
          (quad-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            v4 #f tl tt
            texture-depth))
        
        (count-sphere)
        (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
              (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                    (let ((v1 (vertex (* (cos (* theta DTOR)) (cos (* phi DTOR)))
                                      (* (cos (* theta DTOR)) (sin (* phi DTOR)))
                                      (sin (* theta DTOR))))
                          (v2 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* phi DTOR)))
                                      (* (cos (* (+ theta dtheta) DTOR)) (sin (* phi DTOR)))
                                      (sin (* (+ theta dtheta) DTOR))))
                          (v3 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* (+ phi dphi) DTOR)))
                                      (* (cos (* (+ theta dtheta) DTOR)) (sin (* (+ phi dphi) DTOR)))
                                      (sin (* (+ theta dtheta) DTOR))))
                          (v4 (when (and (> theta -90.) (< theta 90.))
                                (vertex (* (cos (* theta DTOR)) (cos (* (+ phi dphi) DTOR)))
                                        (* (cos (* theta DTOR)) (sin (* (+ phi dphi) DTOR)))
                                        (sin (* theta DTOR))))))
                      (if v4
                          (add-quad v4 v3 v2 v1)
                        (add-triangle v3 v2 v1)))))))))


;;-----------------------------------------------------------------------------

(definition public (ico-sphere-generator N uv <f32vector>)
  (lambda (setup-proc triangle-proc quad-proc)

    (define (fx= x y) (= x y))
    (define (fx< x y) (< x y))
    (define (fx> x y) (> x y))
    (define (fxeven? x) (even? x))

    (define (flsqrt x) (sqrt x))

;; An icosahedron is a convex solid composed of 20 triangular faces.
;; Each face is an equilateral triangle.  Unfolding the faces onto a
;; flat surface illustrates their connectivity.
;;
;;      /\          /\          /\          /\          /\
;;     /  \        /  \        /  \        /  \        /  \
;;    /    \      /    \      /    \      /    \      /    \
;;   /  3   \    /  7   \    /  11  \    /  15  \    /  19  \
;;  /        \  /        \  /        \  /        \  /        \
;; /__________\/__________\/__________\/__________\/__________\
;; \          /\          /\          /\          /\          /\
;;  \        /  \        /  \        /  \        /  \        /  \
;;   \  2   /    \  6   /    \  10  /    \  14  /    \  18  /    \
;;    \    /  1   \    /  5   \    /  9   \    /  13  \    /  17  \
;;     \  /        \  /        \  /        \  /        \  /        \
;;      \/__________\/__________\/__________\/__________\/__________\
;;       \          /\          /\          /\          /\          /
;;        \        /  \        /  \        /  \        /  \        /
;;         \  0   /    \  4   /    \  8   /    \  12  /    \  16  /
;;          \    /      \    /      \    /      \    /      \    /
;;           \  /        \  /        \  /        \  /        \  /
;;            \/          \/          \/          \/          \/
;;
;; The bottom vertex of faces 0, 4, 8, 12, and 16 is the same point,
;; the south pole.  The top vertex of faces 3, 7, 11, 15, and 19 is
;; the same point, the north pole.
;;
;; The grid can be partitionned into 5 groups of 4 faces.  Each of
;; these groups is a "strip". Each strip can be subdivided into a grid
;; of triangular elements (trixels):
;;
;;      /\           /\           /\           /\           /\
;;     /__\         /__\         /__\         /__\         /__\
;;    /\  /\       /\  /\       /\  /\       /\  /\       /\  /\
;;   /__\/__\     /__\/__\     /__\/__\     /__\/__\     /__\/__\
;;  /\  /\  /\   /\  /\  /\   /\  /\  /\   /\  /\  /\   /\  /\  /\
;; /__\/__\/__\ /__\/__\/__\ /__\/__\/__\ /__\/__\/__\ /__\/__\/__\
;; \  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\
;;  \/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\
;;   \  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\
;;    \/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\
;;     \  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\
;;      \/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\
;;       \  /\  /\  / \  /\  /\  / \  /\  /\  / \  /\  /\  / \  /\  /\  /
;;        \/__\/__\/   \/__\/__\/   \/__\/__\/   \/__\/__\/   \/__\/__\/
;;         \  /\  /     \  /\  /     \  /\  /     \  /\  /     \  /\  /
;;          \/__\/       \/__\/       \/__\/       \/__\/       \/__\/
;;           \  /         \  /         \  /         \  /         \  /
;;            \/           \/           \/           \/           \/
;;
;;
;; A strip can be viewed as a skewed N by 2*N rectangular grid.  Each
;; cell of the rectangular grid contains two trixels.  There is a
;; total of 10*N^2 cells and 20*N^2 trixels.  A cell can be identified
;; by a (X,Y) coordinate where 0 <= X < 5*N and 0 <= Y < 2*N.  A trixel
;; can be identified by a (x,y) coordinate where 0 <= x < 10*N and
;; 0 <= y < 2*N.  A trixel at coordinate (x,y) is in the lower half of
;; cell (x/2,y) if x is even, and in the upper half of cell
;; ((x-1)/2,y) if x is odd.
;;
;;      +-------+-------+-------j
;;      | \     | \     | \     |
;;    5 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |
;;      +-------+-------+-------i
;;      | \     | \     | \     |
;;    4 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |
;;      +-------+-------+-------h
;;      | \     | \     | \     |
;;    3 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |
;;      +-------+-------+-------g    g-------h-------i-------j
;;      | \     | \     | \     |    | \     | \     | \     |
;;    2 |   \   |   \   |   \   |  5 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |    |     \ |     \ |     \ |
;;      +-------+-------+-------f    f-------+-------+-------+
;;      | \     | \     | \     |    | \     | \     | \     |
;;    1 |   \   |   \   |   \   |  4 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |    |     \ |     \ |     \ |
;;      +-------+-------+-------e    e-------+-------+-------+
;;      | \     | \     | \     |    | \     | \     | \     |
;; Y  0 |   \   |   \   |   \   |  3 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |    |     \ |     \ |     \ |
;; ^    a-------b-------c-------d    d-------+-------+-------+
;; |        0       1       2        | \     | \     | \     |
;; |           first strip         2 |   \   |   \   |   \   |
;; +-----> X                         |     \ |     \ |     \ |
;;                                   c-------+-------+-------+
;;                                   | \     | \     | \     |
;;                                 1 |   \   |   \   |   \   |   ...
;;                                   |     \ |     \ |     \ |
;;                                   b-------+-------+-------+
;;                                   | \     | \     | \     |
;;                                 0 |   \   |   \   |   \   |
;;                                   |     \ |     \ |     \ |
;;                                   a-------+-------+-------+
;;                                       3       4       5
;;                                         second strip
;;
;; Each strip shares some vertices with its neighbouring stips.  As
;; shown in the example above, two neighbouring strips share N*3+1
;; vertices (vertices "a" through "j").  The vertices at the poles
;; (vertices "a" and "j") are shared by all strips, so N*3-1 vertices
;; are shared exclusively by two neighbouring cells.  The total number
;; of vertices is equal to 10*N^2 + 2 = 5*((2*N+1)*(N+1) - (N*3+1)) + 2.

(define (trix->strip x y N)
  (fxquotient x (fx* 2 N)))

(define (trix->face x y N)
  (fx+ (fx* 2 (fxquotient y N))
       (fx* 4 (trix->strip x y N))
       (if (fx> (fx+ (fxmodulo x (fx* 2 N)) (fx* 2 (fxmodulo y N))) N) 1 0)))

(define (trix->vertex-west x y N)
  (fx+ (fx* N 5 y) (fxquotient x 2) 1))

(define (trix->vertex-east x y N)
  (let ((x/2 (fxquotient x 2)))
    (cond ((fx= y 0)
           (fx+ (fx* N 5 (fxmodulo x/2 N))
                (fx* N (fxmodulo (fx+ (trix->strip x y N) 1) 5))
                1))
          ((fx= (fxmodulo (fx+ x/2 1) N) 0)
           (if (fx< y N)
               (fx+ (fx* N 5 (fx+ y N -1))
                    (fx* N (fxmodulo (fx+ (trix->strip x y N) 1) 5))
                    1)
               (fx+ (fxmodulo y N)
                    (fx* N 5 (fx+ (fx* 2 N) -1))
                    (fx* N (fxmodulo (fx+ (trix->strip x y N) 1) 5))
                    1)))
          (else
           (fx+ (fx* N 5 (fx+ y -1)) x/2 2)))))

(define (trix->vertex-south-north x y N)
  (if (fxeven? x)
      (if (fx= y 0)
          (if (fx= (fxmodulo x (fx* 2 N)) 0)
              0
              (trix->vertex-east (fx+ x -1) y N))
          (trix->vertex-west x (fx+ y -1) N))
      (if (fx= y (fx+ (fx* 2 N) -1))
          (if (fx= (modulo (fx+ x 1) (fx* 2 N)) 0)
              (fx+ (fx* 10 N N) 1)
              (trix->vertex-west (fx+ x 1) y N))
          (trix->vertex-east x (fx+ y 1) N))))

(define (test-trix-fns)

  (define N 2)

  (let ((rev-lst '()))
    (let loopy ((y 0))
      (if (fx< y (fx* 2 N))
          (let loopx ((x 0))
            (if (fx< x (fx* 10 N))
                (begin
                  (set! rev-lst
                        (cons (list (trix->face x y N)
                                    (trix->vertex-west x y N)
                                    (trix->vertex-east x y N)
                                    (trix->vertex-south-north x y N))
                              rev-lst))
                  (loopx (fx+ x 1)))
                (begin
                  (loopy (fx+ y 1)))))))

    (let ((r (reverse rev-lst)))
      (if (not (equal? r
                       '((0 1 3 0)
                         (0 1 3 2)
                         (0 2 13 3)
                         (1 2 13 23)
                         (4 3 5 0)
                         (4 3 5 4)
                         (4 4 15 5)
                         (5 4 15 25)
                         (8 5 7 0)
                         (8 5 7 6)
                         (8 6 17 7)
                         (9 6 17 27)
                         (12 7 9 0)
                         (12 7 9 8)
                         (12 8 19 9)
                         (13 8 19 29)
                         (16 9 1 0)
                         (16 9 1 10)
                         (16 10 11 1)
                         (17 10 11 21)
                         (0 11 2 1)
                         (1 11 2 12)
                         (1 12 23 2)
                         (1 12 23 33)
                         (4 13 4 3)
                         (5 13 4 14)
                         (5 14 25 4)
                         (5 14 25 35)
                         (8 15 6 5)
                         (9 15 6 16)
                         (9 16 27 6)
                         (9 16 27 37)
                         (12 17 8 7)
                         (13 17 8 18)
                         (13 18 29 8)
                         (13 18 29 39)
                         (16 19 10 9)
                         (17 19 10 20)
                         (17 20 21 10)
                         (17 20 21 31)
                         (2 21 12 11)
                         (2 21 12 22)
                         (2 22 33 12)
                         (3 22 33 34)
                         (6 23 14 13)
                         (6 23 14 24)
                         (6 24 35 14)
                         (7 24 35 36)
                         (10 25 16 15)
                         (10 25 16 26)
                         (10 26 37 16)
                         (11 26 37 38)
                         (14 27 18 17)
                         (14 27 18 28)
                         (14 28 39 18)
                         (15 28 39 40)
                         (18 29 20 19)
                         (18 29 20 30)
                         (18 30 31 20)
                         (19 30 31 32)
                         (2 31 22 21)
                         (3 31 22 32)
                         (3 32 34 22)
                         (3 32 34 41)
                         (6 33 24 23)
                         (7 33 24 34)
                         (7 34 36 24)
                         (7 34 36 41)
                         (10 35 26 25)
                         (11 35 26 36)
                         (11 36 38 26)
                         (11 36 38 41)
                         (14 37 28 27)
                         (15 37 28 38)
                         (15 38 40 28)
                         (15 38 40 41)
                         (18 39 30 29)
                         (19 39 30 40)
                         (19 40 32 30)
                         (19 40 32 41))))
          (error "test-trix-fns failed")))))

;;(test-trix-fns)

;; The faces of the icosahedron are connected to the vertices as
;; follows:
;;
;;      11          11          11          11          11
;;     /  \        /  \        /  \        /  \        /  \
;;    /    \      /    \      /    \      /    \      /    \
;;   /  3   \    /  7   \    /  11  \    /  15  \    /  19  \
;;  /        \  /        \  /        \  /        \  /        \
;;10__________2/__________4/__________6/__________8/__________10
;; \          /\          /\          /\          /\          /\
;;  \        /  \        /  \        /  \        /  \        /  \
;;   \  2   /    \  6   /    \  10  /    \  14  /    \  18  /    \
;;    \    /  1   \    /  5   \    /  9   \    /  13  \    /  17  \
;;     \  /        \  /        \  /        \  /        \  /        \
;;      1/__________3/__________5/__________7/__________9/__________1
;;       \          /\          /\          /\          /\          /
;;        \        /  \        /  \        /  \        /  \        /
;;         \  0   /    \  4   /    \  8   /    \  12  /    \  16  /
;;          \    /      \    /      \    /      \    /      \    /
;;           \  /        \  /        \  /        \  /        \  /
;;            0/          0/          0/          0/          0/

(define ico-connections
  '#( ;; 3 vertices for each face (west, east, south/north)
     #(1 3 0)   ;; face 0
     #(1 3 2)   ;; face 1
     #(10 2 1)  ;; face 2
     #(10 2 11) ;; face 3
     #(3 5 0)   ;; face 4
     #(3 5 4)   ;; face 5
     #(2 4 3)   ;; face 6
     #(2 4 11)  ;; face 7
     #(5 7 0)   ;; face 8
     #(5 7 6)   ;; face 9
     #(4 6 5)   ;; face 10
     #(4 6 11)  ;; face 11
     #(7 9 0)   ;; face 12
     #(7 9 8)   ;; face 13
     #(6 8 7)   ;; face 14
     #(6 8 11)  ;; face 15
     #(9 1 0)   ;; face 16
     #(9 1 10)  ;; face 17
     #(8 10 9)  ;; face 18
     #(8 10 11) ;; face 19
     ))

(define ico-vertices
  (let* ((+phi (fl/ (fl+ 1.0 (flsqrt 5.0)) 2.0))
         (-phi (fl- 0.0 +phi)))
    (vector (vertex -1.0 -phi  0.0)
            (vertex -phi  0.0 -1.0)
            (vertex  0.0 +1.0 -phi)
            (vertex  0.0 -1.0 -phi)
            (vertex +phi  0.0 -1.0)
            (vertex +1.0 -phi  0.0)
            (vertex +phi  0.0 +1.0)
            (vertex  0.0 -1.0 +phi)
            (vertex  0.0 +1.0 +phi)
            (vertex -phi  0.0 +1.0)
            (vertex -1.0 +phi  0.0)
            (vertex +1.0 +phi  0.0)
            )))

(define (make-ico-sphere-vertices N)

  (let ((vertices (make-vector (fx+ (fx* 10 N N) 2) #f)))

    (define (set-vertex v x y z)
      (let ((norm (flsqrt (fl+ (fl* x x) (fl+ (fl* y y) (fl* z z))))))
        (vector-set! vertices
                     v
                     (vertex (fl/ x norm) (fl/ y norm) (fl/ z norm)))))

    (let loop-face ((face 0))
      (if (fx< face 20)
          (let* ((facex (fxquotient face 4))
                 (facey (fxquotient (fxmodulo face 4) 2))
                 (conn (vector-ref ico-connections face))
                 (w (vector-ref ico-vertices (vector-ref conn 0)))
                 (e (vector-ref ico-vertices (vector-ref conn 1)))
                 (sn (vector-ref ico-vertices (vector-ref conn 2)))
                 (dw (vertex (fl- (vertex-x w)
                                  (vertex-x sn))
                             (fl- (vertex-y w)
                                  (vertex-y sn))
                             (fl- (vertex-z w)
                                  (vertex-z sn))))
                 (de (vertex (fl- (vertex-x e)
                                  (vertex-x sn))
                             (fl- (vertex-y e)
                                  (vertex-y sn))
                             (fl- (vertex-z e)
                                  (vertex-z sn)))))

            (define (set v a b)
              (let ((aa (fl/ (exact->inexact a) (exact->inexact N)))
                    (bb (fl/ (exact->inexact b) (exact->inexact N))))
                (set-vertex
                 v
                 (fl+ (vertex-x sn)
                      (fl+ (fl* aa (vertex-x de))
                           (fl* bb (vertex-x dw))))
                 (fl+ (vertex-y sn)
                      (fl+ (fl* aa (vertex-y de))
                           (fl* bb (vertex-y dw))))
                 (fl+ (vertex-z sn)
                      (fl+ (fl* aa (vertex-z de))
                           (fl* bb (vertex-z dw)))))))

            (let loop-i ((i 0))
              (if (fx< i N)
                  (let loop-j ((j 0))
                    (if (fx< (fx+ i j) N)
                        (begin

                          (if (fxeven? face)

                              (let* ((basex (fx* 2 N facex))
                                     (basey (fx* N facey))
                                     (x (fx+ basex (fx* 2 i)))
                                     (y (fx+ basey j))
                                     (vw (trix->vertex-west x y N)))
                                (set vw i (fx+ j 1)))

                              (let* ((basex (fx- (fx* 2 N (fx+ facex 1)) 1))
                                     (basey (fx- (fx* N (fx+ facey 1)) 1))
                                     (x (fx- basex (fx* 2 i)))
                                     (y (fx- basey j))
                                     (vw (trix->vertex-west x y N)))
                                (set vw j (fx+ i 1))))

                          (loop-j (fx+ j 1)))
                        (loop-i (fx+ i 1))))
                  (loop-face (fx+ face 1)))))))

    (let ((v0 (vector-ref ico-vertices 0)))
      (set-vertex 0
                  (vertex-x v0)
                  (vertex-y v0)
                  (vertex-z v0)))

    (let ((v11 (vector-ref ico-vertices 11)))
      (set-vertex (fx+ (fx* 10 N N) 1)
                  (vertex-x v11)
                  (vertex-y v11)
                  (vertex-z v11)))

    vertices))

(define (draw-ico-sphere N)
  (let ((vertices (make-ico-sphere-vertices N)))
    (let loop-x ((x 0))
      (if (fx< x (fx* 10 N))
          (let loop-y ((y 0))
            (if (fx< y (fx* 2 N))
                (let ((vw (trix->vertex-west x y N))
                      (ve (trix->vertex-east x y N))
                      (vsn (trix->vertex-south-north x y N)))

                  (let ((tl (uv-left uv))
                        (tt (uv-top uv))
                        (tr (uv-right uv))
                        (tb (uv-bottom uv))
                        (texture-depth (uv-depth uv)))
                    (if (fxeven? x)
                        (triangle-proc
                         (vector-ref vertices vw) #f tl tb
                         (vector-ref vertices ve) #f tr tb
                         (vector-ref vertices vsn) #f tr tt
                         texture-depth)
                        (triangle-proc
                         (vector-ref vertices vsn) #f tr tt
                         (vector-ref vertices ve) #f tr tb
                         (vector-ref vertices vw) #f tl tb
                         texture-depth)))

                  (loop-y (fx+ y 1)))
                (loop-x (fx+ x 1))))))))

(setup-proc (fx* 20 N N) 0)

(draw-ico-sphere N)))

;;-----------------------------------------------------------------------------

(definition public (generate-sphere-mesh slices stacks uv (matrix: matrix #f) (smooth-normals?: smooth-normals? #f) (material: material #f))
  (let ((generator (uv-sphere-generator slices stacks uv)))
    (generate-mesh generator matrix: matrix smooth-normals?: smooth-normals? material: material)))


;;;
;;;; Floor
;;;


(definition public (generate-floor x y z width depth)
  (let ((zone (current-zone)))
    (loop (for i from (- width) to width)
          (loop (for j from (- depth) to depth)
                (let ((x (+ x i))
                      (z (+ z j)))
                  (add-element~ zone
                    (new Quad-Tile
                      v1: (vertex x y (+ z 1.))
                      v2: (vertex (+ x 1.) y (+ z 1.))
                      v3: (vertex (+ x 1.) y z)
                      v4: (vertex x y z)
                      parent: zone)))))))


;;;
;;;; Wall
;;;


(definition public (generate-wall x y z width height)
  (let ((zone (current-zone)))
    (loop (for i from (- width) to width)
          (loop (for j from (- height) to height)
                (let ((x (+ x i))
                      (y (+ y j)))
                  (add-element~ zone
                    (new Quad-Tile
                      v1: (vertex x (+ y 1.) z)
                      v2: (vertex (+ x 1.) (+ y 1.) z)
                      v3: (vertex (+ x 1.) y z)
                      v4: (vertex x y z)
                      parent: zone)))))))


;;;
;;;; Slope
;;;


(definition public (generate-slope x y z height x-count z-count)
  (let ((zone (current-zone)))
    (let ((width 1.)
          (depth 1.))
      (loop (for d from 0 below z-count)
            (loop (for i from 0 below x-count)
                  (let ((x (+ x (* i width)))
                        (y (+ y (* d height)))
                        (z (+ z (* d depth))))
                    (add-element~ zone
                      (new Quad-Tile
                        v1: (vertex x (+ y height) (+ z depth))
                        v2: (vertex (+ x width) (+ y height) (+ z depth))
                        v3: (vertex (+ x width) y z)
                        v4: (vertex x y z)
                        parent: zone))))))))


;;;
;;;; Stairs
;;;


(definition public (generate-stairs stairs x y z width height depth x-count y-count z-count)
  (let ((zone (current-zone)))
    (loop (for d from 0 below stairs)
          (loop (for i from (- x-count) to x-count)
                (let ((x (+ x (* i width)))
                      (y (+ y (* d height)))
                      (z (+ z (* d (* depth z-count)))))
                  ;; front
                  (add-element~ zone
                    (new Quad-Tile
                      v1: (vertex x (+ y height) z)
                      v2: (vertex (+ x width) (+ y height) z)
                      v3: (vertex (+ x width) y z)
                      v4: (vertex x y z)
                      parent: zone))
                  ;; flat
                  (loop (for n from 0 below z-count)
                        (let ((z (+ z (* n depth))))
                          (add-element~ zone
                            (new Quad-Tile
                              v1: (vertex x (+ y height) (+ z depth))
                              v2: (vertex (+ x width) (+ y height) (+ z depth))
                              v3: (vertex (+ x width) (+ y height) z)
                              v4: (vertex x (+ y height) z)
                              parent: zone))))))))))
