;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Shapes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.shape jazz


(import (jazz.geometry)
        (world)
        (world.autoload)
        (world.generate)
        (world.geometry)
        (world.syntax (phase syntax))
        (world.texture))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Cone
;;;


@finish-conversion
(definition public (generate-cone p1 <f64vector> p2 <f64vector> r1 <fl> r2 <fl> m <fx> theta1 <fl> theta2 <fl>)
  (let ;; Normal pointing from p1 to p2
      ((n (vertex-& p1 p2)))
    ;; Create two perpendicular vectors perp and q on the plane of the disk
    (let ((perp n))
      (if (and (= (vertex-x n) 0.) (= (vertex-z n) 0.))
          (vertex-x-set! n (+ (vertex-x n) 1))
        (vertex-y-set! n (+ (vertex-y n) 1)))
      (let ((perp (cross-product& n q)))
        (let ((n (cross-product& q perp)))
          (vertex-normalize! perp perp)
          (vertex-normalize! q q)
          (glBegin GL_QUAD_STRIP)
          (loop (for i from 0 to m)
                (let ((theta (+ theta1 (/ (* i (- theta2 theta1)) m))))
                  (vertex-x-set! n (+ (* (cos theta) perp.x) (* (sin theta) q.x)))
                  (vertex-y-set! n (+ (* (cos theta) perp.y) (* (sin theta) q.y)))
                  (vertex-z-set! n (+ (* (cos theta) perp.z) (* (sin theta) q.z)))
                  (vertex-normalize! n n)
                  
                  p.x = p2.x + r2 * n.x
                  p.y = p2.y + r2 * n.y
                  p.z = p2.z + r2 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 1.0)
                  glVertex3f(p.x p.y p.z)
                  
                  p.x = p1.x + r1 * n.x
                  p.y = p1.y + r1 * n.y
                  p.z = p1.z + r1 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 0.0)
                  glVertex3f(p.x p.y p.z)))
          (glEnd))))))


;;;
;;;; Triangle
;;;


;; for tests
(definition public (triangle-generator (matrix: matrix #f))
  (let ((world (current-world)))
    (let ((uv (image-rect~ (get-block-atlas~ world) "dirty")))
      (lambda (setup-proc triangle-proc quad-proc)
        (setup-proc 1 0)
        (let ((v1 (vertex -1. 0. 0.))
              (v2 (vertex  1. 0. 0.))
              (v3 (vertex  0. 1. 0.))
              (tl (uv-left uv))
              (tt (uv-top uv))
              (tr (uv-right uv))
              (tb (uv-bottom uv))
              (tdepth (uv-depth uv)))
          (triangle-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            tdepth))))))


;;;
;;;; Sphere
;;;


(definition public (uv-sphere-generator slices <fx> stacks <fx> uv <f32vector>)
  (lambda (setup-proc triangle-proc quad-proc)
    (let ((dphi (/ 360. (cast <fl> slices)))
          (dtheta (/ 180. (cast <fl> stacks))))
      (define (count-sphere)
        (let ((triangles (* slices 2))
              (quads (* slices (- stacks 2))))
          (setup-proc triangles quads)))
      
      (let ((DTOR (/ PI*2 360.))
            (tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv)))
        (define (add-triangle v1 v2 v3)
          (triangle-proc
            v1 #f tl tb 0
            v2 #f tr tb 0
            v3 #f tr tt 0
            texture-depth))
        
        (define (add-quad v1 v2 v3 v4)
          (quad-proc
            v1 #f tl tb 0
            v2 #f tr tb 0
            v3 #f tr tt 0
            v4 #f tl tt 0
            texture-depth))
        
        (count-sphere)
        (loop (for i from 0 below stacks)
              (let ((theta (- (* dtheta (cast <fl> i)) 90.)))
                (loop (for j from 0 below slices)
                      (let ((phi (* dphi (cast <fl> j))))
                        (let ((v1 (vertex (* (cos (* theta DTOR)) (cos (* phi DTOR)))
                                          (* (cos (* theta DTOR)) (sin (* phi DTOR)))
                                          (sin (* theta DTOR))))
                              (v2 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* phi DTOR)))
                                          (* (cos (* (+ theta dtheta) DTOR)) (sin (* phi DTOR)))
                                          (sin (* (+ theta dtheta) DTOR))))
                              (v3 (unless (= i (- stacks 1))
                                    (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* (+ phi dphi) DTOR)))
                                            (* (cos (* (+ theta dtheta) DTOR)) (sin (* (+ phi dphi) DTOR)))
                                            (sin (* (+ theta dtheta) DTOR)))))
                              (v4 (unless (= i 0)
                                    (vertex (* (cos (* theta DTOR)) (cos (* (+ phi dphi) DTOR)))
                                            (* (cos (* theta DTOR)) (sin (* (+ phi dphi) DTOR)))
                                            (sin (* theta DTOR))))))
                          (if (and v3 v4)
                              (add-quad v4 v3 v2 v1)
                            (add-triangle (or v3 v4) v2 v1)))))))))))


(definition public (generate-sphere-mesh slices stacks uv (matrix: matrix #f) (neighbors?: neighbors? #f) (smooth-normals?: smooth-normals? #f) (material: material #f))
  (let ((generator (uv-sphere-generator slices stacks uv)))
    (generate-mesh generator matrix: matrix neighbors?: neighbors? smooth-normals?: smooth-normals? material: material))))
