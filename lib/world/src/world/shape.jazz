;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Shapes
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.shape jazz


(import (jazz.geometry)
        (world)
        (world.autoload)
        (world.face)
        (world.generate)
        (world.geometry)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Cone
;;;


@finish-conversion
(definition public (generate-cone p1 <f64vector> p2 <f64vector> r1 <fl> r2 <fl> m <fx> theta1 <fl> theta2 <fl>)
  (let ;; Normal pointing from p1 to p2
      ((n (vertex-& p1 p2)))
    ;; Create two perpendicular vectors perp and q on the plane of the disk
    (let ((perp n))
      (if (and (= (vertex-x n) 0.) (= (vertex-z n) 0.))
          (vertex-x-set! n (+ (vertex-x n) 1))
        (vertex-y-set! n (+ (vertex-y n) 1)))
      (let ((perp (cross-product& n q)))
        (let ((n (cross-product& q perp)))
          (vertex-normalize! perp perp)
          (vertex-normalize! q q)
          (glBegin GL_QUAD_STRIP)
          (loop (for i from 0 to m)
                (let ((theta (+ theta1 (/ (* i (- theta2 theta1)) m))))
                  (vertex-x-set! n (+ (* (cos theta) perp.x) (* (sin theta) q.x)))
                  (vertex-y-set! n (+ (* (cos theta) perp.y) (* (sin theta) q.y)))
                  (vertex-z-set! n (+ (* (cos theta) perp.z) (* (sin theta) q.z)))
                  (vertex-normalize! n n)
                  
                  p.x = p2.x + r2 * n.x
                  p.y = p2.y + r2 * n.y
                  p.z = p2.z + r2 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 1.0)
                  glVertex3f(p.x p.y p.z)
                  
                  p.x = p1.x + r1 * n.x
                  p.y = p1.y + r1 * n.y
                  p.z = p1.z + r1 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 0.0)
                  glVertex3f(p.x p.y p.z)))
          (glEnd))))))


;;;
;;;; Triangle
;;;


;; for tests
(definition public (triangle-generator (matrix: matrix #f))
  (let ((world (current-world)))
    (let ((uv (image-rect~ (get-block-atlas~ world) "dirty")))
      (lambda (setup-proc triangle-proc quad-proc)
        (setup-proc 1 0)
        (let ((v1 (vertex -1. 0. 0.))
              (v2 (vertex  1. 0. 0.))
              (v3 (vertex  0. 1. 0.))
              (tl (uv-left uv))
              (tt (uv-top uv))
              (tr (uv-right uv))
              (tb (uv-bottom uv))
              (tdepth (uv-depth uv)))
          (triangle-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            tdepth))))))


;;;
;;;; Quad
;;;


(definition public (generate-quad-mesh (neighbors?: neighbors? #f))
  (let ((world (current-world)))
    (let ((left -.5)
          (back -.5)
          (right .5)
          (front .5)
          (opaque-material (get-block-opaque~ world))
          (texture-coordinates (f32vector 0. 0. 0. 0. 0. 0. 0. 0.))
          (texture-depth 0.))
      (let ((faces
              (list
                (make-face opaque-material
                           texture-coordinates
                           texture-depth
                           (make-quad #f
                                      (vertex left 0. front) (vertex left 0. back) (vertex right 0. back) (vertex right 0. front))))))
        (generate-mesh (faces-generator faces) neighbors?: neighbors?)))))


;;;
;;;; Cube
;;;


(definition public (generate-cube-mesh (neighbors?: neighbors? #f))
  (let ((world (current-world)))
    (let ((left -.5)
          (bottom -.5)
          (back -.5)
          (right .5)
          (top .5)
          (front .5)
          (opaque-material (get-block-opaque~ world))
          (texture-coordinates (f32vector 0. 0. 0. 0. 0. 0. 0. 0.))
          (texture-depth 0.))
      (let ((faces
              (list
                ;; front
                (make-face opaque-material
                           texture-coordinates
                           texture-depth
                           (make-quad #f
                                      (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front)))
                ;; back
                (make-face opaque-material
                           texture-coordinates
                           texture-depth
                           (make-quad #f
                                      (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back)))
                ;; left
                (make-face opaque-material
                           texture-coordinates
                           texture-depth
                           (make-quad #f
                                      (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front)))
                ;; right
                (make-face opaque-material
                           texture-coordinates
                           texture-depth
                           (make-quad #f
                                      (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back)))
                ;; top
                (make-face opaque-material
                           texture-coordinates
                           texture-depth
                           (make-quad #f
                                      (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back)))
                ;; bottom
                (make-face opaque-material
                           texture-coordinates
                           texture-depth
                           (make-quad #f
                                      (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front))))))
        (generate-mesh (faces-generator faces) neighbors?: neighbors?)))))


;;;
;;;; Sphere
;;;


(definition public (sphere-generator slices <fx> stacks <fx> uv <f32vector>)
  (lambda (setup-proc triangle-proc quad-proc)
    (let ((dphi (/ 360. (cast <fl> slices)))
          (dtheta (/ 180. (cast <fl> stacks))))
      (define (count-sphere)
        (let ((triangles (* slices 2))
              (quads (* slices (- stacks 2))))
          (setup-proc triangles quads)))
      
      (let ((DTOR (/ PI*2 360.))
            (tl uv/left)
            (tt uv/top)
            (tr uv/right)
            (tb uv/bottom)
            (texture-depth (uv-depth uv)))
        (define (add-triangle v1 v2 v3)
          (triangle-proc
            v1 #f tl tb 0
            v2 #f tr tb 0
            v3 #f tr tt 0
            uv
            texture-depth))
        
        (define (add-quad v1 v2 v3 v4)
          (quad-proc
            v1 #f tl tb 0
            v2 #f tr tb 0
            v3 #f tr tt 0
            v4 #f tl tt 0
            uv
            texture-depth))
        
        (count-sphere)
        (loop (for i from 0 below stacks)
              (let ((theta (- (* dtheta (cast <fl> i)) 90.)))
                (loop (for j from 0 below slices)
                      (let ((phi (* dphi (cast <fl> j))))
                        (let ((v1 (vertex (* (cos (* theta DTOR)) (cos (* phi DTOR)))
                                          (* (cos (* theta DTOR)) (sin (* phi DTOR)))
                                          (sin (* theta DTOR))))
                              (v2 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* phi DTOR)))
                                          (* (cos (* (+ theta dtheta) DTOR)) (sin (* phi DTOR)))
                                          (sin (* (+ theta dtheta) DTOR))))
                              (v3 (unless (= i (- stacks 1))
                                    (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* (+ phi dphi) DTOR)))
                                            (* (cos (* (+ theta dtheta) DTOR)) (sin (* (+ phi dphi) DTOR)))
                                            (sin (* (+ theta dtheta) DTOR)))))
                              (v4 (unless (= i 0)
                                    (vertex (* (cos (* theta DTOR)) (cos (* (+ phi dphi) DTOR)))
                                            (* (cos (* theta DTOR)) (sin (* (+ phi dphi) DTOR)))
                                            (sin (* theta DTOR))))))
                          (if (and v3 v4)
                              (add-quad v4 v3 v2 v1)
                            (add-triangle (or v3 v4) v2 v1)))))))))))


(definition public (generate-sphere-mesh slices stacks uv (matrix: matrix #f) (neighbors?: neighbors? #f) (smooth-normals?: smooth-normals? #f) (material: material #f))
  (let ((generator (sphere-generator slices stacks uv)))
    (generate-mesh generator matrix: matrix neighbors?: neighbors? smooth-normals?: smooth-normals? material: material)))


;;;
;;;; Cylinder
;;;


(definition public (cylinder-generator slices <fx> stacks <fx> start-radius <fl> end-radius <fl> uv <f32vector>)
  (lambda (setup-proc triangle-proc quad-proc)
    (let ((dphi (/ 360. (cast <fl> slices)))
          (dside (/ 2. (cast <fl> stacks))))
      (define (count-cylinder)
        (let ((triangles 0)
              (quads (* slices stacks)))
          (setup-proc triangles quads)))
      
      (define add-triangle (wire-triangle triangle-proc))
      (define add-quad (wire-quad quad-proc))
      
      (let ((DTOR (/ PI*2 360.)))
        (count-cylinder)
        (loop (for i from 0 below stacks)
              (let ((side (- (* (cast <fl> i) dside) 1.))
                    (radius-from (/ (+ (* (cast <fl> i) start-radius)
                                       (* (cast <fl> (- stacks i)) end-radius))
                                    (cast <fl> stacks)))
                    (radius-to (/ (+ (* (cast <fl> (+ i 1)) start-radius)
                                     (* (cast <fl> (- stacks (+ i 1))) end-radius))
                                  (cast <fl> stacks))))
                (loop (for j from 0 below slices)
                      (let ((phi (* dphi (cast <fl> j))))
                        (let ((v1 (vertex (* radius-from (cos (* phi DTOR)))
                                          (* radius-from (sin (* phi DTOR)))
                                          side))
                              (v2 (vertex (* radius-to (cos (* phi DTOR)))
                                          (* radius-to (sin (* phi DTOR)))
                                          (+ side dside)))
                              (v3 (vertex (* radius-from (cos (* (+ phi dphi) DTOR)))
                                          (* radius-from (sin (* (+ phi dphi) DTOR)))
                                          side))
                              (v4 (vertex (* radius-to (cos (* (+ phi dphi) DTOR)))
                                          (* radius-to (sin (* (+ phi dphi) DTOR)))
                                          (+ side dside))))
                          (add-quad v1 v3 v4 v2))))))))))


(definition public (generate-cylinder-mesh slices stacks start-radius end-radius uv (matrix: matrix #f) (neighbors?: neighbors? #f) (smooth-normals?: smooth-normals? #f) (material: material #f))
  (let ((generator (cylinder-generator slices stacks start-radius end-radius uv)))
    (generate-mesh generator matrix: matrix neighbors?: neighbors? smooth-normals?: smooth-normals? material: material)))


;;;
;;;; Torus
;;;


(definition public (torus-generator slices <fx> stacks <fx> radius <fl> uv <f32vector>)
  (lambda (setup-proc triangle-proc quad-proc)
    (let ((dphi (/ 360. (cast <fl> slices)))
          (dtheta (/ PI*2 (cast <fl> stacks)))
          (dside (/ 2. (cast <fl> stacks))))
      (define (count-cylinder)
        (let ((triangles 0)
              (quads (* slices stacks)))
          (setup-proc triangles quads)))
      
      (define add-triangle (wire-triangle triangle-proc))
      (define add-quad (wire-quad quad-proc))
      
      (let ((up (vertex 0. 1. 0.))
            (DTOR (/ PI*2 360.)))
        (count-cylinder)
        (loop (for i from 0 below stacks)
              (let ((theta (* dtheta (cast <fl> i)))
                    (thetanext (* dtheta (cast <fl> (+ i 1))))
                    (side (- (* (cast <fl> i) dside) 1.)))
                (loop (for j from 0 below slices)
                      (let ((phi (* dphi (cast <fl> j))))
                        (let ((v1 (rotate-upon& theta
                                                up
                                                (vertex (- (* radius (cos (* phi DTOR))) 1.)
                                                        (* radius (sin (* phi DTOR)))
                                                        0.)))
                              (v2 (rotate-upon& thetanext
                                                up
                                                (vertex (- (* radius (cos (* phi DTOR))) 1.)
                                                        (* radius (sin (* phi DTOR)))
                                                        0.)))
                              (v3 (rotate-upon& theta
                                                up
                                                (vertex (- (* radius (cos (* (+ phi dphi) DTOR))) 1.)
                                                        (* radius (sin (* (+ phi dphi) DTOR)))
                                                        0.)))
                              (v4 (rotate-upon& thetanext
                                                up
                                                (vertex (- (* radius (cos (* (+ phi dphi) DTOR))) 1.)
                                                        (* radius (sin (* (+ phi dphi) DTOR)))
                                                        0.))))
                          (add-quad v1 v3 v4 v2))))))))))


(definition public (generate-torus-mesh slices stacks radius uv (matrix: matrix #f) (neighbors?: neighbors? #f) (smooth-normals?: smooth-normals? #f) (material: material #f))
  (let ((generator (torus-generator slices stacks radius uv)))
    (generate-mesh generator matrix: matrix neighbors?: neighbors? smooth-normals?: smooth-normals? material: material))))
