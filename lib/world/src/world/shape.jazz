;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Shapes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.shape jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.area)
        (world.autoload)
        (world.block)
        (world.generate)
        (world.geometry)
        (world.mesh)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Cone
;;;


@finish-conversion
(definition public (generate-cone p1 <f64vector> p2 <f64vector> r1 <fl> r2 <fl> m <fx> theta1 <fl> theta2 <fl>)
  (let ;; Normal pointing from p1 to p2
      ((n (vertex-& p1 p2)))
    ;; Create two perpendicular vectors perp and q on the plane of the disk
    (let ((perp n))
      (if (and (= (vertex-x n) 0.) (= (vertex-z n) 0.))
          (vertex-x-set! n (+ (vertex-x n) 1))
        (vertex-y-set! n (+ (vertex-y n) 1)))
      (let ((perp (cross-product& n q)))
        (let ((n (cross-product& q perp)))
          (vertex-normalize! perp perp)
          (vertex-normalize! q q)
          (glBegin GL_QUAD_STRIP)
          (loop (for i from 0 to m)
                (let ((theta (+ theta1 (/ (* i (- theta2 theta1)) m))))
                  (vertex-x-set! n (+ (* (cos theta) perp.x) (* (sin theta) q.x)))
                  (vertex-y-set! n (+ (* (cos theta) perp.y) (* (sin theta) q.y)))
                  (vertex-z-set! n (+ (* (cos theta) perp.z) (* (sin theta) q.z)))
                  (vertex-normalize! n n)
                  
                  p.x = p2.x + r2 * n.x
                  p.y = p2.y + r2 * n.y
                  p.z = p2.z + r2 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 1.0)
                  glVertex3f(p.x p.y p.z)
                  
                  p.x = p1.x + r1 * n.x
                  p.y = p1.y + r1 * n.y
                  p.z = p1.z + r1 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 0.0)
                  glVertex3f(p.x p.y p.z)))
          (glEnd))))))


;;;
;;;; Triangle
;;;


;; for tests
(definition public (triangle-generator (matrix: matrix #f))
  (let ((world (current-world)))
    (let ((uv (image-rect~ (get-block-atlas~ world) "dirty")))
      (lambda (setup-proc triangle-proc quad-proc)
        (setup-proc 1 0)
        (let ((v1 (vertex -1. 0. 0.))
              (v2 (vertex  1. 0. 0.))
              (v3 (vertex  0. 1. 0.))
              (tl (uv-left uv))
              (tt (uv-top uv))
              (tr (uv-right uv))
              (tb (uv-bottom uv))
              (tdepth (uv-depth uv)))
          (triangle-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            tdepth))))))


;;;
;;;; Sphere
;;;


(definition public (uv-sphere-generator slices stacks uv <f32vector>)
  (lambda (setup-proc triangle-proc quad-proc)
    (let ((dphi <fl> (/ 360. slices))
          (dtheta <fl> (/ 180. stacks))
          (adjust 4.38))
      (define (count-sphere)
        (let ((triangles 0)
              (quads 0))
          (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
                (loop (for phi <fl> from adjust to (- (+ 360.1 adjust) dphi) by dphi)
                      (if (and (> theta -90.) (< theta 90.))
                          (increase! quads)
                        (increase! triangles))))
          (setup-proc triangles quads)))
      
      (let ((DTOR (/ PI*2 360.))
            (tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv)))
        (define (add-triangle v1 v2 v3)
          (triangle-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            texture-depth))
        
        (define (add-quad v1 v2 v3 v4)
          (quad-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            v4 #f tl tt
            texture-depth))
        
        (count-sphere)
        (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
              (loop (for phi <fl> from adjust to (- (+ 360.1 adjust) dphi) by dphi)
                    (let ((v1 (vertex (* (cos (* theta DTOR)) (cos (* phi DTOR)))
                                      (* (cos (* theta DTOR)) (sin (* phi DTOR)))
                                      (sin (* theta DTOR))))
                          (v2 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* phi DTOR)))
                                      (* (cos (* (+ theta dtheta) DTOR)) (sin (* phi DTOR)))
                                      (sin (* (+ theta dtheta) DTOR))))
                          (v3 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* (+ phi dphi) DTOR)))
                                      (* (cos (* (+ theta dtheta) DTOR)) (sin (* (+ phi dphi) DTOR)))
                                      (sin (* (+ theta dtheta) DTOR))))
                          (v4 (when (and (> theta -90.) (< theta 90.))
                                (vertex (* (cos (* theta DTOR)) (cos (* (+ phi dphi) DTOR)))
                                        (* (cos (* theta DTOR)) (sin (* (+ phi dphi) DTOR)))
                                        (sin (* theta DTOR))))))
                      (if v4
                          (add-quad v4 v3 v2 v1)
                        (add-triangle v3 v2 v1)))))))))


@new-still-buggy
(definition public (uv-sphere-generator slices stacks uv <f32vector>)
  (lambda (setup-proc triangle-proc quad-proc)
    (let ((dphi <fl> (/ 360. slices))
          (dtheta <fl> (/ 180. stacks)))
      (define (count-sphere)
        (let ((triangles (* slices 2))
              (quads (* slices (- stacks 2))))
          (setup-proc triangles quads)))
      
      (let ((DTOR (/ PI*2 360.))
            (tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv)))
        (define (add-triangle v1 v2 v3)
          (triangle-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            texture-depth))
        
        (define (add-quad v1 v2 v3 v4)
          (quad-proc
            v1 #f tl tb
            v2 #f tr tb
            v3 #f tr tt
            v4 #f tl tt
            texture-depth))
        
        (count-sphere)
        (loop (for i from 0 below stacks)
              (let ((theta (- (* dtheta (cast <fl> i)) 90.)))
                (loop (for j from 0 below slices)
                      (let ((phi (* dphi (cast <fl> j))))
                        (let ((v1 (vertex (* (cos (* theta DTOR)) (cos (* phi DTOR)))
                                          (* (cos (* theta DTOR)) (sin (* phi DTOR)))
                                          (sin (* theta DTOR))))
                              (v2 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* phi DTOR)))
                                          (* (cos (* (+ theta dtheta) DTOR)) (sin (* phi DTOR)))
                                          (sin (* (+ theta dtheta) DTOR))))
                              (v3 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* (+ phi dphi) DTOR)))
                                          (* (cos (* (+ theta dtheta) DTOR)) (sin (* (+ phi dphi) DTOR)))
                                          (sin (* (+ theta dtheta) DTOR))))
                              (v4 (when (and (> theta -90.) (< theta (- 90. dtheta .1)))
                                    (vertex (* (cos (* theta DTOR)) (cos (* (+ phi dphi) DTOR)))
                                            (* (cos (* theta DTOR)) (sin (* (+ phi dphi) DTOR)))
                                            (sin (* theta DTOR))))))
                          (if v4
                              (add-quad v4 v3 v2 v1)
                            (add-triangle v3 v2 v1)))))))))))


(definition public (generate-sphere-mesh slices stacks uv (matrix: matrix #f) (neighbors?: neighbors? #f) (smooth-normals?: smooth-normals? #f) (material: material #f))
  (let ((generator (uv-sphere-generator slices stacks uv)))
    (generate-mesh generator matrix: matrix neighbors?: neighbors? smooth-normals?: smooth-normals? material: material)))


;;;
;;;; Floor
;;;


(definition public (generate-floor x y z width depth)
  (let ((zone (current-zone)))
    (loop (for i from (- width) to width)
          (loop (for j from (- depth) to depth)
                (let ((x (+ x i))
                      (z (+ z j)))
                  (add-element~ zone
                    (new Quad-Block
                      v1: (vertex x y (+ z 1.))
                      v2: (vertex (+ x 1.) y (+ z 1.))
                      v3: (vertex (+ x 1.) y z)
                      v4: (vertex x y z)
                      parent: zone)))))))


;;;
;;;; Wall
;;;


(definition public (generate-wall x y z width height)
  (let ((zone (current-zone)))
    (loop (for i from (- width) to width)
          (loop (for j from (- height) to height)
                (let ((x (+ x i))
                      (y (+ y j)))
                  (add-element~ zone
                    (new Quad-Block
                      v1: (vertex x (+ y 1.) z)
                      v2: (vertex (+ x 1.) (+ y 1.) z)
                      v3: (vertex (+ x 1.) y z)
                      v4: (vertex x y z)
                      parent: zone)))))))


;;;
;;;; Slope
;;;


(definition public (generate-slope x y z height x-count z-count)
  (let ((zone (current-zone)))
    (let ((width 1.)
          (depth 1.))
      (loop (for d from 0 below z-count)
            (loop (for i from 0 below x-count)
                  (let ((x (+ x (* i width)))
                        (y (+ y (* d height)))
                        (z (+ z (* d depth))))
                    (add-element~ zone
                      (new Quad-Block
                        v1: (vertex x (+ y height) (+ z depth))
                        v2: (vertex (+ x width) (+ y height) (+ z depth))
                        v3: (vertex (+ x width) y z)
                        v4: (vertex x y z)
                        parent: zone))))))))


;;;
;;;; Stairs
;;;


(definition public (generate-stairs stairs x y z width height depth x-count y-count z-count)
  (let ((zone (current-zone)))
    (loop (for d from 0 below stairs)
          (loop (for i from (- x-count) to x-count)
                (let ((x (+ x (* i width)))
                      (y (+ y (* d height)))
                      (z (+ z (* d (* depth z-count)))))
                  ;; front
                  (add-element~ zone
                    (new Quad-Block
                      v1: (vertex x (+ y height) z)
                      v2: (vertex (+ x width) (+ y height) z)
                      v3: (vertex (+ x width) y z)
                      v4: (vertex x y z)
                      parent: zone))
                  ;; flat
                  (loop (for n from 0 below z-count)
                        (let ((z (+ z (* n depth))))
                          (add-element~ zone
                            (new Quad-Block
                              v1: (vertex x (+ y height) (+ z depth))
                              v2: (vertex (+ x width) (+ y height) (+ z depth))
                              v3: (vertex (+ x width) (+ y height) z)
                              v4: (vertex x (+ y height) z)
                              parent: zone))))))))))
