;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Changes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.change jazz


(import (world)
        (world.context)
        (world.part)
        (world.support))


(proclaim (not check bounds)
          (warn optimizations))


(class Change extends Object
  
  
  (slot name                 getter generate)
  (slot id              <fx> getter generate)
  (slot action-count    <fx> getter generate)
  (slot action-layout        getter generate)
  (slot action-store         getter generate)
  (slot action-apply         getter generate)
  (slot forward-count   <fx> getter generate)
  (slot forward-layout       getter generate)
  (slot forward-store        getter generate)
  (slot forward-apply        getter generate)
  (slot backward-count  <fx> getter generate)
  (slot backward-layout      getter generate)
  (slot backward-store       getter generate)
  (slot backward-apply       getter generate)
  
  
  (method override (initialize self name id action-layout action-store action-apply forward-layout forward-store forward-apply backward-layout backward-store backward-apply)
    (set! self.name name)
    (set! self.id id)
    (set! self.action-count (count-layout action-layout))
    (set! self.action-layout action-layout)
    (set! self.action-store action-store)
    (set! self.action-apply action-apply)
    (set! self.forward-count (count-layout forward-layout))
    (set! self.forward-layout forward-layout)
    (set! self.forward-store forward-store)
    (set! self.forward-apply forward-apply)
    (set! self.backward-count (count-layout backward-layout))
    (set! self.backward-layout backward-layout) 
    (set! self.backward-store backward-store)
    (set! self.backward-apply backward-apply))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition protected changes <table>
  (make-table test: eq?))

(definition protected changeids <vector>
  (make-vector 256 #f))


(definition public inline (name->change name) <Change>
  (table-ref changes name))

(definition public inline (id->change id <fx>) <Change>
  (vector-ref changeids id))


(definition next-change-id <fx>
  0)

(definition (next-change-id!) <fx>
  (prog1 next-change-id
    (increase! next-change-id)))


(definition protected (register-change name (action-layout: action-layout '()) (action-store: action-store #f) (action-apply: action-apply #f) (forward-layout: forward-layout '()) (forward-store: forward-store #f) (forward-apply: forward-apply #f) (backward-layout: backward-layout '()) (backward-store: backward-store #f) (backward-apply: backward-apply #f))
  (let ((id <fx>
          ;; support dynamic evaluation
          (let ((actual (table-ref changes name #f)))
              (if actual
                  (get-id actual)
                (next-change-id!)))))
    (let ((change (new Change name id action-layout action-store action-apply forward-layout forward-store forward-apply backward-layout backward-store backward-apply)))
      (table-set! changes name change)
      (vector-set! changeids id change)
      (unspecified))))


(definition public (record-change? entity)
  (if (client?)
      (eq? entity (current-me))
    #t))


(definition public (snapshot-metadata? entity)
  (eq? entity (current-me+)))


(definition public (bidirectional-change name time action forward backward (metadata: metadata #f))
  (let ((history (current-history)))
    (let ((change (name->change name)))
      (let ((id (get-id change))
            (action-store (get-action-store change))
            (forward-store (get-forward-store change))
            (backward-store (get-backward-store change)))
        (add-change history time id
          (lambda (push)
            (when action-store
              (action action-store push)))
          (lambda (push)
            (forward forward-store push))
          (lambda (push)
            (when backward-store
              (backward backward-store push)))
          metadata)))))


(definition public (bidirectional-size change <Change>) <fx>
  (+ (get-action-count change)
     (get-forward-count change)
     (get-backward-count change)))


(definition protected (max-bidirectional-size) <fx>
  (let ((max -1))
    (table-iterate changes
      (lambda (name change)
        (let ((size (bidirectional-size change)))
          (when (> size max)
            (set! max size)))))
    max))


(definition public (update-size change <Change>) <fx>
  (+ 6
     (get-forward-count change)
     (get-backward-count change)))


(definition public (action-change client-id id pop)
  (let ((change (id->change id)))
    (let ((action (get-action-apply change)))
      (action client-id pop))))
  

(definition public (forward-change client-id id pop)
  (let ((change (id->change id)))
    (let ((forward (get-forward-apply change)))
      (forward client-id pop))))


(definition public (backward-change client-id id pop)
  (let ((change (id->change id)))
    (let ((backward (get-backward-apply change)))
      ;; quicky until all changes have backward
      (when backward
        (backward client-id pop)))))


;; high-level for debugging
(definition protected (iterate-changes changes <f64vector> proc)
  (let ((len (f64vector-length changes)))
    (let (iter (offset 0))
      (when (< offset len)
        (let ((change (id->change (flonum->fixnum (f64vector-ref changes (+ offset 4))))))
          (proc change offset)
          (iter (+ offset (update-size change))))))))


;; high-level for debugging
(definition protected (show-changes changes <f64vector>)
  (let ((first #f)
        (last #f))
    (iterate-changes changes
      (lambda (change offset)
        (let ((sequence-no (flonum->fixnum (f64vector-ref changes (+ offset 5)))))
          (when (not first)
            (set! first sequence-no))
          (when last
            (when (<= sequence-no last)
              (terminal 'out-of-sequence (current-thread) sequence-no 'with last)
              (break)))
          (set! last sequence-no))))
    @debug
    (terminal '******************** 'sequence-no (current-thread) first last)))


;; high-level for debugging
(definition protected (collect-changes changes <f64vector>)
  (let ((queue (new-queue)))
    (iterate-changes changes
      (lambda (change offset)
        (enqueue queue (get-name change))))
    (queue-list queue)))


;; debug sequence
(definition protected last-forward <fx>
  -1)

(definition protected (reset-last-forward)
  (set! last-forward -1))


(definition protected (forward-changes network-sent <fl> network-received <fl> changes <f64vector>)
  (declare (proper-tail-calls))
  (let ((history (current-history)))
    (let ((len (f64vector-length changes))
          (offset 0))
      (when debug-sequence?
        (unless (server?)
          (show-changes changes)))
      (let (iter)
        (when (< offset len)
          (let ((time (f64vector-ref changes offset))
                (sent (f64vector-ref changes (+ offset 1)))
                (received (f64vector-ref changes (+ offset 2)))
                (clnt-id (flonum->fixnum (f64vector-ref changes (+ offset 3))))
                (change-id (flonum->fixnum (f64vector-ref changes (+ offset 4))))
                (sequence-no (flonum->fixnum (f64vector-ref changes (+ offset 5)))))
            (when debug-sequence?
              (let ((last-no last-forward))
                (when (<= sequence-no last-no)
                  (terminal 'out-of-sequence (current-thread) sequence-no 'with last-no)
                  (break)))
              (set! last-forward sequence-no))
            (increase! offset 6)
            ;; this way if client B is receiving a change from client A
            ;; we get the time A sent the change and the time B received it
            (let ((change (id->change change-id)))
              ;; ignore our own changes
              (if (= client-no clnt-id)
                  (increase! offset (get-forward-count change))
                (let ((effective-sent (if (nan? sent) network-sent sent))
                      (effective-received network-received))
                  (add-incoming history time effective-sent effective-received clnt-id change-id sequence-no changes offset))
                (forward-change clnt-id change-id
                  (lambda ()
                    (prog1 (f64vector-ref changes offset)
                      (increase! offset)))))
              ;; skip backward for now
              (increase! offset (get-backward-count change))))
          (iter)))))))
