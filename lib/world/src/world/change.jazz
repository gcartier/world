;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Changes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.change jazz


(import (world)
        (world.autoload)
        (world.syntax (phase syntax)))


(class Change extends Object
  
  
  (slot name                getter generate)
  (slot id             <fx> getter generate)
  (slot action-count        getter generate)
  (slot action-store        getter generate)
  (slot action-apply        getter generate)
  (slot forward-count       getter generate)
  (slot forward-store       getter generate)
  (slot forward-apply       getter generate)
  (slot backward-count      getter generate)
  (slot backward-store      getter generate)
  (slot backward-apply      getter generate)
  
  
  (method override (initialize name id action-count action-store action-apply forward-count forward-store forward-apply backward-count backward-store backward-apply)
    (set! name~self name)
    (set! id~self id)
    (set! action-count~self action-count)
    (set! action-store~self action-store)
    (set! action-apply~self action-apply)
    (set! forward-count~self forward-count)
    (set! forward-store~self forward-store)
    (set! forward-apply~self forward-apply)
    (set! backward-count~self backward-count) 
    (set! backward-store~self backward-store)
    (set! backward-apply~self backward-apply))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition protected changes <table>
  (make-table test: eq?))

(definition protected changeids <vector>
  (make-vector 256 #f))


(definition next-change-id <fx>
  0)

(definition (next-change-id!)
  (prog1 next-change-id
    (increase! next-change-id)))


(definition protected (register-change name (action-count: action-count 0) (action-store: action-store #f) (action-apply: action-apply #f) (forward-count: forward-count 0) (forward-store: forward-store #f) (forward-apply: forward-apply #f) (backward-count: backward-count 0) (backward-store: backward-store #f) (backward-apply: backward-apply #f))
  (let ((id ;; support dynamic evaluation
          (let ((actual (table-ref changes name #f)))
              (if actual
                  (get-id~ actual)
                (next-change-id!)))))
    (let ((change (new Change name id action-count action-store action-apply forward-count forward-store forward-apply backward-count backward-store backward-apply)))
      (table-set! changes name change)
      (vector-set! changeids id change)
      (unspecified))))


(definition public inline (name->change name) <Change>
  (table-ref changes name))

(definition public inline (id->change id <fx>) <Change>
  (vector-ref changeids id))


(definition public (record-change? entity)
  (if (client?)
      (eq? entity (current-me))
    #t))


(definition public (snapshot-metadata? entity)
  (eq? entity (current-me+)))


(definition public (bidirectional-change name time action forward backward (metadata: metadata #f))
  (let ((history (current-history)))
    (let ((change (name->change name)))
      (let ((id (get-id~ change))
            (action-store (get-action-store~ change))
            (forward-store (get-forward-store~ change))
            (backward-store (get-backward-store~ change)))
        (add-change~ history time id
          (lambda (push)
            (when action-store
              (action action-store push)))
          (lambda (push)
            (forward forward-store push))
          (lambda (push)
            (when backward-store
              (backward backward-store push)))
          metadata)))))


(definition public (bidirectional-size change)
  (+ (get-action-count~ change)
     (get-forward-count~ change)
     (get-backward-count~ change)))


(definition protected (max-bidirectional-size)
  (let ((max -1))
    (iterate-table changes
      (lambda (name change)
        (let ((size (bidirectional-size change)))
          (when (> size max)
            (set! max size)))))
    max))
  

(definition public (action-change client-id id pop)
  (let ((change (id->change id)))
    (let ((action (get-action-apply~ change)))
      (action client-id pop))))
  

(definition public (forward-change client-id id pop)
  (let ((change (id->change id)))
    (let ((forward (get-forward-apply~ change)))
      (forward client-id pop))))


(definition public (backward-change client-id id pop)
  (let ((change (id->change id)))
    (let ((backward (get-backward-apply~ change)))
      ;; quicky until all changes have backward
      (when backward
        (backward client-id pop)))))


(definition protected (forward-changes changes)
  (let ((len (f64vector-length changes))
        (offset 0))
    (let (iter)
      (when (< offset len)
        (let ((time (f64vector-ref changes offset))
              (clnt-id (flonum->fixnum (f64vector-ref changes (+ offset 1))))
              (change-id (flonum->fixnum (f64vector-ref changes (+ offset 2)))))
          (increase! offset 3)
          (let ((change (id->change change-id)))
            ;; ignore our own changes
            (if (and client-no (= client-no clnt-id))
                (increase! offset (get-forward-count~ change))
              (forward-change clnt-id change-id
                (lambda ()
                  (prog1 (f64vector-ref changes offset)
                    (increase! offset)))))
            ;; skip backward for now
            (increase! offset (get-backward-count~ change))))
        (iter))))))
