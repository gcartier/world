;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Changes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.change jazz


(import (world)
        (world.context)
        (world.part)
        (world.settings)
        (world.support))


(proclaim (not check bounds)
          (warn optimizations))


(definition debug-changes?
  (world-setting 'world.debug-changes? #f))


(class Change extends Object
  
  
  (slot name                 getter generate)
  (slot id              <fx> getter generate)
  (slot droppable?           getter generate)
  (slot action-count    <fx> getter generate)
  (slot action-layout        getter generate)
  (slot action-store         getter generate)
  (slot action-apply         getter generate)
  (slot forward-count   <fx> getter generate)
  (slot forward-layout       getter generate)
  (slot forward-store        getter generate)
  (slot forward-apply        getter generate)
  (slot backward-count  <fx> getter generate)
  (slot backward-layout      getter generate)
  (slot backward-store       getter generate)
  (slot backward-apply       getter generate)
  
  
  (method override (initialize self name id droppable? action-layout action-store action-apply forward-layout forward-store forward-apply backward-layout backward-store backward-apply)
    (set! self.name name)
    (set! self.id id)
    (set! self.droppable? droppable?)
    (set! self.action-count (count-layout action-layout))
    (set! self.action-layout action-layout)
    (set! self.action-store action-store)
    (set! self.action-apply action-apply)
    (set! self.forward-count (count-layout forward-layout))
    (set! self.forward-layout forward-layout)
    (set! self.forward-store forward-store)
    (set! self.forward-apply forward-apply)
    (set! self.backward-count (count-layout backward-layout))
    (set! self.backward-layout backward-layout) 
    (set! self.backward-store backward-store)
    (set! self.backward-apply backward-apply))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition protected changes <table>
  (make-table test: eq?))

(definition protected changeids <vector>
  (make-vector 256 #f))


(definition public inline (name->change name) <Change>
  (table-ref changes name))

(definition public inline (id->change id <fx>) <Change>
  (vector-ref changeids id))


(definition next-change-id <fx>
  0)

(definition (next-change-id!) <fx>
  (prog1 next-change-id
    (increase! next-change-id)))


(definition protected (register-change name (droppable?: droppable? #f) (action-layout: action-layout '()) (action-store: action-store #f) (action-apply: action-apply #f) (forward-layout: forward-layout '()) (forward-store: forward-store #f) (forward-apply: forward-apply #f) (backward-layout: backward-layout '()) (backward-store: backward-store #f) (backward-apply: backward-apply #f))
  (let ((id <fx>
          ;; support dynamic evaluation
          (let ((actual (table-ref changes name #f)))
              (if actual
                  (get-id actual)
                (next-change-id!)))))
    (let ((change (new Change name id droppable? action-layout action-store action-apply forward-layout forward-store forward-apply backward-layout backward-store backward-apply)))
      (table-set! changes name change)
      (vector-set! changeids id change)
      (unspecified))))


(definition public (record-change? entity)
  (if (client?)
      (eq? entity (current-me))
    #t))


(definition public (snapshot-metadata? entity)
  (eq? entity (current-me+)))


(definition public (bidirectional-change name time action forward backward (metadata: metadata #f))
  (let ((history (current-history)))
    (let ((change (name->change name)))
      (let ((id (get-id change))
            (droppable? (get-droppable? change))
            (action-store (get-action-store change))
            (forward-store (get-forward-store change))
            (backward-store (get-backward-store change)))
        (add-change history time id droppable?
          (lambda (push)
            (when action-store
              (action action-store push)))
          (lambda (push)
            (forward forward-store push))
          (lambda (push)
            (when backward-store
              (backward backward-store push)))
          metadata)))))


(definition public (bidirectional-size change <Change>) <fx>
  (+ (get-action-count change)
     (get-forward-count change)
     (get-backward-count change)))


(definition protected (max-bidirectional-size) <fx>
  (let ((max -1))
    (iterate-table changes
      (lambda (name change)
        (let ((size (bidirectional-size change)))
          (when (> size max)
            (set! max size)))))
    max))


(definition public (update-size change <Change>) <fx>
  (+ 6
     (get-forward-count change)
     (get-backward-count change)))


(definition public (action-change client-id id pop)
  (let ((change (id->change id)))
    (let ((action (get-action-apply change)))
      (action client-id pop))))
  

(definition public (forward-change client-id id pop)
  (let ((change (id->change id)))
    (let ((forward (get-forward-apply change)))
      (forward client-id pop))))


(definition public (backward-change client-id id pop)
  (let ((change (id->change id)))
    (let ((backward (get-backward-apply change)))
      ;; quicky until all changes have backward
      (when backward
        (backward client-id pop)))))


(definition protected (forward-changes network-sent <fl> network-received <fl> changes <vector>)
  (declare (proper-tail-calls))
  (let ((history (current-history)))
    (let ((len (vector-length changes))
          (offset 0))
      (let (iter)
        (when (< offset len)
          (let ((time (vector-ref changes offset))
                (sent (vector-ref changes (+ offset 1)))
                (received (vector-ref changes (+ offset 2)))
                (clnt-id (vector-ref changes (+ offset 3)))
                (change-id (vector-ref changes (+ offset 4))))
            (increase! offset 5)
            ;; this way if client B is receiving a change from client A
            ;; we get the time A sent the change and the time B received it
            (let ((change (id->change change-id)))
              ;; ignore our own changes
              (if (= client-no clnt-id)
                  (increase! offset (get-forward-count change))
                (let ((effective-sent (if (nan? sent) network-sent sent))
                      (effective-received network-received))
                  (add-incoming history time effective-sent effective-received clnt-id change-id changes offset))
                (when debug-changes?
                  (let ((name (get-name change)))
                    (unless (memq? name '(move lookat animate))
                      (tell name))))
                (forward-change clnt-id change-id
                  (lambda ()
                    (prog1 (vector-ref changes offset)
                      (increase! offset)))))
              ;; skip backward for now
              (increase! offset (get-backward-count change))))
          (iter)))))))
