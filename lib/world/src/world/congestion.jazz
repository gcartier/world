;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World UDP Congestion
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


;;  Adapted from https://tools.ietf.org/id/draft-cardwell-iccrg-bbr-congestion-control-00.html
(module world.congestion jazz


(import (jazz.debuggee)
        (jazz.math)
        (world.event)
        (world.rate)
        (world.udp))


(proclaim (generate))


(constant MSEC_PER_SEC
  1000)


;; The Sender Maximum Segment Size.
(constant SMSS <fx>
  1500)

;; A constant specifying the length of the BBR.BtlBw max filter window for BBR.BtlBwFilter, BtlBwFilterLen is 10 packet-timed round trips.
(constant BtlBwFilterLen <fx>
  10)

;; A constant specifying the length of the MinRTT filter window, MinRTTFilterLen is 10 secs.
(constant MinRTTFilterLen <fl>
  10.)

;; A constant specifying the minimum gain value that will allow the sending rate to double each round (2/ln(2) ~= 2.89), used in Startup mode for both BBR.pacing_gain and BBR.cwnd_gain.
(constant HighGain <fl>
  (/ 2 (log 2)))

;; The minimal cwnd value BBR tries to target using: 4 packets, or 4 * SMSS
(constant MinPipeCwnd <fx>
  (* 4 SMSS))

;; The phases in the BBR ProbeBW gain cycle.
(definition GainCycle <vector>
  (vector-map exact->inexact (vector 5/4 3/4 1 1 1 1 1 1)))

;; The number of phases in the BBR ProbeBW gain cycle.
(definition GainCycleLen <fx>
  (vector-length GainCycle))

;; A constant specifying the minimum duration for which ProbeRTT state holds inflight to BBRMinPipeCwnd or fewer packets: 200 ms.
(constant ProbeRTTDuration <fl>
  (exact->inexact (/ 200 MSEC_PER_SEC)))


(definition InitialRTT <fl> (exact->inexact (/ 1 MSEC_PER_SEC)))
(definition InitialCwnd <fx> 125)
(definition InLossRecovery #f) ;; todo
(definition PacketsLost <fx> 0) ;; todo may be important for ending phase of gain > 1 but leave at 0 for now


;;;
;;;; Congestion
;;;


(class UDP-Congestion extends Object
  
  
  (slot cs                    <object> getter generate)
  (slot state                 <object> getter generate)
  (slot send-quantum          <fx>     getter generate)   ;; The maximum size of a data aggregate scheduled and transmitted together.
  (slot btlbw                 <fl>     getter generate)   ;; BBR's estimated bottleneck bandwidth available to the transport flow, estimated from the maximum delivery rate sample in a sliding window.
  (slot btlbw-filter          <object> getter generate)   ;; The max filter used to estimate BBR.BtlBw.
  (slot minrtt                <fl>     getter generate)   ;; BBR's estimated two-way round-trip propagation delay of the path, estimated from the windowed minimum recent round-trip delay sample.
  (slot minrtt-stamp          <fl>     getter generate)   ;; The wall clock time at which the current BBR.MinRTT sample was obtained.
  (slot minrtt-expired?       <bool>   getter generate)   ;; A boolean recording whether the BBR.MinRTT has expired and is due for a refresh with an application idle period or a transition into ProbeRTT state.
  (slot pacing-gain           <fl>     getter generate)   ;; The dynamic gain factor used to scale BBR.BtlBw to produce BBR.pacing_rate.
  (slot pacing-cycle-stamp    <fl>     getter generate)
  (slot pacing-cycle-index    <fx>     getter generate)
  (slot pacing-rate           <fl>     getter generate)   ;; The current pacing rate for a BBR flow, which controls inter-packet spacing.
  (slot cwnd-gain             <fl>     getter generate)   ;; The dynamic gain factor used to scale the estimated BDP to produce a congestion window (cwnd).
  (slot cwnd                  <fl>     getter generate)   ;; The transport sender's congestion window, which limits the amount of data in flight.
  (slot prior-cwnd            <fl>     getter generate)
  (slot target-cwnd           <fl>     getter generate)
  (slot full-reached?         <bool>   getter generate)   ;; A boolean that records whether BBR estimates that it has ever fully utilized its available bandwidth ("filled the pipe").
  (slot full-bw               <fl>     getter generate)
  (slot full-bw-count         <fx>     getter generate)
  (slot round-count           <fx>     getter generate)   ;; Count of packet-timed round trips.
  (slot round-start?          <bool>   getter generate)   ;; A boolean that BBR sets to true once per packet-timed round trip, on ACKs that advance BBR.round_count.
  (slot next-round-delivered  <fx>     getter generate)   ;; packet.delivered value denoting the end of a packet-timed round trip.
  (slot probe-rtt-done-stamp  <fl>     getter generate)
  (slot probe-rtt-round-done? <bool>   getter generate)
  (slot idle-restart?         <bool>   getter generate)
  (slot delivered             <fx>     getter generate)
  
  
  (method public (init self conn-state sq <fx>)
    (set! btlbw-filter (new Windowed-MinMax))
    (set! btlbw (reset btlbw-filter 0 0))
    (set! cs conn-state)
    (set! state #f)
    (set! send-quantum sq)
    (set! minrtt +inf.0)
    (set! minrtt-stamp (current-seconds))
    (set! pacing-gain 1.)
    (set! pacing-rate 0.)
    (set! delivered 0)
    (set! probe-rtt-done-stamp 0)
    (set! probe-rtt-round-done? #f)
    (set! cwnd MinPipeCwnd)
    (set! target-cwnd MinPipeCwnd)
    (set! prior-cwnd 0)
    (set! idle-restart? #f)
    (init-round-counting self)
    (init-full-pipe self)
    (init-pacing-rate self)
    (enter-startup self))
  
  
  (method (change-state self value)
    (define states
      '(Startup Drain ProbeBW ProbeRTT))
    
    (when (neq? value state)
      (set! state value)
      (record-event udp-id-congestion-state
                    -1.
                    -1.
                    -1.
                    -1.
                    (fixnum->flonum (find states value))
                    -1.
                    -1.)))
  
  
  (method (change-pacing-rate self value)
    (when (/= value pacing-rate)
      (set! pacing-rate value)
      ;(format :terminal "{r precision: 3}{%}" (bytes->mbps value))
      (record-event udp-id-congestion-pacing
                    -1.
                    -1.
                    -1.
                    -1.
                    (bytes->mbps value)
                    -1.
                    -1.)))
  
  
  (method (change-cwnd self value)
    (when (/= value cwnd)
      (set! cwnd value)
      (record-event udp-id-congestion-window
                    -1.
                    -1.
                    -1.
                    -1.
                    (bytes->mbps value)
                    -1.
                    -1.)))
  
  
  ;;;
  ;;;; Startup
  ;;;
  
  
  (method (enter-startup self)
    (change-state self 'Startup)
    (set! pacing-gain HighGain)
    (set! cwnd-gain HighGain))
  
  
  ;;;
  ;;;; Transmit
  ;;;
  
  
  (method public (packet-sent self)
    (handle-restart-from-idle self))
    
  
  (method (handle-restart-from-idle self)
    (when (and (= (get-inflight cs) 0) (> (get-app-limited cs) 0))
      (set! idle-restart? #t)
      (when (eq? state 'ProbeBW)
        (set-pacing-rate-with-gain self 1))))
  
  
  ;;;
  ;;;; ACK
  ;;;
  
  
  (method public (ack-received self rs packet)
    (update-model-and-state self rs packet)
    (update-control-parameters self packet))

  
  (method (update-model-and-state self rs packet)
    (update-btlbw self rs packet)
    (check-cycle-phase self)
    (check-full-pipe self rs)
    (check-drain self packet)
    (update-minrtt self packet)
    (check-probertt self))

  
  (method (update-control-parameters self packet)
    (update-pacing-rate self)
    (update-cwnd self packet))
  
  
  ;;;
  ;;;; Bottleneck Bandwidth
  ;;;
  
  
  (method (update-btlbw self rs packet)
    (update-round self packet)
    (when (or (not (get-app-limited? rs))
              (>= (get-delivery-rate rs) btlbw))
      (set! btlbw (running-max btlbw-filter
                    BtlBwFilterLen
                    round-count
                    (get-delivery-rate rs)))))

  
  (method (init-round-counting self)
    (set! next-round-delivered 0)
    (set! round-start? #f)
    (set! round-count 0))
  
  
  (method (update-round self packet)
    (increase! delivered (get-size packet))
    (cond ((>= (get-delivered packet) next-round-delivered)
           (set! next-round-delivered delivered)
           (increase! round-count)
           (set! round-start? #t))
          (else
           (set! round-start? #f))))
  
  
  ;;;
  ;;;; Cycle Phase
  ;;;
  
  
  (method (check-cycle-phase self)
    (when (and (eq? state 'ProbeBW) (next-cycle-phase? self))
      (advance-cycle-phase self)))

  
  (method (next-cycle-phase? self)
    (let ((full-length? (> (- (current-seconds) pacing-cycle-stamp) minrtt)))
      (cond ((= pacing-gain 1)
             full-length?)
            ((> pacing-gain 1)
             (and full-length?
                  (or (> PacketsLost 0)
                      (>= (get-prior-inflight cs) (estimate-target-cwnd self pacing-gain)))))
            (else
             (or full-length?
                 (<= (get-prior-inflight cs) (estimate-target-cwnd self 1)))))))

  
  (method (advance-cycle-phase self)
    (set! pacing-cycle-stamp (current-seconds))
    (set! pacing-cycle-index (modulo (+ pacing-cycle-index 1) GainCycleLen))
    (set! pacing-gain (vector-ref GainCycle pacing-cycle-index)))
  
  
  ;;;
  ;;;; Full Pipe
  ;;;
  
  
  (method (init-full-pipe self)
    (set! full-reached? #f)
    (set! full-bw 0)
    (set! full-bw-count 0))
  
  
  (method (check-full-pipe self rs)
    (cond ;; no need to check for a full pipe now
          ((or full-reached?
               (not round-start?)
               (get-app-limited? rs)))
          ;; BBR.BtlBw still growing?
          ((>= btlbw (* full-bw 1.25))
           (set! full-bw btlbw)         ;; record new baseline level
           (set! full-bw-count 0))
          ;; another round w/o much growth
          (else
           (increase! full-bw-count)
           (when (>= full-bw-count 3)
             (set! full-reached? #t)))))
  
  
  ;;;
  ;;;; Drain
  ;;;
  
  
  (method (check-drain self packet)
    (when (and (eq? state 'Startup) full-reached?)
      (enter-drain self))
    ;; we estimate queue is drained
    (when (and (eq? state 'Drain) (<= (get-inflight cs) (estimate-target-cwnd self 1.0)))
      (enter-probebw self)))
  
  
  (method (enter-drain self)
    (change-state self 'Drain)
    (set! pacing-gain (/ 1 HighGain))  ;; pace slowly
    (set! cwnd-gain HighGain))         ;; maintain cwnd
  
  
  ;;;
  ;;;; Min RTT
  ;;;
  
  
  (method (update-minrtt self packet)
    (set! minrtt-expired? (> (current-seconds) (+ minrtt-stamp MinRTTFilterLen)))
    (when (and (>= (get-rtt packet) 0)
               (or (<= (get-rtt packet) minrtt)
                   minrtt-expired?))
      (set! minrtt (get-rtt packet))
      (set! minrtt-stamp (current-seconds))))
  
  
  ;;;
  ;;;; Probe RoundTrip
  ;;;
  
  
  (method (check-probertt self)
    (when (and (neq? state 'ProbeRTT)
               minrtt-expired?
               (not idle-restart?))
      (enter-probertt self)
      (save-cwnd self)
      (set! probe-rtt-done-stamp 0))
    (when (eq? state 'ProbeRTT)
      (handle-probertt self))
    (set! idle-restart? #f))

  
  (method (enter-probertt self)
    (change-state self 'ProbeRTT)
    (set! pacing-gain 1)
    (set! cwnd-gain 1))

  
  (method (handle-probertt self)
    (set-app-limited cs (let ((count (+ (get-delivered cs) (get-inflight cs)))) (if (> count 0) count 1)))
    (cond ((and (= probe-rtt-done-stamp 0)
                (<= (get-inflight cs) MinPipeCwnd))
           (set! probe-rtt-done-stamp (+ (current-seconds) ProbeRTTDuration))
           (set! probe-rtt-round-done? #f)
           (set! next-round-delivered delivered))
          ((/= probe-rtt-done-stamp 0)
           (when round-start?
             (set! probe-rtt-round-done? #t))
           (when (and probe-rtt-round-done?
                      (> (current-seconds) probe-rtt-done-stamp))
             (set! minrtt-stamp (current-seconds))
             (restore-cwnd self)
             (exit-probertt self)))))

  
  (method (exit-probertt self)
    (if full-reached?
        (enter-probebw self)
      (enter-startup self)))

  
  ;;;
  ;;;; Probe Bandwidth
  ;;;
  
  
  (method (enter-probebw self)
    (change-state self 'ProbeBW)
    (set! pacing-gain 1)
    (set! pacing-cycle-index (modulo (+ 2 (random 7)) 8)) ;; random phase but not 3/4
    (set! cwnd-gain 2)
    (advance-cycle-phase self))
  
  
  ;;;
  ;;;; Pacing Rate
  ;;;
  
  
  (method (init-pacing-rate self)
    (let ((nominal-bandwidth (/ InitialCwnd InitialRTT)))
      (change-pacing-rate self (* pacing-gain nominal-bandwidth))))
  
  
  (method (set-pacing-rate-with-gain self pacing-gain <fl>)
    (let ((rate (* pacing-gain btlbw)))
      (when (or full-reached? (> rate pacing-rate))
        (change-pacing-rate self rate))))

  
  (method (update-pacing-rate self)
    (set-pacing-rate-with-gain self pacing-gain))
  
  
  ;;;
  ;;;; Congestion Window
  ;;;
  
  
  (method (estimate-target-cwnd self gain <fl>)
    (if (= minrtt +inf.0)
        InitialCwnd
      (let ((quanta (* 3 send-quantum))
            (estimated-bdp (* btlbw minrtt)))
        (+ (* gain estimated-bdp) quanta))))

  
  (method (update-target-cwnd self)
    (set! target-cwnd (estimate-target-cwnd self cwnd-gain)))
  
  
  (method (modulate-cwnd-for-recovery self packet)
    (when (> PacketsLost 0)
      (change-cwnd self (max (- cwnd PacketsLost) 1))))
  
  
  (method (save-cwnd self)
    (if (and (not InLossRecovery) (neq? state 'ProbeRTT))
        (set! prior-cwnd cwnd)
      (set! prior-cwnd (max prior-cwnd cwnd))))

  
  (method (restore-cwnd self)
    (change-cwnd self (max cwnd prior-cwnd)))
  
  
  (method (modulate-cwnd-for-probertt self)
    (when (eq? state 'ProbeRTT)
      (change-cwnd self (min cwnd MinPipeCwnd))))
  
  
  (method (update-cwnd self packet)
    (update-target-cwnd self)
    (modulate-cwnd-for-recovery self packet)
    (let ((bytes-delivered (get-size packet)))
      (let ((new-cwnd (cond (full-reached?
                             (min (+ cwnd bytes-delivered) target-cwnd))
                            ((or (< cwnd target-cwnd) (< delivered InitialCwnd))
                             (+ cwnd bytes-delivered))
                            (else
                             cwnd))))
        (change-cwnd self (max new-cwnd MinPipeCwnd))))
    (modulate-cwnd-for-probertt self))))
