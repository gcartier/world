;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Panes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.pane jazz


(import (jazz.application)
        (jazz.graphic)
        (jazz.menu)
        (jazz.process)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.context)
        (world.geometry)
        (world.interface)
        (world.quad-texture)
        (world.syntax (phase syntax)))


(definition public (clear-glass surface resolution)
  (let ((width (get-width resolution))
        (height (get-height resolution)))
    (let ((rect (new Rect 0 0 width height))
          (color {Color red: .000 green: .000 blue: .200 alpha: .25}))
      (clear surface)
      (fill-rect surface rect color)
      (frame-rect surface rect color))))


(class World-Pane extends Element implements (Windowable Playable)
  
  
  (property title      initialize #f accessors generate)
  (property size       initialize #f accessors generate)
  (property resolution initialize #f accessors generate)
  (property billboard  initialize #f accessors generate)
  (property render?    initialize #t accessors generate)
  
  
  (slot quad-texture   <Quad-Texture+> initialize #f getter generate)
  (slot root           <View+>         initialize #f)
  (slot view-focus     <View+>         initialize #f)
  (slot pushed-focuses                 initialize '())
  
  
  (method override (destroy self)
    (when (eq? self (get-window-focus))
      (focus-world))
    (nextmethod self))
  
  
  (method override (update-radiuses self)
    (when size
      (set-radiuses self (vertex (/ (get-width size) 2.) (/ (get-height size) 2.) .001))))
  
  
  (method protected virtual (make-texture self)
    (let ((w (get-width size))
          (h (get-height size))
          (width (get-width resolution))
          (height (get-height resolution)))
      (let ((v1 (vertex (/ w -2.) (/ h  2.) 0.))
            (v2 (vertex (/ w -2.) (/ h -2.) 0.))
            (v3 (vertex (/ w  2.) (/ h -2.) 0.))
            (v4 (vertex (/ w  2.) (/ h  2.) 0.)))
        (let ((quad-texture <Quad-Texture> (make-quad-texture width height v1 v2 v3 v4 mipmap?: (mipmap? self))))
          (let ((texture (get-texture quad-texture)))
            (let ((surface (get-surface texture)))
              (draw self surface)
              (map-texture texture)))
          quad-texture))))
  
  
  (method package virtual (mipmap? self)
    #f)
  
  
  (method package virtual (draw self surface)
    )
  
  
  (method package (cache-quad-texture self)
    (when (not quad-texture)
      (set! quad-texture (make-texture self)))
    quad-texture)
  
  
  (method override (render self)
    (draw-texture (cache-quad-texture self)))
  
  
  (method (mouse-down self h v)
    (parameterize ((event-type 'mouse))
      (root-mouse-down root (fxround h) (fxround v))))
  
  
  (method (mouse-moved self x y)
    (parameterize ((event-type 'mouse))
      (dispatch-mouse-move root (fxround x) (fxround y))))
  
  
  (method (mouse-up self h v)
    (parameterize ((event-type 'mouse))
      (root-mouse-up root (fxround h) (fxround v))))
  
  
  (method (mouse-wheel self h v delta)
    (root-mouse-wheel root h v delta))
  
  
  (method (double-click self h v)
    (parameterize ((event-type 'mouse))
      (root-double-click root (fxround h) (fxround v))))
  
  
  (method (multiple-click self count h v)
    (parameterize ((event-type 'mouse))
      (root-multiple-click root count (fxround h) (fxround v))))
  
  
  (method protected virtual (look-at self)
    )
  
  
  ;;;
  ;;;; Windowable
  ;;;
  
  
  (method override (get-overlapped self)
    self)
  
  
  (method override (track-mouse-leave self)
    )
  
  
  (method override (cancel-mouse-leave-tracking self)
    )
  
  
  ;; TODO
  (method override (mouse-position self) <Point>
    {Point 0 0})
  
  
  (method override (get-focus self)
    self)
  
  
  (method override (set-focus self)
    (let ((window (current-window)))
      (set-playable-focus window self)
      (platform-set-focus (get-handle window))))
  
  
  (method override (acquire-capture self)
    )
  
  
  (method override (release-capture self)
    )
  
  
  (method override (acquire self window <Windowable> shape)
    shape)
  
  
  (method override (get-cursor-visible? self)
    #t)


  (method override (scroll-window self delta rect clip-rect)
    ;; quick test
    (redraw-texture self))
  
  
  (method override (invalidate-rect self rect)
    ;; quick test
    (redraw-texture self))
  
  
  (method override (invalidate-region self region)
    ;; quick test
    (redraw-texture self))
  
  
  (method override (redraw-window self (rect: rect #f) (region: region #f))
    ;; quick test
    (redraw-texture self))
  
  
  (method override (update-window self)
    )
  
  
  (method (redraw-texture self)
    (let ((texture (get-texture (cache-quad-texture self))))
      (let ((surface (get-surface texture)))
        (draw self surface)
        (map-texture texture))))
  
  
  ;;;
  ;;;; Playable
  ;;;
  
  
  (method override (owner-window self)
    (current-window))
  
  
  (method override (get-root self)
    root)
  
  
  (method override (set-root self value (detach?: detach? #t) (offscreen?: offscreen? #t))
    (when (neq? value root)
      (set! root value)
      (set-name root 'root)
      (set-player root self)
      (set-offscreen? root offscreen?)))
  
  
  (method override (get-view-focus self)
    view-focus)
  
  
  (method override (set-view-focus self focus)
    (set! view-focus focus))
  
  
  (method override (get-pushed-focuses self)
    '())
  
  
  (method override (focus-gain self)
    (set-focused-window self)
    (when (and view-focus (in-player? view-focus))
      (parameterize ((activating-window? #t))
        (focus-view self view-focus)
        (focus-delegate view-focus)))
    processed)
  
  
  (method override (focus-lose self)
    (parameterize ((window-losing-focus? #t))
      (unfocus-view self))
    (set-focused-window #f)
    processed)
  
  
  (method override (focus-view self new-focus (process-focus-change? #t))
    (set! view-focus new-focus)
    (call-focus-gained view-focus)
    (when (and process-focus-change? (process-active?))
      (process-focus-change (current-application) view-focus)))
  
  
  (method override (unfocus-view self)
    (when view-focus
      (let ((focus view-focus))
        (call-focus-lose focus)
        (set! view-focus (focus-master focus))
        (call-focus-lost focus))))
  
  
  (method override (push-view-focus self new-focus)
    (when view-focus
      (set! pushed-focuses (cons view-focus pushed-focuses)))
    ;; quick hack to fix correctly
    (unless (is? view-focus Menubar)
      (let ((focus view-focus))
        (when focus
          (call-focus-lose focus))))
    (focus-view self new-focus #f))
  
  
  (method override (pop-view-focus self)
    (when (has-pushed-focuses? self)
      (let ((new-focus (car pushed-focuses)))
        (set! pushed-focuses (cdr pushed-focuses))
        (when view-focus
          (call-focus-lose view-focus))
        (parameterize ((activating-window? #t))
          (focus-view self new-focus #f)))))
  
  
  (method override (pop-view-focuses self popup)
    (let (iterate)
      (let ((focus view-focus))
        (when (and view-focus
                   (eq? (get-player view-focus) popup)
                   (has-pushed-focuses? self))
          (pop-view-focus self)
          (iterate)))))
  
  
  (method override (pop-all-view-focuses self)
    (let (iterate)
      (when (has-pushed-focuses? self)
        (pop-view-focus self)
        (iterate))))
  
  
  (method override (clear-pushed-focuses self)
    )
  
  
  (method package (has-pushed-focuses? self)
    (not-null? pushed-focuses))
  
  
  (method override (close-popups self . rest)
    )))
