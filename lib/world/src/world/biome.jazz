;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Biomes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s): Édouard Hébert


(module world.biome jazz


(import (jazz.geometry)
        (jazz.graphic)
        (world)
        (world.autoload)
        (world.foreign)
        (world.generation.block)
        (world.geometry)
        (world.geometry.syntax (phase syntax))
        (world.homogeneous)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))


;;;
;;;; Biome
;;;


(class Biome extends Object
  
  
  (slot name                 getter generate)
  (slot title                getter generate)
  (slot id          <fx>     getter generate)
  (slot top                  accessors generate)
  (slot fill                 accessors generate)
  (slot color       <Color>  getter generate)
  (slot base        <fl>     getter generate)
  (slot variation   <fl>     getter generate)
  (slot temperature <fl>     getter generate)
  (slot rain        <fl>     getter generate)
  (slot decorator            getter generate)
  (slot type        <symbol> getter generate)
  
  
  (method override (initialize name title id top fill color base variation temperature rain type)
    (set! name~self name)
    (set! title~self title)
    (set! id~self id)
    (set! top~self top)
    (set! fill~self fill)
    (set! color~self color)
    (set! base~self base)
    (set! variation~self variation)
    (set! temperature~self temperature)
    (set! rain~self rain)
    (set! decorator (new Biome-Decorator))
    (set! type~self type)
    (setup-decorator))
  
  
  (method virtual (setup-decorator)
    )
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method virtual (mutation?)
    #f)
  
  
  (method virtual (mutate) <Biome+>
    #f)
  
  
  (method virtual (get-tree-generation rand) <fx>
    (if (= (randomInt rand 10) 0) 0 1))
  
  
  (method virtual (replace-blocks x z rand block-ref block-set! blockstate-set!)
    (let ((replace-amount -1))
      (let (iter (y 255))
        (let ((block-id <fx> (block-ref x y z)))
          (if (= block-id 0)
              (set! replace-amount -1)
            (when (= block-id 1)
              (if (= replace-amount -1)
                  (begin
                    (blockstate-set! x y z top)
                    (set! replace-amount (randomIntBetween rand 3 5)))
                (when (> replace-amount 0)
                  (blockstate-set! x y z fill)
                  (decrease! replace-amount))))))
        (when (> y 0)
          (iter (- y 1))))))
  
  
  (method (decorate-biome rand block-ref block-set! blockstate-set! skylight-set! get-sector get-height)
    (decorate~ decorator self rand block-ref block-set! blockstate-set! skylight-set! get-sector get-height)))


;;;
;;;; Decorator
;;;


(class Biome-Decorator extends Object
  
  
  (slot grass-per-chunk  <fx>   initialize 0  accessors generate)
  (slot trees-per-chunk  <fx>   initialize 0  accessors generate)
  (slot tree-generations        initialize #f getter generate)
  (slot water-lakes?     <bool> initialize #t accessors generate)
  
  
  (method override (initialize)
    (set! tree-generations (list generate-tree generate-big-tree generate-spruce-tree generate-birch-tree)))
  
  
  (method (decorate biome <Biome> rand block-ref block-set! blockstate-set! skylight-set! get-sector get-height)
    (loop (for j2 from 0 below trees-per-chunk)
          (let ((k6 (+ (randomInt rand 16) 8))
                (l (+ (randomInt rand 16) 8)))
            (let ((height (get-height k6 l)))
              ((list-ref tree-generations (get-tree-generation~ biome rand)) k6 height l rand biome block-ref block-set! blockstate-set! get-height))))
    (loop (for i3 from 0 below grass-per-chunk)
          (let ((x (+ (randomInt rand 16) 8))
                (z (+ (randomInt rand 16) 8)))
            (let ((k14 (+ (get-height x z) -5 (randomInt rand 10))))
              (generate-grass x k14 z rand block-ref block-set! blockstate-set!))))
    (when water-lakes?
      @not-good(when (= (randomInt rand 4) 0)
                 (generate-water-lake (randomInt rand 16) (randomInt rand 248) (randomInt rand 16) rand biome block-ref block-set! blockstate-set! skylight-set! get-height))
      (loop (for k5 from 0 below 50)
            (let ((i17 (+ (randomInt rand 240) 8)))
              (when (> i17 0)
                (generate-water-pocket (+ (randomInt rand 16) 8) (randomInt rand i17) (+ (randomInt rand 16) 8) rand block-ref block-set! blockstate-set! get-sector)))))
    (generate-ores rand block-ref block-set! blockstate-set!))
  
  
  (method (generate-water-pocket x <fx> y <fx> z <fx> rand block-ref block-set! blockstate-set! get-sector)
    (when (and (= (block-ref x (+ y 1) z) 1) (= (block-ref x (- y 1) z) 1) (id? (block-ref x y z) 0 1))
      (let ((i 0)
            (j 0)
            (blocks (list (block-ref (- x 1) y z) (block-ref (+ x 1) y z) (block-ref x y (- z 1)) (block-ref x y (+ z 1)))))
        (for-each (lambda (block)
                    (if (= block 0)
                        (increase! j)
                      (when (= block 1)
                        (increase! i))))
                  blocks)
        (when (and (= i 3) (= j 1))
          (block-set! x y z 8)
          ;; To redo when we have sectors in constant memory
          @w(enqueue (get-water-blocks~ (current-game)) (list (get-sector x y z) (modulo x 16) (modulo y 16) (modulo z 16)))
          ))))
  
  
  (method (generate-water-lake x <fx> y <fx> z <fx> rand biome <Biome> block-ref block-set! blockstate-set! skylight-set! get-height)
    @this-is-just-way-too-brittle-and-has-bitten-me-just-too-many-times (
    (while (and (> y 5) (= (block-ref x y z) 0))
      (decrease! y))
    (when (> y 8)
      (let ((y (- y 4))
            (aboolean (make-vector 2048 #f))
            (i (+ (randomInt rand 4) 4)))
        (continuation-capture
          (lambda (return)
            (define (aboolean-ref a <fx> b <fx> c <fx>)
              (vector-ref aboolean (+ (* (+ (* a 16) c) 8) b)))
            
            (loop (for j from 0 below i)
                  (let ((d0 (/ (+ (* (randomFloat rand) 6.) 3.) 2.))
                        (d1 (/ (+ (* (randomFloat rand) 4.) 2.) 2.))
                        (d2 (/ (+ (* (randomFloat rand) 6.) 3.) 2.)))
                    (let ((d3 (+ (* (randomFloat rand) (- 14. d0)) 1. d0))
                          (d4 (+ (* (randomFloat rand) (- 4. d1)) 2. d1))
                          (d5 (+ (* (randomFloat rand) (- 14. d2) 1. d2))))
                      (loop (for l from 1 below 15)
                            (loop (for i1 from 1 below 15)
                                  (loop (for j1 from 1 below 7)
                                        (let ((d6 (/ (- l d3) d0))
                                              (d7 (/ (- j1 d4) d1))
                                              (d8 (/ (- i1 d5) d2)))
                                          (let ((d9 (+ (* d6 d6) (* d7 d7) (* d8 d8))))
                                            (when (< d9 1.)
                                              (vector-set! aboolean (+ (* (+ (* l 16) i1) 8) j1) #t))))))))))
            (loop (for k1 from 0 below 16)
                  (loop (for l2 from 0 below 16)
                        (loop (for k from 0 below 8)
                              (when (and (not (aboolean-ref k1 k l2))
                                         (or (and (< k1 15) (aboolean-ref (+ k1 1) k l2))
                                             (and (> k1 0) (aboolean-ref (- k1 1) k l2))
                                             (and (< l2 15) (aboolean-ref k1 k (+ l2 1)))
                                             (and (> l2 0) (aboolean-ref k1 k (- l2 1)))
                                             (and (< k 7) (aboolean-ref k1 (+ k 1) l2))
                                             (and (> k 0) (aboolean-ref k1 (- k 1) l2))))
                                (let ((block (id->block (block-ref (+ x k1) (+ y k) (+ z l2)))))
                                  (if (>= k 4)
                                      (when (get-liquid-cube?~ block)
                                        (continuation-return return #f))
                                    (when (and (not (get-cube?~ block))
                                               (not (id? (get-id~ block) 8 9)))
                                      (continuation-return return #f))))))))
            (loop (for l1 from 0 below 16)
                  (loop (for i3 from 0 below 16)
                        (loop (for i4 from 0 below 8)
                              (do (when (aboolean-ref l1 i4 i3)
                                    (if (< i4 4)
                                        (block-set! (+ x l1) (+ y i4) (+ z i3) 9)
                                      (block-set! (+ x l1) (+ y i4) (+ z i3) 0)
                                      (skylight-set! (+ x l1) (+ y i4) (+ z i3) 15)))))))
            (loop (for i2 from 0 below 16)
                  (loop (for j3 from 0 below 16)
                        (loop (for j4 from 4 below 8)
                              (when (aboolean-ref i2 j4 j3)
                                (let ((x (+ x i2))
                                      (y (+ y j4 -1))
                                      (z (+ z j3)))
                                  (when (and (= (block-ref x y z) 3) (> y (get-height x z)))
                                    (block-set! x y z (if (is? biome BiomeMushroomIsland) 110 2))))))))
            (loop (for k2 from 0 below 16)
                  (loop (for l3 from 0 below 16)
                        (let ((l4 <int> 4))
                          (when (and (<= (get-temperature~ biome) .15) (= (block-ref (+ x k2) (+ y 5) (+ z l3)) 0))
                            (block-set! (+ x k2) (+ y 4) (+ z l3) 79)))))))))))
  
  
  (method (generate-tree x <fx> y <fx> z <fx> rand biome <Biome> block-ref block-set! blockstate-set! get-height)
    (let ((i (+ (randomInt rand 3) 4))
          (flag #t))
      (when (and (> y 0) (< (+ y i) 255))
        (loop (for j from y to (+ y i 1))
              (let ((k (if (>= j (+ y i -1)) 2 (if (= j y) 0 1))))
                (loop (for l init (- x k) test (and flag (<= l (+ x k))) iter (+ l 1))
                      (loop (for i1 init (- z k) test (and flag (<= i1 (+ z k))) iter (+ i1 1))
                            (unless (and (>= j 0) (< j 256) (id? (block-ref l j i1) 0 18 2 3 17 106))
                              (set! flag #f))))))
        (when (and flag (id? (block-ref x (- y 1) z) 2 3))
          (block-set! x (- y 1) z 3)
          (loop (for i3 from (+ y i -3) to (+ y i))
                (let ((i4 (- i3 (+ y i))))
                  (let ((j1 (- 1 (fxfloor/ (+ i4 1) 2))))
                    (loop (for k1 from (- x j1) to (+ x j1))
                          (loop (for i2 from (- z j1) to (+ z j1))
                                (do (when (or (/= (abs (- k1 x)) j1) (/= (abs (- i2 z)) j1) (and (randomBool rand) (/= i4 0)))
                                      (when (id? (block-ref k1 i3 i2) 0 18 106)
                                        (blockstate-set! k1 i3 i2 307)))))))))
          (loop (for j3 from 0 below i)
                (when (id? (block-ref x (+ y j3) z) 0 18 106)
                  (blockstate-set! x (+ y j3) z 290)))))))
  
  
  (method (generate-big-tree x <fx> y <fx> z <fx> rand biome <Biome> block-ref block-set! blockstate-set! get-height)
    (let ((i (+ (randomInt rand 3) 10))
          (flag #t))
      (when (and (> y 0) (< (+ y i) 255))
        (loop (for j from y to (+ y i 1))
              (let ((k (if (>= j (+ y i -1)) 2 (if (= j y) 0 1))))
                (loop (for l init (- x k) test (and flag (<= l (+ x k))) iter (+ l 1))
                      (loop (for i1 init (- z k) test (and flag (<= i1 (+ z k))) iter (+ i1 1))
                            (unless (and (>= j 0) (< j 256) (id? (block-ref l j i1) 0 18 2 3 17 106))
                              (set! flag #f))))))
        (when (and flag (id? (block-ref x (- y 1) z) 2 3))
          (block-set! x (- y 1) z 3)
          (loop (for i3 from (+ y i -3) to (+ y i))
                (let ((i4 (- i3 (+ y i))))
                  (let ((j1 (- 1 (fxfloor/ (+ i4 1) 2))))
                    (loop (for k1 from (- x j1) to (+ x j1))
                          (loop (for i2 from (- z j1) to (+ z j1))
                                (do (when (or (/= (abs (- k1 x)) j1) (/= (abs (- i2 z)) j1) (and (randomBool rand) (/= i4 0)))
                                      (when (id? (block-ref k1 i3 i2) 0 18 106)
                                        (blockstate-set! k1 i3 i2 307)))))))))
          (loop (for j3 from 0 below i)
                (when (id? (block-ref x (+ y j3) z) 0 18 106)
                  (blockstate-set! x (+ y j3) z 290)))))))
  
  
  (method (generate-birch-tree x <fx> y <fx> z <fx> rand biome <Biome> block-ref block-set! blockstate-set! get-height)
    (let ((i (+ (randomInt rand 3) 4))
          (flag #t))
      (when (and (> y 0) (< (+ y i) 255))
        (loop (for j from y to (+ y i 1))
              (let ((k (if (>= j (+ y i -1)) 2 (if (= j y) 0 1))))
                (loop (for l init (- x k) test (and flag (<= l (+ x k))) iter (+ l 1))
                      (loop (for i1 init (- z k) test (and flag (<= i1 (+ z k))) iter (+ i1 1))
                            (unless (and (>= j 0) (< j 256) (id? (block-ref l j i1) 0 18 2 3 17 106))
                              (set! flag #f))))))
        (when (and flag (id? (block-ref x (- y 1) z) 2 3))
          (block-set! x (- y 1) z 3)
          (loop (for i3 from (+ y i -3) to (+ y i))
                (let ((i4 (- i3 (+ y i))))
                  (let ((j1 (- 1 (fxfloor/ (+ i4 1) 2))))
                    (loop (for k1 from (- x j1) to (+ x j1))
                          (loop (for i2 from (- z j1) to (+ z j1))
                                (do (when (or (/= (abs (- k1 x)) j1) (/= (abs (- i2 z)) j1) (and (randomBool rand) (/= i4 0)))
                                      (when (id? (block-ref k1 i3 i2) 0 18 106)
                                        (blockstate-set! k1 i3 i2 309)))))))))
          (loop (for j3 from 0 below i)
                (when (id? (block-ref x (+ y j3) z) 0 18 106)
                  (blockstate-set! x (+ y j3) z 292)))))))
  
  
  (method (generate-spruce-tree x <fx> y <fx> z <fx> rand biome <Biome> block-ref block-set! blockstate-set! get-height)
    (let ((max-leaf-elevation (+ (randomInt rand 4) 6))
          (min-leaf-elevation (+ 1 (randomInt rand 2))))
      (let ((leaf-height (- max-leaf-elevation min-leaf-elevation))
            (max-radius (+ 2 (randomInt rand 2)))
            (flag #t)
            (flag2 #f))
        (when (and (> y 0) (< (+ y max-leaf-elevation) 255))
          (loop (for check-y init y test (and (<= check-y (+ y max-leaf-elevation 1)) flag) iter (+ check-y 1))
                (let ((check-radius (if (< (- check-y y) min-leaf-elevation) 0 1)))
                  (loop (for check-x init (- x check-radius) test (and flag (<= check-x (+ x check-radius))) iter (+ check-x 1))
                        (loop (for check-z init (- z check-radius) test (and flag (<= check-z (+ z check-radius))) iter (+ check-z 1))
                              (unless (and (>= check-y 0) (< check-y 256) (id? (block-ref check-x check-y check-z) 0 18 78))
                                (set! flag #f))))))
          (when (and flag (id? (block-ref x (- y 1) z) 2 3))
            (block-set! x (- y 1) z 3)
            (let ((radius <fx> (randomInt rand 2))
                  (max-intermediate-radius <fx> 1)
                  (radius-fallback <fx> 0)
                  (max-snow <fx> 0))
              (loop (for y-ref from 0 to leaf-height)
                    (let ((y-pos (- (+ y max-leaf-elevation) y-ref)))
                      (loop (for x-pos from (- x radius) to (+ x radius))
                            (let ((x-ref (- x-pos x)))
                              (loop (for z-pos from (- z radius) to (+ z radius))
                                    (let ((z-ref (- z-pos z)))
                                      (when (and (or (/= (abs x-ref) radius) (/= (abs z-ref) radius) (<= radius 0)) (id? (block-ref x-pos y-pos z-pos) 0 18 106))
                                        (blockstate-set! x-pos y-pos z-pos 308)
                                        (when (and (< (get-temperature~ biome) 0) (>= radius max-snow) (= (block-ref x-pos (+ y-pos 1) z-pos) 0))
                                          (blockstate-set! x-pos (+ y-pos 1) z-pos 1327)
                                          (block-set! x-pos (get-height x-pos z-pos) z-pos 0)
                                          (unless flag2 (set! flag2 #t))))))))
                      (when flag2 (set! flag2 #f) (set! max-snow (+ (max max-snow radius) 1)))
                      (if (>= radius max-intermediate-radius)
                          (begin
                            (set! radius radius-fallback)
                            (set! radius-fallback 1)
                            (increase! max-intermediate-radius)
                            (when (> max-intermediate-radius max-radius)
                              (set! max-intermediate-radius max-radius)))
                        (increase! radius))))
              (let ((i4 (randomInt rand 3)))
                (loop (for k4 from 0 below (- max-leaf-elevation i4))
                      (when (id? (block-ref x (+ y k4) z) 0 18 78)
                        (blockstate-set! x (+ y k4) z 291))))))))))
  
  
  (method (generate-grass x <fx> y <fx> z <fx> rand block-ref block-set! blockstate-set!)
    @this-is-just-way-too-brittle-and-has-bitten-me-just-too-many-times (
    (while (id? (block-ref x y z) 0 18 161)
      (decrease! y))
    (loop (for i1 from 0 below 128)
          (let ((i (+ x (- (randomInt rand 8) (randomInt rand 8))))
                (j (+ y (- (randomInt rand 4) (randomInt rand 4))))
                (k (+ z (- (randomInt rand 8) (randomInt rand 8)))))
            (when (and (id? (block-ref i j k) 0) (id? (block-ref i (- j 1) k) 2 3))
              (block-set! i j k 31))))))
  
  
  (method (generate-ores rand block-ref block-set! blockstate-set!)
    (generate-standard-ore rand 0 255 13 33  8 block-ref block-set!)  ;; gravel
    (generate-standard-ore rand 0 128 16 17 20 block-ref block-set!)  ;; coal
    (generate-standard-ore rand 0  64 15  9 20 block-ref block-set!)  ;; iron
    (generate-standard-ore rand 0  32 14  9  2 block-ref block-set!)  ;; gold
    (generate-standard-ore rand 0  16 73  8  8 block-ref block-set!)  ;; redstone
    (generate-standard-ore rand 0  16 56  8  1 block-ref block-set!)  ;; diamond
    (generate-standard-ore rand 0  32 21  7  1 block-ref block-set!)) ;; lapis
  
  
  (method (generate-standard-ore rand min-y <fx> max-y <fx> id <fx> size <fx> tries <fx> block-ref blockstate-set!)
    (if (< max-y min-y)
        (let ((i max-y))
          (set! max-y min-y)
          (set! min-y i))
      (when (= max-y min-y)
        (if (< max-y 255)
            (increase! max-y)
          (decrease! min-y))))
    (loop (for j0 from 0 below tries)
          (let ((x (cast <fl> (+ (randomInt rand 16) 8)))
                (y (cast <fl> (+ min-y (randomInt rand (- max-y min-y)))))
                (z (cast <fl> (+ (randomInt rand 16) 8))))
            (let ((f0 (* (randomFloat rand) PI)))
              (let ((size/8 (/ (cast <fl> size) 8.)))
                (let ((d0 (f64& (+ x (* (sin f0) size/8))))
                      (d1 (f64& (+ x (* (sin f0) size/8))))
                      (d2 (f64& (+ z (* (cos f0) size/8))))
                      (d3 (f64& (+ z (* (cos f0) size/8))))
                      (d4 (f64& (+ y (randomInt rand 3) -2.)))
                      (d5 (f64& (+ y (randomInt rand 3) -2.))))
                  (loop (for i from 0 below size)
                        (let ((f1 (/ (cast <fl> i) (cast <fl> size))))
                          (let ((d6 (f64& (+ (f64-ref d0) (* (- (f64-ref d1) (f64-ref d0)) f1))))
                                (d7 (f64& (+ (f64-ref d4) (* (- (f64-ref d5) (f64-ref d4)) f1))))
                                (d8 (f64& (+ (f64-ref d2) (* (- (f64-ref d3) (f64-ref d2)) f1))))
                                (d9 (f64& (* (randomFloat rand) (cast <fl> size) 0.0625))))
                            (let ((d10 (f64& (/ (+ (* (+ (sin (* f1 PI)) 1.) (f64-ref d9)) 1.) 2.))))
                              (loop (for l1 from (fxfloor (- (f64-ref d6) (f64-ref d10))) to (fxfloor (+ (f64-ref d6) (f64-ref d10))))
                                    (let ((d12 (f64& (expt (/ (- l1 -0.5 (f64-ref d6)) (f64-ref d10)) 2.))))
                                      (when (< (f64-ref d12) 1.)
                                        (loop (for i2 from (max min-y (fxfloor (- (f64-ref d7) (f64-ref d10)))) to (min max-y (fxfloor (+ (f64-ref d7) (f64-ref d10)))))
                                              (let ((d13 (f64& (expt (/ (- (cast <fl> i2) -0.5 (f64-ref d7)) (f64-ref d10)) 2.))))
                                                (when (< (+ (f64-ref d12) (f64-ref d13)) 1.)
                                                  (loop (for j2 from (fxfloor (- (f64-ref d8) (f64-ref d10))) to (fxfloor (+ (f64-ref d8) (f64-ref d10))))
                                                        (when (and (< (+ (f64-ref d12) (f64-ref d13) (expt (/ (- (cast <fl> j2) -0.5 (f64-ref d8)) (f64-ref d10)) 2.)) 1.) (id? (block-ref l1 i2 j2) 1))
                                                          (blockstate-set! l1 i2 j2 id))))))))))))))))))))


(definition protected biome-names <table>
  (make-table test: eq?))

(definition protected biome-ids <vector>
  (make-vector 256 #f))


(definition protected (register-biome name class title id top fill color (base: base 0.1) (variation: variation 0.2) (temperature: temperature 0.5) (rain: rain 0.5) (type: type 'default))
  (bind (red green blue) color
    (let ((color (new Color red: red green: green blue: blue)))
      (let ((biome (new class name title id top fill color base variation temperature rain type)))
        (table-set! biome-names name biome)
        (vector-set! biome-ids id biome)
        (unspecified)))))


(definition public (name->biome name) <Biome>
  (table-ref biome-names name #f))

(definition public (id->biome id <fx>) <Biome>
  (vector-ref biome-ids id)))
