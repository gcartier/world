;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Player
;;;


(module world.player jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.actor)
        (world.autoload)
        (world.block)
        (world.collision)
        (world.dye)
        (world.element)
        (world.enemy)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.mark)
        (world.movement)
        (world.syntax (phase syntax))
        (world.texture)
        (world.window)
        (world.client.window))


;;;
;;;; Player
;;;


(definition player-speed
  .5)

(definition floor-deceleration
  .25)

(definition air-deceleration
  .05)

(definition max-vy
  -.8)

(definition die-bottom
  -6.)


(class Player extends Actor
  

  (slot ready?         <bool>      initialize #f            accessors generate)
  (slot jumping?       <bool>      initialize #f            accessors generate)
  (slot floor?         <bool>      initialize #f            accessors generate)
  (slot avatar         <object>    initialize #f            accessors generate)
  (slot facing         <symbol>    initialize 'left         accessors generate)
  (slot state          <symbol+>   initialize #f            accessors generate)
  (slot movement       <f32vector> initialize (make-vertex) getter generate)
  (slot rotation       <fl>        initialize 0.            accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-size (vertex 4. 4. 4.))
    (set-radius 2.)
    (set-color (dye .678 .047 .902 1.)))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (standardize-lookat! lookat))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" name position))))
  
  
  (method override (copy-from from)
    (nextmethod from)
    (set! movement (clone-vertex (get-movement~ from))))
  
  
  (method public inline (set-movement mvt <f32vector>) <void>
    (vertex-copy! movement mvt))
  
  
  (method override (update-radius)
    (set! radius (/ (get-width) 2.))
    (set-radiuses radius radius radius))
  
  
  (method override (is-player?)
    #t)
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (wound)
    (nextmethod)
    (let ((world (current-world)))
      (let ((player-pane (child~ (get-interface~ world) 'player)))
        (set-visible?~ player-pane #t)
        (invalidate-view~ player-pane))))
  
  
  (method override (die)
    (let ((world (current-world))
          (zone (current-zone))
          (me (current-me)))
      (play-sound-file~ world death-sound)
      (display-message~ world (format "{a} died" name))
      (set-life 100)
      (invalidate-view~ (child~ (get-interface~ world) 'player))
      (let ((old-position (get-position)))
        (set-position (vertex -127.6 17.0 -138.0))
        (update-area~ zone self old-position))
      (set-sight~ lookat (vertex .6830981969833374 -.15438011288642883 .7138231992721558))
      (set-up~ lookat (vertex .10673626512289047 .9880115389823914 .11153727769851685))
      (set-right~ lookat (vertex -.7224847078323364 0. .6913869380950928))
      (when (eq? self me)
        (camera-behind-player~ world)
        (follow-player~ world))))
  
  
  (method override (update-position)
    (nextmethod)
    (matrix-multiply! matrix
                      (make-translation-matrix& (get-x) (- (get-y) 2.) (get-z))
                      (matrix-multiply& (make-scaling-matrix& scale scale scale)
                                        ;; rotation is a quicky for tests
                                        (if avatar
                                            (matrix-multiply& (make-rotation-matrix& 0. (- PI/2) 0.)
                                                              (make-lookat-matrix& lookat))
                                          (make-lookat-matrix& lookat)))))
  
  
  (method override (tick-actions commands)
    (let ((world (current-world)))
      (when (get-modified?~ commands)
        (let ((first-person? (get-first-person?~ world)))
          (for-each (lambda (action)
                      (bind (name . arguments) action
                        (case name
                          ((track)
                           (bind (dh dv eye-sight eye-up eye-right first?) arguments
                             (track-player~ world self dh dv eye-sight eye-up eye-right first?)))
                          ((edit)
                           (bind (mode grid? grid-plane grid-position eye direction stage) arguments
                             (editor-edit~ world mode grid? grid-plane grid-position eye direction stage)))
                          ((delete)
                           (bind (position) arguments
                             (editor-delete~ world position)))
                          ((fire)
                           (bind (direction) arguments
                             (when first-person?
                               (fire-missile direction))))
                          ((sit)
                           (sit-down)))))
                    (get-actions~ commands))))))
  
  
  (method override (tick commands elapse exit)
    (let ((world (current-world))
          (zone (current-zone))
          (me (current-me)))
      (define (win-hit elements)
        (when (member? 'win elements key: get-user-data~)
          (win~ world self)
          (continuation-return exit)))
      
      (define (stomp-enemies elements)
        (for-each (lambda (elem)
                    (when (and (is? elem Actor) (stomp~ elem))
                      (vertex-y-set! velocity 3.)))
                  elements))
      
      (let ((moving? #f)
            (target-vx #f)
            (target-vz #f)
            (factor (* elapse 65))
            (first-person? (get-first-person?~ world))
            (fly? (get-fly?~ world))
            (old-position (copy-vertex position)))
        (when (get-modified?~ commands)
          (when (get-move-left?~ commands)
            (set! moving? #t)
            (set! target-vx (- player-speed)))
          (when (get-move-right?~ commands)
            (set! moving? #t)
            (set! target-vx player-speed))
          (when (get-move-down?~ commands)
            (if first-person?
                (begin
                  (move-player-backward~ world self factor)
                  (decrease! rotation (* 150. elapse)))
              (set! moving? #t)
              (set! target-vz player-speed)))
          (when (get-move-up?~ commands)
            (if first-person?
                (begin
                  (move-player-forward~ world self factor)
                  (unless fly?
                    (increase! rotation (* 150. elapse))))
              (set! moving? #t)
              (set! target-vz (- player-speed))))
          (when (get-strafe-left?~ commands)
            (when first-person?
              (strafe-player-left~ world self factor)))
          (when (get-strafe-right?~ commands)
            (when first-person?
              (strafe-player-right~ world self factor)))
          (when (get-strafe-up?~ commands)
            (when fly?
              (strafe-player-up~ world self factor)))
          (when (get-strafe-down?~ commands)
            (when fly?
              (strafe-player-down~ world self factor)))
          (when (get-rotate-left?~ commands)
            (when first-person?
              (rotate-player-left~ world self factor)))
          (when (get-rotate-right?~ commands)
            (when first-person?
              (rotate-player-right~ world self factor)))
          (when (and fly?
                     (not (get-rotate-left?~ commands))
                     (not (get-rotate-right?~ commands)))
            (reset-player-tilt~ world self)))
        (when (not moving?)
          (set! target-vx 0.)
          (set! target-vz 0.))
        (when target-vx
          (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
            (cond ((> (vertex-x velocity) target-vx)
                   (vertex-x-set! velocity (- (vertex-x velocity) deceleration))
                   (if (< (vertex-x velocity) target-vx)
                       (vertex-x-set! velocity target-vx)))
                  ((< (vertex-x velocity) target-vx)
                   (vertex-x-set! velocity (+ (vertex-x velocity) deceleration))
                   (if (> (vertex-x velocity) target-vx)
                       (vertex-x-set! velocity target-vx))))))
        (when target-vz
          (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
            (cond ((> (vertex-z velocity) target-vz)
                   (vertex-z-set! velocity (- (vertex-z velocity) deceleration))
                   (if (< (vertex-z velocity) target-vz)
                       (vertex-z-set! velocity target-vz)))
                  ((< (vertex-z velocity) target-vz)
                   (vertex-z-set! velocity (+ (vertex-z velocity) deceleration))
                   (if (> (vertex-z velocity) target-vz)
                       (vertex-z-set! velocity target-vz))))))
        (if (not (get-jump?~ commands))
            (set! ready? #t)
          (when (and floor? ready? (not jumping?))
            (set! ready? #f)
            (set! jumping? #t)
            (vertex-y-set! velocity (get-jump-impulsion~ world))))
        
        (set! floor? #f)
        (when (not (get-start-3d?~ world))
          (set-position (vertex+ position (vertex (vertex-x velocity) 0. (vertex-z velocity)))))
        (let ((target-position (copy-vertex position)))
          ;; reset to test collisions
          ;; this hack is until we change actions moving player by setting his position
          (set-position old-position)
          @wait-collision-debugged (vertex-x-set! target-position (+ (vertex-x target-position) (* (vertex-x velocity) factor)))
          @wait-collision-debugged (vertex-z-set! target-position (+ (vertex-z target-position) (* (vertex-z velocity) factor)))
          (when (< (vertex-y velocity) max-vy)
            (vertex-y-set! velocity max-vy))
          (let ((mvt (new Movement position (vertex- target-position position))))
            (receive (new-position last-direction collisions) (collide&slide radius mvt #f)
              (win-hit (map get-element~ collisions))
              ;; try and use last-direction so next movement is aligned with it!?
              ;; (set! direction (vertex-normalize-safe last-direction))
              (let ((target-fall (copy-vertex new-position)))
                (unless fly?
                  @need-to-generalize-gravity-as-a-vector-in-the-interpolation-algorithm
                  (let ((gravity (compute-gravity~ zone position)))
                    (vertex+! velocity velocity (vertex-scalar* gravity factor))
                    (vertex+! position position (vertex-scalar* velocity factor))
                    (set! x (vertex-x position))
                    (set! y (vertex-y position))
                    (set! z (vertex-z position)))
                  (let ((gravity (get-gravity~ world))
                        (adjusted (* elapse 50.)))
                    (vertex-y-set! velocity (- (vertex-y velocity) (* gravity adjusted)))
                    (vertex-y-set! target-fall (+ (vertex-y target-fall) (- (* (vertex-y velocity) adjusted) (* gravity .5 adjusted adjusted))))))
                (let ((mvt (new Movement new-position (vertex- target-fall new-position))))
                  (receive (new-fall last-direction collisions) (collide&stop radius mvt #f)
                    (let ((fall-collided? (vertex/=? new-fall target-fall)))
                      (if fall-collided?
                          (let ((going-down? (< (vertex-y (get-vector~ mvt)) 0.)))
                            (vertex-y-set! velocity 0.)
                            (set! jumping? #f)
                            (set! floor? #t)
                            (when going-down?
                              (stomp-enemies (map get-element~ collisions))))
                        (let ((floor-level (+ (get-floor-level~ zone) (get-radius-y))))
                          (when (and (< (vertex-y new-fall) floor-level) (not fly?))
                            (vertex-y-set! new-fall floor-level)
                            (vertex-y-set! velocity 0.)
                            (set! jumping? #f)
                            (set! floor? #t)))))
                    @w
                    (when (< y die-bottom)
                      (lose~ world self)
                      (continuation-return exit))
                    (set-position new-fall)
                    (update-area~ zone self old-position)
                    (vertex-! movement position old-position)
                    (when (and (eq? self me)
                               (not (vertex=? old-position new-fall)))
                      (camera-center-player~ world)))))))))))
  
  
  (method (fire-missile direction)
    (let ((world (current-world))
          (zone (current-zone)))
      (when (< missiles-count max-missiles)
        (let ((target (player-target~ world self)))
          (let ((pos (vertex+ target (vertex-scalar* direction (- radius .1)))))
            (let ((missile (new Missile parent: world position: pos actor: self)))
              (increase-missiles)
              (set-velocity~ missile (vertex-scalar* direction missile-speed))
              (add-element~ zone missile)))))))
  
  
  (method (sit-down)
    )
  
  
  (method (move-left commands)
    (move-left~ commands))
  
  
  (method (move-right commands)
    (move-right~ commands))
  
  
  (method (move-down commands)
    (move-down~ commands))
  
  
  (method (move-up commands)
    (move-up~ commands))
  
  
  (method (strafe-left commands)
    (strafe-left~ commands))
  
  
  (method (strafe-right commands)
    (strafe-right~ commands))
  
  
  (method (strafe-up commands)
    (strafe-up~ commands))
  
  
  (method (strafe-down commands)
    (strafe-down~ commands))
  
  
  (method (rotate-left commands)
    (rotate-left~ commands))
  
  
  (method (rotate-right commands)
    (rotate-right~ commands))
  
  
  (method (space commands)
    (jump commands))
  
  
  (method (jump commands)
    (jump~ commands))
  
  
  (method (fire commands)
    (let ((world (current-world)))
      (add-action~ commands 'fire (list (get-sight~ (get-eye-lookat~ world))))))
  
  
  (method (win)
    (set! jumping? #f)
    (set! state 'win))
  
  
  (method (lose)
    (set! jumping? #f)
    (set! state 'lose))
  
  
  (method (reset-state)
    (set! state #f))
  
  
  (method (reset-position)
    (let ((zone (current-zone)))
      (set-position (or (get-start-position~ zone) (vertex -9.5 62.5 0.0)))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-3d)
    (let ((world (current-world)))
      (cond (avatar
              (draw-entity))
            ((in-history?)
             (draw-3d-history))
            (else
             (draw-as-sphere-actor movement rotation (get-mount~ world) 'high GL_LINE))))))


;;;
;;;; Pacman
;;;


(class Pacman extends Player
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set-color (dye 1. 1. 0. 1.))))


;;;
;;;; Commands
;;;


(class Commands extends Object
  
  
  (slot move-left?    <bool>   initialize #f getter generate)
  (slot move-right?   <bool>   initialize #f getter generate)
  (slot move-down?    <bool>   initialize #f getter generate)
  (slot move-up?      <bool>   initialize #f getter generate)
  (slot strafe-left?  <bool>   initialize #f getter generate)
  (slot strafe-right? <bool>   initialize #f getter generate)
  (slot strafe-up?    <bool>   initialize #f getter generate)
  (slot strafe-down?  <bool>   initialize #f getter generate)
  (slot rotate-left?  <bool>   initialize #f getter generate)
  (slot rotate-right? <bool>   initialize #f getter generate)
  (slot jump?         <bool>   initialize #f getter generate)
  (slot actions       <object> initialize (new-queue) getter generate)
  (slot last-no       <object> initialize #f getter generate)
  (slot modified?     <bool>   initialize #f getter generate)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{l}"
          `(,@(if move-left? '(move-left) '())
            ,@(if move-right? '(move-right) '())
            ,@(if move-down? '(move-down) '())
            ,@(if move-up? '(move-up) '())
            ,@(if strafe-left? '(strafe-left) '())
            ,@(if strafe-right? '(strafe-right) '())
            ,@(if strafe-up? '(strafe-up) '())
            ,@(if strafe-down? '(strafe-down) '())
            ,@(if rotate-left? '(rotate-left) '())
            ,@(if rotate-right? '(rotate-right) '())
            ,@(if jump? '(jump) '()))))))
  
  
  (method public (move-left)
    (set! move-left? #t)
    (set! modified? #t))
  
  (method public (move-right)
    (set! move-right? #t)
    (set! modified? #t))
  
  (method public (move-down)
    (set! move-down? #t)
    (set! modified? #t))
  
  (method public (move-up)
    (set! move-up? #t)
    (set! modified? #t))
  
  
  (method public (strafe-left)
    (set! strafe-left? #t)
    (set! modified? #t))
  
  (method public (strafe-right)
    (set! strafe-right? #t)
    (set! modified? #t))
  
  (method public (strafe-up)
    (set! strafe-up? #t)
    (set! modified? #t))
  
  (method public (strafe-down)
    (set! strafe-down? #t)
    (set! modified? #t))
  
  
  (method public (rotate-left)
    (set! rotate-left? #t)
    (set! modified? #t))
  
  (method public (rotate-right)
    (set! rotate-right? #t)
    (set! modified? #t))
  
  
  (method public (jump)
    (set! jump? #t)
    (set! modified? #t))
  
  
  (method public (add-action name arguments)
    (enqueue actions (cons name arguments))
    (set! modified? #t))
  
  
  (method public (enqueue-action action)
    (enqueue actions action)
    (set! modified? #t))
  
  
  (method public (set-last-no no)
    (set! last-no no))
  
  
  (method public (complete)
    (when (and modified? (is? actions Queue))
      (set! actions (queue-list actions))))
  
  
  (method (serialize)
    (vector move-left?
            move-right?
            move-down?
            move-up?
            strafe-left?
            strafe-right?
            strafe-up?
            strafe-down?
            rotate-left?
            rotate-right?
            jump?
            actions
            last-no))
  
  
  (method (deserialize vec)
    (set! move-left?    (vector-ref vec 0))
    (set! move-right?   (vector-ref vec 1))
    (set! move-down?    (vector-ref vec 2))
    (set! move-up?      (vector-ref vec 3))
    (set! strafe-left?  (vector-ref vec 4))
    (set! strafe-right? (vector-ref vec 5))
    (set! strafe-up?    (vector-ref vec 6))
    (set! strafe-down?  (vector-ref vec 7))
    (set! rotate-left?  (vector-ref vec 8))
    (set! rotate-right? (vector-ref vec 9))
    (set! jump?         (vector-ref vec 10))
    (set! actions       (vector-ref vec 11))
    (set! last-no       (vector-ref vec 12))
    (set! modified?     #t)))


(definition public (serialize-commands commands)
  (serialize~ commands))


(definition public (deserialize-commands vec)
  (let ((commands (new Commands)))
    (deserialize~ commands vec)
    commands)))
