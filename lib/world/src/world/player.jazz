;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Player
;;;


(module world.player jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.actor)
        (world.autoload)
        (world.block)
        (world.collision)
        (world.element)
        (world.enemy)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.mark)
        (world.movement)
        (world.texture)
        (world.window)
        (world.client.window))


;;;
;;;; Player
;;;


(definition player-speed
  .5)

(definition floor-deceleration
  .25)

(definition air-deceleration
  .05)

(definition max-vy
  -.8)

(definition die-bottom
  -6.)


(class Player extends Actor
  

  (slot ready?         <bool>      initialize #f            accessors generate)
  (slot jumping?       <bool>      initialize #f            accessors generate)
  (slot floor?         <bool>      initialize #f            accessors generate)
  (slot avatar         <object>    initialize #f            accessors generate)
  (slot facing         <symbol>    initialize 'left         accessors generate)
  (slot state          <symbol+>   initialize #f            accessors generate)
  (slot movement       <f32vector> initialize (make-vertex) accessors generate)
  (slot rotation       <fl>        initialize 0.            accessors generate)
  (slot history-color  <object>    initialize #f            accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! width 4.)
    (set! height 4.)
    (set! depth 4.)
    (set-color {Color red: 173 green: 12 blue: 230}))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (standardize!~ lookat))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {r precision: 1} {r precision: 1} {r precision: 1}" name x y z))))
  
  
  (method override (update-radius)
    (set! radius (/ width 2.))
    (set! radius-x radius)
    (set! radius-y radius)
    (set! radius-z radius))
  
  
  (method override (is-player?)
    #t)
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (wound)
    (nextmethod)
    (let ((player-pane (child~ (get-interface~ world) 'player)))
      (set-visible?~ player-pane #t)
      (invalidate-view~ player-pane)))
  
  
  (method override (die)
    (play-sound-file~ world death-sound)
    (display-message~ world (format "{a} died" name))
    (set-life 100)
    (invalidate-view~ (child~ (get-interface~ world) 'player))
    (let ((old-position (get-position)))
      (set-position (vertex -127.6 17.0 -138.0))
      (update-area~ zone self old-position))
    (set-sight~ lookat (vertex .6830981969833374 -.15438011288642883 .7138231992721558))
    (set-up~ lookat (vertex .10673626512289047 .9880115389823914 .11153727769851685))
    (set-right~ lookat (vertex -.7224847078323364 0. .6913869380950928))
    (when (eq? self me)
      (camera-behind-player~ world)
      (follow-player~ world)))
  
  
  (method override (update-position)
    (nextmethod)
    (set! matrix (matrix-multiply (make-translation-matrix x (- y 2.) z)
                                  (matrix-multiply (make-scaling-matrix scale scale scale)
                                                   ;; rotation is a quicky for tests
                                                   (if avatar
                                                       (matrix-multiply (make-rotation-matrix 0. (- PI/2) 0.)
                                                                        (make-lookat-matrix lookat))
                                                     (make-lookat-matrix lookat))))))
  
  
  (method override (update-color)
    (nextmethod)
    (let ((color (copy-object~ color #f)))
      (set-alpha~ color .2)
      (set! history-color color)))
  
  
  (method override (tick-actions commands)
    (when (get-modified?~ commands)
      (let ((first-person? (get-first-person?~ world)))
        (for-each (lambda (action)
                    (bind (name . arguments) action
                      (case name
                        ((track)
                         (bind (dh dv eye-sight eye-up eye-right first?) arguments
                           (track-player~ world self dh dv eye-sight eye-up eye-right first?)))
                        ((edit)
                         (bind (mode grid? grid-plane grid-position eye direction stage) arguments
                           (editor-edit~ world mode grid? grid-plane grid-position eye direction stage)))
                        ((delete)
                         (bind (position) arguments
                           (editor-delete~ world position)))
                        ((fire)
                         (bind (direction) arguments
                           (when first-person?
                             (fire-missile direction))))
                        ((sit)
                         (sit-down)))))
                  (get-actions~ commands)))))
  
  
  (method override (tick commands elapse exit)
    (define (win-hit elements)
      (when (member? 'win elements key: get-user-data~)
        (win~ world self)
        (continuation-return exit)))
    
    (unless (find-setting 'world.disable-tick? #f)
    (if (find-setting 'world.collision-detection? #f)
        (test-tick commands elapse exit)
    (let ((old-left left)
          (old-bottom bottom)
          (old-back back)
          (old-position (get-position))
          (moving? #f)
          (target-vx #f)
          (target-vz #f)
          (factor (* elapse 65))
          (first-person? (get-first-person?~ world))
          (fly? (get-fly?~ world)))
      (when (get-modified?~ commands)
        (when (get-move-left?~ commands)
          (set! moving? #t)
          (set! target-vx (- player-speed)))
        (when (get-move-right?~ commands)
          (set! moving? #t)
          (set! target-vx player-speed))
        (when (get-move-down?~ commands)
          (if first-person?
              (begin
                (move-player-backward~ world self factor)
                (decrease! rotation (* 150. elapse)))
            (set! moving? #t)
            (set! target-vz player-speed)))
        (when (get-move-up?~ commands)
          (if first-person?
              (begin
                (move-player-forward~ world self factor)
                (unless fly?
                  (increase! rotation (* 150. elapse))))
            (set! moving? #t)
            (set! target-vz (- player-speed))))
        (when (get-strafe-left?~ commands)
          (when first-person?
            (strafe-player-left~ world self factor)))
        (when (get-strafe-right?~ commands)
          (when first-person?
            (strafe-player-right~ world self factor)))
        (when (get-strafe-up?~ commands)
          (when fly?
            (strafe-player-up~ world self factor)))
        (when (get-strafe-down?~ commands)
          (when fly?
            (strafe-player-down~ world self factor)))
        (when (get-rotate-left?~ commands)
          (when first-person?
            (rotate-player-left~ world self factor)))
        (when (get-rotate-right?~ commands)
          (when first-person?
            (rotate-player-right~ world self factor)))
        (when (and fly?
                   (not (get-rotate-left?~ commands))
                   (not (get-rotate-right?~ commands)))
          (reset-player-tilt~ world self)))
      (when (not moving?)
        (set! target-vx 0.)
        (set! target-vz 0.))
      (when target-vx
        (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
          (cond ((> (vertex-x velocity) target-vx)
                 (vertex-x-set! velocity (- (vertex-x velocity) deceleration))
                 (if (< (vertex-x velocity) target-vx)
                     (vertex-x-set! velocity target-vx)))
                ((< (vertex-x velocity) target-vx)
                 (vertex-x-set! velocity (+ (vertex-x velocity) deceleration))
                 (if (> (vertex-x velocity) target-vx)
                     (vertex-x-set! velocity target-vx))))))
      (when target-vz
        (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
          (cond ((> (vertex-z velocity) target-vz)
                 (vertex-z-set! velocity (- (vertex-z velocity) deceleration))
                 (if (< (vertex-z velocity) target-vz)
                     (vertex-z-set! velocity target-vz)))
                ((< (vertex-z velocity) target-vz)
                 (vertex-z-set! velocity (+ (vertex-z velocity) deceleration))
                 (if (> (vertex-z velocity) target-vz)
                     (vertex-z-set! velocity target-vz))))))
      (if (not (get-jump?~ commands))
          (set! ready? #t)
        (when (and floor? ready? (not jumping?))
          (set! ready? #f)
          (set! jumping? #t)
          (vertex-y-set! velocity (get-jump-impulsion~ world))))
      
      (increase! x (* (vertex-x velocity) factor))
      (increase! z (* (vertex-z velocity) factor))
      (unless fly?
        @need-to-generalize-gravity-as-a-vector-in-the-interpolation-algorithm
        (let ((gravity (compute-gravity~ zone position)))
          (vertex+! velocity velocity (vertex-scalar* gravity factor))
          (vertex+! position position (vertex-scalar* velocity factor))
          (set! x (vertex-x position))
          (set! y (vertex-y position))
          (set! z (vertex-z position)))
        (let ((gravity (get-gravity~ world))
              (adjusted (* elapse 50.)))
          (vertex-y-set! velocity (- (vertex-y velocity) (* gravity adjusted)))
          (increase! y (- (* (vertex-y velocity) adjusted) (* gravity .5 adjusted adjusted)))))
      (when (< (vertex-y velocity) max-vy)
        (vertex-y-set! velocity max-vy))
      (receive (hit-x hit-y hit-z) (hit-test~ zone self old-left old-bottom old-back (- x radius-x) (- y radius-y) (- z radius-z) width height depth radius-x radius-y radius-z #f)
        (when hit-x
          (bind (elements direction border reset) hit-x
            (win-hit elements)
            (set! x reset)))
        (if (not hit-y)
            (set! floor? #f)
          (bind (elements direction border reset) hit-y
            (win-hit elements)
            (set! y reset)
            (vertex-y-set! velocity 0.)
            (when (= direction -1)
              (set! jumping? #f)
              (set! floor? #t)
              (for-each (lambda (obj)
                          (when (and (is? obj Actor) (stomp~ obj))
                            (vertex-y-set! velocity 3.)))
                        elements))))
        (when hit-z
          (bind (elements direction border reset) hit-z
            (win-hit elements)
            (set! z reset))))
      (let ((floor-level (+ (get-floor-level~ zone) radius-y)))
        (when (and (< y floor-level) (not fly?))
          (set! y floor-level)
          (vertex-y-set! velocity 0.)
          (set! jumping? #f)
          (set! floor? #t)))
      @w
      (when (< y die-bottom)
        (lose~ world self)
        (continuation-return exit))
      (update-position)
      (update-area~ zone self old-position)
      (vertex-! movement position old-position)
      (when (and (eq? self me)
                 (or (/= left old-left)
                     (/= bottom old-bottom)
                     (/= back old-back)))
        (camera-center-player~ world))))))
  
  
  (method (test-tick commands elapse exit)
    (define (win-hit elements)
      (when (member? 'win elements key: get-user-data~)
        (win~ world self)
        (continuation-return exit)))
    
    (let ((moving? #f)
          (target-vx #f)
          (target-vz #f)
          (factor (* elapse 65))
          (first-person? (get-first-person?~ world))
          (fly? (get-fly?~ world))
          (old-position (copy-vertex position)))
      (when (get-modified?~ commands)
        (when (get-move-left?~ commands)
          (set! moving? #t)
          (set! target-vx (- player-speed)))
        (when (get-move-right?~ commands)
          (set! moving? #t)
          (set! target-vx player-speed))
        (when (get-move-down?~ commands)
          (if first-person?
              (begin
                (move-player-backward~ world self factor)
                (decrease! rotation (* 150. elapse)))
            (set! moving? #t)
            (set! target-vz player-speed)))
        (when (get-move-up?~ commands)
          (if first-person?
              (begin
                (move-player-forward~ world self factor)
                (unless fly?
                  (increase! rotation (* 150. elapse))))
            (set! moving? #t)
            (set! target-vz (- player-speed))))
        (when (get-strafe-left?~ commands)
          (when first-person?
            (strafe-player-left~ world self factor)))
        (when (get-strafe-right?~ commands)
          (when first-person?
            (strafe-player-right~ world self factor)))
        (when (get-strafe-up?~ commands)
          (when fly?
            (strafe-player-up~ world self factor)))
        (when (get-strafe-down?~ commands)
          (when fly?
            (strafe-player-down~ world self factor)))
        (when (get-rotate-left?~ commands)
          (when first-person?
            (rotate-player-left~ world self factor)))
        (when (get-rotate-right?~ commands)
          (when first-person?
            (rotate-player-right~ world self factor)))
        (when (and fly?
                   (not (get-rotate-left?~ commands))
                   (not (get-rotate-right?~ commands)))
          (reset-player-tilt~ world self)))
      (when (not moving?)
        (set! target-vx 0.)
        (set! target-vz 0.))
      (when target-vx
        (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
          (cond ((> (vertex-x velocity) target-vx)
                 (vertex-x-set! velocity (- (vertex-x velocity) deceleration))
                 (if (< (vertex-x velocity) target-vx)
                     (vertex-x-set! velocity target-vx)))
                ((< (vertex-x velocity) target-vx)
                 (vertex-x-set! velocity (+ (vertex-x velocity) deceleration))
                 (if (> (vertex-x velocity) target-vx)
                     (vertex-x-set! velocity target-vx))))))
      (when target-vz
        (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
          (cond ((> (vertex-z velocity) target-vz)
                 (vertex-z-set! velocity (- (vertex-z velocity) deceleration))
                 (if (< (vertex-z velocity) target-vz)
                     (vertex-z-set! velocity target-vz)))
                ((< (vertex-z velocity) target-vz)
                 (vertex-z-set! velocity (+ (vertex-z velocity) deceleration))
                 (if (> (vertex-z velocity) target-vz)
                     (vertex-z-set! velocity target-vz))))))
      (if (not (get-jump?~ commands))
          (set! ready? #t)
        (when (and floor? ready? (not jumping?))
          (set! ready? #f)
          (set! jumping? #t)
          (vertex-y-set! velocity (get-jump-impulsion~ world))))
      
      (set! floor? #f)
      (let ((target-position (copy-vertex position)))
        ;; reset to test collisions
        ;; this hack is until we change actions moving player by setting his position
        (set-position old-position)
        @wait-collision-debugged (vertex-x-set! target-position (+ (vertex-x target-position) (* (vertex-x velocity) factor)))
        @wait-collision-debugged (vertex-z-set! target-position (+ (vertex-z target-position) (* (vertex-z velocity) factor)))
        (when (< (vertex-y velocity) max-vy)
          (vertex-y-set! velocity max-vy))
        (let ((mvt (new Movement position (vertex- target-position position))))
          (receive (new-position last-direction) (collide&slide radius mvt #f)
            ;; try and use last-direction so next movement is aligned with it!?
            ;; (set! direction (vertex-normalize-safe last-direction))
            (let ((target-fall (copy-vertex new-position)))
              (unless fly?
                @need-to-generalize-gravity-as-a-vector-in-the-interpolation-algorithm
                (let ((gravity (compute-gravity~ zone position)))
                  (vertex+! velocity velocity (vertex-scalar* gravity factor))
                  (vertex+! position position (vertex-scalar* velocity factor))
                  (set! x (vertex-x position))
                  (set! y (vertex-y position))
                  (set! z (vertex-z position)))
                (let ((gravity (get-gravity~ world))
                      (adjusted (* elapse 50.)))
                  (vertex-y-set! velocity (- (vertex-y velocity) (* gravity adjusted)))
                  (vertex-y-set! target-fall (+ (vertex-y target-fall) (- (* (vertex-y velocity) adjusted) (* gravity .5 adjusted adjusted))))))
              (let ((mvt (new Movement new-position (vertex- target-fall new-position))))
                (receive (new-fall last-direction) (collide&stop radius mvt #f)
                  (let ((fall-collided? (vertex/=? new-fall target-fall)))
                    (if fall-collided?
                        (begin
                          (set! jumping? #f)
                          (set! floor? #t))
                      (let ((floor-level (+ (get-floor-level~ zone) radius-y)))
                        (when (and (< (vertex-y new-fall) floor-level) (not fly?))
                          (vertex-y-set! new-fall floor-level)
                          (vertex-y-set! velocity 0.)
                          (set! jumping? #f)
                          (set! floor? #t)))))
                  (set-position new-fall)
                  (update-area~ zone self old-position)
                  (vertex-! movement position old-position)
                  (when (and (eq? self me)
                             (not (vertex=? old-position new-fall)))
                    (camera-center-player~ world))))))))))
  
  
  (method (fire-missile direction)
    (when (< missiles-count max-missiles)
      (let ((target (player-target~ world self)))
        (let ((center (vertex+ target (vertex-scalar* direction 5.))))
          (let ((missile (new Missile parent: world x: (vertex-x center) y: (vertex-y center) z: (vertex-z center) actor: self)))
            (increase-missiles)
            (set-velocity~ missile (vertex-scalar* direction missile-speed))
            (add-element~ zone missile))))))
  
  
  (method (sit-down)
    )
  
  
  (method (move-left commands)
    (move-left~ commands))
  
  
  (method (move-right commands)
    (move-right~ commands))
  
  
  (method (move-down commands)
    (move-down~ commands))
  
  
  (method (move-up commands)
    (move-up~ commands))
  
  
  (method (strafe-left commands)
    (strafe-left~ commands))
  
  
  (method (strafe-right commands)
    (strafe-right~ commands))
  
  
  (method (strafe-up commands)
    (strafe-up~ commands))
  
  
  (method (strafe-down commands)
    (strafe-down~ commands))
  
  
  (method (rotate-left commands)
    (rotate-left~ commands))
  
  
  (method (rotate-right commands)
    (rotate-right~ commands))
  
  
  (method (space commands)
    (jump commands))
  
  
  (method (jump commands)
    (jump~ commands))
  
  
  (method (fire commands)
    (add-action~ commands 'fire (list (get-sight~ (get-eye-lookat~ world)))))
  
  
  (method (win)
    (set! jumping? #f)
    (set! state 'win)
    (update-position))
  
  
  (method (lose)
    (set! jumping? #f)
    (set! state 'lose)
    (update-position))
  
  
  (method (reset-state)
    (set! state #f))
  
  
  (method (reset-position)
    (set-position (or (get-start-position~ zone) (vertex -9.5 62.5 0.0))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-3d)
    (cond (avatar
           (draw-entity))
          ((in-history?)
           (draw-3d-history))
          (else
           (draw-as-sphere-actor movement rotation (get-mount~ world) 'high GL_LINE))))
  
  
  (method (draw-3d-history)
    (let ((x1 (get-left))
          (x2 (get-right))
          (y1 (get-bottom))
          (y2 (get-top))
          (z1 (get-back))
          (z2 (get-front)))
      (gl-colorize history-color)
      (render-block x1 x2 y1 y2 z1 z2 GL_LINE_LOOP))))


;;;
;;;; Pacman
;;;


(class Pacman extends Player
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set-color {Color Yellow})))


;;;
;;;; Commands
;;;


(class Commands extends Object
  
  
  (slot move-left?    <bool>   initialize #f getter generate)
  (slot move-right?   <bool>   initialize #f getter generate)
  (slot move-down?    <bool>   initialize #f getter generate)
  (slot move-up?      <bool>   initialize #f getter generate)
  (slot strafe-left?  <bool>   initialize #f getter generate)
  (slot strafe-right? <bool>   initialize #f getter generate)
  (slot strafe-up?    <bool>   initialize #f getter generate)
  (slot strafe-down?  <bool>   initialize #f getter generate)
  (slot rotate-left?  <bool>   initialize #f getter generate)
  (slot rotate-right? <bool>   initialize #f getter generate)
  (slot jump?         <bool>   initialize #f getter generate)
  (slot actions       <object> initialize (new-queue) getter generate)
  (slot last-no       <object> initialize #f getter generate)
  (slot modified?     <bool>   initialize #f getter generate)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{l}"
          `(,@(if move-left? '(move-left) '())
            ,@(if move-right? '(move-right) '())
            ,@(if move-down? '(move-down) '())
            ,@(if move-up? '(move-up) '())
            ,@(if strafe-left? '(strafe-left) '())
            ,@(if strafe-right? '(strafe-right) '())
            ,@(if strafe-up? '(strafe-up) '())
            ,@(if strafe-down? '(strafe-down) '())
            ,@(if rotate-left? '(rotate-left) '())
            ,@(if rotate-right? '(rotate-right) '())
            ,@(if jump? '(jump) '()))))))
  
  
  (method public (move-left)
    (set! move-left? #t)
    (set! modified? #t))
  
  (method public (move-right)
    (set! move-right? #t)
    (set! modified? #t))
  
  (method public (move-down)
    (set! move-down? #t)
    (set! modified? #t))
  
  (method public (move-up)
    (set! move-up? #t)
    (set! modified? #t))
  
  
  (method public (strafe-left)
    (set! strafe-left? #t)
    (set! modified? #t))
  
  (method public (strafe-right)
    (set! strafe-right? #t)
    (set! modified? #t))
  
  (method public (strafe-up)
    (set! strafe-up? #t)
    (set! modified? #t))
  
  (method public (strafe-down)
    (set! strafe-down? #t)
    (set! modified? #t))
  
  
  (method public (rotate-left)
    (set! rotate-left? #t)
    (set! modified? #t))
  
  (method public (rotate-right)
    (set! rotate-right? #t)
    (set! modified? #t))
  
  
  (method public (jump)
    (set! jump? #t)
    (set! modified? #t))
  
  
  (method public (add-action name arguments)
    (enqueue actions (cons name arguments))
    (set! modified? #t))
  
  
  (method public (enqueue-action action)
    (enqueue actions action)
    (set! modified? #t))
  
  
  (method public (set-last-no no)
    (set! last-no no))
  
  
  (method public (complete)
    (when (and modified? (is? actions Queue))
      (set! actions (queue-list actions))))
  
  
  (method (serialize)
    (vector move-left?
            move-right?
            move-down?
            move-up?
            strafe-left?
            strafe-right?
            strafe-up?
            strafe-down?
            rotate-left?
            rotate-right?
            jump?
            actions
            last-no))
  
  
  (method (deserialize vec)
    (set! move-left?    (vector-ref vec 0))
    (set! move-right?   (vector-ref vec 1))
    (set! move-down?    (vector-ref vec 2))
    (set! move-up?      (vector-ref vec 3))
    (set! strafe-left?  (vector-ref vec 4))
    (set! strafe-right? (vector-ref vec 5))
    (set! strafe-up?    (vector-ref vec 6))
    (set! strafe-down?  (vector-ref vec 7))
    (set! rotate-left?  (vector-ref vec 8))
    (set! rotate-right? (vector-ref vec 9))
    (set! jump?         (vector-ref vec 10))
    (set! actions       (vector-ref vec 11))
    (set! last-no       (vector-ref vec 12))
    (set! modified?     #t)))


(definition public (serialize-commands commands)
  (serialize~ commands))


(definition public (deserialize-commands vec)
  (let ((commands (new Commands)))
    (deserialize~ commands vec)
    commands)))
