;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Assets
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.assets jazz


(import (jazz.associative)
        (jazz.io)
        (world)
        (world.asset)
        (world.context))


;;;
;;;; Assets
;;;


(class Assets extends Object
  
  
  (slot where getter generate)
  
  
  (method override (initialize self where)
    (set! self.where where))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" where))))
  
  
  (method protected virtual (cache-index self)
    )
  
  
  (method protected virtual (retrieve-directory self path)
    )
  
  
  (method protected virtual (retrieve-file self path)
    )
  
  
  (method protected virtual (make-directory self path)
    )
  
  
  (method protected virtual (make-file self path)
    )
  
  
  (method protected (listify-path self path)
    (if (string? path)
        (tokenise-filename path)
      path))
  
  
  (method public virtual (iterate-entries self proc)
    (let ((index (cache-index self)))
      (for-each (lambda (entry)
                  (proc (car entry)))
                (get-entries index))))
  
  
  (method public virtual (contains-file? self filename)
    (find-entry (cache-index self) filename))
  
  
  (method public virtual (contains-directory? self dirname)
    (let ((dirname (normalize-directory dirname)))
      (continuation-capture
        (lambda (return)
          (iterate-entries self
            (lambda (path)
              (when (starts-with? path dirname)
                (continuation-return return #t))))
          #f)))))


;;;
;;;; Local
;;;


(class Local-Assets extends Assets
  
  
  (slot repository   getter generate)
  (slot remote-index getter generate)
  
  
  (method override (initialize self where directory)
    (nextmethod self where)
    (set! self.repository (new Associative-Repository directory init?: #t))
    (set! self.remote-index (new Associative-Index #f #f)))
  
  
  (method override (cache-index self)
    (get-index repository))
  
  
  ;; removed special handling to ensure consistency
  ;; of local assets being a subset of remote assets
  (method package (update-removed self changes)
    (let ((removed (collect-if (lambda (change)
                                 (eq? (car change) 'removed))
                               changes)))
      (when (not-null? removed)
        (let ((index (cache-index self)))
          (apply-changes index removed)
          (discarding-directories repository
            (lambda (discard-directory)
              (for-each (lambda (change)
                          (let ((path (cadr change)))
                            (let ((file (new-file (get-working repository) (tokenise-filename path))))
                              (when (exists? file)
                                (delete file)
                                (discard-directory (get-parent file))))))
                        removed)))))))
  
  
  (method override (retrieve-directory self dirpath)
    (let ((dirpath (normalize-directory dirpath)))
      (iterate-entries self
        (lambda (path)
          (when (starts-with? path dirpath)
            (retrieve-file self path))))
      (make-directory self dirpath)))
  
  
  (method override (retrieve-file self path)
    (let ((index (cache-index self)))
      (let ((entry (find-entry index path))
            (remote-entry (find-entry remote-index path))
            (file (new-file (get-working repository) (tokenise-filename path))))
        (assert remote-entry
          (if (and entry (equal? (second entry) (second remote-entry))
                ;; this test is a fail safe against someone deleting
                ;; a file from their assets directory without the jas
                ;; index being updated
                (exists? file))
              file
            (let ()
              (define (retrieve)
                (bind (content digest) (retrieve-asset self path)
                  (store-object repository content digest)
                  (retrieve-file repository digest file)
                  (update index path 'file (list remote-entry))
                  (save-to-file index)
                  file))
              
              (if (inhibit-working?)
                  (retrieve)
                (working self
                  (lambda ()
                    (retrieve))))))))))
  
  
  (method protected virtual (retrieve-asset self path)
    )
  
  
  (method override (make-directory self path) <Directory>
    (new-directory (get-working repository) (listify-path self path)))
  
  
  (method override (make-file self path) <File>
    (new-file (get-working repository) (listify-path self path)))
  
  
  (method protected virtual (working self thunk)
    (thunk))
  
  
  (method override (iterate-entries self proc)
    (for-each (lambda (entry)
                (let ((path (car entry)))
                  (proc path)))
              (get-entries remote-index)))
  
  
  (method override (contains-file? self filename)
    (find-entry remote-index filename)))


;;;
;;;; Remote
;;;


(class Remote-Assets extends Assets
  
  
  (slot repository getter generate)
  
  
  (method override (initialize self where directory)
    (nextmethod self where)
    (set! self.repository (new Associative-Repository directory init?: #t)))
  
  
  (method override (cache-index self)
    (get-index repository))
  
  
  (method override (retrieve-directory self dirpath)
    (let ((dirpath (normalize-directory dirpath)))
      (iterate-entries self
        (lambda (path)
          (when (starts-with? path dirpath)
            (retrieve-file self path))))
      (make-directory self dirpath)))
  
  
  (method override (retrieve-file self path)
    (let ((entry (find-entry repository path))
          (file (new-file (get-working repository) (tokenise-filename path))))
      (assert entry
        (bind (path digest seconds) entry
          (retrieve-file repository digest file)
          file))))
  
  
  (method override (make-directory self path) <Directory>
    (new-directory (get-working repository) (listify-path self path)))
  
  
  (method override (make-file self path) <File>
    (new-file (get-working repository) (listify-path self path))))


;;;
;;;; Directory
;;;


(definition public (make-directory-assets where dir)
  (new Directory-Assets where dir))


(class Directory-Assets extends Assets
  
  
  (slot directory               getter generate)
  (slot index     initialize #f getter generate)
  
  
  (method override (initialize self where directory)
    (nextmethod self where)
    (set! self.directory directory))
  
  
  (method override (cache-index self)
    (or index
        (let ((entries (scanning-directory "" directory
                         (lambda (path file base)
                           (list path #f #f)))))
          (let ((idx (new Associative-Index #f directory entries: entries)))
            (set! index idx)
            idx))))
  
  
  (method override (retrieve-directory self path)
    (make-directory self path))
  
  
  (method override (retrieve-file self path)
    (make-file self path))
  
  
  (method override (make-directory self path) <Directory>
    (new-directory directory (listify-path self path)))
  
  
  (method override (make-file self path) <File>
    (new-file directory (listify-path self path))))


;;;
;;;; Catalog
;;;


(class Catalog-Assets extends Directory-Assets))
