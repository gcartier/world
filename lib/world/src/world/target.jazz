;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Target
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.target jazz


(import (jazz.geometry)
        (jazz.opengl.glew)
        (world)
        (world.animation)
        (world.autoload)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.generate)
        (world.geometry)
        (world.quad)
        (world.syntax (phase syntax))
        (world.widget))


;;;
;;;; Widget
;;;


(class Target-Widget extends Widget
  
  
  (slot last-point initialize #f)
  
  
  (method (widget-dye name default (alpha #f))
    (let ((world (current-world)))
      (let ((down (get-widget-down~ world))
            (part (get-widget-part~ world)))
        (if (and (eq? self down) (eq? part name))
            (if alpha
                (dye 1. 1. 0. alpha)
              yellow-dye)
          default)))))


;;;
;;;; Mover
;;;


(class Mover extends Target-Widget
  
  
  (slot contact-offset)


  (method override (draw-widget)
    (let ((world (current-world)))
      (let ((target (first-target~ world)))
        (let ((x (get-x~ target))
              (y (get-y~ target))
              (z (get-z~ target))
              (sx (+ 1.5 (get-radius-x~ target)))
              (sy (+ 1.5 (get-radius-y~ target)))
              (sz (+ 1.5 (get-radius-z~ target)))
              (ps .5)
              (pa .4)
              (width .01))
          (glDisable GL_DEPTH_TEST)
          ;; Axis X
          (render-line (vertex (+ x 0.0) y (+ z 0.0))
                       (vertex (+ x  sx) y (+ z 0.0))
                       width
                       (widget-dye 'x red-dye))
          
          ;; Axis Y
          (render-line (vertex (+ x 0.0) (+ y 0.0) z)
                       (vertex (+ x 0.0) (+ y  sy) z)
                       width
                       (widget-dye 'y green-dye))
          
          ;; Axis Z
          (render-line (vertex (+ x 0.0) y (+ z 0.0))
                       (vertex (+ x 0.0) y (+ z  sz))
                       width
                       (widget-dye 'z blue-dye))
          
          ;; Plane X
          (render-quad (matrix-multiply& (make-translation-matrix& (vertex x (+ y .25) (+ z .25)))
                                         (matrix-multiply& (make-euler-matrix& (vertex 0. 0. PI/2))
                                                           (make-scaling-matrix& (vertex .5 .5 .5))))
                       wire-color: (widget-dye 'plane-x red-dye)
                       fill-color: (widget-dye 'plane-x (dye 1. 0. 0. pa) pa))
          
          ;; Plane Y
          (render-quad (matrix-multiply& (make-translation-matrix& (vertex (+ x .25) y (+ z .25)))
                                         (matrix-multiply& (make-euler-matrix& (vertex 0. 0. 0.))
                                                           (make-scaling-matrix& (vertex .5 .5 .5))))
                       wire-color: (widget-dye 'plane-y green-dye)
                       fill-color: (widget-dye 'plane-y (dye 0. 1. 0. pa) pa))
          
          ;; Plane Z
          (render-quad (matrix-multiply& (make-translation-matrix& (vertex (+ x .25) (+ y .25) z))
                                         (matrix-multiply& (make-euler-matrix& (vertex PI/2 0. 0.))
                                                           (make-scaling-matrix& (vertex .5 .5 .5))))
                       wire-color: (widget-dye 'plane-z blue-dye)
                       fill-color: (widget-dye 'plane-z (dye 0. 0. 1. pa) pa))
          
          ;; Arrow X
          (render-cone (matrix-multiply& (make-translation-matrix& (vertex (+ x sx) y z))
                                         (matrix-multiply& (make-euler-matrix& (vertex 0. PI/2 0.))
                                                           (make-scaling-matrix& (vertex .1 .1 .1))))
                       color: (widget-dye 'x red-dye))
          
          ;; Arrow Y
          (render-cone (matrix-multiply& (make-translation-matrix& (vertex x (+ y sy) z))
                                         (matrix-multiply& (make-euler-matrix& (vertex (- PI/2) 0. 0.))
                                                           (make-scaling-matrix& (vertex .1 .1 .1))))
                       color: (widget-dye 'y green-dye))
          
          ;; Arrow Z
          (render-cone (matrix-multiply& (make-translation-matrix& (vertex x y (+ z sz)))
                                         (matrix-multiply& (make-euler-matrix& (vertex 0. PI 0.))
                                                           (make-scaling-matrix& (vertex .1 .1 .1))))
                       color: (widget-dye 'z blue-dye))
          (glEnable GL_DEPTH_TEST)))))
  
  
  (method override (iterate-polygons proc)
    (let ((world (current-world)))
      (let ((target (first-target~ world)))
        (when (and target (target-moveable?~ target))
          (let ((x (get-x~ target))
                (y (get-y~ target))
                (z (get-z~ target))
                (sx (+ 1.5 (get-radius-x~ target)))
                (sy (+ 1.5 (get-radius-y~ target)))
                (sz (+ 1.5 (get-radius-z~ target)))
                (ps .5)
                (cuboid (make-cuboid))
                (cr .1)
                (ar .05))
            (define (iterate-plane v1 v2 v3 v4 part)
              (proc (make-quad (cons self part)
                               v1 v2 v3 v4)))
            
            (define (iterate-arrow x y z part)
              (cuboid! cuboid (- x cr) (- y cr) (- z cr) (+ x cr) (+ y cr) (+ z cr))
              (iterate-cuboid-quads cuboid (cons self part) proc))
            
            (define (iterate-axis left bottom back right top front part)
              (cuboid! cuboid left bottom back right top front)
              (iterate-cuboid-quads cuboid (cons self part) proc))
            
            (iterate-plane (vertex x y z)
                           (vertex x y (+ z ps))
                           (vertex x (+ y ps) (+ z ps))
                           (vertex x (+ y ps) z)
                           'plane-x)
            (iterate-plane (vertex x y z)
                           (vertex x y (+ z ps))
                           (vertex (+ x ps) y (+ z ps))
                           (vertex (+ x ps) y z)
                           'plane-y)
            (iterate-plane (vertex x y z)
                           (vertex x (+ y ps) z)
                           (vertex (+ x ps) (+ y ps) z)
                           (vertex (+ x ps) y z)
                           'plane-z)
            (iterate-arrow (+ x sx) y z 'x)
            (iterate-arrow x (+ y sy) z 'y)
            (iterate-arrow x y (+ z sz) 'z)
            (iterate-axis (+ x ps ar) (- y ar) (- z ar) (+ x sx) (+ y ar) (+ z ar) 'x)
            (iterate-axis (- x ar) (+ y ps ar) (- z ar) (+ x ar) (+ y sy) (+ z ar) 'y)
            (iterate-axis (- x ar) (- y ar) (+ z ps ar) (+ x ar) (+ y ar) (+ z sz) 'z))))))
  
  
  (method (widget-contact h v)
    (let ((world (current-world)))
      (let ((camera (current-camera))
            (pos (get-position~ (first-target~ world)))
            (part (get-widget-part~ world)))
        (receive (position direction) (screen->world~ camera h v)
          (receive (vertex normal) (case part
                                     ((plane-x) (ray-grid-intersection~ world position direction #t 'x (vertex-x pos)))
                                     ((plane-z) (ray-grid-intersection~ world position direction #t 'z (vertex-z pos)))
                                     ((x z plane-y) (ray-grid-intersection~ world position direction #t 'y (vertex-y pos)))
                                     ((y) (let ((sight (get-sight~ camera)))
                                            (if (> (vertex-z sight) (* 3. (vertex-x sight)))
                                                (ray-grid-intersection~ world position direction #t 'x (vertex-x pos))
                                              (ray-grid-intersection~ world position direction #t 'z (vertex-z pos))))))
            vertex)))))
  
  
  (method override (widget-mouse-down h v)
    (let ((world (current-world)))
      (let ((target (first-target~ world)))
        (set! contact-offset (vertex- (widget-contact h v) (get-position~ target))))))
  
  
  (method override (widget-mouse-move h v)
    (let ((world (current-world)))
      (let ((contact (widget-contact h v)))
        (when contact
          (let ((target (first-target~ world))
                (part (get-widget-part~ world)))
            (let ((new-position (vertex- contact contact-offset)))
              (let ((delta (vertex- new-position (get-position~ target))))
                (let ((projected-delta
                        (case part
                          ((plane-x plane-y plane-z) delta)
                          ((x) (vertex (vertex-x delta) 0. 0.))
                          ((y) (vertex 0. (vertex-y delta) 0.))
                          ((z) (vertex 0. 0. (vertex-z delta))))))
                  (move-selection (get-selection~ world) projected-delta)))))))))
  
  
  (method (move-selection selection delta)
    (for-each (lambda (elem)
                (move-element elem delta))
              selection))
  
  
  (method (move-element elem delta)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone))
            (old-position (copy-vertex (get-position~ elem))))
        (let ((new-position (vertex+ old-position delta)))
          (set-property~ designer elem 'position new-position)
          (update-element~ zone elem old-position)
          (invalidate-lightmaps~ zone elem))))))


;;;
;;;; Rotater
;;;


(class Rotater extends Target-Widget


  (method override (draw-widget)
    (let ((world (current-world)))
      (let ((target (first-target~ world)))
        (let ((x (get-x~ target))
              (y (get-y~ target))
              (z (get-z~ target))
              (sx (+ 1.5 (get-radius-x~ target)))
              (sy (+ 1.5 (get-radius-y~ target)))
              (sz (+ 1.5 (get-radius-z~ target)))
              (radius (+ .5 (get-radius~ target)))
              (width .01))
          (glDisable GL_DEPTH_TEST)
          ;; Axis X
          (render-line (vertex (+ x 0.0) y (+ z 0.0))
                       (vertex (+ x  sx) y (+ z 0.0))
                       width
                       (widget-dye 'x red-dye))
          
          ;; Axis Y
          (render-line (vertex (+ x 0.0) (+ y 0.0) z)
                       (vertex (+ x 0.0) (+ y  sy) z)
                       width
                       (widget-dye 'y green-dye))
          
          ;; Axis Z
          (render-line (vertex (+ x 0.0) y (+ z 0.0))
                       (vertex (+ x 0.0) y (+ z  sz))
                       width
                       (widget-dye 'z blue-dye))
          
          ;; Sphere X
          (render-sphere (matrix-multiply& (make-translation-matrix& (vertex (+ x sx) y z))
                                           (make-scaling-matrix& (vertex .1 .1 .1)))
                         color: (widget-dye 'x red-dye))
          
          ;; Sphere Y
          (render-sphere (matrix-multiply& (make-translation-matrix& (vertex x (+ y sy) z))
                                           (make-scaling-matrix& (vertex .1 .1 .1)))
                         color: (widget-dye 'y green-dye))
          
          ;; Sphere Z
          (render-sphere (matrix-multiply& (make-translation-matrix& (vertex x y (+ z sz)))
                                           (make-scaling-matrix& (vertex .1 .1 .1)))
                         color: (widget-dye 'z blue-dye))
          (glEnable GL_DEPTH_TEST)))))
  
  
  ;; quick hack
  (method override (iterate-polygons proc)
    (let ((world (current-world)))
      (let ((target (first-target~ world)))
        (when (and target (target-moveable?~ target))
          (let ((x (get-x~ target))
                (y (get-y~ target))
                (z (get-z~ target))
                (sx (+ 1.5 (get-radius-x~ target)))
                (sy (+ 1.5 (get-radius-y~ target)))
                (sz (+ 1.5 (get-radius-z~ target)))
                (cuboid (make-cuboid))
                (cr .1))
            (define (iterate x y z part)
              (cuboid! cuboid (- x cr) (- y cr) (- z cr) (+ x cr) (+ y cr) (+ z cr))
              (iterate-cuboid-quads cuboid (cons self part) proc))
            
            (iterate x y z 'global)
            (iterate (+ x sx) y z 'x)
            (iterate x (+ y sy) z 'y)
            (iterate x y (+ z sz) 'z))))))
  
  
  ;; quick hack
  (method override (widget-mouse-down h v)
    (set! last-point (new Point h v)))
  
  
  ;; quick hack
  (method override (widget-mouse-move h v)
    (let ((world (current-world)))
      (let ((selection (get-selection~ world))
            (part (get-widget-part~ world)))
        (let ((delta (- h (get-h~ last-point))))
          (set! last-point (new Point h v))
          (rotate-selection selection delta part)))))
  
  
  (method (rotate-selection selection delta part)
    (for-each (lambda (elem)
                (rotate-element elem delta part))
              selection))
  
  
  (method (rotate-element elem delta part)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone))
            (d (cast <fl> delta)))
        (let ((inc (* d (/ PI/8 2.))))
          (case part
            ((x) (set-lookat~ elem (rotate-lookat& (get-lookat~ elem) inc (get-sight~ (get-lookat~ elem)))))
            ((y) (set-lookat~ elem (rotate-lookat& (get-lookat~ elem) inc (get-up~ (get-lookat~ elem)))))
            ((z) (set-lookat~ elem (rotate-lookat& (get-lookat~ elem) inc (get-right~ (get-lookat~ elem))))))
          (set-property~ designer elem 'lookat (get-lookat~ elem)))))))


;;;
;;;; Scaler
;;;


(class Scaler extends Target-Widget


  (method override (draw-widget)
    (let ((world (current-world)))
      (let ((target (first-target~ world)))
        (let ((x (get-x~ target))
              (y (get-y~ target))
              (z (get-z~ target))
              (sx (+ 1.5 (get-radius-x~ target)))
              (sy (+ 1.5 (get-radius-y~ target)))
              (sz (+ 1.5 (get-radius-z~ target)))
              (width .01))
          (glDisable GL_DEPTH_TEST)
          ;; Axis X
          (render-line (vertex (+ x 0.0) y (+ z 0.0))
                       (vertex (+ x  sx) y (+ z 0.0))
                       width
                       (widget-dye 'x red-dye))
          
          ;; Axis Y
          (render-line (vertex (+ x 0.0) (+ y 0.0) z)
                       (vertex (+ x 0.0) (+ y  sy) z)
                       width
                       (widget-dye 'y green-dye))
          
          ;; Axis Z
          (render-line (vertex (+ x 0.0) y (+ z 0.0))
                       (vertex (+ x 0.0) y (+ z  sz))
                       width
                       (widget-dye 'z blue-dye))
          
          ;; Sphere X
          (render-sphere (matrix-multiply& (make-translation-matrix& (vertex (+ x sx) y z))
                                           (make-scaling-matrix& (vertex .1 .1 .1)))
                         color: (widget-dye 'x red-dye))
          
          ;; Sphere Y
          (render-sphere (matrix-multiply& (make-translation-matrix& (vertex x (+ y sy) z))
                                           (make-scaling-matrix& (vertex .1 .1 .1)))
                         color: (widget-dye 'y green-dye))
          
          ;; Sphere Z
          (render-sphere (matrix-multiply& (make-translation-matrix& (vertex x y (+ z sz)))
                                           (make-scaling-matrix& (vertex .1 .1 .1)))
                         color: (widget-dye 'z blue-dye))
          
          ;; Sphere Global
          (render-sphere (matrix-multiply& (make-translation-matrix& (vertex x y z))
                                           (make-scaling-matrix& (vertex .15 .15 .15)))
                         color: (widget-dye 'global (dye .5 .5 .5 1.)))
          (glEnable GL_DEPTH_TEST)))))
  
  
  (method override (iterate-polygons proc)
    (let ((world (current-world)))
      (let ((target (first-target~ world)))
        (when (and target (target-moveable?~ target))
          (let ((x (get-x~ target))
                (y (get-y~ target))
                (z (get-z~ target))
                (sx (+ 1.5 (get-radius-x~ target)))
                (sy (+ 1.5 (get-radius-y~ target)))
                (sz (+ 1.5 (get-radius-z~ target)))
                (cuboid (make-cuboid))
                (cr .1))
            (define (iterate x y z part)
              (cuboid! cuboid (- x cr) (- y cr) (- z cr) (+ x cr) (+ y cr) (+ z cr))
              (iterate-cuboid-quads cuboid (cons self part) proc))
            
            (iterate x y z 'global)
            (iterate (+ x sx) y z 'x)
            (iterate x (+ y sy) z 'y)
            (iterate x y (+ z sz) 'z))))))
  
  
  (method override (widget-mouse-down h v)
    (set! last-point (new Point h v)))
  
  
  (method override (widget-mouse-move h v)
    (let ((world (current-world)))
      (let ((selection (get-selection~ world))
            (part (get-widget-part~ world)))
        (let ((delta (- h (get-h~ last-point))))
          (set! last-point (new Point h v))
          (scale-selection selection delta part)))))
  
  
  (method (scale-selection selection delta part)
    (for-each (lambda (elem)
                (scale-element elem delta part))
              selection))
  
  
  (method (scale-element elem delta part)
    (let ((zone (current-zone)))
      (let ((designer (get-designer~ zone))
            (d (cast <fl> delta))
            (f 1.025))
        (let ((factor (if (> d 0.) f (/ f))))
          (let ((s (case part
                     ((global) (vertex factor factor factor))
                     ((x) (vertex factor 1. 1.))
                     ((y) (vertex 1. factor 1.))
                     ((z) (vertex 1. 1. factor)))))
            (set-property~ designer elem 'scale (vertex* (get-scale~ elem) s))))))))


;;;
;;;; Skeleton
;;;


(definition selected-bone
  #f)

(definition selected-chain
  #f)

(definition public (get-selected-bone)
  selected-bone)

(definition public (get-selected-chain)
  selected-chain)

(definition public (set-selected-bone bone)
  (set! selected-bone bone)
  (set! selected-chain (and bone (bone-chain (get-animation~ ?o) bone))))


(class Skeleton extends Target-Widget
  
  
  (method override (draw-widget)
    (let ((world (current-world)))
      (for-each (lambda (target)
                  (let ((morphing (get-morphing~ target)))
                    (when morphing
                      (let ((morphs (get-morphs~ morphing)))
                        (define (draw parent level)
                          (loop (for morph in-vector morphs)
                                (when (eq? (get-parent~ morph) parent)
                                  (let ((selected? (eqv? (get-index~ (get-bone~ morph)) selected-bone)))
                                    (let ((scaling (if selected? .05 .015)))
                                      (let ((matrix (matrix-multiply& (get-matrix~ target) (matrix-multiply& (make-y-rotation-matrix& PI/2) (matrix-multiply& (get-global-matrix~ morph) (make-scaling-matrix& (vertex& scaling scaling scaling)))))))
                                        (render-sphere matrix color: (if selected? yellow-dye red-dye))
                                        (when parent
                                          (let ((parent-matrix (matrix-multiply& (get-matrix~ target) (matrix-multiply& (make-y-rotation-matrix& PI/2) (matrix-multiply& (get-global-matrix~ parent) (make-scaling-matrix& (vertex& scaling scaling scaling))))))
                                                (parent-selected? (eqv? (get-index~ (get-bone~ parent)) selected-bone))
                                                (morph-selected? (and selected-chain (memv? (get-index~ (get-bone~ morph)) selected-chain))))
                                            (let ((pos (matrix-transform& matrix (vertex& 0. 0. 0.)))
                                                  (parent-pos (matrix-transform& parent-matrix (vertex& 0. 0. 0.))))
                                              (render-line parent-pos pos .005 (if parent-selected? yellow-dye (if morph-selected? green-dye blue-dye)))))))))
                                  (draw morph (+ level 1)))))
                        
                        (glDisable GL_DEPTH_TEST)
                        (draw #f 0)
                        (glEnable GL_DEPTH_TEST)))))
                (get-selection~ world))))))
