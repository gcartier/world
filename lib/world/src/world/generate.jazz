;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Generate
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.generate jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.area)
        (world.autoload)
        (world.face)
        (world.geometry)
        (world.mesh)
        (world.polygon)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Void
;;;


(definition public (generate-void generator)
  (generator
    (lambda (triangles quads)
      )
    (lambda (v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v tdepth)
      )
    (lambda (v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v v4 n4 t4u t4v tdepth)
      )))


;;;
;;;; Debug
;;;


(definition public (generate-debug generator)
  (generator
    (lambda (triangles quads)
      (debug 'setup triangles quads))
    (lambda (v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v tdepth)
      (debug 'triangle v1 v2 v3))
    (lambda (v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v v4 n4 t4u t4v tdepth)
      (debug 'quad v1 v2 v3 v4))))


;;;
;;;; Cuboid
;;;


(definition public (iterate-cuboid-quads cuboid element proc)
  (let ((left (cuboid-left cuboid))
        (right (cuboid-right cuboid))
        (bottom (cuboid-bottom cuboid))
        (top (cuboid-top cuboid))
        (back (cuboid-back cuboid))
        (front (cuboid-front cuboid)))
    ;; front face
    (proc (make-quad element (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front)))
    ;; back face
    (proc (make-quad element (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back)))
    ;; left face
    (proc (make-quad element (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front)))
    ;; right face
    (proc (make-quad element (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back)))
    ;; top face
    (proc (make-quad element (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back)))
    ;; bottom face
    (proc (make-quad element (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front)))))


(definition public (iterate-cuboid-inner-quads cuboid element proc)
  (let ((left (cuboid-left cuboid))
        (right (cuboid-right cuboid))
        (bottom (cuboid-bottom cuboid))
        (top (cuboid-top cuboid))
        (back (cuboid-back cuboid))
        (front (cuboid-front cuboid)))
    (define (iterate v1 v2 v3 v4)
      (proc (make-quad element v4 v3 v2 v1)))
    
    ;; front face
    (iterate (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front))
    ;; back face
    (iterate (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back))
    ;; left face
    (iterate (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front))
    ;; right face
    (iterate (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back))
    ;; top face
    (iterate (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back))
    ;; bottom face
    (iterate (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front))))


(definition public (ray-closest-cuboid-inner-quad orig <f64vector> dir <f64vector> cuboid)
  (let ((closest #f)
        (distance #f))
    (iterate-cuboid-inner-quads cuboid #f
      (lambda (quad)
        (let ((cls (ray-closest-triangle~ quad orig dir #f)))
          (when cls
            (bind (poly dist) cls
              (when (or (not distance)
                        (< dist distance))
                (set! closest (list poly dist))
                (set! distance dist)))))))
    closest))


;;;
;;;; Parallelepiped
;;;


(definition public (iterate-parallelepiped-quads para sphere-matrix poly proc element)
  (let ((left/bottom/back (get-left/bottom/back~ para))
        (left/bottom/front (get-left/bottom/front~ para))
        (left/top/back (get-left/top/back~ para))
        (left/top/front (get-left/top/front~ para))
        (right/bottom/back (get-right/bottom/back~ para))
        (right/bottom/front (get-right/bottom/front~ para))
        (right/top/back (get-right/top/back~ para))
        (right/top/front (get-right/top/front~ para)))
    (define (transform v1 v2 v3 v4)
      (proc (make-quad element
                       (matrix+-transform-3x4 sphere-matrix v1)
                       (matrix+-transform-3x4 sphere-matrix v2)
                       (matrix+-transform-3x4 sphere-matrix v3)
                       (matrix+-transform-3x4 sphere-matrix v4))))
    
    ;; top
    (transform right/top/back left/top/back left/top/front right/top/front)
    ;; bottom
    (transform right/bottom/front left/bottom/front left/bottom/back right/bottom/back)
    ;; front
    (transform left/bottom/front right/bottom/front right/top/front left/top/front)
    ;; back
    (transform right/bottom/back left/bottom/back left/top/back right/top/back)
    ;; left
    (transform left/top/front left/top/back left/bottom/back left/bottom/front)
    ;; right
    (transform right/top/back right/top/front right/bottom/front right/bottom/back)))


;;;
;;;; Mesh
;;;


(definition public (generate-mesh generator (matrix: matrix #f) (neighbors?: neighbors? #f) (smooth-normals?: smooth-normals? #f) (material: material #f) (return-faces?: return-faces? #f))
  (let ((vertex-floats 10)
        (neighbors-floats 6)
        (triangles-count <fx+> #f)
        (triangle-floats <fx+> #f)
        (triangle-neighbors-floats <fx+> #f)
        (content <f32vector+> #f)
        (neighbors <f32vector+> #f)
        (n 0)
        (m 0)
        (smooth-normals (and smooth-normals? (make-table test: vertex=? hash: vertex-hash)))
        (faces (and return-faces? (new-queue))))
    (define (setup triangles <fx> quads <fx>)
      (unless return-faces?
        (set! triangles-count (+ triangles (* quads 2)))
        (set! triangle-floats (* 3 vertex-floats))
        (set! triangle-neighbors-floats (* 3 7))
        (set! content (make-f32vector (* triangles-count triangle-floats)))
        (when neighbors?
          (set! neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))))
    
    (define (add-triangle v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v tdepth)
      (add
        (transform v1) n1 t1u t1v
        (transform v2) n2 t2u t2v
        (transform v3) n3 t3u t3v
        tdepth))
    
    (define (add-quad v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v v4 n4 t4u t4v tdepth)
      (add
        (transform v1) n1 t1u t1v
        (transform v2) n2 t2u t2v
        (transform v3) n3 t3u t3v
        tdepth)
      (add
        (transform v3) n3 t3u t3v
        (transform v4) n4 t4u t4v
        (transform v1) n1 t1u t1v
        tdepth))
    
    (define (transform vert)
      (matrix+-transform-3x4 matrix vert))
    
    (define (add v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v tdepth)
      (let ((plane-normal #f))
        (define (get-plane-normal)
          (or plane-normal (let ((normal (plane-normal-safe v1 v2 v3)))
                             (set! plane-normal normal)
                             normal)))
        
        (let ((n1 (or n1 (get-plane-normal)))
              (n2 (or n2 (get-plane-normal)))
              (n3 (or n3 (get-plane-normal))))
          (when smooth-normals?
            (let ((plane-normal (get-plane-normal)))
              (define (process-vertex vert)
                (let ((vert (if return-faces? vert (vertex-64->32 vert))))
                  (let ((smooth-normal (table-ref smooth-normals vert #f)))
                    (if (not smooth-normal)
                        (table-set! smooth-normals vert plane-normal)
                      (vertex-increase! smooth-normal plane-normal)))))
              
              (process-vertex v1)
              (process-vertex v2)
              (process-vertex v3)))
          (if return-faces?
              (enqueue faces (make-face material
                                        (f32vector t1u t1v t2u t2v t3u t3v)
                                        tdepth
                                        (make-smooth-triangle #f v1 v2 v3 n1 n2 n3)))
            (add-vertex v1) (add-normal n1) (add-texture t1u t1v tdepth) (add-bone) (when neighbors? (add-neighbors 0. v2 v3))
            (add-vertex v2) (add-normal n2) (add-texture t2u t2v tdepth) (add-bone) (when neighbors? (add-neighbors 1. v1 v3))
            (add-vertex v3) (add-normal n3) (add-texture t3u t3v tdepth) (add-bone) (when neighbors? (add-neighbors 2. v1 v2))))))
    
    (define (add-vertex vert)
      (f32vector-set! content n (vertex-x vert))
      (f32vector-set! content (+ n 1) (vertex-y vert))
      (f32vector-set! content (+ n 2) (vertex-z vert))
      (set! n (+ n 3)))
    
    (define (add-normal normal)
      (f32vector-set! content n (vertex-x normal))
      (f32vector-set! content (+ n 1) (vertex-y normal))
      (f32vector-set! content (+ n 2) (vertex-z normal))
      (set! n (+ n 3)))
    
    (define (add-texture tu tv tdepth)
      (f32vector-set! content n tu)
      (f32vector-set! content (+ n 1) tv)
      (f32vector-set! content (+ n 2) tdepth)
      (set! n (+ n 3)))
    
    (define (add-bone)
      (f32vector-set! content n 0.)
      (set! n (+ n 1)))
    
    (define (add-neighbors rank n1 n2)
      (f32vector-set! neighbors m rank)
      (set! m (+ m 1))
      (f32vector-set! neighbors m (vertex-x n1))
      (f32vector-set! neighbors (+ m 1) (vertex-y n1))
      (f32vector-set! neighbors (+ m 2) (vertex-z n1))
      (set! m (+ m 3))
      (f32vector-set! neighbors m (vertex-x n2))
      (f32vector-set! neighbors (+ m 1) (vertex-y n2))
      (f32vector-set! neighbors (+ m 2) (vertex-z n2))
      (set! m (+ m 3)))
    
    (generator setup add-triangle add-quad)
    (when smooth-normals?
      (iterate-table smooth-normals
        (lambda (vert smooth-normal)
          (vertex-normalize! smooth-normal smooth-normal)))
      (if return-faces?
          (for-each (lambda (face <Face>)
                      (let ((triangle <Smooth-Triangle> (get-polygon~ face)))
                        (let ((v1 (get-v1~ triangle)))
                          (let ((smooth-normal (table-ref smooth-normals v1)))
                            (set-n1~ triangle smooth-normal)))
                        (let ((v2 (get-v2~ triangle)))
                          (let ((smooth-normal (table-ref smooth-normals v2)))
                            (set-n2~ triangle smooth-normal)))
                        (let ((v3 (get-v3~ triangle)))
                          (let ((smooth-normal (table-ref smooth-normals v3)))
                            (set-n3~ triangle smooth-normal)))))
                    (queue-list faces))
        (loop (for i from 0 below triangles-count)
              (let ((n (* i triangle-floats)))
                (define (smooth-vertex offset <fx>)
                  (let ((vert (vertex (f32vector-ref content offset) (f32vector-ref content (+ offset 1)) (f32vector-ref content (+ offset 2)))))
                    (let ((smooth-normal (table-ref smooth-normals vert)))
                      (f32vector-set! content (+ offset 3) (vertex-x smooth-normal))
                      (f32vector-set! content (+ offset 4) (vertex-y smooth-normal))
                      (f32vector-set! content (+ offset 5) (vertex-z smooth-normal)))))
                
                (smooth-vertex n)
                (smooth-vertex (+ n vertex-floats))
                (smooth-vertex (+ n (* vertex-floats 2)))))))
    (if return-faces?
        (queue-list faces)
      (let ((mesh (new Mesh material: material)))
        (allocate-vertices~ mesh)
        (set-data~ (get-vertices-buffer~ mesh) content vertex-floats)
        (when neighbors?
          (allocate-neighbors~ mesh)
          (set-data~ (get-neighbors-buffer~ mesh) neighbors neighbors-floats))
        mesh))))


;;;
;;;; Faces
;;;


(definition public (generate/add-faces generator (matrix: matrix #f) (smooth-normals?: smooth-normals? #f) (material: material #f))
  (let ((zone (current-zone)))
    (let ((faces (generate-mesh generator matrix: matrix smooth-normals?: smooth-normals? material: material return-faces?: #t))
          (sectors (make-table test: eq?)))
      (for-each (lambda (face)
                  (let ((sector (position-sector~ zone (get-center~ (get-polygon~ face)))))
                    (add-face~ sector face)
                    (table-set! sectors sector #t)))
                faces)
      (iterate-table sectors
        (lambda (sector ignore)
          (set-vertices-uptodate?~ sector #f)
          (set-lightmap-uptodate?~ sector #f))))))


(definition public (faces-generator faces)
  (lambda (setup-proc triangle-proc quad-proc)
    (define (count)
      (let ((triangles 0)
            (quads 0))
        (for-each (lambda (face)
                    (increase! triangles (triangle-count~ face)))
                  faces)
        (setup-proc triangles quads)))
    
    (count)
    (for-each (lambda (face)
                (add-triangles~ face triangle-proc))
              faces)))


;;;
;;;; Polygons
;;;


(definition public (polygons-extract element polygons matrix)
  (let ((queue (new-queue)))
    (loop (for i from 0 below (/ (f64vector-length polygons) polygon-float-size))
          (let ((offset (* i polygon-float-size)))
            (let ((poly (if (nan? (f64vector-ref polygons (+ offset 12)))
                            (make-triangle element (make-zero-vertex) (make-zero-vertex) (make-zero-vertex))
                          (make-quad element (make-zero-vertex) (make-zero-vertex) (make-zero-vertex) (make-zero-vertex)))))
              (enqueue queue (polygon-extract!~ poly element polygons offset matrix)))))
    (queue-list queue)))


(definition public (generate/add-polygons generator (element: element #f) (matrix: matrix #f))
  (let ((world (current-world))
        (zone (current-zone))
        (areas #f))
    (define (setup triangles quads)
      (set! areas (make-table test: eq?)))
    
    (define (add-triangle v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v tdepth)
      (add-polygon (triangle-class~ world) (vector v1 v2 v3)))
    
    (define (add-quad v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v v4 n4 t4u t4v tdepth)
      (add-polygon (quad-class~ world) (vector v1 v2 v3 v4)))
    
    (define (add-polygon class vertices)
      (define (transform vertex)
        (matrix+-transform-3x4 matrix vertex))
      
      (let ((vertices vertices))
        (let ((polygon <Polygon> (new class element vertices)))
          (let ((center (matrix+-transform-3x4 matrix (get-center~ polygon))))
            (let ((area (index-area~ zone (position-area-index~ zone center) #f)))
              (table-add areas area polygon))))))
    
    (generator setup add-triangle add-quad)
    (iterate-table areas
      (lambda (area <Area> polygons)
        (add-polygons~ area element polygons matrix))))))
