;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Generate
;;;


(module world.generate jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.geometry)
        (world.mesh)
        (world.texture))


;;;
;;;; Cone
;;;


@finish-conversion
(definition public (generate-cone p1 <f32vector> p2 <f32vector> r1 <fl> r2 <fl> m <fx> theta1 <fl> theta2 <fl>)
  (let ;; Normal pointing from p1 to p2
      ((n (vertex- p1 p2)))
    ;; Create two perpendicular vectors perp and q on the plane of the disk
    (let ((perp n))
      (if (and (= (vertex-x n) 0.) (= (vertex-z n) 0.))
          (vertex-x-set! n (+ (vertex-x n) 1))
        (vertex-y-set! n (+ (vertex-y n) 1)))
      (let ((perp (cross-product n q)))
        (let ((n (cross-product q perp)))
          (vertex-normalize! perp perp)
          (vertex-normalize! q q)
          (glBegin GL_QUAD_STRIP)
          (loop (for i from 0 to m)
                (let ((theta (+ theta1 (/ (* i (- theta2 theta1)) m))))
                  (vertex-x-set! n (+ (* (cos theta) perp.x) (* (sin theta) q.x)))
                  (vertex-y-set! n (+ (* (cos theta) perp.y) (* (sin theta) q.y)))
                  (vertex-z-set! n (+ (* (cos theta) perp.z) (* (sin theta) q.z)))
                  (vertex-normalize! n n)
                  
                  p.x = p2.x + r2 * n.x
                  p.y = p2.y + r2 * n.y
                  p.z = p2.z + r2 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 1.0)
                  glVertex3f(p.x p.y p.z)
                  
                  p.x = p1.x + r1 * n.x
                  p.y = p1.y + r1 * n.y
                  p.z = p1.z + r1 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 0.0)
                  glVertex3f(p.x p.y p.z)))
          (glEnd))))))


;;;
;;;; Sphere
;;;


(definition public (generate-sphere slices stacks uv (material: material #f))
  (let ((dphi (/ 360. slices))
        (dtheta (/ 180. stacks)))
    (define (count-sphere) <fx>
      (let ((count 0))
        (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
              (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                    (if (and (> theta -90.) (< theta 90.))
                        (increase! count 2)
                      (increase! count))))
        count))
    
    (let ((floats-per-indice 10))
      (let ((mesh (new Mesh material: material))
            (triangles-count (count-sphere))
            (triangle-floats (* 3 floats-per-indice))
            (DTOR (/ PI*2 360.))
            (tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv)))
        (let ((content (make-f32vector (* triangles-count triangle-floats)))
              (n 0))
          (define (add-triangle v1 v2 v3)
            (add
              v1 v2 v3
              tl tb tr tb tr tt
              texture-depth))
          (define (add-quad v1 v2 v3 v4)
            (add
              v1 v2 v3
              tl tb tr tb tr tt
              texture-depth)
            (add
              v3 v4 v1
              tr tt tl tt tl tb
              texture-depth))
          
          (define (add v1 v2 v3 t1u t1v t2u t2v t3u t3v tdepth)
            (let ((normal (plane-normal-safe v1 v2 v3)))
              (add-vertex v1) (add-normal normal) (add-texture t1u t1v tdepth) (add-bone)
              (add-vertex v2) (add-normal normal) (add-texture t2u t2v tdepth) (add-bone)
              (add-vertex v3) (add-normal normal) (add-texture t3u t3v tdepth) (add-bone)))
          
          (define (add-vertex vert)
            (f32vector-set! content n (vertex-x vert))
            (f32vector-set! content (+ n 1) (vertex-y vert))
            (f32vector-set! content (+ n 2) (vertex-z vert))
            (set! n (+ n 3)))
          
          (define (add-normal normal)
            (f32vector-set! content n (vertex-x normal))
            (f32vector-set! content (+ n 1) (vertex-y normal))
            (f32vector-set! content (+ n 2) (vertex-z normal))
            (set! n (+ n 3)))
          
          (define (add-texture tu tv tdepth)
            (f32vector-set! content n tu)
            (f32vector-set! content (+ n 1) tv)
            (f32vector-set! content (+ n 2) tdepth)
            (set! n (+ n 3)))
          
          (define (add-bone)
            (f32vector-set! content n 0.)
            (set! n (+ n 1)))
          
          (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
                (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                      @pacman (for phi <fl> from (* dphi 4) to (- 360. dphi) by dphi)
                      (let ((v1 (vertex  (* (cos (* theta DTOR)) (cos (* phi DTOR)))
                                         (* (cos (* theta DTOR)) (sin (* phi DTOR)))
                                         (sin (* theta DTOR))))
                            (v2 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* phi DTOR)))
                                        (* (cos (* (+ theta dtheta) DTOR)) (sin (* phi DTOR)))
                                        (sin (* (+ theta dtheta) DTOR))))
                            (v3 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* (+ phi dphi) DTOR)))
                                        (* (cos (* (+ theta dtheta) DTOR)) (sin (* (+ phi dphi) DTOR)))
                                        (sin (* (+ theta dtheta) DTOR))))
                            (v4 (when (and (> theta -90.) (< theta 90.))
                                  (vertex (* (cos (* theta DTOR)) (cos (* (+ phi dphi) DTOR)))
                                          (* (cos (* theta DTOR)) (sin (* (+ phi dphi) DTOR)))
                                          (sin (* theta DTOR))))))
                        (if v4
                            (add-quad v1 v2 v3 v4)
                          (add-triangle v1 v2 v3)))))
          (allocate-vertices~ mesh)
          (set-data~ (get-vertices-buffer~ mesh) content floats-per-indice)
          mesh))))))
