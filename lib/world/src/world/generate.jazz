;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Generate
;;;


(module world.generate jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.area)
        (world.autoload)
        (world.geometry)
        (world.mesh)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile))


;;;
;;;; Cone
;;;


@finish-conversion
(definition public (generate-cone p1 <f64vector> p2 <f64vector> r1 <fl> r2 <fl> m <fx> theta1 <fl> theta2 <fl>)
  (let ;; Normal pointing from p1 to p2
      ((n (vertex- p1 p2)))
    ;; Create two perpendicular vectors perp and q on the plane of the disk
    (let ((perp n))
      (if (and (= (vertex-x n) 0.) (= (vertex-z n) 0.))
          (vertex-x-set! n (+ (vertex-x n) 1))
        (vertex-y-set! n (+ (vertex-y n) 1)))
      (let ((perp (cross-product n q)))
        (let ((n (cross-product q perp)))
          (vertex-normalize! perp perp)
          (vertex-normalize! q q)
          (glBegin GL_QUAD_STRIP)
          (loop (for i from 0 to m)
                (let ((theta (+ theta1 (/ (* i (- theta2 theta1)) m))))
                  (vertex-x-set! n (+ (* (cos theta) perp.x) (* (sin theta) q.x)))
                  (vertex-y-set! n (+ (* (cos theta) perp.y) (* (sin theta) q.y)))
                  (vertex-z-set! n (+ (* (cos theta) perp.z) (* (sin theta) q.z)))
                  (vertex-normalize! n n)
                  
                  p.x = p2.x + r2 * n.x
                  p.y = p2.y + r2 * n.y
                  p.z = p2.z + r2 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 1.0)
                  glVertex3f(p.x p.y p.z)
                  
                  p.x = p1.x + r1 * n.x
                  p.y = p1.y + r1 * n.y
                  p.z = p1.z + r1 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 0.0)
                  glVertex3f(p.x p.y p.z)))
          (glEnd))))))


;;;
;;;; Sphere
;;;


(definition public (generate-sphere slices stacks uv what (matrix: matrix #f) (material: material #f))
  (let ((world (current-world))
        (zone (current-zone))
        (dphi (/ 360. slices))
        (dtheta (/ 180. stacks)))
    (define (count-sphere) <fx>
      (let ((count 0))
        (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
              (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                    (if (and (> theta -90.) (< theta 90.))
                        (increase! count 2)
                      (increase! count))))
        count))
    
    (let ((floats-per-indice 10))
      (let ((triangles-count (count-sphere))
            (triangle-floats (* 3 floats-per-indice))
            (DTOR (/ PI*2 360.))
            (tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv))
            (areas (and (eq? what 'physical) (make-table test: eq?))))
        (let ((content (and (eq? what 'render) (make-f32vector (* triangles-count triangle-floats))))
              (n 0))
          (define (add-triangle v1 v2 v3)
            (if (eq? what 'physical)
                (add-polygon (triangle-class~ world) (vector v3 v2 v1))
              (add
                v1 v2 v3
                tl tb tr tb tr tt
                texture-depth)))
          
          (define (add-quad v1 v2 v3 v4)
            (if (eq? what 'physical)
                (add-polygon (quad-class~ world) (vector v4 v3 v2 v1))
              (add
                v1 v2 v3
                tl tb tr tb tr tt
                texture-depth)
              (add
                v3 v4 v1
                tr tt tl tt tl tb
                texture-depth)))
          
          (define (add-polygon class vertices)
            (define (transform vertex)
              (matrix-transform-3x4 matrix vertex))
            
            (let ((vertices (vector-map transform vertices)))
              (let ((polygon (new class #f vertices)))
                (let ((center (get-center~ polygon)))
                  (let ((area (index-area~ zone (position-area-index~ zone center) #f)))
                    (table-add areas area polygon))))))
          
          (define (add v1 v2 v3 t1u t1v t2u t2v t3u t3v tdepth)
            (let ((normal (plane-normal-safe v1 v2 v3)))
              (add-vertex v1) (add-normal normal) (add-texture t1u t1v tdepth) (add-bone)
              (add-vertex v2) (add-normal normal) (add-texture t2u t2v tdepth) (add-bone)
              (add-vertex v3) (add-normal normal) (add-texture t3u t3v tdepth) (add-bone)))
          
          (define (add-vertex vert)
            (f32vector-set! content n (vertex-x vert))
            (f32vector-set! content (+ n 1) (vertex-y vert))
            (f32vector-set! content (+ n 2) (vertex-z vert))
            (set! n (+ n 3)))
          
          (define (add-normal normal)
            (f32vector-set! content n (vertex-x normal))
            (f32vector-set! content (+ n 1) (vertex-y normal))
            (f32vector-set! content (+ n 2) (vertex-z normal))
            (set! n (+ n 3)))
          
          (define (add-texture tu tv tdepth)
            (f32vector-set! content n tu)
            (f32vector-set! content (+ n 1) tv)
            (f32vector-set! content (+ n 2) tdepth)
            (set! n (+ n 3)))
          
          (define (add-bone)
            (f32vector-set! content n 0.)
            (set! n (+ n 1)))
          
          (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
                (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                      @pacman (for phi <fl> from (* dphi 4) to (- 360. dphi) by dphi)
                      (let ((v1 (vertex  (* (cos (* theta DTOR)) (cos (* phi DTOR)))
                                         (* (cos (* theta DTOR)) (sin (* phi DTOR)))
                                         (sin (* theta DTOR))))
                            (v2 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* phi DTOR)))
                                        (* (cos (* (+ theta dtheta) DTOR)) (sin (* phi DTOR)))
                                        (sin (* (+ theta dtheta) DTOR))))
                            (v3 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* (+ phi dphi) DTOR)))
                                        (* (cos (* (+ theta dtheta) DTOR)) (sin (* (+ phi dphi) DTOR)))
                                        (sin (* (+ theta dtheta) DTOR))))
                            (v4 (when (and (> theta -90.) (< theta 90.))
                                  (vertex (* (cos (* theta DTOR)) (cos (* (+ phi dphi) DTOR)))
                                          (* (cos (* theta DTOR)) (sin (* (+ phi dphi) DTOR)))
                                          (sin (* theta DTOR))))))
                        (if v4
                            (add-quad v1 v2 v3 v4)
                          (add-triangle v1 v2 v3)))))
          (case what
            ((physical)
             (iterate-table areas
               (lambda (area <Area> polygons)
                 (add-polygons~ area #f polygons))))
            ((render)
             (let ((mesh (new Mesh material: material)))
               (allocate-vertices~ mesh)
               (set-data~ (get-vertices-buffer~ mesh) content floats-per-indice)
               mesh))))))))


;;;
;;;; Floor
;;;


(definition public (generate-floor x y z width depth)
  (let ((zone (current-zone)))
    (loop (for i from (- width) to width)
          (loop (for j from (- depth) to depth)
                (let ((x (+ x i))
                      (z (+ z j)))
                  (add-element~ zone
                    (new Quad-Tile
                      v1: (vertex x y (+ z 1.))
                      v2: (vertex (+ x 1.) y (+ z 1.))
                      v3: (vertex (+ x 1.) y z)
                      v4: (vertex x y z)
                      parent: zone)))))))


;;;
;;;; Wall
;;;


(definition public (generate-wall x y z width height)
  (let ((zone (current-zone)))
    (loop (for i from (- width) to width)
          (loop (for j from (- height) to height)
                (let ((x (+ x i))
                      (y (+ y j)))
                  (add-element~ zone
                    (new Quad-Tile
                      v1: (vertex x (+ y 1.) z)
                      v2: (vertex (+ x 1.) (+ y 1.) z)
                      v3: (vertex (+ x 1.) y z)
                      v4: (vertex x y z)
                      parent: zone)))))))


;;;
;;;; Slope
;;;


(definition public (generate-slope x y z height x-count z-count)
  (let ((zone (current-zone)))
    (let ((width 1.)
          (depth 1.))
      (loop (for d from 0 below z-count)
            (loop (for i from 0 below x-count)
                  (let ((x (+ x (* i width)))
                        (y (+ y (* d height)))
                        (z (+ z (* d depth))))
                    (add-element~ zone
                      (new Quad-Tile
                        v1: (vertex x (+ y height) (+ z depth))
                        v2: (vertex (+ x width) (+ y height) (+ z depth))
                        v3: (vertex (+ x width) y z)
                        v4: (vertex x y z)
                        parent: zone))))))))


;;;
;;;; Stairs
;;;


(definition public (generate-stairs stairs x y z width height depth x-count y-count z-count)
  (let ((zone (current-zone)))
    (loop (for d from 0 below stairs)
          (loop (for i from (- x-count) to x-count)
                (let ((x (+ x (* i width)))
                      (y (+ y (* d height)))
                      (z (+ z (* d (* depth z-count)))))
                  ;; front
                  (add-element~ zone
                    (new Quad-Tile
                      v1: (vertex x (+ y height) z)
                      v2: (vertex (+ x width) (+ y height) z)
                      v3: (vertex (+ x width) y z)
                      v4: (vertex x y z)
                      parent: zone))
                  ;; flat
                  (loop (for n from 0 below z-count)
                        (let ((z (+ z (* n depth))))
                          (add-element~ zone
                            (new Quad-Tile
                              v1: (vertex x (+ y height) (+ z depth))
                              v2: (vertex (+ x width) (+ y height) (+ z depth))
                              v3: (vertex (+ x width) (+ y height) z)
                              v4: (vertex x (+ y height) z)
                              parent: zone))))))))))
