;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Generate
;;;


(module world.generate jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.geometry)
        (world.mesh))


;;;
;;;; Cone
;;;


@finish-conversion
(definition public (generate-cone p1 <f32vector> p2 <f32vector> r1 <fl> r2 <fl> m <fx> theta1 <fl> theta2 <fl>)
  (let ;; Normal pointing from p1 to p2
      ((n (vertex- p1 p2)))
    ;; Create two perpendicular vectors perp and q on the plane of the disk
    (let ((perp n))
      (if (and (= (vertex-x n) 0.) (= (vertex-z n) 0.))
          (vertex-x-set! n (+ (vertex-x n) 1))
        (vertex-y-set! n (+ (vertex-y n) 1)))
      (let ((perp (cross-product n q)))
        (let ((n (cross-product q perp)))
          (vertex-normalize! perp perp)
          (vertex-normalize! q q)
          (glBegin GL_QUAD_STRIP)
          (loop (for i from 0 to m)
                (let ((theta (+ theta1 (/ (* i (- theta2 theta1)) m))))
                  (vertex-x-set! n (+ (* (cos theta) perp.x) (* (sin theta) q.x)))
                  (vertex-y-set! n (+ (* (cos theta) perp.y) (* (sin theta) q.y)))
                  (vertex-z-set! n (+ (* (cos theta) perp.z) (* (sin theta) q.z)))
                  (vertex-normalize! n n)
                  
                  p.x = p2.x + r2 * n.x
                  p.y = p2.y + r2 * n.y
                  p.z = p2.z + r2 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 1.0)
                  glVertex3f(p.x p.y p.z)
                  
                  p.x = p1.x + r1 * n.x
                  p.y = p1.y + r1 * n.y
                  p.z = p1.z + r1 * n.z
                  glNormal3f(n.x n.y n.z)
                  glTexCoord2f(i/(double)m 0.0)
                  glVertex3f(p.x p.y p.z)))
          (glEnd))))))


;;;
;;;; Sphere
;;;


(definition public (generate-sphere slices stacks (material: material #f))
  (let ((dphi (/ 360. slices))
        (dtheta (/ 180. stacks)))
    (define (count-sphere)
      (let ((count 0))
        (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
              (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                    (if (and (> theta -90.) (< theta 90.))
                        (increase! count 2)
                      (increase! count))))
        count))
    
    (let ((floats-per-indice 10))
      (let ((mesh (new Mesh material: material))
            (triangles-count (count-sphere))
            (triangle-floats (* 3 floats-per-indice))
            (DTOR (/ PI*2 360.)))
        (let ((content (make-f32vector (* triangles-count triangle-floats)))
              (n 0))
          (define (add-triangle v1 v2 v3)
            (add
              v1 (vertex 0. 1. 1.)
              v2 (vertex 1. 1. 1.)
              v3 (vertex 1. 0. 1.)))
          
          (define (add-quad v1 v2 v3 v4)
            (add
              v1 (vertex 0. 1. 1.)
              v2 (vertex 1. 1. 1.)
              v3 (vertex 1. 0. 1.))
            (add
              v3 (vertex 1. 0. 1.)
              v4 (vertex 0. 0. 1.) 
              v1 (vertex 0. 1. 1.)))
          
          (define (add v1 t1 v2 t2 v3 t3)
            (let ((normal (plane-normal v1 v2 v3)))
              (add-vertex v1) (add-texture t1) (add-normal normal) (add-bone)
              (add-vertex v2) (add-texture t2) (add-normal normal) (add-bone)
              (add-vertex v3) (add-texture t3) (add-normal normal) (add-bone)))
          
          (define (add-vertex vert)
            (f32vector-set! content n (vertex-x vert))
            (f32vector-set! content (+ n 1) (vertex-y vert))
            (f32vector-set! content (+ n 2) (vertex-z vert))
            (set! n (+ n 3)))
          
          (define (add-texture tex)
            (f32vector-set! content n (vertex-x tex))
            (f32vector-set! content (+ n 1) (vertex-y tex))
            (f32vector-set! content (+ n 2) 0.)
            (set! n (+ n 3)))
          
          (define (add-normal normal)
            (f32vector-set! content n (vertex-x normal))
            (f32vector-set! content (+ n 1) (vertex-y normal))
            (f32vector-set! content (+ n 2) (vertex-z normal))
            (set! n (+ n 3)))
          
          (define (add-bone)
            (f32vector-set! content n 0.)
            (set! n (+ n 1)))
          
          (loop (for theta <fl> from -90. to (- 90. dtheta) by dtheta)
                (loop (for phi <fl> from 0. to (- 360. dphi) by dphi)
                      @pacman (for phi <fl> from (* dphi 4) to (- 360. dphi) by dphi)
                      (let ((v1 (vertex  (* (cos (* theta DTOR)) (cos (* phi DTOR)))
                                         (* (cos (* theta DTOR)) (sin (* phi DTOR)))
                                         (sin (* theta DTOR))))
                            (v2 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* phi DTOR)))
                                        (* (cos (* (+ theta dtheta) DTOR)) (sin (* phi DTOR)))
                                        (sin (* (+ theta dtheta) DTOR))))
                            (v3 (vertex (* (cos (* (+ theta dtheta) DTOR)) (cos (* (+ phi dphi) DTOR)))
                                        (* (cos (* (+ theta dtheta) DTOR)) (sin (* (+ phi dphi) DTOR)))
                                        (sin (* (+ theta dtheta) DTOR))))
                            (v4 (when (and (> theta -90.) (< theta 90.))
                                  (vertex (* (cos (* theta DTOR)) (cos (* (+ phi dphi) DTOR)))
                                          (* (cos (* theta DTOR)) (sin (* (+ phi dphi) DTOR)))
                                          (sin (* theta DTOR))))))
                        (if v4
                            (add-quad v1 v2 v3 v4)
                          (add-triangle v1 v2 v3)))))
          (allocate-vertices~ mesh)
          (set-data~ (get-vertices-buffer~ mesh) content floats-per-indice)
          mesh))))))
