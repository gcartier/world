;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Generate
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.generate jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.area)
        (world.autoload)
        (world.face)
        (world.geometry)
        (world.material)
        (world.mesh)
        (world.parallelepiped)
        (world.polygon)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Void
;;;


(definition public (generate-void generator)
  (generator
    (lambda (triangles quads)
      )
    (lambda (v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v tdepth)
      )
    (lambda (v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v v4 n4 t4u t4v tdepth)
      )))


;;;
;;;; Debug
;;;


(definition public (generate-debug generator)
  (generator
    (lambda (triangles quads)
      (debug 'setup triangles quads))
    (lambda (v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v tdepth)
      (debug 'triangle v1 v2 v3))
    (lambda (v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v v4 n4 t4u t4v tdepth)
      (debug 'quad v1 v2 v3 v4))))


;;;
;;;; Cuboid
;;;


(definition public (iterate-cuboid-quads cuboid element proc)
  (let ((left (cuboid-left cuboid))
        (right (cuboid-right cuboid))
        (bottom (cuboid-bottom cuboid))
        (top (cuboid-top cuboid))
        (back (cuboid-back cuboid))
        (front (cuboid-front cuboid)))
    ;; front face
    (proc (make-quad element (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front)))
    ;; back face
    (proc (make-quad element (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back)))
    ;; left face
    (proc (make-quad element (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front)))
    ;; right face
    (proc (make-quad element (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back)))
    ;; top face
    (proc (make-quad element (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back)))
    ;; bottom face
    (proc (make-quad element (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front)))))


(definition public (iterate-cuboid-inner-quads cuboid element proc)
  (let ((left (cuboid-left cuboid))
        (right (cuboid-right cuboid))
        (bottom (cuboid-bottom cuboid))
        (top (cuboid-top cuboid))
        (back (cuboid-back cuboid))
        (front (cuboid-front cuboid)))
    (define (iterate v1 v2 v3 v4)
      (proc (make-quad element v4 v3 v2 v1)))
    
    ;; front face
    (iterate (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front))
    ;; back face
    (iterate (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back))
    ;; left face
    (iterate (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front))
    ;; right face
    (iterate (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back))
    ;; top face
    (iterate (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back))
    ;; bottom face
    (iterate (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front))))


(definition public (ray-closest-cuboid-inner-quad orig <f64vector> dir <f64vector> cuboid)
  (let ((closest #f)
        (distance <fl+> #f))
    (iterate-cuboid-inner-quads cuboid #f
      (lambda (quad <Quad>)
        (let ((cls (ray-closest-triangle~ quad orig dir #f)))
          (when cls
            (bind (poly dist <fl>) cls
              (when (or (not distance)
                        (< dist distance))
                (set! closest (list poly dist))
                (set! distance dist)))))))
    closest))


;;;
;;;; Parallelepiped
;;;


(definition public (iterate-parallelepiped-quads para <Parallelepiped> sphere-matrix poly proc element)
  (let ((left/bottom/back (get-left/bottom/back~ para))
        (left/bottom/front (get-left/bottom/front~ para))
        (left/top/back (get-left/top/back~ para))
        (left/top/front (get-left/top/front~ para))
        (right/bottom/back (get-right/bottom/back~ para))
        (right/bottom/front (get-right/bottom/front~ para))
        (right/top/back (get-right/top/back~ para))
        (right/top/front (get-right/top/front~ para)))
    (define (transform v1 v2 v3 v4)
      (proc (make-quad element
                       (matrix+-transform-3x4 sphere-matrix v1)
                       (matrix+-transform-3x4 sphere-matrix v2)
                       (matrix+-transform-3x4 sphere-matrix v3)
                       (matrix+-transform-3x4 sphere-matrix v4))))
    
    ;; top
    (transform right/top/back left/top/back left/top/front right/top/front)
    ;; bottom
    (transform right/bottom/front left/bottom/front left/bottom/back right/bottom/back)
    ;; front
    (transform left/bottom/front right/bottom/front right/top/front left/top/front)
    ;; back
    (transform right/bottom/back left/bottom/back left/top/back right/top/back)
    ;; left
    (transform left/top/front left/top/back left/bottom/back left/bottom/front)
    ;; right
    (transform right/top/back right/top/front right/bottom/front right/bottom/back)))


;;;
;;;; Mesh
;;;


(constant vertex-floats <fx>
  10)

(constant triangle-floats <fx>
  (* 3 vertex-floats))

(constant triangle-neighbors-floats <fx>
  (* 3 7))

(constant triangle-lightmap-floats <fx>
  (* 3 3))


(definition public (generate-mesh generator (matrix: matrix #f) (neighbors?: neighbors? #f) (smooth-normals?: smooth-normals? #f) (material: material #f) (return-faces?: return-faces? #f))
  (let ((neighbors-floats 6)
        (lightmap-floats 3)
        (triangles-count <fx+> #f)
        (content <f32vector+> #f)
        (neighbors <f32vector+> #f)
        (lightmap <f32vector+> #f)
        (n <fx> 0)
        (m <fx> 0)
        (smooth-normals (and smooth-normals? (make-table test: vertex=? hash: vertex-hash)))
        (faces (and return-faces? (new-queue))))
    (define (setup triangles <fx> quads <fx>)
      (unless return-faces?
        (set! triangles-count (+ triangles (* quads 2)))
        (allege (and triangles-count triangle-floats triangle-neighbors-floats triangle-lightmap-floats)
          (set! content (make-f32vector (* triangles-count triangle-floats)))
          (when neighbors?
            (set! neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))
          (set! lightmap (make-f32vector (* triangles-count triangle-lightmap-floats) 0.)))))
    
    (define (add-triangle v1 n1 t1u t1v b1 v2 n2 t2u t2v b2 v3 n3 t3u t3v b3 tdepth)
      (add
        (transform v1) n1 t1u t1v b1
        (transform v2) n2 t2u t2v b2
        (transform v3) n3 t3u t3v b3
        tdepth))
    
    (define (add-quad v1 n1 t1u t1v b1 v2 n2 t2u t2v b2 v3 n3 t3u t3v b3 v4 n4 t4u t4v b4 tdepth)
      (add
        (transform v1) n1 t1u t1v b1
        (transform v2) n2 t2u t2v b2
        (transform v3) n3 t3u t3v b3
        tdepth)
      (add
        (transform v3) n3 t3u t3v b3
        (transform v4) n4 t4u t4v b4
        (transform v1) n1 t1u t1v b1
        tdepth))
    
    (define (transform vert)
      (matrix+-transform-3x4 matrix vert))
    
    (define (add v1 n1 t1u <fl> t1v <fl> b1 v2 n2 t2u <fl> t2v <fl> b2 v3 n3 t3u <fl> t3v <fl> b3 tdepth)
      (let ((plane-normal #f))
        (define (get-plane-normal)
          (or plane-normal (let ((normal (plane-normal-safe v1 v2 v3)))
                             (set! plane-normal normal)
                             normal)))
        
        (let ((n1 (or n1 (get-plane-normal)))
              (n2 (or n2 (get-plane-normal)))
              (n3 (or n3 (get-plane-normal))))
          (when smooth-normals?
            (allege smooth-normals
              (let ((plane-normal (get-plane-normal)))
                (define (process-vertex vert)
                  (let ((vert (if return-faces? vert (vertex-64->32 vert))))
                    (let ((smooth-normal (table-ref smooth-normals vert #f)))
                      (if (not smooth-normal)
                          (table-set! smooth-normals vert plane-normal)
                        (vertex-increase! smooth-normal plane-normal)))))
                
                (process-vertex v1)
                (process-vertex v2)
                (process-vertex v3))))
          (if return-faces?
              (enqueue faces (make-face material
                                        (f32vector t1u t1v t2u t2v t3u t3v)
                                        tdepth
                                        (make-smooth-triangle #f v1 v2 v3 n1 n2 n3)))
            (add-vertex v1) (add-normal n1) (add-texture t1u t1v tdepth) (add-bone b1) (when neighbors? (add-neighbors 0. v2 v3))
            (add-vertex v2) (add-normal n2) (add-texture t2u t2v tdepth) (add-bone b2) (when neighbors? (add-neighbors 1. v1 v3))
            (add-vertex v3) (add-normal n3) (add-texture t3u t3v tdepth) (add-bone b3) (when neighbors? (add-neighbors 2. v1 v2))))))
    
    (define (add-vertex vert)
      (allege content
        (f32vector-set! content n (vertex-x vert))
        (f32vector-set! content (+ n 1) (vertex-y vert))
        (f32vector-set! content (+ n 2) (vertex-z vert))
        (set! n (+ n 3))))
    
    (define (add-normal normal)
      (allege content
        (f32vector-set! content n (vertex-x normal))
        (f32vector-set! content (+ n 1) (vertex-y normal))
        (f32vector-set! content (+ n 2) (vertex-z normal))
        (set! n (+ n 3))))
    
    (define (add-texture tu tv tdepth)
      (allege content
        (f32vector-set! content n tu)
        (f32vector-set! content (+ n 1) tv)
        (f32vector-set! content (+ n 2) tdepth)
        (set! n (+ n 3))))
    
    (define (add-bone bone <fx>)
      (allege content
        (f32vector-set! content n (cast <fl> bone))
        (set! n (+ n 1))))
    
    (define (add-neighbors rank n1 n2)
      (allege neighbors
        (f32vector-set! neighbors m rank)
        (set! m (+ m 1))
        (f32vector-set! neighbors m (vertex-x n1))
        (f32vector-set! neighbors (+ m 1) (vertex-y n1))
        (f32vector-set! neighbors (+ m 2) (vertex-z n1))
        (set! m (+ m 3))
        (f32vector-set! neighbors m (vertex-x n2))
        (f32vector-set! neighbors (+ m 1) (vertex-y n2))
        (f32vector-set! neighbors (+ m 2) (vertex-z n2))
        (set! m (+ m 3))))
    
    (generator setup add-triangle add-quad)
    (when smooth-normals?
      (allege smooth-normals
        (iterate-table smooth-normals
          (lambda (vert smooth-normal)
            (vertex-normalize! smooth-normal smooth-normal)))
        (if return-faces?
            (for-each (lambda (face <Face>)
                        (let ((triangle <Smooth-Triangle> (get-polygon~ face)))
                          (let ((v1 (get-v1~ triangle)))
                            (let ((smooth-normal (table-ref smooth-normals v1)))
                              (set-n1~ triangle smooth-normal)))
                          (let ((v2 (get-v2~ triangle)))
                            (let ((smooth-normal (table-ref smooth-normals v2)))
                              (set-n2~ triangle smooth-normal)))
                          (let ((v3 (get-v3~ triangle)))
                            (let ((smooth-normal (table-ref smooth-normals v3)))
                              (set-n3~ triangle smooth-normal)))))
                      (queue-list faces))
          (loop (for i from 0 below (allege triangles-count))
                (let ((n (* i (allege triangle-floats))))
                  (define (smooth-vertex offset <fx>)
                    (allege content
                      (let ((vert (vertex (f32vector-ref content offset) (f32vector-ref content (+ offset 1)) (f32vector-ref content (+ offset 2)))))
                        (let ((smooth-normal (table-ref smooth-normals vert)))
                          (f32vector-set! content (+ offset 3) (vertex-x smooth-normal))
                          (f32vector-set! content (+ offset 4) (vertex-y smooth-normal))
                          (f32vector-set! content (+ offset 5) (vertex-z smooth-normal))))))
                  
                  (smooth-vertex n)
                  (smooth-vertex (+ n vertex-floats))
                  (smooth-vertex (+ n (* vertex-floats 2))))))))
    (if return-faces?
        (queue-list faces)
      (let ((mesh (new Mesh material: material)))
        (allocate-vertices~ mesh)
        (set-data~ (get-vertices-buffer~ mesh) content vertex-floats)
        (when neighbors?
          (allocate-neighbors~ mesh)
          (set-data~ (get-neighbors-buffer~ mesh) neighbors neighbors-floats))
        (allocate-lightmap~ mesh)
        (set-data~ (get-lightmap-buffer~ mesh) lightmap lightmap-floats)
        mesh))))


;;;
;;;; Mesher
;;;


(class Mesher extends Object
  
  
  (slot content   <f32vector>  getter generate)
  (slot neighbors <f32vector>  getter generate)
  (slot lightmap  <f32vector>  getter generate)
  (slot matrix    <f64vector+> getter generate)
  (slot material  <Material>   getter generate)
  
  (slot i         <fx> initialize 0)
  (slot j         <fx> initialize 0)
  (slot k         <fx> initialize 0)
  
  
  (method override (initialize triangles <fx> quads <fx> (matrix: matrix #f) (material: material #f))
    (let ((triangles-count (+ triangles (* quads 2))))
      (set! content (make-f32vector (* triangles-count triangle-floats)))
      (set! neighbors (make-f32vector (* triangles-count triangle-neighbors-floats)))
      (set! lightmap (make-f32vector (* triangles-count triangle-lightmap-floats))))
    (set! matrix~self matrix)
    (set! material~self material))
  
  
  (method (add-face face <Face>)
    (add-triangles~ face add-triangle))
  
  
  (method (add-triangle v1 <f64vector> n1 <f64vector> t1u <fl> t1v <fl> b1 <fx> v2 <f64vector> n2 <f64vector> t2u <fl> t2v <fl> b2 <fx> v3 <f64vector> n3 <f64vector> t3u <fl> t3v <fl> b3 <fx> tdepth <fl>)
    (add
      (transform v1) n1 t1u t1v b1
      (transform v2) n2 t2u t2v b2
      (transform v3) n3 t3u t3v b3
      tdepth))
  
  
  (method (add-quad v1 <f64vector> n1 <f64vector> t1u <fl> t1v <fl> b1 <fx> v2 <f64vector> n2 <f64vector> t2u <fl> t2v <fl> b2 <fx> v3 <f64vector> n3 <f64vector> t3u <fl> t3v <fl> b3 <fx> v4 <f64vector> n4 <f64vector> t4u <fl> t4v <fl> b4 <fx> tdepth <fl>)
    (add
      (transform v1) n1 t1u t1v b1
      (transform v2) n2 t2u t2v b2
      (transform v3) n3 t3u t3v b3
      tdepth)
    (add
      (transform v3) n3 t3u t3v b3
      (transform v4) n4 t4u t4v b4
      (transform v1) n1 t1u t1v b1
      tdepth))
  
  
  (method (transform vert)
    (matrix+-transform-3x4 matrix vert))
  
  
  (method (add v1 n1 t1u t1v b1 v2 n2 t2u t2v b2 v3 n3 t3u t3v b3 tdepth)
    (let ((plane-normal #f))
      (define (get-plane-normal)
        (or plane-normal (let ((normal (plane-normal-safe v1 v2 v3)))
                           (set! plane-normal normal)
                           normal)))
      
      (let ((n1 (or n1 (get-plane-normal)))
            (n2 (or n2 (get-plane-normal)))
            (n3 (or n3 (get-plane-normal))))
        (add-vertex v1) (add-normal n1) (add-texture t1u t1v tdepth) (add-bone b1) (add-neighbors 0. v2 v3)
        (add-vertex v2) (add-normal n2) (add-texture t2u t2v tdepth) (add-bone b2) (add-neighbors 1. v1 v3)
        (add-vertex v3) (add-normal n3) (add-texture t3u t3v tdepth) (add-bone b3) (add-neighbors 2. v1 v2))))
  
  
  (method (add-vertex vert)
    (f32vector-set! content i (vertex-x vert))
    (f32vector-set! content (+ i 1) (vertex-y vert))
    (f32vector-set! content (+ i 2) (vertex-z vert))
    (set! i (+ i 3)))
  
  
  (method (add-normal normal)
    (f32vector-set! content i (vertex-x normal))
    (f32vector-set! content (+ i 1) (vertex-y normal))
    (f32vector-set! content (+ i 2) (vertex-z normal))
    (set! i (+ i 3)))
  
  
  (method (add-texture tu tv tdepth)
    (f32vector-set! content i tu)
    (f32vector-set! content (+ i 1) tv)
    (f32vector-set! content (+ i 2) tdepth)
    (set! i (+ i 3)))
  
  
  (method (add-bone bone <fx>)
    (f32vector-set! content i (cast <fl> bone))
    (set! i (+ i 1)))
  
  
  (method (add-neighbors rank n1 n2)
    (f32vector-set! neighbors j rank)
    (set! j (+ j 1))
    (f32vector-set! neighbors j (vertex-x n1))
    (f32vector-set! neighbors (+ j 1) (vertex-y n1))
    (f32vector-set! neighbors (+ j 2) (vertex-z n1))
    (set! j (+ j 3))
    (f32vector-set! neighbors j (vertex-x n2))
    (f32vector-set! neighbors (+ j 1) (vertex-y n2))
    (f32vector-set! neighbors (+ j 2) (vertex-z n2))
    (set! j (+ j 3)))
  
  
  (method (get-info)
    (list content neighbors lightmap))
  
  
  (method (get-mesh)
    (let ((neighbors-floats 6)
          (lightmap-floats 3)
          (mesh (new Mesh material: material)))
      (allocate-vertices~ mesh)
      (set-data~ (get-vertices-buffer~ mesh) content vertex-floats)
      (allocate-neighbors~ mesh)
      (set-data~ (get-neighbors-buffer~ mesh) neighbors neighbors-floats)
      (allocate-lightmap~ mesh)
      (set-data~ (get-lightmap-buffer~ mesh) lightmap lightmap-floats)
      mesh)))


;;;
;;;; Faces
;;;


(definition public (generate/add-faces generator (matrix: matrix #f) (smooth-normals?: smooth-normals? #f) (material: material #f))
  (let ((zone (current-zone)))
    (let ((faces (generate-mesh generator matrix: matrix smooth-normals?: smooth-normals? material: material return-faces?: #t))
          (sectors (make-table test: eq?)))
      (for-each (lambda (face <Face>)
                  (let ((sector (position-sector~ zone (get-center~ (get-polygon~ face)))))
                    (add-face~ sector face)
                    (table-set! sectors sector #t)))
                faces)
      (iterate-table sectors
        (lambda (sector <Sector> ignore)
          (set-vertices-uptodate?~ sector #f)
          (set-lightmap-uptodate?~ sector #f))))))


(definition public (faces-generator faces)
  (lambda (setup-proc triangle-proc quad-proc)
    (define (count)
      (let ((triangles 0)
            (quads 0))
        (for-each (lambda (face <Face>)
                    (increase! triangles (triangle-count~ face)))
                  faces)
        (setup-proc triangles quads)))
    
    (count)
    (for-each (lambda (face <Face>)
                (add-triangles~ face triangle-proc))
              faces)))


;;;
;;;; Polygons
;;;


(definition public (polygons-extract element polygons <f64vector> matrix)
  (let ((queue (new-queue)))
    (loop (for i from 0 below (/ (f64vector-length polygons) polygon-float-size))
          (let ((offset (* i polygon-float-size)))
            (let ((poly <Polygon> (if (nan? (f64vector-ref polygons (+ offset 12)))
                                      (make-triangle element (make-zero-vertex) (make-zero-vertex) (make-zero-vertex))
                                    (make-quad element (make-zero-vertex) (make-zero-vertex) (make-zero-vertex) (make-zero-vertex)))))
              (enqueue queue (polygon-extract!~ poly element polygons offset matrix)))))
    (queue-list queue)))


(definition public (generate/add-polygons generator (element: element #f) (matrix: matrix #f))
  (let ((world (current-world))
        (zone (current-zone)))
    (let ((areas #f))
      (define (setup triangles quads)
        (set! areas (make-table test: eq?)))
      
      (define (add-triangle v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v tdepth)
        (add-polygon (triangle-class~ world) (vector v1 v2 v3)))
      
      (define (add-quad v1 n1 t1u t1v v2 n2 t2u t2v v3 n3 t3u t3v v4 n4 t4u t4v tdepth)
        (add-polygon (quad-class~ world) (vector v1 v2 v3 v4)))
      
      (define (add-polygon class vertices)
        (define (transform vertex)
          (matrix+-transform-3x4 matrix vertex))
        
        (let ((vertices vertices))
          (let ((polygon <Polygon> (new class element vertices)))
            (let ((center (matrix+-transform-3x4 matrix (get-center~ polygon))))
              (let ((area (index-area~ zone (position-area-index~ zone center) #f)))
                (table-add areas area polygon))))))
      
      (generator setup add-triangle add-quad)
      (iterate-table areas
        (lambda (area <Area> polygons)
          (add-polygons~ area element polygons matrix)))))))
