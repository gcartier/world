;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Procedural Content
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.procedural jazz


(import (jazz.component)
        (jazz.foreign)
        (jazz.geometry)
        (jazz.optimize (phase syntax))
        (jazz.platform (phase syntax))
        (jazz.syntax (phase syntax))
        (world.biome)
        (world.chunk)
        (world.foreign)
        (world.foreign.noise)
        (world.geometry.syntax)
        (world.generation.block)
        (world.generation.building)
        (world.homogeneous)
        (world.layer)
        (world.region)
        (world.section)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))


;; for optimize tests
(c-declare world.procedural #/C/
#define ___BODYREF(x, y) ___CAST(___SCMOBJ*, ___BODY(x))[y]
#define ___S32BODYREF(x, y) ___CAST(___S32*, ___BODY(x))[y]
#define ___S32BODYSET(x, y, z) ___CAST(___S32*, ___BODY(x))[y] = (z)
#define ___F64BODYREF(x, y) ___CAST(___F64*, ___BODY(x))[y]
#define ___F64BODYSET(x, y, z) ___CAST(___F64*, ___BODY(x))[y] = (z)

inline int even(int x)
{
    return (x % 2) == 0;
}

inline int odd(int x)
{
    return (x % 2) != 0;
}
//#)


;; ADD CORRECT BOOLEAN SUPPORT FOR shapings-touched and generate-skylight


;; TO THINK IS IT OK TO TOUCH EVEN WHEN REFING?????
(defoptimize inline (shaping-section shapings <vector> shapings-touched <u8vector> j <fx>) <World-Section>
  (let ((y (fxfloor (/ (cast <fl> j) 16.))))
    (u8vector-set! shapings-touched y 1)
    (vector-ref shapings y)))


(defoptimize inline (local-index i <fx> j <fx> k <fx>) <fx>
  (+ (* j 256) (* k 16) i))


@w
(defoptimize inline (u4vector-set! field <u8vector> index <fx> value <fx>) <void>
  (let ((offset (quotient index 2)))
    (let ((byte (u8vector-ref field offset)))
      (u8vector-set! field offset
        (if (even? index)
            (bitwise-ior value (bitwise-and byte #xF0))
          (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift-left value 4)))))))


;; QUICK HACK AROUND DUPLICATION THAT NEEDS LINKING LOGIC
(defoptimize inline (shaping-blocks shapings <vector> shapings-touched <u8vector> j <fx>) <u8vector>
  (get-blocks~ (shaping-section shapings shapings-touched j)))


(defoptimize inline (block-ref shapings <vector> shapings-touched <u8vector> i <fx> j <fx> k <fx>) <fx>
  (u8vector-ref (shaping-blocks shapings shapings-touched j) (local-index i (modulo j 16) k)))


(defoptimize inline (block-set! shapings <vector> shapings-touched <u8vector> i <fx> j <fx> k <fx> block-id <fx>) <void>
  (u8vector-set! (shaping-blocks shapings shapings-touched j) (local-index i (modulo j 16) k) block-id))

@w
(defoptimize inline (skylight-set! shapings <vector> shapings-touched <u8vector> i <fx> j <fx> k <fx> value <fx>) <void>
  (u4vector-set! (get-skylight~ (shaping-section shapings shapings-touched j)) (local-index i (modulo j 16) k) value))


(defoptimize inline (touched-top-y shapings-touched <u8vector>) <fx>
  (continuation-capture
    (lambda (return)
      (for (y 15 (>= y 0) (decrease! y))
           (when (= (u8vector-ref shapings-touched y) 1)
             (continuation-return return (* y 16))))
      -1)))


;;;
;;;; Generator
;;;


(class Generator extends Component
  
  
  (property revision <fx> initialize 0 accessors generate)
  
  
  (method protected virtual (free)
    )
  
  
  (method protected (increase-revision)
    (increase! revision))
  
  
  (method protected virtual (shape-chunk chunk <World-Chunk> shapings shapings-touched block-ref block-set! data-set! blockstate-set! skylight-set!)
    )
  
  
  (method protected virtual (generate-heightmap chunk-x chunk-z region-x region-z)
    )
  
  
  (method protected virtual (generate-variations chunk-x chunk-z region-x region-z)
    )
  

  (method (generate-skylight chunk <World-Chunk> shapings <vector> shapings-touched <u8vector> block-ref skylight-set!)
    ;; old
    (define (get-top-y) <fx>
      (let (iter (y 15))
        (if (= (u8vector-ref shapings-touched y) 1)
            (* y 16)
          (iter (- y 1)))))
    
    (define (get-opacity x y z) <fx>
      (get-opacity~ (id->block (block-ref x y z))))
    
    (let ((top-y (get-top-y))
          (heightmap (get-heightmap~ chunk)))
      (loop (for x from 0 below 16)
            (loop (for z from 0 below 16)
                  (let ((heightmap-set? #f))
                    (let (iter (y (+ top-y 15))
                               (light 15))
                      (let ((opacity (get-opacity x y z)))
                        (unless heightmap-set?
                          (when (/= opacity 0)
                            (vector-set! heightmap (+ x (* z 16)) (+ y 1))
                            (set! heightmap-set? #t)))
                        (when (and (= opacity 0) (/= light 15))
                          (set! opacity 1))
                        (decrease! light opacity)
                        (when (> light 0)
                          (skylight-set! x y z light))
                        (unless (or (<= y 0) (<= light 0))
                          (iter (- y 1) light))))))))
    
    @w
    (site (skylight on?: #t parent: generate)
      (begin;optimize
        (let ((top-y (touched-top-y shapings-touched))
              (heightmap (get-heightmap~ chunk)))
          (for (x 0 (< x 16) (increase! x))
               (for (z 0 (< z 16) (increase! z))
                    (let ((heightmap-set? #f))
                      (continuation-capture
                        (lambda (break)
                          (let ((y (+ top-y 15)) (light 15))
                            (for ()
                                 (let ((opacity (get-opacity~ (cast <Block> (vector-ref blockids (* (block-ref shapings shapings-touched x y z) block-variants)))))
                                       @optimize (opacity (get-opacity~ (id->block (block-ref shapings shapings-touched x y z)))))
                                   (unless heightmap-set?
                                     (when (/= opacity 0)
                                       (vector-set! heightmap (+ x (* z 16)) (+ y 1))
                                       (set! heightmap-set? #t)))
                                   (when (and (= opacity 0) (/= light 15))
                                     (set! opacity 1))
                                   (decrease! light opacity)
                                   (when (> light 0)
                                     (skylight-set! shapings shapings-touched x y z light))
                                   (if (or (<= y 0) (<= light 0))
                                       (continuation-return break)
                                     (decrease! y))))))))))))))
  
  
  (method protected virtual (populate-chunk block-ref block-set! blockstate-set! skylight-set! chunk front corner right)
    ))


;;;
;;;; Empty
;;;


(class Empty-Generator extends Generator)


;;;
;;;; Flat
;;;


(class Flat-Generator extends Generator
  
  
  (method override (shape-chunk chunk <World-Chunk> shapings shapings-touched block-ref block-set! data-set! blockstate-set! skylight-set!)
    (loop (for i from 0 below 16)
          (loop (for k from 0 below 16)
                (block-set! i 0 k Bedrock)
                (block-set! i 1 k Dirt)
                (block-set! i 2 k Dirt)
                (block-set! i 3 k Grass)))
    (generate-skylight chunk shapings shapings-touched block-ref skylight-set!)))


;;;
;;;; Simplex
;;;


(class Simplex-Generator extends Generator
  
  
  (slot simplex initialize #f getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! simplex (simplex-noise 87)))
  
  
  (method override (free)
    (simplex-noise-free simplex)
    (nextmethod))
  
  
  (method override (generate-heightmap chunk-x <fx> chunk-z <fx> region-x <fx> region-z <fx>)
    (let ((heights (make-f64vector 256 1.))
          (base-x (* (+ chunk-x (* region-x 32)) 16.))
          (base-z (* (+ chunk-z (* region-z 32)) 16.)))
      (define (vector-index x <fx> z <fx>) <fx>
        (+ x (* z 16)))
      
      (let ((frequency .02)
            (amplitude 20.)
            (octaves 3)
            (lacunarity 2.0)
            (gain .5))
        (loop (repeat octaves)
              (loop (for a from 0 below 16)
                    (loop (for c from 0 below 16)
                          (let ((index (vector-index a c))
                                (x (* (+ base-x (cast <fl> a)) frequency))
                                (z (* (+ base-z (cast <fl> c)) frequency)))
                            (f64vector-set! heights index (+ (f64vector-ref heights index) (* amplitude (+ 1. (simplex-noise2 simplex x z))))))))
              (set! amplitude (* amplitude gain))
              (set! frequency (* frequency lacunarity))))
      heights)))


;;;
;;;; World
;;;


(defoptimize coordinate-scale <fl>
  684.412) ;; 684.412


(defoptimize height-scale <fl>
  684.412) ;; 684.412


(defoptimize depth-noise-scale-x <fl>
  200.) ;; 200.

(defoptimize depth-noise-scale-z <fl>
  200.) ;; 200.


(defoptimize main-noise-scale-x <fl>
  80.) ;; 80.

(defoptimize main-noise-scale-y <fl>
  160.) ;; 160.

(defoptimize main-noise-scale-z <fl>
  80.) ;; 80.


(defoptimize base-size <fl>
  8.5) ;; 8.5


(defoptimize lower-limit-scale <fl>
  512.) ;; 512.

(defoptimize upper-limit-scale <fl>
  512.) ;; 512.


(defoptimize default-base-height <fl>
  .125) ;; .125

(defoptimize default-height-variation <fl>
  .05) ;; .05


(defoptimize stretch-y <fl>
  12.) ;; 12.


(defoptimize biome-depth-weight <fl>
  1.) ;; 1.

(defoptimize biome-depth-offset <fl>
  0.) ;; 0.

(defoptimize biome-scale-weight <fl>
  1.) ;; 1.

(defoptimize biome-scale-offset <fl>
  0.) ;; 0.


(definition rand-seed
  42)

(definition rand
  (newRandom 42))


(defoptimize inline (clamp a <fl> b <fl> w <fl>) <fl>
  (cond ((< w 0.) a)
        ((> w 1.) b)
        (else (+ a (* (- b a) w)))))


(defoptimize inline (smooth x <fl>) <fl>
  (* x x x (+ (* x (- (* x 6.) 15.)) 10.)))


(defoptimize grad-x <f64vector>
  #f64(1. -1. 1. -1. 1. -1. 1. -1. 0. 0. 0. 0. 1. 0. -1. 0.))

(defoptimize grad-y <f64vector>
  #f64(1. 1. -1. -1. 0. 0. 0. 0. 1. -1. 1. -1. 1. -1. 1. -1.))

(defoptimize grad-z <f64vector>
  #f64(0. 0. 0. 0. 1. 1. -1. -1. 1. 1. -1. -1. 0. 1. 0. -1.))

(defoptimize inline (grad index <fx> x <fl> y <fl> z <fl>) <fl>
  (let ((i (bitwise-and index #b1111)))
    (+ (* (f64vector-ref grad-x i) x) (* (f64vector-ref grad-y i) y) (* (f64vector-ref grad-z i) z))))

(defoptimize inline (grad-2d index <fx> x <fl> z <fl>) <fl>
  (let ((i (bitwise-and index #b1111)))
    (+ (* (f64vector-ref grad-x i) x) (* (f64vector-ref grad-z i) z))))


(defoptimize inline (lerp a <fl> b <fl> w <fl>) <fl>
  (+ a (* w (- b a))))


(class Perlin-Attributes extends Object
  
  
  (slot permutations <s32vector> initialize (make-s32vector 512) getter generate)
  (slot x-coord      <fl>        initialize 0.                   getter generate)
  (slot y-coord      <fl>        initialize 0.                   getter generate)
  (slot z-coord      <fl>        initialize 0.                   getter generate)
  
  
  (method override (initialize)
    (setSeed rand rand-seed)
    (set! x-coord (* (randomFloat rand) 256.))
    (set! y-coord (* (randomFloat rand) 256.))
    (set! z-coord (* (randomFloat rand) 256.))
    (loop (for i from 0 below 256)
          (s32vector-set! permutations i i))
    (loop (for j from 0 below 256)
          (let ((rnd (randomIntBetween rand j 255))
                (temp (s32vector-ref permutations j)))
            (s32vector-set! permutations j (s32vector-ref permutations rnd))
            (s32vector-set! permutations rnd temp)
            (s32vector-set! permutations (+ j 256) (s32vector-ref permutations j))))))


(class World-Generator extends Generator
  
  
  (slot biome-weights     <f64vector> initialize (make-f64vector 25 0.) getter generate)
  (slot main-attributes               initialize (make-vector 8  (new Perlin-Attributes)) getter generate)
  (slot min-attributes                initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  (slot max-attributes                initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  (slot depth-attributes              initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (for (i -2 (< i 3) (increase! i))
         (for (j -2 (< j 3) (increase! j))
              (f64vector-set! biome-weights (+ i 2 (* (+ j 2) 5)) (/ 10. (sqrt (+ (* (cast <fl> i) (cast <fl> i)) (* (cast <fl> j) (cast <fl> j)) .2)))))))
  
  
  (method override (shape-chunk chunk <World-Chunk> shapings shapings-touched block-ref block-set! data-set! blockstate-set! skylight-set!)
    (let ((region <World-Region> (get-region~ chunk)))
      (setSeed rand rand-seed)
      (generate-blocks shapings shapings-touched (generate-variations (get-x~ region) (get-z~ region) (get-x~ chunk) (get-z~ chunk)))
      (replace-biome-blocks chunk block-ref block-set! blockstate-set!)
      (generate-caverns chunk block-ref block-set! data-set!)
      (generate-skylight chunk shapings shapings-touched block-ref skylight-set!)))
  
  
  (method override (generate-variations region-x <fx> region-z <fx> chunk-x <fx> chunk-z <fx>) <f64vector>
    (site (variations on?: #t parent: generate)
      (let ((chunk-offset-x (* (+ (cast <fl> chunk-x) (* 32. (cast <fl> region-x))) 4.))
            (chunk-offset-z (* (+ (cast <fl> chunk-z) (* 32. (cast <fl> region-z))) 4.)))
        (let ((depth-region (generate-perlin-noise depth-attributes chunk-offset-x 10. chunk-offset-z 5 1 5 depth-noise-scale-x 1. depth-noise-scale-z))
              (main-noise (generate-perlin-noise main-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 (/ coordinate-scale main-noise-scale-x) (/ height-scale main-noise-scale-y) (/ coordinate-scale main-noise-scale-z)))
              (min-limit-region (generate-perlin-noise min-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 coordinate-scale height-scale coordinate-scale))
              (max-limit-region (generate-perlin-noise max-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 coordinate-scale height-scale coordinate-scale))
              (variations (make-f64vector 825 0.))
              (biomes (generate-variations-biomes region-x region-z chunk-x chunk-z))
              (variations-index 0)
              (depth-index 0))
          (optimize
            (for (x 0 (< x 5) (increase! x))
                 (for (z 0 (< z 5) (increase! z))
                      (let ((total-height-var <fl> 0.)
                            (total-height <fl> 0.)
                            (total-weight <fl> 0.)
                            (biome (cast <Biome> (vector-ref biome-ids @optimize id->biome (s32vector-ref biomes (+ x 2 (* (+ z 2) 10)))))))
                        (for (biome-x -2 (<= biome-x 2) (increase! biome-x))
                             (for (biome-z -2 (<= biome-z 2) (increase! biome-z))
                                  (let ((biome1 (cast <Biome> (vector-ref biome-ids @optimize id->biome (s32vector-ref biomes (+ x biome-x 2 (* (+ z biome-z 2) 10)))))))
                                    (let ((base-height <fl> (+ biome-depth-offset (* (get-base~ biome1) biome-depth-weight)))
                                          (height-variation <fl> (+ biome-scale-offset (* (get-variation~ biome1) biome-scale-weight))))
                                      (let ((weight <fl> (/ (f64vector-ref biome-weights (+ biome-x 2 (* (+ biome-z 2) 5))) (+ base-height 2.))))
                                        (when (> (get-base~ biome1) (get-base~ biome))
                                          (divide! weight 2.))
                                        (increase! total-height-var (* height-variation weight))
                                        (increase! total-height (* base-height weight))
                                        (increase! total-weight weight))))))
                        (set! total-height-var (+ (* (/ total-height-var total-weight) .9) .1))
                        (set! total-height (/ (- (* (/ total-height total-weight) 4.) 1) 8.))
                        (let ((depth-factor <fl> (/ (f64vector-ref depth-region depth-index) 8000.)))
                          (if (< depth-factor 0.)
                              (set! depth-factor (- (* depth-factor -0.9) 2.))
                            (set! depth-factor (- (* depth-factor 3.) 2.)))
                          (if (< depth-factor 0.)
                              (if (< depth-factor -2.)
                                  (set! depth-factor (/ -5. 14.))
                                (divide! depth-factor 5.6))
                            (if (> depth-factor 1.)
                                (set! depth-factor 1.)
                              (divide! depth-factor 8.)))
                          (increase! depth-index)
                          (set! total-height (* (+ total-height (* depth-factor .2)) (/ base-size 8.)))
                          (let ((height-factor <fl> (+ base-size (* total-height 4.))))
                            (for (y 0 (< y 33) (increase! y))
                                 (let ((min-height <fl> (* (- y height-factor) (/ stretch-y 2. total-height-var))))
                                   (when (< min-height 0.)
                                     (multiply! min-height 4.))
                                   (let ((min-limit <fl> (/ (f64vector-ref min-limit-region variations-index) lower-limit-scale))
                                         (max-limit <fl> (/ (f64vector-ref max-limit-region variations-index) upper-limit-scale))
                                         (main-height <fl> (/ (+ (/ (f64vector-ref main-noise variations-index) 10.) 1.) 2.)))
                                     (let ((normalized-height <fl> (- (clamp min-limit max-limit main-height) min-height)))
                                       (when (> y 29)
                                         (let ((d6 (/ (- (cast <fl> y) 29.) 3.)))
                                           (set! normalized-height (+ (* normalized-height (- 1. d6)) (* -10. d6)))))
                                       (f64vector-set! variations variations-index normalized-height)
                                       (increase! variations-index)))))))))))
          variations))))
  
  
  (definition rand-seed
    23)
  
  (definition rand
    (newRandom rand-seed))
  
  
  (definition sea-level <fx>
    63)

  
  (method (generate-blocks shapings <vector> shapings-touched <u8vector> variations <f64vector>)
    ;; optimize test
    (define (call-randomInt n <fx>) <fx>
      (randomInt rand n))
    
    (site (blocks on?: #t parent: generate)
      (optimize
        (for (i 0 (< i 4) (increase! i))
             (let ((j (* i 5))
                   (k (* (+ i 1) 5)))
               (for (l 0 (< l 4) (increase! l))
                    (let ((i1 (* (+ j l) 33))
                          (j1 (* (+ j l 1) 33))
                          (k1 (* (+ k l) 33))
                          (l1 (* (+ k l 1) 33)))
                      (for (i2 0 (< i2 32) (increase! i2))
                           (let ((d1 (f64vector-ref variations (+ i1 i2)))
                                 (d2 (f64vector-ref variations (+ j1 i2)))
                                 (d3 (f64vector-ref variations (+ k1 i2)))
                                 (d4 (f64vector-ref variations (+ l1 i2))))
                             (let ((d5 (/ (- (f64vector-ref variations (+ i1 i2 1)) d1) 8.))
                                   (d6 (/ (- (f64vector-ref variations (+ j1 i2 1)) d2) 8.))
                                   (d7 (/ (- (f64vector-ref variations (+ k1 i2 1)) d3) 8.))
                                   (d8 (/ (- (f64vector-ref variations (+ l1 i2 1)) d4) 8.)))
                               (for (j2 0 (< j2 8) (increase! j2))
                                    (let ((d9 d1)
                                          (d10 d2)
                                          (y (+ j2 (* i2 8))))
                                      (let ((d11 (/ (- d3 d1) 4.))
                                            (d12 (/ (- d4 d2) 4.)))
                                        (for (k2 0 (< k2 4) (increase! k2))
                                             (let ((d13 (/ (- d10 d9) 4.))
                                                   (x (+ k2 (* i 4))))
                                               (let ((lvt-45-1 d9))
                                                 (for (l2 0 (< l2 4) (increase! l2))
                                                      (let ((z (+ l2 (* l 4))))
                                                        (if (<= y 2 @w (call-randomInt 5))
                                                            (block-set! shapings shapings-touched x y z 7)
                                                          (if (> lvt-45-1 0.)
                                                              (block-set! shapings shapings-touched x y z 1)
                                                            (when (< y sea-level)
                                                              (block-set! shapings shapings-touched x y z 9)))))
                                                      (set! lvt-45-1 (+ lvt-45-1 d13)))
                                                 (set! d9 (+ d9 d11))
                                                 (set! d10 (+ d10 d12)))))
                                        (set! d1 (+ d1 d5))
                                        (set! d2 (+ d2 d6))
                                        (set! d3 (+ d3 d7))
                                        (set! d4 (+ d4 d8)))))))))))))))


  (method (replace-biome-blocks chunk <World-Chunk> block-ref block-set! blockstate-set!)
    (site (replace on?: #t parent: generate)
      (let ((biomes (get-biomes~ chunk)))
        (loop (for x from 0 below 16)
              (loop (for z from 0 below 16)
                    (let ((biome <Biome> (id->biome (u8vector-ref biomes (+ x (* z 16))))))
                      (replace-blocks~ biome x z rand block-ref block-set! blockstate-set!)))))))
  
  
  (method (generate-caverns chunk <World-Chunk> block-ref block-set! data-set!)
    (site (caverns on?: #t parent: generate)
    (let ((x (get-x~ chunk))
          (z (get-z~ chunk))
          (range 8)
          (br block-ref)
          (bs block-set!)
          (ds data-set!)
          (Air 0)
          (Water 8)
          (StationaryWater 9))
      (define (add-room seed chunkX chunkZ rx ry rz)
        (add-tunnel seed chunkX chunkZ rx ry rz (+ 1.0 (* (randomFloat rand) 6.0)) 0.0 0.0 -1 -1 0.5))
      
      (define (add-tunnel seed chunkX <fx> chunkZ <fx> rx <fl> ry <fl> rz <fl> p_180702_12_ <fl> p_180702_13_ <fl> p_180702_14_ <fl> p_180702_15_ <fx> p_180702_16_ <fx> p_180702_17_ <fl>)
        (continuation-capture
          (lambda (return)
            (let ((d0 (+ (* (cast <fl> chunkX) 16.) 8.))
                  (d1 (+ (* (cast <fl> chunkZ) 16.) 8.))
                  (f0 0.)
                  (f1 0.))
              (let ((random (newRandom seed)))
                (when (<= p_180702_16_ 0)
                  (let ((i (- (* range 16) 16)))
                    (set! p_180702_16_ (- i (randomInt random (/ i 4))))))
                (let ((flag2 #f))
                  (when (= p_180702_15_ -1)
                    (set! p_180702_15_ (fxfloor/ p_180702_16_ 2))
                    (set! flag2 #t))
                  (let ((j (+ (randomInt random (fxfloor/ p_180702_16_ 2)) (fxfloor/ p_180702_16_ 4)))
                        (flag (= (randomInt random 6) 0)))
                    (continuation-capture
                      (lambda (continue)
                        (for (p_180702_15_ p_180702_15_ (< p_180702_15_ p_180702_16_) (increase! p_180702_15_))
                             (let ((d2 (+ 1.5 (* (sin
                                                   (/ (* (cast <fl> p_180702_15_) PI)
                                                      (cast <fl> p_180702_16_)))
                                                 p_180702_12_))))
                               (let ((d3 (* d2 p_180702_17_))
                                     (f2 (cos p_180702_14_))
                                     (f3 (sin p_180702_14_)))
                                 (set! rx (+ rx (* (cos p_180702_13_) f2)))
                                 (set! ry (+ ry f3))
                                 (set! rz (+ rz (* (sin p_180702_13_) f2)))
                                 (if flag
                                     (set! p_180702_14_ (* p_180702_14_ .92))
                                   (set! p_180702_14_ (* p_180702_14_ .7)))
                                 (set! p_180702_14_ (+ p_180702_14_ (* f1 .1)))
                                 (increase! p_180702_13_ (* f0 .1))
                                 (set! f1 (* f1 .9))
                                 (set! f0 (* f0 .75))
                                 (set! f1 (+ f1 (* (- (randomFloat random) (randomFloat random)) (randomFloat random) 2.)))
                                 (set! f0 (+ f0 (* (- (randomFloat random) (randomFloat random)) (randomFloat random) 4.)))
                                 (when (and (not flag2)
                                            (= p_180702_15_ j)
                                            (> p_180702_12_ 1.)
                                            (> p_180702_16_ 0))
                                   (add-tunnel (randomLong random) chunkX chunkZ rx ry rz (+ (* (randomFloat random) .5) .5) (- p_180702_13_ (/ PI 2.)) (/ p_180702_14_ 3.) p_180702_15_ p_180702_16_ 1.)
                                   (add-tunnel (randomLong random) chunkX chunkZ rx ry rz (+ (* (randomFloat random) .5) .5) (+ p_180702_13_ (/ PI 2.)) (/ p_180702_14_ 3.) p_180702_15_ p_180702_16_ 1.)
                                   (continuation-return return #f))
                                 (when (or flag2 (/= (randomInt random 4) 0))
                                   (let ((d4 (- rx d0))
                                         (d5 (- rz d1))
                                         (d6 (- (cast <fl> p_180702_16_) (cast <fl> p_180702_15_)))
                                         (d7 (+ p_180702_12_ 2. 16.)))
                                     (when (> (- (+ (* d4 d4) (* d5 d5))
                                                 (* d6 d6))
                                              (* d7 d7))
                                       (continuation-return return #f))
                                     (when (and (>= rx (- (- d0 16.) (* d2 2.)))
                                                (>= rz (- (- d1 16.) (* d2 2.)))
                                                (<= rx (+ d0 16. (* d2 2.)))
                                                (<= rz (+ d1 16. (* d2 2.))))
                                       (let ((k2 (- (- (fxfloor (- rx d2)) (* chunkX 16)) 1))
                                             (k (+ (- (fxfloor (+ rx d2)) (* chunkX 16)) 1))
                                             (l2 (- (fxfloor (- ry d3)) 1))
                                             (l (+ (fxfloor (+ ry d3)) 1))
                                             (i3 (- (- (fxfloor (- rz d2)) (* chunkZ 16)) 1))
                                             (i1 (+ (- (fxfloor (+ rz d2)) (* chunkZ 16)) 1)))
                                         (let ((k2 (if (< k2 0) 0 k2))
                                               (k (if (> k 16) 16 k))
                                               (l2 (if (< l2 1) 1 l2))
                                               (l (if (> l 248) 248 l))
                                               (i3 (if (< i3 0) 0 i3))
                                               (i1 (if (> i1 16) 16 i1))
                                               (flag3 #f))
                                           (for (j1 k2 (and (not flag3) (< j1 k)) (increase! j1))
                                                (for (k1 i3 (and (not flag3) (< k1 i1)) (increase! k1))
                                                     (let (iter (l1 <fx> (+ l 1)))
                                                       (when (and (not flag3) (>= l1 (- l2 1)))
                                                         (if (and (>= l1 0) (< l1 256))
                                                             (let ((block <fx> (block-ref j1 l1 k1)))
                                                               (when (or (= block Water)
                                                                         (= block StationaryWater))
                                                                 (set! flag3 #t))
                                                               (if (and (/= l1 (- l2 1))
                                                                        (/= j1 k2)
                                                                        (/= j1 (- k 1))
                                                                        (/= k1 i3)
                                                                        (/= k1 (- i1 1)))
                                                                   (iter (- l2 1))
                                                                 (iter (- l1 1))))
                                                           (iter (- l1 1)))))))
                                           (unless flag3
                                             (for (j3 k2 (< j3 k) (increase! j3))
                                                  (let ((d10 (/ (- (+ (cast <fl> j3) (* (cast <fl> chunkX) 16.) .5) rx) d2)))
                                                    (for (i2 i3 (< i2 i1) (increase! i2))
                                                         (let ((d8 (/ (- (+ (cast <fl> i2) (* (cast <fl> chunkZ) 16.) .5) rz) d2)))
                                                           (when (< (+ (* d10 d10) (* d8 d8)) 1.)
                                                             (for (j2 l (> j2 l2) (decrease! j2))
                                                                  (let ((d9 (/ (- (+ (- (cast <fl> j2) 1.) .5) ry) d3)))
                                                                    (when (and (> d9 -.7)
                                                                               (< (+ (* d10 d10) (* d9 d9) (* d8 d8)) 1.))
                                                                      (block-set! j3 j2 i2 Air)))))))))
                                             (when flag2
                                               (continuation-return continue #f))))))))))))))))))))
      
      (define (recursive-generate p <fx> q <fx> chunkX <fx> chunkZ <fx>)
        (let ((i (randomInt rand (+ (randomInt rand (+ (randomInt rand 15) 1)) 1))))
          (when (/= (randomInt rand 7) 0)
            (set! i 0))
          (for (j 0 (< j i) (increase! j))
               (let ((rx (cast <fl> (+ (* p 16) (randomInt rand 16))))
                     (ry (cast <fl> (randomInt rand (+ (randomInt rand 120) 8))))
                     (rz (cast <fl> (+ (* q 16) (randomInt rand 16))))
                     (k 1))
                 (when (= (randomInt rand 4) 0)
                   (add-room (randomLong rand) chunkX chunkZ rx ry rz)
                   (increase! k (randomInt rand 4)))
                 (for (l 0 (< l k) (increase! l))
                      (let ((f0 (* (randomFloat rand) (* PI 2.)))
                            (f1 (/ (* (- (randomFloat rand) .5) 2.) 8.))
                            (f2 (+ (* (randomFloat rand) 2.) (randomFloat rand))))
                        (when (= (randomInt rand 10) 0)
                          (multiply! f2 (+ (* (randomFloat rand) (randomFloat rand) 3.) 1.)))
                        (add-tunnel (randomLong rand) chunkX chunkZ rx ry rz f2 f0 f1 0 0 1.)))))))
      
      (let ((i range)
            (worldSeed (worldSeed)))
        (setSeed rand worldSeed)
        (let ((j (randomLong rand))
              (k (randomLong rand)))
          (for (p (- x i) (<= p (+ x i)) (increase! p))
               (for (q (- z i) (<= q (+ z i)) (increase! q))
                    (setSeedAux rand p q j k worldSeed)
                    (recursive-generate p q x z))))))))
  
  
  (method override (populate-chunk block-ref block-set! blockstate-set! skylight-set! chunk front corner right)
    (define (neighbor-chunk x <fx> z <fx>) <World-Chunk>
      (if (< x 16)
          (if (< z 16)
              chunk
            front)
        (if (< z 16)
            right
          corner)))
    
    (define (get-height x <fx> z <fx>) <fx>
      (get-chunk-height~ (neighbor-chunk x z) (modulo x 16) (modulo z 16)))
    
    (define (get-biome x <fx> z <fx>) <Biome>
      (id->biome (u8vector-ref (get-biomes~ (neighbor-chunk x z)) (biomes-index (modulo x 16) (modulo z 16)))))
    
    (define (biomes-index x <fx> z <fx>) <fx>
      (+ x (* z 16)))
    
    (define (chunk-block-ref x <fx> y <fx> z <fx>) <fx>
      (block-ref (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16)))
    
    (define (chunk-block-set! x <fx> y <fx> z <fx> block-id <fx>)
      (block-set! (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16) block-id))
    
    (define (chunk-blockstate-set! x <fx> y <fx> z <fx> id <fx>)
      (blockstate-set! (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16) id))
    
    (define (chunk-skylight-set! x <fx> y <fx> z <fx> value <fx>)
      (skylight-set! (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16) value))
    
    (define (chunk-get-sector x <fx> y <fx> z <fx>)
      (get-sector~ (get-section~ (neighbor-chunk x z) (fxfloor/ y 16))))
    
    (site (populate on?: #t parent: generate)
      (let ((biome (get-biome 16 16)))
        (decorate-biome~ biome rand chunk-block-ref chunk-block-set! chunk-blockstate-set! chunk-skylight-set! chunk-get-sector get-height))))
  
  
  (method (generate-perlin-noise attributes <vector> x-offset <fl> y-offset <fl> z-offset <fl> x-size <fx> y-size <fx> z-size <fx> x-scale <fl> y-scale <fl> z-scale <fl>) <f64vector>
    (let ((noise (make-f64vector (* x-size y-size z-size) 0.))
          (octaves (vector-length attributes)))
      (let (iter (i 0) (scaling 1.))
        (if (< i octaves)
            (let ((scaled-x-offset (* scaling x-offset x-scale))
                  (scaled-y-offset (* scaling y-offset y-scale))
                  (scaled-z-offset (* scaling z-offset z-scale)))
              (generate-noise-octave noise (vector-ref attributes i) (flmodulo scaled-x-offset 16777216.) scaled-y-offset (flmodulo scaled-z-offset 16777216.) x-size y-size z-size (* x-scale scaling) (* y-scale scaling) (* z-scale scaling) scaling)
              (iter (+ i 1) (/ scaling 2.)))
          noise))))
  
  
  (method (generate-noise-octave noise <f64vector> attributes <Perlin-Attributes> x-offset <fl> y-offset <fl> z-offset <fl> x-size <fx> y-size <fx> z-size <fx> x-scale <fl> y-scale <fl> z-scale <fl> scaling <fl>)
    (optimize
      (let ((permutations (get-permutations~ attributes))
            (x-coord (get-x-coord~ attributes))
            (y-coord (get-y-coord~ attributes))
            (z-coord (get-z-coord~ attributes)))
        (if (= y-size 1)
            (let ((j 0)
                  (i5 0)
                  (j5 0)
                  (k5 0)
                  (d14 0.)
                  (d15 0.)
                  (d21 0.)
                  (index 0))
              (for (x 0 (< x x-size) (increase! x))
                   (smooth/floor k2 d17 d18 (+ x-offset (* (cast <fl> x) x-scale) x-coord)
                     (for (z 0 (< z z-size) (increase! z))
                          (smooth/floor l6 d19 d20 (+ z-offset (* (cast <fl> z) z-scale) z-coord)
                            (set! i5 (permute k2))
                            (set! j5 (+ (permute i5) l6))
                            (set! j (permute (+ k2 1)))
                            (set! k5 (+ (permute j) l6))
                            (set! d14 (lerp (grad-2d (permute j5) d17 d19) (grad-2d (permute k5) (- d17 1.) d19) d18))
                            (set! d15 (lerp (grad-2d (permute (+ j5 1)) d17 (- d19 1.)) (grad-2d (permute (+ k5 1)) (- d17 1.) (- d19 1.)) d18))
                            (set! d21 (lerp d14 d15 d20))
                            (f64vector-set! noise index (+ (f64vector-ref noise index) (/ d21 scaling)))
                            (set! index (+ index 1)))))))
          (let ((k -1)
                (l 0)
                (i1 0)
                (j1 0)
                (k1 0)
                (l1 0)
                (i2 0)
                (d1 0.)
                (d2 0.)
                (d3 0.)
                (d4 0.)
                (d11 0.)
                (d12 0.)
                (d13 0.)
                (index 0))
            (for (x 0 (< x x-size) (increase! x))
                 (smooth/floor j3 d5 d6 (+ x-offset (* (cast <fl> x) x-scale) x-coord)
                   (for (z 0 (< z z-size) (increase! z))
                        (smooth/floor i4 d7 d8 (+ z-offset (* (cast <fl> z) z-scale) z-coord)
                          (for (y 0 (< y y-size) (increase! y))
                               (smooth/floor l4 d9 d10 (+ y-offset (* (cast <fl> y) y-scale) y-coord)
                                 (when (or (= y 0) (/= l4 k))
                                   (set! k l4)
                                   (set! l (+ (permute j3) l4))
                                   (set! i1 (+ (permute l) i4))
                                   (set! j1 (+ (permute (+ l 1)) i4))
                                   (set! k1 (+ (permute (+ j3 1)) l4))
                                   (set! l1 (+ (permute k1) i4))
                                   (set! i2 (+ (permute (+ k1 1)) i4))
                                   (set! d1 (lerp (grad (permute i1) d5 d9 d7) (grad (permute l1) (- d5 1.) d9 d7) d6))
                                   (set! d2 (lerp (grad (permute j1) d5 (- d9 1.) d7) (grad (permute i2) (- d5 1.) (- d9 1.) d7) d6))
                                   (set! d3 (lerp (grad (permute (+ i1 1)) d5 d9 (- d7 1.)) (grad (permute (+ l1 1)) (- d5 1.) d9 (- d7 1.)) d6))
                                   (set! d4 (lerp (grad (permute (+ j1 1)) d5 (- d9 1.) (- d7 1.)) (grad (permute (+ i2 1)) (- d5 1.) (- d9 1.) (- d7 1.)) d6)))
                                 (set! d11 (lerp d1 d2 d10))
                                 (set! d12 (lerp d3 d4 d10))
                                 (set! d13 (lerp d11 d12 d8))
                                 (f64vector-set! noise index (+ (f64vector-ref noise index) (/ d13 scaling)))
                                 (set! index (+ index 1)))))))))))))))
