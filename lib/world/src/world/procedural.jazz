;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Procedural Content
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.procedural jazz


(import (jazz.component)
        (jazz.geometry)
        (world)
        (world.biome)
        (world.foreign.noise)
        (world.generation)
        (world.generation.building)
        (world.geometry))


(proclaim (warn optimizations))


;;;
;;;; Generator
;;;


(class Generator extends Component
  
  
  (property revision <fx> initialize 0 accessors generate)
  
  
  (method protected virtual (free)
    )
  
  
  (method protected (increase-revision)
    (increase! revision))
  
  
  (method protected virtual (generate-chunk chunk block-ref block-set! data-set!)
    (let ((region (get-region~ chunk)))
      (generate-blocks~ chunk block-ref block-set! data-set! (generate-heightmap (get-x~ chunk) (get-z~ chunk) (get-x~ region) (get-z~ region)))))
  
  
  (method protected virtual (generate-heightmap chunk-x chunk-z region-x region-z)
    ))


;;;
;;;; Empty
;;;


(class Empty-Generator extends Generator
  
  
  (method override (generate-chunk chunk block-ref block-set! data-set!)
    ))


;;;
;;;; Flat
;;;


(class Flat-Generator extends Generator
  
  
  (method override (generate-chunk chunk block-ref block-set! data-set!)
    (let ((section (add-section~ chunk 0)))
      (loop (for i from 0 below 16)
            (loop (for k from 0 below 16)
                  (block-set! section i 0 k Bedrock)
                  (block-set! section i 1 k Dirt)
                  (block-set! section i 2 k Dirt)
                  (block-set! section i 3 k Grass))))))


;;;
;;;; Old Simplex
;;;


(class Simplex-Generator-Old extends Generator
  
  
  (slot simplex initialize #f getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! simplex (simplex-noise 87)))
  
  
  (method override (free)
    (simplex-noise-free simplex)
    (nextmethod))
  
  
  (method override (generate-heightmap chunk-x chunk-z region-x region-z)
    (let ((heights (make-vector 256 1.))
          (base-x (* (+ chunk-x (* region-x 32)) 16.))
          (base-z (* (+ chunk-z (* region-z 32)) 16.)))
      (define (vector-index x <fx> z <fx>) <fx>
        (+ x (* z 16)))
      
      (let ((frequency .02)
            (amplitude 20.)
            (octaves 3)
            (lacunarity 2.0)
            (gain .5))
        (loop (repeat octaves)
              (loop (for a from 0 below 16)
                    (loop (for c from 0 below 16)
                          (let ((index (vector-index a c))
                                (x (* (+ base-x (cast <fl> a)) frequency))
                                (z (* (+ base-z (cast <fl> c)) frequency)))
                            (vector-set! heights index (+ (vector-ref heights index) (* amplitude (+ 1. (simplex-noise2 simplex x z))))))))
              (set! amplitude (* amplitude gain))
              (set! frequency (* frequency lacunarity))))
      heights)))


;;;
;;;; Simplex
;;;


(definition coordinate-scale <fl>
  684.412) ;; 684.412


(definition height-scale <fl>
  684.412) ;; 684.412


(definition depth-noise-scale-x <fl>
  200.) ;; 200.

(definition depth-noise-scale-z <fl>
  200.) ;; 200.


(definition main-noise-scale-x <fl>
  80.) ;; 80.

(definition main-noise-scale-y <fl>
  160.) ;; 160.

(definition main-noise-scale-z <fl>
  80.) ;; 80.


(definition base-size <fl>
  8.5) ;; 8.5


(definition lower-limit-scale <fl>
  512.) ;; 512.

(definition upper-limit-scale <fl>
  512.) ;; 512.


(definition default-base-height <fl>
  .125)

(definition default-height-variation <fl>
  .05)


(definition stretch-y <fl>
  12.) ;; 12.


(definition biome-depth-weight <fl>
  1.) ;; 1.

(definition biome-depth-offset <fl>
  0.) ;; 0.

(definition biome-scale-weight <fl>
  1.) ;; 1.

(definition biome-scale-offset <fl>
  0.) ;; 0.


(class Perlin-Attributes extends Object
  
  
  (slot permutations <vector> initialize (make-vector 512) getter generate)
  (slot x-coord      <fl>     initialize 0.                getter generate)
  (slot y-coord      <fl>     initialize 0.                getter generate)
  (slot z-coord      <fl>     initialize 0.                getter generate)
  
  
  (method override (initialize)
    (set! x-coord (* (random-real) 256.))
    (set! y-coord (* (random-real) 256.))
    (set! z-coord (* (random-real) 256.))
    (loop (for i from 0 below 256)
          (vector-set! permutations i i))
    (loop (for j from 0 below 256)
          (let ((rnd (random-integer-between j 256))
                (temp (vector-ref permutations j)))
            (vector-set! permutations j (vector-ref permutations rnd))
            (vector-set! permutations rnd temp)
            (vector-set! permutations (+ j 256) (vector-ref permutations j))))))


(class Simplex-Generator extends Generator
  
  
  (slot biome-weights     <f64vector> initialize (make-f64vector 25 0.) getter generate)
  (slot main-attributes               initialize (make-vector 8  (new Perlin-Attributes)) getter generate)
  (slot min-attributes                initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  (slot max-attributes                initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  (slot depth-attributes              initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (loop (for i from -2 below 3)
          (loop (for j from -2 below 3)
                (f64vector-set! biome-weights (+ i 2 (* (+ j 2) 5)) (/ 10. (sqrt (+ (* i i) (* j j) .2)))))))
  
  
  (method override (generate-heightmap chunk-x <fx> chunk-z <fx> region-x <fx> region-z <fx>) <f64vector>
    (let ((chunk-offset-x (* (+ (cast <fl> chunk-x) (* 32. (cast <fl> region-x))) 4.))
          (chunk-offset-z (* (+ (cast <fl> chunk-z) (* 32. (cast <fl> region-z))) 4.)))
      (let ((depth-region (generate-perlin-noise depth-attributes chunk-offset-x 10. chunk-offset-z 5 1 5 depth-noise-scale-x 1. depth-noise-scale-z 16))
            (main-noise (generate-perlin-noise main-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 (/ coordinate-scale main-noise-scale-x) (/ height-scale main-noise-scale-y) (/ coordinate-scale main-noise-scale-z) 8))
            (min-limit-region (generate-perlin-noise min-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 coordinate-scale height-scale coordinate-scale 16))
            (max-limit-region (generate-perlin-noise max-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 coordinate-scale height-scale coordinate-scale 16))
            (heightmap (make-f64vector 825 0.))
            (heightmaps-index 0)
            (depth-index 0))
        (define (clamp a <fl> b <fl> w <fl>) <fl>
          (cond ((< w 0.) a)
                ((> w 1.) b)
                (else (+ a (* (- b a) w)))))
        
        (loop (for x from 0 below 5)
              (loop (for z from 0 below 5)
                    (let ((total-height-var <fl> 0.)
                          (total-height <fl> 0.)
                          (total-weight <fl> 0.))
                      (loop (for biome-x from -2 to 2)
                            (loop (for biome-z from -2 to 2)
                                  (let ((base-height <fl> (+ biome-depth-offset (* default-base-height biome-depth-weight)))
                                        (height-variation <fl> (+ biome-scale-offset (* default-height-variation biome-scale-weight))))
                                    (let ((weight <fl> (/ (f64vector-ref biome-weights (+ biome-x 2 (* (+ biome-z 2) 5))) (+ base-height 2.))))
                                      (increase! total-height-var (* height-variation weight))
                                      (increase! total-height (* base-height weight))
                                      (increase! total-weight weight)))))
                      (set! total-height-var (+ (* (/ total-height-var total-weight) .9) .1))
                      (set! total-height (/ (- (* (/ total-height total-weight) 4.) 1) 8.))
                      (let ((depth-factor <fl> (/ (f64vector-ref depth-region depth-index) 8000.)))
                        (if (< depth-factor 0.)
                            (set! depth-factor (- (* depth-factor -0.9) 2.))
                          (set! depth-factor (- (* depth-factor 3.) 2.)))
                        (if (< depth-factor 0.)
                            (if (< depth-factor -2.)
                                (set! depth-factor (/ -5. 14.))
                              (divide! depth-factor 5.6))
                          (if (> depth-factor 1.)
                              (set! depth-factor 1.)
                            (divide! depth-factor 8.)))
                        (increase! depth-index)
                        (set! total-height (* (+ total-height (* depth-factor .2)) (/ base-size 8.)))
                        (let ((height-factor <fl> (+ base-size (* total-height 4.))))
                          (loop (for y from 0 below 33)
                                (let ((min-height <fl> (* (- y height-factor) (/ stretch-y 2. total-height-var))))
                                  (when (< min-height 0.)
                                    (multiply! min-height 4.))
                                  (let ((min-limit <fl> (/ (f64vector-ref min-limit-region heightmaps-index) lower-limit-scale))
                                        (max-limit <fl> (/ (f64vector-ref max-limit-region heightmaps-index) upper-limit-scale))
                                        (main-height <fl> (/ (+ (/ (f64vector-ref main-noise heightmaps-index) 10.) 1.) 2.)))
                                    (let ((normalized-height <fl> (- (clamp min-limit max-limit main-height) min-height)))
                                      (when (> y 29)
                                        (let ((d6 (/ (- (cast <fl> y) 29.) 3.)))
                                          (set! normalized-height (+ (* normalized-height (- 1. d6)) (* -10. d6)))))
                                      (f64vector-set! heightmap heightmaps-index normalized-height)
                                      (increase! heightmaps-index))))))))))
        heightmap)))
  
  
  (method (generate-perlin-noise attributes <vector> x-offset <fl> y-offset <fl> z-offset <fl> x-size <fx> y-size <fx> z-size <fx> x-scale <fl> y-scale <fl> z-scale <fl> octaves <fx>) <f64vector>
    (let (iter (i 0)
               (noise (make-f64vector (* x-size y-size z-size) 0.))
               (scaling 1.))
      (if (< i octaves)
          (let ((scaled-x-offset (* scaling x-offset x-scale))
                (scaled-y-offset (* scaling y-offset y-scale))
                (scaled-z-offset (* scaling z-offset z-scale)))
              (generate-noise-octave noise (vector-ref attributes i) (flmodulo scaled-x-offset 16777216.) scaled-y-offset (flmodulo scaled-z-offset 16777216.) x-size y-size z-size (* x-scale scaling) (* y-scale scaling) (* z-scale scaling) scaling
                (lambda (noise)
                  (iter (+ i 1) noise (/ scaling 2.)))))
        noise)))
  
  
  (method (generate-noise-octave noise <f64vector> attributes <Perlin-Attributes> x-offset <fl> y-offset <fl> z-offset <fl> x-size <fx> y-size <fx> z-size <fx> x-scale <fl> y-scale <fl> z-scale <fl> scaling <fl> proc)
    (define (smooth/floor offset <fl> proc)
      (let ((x (fxfloor offset)))
        (let ((diff (- offset (cast <fl> x))))
          (proc (bitwise-and x 255) diff (smooth diff)))))
    
    (define (permute x <fx>) <fx>
      (vector-ref (get-permutations~ attributes) x))
    
    (if (= y-size 1)
        (let ((j <fx> 0)
              (i5 <fx> 0)
              (j5 <fx> 0)
              (k5 <fx> 0)
              (d14 <fl> 0.)
              (d15 <fl> 0.)
              (d21 <fl> 0.)
              (index <fx> 0))
          (loop (for x from 0 below x-size)
                (smooth/floor (+ x-offset (* (cast <fl> x) x-scale) (get-x-coord~ attributes))
                  (lambda (k2 <fx> d17 <fl> d18 <fl>)
                    (loop (for z from 0 below z-size)
                          (smooth/floor (+ z-offset (* (cast <fl> z) z-scale) (get-z-coord~ attributes))
                            (lambda (l6 <fx> d19 <fl> d20 <fl>)
                              (set! i5 (permute k2))
                              (set! j5 (+ (permute i5) l6))
                              (set! j (permute (+ k2 1)))
                              (set! k5 (+ (permute j) l6))
                              (set! d14 (lerp (grad-2d (permute j5) d17 d19) (grad-2d (permute k5) (- d17 1) d19) d18))
                              (set! d15 (lerp (grad-2d (permute (+ j5 1)) d17 (- d19 1)) (grad-2d (permute (+ k5 1)) (- d17 1) (- d19 1)) d18))
                              (set! d21 (lerp d14 d15 d20))
                              (f64vector-set! noise index (+ (f64vector-ref noise index) (/ d21 scaling)))
                              (increase! index))))))))
      (let ((k <fx> -1)
            (l <fx> 0)
            (i1 <fx> 0)
            (j1 <fx> 0)
            (k1 <fx> 0)
            (l1 <fx> 0)
            (i2 <fx> 0)
            (d1 <fl> 0.)
            (d2 <fl> 0.)
            (d3 <fl> 0.)
            (d4 <fl> 0.)
            (d11 <fl> 0.)
            (d12 <fl> 0.)
            (d13 <fl> 0.)
            (index <fx> 0))
        (loop (for x from 0 below x-size)
              (smooth/floor (+ x-offset (* (cast <fl> x) x-scale) (get-x-coord~ attributes))
                (lambda (j3 <fx> d5 <fl> d6 <fl>)
                  (loop (for z from 0 below z-size)
                        (smooth/floor (+ z-offset (* (cast <fl> z) z-scale) (get-z-coord~ attributes))
                          (lambda (i4 <fx> d7 <fl> d8 <fl>)
                            (loop (for y from 0 below y-size)
                                  (smooth/floor (+ y-offset (* (cast <fl> y) y-scale) (get-y-coord~ attributes))
                                    (lambda (l4 <fx> d9 <fl> d10 <fl>)
                                      (when (or (= y 0) (/= l4 k))
                                        (set! k l4)
                                        (set! l (+ (permute j3) l4))
                                        (set! i1 (+ (permute l) i4))
                                        (set! j1 (+ (permute (+ l 1)) i4))
                                        (set! k1 (+ (permute (+ j3 1)) l4))
                                        (set! l1 (+ (permute k1) i4))
                                        (set! i2 (+ (permute (+ k1 1)) i4))
                                        (set! d1 (lerp (grad (permute i1) d5 d9 d7) (grad (permute l1) (- d5 1) d9 d7) d6))
                                        (set! d2 (lerp (grad (permute j1) d5 (- d9 1) d7) (grad (permute i2) (- d5 1) (- d9 1) d7) d6))
                                        (set! d3 (lerp (grad (permute (+ i1 1)) d5 d9 (- d7 1)) (grad (permute (+ l1 1)) (- d5 1) d9 (- d7 1)) d6))
                                        (set! d4 (lerp (grad (permute (+ j1 1)) d5 (- d9 1) (- d7 1)) (grad (permute (+ i2 1)) (- d5 1) (- d9 1) (- d7 1)) d6)))
                                      (set! d11 (lerp d1 d2 d10))
                                      (set! d12 (lerp d3 d4 d10))
                                      (set! d13 (lerp d11 d12 d8))
                                      (f64vector-set! noise index (+ (f64vector-ref noise index) (/ d13 scaling)))
                                      (increase! index))))))))))))
    (proc noise)))
                            

(definition inline (smooth x <fl>) <fl>
  (* x x x (+ (* x (- (* x 6.) 15.)) 10.)))


(definition grad-x <f64vector>
  #f64(1. -1. 1. -1. 1. -1. 1. -1. 0. 0. 0. 0. 1. 0. -1. 0.))

(definition grad-y <f64vector>
  #f64(1. 1. -1. -1. 0. 0. 0. 0. 1. -1. 1. -1. 1. -1. 1. -1.))

(definition grad-z <f64vector>
  #f64(0. 0. 0. 0. 1. 1. -1. -1. 1. 1. -1. -1. 0. 1. 0. -1.))

(definition (grad index <fx> x <fl> y <fl> z <fl>) <fl>
  (let ((i (bitwise-and index #b1111)))
    (+ (* (f64vector-ref grad-x i) x) (* (f64vector-ref grad-y i) y) (* (f64vector-ref grad-z i) z))))

(definition (grad-2d index <fx> x <fl> z <fl>) <fl>
  (let ((i (bitwise-and index #b1111)))
    (+ (* (f64vector-ref grad-x i) x) (* (f64vector-ref grad-z i) z))))


(definition (lerp a <fl> b <fl> w <fl>) <fl>
  (+ a (* w (- b a))))


;;;
;;;; Diamond
;;;


@wait
(class Diamond-Generator extends Generator
  
  
  (method override (generate-heightmap chunk-x chunk-z region-x region-z)
    (let ((height (make-vector 289 0)))
      (define (vector-index x <fx> z <fx>) <fx>
        (+ x (* z 17)))
      
      (define (diamond-step n)
        (let ((average-hop (/ 16 (expt 2 n))))
          (let ((move-hop (* average-hop 2)))
            (define (diamond-average x z)
              (fxfloor (/ (+ (vector-ref height (vector-index (- x average-hop) (- z average-hop)))
                             (vector-ref height (vector-index (+ x average-hop) (- z average-hop)))
                             (vector-ref height (vector-index (- x average-hop) (+ z average-hop)))
                             (vector-ref height (vector-index (+ x average-hop) (+ z average-hop))))
                          4.)))
            
            (loop (for a from 0 below (expt 2 (- n 1)))
                  (loop (for c from 0 below (expt 2 (- n 1)))
                        (let ((x (+ average-hop (* a move-hop)))
                              (z (+ average-hop (* c move-hop))))
                          (vector-set! height (vector-index x z) (+ (diamond-average x z) (if (> n 1) 0 (random-integer-between -1 1))))))))))
      
      (define (square-step n)
        (let ((average-hop (/ 16 (expt 2 n))))
          (let ((move-hop (* average-hop 2)))
            (define (square-average x z)
              (let ((edge? (or (= x 0) (= x 16) (= z 0) (= z 16))))
                (fxfloor (/ (+ (if (= x 0) 0 (vector-ref height (vector-index (- x average-hop) z)))
                               (if (= x 16) 0 (vector-ref height (vector-index (+ x average-hop) z)))
                               (if (= z 0) 0 (vector-ref height (vector-index x (- z average-hop))))
                               (if (= z 16) 0 (vector-ref height (vector-index x (+ z average-hop)))))
                            (if edge? 3. 4.)))))
            
            (loop (for c from 0 below (+ (expt 2 n) 1))
                  (if (even? c)
                      (loop (for a from 0 below (expt 2 (- n 1)))
                            (let ((x (+ average-hop (* a move-hop)))
                                  (z (* c average-hop)))
                              (vector-set! height (vector-index x z) (+ (square-average x z) (if (> n 1) 0 (random-integer-between -1 1))))))
                    (loop (for a from 0 below (+ (expt 2 (- n 1)) 1))
                          (let ((x (* a move-hop))
                                (z (* c average-hop)))
                            (vector-set! height (vector-index x z) (+ (square-average x z) (if (> n 1) 0 (random-integer-between -1 1)))))))))))
      
      (vector-set! height (vector-index 0  0 ) 64)
      (vector-set! height (vector-index 0  16) 64)
      (vector-set! height (vector-index 16 0 ) 64)
      (vector-set! height (vector-index 16 16) 64)
      (loop (for n from 1 to 4)
            (diamond-step n)
            (square-step n))
      (subvector height 0 256))))


;;;
;;;; Polynomial
;;;


@wait
(class Polynomial-Generator extends Generator
  
  
  (method override (generate-heightmap chunk-x chunk-z region-x region-z)
    (let ((zone (current-zone))
          (heights (make-vector 256 0))
          (region #f)
          (chunk #f))
      (define (corner-height n x z)
        (set! region (cond ((< x 0) (increase! x 32) (table-ref (get-regions~ zone) (cons (- (get-x~ region~self) 1) (get-z~ region~self)) #f))
                           ((> x 31) (decrease! x 32) (table-ref (get-regions~ zone) (cons (+ (get-x~ region~self) 1) (get-z~ region~self)) #f))
                           ((< z 0) (increase! z 32) (table-ref (get-regions~ zone) (cons (get-x~ region~self) (- (get-z~ region~self) 1)) #f))
                           ((> z 31) (decrease! z 32) (table-ref (get-regions~ zone) (cons (get-x~ region~self) (+ (get-z~ region~self) 1)) #f))
                           (else region~self)))
        (when region
          (set! chunk (table-ref (get-chunks~ region) (cons x z) #f))
          (when chunk
            (get-corner~ chunk n))))
      
      (define (make-heightmap fx fz ax az mx mz ac)
        (loop (for x from 0 below 16)
              (loop (for z from 0 below 16)
                    (vector-set! heights (+ (ax x) (* (az z) 16)) (min 255 (max 1 (+ 16 (fxround (cast <fl> (+ (* (/ x (max 1 (+ x z))) (/ (fx x) mx)) (* (/ z (max 1 (+ x z))) (/ (fz z) mz)) (* (/ (+ x z) 30) (- 1 (/ (abs (- z x)) 15)) ac)))))))))))
      
      (define (approx row)
        #f)
      
      (let ((corner1 (corner-height 2 (- x 1) z))
            (corner2 (corner-height 4 x (- z 1)))
            (corner3 (corner-height 1 x (+ z 1)))
            (corner4 (corner-height 3 (+ x 1) z))
            (x-ajust (lambda (x) x))
            (z-ajust (lambda (z) z)))
        (let ((nb 0))
          (when corner1
            (increase! nb))
          (when corner2
            (increase! nb))
          (when corner3
            (increase! nb))
          (when corner4
            (increase! nb))
          (when (= nb 0)
            (set! corner1 64))
          (case nb
            ((1) (let ((corner (or corner1 (cond (corner2 (set! x-ajust (lambda (x) (- 15 x))) corner2)
                                                 (corner3 (set! z-ajust (lambda (z) (- 15 z))) corner3)
                                                 (corner4 (set! x-ajust (lambda (x) (- 15 x))) (set! z-ajust (lambda (z) (- 15 z))) corner4)))))
                   (let ((x-var (lambda (x) (+ (* x x x (- (random-real) .5) 3) (* x x (- (random-real) .5) 10) (* x (- (random-real) .5) 14) corner)))
                         (z-var (lambda (z) (+ (* z z (- (random-real) .5) 3) (* z (- (random-real) .5) 10) corner)))
                         (max-x (max 1 (fxround (* (random-real) (random-real) 3))))
                         (max-z (max 1 (fxround (* (random-real) (random-real) 3)))))
                     (let ((x-factor (abs (/ (- (x-var 16) (x-var 0)) max-x)))
                           (z-factor (abs (/ (- (z-var 16) (z-var 0)) max-z))))
                       (make-heightmap x-var z-var x-ajust z-ajust x-factor z-factor (random-integer-between -3 3))))))
            ((2) (if (or (and corner1 corner4) (and corner2 corner3))
                     (let ((c1 (or corner1 (begin (set! x-ajust (lambda (x) (- 15 x))) corner2)))
                           (c2 (or corner3 corner4)))
                       (let ((x-var (lambda (x) (+ (* x x x (- (random-real) .5) 6) (* x x (- (random-real) .5) 10) (* x (- (random-real) .5) 14) c1)))
                             (z-var (lambda (z) (+ (* z z z (- (random-real) .5) 4) (* z z (- (random-real) .5) 8) (* z (- (random-real) .5) 12) c1)))
                             (max-x (max 1 (fxround (* (random-real) (random-real) 3))))
                             (max-z (max 1 (fxround (* (random-real) (random-real) 3)))))
                         (let ((x-factor (abs (/ (- (x-var 16) (x-var 0)) max-x)))
                               (z-factor (abs (/ (- (z-var 16) (z-var 0)) max-z))))
                           (make-heightmap x-var z-var x-ajust z-ajust x-factor z-factor (- c2 (+ (* .5 (/ (x-var 15) x-factor)) (* .5 (/ (z-var 15) z-factor))))))))
                   (make-heightmap
                     (lambda (x) (+ (* x x x (- (random-real) .5) 6) (* x x (- (random-real) .5) 10) (* x (- (random-real) .5) 14) 64))
                     (lambda (z) (+ (* z z z (- (random-real) .5) 4) (* z z (- (random-real) .5) 8) (* z (- (random-real) .5) 12) 64))
                     (lambda (x) x)
                     (lambda (z) z)
                     (* (+ (random-real) 1) 800)
                     (* (+ (random-real) 1) 800)
                     3)))
            (else (make-heightmap
                    (lambda (x) (+ (* x x x (- (random-real) .5) 3) (* x x (- (random-real) .5) 4) (* x (- (random-real) .5) 5) 64))
                    (lambda (z) (+ (* z z z (- (random-real) .5) 2) (* z z (- (random-real) .5) 3) (* z (- (random-real) .5) 4) 64))
                    (lambda (x) x)
                    (lambda (z) z)
                    (* (+ (random-real) 1) 800)
                    (* (+ (random-real) 1) 800)
                    1)))))
      heights)))


;;;
;;;; Perlin
;;;


(definition private *perlin-permutations* <vector>
  #(25 155 210 108 175 199 221 144 203 116 70 213 69 158 33 252
     5 82 173 133 222 139 174 27 9 71 90 246 75 130 91 191
     169 138 2 151 194 235 81 7 25 113 228 159 205 253 134 142
     248 65 224 217 22 121 229 63 89 103 96 104 156 17 201 129
     36 8 165 110 237 117 231 56 132 211 152 20 181 111 239 218
     170 163 51 172 157 47 80 212 176 250 87 49 99 242 136 189
     162 115 44 43 124 94 150 16 141 247 32 10 198 223 255 72
     53 131 84 57 220 197 58 50 208 11 241 28 3 192 62 202
     18 215 153 24 76 41 15 179 39 46 55 6 128 167 23 188
     106 34 187 140 164 73 112 182 244 195 227 13 35 77 196 185
     26 200 226 119 31 123 168 125 249 68 183 230 177 135 160 180
     12 1 243 148 102 166 38 238 251 37 240 126 64 74 161 40
     184 149 171 178 101 66 29 59 146 61 254 107 42 86 154 4
     236 232 120 21 233 209 45 98 193 114 78 19 206 14 118 127
     48 79 147 85 30 207 219 54 88 234 190 122 95 67 143 109
     137 214 145 93 92 100 245 0 216 186 60 83 105 97 204 52))

(definition private *perlin-permutations-size* <fx>
  (vector-length *perlin-permutations*))


(class Perlin-Generator extends Generator
  
  
  (property detail-level   <fl> accessors generate)
  (property clamp-height   <fl> accessors generate)
  (property gradient-table <f64vector> initialize (make-f64vector (* *perlin-permutations-size* 3)))
  
  
  (method override (initialize detail-level clamp-height)
    (nextmethod)
    (set! detail-level~self detail-level)
    (set! clamp-height~self clamp-height)
    (let (loop (i 0))
      (when (< i *perlin-permutations-size*)
        (begin
          (let ((z (- 1.0 (* 2.0 (random-real)))))
            (let ((r (sqrt (- 1.0 (* z z))))
                  (theta (* 2.0 PI (random-real))))
              (f64vector-set! gradient-table (* i 3) (* r (cos theta)))
              (f64vector-set! gradient-table (+ (* i 3) 1) (* r (sin theta)))
              (f64vector-set! gradient-table (+ (* i 3) 2) z)))
          (loop (+ i 1))))))
  
  
  (method private (permute x <fx>) <fx>
    (cast <fx> (vector-ref *perlin-permutations* (bitwise-and (- *perlin-permutations-size* 1) x))))
  
  
  (method private (lattice ix <fx> iy <fx> iz <fx> fx <fl> fy <fl> fz <fl>) <fl>
    (define (index ix <fx> iy <fx> iz <fx>) <fx>
      (permute (+ ix (permute (+ iy (permute iz))))))
    
    (let ((i (index ix iy iz)))
      (let ((g (* 3 i)))
        (+ (* fx (f64vector-ref gradient-table g))
           (* fy (f64vector-ref gradient-table (+ g 1)))
           (* fz (f64vector-ref gradient-table (+ g 2)))))))
  
  
  (method private (lerp t <fl> v0 <fl> v1 <fl>) <fl>
    (+ (* (- 1. t) v0) (* t v1)))
  
  
  (method private (smooth x <fl>) <fl>
    (* x x (- 3. (* 2. x))))
  
  
  (method private (point x <fl> y <fl> z <fl>) <fl>
    (let ((ix (fxtruncate x))
          (iy (fxtruncate y))
          (iz (fxtruncate z)))
      (let ((fx0 (- x ix))
            (fy0 (- y iy))
            (fz0 (- z iz)))
        (let ((fx1 (- fx0 1.))
              (fy1 (- fy0 1.))
              (fz1 (- fz0 1.)))
          (let ((wx (smooth fx0))
                (wy (smooth fy0))
                (wz (smooth fz0)))
            (let ((vz0 (lerp wy
                             (lerp wx
                                   (lattice ix iy iz fx0 fy0 fz0)
                                   (lattice (+ ix 1) iy iz fx1 fy0 fz0))
                             (lerp wx
                                   (lattice ix (+ iy 1) iz fx0 fy1 fz0)
                                   (lattice (+ ix 1) (+ iy 1) iz fx1 fy1 fz0))))
                  (vz1 (lerp wy
                             (lerp wx
                                   (lattice ix iy (+ iz 1) fx0 fy0 fz1)
                                   (lattice (+ ix 1) iy (+ iz 1) fx1 fy0 fz1))
                             (lerp wx
                                   (lattice ix (+ iy 1) (+ iz 1) fx0 fy1 fz1)
                                   (lattice (+ ix 1) (+ iy 1) (+ iz 1) fx1 fy1 fz1)))))
              (lerp wz vz0 vz1)))))))
  
  
  (method (raw-value x <fl> y <fl>) <fl>
    (point (/ x detail-level)
           (/ y detail-level)
           0.))
  
  
  (method public (get-value x <fl> y <fl>) <fl>
    (* (raw-value x y)
       clamp-height)))


;;;
;;;; Diamond
;;;


@wait
(definition public (diamond-square power (detail-level: detail-level 64) (clamp-height: clamp-height 64))
  (define half-clamp-height (/ clamp-height 2))
  (define (to-index col row size)
    (+ (* row size) col)) 
  (define (clamp value (min: min #f) (max: max #f))
    (if (< value (or min (- half-clamp-height)))
        (or min (- half-clamp-height))
      (if (> value (or max half-clamp-height))
          (or max half-clamp-height)
        value)))
  (define (random-bound)
    (* half-clamp-height (- (random-integer 3) 1)))
  (define (diamond data bound length range)
    ;; quick patch for dominic to fix
    (when (not (integer? range))
      (set! range (flonum->fixnum (round (exact->inexact range)))))
    (let ((half-range (arithmetic-shift-right range 1))
          (part (arithmetic-shift-right length 1))
          (size (+ bound 1)))
      (let (outer (y-part (arithmetic-shift-right length 1))
                  (y 0))
        (when (< y bound)
          (let (inner (x 0))
            (when (< x bound)
              (vector-set! data (to-index (+ x part) y-part size)
                (truncate 
                  (clamp
                    (/ 
                      (+ (vector-ref data (to-index x y size))
                         (vector-ref data (to-index x (+ y length) size))
                         (vector-ref data (to-index (+ x length) y size))
                         (vector-ref data (to-index (+ x length) (+ y length) size)))
                      4))))
              (inner (+ x length))))
          (outer (+ part (+ y length))
                 (+ y length))))))
  (define (square data bound length range)
    ;; quick patch for dominic to fix
    (when (not (integer? range))
      (set! range (flonum->fixnum (round (exact->inexact range)))))
    (let ((part (truncate (/ length 2))))
      (let (outer (y 0)
                  (y1 part))
        (when (<= y bound)
          (let (inner (x 0)
                      (x1 part))
            (when (<= x bound)
              (inner-square x1 y data bound part range)
              (inner-square x y1 data bound part range)
              (inner-square x1 (+ y1 part) data bound part range)
              (inner-square (+ x1 part) y1 data bound part range)
              (inner (+ x length)
                     (+ x1 length))))
          (outer (+ y length)
                 (+ y1 length))))))
  (define (inner-square x y data bound part range)
    ;; quick patch for dominic to fix
    (when (not (integer? range))
      (set! range (flonum->fixnum (round (exact->inexact range)))))
    (when (and (>= x 0)
               (>= y 0)
               (<= x bound)
               (<= y bound))
      (let (loop (count 0)
                 (total 0)
                 (points `((,(- x part) ,@y)
                           (,(+ x part) ,@y)
                           (,x ,@(- y part))
                           (,x ,@(+ y part)))))
        (if (null? points)
            (let ((index (to-index x y (+ bound 1))))
              (vector-set! data
                           index
                           (clamp
                             (+ (vector-ref data index)
                                (truncate (/ total count))
                                (- (random-integer range)
                                   (/ range 2))))))
          (let ((point (car points)))
            (if (and (>= (cdr point) 0)
                     (>= (car point) 0)
                     (<= (cdr point) bound)
                     (<= (car point) bound))
                (loop (+ count 1)
                      (+ (vector-ref data
                                     (to-index (car point)
                                               (cdr point)
                                               (+ bound 1))))
                      (cdr points))
              (loop count total (cdr points))))))))  
  (let ((size (+ (expt 2 power) 1)))
    (let ((dimension (* size size))
          (bound (- size 1)))
      (let ((data (make-vector dimension)))
        (vector-set! data (to-index 0 0 size) (random-bound))
        (vector-set! data (to-index bound 0 size) (random-bound))
        (vector-set! data (to-index 0 bound size) (random-bound))
        (vector-set! data (to-index bound bound size) (random-bound))
        (let (loop (length bound)
                   (range detail-level))
          (when (> length 0)
            (diamond data bound length range)
            (square data bound length range)
            (loop (truncate (/ length 2))
                  (clamp (/ range 2) min: 1 max: clamp-height))))
        data)))))
