;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Procedural Content
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.procedural jazz


(import (jazz.component)
        (jazz.geometry)
        (jazz.syntax (phase syntax))
        (world.biome)
        (world.chunk)
        (world.foreign)
        (world.foreign.noise)
        (world.geometry.syntax)
        (world.generation.block)
        (world.generation.building)
        (world.homogeneous)
        (world.layer)
        (world.region)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))


;;;
;;;; Generator
;;;


(class Generator extends Component
  
  
  (property revision <fx> initialize 0 accessors generate)
  
  
  (method protected virtual (free)
    )
  
  
  (method protected (increase-revision)
    (increase! revision))
  
  
  (method protected virtual (shape-chunk chunk <World-Chunk> block-ref block-set! data-set! blockstate-set! skylight-set!)
    )
  
  
  (method protected virtual (generate-heightmap chunk-x chunk-z region-x region-z)
    )
  
  
  (method (generate-skylight chunk <World-Chunk> block-ref skylight-set!)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (site (skylight on?: #t parent: generate)
      (let ((sections-table (allege (get-sections-table~ chunk))))
        (define (get-top-y) <fx>
          (let (iter (y 15))
            (if (table-ref sections-table y #f)
                (* y 16)
              (iter (- y 1)))))
        
        (define (get-opacity x y z) <fx>
          (get-opacity~ (id->block (block-ref x y z))))
        
        (let ((top-y (get-top-y)))
          (loop (for x from 0 below 16)
                (loop (for z from 0 below 16)
                      (let ((heightmap-set? #f))
                        (let (iter (y (+ top-y 15))
                                   (light 15))
                          (let ((opacity (get-opacity x y z)))
                            (unless heightmap-set?
                              (when (/= opacity 0)
                                (set-height!~ chunk x z (+ y 1))
                                (set! heightmap-set? #t)))
                            (when (and (= opacity 0) (/= light 15))
                              (set! opacity 1))
                            (decrease! light opacity)
                            (when (> light 0)
                              (skylight-set! x y z light))
                            (unless (or (<= y 0) (<= light 0))
                              (iter (- y 1) light)))))))))))
  
  
  (method protected virtual (populate-chunk block-ref block-set! blockstate-set! skylight-set! chunk front corner right)
    ))


;;;
;;;; Empty
;;;


(class Empty-Generator extends Generator)


;;;
;;;; Flat
;;;


(class Flat-Generator extends Generator
  
  
  (method override (shape-chunk chunk <World-Chunk> block-ref block-set! data-set! blockstate-set! skylight-set!)
    (loop (for i from 0 below 16)
          (loop (for k from 0 below 16)
                (block-set! i 0 k Bedrock)
                (block-set! i 1 k Dirt)
                (block-set! i 2 k Dirt)
                (block-set! i 3 k Grass)))
    (generate-skylight chunk block-ref skylight-set!)))


;;;
;;;; Simplex
;;;


(class Simplex-Generator extends Generator
  
  
  (slot simplex initialize #f getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! simplex (simplex-noise 87)))
  
  
  (method override (free)
    (simplex-noise-free simplex)
    (nextmethod))
  
  
  (method override (generate-heightmap chunk-x <fx> chunk-z <fx> region-x <fx> region-z <fx>)
    (let ((heights (make-f64vector 256 1.))
          (base-x (* (+ chunk-x (* region-x 32)) 16.))
          (base-z (* (+ chunk-z (* region-z 32)) 16.)))
      (define (vector-index x <fx> z <fx>) <fx>
        (+ x (* z 16)))
      
      (let ((frequency .02)
            (amplitude 20.)
            (octaves 3)
            (lacunarity 2.0)
            (gain .5))
        (loop (repeat octaves)
              (loop (for a from 0 below 16)
                    (loop (for c from 0 below 16)
                          (let ((index (vector-index a c))
                                (x (* (+ base-x (cast <fl> a)) frequency))
                                (z (* (+ base-z (cast <fl> c)) frequency)))
                            (f64vector-set! heights index (+ (f64vector-ref heights index) (* amplitude (+ 1. (simplex-noise2 simplex x z))))))))
              (set! amplitude (* amplitude gain))
              (set! frequency (* frequency lacunarity))))
      heights)))


;;;
;;;; World
;;;


(definition coordinate-scale <fl>
  684.412) ;; 684.412


(definition height-scale <fl>
  684.412) ;; 684.412


(definition depth-noise-scale-x <fl>
  200.) ;; 200.

(definition depth-noise-scale-z <fl>
  200.) ;; 200.


(definition main-noise-scale-x <fl>
  80.) ;; 80.

(definition main-noise-scale-y <fl>
  160.) ;; 160.

(definition main-noise-scale-z <fl>
  80.) ;; 80.


(definition base-size <fl>
  8.5) ;; 8.5


(definition lower-limit-scale <fl>
  512.) ;; 512.

(definition upper-limit-scale <fl>
  512.) ;; 512.


(definition default-base-height <fl>
  .125) ;; .125

(definition default-height-variation <fl>
  .05) ;; .05


(definition stretch-y <fl>
  12.) ;; 12.


(definition biome-depth-weight <fl>
  1.) ;; 1.

(definition biome-depth-offset <fl>
  0.) ;; 0.

(definition biome-scale-weight <fl>
  1.) ;; 1.

(definition biome-scale-offset <fl>
  0.) ;; 0.


(definition rand-seed
  42)

(definition rand
  (newRandom 42))


(definition inline (smooth x <fl>) <fl>
  (* x x x (+ (* x (- (* x 6.) 15.)) 10.)))


(definition grad-x <f64vector>
  #f64(1. -1. 1. -1. 1. -1. 1. -1. 0. 0. 0. 0. 1. 0. -1. 0.))

(definition grad-y <f64vector>
  #f64(1. 1. -1. -1. 0. 0. 0. 0. 1. -1. 1. -1. 1. -1. 1. -1.))

(definition grad-z <f64vector>
  #f64(0. 0. 0. 0. 1. 1. -1. -1. 1. 1. -1. -1. 0. 1. 0. -1.))

(definition inline (grad index <fx> x <fl> y <fl> z <fl>) <fl>
  (let ((i (bitwise-and index #b1111)))
    (+ (* (f64vector-ref grad-x i) x) (* (f64vector-ref grad-y i) y) (* (f64vector-ref grad-z i) z))))

(definition inline (grad-2d index <fx> x <fl> z <fl>) <fl>
  (let ((i (bitwise-and index #b1111)))
    (+ (* (f64vector-ref grad-x i) x) (* (f64vector-ref grad-z i) z))))


(definition inline (lerp a <fl> b <fl> w <fl>) <fl>
  (+ a (* w (- b a))))


(class Perlin-Attributes extends Object
  
  
  (slot permutations <s32vector> initialize (make-s32vector 512) getter generate)
  (slot x-coord      <fl>        initialize 0.                   getter generate)
  (slot y-coord      <fl>        initialize 0.                   getter generate)
  (slot z-coord      <fl>        initialize 0.                   getter generate)
  
  
  (method override (initialize)
    (setSeed rand rand-seed)
    (set! x-coord (* (randomFloat rand) 256.))
    (set! y-coord (* (randomFloat rand) 256.))
    (set! z-coord (* (randomFloat rand) 256.))
    (loop (for i from 0 below 256)
          (s32vector-set! permutations i i))
    (loop (for j from 0 below 256)
          (let ((rnd (randomIntBetween rand j 255))
                (temp (s32vector-ref permutations j)))
            (s32vector-set! permutations j (s32vector-ref permutations rnd))
            (s32vector-set! permutations rnd temp)
            (s32vector-set! permutations (+ j 256) (s32vector-ref permutations j))))))


(class World-Generator extends Generator
  
  
  (slot biome-weights     <f64vector> initialize (make-f64vector 25 0.) getter generate)
  (slot main-attributes               initialize (make-vector 8  (new Perlin-Attributes)) getter generate)
  (slot min-attributes                initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  (slot max-attributes                initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  (slot depth-attributes              initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (loop (for i from -2 below 3)
          (loop (for j from -2 below 3)
                (f64vector-set! biome-weights (+ i 2 (* (+ j 2) 5)) (/ 10. (sqrt (+ (* (cast <fl> i) (cast <fl> i)) (* (cast <fl> j) (cast <fl> j)) .2)))))))
  
  
  (method override (shape-chunk chunk <World-Chunk> block-ref block-set! data-set! blockstate-set! skylight-set!)
    (let ((region <World-Region> (get-region~ chunk)))
      (setSeed rand rand-seed)
      (generate-blocks chunk block-ref block-set! data-set! (generate-heightmap (get-x~ region) (get-z~ region) (get-x~ chunk) (get-z~ chunk)))
      (replace-biome-blocks chunk block-ref block-set! blockstate-set!)
      (generate-caverns chunk block-ref block-set! data-set!)
      (generate-skylight chunk block-ref skylight-set!)))
  
  
  (method override (generate-heightmap region-x <fx> region-z <fx> chunk-x <fx> chunk-z <fx>) <f64vector>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (site (heightmap on?: #t parent: generate)
    (let ((chunk-offset-x (* (+ (cast <fl> chunk-x) (* 32. (cast <fl> region-x))) 4.))
          (chunk-offset-z (* (+ (cast <fl> chunk-z) (* 32. (cast <fl> region-z))) 4.)))
      (let ((depth-region (generate-perlin-noise depth-attributes chunk-offset-x 10. chunk-offset-z 5 1 5 depth-noise-scale-x 1. depth-noise-scale-z))
            (main-noise (generate-perlin-noise main-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 (/ coordinate-scale main-noise-scale-x) (/ height-scale main-noise-scale-y) (/ coordinate-scale main-noise-scale-z)))
            (min-limit-region (generate-perlin-noise min-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 coordinate-scale height-scale coordinate-scale))
            (max-limit-region (generate-perlin-noise max-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 coordinate-scale height-scale coordinate-scale))
            (heightmap (make-f64vector 825 0.))
            (biomes (generate-heightmap-biomes region-x region-z chunk-x chunk-z))
            (heightmaps-index 0)
            (depth-index 0))
        (define (clamp a <fl> b <fl> w <fl>) <fl>
          (cond ((< w 0.) a)
                ((> w 1.) b)
                (else (+ a (* (- b a) w)))))
        
        (loop (for x from 0 below 5)
              (loop (for z from 0 below 5)
                    (let ((total-height-var <fl> 0.)
                          (total-height <fl> 0.)
                          (total-weight <fl> 0.)
                          (biome (id->biome (s32vector-ref biomes (+ x 2 (* (+ z 2) 10))))))
                      (loop (for biome-x from -2 to 2)
                            (loop (for biome-z from -2 to 2)
                                  (let ((biome1 (id->biome (s32vector-ref biomes (+ x biome-x 2 (* (+ z biome-z 2) 10))))))
                                    (let ((base-height <fl> (+ biome-depth-offset (* (get-base~ biome1) biome-depth-weight)))
                                          (height-variation <fl> (+ biome-scale-offset (* (get-variation~ biome1) biome-scale-weight))))
                                      (let ((weight <fl> (/ (f64vector-ref biome-weights (+ biome-x 2 (* (+ biome-z 2) 5))) (+ base-height 2.))))
                                        (when (> (get-base~ biome1) (get-base~ biome))
                                          (divide! weight 2.))
                                        (increase! total-height-var (* height-variation weight))
                                        (increase! total-height (* base-height weight))
                                        (increase! total-weight weight))))))
                      (set! total-height-var (+ (* (/ total-height-var total-weight) .9) .1))
                      (set! total-height (/ (- (* (/ total-height total-weight) 4.) 1) 8.))
                      (let ((depth-factor <fl> (/ (f64vector-ref depth-region depth-index) 8000.)))
                        (if (< depth-factor 0.)
                            (set! depth-factor (- (* depth-factor -0.9) 2.))
                          (set! depth-factor (- (* depth-factor 3.) 2.)))
                        (if (< depth-factor 0.)
                            (if (< depth-factor -2.)
                                (set! depth-factor (/ -5. 14.))
                              (divide! depth-factor 5.6))
                          (if (> depth-factor 1.)
                              (set! depth-factor 1.)
                            (divide! depth-factor 8.)))
                        (increase! depth-index)
                        (set! total-height (* (+ total-height (* depth-factor .2)) (/ base-size 8.)))
                        (let ((height-factor <fl> (+ base-size (* total-height 4.))))
                          (loop (for y from 0 below 33)
                                (let ((min-height <fl> (* (- y height-factor) (/ stretch-y 2. total-height-var))))
                                  (when (< min-height 0.)
                                    (multiply! min-height 4.))
                                  (let ((min-limit <fl> (/ (f64vector-ref min-limit-region heightmaps-index) lower-limit-scale))
                                        (max-limit <fl> (/ (f64vector-ref max-limit-region heightmaps-index) upper-limit-scale))
                                        (main-height <fl> (/ (+ (/ (f64vector-ref main-noise heightmaps-index) 10.) 1.) 2.)))
                                    (let ((normalized-height <fl> (- (clamp min-limit max-limit main-height) min-height)))
                                      (when (> y 29)
                                        (let ((d6 (/ (- (cast <fl> y) 29.) 3.)))
                                          (set! normalized-height (+ (* normalized-height (- 1. d6)) (* -10. d6)))))
                                      (f64vector-set! heightmap heightmaps-index normalized-height)
                                      (increase! heightmaps-index))))))))))
        heightmap))))
  
  
  (definition rand-seed
    23)
  
  (definition rand
    (newRandom rand-seed))
  
  
  (definition sea-level <fx>
    63)
  
  
  (method (generate-blocks chunk block-ref block-set! data-set! heightmap <f64vector>)
    (site (blocks on?: #t parent: generate)
      (loop (for i from 0 below 4)
            (let ((j (* i 5))
                  (k (* (+ i 1) 5)))
              (loop (for l from 0 below 4)
                    (let ((i1 (* (+ j l) 33))
                          (j1 (* (+ j l 1) 33))
                          (k1 (* (+ k l) 33))
                          (l1 (* (+ k l 1) 33)))
                      (loop (for i2 from 0 below 32)
                            (let ((d1 (f64& (f64vector-ref heightmap (+ i1 i2))))
                                  (d2 (f64& (f64vector-ref heightmap (+ j1 i2))))
                                  (d3 (f64& (f64vector-ref heightmap (+ k1 i2))))
                                  (d4 (f64& (f64vector-ref heightmap (+ l1 i2)))))
                              (let ((d5 (f64& (/ (- (f64vector-ref heightmap (+ i1 i2 1)) (f64-ref d1)) 8.)))
                                    (d6 (f64& (/ (- (f64vector-ref heightmap (+ j1 i2 1)) (f64-ref d2)) 8.)))
                                    (d7 (f64& (/ (- (f64vector-ref heightmap (+ k1 i2 1)) (f64-ref d3)) 8.)))
                                    (d8 (f64& (/ (- (f64vector-ref heightmap (+ l1 i2 1)) (f64-ref d4)) 8.))))
                                (loop (for j2 from 0 below 8)
                                      (let ((d9 (f64& (f64-ref d1)))
                                            (d10 (f64& (f64-ref d2)))
                                            (y (+ j2 (* i2 8))))
                                        (let ((d11 (f64& (/ (- (f64-ref d3) (f64-ref d1)) 4.)))
                                              (d12 (f64& (/ (- (f64-ref d4) (f64-ref d2)) 4.))))
                                          (loop (for k2 from 0 below 4)
                                                (let ((d13 (f64& (/ (- (f64-ref d10) (f64-ref d9)) 4.)))
                                                      (x (+ k2 (* i 4))))
                                                  (let ((lvt-45-1 (f64& (f64-ref d9))))
                                                    (loop (for l2 from 0 below 4)
                                                          (let ((z (+ l2 (* l 4))))
                                                            (if (<= y (randomInt rand 5))
                                                                (block-set! x y z 7)
                                                              (if (> (f64-ref lvt-45-1) 0.)
                                                                  (block-set! x y z 1)
                                                                (when (< y sea-level)
                                                                  (block-set! x y z 9)))))
                                                          (f64-set! lvt-45-1 (+ (f64-ref lvt-45-1) (f64-ref d13))))
                                                    (f64-set! d9 (+ (f64-ref d9) (f64-ref d11)))
                                                    (f64-set! d10 (+ (f64-ref d10) (f64-ref d12))))))
                                          (f64-set! d1 (+ (f64-ref d1) (f64-ref d5)))
                                          (f64-set! d2 (+ (f64-ref d2) (f64-ref d6)))
                                          (f64-set! d3 (+ (f64-ref d3) (f64-ref d7)))
                                          (f64-set! d4 (+ (f64-ref d4) (f64-ref d8)))))))))))))))


  (method (replace-biome-blocks chunk <World-Chunk> block-ref block-set! blockstate-set!)
    (site (replace on?: #t parent: generate)
      (let ((biomes (get-biomes~ chunk)))
        (loop (for x from 0 below 16)
              (loop (for z from 0 below 16)
                    (let ((biome <Biome> (id->biome (u8vector-ref biomes (+ x (* z 16))))))
                      (replace-blocks~ biome x z rand block-ref block-set! blockstate-set!)))))))
  
  
  (method (generate-caverns chunk <World-Chunk> block-ref block-set! data-set!)
    (site (caverns on?: #t parent: generate)
    (let ((x (get-x~ chunk))
          (z (get-z~ chunk))
          (range 8)
          (br block-ref)
          (bs block-set!)
          (ds data-set!)
          (Air 0)
          (Water 8)
          (StationaryWater 9))
      (define (add-room seed chunkX chunkZ rx ry rz)
        (add-tunnel seed chunkX chunkZ rx ry rz (+ 1.0 (* (randomFloat rand) 6.0)) 0.0 0.0 -1 -1 0.5))
      
      (define (add-tunnel seed chunkX <fx> chunkZ <fx> rx <fl> ry <fl> rz <fl> p_180702_12_ <fl> p_180702_13_ <fl> p_180702_14_ <fl> p_180702_15_ <fx> p_180702_16_ <fx> p_180702_17_ <fl>)
        (continuation-capture
          (lambda (return)
            (let ((rx (f64& rx))
                  (ry (f64& ry))
                  (rz (f64& rz))
                  (d0 (+ (* (cast <fl> chunkX) 16.) 8.))
                  (d1 (+ (* (cast <fl> chunkZ) 16.) 8.))
                  (f0 (f64& 0.))
                  (f1 (f64& 0.)))
              (let ((random (newRandom seed)))
                (when (<= p_180702_16_ 0)
                  (let ((i (- (* range 16) 16)))
                    (set! p_180702_16_ (- i (randomInt random (/ i 4))))))
                (let ((flag2 #f))
                  (when (= p_180702_15_ -1)
                    (set! p_180702_15_ (fxfloor/ p_180702_16_ 2))
                    (set! flag2 #t))
                  (let ((j (+ (randomInt random (fxfloor/ p_180702_16_ 2)) (fxfloor/ p_180702_16_ 4)))
                        (flag (= (randomInt random 6) 0)))
                    (continuation-capture
                      (lambda (continue)
                        (loop (for p_180702_15_ from p_180702_15_ below p_180702_16_)
                              (let ((d2 (f64& (+ 1.5 (* (sin
                                                          (/ (* (cast <fl> p_180702_15_) PI)
                                                             (cast <fl> p_180702_16_)))
                                                        p_180702_12_)))))
                                (let ((d3 (f64& (* (f64-ref d2) p_180702_17_)))
                                      (f2 (f64& (cos p_180702_14_)))
                                      (f3 (f64& (sin p_180702_14_))))
                                  (f64-set! rx (+ (f64-ref rx) (* (cos p_180702_13_) (f64-ref f2))))
                                  (f64-set! ry (+ (f64-ref ry) (f64-ref f3)))
                                  (f64-set! rz (+ (f64-ref rz) (* (sin p_180702_13_) (f64-ref f2))))
                                  (if flag
                                      (set! p_180702_14_ (* p_180702_14_ .92))
                                    (set! p_180702_14_ (* p_180702_14_ .7)))
                                  (set! p_180702_14_ (+ p_180702_14_ (* (f64-ref f1) .1)))
                                  (increase! p_180702_13_ (* (f64-ref f0) .1))
                                  (f64-set! f1 (* (f64-ref f1) .9))
                                  (f64-set! f0 (* (f64-ref f0) .75))
                                  (f64-set! f1 (+ (f64-ref f1) (* (- (randomFloat random) (randomFloat random)) (randomFloat random) 2.)))
                                  (f64-set! f0 (+ (f64-ref f0) (* (- (randomFloat random) (randomFloat random)) (randomFloat random) 4.)))
                                  (when (and (not flag2)
                                             (= p_180702_15_ j)
                                             (> p_180702_12_ 1.)
                                             (> p_180702_16_ 0))
                                    (add-tunnel (randomLong random) chunkX chunkZ (f64-ref rx) (f64-ref ry) (f64-ref rz) (+ (* (randomFloat random) .5) .5) (- p_180702_13_ (/ PI 2.)) (/ p_180702_14_ 3.) p_180702_15_ p_180702_16_ 1.)
                                    (add-tunnel (randomLong random) chunkX chunkZ (f64-ref rx) (f64-ref ry) (f64-ref rz) (+ (* (randomFloat random) .5) .5) (+ p_180702_13_ (/ PI 2.)) (/ p_180702_14_ 3.) p_180702_15_ p_180702_16_ 1.)
                                    (continuation-return return #f))
                                  (when (or flag2 (/= (randomInt random 4) 0))
                                    (let ((d4 (- (f64-ref rx) d0))
                                          (d5 (- (f64-ref rz) d1))
                                          (d6 (- (cast <fl> p_180702_16_) (cast <fl> p_180702_15_)))
                                          (d7 (+ p_180702_12_ 2. 16.)))
                                      (when (> (- (+ (* d4 d4) (* d5 d5))
                                                  (* d6 d6))
                                               (* d7 d7))
                                        (continuation-return return #f))
                                      (when (and (>= (f64-ref rx) (- (- d0 16.) (* (f64-ref d2) 2.)))
                                                 (>= (f64-ref rz) (- (- d1 16.) (* (f64-ref d2) 2.)))
                                                 (<= (f64-ref rx) (+ d0 16. (* (f64-ref d2) 2.)))
                                                 (<= (f64-ref rz) (+ d1 16. (* (f64-ref d2) 2.))))
                                        (let ((k2 (- (- (fxfloor (- (f64-ref rx) (f64-ref d2))) (* chunkX 16)) 1))
                                              (k (+ (- (fxfloor (+ (f64-ref rx) (f64-ref d2))) (* chunkX 16)) 1))
                                              (l2 (- (fxfloor (- (f64-ref ry) (f64-ref d3))) 1))
                                              (l (+ (fxfloor (+ (f64-ref ry) (f64-ref d3))) 1))
                                              (i3 (- (- (fxfloor (- (f64-ref rz) (f64-ref d2))) (* chunkZ 16)) 1))
                                              (i1 (+ (- (fxfloor (+ (f64-ref rz) (f64-ref d2))) (* chunkZ 16)) 1)))
                                          (let ((k2 (if (< k2 0) 0 k2))
                                                (k (if (> k 16) 16 k))
                                                (l2 (if (< l2 1) 1 l2))
                                                (l (if (> l 248) 248 l))
                                                (i3 (if (< i3 0) 0 i3))
                                                (i1 (if (> i1 16) 16 i1))
                                                (flag3 #f))
                                            (loop (for j1 <fx> init k2 test (and (not flag3) (< j1 k)) iter (+ j1 1))
                                                  (loop (for k1 <fx> init i3 test (and (not flag3) (< k1 i1)) iter (+ k1 1))
                                                        (let (iter (l1 <fx> (+ l 1)))
                                                          (when (and (not flag3) (>= l1 (- l2 1)))
                                                            (if (and (>= l1 0) (< l1 256))
                                                                (let ((block <fx> (block-ref j1 l1 k1)))
                                                                  (when (or (= block Water)
                                                                            (= block StationaryWater))
                                                                    (set! flag3 #t))
                                                                  (if (and (/= l1 (- l2 1))
                                                                           (/= j1 k2)
                                                                           (/= j1 (- k 1))
                                                                           (/= k1 i3)
                                                                           (/= k1 (- i1 1)))
                                                                      (iter (- l2 1))
                                                                    (iter (- l1 1))))
                                                              (iter (- l1 1)))))))
                                            (unless flag3
                                              (loop (for j3 <fx> init k2 test (< j3 k) iter (+ j3 1))
                                                    (let ((d10 (/ (- (+ (cast <fl> j3) (* (cast <fl> chunkX) 16.) .5) (f64-ref rx)) (f64-ref d2))))
                                                      (loop (for i2 <fx> init i3 test (< i2 i1) iter (+ i2 1))
                                                            (let ((d8 (/ (- (+ (cast <fl> i2) (* (cast <fl> chunkZ) 16.) .5) (f64-ref rz)) (f64-ref d2))))
                                                              (when (< (+ (* d10 d10) (* d8 d8)) 1.)
                                                                (loop (for j2 <fx> init l test (> j2 l2) iter (- j2 1))
                                                                      (let ((d9 (f64& (/ (- (+ (- (cast <fl> j2) 1.) .5) (f64-ref ry)) (f64-ref d3)))))
                                                                        (when (and (> (f64-ref d9) -.7)
                                                                                   (< (+ (* d10 d10) (* (f64-ref d9) (f64-ref d9)) (* d8 d8)) 1.))
                                                                          (block-set! j3 j2 i2 Air)))))))))
                                              (when flag2
                                                (continuation-return continue #f))))))))))))))))))))
      
      (define (recursive-generate p <fx> q <fx> chunkX <fx> chunkZ <fx>)
        (let ((i (randomInt rand (+ (randomInt rand (+ (randomInt rand 15) 1)) 1))))
          (when (/= (randomInt rand 7) 0)
            (set! i 0))
          (loop (for j from 0 below i)
                (let ((rx (cast <fl> (+ (* p 16) (randomInt rand 16))))
                      (ry (cast <fl> (randomInt rand (+ (randomInt rand 120) 8))))
                      (rz (cast <fl> (+ (* q 16) (randomInt rand 16))))
                      (k 1))
                  (when (= (randomInt rand 4) 0)
                    (add-room (randomLong rand) chunkX chunkZ rx ry rz)
                    (increase! k (randomInt rand 4)))
                  (loop (for l from 0 below k)
                        (let ((f0 (* (randomFloat rand) (* PI 2.)))
                              (f1 (/ (* (- (randomFloat rand) .5) 2.) 8.))
                              (f2 (+ (* (randomFloat rand) 2.) (randomFloat rand))))
                          (when (= (randomInt rand 10) 0)
                            (multiply! f2 (+ (* (randomFloat rand) (randomFloat rand) 3.) 1.)))
                          (add-tunnel (randomLong rand) chunkX chunkZ rx ry rz f2 f0 f1 0 0 1.)))))))
      
      (let ((i range)
            (worldSeed (worldSeed)))
        (setSeed rand worldSeed)
        (let ((j (randomLong rand))
              (k (randomLong rand)))
          (loop (for p <fx> init (- x i) test (<= p (+ x i)) iter (+ p 1))
                (loop (for q <fx> init (- z i) test (<= q (+ z i)) iter (+ q 1))
                      (setSeedAux rand p q j k worldSeed)
                      (recursive-generate p q x z))))))))
  
  
  (method override (populate-chunk block-ref block-set! blockstate-set! skylight-set! chunk front corner right)
    (define (neighbor-chunk x <fx> z <fx>) <World-Chunk>
      (if (< x 16)
          (if (< z 16)
              chunk
            front)
        (if (< z 16)
            right
          corner)))
    
    (define (get-height x <fx> z <fx>) <fx>
      (get-chunk-height~ (neighbor-chunk x z) (modulo x 16) (modulo z 16)))
    
    (define (get-biome x <fx> z <fx>) <Biome>
      (id->biome (u8vector-ref (get-biomes~ (neighbor-chunk x z)) (heightmap-index (modulo x 16) (modulo z 16)))))
    
    (define (heightmap-index x <fx> z <fx>) <fx>
      (+ x (* z 16)))
    
    (define (chunk-block-ref x <fx> y <fx> z <fx>) <fx>
      (block-ref (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16)))
    
    (define (chunk-block-set! x <fx> y <fx> z <fx> block-id <fx>)
      (block-set! (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16) block-id))
    
    (define (chunk-blockstate-set! x <fx> y <fx> z <fx> id <fx>)
      (blockstate-set! (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16) id))
    
    (define (chunk-skylight-set! x <fx> y <fx> z <fx> value <fx>)
      (skylight-set! (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16) value))
    
    (define (chunk-get-sector x <fx> y <fx> z <fx>)
      (get-sector~ (get-section~ (neighbor-chunk x z) (fxfloor/ y 16))))
    
    (site (populate on?: #t parent: generate)
      (let ((biome (get-biome 16 16)))
        (decorate-biome~ biome rand chunk-block-ref chunk-block-set! chunk-blockstate-set! chunk-skylight-set! chunk-get-sector get-height))))
  
  
  (method (generate-perlin-noise attributes <vector> x-offset <fl> y-offset <fl> z-offset <fl> x-size <fx> y-size <fx> z-size <fx> x-scale <fl> y-scale <fl> z-scale <fl>) <f64vector>
    (let ((noise (make-f64vector (* x-size y-size z-size) 0.))
          (octaves (vector-length attributes)))
      (let (iter (i 0) (scaling 1.))
        (if (< i octaves)
            (let ((scaled-x-offset (* scaling x-offset x-scale))
                  (scaled-y-offset (* scaling y-offset y-scale))
                  (scaled-z-offset (* scaling z-offset z-scale)))
              (generate-noise-octave noise (vector-ref attributes i) (flmodulo scaled-x-offset 16777216.) scaled-y-offset (flmodulo scaled-z-offset 16777216.) x-size y-size z-size (* x-scale scaling) (* y-scale scaling) (* z-scale scaling) scaling)
              (iter (+ i 1) (/ scaling 2.)))
          noise))))
  
  
  (method (generate-noise-octave noise <f64vector> attributes <Perlin-Attributes> x-offset <fl> y-offset <fl> z-offset <fl> x-size <fx> y-size <fx> z-size <fx> x-scale <fl> y-scale <fl> z-scale <fl> scaling <fl>)
    (generateOctaves
      noise
      (get-permutations~ attributes) (get-x-coord~ attributes) (get-y-coord~ attributes) (get-z-coord~ attributes)
      x-offset y-offset z-offset x-size y-size z-size x-scale y-scale z-scale scaling)
    @jazz (optimize ()
    (let ((permutations (get-permutations~ attributes)))
      (if (= y-size 1)
          (let ((j (fx& 0))
                (i5 (fx& 0))
                (j5 (fx& 0))
                (k5 (fx& 0))
                (d14 (f64& 0.))
                (d15 (f64& 0.))
                (d21 (f64& 0.))
                (index (fx& 0)))
            (loop (for x from 0 below x-size)
                  (let ((k2 (make-fx&))
                        (d17 (make-f64&))
                        (d18 (make-f64&)))
                    (smooth/floor (+ x-offset (* (cast <fl> x) x-scale) (get-x-coord~ attributes)) k2 d17 d18)
                    (loop (for z from 0 below z-size)
                          (let ((l6 (make-fx&))
                                (d19 (make-f64&))
                                (d20 (make-f64&)))
                            (smooth/floor (+ z-offset (* (cast <fl> z) z-scale) (get-z-coord~ attributes)) l6 d19 d20)
                            (fx-set! i5 (permute (fx-ref k2)))
                            (fx-set! j5 (+ (permute (fx-ref i5)) (fx-ref l6)))
                            (fx-set! j (permute (+ (fx-ref k2) 1)))
                            (fx-set! k5 (+ (permute (fx-ref j)) (fx-ref l6)))
                            (f64-set! d14 (lerp (grad-2d (permute (fx-ref j5)) (f64-ref d17) (f64-ref d19)) (grad-2d (permute (fx-ref k5)) (- (f64-ref d17) 1.) (f64-ref d19)) (f64-ref d18)))
                            (f64-set! d15 (lerp (grad-2d (permute (+ (fx-ref j5) 1)) (f64-ref d17) (- (f64-ref d19) 1.)) (grad-2d (permute (+ (fx-ref k5) 1)) (- (f64-ref d17) 1.) (- (f64-ref d19) 1.)) (f64-ref d18)))
                            (f64-set! d21 (lerp (f64-ref d14) (f64-ref d15) (f64-ref d20)))
                            (f64vector-set! noise (fx-ref index) (+ (f64vector-ref noise (fx-ref index)) (/ (f64-ref d21) scaling)))
                            (fx-set! index (+ (fx-ref index) 1)))))))
        (let ((k (fx& -1))
              (l (fx& 0))
              (i1 (fx& 0))
              (j1 (fx& 0))
              (k1 (fx& 0))
              (l1 (fx& 0))
              (i2 (fx& 0))
              (d1 (f64& 0.))
              (d2 (f64& 0.))
              (d3 (f64& 0.))
              (d4 (f64& 0.))
              (d11 (f64& 0.))
              (d12 (f64& 0.))
              (d13 (f64& 0.))
              (index (fx& 0)))
          (loop (for x from 0 below x-size)
                (let ((j3 (make-fx&))
                      (d5 (make-f64&))
                      (d6 (make-f64&)))
                  (smooth/floor (+ x-offset (* (cast <fl> x) x-scale) (get-x-coord~ attributes)) j3 d5 d6)
                  (loop (for z from 0 below z-size)
                        (let ((i4 (make-fx&))
                              (d7 (make-f64&))
                              (d8 (make-f64&)))
                          (smooth/floor (+ z-offset (* (cast <fl> z) z-scale) (get-z-coord~ attributes)) i4 d7 d8)
                          (loop (for y from 0 below y-size)
                                (let ((l4 (make-fx&))
                                      (d9 (make-f64&))
                                      (d10 (make-f64&)))
                                  (smooth/floor (+ y-offset (* (cast <fl> y) y-scale) (get-y-coord~ attributes)) l4 d9 d10)
                                  (when (or (= y 0) (/= (fx-ref l4) (fx-ref k)))
                                    (fx-set! k (fx-ref l4))
                                    (fx-set! l (+ (permute (fx-ref j3)) (fx-ref l4)))
                                    (fx-set! i1 (+ (permute (fx-ref l)) (fx-ref i4)))
                                    (fx-set! j1 (+ (permute (+ (fx-ref l) 1)) (fx-ref i4)))
                                    (fx-set! k1 (+ (permute (+ (fx-ref j3) 1)) (fx-ref l4)))
                                    (fx-set! l1 (+ (permute (fx-ref k1)) (fx-ref i4)))
                                    (fx-set! i2 (+ (permute (+ (fx-ref k1) 1)) (fx-ref i4)))
                                    (f64-set! d1 (lerp (grad (permute (fx-ref i1)) (f64-ref d5) (f64-ref d9) (f64-ref d7)) (grad (permute (fx-ref l1)) (- (f64-ref d5) 1.) (f64-ref d9) (f64-ref d7)) (f64-ref d6)))
                                    (f64-set! d2 (lerp (grad (permute (fx-ref j1)) (f64-ref d5) (- (f64-ref d9) 1.) (f64-ref d7)) (grad (permute (fx-ref i2)) (- (f64-ref d5) 1.) (- (f64-ref d9) 1.) (f64-ref d7)) (f64-ref d6)))
                                    (f64-set! d3 (lerp (grad (permute (+ (fx-ref i1) 1)) (f64-ref d5) (f64-ref d9) (- (f64-ref d7) 1.)) (grad (permute (+ (fx-ref l1) 1)) (- (f64-ref d5) 1.) (f64-ref d9) (- (f64-ref d7) 1.)) (f64-ref d6)))
                                    (f64-set! d4 (lerp (grad (permute (+ (fx-ref j1) 1)) (f64-ref d5) (- (f64-ref d9) 1.) (- (f64-ref d7) 1.)) (grad (permute (+ (fx-ref i2) 1)) (- (f64-ref d5) 1.) (- (f64-ref d9) 1.) (- (f64-ref d7) 1.)) (f64-ref d6))))
                                  (f64-set! d11 (lerp (f64-ref d1) (f64-ref d2) (f64-ref d10)))
                                  (f64-set! d12 (lerp (f64-ref d3) (f64-ref d4) (f64-ref d10)))
                                  (f64-set! d13 (lerp (f64-ref d11) (f64-ref d12) (f64-ref d8)))
                                  (f64vector-set! noise (fx-ref index) (+ (f64vector-ref noise (fx-ref index)) (/ (f64-ref d13) scaling)))
                                  (fx-set! index (+ (fx-ref index) 1)))))))))))))))
