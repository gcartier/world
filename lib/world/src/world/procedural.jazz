;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Procedural Content
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.procedural jazz


(import (jazz.component)
        (jazz.syntax (phase syntax))
        (world.biome)
        (world.chunk)
        (world.foreign)
        (world.foreign.noise)
        (world.geometry.syntax)
        (world.generation.building)
        (world.homogeneous)
        (world.layer)
        (world.region)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))


;;;
;;;; Generator
;;;


(class Generator extends Component
  
  
  (property revision <fx> initialize 0 accessors generate)
  
  
  (method protected virtual (free)
    )
  
  
  (method protected (increase-revision)
    (increase! revision))
  
  
  (method protected virtual (generate-chunk chunk <World-Chunk> block-ref block-set! data-set! blockstate-set! skylight-set!)
    )
  
  
  (method protected virtual (generate-heightmap chunk-x chunk-z region-x region-z)
    ))


;;;
;;;; Empty
;;;


(class Empty-Generator extends Generator)


;;;
;;;; Flat
;;;


(class Flat-Generator extends Generator
  
  
  (method override (generate-chunk chunk <World-Chunk> block-ref block-set! data-set! blockstate-set! skylight-set!)
    (loop (for i from 0 below 16)
          (loop (for k from 0 below 16)
                (block-set! i 0 k Bedrock)
                (block-set! i 1 k Dirt)
                (block-set! i 2 k Dirt)
                (block-set! i 3 k Grass)))
    (generate-skylight~ chunk block-ref skylight-set!)))


;;;
;;;; Simplex
;;;


(class Simplex-Generator extends Generator
  
  
  (slot simplex initialize #f getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! simplex (simplex-noise 87)))
  
  
  (method override (free)
    (simplex-noise-free simplex)
    (nextmethod))
  
  
  (method override (generate-heightmap chunk-x <fx> chunk-z <fx> region-x <fx> region-z <fx>)
    (let ((heights (make-f64vector 256 1.))
          (base-x (* (+ chunk-x (* region-x 32)) 16.))
          (base-z (* (+ chunk-z (* region-z 32)) 16.)))
      (define (vector-index x <fx> z <fx>) <fx>
        (+ x (* z 16)))
      
      (let ((frequency .02)
            (amplitude 20.)
            (octaves 3)
            (lacunarity 2.0)
            (gain .5))
        (loop (repeat octaves)
              (loop (for a from 0 below 16)
                    (loop (for c from 0 below 16)
                          (let ((index (vector-index a c))
                                (x (* (+ base-x (cast <fl> a)) frequency))
                                (z (* (+ base-z (cast <fl> c)) frequency)))
                            (f64vector-set! heights index (+ (f64vector-ref heights index) (* amplitude (+ 1. (simplex-noise2 simplex x z))))))))
              (set! amplitude (* amplitude gain))
              (set! frequency (* frequency lacunarity))))
      heights)))


;;;
;;;; World
;;;


(definition coordinate-scale <fl>
  684.412) ;; 684.412


(definition height-scale <fl>
  684.412) ;; 684.412


(definition depth-noise-scale-x <fl>
  200.) ;; 200.

(definition depth-noise-scale-z <fl>
  200.) ;; 200.


(definition main-noise-scale-x <fl>
  80.) ;; 80.

(definition main-noise-scale-y <fl>
  160.) ;; 160.

(definition main-noise-scale-z <fl>
  80.) ;; 80.


(definition base-size <fl>
  8.5) ;; 8.5


(definition lower-limit-scale <fl>
  512.) ;; 512.

(definition upper-limit-scale <fl>
  512.) ;; 512.


(definition default-base-height <fl>
  .125) ;; .125

(definition default-height-variation <fl>
  .05) ;; .05


(definition stretch-y <fl>
  12.) ;; 12.


(definition biome-depth-weight <fl>
  1.) ;; 1.

(definition biome-depth-offset <fl>
  0.) ;; 0.

(definition biome-scale-weight <fl>
  1.) ;; 1.

(definition biome-scale-offset <fl>
  0.) ;; 0.


(definition rand-seed
  42)

(definition rand
  (newRandom 42))


(definition inline (smooth x <fl>) <fl>
  (* x x x (+ (* x (- (* x 6.) 15.)) 10.)))


(definition grad-x <f64vector>
  #f64(1. -1. 1. -1. 1. -1. 1. -1. 0. 0. 0. 0. 1. 0. -1. 0.))

(definition grad-y <f64vector>
  #f64(1. 1. -1. -1. 0. 0. 0. 0. 1. -1. 1. -1. 1. -1. 1. -1.))

(definition grad-z <f64vector>
  #f64(0. 0. 0. 0. 1. 1. -1. -1. 1. 1. -1. -1. 0. 1. 0. -1.))

(definition inline (grad index <fx> x <fl> y <fl> z <fl>) <fl>
  (let ((i (bitwise-and index #b1111)))
    (+ (* (f64vector-ref grad-x i) x) (* (f64vector-ref grad-y i) y) (* (f64vector-ref grad-z i) z))))

(definition inline (grad-2d index <fx> x <fl> z <fl>) <fl>
  (let ((i (bitwise-and index #b1111)))
    (+ (* (f64vector-ref grad-x i) x) (* (f64vector-ref grad-z i) z))))


(definition inline (lerp a <fl> b <fl> w <fl>) <fl>
  (+ a (* w (- b a))))


(class Perlin-Attributes extends Object
  
  
  (slot permutations <s32vector> initialize (make-s32vector 512) getter generate)
  (slot x-coord      <fl>        initialize 0.                   getter generate)
  (slot y-coord      <fl>        initialize 0.                   getter generate)
  (slot z-coord      <fl>        initialize 0.                   getter generate)
  
  
  (method override (initialize)
    (setSeed rand rand-seed)
    (set! x-coord (* (randomFloat rand) 256.))
    (set! y-coord (* (randomFloat rand) 256.))
    (set! z-coord (* (randomFloat rand) 256.))
    (loop (for i from 0 below 256)
          (s32vector-set! permutations i i))
    (loop (for j from 0 below 256)
          (let ((rnd (randomIntBetween rand j 255))
                (temp (s32vector-ref permutations j)))
            (s32vector-set! permutations j (s32vector-ref permutations rnd))
            (s32vector-set! permutations rnd temp)
            (s32vector-set! permutations (+ j 256) (s32vector-ref permutations j))))))


(class World-Generator extends Generator
  
  
  (slot biome-weights     <f64vector> initialize (make-f64vector 25 0.) getter generate)
  (slot main-attributes               initialize (make-vector 8  (new Perlin-Attributes)) getter generate)
  (slot min-attributes                initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  (slot max-attributes                initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  (slot depth-attributes              initialize (make-vector 16 (new Perlin-Attributes)) getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (loop (for i from -2 below 3)
          (loop (for j from -2 below 3)
                (f64vector-set! biome-weights (+ i 2 (* (+ j 2) 5)) (/ 10. (sqrt (+ (* (cast <fl> i) (cast <fl> i)) (* (cast <fl> j) (cast <fl> j)) .2)))))))
  
  
  (method override (generate-chunk chunk <World-Chunk> block-ref block-set! data-set! blockstate-set! skylight-set!)
    (site (generate on?: #t)
    (let ((region <World-Region> (get-region~ chunk)))
      (setSeed rand rand-seed)
      (generate-blocks~ chunk block-ref block-set! data-set! (generate-heightmap (get-x~ chunk) (get-z~ chunk) (get-x~ region) (get-z~ region)))
      (replace-biome-blocks~ chunk block-ref block-set! blockstate-set!)
      (generate-caves~ chunk block-ref block-set! data-set!)
      (generate-skylight~ chunk block-ref skylight-set!))))
  
  
  (method override (generate-heightmap chunk-x <fx> chunk-z <fx> region-x <fx> region-z <fx>) <f64vector>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (site (heightmap on?: #t parent: generate) 
    (let ((chunk-offset-x (* (+ (cast <fl> chunk-x) (* 32. (cast <fl> region-x))) 4.))
          (chunk-offset-z (* (+ (cast <fl> chunk-z) (* 32. (cast <fl> region-z))) 4.)))
      (let ((depth-region (generate-perlin-noise depth-attributes chunk-offset-x 10. chunk-offset-z 5 1 5 depth-noise-scale-x 1. depth-noise-scale-z))
            (main-noise (generate-perlin-noise main-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 (/ coordinate-scale main-noise-scale-x) (/ height-scale main-noise-scale-y) (/ coordinate-scale main-noise-scale-z)))
            (min-limit-region (generate-perlin-noise min-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 coordinate-scale height-scale coordinate-scale))
            (max-limit-region (generate-perlin-noise max-attributes chunk-offset-x 0. chunk-offset-z 5 33 5 coordinate-scale height-scale coordinate-scale))
            (heightmap (make-f64vector 825 0.))
            (biomes (generate-heightmap-biomes region-x region-z chunk-x chunk-z))
            (heightmaps-index 0)
            (depth-index 0))
        (define (clamp a <fl> b <fl> w <fl>) <fl>
          (cond ((< w 0.) a)
                ((> w 1.) b)
                (else (+ a (* (- b a) w)))))
        
        (loop (for x from 0 below 5)
              (loop (for z from 0 below 5)
                    (let ((total-height-var <fl> 0.)
                          (total-height <fl> 0.)
                          (total-weight <fl> 0.)
                          (biome (id->biome (s32vector-ref biomes (+ x 2 (* (+ z 2) 10))))))
                      (loop (for biome-x from -2 to 2)
                            (loop (for biome-z from -2 to 2)
                                  (let ((biome1 (id->biome (s32vector-ref biomes (+ x biome-x 2 (* (+ z biome-z 2) 10))))))
                                    (let ((base-height <fl> (+ biome-depth-offset (* (get-base~ biome1) biome-depth-weight)))
                                          (height-variation <fl> (+ biome-scale-offset (* (get-variation~ biome1) biome-scale-weight))))
                                      (let ((weight <fl> (/ (f64vector-ref biome-weights (+ biome-x 2 (* (+ biome-z 2) 5))) (+ base-height 2.))))
                                        (when (> (get-base~ biome1) (get-base~ biome))
                                          (divide! weight 2.))
                                        (increase! total-height-var (* height-variation weight))
                                        (increase! total-height (* base-height weight))
                                        (increase! total-weight weight))))))
                      (set! total-height-var (+ (* (/ total-height-var total-weight) .9) .1))
                      (set! total-height (/ (- (* (/ total-height total-weight) 4.) 1) 8.))
                      (let ((depth-factor <fl> (/ (f64vector-ref depth-region depth-index) 8000.)))
                        (if (< depth-factor 0.)
                            (set! depth-factor (- (* depth-factor -0.9) 2.))
                          (set! depth-factor (- (* depth-factor 3.) 2.)))
                        (if (< depth-factor 0.)
                            (if (< depth-factor -2.)
                                (set! depth-factor (/ -5. 14.))
                              (divide! depth-factor 5.6))
                          (if (> depth-factor 1.)
                              (set! depth-factor 1.)
                            (divide! depth-factor 8.)))
                        (increase! depth-index)
                        (set! total-height (* (+ total-height (* depth-factor .2)) (/ base-size 8.)))
                        (let ((height-factor <fl> (+ base-size (* total-height 4.))))
                          (loop (for y from 0 below 33)
                                (let ((min-height <fl> (* (- y height-factor) (/ stretch-y 2. total-height-var))))
                                  (when (< min-height 0.)
                                    (multiply! min-height 4.))
                                  (let ((min-limit <fl> (/ (f64vector-ref min-limit-region heightmaps-index) lower-limit-scale))
                                        (max-limit <fl> (/ (f64vector-ref max-limit-region heightmaps-index) upper-limit-scale))
                                        (main-height <fl> (/ (+ (/ (f64vector-ref main-noise heightmaps-index) 10.) 1.) 2.)))
                                    (let ((normalized-height <fl> (- (clamp min-limit max-limit main-height) min-height)))
                                      (when (> y 29)
                                        (let ((d6 (/ (- (cast <fl> y) 29.) 3.)))
                                          (set! normalized-height (+ (* normalized-height (- 1. d6)) (* -10. d6)))))
                                      (f64vector-set! heightmap heightmaps-index normalized-height)
                                      (increase! heightmaps-index))))))))))
        heightmap))))
  
  
  (method (generate-perlin-noise attributes <vector> x-offset <fl> y-offset <fl> z-offset <fl> x-size <fx> y-size <fx> z-size <fx> x-scale <fl> y-scale <fl> z-scale <fl>) <f64vector>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((noise (make-f64vector (* x-size y-size z-size) 0.))
          (octaves (vector-length attributes)))
      (let (iter (i 0) (scaling 1.))
        (if (< i octaves)
            (let ((scaled-x-offset (* scaling x-offset x-scale))
                  (scaled-y-offset (* scaling y-offset y-scale))
                  (scaled-z-offset (* scaling z-offset z-scale)))
              (generate-noise-octave noise (vector-ref attributes i) (flmodulo scaled-x-offset 16777216.) scaled-y-offset (flmodulo scaled-z-offset 16777216.) x-size y-size z-size (* x-scale scaling) (* y-scale scaling) (* z-scale scaling) scaling)
              (iter (+ i 1) (/ scaling 2.)))
          noise))))
  
  
  (method (generate-noise-octave noise <f64vector> attributes <Perlin-Attributes> x-offset <fl> y-offset <fl> z-offset <fl> x-size <fx> y-size <fx> z-size <fx> x-scale <fl> y-scale <fl> z-scale <fl> scaling <fl>)
    (generateOctaves
      noise
      (get-permutations~ attributes) (get-x-coord~ attributes) (get-y-coord~ attributes) (get-z-coord~ attributes)
      x-offset y-offset z-offset x-size y-size z-size x-scale y-scale z-scale scaling)
    @jazz (begin
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((permutations (get-permutations~ attributes)))
      (if (= y-size 1)
          (let ((j (fx& 0))
                (i5 (fx& 0))
                (j5 (fx& 0))
                (k5 (fx& 0))
                (d14 (f64& 0.))
                (d15 (f64& 0.))
                (d21 (f64& 0.))
                (index (fx& 0)))
            (loop (for x from 0 below x-size)
                  (let ((k2 (make-fx&))
                        (d17 (make-f64&))
                        (d18 (make-f64&)))
                    (smooth/floor (+ x-offset (* (cast <fl> x) x-scale) (get-x-coord~ attributes)) k2 d17 d18)
                    (loop (for z from 0 below z-size)
                          (let ((l6 (make-fx&))
                                (d19 (make-f64&))
                                (d20 (make-f64&)))
                            (smooth/floor (+ z-offset (* (cast <fl> z) z-scale) (get-z-coord~ attributes)) l6 d19 d20)
                            (fx-set! i5 (permute (fx-ref k2)))
                            (fx-set! j5 (+ (permute (fx-ref i5)) (fx-ref l6)))
                            (fx-set! j (permute (+ (fx-ref k2) 1)))
                            (fx-set! k5 (+ (permute (fx-ref j)) (fx-ref l6)))
                            (f64-set! d14 (lerp (grad-2d (permute (fx-ref j5)) (f64-ref d17) (f64-ref d19)) (grad-2d (permute (fx-ref k5)) (- (f64-ref d17) 1.) (f64-ref d19)) (f64-ref d18)))
                            (f64-set! d15 (lerp (grad-2d (permute (+ (fx-ref j5) 1)) (f64-ref d17) (- (f64-ref d19) 1.)) (grad-2d (permute (+ (fx-ref k5) 1)) (- (f64-ref d17) 1.) (- (f64-ref d19) 1.)) (f64-ref d18)))
                            (f64-set! d21 (lerp (f64-ref d14) (f64-ref d15) (f64-ref d20)))
                            (f64vector-set! noise (fx-ref index) (+ (f64vector-ref noise (fx-ref index)) (/ (f64-ref d21) scaling)))
                            (fx-set! index (+ (fx-ref index) 1)))))))
        (let ((k (fx& -1))
              (l (fx& 0))
              (i1 (fx& 0))
              (j1 (fx& 0))
              (k1 (fx& 0))
              (l1 (fx& 0))
              (i2 (fx& 0))
              (d1 (f64& 0.))
              (d2 (f64& 0.))
              (d3 (f64& 0.))
              (d4 (f64& 0.))
              (d11 (f64& 0.))
              (d12 (f64& 0.))
              (d13 (f64& 0.))
              (index (fx& 0)))
          (loop (for x from 0 below x-size)
                (let ((j3 (make-fx&))
                      (d5 (make-f64&))
                      (d6 (make-f64&)))
                  (smooth/floor (+ x-offset (* (cast <fl> x) x-scale) (get-x-coord~ attributes)) j3 d5 d6)
                  (loop (for z from 0 below z-size)
                        (let ((i4 (make-fx&))
                              (d7 (make-f64&))
                              (d8 (make-f64&)))
                          (smooth/floor (+ z-offset (* (cast <fl> z) z-scale) (get-z-coord~ attributes)) i4 d7 d8)
                          (loop (for y from 0 below y-size)
                                (let ((l4 (make-fx&))
                                      (d9 (make-f64&))
                                      (d10 (make-f64&)))
                                  (smooth/floor (+ y-offset (* (cast <fl> y) y-scale) (get-y-coord~ attributes)) l4 d9 d10)
                                  (when (or (= y 0) (/= (fx-ref l4) (fx-ref k)))
                                    (fx-set! k (fx-ref l4))
                                    (fx-set! l (+ (permute (fx-ref j3)) (fx-ref l4)))
                                    (fx-set! i1 (+ (permute (fx-ref l)) (fx-ref i4)))
                                    (fx-set! j1 (+ (permute (+ (fx-ref l) 1)) (fx-ref i4)))
                                    (fx-set! k1 (+ (permute (+ (fx-ref j3) 1)) (fx-ref l4)))
                                    (fx-set! l1 (+ (permute (fx-ref k1)) (fx-ref i4)))
                                    (fx-set! i2 (+ (permute (+ (fx-ref k1) 1)) (fx-ref i4)))
                                    (f64-set! d1 (lerp (grad (permute (fx-ref i1)) (f64-ref d5) (f64-ref d9) (f64-ref d7)) (grad (permute (fx-ref l1)) (- (f64-ref d5) 1.) (f64-ref d9) (f64-ref d7)) (f64-ref d6)))
                                    (f64-set! d2 (lerp (grad (permute (fx-ref j1)) (f64-ref d5) (- (f64-ref d9) 1.) (f64-ref d7)) (grad (permute (fx-ref i2)) (- (f64-ref d5) 1.) (- (f64-ref d9) 1.) (f64-ref d7)) (f64-ref d6)))
                                    (f64-set! d3 (lerp (grad (permute (+ (fx-ref i1) 1)) (f64-ref d5) (f64-ref d9) (- (f64-ref d7) 1.)) (grad (permute (+ (fx-ref l1) 1)) (- (f64-ref d5) 1.) (f64-ref d9) (- (f64-ref d7) 1.)) (f64-ref d6)))
                                    (f64-set! d4 (lerp (grad (permute (+ (fx-ref j1) 1)) (f64-ref d5) (- (f64-ref d9) 1.) (- (f64-ref d7) 1.)) (grad (permute (+ (fx-ref i2) 1)) (- (f64-ref d5) 1.) (- (f64-ref d9) 1.) (- (f64-ref d7) 1.)) (f64-ref d6))))
                                  (f64-set! d11 (lerp (f64-ref d1) (f64-ref d2) (f64-ref d10)))
                                  (f64-set! d12 (lerp (f64-ref d3) (f64-ref d4) (f64-ref d10)))
                                  (f64-set! d13 (lerp (f64-ref d11) (f64-ref d12) (f64-ref d8)))
                                  (f64vector-set! noise (fx-ref index) (+ (f64vector-ref noise (fx-ref index)) (/ (f64-ref d13) scaling)))
                                  (fx-set! index (+ (fx-ref index) 1)))))))))))))))
