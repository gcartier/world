;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Procedural Content
;;;


(module world.procedural jazz


(import (jazz.geometry))


(proclaim (warn optimizations))


;;;
;;;; Perlin Noise
;;;


(definition private *perlin-permutations*
  #(25 155 210 108 175 199 221 144 203 116 70 213 69 158 33 252
     5 82 173 133 222 139 174 27 9 71 90 246 75 130 91 191
     169 138 2 151 194 235 81 7 25 113 228 159 205 253 134 142
     248 65 224 217 22 121 229 63 89 103 96 104 156 17 201 129
     36 8 165 110 237 117 231 56 132 211 152 20 181 111 239 218
     170 163 51 172 157 47 80 212 176 250 87 49 99 242 136 189
     162 115 44 43 124 94 150 16 141 247 32 10 198 223 255 72
     53 131 84 57 220 197 58 50 208 11 241 28 3 192 62 202
     18 215 153 24 76 41 15 179 39 46 55 6 128 167 23 188
     106 34 187 140 164 73 112 182 244 195 227 13 35 77 196 185
     26 200 226 119 31 123 168 125 249 68 183 230 177 135 160 180
     12 1 243 148 102 166 38 238 251 37 240 126 64 74 161 40
     184 149 171 178 101 66 29 59 146 61 254 107 42 86 154 4
     236 232 120 21 233 209 45 98 193 114 78 19 206 14 118 127
     48 79 147 85 30 207 219 54 88 234 190 122 95 67 143 109
     137 214 145 93 92 100 245 0 216 186 60 83 105 97 204 52))

(definition private *perlin-permutations-size* <fx>
  (vector-length *perlin-permutations*))


(class Perlin-Generator extends Object
  
  
  (property detail-level   <fl> accessors generate)
  (property clamp-height   <fl> accessors generate)
  (property gradient-table <f32vector> initialize (make-f32vector (* *perlin-permutations-size* 3)))
  
  
  (method override (initialize detail-level clamp-height)
    (nextmethod)
    (set! detail-level~self detail-level)
    (set! clamp-height~self clamp-height)
    (let (loop (i 0))
      (when (< i *perlin-permutations-size*)
        (begin
          (let ((z (- 1.0 (* 2.0 (random-real)))))
            (let ((r (sqrt (- 1.0 (* z z))))
                  (theta (* 2.0 PI (random-real))))
              (f32vector-set! gradient-table (* i 3)
                (* r (cos theta)))
              (f32vector-set! gradient-table (+ (* i 3) 1)
                (* r (sin theta)))
              (f32vector-set! gradient-table (+ (* i 3) 2)
                z)))
          (loop (+ i 1))))))
  
  
  (method private (permute x <fx>) <fx>
    (cast <fx> (vector-ref *perlin-permutations* (bitwise-and (- *perlin-permutations-size* 1) x))))
  
  
  (method private (index ix <fx> iy <fx> iz <fx>) <fx>
    (permute (+ ix (permute (+ iy (permute iz))))))
  
  
  (method private (lattice ix <fx> iy <fx> iz <fx> fx <fl> fy <fl> fz <fl>) <fl>
    (let ((i (index ix iy iz)))
      (let ((g (* 3 i)))
        (+ (* fx (f32vector-ref gradient-table g))
           (* fy (f32vector-ref gradient-table (+ g 1)))
           (* fz (f32vector-ref gradient-table (+ g 2)))))))
  
  
  (method private (lerp t <fl> v0 <fl> v1 <fl>) <fl>
    (+ v0 (* t (- v1 v0))))
  
  
  (method private (smooth x <fl>) <fl>
    (* x x (- 3. (* 2. x))))
  
  
  (method private (point x <fl> y <fl> z <fl>) <fl>
    (let ((ix (fxtruncate x))
          (iy (fxtruncate y))
          (iz (fxtruncate z)))
      (let ((fx0 (- x ix))
            (fy0 (- y iy))
            (fz0 (- z iz)))
        (let ((fx1 (- fx0 1.))
              (fy1 (- fy0 1.))
              (fz1 (- fz0 1.)))
          (let ((wx (smooth fx0))
                (wy (smooth fy0))
                (wz (smooth fz0)))
            (let ((vz0 (lerp wy
                             (lerp wx
                                   (lattice ix iy iz fx0 fy0 fz0)
                                   (lattice (+ ix 1) iy iz fx1 fy0 fz0))
                             (lerp wx
                                   (lattice ix (+ iy 1) iz fx0 fy1 fz0)
                                   (lattice (+ ix 1) (+ iy 1) iz fx1 fy1 fz0))))
                  (vz1 (lerp wy
                             (lerp wx
                                   (lattice ix iy (+ iz 1) fx0 fy0 fz1)
                                   (lattice (+ ix 1) iy (+ iz 1) fx1 fy0 fz1))
                             (lerp wx
                                   (lattice ix (+ iy 1) (+ iz 1) fx0 fy1 fz1)
                                   (lattice (+ ix 1) (+ iy 1) (+ iz 1) fx1 fy1 fz1)))))
              (lerp wz vz0 vz1)))))))
  
  
  (method (raw-value x <fl> y <fl>) <fl>
    (point (/ x detail-level)
           (/ y detail-level)
           0.))
  
  
  (method public (get-value x <fl> y <fl>) <fl>
    (* (raw-value x y)
       clamp-height)))


;;;
;;;; Diamond Square
;;;


@wait
(definition public (diamond-square power (detail-level: detail-level 64) (clamp-height: clamp-height 64))
  (define half-clamp-height (/ clamp-height 2))
  (define (to-index col row size)
    (+ (* row size) col)) 
  (define (clamp value (min: min #f) (max: max #f))
    (if (< value (or min (- half-clamp-height)))
        (or min (- half-clamp-height))
      (if (> value (or max half-clamp-height))
          (or max half-clamp-height)
        value)))
  (define (random-bound)
    (* half-clamp-height (- (random-integer 3) 1)))
  (define (diamond data bound length range)
    ;; quick patch for dominic to fix
    (when (not (integer? range))
      (set! range (flonum->fixnum (round (exact->inexact range)))))
    (let ((half-range (arithmetic-shift-right range 1))
          (part (arithmetic-shift-right length 1))
          (size (+ bound 1)))
      (let (outer (y-part (arithmetic-shift-right length 1))
                  (y 0))
        (when (< y bound)
          (let (inner (x 0))
            (when (< x bound)
              (vector-set! data (to-index (+ x part) y-part size)
                (truncate 
                  (clamp
                    (/ 
                      (+ (vector-ref data (to-index x y size))
                         (vector-ref data (to-index x (+ y length) size))
                         (vector-ref data (to-index (+ x length) y size))
                         (vector-ref data (to-index (+ x length) (+ y length) size)))
                      4))))
              (inner (+ x length))))
          (outer (+ part (+ y length))
                 (+ y length))))))
  (define (square data bound length range)
    ;; quick patch for dominic to fix
    (when (not (integer? range))
      (set! range (flonum->fixnum (round (exact->inexact range)))))
    (let ((part (truncate (/ length 2))))
      (let (outer (y 0)
                  (y1 part))
        (when (<= y bound)
          (let (inner (x 0)
                      (x1 part))
            (when (<= x bound)
              (inner-square x1 y data bound part range)
              (inner-square x y1 data bound part range)
              (inner-square x1 (+ y1 part) data bound part range)
              (inner-square (+ x1 part) y1 data bound part range)
              (inner (+ x length)
                     (+ x1 length))))
          (outer (+ y length)
                 (+ y1 length))))))
  (define (inner-square x y data bound part range)
    ;; quick patch for dominic to fix
    (when (not (integer? range))
      (set! range (flonum->fixnum (round (exact->inexact range)))))
    (when (and (>= x 0)
               (>= y 0)
               (<= x bound)
               (<= y bound))
      (let (loop (count 0)
                 (total 0)
                 (points `((,(- x part) ,@y)
                           (,(+ x part) ,@y)
                           (,x ,@(- y part))
                           (,x ,@(+ y part)))))
        (if (null? points)
            (let ((index (to-index x y (+ bound 1))))
              (vector-set! data
                           index
                           (clamp
                             (+ (vector-ref data index)
                                (truncate (/ total count))
                                (- (random-integer range)
                                   (/ range 2))))))
          (let ((point (car points)))
            (if (and (>= (cdr point) 0)
                     (>= (car point) 0)
                     (<= (cdr point) bound)
                     (<= (car point) bound))
                (loop (+ count 1)
                      (+ (vector-ref data
                                     (to-index (car point)
                                               (cdr point)
                                               (+ bound 1))))
                      (cdr points))
              (loop count total (cdr points))))))))  
  (let ((size (+ (expt 2 power) 1)))
    (let ((dimension (* size size))
          (bound (- size 1)))
      (let ((data (make-vector dimension)))
        (vector-set! data (to-index 0 0 size) (random-bound))
        (vector-set! data (to-index bound 0 size) (random-bound))
        (vector-set! data (to-index 0 bound size) (random-bound))
        (vector-set! data (to-index bound bound size) (random-bound))
        (let (loop (length bound)
                   (range detail-level))
          (when (> length 0)
            (diamond data bound length range)
            (square data bound length range)
            (loop (truncate (/ length 2))
                  (clamp (/ range 2) min: 1 max: clamp-height))))
        data)))))
