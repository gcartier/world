;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Sections
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.section jazz


(import (world.index))


(proclaim (warn optimizations))


(definition protected section-size <fx>
  16)


(definition protected (make-section section-y)
  (let ((blocks (make-u8vector 4096))
        (data (make-u8vector 2048))
        (blocklight (make-u8vector 2048 0))
        (skylight (make-u8vector 2048 0)))
    (new World-Section #f section-y blocks data blocklight skylight)))


(class World-Section extends Object
  
  
  (slot index            <vector+>  initialize #f getter explicit)
  (slot refcount         <fx>       initialize 0  getter generate)
  (slot chunk                                     accessors generate)
  (slot y                                         accessors generate)
  (slot entities         <list>                   accessors generate)
  (slot blocks           <u8vector>               getter generate)
  (slot data             <u8vector>               getter generate)
  (slot blocklight       <u8vector>               getter generate)
  (slot skylight         <u8vector>               getter generate)
  (slot touched          <fx>       initialize 0  accessors generate)
  
  
  (method override (initialize chunk y blocks data blocklight skylight)
    (set! chunk~self chunk)
    (set! y~self y)
    (set! entities~self '())
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)
    (set! skylight~self skylight))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((index (get-index))
              (entities (length entities)))
          (format output "{a}, {a}, {a} with {a} entities" (index-x index) (index-y index) (index-z index) entities)))))
  
  
  ;; simplest for now to also have an index in section
  (method (get-index)
    (or index
        (assert chunk
          (let ((idx (with-index vector)))
            (set! index idx)
            idx))))
  
  
  (method (with-index proc)
    (let ((region (get-region~ chunk)))
      (let ((section-x (+ (* (get-x~ region) 32) (get-x~ chunk)))
            (section-y y)
            (section-z (+ (* (get-z~ region) 32) (get-z~ chunk))))
        (proc section-x section-y section-z))))
  
  
  (method (retain)
    (increase! refcount))
  
  
  (method (release)
    (decrease! refcount)
    (when (<= refcount 0)
      (free)))
  
  
  (method (free)
    ;(debug 'free self)
    (release~ chunk))))
