;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Sections
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.section jazz


(import (world.index)
        (world.retain))


(proclaim (warn optimizations))


(definition protected section-size <fx>
  16)


(definition protected (make-section section-y)
  (let ((blocks (make-u8vector 4096))
        (data (make-u8vector 2048))
        (blocklight (make-u8vector 2048 0))
        (skylight (make-u8vector 2048 0)))
    (new World-Section #f section-y blocks data blocklight skylight)))


(class World-Section extends Object
  
  
  (slot index            <index+>   initialize #f getter explicit)
  (slot refcount         <fx>       initialize 0  getter generate)
  (slot chunk                                     accessors generate)
  (slot y                                         accessors generate)
  (slot entities         <list>                   accessors generate)
  (slot blocks           <u8vector>               getter generate)
  (slot data             <u8vector>               getter generate)
  (slot blocklight       <u8vector>               getter generate)
  (slot skylight         <u8vector>               getter generate)
  (slot touched          <fx>       initialize 0  accessors generate)
  
  
  (method override (initialize chunk y blocks data blocklight skylight)
    (set! chunk~self chunk)
    (set! y~self y)
    (set! entities~self '())
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)
    (set! skylight~self skylight))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (when chunk
          (with-index
            (lambda (section-x section-y section-z)
              (format output "{a}, {a}, {a}{?: with {a} entities~}" section-x section-y section-z (not-null? entities) (length entities))))))))
  
  
  ;; for now quick hack around designer problems
  (method (add-entity entity)
    (unless (memq? entity entities)
      (set! entities (cons entity entities))))
  
  
  (method (remove-entity entity)
    (set! entities (remove! entity entities)))
  
  
  ;; simplest for now to also have an index in section
  (method (get-index)
    (or index
        (assert chunk
          (let ((idx (with-index indexed)))
            (set! index idx)
            idx))))
  
  
  (method (with-index proc)
    (let ((region (get-region~ chunk)))
      (let ((section-x (+ (* (get-x~ region) 32) (get-x~ chunk)))
            (section-y y)
            (section-z (+ (* (get-z~ region) 32) (get-z~ chunk))))
        (proc section-x section-y section-z))))
  
  
  (method (retain retainer)
    (when debug-retain?
      (when (= (find-refcount self) 0)
        (retain~ chunk self))
      (increase-refcount self)
      (add-retainer self retainer)))
  
  
  (method (transfer old-retainer new-retainer)
    (when debug-retain?
      (transfer-retainer self old-retainer new-retainer)))
  
  
  (method (release retainer)
    (when debug-retain?
      (decrease-refcount self)
      (remove-retainer self retainer)
      (when (<= (find-refcount self) 0)
        (free))))
  
  
  (method (free)
    (release~ chunk self))))
