;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Sections
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.section jazz


(import (jazz.component)
        (jazz.markup)
        (world)
        (world.index)
        (world.tag))


(proclaim (warn optimizations))


(definition protected section-size <fx>
  16)


(definition protected (make-section section-y)
  (let ((blocks (make-u8vector 4096))
        (data (make-u8vector 2048))
        (blocklight (make-u8vector 2048 0))
        (skylight (make-u8vector 2048 15))
        (elements #f))
    (let ((tags (list
                  (make-tag "Y" TAG_Byte section-y)
                  (make-tag "Blocks" TAG_Byte_Array blocks)
                  (make-tag "Data" TAG_Byte_Array data)
                  (make-tag "BlockLight" TAG_Byte_Array blocklight)
                  (make-tag "SkyLight" TAG_Byte_Array skylight))))
      (new World-Section #f tags section-y blocks data blocklight skylight elements))))


(class World-Section extends Object
  
  
  (slot index            <index+>   initialize #f getter explicit)
  (slot chunk                                     accessors generate)
  (slot tags                                      getter generate)
  (slot y                                         accessors generate)
  (slot blocks           <u8vector>               getter generate)
  (slot data             <u8vector>               getter generate)
  (slot blocklight       <u8vector>               getter generate)
  (slot skylight         <u8vector>               getter generate)
  (slot elements                                  getter generate)
  (slot elements-list               initialize #f getter generate)
  (slot elements-designer           initialize #f getter generate)
  (slot touched          <fx>       initialize 0  accessors generate)
  
  
  (method override (initialize self chunk tags y blocks data blocklight skylight elements)
    (set! self.chunk chunk)
    (set! self.tags tags)
    (set! self.y y)
    (set! self.blocks blocks)
    (set! self.data data)
    (set! self.blocklight blocklight)
    (set! self.skylight skylight)
    (set! self.elements elements))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (when chunk
          (with-index self
            (lambda (section-x section-y section-z)
              (format output "{a}, {a}, {a}" section-x section-y section-z)))))))
  
  
  ;; simplest for now to also have an index in section
  (method package (get-index self) <index>
    (or index
        (assert chunk
          (let ((idx (with-index self indexed)))
            (set! index idx)
            idx))))
  
  
  (method package (with-index self proc)
    (let ((region (get-region chunk)))
      (let ((section-x (+ (* (get-x region) 32) (get-x chunk)))
            (section-y (+ (* (get-y region) 32) y))
            (section-z (+ (* (get-z region) 32) (get-z chunk))))
        (proc section-x section-y section-z))))
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method package (cache-designer self)
    (or elements-designer
        (let ((units '(world.data)))
          (let ((tag '(<Section-Container>))
                (data (new Data zone-version 'jazz units #f)))
            (let ((form (construct-form tag (imports-locator units) data))
                  (container (new Section-Container)))
              (set-section container self)
              (let ((des (new Former form: form reference: container)))
                (set! elements-designer des)
                des))))))
  
  
  (method package (save-designer self)
    (when elements-designer
      (if (null? (get-children (get-form elements-designer)))
          (begin
            (tags-remove tags "Elements")
            (set! elements #f)
            (set! elements-designer #f))
        (let ((port (open-output-string)))
          ;; for now save as string
          (save-to-port elements-designer port)
          (let ((content (object->u8vector (get-output-string port))))
            (tags-add tags "Elements" TAG_Byte_Array content)
            (set! elements content))))))
  
  
  (method package (instantiate-elements self)
    (when (not elements-list)
      (if (not elements)
          (begin
            (set! elements-list '())
            (set! elements-designer #f))
        (let ((content (u8vector->object elements)))
          (call-with-input-string (list init: content readtable: jazz-readtable)
            (lambda (port)
              (let ((form (read-form-from port)))
                (let ((container (instantiate form)))
                  (set-section container self)
                  (set! elements-list (get-children container))
                  (set! elements-designer (new Former form: form reference: container)))))))
        (set! elements #f)))
    elements-list)
  
  
  (method package (add-element self obj)
    (if (not elements-list)
        (set! elements-list (list obj))
      (set! elements-list (append elements-list (list obj)))))
  
  
  (method package (remove-element self obj)
    (when elements-list
      (set! elements-list (remove obj elements-list)))))


;;;
;;;; Container
;;;


(class Section-Container extends Component
  
  
  (property version initialize #f accessors generate)
  
  
  (slot section initialize #f accessors generate)
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (with-index section
          (lambda (section-x section-y section-z)
            (format output "{a} {a} {a}" section-x section-y section-z))))))))
