;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Records
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.record jazz


(definition kind-sizes
  (list->table
    '((boolean  . 1)
      (u8       . 1)
      (u16      . 2)
      (u32      . 4)
      (u64      . 8)
      (double   . 8)
      (u8vector . 4))))


(class Record-Field extends Object
  
  
  (slot offset getter generate)
  (slot next  getter generate)
  
  
  (method override (initialize self offset next)
    (nextmethod self)
    (set! self.offset offset)
    (set! self.next next)))


(definition record-fields
  (make-table test: eq?))


(definition (field-next name)
  (let ((next (if (not name)
                  0
                (get-next (table-ref record-fields name)))))
    (if (symbol? next)
        (field-next next)
      next)))


(macro public (fieldoffset name)
  (get-offset (table-ref record-fields name)))

(macro public (fieldnext name)
  (field-next name))


(macro public (define-field name previous kind (type #f))
  (let ((offset (field-next previous))
        (size (table-ref kind-sizes kind))
        (type (if type (list type) '()))
        (read (string->symbol (string-append "read-udp-" (symbol->string name))))
        (write (string->symbol (string-append "write-udp-" (symbol->string name))))
        (scan (string->symbol (string-append "scan-" (symbol->string kind))))
        (put (string->symbol (string-append "put-" (symbol->string kind)))))
    (table-set! record-fields name (new Record-Field offset (+ offset size)))
    (let ((x
            `(begin
               (definition public (,read data) ,@type
                           (,scan data ,offset))
               
               (definition public (,write data value)
                 (,put data ,offset value))))) (pp x) x)))


(macro public (define-record name . fields)
  (define (parse)
    (if (and (pair? fields) (symbol? (car fields)))
        (values (car fields) (cdr fields))
      (values #f fields)))
  
  (receive (ascendant fields) (parse)
    (let ((previous ascendant))
      (table-set! record-fields name (let ((offset (if (not ascendant)
                                                       0
                                                     (field-next ascendant)))
                                           (next (if (null? fields)
                                                     (if (not ascendant)
                                                         0
                                                       ascendant)
                                                   (car (last fields)))))
                                       (new Record-Field offset next)))
      (let ((x
      `(begin
         ,@(map (lambda (field)
                  (bind (name kind . rest) field
                    (bind-optionals ((type #f)) rest
                      (prog1 `(define-field ,name ,previous ,kind ,type)
                        (set! previous name)))))
                fields)))) (pp x) x)))))
