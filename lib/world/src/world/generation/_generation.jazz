;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Generation
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Edouard Hebert


(module world.generation jazz


(import (jazz.geometry)
        (jazz.io)
        (jazz.json)
        (jazz.opengl.render)
        (gaea.geometry)
        (gaea.homogeneous)
        (gaea.plane)
        (world)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.chunk)
        (world.context)
        (world.generate)
        (world.generation.base)
        (world.generation.block)
        (world.generation.categories)
        (world.generation.rendering)
        (world.index)
        (world.mesh)
        (world.model)
        (world.polygon)
        (world.quad)
        (world.region)
        (world.render)
        (world.section)
        (world.sector)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.template)
        (world.texture)
        (world.triangle))


;; LEXICON
;; - index: section-local i j k coordinates
;; - location: integer vector representing a block in the block entities format
;; - position: block center position


;; WARNING
;; - the temporary hack of duplicating non thread-safe geometry functions
;;   like horizon-lookat&^ is super dangerous and should be improved upon


(proclaim (not check bounds types)
          (warn optimizations))


(definition protected aa 0) ;; 10421010
(definition protected oo 0) ;; 12248627
(definition protected gg 0) ;; 745240
(definition protected ww 0) ;; 697473
(definition protected cc 0) ;; 54050


(definition protected (block-texture-coordinates block <Block>) <f32vector>
  (or (get-texture-coordinates block)
      (let ((texture (or (get-texture block) "unknown")))
        (let ((coords (image-rect (cache-atlas) texture)))
          (set-texture-coordinates block coords)
          coords))))


(definition coordinates-mutex
  (make-mutex 'coordinates))

(definition coordinates <table>
  (make-table test: equal?))

(definition protected (cache-coordinates name <string>) <f32vector>
  (mutex-lock! coordinates-mutex)
  (prog1 (or (table-ref coordinates name #f)
             (let ((coords (if (window?) (image-rect (cache-atlas) name) dummy-uv)))
               (table-set! coordinates name coords)
               coords))
    (mutex-unlock! coordinates-mutex)))


(definition dummy-rendering <Rendering>
  (make-rendering 0 'dummy #f #f #f #f))


(definition public (liquid-filter poly <Polygon>) <bool>
  (not (get-liquid-cube? (id->block (decode-id (get-data1 poly))))))


(definition public (only-water-filter poly <Polygon>) <bool>
  (memq? (get-id (id->block (decode-id (get-data1 poly)))) '(8 9)))


;;;
;;;; Generate
;;;


(definition protected generate-mutex
  (make-mutex 'generate))


(definition protected (with-generate-mutex thunk)
  (unwind-protect
      (begin
        (mutex-lock! generate-mutex)
        (thunk))
    (mutex-unlock! generate-mutex)))


;;;
;;;; Neighbor
;;;


;; put back inline when light propagation bug fixed
(definition protected (neighbor-section-index a <fx> b <fx> c <fx>) <fx+>
  ;; hack around light propagation bug
  (if (and (>= a -1) (<= a 1)
           (>= b -1) (<= b 1)
           (>= c -1) (<= c 1))
      (+ (* b 9) (* c 3) a 13)
    #f
    ;; hack so return value is not tested for being a fixnum
    @debug-light-propagation-bug
    (cast <fx> (error "Section index out of bounds: {a} {a} {a}" a b c))))


(definition protected (neighbor-sections section <World-Section> section-x <fx> section-y <fx> section-z <fx>) <vector>
  (let ((zone (current-zone)))
    (let ((sections (make-vector 27 #f)))
      (loop (for a from -1 to 1)
            (loop (for b from -1 to 1)
                  (loop (for c from -1 to 1)
                        (let ((index (allege (neighbor-section-index a b c))))
                          (if (and (= a 0)
                                   (= b 0)
                                   (= c 0))
                              (vector-set! sections index section)
                            (let ((x (+ section-x a))
                                  (y (+ section-y b))
                                  (z (+ section-z c)))
                              (vector-set! sections index (index-section zone (indexed x y z)))))))))
      sections)))


;;;
;;;; Visual
;;;


;; we need to go two in every direction instead of just one
;; because of door tops that are rendered by door bottom blocks
(definition protected block-cache-size <fx>
  (* 20 20 20 4))

(definition protected (initialize-block-cache block-cache <u16vector> cache-uninitialized <fx>) <u16vector>
  (loop (for i from 0 below block-cache-size)
        (u16vector-set! block-cache i cache-uninitialized))
  block-cache)


(definition protected block-cache <u16vector>
  (make-u16vector block-cache-size))


(definition protected ambient-occlusion <fl>
  (->flonum (world-setting 'world.ambient-occlusion .65)))

(definition protected ambient-passthrough <fl>
  (- 1. ambient-occlusion))


(definition protected (instantiate-visual sector <Sector>)
  (let ((zone (current-zone)))
    (define (generate-done)
      (set-visual-uptodate? sector #t)
      (set-visual-revision sector (get-revision (get-generator zone)))
      (set-visual-generating? sector #f)
      (decrease-sectors-generating zone 1)
      (increase-sectors-generated zone))
    
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((sector-index (get-index sector)))
      (let ((sector-x (index-x sector-index))
            (sector-y (index-y sector-index))
            (sector-z (index-z sector-index)))
        (let ((section (index-section zone (indexed& sector-x sector-y sector-z))))
          (if (not section)
              (begin
                (free sector)
                (generate-done))
            (let ((truncate-y (get-truncate-y zone))
                  (cache-uninitialized <fx> 65535)
                  (sections <vector> (neighbor-sections section sector-x sector-y sector-z)))
              (with-generate-mutex
                (lambda ()
                  (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y 0))))
                        (cache <u16vector> (initialize-block-cache block-cache cache-uninitialized))
                        (blocks <u8vector> (get-blocks section))
                        (data <u8vector> (get-data section))
                        (blocklight <u8vector> (get-blocklight section))
                        (skylight <u8vector> (get-skylight section))
                        (opaque-rendering <Rendering> (opaque-rendering))
                        (transparent-rendering <Rendering> (transparent-rendering))
                        (coverage-rendering <Rendering> (coverage-rendering))
                        (water-rendering <Rendering> (water-rendering))
                        (wet-rendering <Rendering> (wet-rendering))
                        (multitexture-rendering <Rendering> (multitexture-rendering))
                        (redstone-rendering <Rendering> (redstone-rendering))
                        (texture-elements '()))
                    (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                      (let ((index (neighbor-section-index a b c)))
                        (and index (vector-ref sections index))))
                    
                    (define (local-index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (effective-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* j 400) (* k 20) i 842) 4))
                    
                    (define (blocks-get section <World-Section>) <u8vector>
                      (get-blocks section))
                    
                    (define (data-get section <World-Section>) <u8vector>
                      (get-data section))
                    
                    (define (blocklight-get section <World-Section>) <u8vector>
                      (get-blocklight section))
                    
                    (define (skylight-get section <World-Section>) <u8vector>
                      (get-skylight section))
                    
                    (define (local-block-ref i <fx> j <fx> k <fx>) <fx>
                      (u8vector-ref blocks (local-index i j k)))
                    
                    (define (local-data-ref i <fx> j <fx> k <fx>) <fx>
                      (u4vector-ref data (local-index i j k)))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (effective-data-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k data-get u4vector-ref 0 0))
                    
                    (define (effective-light-ref! i <fx> j <fx> k <fx> lighting <f32vector>) <void>
                      (let ((id (effective-block-ref i j k)))
                        (unless (get-opaque? (id->block id))
                          (let ((index (effective-index i j k)))
                            (let ((value (u16vector-ref cache (+ index 1))))
                              (if (/= value cache-uninitialized)
                                  (begin
                                    (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> value)))
                                    (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> (u16vector-ref cache (+ index 2))))))
                                (let ((blocklight (field-ref i j k blocklight-get u4vector-ref 0 0))
                                      (skylight (field-ref i j k skylight-get u4vector-ref 15 15)))
                                  (u16vector-set! cache (+ index 1) blocklight)
                                  (u16vector-set! cache (+ index 2) skylight)
                                  (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> blocklight)))
                                  (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> skylight)))))))
                          (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))))
                    
                    (define (effective-opaque-ref! i <fx> j <fx> k <fx> lighting <f32vector> average-blocklight <fl> average-skylight <fl>) <void>
                      (let ((id (effective-block-ref i j k)))
                        (let ((block (id->block id)))
                          (when (get-opaque? block)
                            (let ((occlusion (get-occlusion block)))
                              (let ((passthrough (- 1. (* ambient-occlusion occlusion))))
                                (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (* average-blocklight passthrough)))
                                (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (* average-skylight passthrough)))))))))
                    
                    @todo!?
                    (define (inner-light-ref! i <fx> j <fx> k <fx> lighting <f32vector>) <void>
                      (let ((id (effective-block-ref i j k)))
                        (unless (get-opaque? (id->block id))
                          (let ((index (effective-index i j k)))
                            (let ((value (u16vector-ref cache (+ index 1))))
                              (if (/= value cache-uninitialized)
                                  (begin
                                    (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> value)))
                                    (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> (u16vector-ref cache (+ index 2)))))
                                    (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> (u16vector-ref cache (+ index 3)))))
                                    (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 2221.)))
                                (let ((local-index (local-index i j k)))
                                  (let ((blocklight (u4vector-ref blocklight local-index))
                                        (skylight (u4vector-ref skylight local-index))
                                        (ambience (if (= (u8vector-ref blocks local-index) air-id) 1 0)))
                                    (u16vector-set! cache (+ index 1) blocklight)
                                    (u16vector-set! cache (+ index 2) skylight)
                                    (u16vector-set! cache (+ index 3) ambience)
                                    (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> blocklight)))
                                    (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> skylight)))
                                    (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> ambience)))
                                    (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 2221.))))))))))
                    
                    (define (u4vector-ref field <u8vector> index <fx>) <fx>
                      (let ((byte (u8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (local-index i j k)))))))
                          
                          (cond ((< k 0) (bind-k (quotient/ k 16) (modulo k 16)))
                                ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j (quotient/ j 16) (modulo j 16)))
                              ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i (quotient/ i 16) (modulo i 16)))
                            ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                            (else (bind-i 0 i))))
                    
                    (define (add-template i j k x y z template <Lighted-Template> depth-offset <fx+> rendering <Rendering> category)
                      (let ((mesher <Lighted-Mesher> (get-mesher rendering))
                            (l1 (static (f32vector 0. 0. 0. 0.)))
                            (l2 (static (f32vector 0. 0. 0. 0.)))
                            (l3 (static (f32vector 0. 0. 0. 0.)))
                            (l4 (static (f32vector 0. 0. 0. 0.))))
                        (let ((inverse? (setup-lighting template i j k compute-lighting l1 l2 l3 l4)))
                          (add-template-face mesher x y z template depth-offset inverse?)
                          (add-template-lighting mesher template l1 l2 l3 l4 inverse?))
                        (when (and mesh-categories? (eq? category redstone))
                          (let ((mesher <Lighted-Mesher> (get-mesher redstone-rendering)))
                            (let ((inverse? (setup-lighting template i j k full-lighting l1 l2 l3 l4)))
                              (add-template-face mesher x y z template depth-offset inverse?)
                              (add-template-lighting mesher template l1 l2 l3 l4 inverse?))))))
                    
                    (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering <Rendering> category block-id <fx> add-template)
                      (let ((data-id (local-data-ref i j k)))
                        (let ((templates (find-visual-templates block-id data-id 0 #f)))
                          (let ((rendering (effective-rendering (effective-block-ref (- i 1) j k) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 0) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref (+ i 1) j k) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 1) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref i (- j 1) k) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 2) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref i (+ j 1) k) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 3) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref i j (- k 1)) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 4) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref i j (+ k 1)) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 5) #f rendering category))))))
                    
                    (define (add-inner-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering <Rendering> category block-id <fx> add-template)
                      (let ((index (local-index i j k)))
                        (let ((data-id (u4vector-ref data index)))
                          (let ((templates (find-visual-templates block-id data-id 0 #f)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (- index   1)) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 0) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (+ index   1)) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 1) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (- index 256)) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 2) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (+ index 256)) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 3) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (- index  16)) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 4) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (+ index  16)) rendering))) (when rendering (add-template i j k x y z (vector-ref templates 5) #f rendering category)))))))
                    
                    (define (effective-rendering neighbor-id <fx> rendering <Rendering>)
                      (let ((neighbor (id->block neighbor-id)))
                        (cond ((get-opaque-cube? neighbor)
                               #f)
                              ((get-liquid-cube? neighbor)
                               wet-rendering)
                              (else
                               rendering))))
                    
                    (define (add-translucent-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering category block-id <fx> add-template)
                      (let ((data-id (local-data-ref i j k)))
                        (let ((templates (find-visual-templates block-id data-id 0 #f)))
                          (unless (translucent-translucent? block-id (effective-block-ref (- i 1) j k)) (add-template i j k x y z (vector-ref templates 0) #f rendering category))
                          (unless (translucent-opaque?      block-id (effective-block-ref (+ i 1) j k)) (add-template i j k x y z (vector-ref templates 1) #f rendering category))
                          (unless (translucent-translucent? block-id (effective-block-ref i (- j 1) k)) (add-template i j k x y z (vector-ref templates 2) #f rendering category))
                          (unless (translucent-opaque?      block-id (effective-block-ref i (+ j 1) k)) (add-template i j k x y z (vector-ref templates 3) #f rendering category))
                          (unless (translucent-translucent? block-id (effective-block-ref i j (- k 1))) (add-template i j k x y z (vector-ref templates 4) #f rendering category))
                          (unless (translucent-opaque?      block-id (effective-block-ref i j (+ k 1))) (add-template i j k x y z (vector-ref templates 5) #f rendering category)))))
                    
                    (define (add-inner-translucent-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering category block-id <fx> add-template)
                      (let ((index (local-index i j k)))
                        (let ((data-id (u4vector-ref data index)))
                          (let ((templates (find-visual-templates block-id data-id 0 #f)))
                            (unless (translucent-translucent? block-id (u8vector-ref blocks (- index   1))) (add-template i j k x y z (vector-ref templates 0) #f rendering category))
                            (unless (translucent-opaque?      block-id (u8vector-ref blocks (+ index   1))) (add-template i j k x y z (vector-ref templates 1) #f rendering category))
                            (unless (translucent-translucent? block-id (u8vector-ref blocks (- index 256))) (add-template i j k x y z (vector-ref templates 2) #f rendering category))
                            (unless (translucent-opaque?      block-id (u8vector-ref blocks (+ index 256))) (add-template i j k x y z (vector-ref templates 3) #f rendering category))
                            (unless (translucent-translucent? block-id (u8vector-ref blocks (- index  16))) (add-template i j k x y z (vector-ref templates 4) #f rendering category))
                            (unless (translucent-opaque?      block-id (u8vector-ref blocks (+ index  16))) (add-template i j k x y z (vector-ref templates 5) #f rendering category))))))
                    
                    (define (translucent-opaque? block-id <fx> neighbor-id <fx>)
                      (or (= block-id neighbor-id)
                          (get-opaque-cube? (id->block neighbor-id))))
                    
                    (define (translucent-translucent? block-id <fx> neighbor-id <fx>)
                      (get-opaque-cube? (id->block neighbor-id)))
                    
                    (define (add-liquid-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering category templates <vector> add-template)
                      (unless (liquid-opaque? (effective-block-ref (- i 1) j k)) (add-template i j k x y z (vector-ref templates 0) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref (+ i 1) j k)) (add-template i j k x y z (vector-ref templates 1) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref i (- j 1) k)) (add-template i j k x y z (vector-ref templates 2) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref i (+ j 1) k)) (add-template i j k x y z (vector-ref templates 3) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref i j (- k 1))) (add-template i j k x y z (vector-ref templates 4) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref i j (+ k 1))) (add-template i j k x y z (vector-ref templates 5) #f rendering category)))
                    
                    (define (add-inner-liquid-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering category templates <vector> add-template)
                      (let ((index (local-index i j k)))
                        (unless (liquid-opaque? (u8vector-ref blocks (- index   1))) (add-template i j k x y z (vector-ref templates 0) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (+ index   1))) (add-template i j k x y z (vector-ref templates 1) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (- index 256))) (add-template i j k x y z (vector-ref templates 2) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (+ index 256))) (add-template i j k x y z (vector-ref templates 3) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (- index  16))) (add-template i j k x y z (vector-ref templates 4) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (+ index  16))) (add-template i j k x y z (vector-ref templates 5) #f rendering category))))
                    
                    (define (liquid-opaque? neighbor-id <fx>)
                      (let ((neighbor (id->block neighbor-id)))
                        (or (get-liquid-cube? neighbor)
                            (get-opaque-cube? neighbor))))
                    
                    (define (compute-lighting lighting <f32vector> i <fx> j <fx> k <fx> t <Light-Template>)
                      (let ((shade (get-shade t))
                            (s1 (get-s1 t))
                            (s2 (get-s2 t))
                            (s3 (get-s3 t))
                            (s4 (get-s4 t)))
                        (f32vector-set! lighting 0 0.)
                        (f32vector-set! lighting 1 0.)
                        (f32vector-set! lighting 2 shade)
                        (f32vector-set! lighting 3 0.)
                        (effective-light-ref! (+ i (s8vector-ref s1 0)) (+ j (s8vector-ref s1 1)) (+ k (s8vector-ref s1 2)) lighting)
                        (effective-light-ref! (+ i (s8vector-ref s2 0)) (+ j (s8vector-ref s2 1)) (+ k (s8vector-ref s2 2)) lighting)
                        (effective-light-ref! (+ i (s8vector-ref s3 0)) (+ j (s8vector-ref s3 1)) (+ k (s8vector-ref s3 2)) lighting)
                        (effective-light-ref! (+ i (s8vector-ref s4 0)) (+ j (s8vector-ref s4 1)) (+ k (s8vector-ref s4 2)) lighting)
                        (let ((count (f32vector-ref lighting 3)))
                          (when (< count 4.)
                            (let ((total-blocklight (f32vector-ref lighting 0))
                                  (total-skylight (f32vector-ref lighting 1)))
                              (let ((average-blocklight (/ total-blocklight count))
                                    (average-skylight (/ total-skylight count)))
                                (effective-opaque-ref! (+ i (s8vector-ref s1 0)) (+ j (s8vector-ref s1 1)) (+ k (s8vector-ref s1 2)) lighting average-blocklight average-skylight)
                                (effective-opaque-ref! (+ i (s8vector-ref s2 0)) (+ j (s8vector-ref s2 1)) (+ k (s8vector-ref s2 2)) lighting average-blocklight average-skylight)
                                (effective-opaque-ref! (+ i (s8vector-ref s3 0)) (+ j (s8vector-ref s3 1)) (+ k (s8vector-ref s3 2)) lighting average-blocklight average-skylight)
                                (effective-opaque-ref! (+ i (s8vector-ref s4 0)) (+ j (s8vector-ref s4 1)) (+ k (s8vector-ref s4 2)) lighting average-blocklight average-skylight)))))
                        lighting))
                    
                    (define (full-lighting lighting <f32vector> i <fx> j <fx> k <fx> t <Light-Template>)
                      (f32vector-set! lighting 0 60.)
                      (f32vector-set! lighting 1 60.)
                      (f32vector-set! lighting 2 1.))
                    
                    (define (add-texture-element proc)
                      (proc section texture-element-adder))
                    
                    (define (texture-element-adder element)
                      (set! texture-elements (cons element texture-elements)))
                    
                    (reset-mesher opaque-rendering)
                    (reset-mesher transparent-rendering)
                    (reset-mesher coverage-rendering)
                    (reset-mesher water-rendering)
                    (reset-mesher wet-rendering)
                    (reset-mesher multitexture-rendering)
                    (when mesh-categories?
                      (reset-mesher redstone-rendering))
                    
                    ;; inner
                    (loop (for j from 1 below 15)
                          (loop (for k from 1 below 15)
                                (loop (for i from 1 below 15)
                                      (let ((block-id (local-block-ref i j k))
                                            (data-id (local-data-ref i j k)))
                                        (when (/= block-id air-id)
                                          (let ((block (id/data-id->block block-id data-id)))
                                            (let ((x (fl& (+ block-radius (cast <fl> i))))
                                                  (y (fl& (+ block-radius (cast <fl> j))))
                                                  (z (fl& (+ block-radius (cast <fl> k))))
                                                  (rendering <Rendering> (cache-rendering block))
                                                  (category (get-category block)))
                                              (let ((visual (get-visual block)))
                                                (cond (visual
                                                       (visual block-id data-id i j k x y z rendering category add-template add-inner-opaque-cube add-inner-translucent-cube add-inner-liquid-cube add-texture-element effective-block-ref effective-data-ref))
                                                      ((get-opaque-cube? block)
                                                       (add-inner-opaque-cube i j k x y z rendering category block-id add-template))
                                                      ((get-translucent-cube? block)
                                                       (add-inner-translucent-cube i j k x y z rendering category block-id add-template))
                                                      (else
                                                       (add-visual-template block-id data-id 0 i j k x y z #f rendering category add-template effective-block-ref effective-data-ref)))))))))))
                    
                    ;; outer
                    (let ()
                      (define (add i <fx> j <fx> k <fx>)
                        (let ((block-id (local-block-ref i j k))
                              (data-id (local-data-ref i j k)))
                          (when (/= block-id air-id)
                            (let ((block (id/data-id->block block-id data-id)))
                              (let ((x (fl& (+ block-radius (cast <fl> i))))
                                    (y (fl& (+ block-radius (cast <fl> j))))
                                    (z (fl& (+ block-radius (cast <fl> k))))
                                    (rendering <Rendering> (cache-rendering block))
                                    (category (get-category block)))
                                (let ((visual (get-visual block)))
                                  (cond (visual
                                         (visual block-id data-id i j k x y z rendering category add-template add-opaque-cube add-translucent-cube add-liquid-cube add-texture-element effective-block-ref effective-data-ref))
                                        ((get-opaque-cube? block)
                                         (add-opaque-cube i j k x y z rendering category block-id add-template))
                                        ((get-translucent-cube? block)
                                         (add-translucent-cube i j k x y z rendering category block-id add-template))
                                        (else
                                         (add-visual-template block-id data-id 0 i j k x y z #f rendering category add-template effective-block-ref effective-data-ref)))))))))
                      
                      ;; left
                      (let ((i 0))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; right
                      (let ((i 15))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; bottom
                      (let ((j 0))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; top
                      (let ((j 15))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; back
                      (let ((k 0))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k))))
                      ;; front
                      (let ((k 15))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k)))))
                    
                    (with-render-mutex
                      (lambda ()
                        (define (prepare-mesh)
                          (let ((mesher (get-mesher opaque-rendering)))
                            (let ((triangles (get-used mesher)))
                              (when (> triangles 0)
                                (setup-mesh sector)
                                (let ((mesh (get-mesh sector)))
                                  (allege mesh
                                    (fill-vertices/neighbors sector mesh triangles (get-content mesher) (get-neighbors mesher))
                                    (fill-lightmap sector mesh triangles (get-lightmap mesher))
                                    (setup-feedback sector mesh triangles)
                                    (setup-array mesh)))))))
                        
                        (define (prepare-other-meshes)
                          (let ((renderings (other-renderings))
                                (count 0))
                            (define (increase-count rendering <Rendering>)
                              (when (> (get-used (get-mesher rendering)) 0)
                                (increase! count)))
                            
                            (for-each increase-count renderings)
                            (when (> count 0)
                              (let ((meshes (make-vector count))
                                    (rank 0))
                                (loop (for rendering <Rendering> in renderings)
                                      (let ((material (get-material rendering))
                                            (mesher (get-mesher rendering)))
                                        (let ((triangles (get-used mesher)))
                                          (when (> (get-used mesher) 0)
                                            (let ((mesh (new Mesh material: material)))
                                              (vector-set! meshes rank mesh)
                                              (fill-vertices/neighbors sector mesh triangles (get-content mesher) (get-neighbors mesher))
                                              (fill-lightmap sector mesh triangles (get-lightmap mesher))
                                              (setup-array mesh)
                                              (increase! rank))))))
                                (setup-other-meshes sector meshes)))))
                        
                        (define (prepare-redstone-mesh)
                          (let ((material (get-material redstone-rendering))
                                (mesher (get-mesher redstone-rendering)))
                            (let ((triangles (get-used mesher)))
                              (when (> triangles 0)
                                (let ((mesh (new Mesh material: material)))
                                  (setup-categorized-mesh sector mesh)
                                  (fill-vertices/neighbors sector mesh triangles (get-content mesher) (get-neighbors mesher))
                                  (fill-lightmap sector mesh triangles (get-lightmap mesher))
                                  (setup-array mesh))))))
                        
                        (when (eq? zone (current-zone))
                          (free-mesh sector)
                          (prepare-mesh)
                          (prepare-other-meshes)
                          (when mesh-categories?
                            (prepare-redstone-mesh))
                          (set-texture-elements sector texture-elements)
                          (generate-done))))))))))))))


(class Light-Template extends Object
  
  
  (slot shade <fl>       getter generate)
  (slot s1    <s8vector> getter generate)
  (slot s2    <s8vector> getter generate)
  (slot s3    <s8vector> getter generate)
  (slot s4    <s8vector> getter generate)
  
  
  (method override (initialize self shade <fl> s1 s2 s3 s4)
    (set! self.shade shade)
    (set! self.s1 s1)
    (set! self.s2 s2)
    (set! self.s3 s3)
    (set! self.s4 s4)))


(definition (allocate-light-template shade s1 s2 s3 s4)
  (allocate Light-Template shade s1 s2 s3 s4))


(class Lighted-Template extends Face-Template
  
  
  (method package virtual (setup-lighting self l1 l2 l3 l4)
    )
  
  
  (method package virtual (iterate-lighting self mesher l1 l2 l3 l4 inverse? proc)
    ))


(class Triangle-Template extends Lighted-Template
  
  
  (slot t1 getter generate)
  (slot t2 getter generate)
  (slot t3 getter generate)
  
  
  (method override (initialize self texture-coordinates <f32vector> texture-depth triangle <Triangle> t1 t2 t3)
    (nextmethod self texture-coordinates texture-depth triangle)
    (set! self.t1 t1)
    (set! self.t2 t2)
    (set! self.t3 t3))
  
  
  (method override (setup-lighting self i j k compute-lighting l1 <f32vector> l2 <f32vector> l3 <f32vector> l4 <f32vector>)
    (compute-lighting l1 i j k t1)
    (compute-lighting l2 i j k t2)
    (compute-lighting l3 i j k t3)
    #f)
  
  
  (method override (iterate-lighting self mesher l1 l2 l3 l4 inverse? proc)
    (proc mesher l1 l2 l3)))


(class Quad-Template extends Lighted-Template
  
  
  (slot t1 getter generate)
  (slot t2 getter generate)
  (slot t3 getter generate)
  (slot t4 getter generate)
  
  
  (method override (initialize self texture-coordinates <f32vector> texture-depth quad <Quad> t1 t2 t3 t4)
    (nextmethod self texture-coordinates texture-depth quad)
    (set! self.t1 t1)
    (set! self.t2 t2)
    (set! self.t3 t3)
    (set! self.t4 t4))
  
  
  (method override (setup-lighting self i j k compute-lighting l1 <f32vector> l2 <f32vector> l3 <f32vector> l4 <f32vector>)
    (compute-lighting l1 i j k t1)
    (compute-lighting l2 i j k t2)
    (compute-lighting l3 i j k t3)
    (compute-lighting l4 i j k t4)
    ;; inversing the quad solves lighting anisotropy
    (let ((a00 (max (f32vector-ref l1 0) (f32vector-ref l1 1)))
          (a01 (max (f32vector-ref l2 0) (f32vector-ref l2 1)))
          (a11 (max (f32vector-ref l3 0) (f32vector-ref l3 1)))
          (a10 (max (f32vector-ref l4 0) (f32vector-ref l4 1))))
      (< (+ a00 a11) (+ a01 a10))))
  
  
  (method override (iterate-lighting self mesher l1 l2 l3 l4 inverse? proc)
    (cond ((not inverse?)
           (proc mesher l1 l2 l3)
           (proc mesher l3 l4 l1))
          (else
           (proc mesher l4 l1 l2)
           (proc mesher l2 l3 l4)))))


(definition protected (dynamic-visual-template block <Block> data-id <fx> i <fx> j <fx> k <fx> block-ref data-ref proc)
  (let ((block-id (get-id block))
        (variant-id (or (get-variant-id block) -1))
        (category (get-category block))
        (uv (block-texture-coordinates block))
        (generate (get-generate block))
        (rendering <Rendering> (cache-rendering block))
        (transparent-rendering (transparent-rendering)))
    (define (add-face template <Face-Template> rendering <Rendering> category)
      (proc template))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      (allocate-light-template shade
                               (s8vector ax ay az)
                               (s8vector bx by bz)
                               (s8vector cx cy cz)
                               (s8vector dx dy dz)))
    
    (generate 'visual block-id variant-id data-id -1 i j k 0. 0. 0. uv lighting rendering category add-face #f block-ref data-ref)))


(definition protected (create-visual-templates block <Block> data-id <fx> config-id <fx> generate)
  (let ((templates (new-queue))
        (block-id (get-id block))
        (variant-id (or (get-variant-id block) -1))
        (category (get-category block))
        (uv <f32vector> (block-texture-coordinates block))
        (generate (or generate (get-generate block)))
        (rendering <Rendering> (cache-rendering block))
        (transparent-rendering (transparent-rendering)))
    (define (block-ref i <fx> j <fx> k <fx>) <fx>
      air-id)
    
    (define (data-ref i <fx> j <fx> k <fx>) <fx>
      0)
    
    (define (add-face template <Face-Template> rendering <Rendering> category)
      (enqueue templates template))
    
    (define (add-cube what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id variant-id add-face)
      (add-face (left-side   what i j k x y z left-uv lighting rendering block-id variant-id) rendering category)
      (add-face (right-side  what i j k x y z right-uv lighting rendering block-id variant-id) rendering category)
      (add-face (bottom-side what i j k x y z bottom-uv lighting rendering block-id variant-id) rendering category)
      (add-face (top-side    what i j k x y z top-uv lighting rendering block-id variant-id) rendering category)
      (add-face (back-side   what i j k x y z back-uv lighting rendering block-id variant-id) rendering category)
      (add-face (front-side  what i j k x y z front-uv lighting rendering block-id variant-id) rendering category))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      (allocate-light-template shade
                               (s8vector ax ay az)
                               (s8vector bx by bz)
                               (s8vector cx cy cz)
                               (s8vector dx dy dz)))
    
    (cond (generate
           (generate 'visual block-id variant-id data-id config-id 0 0 0 0. 0. 0. uv lighting rendering category add-face add-cube block-ref data-ref))
          ((or (get-opaque-cube? block)
               (get-translucent-cube? block))
           (add-cube 'visual 0 0 0 0. 0. 0. uv uv uv uv uv uv lighting rendering category block-id variant-id add-face))
          (else
           (add-cross-faces 'visual 0 0 0 0. 0. 0. uv lighting transparent-rendering category block-id variant-id add-face)))
    (list->vector (queue-list templates))))


(definition protected (find-visual-templates block-id <fx> data-id <fx> config-id <fx> generate) <vector>
  (let ((block (id/data-id->block block-id data-id)))
    (let ((visuals (get-visuals block)))
      (if (not visuals)
          (let ((templates (create-visual-templates block data-id config-id generate))
                (visuals (make-vector (get-configurations block) #f)))
            (vector-set! visuals config-id templates)
            (set-visuals block visuals)
            templates)
        (or (vector-ref visuals config-id)
            (let ((templates (create-visual-templates block data-id config-id generate)))
              (vector-set! visuals config-id templates)
              templates))))))


(definition protected (add-visual-template block-id <fx> data-id <fx> config-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> depth-offset <fx+> rendering category add-template block-ref data-ref)
  ;; quick hack
  @PERFREG
  (when (id? block-id 155 247)
    (set! block-id 153))
  (let ((templates (find-visual-templates block-id data-id config-id #f)))
    (loop (for template in-vector templates)
          (add-template i j k x y z template depth-offset rendering category))))


(definition protected (add-data-visual block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering category add-template add-opaque-cube add-translucent-cube add-liquid-cube add-texture-element block-ref data-ref)
  (add-visual-template block-id data-id data-id i j k x y z #f rendering category add-template block-ref data-ref))


;;;
;;;; Physical
;;;


(definition protected (instantiate-physical area <Area> revision-update?)
  (let ((zone (current-zone)))
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((area-index (get-index area)))
      (let ((area-x (index-x area-index))
            (area-y (index-y area-index))
            (area-z (index-z area-index)))
        (let ((section (index-section zone (indexed& area-x area-y area-z))))
          (set-section area section)
          (if (not section)
              (when revision-update?
                (clear-polygons area))
            (let ((region (get-region (cast <World-Chunk> (get-chunk section))))
                  (chunk-x (section->chunk area-x))
                  (chunk-z (section->chunk area-z))
                  (truncate-y (get-truncate-y zone))
                  (cache-uninitialized <fx> 65535)
                  (sections (neighbor-sections section area-x area-y area-z)))
              (with-generate-mutex
                (lambda ()
                  (let ((bottom-section? (= area-y (cast <fx> (or truncate-y 0))))
                        (section-x (+ (* (get-x region) 32 16) (* chunk-x 16)))
                        (section-y (* area-y 16))
                        (section-z (+ (* (get-z region) 32 16) (* chunk-z 16)))
                        (cache <u16vector> (initialize-block-cache block-cache cache-uninitialized))
                        (blocks <u8vector> (get-blocks section))
                        (data <u8vector> (get-data section))
                        (areas (make-table test: equal?))
                        (area-position (get-position& area)))
                    (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                      (let ((index (neighbor-section-index a b c)))
                        (and index (vector-ref sections index))))
                    
                    (define (local-index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (effective-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* j 400) (* k 20) i 842) 4))
                    
                    (define (blocks-get section <World-Section>) <u8vector>
                      (get-blocks section))
                    
                    (define (data-get section <World-Section>) <u8vector>
                      (get-data section))
                    
                    (define (local-block-ref i <fx> j <fx> k <fx>) <fx>
                      (u8vector-ref blocks (local-index i j k)))
                    
                    (define (local-data-ref i <fx> j <fx> k <fx>) <fx>
                      (u4vector-ref data (local-index i j k)))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (effective-data-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k data-get u4vector-ref 0 0))
                    
                    (define (u4vector-ref field <u8vector> index <fx>) <fx>
                      (let ((byte (u8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (local-index i j k)))))))
                          
                          (cond ((< k 0) (bind-k (quotient/ k 16) (modulo k 16)))
                                ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j (quotient/ j 16) (modulo j 16)))
                              ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i (quotient/ i 16) (modulo i 16)))
                            ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                            (else (bind-i 0 i))))
                    
                    (define (add-template x <fl> y <fl> z <fl> poly <Polygon>)
                      (let ((center (vertex+xyz& (get-center poly) x y z)))
                        (let ((index (position-index area (vertex-& center area-position))))
                          ;; quicky for tests
                          (let ((poly (copy-polygon poly)))
                            (vertex+xyz! (get-origin poly) (get-origin poly) x y z)
                            (loop (for vert in-vector (get-vertices poly))
                                  (vertex+xyz! vert vert x y z))
                            ;; data1 already set in poly
                            (set-data2 poly (+ (get-data2 poly) x))
                            (set-data3 poly (+ (get-data3 poly) y))
                            (set-data4 poly (+ (get-data4 poly) z))
                            (table-add areas index poly)))))
                    
                    (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-id <fx> add-template)
                      (let ((data-id (local-data-ref i j k)))
                        (let ((templates (find-physical-templates block-id data-id 0 #f)))
                          (unless (opaque? (effective-block-ref (- i 1) j k)) (add-template x y z (vector-ref templates 0)))
                          (unless (opaque? (effective-block-ref (+ i 1) j k)) (add-template x y z (vector-ref templates 1)))
                          (unless (opaque? (effective-block-ref i (- j 1) k)) (add-template x y z (vector-ref templates 2)))
                          (unless (opaque? (effective-block-ref i (+ j 1) k)) (add-template x y z (vector-ref templates 3)))
                          (unless (opaque? (effective-block-ref i j (- k 1))) (add-template x y z (vector-ref templates 4)))
                          (unless (opaque? (effective-block-ref i j (+ k 1))) (add-template x y z (vector-ref templates 5))))))
                    
                    (define (add-inner-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-id <fx> add-template)
                      (let ((data-id (local-data-ref i j k)))
                        (let ((templates (find-physical-templates block-id data-id 0 #f)))
                          (unless (opaque? (local-block-ref (- i 1) j k)) (add-template x y z (vector-ref templates 0)))
                          (unless (opaque? (local-block-ref (+ i 1) j k)) (add-template x y z (vector-ref templates 1)))
                          (unless (opaque? (local-block-ref i (- j 1) k)) (add-template x y z (vector-ref templates 2)))
                          (unless (opaque? (local-block-ref i (+ j 1) k)) (add-template x y z (vector-ref templates 3)))
                          (unless (opaque? (local-block-ref i j (- k 1))) (add-template x y z (vector-ref templates 4)))
                          (unless (opaque? (local-block-ref i j (+ k 1))) (add-template x y z (vector-ref templates 5))))))
                    
                    (define (opaque? block-id <fx>)
                      (let ((block (id->block block-id)))
                        (get-opaque-cube? block)))
                    
                    (define (add-liquid-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> templates <vector> add-template)
                      (unless (liquid-opaque? (effective-block-ref (- i 1) j k)) (add-template x y z (vector-ref templates 0)))
                      (unless (liquid-opaque? (effective-block-ref (+ i 1) j k)) (add-template x y z (vector-ref templates 1)))
                      (unless (liquid-opaque? (effective-block-ref i (- j 1) k)) (add-template x y z (vector-ref templates 2)))
                      (unless (liquid-opaque? (effective-block-ref i (+ j 1) k)) (add-template x y z (vector-ref templates 3)))
                      (unless (liquid-opaque? (effective-block-ref i j (- k 1))) (add-template x y z (vector-ref templates 4)))
                      (unless (liquid-opaque? (effective-block-ref i j (+ k 1))) (add-template x y z (vector-ref templates 5))))
                    
                    (define (add-inner-liquid-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> templates <vector> add-template)
                      (unless (liquid-opaque? (local-block-ref (- i 1) j k)) (add-template x y z (vector-ref templates 0)))
                      (unless (liquid-opaque? (local-block-ref (+ i 1) j k)) (add-template x y z (vector-ref templates 1)))
                      (unless (liquid-opaque? (local-block-ref i (- j 1) k)) (add-template x y z (vector-ref templates 2)))
                      (unless (liquid-opaque? (local-block-ref i (+ j 1) k)) (add-template x y z (vector-ref templates 3)))
                      (unless (liquid-opaque? (local-block-ref i j (- k 1))) (add-template x y z (vector-ref templates 4)))
                      (unless (liquid-opaque? (local-block-ref i j (+ k 1))) (add-template x y z (vector-ref templates 5))))
                    
                    (define (liquid-opaque? neighbor-id <fx>)
                      (let ((neighbor (id->block neighbor-id)))
                        (or (get-liquid-cube? neighbor)
                            (get-opaque-cube? neighbor))))
                    
                    ;; inner
                    (loop (for j from 1 below 15)
                          (loop (for k from 1 below 15)
                                (loop (for i from 1 below 15)
                                      (let ((block-id (local-block-ref i j k))
                                            (data-id (local-data-ref i j k)))
                                        (when (/= block-id air-id)
                                          (let ((x (+ section-x i))
                                                (y (+ section-y j))
                                                (z (+ section-z k))
                                                (block (id/data-id->block block-id data-id)))
                                            (let ((x (fl& (+ block-radius (cast <fl> x))))
                                                  (y (fl& (+ block-radius (cast <fl> y))))
                                                  (z (fl& (+ block-radius (cast <fl> z)))))
                                              (let ((physical (get-physical block)))
                                                (cond (physical
                                                       (physical block-id data-id i j k x y z add-template add-inner-liquid-cube effective-block-ref effective-data-ref))
                                                      ((get-opaque-cube? block)
                                                       (add-inner-opaque-cube i j k x y z block-id add-template))
                                                      (else
                                                       (add-physical-template block-id data-id 0 i j k x y z add-template effective-block-ref effective-data-ref)))))))))))
                    
                    ;; outer
                    (let ()
                      (define (add i <fx> j <fx> k <fx>)
                        (let ((block-id (local-block-ref i j k))
                              (data-id (local-data-ref i j k)))
                          (when (/= block-id air-id)
                            (let ((x (+ section-x i))
                                  (y (+ section-y j))
                                  (z (+ section-z k))
                                  (block (id/data-id->block block-id data-id)))
                              (let ((x (fl& (+ block-radius (cast <fl> x))))
                                    (y (fl& (+ block-radius (cast <fl> y))))
                                    (z (fl& (+ block-radius (cast <fl> z)))))
                                (let ((physical (get-physical block)))
                                  (cond (physical
                                         (physical block-id data-id i j k x y z add-template add-liquid-cube effective-block-ref effective-data-ref))
                                        ((get-opaque-cube? block)
                                         (add-opaque-cube i j k x y z block-id add-template))
                                        (else
                                         (add-physical-template block-id data-id 0 i j k x y z add-template effective-block-ref effective-data-ref)))))))))
                      
                      ;; left
                      (let ((i 0))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; right
                      (let ((i 15))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; bottom
                      (let ((j 0))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; top
                      (let ((j 15))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; back
                      (let ((k 0))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k))))
                      ;; front
                      (let ((k 15))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k)))))
                    (when (eq? zone (current-zone))
                      (iterate-table areas
                        (lambda (index polygons)
                          (add-polygons area #f index polygons #f))))))))))))))


(definition protected (dynamic-physical-template block <Block> data-id <fx> i <fx> j <fx> k <fx> block-ref data-ref proc)
  (let ((block-id (get-id block))
        (variant-id (or (get-variant-id block) -1))
        (category (get-category block))
        (uv dummy-uv)
        (generate (get-generate block))
        (rendering dummy-rendering))
    (define (add-face polygon <Polygon> rendering <Rendering> category)
      (proc polygon))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      #f)
    
    (generate 'physical block-id variant-id data-id -1 0 0 0 0. 0. 0. uv lighting rendering category add-face #f block-ref data-ref)))


(definition protected (create-physical-templates block <Block> data-id <fx> config-id <fx> generate)
  (let ((polygons (new-queue))
        (block-id (get-id block))
        (variant-id (or (get-variant-id block) -1))
        (category (get-category block))
        (uv dummy-uv)
        (generate (or generate (get-generate block)))
        (rendering dummy-rendering)
        (transparent-rendering dummy-rendering))
    (define (block-ref i <fx> j <fx> k <fx>) <fx>
      air-id)
    
    (define (data-ref i <fx> j <fx> k <fx>) <fx>
      0)
    
    (define (add-face polygon <Polygon> rendering <Rendering> category)
      (enqueue polygons polygon))
    
    (define (add-cube what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id variant-id add-face)
      (add-face (left-side   what i j k x y z left-uv lighting rendering block-id variant-id) rendering category)
      (add-face (right-side  what i j k x y z right-uv lighting rendering block-id variant-id) rendering category)
      (add-face (bottom-side what i j k x y z bottom-uv lighting rendering block-id variant-id) rendering category)
      (add-face (top-side    what i j k x y z top-uv lighting rendering block-id variant-id) rendering category)
      (add-face (back-side   what i j k x y z back-uv lighting rendering block-id variant-id) rendering category)
      (add-face (front-side  what i j k x y z front-uv lighting rendering block-id variant-id) rendering category))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      #f)
    
    (cond (generate
           (generate 'physical block-id variant-id data-id config-id 0 0 0 0. 0. 0. uv lighting rendering category add-face add-cube block-ref data-ref))
          ((or (get-opaque-cube? block)
               (get-translucent-cube? block))
           (add-cube 'physical 0 0 0 0. 0. 0. uv uv uv uv uv uv lighting rendering category block-id variant-id add-face))
          (else
           (add-cross-faces 'physical 0 0 0 0. 0. 0. uv lighting transparent-rendering category block-id variant-id add-face)))
    (list->vector (queue-list polygons))))


(definition protected (find-physical-templates block-id <fx> data-id <fx> config-id <fx> generate) <vector>
  (let ((block (id/data-id->block block-id data-id)))
    (let ((physicals (get-physicals block)))
      (if (not physicals)
          (let ((templates (create-physical-templates block data-id config-id generate))
                (physicals (make-vector (get-configurations block) #f)))
            (vector-set! physicals config-id templates)
            (set-physicals block physicals)
            templates)
        (or (vector-ref physicals config-id)
            (let ((templates (create-physical-templates block data-id config-id generate)))
              (vector-set! physicals config-id templates)
              templates))))))


(definition protected (add-physical-template block-id <fx> data-id <fx> config-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
  (let ((polygons (find-physical-templates block-id data-id config-id #f)))
    (loop (for poly in-vector polygons)
          (add-template x y z poly))))


(definition protected (add-data-physical block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template add-liquid-cube block-ref data-ref)
  (add-physical-template block-id data-id data-id i j k x y z add-template block-ref data-ref))


;;;
;;;; Coordinates
;;;


(definition protected (index->coordinates index <fx>) <index>
  (let ((i (modulo index 16))
        (k (modulo (quotient index 16) 16))
        (j (modulo (quotient (quotient index 16) 16) 16)))
    (indexed i j k)))


(definition protected (section/coordinates->location section <World-Section> coord <index>) <index>
  (let ((index (get-index section)))
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (indexed (+ (index-x coord) (* section-x 16))
               (+ (index-y coord) (* section-y 16))
               (+ (index-z coord) (* section-z 16))))))


(definition protected (section/index->position section <World-Section> index <fx>) <vertex>
  (let ((coord (index->coordinates index)))
    (let ((location (section/coordinates->location section coord)))
      (let ((x (index-x location))
            (y (index-y location))
            (z (index-z location)))
        (vertex (+ (cast <fl> x) .5)
                (+ (cast <fl> y) .5)
                (+ (cast <fl> z) .5))))))


(definition protected (normalize-section/coordinates section i <fx> j <fx> k <fx> with-field proc)
  (if (and (between? i 0 15)
           (between? j 0 15)
           (between? k 0 15))
      (proc section i j k)
    (with-field i j k
      (lambda (section index)
        (bind-index (i j k) (index->coordinates index)
          (proc section i j k))))))


(definition protected (enqueue-section/coordinates queue section coordinates with-field)
  (assert section) ; tracking a bug
  (bind-index (i j k) coordinates
    (normalize-section/coordinates section i j k with-field
      (lambda (section i j k)
        ;; quick try as every caller seems to test for section
        (when section
          (enqueue queue (cons section (indexed i j k))))))))


(definition protected (taxicab-distance section1 <World-Section> section2 <World-Section>)
  (let ((index1 (get-index section1))
        (index2 (get-index section2)))
    (+ (abs (- (index-x index1) (index-x index2)))
       (abs (- (index-y index1) (index-y index2)))
       (abs (- (index-z index1) (index-z index2))))))


(definition protected (block-entity-data section <World-Section> coordinates <index>)
  (let ((chunk <World-Chunk> (get-chunk section))
        (index (section/coordinates->location section coordinates)))
    (find-block-entity chunk index)))


(definition protected (block-entity-add section <World-Section> coordinates <index>)
  (let ((chunk <World-Chunk> (get-chunk section))
        (index (section/coordinates->location section coordinates)))
    (add-block-entity chunk index)))


;;;
;;;; Components
;;;


(definition protected (new-repeater section i j k delay power? with-field)
  (normalize-section/coordinates section i j k with-field
    (lambda (section i j k)
      (new Repeater section i j k delay power?))))


(definition protected (new-plate section i j k delay actor with-field)
  (normalize-section/coordinates section i j k with-field
    (lambda (section i j k)
      (new Plate section i j k delay actor))))


(class Redstone-Component extends Object
  
  
  (slot section getter generate)
  (slot i       getter generate)
  (slot j       getter generate)
  (slot k       getter generate)
  (slot delay   accessors generate)
  
  
  (method override (initialize self section i j k delay)
    (set! self.section section)
    (set! self.i i)
    (set! self.j j)
    (set! self.k k)
    (set! self.delay delay))
  
  (method package (location self)
    (list section i j k)))


;;;
;;;; Plate
;;;


(class Plate extends Redstone-Component
  
  
  (slot colliders accessors generate)
  
  
  (method override (initialize self section i j k delay actor)
    (nextmethod self section i j k delay)
    (set! self.colliders (cons actor '()))))


;;;
;;;; Repeater
;;;


(class Repeater extends Redstone-Component
  
  
  (slot power? accessors generate)
  
  
  (method override (initialize self section i j k delay power?)
    (nextmethod self section i j k delay)
    (set! self.power? power?)))


;;;
;;;; Burnout
;;;


@code-to-implement-redstone-torch-burnout (
(class Powerer extends Object
  
  
  (slot i    getter generate)
  (slot j    getter generate)
  (slot time getter generate)
  
  
  (method override (initialize i j time)
    (set! self.i i)
    (set! self.j j)
    (set! self.time time)))


(define burnout-delay
  3)


(define last-torches
  (list #f))


(define (add-torch powerer)
  (set-cdr! last-torches (cons powerer (cdr last-torches))))


(define (count-powerings i j time)
  (define (powering? powerer)
    (and (= (get-i powerer) i)
         (= (get-j powerer) j)))
  
  (define (past-delay? powerer)
    (> (- time (get-time powerer)) burnout-delay))
  
  (let (iter (scan last-torches) (count 0))
    (let ((torches (cdr scan)))
      (if (null? torches)
          count
        (let ((torch (car torches)))
          (if (past-delay? torch)
              (begin
                (set-cdr! scan '())
                count)
            (iter (cdr scan) (if (powering? torch) (+ count 1) count))))))))


(add-torch (new Powerer 1 2 10)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 10)         (debug 'count (length (cdr last-torches)))
(add-torch (new Powerer 1 2 11)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 11)         (debug 'count (length (cdr last-torches)))
(add-torch (new Powerer 1 2 14)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 14)         (debug 'count (length (cdr last-torches)))
(count-powerings 1 2 20)         (debug 'count (length (cdr last-torches))))


;;;
;;;; Actions
;;;


(definition protected block-hook
  #f)


(definition public (register-block-hook hook)
  (set! block-hook hook))


(definition public (invoke-block-hook pos)
  (when block-hook
    (block-hook pos)))


(definition protected block-actions <table>
  (make-table test: equal?))

;; quick hack to think through
(definition protected (reset-block-actions)
  (set! block-actions (make-table test: equal?)))


(definition public (registered-block-action pos event)
  (table-ref block-actions (cons pos event) #f))


(definition public (register-block-action pos event action)
  (table-set! block-actions (cons pos event) action))


(definition public (register-blocks-action lst event action)
  (for-each (lambda (pos)
              (register-block-action pos event action))
            lst))


(definition public (invoke-block-action pos event)
  (let ((action (registered-block-action pos event)))
    (when action
      (action)
      #t)))


;;;
;;;; Add
;;;


(definition (make-quad-face what rendering <Rendering> texture-coordinates texture-depth quad l1 l2 l3 l4)
  (case what
    ((physical)
     quad)
    ((visual)
     (new Quad-Template texture-coordinates texture-depth quad l1 l2 l3 l4))
    (else
     (new Quad-Face (get-entity-material rendering) texture-coordinates texture-depth quad l1 l2 l3 l4))))


(definition (make-triangle-face what rendering <Rendering> texture-coordinates texture-depth triangle l1 l2 l3)
  (case what
    ((physical)
     triangle)
    ((visual)
     (new Triangle-Template texture-coordinates texture-depth triangle l1 l2 l3))
    (else
     (new Triangle-Face (get-entity-material rendering) texture-coordinates texture-depth triangle l1 l2 l3))))


(definition (make-block-quad v1 v2 v3 v4 block-id <fx> variant-id <fx> x <fl> y <fl> z <fl>) <Quad>
  (let ((quad <Quad> (make-quad #f v1 v2 v3 v4)))
    (set-data1 quad (cast <fl> (encode-id block-id variant-id)))
    (set-data2 quad x)
    (set-data3 quad y)
    (set-data4 quad z)
    quad))


(definition (make-block-triangle v1 v2 v3 block-id <fx> variant-id <fx> x <fl> y <fl> z <fl>) <Triangle>
  (let ((triangle <Triangle> (make-triangle #f v1 v2 v3)))
    (set-data1 triangle (cast <fl> (encode-id block-id variant-id)))
    (set-data2 triangle x)
    (set-data3 triangle y)
    (set-data4 triangle z)
    triangle))


(definition protected (generic-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tt tl tb tr tb tr tt)))


;; 90 degrees to the left
(definition protected (rotate-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tb tr tb tr tt tl tt)))


;; 90 degrees to the right
(definition protected (rotate-inverse-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tl tt tl tb tr tb)))


(definition protected (rotate-other-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tb tr tt tl tt tl tb)))


(definition protected (transpose-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tr tb tl tb tl tt)))


(definition (generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <vertex> v2 <vertex> v3 <vertex> v4 <vertex> uv <f32vector> uv-coordinates lighting shade rendering block-id <fx> variant-id <fx> matrix <matrix>)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3))
        (v4 (matrix-transform-3x4 matrix v4)))
    (let ((quad (make-block-quad (vertex+xyz v1 x y z)
                                 (vertex+xyz v2 x y z)
                                 (vertex+xyz v3 x y z)
                                 (vertex+xyz v4 x y z)
                                 block-id
                                 variant-id
                                 x
                                 y
                                 z)))
      (let ((normal (get-normal quad)))
        (make-quad-face what
                        rendering
                        (uv-coordinates uv)
                        (uv-depth uv)
                        quad
                        (generic-lighting i j k v1 normal lighting shade)
                        (generic-lighting i j k v2 normal lighting shade)
                        (generic-lighting i j k v3 normal lighting shade)
                        (generic-lighting i j k v4 normal lighting shade))))))


(definition (generic-triangle what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <vertex> v2 <vertex> v3 <vertex> uv <f32vector> uv-coordinates lighting shade rendering block-id <fx> variant-id <fx> matrix <matrix>)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3)))
    (let ((triangle (make-block-triangle (vertex+xyz v1 x y z)
                                         (vertex+xyz v2 x y z)
                                         (vertex+xyz v3 x y z)
                                         block-id
                                         variant-id
                                         x
                                         y
                                         z)))
      (let ((normal (get-normal triangle)))
        (make-triangle-face what
                            rendering
                            (uv-coordinates uv)
                            (uv-depth uv)
                            triangle
                            (generic-lighting i j k v1 normal lighting shade)
                            (generic-lighting i j k v2 normal lighting shade)
                            (generic-lighting i j k v3 normal lighting shade))))))


(constant inline 1/SQRT2 <fl>
  (/ 1. (sqrt 2.)))

;; minimal value for door to clear itself
(constant inline ambient-forward <fl>
  .3)

;; minimal value for stair top to clear itself and fence to be uniform
(constant inline ambient-angled <fl>
  .9)


@debugging
(definition protected (get-ambient-forward/angled)
  (values ambient-forward ambient-angled))

@debugging
(definition protected (set-ambient-forward/angled forward angled)
  (set! ambient-forward forward)
  (set! ambient-angled angled))


(definition protected (generic-lighting i <fx> j <fx> k <fx> vert <vertex> normal <vertex> lighting shade)
  (if (u8vector? lighting)
      lighting
    ;; the .5 is because the shape is centered at 0 0 0
    (let ((adjusted (vertex+& (vertex+& vert (vertex& .5 .5 .5)) (vertex-scalar*& normal ambient-forward)))
          (r1 (make-vertex&))
          (r2 (make-vertex&))
          (r3 (make-vertex&))
          (r4 (make-vertex&)))
      (define (ambient-rays!)
        (let ((up (roll-free-up& normal)))
          (let ((right (cross-product& normal up)))
            (let ((advance (vertex-scalar*& normal 1/SQRT2)))
              (let ((up/+2 (vertex-scalar/& up  2.))
                    (up/-2 (vertex-scalar/& up -2.))
                    (right/+2 (vertex-scalar/& right  2.))
                    (right/-2 (vertex-scalar/& right -2.)))
                (vertex+! r1 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/+2)) ambient-angled))
                (vertex+! r2 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/-2)) ambient-angled))
                (vertex+! r3 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/-2)) ambient-angled))
                (vertex+! r4 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/+2)) ambient-angled)))))))
      
      (ambient-rays!)
      (lighting shade i j k
        (fxfloor (vertex-x r1)) (fxfloor (vertex-y r1)) (fxfloor (vertex-z r1))
        (fxfloor (vertex-x r2)) (fxfloor (vertex-y r2)) (fxfloor (vertex-z r2))
        (fxfloor (vertex-x r3)) (fxfloor (vertex-y r3)) (fxfloor (vertex-z r3))
        (fxfloor (vertex-x r4)) (fxfloor (vertex-y r4)) (fxfloor (vertex-z r4))))))


(constant inline no-shade     <fl> 1.)
(constant inline top-shade    <fl> (->flonum (world-setting 'world.top-shade    1.)))
(constant inline bottom-shade <fl> (->flonum (world-setting 'world.bottom-shade .5)))
(constant inline left-shade   <fl> (->flonum (world-setting 'world.left-shade   .6)))
(constant inline right-shade  <fl> (->flonum (world-setting 'world.right-shade  .6)))
(constant inline back-shade   <fl> (->flonum (world-setting 'world.back-shade   .8)))
(constant inline front-shade  <fl> (->flonum (world-setting 'world.front-shade  .8)))


(definition protected (compute-shade normal <vertex> matrix <matrix>)
  (let ((n (matrix-transform& matrix normal)))
    (let ((x (vertex-x n))
          (y (vertex-y n))
          (z (vertex-z n)))
      (let ((xs (if (>= x 0.) (* x .6) (* x -.6)))
            (ys (if (>= y 0.) y (* y -.5)))
            (zs (if (>= z 0.) (* z .8) (* z -.8))))
        (sqrt (+ (* xs xs) (* ys ys) (* zs zs)))))))


(definition public (left-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id <fx> variant-id <fx>)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (left-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (left-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front) block-id variant-id x y z)
                  (lighting left-shade i j k -1  0 -1 -1  0  0 -1  1 -1 -1  1  0)
                  (lighting left-shade i j k -1 -1 -1 -1 -1  0 -1  0 -1 -1  0  0)
                  (lighting left-shade i j k -1 -1  0 -1 -1  1 -1  0  0 -1  0  1)
                  (lighting left-shade i j k -1  0  0 -1  0  1 -1  1  0 -1  1  1)))


;; simple solution for shapes that don't work well with ambient vectors
(definition (uniform-lighting i <fx> j <fx> k <fx> lighting)
  (lighting no-shade i j k 0 0 1 0 0 -1 1 0 0 -1 0 0))


(definition public (left-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx> matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left top front))
        (shade (compute-shade (vertex& -1. 0. 0.) matrix)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting shade rendering block-id variant-id matrix)))


(definition public (left-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top-first <fl> top-second <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (let ((v1 (vertex left top-first back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left top-second front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting left-shade rendering block-id variant-id (make-identity-matrix))))


(definition public (right-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id <fx> variant-id <fx>)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (right-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (right-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back) block-id variant-id x y z)
                  (lighting right-shade i j k  1  0  0  1  0  1  1  1  0  1  1  1)
                  (lighting right-shade i j k  1 -1  0  1 -1  1  1  0  0  1  0  1)
                  (lighting right-shade i j k  1 -1 -1  1 -1  0  1  0 -1  1  0  0)
                  (lighting right-shade i j k  1  0 -1  1  0  0  1  1 -1  1  1  0)))


(definition public (right-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx> matrix)
  (let ((v1 (vertex right top front))
        (v2 (vertex right bottom front))
        (v3 (vertex right bottom back))
        (v4 (vertex right top back))
        (shade (compute-shade (vertex& 1. 0. 0.) matrix)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting shade rendering block-id variant-id matrix)))


(definition public (right-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top-first <fl> top-second <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (let ((v1 (vertex right top-first front))
        (v2 (vertex right bottom front))
        (v3 (vertex right bottom back))
        (v4 (vertex right top-second back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting right-shade rendering block-id variant-id (make-identity-matrix))))


(definition public (bottom-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id <fx> variant-id <fx>)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (bottom-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front) block-id variant-id x y z)
                  (lighting bottom-shade i j k -1 -1  0 -1 -1  1  0 -1  0  0 -1  1)
                  (lighting bottom-shade i j k -1 -1 -1 -1 -1  0  0 -1 -1  0 -1  0)
                  (lighting bottom-shade i j k  0 -1 -1  0 -1  0  1 -1 -1  1 -1  0)
                  (lighting bottom-shade i j k  0 -1  0  0 -1  1  1 -1  0  1 -1  1)))


(definition public (bottom-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx> matrix)
  (let ((v1 (vertex left bottom front))
        (v2 (vertex left bottom back))
        (v3 (vertex right bottom back))
        (v4 (vertex right bottom front))
        (shade (compute-shade (vertex& 0. -1. 0.) matrix)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting shade rendering block-id variant-id matrix)))


(definition public (top-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id <fx> variant-id <fx>)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (top-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (top-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back) block-id variant-id x y z)
                  (lighting top-shade i j k -1  1 -1 -1  1  0  0  1 -1  0  1  0)
                  (lighting top-shade i j k -1  1  0 -1  1  1  0  1  0  0  1  1)
                  (lighting top-shade i j k  0  1  0  0  1  1  1  1  0  1  1  1)
                  (lighting top-shade i j k  0  1 -1  0  1  0  1  1 -1  1  1  0)))

(definition public (top-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx> matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left top front))
        (v3 (vertex right top front))
        (v4 (vertex right top back))
        (shade (compute-shade (vertex& 0. 1. 0.) matrix)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting shade rendering block-id variant-id matrix)))


(definition public (top-sloped what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> left-back-height <fl> left-front-height <fl> right-front-height <fl> right-back-height <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (let ((v1 (vertex left left-back-height back))
        (v2 (vertex left left-front-height front))
        (v3 (vertex right right-front-height front))
        (v4 (vertex right right-back-height back))
        (matrix (make-identity-matrix)))
    (define (needs-triangles?)
      (/= (/ (+ (vertex-y v1) (vertex-y v3)) 2.)
          (/ (+ (vertex-y v2) (vertex-y v4)) 2.)))
    
    (if (needs-triangles?)
        (list
          (generic-triangle what i j k x y z v1 v2 v4 uv uv-coordinates lighting top-shade rendering block-id variant-id matrix)
          (generic-triangle what i j k x y z v3 v4 v2 uv uv-coordinates lighting top-shade rendering block-id variant-id matrix))
      (list
        (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting top-shade rendering block-id variant-id matrix)))))


(definition public (back-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id <fx> variant-id <fx>)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (back-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (back-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back) block-id variant-id x y z)
                  (lighting back-shade i j k  0  0 -1  0  1 -1  1  0 -1  1  1 -1)
                  (lighting back-shade i j k  0 -1 -1  0  0 -1  1 -1 -1  1  0 -1)
                  (lighting back-shade i j k -1 -1 -1 -1  0 -1  0 -1 -1  0  0 -1)
                  (lighting back-shade i j k -1  0 -1 -1  1 -1  0  0 -1  0  1 -1)))


(definition public (back-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx> matrix)
  (let ((v1 (vertex right top back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left top back))
        (shade (compute-shade (vertex& 0. 0. -1.) matrix)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting shade rendering block-id variant-id matrix)))


(definition public (back-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top-first <fl> top-second <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (let ((v1 (vertex right top-first back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left top-second back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting back-shade rendering block-id variant-id (make-identity-matrix))))


(definition public (front-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id <fx> variant-id <fx>)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (front-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (front-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front) block-id variant-id x y z)
                  (lighting front-shade i j k -1  0  1 -1  1  1  0  0  1  0  1  1)
                  (lighting front-shade i j k -1 -1  1 -1  0  1  0 -1  1  0  0  1)
                  (lighting front-shade i j k  0 -1  1  0  0  1  1 -1  1  1  0  1)
                  (lighting front-shade i j k  0  0  1  0  1  1  1  0  1  1  1  1)))


(definition public (front-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx> matrix)
  (let ((v1 (vertex left top front))
        (v2 (vertex left bottom front))
        (v3 (vertex right bottom front))
        (v4 (vertex right top front))
        (shade (compute-shade (vertex& 0. 0. 1.) matrix)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting shade rendering block-id variant-id matrix)))


(definition public (front-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top-first <fl> top-second <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id <fx> variant-id <fx>)
  (let ((v1 (vertex left top-first front))
        (v2 (vertex left bottom front))
        (v3 (vertex right bottom front))
        (v4 (vertex right top-second front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting front-shade rendering block-id variant-id (make-identity-matrix))))


(definition public (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id <fx> variant-id <fx> matrix add-face)
  (add-face (left-generic   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (right-generic  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (bottom-generic what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (top-generic    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (back-generic   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (front-generic  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category))


(definition public (add-cube-faces what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering category block-id <fx> variant-id <fx> add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)))


(definition public (add-cross-faces what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering category block-id <fx> variant-id <fx> add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius)))
        (tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv))
        (lighting (uniform-lighting i j k lighting)))
    (add-face (make-quad-face what
                              rendering
                              (f32vector tl tt tl tb tr tb tr tt)
                              texture-depth
                              (make-block-quad (vertex right top back) (vertex right bottom back) (vertex left bottom front) (vertex left top front) block-id variant-id x y z)
                              lighting lighting lighting lighting)
              rendering
              category)
    (add-face (make-quad-face what
                              rendering
                              (f32vector tl tt tl tb tr tb tr tt)
                              texture-depth
                              (make-block-quad (vertex right top front) (vertex right bottom front) (vertex left bottom back) (vertex left top back) block-id variant-id x y z)
                              lighting lighting lighting lighting)
              rendering
              category)))


(definition protected (add-torch what block-id <fx> variant-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category add-face add-cube block-ref data-ref top-texture bottom-texture)
  (define (position-torch proc)
    (let ((margin .32))
      (ecase data-id
        ((1) (proc (- margin) 0.))
        ((2) (proc margin 0.))
        ((3) (proc 0. (- margin)))
        ((4) (proc 0. margin))
        (else (proc 0. 0.)))))
  
  (position-torch
    (lambda (dx <fl> dz <fl>)
      (let ((margin 1m)
            (left (- x block-radius))
            (right (+ x block-radius))
            (bottom (- y block-radius))
            (top (+ y block-radius))
            (back (- z block-radius))
            (front (+ z block-radius))
            (top-uv (cache-coordinates top-texture))
            (bottom-uv (cache-coordinates bottom-texture)))
        (add-face (top-face    what i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) top-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (bottom-face what i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) bottom-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (left-face   what i j k x y z (+ dx (- x margin)) (+ dx right) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (right-face  what i j k x y z (+ dx left) (+ dx (+ x margin)) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (back-face   what i j k x y z (+ dx left) (+ dx right) bottom top (+ dz (- z margin)) (+ dz front) uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (front-face  what i j k x y z (+ dx left) (+ dx right) bottom top (+ dz back) (+ dz (+ z margin)) uv generic-coordinates lighting rendering block-id variant-id) rendering category)))))


(definition protected (add-button what block-id <fx> variant-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category add-face add-cube block-ref data-ref)
  (define (position-button proc)
    (let ((orientation (bitwise-and data-id #b111))
          (depth (if (bit-set? 3 data-id) 1m 2m))
          (margin 3m)
          (thick 2m)
          (thin 1m))
      (ecase orientation
        ((0) (proc (- x margin) (+ x margin) (- (+ y block-radius) depth) (+ y block-radius) (- z thick) (+ z thick)))
        ((1) (proc (- x block-radius) (+ (- x block-radius) depth) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((2) (proc (- (+ x block-radius) depth) (+ x block-radius) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((3) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- z block-radius) (+ (- z block-radius) depth)))
        ((4) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- (+ z block-radius) depth) (+ z block-radius)))
        ((5) (proc (- x margin) (+ x margin) (- y block-radius) (+ (- y block-radius) depth) (- z thick) (+ z thick))))))
  
  (position-button
    (lambda (left right bottom top back front)
      (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category))))


;; unused
(definition protected (add-stairs what block-id variant-id data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category add-face)
  (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case (bitwise-and data-id #b11)
                                                         ((3) (vertex&  0. 0. -1.))
                                                         ((2) (vertex&  0. 0.  1.))
                                                         ((1) (vertex& -1. 0.  0.))
                                                         ((0) (vertex&  1. 0.  0.)))))))
    ;; bottom
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom (fl& (- block-radius)))
          (top 0.)
          (back (fl& (- block-radius)))
          (front (fl& (+ block-radius))))
      (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face))
    ;; top
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom 0.)
          (top (fl& (+ block-radius)))
          (back 0.)
          (front (fl& (+ block-radius))))
      (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face))))


(definition protected (fence-configuration i <fx> j <fx> k <fx> block-ref connects)
  (define (connect? block-id)
    (memv? block-id connects))
  
  (bitwise-ior
    ;; left
    (if (connect? (block-ref (+ i 1) j k)) 1 0)
    ;; right
    (if (connect? (block-ref (- i 1) j k)) 2 0)
    ;; back
    (if (connect? (block-ref i j (+ k 1))) 4 0)
    ;; front
    (if (connect? (block-ref i j (- k 1))) 8 0)))


(definition protected (add-fence what block-id <fx> variant-id <fx> config-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face block-ref)
  (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (vertex&  0. 0.  1.))))
        (depth .075))
    (define (add-trunk)
      (let ((left (- .1))
            (right (+ .1))
            (bottom (- block-radius))
            (top (+ block-radius))
            (back (- .1))
            (front (+ .1)))
        (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face)))
    
    (define (add-branches left <fl> right <fl> back <fl> front <fl>)
      ;; upper
      (let ((bottom (- .35 .075))
            (top (+ .35 .075)))
        (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face))
      ;; lower
      (let ((bottom (- .075))
            (top (+ .075)))
        (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face)))
    
    ;; trunk
    (add-trunk)
    ;; left
    (when (bit-set? 0 config-id)
      (add-branches .1 (+ block-radius) (- depth) depth))
    ;; right
    (when (bit-set? 1 config-id)
      (add-branches (- block-radius) -.1 (- depth) depth))
    ;; back
    (when (bit-set? 2 config-id)
      (add-branches (- depth) depth .1 (+ block-radius)))
    ;; front
    (when (bit-set? 3 config-id)
      (add-branches (- depth) depth (- block-radius) -.1))))


(definition protected (add-slab what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv side-uv lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top y)
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (right-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (back-face   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (front-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-sloped what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category block-id variant-id add-face horizon)
  (let ((left (fl& (- block-radius)))
        (right (fl& (+ block-radius)))
        (bottom (fl& (- block-radius)))
        (top (fl& (+ block-radius)))
        (back (fl& (- block-radius)))
        (front (fl& (+ block-radius))))
    (let ((v1 (vertex left top back))
          (v2 (vertex left bottom front))
          (v3 (vertex right bottom front))
          (v4 (vertex right top back))
          (matrix (make-lookat-matrix& (horizon-lookat&^ horizon))))
      (add-face (generic-quad what i j k x y z v1 v2 v3 v4 uv generic-coordinates lighting no-shade rendering block-id variant-id matrix) rendering category))))


(definition protected (add-rail what block-id <fx> variant-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category add-face)
  (case data-id
    ((0) (add-bottom what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
    ((1) (add-bottom what i j k x y z uv rotate-coordinates lighting rendering category block-id variant-id add-face))
    ((2) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex& -1. 0.  0.)))
    ((3) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  1. 0.  0.)))
    ((4) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  0. 0.  1.)))
    ((5) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  0. 0. -1.)))
    ((6) (add-bottom what i j k x y z (cache-coordinates "rail_normal_turned") generic-coordinates lighting rendering category block-id variant-id add-face))
    ((7) (add-bottom what i j k x y z (cache-coordinates "rail_normal_turned") rotate-coordinates lighting rendering category block-id variant-id add-face))
    ((8) (add-bottom what i j k x y z (cache-coordinates "rail_normal_turned") rotate-other-coordinates lighting rendering category block-id variant-id add-face))
    ((9) (add-bottom what i j k x y z (cache-coordinates "rail_normal_turned") rotate-inverse-coordinates lighting rendering category block-id variant-id add-face))))


(definition protected (add-rail-gadget what block-id <fx> variant-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-powered lighting rendering category add-face)
  (let ((powered? (bit-set? 3 data-id)))
    (let ((uv (if powered? uv-powered uv)))
      (case (bitwise-and data-id #b111)
        ((0) (add-bottom what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
        ((1) (add-bottom what i j k x y z uv rotate-coordinates lighting rendering category block-id variant-id add-face))
        ((2) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex& -1. 0.  0.)))
        ((3) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  1. 0.  0.)))
        ((4) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  0. 0.  1.)))
        ((5) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  0. 0. -1.)))))))


(definition protected add-epsilon <fl>
  .02)


(definition protected (add-left what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id <fx> variant-id <fx> add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (right-face what i j k x y z left (+ left add-epsilon) bottom top back front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-right what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id <fx> variant-id <fx> add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face what i j k x y z (- right add-epsilon) right bottom top back front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-bottom what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id <fx> variant-id <fx> add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (top-face what i j k x y z left right bottom (+ bottom add-epsilon) back front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-top what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id <fx> variant-id <fx> add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (bottom-face what i j k x y z left right (- top add-epsilon) top back front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-back what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id <fx> variant-id <fx> add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (front-face what i j k x y z left right bottom top back (+ back add-epsilon) uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-front what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id <fx> variant-id <fx> add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (back-face what i j k x y z left right bottom top (- front add-epsilon) front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-transparent what block-id <fx> variant-id <fx> data-id left right back front i j k x <fl> y <fl> z <fl> uv lighting rendering category add-face)
  (ecase data-id
    ((left)  (add-left  what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
    ((right) (add-right what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
    ((back)  (add-back  what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
    (else    (add-front what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))))


;;;
;;;; Models
;;;


;; hacks to try out blocks rendered with ambient lighting


(definition protected (generate-model what name block-id <fx> variant-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category add-face)
  (let ((world (current-world)))
    (let ((model <Model> (find-model world name))
          (center (vertex& x y z)))
      (let ((matrix (make-translation-matrix& center)))
        (let ((polygons (block-polygons-extract #f (get-polygons model) matrix block-id variant-id x y z)))
          (for-each (lambda (poly <Polygon>)
                      (let ((normal (get-normal poly)))
                        (let ((shade (determine-shade normal)))
                          (define (triangle)
                            (let ((poly (cast <Triangle> poly)))
                              (make-triangle-face what rendering (uv-coordinates uv) (uv-depth uv) poly
                                (generic-lighting i j k (vertex-& (get-v1 poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v2 poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v3 poly) center) normal lighting shade))))
                          
                          (define (quad)
                            (let ((poly (cast <Quad> poly)))
                              (make-quad-face what rendering (uv-coordinates uv) (uv-depth uv) poly
                                (generic-lighting i j k (vertex-& (get-v1 poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v2 poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v3 poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v4 poly) center) normal lighting shade))))
                          
                          (add-face (if (is? poly Triangle)
                                        (triangle)
                                      (quad))
                                    rendering
                                    category))))
                    polygons))))))


(definition (determine-shade normal)
  (cond ((vertex=? normal (vertex&  0.  1.  0.)) top-shade)
        ((vertex=? normal (vertex&  0. -1.  0.)) bottom-shade)
        ((vertex=? normal (vertex&  1.  0.  0.)) left-shade)
        ((vertex=? normal (vertex& -1.  0.  0.)) right-shade)
        ((vertex=? normal (vertex&  0.  0.  1.)) back-shade)
        ((vertex=? normal (vertex&  0.  0. -1.)) front-shade)
        (else no-shade))))
