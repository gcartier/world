;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Generation
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Edouard Hebert


(module world.generation jazz


(import (jazz.geometry)
        (jazz.io)
        (jazz.json)
        (jazz.syntax (phase syntax))
        (world)
        (world.area)
        (world.autoload)
        (world.chunk)
        (world.generate)
        (world.generation.base)
        (world.generation.block)
        (world.generation.categories)
        (world.generation.rendering)
        (world.geometry)
        (world.homogeneous)
        (world.index)
        (world.light-syntax)
        (world.mesh)
        (world.model)
        (world.models)
        (world.polygon)
        (world.quad)
        (world.region)
        (world.render)
        (world.section)
        (world.sector)
        (world.support)
        (world.syntax (phase syntax))
        (world.template)
        (world.texture)
        (world.triangle))


;; LEXICON
;; - index: section-local i j k coordinates
;; - location: integer vector representing a block in the block entities format
;; - position: block center position


;; WARNING
;; - the temporary hack of duplicating non thread-safe geometry functions
;;   like horizon-lookat&^ is super dangerous and should be improved upon


(proclaim (warn optimizations))


(definition protected aa 0) ;; 10421010
(definition protected oo 0) ;; 12248627
(definition protected gg 0) ;; 745240
(definition protected ww 0) ;; 697473
(definition protected cc 0) ;; 54050


(definition protected (block-texture-coordinates block <Block>) <f32vector>
  (or (get-texture-coordinates~ block)
      (let ((texture (get-texture~ block)))
        (let ((coords (and texture (image-rect~ (cache-atlas) texture))))
          (set-texture-coordinates~ block coords)
          coords))))


(definition coordinates-mutex
  (make-mutex 'coordinates))

(definition coordinates <table>
  (make-table test: equal?))

(definition protected (get-coordinates name <string>) <f32vector>
  (mutex-lock! coordinates-mutex)
  (prog1 (or (table-ref coordinates name #f)
             (let ((coords (if (window?) (image-rect~ (cache-atlas) name) dummy-uv)))
               (table-set! coordinates name coords)
               coords))
    (mutex-unlock! coordinates-mutex)))


(definition dummy-uv <f32vector>
  (uv 0. 0. 1. 1. 0.))


(definition dummy-rendering <Rendering>
  (make-rendering 0 'dummy #f #f #f #f))


(definition public (liquid-filter poly <Polygon>) <bool>
  (not (get-liquid-cube?~ (id->block (decode-id (get-data1~ poly))))))


(definition public (only-water-filter poly <Polygon>) <bool>
  (memq? (get-id~ (id->block (decode-id (get-data1~ poly)))) '(8 9)))


;;;
;;;; Generate
;;;


(definition protected generate-mutex
  (make-mutex 'generate))


(definition protected (with-generate-mutex thunk)
  (unwind-protect
      (begin
        (mutex-lock! generate-mutex)
        (thunk))
    (mutex-unlock! generate-mutex)))


;;;
;;;; Neighbor
;;;


(definition protected inline (section-index a <fx> b <fx> c <fx>) <fx>
  (+ (* b 9) (* c 3) a 13))


(definition protected (neighbor-sections section <World-Section> section-x <fx> section-y <fx> section-z <fx>) <vector>
  (let ((zone (current-zone)))
    (let ((sections (make-vector 27 #f)))
      (loop (for a from -1 to 1)
            (loop (for b from -1 to 1)
                  (loop (for c from -1 to 1)
                        (let ((index (section-index a b c)))
                          (if (and (= a 0)
                                   (= b 0)
                                   (= c 0))
                              (vector-set! sections index section)
                            (let ((x (+ section-x a))
                                  (y (+ section-y b))
                                  (z (+ section-z c)))
                              (vector-set! sections index (index-section~ zone (indexed& x y z)))))))))
      sections)))


;;;
;;;; Visual
;;;


;; we need to go two in every direction instead of just one
;; because of door tops that are rendered by door bottom blocks
(definition protected block-cache-size <fx>
  (* 20 20 20 4))

(definition protected (initialize-block-cache block-cache <u16vector> cache-uninitialized <fx>) <u16vector>
  (loop (for i from 0 below block-cache-size)
        (u16vector-set! block-cache i cache-uninitialized))
  block-cache)


(definition protected block-cache <u16vector>
  (make-u16vector block-cache-size))


(definition protected (instantiate-visual sector <Sector>)
  (let ((zone (current-zone)))
    (define (generate-done)
      (set-visual-uptodate?~ sector #t)
      (set-visual-revision~ sector (get-revision~ (get-generator~ zone)))
      (set-visual-generating?~ sector #f)
      (decrease-sectors-generating~ zone 1)
      (increase-sectors-generated~ zone))
    
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x (index-x sector-index))
            (sector-y (index-y sector-index))
            (sector-z (index-z sector-index)))
        (let ((section (index-section~ zone (indexed& sector-x sector-y sector-z))))
          (if (not section)
              (begin
                (free~ sector)
                (generate-done))
            (let ((truncate-y (get-truncate-y~ zone))
                  (cache-uninitialized 65535)
                  (sections <vector> (neighbor-sections section sector-x sector-y sector-z)))
              (with-generate-mutex
                (lambda ()
                  (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y 0))))
                        (cache <u16vector> (initialize-block-cache block-cache cache-uninitialized))
                        (blocks <u8vector> (get-blocks~ section))
                        (data <u8vector> (get-data~ section))
                        (blocklight <u8vector> (get-blocklight~ section))
                        (skylight <u8vector> (get-skylight~ section))
                        (opaque-rendering <Rendering> (opaque-rendering))
                        (transparent-rendering <Rendering> (transparent-rendering))
                        (coverage-rendering <Rendering> (coverage-rendering))
                        (water-rendering <Rendering> (water-rendering))
                        (wet-rendering <Rendering> (wet-rendering))
                        (multitexture-rendering <Rendering> (multitexture-rendering))
                        (redstone-rendering <Rendering> (redstone-rendering))
                        (texture-elements '()))
                    (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                      (vector-ref sections (section-index a b c)))
                    
                    (define (local-index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (effective-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* j 400) (* k 20) i 842) 4))
                    
                    (define (blocks-get section <World-Section>) <u8vector>
                      (get-blocks~ section))
                    
                    (define (data-get section <World-Section>) <u8vector>
                      (get-data~ section))
                    
                    (define (blocklight-get section <World-Section>) <u8vector>
                      (get-blocklight~ section))
                    
                    (define (skylight-get section <World-Section>) <u8vector>
                      (get-skylight~ section))
                    
                    (define (local-block-ref i <fx> j <fx> k <fx>) <fx>
                      (u8vector-ref blocks (local-index i j k)))
                    
                    (define (local-data-ref i <fx> j <fx> k <fx>) <fx>
                      (u4vector-ref data (local-index i j k)))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (effective-data-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k data-get u4vector-ref 0 0))
                    
                    (define (effective-light-ref! i <fx> j <fx> k <fx> lighting <f32vector>) <void>
                      (unless (get-opaque-cube?~ (id->block (effective-block-ref i j k)))
                        (let ((index (effective-index i j k)))
                          (let ((value (u16vector-ref cache (+ index 1))))
                            (if (/= value cache-uninitialized)
                                (begin
                                  (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> value)))
                                  (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> (u16vector-ref cache (+ index 2)))))
                                  (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> (u16vector-ref cache (+ index 3)))))
                                  (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))
                              (let ((blocklight (field-ref i j k blocklight-get u4vector-ref 0 0))
                                    (skylight (field-ref i j k skylight-get u4vector-ref 15 15))
                                    (ambience (if (= (effective-block-ref i j k) air-id) 1 0)))
                                (u16vector-set! cache (+ index 1) blocklight)
                                (u16vector-set! cache (+ index 2) skylight)
                                (u16vector-set! cache (+ index 3) ambience)
                                (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> blocklight)))
                                (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> skylight)))
                                (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> ambience)))
                                (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.))))))))
                    
                    (define (inner-light-ref! i <fx> j <fx> k <fx> lighting <f32vector>) <void>
                      (unless (get-opaque-cube?~ (id->block (effective-block-ref i j k)))
                        (let ((index (effective-index i j k)))
                          (let ((value (u16vector-ref cache (+ index 1))))
                            (if (/= value cache-uninitialized)
                                (begin
                                  (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> value)))
                                  (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> (u16vector-ref cache (+ index 2)))))
                                  (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> (u16vector-ref cache (+ index 3)))))
                                  (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))
                              (let ((local-index (local-index i j k)))
                                (let ((blocklight (u4vector-ref blocklight local-index))
                                      (skylight (u4vector-ref skylight local-index))
                                      (ambience (if (= (u8vector-ref blocks local-index) air-id) 1 0)))
                                  (u16vector-set! cache (+ index 1) blocklight)
                                  (u16vector-set! cache (+ index 2) skylight)
                                  (u16vector-set! cache (+ index 3) ambience)
                                  (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> blocklight)))
                                  (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> skylight)))
                                  (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> ambience)))
                                  (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))))))))
                    
                    (define (u4vector-ref field <u8vector> index <fx>) <fx>
                      (let ((byte (u8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (local-index i j k)))))))
                          
                          (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                ((> k 15) (bind-k 1 (- k 16)))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j -1 (+ 16 j)))
                              ((> j 15) (bind-j 1 (- j 16)))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i -1 (+ 16 i)))
                            ((> i 15) (bind-i 1 (- i 16)))
                            (else (bind-i 0 i))))
                    
                    (define (add-template i j k x y z template <Lighted-Template> depth-offset <fx+> rendering <Rendering> category)
                      (let ((mesher <Lighted-Mesher> (get-mesher~ rendering))
                            (l1 (static (f32vector 0. 0. 0. 0.)))
                            (l2 (static (f32vector 0. 0. 0. 0.)))
                            (l3 (static (f32vector 0. 0. 0. 0.)))
                            (l4 (static (f32vector 0. 0. 0. 0.))))
                        (let ((inverse? (setup-lighting~ template i j k compute-lighting l1 l2 l3 l4)))
                          (add-template~ mesher x y z template depth-offset inverse?)
                          (add-lighting~ mesher template l1 l2 l3 l4 inverse?))
                        (when (and mesh-categories? (eq? category redstone))
                          (let ((mesher <Lighted-Mesher> (get-mesher~ redstone-rendering)))
                            (let ((inverse? (setup-lighting~ template i j k full-lighting l1 l2 l3 l4)))
                              (add-template~ mesher x y z template depth-offset inverse?)
                              (add-lighting~ mesher template l1 l2 l3 l4 inverse?))))))
                    
                    (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering <Rendering> category block-id <fx> add-template)
                      (let ((data-id (local-data-ref i j k)))
                        (let ((template (find-visual-template block-id data-id 0 #f)))
                          (let ((rendering (effective-rendering (effective-block-ref (- i 1) j k) rendering))) (when rendering (add-template i j k x y z (vector-ref template 0) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref (+ i 1) j k) rendering))) (when rendering (add-template i j k x y z (vector-ref template 1) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref i (- j 1) k) rendering))) (when rendering (add-template i j k x y z (vector-ref template 2) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref i (+ j 1) k) rendering))) (when rendering (add-template i j k x y z (vector-ref template 3) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref i j (- k 1)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 4) #f rendering category)))
                          (let ((rendering (effective-rendering (effective-block-ref i j (+ k 1)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 5) #f rendering category))))))
                    
                    (define (add-inner-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering <Rendering> category block-id <fx> add-template)
                      (let ((index (local-index i j k)))
                        (let ((data-id (u4vector-ref data index)))
                          (let ((template (find-visual-template block-id data-id 0 #f)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (- index   1)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 0) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (+ index   1)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 1) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (- index 256)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 2) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (+ index 256)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 3) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (- index  16)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 4) #f rendering category)))
                            (let ((rendering (effective-rendering (u8vector-ref blocks (+ index  16)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 5) #f rendering category)))))))
                    
                    (define (effective-rendering neighbor-id <fx> rendering <Rendering>)
                      (let ((neighbor (id->block neighbor-id)))
                        (cond ((get-opaque-cube?~ neighbor)
                               #f)
                              ((get-liquid-cube?~ neighbor)
                               wet-rendering)
                              (else
                               rendering))))
                    
                    (define (add-translucent-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering category block-id <fx> add-template)
                      (let ((data-id (local-data-ref i j k)))
                        (let ((template (find-visual-template block-id data-id 0 #f)))
                          (unless (translucent-translucent? block-id (effective-block-ref (- i 1) j k)) (add-template i j k x y z (vector-ref template 0) #f rendering category))
                          (unless (translucent-opaque?      block-id (effective-block-ref (+ i 1) j k)) (add-template i j k x y z (vector-ref template 1) #f rendering category))
                          (unless (translucent-translucent? block-id (effective-block-ref i (- j 1) k)) (add-template i j k x y z (vector-ref template 2) #f rendering category))
                          (unless (translucent-opaque?      block-id (effective-block-ref i (+ j 1) k)) (add-template i j k x y z (vector-ref template 3) #f rendering category))
                          (unless (translucent-translucent? block-id (effective-block-ref i j (- k 1))) (add-template i j k x y z (vector-ref template 4) #f rendering category))
                          (unless (translucent-opaque?      block-id (effective-block-ref i j (+ k 1))) (add-template i j k x y z (vector-ref template 5) #f rendering category)))))
                    
                    (define (add-inner-translucent-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering category block-id <fx> add-template)
                      (let ((index (local-index i j k)))
                        (let ((data-id (u4vector-ref data index)))
                          (let ((template (find-visual-template block-id data-id 0 #f)))
                            (unless (translucent-translucent? block-id (u8vector-ref blocks (- index   1))) (add-template i j k x y z (vector-ref template 0) #f rendering category))
                            (unless (translucent-opaque?      block-id (u8vector-ref blocks (+ index   1))) (add-template i j k x y z (vector-ref template 1) #f rendering category))
                            (unless (translucent-translucent? block-id (u8vector-ref blocks (- index 256))) (add-template i j k x y z (vector-ref template 2) #f rendering category))
                            (unless (translucent-opaque?      block-id (u8vector-ref blocks (+ index 256))) (add-template i j k x y z (vector-ref template 3) #f rendering category))
                            (unless (translucent-translucent? block-id (u8vector-ref blocks (- index  16))) (add-template i j k x y z (vector-ref template 4) #f rendering category))
                            (unless (translucent-opaque?      block-id (u8vector-ref blocks (+ index  16))) (add-template i j k x y z (vector-ref template 5) #f rendering category))))))
                    
                    (define (translucent-opaque? block-id <fx> neighbor-id <fx>)
                      (or (= block-id neighbor-id)
                          (get-opaque-cube?~ (id->block neighbor-id))))
                    
                    (define (translucent-translucent? block-id <fx> neighbor-id <fx>)
                      (get-opaque-cube?~ (id->block neighbor-id)))
                    
                    (define (add-liquid-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering category template <vector> add-template)
                      (unless (liquid-opaque? (effective-block-ref (- i 1) j k)) (add-template i j k x y z (vector-ref template 0) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref (+ i 1) j k)) (add-template i j k x y z (vector-ref template 1) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref i (- j 1) k)) (add-template i j k x y z (vector-ref template 2) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref i (+ j 1) k)) (add-template i j k x y z (vector-ref template 3) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref i j (- k 1))) (add-template i j k x y z (vector-ref template 4) #f rendering category))
                      (unless (liquid-opaque? (effective-block-ref i j (+ k 1))) (add-template i j k x y z (vector-ref template 5) #f rendering category)))
                    
                    (define (add-inner-liquid-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> rendering category template <vector> add-template)
                      (let ((index (local-index i j k)))
                        (unless (liquid-opaque? (u8vector-ref blocks (- index   1))) (add-template i j k x y z (vector-ref template 0) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (+ index   1))) (add-template i j k x y z (vector-ref template 1) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (- index 256))) (add-template i j k x y z (vector-ref template 2) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (+ index 256))) (add-template i j k x y z (vector-ref template 3) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (- index  16))) (add-template i j k x y z (vector-ref template 4) #f rendering category))
                        (unless (liquid-opaque? (u8vector-ref blocks (+ index  16))) (add-template i j k x y z (vector-ref template 5) #f rendering category))))
                    
                    (define (liquid-opaque? neighbor-id <fx>)
                      (let ((neighbor (id->block neighbor-id)))
                        (or (get-liquid-cube?~ neighbor)
                            (get-opaque-cube?~ neighbor))))
                    
                    (define (compute-lighting lighting <f32vector> i <fx> j <fx> k <fx> t <Light-Template>)
                      (let ((shade (get-shade~ t))
                            (s1 (get-s1~ t))
                            (s2 (get-s2~ t))
                            (s3 (get-s3~ t))
                            (s4 (get-s4~ t)))
                        (f32vector-set! lighting 0 0.)
                        (f32vector-set! lighting 1 0.)
                        (f32vector-set! lighting 2 0.)
                        (f32vector-set! lighting 3 0.)
                        (effective-light-ref! (+ i (s8vector-ref s1 0)) (+ j (s8vector-ref s1 1)) (+ k (s8vector-ref s1 2)) lighting)
                        (effective-light-ref! (+ i (s8vector-ref s2 0)) (+ j (s8vector-ref s2 1)) (+ k (s8vector-ref s2 2)) lighting)
                        (effective-light-ref! (+ i (s8vector-ref s3 0)) (+ j (s8vector-ref s3 1)) (+ k (s8vector-ref s3 2)) lighting)
                        (effective-light-ref! (+ i (s8vector-ref s4 0)) (+ j (s8vector-ref s4 1)) (+ k (s8vector-ref s4 2)) lighting)
                        (adjust-lighting lighting 0 shade)
                        (adjust-lighting lighting 1 shade)
                        lighting))
                    
                    (define (full-lighting lighting <f32vector> i <fx> j <fx> k <fx> t <Light-Template>)
                      (f32vector-set! lighting 0 60.)
                      (f32vector-set! lighting 1 60.)
                      (f32vector-set! lighting 2 15.)
                      (f32vector-set! lighting 3 1.))
                    
                    (define (add-texture-element proc)
                      (proc section texture-element-adder))
                    
                    (define (texture-element-adder element)
                      (set! texture-elements (cons element texture-elements)))
                    
                    (reset-mesher~ opaque-rendering)
                    (reset-mesher~ transparent-rendering)
                    (reset-mesher~ coverage-rendering)
                    (reset-mesher~ water-rendering)
                    (reset-mesher~ wet-rendering)
                    (reset-mesher~ multitexture-rendering)
                    (when mesh-categories?
                      (reset-mesher~ redstone-rendering))
                    
                    ;; inner
                    (loop (for j from 1 below 15)
                          (loop (for k from 1 below 15)
                                (loop (for i from 1 below 15)
                                      (let ((block-id (local-block-ref i j k))
                                            (data-id (local-data-ref i j k)))
                                        (when (/= block-id air-id)
                                          (let ((block (id/data-id->block block-id data-id)))
                                            (let ((x (fl& (+ block-radius (cast <fl> i))))
                                                  (y (fl& (+ block-radius (cast <fl> j))))
                                                  (z (fl& (+ block-radius (cast <fl> k))))
                                                  (rendering <Rendering> (cache-rendering~ block))
                                                  (category (get-category~ block)))
                                              (let ((visual (get-visual~ block)))
                                                (cond (visual
                                                       (visual block-id data-id i j k x y z rendering category add-template add-inner-opaque-cube add-inner-translucent-cube add-inner-liquid-cube add-texture-element effective-block-ref effective-data-ref))
                                                      ((get-opaque-cube?~ block)
                                                       (add-inner-opaque-cube i j k x y z rendering category block-id add-template))
                                                      ((get-translucent-cube?~ block)
                                                       (add-inner-translucent-cube i j k x y z rendering category block-id add-template))
                                                      (else
                                                       (add-visual-template block-id data-id 0 i j k x y z #f rendering category add-template effective-block-ref effective-data-ref)))))))))))
                    
                    ;; outer
                    (let ()
                      (define (add i <fx> j <fx> k <fx>)
                        (let ((block-id (local-block-ref i j k))
                              (data-id (local-data-ref i j k)))
                          (when (/= block-id air-id)
                            (let ((block (id/data-id->block block-id data-id)))
                              (let ((x (fl& (+ block-radius (cast <fl> i))))
                                    (y (fl& (+ block-radius (cast <fl> j))))
                                    (z (fl& (+ block-radius (cast <fl> k))))
                                    (rendering <Rendering> (cache-rendering~ block))
                                    (category (get-category~ block)))
                                (let ((visual (get-visual~ block)))
                                  (cond (visual
                                         (visual block-id data-id i j k x y z rendering category add-template add-opaque-cube add-translucent-cube add-liquid-cube add-texture-element effective-block-ref effective-data-ref))
                                        ((get-opaque-cube?~ block)
                                         (add-opaque-cube i j k x y z rendering category block-id add-template))
                                        ((get-translucent-cube?~ block)
                                         (add-translucent-cube i j k x y z rendering category block-id add-template))
                                        (else
                                         (add-visual-template block-id data-id 0 i j k x y z #f rendering category add-template effective-block-ref effective-data-ref)))))))))
                      
                      ;; left
                      (let ((i 0))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; right
                      (let ((i 15))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; bottom
                      (let ((j 0))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; top
                      (let ((j 15))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; back
                      (let ((k 0))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k))))
                      ;; front
                      (let ((k 15))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k)))))
                    
                    (with-render-mutex
                      (lambda ()
                        (define (prepare-mesh)
                          (let ((mesher (get-mesher~ opaque-rendering)))
                            (let ((triangles (get-used~ mesher)))
                              (when (> triangles 0)
                                (setup-mesh~ sector)
                                (let ((mesh (get-mesh~ sector)))
                                  (allege mesh
                                    (fill-vertices/neighbors~ sector mesh triangles (get-content~ mesher) (get-neighbors~ mesher))
                                    (fill-lightmap~ sector mesh triangles (get-lightmap~ mesher))
                                    (setup-array~ mesh)))))))
                        
                        (define (prepare-other-meshes)
                          (let ((renderings (other-renderings))
                                (count 0))
                            (for-each (lambda (rendering <Rendering>)
                                        (when (> (get-used~ (get-mesher~ rendering)) 0)
                                          (increase! count)))
                                      renderings)
                            (when (> count 0)
                              (let ((meshes (make-vector count))
                                    (rank 0))
                                (loop (for rendering <Rendering> in renderings)
                                      (let ((material (get-material~ rendering))
                                            (mesher (get-mesher~ rendering)))
                                        (let ((triangles (get-used~ mesher)))
                                          (when (> (get-used~ mesher) 0)
                                            (let ((mesh (new Mesh material: material)))
                                              (vector-set! meshes rank mesh)
                                              (fill-vertices/neighbors~ sector mesh triangles (get-content~ mesher) (get-neighbors~ mesher))
                                              (fill-lightmap~ sector mesh triangles (get-lightmap~ mesher))
                                              (setup-array~ mesh)
                                              (increase! rank))))))
                                (setup-other-meshes~ sector meshes)))))
                        
                        (define (prepare-redstone-mesh)
                          (let ((material (get-material~ redstone-rendering))
                                (mesher (get-mesher~ redstone-rendering)))
                            (let ((triangles (get-used~ mesher)))
                              (when (> triangles 0)
                                (let ((mesh (new Mesh material: material)))
                                  (setup-categorized-mesh~ sector mesh)
                                  (fill-vertices/neighbors~ sector mesh triangles (get-content~ mesher) (get-neighbors~ mesher))
                                  (fill-lightmap~ sector mesh triangles (get-lightmap~ mesher))
                                  (setup-array~ mesh))))))
                        
                        (when (eq? zone (current-zone))
                          (free-mesh~ sector)
                          (set-section~ sector section)
                          (prepare-mesh)
                          (prepare-other-meshes)
                          (when mesh-categories?
                            (prepare-redstone-mesh))
                          (set-texture-elements~ sector texture-elements)
                          (generate-done))))))))))))))


(class Light-Template extends Object
  
  
  (slot shade <fl>       getter generate)
  (slot s1    <s8vector> getter generate)
  (slot s2    <s8vector> getter generate)
  (slot s3    <s8vector> getter generate)
  (slot s4    <s8vector> getter generate)
  
  
  (method override (initialize shade s1 s2 s3 s4)
    (set! shade~self shade)
    (set! s1~self s1)
    (set! s2~self s2)
    (set! s3~self s3)
    (set! s4~self s4)))


(definition (allocate-light-template shade s1 s2 s3 s4)
  (allocate Light-Template shade s1 s2 s3 s4))


(class Lighted-Template extends Face-Template
  
  
  (method protected virtual (setup-lighting l1 l2 l3 l4)
    )
  
  
  (method protected virtual (iterate-lighting mesher l1 l2 l3 l4 inverse? proc)
    ))


(class Triangle-Template extends Lighted-Template
  
  
  (slot t1 getter generate)
  (slot t2 getter generate)
  (slot t3 getter generate)
  
  
  (method override (initialize texture-coordinates <f32vector> texture-depth triangle <Triangle> t1 t2 t3)
    (nextmethod texture-coordinates texture-depth triangle)
    (set! t1~self t1)
    (set! t2~self t2)
    (set! t3~self t3))
  
  
  (method override (setup-lighting i j k compute-lighting l1 <f32vector> l2 <f32vector> l3 <f32vector> l4 <f32vector>)
    (compute-lighting l1 i j k t1)
    (compute-lighting l2 i j k t2)
    (compute-lighting l3 i j k t3)
    #f)
  
  
  (method override (iterate-lighting mesher l1 l2 l3 l4 inverse? proc)
    (proc mesher l1 l2 l3)))


(class Quad-Template extends Lighted-Template
  
  
  (slot t1 getter generate)
  (slot t2 getter generate)
  (slot t3 getter generate)
  (slot t4 getter generate)
  
  
  (method override (initialize texture-coordinates <f32vector> texture-depth quad <Quad> t1 t2 t3 t4)
    (nextmethod texture-coordinates texture-depth quad)
    (set! t1~self t1)
    (set! t2~self t2)
    (set! t3~self t3)
    (set! t4~self t4))
  
  
  (method override (setup-lighting i j k compute-lighting l1 <f32vector> l2 <f32vector> l3 <f32vector> l4 <f32vector>)
    (compute-lighting l1 i j k t1)
    (compute-lighting l2 i j k t2)
    (compute-lighting l3 i j k t3)
    (compute-lighting l4 i j k t4)
    ;; inversing the quad solves lighting anisotropy
    (let ((a00 (max (f32vector-ref l1 0) (f32vector-ref l1 1)))
          (a01 (max (f32vector-ref l2 0) (f32vector-ref l2 1)))
          (a11 (max (f32vector-ref l3 0) (f32vector-ref l3 1)))
          (a10 (max (f32vector-ref l4 0) (f32vector-ref l4 1))))
      (< (+ a00 a11) (+ a01 a10))))
  
  
  (method override (iterate-lighting mesher l1 l2 l3 l4 inverse? proc)
    (cond ((not inverse?)
           (proc mesher l1 l2 l3)
           (proc mesher l3 l4 l1))
          (else
           (proc mesher l4 l1 l2)
           (proc mesher l2 l3 l4)))))


(definition protected (dynamic-visual-template block <Block> data-id <fx> i <fx> j <fx> k <fx> block-ref data-ref proc)
  (let ((block-id (get-id~ block))
        (variant-id (or (get-variant-id~ block) -1))
        (category (get-category~ block))
        (uv (block-texture-coordinates block))
        (generate (get-generate~ block))
        (rendering <Rendering> (cache-rendering~ block))
        (transparent-rendering (transparent-rendering)))
    (define (add-face template <Face-Template> rendering <Rendering> category)
      (proc template))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      (allocate-light-template shade
                               (s8vector ax ay az)
                               (s8vector bx by bz)
                               (s8vector cx cy cz)
                               (s8vector dx dy dz)))
    
    (generate 'visual block-id variant-id data-id -1 i j k 0. 0. 0. uv lighting rendering category add-face #f block-ref data-ref)))


(definition protected (create-visual-template block <Block> data-id <fx> config-id <fx> generate)
  (let ((templates (new-queue))
        (block-id (get-id~ block))
        (variant-id (or (get-variant-id~ block) -1))
        (category (get-category~ block))
        (uv <f32vector> (block-texture-coordinates block))
        (generate (or generate (get-generate~ block)))
        (rendering <Rendering> (cache-rendering~ block))
        (transparent-rendering (transparent-rendering)))
    (define (block-ref i <fx> j <fx> k <fx>) <fx>
      air-id)
    
    (define (data-ref i <fx> j <fx> k <fx>) <fx>
      0)
    
    (define (add-face template <Face-Template> rendering <Rendering> category)
      (enqueue templates template))
    
    (define (add-cube what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id variant-id add-face)
      (add-face (left-side   what i j k x y z left-uv lighting rendering block-id variant-id) rendering category)
      (add-face (right-side  what i j k x y z right-uv lighting rendering block-id variant-id) rendering category)
      (add-face (bottom-side what i j k x y z bottom-uv lighting rendering block-id variant-id) rendering category)
      (add-face (top-side    what i j k x y z top-uv lighting rendering block-id variant-id) rendering category)
      (add-face (back-side   what i j k x y z back-uv lighting rendering block-id variant-id) rendering category)
      (add-face (front-side  what i j k x y z front-uv lighting rendering block-id variant-id) rendering category))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      (allocate-light-template shade
                               (s8vector ax ay az)
                               (s8vector bx by bz)
                               (s8vector cx cy cz)
                               (s8vector dx dy dz)))
    
    (cond (generate
           (generate 'visual block-id variant-id data-id config-id 0 0 0 0. 0. 0. uv lighting rendering category add-face add-cube block-ref data-ref))
          ((or (get-opaque-cube?~ block)
               (get-translucent-cube?~ block))
           (add-cube 'visual 0 0 0 0. 0. 0. uv uv uv uv uv uv lighting rendering category block-id variant-id add-face))
          (else
           (add-cross-faces 'visual 0 0 0 0. 0. 0. uv lighting transparent-rendering category block-id variant-id add-face)))
    (list->vector (queue-list templates))))


(definition protected (find-visual-template block-id <fx> data-id <fx> config-id <fx> generate) <vector>
  (let ((block (id/data-id->block block-id data-id)))
    (let ((templates (get-visuals~ block)))
      (if (not templates)
          (let ((template (create-visual-template block data-id config-id generate))
                (templates (make-vector (get-configurations~ block) #f)))
            (vector-set! templates config-id template)
            (set-visuals~ block templates)
            template)
        (or (vector-ref templates config-id)
            (let ((template (create-visual-template block data-id config-id generate)))
              (vector-set! templates config-id template)
              template))))))


(definition protected (add-visual-template block-id <fx> data-id <fx> config-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> depth-offset <fx+> rendering category add-template block-ref data-ref)
  (let ((template (find-visual-template block-id data-id config-id #f)))
    (loop (for template in-vector template)
          (add-template i j k x y z template depth-offset rendering category))))


;;;
;;;; Physical
;;;


(definition protected (instantiate-physical area <Area> revision-update?)
  (let ((zone (current-zone)))
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((area-index (get-index~ area)))
      (let ((area-x (index-x area-index))
            (area-y (index-y area-index))
            (area-z (index-z area-index)))
        (let ((section (index-section~ zone (indexed& area-x area-y area-z))))
          (if (not section)
              (when revision-update?
                (clear-polygons~ area))
            (let ((region (get-region~ (cast <World-Chunk> (get-chunk~ section))))
                  (chunk-x (section->chunk area-x))
                  (chunk-z (section->chunk area-z))
                  (truncate-y (get-truncate-y~ zone))
                  (cache-uninitialized 65535)
                  (sections (neighbor-sections section area-x area-y area-z)))
              (with-generate-mutex
                (lambda ()
                  (let ((bottom-section? (= area-y (cast <fx> (or truncate-y 0))))
                        (section-x (+ (* (get-x~ region) 32 16) (* chunk-x 16)))
                        (section-y (* area-y 16))
                        (section-z (+ (* (get-z~ region) 32 16) (* chunk-z 16)))
                        (cache <u16vector> (initialize-block-cache block-cache cache-uninitialized))
                        (blocks <u8vector> (get-blocks~ section))
                        (data <u8vector> (get-data~ section))
                        (areas (make-table test: equal?))
                        (area-position (get-position&~ area)))
                    (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                      (vector-ref sections (section-index a b c)))
                    
                    (define (section-index a <fx> b <fx> c <fx>) <fx>
                      (+ (* b 9) (* c 3) a 13))
                    
                    (define (local-index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (effective-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* j 400) (* k 20) i 842) 4))
                    
                    (define (blocks-get section <World-Section>) <u8vector>
                      (get-blocks~ section))
                    
                    (define (data-get section <World-Section>) <u8vector>
                      (get-data~ section))
                    
                    (define (local-block-ref i <fx> j <fx> k <fx>) <fx>
                      (u8vector-ref blocks (local-index i j k)))
                    
                    (define (local-data-ref i <fx> j <fx> k <fx>) <fx>
                      (u4vector-ref data (local-index i j k)))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (effective-data-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k data-get u4vector-ref 0 0))
                    
                    (define (u4vector-ref field <u8vector> index <fx>) <fx>
                      (let ((byte (u8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (local-index i j k)))))))
                          
                          (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                ((> k 15) (bind-k 1 (- k 16)))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j -1 (+ 16 j)))
                              ((> j 15) (bind-j 1 (- j 16)))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i -1 (+ 16 i)))
                            ((> i 15) (bind-i 1 (- i 16)))
                            (else (bind-i 0 i))))
                    
                    (define (add-template x <fl> y <fl> z <fl> poly <Polygon>)
                      (let ((center (vertex+xyz& (get-center~ poly) x y z)))
                        (let ((index (position-index~ area (vertex-& center area-position))))
                          ;; quicky for tests
                          (let ((poly (copy-polygon~ poly)))
                            (vertex+xyz! (get-origin~ poly) (get-origin~ poly) x y z)
                            (loop (for vert in-vector (get-vertices~ poly))
                                  (vertex+xyz! vert vert x y z))
                            (set-data2~ poly (+ (get-data2~ poly) x))
                            (set-data3~ poly (+ (get-data3~ poly) y))
                            (set-data4~ poly (+ (get-data4~ poly) z))
                            (table-add areas index poly)))))
                    
                    (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-id <fx> add-template)
                      (let ((data-id (local-data-ref i j k)))
                        (let ((template (find-physical-template block-id data-id 0 #f)))
                          (unless (opaque? (effective-block-ref (- i 1) j k)) (add-template x y z (vector-ref template 0)))
                          (unless (opaque? (effective-block-ref (+ i 1) j k)) (add-template x y z (vector-ref template 1)))
                          (unless (opaque? (effective-block-ref i (- j 1) k)) (add-template x y z (vector-ref template 2)))
                          (unless (opaque? (effective-block-ref i (+ j 1) k)) (add-template x y z (vector-ref template 3)))
                          (unless (opaque? (effective-block-ref i j (- k 1))) (add-template x y z (vector-ref template 4)))
                          (unless (opaque? (effective-block-ref i j (+ k 1))) (add-template x y z (vector-ref template 5))))))
                    
                    (define (add-inner-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-id <fx> add-template)
                      (let ((data-id (local-data-ref i j k)))
                        (let ((template (find-physical-template block-id data-id 0 #f)))
                          (unless (opaque? (local-block-ref (- i 1) j k)) (add-template x y z (vector-ref template 0)))
                          (unless (opaque? (local-block-ref (+ i 1) j k)) (add-template x y z (vector-ref template 1)))
                          (unless (opaque? (local-block-ref i (- j 1) k)) (add-template x y z (vector-ref template 2)))
                          (unless (opaque? (local-block-ref i (+ j 1) k)) (add-template x y z (vector-ref template 3)))
                          (unless (opaque? (local-block-ref i j (- k 1))) (add-template x y z (vector-ref template 4)))
                          (unless (opaque? (local-block-ref i j (+ k 1))) (add-template x y z (vector-ref template 5))))))
                    
                    (define (opaque? block-id <fx>)
                      (let ((block (id->block block-id)))
                        (get-opaque-cube?~ block)))
                    
                    (define (add-liquid-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> template <vector> add-template)
                      (unless (liquid-opaque? (effective-block-ref (- i 1) j k)) (add-template x y z (vector-ref template 0)))
                      (unless (liquid-opaque? (effective-block-ref (+ i 1) j k)) (add-template x y z (vector-ref template 1)))
                      (unless (liquid-opaque? (effective-block-ref i (- j 1) k)) (add-template x y z (vector-ref template 2)))
                      (unless (liquid-opaque? (effective-block-ref i (+ j 1) k)) (add-template x y z (vector-ref template 3)))
                      (unless (liquid-opaque? (effective-block-ref i j (- k 1))) (add-template x y z (vector-ref template 4)))
                      (unless (liquid-opaque? (effective-block-ref i j (+ k 1))) (add-template x y z (vector-ref template 5))))
                    
                    (define (add-inner-liquid-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> template <vector> add-template)
                      (unless (liquid-opaque? (local-block-ref (- i 1) j k)) (add-template x y z (vector-ref template 0)))
                      (unless (liquid-opaque? (local-block-ref (+ i 1) j k)) (add-template x y z (vector-ref template 1)))
                      (unless (liquid-opaque? (local-block-ref i (- j 1) k)) (add-template x y z (vector-ref template 2)))
                      (unless (liquid-opaque? (local-block-ref i (+ j 1) k)) (add-template x y z (vector-ref template 3)))
                      (unless (liquid-opaque? (local-block-ref i j (- k 1))) (add-template x y z (vector-ref template 4)))
                      (unless (liquid-opaque? (local-block-ref i j (+ k 1))) (add-template x y z (vector-ref template 5))))
                    
                    (define (liquid-opaque? neighbor-id <fx>)
                      (let ((neighbor (id->block neighbor-id)))
                        (or (get-liquid-cube?~ neighbor)
                            (get-opaque-cube?~ neighbor))))
                    
                    ;; inner
                    (loop (for j from 1 below 15)
                          (loop (for k from 1 below 15)
                                (loop (for i from 1 below 15)
                                      (let ((block-id (local-block-ref i j k))
                                            (data-id (local-data-ref i j k)))
                                        (when (/= block-id air-id)
                                          (let ((x (+ section-x i))
                                                (y (+ section-y j))
                                                (z (+ section-z k))
                                                (block (id/data-id->block block-id data-id)))
                                            (let ((x (fl& (+ block-radius (cast <fl> x))))
                                                  (y (fl& (+ block-radius (cast <fl> y))))
                                                  (z (fl& (+ block-radius (cast <fl> z)))))
                                              (let ((physical (get-physical~ block)))
                                                (cond (physical
                                                       (physical block-id data-id i j k x y z add-template add-inner-liquid-cube effective-block-ref effective-data-ref))
                                                      ((get-opaque-cube?~ block)
                                                       (add-inner-opaque-cube i j k x y z block-id add-template))
                                                      (else
                                                       (add-physical-template block-id data-id 0 i j k x y z add-template effective-block-ref effective-data-ref)))))))))))
                    
                    ;; outer
                    (let ()
                      (define (add i <fx> j <fx> k <fx>)
                        (let ((block-id (local-block-ref i j k))
                              (data-id (local-data-ref i j k)))
                          (when (/= block-id air-id)
                            (let ((x (+ section-x i))
                                  (y (+ section-y j))
                                  (z (+ section-z k))
                                  (block (id/data-id->block block-id data-id)))
                              (let ((x (fl& (+ block-radius (cast <fl> x))))
                                    (y (fl& (+ block-radius (cast <fl> y))))
                                    (z (fl& (+ block-radius (cast <fl> z)))))
                                (let ((physical (get-physical~ block)))
                                  (cond (physical
                                         (physical block-id data-id i j k x y z add-template add-liquid-cube effective-block-ref effective-data-ref))
                                        ((get-opaque-cube?~ block)
                                         (add-opaque-cube i j k x y z block-id add-template))
                                        (else
                                         (add-physical-template block-id data-id 0 i j k x y z add-template effective-block-ref effective-data-ref)))))))))
                      
                      ;; left
                      (let ((i 0))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; right
                      (let ((i 15))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; bottom
                      (let ((j 0))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; top
                      (let ((j 15))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; back
                      (let ((k 0))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k))))
                      ;; front
                      (let ((k 15))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k)))))
                    (when (eq? zone (current-zone))
                      (iterate-table areas
                        (lambda (index polygons)
                          (add-polygons~ area #f index polygons #f))))))))))))))


(definition protected (dynamic-physical-template block <Block> data-id <fx> i <fx> j <fx> k <fx> block-ref data-ref proc)
  (let ((block-id (get-id~ block))
        (variant-id (or (get-variant-id~ block) -1))
        (category (get-category~ block))
        (uv dummy-uv)
        (generate (get-generate~ block))
        (rendering dummy-rendering))
    (define (add-face polygon <Polygon> rendering <Rendering> category)
      (proc polygon))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      #f)
    
    (generate 'physical block-id variant-id data-id -1 0 0 0 0. 0. 0. uv lighting rendering category add-face #f block-ref data-ref)))


(definition protected (create-physical-template block <Block> data-id <fx> config-id <fx> generate)
  (let ((polygons (new-queue))
        (block-id (get-id~ block))
        (variant-id (or (get-variant-id~ block) -1))
        (category (get-category~ block))
        (uv dummy-uv)
        (generate (or generate (get-generate~ block)))
        (rendering dummy-rendering)
        (transparent-rendering dummy-rendering))
    (define (block-ref i <fx> j <fx> k <fx>) <fx>
      air-id)
    
    (define (data-ref i <fx> j <fx> k <fx>) <fx>
      0)
    
    (define (add-face polygon <Polygon> rendering <Rendering> category)
      (enqueue polygons polygon))
    
    (define (add-cube what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id variant-id add-face)
      (add-face (left-side   what i j k x y z left-uv lighting rendering block-id variant-id) rendering category)
      (add-face (right-side  what i j k x y z right-uv lighting rendering block-id variant-id) rendering category)
      (add-face (bottom-side what i j k x y z bottom-uv lighting rendering block-id variant-id) rendering category)
      (add-face (top-side    what i j k x y z top-uv lighting rendering block-id variant-id) rendering category)
      (add-face (back-side   what i j k x y z back-uv lighting rendering block-id variant-id) rendering category)
      (add-face (front-side  what i j k x y z front-uv lighting rendering block-id variant-id) rendering category))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      #f)
    
    (cond (generate
           (generate 'physical block-id variant-id data-id config-id 0 0 0 0. 0. 0. uv lighting rendering category add-face add-cube block-ref data-ref))
          ((or (get-opaque-cube?~ block)
               (get-translucent-cube?~ block))
           (add-cube 'physical 0 0 0 0. 0. 0. uv uv uv uv uv uv lighting rendering category block-id variant-id add-face))
          (else
           (add-cross-faces 'physical 0 0 0 0. 0. 0. uv lighting transparent-rendering category block-id variant-id add-face)))
    (list->vector (queue-list polygons))))


(definition protected (find-physical-template block-id <fx> data-id <fx> config-id <fx> generate) <vector>
  (let ((block (id/data-id->block block-id data-id)))
    (let ((templates (get-physicals~ block)))
      (if (not templates)
          (let ((template (create-physical-template block data-id config-id generate))
                (templates (make-vector (get-configurations~ block) #f)))
            (vector-set! templates config-id template)
            (set-physicals~ block templates)
            template)
        (or (vector-ref templates config-id)
            (let ((template (create-physical-template block data-id config-id generate)))
              (vector-set! templates config-id template)
              template))))))


(definition protected (add-physical-template block-id <fx> data-id <fx> config-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
  (let ((polygons (find-physical-template block-id data-id config-id #f)))
    (loop (for poly in-vector polygons)
          (add-template x y z poly))))


;;;
;;;; Coordinates
;;;


(definition protected (index->coordinates index <fx>) <index>
  (let ((i (modulo index 16))
        (k (modulo (quotient index 16) 16))
        (j (modulo (quotient (quotient index 16) 16) 16)))
    (indexed i j k)))


(definition protected (section/coordinates->location section <World-Section> coord <index>) <index>
  (let ((index (get-index~ section)))
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (indexed (+ (index-x coord) (* section-x 16))
               (+ (index-y coord) (* section-y 16))
               (+ (index-z coord) (* section-z 16))))))


(definition protected (location->section/coordinates location <index>)
  (let ((zone (current-zone)))
    (let ((i (index-x location))
          (j (index-y location))
          (k (index-z location)))
      (let ((section (index-section~ zone (indexed& (fxfloor/ i 16) (fxfloor/ j 16) (fxfloor/ k 16)))))
        (if section
            (values section (indexed (modulo i 16) (modulo j 16) (modulo k 16)))
          (values #f #f))))))


(definition protected (section/index->position section <World-Section> index <fx>) <vertex>
  (let ((coord (index->coordinates index)))
    (let ((location (section/coordinates->location section coord)))
      (let ((x (index-x location))
            (y (index-y location))
            (z (index-z location)))
        (vertex (+ (cast <fl> x) .5)
                (+ (cast <fl> y) .5)
                (+ (cast <fl> z) .5))))))


(definition protected (normalize-section/coordinates section i <fx> j <fx> k <fx> with-field proc)
  (if (and (between? i 0 15)
           (between? j 0 15)
           (between? k 0 15))
      (proc section i j k)
    (with-field i j k
      (lambda (section index)
        (bind-index (i j k) (index->coordinates index)
          (proc section i j k))))))


(definition protected (enqueue-section/coordinates queue section coordinates with-field)
  (assert section) ; tracking a bug
  (bind-index (i j k) coordinates
    (normalize-section/coordinates section i j k with-field
      (lambda (section i j k)
        (enqueue queue (cons section (indexed i j k)))))))


(definition protected (taxicab-distance section1 <World-Section> section2 <World-Section>)
  (let ((index1 (get-index~ section1))
        (index2 (get-index~ section2)))
    (+ (abs (- (index-x index1) (index-x index2)))
       (abs (- (index-y index1) (index-y index2)))
       (abs (- (index-z index1) (index-z index2))))))


(definition protected (block-entity-data section <World-Section> coordinates <index>)
  (let ((chunk <World-Chunk> (get-chunk~ section))
        (index (section/coordinates->location section coordinates)))
    (find-block-entity~ chunk index)))


(definition protected (block-entity-add section <World-Section> coordinates <index>)
  (let ((chunk <World-Chunk> (get-chunk~ section))
        (index (section/coordinates->location section coordinates)))
    (add-block-entity~ chunk index)))


;;;
;;;; Components
;;;


(definition protected (new-repeater section i j k delay power? with-field)
  (normalize-section/coordinates section i j k with-field
    (lambda (section i j k)
      (new Repeater section i j k delay power?))))


(definition protected (new-plate section i j k delay actor with-field)
  (normalize-section/coordinates section i j k with-field
    (lambda (section i j k)
      (new Plate section i j k delay actor))))


(class Redstone-Component extends Object
  
  
  (slot section getter generate)
  (slot i       getter generate)
  (slot j       getter generate)
  (slot k       getter generate)
  (slot delay   accessors generate)
  
  
  (method override (initialize section i j k delay)
    (set! section~self section)
    (set! i~self i)
    (set! j~self j)
    (set! k~self k)
    (set! delay~self delay))
  
  (method (location)
    (list section i j k)))


;;;
;;;; Plate
;;;


(class Plate extends Redstone-Component
  
  
  (slot colliders accessors generate)
  
  
  (method override (initialize section i j k delay actor)
    (nextmethod section i j k delay)
    (set! colliders~self (cons actor '()))))


;;;
;;;; Repeater
;;;


(class Repeater extends Redstone-Component
  
  
  (slot power? accessors generate)
  
  
  (method override (initialize section i j k delay power?)
    (nextmethod section i j k delay)
    (set! power?~self power?)))


;;;
;;;; Burnout
;;;


@code-to-implement-redstone-torch-burnout (
(class Powerer extends Object
  
  
  (slot i    getter generate)
  (slot j    getter generate)
  (slot time getter generate)
  
  
  (method override (initialize i j time)
    (set! i~self i)
    (set! j~self j)
    (set! time~self time)))


(define burnout-delay
  3)


(define last-torches
  (list #f))


(define (add-torch powerer)
  (set-cdr! last-torches (cons powerer (cdr last-torches))))


(define (count-powerings i j time)
  (define (powering? powerer)
    (and (= (get-i~ powerer) i)
         (= (get-j~ powerer) j)))
  
  (define (past-delay? powerer)
    (> (- time (get-time~ powerer)) burnout-delay))
  
  (let (iter (scan last-torches) (count 0))
    (let ((torches (cdr scan)))
      (if (null? torches)
          count
        (let ((torch (car torches)))
          (if (past-delay? torch)
              (begin
                (set-cdr! scan '())
                count)
            (iter (cdr scan) (if (powering? torch) (+ count 1) count))))))))


(add-torch (new Powerer 1 2 10)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 10)         (debug 'count (length (cdr last-torches)))
(add-torch (new Powerer 1 2 11)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 11)         (debug 'count (length (cdr last-torches)))
(add-torch (new Powerer 1 2 14)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 14)         (debug 'count (length (cdr last-torches)))
(count-powerings 1 2 20)         (debug 'count (length (cdr last-torches))))


;;;
;;;; Actions
;;;


(definition protected block-hook
  #f)


(definition public (register-block-hook hook)
  (set! block-hook hook))


(definition public (invoke-block-hook pos)
  (when block-hook
    (block-hook pos)))


(definition protected block-actions <table>
  (make-table test: equal?))

;; sejour quick hack to think through
(definition protected (reset-block-actions)
  (set! block-actions (make-table test: equal?)))


(definition public (registered-block-action pos event)
  (table-ref block-actions (cons pos event) #f))


(definition public (register-block-action pos event action)
  (table-set! block-actions (cons pos event) action))


(definition public (register-blocks-action lst event action)
  (for-each (lambda (pos)
              (register-block-action pos event action))
            lst))


(definition public (invoke-block-action pos event)
  (let ((action (registered-block-action pos event)))
    (when action
      (action)
      #t)))


;;;
;;;; Add
;;;


(definition (make-quad-face what rendering <Rendering> texture-coordinates texture-depth quad l1 l2 l3 l4)
  (case what
    ((physical)
     quad)
    ((visual)
     (new Quad-Template texture-coordinates texture-depth quad l1 l2 l3 l4))
    (else
     (new Quad-Face (get-entity-material~ rendering) texture-coordinates texture-depth quad l1 l2 l3 l4))))


(definition (make-triangle-face what rendering <Rendering> texture-coordinates texture-depth triangle l1 l2 l3)
  (case what
    ((physical)
     triangle)
    ((visual)
     (new Triangle-Template texture-coordinates texture-depth triangle l1 l2 l3))
    (else
     (new Triangle-Face (get-entity-material~ rendering) texture-coordinates texture-depth triangle l1 l2 l3))))


(definition (make-block-quad v1 v2 v3 v4 block-id <fx> variant-id <fx> x <fl> y <fl> z <fl>) <Quad>
  (let ((quad <Quad> (make-quad #f v1 v2 v3 v4)))
    (set-data1~ quad (cast <fl> (encode-id block-id variant-id)))
    (set-data2~ quad x)
    (set-data3~ quad y)
    (set-data4~ quad z)
    quad))


(definition (make-block-triangle v1 v2 v3 block-id <fx> variant-id <fx> x <fl> y <fl> z <fl>) <Triangle>
  (let ((triangle <Triangle> (make-triangle #f v1 v2 v3)))
    (set-data1~ triangle (cast <fl> (encode-id block-id variant-id)))
    (set-data2~ triangle x)
    (set-data3~ triangle y)
    (set-data4~ triangle z)
    triangle))


(definition protected (generic-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tt tl tb tr tb tr tt)))


;; 90 degrees to the left
(definition protected (rotate-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tb tr tb tr tt tl tt)))


;; 90 degrees to the right
(definition protected (rotate-inverse-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tl tt tl tb tr tb)))


(definition protected (rotate-other-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tb tr tt tl tt tl tb)))


(definition protected (transpose-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tr tb tl tb tl tt)))


(definition (generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <vertex> v2 <vertex> v3 <vertex> v4 <vertex> uv <f32vector> uv-coordinates lighting shade rendering block-id variant-id matrix)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3))
        (v4 (matrix-transform-3x4 matrix v4)))
    (let ((quad (make-block-quad (vertex+xyz v1 x y z)
                                 (vertex+xyz v2 x y z)
                                 (vertex+xyz v3 x y z)
                                 (vertex+xyz v4 x y z)
                                 block-id
                                 variant-id
                                 x
                                 y
                                 z)))
      (let ((normal (get-normal~ quad)))
        (make-quad-face what
                        rendering
                        (uv-coordinates uv)
                        (uv-depth uv)
                        quad
                        (generic-lighting i j k v1 normal lighting shade)
                        (generic-lighting i j k v2 normal lighting shade)
                        (generic-lighting i j k v3 normal lighting shade)
                        (generic-lighting i j k v4 normal lighting shade))))))


(definition (generic-triangle what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <vertex> v2 <vertex> v3 <vertex> uv <f32vector> uv-coordinates lighting shade rendering block-id variant-id matrix)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3)))
    (let ((triangle (make-block-triangle (vertex+xyz v1 x y z)
                                         (vertex+xyz v2 x y z)
                                         (vertex+xyz v3 x y z)
                                         block-id
                                         variant-id
                                         x
                                         y
                                         z)))
      (let ((normal (get-normal~ triangle)))
        (make-triangle-face what
                            rendering
                            (uv-coordinates uv)
                            (uv-depth uv)
                            triangle
                            (generic-lighting i j k v1 normal lighting shade)
                            (generic-lighting i j k v2 normal lighting shade)
                            (generic-lighting i j k v3 normal lighting shade))))))


(constant inline 1/SQRT2 <fl>
  (/ 1. (sqrt 2.)))

;; minimal value for door to clear itself
(constant inline ambient-forward <fl>
  .3)

;; minimal value for stair top to clear itself and fence to be uniform
(constant inline ambient-angled <fl>
  .9)


@debugging
(definition protected (get-ambient-forward/angled)
  (values ambient-forward ambient-angled))

@debugging
(definition protected (set-ambient-forward/angled forward angled)
  (set! ambient-forward forward)
  (set! ambient-angled angled))


(definition protected (generic-lighting i <fx> j <fx> k <fx> vert <vertex> normal <vertex> lighting shade)
  (if (u8vector? lighting)
      lighting
    ;; the .5 is because the shape is centered at 0 0 0
    (let ((adjusted (vertex+& (vertex+& vert (vertex& .5 .5 .5)) (vertex-scalar*& normal ambient-forward)))
          (r1 (make-vertex&))
          (r2 (make-vertex&))
          (r3 (make-vertex&))
          (r4 (make-vertex&)))
      (define (ambient-rays!)
        (let ((up (roll-free-up& normal)))
          (let ((right (cross-product& normal up)))
            (let ((advance (vertex-scalar*& normal 1/SQRT2)))
              (let ((up/+2 (vertex-scalar/& up  2.))
                    (up/-2 (vertex-scalar/& up -2.))
                    (right/+2 (vertex-scalar/& right  2.))
                    (right/-2 (vertex-scalar/& right -2.)))
                (vertex+! r1 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/+2)) ambient-angled))
                (vertex+! r2 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/-2)) ambient-angled))
                (vertex+! r3 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/-2)) ambient-angled))
                (vertex+! r4 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/+2)) ambient-angled)))))))
      
      (ambient-rays!)
      (lighting shade i j k
        (fxfloor (vertex-x r1)) (fxfloor (vertex-y r1)) (fxfloor (vertex-z r1))
        (fxfloor (vertex-x r2)) (fxfloor (vertex-y r2)) (fxfloor (vertex-z r2))
        (fxfloor (vertex-x r3)) (fxfloor (vertex-y r3)) (fxfloor (vertex-z r3))
        (fxfloor (vertex-x r4)) (fxfloor (vertex-y r4)) (fxfloor (vertex-z r4))))))


(constant inline no-shade     <fl> 1.)
(constant inline top-shade    <fl> 1.)
(constant inline bottom-shade <fl> .5)
(constant inline left-shade   <fl> .6)
(constant inline right-shade  <fl> .6)
(constant inline back-shade   <fl> .8)
(constant inline front-shade  <fl> .8)


(definition public (left-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id variant-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (left-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (left-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front) block-id variant-id x y z)
                  (lighting left-shade i j k -1  0 -1 -1  0  0 -1  1 -1 -1  1  0)
                  (lighting left-shade i j k -1 -1 -1 -1 -1  0 -1  0 -1 -1  0  0)
                  (lighting left-shade i j k -1 -1  0 -1 -1  1 -1  0  0 -1  0  1)
                  (lighting left-shade i j k -1  0  0 -1  0  1 -1  1  0 -1  1  1)))


;; simple solution for shapes that don't work well with ambient vectors
(definition (uniform-lighting i <fx> j <fx> k <fx> lighting)
  (lighting no-shade i j k 0 0 1 0 0 -1 1 0 0 -1 0 0))


(definition public (left-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left top front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting left-shade rendering block-id variant-id matrix)))


(definition public (left-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top-first <fl> top-second <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (let ((v1 (vertex left top-first back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left top-second front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting left-shade rendering block-id variant-id (make-identity-matrix))))


(definition public (right-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id variant-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (right-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (right-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back) block-id variant-id x y z)
                  (lighting right-shade i j k  1  0  0  1  0  1  1  1  0  1  1  1)
                  (lighting right-shade i j k  1 -1  0  1 -1  1  1  0  0  1  0  1)
                  (lighting right-shade i j k  1 -1 -1  1 -1  0  1  0 -1  1  0  0)
                  (lighting right-shade i j k  1  0 -1  1  0  0  1  1 -1  1  1  0)))


(definition public (right-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id matrix)
  (let ((v1 (vertex right top front))
        (v2 (vertex right bottom front))
        (v3 (vertex right bottom back))
        (v4 (vertex right top back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting right-shade rendering block-id variant-id matrix)))


(definition public (right-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top-first <fl> top-second <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (let ((v1 (vertex right top-first front))
        (v2 (vertex right bottom front))
        (v3 (vertex right bottom back))
        (v4 (vertex right top-second back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting right-shade rendering block-id variant-id (make-identity-matrix))))


(definition public (bottom-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id variant-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (bottom-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front) block-id variant-id x y z)
                  (lighting bottom-shade i j k -1 -1  0 -1 -1  1  0 -1  0  0 -1  1)
                  (lighting bottom-shade i j k -1 -1 -1 -1 -1  0  0 -1 -1  0 -1  0)
                  (lighting bottom-shade i j k  0 -1 -1  0 -1  0  1 -1 -1  1 -1  0)
                  (lighting bottom-shade i j k  0 -1  0  0 -1  1  1 -1  0  1 -1  1)))


(definition public (bottom-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id matrix)
  (let ((v1 (vertex left bottom front))
        (v2 (vertex left bottom back))
        (v3 (vertex right bottom back))
        (v4 (vertex right bottom front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting bottom-shade rendering block-id variant-id matrix)))


(definition public (top-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id variant-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (top-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (top-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back) block-id variant-id x y z)
                  (lighting top-shade i j k -1  1 -1 -1  1  0  0  1 -1  0  1  0)
                  (lighting top-shade i j k -1  1  0 -1  1  1  0  1  0  0  1  1)
                  (lighting top-shade i j k  0  1  0  0  1  1  1  1  0  1  1  1)
                  (lighting top-shade i j k  0  1 -1  0  1  0  1  1 -1  1  1  0)))

(definition public (top-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left top front))
        (v3 (vertex right top front))
        (v4 (vertex right top back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting top-shade rendering block-id variant-id matrix)))


(definition public (top-sloped what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> left-back-height <fl> left-front-height <fl> right-front-height <fl> right-back-height <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (let ((v1 (vertex left left-back-height back))
        (v2 (vertex left left-front-height front))
        (v3 (vertex right right-front-height front))
        (v4 (vertex right right-back-height back))
        (matrix (make-identity-matrix)))
    (define (needs-triangles?)
      (/= (/ (+ (vertex-y v1) (vertex-y v3)) 2.)
          (/ (+ (vertex-y v2) (vertex-y v4)) 2.)))
    
    (if (needs-triangles?)
        (list
          (generic-triangle what i j k x y z v1 v2 v4 uv uv-coordinates lighting top-shade rendering block-id variant-id matrix)
          (generic-triangle what i j k x y z v3 v4 v2 uv uv-coordinates lighting top-shade rendering block-id variant-id matrix))
      (list
        (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting top-shade rendering block-id variant-id matrix)))))


(definition public (back-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id variant-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (back-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (back-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back) block-id variant-id x y z)
                  (lighting back-shade i j k  0  0 -1  0  1 -1  1  0 -1  1  1 -1)
                  (lighting back-shade i j k  0 -1 -1  0  0 -1  1 -1 -1  1  0 -1)
                  (lighting back-shade i j k -1 -1 -1 -1  0 -1  0 -1 -1  0  0 -1)
                  (lighting back-shade i j k -1  0 -1 -1  1 -1  0  0 -1  0  1 -1)))


(definition public (back-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id matrix)
  (let ((v1 (vertex right top back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left top back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting back-shade rendering block-id variant-id matrix)))


(definition public (back-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top-first <fl> top-second <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (let ((v1 (vertex right top-first back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left top-second back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting back-shade rendering block-id variant-id (make-identity-matrix))))


(definition public (front-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id variant-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (front-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id)))


(definition public (front-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front) block-id variant-id x y z)
                  (lighting front-shade i j k -1  0  1 -1  1  1  0  0  1  0  1  1)
                  (lighting front-shade i j k -1 -1  1 -1  0  1  0 -1  1  0  0  1)
                  (lighting front-shade i j k  0 -1  1  0  0  1  1 -1  1  1  0  1)
                  (lighting front-shade i j k  0  0  1  0  1  1  1  0  1  1  1  1)))


(definition public (front-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id matrix)
  (let ((v1 (vertex left top front))
        (v2 (vertex left bottom front))
        (v3 (vertex right bottom front))
        (v4 (vertex right top front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting front-shade rendering block-id variant-id matrix)))


(definition public (front-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top-first <fl> top-second <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id variant-id)
  (let ((v1 (vertex left top-first front))
        (v2 (vertex left bottom front))
        (v3 (vertex right bottom front))
        (v4 (vertex right top-second front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting front-shade rendering block-id variant-id (make-identity-matrix))))


(definition public (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face)
  (add-face (left-generic   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (right-generic  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (bottom-generic what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (top-generic    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (back-generic   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category)
  (add-face (front-generic  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id matrix) rendering category))


(definition public (add-cube-faces what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)))


(definition public (add-cross-faces what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius)))
        (tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv))
        (lighting (uniform-lighting i j k lighting)))
    (add-face (make-quad-face what
                              rendering
                              (f32vector tl tt tl tb tr tb tr tt)
                              texture-depth
                              (make-block-quad (vertex right top back) (vertex right bottom back) (vertex left bottom front) (vertex left top front) block-id variant-id x y z)
                              lighting lighting lighting lighting)
              rendering
              category)
    (add-face (make-quad-face what
                              rendering
                              (f32vector tl tt tl tb tr tb tr tt)
                              texture-depth
                              (make-block-quad (vertex right top front) (vertex right bottom front) (vertex left bottom back) (vertex left top back) block-id variant-id x y z)
                              lighting lighting lighting lighting)
              rendering
              category)))


(definition protected (add-torch what block-id variant-id data-id i j k x y z uv lighting rendering category add-face add-cube block-ref data-ref top-texture bottom-texture)
  (define (position-torch proc)
    (let ((margin .32))
      (ecase data-id
        ((1) (proc (- margin) 0.))
        ((2) (proc margin 0.))
        ((3) (proc 0. (- margin)))
        ((4) (proc 0. margin))
        (else (proc 0. 0.)))))
  
  (position-torch
    (lambda (dx dz)
      (let ((margin 1m)
            (left (- x block-radius))
            (right (+ x block-radius))
            (bottom (- y block-radius))
            (top (+ y block-radius))
            (back (- z block-radius))
            (front (+ z block-radius))
            (top-uv (get-coordinates top-texture))
            (bottom-uv (get-coordinates bottom-texture)))
        (add-face (top-face    what i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) top-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (bottom-face what i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) bottom-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (left-face   what i j k x y z (+ dx (- x margin)) (+ dx right) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (right-face  what i j k x y z (+ dx left) (+ dx (+ x margin)) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (back-face   what i j k x y z (+ dx left) (+ dx right) bottom top (+ dz (- z margin)) (+ dz front) uv generic-coordinates lighting rendering block-id variant-id) rendering category)
        (add-face (front-face  what i j k x y z (+ dx left) (+ dx right) bottom top (+ dz back) (+ dz (+ z margin)) uv generic-coordinates lighting rendering block-id variant-id) rendering category)))))


(definition protected (add-button what block-id variant-id data-id i j k x y z uv lighting rendering category add-face add-cube block-ref data-ref)
  (define (position-button proc)
    (let ((orientation (bitwise-and data-id #b111))
          (depth (if (bit-set? 3 data-id) 1m 2m))
          (margin 3m)
          (thick 2m)
          (thin 1m))
      (ecase orientation
        ((0) (proc (- x margin) (+ x margin) (- (+ y block-radius) depth) (+ y block-radius) (- z thick) (+ z thick)))
        ((1) (proc (- x block-radius) (+ (- x block-radius) depth) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((2) (proc (- (+ x block-radius) depth) (+ x block-radius) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((3) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- z block-radius) (+ (- z block-radius) depth)))
        ((4) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- (+ z block-radius) depth) (+ z block-radius)))
        ((5) (proc (- x margin) (+ x margin) (- y block-radius) (+ (- y block-radius) depth) (- z thick) (+ z thick))))))
  
  (position-button
    (lambda (left right bottom top back front)
      (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
      (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category))))


(proclaim (not warn optimizations))


(definition protected (add-json-model what filename block-id variant-id data-id i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category add-face add-cube block-ref data-ref y-rotation x-rotation)
  (define (read-json-model proc (file #f) (previous-textures #f))
    (let ((models (load-block-model (or file filename))))
      (let ((has-parent? (table-ref models "parent" #f))
            (textures (or (table-ref models "textures" #f) previous-textures)))
        (when (and previous-textures (table-ref models "textures" #f))
          (iterate-table-safe textures
            (lambda (key value)
              (table-set! textures key (or (table-ref previous-textures (string-trailer value #\#) #f) value))))
          (iterate-table previous-textures
            (lambda (key value)
              (unless (table-ref textures key #f)
                (table-set! textures key value)))))
        (if has-parent?
            (read-json-model proc (string-append (string-trailer has-parent? #\/) ".json") textures)
          (iterate-table-safe textures
            (lambda (key value)
              (table-set! textures key (string-trailer value #\/))))
          (proc (table-ref models "elements") textures)))))
  
  (define (load-block-model filename)
    (set-current-directory (new-directory~ {Directory Yownu-World "assets" "minecraft" "models"} texture-dir))
    (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "models"} (if (file-exists? filename) (list texture-dir filename) (list "minecraft" filename)))))

  (read-json-model
    (lambda (elements textures)
      (let ((matrix (matrix-multiply (make-y-rotation-matrix (degree->radian (cast <fl> y-rotation)))
                                     (make-x-rotation-matrix (degree->radian (cast <fl> x-rotation))))))
        (for-each (lambda (element)
                    (define (get-file-texture face-name)
                      (let ((face (table-ref (table-ref element "faces") face-name #f)))
                        (and face
                             (if (id? block-id 55)
                                 (let ((texture-name (string-trailer (table-ref face "texture") #\#)))
                                   (and (not (ends-with? texture-name "overlay"))
                                        (let ((texture (get-coordinates (string-append (table-ref textures texture-name) "_" (->string data-id)))))
                                          (bind (l t r b) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref face "uv"))
                                            (uv-rect texture l t r b)))))
                               (let ((texture (get-coordinates (table-ref textures (string-trailer (table-ref face "texture") #\#)))))
                                 (bind (l t r b) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref face "uv" '(0 0 16 16)))
                                   (uv-rect texture l t r b)))))))
                    
                    (define (get-texture-rotation face-name)
                      (let ((face (table-ref (table-ref element "faces") face-name #f)))
                        (and face
                             (let ((rot (or (table-ref face "rotation" #f) 0)))
                               (case rot
                                 ((0)   generic-coordinates)
                                 ((90)  rotate-inverse-coordinates)
                                 ((180) rotate-other-coordinates)
                                 ((270) rotate-coordinates))))))
                    
                    (define (get-element-matrix)
                      (let ((rotation (table-ref element "rotation" #f)))
                        (if rotation
                            (bind (x y z) (map (lambda (r) (/ (cast <fl> r) 16.)) (table-ref rotation "origin"))
                              (let ((origin (vertex (- .5 x) (- .5 y) (- .5 z)))
                                    (rotation-matrix (case (string->symbol (table-ref rotation "axis"))
                                                       ((x) (make-x-rotation-matrix (degree->radian (cast <fl> (table-ref rotation "angle")))))
                                                       ((y) (make-y-rotation-matrix (- (degree->radian (cast <fl> (table-ref rotation "angle"))))))
                                                       ((z) (make-z-rotation-matrix (- (degree->radian (cast <fl> (table-ref rotation "angle")))))))))
                                (matrix-multiply (make-translation-matrix (vertex-negate origin))
                                                 (matrix-multiply rotation-matrix (make-translation-matrix origin)))))
                          (make-identity-matrix))))
                    
                    (bind (a b c) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref element "from"))
                      (bind (d e f) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref element "to"))
                        (unless (and (= a d) (= b e) (= c f))
                          (let ((left (- a .5))
                                (right (- d .5))
                                (bottom (- b .5))
                                (top (- e .5))
                                (back (- c .5))
                                (front (- f .5))
                                (left-uv (get-file-texture "west"))
                                (right-uv (get-file-texture "east"))
                                (bottom-uv (get-file-texture "down"))
                                (top-uv (get-file-texture "up"))
                                (back-uv (get-file-texture "north"))
                                (front-uv (get-file-texture "south"))
                                (left-rotation (get-texture-rotation "west"))
                                (right-rotation (get-texture-rotation "east"))
                                (bottom-rotation (get-texture-rotation "down"))
                                (top-rotation (get-texture-rotation "up"))
                                (back-rotation (get-texture-rotation "north"))
                                (front-rotation (get-texture-rotation "south"))
                                (matrix (matrix-multiply matrix (get-element-matrix))))
                            (when left-uv   (add-face (left-generic   what i j k x y z left right bottom top back front left-uv left-rotation lighting rendering block-id variant-id matrix) rendering category))
                            (when right-uv  (add-face (right-generic  what i j k x y z left right bottom top back front right-uv right-rotation lighting rendering block-id variant-id matrix) rendering category))
                            (when bottom-uv (add-face (bottom-generic what i j k x y z left right bottom top back front bottom-uv bottom-rotation lighting rendering block-id variant-id matrix) rendering category))
                            (when top-uv    (add-face (top-generic    what i j k x y z left right bottom top back front top-uv top-rotation lighting rendering block-id variant-id matrix) rendering category))
                            (when back-uv   (add-face (back-generic   what i j k x y z left right bottom top back front back-uv back-rotation lighting rendering block-id variant-id matrix) rendering category))
                            (when front-uv  (add-face (front-generic  what i j k x y z left right bottom top back front front-uv front-rotation lighting rendering block-id variant-id matrix) rendering category)))))))
                  elements)))))


(proclaim (warn optimizations))


;; unused
(definition protected (add-stairs what block-id variant-id data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category add-face)
  (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case (bitwise-and data-id #b11)
                                                         ((3) (vertex&  0. 0. -1.))
                                                         ((2) (vertex&  0. 0.  1.))
                                                         ((1) (vertex& -1. 0.  0.))
                                                         ((0) (vertex&  1. 0.  0.)))))))
    ;; bottom
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom (fl& (- block-radius)))
          (top 0.)
          (back (fl& (- block-radius)))
          (front (fl& (+ block-radius))))
      (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face))
    ;; top
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom 0.)
          (top (fl& (+ block-radius)))
          (back 0.)
          (front (fl& (+ block-radius))))
      (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face))))


(definition protected (fence-configuration i <fx> j <fx> k <fx> block-ref connects)
  (define (connect? block-id)
    (memv? block-id connects))
  
  (bitwise-ior
    ;; left
    (if (connect? (block-ref (+ i 1) j k)) 1 0)
    ;; right
    (if (connect? (block-ref (- i 1) j k)) 2 0)
    ;; back
    (if (connect? (block-ref i j (+ k 1))) 4 0)
    ;; front
    (if (connect? (block-ref i j (- k 1))) 8 0)))


(definition protected (add-fence what block-id <fx> variant-id <fx> config-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face block-ref)
  (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (vertex&  0. 0.  1.))))
        (depth .075))
    (define (add-trunk)
      (let ((left (- .1))
            (right (+ .1))
            (bottom (- block-radius))
            (top (+ block-radius))
            (back (- .1))
            (front (+ .1)))
        (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face)))
    
    (define (add-branches left <fl> right <fl> back <fl> front <fl>)
      ;; upper
      (let ((bottom (- .35 .075))
            (top (+ .35 .075)))
        (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face))
      ;; lower
      (let ((bottom (- .075))
            (top (+ .075)))
        (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id variant-id matrix add-face)))
    
    ;; trunk
    (add-trunk)
    ;; left
    (when (bit-set? 0 config-id)
      (add-branches .1 (+ block-radius) (- depth) depth))
    ;; right
    (when (bit-set? 1 config-id)
      (add-branches (- block-radius) -.1 (- depth) depth))
    ;; back
    (when (bit-set? 2 config-id)
      (add-branches (- depth) depth .1 (+ block-radius)))
    ;; front
    (when (bit-set? 3 config-id)
      (add-branches (- depth) depth (- block-radius) -.1))))


(definition protected (add-slab what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv side-uv lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top y)
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (right-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (back-face   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id variant-id) rendering category)
    (add-face (front-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-sloped what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category block-id variant-id add-face horizon)
  (let ((left (fl& (- block-radius)))
        (right (fl& (+ block-radius)))
        (bottom (fl& (- block-radius)))
        (top (fl& (+ block-radius)))
        (back (fl& (- block-radius)))
        (front (fl& (+ block-radius))))
    (let ((v1 (vertex left top back))
          (v2 (vertex left bottom front))
          (v3 (vertex right bottom front))
          (v4 (vertex right top back))
          (matrix (make-lookat-matrix& (horizon-lookat&^ horizon))))
      (add-face (generic-quad what i j k x y z v1 v2 v3 v4 uv generic-coordinates lighting no-shade rendering block-id variant-id matrix) rendering category))))


(definition protected (add-rail what block-id <fx> variant-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category add-face)
  (case data-id
    ((0) (add-bottom what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
    ((1) (add-bottom what i j k x y z uv rotate-coordinates lighting rendering category block-id variant-id add-face))
    ((2) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex& -1. 0.  0.)))
    ((3) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  1. 0.  0.)))
    ((4) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  0. 0.  1.)))
    ((5) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  0. 0. -1.)))
    ((6) (add-bottom what i j k x y z (get-coordinates "rail_normal_turned") generic-coordinates lighting rendering category block-id variant-id add-face))
    ((7) (add-bottom what i j k x y z (get-coordinates "rail_normal_turned") rotate-coordinates lighting rendering category block-id variant-id add-face))
    ((8) (add-bottom what i j k x y z (get-coordinates "rail_normal_turned") rotate-other-coordinates lighting rendering category block-id variant-id add-face))
    ((9) (add-bottom what i j k x y z (get-coordinates "rail_normal_turned") rotate-inverse-coordinates lighting rendering category block-id variant-id add-face))))


(definition protected (add-rail-gadget what block-id <fx> variant-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-powered lighting rendering category add-face)
  (let ((powered? (bit-set? 3 data-id)))
    (let ((uv (if powered? uv-powered uv)))
      (case (bitwise-and data-id #b111)
        ((0) (add-bottom what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
        ((1) (add-bottom what i j k x y z uv rotate-coordinates lighting rendering category block-id variant-id add-face))
        ((2) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex& -1. 0.  0.)))
        ((3) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  1. 0.  0.)))
        ((4) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  0. 0.  1.)))
        ((5) (add-sloped what i j k x y z uv lighting rendering category block-id variant-id add-face (vertex&  0. 0. -1.)))))))


(definition protected add-epsilon <fl>
  .01)


(definition protected (add-left what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (right-face what i j k x y z left (+ left add-epsilon) bottom top back front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-right what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face what i j k x y z (- right add-epsilon) right bottom top back front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-bottom what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (top-face what i j k x y z left right bottom (+ bottom add-epsilon) back front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-top what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (bottom-face what i j k x y z left right (- top add-epsilon) top back front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-back what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (front-face what i j k x y z left right bottom top back (+ back add-epsilon) uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-front what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id variant-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (back-face what i j k x y z left right bottom top (- front add-epsilon) front uv uv-coordinates lighting rendering block-id variant-id) rendering category)))


(definition protected (add-transparent what block-id variant-id data-id left right back front i j k x <fl> y <fl> z <fl> uv lighting rendering category add-face)
  (ecase data-id
    ((left)  (add-left  what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
    ((right) (add-right what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
    ((back)  (add-back  what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))
    (else    (add-front what i j k x y z uv generic-coordinates lighting rendering category block-id variant-id add-face))))


;;;
;;;; Models
;;;


;; hacks to try out blocks rendered with ambient lighting


(definition protected (generate-model what name block-id <fx> variant-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category add-face)
  (let ((world (current-world)))
    (let ((model <Model> (find-model~ world name))
          (center (vertex& x y z)))
      (let ((matrix (make-translation-matrix& center)))
        (let ((polygons (block-polygons-extract #f (get-polygons~ model) matrix block-id variant-id x y z)))
          (for-each (lambda (poly <Polygon>)
                      (let ((normal (get-normal~ poly)))
                        (let ((shade (determine-shade normal)))
                          (define (triangle)
                            (let ((poly (cast <Triangle> poly)))
                              (make-triangle-face what rendering (uv-coordinates uv) (uv-depth uv) poly
                                (generic-lighting i j k (vertex-& (get-v1~ poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v2~ poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v3~ poly) center) normal lighting shade))))
                          
                          (define (quad)
                            (let ((poly (cast <Quad> poly)))
                              (make-quad-face what rendering (uv-coordinates uv) (uv-depth uv) poly
                                (generic-lighting i j k (vertex-& (get-v1~ poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v2~ poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v3~ poly) center) normal lighting shade)
                                (generic-lighting i j k (vertex-& (get-v4~ poly) center) normal lighting shade))))
                          
                          (add-face (if (is? poly Triangle)
                                        (triangle)
                                      (quad))
                                    rendering
                                    category))))
                    polygons))))))


(definition (determine-shade normal)
  (cond ((vertex=? normal (vertex&  0.  1.  0.)) top-shade)
        ((vertex=? normal (vertex&  0. -1.  0.)) bottom-shade)
        ((vertex=? normal (vertex&  1.  0.  0.)) left-shade)
        ((vertex=? normal (vertex& -1.  0.  0.)) right-shade)
        ((vertex=? normal (vertex&  0.  0.  1.)) back-shade)
        ((vertex=? normal (vertex&  0.  0. -1.)) front-shade)
        (else no-shade))))
