;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Cameras
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.camera jazz


(import (jazz.geometry)
        (jazz.opengl.glew)
        (world)
        (world.area)
        (world.autoload)
        (world.draw)
        (world.dyes)
        (world.gadget)
        (world.geometry)
        (world.homogeneous)
        (world.index)
        (world.settings)
        (world.syntax (phase syntax))
        (world.window))


(definition public (make-camera)
  (new Camera))


(definition public (camera-copy! dst src)
  (size-change~ dst (get-size~ (current-world-window)))
  (set-position~ dst (get-position~ src))
  (set-lookat~ dst (get-lookat~ src))
  (derive-target~ dst)
  (camera-update~ dst))


;;;
;;;; Camera
;;;


(class Camera extends Gadget
  
  
  ;; target
  (slot target             <f64vector>       initialize (make-zero-vertex) getter generate)
  
  ;; stable
  (slot dirty?             <bool>            initialize #f            getter generate)
  (slot stable?            <bool>            initialize #f            getter generate)
  (slot stable-since       <fl>              initialize #f            getter generate)
  (slot callback           <object>          initialize #f            accessors generate)
  
  ;; screen
  (slot screen-width       <fl>              initialize #f            accessors generate)
  (slot screen-height      <fl>              initialize #f            accessors generate)
  (slot inited?            <bool>            initialize #f            accessors generate)
  
  ;; projection
  (slot projection         <symbol>          initialize 'perspective  getter generate)
  
  ;; perspective
  (slot perspective-fov    <fl>              initialize 45.           accessors generate)
  (slot perspective-near   <fl>              initialize 0.1           accessors generate)
  (slot perspective-far    <fl>              initialize 10000.0       accessors generate)
  (slot view-distance      <fl>              initialize 60.           accessors generate)
  
  ;; orthographic
  (slot zoom-factor        <fl>              initialize 0.            accessors generate)
  
  ;; frustum
  (slot frustum-radius     <fl+>             initialize #f            accessors generate)
  (slot frustum-left       <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-bottom     <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-right      <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-top        <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-left-dot   <fl>              initialize 0.            getter generate)
  (slot frustum-bottom-dot <fl>              initialize 0.            getter generate)
  (slot frustum-right-dot  <fl>              initialize 0.            getter generate)
  (slot frustum-top-dot    <fl>              initialize 0.            getter generate)
  
  ;; matrix
  (slot projection-matrix  <f64vector>       initialize (make-matrix) getter generate)
  (slot view-matrix        <f64vector>       initialize (make-matrix) getter generate)
  
  ;; movement
  (slot move-speed         <fl>              initialize .2            accessors generate)
  (slot sprint-speed       <fl>              initialize 2.            accessors generate)
  (slot blink-speed        <fl>              initialize 2.            accessors generate)
  (slot warp-speed         <fl>              initialize 4.            accessors generate)
  (slot strafe-speed       <fl>              initialize 0.1           accessors generate)
  (slot rotate-speed       <fl>              initialize .035          accessors generate)
  
  ;; visual
  (slot sector-index       <vector>          initialize (make-index)  getter generate)
  
  ;; physical
  (slot area-cube          <Area-Cube+>      initialize #f            getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-perspective-fov (world-setting 'world.perspective-fov 45.))
    (set-perspective-near (world-setting 'world.perspective-near 0.1))
    (set-perspective-far (world-setting 'world.perspective-far 10000.0))
    (set-model (camera-model)))
  
  
  (method protected virtual (camera-model)
    'Camera)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (present-vertex position)))))
  
  
  (method (size-change size)
    (set! screen-width (cast <fl> (get-width~ size)))
    (set! screen-height (cast <fl> (get-height~ size)))
    (prepare-projection)
    (set! inited? #t))
  
  
  (method (setup-area-cube radius)
    (set! area-cube (new Area-Cube radius)))
  
  
  (method (update-area-cube)
    (get-areas~ area-cube position)
    area-cube)
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method (set-target vert <f64vector>) <void>
    (unless (vertex=? vert target)
      (vertex-copy! target vert)
      (dirty-update)))
  
  
  (method (derive-target)
    ;(assert (roll-free? lookat (get-world-up~ (current-world))))
    (set-target (vertex+& position (get-sight~ lookat))))
  
  
  (method (reset-camera)
    (standardize-lookat! lookat)
    (derive-target)
    (camera-update))
  
  
  ;;;
  ;;;; Stable
  ;;;
  
  
  (method (init-stable)
    (set! stable-since (current-seconds))
    (set! stable? #t))
  
  
  (method (reset-stable)
    (set! stable-since (current-seconds))
    (set! stable? #f)
    (when callback
      (callback stable?)))
  
  
  (method (update-stable stable-delay <fl>)
    (unless stable?
      (when (>= (- (current-seconds&) stable-since) stable-delay)
        (set! stable? #t)
        (when callback
          (callback stable?)))))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method override (update-matrix)
    (nextmethod)
    (when inited?
      (prepare-view)
      (index-update)
      (dirty-update)))
  
  
  (method (camera-update)
    (when dirty?
      (update-frustum)
      (reset-stable)
      (set! dirty? #f)))
  
  
  (method (dirty-update)
    (set! dirty? #t)
    (camera-update))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method (prepare-projection)
    (let ((ratio (/ screen-width screen-height)))
      (case projection
        ((perspective)
         (make-perspective-matrix! projection-matrix perspective-fov ratio perspective-near perspective-far))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (make-orthographic-matrix! projection-matrix (- width) width (- height) height perspective-near perspective-far)))))))
  
  
  (method (prepare-view)
    (make-view-matrix! view-matrix position lookat))
  
  
  (definition camera-limit <fl>
    5.)
  
  
  (method (move-camera center-x)
    (let ((x (vertex-x position)))
      (if (> center-x (+ x camera-limit))
          (move-horizontally (- center-x (+ x camera-limit))))
      (if (< center-x (- x camera-limit))
          (move-horizontally (- center-x (- x camera-limit))))))
    
  
  ;;;
  ;;;; Screen
  ;;;
  
  
  (method (world->screen vertex)
    (let ((projection (make-perspective-matrix& perspective-fov (/ screen-width screen-height) perspective-near perspective-far))
          (view (make-view-matrix& position lookat)))
      (let ((projection/view (matrix-multiply& projection view)))
        (let ((vert (matrix-transform& projection/view vertex)))
          (new Point
            (fxround (* (+ (vertex-x vert) 1.) (/ screen-width 2.)))
            (fxround (* (- 1. (vertex-y vert)) (/ screen-height 2.))))))))
  
  
  (method (screen->world h v)
    (let ((ratio (/ screen-width screen-height))
          (ch (- h (/ screen-width 2)))
          (cv (- (- screen-height v) (/ screen-height 2))))
      (case projection
        ((perspective)
         (let ((half-fov (/ (degree->radian perspective-fov) 2.))
               (up (get-up~ lookat)))
           (let ((cone (tan half-fov))
                 (d (vertex-distance position target))
                 (right (cross-product& (vertex-& target position) up)))
             (let ((target-in-eye-space (vertex+& (vertex-scalar*& up (/ (* cv d cone 2.) screen-height))
                                                  (vertex+& (vertex-scalar*& right (/ (* ch d cone 2. ratio) screen-width))
                                                            target))))
               (values (copy-vertex position) (vertex-normalize (vertex-& target-in-eye-space position)))))))
        ((orthographic)
         (let ((x (+ (/ (* 2. ch zoom-factor) screen-width) (vertex-x position)))
               (y (+ (/ (* 2. cv zoom-factor) screen-height ratio) (vertex-y position))))
           (values (vertex x y (vertex-z position)) (vertex 0. 0. -1.)))))))
  
  
  ;;;
  ;;;; Index
  ;;;
  
  
  (method (index-update)
    (let ((zone (current-zone+)))
      (when zone
        (index-copy! sector-index (position-sector-index&~ zone position)))))
  
  
  ;;;
  ;;;; Frustum
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (update-frustum)
    (let ((zone (current-zone+)))
      ;; quick hack around initialization order
      (let ((default-radius 13.856406460551018))
        (let ((radius <fl> (or frustum-radius (if (not zone) default-radius (or (get-sector-radius~ zone) default-radius)))))
          (frustum-normals! frustum-left frustum-bottom frustum-right frustum-top)
          (set! frustum-left-dot (- (dot-product& frustum-left position) radius))
          (set! frustum-bottom-dot (- (dot-product& frustum-bottom position) radius))
          (set! frustum-right-dot (- (dot-product& frustum-right position) radius))
          (set! frustum-top-dot (- (dot-product& frustum-top position) radius))))))
  
  
  (method (frustum-normals! left-normal <f64vector> bottom-normal <f64vector> right-normal <f64vector> top-normal <f64vector>) <void>
    ;; copied from screen->world for performance
    (let ((ratio (/ screen-width screen-height))
          (half-fov (/ (degree->radian perspective-fov) 2.))
          (up (get-up~ lookat)))
      (let ((cone (tan half-fov))
            (d (vertex-distance& position target))
            (right (cross-product& (vertex-& target position) up)))
        (define (compute-normal! res <f64vector> h <fl> v <fl>) <void>
          (let ((ch (- h (/ screen-width 2.)))
                (cv (- (- screen-height v) (/ screen-height 2.))))
            (let ((target-in-eye-space (vertex+& (vertex-scalar*& up (/ (* cv d cone 2.) screen-height))
                                                 (vertex+& (vertex-scalar*& right (/ (* ch d cone 2. ratio) screen-width))
                                                           target))))
              (vertex-normalize! res (vertex-& target-in-eye-space position)))))
        
        (let ((r00 (make-vertex&))
              (r01 (make-vertex&))
              (r10 (make-vertex&))
              (r11 (make-vertex&)))
          (compute-normal! r00 0. 0.)
          (compute-normal! r01 0. screen-height)
          (compute-normal! r10 screen-width 0.)
          (compute-normal! r11 screen-width screen-height)
          (cross-product! left-normal r01 r00)
          (cross-product! bottom-normal r00 r10)
          (cross-product! right-normal r10 r11)
          (cross-product! top-normal r11 r01)))))
  
  
  (method (in-frustum? pos <f64vector>) <bool>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    ;; unroll the dot products
    (let ((left frustum-left)
          (bottom frustum-bottom)
          (right frustum-right)
          (top frustum-top))
      (and (>= (+ (* (vertex-x left) (vertex-x pos))
                  (* (vertex-y left) (vertex-y pos))
                  (* (vertex-z left) (vertex-z pos)))
               frustum-left-dot)
           (>= (+ (* (vertex-x bottom) (vertex-x pos))
                  (* (vertex-y bottom) (vertex-y pos))
                  (* (vertex-z bottom) (vertex-z pos)))
               frustum-bottom-dot)
           (>= (+ (* (vertex-x right) (vertex-x pos))
                  (* (vertex-y right) (vertex-y pos))
                  (* (vertex-z right) (vertex-z pos)))
               frustum-right-dot)
           (>= (+ (* (vertex-x top) (vertex-x pos))
                  (* (vertex-y top) (vertex-y pos))
                  (* (vertex-z top) (vertex-z pos)))
               frustum-top-dot))))
  
  
  @try-that-doesnt-seem-to-gain-a-lot
  (method (in-frustum? pos <f64vector>) <bool>
    (declare (not interrupts-enabled))
    (c-code
      #/C/

double x = ___F64VECTORREF(___ARG1, ___FIX(0));
double y = ___F64VECTORREF(___ARG1, ___FIX(1));
double z = ___F64VECTORREF(___ARG1, ___FIX(2));

if ( ( (___F64VECTORREF(___ARG2, ___FIX(0)) * x) +
       (___F64VECTORREF(___ARG2, ___FIX(1)) * y) +
       (___F64VECTORREF(___ARG2, ___FIX(2)) * z) ) >= ___F64VECTORREF(___ARG6, ___FIX(0)) &&
     ( (___F64VECTORREF(___ARG3, ___FIX(0)) * x) +
       (___F64VECTORREF(___ARG3, ___FIX(1)) * y) +
       (___F64VECTORREF(___ARG3, ___FIX(2)) * z) ) >= ___F64VECTORREF(___ARG7, ___FIX(0)) &&
     ( (___F64VECTORREF(___ARG4, ___FIX(0)) * x) +
       (___F64VECTORREF(___ARG4, ___FIX(1)) * y) +
       (___F64VECTORREF(___ARG4, ___FIX(2)) * z) ) >= ___F64VECTORREF(___ARG8, ___FIX(0)) &&
     ( (___F64VECTORREF(___ARG5, ___FIX(0)) * x) +
       (___F64VECTORREF(___ARG5, ___FIX(1)) * y) +
       (___F64VECTORREF(___ARG5, ___FIX(2)) * z) ) >= ___F64VECTORREF(___ARG9, ___FIX(0)) )
    ___RESULT = ___TRU;
else
    ___RESULT = ___FAL;

//#

  pos                ;; ___ARG1
  frustum-left       ;; ___ARG2
  frustum-bottom     ;; ___ARG3
  frustum-right      ;; ___ARG4
  frustum-top        ;; ___ARG5
  frustum-left-dot   ;; ___ARG6
  frustum-bottom-dot ;; ___ARG7
  frustum-right-dot  ;; ___ARG8
  frustum-top-dot    ;; ___ARG9
  ))
  
  
  (proclaim (not warn optimizations))

  
  ;;;
  ;;;; Zoom
  ;;;
  
  
  (method (zoom-speed)
    1.)

  
  (method (zoom-in)
    (case projection
      ((perspective)
       (let ((me (get-camera-me)))
         (increase! view-distance (- (zoom-speed)))
         (vertex+! position me (vertex-scalar*& (get-sight~ lookat) (- view-distance)))
         (derive-target)
         (camera-update)))
      ((orthographic)
       (set! zoom-factor (* zoom-factor .75)))))
  
  
  (method (zoom-out)
    (case projection
      ((perspective)
       (let ((me (get-camera-me)))
         (increase! view-distance (zoom-speed))
         (vertex+! position me (vertex-scalar*& (get-sight~ lookat) (- view-distance)))
         (derive-target)
         (camera-update)))
      ((orthographic)
       (set! zoom-factor (/ zoom-factor .75)))))
  
  
  (method (get-camera-me)
    (vertex+ position (vertex-scalar*& (get-sight~ lookat) view-distance)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method (move-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) move-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (move-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- move-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (sprint-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) sprint-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (sprint-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- sprint-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (blink-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) blink-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (blink-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- blink-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (warp-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) warp-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (warp-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- warp-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (move-left)
    (move-horizontally (- (* strafe-speed 2))))
  
  
  (method (move-right)
    (move-horizontally (* strafe-speed 2)))
  
  
  (method (move-horizontally d)
    (set-position (vertex+& position (vertex-scalar*& (get-right~ lookat) d)))
    (derive-target)
    (camera-update))
  
  
  (method (move-up)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-world-up~ world) (* strafe-speed 2))))
      (derive-target)
      (camera-update)))
  
  
  (method (move-down)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-world-up~ world) (- (* strafe-speed 2)))))
      (derive-target)
      (camera-update)))
  
  
  (method (rotate-left)
    (rotate-horizontal rotate-speed))
  
  
  (method (rotate-right)
    (rotate-horizontal (- rotate-speed)))
  
  
  (method (rotate-horizontal angle)
    (let ((world (current-world)))
      (set-lookat (rotate-lookat& lookat angle (get-world-up~ world)))
      (derive-target)
      (camera-update)))
  
  
  (method (rotate-up)
    (rotate-vertical rotate-speed))
  
  
  (method (rotate-down)
    (rotate-vertical (- rotate-speed)))
  
  
  (method (rotate-vertical angle)
    (let ((world (current-world)))
      (rotate-lookat-vertical-up! lookat angle (get-world-up~ world))
      (derive-target)
      (camera-update)))
  
  
  (method (rotate-vertical-up angle up)
    (rotate-lookat-vertical-up! lookat angle up)
    (derive-target)
    (camera-update))
  
  
  ;;;
  ;;;; Orientation
  ;;;
  
  
  (method (draw-orientation)
    (let ((center (vertex-& (vertex-& (vertex+& position (vertex-scalar*& (get-sight~ lookat) 5.)) (vertex-scalar*& (get-right~ lookat) 1.5)) (get-up~ lookat))))
      (let ((sight (vertex+& center (get-sight~ lookat)))
            (up (vertex+& center (get-up~ lookat)))
            (right (vertex+& center (get-right~ lookat)))
            (axis-x (vertex+& center (vertex 1. 0. 0.)))
            (axis-y (vertex+& center (vertex 0. 1. 0.)))
            (axis-z (vertex+& center (vertex 0. 0. 1.))))
        (let ((cx (vertex-x center))
              (cy (vertex-y center))
              (cz (vertex-z center))
              (width .01))
          (glDisable GL_DEPTH_TEST)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x sight) (vertex-y sight) (vertex-z sight))
                       width
                       white-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x right) (vertex-y right) (vertex-z right))
                       width
                       white-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x up) (vertex-y up) (vertex-z up))
                       width
                       white-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x axis-x) (vertex-y axis-x) (vertex-z axis-x))
                       width
                       red-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x axis-y) (vertex-y axis-y) (vertex-z axis-y))
                       width
                       green-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x axis-z) (vertex-y axis-z) (vertex-z axis-z))
                       width
                       blue-dye)
          (glEnable GL_DEPTH_TEST)))))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method override (history-draw-now?)
    #t)
  
  
  (method override (history-draw-trail?)
    #t)))
