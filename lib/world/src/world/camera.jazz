;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Cameras
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.camera jazz


(import (jazz.geometry)
        (jazz.graphic.opengl.glew)
        (world)
        (world.autoload)
        (world.dyes)
        (world.geometry)
        (world.homogeneous)
        (world.lookat)
        (world.opengl)
        (world.syntax (phase syntax)))


(definition public (make-camera)
  (new Camera))


;;;
;;;; Camera
;;;


(class Camera extends Object
  
  
  ;; camera
  (slot position           <f64vector>       initialize (make-vertex) getter generate)
  (slot target             <f64vector>       initialize (make-vertex) getter generate)
  (slot lookat             <LookAt>          initialize (make-lookat) getter generate)
  
  ;; stable
  (slot dirty?             <bool>            initialize #f            getter generate)
  (slot stable?            <bool>            initialize #f            getter generate)
  (slot stable-since       <fl+>             initialize #f            getter generate)
  (slot stable-callback    <object>          initialize #f            accessors generate)

  ;; screen
  (slot width              <fl>              initialize #f            accessors generate)
  (slot height             <fl>              initialize #f            accessors generate)
    
  ;; projection
  (slot projection         <symbol>          initialize 'perspective  getter generate)
  
  ;; perspective
  (slot perspective-fov    <fl>              initialize 45.           accessors generate)
  (slot perspective-near   <fl>              initialize 0.1           accessors generate)
  (slot perspective-far    <fl>              initialize 10000.0       accessors generate)
  (slot view-distance      <fl>              initialize 60.           accessors generate)
  
  ;; orthographic
  (slot zoom-factor        <fl>              initialize 0.            accessors generate)

  ;; frustum
  (slot frustum-radius     <fl+>             initialize #f            accessors generate)
  (slot frustum-left       <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-bottom     <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-right      <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-top        <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-left-dot   <fl>              initialize 0.            getter generate)
  (slot frustum-bottom-dot <fl>              initialize 0.            getter generate)
  (slot frustum-right-dot  <fl>              initialize 0.            getter generate)
  (slot frustum-top-dot    <fl>              initialize 0.            getter generate)
  
  ;; movement
  (slot move-speed         <fl>              initialize .2            accessors generate)
  (slot blink-speed        <fl>              initialize 2.            accessors generate)
  (slot warp-speed         <fl>              initialize 4.            accessors generate)
  (slot strafe-speed       <fl>              initialize 0.1           accessors generate)
  (slot rotate-speed       <fl>              initialize .035          accessors generate)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" (present-vertex position) (present-vertex target)))))
  
  
  (method (size-change size)
    (set! width (cast <fl> (get-width~ size)))
    (set! height (cast <fl> (get-height~ size))))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method inline (get-sight) <f64vector>
    (get-sight~ lookat))
  
  (method inline (get-up) <f64vector>
    (get-up~ lookat))
  
  (method inline (get-right) <f64vector>
    (get-right~ lookat))
  
  
  (method (set-position vert <f64vector>) <void>
    (unless (vertex-near? vert position)
      (vertex-copy! position vert)
      (dirty-update)))
  
  
  (method (set-target vert <f64vector>) <void>
    (unless (vertex-near? vert target)
      (vertex-copy! target vert)
      (dirty-update)))
  
  
  (method (set-lookat at <LookAt>) <void>
    (unless (lookat-near? at lookat)
      (lookat-copy! lookat at)
      (dirty-update)))
  
  
  (method (set-sight sight <f64vector>) <void>
    (unless (vertex-near? sight (get-sight~ lookat))
      (set-sight~ lookat sight)
      (dirty-update)))
  
  (method (set-up up <f64vector>) <void>
    (unless (vertex-near? up (get-up~ lookat))
      (set-up~ lookat up)
      (dirty-update)))
  
  (method (set-right right <f64vector>) <void>
    (unless (vertex-near? right (get-right~ lookat))
      (set-right~ lookat right)
      (dirty-update)))
  
  
  (method (derive-target)
    (set-target (vertex+& position (get-sight~ lookat))))
  
  
  (method (reset-camera)
    (standardize-lookat! lookat)
    (derive-target)
    (camera-update))
  
  
  ;;;
  ;;;; Stable
  ;;;
  
  
  (method (init-stable)
    (set! stable-since (current-seconds))
    (set! stable? #t))
  
  
  (method (reset-stable)
    (set! stable-since (current-seconds))
    (set! stable? #f)
    (when stable-callback
      (stable-callback stable?)))
  
  
  (method (update-stable stable-delay)
    (unless stable?
      (when (>= (- (current-seconds) stable-since) stable-delay)
        (set! stable? #t)
        (when stable-callback
          (stable-callback stable?)))))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (camera-update)
    (when dirty?
      (update-frustum)
      (reset-stable)
      (set! dirty? #f)))
  
  
  (method (dirty-update)
    (set! dirty? #t)
    (camera-update))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method (prepare-projection)
    (let ((ratio (/ width height)))
      (glMatrixMode GL_PROJECTION)
      (glLoadIdentity)
      (case projection
        ((perspective)
         (gluPerspective perspective-fov ratio perspective-near perspective-far))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (glOrtho (- width) width (- height) height perspective-near perspective-far)))))))
  
  
  (method (activate-perspective)
    (set! projection 'perspective))
  
  
  (method (activate-orthographic)
    (reset-camera)
    (set! projection 'orthographic))
  
  
  (method (setup-camera)
    (let ((up (get-up~ lookat)))
      (gluLookAt
        (vertex-x position) (vertex-y position) (vertex-z position)
        (vertex-x target) (vertex-y target) (vertex-z target)
        (vertex-x up) (vertex-y up) (vertex-z up))))
  
  
  (definition camera-limit <fl>
    5.)
  
  
  (method (move-camera center-x)
    (let ((x (vertex-x position)))
      (if (> center-x (+ x camera-limit))
          (move-horizontally (- center-x (+ x camera-limit))))
      (if (< center-x (- x camera-limit))
          (move-horizontally (- center-x (- x camera-limit))))))
    
  
  ;;;
  ;;;; Screen
  ;;;
  
  
  (method (world->screen vertex)
    (let ((projection (make-projection-matrix& perspective-fov (/ width height) perspective-near perspective-far))
          (view (make-view-matrix& position lookat)))
      (let ((projection/view (matrix-multiply& projection view)))
        (let ((vert (matrix-transform& projection/view vertex)))
          (new Point
            (fxround (* (+ (vertex-x vert) 1.) (/ width 2.)))
            (fxround (* (- 1. (vertex-y vert)) (/ height 2.))))))))
  
  
  (method (screen->ray h v)
    (let ((ratio (/ width height))
          (ch (- h (/ width 2)))
          (cv (- (- height v) (/ height 2))))
      (case projection
        ((perspective)
         (let ((half-fov (/ (degree->radian perspective-fov) 2.))
               (up (get-up~ lookat)))
           (let ((cone (tan half-fov))
                 (d (vertex-distance position target))
                 (right (cross-product& (vertex-& target position) up)))
             (let ((target-in-eye-space (vertex+& (vertex-scalar*& up (/ (* cv d cone 2.) height))
                                                  (vertex+& (vertex-scalar*& right (/ (* ch d cone 2. ratio) width))
                                                            target))))
               (values (copy-vertex position) (vertex-normalize (vertex-& target-in-eye-space position)))))))
        ((orthographic)
         (let ((x (+ (/ (* 2. ch zoom-factor) width) (vertex-x position)))
               (y (+ (/ (* 2. cv zoom-factor) height ratio) (vertex-y position))))
           (values (vertex x y (vertex-z position)) (vertex 0. 0. -1.)))))))
  
  
  ;;;
  ;;;; Frustum
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (update-frustum)
    (let ((zone (current-zone+)))
      ;; quick hack around initialization order
      (let ((default-radius 13.856406460551018))
        (let ((radius <fl> (or frustum-radius (if (not zone) default-radius (or (get-sector-radius~ zone) default-radius)))))
          (frustum-normals! frustum-left frustum-bottom frustum-right frustum-top)
          (set! frustum-left-dot (- (f64-ref (dot-product& frustum-left position)) radius))
          (set! frustum-bottom-dot (- (f64-ref (dot-product& frustum-bottom position)) radius))
          (set! frustum-right-dot (- (f64-ref (dot-product& frustum-right position)) radius))
          (set! frustum-top-dot (- (f64-ref (dot-product& frustum-top position)) radius))))))
  
  
  (method (frustum-normals! left-normal <f64vector> bottom-normal <f64vector> right-normal <f64vector> top-normal <f64vector>) <void>
    ;; copied from screen->ray for performance
    (let ((ratio (/ width height))
          (half-fov (/ (degree->radian perspective-fov) 2.))
          (up (get-up~ lookat)))
      (let ((cone (tan half-fov))
            (d (f64-ref (vertex-distance& position target)))
            (right (cross-product& (vertex-& target position) up)))
        (define (compute-normal! res <f64vector> h <fl> v <fl>) <void>
          (let ((ch (- h (/ width 2.)))
                (cv (- (- height v) (/ height 2.))))
            (let ((target-in-eye-space (vertex+& (vertex-scalar*& up (/ (* cv d cone 2.) height))
                                                 (vertex+& (vertex-scalar*& right (/ (* ch d cone 2. ratio) width))
                                                           target))))
              (vertex-normalize! res (vertex-& target-in-eye-space position)))))
        
        (let ((r00 (make-vertex&))
              (r01 (make-vertex&))
              (r10 (make-vertex&))
              (r11 (make-vertex&)))
          (compute-normal! r00 0. 0.)
          (compute-normal! r01 0. height)
          (compute-normal! r10 width 0.)
          (compute-normal! r11 width height)
          (cross-product! left-normal r01 r00)
          (cross-product! bottom-normal r00 r10)
          (cross-product! right-normal r10 r11)
          (cross-product! top-normal r11 r01)))))
  
  
  (method (in-frustum? pos <f64vector>) <bool>
    (and (>= (f64-ref (dot-product& frustum-left pos)) frustum-left-dot)
         (>= (f64-ref (dot-product& frustum-bottom pos)) frustum-bottom-dot)
         (>= (f64-ref (dot-product& frustum-right pos)) frustum-right-dot)
         (>= (f64-ref (dot-product& frustum-top pos)) frustum-top-dot)))
  
  
  (proclaim (not warn optimizations))

  
  ;;;
  ;;;; Zoom
  ;;;
  
  
  (method (zoom-speed)
    1.)

  
  (method (zoom-in)
    (case projection
      ((perspective)
       (let ((me (get-camera-me)))
         (increase! view-distance (- (zoom-speed)))
         (vertex+! position me (vertex-scalar*& (get-sight~ lookat) (- view-distance)))
         (derive-target)
         (camera-update)))
      ((orthographic)
       (set! zoom-factor (* zoom-factor .75)))))
  
  
  (method (zoom-out)
    (case projection
      ((perspective)
       (let ((me (get-camera-me)))
         (increase! view-distance (zoom-speed))
         (vertex+! position me (vertex-scalar*& (get-sight~ lookat) (- view-distance)))
         (derive-target)
         (camera-update)))
      ((orthographic)
       (set! zoom-factor (/ zoom-factor .75)))))
  
  
  (method (get-camera-me)
    (vertex+ position (vertex-scalar*& (get-sight~ lookat) view-distance)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method (move-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) move-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (move-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- move-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (blink-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) blink-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (blink-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- blink-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (warp-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) warp-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (warp-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- warp-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (move-left)
    (move-horizontally (- (* strafe-speed 2))))
  
  
  (method (move-right)
    (move-horizontally (* strafe-speed 2)))
  
  
  (method (move-horizontally d)
    (set-position (vertex+& position (vertex-scalar*& (get-right~ lookat) d)))
    (derive-target)
    (camera-update))
  
  
  (method (move-up)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-world-up~ world) (* strafe-speed 2))))
      (derive-target)
      (camera-update)))
  
  
  (method (move-down)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-world-up~ world) (- (* strafe-speed 2)))))
      (derive-target)
      (camera-update)))
  
  
  (method (rotate-left)
    (rotate-horizontal rotate-speed))
  
  
  (method (rotate-right)
    (rotate-horizontal (- rotate-speed)))
  
  
  (method (rotate-horizontal angle)
    (let ((world (current-world)))
      (set-lookat (rotate-lookat& lookat angle (get-world-up~ world)))
      (derive-target)
      (camera-update)))
  
  
  (method (rotate-up)
    (rotate-vertical rotate-speed))
  
  
  (method (rotate-down)
    (rotate-vertical (- rotate-speed)))
  
  
  (method (rotate-vertical angle)
    (let ((world (current-world)))
      (rotate-lookat-vertical-up! lookat angle (get-world-up~ world))
      (derive-target)
      (camera-update)))
  
  
  (method (rotate-vertical-up angle up)
    (rotate-lookat-vertical-up! lookat angle up)
    (derive-target)
    (camera-update))
  
  
  ;;;
  ;;;; Orientation
  ;;;
  
  
  (method (draw-orientation)
    (let ((center (vertex-& (vertex-& (vertex+& position (vertex-scalar*& (get-sight~ lookat) 5.)) (vertex-scalar*& (get-right~ lookat) 1.5)) (get-up~ lookat))))
      (let ((sight (vertex+& center (get-sight~ lookat)))
            (up (vertex+& center (get-up~ lookat)))
            (right (vertex+& center (get-right~ lookat)))
            (axis-x (vertex+& center (vertex 1. 0. 0.)))
            (axis-y (vertex+& center (vertex 0. 1. 0.)))
            (axis-z (vertex+& center (vertex 0. 0. 1.))))
        (let ((cx (vertex-x center))
              (cy (vertex-y center))
              (cz (vertex-z center)))
          (glLineWidth 2.)
          (glDisable GL_LIGHTING)
          (gl-colorize-dye white-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x sight) (vertex-y sight) (vertex-z sight))
          (glEnd)
          (gl-colorize-dye white-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x right) (vertex-y right) (vertex-z right))
          (glEnd)
          (gl-colorize-dye white-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x up) (vertex-y up) (vertex-z up))
          (glEnd)
          (gl-colorize-dye red-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-x) (vertex-y axis-x) (vertex-z axis-x))
          (glEnd)
          (gl-colorize-dye green-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-y) (vertex-y axis-y) (vertex-z axis-y))
          (glEnd)
          (gl-colorize-dye blue-dye)
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-z) (vertex-y axis-z) (vertex-z axis-z))
          (glEnd)
          (glEnable GL_LIGHTING)
          (glLineWidth 1.)))))))
