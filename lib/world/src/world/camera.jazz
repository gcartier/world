;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Cameras
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.camera jazz


(import (jazz.geometry)
        (jazz.graphic.opengl.glew)
        (jazz.system)
        (world)
        (world.autoload)
        (world.draw)
        (world.dyes)
        (world.gadget)
        (world.geometry)
        (world.homogeneous)
        (world.lookat)
        (world.opengl)
        (world.serialization)
        (world.settings)
        (world.syntax (phase syntax))
        (world.window))


(definition public (make-camera)
  (new Camera))


(definition public (camera-copy! dst src)
  (size-change~ dst (get-size~ (current-world-window)))
  (set-position~ dst (get-position~ src))
  (set-lookat~ dst (get-lookat~ src))
  (derive-target~ dst)
  (camera-update~ dst))


(class Camera-Class extends (:class Gadget)
  
  
  (method override (marshall-object object)
    (serialize-object (class-of object)
                      (vector (serialize (get-position~ object))
                              (serialize (get-lookat~ object)))))
  
  
  (method override (unmarshall-object content)
    (bind-vector (position lookat) content
      (let ((camera (make-camera)))
        (size-change~ camera (get-size~ (current-world-window)))
        (set-position~ camera position)
        (set-lookat~ camera lookat)
        (derive-target~ camera)
        camera))))


;;;
;;;; Camera
;;;


(class Camera metaclass Camera-Class extends Gadget
  
  
  ;; target
  (slot target             <f64vector>       initialize (make-vertex) getter generate)
  
  ;; stable
  (slot dirty?             <bool>            initialize #f            getter generate)
  (slot stable?            <bool>            initialize #f            getter generate)
  (slot stable-since       <fl+>             initialize #f            getter generate)
  (slot stable-callback    <object>          initialize #f            accessors generate)
  
  ;; screen
  (slot screen-width       <fl>              initialize #f            accessors generate)
  (slot screen-height      <fl>              initialize #f            accessors generate)
  
  ;; projection
  (slot projection         <symbol>          initialize 'perspective  getter generate)
  
  ;; perspective
  (slot perspective-fov    <fl>              initialize 45.           accessors generate)
  (slot perspective-near   <fl>              initialize 0.1           accessors generate)
  (slot perspective-far    <fl>              initialize 10000.0       accessors generate)
  (slot view-distance      <fl>              initialize 60.           accessors generate)
  
  ;; orthographic
  (slot zoom-factor        <fl>              initialize 0.            accessors generate)
  
  ;; frustum
  (slot frustum-radius     <fl+>             initialize #f            accessors generate)
  (slot frustum-left       <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-bottom     <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-right      <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-top        <f64vector>       initialize (make-vertex) getter generate)
  (slot frustum-left-dot   <fl>              initialize 0.            getter generate)
  (slot frustum-bottom-dot <fl>              initialize 0.            getter generate)
  (slot frustum-right-dot  <fl>              initialize 0.            getter generate)
  (slot frustum-top-dot    <fl>              initialize 0.            getter generate)
  
  ;; matrix
  (slot projection-matrix  <f64vector>       initialize (make-matrix) getter generate)
  (slot view-matrix        <f64vector>       initialize (make-matrix) getter generate)
  
  ;; movement
  (slot move-speed         <fl>              initialize .2            accessors generate)
  (slot run-speed          <fl>              initialize 2.            accessors generate)
  (slot blink-speed        <fl>              initialize 2.            accessors generate)
  (slot warp-speed         <fl>              initialize 4.            accessors generate)
  (slot strafe-speed       <fl>              initialize 0.1           accessors generate)
  (slot rotate-speed       <fl>              initialize .035          accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-perspective-fov (world-setting 'world.perspective-fov 45.))
    (set-perspective-near (world-setting 'world.perspective-near 0.1))
    (set-perspective-far (world-setting 'world.perspective-far 10000.0))
    (set-model (camera-model)))
  
  
  (method protected virtual (camera-model)
    'Camera)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (present-vertex position)))))
  
  
  (method (size-change size)
    (set! screen-width (cast <fl> (get-width~ size)))
    (set! screen-height (cast <fl> (get-height~ size)))
    (prepare-projection))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method (set-target vert <f64vector>) <void>
    (unless (vertex-near? vert target)
      (vertex-copy! target vert)
      (dirty-update)))
  
  
  (method (derive-target)
    (assert (roll-free? lookat (get-world-up~ (current-world))))
    (set-target (vertex+& position (get-sight~ lookat))))
  
  
  (method (reset-camera)
    (standardize-lookat! lookat)
    (derive-target)
    (camera-update))
  
  
  ;;;
  ;;;; Stable
  ;;;
  
  
  (method (init-stable)
    (set! stable-since (current-seconds))
    (set! stable? #t))
  
  
  (method (reset-stable)
    (set! stable-since (current-seconds))
    (set! stable? #f)
    (when stable-callback
      (stable-callback stable?)))
  
  
  (method (update-stable stable-delay)
    (unless stable?
      (when (>= (- (current-seconds) stable-since) stable-delay)
        (set! stable? #t)
        (when stable-callback
          (stable-callback stable?)))))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method override (update-matrix)
    (nextmethod)
    (dirty-update))
  
  
  (method (camera-update)
    (when dirty?
      (update-frustum)
      (reset-stable)
      (set! dirty? #f)))
  
  
  (method (dirty-update)
    (set! dirty? #t)
    (camera-update))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method (prepare-projection)
    (let ((ratio (/ screen-width screen-height)))
      (case projection
        ((perspective)
         (make-perspective-matrix! projection-matrix perspective-fov ratio perspective-near perspective-far))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (make-orthographic-matrix! projection-matrix (- width) width (- height) height perspective-near perspective-far)))))))
  
  
  (method (setup-camera)
    (make-view-matrix! view-matrix position lookat))
  
  
  (definition camera-limit <fl>
    5.)
  
  
  (method (move-camera center-x)
    (let ((x (vertex-x position)))
      (if (> center-x (+ x camera-limit))
          (move-horizontally (- center-x (+ x camera-limit))))
      (if (< center-x (- x camera-limit))
          (move-horizontally (- center-x (- x camera-limit))))))
    
  
  ;;;
  ;;;; Screen
  ;;;
  
  
  (method (world->screen vertex)
    (let ((projection (make-perspective-matrix& perspective-fov (/ screen-width screen-height) perspective-near perspective-far))
          (view (make-view-matrix& position lookat)))
      (let ((projection/view (matrix-multiply& projection view)))
        (let ((vert (matrix-transform& projection/view vertex)))
          (new Point
            (fxround (* (+ (vertex-x vert) 1.) (/ screen-width 2.)))
            (fxround (* (- 1. (vertex-y vert)) (/ screen-height 2.))))))))
  
  
  (method (screen->ray h v)
    (let ((ratio (/ screen-width screen-height))
          (ch (- h (/ screen-width 2)))
          (cv (- (- screen-height v) (/ screen-height 2))))
      (case projection
        ((perspective)
         (let ((half-fov (/ (degree->radian perspective-fov) 2.))
               (up (get-up~ lookat)))
           (let ((cone (tan half-fov))
                 (d (vertex-distance position target))
                 (right (cross-product& (vertex-& target position) up)))
             (let ((target-in-eye-space (vertex+& (vertex-scalar*& up (/ (* cv d cone 2.) screen-height))
                                                  (vertex+& (vertex-scalar*& right (/ (* ch d cone 2. ratio) screen-width))
                                                            target))))
               (values (copy-vertex position) (vertex-normalize (vertex-& target-in-eye-space position)))))))
        ((orthographic)
         (let ((x (+ (/ (* 2. ch zoom-factor) screen-width) (vertex-x position)))
               (y (+ (/ (* 2. cv zoom-factor) screen-height ratio) (vertex-y position))))
           (values (vertex x y (vertex-z position)) (vertex 0. 0. -1.)))))))
  
  
  ;;;
  ;;;; Frustum
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (update-frustum)
    (let ((zone (current-zone+)))
      ;; quick hack around initialization order
      (let ((default-radius 13.856406460551018))
        (let ((radius <fl> (or frustum-radius (if (not zone) default-radius (or (get-sector-radius~ zone) default-radius)))))
          (frustum-normals! frustum-left frustum-bottom frustum-right frustum-top)
          (set! frustum-left-dot (- (f64-ref (dot-product& frustum-left position)) radius))
          (set! frustum-bottom-dot (- (f64-ref (dot-product& frustum-bottom position)) radius))
          (set! frustum-right-dot (- (f64-ref (dot-product& frustum-right position)) radius))
          (set! frustum-top-dot (- (f64-ref (dot-product& frustum-top position)) radius))))))
  
  
  (method (frustum-normals! left-normal <f64vector> bottom-normal <f64vector> right-normal <f64vector> top-normal <f64vector>) <void>
    ;; copied from screen->ray for performance
    (let ((ratio (/ screen-width screen-height))
          (half-fov (/ (degree->radian perspective-fov) 2.))
          (up (get-up~ lookat)))
      (let ((cone (tan half-fov))
            (d (f64-ref (vertex-distance& position target)))
            (right (cross-product& (vertex-& target position) up)))
        (define (compute-normal! res <f64vector> h <fl> v <fl>) <void>
          (let ((ch (- h (/ screen-width 2.)))
                (cv (- (- screen-height v) (/ screen-height 2.))))
            (let ((target-in-eye-space (vertex+& (vertex-scalar*& up (/ (* cv d cone 2.) screen-height))
                                                 (vertex+& (vertex-scalar*& right (/ (* ch d cone 2. ratio) screen-width))
                                                           target))))
              (vertex-normalize! res (vertex-& target-in-eye-space position)))))
        
        (let ((r00 (make-vertex&))
              (r01 (make-vertex&))
              (r10 (make-vertex&))
              (r11 (make-vertex&)))
          (compute-normal! r00 0. 0.)
          (compute-normal! r01 0. screen-height)
          (compute-normal! r10 screen-width 0.)
          (compute-normal! r11 screen-width screen-height)
          (cross-product! left-normal r01 r00)
          (cross-product! bottom-normal r00 r10)
          (cross-product! right-normal r10 r11)
          (cross-product! top-normal r11 r01)))))
  
  
  (method (in-frustum? pos <f64vector>) <bool>
    (and (>= (f64-ref (dot-product& frustum-left pos)) frustum-left-dot)
         (>= (f64-ref (dot-product& frustum-bottom pos)) frustum-bottom-dot)
         (>= (f64-ref (dot-product& frustum-right pos)) frustum-right-dot)
         (>= (f64-ref (dot-product& frustum-top pos)) frustum-top-dot)))
  
  
  (proclaim (not warn optimizations))

  
  ;;;
  ;;;; Zoom
  ;;;
  
  
  (method (zoom-speed)
    1.)

  
  (method (zoom-in)
    (case projection
      ((perspective)
       (let ((me (get-camera-me)))
         (increase! view-distance (- (zoom-speed)))
         (vertex+! position me (vertex-scalar*& (get-sight~ lookat) (- view-distance)))
         (derive-target)
         (camera-update)))
      ((orthographic)
       (set! zoom-factor (* zoom-factor .75)))))
  
  
  (method (zoom-out)
    (case projection
      ((perspective)
       (let ((me (get-camera-me)))
         (increase! view-distance (zoom-speed))
         (vertex+! position me (vertex-scalar*& (get-sight~ lookat) (- view-distance)))
         (derive-target)
         (camera-update)))
      ((orthographic)
       (set! zoom-factor (/ zoom-factor .75)))))
  
  
  (method (get-camera-me)
    (vertex+ position (vertex-scalar*& (get-sight~ lookat) view-distance)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method (move-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) move-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (move-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- move-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (run-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) run-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (run-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- run-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (blink-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) blink-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (blink-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- blink-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (warp-forward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) warp-speed)))
    (derive-target)
    (camera-update))
  
  
  (method (warp-backward)
    (set-position (vertex+& position (vertex-scalar*& (get-sight~ lookat) (- warp-speed))))
    (derive-target)
    (camera-update))
  
  
  (method (move-left)
    (move-horizontally (- (* strafe-speed 2))))
  
  
  (method (move-right)
    (move-horizontally (* strafe-speed 2)))
  
  
  (method (move-horizontally d)
    (set-position (vertex+& position (vertex-scalar*& (get-right~ lookat) d)))
    (derive-target)
    (camera-update))
  
  
  (method (move-up)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-world-up~ world) (* strafe-speed 2))))
      (derive-target)
      (camera-update)))
  
  
  (method (move-down)
    (let ((world (current-world)))
      (set-position (vertex+& position (vertex-scalar*& (get-world-up~ world) (- (* strafe-speed 2)))))
      (derive-target)
      (camera-update)))
  
  
  (method (rotate-left)
    (rotate-horizontal rotate-speed))
  
  
  (method (rotate-right)
    (rotate-horizontal (- rotate-speed)))
  
  
  (method (rotate-horizontal angle)
    (let ((world (current-world)))
      (set-lookat (rotate-lookat& lookat angle (get-world-up~ world)))
      (derive-target)
      (camera-update)))
  
  
  (method (rotate-up)
    (rotate-vertical rotate-speed))
  
  
  (method (rotate-down)
    (rotate-vertical (- rotate-speed)))
  
  
  (method (rotate-vertical angle)
    (let ((world (current-world)))
      (rotate-lookat-vertical-up! lookat angle (get-world-up~ world))
      (derive-target)
      (camera-update)))
  
  
  (method (rotate-vertical-up angle up)
    (rotate-lookat-vertical-up! lookat angle up)
    (derive-target)
    (camera-update))
  
  
  ;;;
  ;;;; Orientation
  ;;;
  
  
  (method (draw-orientation)
    (let ((center (vertex-& (vertex-& (vertex+& position (vertex-scalar*& (get-sight~ lookat) 5.)) (vertex-scalar*& (get-right~ lookat) 1.5)) (get-up~ lookat))))
      (let ((sight (vertex+& center (get-sight~ lookat)))
            (up (vertex+& center (get-up~ lookat)))
            (right (vertex+& center (get-right~ lookat)))
            (axis-x (vertex+& center (vertex 1. 0. 0.)))
            (axis-y (vertex+& center (vertex 0. 1. 0.)))
            (axis-z (vertex+& center (vertex 0. 0. 1.))))
        (let ((cx (vertex-x center))
              (cy (vertex-y center))
              (cz (vertex-z center))
              (width .01))
          (glDisable GL_DEPTH_TEST)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x sight) (vertex-y sight) (vertex-z sight))
                       width
                       white-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x right) (vertex-y right) (vertex-z right))
                       width
                       white-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x up) (vertex-y up) (vertex-z up))
                       width
                       white-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x axis-x) (vertex-y axis-x) (vertex-z axis-x))
                       width
                       red-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x axis-y) (vertex-y axis-y) (vertex-z axis-y))
                       width
                       green-dye)
          (render-line (vertex cx cy cz)
                       (vertex (vertex-x axis-z) (vertex-y axis-z) (vertex-z axis-z))
                       width
                       blue-dye)
          (glEnable GL_DEPTH_TEST)))))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method override (history-draw-now?)
    #t)
  
  
  (method override (history-draw-trail?)
    #t)))
