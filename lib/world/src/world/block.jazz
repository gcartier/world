;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Blocks
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.block jazz


(import (jazz.geometry)
        (world)
        (world.autoload)
        (world.draw)
        (world.dye)
        (world.entity)
        (world.face)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.model)
        (world.renderers)
        (world.syntax (phase syntax))
        (world.texture))


;;;
;;;; Block-Model
;;;


(class Block-Model extends Model
  
  
  (slot flat? <bool> initialize #f accessors generate)
  
  
  (method override (block?)
    #t))


;;;
;;;; Block
;;;


(class Block extends Entity
  
  
  (property rotation initialize #f getter generate setter explicit)
  (property images   initialize #f accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-model 'Dirty)
    (set-color (dye .525 .321 .004 1.)))
  
  
  (method override (resolve-model)
    (registered-model model))
  
  
  (method override (set-shaders value)
    (set! shaders value))
  
  
  (method public (set-rotation rot)
    (set! rotation rot)
    (case rotation
      ((north))
      ((east) (rotate (- PI/2)))
      ((south) (rotate PI))
      ((west) (rotate PI/2))))
  
  
  (method (image-ref n)
    (and images (list-ref images n)))
  
  
  (method (shader-ref n)
    (and shaders (list-ref shaders n)))
  
  
  ;; extract model polygons and create new faces with our images
  (method override (element-faces)
    (let ((world (current-world))
          (model (cache-model)))
      (let ((rank 0))
        (map (lambda (face poly)
               (prog1 (let ((image (image-ref rank))
                            (shader (shader-ref rank)))
                        (if (not image)
                            (if (not shader)
                                (make-face (get-material~ face) (get-texture-coordinates~ face) (get-texture-depth~ face) poly)
                              (let ((material (copy-material (get-material~ face))))
                                (set-renderer~ material (require-renderer shader))
                                (make-face material (get-texture-coordinates~ face) (get-texture-depth~ face) poly)))
                          (let ((uv (image-coordinates (or image "dirty"))))
                            (let ((tl (uv-left uv))
                                  (tt (uv-top uv))
                                  (tr (uv-right uv))
                                  (tb (uv-bottom uv))
                                  (depth (uv-depth uv)))
                              (let ((coordinates (f32vector tl tt tl tb tr tb tr tt)))
                                (let ((material (find-block-material~ world (or shader (find-texture-shader~ world image) 'opaque))))
                                  (make-face material coordinates depth poly)))))))
                 (increase! rank)))
             (get-faces~ model)
             (element-polygons)))))
  
  
  (method override (element-polygons)
    (let ((model (cache-model)))
      (polygons-extract self (get-polygons~ model) matrix)))
  
  
  (method override (draw-target dye)
    (let ((matrix (matrix-multiply& (effective-matrix&) (make-scaling-matrix& (vertex& 1.0001 1.0001 1.0001)))))
      (render-cube matrix dye)))
  
  
  (method override (update-face-texture face face-rank texture)
    (let ((zone (current-zone))
          (model (cache-model)))
      (let ((designer (get-designer~ zone)))
        (let ((images (or images (make-list (length (get-faces~ model)) #f))))
          (let ((actual (list-ref images face-rank)))
            (unless (equal? texture actual)
              (list-set! images face-rank texture)
              (set-property~ designer self 'images images)
              #t))))))
  
  
  (method override (update-face-shader face face-rank shader)
    (let ((zone (current-zone))
          (model (cache-model)))
      (let ((designer (get-designer~ zone)))
        (let ((shaders (or shaders (make-list (length (get-faces~ model)) #f))))
          (let ((actual (list-ref shaders face-rank)))
            (unless (equal? shader actual)
              (list-set! shaders face-rank shader)
              (set-property~ designer self 'shaders shaders)
              #t))))))
  
  
  (method override (target-moveable?)
    #f)))
