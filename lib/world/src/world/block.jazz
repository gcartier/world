;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Blocks
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.block jazz


(import (jazz.geometry)
        (world)
        (world.autoload)
        (world.draw)
        (world.dye)
        (world.entity)
        (world.face)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.model)
        (world.renderers)
        (world.syntax (phase syntax))
        (world.texture))


;;;
;;;; Block-Model
;;;


(class Block-Model extends Model
  
  
  (slot flat? <bool> initialize #f accessors generate)
  
  
  (method override (block?)
    #t))


;;;
;;;; Block
;;;


(class Block extends Entity
  
  
  (property rotation initialize #f getter generate setter explicit)
  (property images   initialize #f accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-model 'Dirty)
    (set-color (dye .525 .321 .004 1.)))
  
  
  (method override (resolve-model)
    (registered-model model))
  
  
  (method override (set-shaders value)
    (set! shaders value))
  
  
  (method public (set-rotation rot)
    (set! rotation rot)
    (case rotation
      ((north))
      ((east) (rotate (- PI/2)))
      ((south) (rotate PI))
      ((west) (rotate PI/2))))
  
  
  (method (image-ref n)
    (and images (list-ref images n)))
  
  
  (method (shader-ref n)
    (and shaders (list-ref shaders n)))
  
  
  ;; extract model polygons and create new faces with our images
  (method override (element-faces)
    (let ((world (current-world))
          (model (cache-model)))
      (let ((rank 0))
        (map (lambda (face poly)
               (prog1 (let ((image (image-ref rank))
                            (shader (shader-ref rank)))
                        (if (not image)
                            (if (not shader)
                                (make-face (get-material~ face) (get-texture-coordinates~ face) (get-texture-depth~ face) poly)
                              (let ((material (copy-material (get-material~ face))))
                                (set-renderer~ material (require-renderer shader))
                                (make-face material (get-texture-coordinates~ face) (get-texture-depth~ face) poly)))
                          (let ((uv (image-coordinates (or image "dirty"))))
                            (let ((tl (uv-left uv))
                                  (tt (uv-top uv))
                                  (tr (uv-right uv))
                                  (tb (uv-bottom uv))
                                  (depth (uv-depth uv)))
                              (let ((coordinates (f32vector tl tt tl tb tr tb tr tt)))
                                (let ((material (find-block-material~ world (or shader (find-texture-shader~ world image) 'opaque))))
                                  (make-face material coordinates depth poly)))))))
                 (increase! rank)))
             (get-faces~ model)
             (element-polygons)))))
  
  
  (method override (element-polygons)
    (let ((model (cache-model)))
      (polygons-extract self (get-polygons~ model) matrix)))
  
  
  (method override (draw-target color)
    (for-each (lambda (poly)
                (draw-polygon poly color))
              (element-polygons)))
  
  
  (method override (update-face-texture face face-rank texture)
    (let ((zone (current-zone))
          (model (cache-model)))
      (let ((designer (get-designer~ zone)))
        (let ((images (or images (make-list (length (get-faces~ model)) #f))))
          (let ((actual (list-ref images face-rank)))
            (unless (equal? texture actual)
              (list-set! images face-rank texture)
              (set-property~ designer self 'images images)
              #t))))))
  
  
  (method override (update-face-shader face face-rank shader)
    (let ((zone (current-zone))
          (model (cache-model)))
      (let ((designer (get-designer~ zone)))
        (let ((shaders (or shaders (make-list (length (get-faces~ model)) #f))))
          (let ((actual (list-ref shaders face-rank)))
            (unless (equal? shader actual)
              (list-set! shaders face-rank shader)
              (set-property~ designer self 'shaders shaders)
              #t))))))
  
  
  (method override (target-moveable?)
    #f)))
