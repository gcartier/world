;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Creatures
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.creature jazz


(import (jazz.geometry)
        (jazz.syntax (phase syntax))
        (world)
        (world.actor)
        (world.audio)
        (world.autoload)
        (world.change)
        (world.changes)
        (world.commands)
        (world.configure)
        (world.dye)
        (world.dyes)
        (world.generation.block)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.scripting)
        (world.settings)
        (world.syntax (phase syntax))
        (world.task)
        (world.travel))


;;;
;;;; Creature
;;;


(definition public default-creature-behavior <symbol+>
  (world-setting 'world.creature-behavior #f))

(definition public non-user-aggroes? <bool>
  (world-setting 'world.non-user-aggroes? #f))


(definition protected attack-distance <fl>
  .1)


(definition public creature-models? <bool>
  (world-setting 'world.creature-models? #f))

(definition public (set-creature-models? flag <bool>)
  (set! creature-models? flag))


(class Creature extends Actor
  
  
  (slot tick?            <bool>       initialize #t accessors generate)
  (slot tick-count       <fx>         initialize -1 accessors generate)
  (slot path-duration    <fl+>        initialize #f accessors generate)
  (slot behavior         <symbol+>    initialize #f accessors generate)
  (slot attack?          <bool>       initialize #f accessors generate)
  (slot attack-delay     <fl+>        initialize #f accessors generate)
  (slot aggro-radius     <fl+>        initialize #f accessors generate)
  (slot aggro-target     <Player+>    initialize #f accessors generate)
  (slot spawner          <object>     initialize #f accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (prepare-pathing))
  
  
  (method override (call-model-update model)
    (nextmethod model)
    (set! aggro-radius 25.)
    @until-horizontal-debugged
    (set! orientation (or (get-orientation~ model) 'horizontal)))
  
  
  (method protected virtual (update-model (anchor?: anchor? #f))
    )
  
  
  (method override (setup-area-cube)
    (unless (client?)
      (nextmethod)))
  
  
  (method override (update-area-cube)
    (assert (not (client?))
      (nextmethod)))
  
  
  (method override (run-task script)
    (task-start script))
  
  
  (method override (task-name)
    (if (string? model)
        (let ((pos (string-find model #\/)))
          (if pos
              (string->symbol (substring model (+ pos 1) (string-length model)))
            (string->symbol model)))
      'creature))
  
  
  (method override (task-priority)
    (if spawner
        creature-priority
      entity-priority))
  
  
  (method override (task-run task script)
    (declare (proper-tail-calls))
    (if script
        (nextmethod task script)
      (with-script-task task
        (lambda (exit)
          (let (iter (previous (current-seconds)))
            (handle-events)
            ;; not 100% correct if preempted before task-mutex
            (let ((time (current-seconds)))
              (unless (stopping?~ task)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused?~ history)
                        (tick-creature time elapse))))))
              (let ((duration (- (current-seconds) time)))
                (task-sleep task creature-period duration exit))
              (iter time)))))))
  
  
  (method override (fallthrough)
    (%%stay))
  
  
  (method (tick-creature time elapse)
    (let ((world (current-world))
          (history (current-history)))
      (site (creature on?: #t)
        (tick-sliced~ world self #f time elapse)
        (with-task-mutex
          (lambda ()
            (unless (get-paused?~ history)
              (animate elapse)))))))
  
  
  (method override (tick commands time elapse)
    (let ((history (current-history)))
      (set! tick-count (modulo (+ tick-count 1) creature-ticks))
      (let ((script (get-script)))
        (let ((tick (and script (get-tick~ script))))
          (if tick
              (bind (invocation . proc) tick
                (running-handler~ script
                  (lambda ()
                    (parameterize ((current-event (new Tick-Event self time elapse)))
                      (proc self)))))
            (with-task-mutex
              (lambda ()
                (unless (get-paused?~ history)
                  (case (or behavior default-creature-behavior)
                    ((stay) (tick-actor stay-commands time elapse #t 'slide))
                    ((move) (tick-actor move-commands time elapse #t 'slide))
                    ((path) (tick-path time elapse))
                    ((hostile) (tick-hostile time elapse)))))))))))
  
  
  (method (tick-path time elapse)
    (let ((me (current-me+)))
      (when (and tick? (or (not me) (neq? self (get-controlled~ me))))
        (when (and path-duration (> path-duration 0.))
          (decrease! path-duration elapse))
        (move-creature time elapse)
        (when (and (= (modulo tick-count aggro-ticks) 0)
                   (<= path-duration 0.))
          (path-creature)))))
  
  
  (method (tick-hostile time elapse)
    (let ((me (current-me+)))
      (when (record-change? self)
        (when (and tick? (or (not me) (neq? self (get-controlled~ me))))
          (when (and (not aggro-target) path-duration (> path-duration 0.))
            (decrease! path-duration elapse))
          (when aggro-target
            (when (and attack-delay (> attack-delay 0.))
              (decrease! attack-delay elapse))
            (lookat-target)
            (set! motion 'walk))
          (set! attack? (and aggro-target (< (vertex-distance position (get-position~ aggro-target)) (+ (get-radius) (get-radius~ aggro-target) attack-distance))))
          (if attack?
              (attack-player aggro-target)
            (move-creature time elapse))
          (when (and (not aggro-target) (= (modulo tick-count aggro-ticks) 0))
            (or (players-aggro)
                (when (<= path-duration 0.)
                  (path-creature))))))))
  
  
  (method (move-creature time elapse (gravity?: gravity? #t) (response: response 'slide) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f) (ignore-me?: ignore-me? #f))
    (let ((idle? (and (eq? motion 'idle) (not aggro-target))))
      (if (and jump? (not idle?))
          (begin
            (set! jump? #f)
            (tick-actor move/jump-commands time elapse gravity? response ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: #f))
        (let ((commands (if idle? stay-commands move-commands)))
          (let ((info (tick-actor commands time elapse gravity? response ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: #f)))
            (when (and info (or (not jump-time) (> time (+ jump-time (if aggro-target 1. 2.)))))
              (bind-values (center slide-collisions fall-collisions) info
                (when (or (not-null? slide-collisions) (random-jump?))
                  (set! jump? #t)))))))))
  
  
  (method (random-jump?)
    (let ((number (random-jump)))
      (and number (< (random-real) number))))
  
  
  (method protected virtual (random-jump)
    #f)
  
  
  (method override (adjust-fast-slide! center new-center)
    (when aggro-target
      (let ((target (get-position~ aggro-target)))
        (let ((direct (vertex-& target center))
              (actual (vertex-& new-center center)))
          (let ((dist (vertex-norm& actual)))
            (when (and (not (vertex-zero? direct)) (> dist 0.))
              ;; only consider reasonable angles with the aggro target
              (when (< (abs (dot-product& (vertex-normalize& direct) (vertex-normalize& actual))) .1)
                (let ((proj (/ (dot-product& direct actual) dist)))
                  (when (< proj dist)
                    (vertex+! new-center center (vertex-scalar*& (vertex-normalize& actual) proj)))))))))))
  
  
  (method public virtual (aggro-sound)
    #f)
  
  
  (method public virtual (attack-sound)
    #f)
  
  
  (method (players-aggro)
    (when (and aggro-radius (not aggro-target))
      (let ((zone (current-zone)))
        (let (iter (scan (get-players~ zone)))
          (if (null? scan)
              (begin
                (set! aggro-target #f)
                #f)
            (let ((player (car scan)))
              (if (and (or (user?) non-user-aggroes?) (can-aggro? player) (aggro-sight? player))
                  (begin
                    (aggro-player player)
                    #t)
                (let (iter1 (creatures (get-aggroed-creatures~ player)))
                  (if (null? creatures)
                      (iter (cdr scan))
                    (let ((creature (car creatures)))
                      (if (aggro-sight? creature)
                          (begin
                            (aggro-player (get-aggro-target~ creature))
                            #t)
                        (iter1 (cdr creatures)))))))))))))
  
  
  (method (can-aggro? player)
    (and (is? player Player)
         (not (admin-me?~ player))))
  
  
  (method (aggro-sight? obj)
    (define (polygon-filter poly)
      (let ((element (get-element~ poly)))
        (and (not (eq? element self))
             (or (eq? element obj) (is-not? element Creature))
             (not (get-liquid-cube?~ (id->block (decode-id (get-data1~ poly))))))))
    
    (let ((position (lens-center))
          (pos (lens-center~ obj)))
      (let ((dist (vertex-distance position pos)))
        (and (<= dist aggro-radius)
             (< (vector-angle (get-sight~ lookat) (vertex-& pos position)) PI/2)
             (let ((dir (vertex-& pos position)))
               (and (not (vertex-zero? dir))
                    (let ((closest (ray-closest-polygon position (vertex-normalize dir) (+ aggro-radius (get-radius) (get-radius~ obj)) filter: polygon-filter ignore-entities?: #f)))
                      @debug
                      (when closest
                        (let ((poly (first closest)))
                          (debug (or (get-element~ poly) (list (decode-id (get-data1~ poly))
                                                               (flonum->fixnum (get-data2~ poly))
                                                               (flonum->fixnum (get-data3~ poly))
                                                               (flonum->fixnum (get-data4~ poly)))))))
                      (and closest (equal? (get-element~ (first closest)) obj)))))))))
  
  
  (method (aggro-player player)
    (when (neq? player aggro-target)
      (set! aggro-target player)
      (set-aggroed-creatures~ player (cons self (get-aggroed-creatures~ player)))
      (play-3d-sound-if (aggro-sound) position))
    (lookat-target))
  
  
  (method (lookat-target)
    (let ((pos (get-position~ aggro-target)))
      (let ((dir (vertex-& (vertex& (vertex-x pos) (vertex-y position) (vertex-z pos)) position)))
        (unless (vertex-near-zero? dir)
          (let ((old-lookat (lookat-copy& lookat)))
            (horizon-sight! dir)
            (lookat-change (current-seconds) self #f #f old-lookat lookat))))))
  
  
  (method override (attacking?)
    attack?)
  
  
  (method (attack-player player)
    (when (or (not attack-delay) (<= attack-delay 0))
      (play-3d-sound-if (attack-sound) position)
      (when (find-animation~ (cache-model) "AttackUnarmed")
        (transition-morphing "AttackUnarmed")
        (set! animation-active "AttackUnarmed"))
      (wound~ player self 1.)
      (set! attack-delay 1.5)))
  
  
  (method (prepare-pathing)
    (set! path-duration (random-between 1. 3.)))
  
  
  (method protected virtual (path-creature)
    (cond ((< (random-real) .333)
           (set! motion 'idle))
          (else
           (set! motion 'walk)
           (horizon-sight! (random-horizon))))
    (prepare-pathing))
  
  
  (method override (wound inflictor (amount #f))
    (nextmethod inflictor amount)
    (let ((script (get-script)))
      (if (and script (get-hit~ script))
          (bind (invocation . proc) (get-hit~ script)
            (case invocation
              ((handle)
               (running-handler~ script
                 (lambda ()
                   (parameterize ((current-event (new Script-Event self (current-seconds))))
                     (proc self)))))
              ((accept)
               (enqueue-event~ script 'hit))))
        (when (and alive? (can-aggro? inflictor))
          (aggro-player inflictor)))))
  
  
  (method override (die)
    (let ((zone (current-zone)))
      (set! alive? #f)
      (when aggro-target
        (set-aggroed-creatures~ aggro-target (remove! self (get-aggroed-creatures~ aggro-target))))
      (nextmethod)))
  
  
  (method override (resurrect)
    (when aggro-target
      (set-aggroed-creatures~ aggro-target (cons self (get-aggroed-creatures~ aggro-target))))
    (nextmethod)))


;;;
;;;; Spawn
;;;


(class Spawn extends Creature
  
  
  (method override (client-simulated?)
    #t))


;;;
;;;; Wolf
;;;


(class Wolf extends Spawn
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! aggro-radius 40.)
    (update-model))
  
  
  (method override (element-radiuses)
    (vertex .4 .4 .4))
  
  
  (method override (element-radius)
    .4)
  
  
  (method override (target-radius)
    (* (average-scaling) 1.8))
  
  
  (method override (update-model (anchor?: anchor? #f))
    (cond ((not creature-models?)
           (set-scaling .4)
           (set-color (dye .157 .157 .157 1.))
           (change-model 'Wolf anchor?)
           (free-morphing))
          (else
           (set-scaling .5)
           (change-model "creature/direwolf" anchor?))))
  
  
  (method override (task-name)
    'wolf)
  
  
  (method override (walk-speed)
    (if aggro-target
        4.5
      3.))
  
  (method override (run-speed)
    6.5)
  
  
  (method override (aggro-sound)
    "sound/creature/wolf/aggro")
  
  (method override (attack-sound)
    "sound/creature/wolf/attack")
  
  (method override (wound-sound)
    "sound/creature/wolf/wound")
  
  (method override (wound-critical-sound)
    "sound/creature/wolf/woundCritical")
  
  (method override (death-sound)
    "sound/creature/wolf/death"))


;;;
;;;; Spider
;;;


(class Spider extends Spawn
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! aggro-radius 25.)
    (update-model))
  
  
  (method override (element-radiuses)
    (vertex .4 .4 .4))
  
  
  (method override (element-radius)
    .4)
  
  
  (method override (target-radius)
    (* (average-scaling) 1.8))
  
  
  (method override (update-model (anchor?: anchor? #f))
    (cond ((not creature-models?)
           (set-scaling .4)
           (set-color (dye 0. .235 0. 1.))
           (change-model 'Spider anchor?)
           (free-morphing))
          (else
           (set-scaling .5)
           (change-model "creature/scorpion" anchor?))))
  
  
  (method override (task-name)
    'spider)
  
  
  (method override (walk-speed)
    (if aggro-target
        2.
      1.5))
  
  (method override (run-speed)
    3.25)
  
  
  (method override (aggro-sound)
    "sound/creature/spider/aggro")
  
  (method override (attack-sound)
    "sound/creature/spider/attack")
  
  (method override (wound-sound)
    "sound/creature/spider/wound")
  
  (method override (wound-critical-sound)
    "sound/creature/spider/woundCritical")
  
  (method override (death-sound)
    "sound/creature/spider/death"))


;;;
;;;; Jumper
;;;


(class Jumper extends Spawn
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! aggro-radius 40.)
    (update-model))
  
  
  (method override (element-radiuses)
    (vertex .4 .4 .4))
  
  
  (method override (element-radius)
    .4)
  
  
  (method override (target-radius)
    (* (average-scaling) 1.8))
  
  
  (method override (update-model (anchor?: anchor? #f))
    (cond ((not creature-models?)
           (set-scaling .4)
           (set-color (dye .4 0. .5 .3))
           (change-model 'Jumper anchor?)
           (free-morphing))
          (else
           (set-scaling .5)
           (change-model "creature/sporebat" anchor?))))
  
  
  (method override (task-name)
    'jumper)
  
  
  (method override (walk-speed)
    (if aggro-target
        3.
      2.))
  
  (method override (run-speed)
    5.)
  
  
  (method override (aggro-sound)
    "sound/creature/jumper/aggro")
  
  (method override (attack-sound)
    "sound/creature/jumper/attack")
  
  (method override (wound-sound)
    "sound/creature/jumper/wound")
  
  (method override (wound-critical-sound)
    "sound/creature/jumper/woundCritical")
  
  (method override (death-sound)
    "sound/creature/jumper/death")
  
  
  (method override (random-jump)
    .005))


;;;
;;;; Turtle
;;;


@wait-missing-turf-tile
(class Turtle extends Spawn
  
  
  (slot stomp-time <fl> initialize 0. accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-color green-dye)
    (set-model 'Turtle))
  
  
  (method override (element-radiuses)
    (vertex .2 .2 .2))
  
  
  (method override (element-radius)
    .2)
  
  
  (method override (target-radius)
    .3)
  
  
  (method override (path-creature)
    (let ((zone (current-zone)))
      (if (getf (get-properties~ zone) victor?:)
          (vertex-x-set! velocity turtle-speed)
        (nextmethod))))
  
  
  (method override (tick commands time elapse)
    (let ((zone (current-zone)))
      (when tick?
        (if stomp-time
            (when (>= time stomp-time)
              (set! stomp-time #f))
          (move-creature time elapse)
          (when (and (getf (get-properties~ zone) victor?:)
                     (or (< (get-x) -35.)
                         (> (get-x) -27.)))
            (rebound-x))))))
  
  
  (method override (stomp)
    (set! stomp-time (+ (current-seconds) 3.))
    #t)))
