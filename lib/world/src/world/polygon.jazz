;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Polygons
;;;


(module world.polygon jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world)
        (world.geometry)
        (world.homogeneous)
        (world.plane)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Polygon
;;;


(class Polygon extends Plane
  
  
  (slot element  <object> getter generate)
  (slot vertices <vector> getter generate)
  (slot radius   <fl>     getter generate)
  @new
  (slot normalnew         getter generate)
  
  
  (method override (initialize element vertices normal)
    (debug-allocation Polygon)
    (nextmethod (center-of-mass& vertices) normal)
    (set! element~self element)
    (set! vertices~self vertices)
    (set! radius~self (polygon-radius origin vertices))
    @new
    (set! normalnew~self (polygon-normal vertices)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a}" vertices origin normal))))
  
  
  (method protected virtual (triangle-count)
    )
  
  
  (method protected virtual (add-triangles uv add)
    )
  
  
  (method protected virtual (iterate-triangles proc)
    )
  
  
  (method public inline (get-center)
    origin)
  
  
  (method public (ray-closest-triangle p <f32vector> d <f32vector> filter <procedure+>)
    (let ((closest #f)
          (distance -1.)
          (normal (get-normal)))
      (iterate-triangles
        (lambda (v1 v2 v3)
          (when (or (not filter)
                    (filter self normal))
            (let ((dist (ray-triangle-distance p d v1 v2 v3)))
              (when (and (/= dist -1.)
                         (or (= distance -1.)
                             (< dist distance)))
                (set! closest (list self dist))
                (set! distance dist))))))
      closest))
  
  
  (method public (inside? p <f32vector> epsilon <fl>) <bool>
    (let ((pos 0)
          (neg 0)
          (vertex-count (vector-length vertices)))
      (for (i 0 vertex-count)
           (let ((p0 (vector-ref vertices i))
                 (p1 (vector-ref vertices (let ((j (+ i 1))) (if (< j vertex-count) j 0)))))
             ;; Generate a normal for this edge
             (let ((n (cross-product& (vertex-& p1 p0) normal)))
               ;; Which side of this edge-plane is the point?
               (let ((half-plane (- (f32-ref (dot-product& p n)) (f32-ref (dot-product& p0 n)))))
                 ;; Keep track of positives & negatives (but not zeros -- which means it's on the edge)
                 (cond ((> half-plane epsilon)
                        (increase! pos))
                       ((< half-plane (- epsilon))
                        (increase! neg)))))))
      ;; If they're ALL positive or ALL negative then it's inside
      (or (= pos 0)
          (= neg 0))))
  
  
  (method public (closest-point-on-perimeter p <f32vector>) <values>
    (let ((closest-point (make-vertex))
          (closest-p0 (make-vertex))
          (closest-p1 (make-vertex)))
      (let ((edge-flag (closest-point-on-perimeter! p closest-point closest-p0 closest-p1)))
        (values closest-point closest-p0 closest-p1 edge-flag))))
  
  
  (method public (closest-point-on-perimeter! p <f32vector> closest-point <f32vector> closest-p0 <f32vector> closest-p1 <f32vector>) <bool>
    (let ((found #f)
          (edge-flag #f)
          (closest-distance 0.)
          (closest-index <fx> 0)
          (vertex-count <fx> (vector-length vertices)))
      (for (i 0 vertex-count)
           (let ((p1 (vector-ref vertices i))
                 (p0 (vector-ref vertices (let ((j (- i 1))) (if (< j 0) (- vertex-count 1) j))))
                 (cp (make-vertex&)))
             (let ((edge? (closest-point-on-line-segment! cp p0 p1 p)))
               (let ((d (f32-ref (vertex-distance& cp p))))
                 (when (or (not found) (< d closest-distance))
                   (set! closest-distance d)
                   (vertex-copy! closest-point cp)
                   (vertex-copy! closest-p0 p0)
                   (vertex-copy! closest-p1 p1)
                   (set! edge-flag edge?)
                   (set! closest-index i)
                   (set! found #t))))))
      (if (not edge-flag)
          (let ((a (- closest-index 1)))
            (when (< a 0)
              (set! a (- vertex-count 1)))
            (let ((b (+ closest-index 1)))
              (when (>= b vertex-count)
                (set! b 0))
              (vertex-copy! closest-p0 (vector-ref vertices a))
              (vertex-copy! closest-p1 (vector-ref vertices b))
              edge-flag))
        edge-flag)))))
