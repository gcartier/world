;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Polygons
;;;


(module world.polygon jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world)
        (world.geometry)
        (world.plane))


(definition public (closest-point-on-line-segment a b p)
  (let ((on-edge #t)
        (c (vertex- p a))
        (v (vertex-normalize (vertex- b a))))
    (let ((t (dot-product v c)))
      (if (< t 0)
          (values a (not on-edge))
        (let ((d (vertex-distance b a)))
          (if (> t d)
              (values b (not on-edge))
            (values (vertex+ a (vertex-scalar* v t)) on-edge)))))))


(definition public (closest-point-on-line a b p)
  (let ((c (vertex- p a))
        (v (vertex-normalize (vertex- b a))))
    (let ((t (dot-product v c))
          (d (vertex-distance b a)))
      (vertex+ a (vertex-scalar* v t)))))


;;;
;;;; Polygon
;;;


(class Polygon extends Object
  
  
  (slot vertices <object> initialize #f getter generate)
  (slot plane    <Plane>  initialize #f getter generate)
  
  
  (method override (initialize vertices plane)
    (nextmethod)
    (set! vertices~self vertices)
    (set! plane~self plane))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" vertices plane))))
  
  
  (method (calc-center-of-mass)
    (let ((center (vertex 0. 0. 0.)))
      (for-each (lambda (vertex)
                  (vertex+! center center vertex))
                vertices)
      (vertex-scalar*! center (/ 1. (length vertices)))))
  
  
  (method public (inside p epsilon)
    (let ((pos 0)
          (neg 0)
          (center (calc-center-of-mass)))
      (for-each-pair vertices
        proc: (lambda (pair)
                (let ((p0 (car pair))
                      (p1 (if (not-null? (cdr pair)) (cadr pair) (car vertices))))
                  ;; Generate a normal for this edge
                  (let ((n (cross-product (vertex- p1 p0) (get-normal~ plane))))
                    ;; Which side of this edge-plane is the point?
                    (let ((half-plane (- (dot-product p n) (dot-product p0 n))))
                      ;; Keep track of positives & negatives (but not zeros -- which means it's on the edge)
                      (cond ((> half-plane epsilon)
                             (increase! pos))
                            ((< half-plane (- epsilon))
                             (increase! neg))))))))
      ;; If they're ALL positive or ALL negative then it's inside
      (or (= pos 0)
          (= neg 0))))
  
  
  (method public (closest-point-on-perimeter p)
    (let ((found #f)
          (edge-flag #f)
          (closest-distance 0.)
          (closest-point = (vertex 0. 0. 0.))
          (closest-p0 #f)
          (closest-p1 #f)
          (closest-index #f)
          (vertex-count (length vertices)))
      (let (iter (p0 (last vertices)) (scan vertices) (index 0))
        (when (not-null? scan)
          (let ((p1 (car scan)))
            (receive (cp edge) (closest-point-on-line-segment p0 p1 p)
              (let ((d (vertex-distance cp p)))
                (when (or (not found) (< d closest-distance))
                  (set! closest-distance d)
                  (set! closest-point cp)
                  (set! closest-p0 p0)
                  (set! closest-p1 p1)
                  (set! edge-flag edge)
                  (set! closest-index index)
                  (set! found #t))))
            (iter p1 (cdr scan) (+ index 1)))))
      (if (not edge-flag)
          (let ((a (- closest-index 1)))
            (when (< a 0)
              (set! a (- vertex-count 1)))
            (let ((b (+ closest-index 1)))
              (when (>= b vertex-count)
                (set! b 0))
              (values closest-point
                      (element vertices a)
                      (element vertices b)
                      edge-flag)))
        (values closest-point
                closest-p0
                closest-p1
                edge-flag))))))
