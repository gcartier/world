;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Polygons
;;;


(module world.polygon jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world)
        (world.geometry)
        (world.plane))


(proclaim (warn optimizations))


;;;
;;;; Polygon
;;;


(class Polygon extends Object
  
  
  (slot vertices <list>      initialize #f getter generate)
  (slot plane    <Plane>     initialize #f getter generate)
  (slot center   <f32vector> initialize (make-vertex) getter generate)
  
  
  (method override (initialize vertices plane)
    (define (update-center-of-mass)
      (vertex-init! center 0. 0. 0.)
      (for-each (lambda (vertex)
                  (vertex+! center center vertex))
                vertices)
      (vertex-scalar*! center center (/ 1. (length vertices))))
    
    (nextmethod)
    (set! vertices~self vertices)
    (set! plane~self plane)
    (update-center-of-mass))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" vertices plane))))
  
  
  (method public (inside? p <f32vector> epsilon <fl>) <bool>
    (let ((pos 0)
          (neg 0))
      (for-each-pair vertices
        proc: (lambda (pair)
                (let ((p0 (car pair))
                      (p1 (if (not-null? (cdr pair)) (cadr pair) (car vertices))))
                  ;; Generate a normal for this edge
                  (let ((n (cross-product& (vertex-& p1 p0) (get-normal~ plane))))
                    ;; Which side of this edge-plane is the point?
                    (let ((half-plane (- (f32-ref (dot-product& p n)) (f32-ref (dot-product& p0 n)))))
                      ;; Keep track of positives & negatives (but not zeros -- which means it's on the edge)
                      (cond ((> half-plane epsilon)
                             (increase! pos))
                            ((< half-plane (- epsilon))
                             (increase! neg))))))))
      ;; If they're ALL positive or ALL negative then it's inside
      (or (= pos 0)
          (= neg 0))))
  
  
  (method public (closest-point-on-perimeter p <f32vector>) <values>
    (let ((found #f)
          (edge-flag #f)
          (closest-distance 0.)
          (closest-point (make-vertex&))
          (closest-p0 (make-vertex&))
          (closest-p1 (make-vertex&))
          (closest-index <fx> 0)
          (vertex-count <fx> (length vertices)))
      (let (iter (p0 (last vertices)) (scan vertices) (index 0))
        (when (not-null? scan)
          (let ((p1 (car scan)))
            (let ((cp (make-vertex&)))
              (let ((edge? (closest-point-on-line-segment! cp p0 p1 p)))
                (let ((d (f32-ref (vertex-distance& cp p))))
                  (when (or (not found) (< d closest-distance))
                    (set! closest-distance d)
                    (set! closest-point cp)
                    (set! closest-p0 p0)
                    (set! closest-p1 p1)
                    (set! edge-flag edge?)
                    (set! closest-index index)
                    (set! found #t)))))
            (iter p1 (cdr scan) (+ index 1)))))
      (if (not edge-flag)
          (let ((a (- closest-index 1)))
            (when (< a 0)
              (set! a (- vertex-count 1)))
            (let ((b (+ closest-index 1)))
              (when (>= b vertex-count)
                (set! b 0))
              (values closest-point
                      (element vertices a)
                      (element vertices b)
                      edge-flag)))
        (values closest-point
                closest-p0
                closest-p1
                edge-flag))))))
