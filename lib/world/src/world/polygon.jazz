;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Polygons
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.polygon jazz


(import (world.geometry)
        (world.homogeneous)
        (world.plane)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


(definition public polygon-float-size <fx>
  20)


(definition public (polygon? obj)
  (is? obj Polygon))


(definition public (polygon-position poly)
  (vertex (get-data2~ poly)
          (get-data3~ poly)
          (get-data4~ poly)))


;;;
;;;; Polygon
;;;


(class Polygon extends Plane
  
  
  (slot element   <object>                      getter generate)
  (slot vertices  <vector>                      getter generate)
  (slot radius    <fl>     initialize (make-fl) accessors generate)
  (slot data1     <fl>     initialize (make-fl) getter generate setter explicit)
  (slot data2     <fl>     initialize (make-fl) getter generate setter explicit)
  (slot data3     <fl>     initialize (make-fl) getter generate setter explicit)
  (slot data4     <fl>     initialize (make-fl) getter generate setter explicit)
  
  
  (method (set-data1 value) (fl! data1 value))
  (method (set-data2 value) (fl! data2 value))
  (method (set-data3 value) (fl! data3 value))
  (method (set-data4 value) (fl! data4 value))
  
  
  (method override (initialize element vertices)
    (nextmethod (center-of-mass& vertices) (polygon-normal& vertices))
    (set! element~self element)
    (set! vertices~self vertices)
    (fl! radius~self (f64-ref (polygon-radius& origin vertices)))
    (unspecified))
  
  
  (method override (assemble element)
    (nextmethod (center-of-mass& vertices) (polygon-normal& vertices))
    (set! element~self element)
    (fl! radius~self (f64-ref (polygon-radius& origin vertices)))
    (unspecified))
  
  
  (method public virtual (alloc-polygon$) <void>
    )
  
  
  (method public virtual (free-polygon$) <void>
    )
  
  
  (method public virtual (copy-polygon) <Polygon>
    )
  
  
  (method public virtual (flip-polygon) <Polygon>
    )
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a}" origin normal vertices))))
  
  
  (method protected virtual (triangle-count) <fx>
    )
  
  
  (method protected virtual (add-triangles uv <f32vector> depth <fl> add)
    )
  
  
  (method protected virtual (add-template-triangles mesher x y z inverse? uv <f32vector> depth <fl> add)
    )
  
  
  (method protected virtual (iterate-triangles proc)
    )
  
  
  (method protected virtual (iterate-vertices proc)
    )
  
  
  (method protected virtual (polygon-transform! src <Polygon> matrix <f64vector> inverse-matrix <f64vector>) <void>
    )
  
  
  (method protected virtual (polygon-move! vect <f64vector> offset <fx> matrix <f64vector+>) <void>
    )
  
  
  (method protected virtual (polygon-extract! elem vect <f64vector> offset <fx> matrix <f64vector+>) <void>
    )
  
  
  (method public inline (get-center)
    origin)
  
  
  (method public (ray-closest-triangle p <f64vector> d <f64vector> filter <procedure+>)
    (let ((closest #f)
          (distance -1.))
      (iterate-triangles
        (lambda (v1 v2 v3)
          (when (or (not filter)
                    (filter self))
            (let ((dist (ray-triangle-distance p d v1 v2 v3)))
              (when (and (/= dist -1.)
                         (or (= distance -1.)
                             (< dist distance)))
                (set! closest (list self dist))
                (set! distance dist))))))
      closest))
  
  
  (method public (ray/distance-closest-vertex origin <f64vector> direction <f64vector> distance <fl>) <f64vector>
    (let ((intersect (vertex+& origin (vertex-scalar*& direction distance)))
          (dist #f)
          (closest #f))
      (iterate-vertices
        (lambda (vert)
          (let ((d (vertex-distance vert intersect)))
            (when (or (not dist)
                      (< d dist))
              (set! dist d)
              (set! closest vert)))))
      closest))
  
  
  (method public (inside? p <f64vector> epsilon <fl>) <bool>
    (let ((vertex-count <fx> (vector-length vertices)))
      (let (iter (i 0) (pos 0) (neg 0))
        (if (< i vertex-count)
            (let ((p0 (vector-ref vertices i))
                  (p1 (vector-ref vertices (cast <fx> (let ((j (+ i 1))) (if (< j vertex-count) j 0))))))
              ;; Generate a normal for this edge
              (let ((n (cross-product& (vertex-& p1 p0) normal)))
                ;; Which side of this edge-plane is the point?
                (let ((half-plane (f64& (- (dot-product& p n) (dot-product& p0 n)))))
                  ;; Keep track of positives & negatives (but not zeros -- which means it's on the edge)
                  (cond ((> half-plane epsilon)
                         (iter (+ i 1) (+ pos 1) neg))
                        ((< half-plane (- epsilon))
                         (iter (+ i 1) pos (+ neg 1)))
                        (else
                         (iter (+ i 1) pos neg))))))
          ;; If they're ALL positive or ALL negative then it's inside
          (or (= pos 0)
              (= neg 0))))))
  
  
  (method public (closest-point-on-perimeter p <f64vector>) <values>
    (let ((closest-point (make-vertex))
          (closest-p0 (make-vertex))
          (closest-p1 (make-vertex)))
      (let ((edge-flag (closest-point-on-perimeter! p closest-point closest-p0 closest-p1)))
        (values closest-point closest-p0 closest-p1 edge-flag))))
  
  
  (method public (closest-point-on-perimeter! p <f64vector> closest-point <f64vector> closest-p0 <f64vector> closest-p1 <f64vector>) <bool>
    (let ((found #f)
          (edge-flag #f)
          (closest-distance (f64& 0.))
          (closest-index <fx> 0)
          (vertex-count <fx> (vector-length vertices)))
      (loop (for i from 0 below vertex-count)
            (let ((p1 (vector-ref vertices i))
                  (p0 (vector-ref vertices (cast <fx> (let ((j (- i 1))) (if (< j 0) (- vertex-count 1) j)))))
                  (cp (make-vertex&)))
              (let ((edge? (closest-point-on-line-segment! cp p0 p1 p)))
                (let ((d (vertex-distance& cp p)))
                  (when (or (not found) (< d closest-distance))
                    (set! closest-distance d)
                    (vertex-copy! closest-point cp)
                    (vertex-copy! closest-p0 p0)
                    (vertex-copy! closest-p1 p1)
                    (set! edge-flag edge?)
                    (set! closest-index i)
                    (set! found #t))))))
      (if (not edge-flag)
          (let ((a (- closest-index 1)))
            (when (< a 0)
              (set! a (- vertex-count 1)))
            (let ((b (+ closest-index 1)))
              (when (>= b vertex-count)
                (set! b 0))
              (vertex-copy! closest-p0 (vector-ref vertices a))
              (vertex-copy! closest-p1 (vector-ref vertices b))
              edge-flag))
        edge-flag))))


;;;
;;;; Functional
;;;


(definition public (polygon=? p1 <Polygon> p2 <Polygon>)
  (and (vertex=? (get-origin~ p1) (get-origin~ p2)) ;; fast test pruning
       (let ((vertices1 (get-vertices~ p1))
             (vertices2 (get-vertices~ p2)))
         (and (= (vector-length vertices1)
                 (vector-length vertices2))
              (loop (for v1 <f64vector> in-vector vertices1)
                    (for v2 <f64vector> in-vector vertices2)
                    (every (vertex=? v1 v2)))))))


(definition public (transform-polygon$ poly <Polygon> matrix inverse-matrix)
  (let ((p (alloc-polygon$~ poly)))
    (polygon-transform!~ p poly matrix inverse-matrix)
    p)))
