;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Polygons
;;;


(module world.polygon jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world)
        (world.geometry)
        (world.homogeneous)
        (world.plane)
        (world.serialization)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


(definition public polygon-float-size
  19)


;;;
;;;; Polygon
;;;


(class Polygon extends Plane
  
  
  (slot element  <object> getter generate)
  (slot vertices <vector> getter generate)
  (slot radius   <fl>     accessors generate)
  
  
  (method override (initialize element vertices handcoded-normal)
    (debug-allocation Polygon)
    (let ((normal (polygon-normal vertices)))
      (assert (< (vertex-distance normal handcoded-normal) 1e-5))
      (nextmethod (center-of-mass& vertices) normal))
    (set! element~self element)
    (set! vertices~self vertices)
    (set! radius~self (polygon-radius origin vertices)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a}" origin normal vertices))))
  
  
  (method meta override (marshall-object object)
    (serialize-object (class-of object)
                      (vector (serialize (get-origin~ object))
                              (serialize (get-normal~ object))
                              (serialize (get-vertices~ object))
                              (serialize (get-radius~ object)))))
  
  
  (method meta override (unmarshall-object content)
    (bind-vector (origin normal vertices radius) content
      (allocate self
                #f
                (deserialize origin)
                (deserialize normal)
                (deserialize vertices)
                (deserialize radius))))
  
  
  (method protected virtual (triangle-count) <fx>
    )
  
  
  (method protected virtual (add-triangles uv depth add)
    )
  
  
  (method protected virtual (iterate-triangles proc)
    )
  
  
  (method protected virtual (polygon-move! vect <f64vector> offset <fx>) <void>
    )
  
  
  (method public inline (get-center)
    origin)
  
  
  (method public (ray-closest-triangle p <f64vector> d <f64vector> filter <procedure+>)
    (let ((closest #f)
          (distance -1.)
          (normal (get-normal)))
      (iterate-triangles
        (lambda (v1 v2 v3)
          (when (or (not filter)
                    (filter self normal))
            (let ((dist (ray-triangle-distance p d v1 v2 v3)))
              (when (and (/= dist -1.)
                         (or (= distance -1.)
                             (< dist distance)))
                (set! closest (list self dist))
                (set! distance dist))))))
      closest))
  
  
  (method public (inside? p <f64vector> epsilon <fl>) <bool>
    (let ((pos 0)
          (neg 0)
          (vertex-count (vector-length vertices)))
      (for (i 0 vertex-count)
           (let ((p0 (vector-ref vertices i))
                 (p1 (vector-ref vertices (let ((j (+ i 1))) (if (< j vertex-count) j 0)))))
             ;; Generate a normal for this edge
             (let ((n (cross-product& (vertex-& p1 p0) normal)))
               ;; Which side of this edge-plane is the point?
               (let ((half-plane (- (f64-ref (dot-product& p n)) (f64-ref (dot-product& p0 n)))))
                 ;; Keep track of positives & negatives (but not zeros -- which means it's on the edge)
                 (cond ((> half-plane epsilon)
                        (increase! pos))
                       ((< half-plane (- epsilon))
                        (increase! neg)))))))
      ;; If they're ALL positive or ALL negative then it's inside
      (or (= pos 0)
          (= neg 0))))
  
  
  (method public (closest-point-on-perimeter p <f64vector>) <values>
    (let ((closest-point (make-vertex))
          (closest-p0 (make-vertex))
          (closest-p1 (make-vertex)))
      (let ((edge-flag (closest-point-on-perimeter! p closest-point closest-p0 closest-p1)))
        (values closest-point closest-p0 closest-p1 edge-flag))))
  
  
  (method public (closest-point-on-perimeter! p <f64vector> closest-point <f64vector> closest-p0 <f64vector> closest-p1 <f64vector>) <bool>
    (let ((found #f)
          (edge-flag #f)
          (closest-distance 0.)
          (closest-index <fx> 0)
          (vertex-count <fx> (vector-length vertices)))
      (for (i 0 vertex-count)
           (let ((p1 (vector-ref vertices i))
                 (p0 (vector-ref vertices (let ((j (- i 1))) (if (< j 0) (- vertex-count 1) j))))
                 (cp (make-vertex&)))
             (let ((edge? (closest-point-on-line-segment! cp p0 p1 p)))
               (let ((d (f64-ref (vertex-distance& cp p))))
                 (when (or (not found) (< d closest-distance))
                   (set! closest-distance d)
                   (vertex-copy! closest-point cp)
                   (vertex-copy! closest-p0 p0)
                   (vertex-copy! closest-p1 p1)
                   (set! edge-flag edge?)
                   (set! closest-index i)
                   (set! found #t))))))
      (if (not edge-flag)
          (let ((a (- closest-index 1)))
            (when (< a 0)
              (set! a (- vertex-count 1)))
            (let ((b (+ closest-index 1)))
              (when (>= b vertex-count)
                (set! b 0))
              (vertex-copy! closest-p0 (vector-ref vertices a))
              (vertex-copy! closest-p1 (vector-ref vertices b))
              edge-flag))
        edge-flag)))))
