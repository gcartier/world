;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Polygons
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.polygon jazz


(import (world.geometry)
        (world.homogeneous)
        (world.plane)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


(definition public polygon-float-size <fx>
  20)


;;;
;;;; Polygon
;;;


(proclaim (not warn optimizations))


(class Polygon-Class extends (:class Plane)
  
  
  (method override (marshall-object object)
    (serialize-object (class-of object)
                      (vector (serialize (get-origin~ object))
                              (serialize (get-normal~ object))
                              (serialize (get-vertices~ object))
                              (serialize (get-radius~ object)))))
  
  
  (method override (unmarshall-object content)
    (bind-vector (origin normal vertices radius) content
      (allocate self
                #f
                (deserialize origin)
                (deserialize normal)
                (deserialize vertices)
                (deserialize radius)))))


(proclaim (warn optimizations))


(class Polygon metaclass Polygon-Class extends Plane
  
  
  (slot element   <object> getter generate)
  (slot vertices  <vector> getter generate)
  (slot radius    <fl>     accessors generate)
  (slot data1     <fl>     getter generate setter explicit)
  (slot data2     <fl>     getter generate setter explicit)
  (slot data3     <fl>     getter generate setter explicit)
  (slot data4     <fl>     getter generate setter explicit)
  
  
  (method (set-data1 value) (fl-init! data1 value))
  (method (set-data2 value) (fl-init! data2 value))
  (method (set-data3 value) (fl-init! data3 value))
  (method (set-data4 value) (fl-init! data4 value))
  
  
  (method override (initialize element vertices)
    (debug-allocation Polygon)
    (nextmethod (center-of-mass& vertices) (polygon-normal vertices))
    (set! element~self element)
    (set! vertices~self vertices)
    (set! radius~self (polygon-radius origin vertices))
    (set! data1~self (make-fl))
    (set! data2~self (make-fl))
    (set! data3~self (make-fl))
    (set! data4~self (make-fl)))
  
  
  (method public virtual (copy-polygon) <Polygon>
    )
  
  
  (method public virtual (transform-polygon matrix <f64vector> inverse-matrix <f64vector>) <Polygon>
    )
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a}" origin normal vertices))))
  
  
  (method protected virtual (triangle-count) <fx>
    )
  
  
  (method protected virtual (add-triangles uv <f32vector> depth <fl> add)
    )
  
  
  (method protected virtual (iterate-triangles proc)
    )
  
  
  (method protected virtual (polygon-move! vect <f64vector> offset <fx> matrix <f64vector+>) <void>
    )
  
  
  (method protected virtual (polygon-extract! elem vect <f64vector> offset <fx> matrix <f64vector+>) <void>
    )
  
  
  (method public inline (get-center)
    origin)
  
  
  (method public (ray-closest-triangle p <f64vector> d <f64vector> filter <procedure+>)
    (let ((closest #f)
          (distance -1.))
      (iterate-triangles
        (lambda (v1 v2 v3)
          (when (or (not filter)
                    (filter self))
            (let ((dist (ray-triangle-distance p d v1 v2 v3)))
              (when (and (/= dist -1.)
                         (or (= distance -1.)
                             (< dist distance)))
                (set! closest (list self dist))
                (set! distance dist))))))
      closest))
  
  
  (method public (ray/distance-closest-vertex origin <f64vector> direction <f64vector> distance <fl>) <f64vector>
    (let ((intersect (vertex+& origin (vertex-scalar*& direction distance)))
          (dist #f)
          (closest #f))
      (iterate-vertices
        (lambda (vert)
          (let ((d (vertex-distance vert intersect)))
            (when (or (not dist)
                      (< d dist))
              (set! dist d)
              (set! closest vert)))))
      closest))
  
  
  (method public (inside? p <f64vector> epsilon <fl>) <bool>
    (let ((pos 0)
          (neg 0)
          (vertex-count <fx> (vector-length vertices)))
      (loop (for i from 0 below vertex-count)
            (let ((p0 (vector-ref vertices i))
                  (p1 (vector-ref vertices (cast <fx> (let ((j (+ i 1))) (if (< j vertex-count) j 0))))))
              ;; Generate a normal for this edge
              (let ((n (cross-product& (vertex-& p1 p0) normal)))
                ;; Which side of this edge-plane is the point?
                (let ((half-plane (- (f64-ref (dot-product& p n)) (f64-ref (dot-product& p0 n)))))
                  ;; Keep track of positives & negatives (but not zeros -- which means it's on the edge)
                  (cond ((> half-plane epsilon)
                         (increase! pos))
                        ((< half-plane (- epsilon))
                         (increase! neg)))))))
      ;; If they're ALL positive or ALL negative then it's inside
      (or (= pos 0)
          (= neg 0))))
  
  
  (method public (closest-point-on-perimeter p <f64vector>) <values>
    (let ((closest-point (make-vertex))
          (closest-p0 (make-vertex))
          (closest-p1 (make-vertex)))
      (let ((edge-flag (closest-point-on-perimeter! p closest-point closest-p0 closest-p1)))
        (values closest-point closest-p0 closest-p1 edge-flag))))
  
  
  (method public (closest-point-on-perimeter! p <f64vector> closest-point <f64vector> closest-p0 <f64vector> closest-p1 <f64vector>) <bool>
    (let ((found #f)
          (edge-flag #f)
          (closest-distance 0.)
          (closest-index <fx> 0)
          (vertex-count <fx> (vector-length vertices)))
      (loop (for i from 0 below vertex-count)
            (let ((p1 (vector-ref vertices i))
                  (p0 (vector-ref vertices (cast <fx> (let ((j (- i 1))) (if (< j 0) (- vertex-count 1) j)))))
                  (cp (make-vertex&)))
              (let ((edge? (closest-point-on-line-segment! cp p0 p1 p)))
                (let ((d (f64-ref (vertex-distance& cp p))))
                  (when (or (not found) (< d closest-distance))
                    (set! closest-distance d)
                    (vertex-copy! closest-point cp)
                    (vertex-copy! closest-p0 p0)
                    (vertex-copy! closest-p1 p1)
                    (set! edge-flag edge?)
                    (set! closest-index i)
                    (set! found #t))))))
      (if (not edge-flag)
          (let ((a (- closest-index 1)))
            (when (< a 0)
              (set! a (- vertex-count 1)))
            (let ((b (+ closest-index 1)))
              (when (>= b vertex-count)
                (set! b 0))
              (vertex-copy! closest-p0 (vector-ref vertices a))
              (vertex-copy! closest-p1 (vector-ref vertices b))
              edge-flag))
        edge-flag)))))
