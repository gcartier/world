;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Geometry
;;;


(module world.geometry jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew))


(proclaim (warn optimizations))


;;;
;;;; F32
;;;


(definition public inline (f32 x <fl>) <f32vector>
  (f32vector x))


(definition public inline (make-f32) <f32vector>
  (make-f32vector 1))


(definition public inline (f32-ref fl <f32vector>) <fl>
  (f32vector-ref fl 0))


(definition public inline (f32-set! fl <f32vector> val <fl>) <void>
  (f32vector-set! fl 0 val))


;;;
;;;; Vertex
;;;


(definition public inline (vertex x <fl> y <fl> z <fl>) <f32vector>
  (f32vector x y z))


(definition public inline (make-vertex) <f32vector>
  (make-f32vector 3))


(definition public (copy-vertex vert <f32vector>) <f32vector>
  (let ((copy (make-vertex)))
    (vertex-copy! copy vert)
    copy))


(definition public inline (vertex-x vert <f32vector>) <fl>
  (f32vector-ref vert 0))

(definition public inline (vertex-y vert <f32vector>) <fl>
  (f32vector-ref vert 1))

(definition public inline (vertex-z vert <f32vector>) <fl>
  (f32vector-ref vert 2))


(definition public inline (vertex-x-set! vert <f32vector> x <fl>) <void>
  (f32vector-set! vert 0 x))

(definition public inline (vertex-y-set! vert <f32vector> y <fl>) <void>
  (f32vector-set! vert 1 y))

(definition public inline (vertex-z-set! vert <f32vector> z <fl>) <void>
  (f32vector-set! vert 2 z))


(definition public (vertex=? v1 <f32vector> v2 <f32vector>) <bool>
  (and (= (vertex-x v1) (vertex-x v2))
       (= (vertex-y v1) (vertex-y v2))
       (= (vertex-z v1) (vertex-z v2))))


(definition public (vertex-zero? vert <f32vector>) <bool>
  (and (= (vertex-x vert) 0.)
       (= (vertex-y vert) 0.)
       (= (vertex-z vert) 0.)))


(definition public (vertex-init! vert <f32vector> x <fl> y <fl> z <fl>) <void>
  (vertex-x-set! vert x)
  (vertex-y-set! vert y)
  (vertex-z-set! vert z))


(definition public (vertex-copy! dst <f32vector> src <f32vector>) <void>
  (vertex-x-set! dst (vertex-x src))
  (vertex-y-set! dst (vertex-y src))
  (vertex-z-set! dst (vertex-z src)))


(definition public (present-vertex vert)
  (format "~{Vertex {r precision: 3} {r precision: 3} {r precision: 3}}"
          (vertex-x vert)
          (vertex-y vert)
          (vertex-z vert)))


;;;
;;;; Matrix
;;;


;; 0  4  8 12
;; 1  5  9 13
;; 2  6 10 14
;; 3  7 11 15


(definition public (matrix f0 <fl> f4 <fl> f8 <fl> f12 <fl> f1 <fl> f5 <fl> f9 <fl> f13 <fl> f2 <fl> f6 <fl> f10 <fl> f14 <fl> f3 <fl> f7 <fl> f11 <fl> f15 <fl>) <f32vector>
  (f32vector f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15))


(definition public (make-matrix) <f32vector>
  (make-f32vector 16))


(definition public (copy-matrix mat <f32vector>) <f32vector>
  (let ((copy (make-matrix)))
    (matrix-copy! copy mat)
    copy))


(definition public inline (matrix-ref mat <f32vector> ind <fx>) <fl>
  (f32vector-ref mat ind))


(definition public inline (matrix-set! mat <f32vector> ind <fx> val <object>) <void>
  (f32vector-set! mat ind val))


(definition public (matrix=? m1 <f32vector> m2 <f32vector>) <bool>
  (and (= (matrix-ref m1  0) (matrix-ref m2  0))
       (= (matrix-ref m1  1) (matrix-ref m2  1))
       (= (matrix-ref m1  2) (matrix-ref m2  2))
       (= (matrix-ref m1  3) (matrix-ref m2  3))
       (= (matrix-ref m1  4) (matrix-ref m2  4))
       (= (matrix-ref m1  5) (matrix-ref m2  5))
       (= (matrix-ref m1  6) (matrix-ref m2  6))
       (= (matrix-ref m1  7) (matrix-ref m2  7))
       (= (matrix-ref m1  8) (matrix-ref m2  8))
       (= (matrix-ref m1  9) (matrix-ref m2  9))
       (= (matrix-ref m1 10) (matrix-ref m2 10))
       (= (matrix-ref m1 11) (matrix-ref m2 11))
       (= (matrix-ref m1 12) (matrix-ref m2 12))
       (= (matrix-ref m1 13) (matrix-ref m2 13))
       (= (matrix-ref m1 14) (matrix-ref m2 14))
       (= (matrix-ref m1 15) (matrix-ref m2 15))))


(definition public (make-identity-matrix) <f32vector>
  (let ((mat (make-matrix)))
    (matrix-set-identity! mat)
    mat))


(definition public (matrix-set-identity! mat <f32vector>) <void>
  (matrix-set! mat  0 1.)
  (matrix-set! mat  1 0.)
  (matrix-set! mat  2 0.)
  (matrix-set! mat  3 0.)
  (matrix-set! mat  4 0.)
  (matrix-set! mat  5 1.)
  (matrix-set! mat  6 0.)
  (matrix-set! mat  7 0.)
  (matrix-set! mat  8 0.)
  (matrix-set! mat  9 0.)
  (matrix-set! mat 10 1.)
  (matrix-set! mat 11 0.)
  (matrix-set! mat 12 0.)
  (matrix-set! mat 13 0.)
  (matrix-set! mat 14 0.)
  (matrix-set! mat 15 1.))


(definition public (matrix-copy! dst <f32vector> src <f32vector>) <void>
  (matrix-set! dst  0 (matrix-ref src 0))
  (matrix-set! dst  1 (matrix-ref src 1))
  (matrix-set! dst  2 (matrix-ref src 2))
  (matrix-set! dst  3 (matrix-ref src 3))
  (matrix-set! dst  4 (matrix-ref src 4))
  (matrix-set! dst  5 (matrix-ref src 5))
  (matrix-set! dst  6 (matrix-ref src 6))
  (matrix-set! dst  7 (matrix-ref src 7))
  (matrix-set! dst  8 (matrix-ref src 8))
  (matrix-set! dst  9 (matrix-ref src 9))
  (matrix-set! dst 10 (matrix-ref src 10))
  (matrix-set! dst 11 (matrix-ref src 11))
  (matrix-set! dst 12 (matrix-ref src 12))
  (matrix-set! dst 13 (matrix-ref src 13))
  (matrix-set! dst 14 (matrix-ref src 14))
  (matrix-set! dst 15 (matrix-ref src 15)))


(definition public (matrix-multiply a <f32vector> b <f32vector>) <f32vector>
  (let ((mat (make-matrix)))
    (loop (for i from 0 below 4)
        (loop (for j from 0 below 4)
              (let ((ind (+ (* j 4) i)))
                (matrix-set! mat ind 0.)
                (loop (for k from 0 below 4)
                      (matrix-set! mat ind (+ (matrix-ref mat ind)
                                              (* (matrix-ref a (+ (* k 4) i))
                                                 (matrix-ref b (+ (* j 4) k)))))))))
    mat))


(definition public (make-translation-matrix x <fl> y <fl> z <fl>) <f32vector>
  (let ((mat (make-matrix)))
    (matrix-set-translation! mat x y z)
    mat))


(definition public (matrix-set-translation! mat <f32vector> x <fl> y <fl> z <fl>) <void>
  (matrix-set-identity! mat)
  (matrix-set! mat 12 x)
  (matrix-set! mat 13 y)
  (matrix-set! mat 14 z))


(definition public (make-projection-matrix fov <fl> ratio <fl> near <fl> far <fl>) <void>
  (let ((mat (make-identity-matrix))
        (f (/ 1.0 (tan (* fov (/ PI 360.))))))
    (matrix-set! mat  0 (/ f ratio))
    (matrix-set! mat  5 f)
    (matrix-set! mat 10 (/ (+ far near) (- near far)))
    (matrix-set! mat 14 (/ (* 2.0 far near) (- near far)))
    (matrix-set! mat 11 -1.)
    mat))


(definition public (make-view-matrix position <f32vector> lookat <f32vector>) <void>
  (let* ((up (vertex 0.0 1.0 0.0))
         (dir (vertex-normalize (vertex- lookat position)))
         (right (vertex-normalize (cross-product dir up)))
         (up (vertex-normalize (cross-product right dir)))
         (view (matrix (vertex-x right)   (vertex-y right)   (vertex-z right)   0.0
                       (vertex-x up)      (vertex-y up)      (vertex-z up)      0.0
                       (- (vertex-x dir)) (- (vertex-y dir)) (- (vertex-z dir)) 0.0
                       0.0                0.0                0.0                1.0))
         (translate (make-translation-matrix (- (vertex-x position))
                                             (- (vertex-y position))
                                             (- (vertex-z position)))))
    (matrix-multiply view translate)))


;;;
;;;; Ray
;;;


(class Ray extends Object
  
  
  (slot position  <f32vector> initialize (make-vertex) getter generate)
  (slot direction <f32vector> initialize (make-vertex) getter generate)
  
  
  (method override (initialize pos <f32vector> dir <f32vector>)
    (set-position pos)
    (set-direction dir))
  
  
  (method public inline (set-position pos <f32vector>) <void>
    (vertex-copy! position pos))
  
  (method public inline (set-direction dir <f32vector>) <void>
    (vertex-copy! direction dir)))


(definition public (make-ray pos dir)
  (new Ray pos dir))


;;;
;;;; LookAt
;;;


(class LookAt extends Object
  
  
  (slot sight <f32vector> initialize (make-vertex) getter generate)
  (slot up    <f32vector> initialize (make-vertex) getter generate)
  (slot right <f32vector> initialize (make-vertex) getter generate)
  
  
  (method public inline (set-sight sight <f32vector>) <void>
    (vertex-copy! sight~self sight))
  
  (method public inline (set-up up <f32vector>) <void>
    (vertex-copy! up~self up))
  
  (method public inline (set-right right <f32vector>) <void>
    (vertex-copy! right~self right))
  
  
  (method public (standardize!) <void>
    (vertex-init! sight 0.0  0.0 -1.0)
    (vertex-init! up    0.0  1.0  0.0)
    (vertex-init! right 1.0  0.0  0.0))
  
  
  (method public (rotate angle <fl> vert <f32vector>) <void>
    ;; sight
    (rotate-upon! sight angle vert sight)
    (vertex-normalize! sight)
    ;; up
    (rotate-upon! up angle vert up)
    (vertex-normalize! up)
    ;; right
    (rotate-upon! right angle vert right)
    (vertex-normalize! right))
  
  
  (method public (validate-normalized) <void>
    (define (validate vert)
      (unless (near? (vertex-norm vert) 1. .0001)
        (error "Vertex {s} is not normalized" vert)))
    
    (validate sight)
    (validate up)
    (validate right)))


(definition public (make-lookat)
  (new LookAt))


(definition public (copy-lookat lookat)
  (let ((copy (make-lookat)))
    (set-sight~ copy (get-sight~ lookat))
    (set-up~ copy (get-up~ lookat))
    (set-right~ copy (get-right~ lookat))
    copy))


;;;
;;;; Cuboid
;;;


(class Cuboid extends Object
  
  
  (slot left   <fl> accessors generate)
  (slot bottom <fl> accessors generate)
  (slot back   <fl> accessors generate)
  (slot right  <fl> accessors generate)
  (slot top    <fl> accessors generate)
  (slot front  <fl> accessors generate)
  
  
  (method override (initialize left <fl> bottom <fl> back <fl> right <fl> top <fl> front <fl>)
    (set! left~self left)
    (set! bottom~self bottom)
    (set! back~self back)
    (set! right~self right)
    (set! top~self top)
    (set! front~self front))
  
  
  (method override (print printer readably)
    (format printer "~{{a} {r precision: 1} {r precision: 1} {r precision: 1} {r precision: 1} {r precision: 1} {r precision: 1}}"
            (category-name (class-of self))
            left
            bottom
            back
            right
            top
            front)))


;;;
;;;; Operations
;;;


(definition public (vertex+ v1 <f32vector> v2 <f32vector>) <f32vector>
  (vertex
    (+ (vertex-x v1) (vertex-x v2))
    (+ (vertex-y v1) (vertex-y v2))
    (+ (vertex-z v1) (vertex-z v2))))


(definition public (vertex+! res <f32vector> v1 <f32vector> v2 <f32vector>) <void>
  (vertex-x-set! res (+ (vertex-x v1) (vertex-x v2)))
  (vertex-y-set! res (+ (vertex-y v1) (vertex-y v2)))
  (vertex-z-set! res (+ (vertex-z v1) (vertex-z v2))))


(definition public (vertex- v1 <f32vector> v2 <f32vector>) <f32vector>
  (vertex
    (- (vertex-x v1) (vertex-x v2))
    (- (vertex-y v1) (vertex-y v2))
    (- (vertex-z v1) (vertex-z v2))))


(definition public (vertex-! res <f32vector> v1 <f32vector> v2 <f32vector>) <void>
  (vertex-x-set! res (- (vertex-x v1) (vertex-x v2)))
  (vertex-y-set! res (- (vertex-y v1) (vertex-y v2)))
  (vertex-z-set! res (- (vertex-z v1) (vertex-z v2))))


(definition public (vertex-negate v <f32vector>) <f32vector>
  (vertex
    (- (vertex-x v))
    (- (vertex-y v))
    (- (vertex-z v))))


(definition public (vertex-negate! v <f32vector>) <void>
  (vertex-x-set! v (- (vertex-x v)))
  (vertex-y-set! v (- (vertex-y v)))
  (vertex-z-set! v (- (vertex-z v))))


(definition public (vertex-scalar* v <f32vector> r <fl>) <f32vector>
  (vertex
    (* r (vertex-x v))
    (* r (vertex-y v))
    (* r (vertex-z v))))


(definition public (vertex-scalar*! v <f32vector> r <fl>) <void>
  (vertex-x-set! v (* r (vertex-x v)))
  (vertex-y-set! v (* r (vertex-y v)))
  (vertex-z-set! v (* r (vertex-z v))))


(definition public (rotate-upon angle <fl> u <f32vector> v <f32vector>) <f32vector>
  (let ((res (make-vertex)))
    (rotate-upon! res angle u v)
    res))


(definition public (rotate-upon! res <f32vector> angle <fl> u <f32vector> v <f32vector>) <void>
  (let ((c <fl> (cos angle))
        (s <fl> (sin angle))
        (x (vertex-x u))
        (y (vertex-y u))
        (z (vertex-z u))
        (i (vertex-x v))
        (j (vertex-y v))
        (k (vertex-z v)))
    (vertex-x-set! res (+ (* i (+ (* x x (- 1. c)) c))
                          (* j (- (* x y (- 1. c)) (* z s)))
                          (* k (+ (* x z (- 1. c)) (* y s)))))
    (vertex-y-set! res (+ (* i (+ (* y x (- 1. c)) (* z s)))
                          (* j (+ (* y y (- 1. c)) c))
                          (* k (- (* y z (- 1. c)) (* x s)))))
    (vertex-z-set! res (+ (* i (- (* x z (- 1. c)) (* y s)))
                          (* j (+ (* y z (- 1. c)) (* x s)))
                          (* k (+ (* z z (- 1. c)) c))))))


(definition public (vertex-norm v <f32vector>) <fl>
  (let ((x (vertex-x v))
        (y (vertex-y v))
        (z (vertex-z v)))
    (sqrt (+ (* x x)
             (* y y)
             (* z z)))))


(definition public (vertex-normalize v <f32vector>) <f32vector>
  (vertex-scalar* v (/ (vertex-norm v))))


(definition public (vertex-normalize! v <f32vector>) <void>
  (vertex-scalar*! v (/ (vertex-norm v))))


(definition public (vertex-distance v1 <f32vector> v2 <f32vector>) <fl>
  (vertex-norm (vertex- v2 v1)))


(definition public (inner-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (inner-product! res <f32vector> u <f32vector> v <f32vector>) <void>
  (f32-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v)))))


(definition public (cross-product u <f32vector> v <f32vector>) <f32vector>
  (let ((res (make-vertex)))
    (cross-product! res u v)
    res))


(definition public (cross-product! res <f32vector> u <f32vector> v <f32vector>) <void>
  (let ((a (vertex-x u))
        (b (vertex-y u))
        (c (vertex-z u))
        (d (vertex-x v))
        (e (vertex-y v))
        (f (vertex-z v)))
    (vertex-x-set! res (- (* b f) (* c e)))
    (vertex-y-set! res (- (* c d) (* a f)))
    (vertex-z-set! res (- (* a e) (* b d)))))


(definition public (vector-angle v1 <f32vector> v2 <f32vector>) <fl>
  (acos (inner-product v1 v2)))


(definition public (vertical-angle vert up)
  (- (vector-angle vert up)
     PI/2))


(definition public (plane-normal v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (cross-product (vertex- v2 v1)
                 (vertex- v3 v1)))


(definition public (plane-normal! res <f32vector> v1 <f32vector> v2 <f32vector> v3 <f32vector>) <void>
  (cross-product! res
                  (vertex- v2 v1)
                  (vertex- v3 v1)))


(definition public (ray-triangle-distance p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <fl>
  (let ((r! (make-f32)))
    (ray-triangle-distance! r! p d v0 v1 v2)
    (f32-ref r!)))


(definition public ray-triangle-distance!
  (let ((e1! (make-vertex))
        (e2! (make-vertex))
        (h! (make-vertex))
        (a! (make-f32))
        (s! (make-vertex))
        (b! (make-f32))
        (q! (make-vertex))
        (c! (make-f32))
        (d! (make-f32))
        (f! (make-f32))
        (u! (make-f32))
        (v! (make-f32))
        (t! (make-f32)))
    (lambda (r! <f32vector> p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <fl+>
      (vertex-! e1! v1 v0)
      (vertex-! e2! v2 v0)
      (cross-product! h! d e2!)
      (inner-product! a! e1! h!)
      (if (and (> (f32-ref a!) -0.00001) (< (f32-ref a!) 0.00001))
          (f32-set! r! -1.)
        (f32-set! f! (/ 1. (f32-ref a!)))
        (vertex-! s! p v0)
        (inner-product! b! s! h!)
        (f32-set! u! (* (f32-ref f!) (f32-ref b!)))
        (if (or (< (f32-ref u!) 0.0) (> (f32-ref u!) 1.0))
            (f32-set! r! -1.)
          (cross-product! q! s! e1!)
          (inner-product! c! d q!)
          (f32-set! v! (* (f32-ref f!) (f32-ref c!)))
          (if (or (< (f32-ref v!) 0.0) (> (+ (f32-ref u!) (f32-ref v!)) 1.0))
              (f32-set! r! -1.)
            ;; at this stage we can compute t to find out where
            ;; the intersection point is on the line
            (inner-product! d! e2! q!)
            (f32-set! t! (* (f32-ref f!) (f32-ref d!)))
            (if (> (f32-ref t!) 0.00001) ;; ray intersection
                (f32-set! r! (f32-ref t!))
              ;; this means that there is a line intersection
              ;; but not a ray intersection
              (f32-set! r! -1.))))))))


(definition public ray-intersects-triangle?
  (let ((d! (make-f32)))
    (lambda (p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <bool>
      (ray-triangle-distance! d! p d v0 v1 v2)
      (/= (f32-ref d!) -1.))))


(definition public ray-intersects-sphere?
  (let ((t! (make-vertex))
        (i! (make-f32))
        (j! (make-f32))
        (b! (make-f32))
        (det! (make-f32)))
    (lambda (p <f32vector> d <f32vector> s <f32vector> r <fl>) <bool>
      (vertex-! t! p s)
      (inner-product! i! t! d)
      (f32-set! b! (- (f32-ref i!)))
      (inner-product! j! t! t!)
      (f32-set! det! (+ (- (* (f32-ref b!) (f32-ref b!)) (f32-ref j!)) (* r r)))
      (if (< (f32-ref det!) 0.)
          #f
        (f32-set! det! (sqrt (f32-ref det!)))
        (let ((i (+ (f32-ref b!) (f32-ref det!))))
          (>= i 0.))))))


;;;
;;;; OpenGL
;;;


(definition public (gl-plane-normal v1 v2 v3)
  (let ((normal (plane-normal v1 v2 v3)))
    (glNormal3f (vertex-x normal)
                (vertex-y normal)
                (vertex-z normal))))


;;;
;;;; Utilities
;;;


(definition public (random-in max)
  (- (* (random-real) max 2) max)))
