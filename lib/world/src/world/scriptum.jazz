;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Scripting
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.scriptum jazz


(import (jazz.io)
        (world)
        (world.autoload)
        (world.commands)
        (world.context)
        (world.task))


;;;
;;;; Event
;;;


(definition public %%current-instance
  (make-parameter #f))


(definition public %%current-event
  (make-parameter #f))


(definition protected (%%poll-script)
  (let ((task (current-task))
        (exit (current-exit))
        (entity (%%current-entity)))
    (when entity
      (handle-event entity))
    (when (and task exit)
      (task-wait task .01 0. exit))))


(definition protected run?
  (make-parameter #f))


;;;
;;;; Events
;;;


(class Script-Event extends Object
  
  
  (slot me   initialize #f getter generate)
  (slot time initialize #f getter generate)
  
  
  (method override (initialize self me time)
    (set! self.me me)
    (set! self.time time)))


(class Tick-Event extends Script-Event
  
  
  (slot elapse initialize #f getter generate)
  
  
  (method override (initialize self me time elapse)
    (nextmethod self me time)
    (set! self.elapse elapse)))


;;;
;;;; Lock
;;;


(definition protected (with-lock thunk)
  ;; handle events will already own the task mutex
  (if (task-mutex-owner?)
      (thunk)
    (with-task-mutex thunk)))


;;;
;;;; Tick
;;;


(definition protected default-tick-period
  (/ 1. 30.))


(definition protected (%%tick period proc)
  (let ((history (current-history))
        (task (current-task))
        (exit (current-exit))
        (entity (%%current-entity)))
    (let ((script (get-script entity))
          (last-tick (current-seconds)))
      (let (iter)
        (declare (proper-tail-calls))
        (if (or (stopping? task) (get-paused? history))
            (begin
              (task-wait task period 0. exit)
              (iter))
          (handle-event entity)
          (let ((time (current-seconds)))
            (let ((elapse (- time last-tick)))
              (if (>= elapse period)
                  (continuation-capture
                    (lambda (outside-parameterize)
                      (parameterize ((%%current-event (new Tick-Event entity time elapse)))
                        (set! last-tick time)
                        (with-lock
                          (lambda ()
                            (animate entity elapse)))
                        (proc entity script time elapse (lambda () (continuation-graft outside-parameterize iter))))))
                (task-wait task (- period elapse) 0. exit)
                (iter)))))))))


;;;
;;;; Commands
;;;


(definition public stay-commands
  (new Commands))


(definition public move-commands
  (let ((commands (new Commands)))
    (move-forward commands)
    commands))


(definition public move/jump-commands
  (let ((commands (new Commands)))
    (move-forward commands)
    (jump commands)
    commands))


(definition public sprint-commands
  (let ((commands (new Commands)))
    (sprint-forward commands)
    commands))


(definition public rotate-left-commands
  (let ((commands (new Commands)))
    (rotate-left commands)
    commands))

(definition public rotate-right-commands
  (let ((commands (new Commands)))
    (rotate-right commands)
    commands))


(definition public jump-commands
  (let ((commands (new Commands)))
    (jump commands)
    commands))


;;;
;;;; Perform
;;;


(definition public (perform-stay)
  (perform stay-commands))

(definition public (perform-move)
  (perform (if (get-sprint? (%%current-actor)) sprint-commands move-commands)))

(definition public (perform-move/jump)
  (perform move/jump-commands))

(definition public (perform-rotate-left)
  (perform rotate-left-commands))

(definition public (perform-rotate-right)
  (perform rotate-right-commands))

(definition public (perform-hover)
  (perform move-commands gravity?: #f))

(definition public (perform-jump)
  (perform jump-commands))


(definition public (perform commands (gravity?: gravity? #t))
  (%%perform commands gravity?: gravity?))


(definition public (%%perform-stay)
  (%%perform stay-commands))

(definition public (%%perform-move (after #f))
  (%%perform (if (get-sprint? (%%current-actor)) sprint-commands move-commands) after: after))

(definition public (%%perform-move/jump)
  (%%perform move/jump-commands))

(definition public (%%perform-rotate-left)
  (%%perform rotate-left-commands))

(definition public (%%perform-rotate-right)
  (%%perform rotate-right-commands))

(definition public (%%perform-hover)
  (%%perform move-commands gravity?: #f))

(definition public (%%perform-jump)
  (%%perform jump-commands))


(definition public (%%perform commands (gravity?: gravity? #t) (after: after #f))
  (unless (get-paused? (current-history))
    (let ((event (%%current-event)))
      (let ((actor (get-me event))
            (time (get-time event))
            (elapse (get-elapse event)))
        (with-lock
          (lambda ()
            (tick-actor actor commands time elapse gravity? 'slide)
            (when after
              (after))))))))


;;;
;;;; Properties
;;;


(definition protected properties-mutex
  (make-mutex 'properties))


(definition protected *properties*
  (make-table test: eq? weak-keys: #t))

;; sejour quick hack to think through
(definition protected (reset-properties)
  (set! *properties* (make-table test: eq? weak-keys: #t)))


(definition protected (require-properties object)
  (or (table-ref *properties* object #f)
      (let ((properties (make-table test: eq?)))
        (table-set! *properties* object properties)
        properties)))


(definition public (%%get object property (default #f))
  (mutex-lock! properties-mutex)
  (prog1 (table-ref (require-properties object) property default)
    (mutex-unlock! properties-mutex)))


(definition public (%%need object property)
  (tick
    (lambda (iter)
      (or (%%get object property #f)
          (begin
            (perform-stay)
            (iter))))))


(definition public (%%wait object property value)
  (tick
    (lambda (iter)
      (unless (equal? (%%get object property #f) value)
        (perform-stay)
        (iter)))))


(definition public (%%set object property value)
  (mutex-lock! properties-mutex)
  (table-set! (require-properties object) property value)
  (mutex-unlock! properties-mutex)
  (unspecified))


(definition public (%%clear object property)
  (mutex-lock! properties-mutex)
  (prog1 (table-clear (require-properties object) property)
    (mutex-unlock! properties-mutex)))


;;;
;;;; Entity
;;;


(definition public (%%current-entity)
  (if (%%current-event)
      (get-me (%%current-event))
    (%%current-instance)))


;;;
;;;; Actor
;;;


(definition public (%%current-actor)
  (let ((entity (%%current-entity)))
    (and (is? entity Actor)
         entity)))


;;;
;;;; Stay
;;;


(definition public (%%stay)
  (declare (proper-tail-calls))
  (%%tick default-tick-period
    (lambda (actor script time elapse iter)
      (%%perform-stay)
      (iter))))


;;;
;;;; Pause
;;;


(definition public (%%paused?)
  (boolean (find-restart 'unpause)))


(definition public (%%pause)
  (with-restart-catcher 'unpause "Unpause"
    (lambda ()
      (declare (proper-tail-calls))
      (%%tick default-tick-period
        (lambda (entity script time elapse iter)
          (when (is? entity Actor)
            (%%perform-stay))
          (iter))))))


(definition public (%%unpause)
  (let ((restart (find-restart 'unpause)))
    (when restart
      (invoke-restart restart))))


(definition public (%%toggle-paused)
  (if (%%paused?)
      (%%unpause)
    (%%pause))))
