;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Circular Queues
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.queue jazz


(import (world.autoload))


(proclaim (warn optimizations))


;;;
;;;; Circular
;;;


(class Circular-Queue extends Object
  
  
  (slot count   <fx>)
  (slot content <vector>)
  (slot head    <fx>)
  (slot tail    <fx>)
  (slot size    <fx>     getter generate)
  
  
  (method override (initialize cnt)
    (set! count cnt)
    (set! content (make-vector cnt))
    (set! head 0)
    (set! tail 0)
    (set! size 0))
  
  
  (method public (empty?)
    (= head tail))
  
  
  (method public (reset)
    (loop (for n from 0 below size)
          (let ((offset (modulo (+ head n) count)))
            (let ((sector <Sector> (vector-ref content offset)))
              (set-generating?~ sector #f)
              (vector-set! content offset #f))))
    (set! head 0)
    (set! tail 0)
    (set! size 0))
  
  
  (method public (enqueue obj)
    (if (>= size count)
        (error "Queue overflow")
      (vector-set! content tail obj)
      (set! tail (modulo (+ tail 1) count))
      (increase! size)))
  
  
  (method public (dequeue)
    (if (<= size 0)
        (error "Queue is empty")
      (prog1 (vector-ref content head)
        (vector-set! content head #f)
        (set! head (modulo (+ head 1) count))
        (decrease! size)))))


;;;
;;;; Priorities
;;;


(class Priorities-Queue extends Object
  
  
  (slot count     <fx>)
  (slot queues    <vector>)
  (slot mutex              initialize (make-mutex))
  (slot condition          initialize (make-condition))
  
  
  (method override (initialize cnt <fx> reserved)
    (nextmethod)
    (assert (> cnt 0))
    (set! count cnt)
    (set! queues (list->vector (map (lambda (n) (new Circular-Queue reserved))
                                    (naturals 0 count)))))
  
  
  (method inline (get-queue priority <fx>) <Circular-Queue>
    (element queues priority))
  
  
  (method (top-queue) <Circular-Queue+>
    (let (iter (priority 0))
      (if (< priority count)
          (let ((queue (get-queue priority)))
            (if (not (empty?~ queue))
                queue
              (iter (+ priority 1))))
        #f)))
  
  
  (method public (size)
    (mutex-lock! mutex)
    (prog1 (let ((size 0))
             (loop (for queue <Circular-Queue> in-vector queues)
                   (increase! size (get-size~ queue)))
             size)
      (mutex-unlock! mutex)))
  
  
  (method public (empty?)
    (mutex-lock! mutex)
    (prog1 (not (top-queue))
      (mutex-unlock! mutex)))
  
  
  (method public (reset)
    (mutex-lock! mutex)
    (loop (for queue <Circular-Queue> in-vector queues)
          (reset~ queue))
    (mutex-unlock! mutex))
  
  
  (method public (trim priority)
    (mutex-lock! mutex)
    (let ((trimmed 0))
      (loop (for p from priority below count)
            (let ((queue (get-queue p)))
              (increase! trimmed (get-size~ queue))
              (reset~ queue)))
      (prog1 trimmed
        (mutex-unlock! mutex))))
  
  
  (method public (push obj priority <fx>)
    (mutex-lock! mutex)
    (enqueue~ (get-queue priority) obj)
    (mutex-unlock! mutex)
    (condition-signal! condition))
  
  
  (method public (pop timeout)
    (declare (proper-tail-calls))
    (let (iter)
      (mutex-lock! mutex)
      (let ((queue (top-queue)))
        (cond (queue
               (prog1 (dequeue~ queue)
                 (mutex-unlock! mutex)))
              ((mutex-unlock! mutex condition timeout)
               (iter))
              (else
               (eof-object))))))))
