;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Circular Queues
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.queue jazz


(import (world)
        (world.autoload))


(proclaim (not check bounds)
          (warn optimizations))


;;;
;;;; Circular
;;;


(class Circular-Queue extends Object
  
  
  (slot count   <fx>)
  (slot content <vector>)
  (slot head    <fx>)
  (slot tail    <fx>)
  (slot size    <fx>     getter generate)
  
  
  (method override (initialize self cnt)
    (set! count cnt)
    (set! content (make-vector cnt))
    (set! head 0)
    (set! tail 0)
    (set! size 0))
  
  
  (method public (empty? self)
    (= head tail))
  
  
  (method public (reset self)
    (loop (for n from 0 below size)
          (let ((offset (modulo (+ head n) count)))
            ;; quick hack. we need to understand how sometimes when
            ;; in a bailout-client we can end up getting a #f sector
            (let ((sector <Sector+> (vector-ref content offset)))
              (when sector
                (set-visual-generating? sector #f)
                (vector-set! content offset #f)))))
    (set! head 0)
    (set! tail 0)
    (set! size 0))
  
  
  (method public (push self obj)
    (if (>= size count)
        (error "Queue overflow")
      (vector-set! content tail obj)
      (set! tail (modulo (+ tail 1) count))
      (increase! size)))
  
  
  (method public (pop self)
    (if (<= size 0)
        (error "Queue is empty")
      (prog1 (vector-ref content head)
        (vector-set! content head #f)
        (set! head (modulo (+ head 1) count))
        (decrease! size)))))


;;;
;;;; Priorities
;;;


(class Priorities-Queue extends Object
  
  
  (slot count     <fx>)
  (slot queues    <vector>)
  (slot mutex              initialize (make-mutex))
  (slot condition-variable initialize (make-condition-variable))
  
  
  (method override (initialize self cnt <fx> reserved)
    (nextmethod self)
    (assert (> cnt 0))
    (set! count cnt)
    (set! queues (list->vector (map (lambda (n) (new Circular-Queue reserved))
                                    (naturals 0 count)))))
  
  
  (method inline (get-queue self priority <fx>) <Circular-Queue>
    (element queues priority))
  
  
  (method (top-queue self) <Circular-Queue+>
    (let (iter (priority 0))
      (if (< priority count)
          (let ((queue (get-queue self priority)))
            (if (not (empty? queue))
                queue
              (iter (+ priority 1))))
        #f)))
  
  
  (method package (top-priority self) <fx+>
    (let (iter (priority 0))
      (if (< priority count)
          (let ((queue (get-queue self priority)))
            (if (not (empty? queue))
                priority
              (iter (+ priority 1))))
        #f)))
  
  
  (method public (size self)
    (mutex-lock! mutex)
    (prog1 (let ((size 0))
             (loop (for queue <Circular-Queue> in-vector queues)
                   (increase! size (get-size queue)))
             size)
      (mutex-unlock! mutex)))
  
  
  (method public (empty? self)
    (mutex-lock! mutex)
    (prog1 (not (top-queue self))
      (mutex-unlock! mutex)))
  
  
  (method public (has? self priority)
    (mutex-lock! mutex)
    (prog1 (not (empty? (get-queue self priority)))
      (mutex-unlock! mutex)))
  
  
  (method public (reset self)
    (mutex-lock! mutex)
    (loop (for queue <Circular-Queue> in-vector queues)
          (reset queue))
    (mutex-unlock! mutex))
  
  
  (method public (trim self priority)
    (mutex-lock! mutex)
    (let ((trimmed 0))
      (loop (for p from priority below count)
            (let ((queue (get-queue self p)))
              (increase! trimmed (get-size queue))
              (reset queue)))
      (prog1 trimmed
        (mutex-unlock! mutex))))
  
  
  (method public (push self obj priority <fx>)
    (mutex-lock! mutex)
    (push (get-queue self priority) obj)
    (mutex-unlock! mutex)
    (condition-variable-signal! condition-variable))
  
  
  (method public (pop self timeout)
    (declare (proper-tail-calls))
    (let (iter)
      (mutex-lock! mutex)
      (let ((queue (top-queue self)))
        (cond (queue
               (prog1 (pop queue)
                 (mutex-unlock! mutex)))
              ((mutex-unlock! mutex condition-variable timeout)
               (iter))
              (else
               (eof-object)))))))


;;;
;;;; Pool
;;;


(constant queues-cardinality <fx>
  128)

(definition protected queues-pool <vector>
  (make-vector queues-cardinality #f))

(definition protected queues-allocated <fx>
  0)

(definition protected queues-available <fx>
  0)


(definition protected (alloc-queue$) <Queue>
  (if (= queues-available 0)
      (assert (< queues-allocated queues-cardinality)
        (increase! queues-allocated)
        (new-queue))
    (decrease! queues-available)
    (let ((queue (vector-ref queues-pool queues-available)))
      (vector-set! queues-pool queues-available #f)
      queue)))


(definition protected (make-queue$) <Queue>
  (let ((queue (alloc-queue$)))
    (reset-queue queue)
    queue))


(definition protected (free-queue$ queue <Queue>) <void>
  (assert (< queues-available queues-cardinality))
  (vector-set! queues-pool queues-available queue)
  (increase! queues-available)))
