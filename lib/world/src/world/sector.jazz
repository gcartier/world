;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Sectors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.sector jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.actor)
        (world.autoload)
        (world.block)
        (world.dye)
        (world.element)
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.light)
        (world.material)
        (world.mesh)
        (world.settings)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle)
        (world.window)
        (world.client.window))


;;;
;;;; Thread
;;;


(definition content-thread
  #f)


(definition (get-content-thread)
  (or content-thread
      (let ((thread (start-loop-thread 'content)))
        (set! content-thread thread)
        thread)))


(definition public (post-content thunk)
  (thread-post (get-content-thread) 'content
    thunk))


;;;
;;;; Sector
;;;


(definition current-content-revision
  0)

(definition public (get-current-content-revision) <fx>
  current-content-revision)

(definition public (increase-current-content-revision)
  (increase! current-content-revision))


(class Sector extends Object
  
  
  (slot index               <vector>                   getter generate)
  (slot center              <f64vector>                getter generate)
  (slot tiles               <list>                     accessors generate)
  (slot entities            <list>                     accessors generate)
  (slot faces               <object>                   accessors generate)
  (slot faces-queue         <object>                   accessors generate)
  (slot mesh                <Mesh>                     getter generate)
  (slot physical-uptodate?  <bool>       initialize #f accessors generate)
  (slot content-uptodate?   <bool>       initialize #f accessors generate)
  (slot content-revision    <fx>         initialize 0  accessors generate)
  (slot vertices-uptodate?  <bool>       initialize #f accessors generate)
  (slot lightmap-uptodate?  <bool>       initialize #f accessors generate)
  (slot lightmap-baked?     <bool>       initialize #f accessors generate)
  
  
  (method override (initialize index center)
    (set! index~self index)
    (set! center~self center)
    (set! tiles~self '())
    (set! entities~self '())
    (set! faces~self #f)
    (set! faces-queue~self #f)
    (set! mesh~self (new Mesh material: (get-material~ (get-tile-mesh~ (current-world))))))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((tiles (length tiles))
              (entities (length entities)))
          (format output "{a}, {a}, {a} with {a} tile{a}, {a} entities" (vector-ref index 0) (vector-ref index 1) (vector-ref index 2) tiles (format-plural tiles) entities)))))
  
  
  (method (free-mesh)
    (free-resources~ mesh))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (update)
    (update-content)
    (update-vertices)
    (update-lightmap))
  
  
  ;;;
  ;;;; Physical
  ;;;
  
  
  (method (update-physical)
    (when (not physical-uptodate?)
      (let ((zone (current-zone)))
        (generate-physical~ zone self))
      (set! physical-uptodate? #t)))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method (update-content)
    (let ((world (current-world))
          (zone (current-zone)))
      (define (generate)
        (generate-content~ zone self))
      
      (when (or (not content-uptodate?)
                (< content-revision current-content-revision))
        (cond ((< (get-sectors-generating~ zone)
                  (rendering-threshold~ world))
               (if (generate-content?~ zone)
                   (begin
                     (increase-sectors-generating~ zone self)
                     (if (find-setting 'world.generate-threaded? #t)
                         (post-content (lambda () (generate)))
                       (generate)))
                 (set! content-revision current-content-revision)
                 (set! content-uptodate? #t)))
              (else
               (increase-sectors-waiting~ zone self))))))
  
  
  ;;;
  ;;;; Vertices
  ;;;
  
  
  (method (update-vertices)
    (when (not vertices-uptodate?)
      (let ((apparent-faces (collect-apparent-faces)))
        (set! faces apparent-faces)
        (fill-faces-vertices apparent-faces))
      ;(set! faces-queue #f)
      (set! vertices-uptodate? #t)))
  
  
  (method (fill-faces-vertices apparent-faces)
    (receive (vertices neighbors) (prepare-vertices/neighbors apparent-faces)
      (fill-vertices/neighbors vertices neighbors)))
  
  
  (method (fill-vertices/neighbors vertices neighbors)
    (if (not vertices)
        (begin
          (free-vertices~ mesh)
          (free-neighbors~ mesh))
      (allocate-vertices~ mesh)
      (set-data~ (get-vertices-buffer~ mesh) vertices 10)
      (allocate-neighbors~ mesh)
      (set-data~ (get-neighbors-buffer~ mesh) neighbors 6)))
  
  
  (method (prepare-vertices/neighbors apparent-faces)
    (if (not apparent-faces)
        (values #f #f)
      (let ((vertex-floats 10))
        (let ((triangles-count 0)
              (triangle-floats (* 3 vertex-floats))
              (triangle-neighbors-floats (* 3 7)))
          (for (i 0 (vector-length apparent-faces))
               (let ((face (vector-ref apparent-faces i)))
                 (increase! triangles-count (triangle-count~ face))))
          (let ((vertices (make-f32vector (* triangles-count triangle-floats)))
                (neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))
            (let ((n 0)
                  (m 0))
              (define (add-triangle v1 v2 v3 n1 n2 n3 t1u t1v t2u t2v t3u t3v tdepth)
                (add-vertex v1) (add-normal n1) (add-texture t1u t1v tdepth) (add-bone) (add-neighbors 0. v2 v3)
                (add-vertex v2) (add-normal n2) (add-texture t2u t2v tdepth) (add-bone) (add-neighbors 1. v1 v3)
                (add-vertex v3) (add-normal n3) (add-texture t3u t3v tdepth) (add-bone) (add-neighbors 2. v1 v2))
                
              (define (add-vertex vert)
                (f32vector-set! vertices n (vertex-x vert))
                (f32vector-set! vertices (+ n 1) (vertex-y vert))
                (f32vector-set! vertices (+ n 2) (vertex-z vert))
                (set! n (+ n 3)))
              
              (define (add-normal normal)
                (f32vector-set! vertices n (vertex-x normal))
                (f32vector-set! vertices (+ n 1) (vertex-y normal))
                (f32vector-set! vertices (+ n 2) (vertex-z normal))
                (set! n (+ n 3)))
              
              (define (add-texture tu tv tdepth)
                (f32vector-set! vertices n tu)
                (f32vector-set! vertices (+ n 1) tv)
                (f32vector-set! vertices (+ n 2) tdepth)
                (set! n (+ n 3)))
              
              (define (add-bone)
                (f32vector-set! vertices n 0.)
                (set! n (+ n 1)))
              
              (define (add-neighbors rank n1 n2)
                (f32vector-set! neighbors m rank)
                (set! m (+ m 1))
                (f32vector-set! neighbors m (vertex-x n1))
                (f32vector-set! neighbors (+ m 1) (vertex-y n1))
                (f32vector-set! neighbors (+ m 2) (vertex-z n1))
                (set! m (+ m 3))
                (f32vector-set! neighbors m (vertex-x n2))
                (f32vector-set! neighbors (+ m 1) (vertex-y n2))
                (f32vector-set! neighbors (+ m 2) (vertex-z n2))
                (set! m (+ m 3)))
              
              (for (i 0 (vector-length apparent-faces))
                   (let ((face (vector-ref apparent-faces i)))
                     (add-triangles~ face add-triangle)
                     (set-indice~ face i)))
              (assert (= n (f32vector-length vertices)))
              (values vertices neighbors)))))))
  
  
  ;;;
  ;;;; Lightmap
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (update-lightmap)
    (fill-faces-lightmap faces))
  
  
  (method (fill-faces-lightmap faces)
    (let ((zone (current-zone)))
      (when (and faces (or (not lightmap-uptodate?)
                           @temporary
                           (and (get-update-lightmaps?~ zone)
                                (not lightmap-baked?))))
        (let ((world (current-world)))
          (let ((update? (get-update-lightmaps?~ zone)))
            (fill-lightmap (prepare-lightmap faces))
            (set! lightmap-baked? update?)
            (set! lightmap-uptodate? #t))))))
  
  
  (method (fill-lightmap lightmap)
    (if (not lightmap)
        (free-lightmap~ mesh)
      (allocate-lightmap~ mesh)
      (set-data~ (get-lightmap-buffer~ mesh) lightmap 3)))
  
  
  (method protected virtual (prepare-lightmap faces)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((update? (get-update-lightmaps?~ zone))
            (shadows? (get-shadowmaps?~ world))
            (edition? (get-edition?~ world)))
        (let ((triangles-count 0)
              (triangle-floats (* 3 3)))
          (for (i 0 (vector-length faces))
               (let ((face (vector-ref faces i)))
                 (increase! triangles-count (triangle-count~ face))))
          (let (@temporary (lights (collect-static-lights~ zone))
                (f32 <f32vector> (make-f32vector (* triangles-count triangle-floats) 0.)))
            (define (reachable? orig dir dist)
              (not (ray-closest-polygon~ world orig dir (- dist .1) filter: #f ignore-players?: #t)))
            
            @temporary
            (when update?
              (for-each (lambda (light <Light>)
                          (let ((pos (get-position~ light))
                                (diffuse (get-diffuse-color~ light))
                                (constant-attenuation (get-constant-attenuation~ light))
                                (linear-attenuation (get-linear-attenuation~ light))
                                (quadratic-attenuation (get-quadratic-attenuation~ light)))
                            (for (i 0 (vector-length faces))
                                 (let ((face (vector-ref faces i)))
                                   (let ((center-dir (vertex-& (get-center~ (get-polygon~ face)) pos)))
                                     (let ((center-dist (sqrt (f32-ref (dot-product& center-dir center-dir))))
                                           (center-L (vertex-normalize& center-dir)))
                                       (when (or (not edition?)
                                                 (and (< center-dist 100.)
                                                      (or (not shadows?) (reachable? pos center-L (- center-dist 5.)))))
                                         (for-each (lambda (triangle <Triangle>)
                                                     (let ((normal (get-normal~ triangle))
                                                           (index <fx> (* (get-indice~ triangle) triangle-floats)))
                                                       (define (augment-lighting v <f32vector> index <fx>)
                                                         (define (add-dye! dye <f32vector> factor <fl>)
                                                           (f32vector-set! f32 index (+ (f32vector-ref f32 index) (* (dye-red dye) factor)))
                                                           (f32vector-set! f32 (+ index 1) (+ (f32vector-ref f32 (+ index 1)) (* (dye-green dye) factor)))
                                                           (f32vector-set! f32 (+ index 2) (+ (f32vector-ref f32 (+ index 2)) (* (dye-blue dye) factor))))
                                                         
                                                         (let ((dir (vertex-& v pos)))
                                                           (let ((dist-square (f32-ref (dot-product& dir dir))))
                                                             (let ((dist (sqrt dist-square))
                                                                   (L (vertex-normalize& dir)))
                                                               (let ((lambert (- (f32-ref (dot-product& normal L)))))
                                                                 (when (> lambert 0.)
                                                                   (when (or edition? (not shadows?) (reachable? pos L dist))
                                                                     (let ((atttenuation-term (+ constant-attenuation (* linear-attenuation dist) (* quadratic-attenuation dist-square))))
                                                                       (let ((attenuation (/ 1. atttenuation-term)))
                                                                         (let ((factor (* lambert attenuation)))
                                                                           (add-dye! diffuse factor)))))))))))
                                                       
                                                       (augment-lighting (get-v1~ triangle) index)
                                                       (augment-lighting (get-v2~ triangle) (+ index 3))
                                                       (augment-lighting (get-v3~ triangle) (+ index 6))))
                                                   (get-triangles~ face)))))))))
                        lights))
            f32)))))
  
  
  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Faces
  ;;;
  
  
  (method (add-face face)
    (when (not faces-queue)
      (set! faces-queue (new-queue)))
    (enqueue faces-queue face))
  
  
  (method (collect-apparent-faces)
    (when (or (not-null? tiles) faces-queue)
      (let ((table (make-table test: vertex=? hash: vertex-hash)))
        (when faces-queue
          (for-each (lambda (face)
                      (table-set! table (get-center~ (get-polygon~ face)) face))
                    (queue-list faces-queue)))
        (for-each (lambda (tile)
                    (if (is-not? tile Block)
                        (for-each (lambda (face)
                                    (table-set! table (get-center~ (get-polygon~ face)) face))
                                  (element-faces~ tile))
                      (for-each (lambda (face)
                                  (let ((center (get-center~ (get-polygon~ face))))
                                    (if (table-ref table center #f)
                                        (table-clear table center)
                                      (table-set! table center face))))
                                (element-faces~ tile))))
                  tiles)
        (let ((faces (make-vector (table-length table)))
              (n 0))
          (iterate-table table
            (lambda (center face)
              (vector-set! faces n face)
              (increase! n)))
          faces))))))
