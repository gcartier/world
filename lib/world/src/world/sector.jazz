;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Sectors
;;;


(module world.sector jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.actor)
        (world.autoload)
        (world.block)
        (world.dye)
        (world.element)
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.light)
        (world.material)
        (world.mesh)
        (world.settings)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle)
        (world.window)
        (world.client.window))


;;;
;;;; Thread
;;;


(definition content-thread
  #f)


(definition (get-content-thread)
  (or content-thread (let ((thread (start-loop-thread 'content)))
                       (set! content-thread thread)
                       thread)))


(definition public (post-content thunk)
  (thread-post (get-content-thread) 'post-content
    thunk))


;;;
;;;; Sector
;;;


(class Sector extends Object
  
  
  (slot index              <vector>                   getter generate)
  (slot center             <f32vector>                getter generate)
  (slot tiles              <list>                     accessors generate)
  (slot entities           <list>                     accessors generate)
  (slot faces              <object>                   accessors generate)
  (slot mesh               <object>                   getter generate)
  (slot content-uptodate?  <bool>       initialize #f accessors generate)
  (slot vertices-uptodate? <bool>       initialize #f accessors generate)
  (slot lightmap-uptodate? <bool>       initialize #f accessors generate)
  (slot lightmap-baked?    <bool>       initialize #f accessors generate)
  
  
  (method override (initialize index center)
    (set! index~self index)
    (set! center~self center)
    (set! tiles~self '())
    (set! entities~self '())
    (set! faces~self #f)
    (set! mesh~self (new Mesh material: (get-material~ (get-tile-mesh~ (current-world))))))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((tiles (length tiles))
              (entities (length entities)))
          (format output "{l} with {a} tile{a} {a} entities" index tiles (format-plural tiles) entities)))))
  
  
  (method (free-mesh)
    (free-resources~ mesh))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (update)
    (update-content)
    (update-vertices)
    (update-lightmap))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method (update-content)
    (when (not content-uptodate?)
      (let ((zone (current-zone)))
        (when (generate-content?~ zone)
          (generate-content~ zone self)))
      (set! content-uptodate? #t)))
  
  
  ;;;
  ;;;; Vertices
  ;;;
  
  
  (method (update-vertices)
    (when (not vertices-uptodate?)
      (let ((apparent-faces (collect-apparent-faces)))
        (set! faces apparent-faces)
        (fill-faces-vertices apparent-faces))
      (set! vertices-uptodate? #t)))
  
  
  (method (fill-faces-vertices apparent-faces)
    (receive (vertices neighbors) (prepare-vertices/neighbors apparent-faces)
      (fill-vertices/neighbors vertices neighbors)))
  
  
  (method (fill-vertices/neighbors vertices neighbors)
    (if (not vertices)
        (begin
          (free-vertices~ mesh)
          (free-neighbors~ mesh))
      (allocate-vertices~ mesh)
      (set-data~ (get-vertices-buffer~ mesh) vertices 10)
      (allocate-neighbors~ mesh)
      (set-data~ (get-neighbors-buffer~ mesh) neighbors 6)))
  
  
  (method (prepare-vertices/neighbors apparent-faces)
    (if (not apparent-faces)
        (values #f #f)
      (let ((floats-per-indice 10))
        (let ((triangles-count 0)
              (triangle-floats (* 3 floats-per-indice))
              (triangle-neighbors-floats (* 3 7)))
          (loop (for i from 0 below (vector-length apparent-faces))
                (let ((face (vector-ref apparent-faces i)))
                  (increase! triangles-count (triangle-count~ face))))
          (let ((vertices (make-f32vector (* triangles-count triangle-floats)))
                (neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))
            (let ((indice 0)
                  (n 0)
                  (m 0))
              (define (add-triangle v1 v2 v3 n1 n2 n3 t1 t2 t3)
                (add-vertex v1) (add-normal n1) (add-texture t1) (add-bone) (add-neighbors 0. v2 v3)
                (add-vertex v2) (add-normal n2) (add-texture t2) (add-bone) (add-neighbors 1. v1 v3)
                (add-vertex v3) (add-normal n3) (add-texture t3) (add-bone) (add-neighbors 2. v1 v2))
                
              (define (add-vertex vert)
                (f32vector-set! vertices n (vertex-x vert))
                (f32vector-set! vertices (+ n 1) (vertex-y vert))
                (f32vector-set! vertices (+ n 2) (vertex-z vert))
                (set! n (+ n 3)))
              
              (define (add-normal normal)
                (f32vector-set! vertices n (vertex-x normal))
                (f32vector-set! vertices (+ n 1) (vertex-y normal))
                (f32vector-set! vertices (+ n 2) (vertex-z normal))
                (set! n (+ n 3)))
              
              (define (add-texture tex)
                (f32vector-set! vertices n (vertex-x tex))
                (f32vector-set! vertices (+ n 1) (vertex-y tex))
                (f32vector-set! vertices (+ n 2) (vertex-z tex))
                (set! n (+ n 3)))
              
              (define (add-bone)
                (f32vector-set! vertices n 0.)
                (set! n (+ n 1)))
              
              (define (add-neighbors rank n1 n2)
                (f32vector-set! neighbors m rank)
                (set! m (+ m 1))
                (f32vector-set! neighbors m (vertex-x n1))
                (f32vector-set! neighbors (+ m 1) (vertex-y n1))
                (f32vector-set! neighbors (+ m 2) (vertex-z n1))
                (set! m (+ m 3))
                (f32vector-set! neighbors m (vertex-x n2))
                (f32vector-set! neighbors (+ m 1) (vertex-y n2))
                (f32vector-set! neighbors (+ m 2) (vertex-z n2))
                (set! m (+ m 3)))
              
              (loop (for i from 0 below (vector-length apparent-faces))
                    (let ((face (vector-ref apparent-faces i)))
                      (add-triangles~ face add-triangle)
                      ;(set-indice~ triangle indice)
                      ;(increase! indice)
                      ))
              (assert (= n (f32vector-length vertices)))
              (values vertices neighbors)))))))
  
  
  ;;;
  ;;;; Lightmap
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (update-lightmap)
    (fill-faces-lightmap faces))
  
  
  (method (fill-faces-lightmap faces)
    (let ((zone (current-zone)))
      (when (and faces (or (not lightmap-uptodate?)
                           @temporary
                           (and (get-update-lightmaps?~ zone)
                                (not lightmap-baked?))))
        (let ((world (current-world)))
          (let ((update? (get-update-lightmaps?~ zone)))
            (fill-lightmap (prepare-lightmap faces))
            (set! lightmap-baked? update?)
            (set! lightmap-uptodate? #t))))))
  
  
  (method (fill-lightmap lightmap)
    (if (not lightmap)
        (free-lightmap~ mesh)
      (allocate-lightmap~ mesh)
      (set-data~ (get-lightmap-buffer~ mesh) lightmap 3)))
  
  
  (method (prepare-lightmap faces)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((update? (get-update-lightmaps?~ zone))
            (shadows? (get-shadowmaps?~ world))
            (edition? (get-edition?~ world)))
        (let ((triangles-count 0)
              (triangle-floats (* 3 3)))
          (loop (for i from 0 below (vector-length faces))
                (let ((face (vector-ref faces i)))
                  (increase! triangles-count (triangle-count~ face))))
          (let ((lights (collect-static-lights~ zone))
                (f32 <f32vector> (make-f32vector (* triangles-count triangle-floats))))
            (define (reachable? orig dir dist)
              (not (ray-closest-face~ world orig dir (- dist .1) filter: #f ignore-players?: #t)))
            
            @temporary
            (when update?
              (for-each (lambda (light <Light>)
                          (let ((pos (get-position~ light))
                                (diffuse (get-diffuse-color~ light))
                                (constant-attenuation (get-constant-attenuation~ light))
                                (linear-attenuation (get-linear-attenuation~ light))
                                (quadratic-attenuation (get-quadratic-attenuation~ light)))
                            (loop (for i from 0 below (vector-length faces))
                                  (let ((face (vector-ref faces i)))
                                    (let ((center-dir (vertex-& (get-center~ face) pos)))
                                      (let ((center-dist (sqrt (f32-ref (dot-product& center-dir center-dir))))
                                            (center-L (vertex-normalize& center-dir)))
                                        (when (or (not edition?)
                                                  (and (< center-dist 100.)
                                                       (or (not shadows?) (reachable? pos center-L (- center-dist 5.)))))
                                          (for-each (lambda (triangle <Triangle>)
                                                      (let ((normal (get-normal~ triangle))
                                                            (index <fx> (* (get-indice~ triangle) triangle-floats)))
                                                        (define (augment-lighting v <f32vector> index <fx>)
                                                          (define (add-dye! dye <f32vector> factor <fl>)
                                                            (f32vector-set! f32 index (+ (f32vector-ref f32 index) (* (dye-red dye) factor)))
                                                            (f32vector-set! f32 (+ index 1) (+ (f32vector-ref f32 (+ index 1)) (* (dye-green dye) factor)))
                                                            (f32vector-set! f32 (+ index 2) (+ (f32vector-ref f32 (+ index 2)) (* (dye-blue dye) factor))))
                                                          
                                                          (let ((dir (vertex-& v pos)))
                                                            (let ((dist-square (f32-ref (dot-product& dir dir))))
                                                              (let ((dist (sqrt dist-square))
                                                                    (L (vertex-normalize& dir)))
                                                                (let ((lambert (- (f32-ref (dot-product& normal L)))))
                                                                  (when (> lambert 0.)
                                                                    (when (or edition? (not shadows?) (reachable? pos L dist))
                                                                      (let ((atttenuation-term (+ constant-attenuation (* linear-attenuation dist) (* quadratic-attenuation dist-square))))
                                                                        (let ((attenuation (/ 1. atttenuation-term)))
                                                                          (let ((factor (* lambert attenuation)))
                                                                            (add-dye! diffuse factor)))))))))))
                                                        
                                                        (augment-lighting (get-v1~ triangle) index)
                                                        (augment-lighting (get-v2~ triangle) (+ index 3))
                                                        (augment-lighting (get-v3~ triangle) (+ index 6))))
                                                    (get-triangles~ face)))))))))
                        lights))
            f32)))))
  
  
  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Faces
  ;;;
  
  
  (method protected virtual (collect-apparent-faces)
    (tiles-apparent-faces tiles))
  
  
  (method (tiles-apparent-faces tiles)
    (when (not-null? tiles)
      (let ((table (make-table test: vertex=? hash: vertex-hash)))
        (for-each (lambda (tile)
                    (if (is-not? tile Blockable)
                        (for-each (lambda (face)
                                    (table-set! table (get-center~ face) face))
                                  (element-faces~ tile))
                      (for-each (lambda (face)
                                  (let ((center (get-center~ face)))
                                    (if (table-ref table center #f)
                                        (table-clear table center)
                                      (table-set! table center face))))
                                (element-faces~ tile))))
                  tiles)
        (let ((faces (make-vector (table-length table)))
              (n 0))
          (iterate-table table
            (lambda (center face)
              (vector-set! faces n face)
              (increase! n)))
          faces))))
  
  
  ;;;
  ;;;; Entities
  ;;;
  
  
  (method (draw-entities)
    (let ((me (current-me)))
      (for-each (lambda (element)
                  (unless (or (eq? element me) (not (get-visible?~ element)))
                    (draw~ element)))
                entities)))))
