;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Sectors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.sector jazz


(import (gambit.log)
        (jazz.debuggee)
        (world)
        (world.autoload)
        (world.block)
        (world.configure)
        (world.face)
        (world.geometry)
        (world.log)
        (world.material)
        (world.mesh)
        (world.renderers)
        (world.section)
        (world.support)
        (world.syntax (phase syntax))
        (world.task))


(proclaim (warn optimizations))


;;;
;;;; Queue
;;;


(class Generate-Queue extends Object
  
  
  (slot queue)
  (slot mutex           initialize (make-mutex))
  (slot mutex-condition initialize (make-condition))
  
  
  (method override (initialize)
    (nextmethod)
    (set! queue (new-queue)))
  
  
  (method public (empty?)
    (mutex-lock! mutex)
    (prog1 (queue-empty? queue)
      (mutex-unlock! mutex)))
  
  
  (method public (reset)
    (mutex-lock! mutex)
    (reset-queue queue)
    (mutex-unlock! mutex))
  
  
  (method public (push obj)
    (mutex-lock! mutex)
    (enqueue queue obj)
    (mutex-unlock! mutex)
    (condition-signal! mutex-condition))
  
  
  (method public (pop timeout)
    (declare (proper-tail-calls))
    (let (iter)
      (mutex-lock! mutex)
      (cond ((not (queue-empty? queue))
             (prog1 (dequeue queue)
               (mutex-unlock! mutex)))
            ((mutex-unlock! mutex mutex-condition timeout)
             (iter))
            (else
             (eof-object))))))


;;;
;;;; Thread
;;;


(definition protected generate-queue
  (new Generate-Queue))


(definition public (push-content thunk)
  (push~ generate-queue thunk))

(definition public (pop-content)
  (pop~ generate-queue +infinity))


(definition protected (stop-generate)
  (push-content
    (lambda (exit)
      (continuation-return exit #f))))


(definition protected (generate-task task <Task>)
  (declare (proper-tail-calls))
  (with-log-context "generate" generate-id waiting-state task
    (lambda (log-context)
      (set-context~ task log-context)
      (continuation-capture
        (lambda (exit)
          (set-generate-thread~ (current-zone) (current-thread))
          (ready-task~ task)
          (let (restart-loop)
            (with-current-loop
              (lambda ()
                (with-restart-catcher 'resume-loop (present-current-loop-restart)
                  (lambda ()
                    (let (iter)
                      (let ((thunk (pop-content)))
                        (log-transition log-context generate-parallel-state)
                        (thunk exit)
                        (log-transition log-context waiting-state)
                        (iter)))))))
            (restart-loop)))))))


;;;
;;;; Sector
;;;


(definition current-content-revision <fx>
  0)

(definition public (get-current-content-revision) <fx>
  current-content-revision)

(definition public (increase-current-content-revision)
  (increase! current-content-revision))


(class Sector extends Object
  
  
  (slot index               <vector>                   getter generate)
  (slot center              <f64vector>                getter generate)
  (slot section             <World-Section+>           accessors generate)
  (slot blocks              <list>                     accessors generate)
  (slot entities            <list>                     accessors generate)
  (slot faces               <list+>                    accessors generate)
  (slot other-faces         <table+>                   accessors generate)
  (slot mesh                <Mesh+>      initialize #f getter generate)
  (slot other-meshes        <table+>     initialize #f accessors generate)
  (slot queued?             <bool>       initialize #f accessors generate)
  (slot physical-uptodate?  <bool>       initialize #f accessors generate)
  (slot content-uptodate?   <bool>       initialize #f accessors generate)
  (slot content-revision    <fx>         initialize 0  accessors generate)
  (slot vertices-uptodate?  <bool>       initialize #f accessors generate)
  (slot lightmap-uptodate?  <bool>       initialize #f accessors generate)
  
  
  (method override (initialize index center)
    (set! index~self index)
    (set! center~self center)
    (set! section~self #f)
    (set! blocks~self '())
    (set! entities~self '())
    (set! faces~self #f)
    (set! other-faces~self #f))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((blocks (length blocks))
              (entities (length entities)))
          (format output "{a}, {a}, {a} with {a} block{a}, {a} entities" (vector-ref index 0) (vector-ref index 1) (vector-ref index 2) blocks (format-plural blocks) entities)))))
  
  
  (method (setup-mesh)
    (when (not mesh)
      (set! mesh (new Mesh material: (get-block-opaque~ (current-world))))))
  
  
  (method (setup-other-meshes)
    (when (not other-meshes)
      (set! other-meshes (make-table test: eq?))))
  
  
  (method (iterate-meshes proc)
    (when mesh
      (proc mesh))
    (when other-meshes
      (iterate-table other-meshes
        (lambda (material mesh)
          (proc mesh)))))
  
  
  (method (free-mesh)
    (when mesh
      (free-resources~ mesh)
      (set! mesh #f))
    (when other-meshes
      (iterate-table other-meshes
        (lambda (material mesh <Mesh>)
          (free-resources~ mesh)))
      (set! other-meshes #f)))
  
  
  (method public (empty?)
    (and (not mesh)
         (not other-meshes)
         (null? entities)))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (update)
    (update-content)
    (update-vertices)
    (update-lightmaps))
  
  
  ;;;
  ;;;; Physical
  ;;;
  
  
  (method (update-physical)
    (when (not physical-uptodate?)
      (site (generate-physical on?: #f)
        (let ((zone (current-zone)))
          (generate-physical~ zone self)))
      (set! physical-uptodate? #t)))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  ;; virtual for nmc
  (method virtual (update-content)
    (let ((world (current-world))
          (zone (current-zone)))
      (when (or (not content-uptodate?)
                (< content-revision current-content-revision))
        (cond ((< (get-sectors-generating~ zone)
                  (generate-threshold~ world))
               (if (generate-content?~ zone)
                   (begin
                     (increase-sectors-generating~ zone self)
                     (if generate-threaded?
                         (push-content
                           (lambda (exit)
                             (site (generate on?: #t)
                               (generate-content~ zone self))))
                       (site (generate-sequential on?: #t parent: draw-neighbors)
                         (generate-content~ zone self))))
                 (set! content-revision current-content-revision)
                 (set! content-uptodate? #t)))
              (else
               (increase-sectors-waiting~ zone self))))))
  
  
  ;;;
  ;;;; Mesh
  ;;;
  
  
  (method (install-mesh mesh <Mesh>)
    (set! mesh~self mesh))
  
  
  (method (install-other-mesh material <Material> mesh <Mesh>)
    (setup-other-meshes)
    (allege other-meshes
      (table-set! other-meshes material mesh)))
  
  
  ;;;
  ;;;; Faces
  ;;;
  
  
  (method (add-face face <Face>)
    (let ((material (get-material~ face)))
      (let ((renderer (get-renderer~ material)))
        (cond ((eq? renderer (get-opaque-renderer))
               (when (not faces)
                 (set! faces '()))
               (set! faces (cons face faces)))
              (else
               (when (not other-faces)
                 (set! other-faces (make-table test: eq?)))
               (allege other-faces
                 (let ((faces (table-ref other-faces material #f)))
                   (when (not faces)
                     (set! faces '())
                     (table-set! other-faces material faces))
                   (table-set! other-faces material (cons face faces)))))))))
  
  
  (method (add-block-faces)
    (let ((cube-faces <table+> #f))
      (for-each (lambda (block <Block>)
                  (let ((faces (element-faces~ block))
                        (model (cache-model~ block)))
                    (if (opaque-cube?~ model)
                        (for-each (lambda (face <Face>)
                                    (let ((center (get-center~ (get-polygon~ face))))
                                      (when (not cube-faces)
                                        (set! cube-faces (make-table test: vertex=? hash: vertex-hash)))
                                      (allege cube-faces
                                        (if (table-ref cube-faces center #f)
                                            (table-clear cube-faces center)
                                          (table-set! cube-faces center face)))))
                                  faces)
                      (for-each add-face faces))))
                blocks)
      (when cube-faces
        (iterate-table cube-faces
          (lambda (center face)
            (add-face face))))))
  
  
  ;;;
  ;;;; Vertices
  ;;;
  
  
  (method (update-vertices)
    (when (not vertices-uptodate?)
      (free-mesh)
      (add-block-faces)
      (when faces
        (setup-mesh)
        (fill-faces-vertices mesh faces))
      (when other-faces
        (setup-other-meshes)
        (allege other-meshes
          (iterate-table other-faces
            (lambda (material faces)
              (when (not (table-ref other-meshes material #f))
                (let ((atlas (get-block-atlas~ (current-world))))
                  (table-set! other-meshes material (new Mesh material: material))))
              (fill-faces-vertices (table-ref other-meshes material) (table-ref other-faces material))))))
      (set! vertices-uptodate? #t)))
  
  
  (method (fill-faces-vertices mesh <Mesh> apparent-faces)
    (receive (vertices neighbors) (prepare-vertices/neighbors apparent-faces)
      (fill-vertices/neighbors mesh #f vertices neighbors)))
  
  
  (method (fill-vertices/neighbors mesh <Mesh> triangles <fx+> vertices neighbors)
    (if (not vertices)
        (begin
          (free-vertices~ mesh)
          (free-neighbors~ mesh))
      (allocate-vertices~ mesh)
      (set-data~ (get-vertices-buffer~ mesh) vertices (if triangles (* triangles triangle-floats) (f32vector-length vertices)) vertex-floats)
      (when (get-debug-meshes?)
        (set-vertices-data~ mesh vertices))
      (allocate-neighbors~ mesh)
      (set-data~ (get-neighbors-buffer~ mesh) neighbors (if triangles (* triangles triangle-neighbors-floats) (f32vector-length neighbors)) neighbors-floats)))
  
  
  (method (prepare-vertices/neighbors apparent-faces)
    (if (not apparent-faces)
        (values #f #f)
      (let ((triangles-count <fx> 0))
        (for-each (lambda (face <Face>)
                    (increase! triangles-count (triangle-count~ face)))
                  apparent-faces)
        (let ((vertices (make-f32vector (* triangles-count triangle-floats)))
              (neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))
          (let ((n <fx> 0)
                (m <fx> 0))
            (define (add-triangle v1 n1 u1 o1 b1 v2 n2 u2 o2 b2 v3 n3 u3 o3 b3 tdepth)
              (add-vertex v1) (add-normal n1) (add-texture u1 o1 tdepth) (add-bone b1) (add-neighbors 0. v2 v3)
              (add-vertex v2) (add-normal n2) (add-texture u2 o2 tdepth) (add-bone b2) (add-neighbors 1. v1 v3)
              (add-vertex v3) (add-normal n3) (add-texture u3 o3 tdepth) (add-bone b3) (add-neighbors 2. v1 v2))
            
            (define (add-vertex vert <f64vector>)
              (f32vector-set! vertices n (vertex-x vert))
              (f32vector-set! vertices (+ n 1) (vertex-y vert))
              (f32vector-set! vertices (+ n 2) (vertex-z vert))
              (set! n (+ n 3)))
            
            (define (add-normal normal <f64vector>)
              (f32vector-set! vertices n (vertex-x normal))
              (f32vector-set! vertices (+ n 1) (vertex-y normal))
              (f32vector-set! vertices (+ n 2) (vertex-z normal))
              (set! n (+ n 3)))
            
            (define (add-texture uv <f32vector> offset <fx> tdepth <fl>)
              (f32vector-set! vertices n (f32vector-ref uv offset))
              (f32vector-set! vertices (+ n 1) (f32vector-ref uv (+ offset 1)))
              (f32vector-set! vertices (+ n 2) tdepth)
              (set! n (+ n 3)))
            
            (define (add-bone bone <fx>)
              (f32vector-set! vertices n (cast <fl> bone))
              (set! n (+ n 1)))
            
            (define (add-neighbors rank <fl> n1 <f64vector> n2 <f64vector>)
              (f32vector-set! neighbors m rank)
              (set! m (+ m 1))
              (f32vector-set! neighbors m (vertex-x n1))
              (f32vector-set! neighbors (+ m 1) (vertex-y n1))
              (f32vector-set! neighbors (+ m 2) (vertex-z n1))
              (set! m (+ m 3))
              (f32vector-set! neighbors m (vertex-x n2))
              (f32vector-set! neighbors (+ m 1) (vertex-y n2))
              (f32vector-set! neighbors (+ m 2) (vertex-z n2))
              (set! m (+ m 3)))
            
            (loop (for face <Face> in apparent-faces)
                  (for i from 0)
                  (do (add-triangles~ face add-triangle)
                      (set-indice~ face i)))
            (assert (= n (f32vector-length vertices)))
            (values vertices neighbors))))))
  
  
  ;;;
  ;;;; Lightmap
  ;;;
  
  
  (method (update-lightmaps)
    (when (not lightmap-uptodate?)
      (when (and mesh faces)
        (update-lightmap mesh faces)
        (set! faces #f))
      (when (and other-meshes other-faces)
        (iterate-table other-meshes
          (lambda (material mesh)
            (let ((faces (table-ref other-faces material)))
              (update-lightmap mesh faces))))
        (set! other-faces #f))
      (set! lightmap-uptodate? #t)))
  
  
  (method (update-lightmap mesh <Mesh> faces)
    (fill-faces-lightmap mesh faces))
  
  
  (method (fill-faces-lightmap mesh <Mesh> faces)
    (fill-lightmap mesh #f (prepare-lightmap faces)))
  
  
  (method (fill-lightmap mesh <Mesh> triangles <fx+> lightmap)
    (if (not lightmap)
        (free-lightmap~ mesh)
      (allocate-lightmap~ mesh)
      (set-data~ (get-lightmap-buffer~ mesh) lightmap (if triangles (* triangles triangle-lightmap-floats) (f32vector-length lightmap)) lightmap-floats)
      (when (get-debug-lightmap?)
        (set-lightmap-data~ mesh lightmap))))
  
  
  (method protected virtual (prepare-lightmap faces)
    (let ((triangles-count <fx> 0))
      (for-each (lambda (face <Face>)
                  (increase! triangles-count (triangle-count~ face)))
                faces)
      (make-f32vector (* triangles-count triangle-lightmap-floats) 0.)))))
