;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Sectors
;;;


(module world.sector jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.actor)
        (world.autoload)
        (world.block)
        (world.dye)
        (world.element)
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.light)
        (world.material)
        (world.mesh)
        (world.settings)
        (world.texture)
        (world.triangle)
        (world.window)
        (world.client.window))


;;;
;;;; Sector
;;;


(class Sector extends Object
  
  
  (slot index              <list>                     getter generate)
  (slot center             <f32vector>                getter generate)
  (slot tiles              <list>                     accessors generate)
  (slot faces              <object>                   accessors generate)
  (slot mesh               <object>                   getter generate)
  (slot vertices-content   <object>     initialize #f getter generate)
  (slot vertices-uptodate? <bool>       initialize #f accessors generate)
  (slot lightmap-uptodate? <bool>       initialize #f accessors generate)
  (slot lightmap-filled?   <bool>       initialize #f accessors generate)
  
  
  (method override (initialize index center)
    (set! index~self index)
    (set! center~self center)
    (set! tiles~self '())
    (set! faces~self #f)
    (set! mesh~self (new Mesh material: (get-material~ (get-tile-mesh~ world)))))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((tiles (length tiles)))
          (format output "{l} with {a} tile{a}" index tiles (format-plural tiles))))))
  
  
  (method (free-mesh)
    (free-resources~ mesh))
  
  
  ;;;
  ;;;; Vertices
  ;;;
  
  
  ;; v1 t1 n1 v2 t2 n2 v3 t3 n3
  ;; v1x v1y v1z t1x t1y t1z n1x n1y n1z v2x v2y v2z t2x t2y t2z n2x n2y n2z v3x v3y v3z t3x t3y t3z n3x n3y n3z
  
  
  (method (update-vertices)
    (when (not vertices-uptodate?)
      (let ((visible-faces (collect-visible-faces)))
        (set! faces visible-faces)
        (if (not visible-faces)
            (begin
              (free-vertices~ mesh)
              (free-neighbors~ mesh))
          (let ((triangles-count 0)
                (triangle-floats (* 3 3 3))
                (triangle-neighbors-floats (* 3 3 2)))
            (iterate-table visible-faces
              (lambda (center face)
                (increase! triangles-count (length (get-triangles~ face)))))
            (let ((content (make-f32vector (* triangles-count triangle-floats)))
                  (neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))
              (let ((indice 0)
                    (n 0)
                    (m 0))
                (define (add-vertex vert)
                  (f32vector-set! content n (vertex-x vert))
                  (f32vector-set! content (+ n 1) (vertex-y vert))
                  (f32vector-set! content (+ n 2) (vertex-z vert))
                  (set! n (+ n 3)))
                
                (define (add-texture tex)
                  (f32vector-set! content n (vertex-x tex))
                  (f32vector-set! content (+ n 1) (vertex-y tex))
                  (f32vector-set! content (+ n 2) (vertex-z tex))
                  (set! n (+ n 3)))
                
                (define (add-normal normal)
                  (f32vector-set! content n (vertex-x normal))
                  (f32vector-set! content (+ n 1) (vertex-y normal))
                  (f32vector-set! content (+ n 2) (vertex-z normal))
                  (set! n (+ n 3)))
                
                (define (add-neighbors n1 n2)
                  (f32vector-set! neighbors m (vertex-x n1))
                  (f32vector-set! neighbors (+ m 1) (vertex-y n1))
                  (f32vector-set! neighbors (+ m 2) (vertex-z n1))
                  (set! m (+ m 3))
                  (f32vector-set! neighbors m (vertex-x n2))
                  (f32vector-set! neighbors (+ m 1) (vertex-y n2))
                  (f32vector-set! neighbors (+ m 2) (vertex-z n2))
                  (set! m (+ m 3)))
                
                (iterate-table visible-faces
                  (lambda (center face)
                    (for-each (lambda (triangle)
                                (let ((v1 (get-v1~ triangle))
                                      (v2 (get-v2~ triangle))
                                      (v3 (get-v3~ triangle))
                                      (n1 (get-normal1~ triangle))
                                      (n2 (get-normal2~ triangle))
                                      (n3 (get-normal3~ triangle)))
                                  (add-vertex v1) (add-texture (get-t1~ triangle)) (add-normal n1) (add-neighbors v2 v3)
                                  (add-vertex v2) (add-texture (get-t2~ triangle)) (add-normal n2) (add-neighbors v1 v3)
                                  (add-vertex v3) (add-texture (get-t3~ triangle)) (add-normal n3) (add-neighbors v1 v2))
                                (set-indice~ triangle indice)
                                (increase! indice))
                              (get-triangles~ face))))
                (assert (= n (f32vector-length content)))
                (set! vertices-content (and (get-draw-wireframe?~ world) content))
                (allocate-vertices~ mesh)
                (set-data~ (get-vertices-buffer~ mesh) content 9)
                (allocate-neighbors~ mesh)
                (set-data~ (get-neighbors-buffer~ mesh) neighbors 6))))))
      (set! vertices-uptodate? #t)))
  
  
  ;;;
  ;;;; Lightmap
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (update-lightmap)
    (when (and faces (or (not lightmap-uptodate?) (not lightmap-filled?)))
      (let ((update? (get-update-lightmaps?~ zone))
            (shadows? (get-shadowmaps?~ world))
            (edition? (get-edition?~ world)))
        (let ((content
                (let ((triangles-count 0)
                      (triangle-floats (* 3 3)))
                  (iterate-table faces
                    (lambda (center <f32vector> face <Face>)
                      (increase! triangles-count (length (get-triangles~ face)))))
                  (let ((lights (collect-static-lights~ zone))
                        (f32 <f32vector> (make-f32vector (* triangles-count triangle-floats))))
                    (define (reachable? orig dir dist)
                      (not (ray-closest-element~ world orig dir (- dist .1) filter: #f ignore-players?: #t)))
                    
                    (when update?
                      (for-each (lambda (light <Light>)
                                  (let ((pos (get-position~ light))
                                        (diffuse (get-diffuse-color~ light))
                                        (constant-attenuation (get-constant-attenuation~ light))
                                        (linear-attenuation (get-linear-attenuation~ light))
                                        (quadratic-attenuation (get-quadratic-attenuation~ light)))
                                    (iterate-table faces
                                      (lambda (center <f32vector> face <Face>)
                                        (let ((center-dir (vertex- center pos)))
                                          (let ((center-dist (sqrt (dot-product center-dir center-dir)))
                                                (center-L (vertex-normalize center-dir)))
                                            (when (or (not edition?)
                                                      (and (< center-dist 100.)
                                                           (or (not shadows?) (reachable? pos center-L (- center-dist 5.)))))
                                              (for-each (lambda (triangle <Triangle>)
                                                          (let ((normal (get-normal~ triangle))
                                                                (index <fx> (* (get-indice~ triangle) triangle-floats)))
                                                            (define (augment-lighting v <f32vector> index <fx>)
                                                              (define (add-dye! dye <f32vector> factor <fl>)
                                                                (f32vector-set! f32 index (+ (f32vector-ref f32 index) (* (dye-red dye) factor)))
                                                                (f32vector-set! f32 (+ index 1) (+ (f32vector-ref f32 (+ index 1)) (* (dye-green dye) factor)))
                                                                (f32vector-set! f32 (+ index 2) (+ (f32vector-ref f32 (+ index 2)) (* (dye-blue dye) factor))))
                                                              
                                                              (let ((dir (vertex- v pos)))
                                                                (let ((dist-square (dot-product dir dir)))
                                                                  (let ((dist (sqrt dist-square))
                                                                        (L (vertex-normalize dir)))
                                                                    (let ((lambert (- (dot-product normal L))))
                                                                      (when (> lambert 0.)
                                                                        (when (or edition? (not shadows?) (reachable? pos L dist))
                                                                          (let ((atttenuation-term (+ constant-attenuation (* linear-attenuation dist) (* quadratic-attenuation dist-square))))
                                                                            (let ((attenuation (/ 1. atttenuation-term)))
                                                                              (let ((factor (* lambert attenuation)))
                                                                                (add-dye! diffuse factor)))))))))))
                                                            
                                                            (augment-lighting (get-v1~ triangle) index)
                                                            (augment-lighting (get-v2~ triangle) (+ index 3))
                                                            (augment-lighting (get-v3~ triangle) (+ index 6))))
                                                        (get-triangles~ face)))))))))
                                lights))
                    f32))))
          (if (not content)
              (free-lightmap~ mesh)
            (allocate-lightmap~ mesh)
            (set-data~ (get-lightmap-buffer~ mesh) content 3))
          (set! lightmap-uptodate? update?)
          (set! lightmap-filled? #t)))))
  
  
  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Faces
  ;;;
  
  
  (method (collect-visible-faces)
    (when (not-null? tiles)
      (let ((table (make-table test: vertex=? hash: vertex-hash)))
        (for-each (lambda (tile)
                    (if (is-not? tile Block)
                        (for-each (lambda (face)
                                    (table-set! table (get-center~ face) face))
                                  (get-faces~ tile))
                      (for-each (lambda (face)
                                  (let ((center (get-center~ face)))
                                    ;; this test only really makes sense for blocks
                                    (if (table-ref table center #f)
                                        (table-clear table center)
                                      (table-set! table center face))))
                                (get-faces~ tile))))
                  tiles)
        table)))))
