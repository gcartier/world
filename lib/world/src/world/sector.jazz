;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Sectors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.sector jazz


(import (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.expanse)
        (world.face)
        (world.geometry)
        (world.homogeneous)
        (world.index)
        (world.mesh)
        (world.queue)
        (world.section)
        (world.support)
        (world.task))


(proclaim (not check bounds)
          (warn optimizations))


;;;
;;;; Thread
;;;


(definition protected generate-queue <Priorities-Queue>
  (new Priorities-Queue 3 65536))


(definition public (push-content sector priority)
  (push generate-queue sector priority))

(definition public (pop-content)
  (pop generate-queue +infinity))

(definition public (reset-content)
  (reset generate-queue))

(definition public (trim-content priority) <fx>
  (trim generate-queue priority))


(definition protected (stop-generate)
  (push-content #f 0))


;; quick hack for generate performance tests to acquire the task mutex
(definition protected force-generate-acquire-task-mutex?
  #f)

(definition protected (set-force-generate-acquire-task-mutex? force?)
  (set! force-generate-acquire-task-mutex? force?))


(definition protected (generate-task task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping? task)
                (if force-generate-acquire-task-mutex?
                    (with-task-mutex
                      (lambda ()
                        (generate-visual zone sector)))
                  (generate-visual zone sector)))
              (iter))))))))


@generate-tasks
(definition protected (generate-task2 task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping? task)
                (if force-generate-acquire-task-mutex?
                    (with-task-mutex
                      (lambda ()
                        (generate-visual2 zone sector)))
                  (generate-visual2 zone sector)))
              (iter))))))))


@generate-tasks
(definition protected (generate-task3 task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping? task)
                (if force-generate-acquire-task-mutex?
                    (with-task-mutex
                      (lambda ()
                        (generate-visual3 zone sector)))
                  (generate-visual3 zone sector)))
              (iter))))))))


@generate-tasks
(definition protected (generate-task4 task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping? task)
                (if force-generate-acquire-task-mutex?
                    (with-task-mutex
                      (lambda ()
                        (generate-visual4 zone sector)))
                  (generate-visual4 zone sector)))
              (iter))))))))


@generate-tasks
(definition protected (generate-task5 task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping? task)
                (if force-generate-acquire-task-mutex?
                    (with-task-mutex
                      (lambda ()
                        (generate-visual5 zone sector)))
                  (generate-visual5 zone sector)))
              (iter))))))))


;;;
;;;; Sector
;;;


(class Sector extends Object
  
  
  (slot index              <index>                         getter generate)
  (slot center             <vertex>                        getter generate)
  (slot expanse            <Expanse>                       getter generate)
  (slot section            <World-Section+> initialize #f  accessors generate)
  (slot texture-elements   <list>           initialize '() accessors generate)
  (slot mesh               <Mesh+>          initialize #f  getter generate)
  (slot material-mesh      <Mesh+>          initialize #f  getter generate)
  (slot other-meshes       <vector+>        initialize #f  accessors generate)
  (slot categorized-mesh   <Mesh+>          initialize #f  accessors generate)
  (slot visual-uptodate?   <bool>           initialize #f  accessors generate)
  (slot visual-revision    <fx>             initialize -1  accessors generate)
  (slot visual-generating? <bool>           initialize #f  accessors generate)
  
  
  (method override (initialize self index center expanse)
    (set! self.index index)
    (set! self.center center)
    (set! self.expanse expanse))
  
  
  (method override (destroy self)
    (nextmethod self)
    (free self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}, {a}, {a}" (index-x index) (index-y index) (index-z index)))))
  
  
  (method package (get-position& self) <vertex>
    (let ((sector-x <fx> (index-x index))
          (sector-y <fx> (index-y index))
          (sector-z <fx> (index-z index)))
      (vertex& (* (cast <fl> sector-x) 16.)
               (* (cast <fl> sector-y) 16.)
               (* (cast <fl> sector-z) 16.))))
  
  
  (method package (setup-mesh self)
    (when (not mesh)
      (set! mesh (new Mesh material: (get-block-opaque (current-world))))))
  
  
  (method package (setup-material-mesh self)
    (when (not material-mesh)
      (set! material-mesh (new Mesh material: (get-material-opaque (current-world))))))
  
  
  (method package (setup-other-meshes self meshes)
    (set! other-meshes meshes))
  
  
  (method package (setup-categorized-mesh self mesh)
    (set! categorized-mesh mesh))
  
  
  (method package (free self)
    (free-section self)
    (free-texture-elements self)
    (free-mesh self))
  
  
  (method (free-section self)
    (set! section #f))
  
  
  (method (free-texture-elements self)
    (for-each close texture-elements))
  
  
  (method package (free-mesh self)
    (when mesh
      (free-resources mesh)
      (set! mesh #f))
    (free-material-mesh self)
    (when other-meshes
      (loop (for mesh <Mesh> in-vector other-meshes)
            (free-resources mesh))
      (set! other-meshes #f))
    (when categorized-mesh
      (free-resources categorized-mesh)
      (set! categorized-mesh #f)))
  
  
  (method package (free-material-mesh self)
    (when material-mesh
      (free-resources material-mesh)
      (set! material-mesh #f)))
  
  
  (method public (empty? self)
    (and (not mesh)
         (not material-mesh)
         (not other-meshes)))
  
  
  ;;;
  ;;;; Visual
  ;;;
  
  
  (method package (update-visual self)
    (let ((world (current-world))
          (zone (current-zone)))
      (define (sector-priority) <fx>
        (let ((camera (current-camera)))
          (let ((pos (get-position camera))
                (sight (get-sight camera)))
            (cond ((< (vertex-distance& pos center) generate-near)
                   0)
                  ((<= (ray-point-horizontal-distance& pos sight center) generate-spread)
                   1)
                  (else
                   2)))))
      
      (when (and (not visual-generating?)
                 (or (not visual-uptodate?)
                     (< visual-revision (get-revision (get-generator zone)))))
        (let ((priority (sector-priority))
              (top-queued (top-priority generate-queue)))
          (when (or (not top-queued) (<= priority top-queued))
            (set! visual-generating? #t)
            (increase-sectors-generating zone 1)
            (push-content self priority))))))
  
  
  ;;;
  ;;;; Vertices
  ;;;
  
  
  (method package (prepare-vertices/neighbors self apparent-faces)
    (if (not apparent-faces)
        (values #f #f)
      (let ((triangles-count <fx> 0))
        (for-each (lambda (face <Face>)
                    (increase! triangles-count (triangle-count face)))
                  apparent-faces)
        (let ((vertices (make-f32vector (* triangles-count triangle-floats)))
              (neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))
          (let ((n <fx> 0)
                (m <fx> 0))
            (define (add-triangle v1 <vertex> n1 <vertex> s1 <fx> t1 <fx> b1 <fx> v2 <vertex> n2 <vertex> s2 <fx> t2 <fx> b2 <fx> v3 <vertex> n3 <vertex> s3 <fx> t3 <fx> b3 <fx> uv <f32vector> tdepth <fl>)
              (add-vertex v1) (add-normal n1) (add-texture s1 t1 uv tdepth) (add-bone b1) (add-neighbors 0. v2 v3)
              (add-vertex v2) (add-normal n2) (add-texture s2 t2 uv tdepth) (add-bone b2) (add-neighbors 1. v1 v3)
              (add-vertex v3) (add-normal n3) (add-texture s3 t3 uv tdepth) (add-bone b3) (add-neighbors 2. v1 v2))
            
            (define (add-vertex vert <vertex>)
              (f32vector-set! vertices n (vertex-x vert))
              (f32vector-set! vertices (+ n 1) (vertex-y vert))
              (f32vector-set! vertices (+ n 2) (vertex-z vert))
              (set! n (+ n 3)))
            
            (define (add-normal normal <vertex>)
              (f32vector-set! vertices n (vertex-x normal))
              (f32vector-set! vertices (+ n 1) (vertex-y normal))
              (f32vector-set! vertices (+ n 2) (vertex-z normal))
              (set! n (+ n 3)))
            
            (define (add-texture s <fx> t <fx> uv <f32vector> tdepth <fl>)
              (f32vector-set! vertices n (f32vector-ref uv s))
              (f32vector-set! vertices (+ n 1) (f32vector-ref uv t))
              (f32vector-set! vertices (+ n 2) tdepth)
              (set! n (+ n 3)))
            
            (define (add-bone bone <fx>)
              (f32vector-set! vertices n (cast <fl> bone))
              (set! n (+ n 1)))
            
            (define (add-neighbors rank <fl> n1 <vertex> n2 <vertex>)
              (f32vector-set! neighbors m rank)
              (set! m (+ m 1))
              (f32vector-set! neighbors m (vertex-x n1))
              (f32vector-set! neighbors (+ m 1) (vertex-y n1))
              (f32vector-set! neighbors (+ m 2) (vertex-z n1))
              (set! m (+ m 3))
              (f32vector-set! neighbors m (vertex-x n2))
              (f32vector-set! neighbors (+ m 1) (vertex-y n2))
              (f32vector-set! neighbors (+ m 2) (vertex-z n2))
              (set! m (+ m 3)))
            
            (loop (for face <Face> in apparent-faces)
                  (for i from 0)
                  (do (add-triangles face add-triangle)
                      (set-indice face i)))
            (assert (= n (f32vector-length vertices)))
            (values vertices neighbors))))))
  
  
  (method package (fill-vertices/neighbors self mesh <Mesh> triangles <fx+> vertices <f32vector+> neighbors <f32vector+>)
    (if (not vertices)
        (begin
          (free-vertices mesh)
          (free-neighbors mesh))
      (allocate-vertices mesh)
      (set-data (get-vertices-buffer mesh) vertices (if triangles (* triangles triangle-floats) (f32vector-length vertices)) vertex-floats)
      (allocate-neighbors mesh)
      (set-data (get-neighbors-buffer mesh) neighbors (if triangles (* triangles triangle-neighbors-floats) (f32vector-length (allege neighbors))) neighbors-floats)))
  
  
  ;;;
  ;;;; Lightmap
  ;;;
  
  
  (method package (prepare-lightmap self faces)
    (let ((triangles-count <fx> 0))
      (for-each (lambda (face <Face>)
                  (increase! triangles-count (triangle-count face)))
                faces)
      (make-f32vector (* triangles-count triangle-lightmap-floats) 0.)))
  
  
  (method package (fill-lightmap self mesh <Mesh> triangles <fx+> lightmap <f32vector+>)
    (if (not lightmap)
        (free-lightmap mesh)
      (allocate-lightmap mesh)
      (set-data (get-lightmap-buffer mesh) lightmap (if triangles (* triangles triangle-lightmap-floats) (f32vector-length lightmap)) lightmap-floats)
      (when debug-lightmap?
        (set-lightmap-data mesh lightmap))))))
