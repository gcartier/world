;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Sectors
;;;


(module world.sector jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.actor)
        (world.autoload)
        (world.block)
        (world.dye)
        (world.element)
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.light)
        (world.material)
        (world.mesh)
        (world.settings)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle)
        (world.window)
        (world.client.window))


;;;
;;;; Thread
;;;


(definition priority-content-thread
  #f)


(definition (get-priority-content-thread)
  (or priority-content-thread (let ((thread (start-loop-thread 'priority-content)))
                                (set! priority-content-thread thread)
                                thread)))


(definition public (post-priority-content thunk)
  (thread-post (get-priority-content-thread) 'priority-content
    thunk))


(definition content-thread
  #f)


(definition (get-content-thread)
  (or content-thread (let ((thread (start-loop-thread 'content)))
                       (set! content-thread thread)
                       thread)))


(definition public (post-content thunk)
  (thread-post (get-content-thread) 'content
    thunk))


(definition public (throttle-content-thread)
  (thread-base-priority-set! (get-content-thread) -1.))

(definition public (resume-content-thread)
  (thread-base-priority-set! (get-content-thread) 0.))


;;;
;;;; Sector
;;;


(definition current-content-revision
  0)

(definition public (get-current-content-revision)
  current-content-revision)

(definition public (increase-current-content-revision)
  (increase! current-content-revision))


(class Sector extends Object
  
  
  (slot index              <vector>                   getter generate)
  (slot center             <f32vector>                getter generate)
  (slot tiles              <list>                     accessors generate)
  (slot entities           <list>                     accessors generate)
  (slot faces              <object>                   accessors generate)
  (slot mesh               <Mesh>                     getter generate)
  (slot physical-uptodate? <bool>       initialize #t accessors generate)
  (slot content-priority   <object>     initialize #f accessors generate)
  (slot content-revision   <fx>         initialize 0  accessors generate)
  (slot content-uptodate?  <bool>       initialize #f accessors generate)
  (slot vertices-uptodate? <bool>       initialize #f accessors generate)
  (slot lightmap-uptodate? <bool>       initialize #f accessors generate)
  (slot lightmap-baked?    <bool>       initialize #f accessors generate)
  
  
  (method override (initialize index center)
    (set! index~self index)
    (set! center~self center)
    (set! tiles~self '())
    (set! entities~self '())
    (set! faces~self #f)
    (set! mesh~self (new Mesh material: (get-material~ (get-tile-mesh~ (current-world))))))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((tiles (length tiles))
              (entities (length entities)))
          (format output "{a}, {a}, {a} with {a} tile{a}, {a} entities" (vector-ref index 0) (vector-ref index 1) (vector-ref index 2) tiles (format-plural tiles) entities)))))
  
  
  (method (free-mesh)
    (free-resources~ mesh))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (update near?)
    (update-content near?)
    (update-vertices)
    (update-lightmap))
  
  
  ;;;
  ;;;; Physical
  ;;;
  
  
  (method (update-physical)
    (when (not physical-uptodate?)
      (let ((zone (current-zone)))
        (generate-physical~ zone self))
      (set! physical-uptodate? #t)))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method (update-content near?)
    (when (or (not content-uptodate?)
              (< content-revision current-content-revision))
      (let ((zone (current-zone)))
        (if (generate-content?~ zone)
            (let ((priority (if near? 1 0)))
              (when (or (not content-priority) (> priority content-priority))
                (set! content-priority priority)
                (set! content-uptodate? #f)
                (generate-content~ zone self priority)))
          (set! content-revision current-content-revision)
          (set! content-uptodate? #t)))))
  
  
  ;;;
  ;;;; Vertices
  ;;;
  
  
  (method (update-vertices)
    (when (not vertices-uptodate?)
      (let ((apparent-faces (collect-apparent-faces)))
        (set! faces apparent-faces)
        (fill-faces-vertices apparent-faces))
      (set! vertices-uptodate? #t)))
  
  
  (method (fill-faces-vertices apparent-faces)
    (receive (vertices neighbors) (prepare-vertices/neighbors apparent-faces)
      (fill-vertices/neighbors vertices neighbors)))
  
  
  (method (fill-vertices/neighbors vertices neighbors)
    (if (not vertices)
        (begin
          (free-vertices~ mesh)
          (free-neighbors~ mesh))
      (allocate-vertices~ mesh)
      (set-data~ (get-vertices-buffer~ mesh) vertices 10)
      (allocate-neighbors~ mesh)
      (set-data~ (get-neighbors-buffer~ mesh) neighbors 6)))
  
  
  (method (prepare-vertices/neighbors apparent-faces)
    (if (not apparent-faces)
        (values #f #f)
      (let ((floats-per-indice 10))
        (let ((triangles-count 0)
              (triangle-floats (* 3 floats-per-indice))
              (triangle-neighbors-floats (* 3 7)))
          (for (i 0 (vector-length apparent-faces))
               (let ((face (vector-ref apparent-faces i)))
                 (increase! triangles-count (triangle-count~ face))))
          (let ((vertices (make-f32vector (* triangles-count triangle-floats)))
                (neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))
            (let ((n 0)
                  (m 0))
              (define (add-triangle v1 v2 v3 n1 n2 n3 t1u t1v t2u t2v t3u t3v)
                (add-vertex v1) (add-normal n1) (add-texture t1u t1v) (add-bone) (add-neighbors 0. v2 v3)
                (add-vertex v2) (add-normal n2) (add-texture t2u t2v) (add-bone) (add-neighbors 1. v1 v3)
                (add-vertex v3) (add-normal n3) (add-texture t3u t3v) (add-bone) (add-neighbors 2. v1 v2))
                
              (define (add-vertex vert)
                (f32vector-set! vertices n (vertex-x vert))
                (f32vector-set! vertices (+ n 1) (vertex-y vert))
                (f32vector-set! vertices (+ n 2) (vertex-z vert))
                (set! n (+ n 3)))
              
              (define (add-normal normal)
                (f32vector-set! vertices n (vertex-x normal))
                (f32vector-set! vertices (+ n 1) (vertex-y normal))
                (f32vector-set! vertices (+ n 2) (vertex-z normal))
                (set! n (+ n 3)))
              
              (define (add-texture tu tv)
                (f32vector-set! vertices n tu)
                (f32vector-set! vertices (+ n 1) tv)
                (f32vector-set! vertices (+ n 2) 1.)
                (set! n (+ n 3)))
              
              (define (add-bone)
                (f32vector-set! vertices n 0.)
                (set! n (+ n 1)))
              
              (define (add-neighbors rank n1 n2)
                (f32vector-set! neighbors m rank)
                (set! m (+ m 1))
                (f32vector-set! neighbors m (vertex-x n1))
                (f32vector-set! neighbors (+ m 1) (vertex-y n1))
                (f32vector-set! neighbors (+ m 2) (vertex-z n1))
                (set! m (+ m 3))
                (f32vector-set! neighbors m (vertex-x n2))
                (f32vector-set! neighbors (+ m 1) (vertex-y n2))
                (f32vector-set! neighbors (+ m 2) (vertex-z n2))
                (set! m (+ m 3)))
              
              (for (i 0 (vector-length apparent-faces))
                   (let ((face (vector-ref apparent-faces i)))
                     (add-triangles~ face add-triangle)
                     (set-indice~ face i)))
              (assert (= n (f32vector-length vertices)))
              (values vertices neighbors)))))))
  
  
  ;;;
  ;;;; Lightmap
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (update-lightmap)
    (fill-faces-lightmap faces))
  
  
  (method (fill-faces-lightmap faces)
    (let ((zone (current-zone)))
      (when (and faces (or (not lightmap-uptodate?)
                           @temporary
                           (and (get-update-lightmaps?~ zone)
                                (not lightmap-baked?))))
        (let ((world (current-world)))
          (let ((update? (get-update-lightmaps?~ zone)))
            (fill-lightmap (prepare-lightmap faces))
            (set! lightmap-baked? update?)
            (set! lightmap-uptodate? #t))))))
  
  
  (method (fill-lightmap lightmap)
    (if (not lightmap)
        (free-lightmap~ mesh)
      (allocate-lightmap~ mesh)
      (set-data~ (get-lightmap-buffer~ mesh) lightmap 3)))
  
  
  (method protected virtual (prepare-lightmap faces)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((update? (get-update-lightmaps?~ zone))
            (shadows? (get-shadowmaps?~ world))
            (edition? (get-edition?~ world)))
        (let ((triangles-count 0)
              (triangle-floats (* 3 3)))
          (for (i 0 (vector-length faces))
               (let ((face (vector-ref faces i)))
                 (increase! triangles-count (triangle-count~ face))))
          (let (@temporary (lights (collect-static-lights~ zone))
                (f32 <f32vector> (make-f32vector (* triangles-count triangle-floats) 0.)))
            (define (reachable? orig dir dist)
              (not (ray-closest-polygon~ world orig dir (- dist .1) filter: #f ignore-players?: #t)))
            
            @temporary
            (when update?
              (for-each (lambda (light <Light>)
                          (let ((pos (get-position~ light))
                                (diffuse (get-diffuse-color~ light))
                                (constant-attenuation (get-constant-attenuation~ light))
                                (linear-attenuation (get-linear-attenuation~ light))
                                (quadratic-attenuation (get-quadratic-attenuation~ light)))
                            (for (i 0 (vector-length faces))
                                 (let ((face (vector-ref faces i)))
                                   (let ((center-dir (vertex-& (get-center~ (get-polygon~ face)) pos)))
                                     (let ((center-dist (sqrt (f32-ref (dot-product& center-dir center-dir))))
                                           (center-L (vertex-normalize& center-dir)))
                                       (when (or (not edition?)
                                                 (and (< center-dist 100.)
                                                      (or (not shadows?) (reachable? pos center-L (- center-dist 5.)))))
                                         (for-each (lambda (triangle <Triangle>)
                                                     (let ((normal (get-normal~ triangle))
                                                           (index <fx> (* (get-indice~ triangle) triangle-floats)))
                                                       (define (augment-lighting v <f32vector> index <fx>)
                                                         (define (add-dye! dye <f32vector> factor <fl>)
                                                           (f32vector-set! f32 index (+ (f32vector-ref f32 index) (* (dye-red dye) factor)))
                                                           (f32vector-set! f32 (+ index 1) (+ (f32vector-ref f32 (+ index 1)) (* (dye-green dye) factor)))
                                                           (f32vector-set! f32 (+ index 2) (+ (f32vector-ref f32 (+ index 2)) (* (dye-blue dye) factor))))
                                                         
                                                         (let ((dir (vertex-& v pos)))
                                                           (let ((dist-square (f32-ref (dot-product& dir dir))))
                                                             (let ((dist (sqrt dist-square))
                                                                   (L (vertex-normalize& dir)))
                                                               (let ((lambert (- (f32-ref (dot-product& normal L)))))
                                                                 (when (> lambert 0.)
                                                                   (when (or edition? (not shadows?) (reachable? pos L dist))
                                                                     (let ((atttenuation-term (+ constant-attenuation (* linear-attenuation dist) (* quadratic-attenuation dist-square))))
                                                                       (let ((attenuation (/ 1. atttenuation-term)))
                                                                         (let ((factor (* lambert attenuation)))
                                                                           (add-dye! diffuse factor)))))))))))
                                                       
                                                       (augment-lighting (get-v1~ triangle) index)
                                                       (augment-lighting (get-v2~ triangle) (+ index 3))
                                                       (augment-lighting (get-v3~ triangle) (+ index 6))))
                                                   (get-triangles~ face)))))))))
                        lights))
            f32)))))
  
  
  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Faces
  ;;;
  
  
  (method (collect-apparent-faces)
    (tiles-apparent-faces tiles))
  
  
  (method (tiles-apparent-faces tiles)
    (when (not-null? tiles)
      (let ((table (make-table test: vertex=? hash: vertex-hash)))
        (for-each (lambda (tile)
                    (if (is-not? tile Block)
                        (for-each (lambda (face)
                                    (table-set! table (get-center~ (get-polygon~ face)) face))
                                  (element-faces~ tile))
                      (for-each (lambda (face)
                                  (let ((center (get-center~ (get-polygon~ face))))
                                    (if (table-ref table center #f)
                                        (table-clear table center)
                                      (table-set! table center face))))
                                (element-faces~ tile))))
                  tiles)
        (let ((faces (make-vector (table-length table)))
              (n 0))
          (iterate-table table
            (lambda (center face)
              (vector-set! faces n face)
              (increase! n)))
          faces))))
  
  
  ;;;
  ;;;; Entities
  ;;;
  
  
  (method (draw-entities)
    (let ((me (current-me)))
      (for-each (lambda (element)
                  (unless (or (eq? element me) (not (get-visible?~ element)))
                    (draw~ element)))
                entities)))))
