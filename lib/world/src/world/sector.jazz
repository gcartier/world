;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Sectors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.sector jazz


(import (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.camera)
        (world.configure)
        (world.expanse)
        (world.face)
        (world.geometry)
        (world.homogeneous)
        (world.index)
        (world.mesh)
        (world.profiling)
        (world.queue)
        (world.section)
        (world.support)
        (world.syntax (phase syntax))
        (world.task))


(proclaim (warn optimizations))


;;;
;;;; Thread
;;;


(definition protected generate-queue <Priorities-Queue>
  (new Priorities-Queue 3 65536))


(definition public (push-content sector priority)
  (push~ generate-queue sector priority))

(definition public (pop-content)
  (pop~ generate-queue +infinity))

(definition public (reset-content)
  (reset~ generate-queue))

(definition public (trim-content priority) <fx>
  (trim~ generate-queue priority))


(definition protected (stop-generate)
  (push-content #f 0))


(definition protected (generate-task task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread~ (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping?~ task)
                (if current-advise
                    (with-task-mutex
                      (lambda ()
                        (generate-visual~ zone sector)))
                  (generate-visual~ zone sector)))
              (iter))))))))


@generate-tasks
(definition protected (generate-task2 task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread~ (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping?~ task)
                (if current-advise
                    (with-task-mutex
                      (lambda ()
                        (generate-visual2~ zone sector)))
                  (generate-visual2~ zone sector)))
              (iter))))))))


@generate-tasks
(definition protected (generate-task3 task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread~ (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping?~ task)
                (if current-advise
                    (with-task-mutex
                      (lambda ()
                        (generate-visual3~ zone sector)))
                  (generate-visual3~ zone sector)))
              (iter))))))))


@generate-tasks
(definition protected (generate-task4 task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread~ (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping?~ task)
                (if current-advise
                    (with-task-mutex
                      (lambda ()
                        (generate-visual4~ zone sector)))
                  (generate-visual4~ zone sector)))
              (iter))))))))


@generate-tasks
(definition protected (generate-task5 task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread~ (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (unless (stopping?~ task)
                (if current-advise
                    (with-task-mutex
                      (lambda ()
                        (generate-visual5~ zone sector)))
                  (generate-visual5~ zone sector)))
              (iter))))))))


;;;
;;;; Sector
;;;


(class Sector extends Object
  
  
  (slot index              <index>                         getter generate)
  (slot center             <vertex>                        getter generate)
  (slot expanse            <Expanse>                       getter generate)
  (slot section            <World-Section+> initialize #f  accessors generate)
  (slot texture-elements   <list>           initialize '() accessors generate)
  (slot mesh               <Mesh+>          initialize #f  getter generate)
  (slot material-mesh      <Mesh+>          initialize #f  getter generate)
  (slot other-meshes       <vector+>        initialize #f  accessors generate)
  (slot categorized-mesh   <Mesh+>          initialize #f  accessors generate)
  (slot visual-uptodate?   <bool>           initialize #f  accessors generate)
  (slot visual-revision    <fx>             initialize -1  accessors generate)
  (slot visual-generating? <bool>           initialize #f  accessors generate)
  
  
  (method override (initialize index center expanse)
    (set! index~self index)
    (set! center~self center)
    (set! expanse~self expanse))
  
  
  (method override (destroy)
    (nextmethod)
    (free))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}, {a}, {a}" (index-x index) (index-y index) (index-z index)))))
  
  
  (method (get-position&) <vertex>
    (let ((sector-x <fx> (index-x index))
          (sector-y <fx> (index-y index))
          (sector-z <fx> (index-z index)))
      (vertex& (* (cast <fl> sector-x) 16.)
               (* (cast <fl> sector-y) 16.)
               (* (cast <fl> sector-z) 16.))))
  
  
  (method (setup-mesh)
    (when (not mesh)
      (set! mesh (new Mesh material: (get-block-opaque~ (current-world))))))
  
  
  (method (setup-material-mesh)
    (when (not material-mesh)
      (set! material-mesh (new Mesh material: (get-material-opaque~ (current-world))))))
  
  
  (method (setup-other-meshes meshes)
    (set! other-meshes meshes))
  
  
  (method (setup-categorized-mesh mesh)
    (set! categorized-mesh mesh))
  
  
  (method (free)
    (free-section)
    (free-texture-elements)
    (free-mesh))
  
  
  (method (free-section)
    (set! section #f))
  
  
  (method (free-texture-elements)
    (for-each close~ texture-elements))
  
  
  (method (free-mesh)
    (when mesh
      (free-resources~ mesh)
      (set! mesh #f))
    (free-material-mesh)
    (when other-meshes
      (loop (for mesh <Mesh> in-vector other-meshes)
            (free-resources~ mesh))
      (set! other-meshes #f))
    (when categorized-mesh
      (free-resources~ categorized-mesh)
      (set! categorized-mesh #f)))
  
  
  (method (free-material-mesh)
    (when material-mesh
      (free-resources~ material-mesh)
      (set! material-mesh #f)))
  
  
  (method public (empty?)
    (and (not mesh)
         (not material-mesh)
         (not other-meshes)))
  
  
  ;;;
  ;;;; Visual
  ;;;
  
  
  (method (update-visual)
    (let ((world (current-world))
          (zone (current-zone)))
      (define (sector-priority) <fx>
        (let ((camera (current-camera)))
          (let ((pos (get-position~ camera))
                (sight (get-sight~ camera)))
            (cond ((< (vertex-distance& pos center) generate-near)
                   0)
                  ((<= (ray-point-horizontal-distance& pos sight center) generate-spread)
                   1)
                  (else
                   2)))))
      
      (when (and (not visual-generating?)
                 (or (not visual-uptodate?)
                     (< visual-revision (get-revision~ (get-generator~ zone)))))
        (let ((priority (sector-priority))
              (top-queued (top-priority~ generate-queue)))
          (when (or (not top-queued) (<= priority top-queued))
            (set! visual-generating? #t)
            (increase-sectors-generating~ zone 1)
            (push-content self priority))))))
  
  
  ;;;
  ;;;; Vertices
  ;;;
  
  
  (method (prepare-vertices/neighbors apparent-faces)
    (if (not apparent-faces)
        (values #f #f)
      (let ((triangles-count <fx> 0))
        (for-each (lambda (face <Face>)
                    (increase! triangles-count (triangle-count~ face)))
                  apparent-faces)
        (let ((vertices (make-f32vector (* triangles-count triangle-floats)))
              (neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))
          (let ((n <fx> 0)
                (m <fx> 0))
            (define (add-triangle v1 n1 s1 t1 b1 v2 n2 s2 t2 b2 v3 n3 s3 t3 b3 uv tdepth)
              (add-vertex v1) (add-normal n1) (add-texture s1 t1 uv tdepth) (add-bone b1) (add-neighbors 0. v2 v3)
              (add-vertex v2) (add-normal n2) (add-texture s2 t2 uv tdepth) (add-bone b2) (add-neighbors 1. v1 v3)
              (add-vertex v3) (add-normal n3) (add-texture s3 t3 uv tdepth) (add-bone b3) (add-neighbors 2. v1 v2))
            
            (define (add-vertex vert <vertex>)
              (f32vector-set! vertices n (vertex-x vert))
              (f32vector-set! vertices (+ n 1) (vertex-y vert))
              (f32vector-set! vertices (+ n 2) (vertex-z vert))
              (set! n (+ n 3)))
            
            (define (add-normal normal <vertex>)
              (f32vector-set! vertices n (vertex-x normal))
              (f32vector-set! vertices (+ n 1) (vertex-y normal))
              (f32vector-set! vertices (+ n 2) (vertex-z normal))
              (set! n (+ n 3)))
            
            (define (add-texture s <fx> t <fx> uv <f32vector> tdepth <fl>)
              (f32vector-set! vertices n (f32vector-ref uv s))
              (f32vector-set! vertices (+ n 1) (f32vector-ref uv t))
              (f32vector-set! vertices (+ n 2) tdepth)
              (set! n (+ n 3)))
            
            (define (add-bone bone <fx>)
              (f32vector-set! vertices n (cast <fl> bone))
              (set! n (+ n 1)))
            
            (define (add-neighbors rank <fl> n1 <vertex> n2 <vertex>)
              (f32vector-set! neighbors m rank)
              (set! m (+ m 1))
              (f32vector-set! neighbors m (vertex-x n1))
              (f32vector-set! neighbors (+ m 1) (vertex-y n1))
              (f32vector-set! neighbors (+ m 2) (vertex-z n1))
              (set! m (+ m 3))
              (f32vector-set! neighbors m (vertex-x n2))
              (f32vector-set! neighbors (+ m 1) (vertex-y n2))
              (f32vector-set! neighbors (+ m 2) (vertex-z n2))
              (set! m (+ m 3)))
            
            (loop (for face <Face> in apparent-faces)
                  (for i from 0)
                  (do (add-triangles~ face add-triangle)
                      (set-indice~ face i)))
            (assert (= n (f32vector-length vertices)))
            (values vertices neighbors))))))
  
  
  (method (fill-vertices/neighbors mesh <Mesh> triangles <fx+> vertices <f32vector+> neighbors <f32vector+>)
    (if (not vertices)
        (begin
          (free-vertices~ mesh)
          (free-neighbors~ mesh))
      (allocate-vertices~ mesh)
      (set-data~ (get-vertices-buffer~ mesh) vertices (if triangles (* triangles triangle-floats) (f32vector-length vertices)) vertex-floats)
      (allocate-neighbors~ mesh)
      (set-data~ (get-neighbors-buffer~ mesh) neighbors (if triangles (* triangles triangle-neighbors-floats) (f32vector-length (allege neighbors))) neighbors-floats)))
  
  
  ;;;
  ;;;; Lightmap
  ;;;
  
  
  (method (prepare-lightmap faces)
    (let ((triangles-count <fx> 0))
      (for-each (lambda (face <Face>)
                  (increase! triangles-count (triangle-count~ face)))
                faces)
      (make-f32vector (* triangles-count triangle-lightmap-floats) 0.)))
  
  
  (method (fill-lightmap mesh <Mesh> triangles <fx+> lightmap <f32vector+>)
    (if (not lightmap)
        (free-lightmap~ mesh)
      (allocate-lightmap~ mesh)
      (set-data~ (get-lightmap-buffer~ mesh) lightmap (if triangles (* triangles triangle-lightmap-floats) (f32vector-length lightmap)) lightmap-floats)
      (when debug-lightmap?
        (set-lightmap-data~ mesh lightmap))))))
