;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Sectors
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.sector jazz


(import (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.block)
        (world.camera)
        (world.configure)
        (world.face)
        (world.geometry)
        (world.homogeneous)
        (world.material)
        (world.mesh)
        (world.queue)
        (world.renderers)
        (world.section)
        (world.support)
        (world.syntax (phase syntax))
        (world.task))


(proclaim (warn optimizations))


;;;
;;;; Thread
;;;


(definition protected generate-queue <Priorities-Queue>
  (new Priorities-Queue 3 65536))


(definition public (push-content sector priority)
  (push~ generate-queue sector priority))

(definition public (pop-content)
  (pop~ generate-queue +infinity))

(definition public (reset-content)
  (reset~ generate-queue))

(definition public (trim-content priority) <fx>
  (trim~ generate-queue priority))


(definition protected (stop-generate)
  (push-content #f 0))


(definition protected (generate-task task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone)))
    (with-task task
      (lambda (exit)
        (set-generate-thread~ (current-zone) (current-thread))
        (let (iter)
          (let ((sector (pop-content)))
            (if (not sector)
                (continuation-return exit #f)
              (trace-task generate ".")
              (site (generate on?: #t)
                (generate-visual~ zone sector))
              (iter))))))))


;;;
;;;; Sector
;;;


(definition current-content-revision <fx>
  0)

(definition public (get-current-content-revision) <fx>
  current-content-revision)

(definition public (increase-current-content-revision)
  (increase! current-content-revision))


(class Sector extends Object
  
  
  (slot index               <vector>                   getter generate)
  (slot center              <f64vector>                getter generate)
  (slot section             <World-Section+>           accessors generate)
  (slot entities            <list>                     accessors generate)
  (slot texture-elements    <list>                     accessors generate)
  (slot faces               <list+>                    accessors generate)
  (slot other-faces         <table+>                   accessors generate)
  (slot mesh                <Mesh+>      initialize #f getter generate)
  ;; to be unified with mesh
  (slot voxel-mesh          <Mesh+>      initialize #f getter generate)
  (slot other-meshes        <table+>     initialize #f accessors generate)
  (slot categorized-meshes  <table+>     initialize #f accessors generate)
  (slot queued?             <bool>       initialize #f accessors generate)
  (slot physical-uptodate?  <bool>       initialize #f accessors generate)
  (slot content-uptodate?   <bool>       initialize #f accessors generate)
  (slot content-revision    <fx>         initialize 0  accessors generate)
  (slot vertices-uptodate?  <bool>       initialize #f accessors generate)
  (slot lightmap-uptodate?  <bool>       initialize #f accessors generate)
  (slot generating?         <bool>       initialize #f accessors generate)
  
  
  (method override (initialize index center)
    (set! index~self index)
    (set! center~self center)
    (set! section~self #f)
    (set! entities~self '())
    (set! texture-elements~self '())
    (set! faces~self #f)
    (set! other-faces~self #f))
  
  
  (method override (destroy)
    (nextmethod)
    (free-texture-elements)
    (free-mesh)
    (when section
      (refcount-decrease~ section)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((entities (length entities)))
          (format output "{a}, {a}, {a} with {a} entities" (vector-ref index 0) (vector-ref index 1) (vector-ref index 2) entities)))))
  
  
  (method (free-texture-elements)
    (for-each close~ texture-elements))
  
  
  (method (setup-mesh)
    (when (not mesh)
      (set! mesh (new Mesh material: (get-block-opaque~ (current-world))))))
  
  
  (method (setup-voxel-mesh)
    (when (not voxel-mesh)
      (set! voxel-mesh (new Mesh material: (get-block-opaque~ (current-world))))))
  
  
  (method (setup-other-meshes)
    (when (not other-meshes)
      (set! other-meshes (make-table test: eq?))))
  
  
  (method (setup-categorized-meshes)
    (when (not categorized-meshes)
      (set! categorized-meshes (make-table test: eq?))))
  
  
  (method (iterate-meshes proc)
    (when mesh
      (proc mesh))
    (when voxel-mesh
      (proc voxel-mesh))
    (when other-meshes
      (iterate-table other-meshes
        (lambda (material mesh)
          (proc mesh)))))
  
  
  (method (free-mesh)
    (when mesh
      (free-resources~ mesh)
      (set! mesh #f))
    (when voxel-mesh
      (free-resources~ voxel-mesh)
      (set! voxel-mesh #f))
    (when other-meshes
      (iterate-table other-meshes
        (lambda (material mesh <Mesh>)
          (free-resources~ mesh)))
      (set! other-meshes #f))
    (when categorized-meshes
      (iterate-table categorized-meshes
        (lambda (material mesh <Mesh>)
          (free-resources~ mesh)))
      (set! categorized-meshes #f)))
  
  
  (method public (empty?)
    (and (not mesh)
         (not voxel-mesh)
         (not other-meshes)
         (null? entities)))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (update)
    (update-content)
    (update-vertices)
    (update-lightmaps))
  
  
  ;;;
  ;;;; Physical
  ;;;
  
  
  (method (update-physical)
    (when (not physical-uptodate?)
      (site (generate-physical on?: #f)
        (let ((zone (current-zone)))
          (generate-physical~ zone self)))
      (set! physical-uptodate? #t)))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method (update-content)
    (let ((world (current-world))
          (zone (current-zone)))
      (define (sector-priority) <fx>
        (let ((camera (current-camera)))
          (let ((pos (get-position~ camera))
                (sight (get-sight~ camera)))
            (cond ((< (f64-ref (vertex-distance& pos center)) generate-near)
                   0)
                  ((<= (ray-point-horizontal-distance pos sight center) generate-spread)
                   1)
                  (else
                   2)))))
      
      (when (and (not generating?)
                 (or (not content-uptodate?)
                     (< content-revision current-content-revision)))
        (let ((priority (sector-priority))
              (top-queued (top-priority~ generate-queue)))
          (when (or (not top-queued) (<= priority top-queued))
            (set! generating? #t)
            (increase-sectors-generating~ zone 1)
            (push-content self priority))))))
  
  
  ;;;
  ;;;; Mesh
  ;;;
  
  
  (method (install-mesh mesh <Mesh>)
    (set! mesh~self mesh))
  
  
  (method (install-other-mesh material <Material> mesh <Mesh>)
    (setup-other-meshes)
    (allege other-meshes
      (table-set! other-meshes material mesh)))
  
  
  ;;;
  ;;;; Vertices
  ;;;
  
  
  (method (update-vertices)
    (when (not vertices-uptodate?)
      (set! vertices-uptodate? #t)))
  
  
  (method (fill-faces-vertices mesh <Mesh> apparent-faces)
    (receive (vertices neighbors) (prepare-vertices/neighbors apparent-faces)
      (fill-vertices/neighbors mesh #f vertices neighbors)))
  
  
  (method (fill-vertices/neighbors mesh <Mesh> triangles <fx+> vertices <f32vector+> neighbors <f32vector+>)
    (if (not vertices)
        (begin
          (free-vertices~ mesh)
          (free-neighbors~ mesh))
      (allocate-vertices~ mesh)
      (set-data~ (get-vertices-buffer~ mesh) vertices (if triangles (* triangles triangle-floats) (f32vector-length vertices)) vertex-floats)
      (allocate-neighbors~ mesh)
      (set-data~ (get-neighbors-buffer~ mesh) neighbors (if triangles (* triangles triangle-neighbors-floats) (f32vector-length (allege neighbors))) neighbors-floats)))
  
  
  (method (prepare-vertices/neighbors apparent-faces)
    (if (not apparent-faces)
        (values #f #f)
      (let ((triangles-count <fx> 0))
        (for-each (lambda (face <Face>)
                    (increase! triangles-count (triangle-count~ face)))
                  apparent-faces)
        (let ((vertices (make-f32vector (* triangles-count triangle-floats)))
              (neighbors (make-f32vector (* triangles-count triangle-neighbors-floats))))
          (let ((n <fx> 0)
                (m <fx> 0))
            (define (add-triangle v1 n1 s1 t1 b1 v2 n2 s2 t2 b2 v3 n3 s3 t3 b3 uv tdepth)
              (add-vertex v1) (add-normal n1) (add-texture s1 t1 uv tdepth) (add-bone b1) (add-neighbors 0. v2 v3)
              (add-vertex v2) (add-normal n2) (add-texture s2 t2 uv tdepth) (add-bone b2) (add-neighbors 1. v1 v3)
              (add-vertex v3) (add-normal n3) (add-texture s3 t3 uv tdepth) (add-bone b3) (add-neighbors 2. v1 v2))
            
            (define (add-vertex vert <f64vector>)
              (f32vector-set! vertices n (vertex-x vert))
              (f32vector-set! vertices (+ n 1) (vertex-y vert))
              (f32vector-set! vertices (+ n 2) (vertex-z vert))
              (set! n (+ n 3)))
            
            (define (add-normal normal <f64vector>)
              (f32vector-set! vertices n (vertex-x normal))
              (f32vector-set! vertices (+ n 1) (vertex-y normal))
              (f32vector-set! vertices (+ n 2) (vertex-z normal))
              (set! n (+ n 3)))
            
            (define (add-texture s <fx> t <fx> uv <f32vector> tdepth <fl>)
              (f32vector-set! vertices n (f32vector-ref uv s))
              (f32vector-set! vertices (+ n 1) (f32vector-ref uv t))
              (f32vector-set! vertices (+ n 2) tdepth)
              (set! n (+ n 3)))
            
            (define (add-bone bone <fx>)
              (f32vector-set! vertices n (cast <fl> bone))
              (set! n (+ n 1)))
            
            (define (add-neighbors rank <fl> n1 <f64vector> n2 <f64vector>)
              (f32vector-set! neighbors m rank)
              (set! m (+ m 1))
              (f32vector-set! neighbors m (vertex-x n1))
              (f32vector-set! neighbors (+ m 1) (vertex-y n1))
              (f32vector-set! neighbors (+ m 2) (vertex-z n1))
              (set! m (+ m 3))
              (f32vector-set! neighbors m (vertex-x n2))
              (f32vector-set! neighbors (+ m 1) (vertex-y n2))
              (f32vector-set! neighbors (+ m 2) (vertex-z n2))
              (set! m (+ m 3)))
            
            (loop (for face <Face> in apparent-faces)
                  (for i from 0)
                  (do (add-triangles~ face add-triangle)
                      (set-indice~ face i)))
            (assert (= n (f32vector-length vertices)))
            (values vertices neighbors))))))
  
  
  ;;;
  ;;;; Lightmap
  ;;;
  
  
  (method (update-lightmaps)
    (when (not lightmap-uptodate?)
      (when (and mesh faces)
        (update-lightmap mesh faces)
        (set! faces #f))
      (when (and other-meshes other-faces)
        (iterate-table other-meshes
          (lambda (material mesh)
            (let ((faces (table-ref other-faces material)))
              (update-lightmap mesh faces))))
        (set! other-faces #f))
      (set! lightmap-uptodate? #t)))
  
  
  (method (update-lightmap mesh <Mesh> faces)
    (fill-faces-lightmap mesh faces))
  
  
  (method (fill-faces-lightmap mesh <Mesh> faces)
    (fill-lightmap mesh #f (prepare-lightmap faces)))
  
  
  (method (fill-lightmap mesh <Mesh> triangles <fx+> lightmap <f32vector+>)
    (if (not lightmap)
        (free-lightmap~ mesh)
      (allocate-lightmap~ mesh)
      (set-data~ (get-lightmap-buffer~ mesh) lightmap (if triangles (* triangles triangle-lightmap-floats) (f32vector-length lightmap)) lightmap-floats)
      (when debug-lightmap?
        (set-lightmap-data~ mesh lightmap))))
  
  
  (method protected virtual (prepare-lightmap faces)
    (let ((triangles-count <fx> 0))
      (for-each (lambda (face <Face>)
                  (increase! triangles-count (triangle-count~ face)))
                faces)
      (make-f32vector (* triangles-count triangle-lightmap-floats) 0.)))))
