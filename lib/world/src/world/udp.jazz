;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.udp jazz


(import (jazz.geometry)
        (jazz.io)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.binary)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.math)
        (world.record (phase syntax))
        (world.ring)
        (world.settings)
        (world.simulate)
        (world.task)
        (world.time))


(definition protected udp-connect <fx>
  0)

(definition protected udp-connected <fx>
  1)

(definition protected udp-heartbeat <fx>
  2)

(definition protected udp-ack <fx>
  3)

(definition protected udp-nack <fx>
  4)

(definition protected udp-audio <fx>
  5)

(definition protected udp-video <fx>
  6)

(definition protected udp-alive <fx>
  7)

(definition protected udp-alive-ack <fx>
  8)

(definition protected udp-profile-pulse <fx>
  9)

(definition protected udp-profile-ack <fx>
  10)

(definition protected udp-profile-media <fx>
  11)

(definition protected udp-state <fx>
  12)


(definition udp-names
  #(connect connected heartbeat ack nack audio video alive alive-ack profile-pulse profile-ack profile-media))

(definition protected (udp-name kind)
  (vector-ref udp-names kind))


(definition protected udp-purge-gap
  1.)

(definition protected udp-purge-seek
  2.)


(definition protected udp-throttle-gap
  1.)

(definition protected udp-throttle-noack
  2.)

(definition protected udp-throttle-restore
  3.)


;; MTU - IP HEADER - UDP HEADER
;; 1500 - 20 (60) - 8 = 1472 (1432)
(definition protected udp-datagram-max <fx>
  1432)


(definition protected udp-sender-retain-window <fl>
  (world-setting 'world.udp-sender-retain-window 1.5))

(definition protected udp-server-retain-window <fl>
  (world-setting 'world.udp-server-retain-window 1.5))

(definition protected udp-retain-size <fx>
  256)

(definition protected udp-retain-max-size <fx>
  8192)


(definition protected udp-audio-present <fl>
  (world-setting 'world.udp-audio-present 0.))

;; gstreamer's audio buffer time
(definition protected udp-audio-buffer <fl>
  (world-setting 'world.udp-audio-buffer .2))

;; this value should be consistent with
;; gstreamer's audio sink buffer-time and
;; lets give it a slightly smaller value
(definition protected udp-audio-giveup <fl>
  (world-setting 'world.udp-audio-giveup (- udp-audio-buffer .01)))


(definition protected udp-video-present <fl>
  (world-setting 'world.udp-video-present (+ udp-audio-present udp-audio-buffer)))

(definition protected udp-video-late <fl>
  (world-setting 'world.udp-video-late .05))

(definition protected udp-video-giveup <fl>
  (world-setting 'world.udp-video-giveup .5))


(definition protected udp-process-size <fx>
  256)

(definition protected udp-process-max-size <fx>
  4096)


;; udp-audio-buffer
(register-live-setting 'world.udp-audio-buffer
  (lambda (value)
    (let ((value (if (unspecified? value) .2 value)))
      (set! udp-audio-buffer value)
      (set! udp-audio-giveup (- udp-audio-buffer .01))
      (set! udp-video-present (+ udp-audio-present udp-audio-buffer)))))


;; udp-audio-present
(register-live-setting 'world.udp-audio-present
  (lambda (value)
    (let ((value (if (unspecified? value) .2 value)))
      (set! udp-audio-present value)
      (set! udp-video-present (+ udp-audio-present udp-audio-buffer)))))


(definition protected udp-max-gap <fx>
  32)

(definition protected udp-state-rate <fl>
  2.)

(definition protected udp-state-period <fl>
  (/ 1. udp-state-rate))

(definition protected udp-heartbeat-rate <fl>
  10.)

(definition protected udp-heartbeat-period <fl>
  (/ 1. udp-heartbeat-rate))

(definition protected udp-throttle <fl>
  1.)


(definition protected (setup-udp-port-buffers port)
  (cond-expand
    (windows
     (let ((size (udp-socket-receive-buffer-size port)))
       (when (< size 65536)
         (udp-socket-receive-buffer-size-set! port 65536))))
    (else))
  (cond-expand
    (windows
     (let ((size (udp-socket-send-buffer-size port)))
       (when (< size 65536)
         (udp-socket-send-buffer-size-set! port 65536))))
    ;; mac os x having only a 8192 send buffer doesn't seem
    ;; to be a problem...
    (else)))


(definition protected udp-record-read/write?
  (world-setting 'world.udp-record-read/write? #f))

(definition protected udp-record-src/sink?
  (world-setting 'world.udp-record-src/sink? #f))


(definition protected udp-media-off
  #u8(111 102 102))


(definition protected (present-media-kind kind)
  (if (= kind udp-audio)
      'AUDIO
    'VIDEO))


(definition protected (bytes->mbps bytes <fl>) <fl>
  (/ bytes 131072.))

(definition protected (mbps->bytes mbps <fl>) <fx>
  (fxround (* mbps 131072.)))


(definition public inline (evolutionary-udp-time    evolution <Evolution> n <fx>) <fl> (evolutionary-time  evolution n))
(definition public inline (evolutionary-udp-id      evolution <Evolution> n <fx>) <fl> (evolutionary-id    evolution n))
(definition public inline (evolutionary-udp-channel evolution <Evolution> n <fx>) <fl> (evolutionary-data1 evolution n))
(definition public inline (evolutionary-udp-origin  evolution <Evolution> n <fx>) <fl> (evolutionary-data2 evolution n))
(definition public inline (evolutionary-udp-kind    evolution <Evolution> n <fx>) <fl> (evolutionary-data3 evolution n))
(definition public inline (evolutionary-udp-data1   evolution <Evolution> n <fx>) <fl> (evolutionary-data4 evolution n))
(definition public inline (evolutionary-udp-data2   evolution <Evolution> n <fx>) <fl> (evolutionary-data5 evolution n))
(definition public inline (evolutionary-udp-data3   evolution <Evolution> n <fx>) <fl> (evolutionary-data6 evolution n))
(definition public inline (evolutionary-udp-data4   evolution <Evolution> n <fx>) <fl> (evolutionary-data7 evolution n))
(definition public inline (evolutionary-udp-data5   evolution <Evolution> n <fx>) <fl> (evolutionary-data8 evolution n))
(definition public inline (evolutionary-udp-data6   evolution <Evolution> n <fx>) <fl> (evolutionary-data9 evolution n))

(definition public inline (evolutionary-udp-sequence evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data1 evolution n)))
(definition public inline (evolutionary-udp-frame    evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data2 evolution n)))


(definition public (evolutionary-udp-receive-ack-heartbeat-sent      evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-receive-ack-heartbeat-sequence  evolution <Evolution> n <fx>) (evolutionary-udp-data1 evolution n))
(definition public (evolutionary-udp-receive-ack-round-trip          evolution <Evolution> n <fx>) (evolutionary-udp-data2 evolution n))
(definition public (evolutionary-udp-receive-ack-ack-sent            evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))

(definition public (evolutionary-udp-traffic-rate-heartbeat-sequence evolution <Evolution> n <fx>) (evolutionary-udp-data1 evolution n))
(definition public (evolutionary-udp-traffic-rate-last-send-rate     evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-traffic-rate-last-receive-rate  evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))

(definition public (evolutionary-udp-update-time-now                 evolution <Evolution> n <fx>) (evolutionary-udp-data2 evolution n))
(definition public (evolutionary-udp-update-time-raw-latency         evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-update-time-timestamp           evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))
(definition public (evolutionary-udp-update-time-effective-latency   evolution <Evolution> n <fx>) (evolutionary-udp-data5 evolution n))

(definition public (evolutionary-udp-insert-packet-latency           evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-insert-packet-dts               evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))
(definition public (evolutionary-udp-insert-packet-base              evolution <Evolution> n <fx>) (evolutionary-udp-data5 evolution n))
(definition public (evolutionary-udp-insert-packet-raw-latency       evolution <Evolution> n <fx>) (evolutionary-udp-data6 evolution n))

(definition public (evolutionary-udp-play-frame-pts                  evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))
(definition public (evolutionary-udp-freeze-frame-pts                evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))


;; relies on 0 reserved for #f in next-literal-id
(definition protected server-no
  0)

(definition protected server-sender
  "Server")


(definition protected reconnect-marker
  123456.)

(definition protected no-connection-marker
  123456.)

(definition protected (barbara-keyframe-hack keyframe?)
  (if keyframe?
      123456.
    -1.))


;;;
;;;; Bailout
;;;


(definition protected bailouts
  (make-table test: equal?))


(definition bailout-prefixes
  '((register-bailout initialize handle-exception-filter handle-exception-filter initialize)
    (register-bailout #f handle-exception-filter handle-exception-filter calling-serving calling-server)
    (register-bailout calling-serving handle-exception-filter handle-exception-filter calling-serving calling-server)
    (register-bailout calling-serving handle-exception-filter handle-exception-filter calling-serving calling-processor)
    (register-bailout send-udp send-udp send-udp)
    (register-bailout #f #f send-udp)))


(definition (print-bailout name)
  (unless (eq? name 'udp-write)
    (let ((thread (current-thread)))
      (let ((thread-name (thread-name thread)))
        (assert thread-name
          (let ((stack (trim-stack (execution-stack identifiers?: #t depth: 10)))
                (mutexes (map mutex-name (thread-mutexes thread)))
                (task (let ((task (current-task))) (if task (get-name task) '$$$$$))))
            (terminal name thread-name '---> stack '>>> mutexes task)))))))


(definition (register-bailout name)
  (let ((thread (current-thread)))
    (let ((thread-name (thread-name thread)))
      (assert thread-name
        (let ((stack (trim-stack (execution-stack identifiers?: #t depth: 10)))
              (mutexes (map mutex-name (thread-mutexes thread)))
              (task (let ((task (current-task))) (if task (get-name task) '$$$$$))))
          (let ((signature (list name thread-name '---> stack '>>> mutexes task)))
            (table-set! bailouts signature (+ (table-ref bailouts signature 0) 1))))))))


(definition (trim-stack stack)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (prefix)
                  (when (and (>= (length stack) (length prefix))
                             (equal? (subseq stack 0 (length prefix)) prefix))
                    (continuation-return return (subseq stack (length prefix) (length stack)))))
                bailout-prefixes)
      stack)))


(definition protected bailout-target
  #f)

(definition protected (set-bailout-target target)
  (set! bailout-target target))

(definition protected (reset-bailout-target)
  (set! bailout-target #f))


(definition (trigger-bailout name)
  (let ((thread (current-thread)))
    (let ((thread-name (thread-name thread)))
      (assert thread-name
        (when (or (eq? bailout-target #t)
                  (eq? thread-name bailout-target))
          (set! bailout-target #t)
          (terminal 'bailout-point name)
          (throw-connection-broke "Bailing out"))))))


(definition protected (bailout-point name)
  @debug
  (print-bailout name)
  @debug
  (register-bailout name)
  @debug
  (trigger-bailout name))


;;;
;;;; Ring
;;;


(definition protected udp-ring-kind-retain
  0.)

(definition protected udp-ring-kind-process
  1.)

(definition protected udp-ring-kind-simulator
  2.)


(definition protected (udp-ring-overflow name kind)
  (lambda (ring data bumped-data)
    (record-event udp-id-ring-overflow
                  (fixnum->flonum (get-no ring))
                  (fixnum->flonum (get-origin ring))
                  (fixnum->flonum (get-media-kind ring))
                  (if (= kind udp-ring-kind-simulator)
                      -1.
                    (fixnum->flonum (get-sequence data)))
                  (fixnum->flonum (get-count ring))
                  kind
                  (fixnum->flonum (get-sequence bumped-data)))))


;;;
;;;; Read/Write
;;;


(definition protected (read-data port)
  (let ((data (read port)))
    (when udp-record-read/write?
      (with-record header
        (let ((sender (read-header-sender data))
              (media-kind (read-header-kind data)))
          (record-event udp-id-read-data
                        -1.
                        (fixnum->flonum sender)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        (fixnum->flonum (u8vector-length data))))))
    data))


(definition protected (write-data data port)
  ;; quick temporary hack to get back the safe behavior
  ;; of retrying-write until port being false is fixed
  (when port
    (write data port)
    (when udp-record-read/write?
      (with-record header
        (let ((sender (read-header-sender data))
              (media-kind (read-header-kind data)))
          (record-event udp-id-write-data
                        -1.
                        (fixnum->flonum sender)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        (fixnum->flonum (u8vector-length data))))))))


;;;
;;;; Tolerance
;;;


(definition protected retrying-grace <fl>
  10.)

(definition protected retrying-start
  #f)

(definition protected (set-retrying-start start)
  (set! retrying-start start))


(definition protected (send-udp data port)
  (if (not retrying-start)
      (safe-write data port)
    (let ((elapsed (- (current-seconds) retrying-start)))
      (if (< elapsed retrying-grace)
          (retrying-write data port)
        (set! retrying-start #f)
        (safe-write data port)))))


(definition protected (safe-write data port)
  (continuation-capture
    (lambda (exit)
      (with-exception-handler
        (lambda (exc)
          (continuation-graft exit
            (lambda ()
              (record-event udp-id-write-failure
                            -1.
                            -1.
                            -1.
                            -1.
                            -1.
                            -1.
                            -1.)
              (bailout (current-client) exc))))
        (lambda ()
          (bailout-point 'udp-write)
          (write-data data port))))))


;; retry every 1/100s for grace period of 10s
(definition protected (retrying-write data port)
  (declare (proper-tail-calls))
  (let (loop (n 0))
    (handle-exception-filter
      (lambda (exc)
        (< n 1000))
      (lambda (exc)
        (sleep .01)
        (if (< n 999)
            (loop (+ n 1))
          (record-event udp-id-write-failure
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.)
          (bailout (current-client) exc)
          exc))
      (lambda ()
        (bailout-point 'udp-write)
        (write-data data port)
        #f))))


;;;
;;;; Tier
;;;


(definition public (current-udp)
  (get-udp-tier (current-tier)))


(class UDP-Tier extends Object
  
  
  (slot send-streams  initialize #f getter generate)
  (slot send-channels initialize #f getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! send-streams (make-table))
    (set! send-channels (make-table))
    (register-snapshot-callback (~ snapshot-send-streams self)))
  
  
  (method package virtual (add-missed-media-packets self sender gap)
    )
  
  
  (method package virtual (send-nack self sender channel-no start end)
    )
  
  
  (method (snapshot-send-streams self)
    (let ((info (map (lambda (stream)
                       (list (get-sender stream)
                             (get-name stream)
                             (get-source-kind stream)))
                     (table-values send-streams))))
      (add-snapshot-property 'live.udp-send info)))
  
  
  (method package (register-send-stream self sender name stream-no source-kind video-level)
    (let ((stream (new UDP-Send-Stream sender name stream-no client-no source-kind video-level)))
      (table-set! send-streams stream-no stream)
      stream))
  
  
  (method public (find-send-stream self stream-no)
    (table-ref send-streams stream-no #f))
  
  
  (method public (locate-send-stream self predicate)
    (table-search (lambda (no stream)
                    (and (predicate stream)
                         stream))
                  send-streams))
  
  
  (method public (find-send-channel self channel-no)
    (table-ref send-channels channel-no #f))
  
  
  (method public (find-streaming self location)
    (table-search (lambda (no stream)
                    (let ((stream-location (get-location stream)))
                      (and stream-location
                           (filename=? location stream-location)
                           stream)))
                  send-streams))
  
  
  (method public (collect-streaming self)
    (let ((queue (new-queue)))
      (iterate-table send-channels
        (lambda (no channel)
          (when (get-stream? (get-src (get-pipeline channel)))
            (enqueue queue channel))))
      (queue-list queue)))
  
  
  (method protected (gather-replay-missing self missing)
    (let ((queue (new-queue)))
      (for-each (lambda (info)
                  (bind (channel-no . missing) info
                    (let ((channel (find-send-channel self channel-no)))
                      (when channel
                        (let ((ring (get-replay-ring channel)))
                          (when ring
                            (for-each (lambda (sequence)
                                        (let ((packet (locate-packet ring sequence)))
                                          (when packet
                                            (enqueue queue (get-data packet)))))
                                      missing)))))))
                missing)
      (queue-list queue))))


;;;
;;;; Stream
;;;


(definition protected next-stream-no <fx>
  0)

(definition protected (next-stream-no!) <fx>
  (prog1 next-stream-no
    (increase! next-stream-no)))


(definition protected (stream-video-level stream profile-level)
  (let ((stream-level (get-video-level stream)))
    (and stream-level
         (let (iter (level (min stream-level profile-level)))
           (cond ;; this will need to be revisited but if no compatible
                 ;; quality found use the stream level so everything works
                 ;; and for now this will also enable showcasing high quality
                 ((< level 0)
                  stream-level)
                 ((find-level stream level)
                  level)
                 (else
                  (iter (- level 1))))))))


(class UDP-Stream extends Object
  
  
  (slot sender         getter generate)
  (slot name           getter generate)
  (slot no             getter generate)
  (slot origin         getter generate)
  (slot source-kind    getter generate)
  (slot video-level    accessors generate)
  (slot channels       getter generate)
  (slot level-channels getter generate)
  
  
  (method override (initialize self sender name no origin source-kind video-level)
    (nextmethod self)
    (set! self.sender sender)
    (set! self.name name)
    (set! self.no no)
    (set! self.origin origin)
    (set! self.source-kind source-kind)
    (set! self.video-level video-level)
    (set! self.channels (make-table test: eqv?))
    (set! self.level-channels (make-vector 5 #f)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a} {a} {a}" sender name no origin source-kind video-level))))
  
  
  (method protected (add-child self channel)
    (table-set! channels (get-no channel) channel)
    (let ((level (get-level channel)))
      (when level
        (vector-set! level-channels level channel))))
  
  
  (method protected (play self)
    (iterate-table channels
      (lambda (no channel)
        (play channel))))
  
  
  (method protected (find-level self level)
    (vector-ref level-channels level))
  
  
  (method public (effective-name self)
    (if (eq? source-kind 'live)
        sender
      name)))


;;;
;;;; Send Stream
;;;


(class UDP-Send-Stream extends UDP-Stream
  
  
  (slot location    initialize #f accessors generate)
  (slot action-proc initialize #f accessors generate)
  
  
  (method protected (locate-audio-channel self)
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-audio)
                         channel))
                  channels))
  
  
  (method protected (locate-video-channel self)
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-video)
                         channel))
                  channels))
  
  
  (method protected (locate-level-channel self level)
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-video)
                         (= (get-level channel) level)
                         channel))
                  channels))
  
  
  (method protected (locate-screen-channel self)
    (table-search (lambda (no channel)
                    (and (eq? (get-source-kind channel) 'screen)
                         channel))
                  channels))
  
  
  (method protected (collect-video-channels self)
    (let ((queue (new-queue)))
      (iterate-table channels
        (lambda (no channel)
          (when (= (get-media-kind channel) udp-video)
            (enqueue queue channel))))
      (queue-list queue))))


;;;
;;;; Channel
;;;


(definition protected next-channel-no <fx>
  0)

(definition protected (next-channel-no!) <fx>
  (prog1 next-channel-no
    (increase! next-channel-no)))


(class UDP-Channel extends Object
  
  
  (slot stream      getter generate)
  (slot no          getter generate)
  (slot media-kind  getter generate)
  (slot source-kind getter generate)
  (slot level       getter generate)
  (slot resolution  accessors generate)
  (slot framerate   getter generate)
  (slot bitrate     getter generate)
  (slot codec       getter generate)
  (slot caps        accessors generate)
  (slot metadata    getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (nextmethod self)
    (set! self.stream stream)
    (set! self.no no)
    (set! self.media-kind media-kind)
    (set! self.source-kind source-kind)
    (set! self.level level)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.metadata metadata)
    (add-child stream self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (if (= media-kind udp-video)
            (format output "{a} {a} {a} {a} {a} {a} {a}" (get-sender stream) (get-name stream) no media-kind source-kind level resolution)
          (format output "{a} {a} {a} {a} {a}" (get-sender stream) (get-name stream) no media-kind source-kind))))))


(definition protected (streams-metadata streams)
  (map-table (lambda (no stream)
               (list
                 (get-sender stream)
                 (get-name stream)
                 (get-no stream)
                 (get-origin stream)
                 (get-source-kind stream)
                 (get-video-level stream)
                 (map-table (lambda (no channel)
                              (list
                                (get-no channel)
                                (get-media-kind channel)
                                (get-source-kind channel)
                                (get-level channel)
                                (get-resolution channel)
                                (get-framerate channel)
                                (get-bitrate channel)
                                (get-codec channel)
                                (get-caps channel)
                                (get-metadata channel)))
                            (get-channels stream))))
             streams))


(class UDP-Audio-Only-Channel-Hack extends UDP-Channel)


(definition public (determine-channel-name channel)
  (if (not channel)
      "Me"
    (let ((stream (get-stream channel)))
      (if (eq? (get-source-kind stream) 'live)
          (get-sender stream)
        (get-name stream)))))


;;;
;;;; Retain Channel
;;;


(class UDP-Retain-Channel extends UDP-Channel
  
  
  (slot retain-ring getter generate))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Retain-Channel
  
  
  (slot pipeline       accessors generate)
  (slot state          accessors generate)
  (slot action-proc    accessors generate)
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-dts       accessors generate)
  (slot last-pts       accessors generate)
  (slot last-reset     getter generate)
  (slot wait-keyframe? getter generate)
  (slot replay-ring    getter generate)
  (slot release-task   getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (nextmethod self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (set! self.pipeline #f)
    (set! self.state 'off)
    (set! self.action-proc #f)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-dts #f)
    (set! self.last-pts #f)
    (set! self.last-reset #f)
    (set! self.wait-keyframe? (= media-kind udp-video))
    (set! self.replay-ring (remember-ring media-kind source-kind level framerate))
    (set! self.retain-ring (new UDP-Ring self no (get-origin stream) media-kind source-kind udp-retain-size max-size: udp-retain-max-size overflow-proc: (udp-ring-overflow 'retain udp-ring-kind-retain) retain-window: udp-sender-retain-window))
    (unless (simulation?)
      (set! self.release-task (new Task 'udp-release (~ run-release self) priority: udp-priority))
      (start-task release-task)))
  
  
  (method override (destroy self)
    (when pipeline
      (release pipeline)
      (close pipeline))
    (terminate retain-ring)
    (thread-join! (get-thread release-task))
    (nextmethod self))
  
  
  (method protected (waiting-keyframe? self)
    wait-keyframe?)
  
  
  (method protected (wait-keyframe self)
    (when (= media-kind udp-video)
      (set! wait-keyframe? #t)))
  
  
  (method protected (got-keyframe self)
    (set! wait-keyframe? #f))
  
  
  (method protected (require-caps self)
    (require-caps (get-src pipeline)))
  
  
  (method (on? self)
    (eq? state 'on))
  
  
  (method (off? self)
    (eq? state 'off))
  
  
  (method (setup self)
    (when pipeline
      (setup pipeline)))
  
  
  (method (start self)
    (when pipeline
      (start pipeline)))
  
  
  (method (play self)
    (when pipeline
      (play pipeline)))
  
  
  (method (pause self)
    (when pipeline
      (pause pipeline)))
  
  
  (method (stop self)
    (when pipeline
      (stop pipeline)))
  
  
  (method (release self)
    (when pipeline
      (release pipeline)))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (remember-media self data)
    (when replay-ring
      (remember replay-ring data)))
  
  
  (method protected (retain-media self data)
    (insert retain-ring data udp-id-retain-packet))
  
  
  (method protected (send-media self buffer dts pts duration keyframe? send)
    (let ((off? (not buffer))
          (frame (next-frame-sequence! self))
          ;; give media off a sequential dts so it gets inserted correctly
          (dts (or dts (+ (or last-dts 0) 1)))
          ;; give media off a sequential pts so it gets inserted correctly
          (pts (or pts (+ (or last-pts 0) 1)))
          (duration (or duration 1))
          ;; udp-media-off is not really used for its content anymore
          ;; but it is still useful as an empty buffer ends the logic
          (buffer (or buffer udp-media-off)))
      (set! last-dts dts)
      (set! last-pts pts)
      (with-record media
        (let ((header-size (+ (calculate-media-size) udp-code-size))
              (payload-size (u8vector-length buffer)))
          (let ((max-content-size (- udp-datagram-max header-size)))
            (let ((total (fxceiling/ payload-size max-content-size)))
              (let (loop-part (part 0) (pos 0))
                (let ((remain (- payload-size pos)))
                  (when (> remain 0)
                    (let ((sequence (next-data-sequence! self))
                          (content-size (min remain max-content-size)))
                      (let ((size (+ header-size content-size)))
                        (let ((data (make-u8vector size)))
                          (write-header-kind data media-kind)
                          (write-header-sender data client-no)
                          (write-media-channel data no)
                          (write-media-sequence data sequence)
                          (write-media-frame data frame)
                          (write-media-part data part)
                          (write-media-total data total)
                          (write-media-dts data dts)
                          (write-media-pts data pts)
                          (write-media-duration data duration)
                          (write-media-subpayload data buffer pos content-size)
                          (write-media-keyframe? data keyframe?)
                          (write-media-off? data off?)
                          (write-media-resent data 0)
                          (write-udp-code data)
                          ;; quick hack to make media off more robust
                          (if off?
                              (loop (repeat 3)
                                    (send data))
                            (send data))
                          (record-event udp-id-create-packet
                                        (fixnum->flonum no)
                                        (fixnum->flonum client-no)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        (fixnum->flonum frame)
                                        (barbara-keyframe-hack keyframe?)
                                        (timestamp->flonum dts)
                                        (timestamp->flonum pts))
                          (record-event udp-id-create-info
                                        (fixnum->flonum no)
                                        (fixnum->flonum client-no)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        (fixnum->flonum part)
                                        (fixnum->flonum total)
                                        (timestamp->flonum duration))
                          (remember-media self data)
                          (retain-media self data)
                          (loop-part (+ part 1) (+ pos content-size))))))))))))))
  
  
  (method (reset-media self)
    (when pipeline
      (let ((src (get-src pipeline)))
        (when (and (resettable? src)
                   (playing? src))
          (let ((now (current-seconds)))
            (unless (and last-reset (< (- now last-reset) (reset-cooldown src)))
              (reset-media src self)
              (set! last-reset now)
              (record-event udp-id-reset-media
                            (fixnum->flonum no)
                            (fixnum->flonum client-no)
                            (fixnum->flonum media-kind)
                            -1.
                            -1.
                            -1.
                            -1.)))))))
  
  
  (method protected (run-release self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((packet (retain-wait retain-ring)))
            (if (eq? packet 'terminate)
                (continuation-return exit #f)
              (site udp-release
                (release-media self packet))
              (loop)))))))
  
  
  (method protected (release-media self packet)
    (let ((data (get-data packet))
          (origin (get-origin stream)))
      (if (not data)
          (let ((removed-sequence (get-sequence packet)))
            (record-event udp-id-giveup-packet
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum removed-sequence)
                          -1.
                          -1.
                          -1.))
        (with-record media
          (let ((sequence (read-media-sequence data))
                (frame (read-media-frame data))
                (dts (read-media-dts data)))
            (record-event udp-id-release-packet
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          -1.
                          (timestamp->flonum dts))))))))


;;;
;;;; Packet
;;;


(class UDP-Packet-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-dts object))
                              (serialize (get-pts object))
                              (serialize (get-duration object))
                              (serialize (get-sequence object))
                              (serialize (get-frame object))
                              (serialize (get-part object))
                              (serialize (get-total object))
                              (serialize (get-keyframe? object))
                              (serialize (get-off? object))
                              (serialize (get-data object)))))
  
  
  (method override (unmarshall-object self content)
    (bind-vector (dts pts duration sequence frame part total keyframe? off? data) content
      (allocate self
                (deserialize dts)
                (deserialize pts)
                (deserialize duration)
                (deserialize sequence)
                (deserialize frame)
                (deserialize part)
                (deserialize total)
                (deserialize keyframe?)
                (deserialize off?)
                (deserialize data)))))


(class UDP-Packet metaclass UDP-Packet-Class extends Object
  
  
  (slot dts            getter generate)
  (slot pts            getter generate)
  (slot duration       getter generate)
  (slot sequence  <fx> getter generate)
  (slot frame          getter generate)
  (slot part           getter generate)
  (slot total          getter generate)
  (slot keyframe?      getter generate)
  (slot off?           getter generate)
  (slot data           accessors generate)
  
  
  (method override (initialize self dts pts duration sequence frame part total keyframe? off? data)
    (nextmethod self)
    (set! self.dts dts)
    (set! self.pts pts)
    (set! self.duration duration)
    (set! self.sequence sequence)
    (set! self.frame frame)
    (set! self.part part)
    (set! self.total total)
    (set! self.keyframe? keyframe?)
    (set! self.off? off?)
    (set! self.data data))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" sequence)))))


;;;
;;;; Remember
;;;

;; temporary copy/paste of UDP-Ring


(definition protected remember-audio
  (world-setting 'world.remember-audio 60))

(definition protected remember-video
  (world-setting 'world.remember-video 30))


(definition average-audio-packets/frame
  1.0)

(definition average-video-packets/frame
  (vector
    6.2
    6.2
    6.6
    9.6
    15.7))


(definition protected (remember-ring media-kind source-kind level framerate)
  (ecase media-kind
         ((udp-audio)
          (and remember-audio
               (let ((estimated-rate 60.)
                     (estimated-packets/frame average-audio-packets/frame))
                 (let ((size (fxround (* estimated-rate estimated-packets/frame remember-audio))))
                   (new Remember-Ring size)))))
         ((udp-video)
          (and remember-video
               (case source-kind
                 ((image)
                  (new Remember-Ring 8))
                 ((draw)
                  (new Remember-Ring 32))
                 ((stream live)
                  (let ((estimated-packets/frame (vector-ref average-video-packets/frame level)))
                    (let ((size (fxround (* framerate estimated-packets/frame remember-video))))
                      (new Remember-Ring size))))
                 (else
                  #f))))))


(class Remember-Ring-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-size object))
                              (serialize (get-max-size object))
                              (serialize (get-packets object))
                              (serialize (get-head object))
                              (serialize (get-tail object))
                              (serialize (get-count object))
                              (serialize (get-lowest object))
                              (serialize (get-highest object))
                              (serialize (get-last-sequence object)))))
  
  
  (method override (unmarshall-object self content <vector>)
    (bind-vector (size max-size packets head tail count lowest highest last-sequence) content
      (allocate self
                (deserialize size)
                (deserialize max-size)
                (deserialize packets)
                (make-mutex 'ring)
                (deserialize head)
                (deserialize tail)
                (deserialize count)
                (deserialize lowest)
                (deserialize highest)
                (deserialize last-sequence)))))


(class Remember-Ring metaclass Remember-Ring-Class extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot max-size     <fx>        getter generate)
  (slot packets      <vector>    getter generate)
  (slot mutex        <object>    getter generate)
  (slot head         <fx>        getter generate)
  (slot tail         <fx>        getter generate)
  (slot count        <fx>        getter generate)
  (slot lowest       <fx>        getter generate)
  (slot highest      <fx>        getter generate)
  (slot last-sequence            getter generate)
  
  
  (method override (initialize self size <fx> (max-size: max-size #f) (overflow-proc: overflow-proc #f))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.packets (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.last-sequence #f))
  
  
  (method protected (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  (method protected (check self)
    (when (> count 0)
      (let ((low (get-sequence (lowest-packet self)))
            (high (get-sequence (highest-packet self))))
        (assert (= lowest low))
        (assert (= highest high)))))
  
  
  (method protected (lowest-packet self) <UDP-Packet>
    (vector-ref packets head))
  
  
  (method protected (highest-packet self) <UDP-Packet>
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (index self seq)
    (modulo (+ head (- seq lowest)) size))
  
  
  (method protected (packet-ref self n) <UDP-Packet>
    (vector-ref packets (modulo (+ head n) size)))
  
  
  (method public (locate-packet self sequence) <UDP-Packet+>
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (vector-ref packets pos)))
      (mutex-unlock! mutex)))

  
  ;;;
  ;;;; Remember
  ;;;
  
  
  (method public (remember self data)
    (mutex-lock! mutex)
    (with-record media
      (let ((dts (timestamp->flonum (read-media-dts data)))
            (pts (timestamp->flonum (read-media-pts data)))
            (duration (read-media-duration data))
            (sequence (read-media-sequence data))
            (frame (read-media-frame data))
            (part (read-media-part data))
            (total (read-media-total data))
            (keyframe? (read-media-keyframe? data))
            (off? (read-media-off? data)))
        (let ((in-order? (or (not last-sequence)
                             (> sequence last-sequence))))
          (cond ;; empty
                ((= count 0)
                 (when in-order?
                   (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? off? data)))
                     (insert-before self head packet)
                     (set! last-sequence sequence)
                     (set! lowest sequence)
                     (set! highest sequence)
                     (check self))))
                ;; insert
                (in-order?
                 (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? off? data)))
                   (let ((expected (+ last-sequence 1)))
                     (let ((gap (- sequence expected)))
                       (if (>= gap udp-max-gap)
                           (begin
                             (set! last-sequence sequence)
                             (remove-before self count))
                         (loop (for seq from (+ highest 1) below sequence)
                               (insert-before self tail (new UDP-Packet #f #f #f seq #f #f #f #f #f #f)))
                         (insert-before self tail packet)
                         (set! last-sequence sequence)
                         (set! highest sequence)
                         (check self))))))
                ;; replace
                (else
                 (when (between? sequence lowest highest)
                   (let ((pos (index self sequence)))
                     (let ((actual-packet <UDP-Packet> (vector-ref packets pos)))
                       (when (not (get-data actual-packet))
                         (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? off? data)))
                           (vector-set! packets pos packet)))))))))))
    (mutex-unlock! mutex))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert-before self pos packet)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-packets (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subvector-move! packets 0 tail new-packets 0)
          (subvector-move! packets tail size new-packets head)
          (set! size new-size)
          (set! packets new-packets))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (vector-set! packets head packet)
                  (increase! count))
                 ((= pos tail)
                  (vector-set! packets tail packet)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subvector-shift! packets head pos -1)
                        (vector-set! packets (- pos 1) packet)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subvector-shift! packets pos tail 1)
                    (vector-set! packets pos packet)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (vector-set! packets tail packet)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail)
           (increase! lowest))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method protected (remove-before self cnt <fx>)
    (loop (repeat cnt)
          (vector-set! packets head #f)
          (set! head (modulo (+ head 1) size))
          (decrease! count)
          (increase! lowest))
    (check self))
  
  
  (method public (collect-missing self)
    (mutex-lock! mutex)
    (unwind-protect (let ((missing (new-queue)))
                      (let (loop (n (- count 1)))
                        (if (< n 0)
                            (queue-list missing)
                          (let ((pos (modulo (+ head n) size)))
                            (let ((packet <UDP-Packet> (vector-ref packets pos)))
                              (when (not (get-data packet))
                                (enqueue missing (get-sequence packet)))
                              (loop (- n 1)))))))
      (mutex-unlock! mutex))))


(definition protected (copy-remember-ring ring <Remember-Ring>) <Remember-Ring>
  (mutex-lock! (get-mutex ring))
  (let ((copy (allocate Remember-Ring
                (get-size ring)
                (get-max-size ring)
                (vector-copy (get-packets ring))
                (make-mutex 'ring)
                (get-head ring)
                (get-tail ring)
                (get-count ring)
                (get-lowest ring)
                (get-highest ring)
                (get-last-sequence ring))))
    (mutex-unlock! (get-mutex ring))
    copy))


;;;
;;;; Ring
;;;


(proclaim (warn optimizations))


;;               ---> time
;;  wait +----+----+----+----+----+ insert
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL
;;   (earliest)                (latest)
;;    (lowest)                 (highest)


(class UDP-Ring extends Object
  
  
  (slot channel                   getter generate)
  (slot no                        getter generate)
  (slot origin                    getter generate)
  (slot media-kind                getter generate)
  (slot source-kind               getter generate)
  (slot size          <fx>        getter generate)
  (slot max-size      <fx>        getter generate)
  (slot packets       <vector>    getter generate)
  (slot mutex         <object>    getter generate)
  (slot wait-condvar  <object>    getter generate)
  (slot head          <fx>        getter generate)
  (slot tail          <fx>        getter generate)
  (slot count         <fx>        getter generate)
  (slot lowest        <fx>        getter generate)
  (slot highest       <fx>        getter generate)
  (slot state                     getter generate)
  (slot last-sequence <fx+>       getter generate)
  (slot time-base     <Time-Base> getter generate)
  (slot terminate?                getter generate)
  (slot overflow-proc             getter generate)
  (slot retain-window             getter generate)
  
  
  (method override (initialize self channel no origin media-kind source-kind size <fx> (max-size: max-size #f) (time-base: time-base #f) (overflow-proc: overflow-proc #f) (retain-window: retain-window #f))
    (nextmethod self)
    (set! self.channel channel)
    (set! self.no no)
    (set! self.origin origin)
    (set! self.media-kind media-kind)
    (set! self.source-kind source-kind)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.packets (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.wait-condvar (make-condition-variable 'wait))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.state (if (eq? media-kind udp-audio) 'ok 'waiting))
    (set! self.last-sequence #f)
    (set! self.time-base (or time-base (new Time-Base)))
    (set! self.terminate? #f)
    (set! self.overflow-proc overflow-proc)
    (set! self.retain-window retain-window))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" state))))
  
  
  (method public (terminate self)
    (mutex-lock! mutex)
    (set! terminate? #t)
    (condition-variable-signal! wait-condvar)
    (mutex-unlock! mutex))
  
  
  (method public (empty self)
    (vector-fill! self.packets #f)
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0))
  
  
  (method protected (check self)
    (when (> count 0)
      (let ((low (get-sequence (lowest-packet self)))
            (high (get-sequence (highest-packet self))))
        (assert (= lowest low))
        (assert (= highest high)))))
  
  
  (method protected (lowest-packet self) <UDP-Packet>
    (vector-ref packets head))
  
  
  (method protected (highest-packet self) <UDP-Packet>
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (index self seq <fx>) <fx>
    (modulo (+ head (- seq lowest)) size))

  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert self data (insert-event #f))
    (with-record media
      (let ((now (current-seconds))
            (dts (timestamp->flonum (read-media-dts data)))
            (pts (timestamp->flonum (read-media-pts data))))
        (mutex-lock! mutex)
        (let ((sender (read-header-sender data))
              (duration (read-media-duration data))
              (sequence (read-media-sequence data))
              (frame (read-media-frame data))
              (part (read-media-part data))
              (total (read-media-total data))
              (keyframe? (read-media-keyframe? data))
              (off? (read-media-off? data)))
          (define (time-update)
            (unless (emulation?)
              (update-time time-base now dts
                (lambda (raw-latency effective-latency)
                  (condition-variable-signal! wait-condvar)
                  (record-event udp-id-update-time
                                (fixnum->flonum no)
                                (fixnum->flonum sender)
                                (fixnum->flonum media-kind)
                                (fixnum->flonum sequence)
                                now
                                raw-latency
                                dts
                                effective-latency)))))
          
          (define (insert/purge reason)
            (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? off? data)))
              (empty self)
              (when reason
                (record-purge reason))
              (record-insert)
              (insert-before self tail packet)
              (set! last-sequence sequence)
              (set! lowest sequence)
              (set! highest sequence)
              (check self)
              (state-waiting self)
              (condition-variable-signal! wait-condvar)))
          
          (define (insert-first-time)
            (insert/purge #f))
          
          (define (insert-highest packet)
            (record-insert)
            (insert-before self tail packet)
            (set! last-sequence sequence)
            (set! highest sequence)
            (check self)
            (condition-variable-signal! wait-condvar))
          
          (define (record-purge reason)
            (record-event udp-id-purge-ring
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          reason
                          -1.))
          
          (define (record-insert)
            (let ((base (get-base time-base))
                  (latency (get-latency time-base))
                  (raw-latency (get-raw-latency time-base)))
              (record-event (or insert-event udp-id-insert-packet)
                            (fixnum->flonum no)
                            (fixnum->flonum origin)
                            (fixnum->flonum media-kind)
                            (fixnum->flonum sequence)
                            (fixnum->flonum frame)
                            latency
                            dts
                            (or base -1.)
                            raw-latency)))
          
          (define (record-missing seq)
            (record-event udp-id-missing-packet
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum seq)
                          (fixnum->flonum sequence)
                          -1.
                          -1.))
          
          (define (record-gap gap)
            (record-event udp-id-packet-gap
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          (fixnum->flonum gap)
                          -1.))
          
          (cond ;; first time
                ((not last-sequence)
                 (time-update)
                 (insert-first-time))
                ;; in-order insert
                ((> sequence last-sequence)
                 (let ((expected (+ (allege last-sequence) 1)))
                   (let ((gap (- sequence expected)))
                     (when (> gap 0)
                       (record-gap gap)
                       (add-missed-media-packets (current-udp) sender gap))
                     (if (>= gap udp-max-gap)
                         (insert/purge udp-purge-gap)
                       (when (> gap 0)
                         (send-nack (current-udp) sender no expected gap))
                       (let ((previous-raw-latency (get-raw-latency time-base)))
                         (time-update)
                         (let ((seek-change-heuristic (abs (- (get-raw-latency time-base) previous-raw-latency))))
                           (if (> seek-change-heuristic 1.)
                               (insert/purge udp-purge-seek)
                             (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? off? data)))
                               (if (= count 0)
                                   (loop (for seq from (+ highest 1) below sequence)
                                         (record-missing seq)
                                         (insert-before self tail (new UDP-Packet dts pts #f seq #f #f #f #f #f #f)))
                                 (let ((highest-packet (highest-packet self)))
                                   (let ((highest-dts (get-dts highest-packet)))
                                     (loop (for seq from (+ highest 1) below sequence)
                                           (let ((dts (interpolate seq highest sequence highest-dts dts)))
                                             (record-missing seq)
                                             (insert-before self tail (new UDP-Packet dts pts #f seq #f #f #f #f #f #f)))))))
                               (insert-highest packet)))))))))
                ;; out-of-order replace
                (else
                 (update-past time-base now dts
                   (lambda (raw-latency effective-latency)
                     ))
                 (if (between? sequence lowest highest)
                     (let ((pos (index self sequence)))
                       (let ((actual-packet <UDP-Packet> (vector-ref packets pos)))
                         (if (get-data actual-packet)
                             (let ((resent (read-media-resent data)))
                               (record-event udp-id-duplicate-packet
                                             (fixnum->flonum no)
                                             (fixnum->flonum origin)
                                             (fixnum->flonum media-kind)
                                             (fixnum->flonum sequence)
                                             (fixnum->flonum frame)
                                             (fixnum->flonum resent)
                                             -1.))
                           (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? off? data)))
                             (vector-set! packets pos packet)
                             (let ((resent (read-media-resent data)))
                               (record-event udp-id-got-packet
                                             (fixnum->flonum no)
                                             (fixnum->flonum origin)
                                             (fixnum->flonum media-kind)
                                             (fixnum->flonum sequence)
                                             (fixnum->flonum frame)
                                             (fixnum->flonum resent)
                                             -1.))
                             (condition-variable-signal! wait-condvar)))))
                   (let ((resent (read-media-resent data)))
                     (record-event udp-id-reject-packet
                                   (fixnum->flonum no)
                                   (fixnum->flonum origin)
                                   (fixnum->flonum media-kind)
                                   (fixnum->flonum sequence)
                                   (fixnum->flonum frame)
                                   (fixnum->flonum resent)
                                   -1.))))))
        (mutex-unlock! mutex))))
  
  
  (method public (insert-before self pos <fx> packet <UDP-Packet>)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-packets (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subvector-move! packets 0 tail new-packets 0)
          (subvector-move! packets tail size new-packets head)
          (set! size new-size)
          (set! packets new-packets))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (vector-set! packets head packet)
                  (increase! count))
                 ((= pos tail)
                  (vector-set! packets tail packet)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subvector-shift! packets head pos -1)
                        (vector-set! packets (- pos 1) packet)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subvector-shift! packets pos tail 1)
                    (vector-set! packets pos packet)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (when overflow-proc
             (let ((bumped-packet <UDP-Packet> (vector-ref packets tail)))
               (overflow-proc self packet bumped-packet)))
           (vector-set! packets tail packet)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail)
           (increase! lowest))))
  
  
  ;;;
  ;;;; Visualizer
  ;;;
  
  
  (method protected (visualizer-packet-ref self n <fx>) <UDP-Packet+>
    (and (< n count)
         (vector-ref packets (modulo (+ head n) size))))
  
  
  (method protected (visualizer-earliest-packet self) <UDP-Packet+>
    (visualizer-packet-ref self 0))
  
  
  (method protected (visualizer-update-time self base latency)
    (visualizer-update time-base base latency))
  
  
  (method protected (visualizer-replace-got self sequence <fx> data)
    ;; quick robust test for visualizer
    (when (between? sequence lowest highest)
      (let ((pos (index self sequence)))
        (let ((actual-packet <UDP-Packet> (vector-ref packets pos)))
          (assert (eqv? (get-sequence actual-packet) sequence)
            (assert (not (get-data actual-packet))
              (with-record media
                (let ((dts (timestamp->flonum (read-media-dts data)))
                      (pts (timestamp->flonum (read-media-pts data)))
                      (duration (read-media-duration data))
                      (sequence (read-media-sequence data))
                      (frame (read-media-frame data))
                      (part (read-media-part data))
                      (total (read-media-total data))
                      (keyframe? (read-media-keyframe? data))
                      (off? (read-media-off? data)))
                  (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? off? data)))
                    (vector-set! packets pos packet))))))))))
  
  
  (method protected (visualizer-frame-complete? self pos <fx>)
    (let ((packet (packet-ref self pos)))
      (let ((part (get-part packet))
            (total (get-total packet)))
        (and (= part 0)
             (<= (+ pos total) count)
             (loop (for n from 0 below total)
                   (every (get-data (packet-ref self (+ pos n)))))))))
  
  
  (method protected (visualizer-remove-frame self)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (let ((part (get-part earliest))
            (total (get-total earliest)))
        (let ((cnt (- total part)))
          (remove-before self cnt)))))
  
  
  (method protected (visualizer-iterate-frame self proc)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (let ((part (get-part earliest))
            (total (get-total earliest)))
        (let ((cnt (- total part)))
          (loop (for n from 0 below cnt)
                (proc (packet-ref self n)))))))
  
  
  ;;;
  ;;;; Retain
  ;;;
  
  
  (method public (retain-wait self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((now (current-seconds))
                (earliest <UDP-Packet> (vector-ref packets head)))
            (let ((release-time (determine-release-time self earliest)))
              (if (>= now release-time)
                  (prog1 earliest
                    (vector-set! packets head #f)
                    (set! head (modulo (+ head 1) size))
                    (decrease! count)
                    (increase! lowest)
                    (check self)
                    (mutex-unlock! mutex))
                (mutex-unlock! mutex wait-condvar (- release-time now))
                (loop-wait))))))))
  
  
  (method (determine-release-time self packet <UDP-Packet>) <fl>
    (let ((dts (get-dts packet)))
      (+ (remote->local time-base dts) retain-window)))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method protected (process-audio self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((now (current-seconds))
                (earliest <UDP-Packet> (vector-ref packets head)))
            (let ((presentation-time (determine-presentation-time self earliest udp-audio-present)))
              (let ((giveup-time (+ presentation-time udp-audio-giveup)))
                (define (debugging what sleep)
                  @debug
                  (let ((sequence (get-sequence earliest))
                        (time (- now (determine-earliest-time self earliest)))
                        (sleep (if (symbol? sleep) sleep (format "{r precision: 3}" sleep)))
                        (content (loop (for n from 0 below count)
                                       (collect (get-sequence (packet-ref self n))))))
                    (format :terminal
                            "{a width: 8} {a} {r precision: 3} {a width: 6} ({l}){%}"
                            what
                            sequence
                            time
                            sleep
                            content)))
                
                (cond ;; off
                      ((get-off? earliest)
                       (prog1 (present self now)
                         (mutex-unlock! mutex)))
                      ;; giveup
                      ((>= now giveup-time)
                       (debugging 'giveup 'loop)
                       (flush-earliest self)
                       (mutex-unlock! mutex)
                       (loop-wait))
                      ;; not ready
                      ((< now presentation-time)
                       (debugging 'sleep (- presentation-time now))
                       (mutex-unlock! mutex wait-condvar (- presentation-time now))
                       (loop-wait))
                      ;; frame
                      ((complete-frame? self)
                       (prog1 (present self now)
                         (debugging 'play 'return)
                         (mutex-unlock! mutex)))
                      ;; not ready to giveup
                      (else
                       (debugging 'nrtgu (- giveup-time now))
                       (mutex-unlock! mutex wait-condvar (- giveup-time now))
                       (loop-wait))))))))))
  
  
  (method protected (process-video self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (if (not (get-framerate channel))
                (begin
                  (mutex-unlock! mutex wait-condvar)
                  (loop-wait))
              (mutex-unlock! mutex wait-condvar udp-video-giveup)
              (if (= count 0)
                  (begin
                    (state-waiting self)
                    (loop-wait))
                (loop-wait)))
          (let ((now (current-seconds))
                (earliest <UDP-Packet> (vector-ref packets head)))
            (let ((presentation-time (determine-presentation-time self earliest udp-video-present)))
              (let ((late-time (+ presentation-time udp-video-late))
                    (giveup-time (+ presentation-time udp-video-giveup)))
                (define (debugging what sleep)
                  @debug
                  (let ((sequence (get-sequence earliest))
                        (time (- now (determine-earliest-time self earliest)))
                        (sleep (if (symbol? sleep) sleep (format "{r precision: 3}" sleep)))
                        (content (loop (for n from 0 below count)
                                       (collect (get-sequence (packet-ref self n))))))
                    (format :terminal
                            "{a width: 6} {a} {r precision: 3} {a width: 6} ({l}){%}"
                            what
                            sequence
                            time
                            sleep
                            content)))
                
                (cond ;; off
                      ((get-off? earliest)
                       (prog1 (present self now)
                         (mutex-unlock! mutex)))
                      ;; giveup
                      ((>= now giveup-time)
                       (debugging 'giveup 'loop)
                       (flush-earliest self)
                       (state-waiting self)
                       (mutex-unlock! mutex)
                       (loop-wait))
                      ;; waiting
                      ((eq? state 'waiting)
                       (let ((keyframe (complete-keyframe self)))
                         (cond ;; keyframe
                               (keyframe
                                (let ((packet (packet-ref self keyframe)))
                                  (let ((packet-present (determine-presentation-time self packet udp-video-present)))
                                    (if (< now packet-present)
                                        ;; not ready
                                        (begin
                                          (mutex-unlock! mutex wait-condvar (- packet-present now))
                                          (loop-wait))
                                      ;; ready
                                      (begin
                                        (flush-before self keyframe)
                                        (state-ok self)
                                        (mutex-unlock! mutex)
                                        (loop-wait))))))
                               ;; giveup
                               ((>= now giveup-time)
                                (flush-earliest self)
                                (mutex-unlock! mutex)
                                (loop-wait))
                               ;; not ready to giveup
                               (else
                                (mutex-unlock! mutex wait-condvar (- giveup-time now))
                                (loop-wait)))))
                      ;; not ready
                      ((< now presentation-time)
                       (debugging 'sleep (- presentation-time now))
                       (mutex-unlock! mutex wait-condvar (- presentation-time now))
                       (loop-wait))
                      ;; frame
                      ((complete-frame? self)
                       (prog1 (begin
                                (if (< now late-time)
                                    (state-ok self)
                                  (state-late self))
                                (present self now))
                         (debugging (if (eq? state 'ok) 'play 'freeze) 'return)
                         (mutex-unlock! mutex)))
                      ;; ok
                      ((< now late-time)
                       (debugging 'ok (- late-time now))
                       (mutex-unlock! mutex wait-condvar (- late-time now))
                       (loop-wait))
                      ;; late
                      (else
                       (debugging 'late (- giveup-time now))
                       (state-late self)
                       (mutex-unlock! mutex wait-condvar (- giveup-time now))
                       (loop-wait))))))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method protected (packet-ref self n <fx>) <UDP-Packet>
    (vector-ref packets (modulo (+ head n) size)))
  
  
  (method (determine-earliest-time self packet <UDP-Packet>) <fl>
    (let ((dts (get-dts packet)))
      (remote->local time-base dts)))
  
  
  (method (determine-presentation-time self packet <UDP-Packet> process-window <fl>) <fl>
    (let ((dts (get-dts packet)))
      (+ (remote->local time-base dts) process-window)))
  
  
  (method protected (complete-frame? self)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (and (get-data earliest)
           (let ((part (get-part earliest))
                 (total (get-total earliest)))
             (and (= part 0)
                  (<= total count)
                  (loop (for n from 0 below total)
                        (every (get-data (packet-ref self n)))))))))
    
  
  (method (complete-keyframe self)
    (continuation-capture
      (lambda (found)
        (loop (for n from 0 below count)
              (let ((packet (packet-ref self n)))
                (when (and (get-data packet)
                           (get-keyframe? packet)
                           (= (get-part packet) 0))
                  (let ((frame (get-frame packet))
                        (total (get-total packet)))
                    (let ((last (+ n total -1)))
                      (when (and (< last count)
                                 (loop (for i from (+ n 1) to last)
                                       (every (let ((packet (packet-ref self i)))
                                                (and (get-data packet)
                                                     (= (get-frame packet) frame))))))
                        (continuation-return found n)))))))
        #f)))
  
  
  (method (present self now)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (let ((frame (get-frame earliest))
            (total (get-total earliest)))
        (prog1 (loop (for n from 0 below total)
                     (collect (get-data (packet-ref self n))))
          (remove-before self total)))))
  
  
  (method (flush-before self cnt)
    (loop (repeat cnt)
          (flush-earliest self)))
  
  
  (method (flush-earliest self)
    (let ((earliest (packet-ref self 0)))
      (let ((sequence (get-sequence earliest))
            (frame (get-frame earliest))
            (keyframe? (get-keyframe? earliest))
            (dts (get-dts earliest)))
        (if (get-data earliest)
            (record-discard-packet self sequence frame keyframe? dts)
          (record-lost-packet self sequence frame keyframe? dts))
        (remove-earliest self))))
  
  
  (method protected (remove-before self cnt <fx>)
    (loop (repeat cnt)
          (vector-set! packets head #f)
          (set! head (modulo (+ head 1) size))
          (decrease! count)
          (increase! lowest))
    (check self))
  
  
  (method protected (remove-earliest self)
    (remove-before self 1))
  
  
  (method protected (state-ok self)
    (unless (eq? state 'ok)
      (set! state 'ok)
      (unless (emulation?)
        (record-event udp-id-state-ok
                      (fixnum->flonum no)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      -1.
                      -1.))))
  
  
  (method protected (state-late self)
    (unless (eq? state 'late)
      (set! state 'late)
      (unless (emulation?)
        (record-event udp-id-state-late
                      (fixnum->flonum no)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      -1.
                      -1.))))
  
  
  (method protected (state-waiting self)
    (unless (eq? state 'waiting)
      (set! state 'waiting)
      (unless (emulation?)
        (record-event udp-id-state-waiting
                      (fixnum->flonum no)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      -1.
                      -1.))))
  
  
  (method (record-lost-packet self sequence frame keyframe? dts)
    (record-event udp-id-lost-packet
                  (fixnum->flonum no)
                  (fixnum->flonum origin)
                  (fixnum->flonum media-kind)
                  (fixnum->flonum sequence)
                  (if (not frame)
                      -1.
                    (fixnum->flonum frame))
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method (record-discard-packet self sequence frame keyframe? dts)
    (record-event udp-id-discard-packet
                  (fixnum->flonum no)
                  (fixnum->flonum origin)
                  (fixnum->flonum media-kind)
                  (fixnum->flonum sequence)
                  (fixnum->flonum frame)
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method public (locate-packet self sequence <fx>) <UDP-Packet+>
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (vector-ref packets pos)))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-data self sequence <fx>)
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (let ((packet <UDP-Packet> (vector-ref packets pos)))
                    (get-data packet))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-earliest self predicate) <UDP-Packet+>
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (if (>= n count)
                          #f
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (if (predicate packet)
                                packet
                              (loop (+ n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-latest self predicate) <UDP-Packet+>
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n (- count 1)))
                      (if (< n 0)
                          #f
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (if (predicate packet)
                                packet
                              (loop (- n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-indexes self proc)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (when (< n count)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc n)
                            (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-earliest self proc)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (when (< n count)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc packet)
                            (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-latest self proc)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n (- count 1)))
                      (when (>= n 0)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc packet)
                            (loop (- n 1))))))
      (mutex-unlock! mutex))))


(proclaim (default warn optimizations))


;;;
;;;; Monitor
;;;


(class UDP-Monitor extends Object
  
  
  (slot packets-sent         initialize 0 getter generate)
  (slot bytes-sent           initialize 0 getter generate)
  (slot packets-received     initialize 0 getter generate)
  (slot bytes-received       initialize 0 getter generate)
  (slot missed-media-packets initialize 0 getter generate)
  
  
  (method protected (increase-sent self data)
    (increase! packets-sent)
    (increase! bytes-sent (u8vector-length data)))
  
  
  (method protected (increase-received self data)
    (increase! packets-received)
    (increase! bytes-received (u8vector-length data)))
  
  
  (method (increase-missed-media-packets self gap)
    (increase! missed-media-packets gap)))


;;;
;;;; UDP-Statistics
;;;


(definition missed-rate-period
  1.)


(class UDP-Statistics extends Object
  
  
  (slot last-bytes-sent            initialize 0   getter generate)
  (slot last-bytes-received        initialize 0   getter generate)
  (slot last-server-missed         initialize 0   getter generate)
  (slot server-missed-accumulated  initialize 0   getter generate)
  (slot server-missed-elapse       initialize 0.  getter generate)
  (slot last-missed-rate           initialize 0.  getter generate)
  (slot last-send-rate             initialize #f  getter generate)
  (slot last-receive-rate          initialize #f  getter generate)
  (slot last-time                  initialize #f  getter generate)
  (slot outgoing-dropped           initialize 0   getter generate)
  (slot outgoing-drop              initialize 0   getter generate)
  (slot incoming-dropped           initialize 0   getter generate)
  (slot incoming-drop              initialize 0   getter generate)
  
  
  (method protected (update self now monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received server-missed-media-packets)
    ;; client
    (let ((packets-sent (get-packets-sent monitor))
          (bytes-sent (get-bytes-sent monitor))
          (packets-received (get-packets-received monitor))
          (bytes-received (get-bytes-received monitor)))
      (if (not last-time)
          (begin
            (set! last-send-rate -1.)
            (set! last-receive-rate -1.)
            (set! last-missed-rate -1.)
            (set! last-time now))
        (when (> now last-time)
          (let ((fresh-bytes-sent (- bytes-sent last-bytes-sent))
                (fresh-bytes-received (- bytes-received last-bytes-received))
                (fresh-server-missed (- server-missed-media-packets last-server-missed))
                (elapse (- now last-time)))
            (let ((fresh-send-rate (/ (cast <fl> fresh-bytes-sent) elapse))
                  (fresh-receive-rate (/ (cast <fl> fresh-bytes-received) elapse)))
              ;; use moving average over 32 samples
              (set! last-send-rate (if (= last-send-rate -1.) fresh-send-rate (/ (+ (* 31. last-send-rate) fresh-send-rate) 32.)))
              (set! last-receive-rate (if (= last-receive-rate -1.) fresh-receive-rate (/ (+ (* 31. last-receive-rate) fresh-receive-rate) 32.)))
              (set! last-time now)
              (set! server-missed-accumulated (+ server-missed-accumulated fresh-server-missed))
              (set! server-missed-elapse (+ server-missed-elapse elapse))))))
      (set! last-bytes-sent bytes-sent)
      (set! last-bytes-received bytes-received)
      (set! last-server-missed server-missed-media-packets)
      ;; client <-> server dropped
      (set! outgoing-dropped (- packets-sent server-packets-received))
      (set! incoming-dropped (- server-packets-sent packets-received))
      (set! outgoing-drop (and (> packets-sent 0) (percentage outgoing-dropped packets-sent)))
      (set! incoming-drop (and (> server-packets-sent 0) (percentage incoming-dropped server-packets-sent)))
      (when (>= server-missed-elapse missed-rate-period)
        (let ((fresh-missed-rate (/ server-missed-accumulated server-missed-elapse)))
          ;; use moving average over 32 samples
          (set! last-missed-rate (if (= last-missed-rate -1.) fresh-missed-rate (/ (+ (* 31. last-missed-rate) fresh-missed-rate) 32.)))
          @w (format :terminal "{a} {r precision: 1} {a} {a}{%}" 'last-missed-rate last-missed-rate 'nacks server-missed-media-packets))
        (set! server-missed-accumulated 0)
        (set! server-missed-elapse 0.)))))


;;;
;;;; Simulator
;;;


(definition protected udp-simulator-size <fx>
  256)

(definition protected udp-simulator-max-size <fx>
  4096)


(class UDP-Simulator extends Object
  
  
  (property latency             getter generate)
  (property drop                getter generate)
  (property congestion          accessors generate)
  (property congestion-duration accessors generate)
  
  (slot simulation-start     getter generate)
  (slot simulation-count     getter generate)
  (slot simulation-last      getter generate)
  (slot simulation           getter generate)
  (slot latency-proc         getter generate)
  (slot congestion-occuring? getter generate)
  (slot congestion-ends      accessors generate)
  (slot writer               getter generate)
  (slot ring                 getter generate)
  (slot thread               getter generate)
  
  
  (method override (initialize self writer)
    (nextmethod self)
    (set! self.latency #f)
    (set! self.latency-proc #f)
    (set! self.drop #f)
    (set! self.simulation #f)
    (set! self.congestion #f)
    (set! self.congestion-duration 5.)
    (set! self.congestion-occuring? #f)
    (set! self.congestion-ends #f)
    (set! self.writer writer)
    (set! self.ring (new Time-Ring udp-simulator-size max-size: udp-simulator-max-size))
    (set! self.thread (new-thread
                        (lambda ()
                          (send-loop self))
                        'simulator))
    (thread-base-priority-set! thread simulator-priority)
    (thread-start! thread))
  
  
  (method protected (setup-simulation self sim)
    (if (not sim)
        (set! simulation #f)
      (set! simulation-start (current-seconds))
      (set! simulation-count (/ (f64vector-length sim) 2))
      (set! simulation-last (- simulation-count 1))
      (set! simulation sim)))
  
  
  (method protected (setup-latency self lat)
    (define (parse-latency lat)
      (if (and (pair? lat) (eq? (car lat) 'add))
          (add-latency (map determine-latency (cdr lat)))
        (determine-latency lat)))
    
    (define (determine-latency lat)
      (define (try name proc)
        (cond ((eq? lat name)
               (proc))
              ((and (pair? lat) (eq? (car lat) name))
               (apply proc (cdr lat)))
              (else
               #f)))
      
      (if (number? lat)
          (fixed-latency lat)
        (or (try 'rise rise-latency)
            (try 'fall fall-latency)
            (try 'updown updown-latency)
            (try 'sin sin-latency)
            (try 'random random-latency)
            (try 'recorded recorded-latency)
            lat)))
    
    (set! latency lat)
    (set! latency-proc (and lat (parse-latency lat))))
  
  
  (method protected (setup-drop self drp)
    (set! drop (and drp (cast <fl> drp))))
  
  
  (method protected (send self data info)
    (define (insert-latency now latency drop)
      (unless (and drop (< (random-real) drop))
        (let ((time (+ now latency))
              (obj (cons data info)))
          (insert-monotonic ring time obj))))
    
    (cond (simulation
           (let ((now (current-seconds)))
             (let ((time (- now simulation-start)))
               (let ((index (fxfloor (/ time udp-heartbeat-period))))
                 (let ((remain (- time (* index udp-heartbeat-period))))
                   (let ((n (modulo index simulation-count)))
                     (if (>= n simulation-last)
                         (let ((latency (f64vector-ref simulation (* simulation-last 2)))
                               (drop (f64vector-ref simulation (+ (* simulation-last 2) 1))))
                           (insert-latency now latency drop))
                       (let ((next (+ n 1)))
                         (let ((latency (f64vector-ref simulation (* n 2)))
                               (drop (f64vector-ref simulation (+ (* n 2) 1))))
                           (let ((next-latency (f64vector-ref simulation (* next 2)))
                                 (next-drop (f64vector-ref simulation (+ (* next 2) 1))))
                             (let ((interp-latency (interpolate remain 0. udp-heartbeat-period latency next-latency))
                                   (interp-drop (interpolate remain 0. udp-heartbeat-period drop next-drop)))
                               (insert-latency now interp-latency interp-drop))))))))))))
          (congestion
           (if (not congestion-occuring?)
               (if (or (eq? congestion #t)
                       (< (random-real) (/ congestion 100.)))
                   (let ((ends (if (eq? congestion-duration #t) +inf.0 (random-between 0. congestion-duration))))
                     (set! congestion-occuring? #t)
                     (set! congestion-ends ends))
                 (send-writer self data info))
             (when (or (not congestion-ends)
                       (>= (current-seconds) congestion-ends))
               (set! congestion-occuring? #f)
               (set! congestion-ends #f)
               (send-writer self data info))))
          (latency-proc
           (let ((latency (let ((time (- (current-monotonic) kernel-boot-monotonic)))
                            (latency-proc time))))
             (insert-latency (current-seconds) latency #f)))
          (else
           (insert-latency (current-seconds) 0. #f))))
  
  
  (method (drop? self)
    (and drop (< (random-real) (/ drop 100.))))
  
  
  (method (send-writer self data info)
    (let ((drop? (drop? self)))
      (writer data info drop?)))
  
  
  (method (send-loop self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((pair (wait ring)))
        (bind (data . info) pair
          (send-writer self data info)))
      (loop))))


;;;
;;;; Media
;;;


(definition public (media-packet-keyframe? data)
  (with-record media
    (and (= (read-media-part data) 0)
         (read-media-keyframe? data))))


;;;
;;;; Access
;;;


(definition public max-u32
  (- (expt 2 32) 1))


(definition public (scan-boolean data pos)
  (/= (scan-s8 data pos) 0))


(definition public (put-boolean data pos value)
  (put-s8 data pos (if value 1 0)))


(definition public (scan-u8vector data pos)
  (let ((len (scan-u32 data pos)))
    (let ((v (make-u8vector len))
          (pos (+ pos 4)))
      (subu8vector-move! data pos (+ pos len) v 0)
      v)))


(definition public (put-u8vector data pos value)
  (let ((len (u8vector-length value)))
    (put-u32 data pos len)
    (let ((pos (+ pos 4)))
      (subu8vector-move! value 0 len data pos))))


(definition public (put-subu8vector! data pos value offset count)
  (put-u32 data pos count)
  (let ((pos (+ pos 4)))
    (subu8vector-move! value offset (+ offset count) data pos)))


(definition public (scan-host data pos)
  (u8vector (u8vector-ref data pos)
            (u8vector-ref data (+ pos 1))
            (u8vector-ref data (+ pos 2))
            (u8vector-ref data (+ pos 3))))


(definition public (put-host data pos value)
  (u8vector-set! data pos (u8vector-ref value 0))
  (u8vector-set! data (+ pos 1) (u8vector-ref value 1))
  (u8vector-set! data (+ pos 2) (u8vector-ref value 2))
  (u8vector-set! data (+ pos 3) (u8vector-ref value 3)))


;;;
;;;; Format
;;;


;; header
(define-record header
  (kind   u8  <fx>)
  (sender u32 <fx>))


;; connect
(define-record connect header
  (sent        double <fl>)
  (video-level s32))

(definition public (calculate-connect-size)
  (recordsize connect))


;; connected
(define-record connected header
  (connect-sent double <fl>))

(definition public (calculate-connected-size)
  (recordsize connected))


;; media
(define-record media header
  (keyframe? boolean)
  (off?      boolean)
  (resent    u8)
  (channel   u32    <fx>)
  (sequence  u64)
  (frame     u64)
  (part      u32    <fx>)
  (total     u32    <fx>)
  (dts       u64)
  (pts       u64)
  (duration  u64)
  (payload   u8vector))

(definition public (calculate-media-size)
  (recordsize media))

(definition public (read-media-payload-size data)
  (scan-u32 data (fieldoffset media payload)))

(definition public (write-media-subpayload data value offset count)
  (put-subu8vector! data (fieldoffset media payload) value offset count))

(definition public (increase-media-resent data)
  (with-record media
    (let ((resent (+ (read-media-resent data) 1)))
      (when (<= resent 255)
        (write-media-resent data resent)))))


;; state
(define-record state header
  (waiting u8vector))

(definition public (calculate-state-size waiting)
  (+ (recordsize state) (u8vector-length waiting)))


;; heartbeat
(define-record heartbeat header
  (sent     double <fl>)
  (sequence u32))

(definition public (calculate-heartbeat-size)
  (recordsize heartbeat))

(definition public max-heartbeat-sequence
  max-u32)


;; ack
(define-record ack header
  (heartbeat-sent       double <fl>)
  (heartbeat-sequence   u32)
  (sent                 double <fl>)
  (packets-sent         u64)
  (bytes-sent           u64)
  (packets-received     u64)
  (bytes-received       u64)
  (missed-media-packets u64))

(definition public (calculate-ack-size)
  (recordsize ack))


;; nack
(define-record nack header
  (channel u32 <fx>)
  (start   u32)
  (gap     u8))

(definition public (calculate-nack-size)
  (recordsize nack))


;; alive
(define-record alive header)

(definition public (calculate-alive-size)
  (recordsize alive))


;; alive ack
(define-record alive-ack header)

(definition public (calculate-alive-ack-size)
  (recordsize alive-ack))


;; profile pulse
(define-record profile-pulse header
  (sent     double <fl>)
  (sequence u32))

(definition public (calculate-profile-pulse-size)
  (recordsize profile-pulse))


;; profile ack
(define-record profile-ack header
  (pulse-sent       double <fl>)
  (pulse-sequence   u32)
  (sent             double <fl>)
  (latency          double <fl>)
  (packets-sent     u64)
  (bytes-sent       u64)
  (packets-received u64)
  (bytes-received   u64))

(definition public (calculate-profile-ack-size)
  (recordsize profile-ack))


;; profile media
(define-record profile-media header
  (sequence u32)
  (payload  u8vector))

(definition public (calculate-profile-media-size payload)
  (+ (recordsize profile-media) (u8vector-length payload)))


;; code
(definition public (read-udp-code data)
  (scan-u32 data (- (u8vector-length data) 4)))

(definition public (write-udp-code data)
  (put-u32 data (- (u8vector-length data) 4) udp-code))

(definition public udp-code-size <fx>
  4))
