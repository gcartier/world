;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.udp jazz


(import (jazz.io)
        (jazz.math)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (gaea.math)
        (world)
        (world.binary)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.format)
        (world.record (phase syntax))
        (world.ring)
        (world.settings)
        (world.simulate)
        (world.stream)
        (world.syntax (phase syntax))
        (world.task)
        (world.time))


(definition protected udp-connect <fx>
  0)

(definition protected udp-connected <fx>
  1)

(definition protected udp-heartbeat <fx>
  2)

(definition protected udp-ack <fx>
  3)

(definition protected udp-nack <fx>
  4)

(definition protected udp-audio <fx>
  5)

(definition protected udp-video <fx>
  6)

(definition protected udp-media-burst <fx>
  7)

(definition protected udp-media-pulse <fx>
  8)

(definition protected udp-media-ack <fx>
  9)

(definition protected udp-live <fx>
  10)

(definition protected udp-live-ack <fx>
  11)

(definition protected udp-profile-pulse <fx>
  12)

(definition protected udp-profile-ack <fx>
  13)

(definition protected udp-profile-media <fx>
  14)

(definition protected udp-profile-media-pulse <fx>
  15)

(definition protected udp-profile-media-ack <fx>
  16)

(definition protected udp-state <fx>
  17)

(definition protected udp-reset <fx>
  18)


(definition protected udp-client-droppable <fx>
  20)

(definition protected udp-processor-droppable <fx>
  21)


(definition udp-names
  #(connect connected heartbeat ack nack audio video alive alive-ack profile-pulse profile-ack profile-media))

(definition protected (udp-name kind)
  (vector-ref udp-names kind))


(definition protected udp-purge-gap
  1.)

(definition protected udp-purge-seek
  2.)


(definition protected udp-header-size
  8)


;; MTU - IP HEADER - UDP HEADER
;; 1500 - 20 (60) - 8 = 1472 (1432)
(definition protected udp-datagram-max <fx>
  1432)


(definition protected live-streaming?
  (world-setting 'world.live-streaming? #f))


(definition protected udp-live-retain-window <fx>
  (flonum->timestamp 2.))

(definition protected udp-non-live-retain-window <fx>
  (flonum->timestamp 5.))

(definition protected (effective-retain-window source-kind) <fx>
  (if (or live-streaming?
          (eq? source-kind 'live))
      udp-live-retain-window
    udp-non-live-retain-window))

(definition protected udp-retain-size <fx>
  256)

(definition protected udp-retain-max-size <fx>
  8192)


;; greater than any reasonably occuring latency change
(definition protected udp-seek-tolerance <fx>
  (flonum->timestamp 5.))


;; tolerance for late reporting
(definition protected udp-late-tolerance <fx>
  (flonum->timestamp .01))


(definition protected udp-audio-process <fx>
  0)

;; gstreamer's audio buffer time
(definition protected udp-audio-buffer <fx>
  (flonum->timestamp .2))

;; should be greater than max reasonable latency drop
(definition protected udp-audio-giveup <fx>
  (flonum->timestamp 2.))


;; audio mixer latency
(definition protected udp-audio-mixer <fx>
  (flonum->timestamp .15))

(definition protected udp-audio-early <fx>
  (flonum->timestamp -.1))

(definition protected udp-audio-late <fx>
  (- udp-audio-mixer udp-late-tolerance))

;; maximum lateness before mixer drops
(definition protected udp-audio-tolerance <fx>
  (- udp-audio-mixer
     (flonum->timestamp .01) ;; tolerance
     (flonum->timestamp .04) ;; opusdec
     ))


(definition protected udp-video-process <fx>
  (+ udp-audio-process udp-audio-buffer))

(definition protected udp-video-hardware-process <fx>
  (- udp-video-process (flonum->timestamp .05)))

(definition protected udp-video-present <fx>
  (flonum->timestamp .05))

(definition protected udp-video-early <fx>
  (flonum->timestamp -.1))

(definition protected udp-video-late <fx>
  (- udp-video-present udp-late-tolerance))

;; should be greater than max reasonable latency drop
;; for example a latency drop of .8s would end up in freeze
;; state but would still send the packets to the codec by not
;; giving up thus not having to wait for the next i-frame
(definition protected udp-video-giveup <fx>
  (flonum->timestamp 2.))

;; maximum lateness before video drops
(definition protected udp-video-tolerance <fx>
  (- udp-video-late (flonum->timestamp .01)))


(definition protected udp-process-size <fx>
  256)

(definition protected udp-process-max-size <fx>
  4096)


(definition protected udp-max-gap-live <fx>
  32)

(definition protected udp-max-gap-non-live <fx>
  128)


(definition protected udp-state-rate <fl>
  2.)

(definition protected udp-state-period <fl>
  (/ 1. udp-state-rate))

(definition protected udp-heartbeat-rate <fl>
  10.)

(definition protected udp-heartbeat-period <fl>
  (/ 1. udp-heartbeat-rate))


;; not receiving a live ack for this amount
;; of time indicates our udp punched whole has
;; probably closed and so disconnect from server
(definition protected live-disconnected <fl>
  45.)


(definition protected media-order <fx>
  0)

(definition protected (next-media-order! self)
  (prog1 media-order
    (increase! media-order)))


(definition protected (setup-udp-port-buffers port)
  (cond-expand
    (windows
     (let ((size (udp-socket-receive-buffer-size port)))
       (when (< size 65536)
         (udp-socket-receive-buffer-size-set! port 65536))))
    (else))
  (cond-expand
    (windows
     (let ((size (udp-socket-send-buffer-size port)))
       (when (< size 65536)
         (udp-socket-send-buffer-size-set! port 65536))))
    ;; mac os x having only a 8192 send buffer doesn't seem
    ;; to be a problem...
    (else)))


(definition protected (present-media-kind kind)
  (if (= kind udp-audio)
      'audio
    'video))


(definition protected (bytes->mbps bytes <fl>) <fl>
  (/ bytes 125000.))

(definition protected (mbps->bytes mbps <fl>) <fx>
  (fxround (* mbps 125000.)))


(definition public inline (evolutionary-udp-time    evolution <Evolution> n <fx>) <fl> (evolutionary-time  evolution n))
(definition public inline (evolutionary-udp-id      evolution <Evolution> n <fx>) <fl> (evolutionary-id    evolution n))
(definition public inline (evolutionary-udp-channel evolution <Evolution> n <fx>) <fl> (evolutionary-data1 evolution n))
(definition public inline (evolutionary-udp-origin  evolution <Evolution> n <fx>) <fl> (evolutionary-data2 evolution n))
(definition public inline (evolutionary-udp-kind    evolution <Evolution> n <fx>) <fl> (evolutionary-data3 evolution n))
(definition public inline (evolutionary-udp-data1   evolution <Evolution> n <fx>) <fl> (evolutionary-data4 evolution n))
(definition public inline (evolutionary-udp-data2   evolution <Evolution> n <fx>) <fl> (evolutionary-data5 evolution n))
(definition public inline (evolutionary-udp-data3   evolution <Evolution> n <fx>) <fl> (evolutionary-data6 evolution n))
(definition public inline (evolutionary-udp-data4   evolution <Evolution> n <fx>) <fl> (evolutionary-data7 evolution n))

(definition public inline (evolutionary-udp-sequence evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data1 evolution n)))
(definition public inline (evolutionary-udp-frame    evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data2 evolution n)))


(definition public (evolutionary-udp-receive-ack-heartbeat-sent      evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-receive-ack-heartbeat-sequence  evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data1 evolution n))
(definition public (evolutionary-udp-receive-ack-round-trip          evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data2 evolution n))
(definition public (evolutionary-udp-receive-ack-ack-sent            evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data4 evolution n))

(definition public (evolutionary-udp-rate-sample-sequence            evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data1 evolution n))
(definition public (evolutionary-udp-rate-sample-delivery-rate       evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data2 evolution n))

(definition public (evolutionary-udp-congestion-pacing               evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data2 evolution n))
(definition public (evolutionary-udp-congestion-window               evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data2 evolution n))

(definition public (evolutionary-udp-traffic-rate-heartbeat-sequence evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data1 evolution n))
(definition public (evolutionary-udp-traffic-rate-last-upload-rate   evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-traffic-rate-last-download-rate evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data4 evolution n))

(definition public (evolutionary-udp-insert-packet-raw-latency       evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-insert-packet-effective-latency evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data4 evolution n))

(definition public (evolutionary-udp-contour-latency                 evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data3 evolution n))

(definition public (evolutionary-udp-play-frame-pts                  evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data4 evolution n))
(definition public (evolutionary-udp-freeze-frame-pts                evolution <Evolution> n <fx>) <fl> (evolutionary-udp-data4 evolution n))


;; relies on 0 reserved for #f in next-literal-id
(definition protected server-no
  0)

(definition protected server-sender
  "Server")


(definition protected reconnect-marker
  123456.)

(definition protected no-connection-marker
  123456.)


(definition protected upload-microphone-priority
  0)

(definition protected upload-share-priority
  1)

(definition protected upload-camera-priority
  2)

(definition protected upload-stream-priority
  3)

(definition protected upload-missing-priority
  4)


;;;
;;;; Bailout
;;;


(definition protected bailouts
  (make-table test: equal?))


(definition bailout-prefixes
  '((register-bailout initialize handle-exception-filter handle-exception-filter initialize)
    (register-bailout #f handle-exception-filter handle-exception-filter calling-serving calling-server)
    (register-bailout calling-serving handle-exception-filter handle-exception-filter calling-serving calling-server)
    (register-bailout calling-serving handle-exception-filter handle-exception-filter calling-serving calling-processor)
    (register-bailout send-udp send-udp send-udp)
    (register-bailout #f #f send-udp)))


(definition (print-bailout name)
  (unless (eq? name 'udp-write)
    (let ((thread (current-thread)))
      (let ((thread-name (thread-name thread)))
        (assert thread-name
          (let ((stack (trim-stack (execution-stack identifiers?: #t depth: 10)))
                (mutexes (map mutex-name (thread-mutexes thread)))
                (task (let ((task (current-task))) (if task (get-name task) '$$$$$))))
            (terminal name thread-name '---> stack '>>> mutexes task)))))))


(definition (register-bailout name)
  (let ((thread (current-thread)))
    (let ((thread-name (thread-name thread)))
      (assert thread-name
        (let ((stack (trim-stack (execution-stack identifiers?: #t depth: 10)))
              (mutexes (map mutex-name (thread-mutexes thread)))
              (task (let ((task (current-task))) (if task (get-name task) '$$$$$))))
          (let ((signature (list name thread-name '---> stack '>>> mutexes task)))
            (table-set! bailouts signature (+ (table-ref bailouts signature 0) 1))))))))


(definition (trim-stack stack)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (prefix)
                  (when (and (>= (length stack) (length prefix))
                             (equal? (subseq stack 0 (length prefix)) prefix))
                    (continuation-return return (subseq stack (length prefix) (length stack)))))
                bailout-prefixes)
      stack)))


(definition protected bailout-target
  #f)

(definition protected (set-bailout-target target)
  (set! bailout-target target))

(definition protected (reset-bailout-target)
  (set! bailout-target #f))


(definition (trigger-bailout name)
  (let ((thread (current-thread)))
    (let ((thread-name (thread-name thread)))
      (assert thread-name
        (when (or (eq? bailout-target #t)
                  (eq? thread-name bailout-target))
          (set! bailout-target #t)
          (terminal 'bailout-point name)
          (throw-connection-broke "Bailing out"))))))


(definition protected (bailout-point name)
  @debug
  (print-bailout name)
  @debug
  (register-bailout name)
  @debug
  (trigger-bailout name))


;;;
;;;; Ring
;;;


(definition protected udp-ring-kind-retain
  0.)

(definition protected udp-ring-kind-process
  1.)

(definition protected udp-ring-kind-simulator
  2.)


(definition protected (udp-ring-overflow name kind)
  (lambda (ring data bumped-data)
    (when record-events?
      (record-event udp-id-ring-overflow
                    (fixnum->flonum (get-no ring))
                    (fixnum->flonum (get-origin ring))
                    (fixnum->flonum (get-media-kind ring))
                    (if (= kind udp-ring-kind-simulator)
                        -1.
                      (fixnum->flonum (get-sequence data)))
                    (fixnum->flonum (get-count ring))
                    kind
                    (fixnum->flonum (get-sequence bumped-data))))))


;;;
;;;; Read/Write
;;;


(definition protected (read-data port)
  (let ((data (read port)))
    (when record-read/write?
      (with-record header
        (let ((sender (read-header-sender data))
              (media-kind (read-header-kind data)))
          (record-event udp-id-read-data
                        -1.
                        (fixnum->flonum sender)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        (fixnum->flonum (u8vector-length data))))))
    data))


(definition protected (write-data data port)
  ;; quick temporary hack to get back the safe behavior
  ;; of retrying-write until port being false is fixed
  (when port
    (write data port)
    (when record-read/write?
      (with-record header
        (let ((sender (read-header-sender data))
              (media-kind (read-header-kind data)))
          (record-event udp-id-write-data
                        -1.
                        (fixnum->flonum sender)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        (fixnum->flonum (u8vector-length data))))))))


;;;
;;;; Tolerance
;;;


(definition protected retrying-grace <fl>
  10.)

(definition protected retrying-start
  #f)

(definition protected (set-retrying-start start)
  (set! retrying-start start))


(definition protected (send-udp data port)
  (if (not retrying-start)
      (safe-write data port)
    (let ((elapsed (- (current-seconds) retrying-start)))
      (if (< elapsed retrying-grace)
          (retrying-write data port)
        (set! retrying-start #f)
        (safe-write data port)))))


(definition protected (safe-write data port)
  (continuation-capture
    (lambda (exit)
      (with-exception-handler
        (lambda (exc)
          (continuation-graft exit
            (lambda ()
              (when record-events?
                (record-event udp-id-write-failure
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.))
              (bailout (current-client) exc))))
        (lambda ()
          (bailout-point 'udp-write)
          (write-data data port))))))


;; retry every 1/100s for grace period of 10s
(definition protected (retrying-write data port)
  (declare (proper-tail-calls))
  (let (loop (n 0))
    (handle-exception-filter
      (lambda (exc)
        (< n 1000))
      (lambda (exc)
        (sleep .01)
        (if (< n 999)
            (loop (+ n 1))
          (when record-events?
            (record-event udp-id-write-failure
                          -1.
                          -1.
                          -1.
                          -1.
                          -1.
                          -1.
                          -1.))
          (bailout (current-client) exc)
          exc))
      (lambda ()
        (bailout-point 'udp-write)
        (write-data data port)
        #f))))


;;;
;;;; Tier
;;;


(definition public (current-udp)
  (get-udp-tier (current-tier)))


(class UDP-Tier extends Object
  
  
  (slot send-streams  initialize #f getter generate)
  (slot send-channels initialize #f getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! send-streams (make-table))
    (set! send-channels (make-table))
    (register-snapshot-callback (~ snapshot-send-streams self)))
  
  
  (method package virtual (send-nack self sender channel-no start end ring)
    )
  
  
  (method (snapshot-send-streams self)
    (let ((info (map (lambda (stream)
                       (list (get-sender stream)
                             (get-name stream)
                             (get-source-kind stream)))
                     (table-values send-streams))))
      (add-snapshot-property 'live.udp-send info)))
  
  
  (method package (register-send-stream self sender name stream-no source-kind video-level)
    (let ((stream (new UDP-Send-Stream sender name stream-no client-no source-kind video-level)))
      (table-set! send-streams stream-no stream)
      stream))
  
  
  (method public (find-send-stream self stream-no)
    (table-ref send-streams stream-no #f))
  
  
  (method public (locate-send-stream self predicate)
    (search-table send-streams
      (lambda (no stream)
        (and (predicate stream)
             stream))))
  
  
  (method public (find-send-channel self channel-no)
    (table-ref send-channels channel-no #f))
  
  
  (method public (find-streaming self location)
    (search-table send-streams
      (lambda (no stream)
        (let ((stream-location (get-location stream)))
          (and stream-location
               (filename=? location stream-location)
               stream)))))
  
  
  (method public (collect-streaming self)
    (let ((queue (new-queue)))
      (iterate-table send-channels
        (lambda (no channel)
          (when (get-stream? (get-src (get-pipeline channel)))
            (enqueue queue channel))))
      (queue-list queue)))
  
  
  (method protected (gather-replay-missing self missing)
    (let ((queue (new-queue)))
      (for-each (lambda (info)
                  (bind (channel-no . missing) info
                    (let ((channel (find-send-channel self channel-no)))
                      (when channel
                        (let ((ring (get-replay-ring channel)))
                          (when ring
                            (for-each (lambda (sequence)
                                        (let ((packet (locate-packet ring sequence)))
                                          (when packet
                                            (enqueue queue (get-data packet)))))
                                      missing)))))))
                missing)
      (queue-list queue))))


;;;
;;;; Stream
;;;


(definition protected next-stream-no <fx>
  0)

(definition protected (next-stream-no!) <fx>
  (prog1 next-stream-no
    (increase! next-stream-no)))


(definition protected (stream-video-level stream profile-level)
  (let ((stream-level (get-video-level stream)))
    (and stream-level
         (let (iter (level (min stream-level profile-level)))
           (cond ;; this will need to be revisited but if no compatible
                 ;; quality found use the stream level so everything works
                 ;; and for now this will also enable showcasing high quality
                 ((< level 0)
                  stream-level)
                 ((find-level stream level)
                  level)
                 (else
                  (iter (- level 1))))))))


(class UDP-Stream extends Object
  
  
  (slot sender         getter generate)
  (slot name           getter generate)
  (slot no             getter generate)
  (slot origin         getter generate)
  (slot source-kind    getter generate)
  (slot video-level    accessors generate)
  (slot channels       getter generate)
  (slot level-channels getter generate)
  
  
  (method override (initialize self sender name no origin source-kind video-level)
    (nextmethod self)
    (set! self.sender sender)
    (set! self.name name)
    (set! self.no no)
    (set! self.origin origin)
    (set! self.source-kind source-kind)
    (set! self.video-level video-level)
    (set! self.channels (make-table test: eqv?))
    (set! self.level-channels (make-vector 5 #f)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a} {a} {a}" sender name no origin source-kind video-level))))
  
  
  (method protected (add-child self channel)
    (table-set! channels (get-no channel) channel)
    (let ((level (get-level channel)))
      (when level
        (vector-set! level-channels level channel))))
  
  
  (method protected (play self)
    (iterate-table channels
      (lambda (no channel)
        (play channel))))
  
  
  (method protected (locate-audio-channel self)
    (search-table channels
      (lambda (no channel)
        (and (= (get-media-kind channel) udp-audio)
             channel))))
  
  
  (method protected (locate-highest-video-channel self)
    (let ((highest-channel #f))
      (iterate-table channels
        (lambda (no channel)
          (when (= (get-media-kind channel) udp-video)
            (when (or (not highest-channel)
                      (> (get-level channel)
                         (get-level highest-channel)))
              (set! highest-channel channel)))))
      highest-channel))
  
  
  (method protected (find-level self level)
    (vector-ref level-channels level))
  
  
  (method public (effective-name self)
    (if (eq? source-kind 'live)
        sender
      name)))


;;;
;;;; Send Stream
;;;


(class UDP-Send-Stream extends UDP-Stream
  
  
  (slot location    initialize #f accessors generate)
  (slot action-proc initialize #f accessors generate)
  
  
  (method protected (locate-video-channel self)
    (search-table channels
      (lambda (no channel)
        (and (= (get-media-kind channel) udp-video)
             channel))))
  
  
  (method protected (locate-level-channel self level)
    (search-table channels
      (lambda (no channel)
        (and (= (get-media-kind channel) udp-video)
             (= (get-level channel) level)
             channel))))
  
  
  (method protected (locate-window-channel self)
    (search-table channels
      (lambda (no channel)
        (and (eq? (get-source-kind channel) 'window)
             channel))))
  
  
  (method protected (locate-screen-channel self)
    (search-table channels
      (lambda (no channel)
        (and (eq? (get-source-kind channel) 'screen)
             channel))))
  
  
  (method protected (collect-video-channels self)
    (let ((queue (new-queue)))
      (iterate-table channels
        (lambda (no channel)
          (when (= (get-media-kind channel) udp-video)
            (enqueue queue channel))))
      (queue-list queue))))


;;;
;;;; Channel
;;;


(definition protected next-channel-no <fx>
  0)

(definition protected (next-channel-no!) <fx>
  (prog1 next-channel-no
    (increase! next-channel-no)))


(class UDP-Channel extends Object
  
  
  (slot stream      getter generate)
  (slot no          getter generate)
  (slot media-kind  getter generate)
  (slot source-kind getter generate)
  (slot level       getter generate)
  (slot resolution  accessors generate)
  (slot framerate   getter generate)
  (slot bitrate     getter generate)
  (slot codec       getter generate)
  (slot caps        accessors generate)
  (slot metadata    getter generate)
  (slot send-state  accessors generate)
  (slot output      accessors generate)
  (slot recorder    accessors generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (nextmethod self)
    (set! self.stream stream)
    (set! self.no no)
    (set! self.media-kind media-kind)
    (set! self.source-kind source-kind)
    (set! self.level level)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.metadata metadata)
    (set! self.send-state send-state)
    (set! self.output #f)
    (set! self.recorder #f)
    (add-child stream self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (if (= media-kind udp-video)
            (format output "{a} {a} {a} {a} {a} {a} {a}" (get-sender stream) (get-name stream) no media-kind source-kind level resolution)
          (format output "{a} {a} {a} {a} {a}" (get-sender stream) (get-name stream) no media-kind source-kind)))))
  
  
  (method protected virtual (sender? self)
    #f)
  
  
  (method protected virtual (receiver? self)
    #f)
  
  
  (method protected virtual (reset self)
    ))


(definition protected (streams-metadata streams)
  (map-table (lambda (no stream)
               (list
                 (get-sender stream)
                 (get-name stream)
                 (get-no stream)
                 (get-origin stream)
                 (get-source-kind stream)
                 (get-video-level stream)
                 (map-table (lambda (no channel)
                              (list
                                (get-no channel)
                                (get-media-kind channel)
                                (get-source-kind channel)
                                (get-level channel)
                                (get-resolution channel)
                                (get-framerate channel)
                                (get-bitrate channel)
                                (get-codec channel)
                                (get-caps channel)
                                (get-metadata channel)
                                (get-send-state channel)))
                            (get-channels stream))))
             streams))


(definition public (determine-channel-name channel)
  (if (not channel)
      "Me"
    (let ((stream (get-stream channel)))
      (cond ((sender? channel)
             (if (eq? (get-source-kind stream) 'live)
                 (if (= (get-media-kind channel) udp-audio)
                     "microphone"
                   "camera")
               (get-name stream)))
            (else
             (if (eq? (get-source-kind stream) 'live)
                 (get-sender stream)
               (get-name stream)))))))


;;;
;;;; Retain Channel
;;;


(class UDP-Retain-Channel extends UDP-Channel
  
  
  (slot retain-ring getter generate))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Retain-Channel
  
  
  (slot priority           getter generate)
  (slot pipeline           accessors generate)
  (slot consumer           accessors generate)
  (slot action-proc        accessors generate)
  (slot data-sequence      accessors generate)
  (slot frame-sequence     accessors generate)
  (slot last-reset         getter generate)
  (slot wait-keyframe?     getter generate)
  (slot upload-ring        accessors generate)
  (slot replay-ring        getter generate)
  (slot release-task       getter generate)
  (slot audio-mirror-mutex getter generate)
  
  
  (method override (initialize self priority stream no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (nextmethod self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (set! self.priority priority)
    (set! self.pipeline #f)
    (set! self.consumer #f)
    (set! self.action-proc #f)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-reset #f)
    (set! self.wait-keyframe? (= media-kind udp-video))
    (set! self.upload-ring #f)
    (set! self.replay-ring (and record-media? (remember-ring media-kind source-kind level framerate)))
    (set! self.retain-ring (new UDP-Ring self no (get-origin stream) media-kind source-kind udp-retain-size max-size: udp-retain-max-size overflow-proc: (udp-ring-overflow 'retain udp-ring-kind-retain) retain-window: (effective-retain-window source-kind)))
    (unless (simulation?)
      (let ((task-name (if (= media-kind udp-audio)
                           (list 'release-audio (determine-channel-name self))
                         (list 'release-video (determine-channel-name self) level))))
        (set! self.release-task (new Task task-name (~ run-release self) priority: release-priority)))
      (start-task release-task))
    (when (= media-kind udp-audio)
      (set! audio-mirror-mutex (make-mutex 'audio-mirror))))
  
  
  (method override (destroy self)
    (when pipeline
      (release pipeline)
      (close pipeline))
    (terminate retain-ring)
    (thread-join! (get-thread release-task))
    (nextmethod self))
  
  
  (method override (sender? self)
    #t)
  
  
  (method protected (waiting-keyframe? self)
    wait-keyframe?)
  
  
  (method protected (wait-keyframe self)
    (when (= media-kind udp-video)
      (set! wait-keyframe? #t)))
  
  
  (method protected (got-keyframe self)
    (set! wait-keyframe? #f))
  
  
  (method protected (require-caps self)
    (require-caps (get-src pipeline)))
  
  
  (method protected (require-consumer-caps self)
    (and (get-processing? consumer)
         (require-consumer-caps (get-src pipeline) consumer)))
  
  
  (method (on? self)
    (eq? send-state 'on))
  
  
  (method (off? self)
    (eq? send-state 'off))
  
  
  (method (setup self)
    (when pipeline
      (setup pipeline)))
  
  
  (method (start self)
    (when pipeline
      (start pipeline)))
  
  
  (method (play self)
    (when pipeline
      (play pipeline)))
  
  
  (method (pause self)
    (when pipeline
      (pause pipeline)))
  
  
  (method (stop self)
    (when pipeline
      (stop pipeline)))
  
  
  (method (release self)
    (when pipeline
      (release pipeline)))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (remember-media self data)
    (when replay-ring
      (remember replay-ring data)))
  
  
  (method protected (retain-media self data)
    (insert retain-ring data udp-id-retain-packet))
  
  
  (method protected (send-media self sender buffer dts pts duration flags send)
    (let ((frame (next-frame-sequence! self)))
      (with-record media
        (let ((header-size (+ (calculate-media-size) udp-code-size))
              (payload-size (u8vector-length buffer)))
          (let ((max-content-size (- udp-datagram-max header-size)))
            (let ((total (fxceiling/ payload-size max-content-size)))
              (let (loop-part (part 0) (pos 0))
                (let ((remain (- payload-size pos)))
                  (when (> remain 0)
                    (let ((sequence (next-data-sequence! self))
                          (content-size (min remain max-content-size)))
                      (let ((size (+ header-size content-size)))
                        (let ((data (make-u8vector size)))
                          (write-header-kind data media-kind)
                          (write-header-sender data sender)
                          (write-media-channel data no)
                          (write-media-sequence data sequence)
                          (write-media-frame data frame)
                          (write-media-part data part)
                          (write-media-total data total)
                          (write-media-dts data dts)
                          (write-media-pts data pts)
                          (write-media-duration data duration)
                          (write-media-subpayload data buffer pos content-size)
                          (write-media-flags data flags)
                          (write-media-resent data 0)
                          (write-udp-code data)
                          (send data)
                          (when record-media?
                            (record-events
                              (lambda (record)
                                (record udp-id-create-packet
                                        (fixnum->flonum no)
                                        (fixnum->flonum sender)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        (fixnum->flonum frame)
                                        (timestamp->flonum dts)
                                        (timestamp->flonum pts))
                                (record udp-id-extra-info
                                        (fixnum->flonum part)
                                        (fixnum->flonum total)
                                        (fixnum->flonum flags)
                                        (timestamp->flonum duration)
                                        -1.
                                        -1.
                                        -1.))))
                          (remember-media self data)
                          (retain-media self data)
                          (loop-part (+ part 1) (+ pos content-size))))))))))))))
  
  
  (method override (reset self)
    (when output
      (reset output)))
  
  
  (method (reset-media self)
    (when pipeline
      (let ((src (get-src pipeline)))
        (when (and (resettable? src)
                   (playing? src))
          (let ((now (current-seconds)))
            (unless (and last-reset (< (- now last-reset) (reset-cooldown src)))
              (reset-media src)
              (set! last-reset now)
              (when record-events?
                (record-event udp-id-reset-media
                              (fixnum->flonum no)
                              (fixnum->flonum client-no)
                              (fixnum->flonum media-kind)
                              -1.
                              -1.
                              -1.
                              -1.))))))))
  
  
  (method protected (run-release self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((packet (retain-wait retain-ring)))
            (if (eq? packet 'terminate)
                (continuation-return exit #f)
              (site release
                (release-media self packet))
              (loop)))))))
  
  
  (method protected (release-media self packet)
    (when record-events?
      (let ((data (get-data packet))
            (origin (get-origin stream)))
        (if (not data)
            (let ((removed-sequence (get-sequence packet)))
              (record-event udp-id-giveup-packet
                            (fixnum->flonum no)
                            (fixnum->flonum origin)
                            (fixnum->flonum media-kind)
                            (fixnum->flonum removed-sequence)
                            -1.
                            -1.
                            -1.))
          (when record-media?
            (with-record media
              (let ((sequence (read-media-sequence data))
                    (frame (read-media-frame data))
                    (dts (read-media-dts data)))
                (record-event udp-id-release-packet
                              (fixnum->flonum no)
                              (fixnum->flonum origin)
                              (fixnum->flonum media-kind)
                              (fixnum->flonum sequence)
                              (fixnum->flonum frame)
                              -1.
                              (timestamp->flonum dts))))))))))


;;;
;;;; Packet
;;;


(class UDP-Packet-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-dts object))
                              (serialize (get-pts object))
                              (serialize (get-duration object))
                              (serialize (get-sequence object))
                              (serialize (get-frame object))
                              (serialize (get-part object))
                              (serialize (get-total object))
                              (serialize (get-flags object))
                              (serialize (get-data object)))))
  
  
  (method override (unmarshall-object self content)
    (bind-vector (dts pts duration sequence frame part total flags data) content
      (allocate self
                (deserialize dts)
                (deserialize pts)
                (deserialize duration)
                (deserialize sequence)
                (deserialize frame)
                (deserialize part)
                (deserialize total)
                (deserialize flags)
                (deserialize data)))))


(class UDP-Packet metaclass UDP-Packet-Class extends Object
  
  
  (slot dts            getter generate)
  (slot pts            getter generate)
  (slot duration       getter generate)
  (slot sequence  <fx> getter generate)
  (slot frame          getter generate)
  (slot part           getter generate)
  (slot total          getter generate)
  (slot flags          getter generate)
  (slot data           accessors generate)
  
  
  (method override (initialize self dts pts duration sequence frame part total flags data)
    (nextmethod self)
    (set! self.dts dts)
    (set! self.pts pts)
    (set! self.duration duration)
    (set! self.sequence sequence)
    (set! self.frame frame)
    (set! self.part part)
    (set! self.total total)
    (set! self.flags flags)
    (set! self.data data))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" sequence))))
  
  
  (method public (is-keyframe? self)
    (frame-keyframe? flags))
  
  
  (method public (has-voice? self)
    (frame-voice? flags)))


;;;
;;;; Base
;;;


(class UDP-Base extends Object
  
  
  (slot base        <fx+> getter generate)
  (slot raw-latency <fx>  getter generate)
  (slot latency     <fx>  accessors generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.base #f)
    (set! self.raw-latency 0)
    (set! self.latency 0))
  
  
  (method protected virtual (reset self)
    (set! self.base #f)
    (set! self.raw-latency 0)
    (set! self.latency 0))
  
  
  (method protected virtual (effective-latency self)
    latency)
  
  
  (method public virtual (update-time self local remote update-proc)
    (let ((new-base (- local remote)))
      (if (not base)
          (begin
            (set! base new-base)
            (set! raw-latency 0)
            (set! latency 0))
        (let ((raw (- new-base base)))
          (set! raw-latency raw)
          (set! latency raw))))
    (update-proc raw-latency latency))
  
  
  (method public virtual (update-past self local remote)
    )
  
  
  (method protected (remote->local self remote) <fx>
    (+ base remote latency)))


;;;
;;;; Visualizer Base
;;;


(class UDP-Visualizer-Base extends UDP-Base
  
  
  (slot base-local  <fl+> getter generate)
  (slot base-remote <fx+> getter generate)
  
  
  (method override (update-time self local remote update-proc)
    )
  
  
  (method protected (visualizer-update self local remote base latency)
    (set! self.base-local local)
    (set! self.base-remote remote)
    (set! self.base base)
    (set! self.latency latency))
  
  
  (method protected (visualizer-remote->local self remote) <fl>
    (+ base-local (timestamp->flonum (- remote base-remote)))))


;;;
;;;; Remember
;;;

;; temporary copy/paste of UDP-Ring


(definition protected remember-audio
  (world-setting 'world.remember-audio 60))

(definition protected remember-video
  (world-setting 'world.remember-video 30))


(definition average-audio-packets/frame
  1.0)

(definition average-video-packets/frame
  (vector
    6.2
    6.2
    6.6
    9.6
    15.7))


(definition protected (remember-ring media-kind source-kind level framerate)
  (ecase media-kind
    ((udp-audio)
     (and remember-audio
          (let ((estimated-rate 60.)
                (estimated-packets/frame average-audio-packets/frame))
            (let ((size (fxround (* estimated-rate estimated-packets/frame remember-audio))))
              (new Remember-Ring size)))))
    ((udp-video)
     (and remember-video
          (case source-kind
            ((image)
             (new Remember-Ring 8))
            ((draw)
             (new Remember-Ring 32))
            ((stream live)
             (let ((estimated-packets/frame (vector-ref average-video-packets/frame level)))
               (let ((size (fxround (* framerate estimated-packets/frame remember-video))))
                 (new Remember-Ring size))))
            (else
             #f))))))


(class Remember-Ring-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-size object))
                              (serialize (get-max-size object))
                              (serialize (get-packets object))
                              (serialize (get-head object))
                              (serialize (get-tail object))
                              (serialize (get-count object))
                              (serialize (get-lowest object))
                              (serialize (get-highest object))
                              (serialize (get-last-sequence object)))))
  
  
  (method override (unmarshall-object self content <vector>)
    (bind-vector (size max-size packets head tail count lowest highest last-sequence) content
      (allocate self
                (deserialize size)
                (deserialize max-size)
                (deserialize packets)
                (make-mutex 'ring)
                (deserialize head)
                (deserialize tail)
                (deserialize count)
                (deserialize lowest)
                (deserialize highest)
                (deserialize last-sequence)))))


(class Remember-Ring metaclass Remember-Ring-Class extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot max-size     <fx>        getter generate)
  (slot packets      <vector>    getter generate)
  (slot mutex        <object>    getter generate)
  (slot head         <fx>        getter generate)
  (slot tail         <fx>        getter generate)
  (slot count        <fx>        getter generate)
  (slot lowest       <fx>        getter generate)
  (slot highest      <fx>        getter generate)
  (slot last-sequence            getter generate)
  
  
  (method override (initialize self size <fx> (max-size: max-size #f) (overflow-proc: overflow-proc #f))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.packets (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.last-sequence #f))
  
  
  (method protected (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  (method protected (check self)
    (when (> count 0)
      (let ((low (get-sequence (lowest-packet self)))
            (high (get-sequence (highest-packet self))))
        (assert (= lowest low))
        (assert (= highest high)))))
  
  
  (method protected (lowest-packet self) <UDP-Packet>
    (vector-ref packets head))
  
  
  (method protected (highest-packet self) <UDP-Packet>
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (index self seq)
    (modulo (+ head (- seq lowest)) size))
  
  
  (method protected (packet-ref self n) <UDP-Packet>
    (vector-ref packets (modulo (+ head n) size)))
  
  
  (method public (locate-packet self sequence) <UDP-Packet+>
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (vector-ref packets pos)))
      (mutex-unlock! mutex)))

  
  ;;;
  ;;;; Remember
  ;;;
  
  
  (method public (remember self data)
    (mutex-lock! mutex)
    (with-record media
      (let ((dts (read-media-dts data))
            (pts (read-media-pts data))
            (duration (read-media-duration data))
            (sequence (read-media-sequence data))
            (frame (read-media-frame data))
            (part (read-media-part data))
            (total (read-media-total data))
            (flags (read-media-flags data)))
        (let ((in-order? (or (not last-sequence)
                             (> sequence last-sequence))))
          (cond ;; empty
                ((= count 0)
                 (when in-order?
                   (let ((packet (new UDP-Packet dts pts duration sequence frame part total flags data)))
                     (insert-before self head packet)
                     (set! last-sequence sequence)
                     (set! lowest sequence)
                     (set! highest sequence)
                     (check self))))
                ;; insert
                (in-order?
                 (let ((packet (new UDP-Packet dts pts duration sequence frame part total flags data)))
                   (let ((expected (+ last-sequence 1)))
                     (let ((gap (- sequence expected)))
                       (if (>= gap udp-max-gap-live)
                           (begin
                             (set! last-sequence sequence)
                             (remove-before self count))
                         (loop (for seq from (+ highest 1) below sequence)
                               (insert-before self tail (new UDP-Packet #f #f #f seq #f #f #f 0 #f)))
                         (insert-before self tail packet)
                         (set! last-sequence sequence)
                         (set! highest sequence)
                         (check self))))))
                ;; replace
                (else
                 (when (between? sequence lowest highest)
                   (let ((pos (index self sequence)))
                     (let ((actual-packet <UDP-Packet> (vector-ref packets pos)))
                       (when (not (get-data actual-packet))
                         (let ((packet (new UDP-Packet dts pts duration sequence frame part total flags data)))
                           (vector-set! packets pos packet)))))))))))
    (mutex-unlock! mutex))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert-before self pos packet)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN-RATIO)))))
        (let ((new-packets (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subvector-move! packets 0 tail new-packets 0)
          (subvector-move! packets tail size new-packets head)
          (set! size new-size)
          (set! packets new-packets))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (vector-set! packets head packet)
                  (increase! count))
                 ((= pos tail)
                  (vector-set! packets tail packet)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subvector-shift! packets head pos -1)
                        (vector-set! packets (- pos 1) packet)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subvector-shift! packets pos tail 1)
                    (vector-set! packets pos packet)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (vector-set! packets tail packet)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail)
           (increase! lowest))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method protected (remove-before self cnt <fx>)
    (loop (repeat cnt)
          (vector-set! packets head #f)
          (set! head (modulo (+ head 1) size))
          (decrease! count)
          (increase! lowest))
    (check self))
  
  
  (method public (collect-missing self)
    (mutex-lock! mutex)
    (unwind-protect (let ((missing (new-queue)))
                      (let (loop (n (- count 1)))
                        (if (< n 0)
                            (queue-list missing)
                          (let ((pos (modulo (+ head n) size)))
                            (let ((packet <UDP-Packet> (vector-ref packets pos)))
                              (when (not (get-data packet))
                                (enqueue missing (get-sequence packet)))
                              (loop (- n 1)))))))
      (mutex-unlock! mutex))))


(definition protected (copy-remember-ring ring <Remember-Ring>) <Remember-Ring>
  (mutex-lock! (get-mutex ring))
  (let ((copy (allocate Remember-Ring
                (get-size ring)
                (get-max-size ring)
                (vector-copy (get-packets ring))
                (make-mutex 'ring)
                (get-head ring)
                (get-tail ring)
                (get-count ring)
                (get-lowest ring)
                (get-highest ring)
                (get-last-sequence ring))))
    (mutex-unlock! (get-mutex ring))
    copy))


;;;
;;;; Ring
;;;


(proclaim (warn optimizations))


;;               ---> time
;;  wait +----+----+----+----+----+ insert
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL
;;   (earliest)                (latest)
;;    (lowest)                 (highest)


(class UDP-Ring extends Object
  
  
  (slot channel                   getter generate)
  (slot no                        getter generate)
  (slot origin                    getter generate)
  (slot media-kind                getter generate)
  (slot source-kind               getter generate)
  (slot size          <fx>        getter generate)
  (slot max-size      <fx>        getter generate)
  (slot max-gap       <fx>        getter generate)
  (slot packets       <vector>    getter generate)
  (slot mutex         <object>    getter generate)
  (slot wait-condvar  <object>    getter generate)
  (slot head          <fx>        getter generate)
  (slot tail          <fx>        getter generate)
  (slot count         <fx>        getter generate)
  (slot lowest        <fx>        getter generate)
  (slot highest       <fx>        getter generate)
  (slot state                     getter generate)
  (slot last-sequence <fx+>       getter generate)
  (slot time-base                 getter generate)
  (slot terminate?                getter generate)
  (slot overflow-proc             getter generate)
  (slot retain-window             getter generate)
  
  
  (method override (initialize self channel no origin media-kind source-kind size <fx> (max-size: max-size #f) (time-base: time-base #f) (overflow-proc: overflow-proc #f) (retain-window: retain-window #f))
    (nextmethod self)
    (set! self.channel channel)
    (set! self.no no)
    (set! self.origin origin)
    (set! self.media-kind media-kind)
    (set! self.source-kind (if live-streaming? 'live source-kind))
    (set! self.max-gap (if (eq? source-kind 'live) udp-max-gap-live udp-max-gap-non-live))
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.packets (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.wait-condvar (make-condition-variable 'wait))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.state (if (eq? media-kind udp-audio) 'ok 'wait))
    (set! self.last-sequence #f)
    (set! self.time-base (or time-base (if (simulation?) (new UDP-Visualizer-Base) (new UDP-Base))))
    (set! self.terminate? #f)
    (set! self.overflow-proc overflow-proc)
    (set! self.retain-window retain-window))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" state))))
  
  
  (method public (terminate self)
    (with-reentrant-mutex self
      (lambda ()
        (set! terminate? #t)
        (condition-variable-signal! wait-condvar))))
  
  
  (method protected virtual (empty self)
    (vector-fill! self.packets #f)
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.last-sequence #f))
  
  
  (method protected virtual (reset self)
    (empty self)
    (reset time-base))
  
  
  (method protected (check self)
    (when (> count 0)
      (let ((low (get-sequence (lowest-packet self)))
            (high (get-sequence (highest-packet self))))
        (assert (= lowest low))
        (assert (= highest high)))))
  
  
  (method protected (empty? self)
    (= count 0))
  
  
  (method protected (lowest-packet self) <UDP-Packet>
    (vector-ref packets head))
  
  
  (method protected (highest-packet self) <UDP-Packet>
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (index self seq <fx>) <fx>
    (modulo (+ head (- seq lowest)) size))
  
  
  @assert-mutex
  (method protected (assert-mutex self tag)
    (let ((thread (current-thread))
          (owner (mutex-state mutex)))
      (when (neq? owner thread)
        @w
        (terminal '***NOT-MUTEX-OWNER*** tag (execution-stack))
        (error "Ring mutex is owned by {a} instead of {a}" owner thread))))
  
  
  (method protected (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  (method package (with-reentrant-mutex self thunk)
    (if (eq? (mutex-state mutex) (current-thread))
        (thunk)
      (with-mutex self thunk)))

  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected virtual (local-timestamp self)
    (current-timestamp))
  
  
  (method public (insert self data insert-event)
    (mutex-lock! mutex)
    (insert-unlocked self data insert-event)
    (mutex-unlock! mutex))
  
  
  (method public (insert-unlocked self data insert-event)
    (with-record media
      (let ((local (local-timestamp self))
            (dts (read-media-dts data))
            (pts (read-media-pts data))
            (duration (read-media-duration data))
            (sender (read-header-sender data))
            (sequence (read-media-sequence data))
            (frame (read-media-frame data))
            (part (read-media-part data))
            (total (read-media-total data))
            (flags (read-media-flags data))
            (record? (if (not insert-event) record-events? record-retain?)))
        (define (time-update)
          (unless (emulation?)
            (update-time time-base local dts
              (lambda (raw-latency latency)
                (condition-variable-signal! wait-condvar)))))
        
        (define (insert/purge reason)
          (let ((packet (new UDP-Packet dts pts duration sequence frame part total flags data)))
            (empty self)
            (when reason
              (record-purge reason))
            (record-insert)
            (insert-before self tail packet)
            (set! last-sequence sequence)
            (set! lowest sequence)
            (set! highest sequence)
            (check self)
            (state-wait self)
            (condition-variable-signal! wait-condvar)))
        
        (define (insert-first-time)
          (insert/purge #f))
        
        (define (insert-highest packet)
          (record-insert)
          (insert-before self tail packet)
          (set! last-sequence sequence)
          (set! highest sequence)
          (check self)
          (condition-variable-signal! wait-condvar))
        
        (define (record-purge reason)
          (when record?
            (record-event udp-id-purge-ring
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          reason
                          -1.)))
        
        (define (record-insert)
          (when record?
            (record-events
              (lambda (record)
                (let ((raw-latency (get-raw-latency time-base))
                      (effective-latency (effective-latency time-base)))
                  (record (or insert-event udp-id-insert-packet)
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          (timestamp->flonum raw-latency)
                          (timestamp->flonum effective-latency)))
                (when record-media?
                  (let ((base (get-base time-base)))
                    (record udp-id-extra-info
                            (timestamp->flonum dts)
                            (timestamp->flonum base)
                            -1.
                            -1.
                            -1.
                            -1.
                            -1.)))))))
        
        (define (record-missing seq)
          (when record?
            (record-event udp-id-missing-packet
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum seq)
                          (fixnum->flonum sequence)
                          -1.
                          -1.)))
        
        (define (record-gap gap)
          (when record?
            (record-event udp-id-packet-gap
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          (fixnum->flonum gap)
                          -1.)))
        
        ;; not nack anything earlier than iframe
        (define (effective-gap gap)
          (if (and (> gap 0)
                   (= media-kind udp-video)
                   (frame-keyframe? flags)
                   (eq? source-kind 'live))
              (min part gap)
            gap))
        
        (cond ;; quick hack todo
              ((not local))
              ;; first time
              ((not last-sequence)
               (time-update)
               (insert-first-time))
              ;; in-order insert
              ((> sequence last-sequence)
               (let ((expected (+ (allege last-sequence) 1)))
                 (let ((gap (effective-gap (- sequence expected))))
                   (when (> gap 0)
                     (record-gap gap))
                   (if (>= gap max-gap)
                       (insert/purge udp-purge-gap)
                     (when (and (> gap 0) (or (= media-kind udp-video) (neq? source-kind 'live)))
                       (send-nack (current-udp) sender no expected gap self))
                     (let ((previous-raw-latency (get-raw-latency time-base)))
                       (time-update)
                       (let ((seek-change-heuristic (abs (- (get-raw-latency time-base) previous-raw-latency))))
                         (if (> seek-change-heuristic udp-seek-tolerance)
                             (begin
                               (reset channel)
                               (time-update)
                               (insert/purge udp-purge-seek))
                           (let ((packet (new UDP-Packet dts pts duration sequence frame part total flags data)))
                             (if (= count 0)
                                 (loop (for seq from (+ highest 1) below sequence)
                                       (record-missing seq)
                                       (insert-before self tail (new UDP-Packet dts pts #f seq #f #f #f 0 #f)))
                               (let ((highest-packet (highest-packet self)))
                                 (let ((highest-dts (get-dts highest-packet)))
                                   (loop (for seq from (+ highest 1) below sequence)
                                         (let ((dts (flonum->timestamp (interpolate seq highest sequence (timestamp->flonum highest-dts) (timestamp->flonum dts)))))
                                           (record-missing seq)
                                           (insert-before self tail (new UDP-Packet dts pts #f seq #f #f #f 0 #f)))))))
                             (insert-highest packet)))))))))
              ;; out-of-order replace
              (else
               (update-past time-base local dts)
               (if (between? sequence lowest highest)
                   (let ((pos (index self sequence)))
                     (let ((actual-packet <UDP-Packet> (vector-ref packets pos)))
                       (if (get-data actual-packet)
                           (when record?
                             (let ((resent (read-media-resent data)))
                               (record-event udp-id-duplicate-packet
                                             (fixnum->flonum no)
                                             (fixnum->flonum origin)
                                             (fixnum->flonum media-kind)
                                             (fixnum->flonum sequence)
                                             (fixnum->flonum frame)
                                             (fixnum->flonum resent)
                                             -1.)))
                         (let ((packet (new UDP-Packet dts pts duration sequence frame part total flags data)))
                           (vector-set! packets pos packet)
                           (when (= media-kind udp-audio)
                             (audio-added self packet))
                           (when record?
                             (let ((resent (read-media-resent data)))
                               (record-event udp-id-got-packet
                                             (fixnum->flonum no)
                                             (fixnum->flonum origin)
                                             (fixnum->flonum media-kind)
                                             (fixnum->flonum sequence)
                                             (fixnum->flonum frame)
                                             (fixnum->flonum resent)
                                             -1.)))
                           (condition-variable-signal! wait-condvar)))))
                 (when record?
                   (let ((resent (read-media-resent data)))
                     (record-event udp-id-reject-packet
                                   (fixnum->flonum no)
                                   (fixnum->flonum origin)
                                   (fixnum->flonum media-kind)
                                   (fixnum->flonum sequence)
                                   (fixnum->flonum frame)
                                   (fixnum->flonum resent)
                                   -1.)))))))))
  
  
  (method public (insert-before self pos <fx> packet <UDP-Packet>)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN-RATIO)))))
        (let ((new-packets (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subvector-move! packets 0 tail new-packets 0)
          (subvector-move! packets tail size new-packets head)
          (set! size new-size)
          (set! packets new-packets))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (vector-set! packets head packet)
                  (increase! count))
                 ((= pos tail)
                  (vector-set! packets tail packet)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subvector-shift! packets head pos -1)
                        (vector-set! packets (- pos 1) packet)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subvector-shift! packets pos tail 1)
                    (vector-set! packets pos packet)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (when overflow-proc
             (let ((bumped-packet <UDP-Packet> (vector-ref packets tail)))
               (overflow-proc self packet bumped-packet)))
           (vector-set! packets tail packet)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail)
           (increase! lowest)))
    ;; duration
    (when (= media-kind udp-audio)
      (audio-added self packet)))
  
  
  ;;;
  ;;;; Audio
  ;;;
  
  
  (method protected virtual (audio-added self packet)
    )
  
  
  (method protected virtual (audio-removed self packet)
    )
  
  
  ;;;
  ;;;; Visualizer
  ;;;
  
  
  (method protected (visualizer-packet-ref self n <fx>) <UDP-Packet+>
    (and (< n count)
         (vector-ref packets (modulo (+ head n) size))))
  
  
  (method protected (visualizer-earliest-packet self) <UDP-Packet+>
    (visualizer-packet-ref self 0))
  
  
  (method protected (visualizer-update-time self local remote base latency)
    (visualizer-update time-base local remote base latency))
  
  
  (method protected (visualizer-replace-got self sequence <fx> data)
    ;; quick robust test for visualizer
    (when (between? sequence lowest highest)
      (let ((pos (index self sequence)))
        (let ((actual-packet <UDP-Packet> (vector-ref packets pos)))
          (assert (eqv? (get-sequence actual-packet) sequence)
            (assert (not (get-data actual-packet))
              (with-record media
                (let ((dts (read-media-dts data))
                      (pts (read-media-pts data))
                      (duration (read-media-duration data))
                      (sequence (read-media-sequence data))
                      (frame (read-media-frame data))
                      (part (read-media-part data))
                      (total (read-media-total data))
                      (flags (read-media-flags data)))
                  (let ((packet (new UDP-Packet dts pts duration sequence frame part total flags data)))
                    (vector-set! packets pos packet))))))))))
  
  
  (method protected (visualizer-frame-complete? self pos <fx>)
    (let ((packet (packet-ref self pos)))
      (let ((part (get-part packet))
            (total (get-total packet)))
        (and (= part 0)
             (<= (+ pos total) count)
             (loop (for n from 0 below total)
                   (every (get-data (packet-ref self (+ pos n)))))))))
  
  
  (method protected (visualizer-remove-frame self)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (let ((part (get-part earliest))
            (total (get-total earliest)))
        (let ((cnt (- total part)))
          (remove-before self cnt)))))
  
  
  (method protected (visualizer-iterate-frame self proc)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (let ((part (get-part earliest))
            (total (get-total earliest)))
        (let ((cnt (- total part)))
          (loop (for n from 0 below cnt)
                (proc (packet-ref self n)))))))
  
  
  ;;;
  ;;;; Retain
  ;;;
  
  
  (method public (retain-wait self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((nowstamp (current-timestamp))
                (earliest <UDP-Packet> (vector-ref packets head)))
            (let ((release-time (determine-release-time self earliest)))
              (if (>= nowstamp release-time)
                  (prog1 earliest
                    (vector-set! packets head #f)
                    (set! head (modulo (+ head 1) size))
                    (decrease! count)
                    (increase! lowest)
                    (check self)
                    (mutex-unlock! mutex))
                (mutex-unlock! mutex wait-condvar (timestamp->flonum (- release-time nowstamp)))
                (loop-wait))))))))
  
  
  (method (determine-release-time self packet <UDP-Packet>) <fx>
    (let ((dts (get-dts packet)))
      (+ (remote->local time-base dts) retain-window)))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method protected (packet-ref self n <fx>) <UDP-Packet>
    (vector-ref packets (modulo (+ head n) size)))
  
  
  (method protected (earliest-packet self) <UDP-Packet>
    (vector-ref packets head))
  
  
  (method protected (latest-packet self) <UDP-Packet>
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (complete-frame? self)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (and (get-data earliest)
           (let ((part (get-part earliest))
                 (total (get-total earliest)))
             (and (= part 0)
                  (<= total count)
                  (loop (for n from 0 below total)
                        (every (get-data (packet-ref self n)))))))))
    
  
  (method (complete-keyframe self)
    (continuation-capture
      (lambda (found)
        (loop (for n from 0 below count)
              (let ((packet (packet-ref self n)))
                (when (and (get-data packet)
                           (is-keyframe? packet)
                           (= (get-part packet) 0))
                  (let ((frame (get-frame packet))
                        (total (get-total packet)))
                    (let ((last (+ n total -1)))
                      (when (and (< last count)
                                 (loop (for i from (+ n 1) to last)
                                       (every (let ((packet (packet-ref self i)))
                                                (and (get-data packet)
                                                     (= (get-frame packet) frame))))))
                        (continuation-return found n)))))))
        #f)))
  
  
  (method (extract-complete self)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (let ((frame (get-frame earliest))
            (total (get-total earliest)))
        (let ((datas (loop (for n from 0 below total)
                           (collect (get-data (packet-ref self n))))))
          (define (assemble-chunks)
            (with-record media
              (if (= total 1)
                  (read-media-payload (car datas))
                (let ((chunks (map (lambda (data)
                                     (read-media-payload data))
                                   datas)))
                  (apply u8vector-append chunks)))))
          
          (prog1 (let ((first (car datas))
                       (data (assemble-chunks)))
                   (with-record media
                     (let ((sender (read-header-sender first)))
                       (values sender earliest data))))
            (remove-before self total))))))
  
  
  (method (flush-before self cnt)
    (loop (repeat cnt)
          (flush-earliest self)))
  
  
  (method (flush-earliest self)
    (let ((earliest (packet-ref self 0)))
      (let ((sequence (get-sequence earliest))
            (frame (get-frame earliest))
            (flags (get-flags earliest))
            (dts (get-dts earliest)))
        (if (get-data earliest)
            (record-discard-packet self sequence frame flags dts)
          (record-lost-packet self sequence frame flags dts))
        (remove-earliest self))))
  
  
  (method protected (remove-before self cnt <fx>)
    (loop (repeat cnt)
          (when (= media-kind udp-audio)
            (let ((packet (vector-ref packets head)))
              (audio-removed self packet)))
          (vector-set! packets head #f)
          (set! head (modulo (+ head 1) size))
          (decrease! count)
          (increase! lowest))
    (check self))
  
  
  (method protected (remove-earliest self)
    (remove-before self 1))
  
  
  (method protected (state-ok self)
    (unless (eq? state 'ok)
      (set! state 'ok)
      (unless (emulation?)
        (when record-events?
          (record-event udp-id-state-ok
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        -1.)))))
  
  
  (method protected (state-wait self)
    (unless (eq? state 'wait)
      (set! state 'wait)
      (unless (emulation?)
        (when record-events?
          (record-event udp-id-state-wait
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        -1.)))))
  
  
  (method (record-lost-packet self sequence frame flags dts)
    (when record-events?
      (record-event udp-id-lost-packet
                    (fixnum->flonum no)
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (if (not frame)
                        -1.
                      (fixnum->flonum frame))
                    (fixnum->flonum flags)
                    (timestamp->flonum dts))))
  
  
  (method (record-discard-packet self sequence frame flags dts)
    (when record-events?
      (record-event udp-id-discard-packet
                    (fixnum->flonum no)
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    (fixnum->flonum flags)
                    (timestamp->flonum dts))))
  
  
  (method public (locate-packet self sequence <fx>) <UDP-Packet+>
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (vector-ref packets pos)))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-data self sequence <fx>)
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (let ((packet <UDP-Packet> (vector-ref packets pos)))
                    (get-data packet))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-earliest self predicate) <UDP-Packet+>
    (declare (proper-tail-calls))
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (if (>= n count)
                          #f
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (if (predicate packet)
                                packet
                              (loop (+ n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-latest self predicate) <UDP-Packet+>
    (declare (proper-tail-calls))
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n (- count 1)))
                      (if (< n 0)
                          #f
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (if (predicate packet)
                                packet
                              (loop (- n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-indexes self proc)
    (declare (proper-tail-calls))
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (when (< n count)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc n)
                            (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-earliest self proc)
    (declare (proper-tail-calls))
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (when (< n count)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc packet)
                            (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-latest self proc)
    (declare (proper-tail-calls))
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n (- count 1)))
                      (when (>= n 0)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc packet)
                            (loop (- n 1))))))
      (mutex-unlock! mutex))))


(proclaim (default warn optimizations))


;;;
;;;; Monitor
;;;


(class UDP-Monitor extends Object
  
  
  (slot bytes-sent     initialize 0 getter generate)
  (slot bytes-received initialize 0 getter generate)
  
  
  (method protected (increase-sent self data)
    (increase! bytes-sent (u8vector-length data)))
  
  
  (method protected (increase-received self data)
    (increase! bytes-received (u8vector-length data))))


;;;
;;;; UDP-Statistics
;;;


(class UDP-Statistics extends Object
  
  
  (slot last-ack-sequence          initialize #f  getter generate)
  (slot last-server-bytes-sent     initialize 0   getter generate)
  (slot last-server-bytes-received initialize 0   getter generate)
  (slot last-bytes-sent            initialize 0   getter generate)
  (slot last-bytes-received        initialize 0   getter generate)
  (slot round-trip-rate            initialize -1. getter generate)
  (slot last-upload-rate           initialize #f  getter generate)
  (slot last-download-rate         initialize #f  getter generate)
  (slot last-time                  initialize #f  getter generate)
  (slot upload-drop                initialize #f  getter generate)
  (slot download-drop              initialize #f  getter generate)
  
  
  (method protected (update self now monitor round-trip ack-sequence client-bytes-sent server-bytes-sent server-bytes-received)
    ;; ignore out-of-order acks that break the code logic
    (when (or (not last-ack-sequence)
              (> ack-sequence last-ack-sequence))
      (let ((bytes-sent client-bytes-sent)
            (bytes-received (get-bytes-received monitor)))
        ;; rates
        (if (not last-time)
            (begin
              (set! round-trip-rate -1.)
              (set! last-upload-rate -1.)
              (set! last-download-rate -1.)
              (set! last-time now))
          (when (> now last-time)
            (let ((fresh-bytes-sent (- bytes-sent last-bytes-sent))
                  (fresh-bytes-received (- bytes-received last-bytes-received))
                  (elapse (- now last-time)))
              (let ((fresh-upload-rate (/ (cast <fl> fresh-bytes-sent) elapse))
                    (fresh-download-rate (/ (cast <fl> fresh-bytes-received) elapse)))
                (set! round-trip-rate (if (= round-trip-rate -1.) round-trip (/ (+ (* 7. round-trip-rate) round-trip) 8.)))
                (set! last-upload-rate (if (= last-upload-rate -1.) fresh-upload-rate (/ (+ (* 31. last-upload-rate) fresh-upload-rate) 32.)))
                (set! last-download-rate (if (= last-download-rate -1.) fresh-download-rate (/ (+ (* 31. last-download-rate) fresh-download-rate) 32.)))
                (set! last-time now)))))
        ;; upload drop
        (let ((fresh-bytes-sent (- bytes-sent last-bytes-sent))
              (fresh-server-bytes-received (- server-bytes-received last-server-bytes-received)))
          (let ((fresh-upload-dropped (- fresh-bytes-sent fresh-server-bytes-received)))
            ;; cannot really happen as client heartbeat size is always included
            (when (> fresh-bytes-sent 0)
              (set! upload-drop ;; ignore incorrect first value
                    (if (not upload-drop)
                        0.
                      (let ((fresh-upload-drop (percentage fresh-upload-dropped fresh-bytes-sent)))
                        (/ (+ (* 31. upload-drop) fresh-upload-drop) 32.)))))))
        ;; download drop
        (let ((fresh-bytes-received (- bytes-received last-bytes-received))
              (fresh-server-bytes-sent (- server-bytes-sent last-server-bytes-sent)))
          (let ((fresh-download-dropped (- fresh-server-bytes-sent fresh-bytes-received)))
            ;; cannot really happen as server ack size is always included
            (when (> fresh-server-bytes-sent 0)
              (set! download-drop ;; ignore incorrect first value
                    (if (not download-drop)
                        0.
                      (let ((fresh-download-drop (percentage fresh-download-dropped fresh-server-bytes-sent)))
                        (/ (+ (* 31. download-drop) fresh-download-drop) 32.)))))))
        ;; preserve last
        (set! last-ack-sequence ack-sequence)
        (set! last-server-bytes-sent server-bytes-sent)
        (set! last-server-bytes-received server-bytes-received)
        (set! last-bytes-sent bytes-sent)
        (set! last-bytes-received bytes-received)))))


;;;
;;;; Simulator
;;;


(definition protected udp-simulator-size <fx>
  256)

(definition protected udp-simulator-max-size <fx>
  4096)


(class UDP-Simulator extends Object
  
  
  (property latency             getter generate)
  (property drop                getter generate)
  (property congestion          accessors generate)
  (property congestion-duration accessors generate)
  
  (slot simulation-start     getter generate)
  (slot simulation-count     getter generate)
  (slot simulation-last      getter generate)
  (slot simulation           getter generate)
  (slot latency-proc         getter generate)
  (slot congestion-occuring? getter generate)
  (slot congestion-ends      accessors generate)
  (slot writer               getter generate)
  (slot ring                 getter generate)
  (slot thread               getter generate)
  
  
  (method override (initialize self writer (wrapper #f))
    (nextmethod self)
    (set! self.latency #f)
    (set! self.latency-proc #f)
    (set! self.drop #f)
    (set! self.simulation #f)
    (set! self.simulation-start #f)
    (set! self.congestion #f)
    (set! self.congestion-duration 5.)
    (set! self.congestion-occuring? #f)
    (set! self.congestion-ends #f)
    (set! self.writer writer)
    (set! self.ring (new Time-Ring udp-simulator-size max-size: udp-simulator-max-size))
    (set! self.thread (new-thread
                        (lambda ()
                          (if (not wrapper)
                              (send-loop self)
                            (wrapper
                              (lambda ()
                                (send-loop self)))))
                        'simulator))
    (thread-base-priority-set! thread simulator-priority)
    (thread-start! thread))
  
  
  (method protected (setup-simulation self sim)
    (if (not sim)
        (begin
          (set! simulation #f)
          (set! simulation-start #f))
      (set! simulation-start (simulable-time))
      (set! simulation-count (/ (f64vector-length sim) 2))
      (set! simulation-last (- simulation-count 1))
      (set! simulation sim)))
  
  
  (method protected (setup-simulation-start self)
    (set! simulation-start (simulable-time)))
  
  
  (method protected (setup-latency self lat)
    (define (parse-latency lat)
      (if (and (pair? lat) (eq? (car lat) 'add))
          (add-latency (map determine-latency (cdr lat)))
        (determine-latency lat)))
    
    (define (determine-latency lat)
      (define (try name proc)
        (cond ((eq? lat name)
               (proc))
              ((and (pair? lat) (eq? (car lat) name))
               (apply proc (cdr lat)))
              (else
               #f)))
      
      (if (number? lat)
          (fixed-latency lat)
        (or (try 'rise rise-latency)
            (try 'fall fall-latency)
            (try 'updown updown-latency)
            (try 'plateau plateau-latency)
            (try 'sin sin-latency)
            (try 'random random-latency)
            (try 'recorded recorded-latency)
            lat)))
    
    (set! simulation #f)
    (set! simulation-start #f)
    (set! latency lat)
    (set! latency-proc (and lat (parse-latency lat))))
  
  
  (method protected (setup-drop self drp)
    (set! drop (and drp (cast <fl> drp))))
  
  
  (method protected (send self data info)
    (define (insert-latency now latency drop)
      (unless (and drop (< (random-real) drop))
        (let ((time (+ now latency))
              (obj (cons data info)))
          (insert-monotonic ring time obj))))
    
    (cond (simulation
           (let ((now (simulable-time)))
             (let ((time (- now simulation-start)))
               (let ((index (fxfloor (/ time udp-heartbeat-period))))
                 (let ((remain (- time (* index udp-heartbeat-period))))
                   (let ((n (modulo index simulation-count)))
                     (if (>= n simulation-last)
                         (let ((latency (f64vector-ref simulation (* simulation-last 2)))
                               (drop (f64vector-ref simulation (+ (* simulation-last 2) 1))))
                           (insert-latency now latency drop))
                       (let ((next (+ n 1)))
                         (let ((latency (f64vector-ref simulation (* n 2)))
                               (drop (f64vector-ref simulation (+ (* n 2) 1))))
                           (let ((next-latency (f64vector-ref simulation (* next 2)))
                                 (next-drop (f64vector-ref simulation (+ (* next 2) 1))))
                             (let ((interp-latency (interpolate remain 0. udp-heartbeat-period latency next-latency))
                                   (interp-drop (interpolate remain 0. udp-heartbeat-period drop next-drop)))
                               (insert-latency now interp-latency interp-drop))))))))))))
          (congestion
           (if (not congestion-occuring?)
               (if (or (eq? congestion #t)
                       (< (random-real) (/ congestion 100.)))
                   (let ((ends (if (eq? congestion-duration #t) +inf.0 (random-between 0. congestion-duration))))
                     (set! congestion-occuring? #t)
                     (set! congestion-ends ends))
                 (send-writer self data info))
             (when (or (not congestion-ends)
                       (>= (simulable-time) congestion-ends))
               (set! congestion-occuring? #f)
               (set! congestion-ends #f)
               (send-writer self data info))))
          (latency-proc
           (let ((latency (let ((time (- (current-monotonic) kernel-boot-monotonic)))
                            (latency-proc time))))
             (insert-latency (simulable-time) latency #f)))
          (else
           (insert-latency (simulable-time) 0. #f))))
  
  
  (method (drop? self)
    (and drop (< (random-real) (/ drop 100.))))
  
  
  (method (send-writer self data info)
    (let ((drop? (drop? self)))
      (writer data info drop?)))
  
  
  (method (send-loop self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((pair (wait ring)))
        (bind (data . info) pair
          (send-writer self data info)))
      (loop))))


;;;
;;;; Media
;;;


(definition public (media-packet-keyframe? data)
  (with-record media
    (and (= (read-media-part data) 0)
         (frame-keyframe? (read-media-flags data))))))
