;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.udp jazz


(import (jazz.geometry)
        (jazz.io)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.binary)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.math)
        (world.ring)
        (world.settings)
        (world.task)
        (world.time))


(definition protected udp-connect <fx>
  0)

(definition protected udp-connected <fx>
  1)

(definition protected udp-state <fx>
  2)

(definition protected udp-ack <fx>
  3)

(definition protected udp-nack <fx>
  4)

(definition protected udp-audio <fx>
  5)

(definition protected udp-video <fx>
  6)

(definition protected udp-profile-heartbeat <fx>
  7)

(definition protected udp-profile-media <fx>
  8)


(definition udp-names
  #(connect connected state ack nack audio video profile-heartbeat profile-media))

(definition protected (udp-name kind)
  (vector-ref udp-names kind))


;; MTU - IP HEADER - UDP HEADER
;; 1500 - 20 (60) - 8 = 1472 (1432)
(definition protected udp-datagram-max
  (world-setting 'world.udp-datagram-max 1432))

(definition protected udp-retain-size
  (world-setting 'world.udp-retain-size 256))

(definition protected udp-retain-max-size
  (world-setting 'world.udp-retain-max-size 8192))

(definition protected udp-sender-retain-window
  (world-setting 'world.udp-sender-retain-window 5.))

(definition protected udp-server-retain-window
  (world-setting 'world.udp-server-retain-window 1.))

;; this value should be consistent with
;; gstreamer's audio sink buffer-time and
;; lets give it a slightly smaller value
(definition protected udp-audio-giveup
  (world-setting 'world.udp-audio-giveup .19))

(definition protected udp-video-giveup
  (world-setting 'world.udp-video-giveup .5))

(definition protected udp-video-late
  (world-setting 'world.udp-video-late .05))

(definition protected udp-process-size
  (world-setting 'world.udp-process-size 256))

(definition protected udp-process-max-size
  (world-setting 'world.udp-process-max-size 4096))

(definition protected udp-process-window
  (world-setting 'world.udp-process-window .4))

(definition protected udp-process-window-nanoseconds
  (fxround (* udp-process-window nanosecond)))

(definition protected udp-latency-threshold
  (world-setting 'world.udp-latency-threshold .01))

(definition protected udp-latency-increment
  (world-setting 'world.udp-latency-increment .01))

(definition protected udp-latency-decrement
  (world-setting 'world.udp-latency-decrement .01))

(definition protected udp-simulator-size
  (world-setting 'world.udp-simulator-size 256))

(definition protected udp-simulator-max-size
  (world-setting 'world.udp-simulator-max-size 4096))

(definition protected udp-max-gap
  (world-setting 'world.udp-max-gap #f))

(definition protected udp-state-rate
  (world-setting 'world.udp-state-rate 5.))

(definition protected udp-state-period
  (/ 1. udp-state-rate))

(definition protected udp-throttle
  (world-setting 'world.udp-throttle 1.))


(definition protected udp-record-read/write?
  (world-setting 'world.udp-record-read/write? #f))


(definition protected udp-show-roundtrip?
  (world-setting 'world.udp-show-roundtrip? #f))

(definition protected udp-show-invalids?
  (world-setting 'world.udp-show-invalids? #f))

(definition protected udp-show-overflows?
  (world-setting 'world.udp-show-overflows? #f))

(definition protected udp-show-gaps?
  (world-setting 'world.udp-show-gaps? #f))

;; duplicates are usually a normal consequence of nacks
(definition protected udp-show-duplicates?
  (world-setting 'world.udp-show-duplicates? #f))

(definition protected udp-show-late?
  (world-setting 'world.udp-show-late? #f))

(definition protected udp-show-missing?
  (world-setting 'world.udp-show-missing? #f))

(definition protected udp-show-resend?
  (world-setting 'world.udp-show-resend? #f))

(definition protected udp-show-retries?
  (world-setting 'world.udp-show-retries? #f))

(definition protected udp-show-states?
  (world-setting 'world.udp-show-states? #f))

(definition protected udp-show-resetting?
  (world-setting 'world.udp-show-resetting? #f))

(definition protected udp-show-resets?
  (world-setting 'world.udp-show-resets? #f))

(definition protected udp-show-throttle?
  (world-setting 'world.udp-show-throttle? #f))

(definition protected udp-show-skipping?
  (world-setting 'world.udp-show-skipping? #f))

(definition protected udp-show-congestion?
  (world-setting 'world.udp-show-congestion? #f))

(definition protected udp-show-nacks?
  (world-setting 'world.udp-show-nacks? #f))

(definition protected udp-show-profile?
  (world-setting 'world.udp-show-profile? #f))

(definition protected udp-show-replay?
  (world-setting 'world.udp-show-replay? #f))

(definition protected udp-freeze-overlay
  (world-setting 'world.udp-freeze-overlay #f))

(definition protected udp-wait-overlay
  (world-setting 'world.udp-wait-overlay #f))

(definition protected udp-latency
  (world-setting 'world.udp-latency #f))

(definition protected udp-latency-count
  (world-setting 'world.udp-latency-count 50))

(definition protected udp-lag
  (world-setting 'world.udp-lag #f))

(definition protected udp-drop
  (world-setting 'world.udp-drop #f))

(definition protected udp-congestion
  (world-setting 'world.udp-congestion #f))

(definition protected udp-congestion-duration
  (world-setting 'world.udp-congestion-duration 5.))


(definition protected udp-media-off
  #u8(111 102 102))


(definition protected (present-media-kind kind)
  (if (= kind udp-audio)
      'AUDIO
    'VIDEO))


(definition protected (bytes->mbps bytes <fl>) <fl>
  (/ bytes 131072.))

(definition protected (mbps->bytes mbps <fl>) <fx>
  (fxround (* mbps 131072.)))


(definition public inline (evolutionary-udp-time    evolution <Evolution> n <fx>) <fl> (evolutionary-time  evolution n))
(definition public inline (evolutionary-udp-id      evolution <Evolution> n <fx>) <fl> (evolutionary-id    evolution n))
(definition public inline (evolutionary-udp-channel evolution <Evolution> n <fx>) <fl> (evolutionary-data1 evolution n))
(definition public inline (evolutionary-udp-origin  evolution <Evolution> n <fx>) <fl> (evolutionary-data2 evolution n))
(definition public inline (evolutionary-udp-kind    evolution <Evolution> n <fx>) <fl> (evolutionary-data3 evolution n))
(definition public inline (evolutionary-udp-data1   evolution <Evolution> n <fx>) <fl> (evolutionary-data4 evolution n))
(definition public inline (evolutionary-udp-data2   evolution <Evolution> n <fx>) <fl> (evolutionary-data5 evolution n))
(definition public inline (evolutionary-udp-data3   evolution <Evolution> n <fx>) <fl> (evolutionary-data6 evolution n))
(definition public inline (evolutionary-udp-data4   evolution <Evolution> n <fx>) <fl> (evolutionary-data7 evolution n))
(definition public inline (evolutionary-udp-data5   evolution <Evolution> n <fx>) <fl> (evolutionary-data8 evolution n))
(definition public inline (evolutionary-udp-data6   evolution <Evolution> n <fx>) <fl> (evolutionary-data9 evolution n))

(definition public inline (evolutionary-udp-sequence evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data1 evolution n)))
(definition public inline (evolutionary-udp-frame    evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data2 evolution n)))


(definition public (evolutionary-udp-receive-ack-state-sequence     evolution <Evolution> n <fx>) (evolutionary-udp-data1 evolution n))
(definition public (evolutionary-udp-receive-ack-round-trip         evolution <Evolution> n <fx>) (evolutionary-udp-data2 evolution n))

(definition public (evolutionary-udp-traffic-rate-state-sequence    evolution <Evolution> n <fx>) (evolutionary-udp-data1 evolution n))
(definition public (evolutionary-udp-traffic-rate-last-send-rate    evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-traffic-rate-last-receive-rate evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))

(definition public (evolutionary-udp-insert-packet-latency          evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-insert-packet-timestamp        evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))
(definition public (evolutionary-udp-insert-packet-base             evolution <Evolution> n <fx>) (evolutionary-udp-data5 evolution n))
(definition public (evolutionary-udp-insert-packet-last-latency     evolution <Evolution> n <fx>) (evolutionary-udp-data6 evolution n))


;; relies on 0 reserved for #f in next-literal-id
(definition protected server-no
  0)

(definition protected server-sender
  "Server")


(definition protected (barbara-header-hack header?)
  (if header?
      123456.
    -1.))


;;;
;;;; Ring
;;;


(definition protected udp-ring-kind-retain
  0.)

(definition protected udp-ring-kind-process
  1.)

(definition protected udp-ring-kind-simulator
  2.)


(definition protected (udp-ring-overflow name kind)
  (lambda (ring data)
    (record-event udp-id-ring-overflow
                  -1.
                  -1.
                  -1.
                  (if (= kind udp-ring-kind-simulator)
                      -1.
                    (fixnum->flonum (read-udp-sequence data)))
                  (fixnum->flonum (get-count ring))
                  kind
                  -1.)
    (when udp-show-overflows?
      (format :terminal "{s} {s} {s}{%}" remote-name '***overflow*** name))))


;;;
;;;; Tolerance
;;;


;; retry write every 1/100s for 1s
;; at the moment centro will return a network is unreachable
;; or down error after about 10mn and then every minute or so
;; this is also a try at understanding the No buffer space
;; available exception that can occur from time to time
(definition protected (retrying-write data port)
  (declare (proper-tail-calls))
  (let (loop (n 0))
    (with-exception-filter
      (lambda (exc)
        (< n 100))
      (lambda (exc)
        (sleep .01)
        (if (< n 99)
            (loop (+ n 1))
          (record-event udp-id-write-failure
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.)
          (when udp-show-retries?
            (format :terminal "{s} {s} {s}{%}" remote-name '***retry*** exc))
          exc))
      (lambda ()
        (write data port)
        (when udp-record-read/write?
          (let ((channel (read-udp-channel data))
                (origin (read-udp-origin data))
                (media-kind (read-udp-kind data))
                (sequence (read-udp-sequence data))
                (frame (read-udp-frame data)))
            (record-event udp-id-write-data
                          (fixnum->flonum channel)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          -1.
                          (fixnum->flonum (u8vector-length data)))))
        #f))))


;;;
;;;; Tier
;;;


(definition public (current-udp)
  (get-udp-tier (current-tier)))


(class UDP-Tier extends Object
  
  
  (slot send-streams  initialize #f getter generate)
  (slot send-channels initialize #f getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! send-streams (make-table))
    (set! send-channels (make-table)))
  
  
  (method package (register-send-stream self sender name stream-no source-kind video-level)
    (let ((stream (new UDP-Send-Stream sender name stream-no client-no source-kind video-level)))
      (table-set! send-streams stream-no stream)
      stream))
  
  
  (method public (find-send-stream self stream-no)
    (table-ref send-streams stream-no #f))
  
  
  (method public (locate-send-stream self predicate)
    (table-search (lambda (no stream)
                    (and (predicate stream)
                         stream))
                  send-streams))
  
  
  (method public (find-send-channel self channel-no)
    (table-ref send-channels channel-no #f))
  
  
  (method public (find-streaming self location)
    (table-search (lambda (no stream)
                    (let ((stream-location (get-location stream)))
                      (and stream-location
                           (filename=? location stream-location)
                           stream)))
                  send-streams))
  
  
  (method public (collect-streaming self)
    (let ((queue (new-queue)))
      (iterate-table send-channels
        (lambda (no channel)
          (when (get-stream? (get-src (get-pipeline channel)))
            (enqueue queue channel))))
      (queue-list queue)))
  
  
  (method protected (gather-replay-missing self missing)
    (let ((queue (new-queue)))
      (for-each (lambda (info)
                  (bind (channel-no . missing) info
                    (let ((channel (find-send-channel self channel-no)))
                      (when channel
                        (let ((ring (get-replay-ring channel)))
                          (for-each (lambda (sequence)
                                      (let ((packet (locate-packet ring sequence)))
                                        (when packet
                                          (enqueue queue (get-data packet)))))
                                    missing))))))
                missing)
      (queue-list queue))))


;;;
;;;; Stream
;;;


(definition protected next-stream-no <fx>
  0)

(definition protected (next-stream-no!) <fx>
  (prog1 next-stream-no
    (increase! next-stream-no)))


(class UDP-Stream extends Object
  
  
  (slot sender      getter generate)
  (slot name        getter generate)
  (slot no          getter generate)
  (slot origin      getter generate)
  (slot source-kind getter generate)
  (slot video-level getter generate)
  (slot channels    getter generate)
  
  
  (method override (initialize self sender name no origin source-kind video-level)
    (nextmethod self)
    (set! self.sender sender)
    (set! self.name name)
    (set! self.no no)
    (set! self.origin origin)
    (set! self.source-kind source-kind)
    (set! self.video-level video-level)
    (set! self.channels (make-table test: eqv?)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a} {a} {a}" sender name no origin source-kind video-level))))
  
  
  (method protected (add-child self channel)
    (table-set! channels (get-no channel) channel))
  
  
  (method protected (play self)
    (iterate-table channels
      (lambda (no channel)
        (play channel))))
  
  
  (method public (effective-name self)
    (if (eq? source-kind 'live)
        sender
      name)))


;;;
;;;; Send Stream
;;;


(class UDP-Send-Stream extends UDP-Stream
  
  
  (slot location    initialize #f accessors generate)
  (slot action-proc initialize #f accessors generate)
  
  
  (method protected (locate-audio-channel self)
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-audio)
                         channel))
                  channels))
  
  
  (method protected (locate-video-channel self)
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-video)
                         channel))
                  channels))
  
  
  (method protected (collect-video-channels self)
    (let ((queue (new-queue)))
      (iterate-table channels
        (lambda (no channel)
          (when (= (get-media-kind channel) udp-video)
            (enqueue queue channel))))
      (queue-list queue))))


;;;
;;;; Channel
;;;


(definition protected next-channel-no <fx>
  0)

(definition protected (next-channel-no!) <fx>
  (prog1 next-channel-no
    (increase! next-channel-no)))


(class UDP-Channel extends Object
  
  
  (slot stream      getter generate)
  (slot no          getter generate)
  (slot origin      getter generate)
  (slot media-kind  getter generate)
  (slot source-kind getter generate)
  (slot level       getter generate)
  (slot resolution  getter generate)
  (slot framerate   getter generate)
  (slot bitrate     getter generate)
  (slot codec       getter generate)
  (slot caps        getter generate)
  
  
  (method override (initialize self stream no origin media-kind source-kind level resolution framerate bitrate codec caps)
    (nextmethod self)
    (set! self.stream stream)
    (set! self.no no)
    (set! self.origin origin)
    (set! self.media-kind media-kind)
    (set! self.source-kind source-kind)
    (set! self.level level)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.caps caps)
    (add-child stream self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (if (= media-kind udp-video)
            (format output "{a} {a} {a} {a} {a} {a} {a} {a}" (get-sender stream) (get-name stream) no origin media-kind source-kind level resolution)
          (format output "{a} {a} {a} {a} {a} {a}" (get-sender stream) (get-name stream) no origin media-kind source-kind))))))


(definition protected (streams-metadata streams)
  (map-table (lambda (no stream)
               (list
                 (get-sender stream)
                 (get-name stream)
                 (get-no stream)
                 (get-origin stream)
                 (get-source-kind stream)
                 (get-video-level stream)
                 (map-table (lambda (no channel)
                              (list
                                (get-no channel)
                                (get-origin channel)
                                (get-media-kind channel)
                                (get-source-kind channel)
                                (get-level channel)
                                (get-resolution channel)
                                (get-framerate channel)
                                (get-bitrate channel)
                                (get-codec channel)
                                (get-caps channel)))
                            (get-channels stream))))
             streams))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Channel
  
  
  (slot pipeline       accessors generate)
  (slot action-proc    accessors generate)
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-timestamp accessors generate)
  (slot last-reset     getter generate)
  (slot wait-header?   getter generate)
  (slot replay-ring    getter generate)
  (slot retain-ring    getter generate)
  (slot release-task   getter generate)
  
  
  (method override (initialize self stream no origin media-kind source-kind level resolution framerate bitrate codec caps)
    (nextmethod self stream no origin media-kind source-kind level resolution framerate bitrate codec caps)
    (set! self.pipeline #f)
    (set! self.action-proc #f)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f)
    (set! self.last-reset #f)
    (set! self.wait-header? (= media-kind udp-video))
    (set! self.replay-ring (new Remember-Ring 6000))
    (set! self.retain-ring (new UDP-Ring self no origin media-kind udp-retain-size max-size: udp-retain-max-size overflow-proc: (udp-ring-overflow 'retain udp-ring-kind-retain) retain-window: udp-sender-retain-window))
    (unless (simulation?)
      (set! self.release-task (new Task 'udp-release (lambda (task)
                                                       (release-loop self task))
                                   priority: udp-priority))
      (start-task release-task)))
  
  
  (method override (destroy self)
    (when pipeline
      (release pipeline)
      (close pipeline))
    (terminate retain-ring)
    (thread-join! (get-thread release-task))
    (nextmethod self))
  
  
  (method protected (waiting-header? self)
    wait-header?)
  
  
  (method protected (wait-header self)
    (when (= media-kind udp-video)
      (set! wait-header? #t)))
  
  
  (method protected (got-header self)
    (set! wait-header? #f))
  
  
  (method (playing? self)
    (if (not pipeline)
        #f
      (playing? (get-src pipeline))))
  
  
  (method (setup self)
    (when pipeline
      (setup pipeline)))
  
  
  (method (start self)
    (when pipeline
      (start pipeline)))
  
  
  (method (play self)
    (when pipeline
      (play pipeline)))
  
  
  (method (pause self)
    (when pipeline
      (pause pipeline)))
  
  
  (method (stop self)
    (when pipeline
      (stop pipeline)))
  
  
  (method (release self)
    (when pipeline
      (release pipeline)))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (remember-media self data)
    (remember replay-ring data))
  
  
  (method protected (retain-media self data)
    (insert retain-ring data udp-id-retain-packet))
  
  
  (method protected (send-media self buffer header? timestamp duration send)
    (let ((off? (not buffer))
          (frame (next-frame-sequence! self))
          ;; give media off a sequential timestamp so it gets inserted correctly
          (timestamp (or timestamp (+ (or last-timestamp 0) 1)))
          (duration (or duration 1))
          ;; udp-media-off is not really used for its content anymore
          ;; but it is still useful as an empty buffer ends the logic
          (buffer (or buffer udp-media-off)))
      ;; -1 means no timestamp used by vorbis header
      (unless (= timestamp -1)
        (set! last-timestamp timestamp))
      (let ((header-size (+ 8 4 2 2 4 4 4 4 8 8 4))
            (payload-size (u8vector-length buffer)))
        (let ((max-content-size (- udp-datagram-max header-size)))
          (let ((total (fxceiling/ payload-size max-content-size)))
            (let (loop-part (part 0) (pos 0))
              (let ((remain (- payload-size pos)))
                (when (> remain 0)
                  (let ((sequence (next-data-sequence! self))
                        (content-size (min remain max-content-size)))
                    (let ((size (+ header-size content-size)))
                      (let ((data (make-u8vector size)))
                        (write-udp-sent data (current-seconds))
                        (write-udp-kind data media-kind)
                        (write-udp-origin data client-no)
                        (write-udp-channel data no)
                        (write-udp-sequence data sequence)
                        (write-udp-frame data frame)
                        (write-udp-part data part)
                        (write-udp-total data total)
                        (write-udp-media-timestamp data timestamp)
                        (write-udp-media-duration data duration)
                        (write-udp-media-subpayload data buffer pos content-size)
                        (write-udp-media-header? data header?)
                        (write-udp-media-off? data off?)
                        (write-udp-resent data 0)
                        ;; quick hack to make media off and timeless more robust
                        (if (or off? (= timestamp -1))
                            (loop (repeat 3)
                                  (send data))
                          (send data))
                        (record-event udp-id-create-packet
                                      (fixnum->flonum no)
                                      (fixnum->flonum client-no)
                                      (fixnum->flonum media-kind)
                                      (fixnum->flonum sequence)
                                      (fixnum->flonum frame)
                                      (barbara-header-hack header?)
                                      (if (= timestamp -1)
                                          -1.
                                        (timestamp->flonum timestamp)))
                        (record-event udp-id-create-info
                                      (fixnum->flonum no)
                                      (fixnum->flonum client-no)
                                      (fixnum->flonum media-kind)
                                      (fixnum->flonum sequence)
                                      (fixnum->flonum part)
                                      (fixnum->flonum total)
                                      (if (= duration -1)
                                          -1.
                                        (timestamp->flonum duration)))
                        (remember-media self data)
                        (retain-media self data)
                        (loop-part (+ part 1) (+ pos content-size)))))))))))))
  
  
  (method (reset-media self)
    (when pipeline
      (let ((src (get-src pipeline)))
        (when (and (resettable? src)
                   (playing? src))
          (let ((now (current-seconds)))
            (if (and last-reset (< (- now last-reset) (reset-cooldown src)))
                (when udp-show-resetting?
                  (format :terminal "{s} {s} {s} {s} - {a} ({a}){%}" remote-name (present-media-kind media-kind) 'RESET 'COOLDOWN (effective-name stream) no))
              (reset-media src self)
              (set! last-reset now)
              (record-event udp-id-reset-media
                            (fixnum->flonum no)
                            (fixnum->flonum client-no)
                            (fixnum->flonum media-kind)
                            -1.
                            -1.
                            -1.
                            -1.)
              (when udp-show-resets?
                (format :terminal "{s} {s} {s} {s} -     {a} ({a}){%}" remote-name (present-media-kind media-kind) 'RESET 'DONE (effective-name stream) no))))))))
  
  
  (method protected (release-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((packet (retain-wait retain-ring)))
            (if (eq? packet 'terminate)
                (continuation-return exit #f)
              (site (udp-release on?: #t)
                (release-media self packet))
              (loop)))))))
  
  
  (method protected (release-media self packet)
    (let ((data (get-data packet)))
      (if (not data)
          (let ((removed-sequence (get-sequence packet)))
            (record-event udp-id-giveup-packet
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum removed-sequence)
                          -1.
                          -1.
                          -1.))
        (let ((origin (read-udp-origin data))
              (sequence (read-udp-sequence data))
              (frame (read-udp-frame data))
              (timestamp (read-udp-media-timestamp data)))
          (record-event udp-id-release-packet
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        (fixnum->flonum sequence)
                        (fixnum->flonum frame)
                        -1.
                        (timestamp->flonum timestamp)))))))


;;;
;;;; Remember
;;;

;; temporary copy/paste of UDP-Ring


(class Remember-Ring-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-size object))
                              (serialize (get-max-size object))
                              (serialize (get-packets object))
                              (serialize (get-head object))
                              (serialize (get-tail object))
                              (serialize (get-count object))
                              (serialize (get-lowest object))
                              (serialize (get-highest object))
                              (serialize (get-last-sequence object)))))
  
  
  (method override (unmarshall-object self content <vector>)
    (bind-vector (size max-size packets head tail count lowest highest last-sequence) content
      (allocate self
                (deserialize size)
                (deserialize max-size)
                (deserialize packets)
                (make-mutex 'ring)
                (deserialize head)
                (deserialize tail)
                (deserialize count)
                (deserialize lowest)
                (deserialize highest)
                (deserialize last-sequence)))))


(class Remember-Ring metaclass Remember-Ring-Class extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot max-size     <fx>        getter generate)
  (slot packets      <vector>    getter generate)
  (slot mutex        <object>    getter generate)
  (slot head         <fx>        getter generate)
  (slot tail         <fx>        getter generate)
  (slot count        <fx>        getter generate)
  (slot lowest       <fx>        getter generate)
  (slot highest      <fx>        getter generate)
  (slot last-sequence            getter generate)
  
  
  (method override (initialize self size <fx> (max-size: max-size #f) (overflow-proc: overflow-proc #f))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.packets (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.last-sequence #f))
  
  
  (method protected (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  (method protected (check self)
    (when (> count 0)
      (let ((low (get-sequence (lowest-packet self)))
            (high (get-sequence (highest-packet self))))
        (assert (= lowest low))
        (assert (= highest high)))))
  
  
  (method protected (lowest-packet self)
    (vector-ref packets head))
  
  
  (method protected (highest-packet self)
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (index self seq)
    (modulo (+ head (- seq lowest)) size))
  
  
  (method protected (packet-ref self n)
    (vector-ref packets (modulo (+ head n) size)))
  
  
  (method public (locate-packet self sequence)
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (vector-ref packets pos)))
      (mutex-unlock! mutex)))

  
  ;;;
  ;;;; Remember
  ;;;
  
  
  (method public (remember self data)
    (mutex-lock! mutex)
    (let ((timestamp (read-udp-media-seconds data))
          (duration (read-udp-media-duration data))
          (sequence (read-udp-sequence data))
          (frame (read-udp-frame data))
          (part (read-udp-part data))
          (total (read-udp-total data))
          (header? (read-udp-media-header? data)))
      (let ((in-order? (or (not last-sequence)
                           (> sequence last-sequence))))
        (cond ;; empty
              ((= count 0)
               (when in-order?
                 (let ((packet (new UDP-Packet timestamp duration sequence frame part total header? data)))
                   (insert-before self head packet)
                   (set! last-sequence sequence)
                   (set! lowest sequence)
                   (set! highest sequence)
                   (check self))))
              ;; insert
              (in-order?
               (let ((packet (new UDP-Packet timestamp duration sequence frame part total header? data)))
                 (let ((expected (+ last-sequence 1)))
                   (let ((gap (- sequence expected)))
                     (if (and udp-max-gap (>= gap udp-max-gap))
                         (begin
                           (set! last-sequence sequence)
                           (remove-count self count))
                       (let ((highest-packet (highest-packet self)))
                         (let ((highest-timestamp (get-timestamp highest-packet)))
                           (loop (for seq from (+ highest 1) below sequence)
                                 (insert-before self tail (new UDP-Packet #f #f seq #f #f #f #f #f)))))
                       (insert-before self tail packet)
                       (set! last-sequence sequence)
                       (set! highest sequence)
                       (check self))))))
              ;; replace
              (else
               (when (between? sequence lowest highest)
                 (let ((pos (index self sequence)))
                   (let ((actual-packet (vector-ref packets pos)))
                     (when (not (get-data actual-packet))
                       (let ((packet (new UDP-Packet timestamp duration sequence frame part total header? data)))
                         (vector-set! packets pos packet))))))))))
    (mutex-unlock! mutex))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert-before self pos packet)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-packets (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subvector-move! packets 0 tail new-packets 0)
          (subvector-move! packets tail size new-packets head)
          (set! size new-size)
          (set! packets new-packets))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (vector-set! packets head packet)
                  (increase! count))
                 ((= pos tail)
                  (vector-set! packets tail packet)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subvector-shift! packets head pos -1)
                        (vector-set! packets (- pos 1) packet)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subvector-shift! packets pos tail 1)
                    (vector-set! packets pos packet)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (vector-set! packets tail packet)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail)
           (increase! lowest))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method public (collect-missing self)
    (mutex-lock! mutex)
    (unwind-protect (let ((missing (new-queue)))
                      (let (loop (n (- count 1)))
                        (if (< n 0)
                            (queue-list missing)
                          (let ((pos (modulo (+ head n) size)))
                            (let ((packet (vector-ref packets pos)))
                              (when (not (get-data packet))
                                (enqueue missing (get-sequence packet)))
                              (loop (- n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (count-missing self)
    (mutex-lock! mutex)
    (unwind-protect (let ((missing 0))
                      (let (loop (n (- count 1)))
                        (if (< n 0)
                            missing
                          (let ((pos (modulo (+ head n) size)))
                            (let ((packet (vector-ref packets pos)))
                              (when (not (get-data packet))
                                (increase! missing))
                              (loop (- n 1)))))))
      (mutex-unlock! mutex))))


(definition protected (copy-remember-ring ring <Remember-Ring>) <Remember-Ring>
  (mutex-lock! (get-mutex ring))
  (let ((copy (allocate Remember-Ring
                (get-size ring)
                (get-max-size ring)
                (vector-copy (get-packets ring))
                (make-mutex 'ring)
                (get-head ring)
                (get-tail ring)
                (get-count ring)
                (get-lowest ring)
                (get-highest ring)
                (get-last-sequence ring))))
    (mutex-unlock! (get-mutex ring))
    copy))


;;;
;;;; Ring
;;;


;;               ---> time
;;  wait +----+----+----+----+----+ insert
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL
;;   (earliest)                (latest)
;;    (lowest)                 (highest)


(class UDP-Ring extends Object
  
  
  (slot channel                  getter generate)
  (slot no                       getter generate)
  (slot origin                   getter generate)
  (slot media-kind               getter generate)
  (slot size         <fx>        getter generate)
  (slot max-size     <fx>        getter generate)
  (slot packets      <vector>    getter generate)
  (slot mutex        <object>    getter generate)
  (slot wait-condvar <object>    getter generate)
  (slot head         <fx>        getter generate)
  (slot tail         <fx>        getter generate)
  (slot count        <fx>        getter generate)
  (slot lowest       <fx>        getter generate)
  (slot highest      <fx>        getter generate)
  (slot state                    getter generate)
  (slot last-sequence            getter generate)
  (slot last-frame               getter generate)
  (slot time-base                getter generate)
  (slot terminate?               getter generate)
  (slot overflow-proc            getter generate)
  (slot retain-window            getter generate)
  
  
  (method override (initialize self channel no origin media-kind size <fx> (max-size: max-size #f) (overflow-proc: overflow-proc #f) (retain-window: retain-window #f))
    (nextmethod self)
    (set! self.channel channel)
    (set! self.no no)
    (set! self.origin origin)
    (set! self.media-kind media-kind)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.packets (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.wait-condvar (make-condition-variable 'wait))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.state 'waiting)
    (set! self.last-sequence #f)
    (set! self.last-frame #f)
    (set! self.time-base (new Time-Base))
    (set! self.terminate? #f)
    (set! self.overflow-proc overflow-proc)
    (set! self.retain-window retain-window))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" state))))
  
  
  (method public (terminate self)
    (mutex-lock! mutex)
    (set! terminate? #t)
    (condition-variable-signal! wait-condvar)
    (mutex-unlock! mutex))
  
  
  (method public (empty self)
    (vector-fill! self.packets #f)
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0))
  
  
  (method protected (check self)
    (when (> count 0)
      (let ((low (get-sequence (lowest-packet self)))
            (high (get-sequence (highest-packet self))))
        (assert (= lowest low))
        (assert (= highest high)))))
  
  
  (method protected (lowest-packet self)
    (vector-ref packets head))
  
  
  (method protected (highest-packet self)
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (index self seq)
    (modulo (+ head (- seq lowest)) size))

  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert self data (insert-event #f))
    (let ((now (current-seconds))
          (timestamp (read-udp-media-seconds data)))
      (mutex-lock! mutex)
      (unless (emulation?)
        (when timestamp
          (update-time time-base now timestamp
            (lambda (current-latency effective-latency)
              (condition-variable-signal! wait-condvar)
              (let ((origin (read-udp-origin data))
                    (sequence (read-udp-sequence data)))
                (record-event udp-id-update-time
                              (fixnum->flonum no)
                              (fixnum->flonum origin)
                              (fixnum->flonum media-kind)
                              (fixnum->flonum sequence)
                              now
                              current-latency
                              timestamp
                              effective-latency))))))
      (let ((duration (read-udp-media-duration data))
            (sequence (read-udp-sequence data))
            (frame (read-udp-frame data))
            (part (read-udp-part data))
            (total (read-udp-total data))
            (header? (read-udp-media-header? data)))
        (define (record-insert)
          (let ((base (get-base time-base))
                (latency (get-latency time-base))
                (last-latency (get-last-latency time-base)))
            (record-event (or insert-event udp-id-insert-packet)
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          (or latency -1.)
                          (if (not timestamp)
                              -1.
                            timestamp)
                          (or base -1.)
                          (or last-latency -1.))))
        
        (define (record-nack seq)
          (record-event udp-id-nack-packet
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        (fixnum->flonum seq)
                        (fixnum->flonum sequence)
                        -1.
                        -1.))
        
        (define (record-gap gap)
          (when (> gap 0)
            (record-event udp-id-packet-gap
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          (fixnum->flonum gap)
                          -1.)
            (when udp-show-gaps?
              (terminal remote-name (present-media-kind media-kind) '***packet-gap*** (current-seconds) gap sequence))))
        
        (let ((in-order? (or (not last-sequence)
                             (> sequence last-sequence))))
          (cond ;; empty
                ((= count 0)
                 (when in-order?
                   (let ((packet (new UDP-Packet timestamp duration sequence frame part total header? data)))
                     (record-insert)
                     (when (insert-before self head packet)
                       (set! last-sequence sequence)
                       (set! lowest sequence)
                       (set! highest sequence)
                       (check self)
                       (condition-variable-signal! wait-condvar)))))
                ;; insert
                (in-order?
                 (let ((packet (new UDP-Packet timestamp duration sequence frame part total header? data)))
                   (let ((expected (+ last-sequence 1)))
                     (let ((gap (- sequence expected)))
                       (record-gap gap)
                       (if (and udp-max-gap (>= gap udp-max-gap))
                           (begin
                             (set! last-sequence sequence)
                             (flush self count #f)
                             (state-waiting self)
                             (condition-variable-signal! wait-condvar))
                         (let ((highest-packet (highest-packet self)))
                           (let ((highest-timestamp (get-timestamp highest-packet)))
                             (loop (for seq from (+ highest 1) below sequence)
                                   (let ((timestamp (and timestamp highest-timestamp (interpolate seq highest sequence highest-timestamp timestamp))))
                                     (record-nack seq)
                                     (insert-before self tail (new UDP-Packet timestamp #f seq #f #f #f #f #f))))))
                         (record-insert)
                         (when (insert-before self tail packet)
                           (set! last-sequence sequence)
                           (set! highest sequence)
                           (check self)
                           (condition-variable-signal! wait-condvar)))))))
                ;; replace
                (else
                 (if (between? sequence lowest highest)
                     (let ((pos (index self sequence)))
                       (let ((actual-packet (vector-ref packets pos)))
                         (if (get-data actual-packet)
                             (let ((resent (read-udp-resent data)))
                               (record-event udp-id-duplicate-packet
                                             (fixnum->flonum no)
                                             (fixnum->flonum origin)
                                             (fixnum->flonum media-kind)
                                             (fixnum->flonum sequence)
                                             (fixnum->flonum frame)
                                             (fixnum->flonum resent)
                                             -1.))
                           (let ((packet (new UDP-Packet timestamp duration sequence frame part total header? data)))
                             (vector-set! packets pos packet)
                             (let ((resent (read-udp-resent data)))
                               (record-event udp-id-got-packet
                                             (fixnum->flonum no)
                                             (fixnum->flonum origin)
                                             (fixnum->flonum media-kind)
                                             (fixnum->flonum sequence)
                                             (fixnum->flonum frame)
                                             (fixnum->flonum resent)
                                             -1.))
                             (condition-variable-signal! wait-condvar)))))
                   (let ((resent (read-udp-resent data)))
                     (record-event udp-id-reject-packet
                                   (fixnum->flonum no)
                                   (fixnum->flonum origin)
                                   (fixnum->flonum media-kind)
                                   (fixnum->flonum sequence)
                                   (fixnum->flonum frame)
                                   (fixnum->flonum resent)
                                   -1.)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (insert-before self pos packet)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-packets (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subvector-move! packets 0 tail new-packets 0)
          (subvector-move! packets tail size new-packets head)
          (set! size new-size)
          (set! packets new-packets))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (vector-set! packets head packet)
                  (increase! count)
                  #t)
                 ((= pos tail)
                  (vector-set! packets tail packet)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count)
                  #t)
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subvector-shift! packets head pos -1)
                        (vector-set! packets (- pos 1) packet)
                        (set! head (modulo (- head 1) size))
                        (increase! count)
                        #t)
                    (subvector-shift! packets pos tail 1)
                    (vector-set! packets pos packet)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)
                    #t))))
          (else
           (if overflow-proc
               (begin
                 (overflow-proc self packet)
                 #f)
             (vector-set! packets tail packet)
             (set! tail (modulo (+ tail 1) size))
             (set! head tail)
             (increase! lowest)
             #t))))
  
  
  (method protected (visualizer-update-time self base latency)
    (visualizer-update time-base base latency))
  
  
  (method protected (visualizer-replace-got self sequence data)
    ;; quick robust test for visualizer
    (when (between? sequence lowest highest)
      (let ((pos (index self sequence)))
        (let ((actual-packet (vector-ref packets pos)))
          (assert (eqv? (get-sequence actual-packet) sequence)
            (assert (not (get-data actual-packet))
              (let ((timestamp (read-udp-media-seconds data))
                    (duration (read-udp-media-duration data))
                    (sequence (read-udp-sequence data))
                    (frame (read-udp-frame data))
                    (part (read-udp-part data))
                    (total (read-udp-total data))
                    (header? (read-udp-media-header? data)))
                (let ((packet (new UDP-Packet timestamp duration sequence frame part total header? data)))
                  (vector-set! packets pos packet)))))))))
  
  
  (method protected (visualizer-remove-frame self)
    (let ((earliest (vector-ref packets head)))
      (let ((part (get-part earliest))
            (total (get-total earliest)))
        (let ((cnt (- total part)))
          (remove-count self cnt)))))
  
  
  (method protected (visualizer-iterate-frame self proc)
    (let ((earliest (vector-ref packets head)))
      (let ((part (get-part earliest))
            (total (get-total earliest)))
        (let ((cnt (- total part)))
          (loop (for n from 0 below cnt)
                (proc (packet-ref self n)))))))
  
  
  ;;;
  ;;;; Retain
  ;;;
  
  
  (method public (retain-wait self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((now (current-seconds))
                (earliest (vector-ref packets head)))
            (let ((release-time (determine-release-time self earliest)))
              (if (>= now release-time)
                  (prog1 earliest
                    (vector-set! packets head #f)
                    (set! head (modulo (+ head 1) size))
                    (decrease! count)
                    (increase! lowest)
                    (check self)
                    (mutex-unlock! mutex))
                (mutex-unlock! mutex wait-condvar (- release-time now))
                (loop-wait))))))))
  
  
  (method (determine-release-time self packet)
    (let ((timestamp (get-timestamp packet)))
      (if (not timestamp)
          0.
        (+ (remote->local time-base timestamp) retain-window))))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method public (process-wait self average (debug? #f))
    (ecase media-kind
      ((udp-audio) (process-audio self average debug?))
      ((udp-video) (process-video self average debug?))))
  
  
  (method (process-audio self average debug?)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((now (current-seconds))
                (earliest (vector-ref packets head)))
            (let ((earliest-time (determine-earliest-time self earliest))
                  (presentation-time (determine-presentation-time self earliest)))
              (let ((giveup-time (+ presentation-time udp-audio-giveup)))
                (define (debugging what sleep)
                  (when debug?
                    (let ((sequence (get-sequence earliest))
                          (time (- now earliest-time))
                          (sleep (if (symbol? sleep) sleep (format "{r precision: 3}" sleep)))
                          (content (loop (for n from 0 below count)
                                         (collect (get-sequence (packet-ref self n))))))
                      (format :terminal
                              "{a width: 8} {a} {r precision: 3} {a width: 6} ({l}){%}"
                              what
                              sequence
                              time
                              sleep
                              content))))
                
                (cond ;; waiting
                      ((eq? state 'waiting)
                       (let ((header (complete-header self)))
                         (cond ;; header
                               (header
                                (let ((packet (packet-ref self header)))
                                  (let ((packet-present (determine-presentation-time self packet)))
                                    (if (< now packet-present)
                                        ;; not ready
                                        (begin
                                          (debugging 'whnotrdy (- packet-present now))
                                          (mutex-unlock! mutex wait-condvar (- packet-present now))
                                          (loop-wait))
                                      ;; ready
                                      (begin
                                        (flush self header average)
                                        (state-ok self)
                                        ;; doing the present here instead of just looping is
                                        ;; to support the quick hack until guaranteed delivery
                                        (prog1 (present self now average)
                                          (debugging 'whrdy 'return)
                                          (mutex-unlock! mutex)))))))
                               ;; giveup
                               ((>= now giveup-time)
                                ;; quick hack until guaranteed delivery
                                (if (get-header? earliest)
                                    (begin
                                      (debugging 'whnotgu 'loop)
                                      (mutex-unlock! mutex wait-condvar)
                                      (loop-wait))
                                  (debugging 'wgu 'loop)
                                  (flush-packet self average)
                                  (mutex-unlock! mutex)
                                  (loop-wait)))
                               ;; not ready to giveup
                               (else
                                (debugging 'wnrtgu (- giveup-time now))
                                (mutex-unlock! mutex wait-condvar (- giveup-time now))
                                (loop-wait)))))
                      ;; giveup
                      ((>= now giveup-time)
                       (debugging 'giveup 'loop)
                       (flush-packet self average)
                       (mutex-unlock! mutex)
                       (loop-wait))
                      ;; not ready
                      ((< now presentation-time)
                       (debugging 'sleep (- presentation-time now))
                       (mutex-unlock! mutex wait-condvar (- presentation-time now))
                       (loop-wait))
                      ;; frame
                      ((complete-frame? self)
                       (prog1 (present self now average)
                         (debugging 'play 'return)
                         (mutex-unlock! mutex)))
                      ;; not ready to giveup
                      (else
                       (debugging 'nrtgu (- giveup-time now))
                       (mutex-unlock! mutex wait-condvar (- giveup-time now))
                       (loop-wait))))))))))
  
  
  (method (process-video self average debug?)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (if (not (get-framerate channel))
                (begin
                  (mutex-unlock! mutex wait-condvar)
                  (loop-wait))
              (mutex-unlock! mutex wait-condvar udp-video-giveup)
              (if (= count 0)
                  (begin
                    (state-waiting self)
                    (loop-wait))
                (loop-wait)))
          (let ((now (current-seconds))
                (earliest (vector-ref packets head)))
            (let ((earliest-time (determine-earliest-time self earliest))
                  (presentation-time (determine-presentation-time self earliest)))
              (let ((late-time (+ presentation-time udp-video-late))
                    (giveup-time (+ presentation-time udp-video-giveup)))
                (define (debugging what sleep)
                  (when debug?
                    (let ((sequence (get-sequence earliest))
                          (time (- now earliest-time))
                          (sleep (if (symbol? sleep) sleep (format "{r precision: 3}" sleep)))
                          (content (loop (for n from 0 below count)
                                         (collect (get-sequence (packet-ref self n))))))
                      (format :terminal
                              "{a width: 6} {a} {r precision: 3} {a width: 6} ({l}){%}"
                              what
                              sequence
                              time
                              sleep
                              content))))
                
                (cond ;; giveup
                      ((>= now giveup-time)
                       (debugging 'giveup 'loop)
                       (flush-packet self average)
                       (state-waiting self)
                       (mutex-unlock! mutex)
                       (loop-wait))
                      ;; waiting
                      ((eq? state 'waiting)
                       (let ((header (complete-header self)))
                         (cond ;; header
                               (header
                                (let ((packet (packet-ref self header)))
                                  (let ((packet-present (determine-presentation-time self packet)))
                                    (if (< now packet-present)
                                        ;; not ready
                                        (begin
                                          (mutex-unlock! mutex wait-condvar (- packet-present now))
                                          (loop-wait))
                                      ;; ready
                                      (begin
                                        (flush self header average)
                                        (state-ok self)
                                        (mutex-unlock! mutex)
                                        (loop-wait))))))
                               ;; giveup
                               ((>= now giveup-time)
                                (flush-packet self average)
                                (mutex-unlock! mutex)
                                (loop-wait))
                               ;; not ready to giveup
                               (else
                                (mutex-unlock! mutex wait-condvar (- giveup-time now))
                                (loop-wait)))))
                      ;; not ready
                      ((< now presentation-time)
                       (debugging 'sleep (- presentation-time now))
                       (mutex-unlock! mutex wait-condvar (- presentation-time now))
                       (loop-wait))
                      ;; frame
                      ((complete-frame? self)
                       (prog1 (begin
                                (if (< now late-time)
                                    (state-ok self)
                                  (state-late self))
                                (present self now average))
                         (debugging (if (eq? state 'ok) 'play 'freeze) 'return)
                         (mutex-unlock! mutex)))
                      ;; ok
                      ((< now late-time)
                       (debugging 'ok (- late-time now))
                       (mutex-unlock! mutex wait-condvar (- late-time now))
                       (loop-wait))
                      ;; late
                      (else
                       (debugging 'late (- giveup-time now))
                       (state-late self)
                       (mutex-unlock! mutex wait-condvar (- giveup-time now))
                       (loop-wait))))))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method protected (earliest-packet self)
    (and (> count 0)
         (vector-ref packets head)))
  
  
  (method protected (packet-ref self n)
    (vector-ref packets (modulo (+ head n) size)))
  
  
  (method (determine-earliest-time self packet)
    (let ((timestamp (get-timestamp packet)))
      (if (not timestamp)
          0.
        (remote->local time-base timestamp))))
  
  
  (method (determine-presentation-time self packet)
    (let ((timestamp (get-timestamp packet)))
      (if (not timestamp)
          0.
        (+ (remote->local time-base timestamp) udp-process-window))))
  
  
  (method (ready? self now packet)
    (>= now (determine-presentation-time self packet)))
  
  
  (method protected (complete-frame? self)
    (let ((earliest (vector-ref packets head)))
      (and (get-data earliest)
           (let ((part (get-part earliest))
                 (total (get-total earliest)))
             (and (= part 0)
                  (<= total count)
                  (loop (for n from 0 below total)
                        (every (get-data (packet-ref self n)))))))))
  
  
  (method protected (frame-complete? self pos)
    (let ((packet (packet-ref self pos)))
      (let ((part (get-part packet))
            (total (get-total packet)))
        (and (= part 0)
             (<= (+ pos total) count)
             (loop (for n from 0 below total)
                   (every (get-data (packet-ref self (+ pos n)))))))))
    
  
  (method (complete-header self)
    (continuation-capture
      (lambda (found)
        (loop (for n from 0 below count)
              (let ((packet (packet-ref self n)))
                (when (and (get-data packet)
                           (get-header? packet)
                           (= (get-part packet) 0))
                  (let ((frame (get-frame packet))
                        (total (get-total packet)))
                    (let ((last (+ n total -1)))
                      (when (and (< last count)
                                 (loop (for i from (+ n 1) to last)
                                       (every (let ((packet (packet-ref self i)))
                                                (and (get-data packet)
                                                     (= (get-frame packet) frame))))))
                        (continuation-return found n)))))))
        #f)))
  
  
  (method (present self now average)
    (let ((earliest (vector-ref packets head)))
      (let ((frame (get-frame earliest))
            (total (get-total earliest)))
        (prog1 (loop (for n from 0 below total)
                     (collect (get-data (packet-ref self n))))
          (remove-count self total)
          (add-average self average frame 1.)))))
  
  
  (method (add-average self average frame x)
    (when (and last-frame
               (/= frame last-frame))
      (let ((gap (- frame (+ last-frame 1))))
        (loop (repeat gap)
              (add average 0.))))
    (when (or (not last-frame)
              (/= frame last-frame))
      (add average x)
      (set! last-frame frame)))
  
  
  (method (flush self cnt average)
    (loop (repeat cnt)
          (flush-packet self average)))
  
  
  (method (flush-packet self average)
    (let ((earliest (packet-ref self 0)))
      (let ((sequence (get-sequence earliest))
            (frame (get-frame earliest))
            (header? (get-header? earliest))
            (timestamp (get-timestamp earliest)))
        (if (get-data earliest)
            (record-discard-packet self sequence frame header? timestamp)
          (record-missing-packet self sequence frame header? timestamp))
        (remove-packet self)
        (when frame
          ;; quick hack fix me
          (when average
            (add-average self average frame 0.))))))
  
  
  (method protected (remove-packet self)
    (remove-count self 1))
  
  
  (method protected (remove-count self cnt)
    (loop (repeat cnt)
          (vector-set! packets head #f)
          (set! head (modulo (+ head 1) size))
          (decrease! count)
          (increase! lowest))
    (check self))
  
  
  (method protected (state-ok self)
    (unless (eq? state 'ok)
      (set! state 'ok)
      (unless (emulation?)
        (record-event udp-id-state-ok
                      (fixnum->flonum no)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      -1.
                      -1.)
        (when udp-show-states?
          (format :terminal "{s} {s} {s} {s}       - {a} ({a}){%}" remote-name (present-media-kind media-kind) 'STATE 'OK (effective-name (get-stream channel)) (get-no channel))))))
  
  
  (method protected (state-late self)
    (unless (eq? state 'late)
      (set! state 'late)
      (unless (emulation?)
        (record-event udp-id-state-late
                      (fixnum->flonum no)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      -1.
                      -1.)
        (when udp-show-states?
          (format :terminal "{s} {s} {s} {s}     - {a} ({a}){%}" remote-name (present-media-kind media-kind) 'STATE 'LATE (effective-name (get-stream channel)) (get-no channel))))))
  
  
  (method protected (state-waiting self)
    (unless (eq? state 'waiting)
      (set! state 'waiting)
      (unless (emulation?)
        (record-event udp-id-state-waiting
                      (fixnum->flonum no)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      -1.
                      -1.)
        (when udp-show-states?
          (format :terminal "{s} {s} {s} {s}  - {a} ({a}){%}" remote-name (present-media-kind media-kind) 'STATE 'WAITING (effective-name (get-stream channel)) (get-no channel))))))
  
  
  (method (record-missing-packet self sequence frame header? timestamp)
    (record-event udp-id-missing-packet
                  (fixnum->flonum no)
                  (fixnum->flonum origin)
                  (fixnum->flonum media-kind)
                  (fixnum->flonum sequence)
                  (if (not frame)
                      -1.
                    (fixnum->flonum frame))
                  (barbara-header-hack header?)
                  (if (not timestamp)
                      -1.
                    (timestamp->flonum timestamp))))
  
  
  (method (record-discard-packet self sequence frame header? timestamp)
    (record-event udp-id-discard-packet
                  (fixnum->flonum no)
                  (fixnum->flonum origin)
                  (fixnum->flonum media-kind)
                  (fixnum->flonum sequence)
                  (fixnum->flonum frame)
                  (barbara-header-hack header?)
                  (if (not timestamp)
                      -1.
                    (timestamp->flonum timestamp))))
  
  
  (method public (locate-packet self sequence)
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (vector-ref packets pos)))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-data self sequence)
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (let ((packet (vector-ref packets pos)))
                    (get-data packet))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-earliest self predicate)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (if (>= n count)
                          #f
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (if (predicate packet)
                                packet
                              (loop (+ n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-latest self predicate)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n (- count 1)))
                      (if (< n 0)
                          #f
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (if (predicate packet)
                                packet
                              (loop (- n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-indexes self proc)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (when (< n count)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc n)
                            (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-earliest self proc)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (when (< n count)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc packet)
                            (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-latest self proc)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n (- count 1)))
                      (when (>= n 0)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc packet)
                            (loop (- n 1))))))
      (mutex-unlock! mutex))))


;;;
;;;; Packet
;;;


(class UDP-Packet-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-timestamp object))
                              (serialize (get-duration object))
                              (serialize (get-sequence object))
                              (serialize (get-frame object))
                              (serialize (get-part object))
                              (serialize (get-total object))
                              (serialize (get-header? object))
                              (serialize (get-data object)))))
  
  
  (method override (unmarshall-object self content)
    (bind-vector (timestamp duration sequence frame part total header? data) content
      (allocate self
                (deserialize timestamp)
                (deserialize duration)
                (deserialize sequence)
                (deserialize frame)
                (deserialize part)
                (deserialize total)
                (deserialize header?)
                (deserialize data)))))


(class UDP-Packet metaclass UDP-Packet-Class extends Object
  
  
  (slot timestamp getter generate)
  (slot duration  getter generate)
  (slot sequence  getter generate)
  (slot frame     getter generate)
  (slot part      getter generate)
  (slot total     getter generate)
  (slot header?   getter generate)
  (slot data      accessors generate)
  
  
  (method override (initialize self timestamp duration sequence frame part total header? data)
    (nextmethod self)
    (set! self.timestamp timestamp)
    (set! self.duration duration)
    (set! self.sequence sequence)
    (set! self.frame frame)
    (set! self.part part)
    (set! self.total total)
    (set! self.header? header?)
    (set! self.data data))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" sequence)))))


;;;
;;;; Monitor
;;;


(class UDP-Monitor extends Object
  
  
  (slot packets-sent     initialize 0 getter generate)
  (slot bytes-sent       initialize 0 getter generate)
  (slot packets-received initialize 0 getter generate)
  (slot bytes-received   initialize 0 getter generate)
  
  
  (method protected (increase-sent self data)
    (increase! packets-sent)
    (increase! bytes-sent (u8vector-length data)))
  
  
  (method protected (increase-received self data)
    (increase! packets-received)
    (increase! bytes-received (u8vector-length data))))


;;;
;;;; UDP-Statistics
;;;


(class UDP-Statistics extends Object
  
  
  (slot period                     initialize #f getter generate)
  (slot last-bytes-sent            initialize 0  getter generate)
  (slot last-bytes-received        initialize 0  getter generate)
  (slot last-server-bytes-sent     initialize 0  getter generate)
  (slot last-server-bytes-received initialize 0  getter generate)
  (slot last-traffic-sent          initialize 0  getter generate)
  (slot last-traffic-received      initialize 0  getter generate)
  (slot last-traffic-time          initialize #f getter generate)
  (slot last-send-rate             initialize #f getter generate)
  (slot last-receive-rate          initialize #f getter generate)
  (slot outgoing-dropped           initialize 0  getter generate)
  (slot outgoing-drop              initialize 0  getter generate)
  (slot incoming-dropped           initialize 0  getter generate)
  (slot incoming-drop              initialize 0  getter generate)
  
  
  (method override (initialize self period)
    (nextmethod self)
    (set! self.period period))
  
  
  (method protected (update self now monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received)
    (let ((packets-sent (get-packets-sent monitor))
          (bytes-sent (get-bytes-sent monitor))
          (packets-received (get-packets-received monitor))
          (bytes-received (get-bytes-received monitor)))
      (let ((fresh-bytes-sent (- bytes-sent last-bytes-sent))
            (fresh-bytes-received (- bytes-received last-bytes-received))
            (fresh-server-bytes-sent (- server-bytes-sent last-server-bytes-sent))
            (fresh-server-bytes-received (- server-bytes-received last-server-bytes-received)))
        (define (update-traffic-rate)
          (if (not last-traffic-time)
              (begin
                (set! last-traffic-time now)
                (set! last-send-rate -1.)
                (set! last-receive-rate -1.))
            (increase! last-traffic-sent fresh-bytes-sent)
            (increase! last-traffic-received fresh-bytes-received)
            (let ((elapse (- now last-traffic-time)))
              ;; best try to smooth the jaggies that I think arise
              ;; from the audio / video frequency, the right solution
              ;; probably being to smooth all this in the graph
              (when (>= elapse period)
                (let ((send-rate (/ (cast <fl> last-traffic-sent) elapse))
                      (receive-rate (/ (cast <fl> last-traffic-received) elapse)))
                  (set! last-traffic-sent 0)
                  (set! last-traffic-received 0)
                  (set! last-traffic-time now)
                  (set! last-send-rate send-rate)
                  (set! last-receive-rate receive-rate))))))
        
        (set! last-bytes-sent bytes-sent)
        (set! last-bytes-received bytes-received)
        (set! last-server-bytes-sent server-bytes-sent)
        (set! last-server-bytes-received server-bytes-received)
        (update-traffic-rate)
        (set! outgoing-dropped (- packets-sent server-packets-received))
        (set! incoming-dropped (- server-packets-sent packets-received))
        (set! outgoing-drop (and (> packets-sent 0) (percentage outgoing-dropped packets-sent)))
        (set! incoming-drop (and (> server-packets-sent 0) (percentage incoming-dropped server-packets-sent)))))))


;;;
;;;; Simulator
;;;


(class UDP-Simulator extends Object
  
  
  (property latency             getter generate)
  (property lag                 getter generate)
  (property drop                getter generate)
  (property congestion          accessors generate)
  (property congestion-duration accessors generate)
  
  (slot congestion-occuring? getter generate)
  (slot congestion-ends      accessors generate)
  (slot latency-last         getter generate)
  (slot latency-count        getter generate)
  (slot writer               getter generate)
  (slot ring                 getter generate)
  (slot thread               getter generate)
  
  
  (method override (initialize self latency lag drop writer)
    (nextmethod self)
    (set! self.latency latency)
    (set! self.lag lag)
    (set! self.drop drop)
    (set! self.congestion udp-congestion)
    (set! self.congestion-duration udp-congestion-duration)
    (set! self.congestion-occuring? #f)
    (set! self.congestion-ends #f)
    (set! self.latency-last #f)
    (set! self.latency-count #f)
    (set! self.writer writer)
    (set! self.ring (new Time-Ring udp-simulator-size max-size: udp-simulator-max-size overflow-proc: (udp-ring-overflow 'simulator udp-ring-kind-simulator)))
    (set! self.thread (new-thread
                        (lambda ()
                          (send-loop self))
                        'simulator))
    (thread-base-priority-set! thread simulator-priority)
    (thread-start! thread))
  
  
  (method protected (send self info)
    ;; congestion
    (if congestion
        (if (not congestion-occuring?)
            (if (or (eq? congestion #t)
                    (< (random-real) (/ congestion 100.)))
                (let ((ends (if (eq? congestion-duration #t) +inf.0 (random-between 0. congestion-duration))))
                  (set! congestion-occuring? #t)
                  (set! congestion-ends ends)
                  (when udp-show-congestion?
                    (format :terminal "{s} {s} {s}{%}" remote-name 'CONGESTION 'ON)))
              (writer info (drop? self)))
          (when (or (not congestion-ends)
                    (>= (current-seconds) congestion-ends))
            (set! congestion-occuring? #f)
            (set! congestion-ends #f)
            (when udp-show-congestion?
              (format :terminal "{s} {s} {s}{%}" remote-name 'CONGESTION 'OFF))
            (writer info (drop? self))))
      ;; latency
      (if latency
          (let ()
            (define (determine-latency)
              (cond ((procedure? latency)
                     (latency info))
                    ((or (not latency-last)
                         (= latency-count 0))
                     (let ((latency (random-between 0. latency)))
                       (set! latency-last latency)
                       (set! latency-count (random udp-latency-count))
                       latency))
                    (else
                     (decrease! latency-count)
                     latency-last)))
            
            (insert ring (+ (current-seconds) (determine-latency)) info))
        (writer info (drop? self)))))
  
  
  (method (drop? self)
    (and drop (< (random-real) (/ drop 100.))))
  
  
  (method (send-loop self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((info (wait ring)))
        (writer info (drop? self)))
      (loop))))


;;;
;;;; Media
;;;


(definition public (media-packet-header? data)
  (and (= (read-udp-part data) 0)
       (read-udp-media-header? data)))


;;;
;;;; Access
;;;


(definition public (scan-boolean data pos)
  (/= (scan-s8 data pos) 0))


(definition public (scan-u8vector data pos)
  (let ((len (scan-s32 data pos)))
    (let ((v (make-u8vector len))
          (pos (+ pos 4)))
      (subu8vector-move! data pos (+ pos len) v 0)
      v)))


(definition public (scan-host data pos)
  (u8vector (u8vector-ref data pos)
            (u8vector-ref data (+ pos 1))
            (u8vector-ref data (+ pos 2))
            (u8vector-ref data (+ pos 3))))


(definition public (put-boolean data pos value)
  (put-s8 data pos (if value 1 0)))


(definition public (put-u8vector data pos value)
  (let ((len (u8vector-length value)))
    (put-s32 data pos len)
    (let ((pos (+ pos 4)))
      (subu8vector-move! value 0 len data pos))))


(definition public (put-subu8vector! data pos value offset count)
  (put-s32 data pos count)
  (let ((pos (+ pos 4)))
    (subu8vector-move! value offset (+ offset count) data pos)))


(definition public (put-host data pos value)
  (u8vector-set! data pos (u8vector-ref value 0))
  (u8vector-set! data (+ pos 1) (u8vector-ref value 1))
  (u8vector-set! data (+ pos 2) (u8vector-ref value 2))
  (u8vector-set! data (+ pos 3) (u8vector-ref value 3)))


;;;
;;;; Format
;;;


;; udp
(definition public (read-udp-sent            data) (scan-double   data  0)) (definition public (write-udp-sent            data value) (put-double   data  0 value))
(definition public (read-udp-kind            data) (scan-s8       data  8)) (definition public (write-udp-kind            data value) (put-s8       data  8 value))
(definition public (read-udp-origin          data) (scan-s16      data 12)) (definition public (write-udp-origin          data value) (put-s16      data 12 value))
(definition public (read-udp-channel         data) (scan-s16      data 14)) (definition public (write-udp-channel         data value) (put-s16      data 14 value))
(definition public (read-udp-sequence        data) (scan-s32      data 16)) (definition public (write-udp-sequence        data value) (put-s32      data 16 value))
(definition public (read-udp-frame           data) (scan-s32      data 20)) (definition public (write-udp-frame           data value) (put-s32      data 20 value))
(definition public (read-udp-part            data) (scan-s32      data 24)) (definition public (write-udp-part            data value) (put-s32      data 24 value))
(definition public (read-udp-total           data) (scan-s32      data 28)) (definition public (write-udp-total           data value) (put-s32      data 28 value))
(definition public (read-udp-media-timestamp data) (scan-s64      data 32)) (definition public (write-udp-media-timestamp data value) (put-s64      data 32 value))
(definition public (read-udp-media-duration  data) (scan-u64      data 40)) (definition public (write-udp-media-duration  data value) (put-u64      data 40 value))
(definition public (read-udp-media-payload   data) (scan-u8vector data 48)) (definition public (write-udp-media-payload   data value) (put-u8vector data 48 value)) (definition public udp-media-buffer-offset (+ 48 4))
(definition public (read-udp-media-header?   data) (scan-boolean  data  9)) (definition public (write-udp-media-header?   data value) (put-boolean  data  9 value))
(definition public (read-udp-media-off?      data) (scan-boolean  data 10)) (definition public (write-udp-media-off?      data value) (put-boolean  data 10 value))
(definition public (read-udp-resent          data) (scan-s8       data 11)) (definition public (write-udp-resent          data value) (put-s8       data 11 value))

(definition public (read-udp-media-seconds data)
  (let ((timestamp (read-udp-media-timestamp data)))
    (if (= timestamp -1)
        #f
      (/ timestamp nanosecond))))

(definition public (read-udp-media-payload-size data)
  (scan-s32 data 48))

(definition public (write-udp-media-subpayload data value offset count)
  (put-subu8vector! data 48 value offset count))

(definition public (increase-udp-resent data)
  (write-udp-resent data (+ (read-udp-resent data) 1)))

;; connect
(definition public (read-udp-connect-local-host  data) (scan-host  data 16)) (definition public (write-udp-connect-local-host  data value) (put-host  data 16 value))
(definition public (read-udp-connect-local-port  data) (scan-s32   data 20)) (definition public (write-udp-connect-local-port  data value) (put-s32   data 20 value))
(definition public (read-udp-connect-latency     data) (scan-float data 24)) (definition public (write-udp-connect-latency     data value) (put-float data 24 value))
(definition public (read-udp-connect-lag         data) (scan-float data 28)) (definition public (write-udp-connect-lag         data value) (put-float data 28 value))
(definition public (read-udp-connect-drop        data) (scan-float data 32)) (definition public (write-udp-connect-drop        data value) (put-float data 32 value))
(definition public (read-udp-connect-video-level data) (scan-s32   data 36)) (definition public (write-udp-connect-video-level data value) (put-s32   data 36 value))

;; state
(definition public (read-udp-state-sequence data) (scan-s32      data 16)) (definition public (write-udp-state-sequence data value) (put-s32      data 16 value))
(definition public (read-udp-state-channels data) (scan-u8vector data 20)) (definition public (write-udp-state-channels data value) (put-u8vector data 20 value))

;; ack
(definition public (read-udp-ack-state-sequence   data) (scan-s32 data 16)) (definition public (write-udp-ack-state-sequence   data value) (put-s32 data 16 value))
(definition public (read-udp-ack-packets-sent     data) (scan-s32 data 20)) (definition public (write-udp-ack-packets-sent     data value) (put-s32 data 20 value))
(definition public (read-udp-ack-bytes-sent       data) (scan-s32 data 24)) (definition public (write-udp-ack-bytes-sent       data value) (put-s32 data 24 value))
(definition public (read-udp-ack-packets-received data) (scan-s32 data 28)) (definition public (write-udp-ack-packets-received data value) (put-s32 data 28 value))
(definition public (read-udp-ack-bytes-received   data) (scan-s32 data 32)) (definition public (write-udp-ack-bytes-received   data value) (put-s32 data 32 value))

;; nack
(definition public (read-udp-nack-media-kind data) (scan-s32      data 16)) (definition public (write-udp-nack-media-kind data value) (put-s32      data 16 value))
(definition public (read-udp-nack-missing    data) (scan-u8vector data 20)) (definition public (write-udp-nack-missing    data value) (put-u8vector data 20 value))

;; profile heartbeat
(definition public (read-udp-profile-heartbeat-packets-sent     data) (scan-s32 data 20)) (definition public (write-udp-profile-heartbeat-packets-sent     data value) (put-s32 data 20 value))
(definition public (read-udp-profile-heartbeat-bytes-sent       data) (scan-s32 data 24)) (definition public (write-udp-profile-heartbeat-bytes-sent       data value) (put-s32 data 24 value))
(definition public (read-udp-profile-heartbeat-packets-received data) (scan-s32 data 28)) (definition public (write-udp-profile-heartbeat-packets-received data value) (put-s32 data 28 value))
(definition public (read-udp-profile-heartbeat-bytes-received   data) (scan-s32 data 32)) (definition public (write-udp-profile-heartbeat-bytes-received   data value) (put-s32 data 32 value))

;; profile media
(definition public (read-udp-profile-media-payload data) (scan-u8vector data 20)) (definition public (write-udp-profile-media-payload data value) (put-u8vector data 20 value)))
