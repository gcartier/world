;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.udp jazz


(import (jazz.geometry)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.audio)
        (world.binary)
        (world.configure)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.ring)
        (world.settings)
        (world.task)
        (world.video))


(definition protected udp-connect <fx>
  0)

(definition protected udp-connected <fx>
  1)

(definition protected udp-state <fx>
  2)

(definition protected udp-ack <fx>
  3)

(definition protected udp-nack <fx>
  4)

(definition protected udp-audio <fx>
  5)

(definition protected udp-video <fx>
  6)


(definition udp-names
  #(connect connected state ack nack audio video))

(definition protected (udp-name kind)
  (vector-ref udp-names kind))


;; MTU - IP HEADER - UDP HEADER
;; 1500 - 20 (60) - 8 = 1472 (1432)
(definition protected udp-datagram-max
  (world-setting 'world.udp-datagram-max 1432))

(definition protected udp-retain-size
  (world-setting 'world.udp-retain-size 256))

(definition protected udp-retain-max-size
  (world-setting 'world.udp-retain-max-size 8192))

(definition protected udp-retain-window
  (world-setting 'world.udp-retain-window 1.))

(definition protected udp-ready-window
  (world-setting 'world.udp-ready-window .5))

(definition protected udp-audio-window
  (world-setting 'world.udp-audio-window .1))

(definition protected udp-video-window
  (world-setting 'world.udp-video-window .5))

(definition protected udp-process-size
  (world-setting 'world.udp-process-size 256))

(definition protected udp-process-max-size
  (world-setting 'world.udp-process-max-size 4096))

(definition protected udp-process-window
  (world-setting 'world.udp-process-window .2))

(definition protected udp-process-window-nanoseconds
  (fxround (* udp-process-window nanosecond)))

(definition protected udp-simulator-size
  (world-setting 'world.udp-simulator-size 256))

(definition protected udp-simulator-max-size
  (world-setting 'world.udp-simulator-max-size 4096))

(definition protected udp-state-frequency
  (world-setting 'world.udp-state-frequency 10.))

(definition protected udp-state-period
  (/ 1. udp-state-frequency))

(definition protected udp-audio-throttle
  (world-setting 'world.udp-audio-throttle 5.))

(definition protected udp-video-throttle
  (world-setting 'world.udp-video-throttle 5.))

(definition protected udp-max-nacks
  (world-setting 'world.udp-max-nacks 8))

(definition protected udp-latest-nacks
  (world-setting 'world.udp-latest-nacks 100))


(definition protected udp-record-read/write?
  (world-setting 'world.udp-record-read/write? #f))


(definition protected udp-show-roundtrip?
  (world-setting 'world.udp-show-roundtrip? #f))

(definition protected udp-show-invalids?
  (world-setting 'world.udp-show-invalids? #f))

(definition protected udp-show-overflows?
  (world-setting 'world.udp-show-overflows? #f))

(definition protected udp-show-gaps?
  (world-setting 'world.udp-show-gaps? #f))

;; duplicates are usually a normal consequence of nacks
(definition protected udp-show-duplicates?
  (world-setting 'world.udp-show-duplicates? #f))

(definition protected udp-show-late?
  (world-setting 'world.udp-show-late? #f))

(definition protected udp-show-missing?
  (world-setting 'world.udp-show-missing? #f))

(definition protected udp-show-retries?
  (world-setting 'world.udp-show-retries? #f))

(definition protected udp-show-states?
  (world-setting 'world.udp-show-states? #f))

(definition protected udp-show-resetting?
  (world-setting 'world.udp-show-resetting? #f))

(definition protected udp-show-resets?
  (world-setting 'world.udp-show-resets? #f))

(definition protected udp-show-throttle?
  (world-setting 'world.udp-show-throttle? #f))

(definition protected udp-show-congestion?
  (world-setting 'world.udp-show-congestion? #f))

(definition protected udp-show-nacks?
  (world-setting 'world.udp-show-nacks? #f))

(definition protected udp-freeze-overlay
  (world-setting 'world.udp-freeze-overlay #f))

(definition protected udp-wait-overlay
  (world-setting 'world.udp-wait-overlay #f))

(definition protected udp-latency
  (world-setting 'world.udp-latency #f))

(definition protected udp-lag
  (world-setting 'world.udp-lag #f))

(definition protected udp-drop
  (world-setting 'world.udp-drop #f))

(definition protected udp-congestion
  (world-setting 'world.udp-congestion #f))

(definition protected udp-congestion-duration
  (world-setting 'world.udp-congestion-duration 5.))


(definition protected udp-media-off
  #u8(111 102 102))


(definition protected (present-media-kind kind)
  (if (= kind udp-audio)
      'AUDIO
    'VIDEO))


(definition public inline (evolutionary-udp-time   evolution <Evolution> n <fx>) <fl> (evolutionary-time  evolution n))
(definition public inline (evolutionary-udp-id     evolution <Evolution> n <fx>) <fl> (evolutionary-id    evolution n))
(definition public inline (evolutionary-udp-origin evolution <Evolution> n <fx>) <fl> (evolutionary-data1 evolution n))
(definition public inline (evolutionary-udp-kind   evolution <Evolution> n <fx>) <fl> (evolutionary-data2 evolution n))
(definition public inline (evolutionary-udp-data1  evolution <Evolution> n <fx>) <fl> (evolutionary-data3 evolution n))
(definition public inline (evolutionary-udp-data2  evolution <Evolution> n <fx>) <fl> (evolutionary-data4 evolution n))
(definition public inline (evolutionary-udp-data3  evolution <Evolution> n <fx>) <fl> (evolutionary-data5 evolution n))
(definition public inline (evolutionary-udp-data4  evolution <Evolution> n <fx>) <fl> (evolutionary-data6 evolution n))

(definition public inline (evolutionary-udp-sequence evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data1 evolution n)))
(definition public inline (evolutionary-udp-frame    evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data2 evolution n)))


;; relies on 0 reserved for #f in next-literal-id
(definition protected server-no
  0)


(definition protected (barbara-header-hack header?)
  (if header?
      123456.
    -1.))


;;;
;;;; Ring
;;;


(definition protected udp-ring-kind-retain
  0.)

(definition protected udp-ring-kind-process
  1.)

(definition protected udp-ring-kind-simulator
  2.)


(definition protected (udp-ring-invalid origin media-kind)
  (lambda (ring what key other-key time other-time)
    @wait
    (record-event udp-id-invalid
                  (fixnum->flonum origin)
                  (fixnum->flonum media-kind)
                  (fixnum->flonum key)
                  (fixnum->flonum other-key)
                  time
                  other-time)
    (when udp-show-invalids?
      (format :terminal "{s} {s} {s} {s} {s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) '***invalid*** what key other-key time other-time))))


(definition protected (udp-ring-overflow name kind)
  (lambda (ring data)
    (record-event udp-id-ring-overflow
                  -1.
                  -1.
                  (if (= kind udp-ring-kind-simulator)
                      -1.
                    (fixnum->flonum (read-udp-sequence data)))
                  (fixnum->flonum (get-count ring))
                  kind
                  -1.)
    (when udp-show-overflows?
      (format :terminal "{s} {s} {s}{%}" remote-name '***overflow*** name))))


;;;
;;;; Media
;;;


;; about one minute of recorded audio
(definition public audio-ring <Ring>
  (new Ring 6000))


;; about one minute of recorded video
(definition public video-ring <Ring>
  (new Ring 6000))


;;;
;;;; Tolerance
;;;


;; retry write every 1/100s for 1s
;; at the moment centro will return a network is unreachable
;; or down error after about 10mn and then every minute or so
;; this is also a try at understanding the No buffer space
;; available exception that can occur from time to time
(definition protected (retrying-write data port)
  (declare (proper-tail-calls))
  (let (loop (n 0))
    (with-exception-filter
      (lambda (exc)
        (< n 100))
      (lambda (exc)
        (sleep .01)
        (if (< n 99)
            (loop (+ n 1))
          (record-event udp-id-write-failure
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.)
          (when udp-show-retries?
            (format :terminal "{s} {s} {s}{%}" remote-name '***retry*** exc))
          exc))
      (lambda ()
        (write data port)
        (when udp-record-read/write?
          (let ((origin (read-udp-origin data))
                (media-kind (read-udp-kind data))
                (sequence (read-udp-sequence data))
                (frame (read-udp-frame data)))
            (record-event udp-id-write-data
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          -1.
                          (fixnum->flonum (u8vector-length data)))))
        #f))))


;;;
;;;; Channel
;;;


(class UDP-Channel extends Object
  
  
  (slot origin     getter generate)
  (slot media-kind getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self)
    (set! self.origin origin)
    (set! self.media-kind media-kind))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" origin media-kind)))))


;;;
;;;; Time
;;;


(class Time-Base extends Object
  
  
  (slot timestamp getter generate)
  (slot time      getter generate)
  
  
  (method override (initialize self timestamp time)
    (nextmethod self)
    (set! self.timestamp timestamp)
    (set! self.time time))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" timestamp time)))))


;;;
;;;; Ring
;;;


;;               ---> time
;;  wait +----+----+----+----+----+ insert
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL
;;   (earliest)                (latest)
;;    (lowest)                 (highest)


(class UDP-Ring extends Object
  
  
  (slot origin                   getter generate)
  (slot media-kind               getter generate)
  (slot size         <fx>        getter generate)
  (slot max-size     <fx>        getter generate)
  (slot packets      <vector>    getter generate)
  (slot mutex        <object>    getter generate)
  (slot wait-condvar <object>    getter generate)
  (slot head         <fx>        getter generate)
  (slot tail         <fx>        getter generate)
  (slot count        <fx>        getter generate)
  (slot lowest       <fx>        getter generate)
  (slot highest      <fx>        getter generate)
  (slot state                    getter generate)
  (slot last-sequence            getter generate)
  (slot last-frame               getter generate)
  (slot time-base                getter generate)
  (slot terminate?               getter generate)
  (slot state-proc               getter generate)
  (slot invalid-proc             getter generate)
  (slot overflow-proc            getter generate)
  
  
  (method override (initialize self origin media-kind size <fx> (max-size: max-size #f) (state-proc: state-proc #f) (invalid-proc: invalid-proc #f) (overflow-proc: overflow-proc #f))
    (nextmethod self)
    (set! self.origin origin)
    (set! self.media-kind media-kind)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.packets (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.wait-condvar (make-condition-variable 'wait))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.state 'waiting)
    (set! self.last-sequence #f)
    (set! self.last-frame #f)
    (set! self.time-base #f)
    (set! self.terminate? #f)
    (set! self.state-proc state-proc)
    (set! self.invalid-proc invalid-proc)
    (set! self.overflow-proc overflow-proc))
  
  
  (method public (terminate self)
    (mutex-lock! mutex)
    (set! terminate? #t)
    (condition-variable-signal! wait-condvar)
    (mutex-unlock! mutex))
  
  
  (method public (empty self)
    (vector-fill! self.packets #f)
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0))
  
  
  (method protected (check self)
    (when (> count 0)
      (let ((low (get-sequence (lowest-packet self)))
            (high (get-sequence (highest-packet self))))
        (assert (= lowest low))
        (assert (= highest high)))))
  
  
  (method protected (lowest-packet self)
    (vector-ref packets head))
  
  
  (method protected (highest-packet self)
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (index self seq)
    (modulo (+ head (- seq lowest)) size))

  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert self data (insert-event #f))
    (define (update-time)
      (let ((new-timestamp (read-udp-media-seconds data)))
        (when new-timestamp
          (let ((new-time (current-seconds)))
            (define (update-time-base new-base change)
              (set! time-base new-base)
              (condition-variable-signal! wait-condvar)
              (let ((origin (read-udp-origin data))
                    (sequence (read-udp-sequence data)))
                (record-event udp-id-update-time
                              (fixnum->flonum origin)
                              (fixnum->flonum media-kind)
                              (fixnum->flonum sequence)
                              change
                              new-time
                              new-timestamp)))
            
            (let ((new-base (- new-time new-timestamp)))
              (if (not time-base)
                  (update-time-base new-base -1.)
                (let ((change (- new-base time-base))
                      (effective-change -.01))
                  (when (< change effective-change)
                    (let ((new-base (+ time-base effective-change)))
                      (update-time-base new-base change))))))))))
    
    (mutex-lock! mutex)
    (unless (visualization?)
      (update-time))
    (let ((timestamp (read-udp-media-seconds data))
          (sequence (read-udp-sequence data))
          (frame (read-udp-frame data))
          (part (read-udp-part data))
          (total (read-udp-total data))
          (header? (read-udp-media-header? data)))
      (define (record-insert)
        (record-event (or insert-event udp-id-insert-packet)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      (fixnum->flonum sequence)
                      (fixnum->flonum frame)
                      (or time-base -1.)
                      (if (not timestamp)
                          -1.
                        timestamp)))
      
      (define (record-nack seq)
        (record-event udp-id-nack-packet
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      (fixnum->flonum seq)
                      (fixnum->flonum sequence)
                      -1.
                      -1.))
      
      (define (record-gap)
        (when last-sequence
          (let ((expected (+ last-sequence 1)))
            (let ((gap (- sequence expected)))
              (when (> gap 0)
                (record-event udp-id-packet-gap
                              (fixnum->flonum origin)
                              (fixnum->flonum media-kind)
                              (fixnum->flonum sequence)
                              (fixnum->flonum frame)
                              (fixnum->flonum gap)
                              -1.)
                (when udp-show-gaps?
                  (terminal remote-name (present-media-kind media-kind) '***packet-gap*** (current-seconds) gap sequence)))))))
      
      (let ((in-order? (or (not last-sequence)
                           (> sequence last-sequence))))
        (cond ;; empty
              ((= count 0)
               (when in-order?
                 (let ((packet (new UDP-Packet timestamp sequence frame part total header? data)))
                   (record-insert)
                   (insert-before self head packet)
                   (set! last-sequence sequence)
                   (set! lowest sequence)
                   (set! highest sequence)
                   (check self)
                   (condition-variable-signal! wait-condvar))))
              ;; insert
              (in-order?
               (let ((packet (new UDP-Packet timestamp sequence frame part total header? data)))
                 (record-gap)
                 (let ((highest-packet (highest-packet self)))
                   (let ((highest-timestamp (get-timestamp highest-packet)))
                     (loop (for seq from (+ highest 1) below sequence)
                           (let ((timestamp (and timestamp highest-timestamp (interpolate seq highest sequence highest-timestamp timestamp))))
                             (insert-before self tail (new UDP-Packet timestamp seq #f #f #f #f #f))
                             (record-nack seq)))))
                 (record-insert)
                 (insert-before self tail packet)
                 (set! last-sequence sequence)
                 (set! highest sequence)
                 (check self)
                 (condition-variable-signal! wait-condvar)))
              ;; replace
              (else
               (if (between? sequence lowest highest)
                   (let ((pos (index self sequence)))
                     (let ((actual-packet (vector-ref packets pos)))
                       (if (get-data actual-packet)
                           (let ((frame (read-udp-frame data)))
                             (record-event udp-id-duplicate-packet
                                           (fixnum->flonum origin)
                                           (fixnum->flonum media-kind)
                                           (fixnum->flonum sequence)
                                           (fixnum->flonum frame)
                                           -1.
                                           -1.))
                         (let ((packet (new UDP-Packet timestamp sequence frame part total header? data)))
                           (vector-set! packets pos packet)
                           (let ((frame (read-udp-frame data)))
                             (record-event udp-id-got-packet
                                           (fixnum->flonum origin)
                                           (fixnum->flonum media-kind)
                                           (fixnum->flonum sequence)
                                           (fixnum->flonum frame)
                                           -1.
                                           -1.))
                           (condition-variable-signal! wait-condvar)))))
                 (let ((frame (read-udp-frame data)))
                   (record-event udp-id-reject-packet
                                 (fixnum->flonum origin)
                                 (fixnum->flonum media-kind)
                                 (fixnum->flonum sequence)
                                 (fixnum->flonum frame)
                                 -1.
                                 -1.)))))))
    (mutex-unlock! mutex))
  
  
  (method public (insert-before self pos packet)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-packets (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subvector-move! packets 0 tail new-packets 0)
          (subvector-move! packets tail size new-packets head)
          (set! size new-size)
          (set! packets new-packets))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (vector-set! packets head packet)
                  (increase! count))
                 ((= pos tail)
                  (vector-set! packets tail packet)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subvector-shift! packets head pos -1)
                        (vector-set! packets (- pos 1) packet)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subvector-shift! packets pos tail 1)
                    (vector-set! packets pos packet)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (if overflow-proc
               (overflow-proc self packet)
             (let ((packet (vector-ref packets tail)))
               (vector-set! packets tail packet)
               (set! tail (modulo (+ tail 1) size))
               (set! head tail))))))
  
  
  (method protected (visualizer-update-time self time-base)
    (set! self.time-base time-base))
  
  
  (method protected (visualizer-replace-got self sequence data)
    (let ((pos (index self sequence)))
      (let ((actual-packet (vector-ref packets pos)))
        (assert (eqv? (get-sequence actual-packet) sequence)
          (assert (not (get-data actual-packet))
            (let ((timestamp (read-udp-media-seconds data))
                  (sequence (read-udp-sequence data))
                  (frame (read-udp-frame data))
                  (part (read-udp-part data))
                  (total (read-udp-total data))
                  (header? (read-udp-media-header? data)))
              (let ((packet (new UDP-Packet timestamp sequence frame part total header? data)))
                (vector-set! packets pos packet))))))))
  
  
  ;;;
  ;;;; Retain
  ;;;
  
  
  (method public (retain-wait self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((now (current-seconds))
                (earliest (vector-ref packets head)))
            (let ((earliest-time (release-time self earliest)))
              (if (>= now earliest-time)
                  (prog1 earliest
                    (vector-set! packets head #f)
                    (set! head (modulo (+ head 1) size))
                    (decrease! count)
                    (increase! lowest)
                    (check self)
                    (mutex-unlock! mutex))
                (mutex-unlock! mutex wait-condvar (- earliest-time now))
                (loop-wait))))))))
  
  
  (method (release-time self packet)
    (let ((timestamp (get-timestamp packet)))
      (if (not timestamp)
          0.
        (+ time-base timestamp udp-retain-window))))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method public (process-wait self timeout average (debug? #f))
    (ecase media-kind
      ((udp-audio) (process-audio self timeout average debug?))
      ((udp-video) (process-video self timeout average debug?))))
  
  
  (method (process-audio self timeout average debug?)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar timeout)
              (if (= count 0)
                  (begin
                    (state-waiting self)
                    (loop-wait))
                (loop-wait)))
          (let ((now (current-seconds))
                (giveup-window udp-audio-window)
                (earliest (vector-ref packets head)))
            (let ((earliest-present (present-time self earliest)))
              (let ((earliest-giveup (+ earliest-present giveup-window)))
                (cond ;; waiting
                      ((eq? state 'waiting)
                       (let ((n (ready-header self now)))
                         (if n
                             ;; header
                             (begin
                               (flush self n average)
                               (set! earliest (vector-ref packets head))
                               (set! earliest-present (present-time self earliest))
                               (state-ok self)
                               (mutex-unlock! mutex)
                               (loop-wait))
                           ;; no header
                           (mutex-unlock! mutex wait-condvar)
                           (loop-wait))))
                      ;; not ready to present
                      ((< now earliest-present)
                       (mutex-unlock! mutex wait-condvar (- earliest-present now))
                       (loop-wait))
                      ;; frame
                      ((ready-frame? self)
                       (prog1 (present self now average)
                         (mutex-unlock! mutex)))
                      ;; not ready to giveup
                      ((< now earliest-giveup)
                       (mutex-unlock! mutex wait-condvar (- earliest-giveup now))
                       (loop-wait))
                      ;; discard
                      ((get-data earliest)
                       (flush-discard self average)
                       (mutex-unlock! mutex)
                       (loop-wait))
                      ;; missing
                      (else
                       (flush-missing self average)
                       (mutex-unlock! mutex)
                       (loop-wait))))))))))
  
  
  (method (process-video self timeout average debug?)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar timeout)
              (if (= count 0)
                  (begin
                    (state-waiting self)
                    (loop-wait))
                (loop-wait)))
          (let ((now (current-seconds))
                (giveup-window udp-video-window)
                (earliest (vector-ref packets head)))
            (let ((earliest-time (earliest-time self earliest))
                  (earliest-present (present-time self earliest)))
              (let ((earliest-late (+ earliest-present .05))
                    (earliest-giveup (+ earliest-present giveup-window)))
                (define (debugging what sleep)
                  (when debug?
                    (let ((sequence (get-sequence earliest))
                          (time (- now earliest-time))
                          (sleep (if (symbol? sleep) sleep (format "{r precision: 3}" sleep)))
                          (content (loop (for n from 0 below count)
                                         (collect (get-sequence (packet-ref self n))))))
                      (format :terminal
                              "{a width: 6} {a} {r precision: 3} {a width: 6} ({l}){%}"
                              what
                              sequence
                              time
                              sleep
                              content))))
                
                (cond ;; sleep
                      ((< now earliest-present)
                       (debugging 'sleep (- earliest-present now))
                       (mutex-unlock! mutex wait-condvar (- earliest-present now))
                       (loop-wait))
                      ;; frame
                      ((ready-frame? self)
                       (prog1 (begin
                                (if (< now earliest-late)
                                    (state-ok self)
                                  (state-late self))
                                (present self now average))
                         (debugging (if (eq? state 'ok) "play  " "freeze") 'return)
                         (mutex-unlock! mutex)))
                      ;; header
                      ((ready-header self now)
                       => (lambda (n)
                            (debugging 'header 'loop)
                            (flush self n average)
                            (set! earliest (vector-ref packets head))
                            (set! earliest-present (present-time self earliest))
                            (mutex-unlock! mutex)
                            (loop-wait)))
                      ;; ok
                      ((< now earliest-late)
                       (debugging 'ok (- earliest-giveup now))
                       (state-ok self)
                       (mutex-unlock! mutex wait-condvar (- earliest-giveup now))
                       (loop-wait))
                      ;; late
                      ((< now earliest-giveup)
                       (debugging 'late (- earliest-giveup now))
                       (state-late self)
                       (mutex-unlock! mutex wait-condvar (- earliest-giveup now))
                       (loop-wait))
                      ;; giveup
                      (else
                       (debugging 'giveup 'loop)
                       (if (get-data earliest)
                           (flush-discard self average)
                         (flush-missing self average))
                       (state-waiting self)
                       (mutex-unlock! mutex)
                       (loop-wait))))))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method protected (earliest-packet self)
    (and (> count 0)
         (vector-ref packets head)))
  
  
  (method protected (packet-ref self n)
    (vector-ref packets (modulo (+ head n) size)))
  
  
  (method (earliest-time self packet)
    (let ((timestamp (get-timestamp packet)))
      (if (not timestamp)
          0.
        (+ time-base timestamp))))
  
  
  (method (present-time self packet)
    (let ((timestamp (get-timestamp packet)))
      (if (not timestamp)
          0.
        (+ time-base timestamp udp-process-window))))
  
  
  (method (ready? self now packet)
    (>= now (present-time self packet)))
  
  
  (method protected (complete-frame? self)
    (let ((earliest (vector-ref packets head)))
      (let ((part (get-part earliest))
            (total (get-total earliest)))
        (and (= part 0)
             (<= total count)
             (loop (for n from 0 below total)
                   (every (get-data (packet-ref self n))))))))
  
  
  (method protected (frame-complete? self pos)
    (let ((packet (packet-ref self pos)))
      (let ((part (get-part packet))
            (total (get-total packet)))
        (and (= part 0)
             (<= (+ pos total) count)
             (loop (for n from 0 below total)
                   (every (get-data (packet-ref self (+ pos n)))))))))
  
  
  (method (ready-frame? self)
    (let ((earliest (vector-ref packets head)))
      (and (get-data earliest)
           (and (complete-frame? self)
                (or (get-header? earliest)
                    (neq? state 'waiting))))))
    
  
  (method (ready-header self now)
    (continuation-capture
      (lambda (found)
        (loop (for n from 1 below count)
              (let ((packet (packet-ref self n)))
                (when (and (get-data packet)
                           (get-header? packet)
                           (= (get-part packet) 0)
                           (ready? self now packet))
                  (let ((frame (get-frame packet))
                        (total (get-total packet)))
                    (let ((last (+ n total -1)))
                      (when (and (< last count)
                                 (loop (for i from (+ n 1) to last)
                                       (every (let ((packet (packet-ref self i)))
                                                (and (get-data packet)
                                                     (= (get-frame packet) frame))))))
                        (continuation-return found n)))))))
        #f)))
  
  
  (method (present self now average)
    (let ((earliest (vector-ref packets head)))
      (let ((frame (get-frame earliest))
            (total (get-total earliest)))
        (prog1 (loop (for n from 0 below total)
                     (collect (get-data (packet-ref self n))))
          (remove-complete-frame self)
          (add-average self average frame 1.)))))
  
  
  (method (add-average self average frame x)
    (when (and last-frame
               (/= frame last-frame))
      (let ((gap (- frame (+ last-frame 1))))
        (loop (repeat gap)
              (add average 0.))))
    (when (or (not last-frame)
              (/= frame last-frame))
      (add average x)
      (set! last-frame frame)))
  
  
  (method (flush self cnt average)
    (loop (repeat cnt)
          (let ((packet (packet-ref self 0)))
            (if (get-data packet)
                (flush-discard self average)
              (flush-missing self average)))))
  
  
  (method (flush-missing self average)
    (let ((earliest (packet-ref self 0)))
      (record-missing-packet self (get-sequence earliest) (get-frame earliest) (get-header? earliest) (get-timestamp earliest))
      (remove-missing self)
      (when (get-frame earliest)
        (add-average self average (get-frame earliest) 0.))))
  
  
  (method (flush-discard self average)
    (let ((earliest (packet-ref self 0)))
      (record-discard-packet self (get-sequence earliest) (get-frame earliest) (get-header? earliest) (get-timestamp earliest))
      (remove-discard self)
      (when (get-frame earliest)
        (add-average self average (get-frame earliest) 0.))))
  
  
  (method protected (remove-complete-frame self)
    (let ((earliest (vector-ref packets head)))
      (remove-count self (get-total earliest))))
  
  
  (method protected (remove-missing self)
    (remove-count self 1))
  
  
  (method protected (remove-discard self)
    (remove-count self 1))
  
  
  (method protected (remove-count self cnt)
    (loop (repeat cnt)
          (vector-set! packets head #f)
          (set! head (modulo (+ head 1) size))
          (decrease! count)
          (increase! lowest))
    (check self))
  
  
  (method protected (state-ok self)
    (unless (eq? state 'ok)
      (set! state 'ok)
      (when state-proc
        (state-proc state))
      (record-event udp-id-state-ok
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    -1.
                    -1.
                    -1.)
      (when udp-show-states?
        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'STATE 'OK))))
  
  
  (method protected (state-late self)
    (unless (eq? state 'late)
      (set! state 'late)
      (when state-proc
        (state-proc state))
      (record-event udp-id-state-late
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    -1.
                    -1.
                    -1.)
      (when udp-show-states?
        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'STATE 'LATE))))
  
  
  (method protected (state-waiting self)
    (unless (eq? state 'waiting)
      (set! state 'waiting)
      (when state-proc
        (state-proc state))
      (record-event udp-id-state-waiting
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    -1.
                    -1.
                    -1.)
      (when udp-show-states?
        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'STATE 'WAITING))))
  
  
  (method (record-missing-packet self sequence frame header? timestamp)
    (record-event udp-id-missing-packet
                  (fixnum->flonum origin)
                  (fixnum->flonum media-kind)
                  (fixnum->flonum sequence)
                  (if (not frame)
                      -1.
                    (fixnum->flonum frame))
                  (barbara-header-hack header?)
                  (if (not timestamp)
                      -1.
                    (timestamp->flonum timestamp))))
  
  
  (method (record-discard-packet self sequence frame header? timestamp)
    (record-event udp-id-discard-packet
                  (fixnum->flonum origin)
                  (fixnum->flonum media-kind)
                  (fixnum->flonum sequence)
                  (fixnum->flonum frame)
                  (barbara-header-hack header?)
                  (if (not timestamp)
                      -1.
                    (timestamp->flonum timestamp))))
  
  
  (method public (locate-data self sequence)
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (let ((packet (vector-ref packets pos)))
                    (get-data packet))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-earliest self predicate)
    (mutex-lock! mutex)
    (prog1 (let (loop (n 0))
             (if (>= n count)
                 #f
               (let ((pos (modulo (+ head n) size)))
                 (let ((packet (vector-ref packets pos)))
                   (if (predicate packet)
                       packet
                     (loop (+ n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-latest self predicate)
    (mutex-lock! mutex)
    (prog1 (let (loop (n (- count 1)))
             (if (< n 0)
                 #f
               (let ((pos (modulo (+ head n) size)))
                 (let ((packet (vector-ref packets pos)))
                   (if (predicate packet)
                       packet
                     (loop (- n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-indexes self proc)
    (mutex-lock! mutex)
    (prog1 (let (loop (n 0))
             (when (< n count)
               (let ((pos (modulo (+ head n) size)))
                 (let ((packet (vector-ref packets pos)))
                   (proc n)
                   (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-earliest self proc)
    (mutex-lock! mutex)
    (prog1 (let (loop (n 0))
             (when (< n count)
               (let ((pos (modulo (+ head n) size)))
                 (let ((packet (vector-ref packets pos)))
                   (proc packet)
                   (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-latest self proc)
    (mutex-lock! mutex)
    (prog1 (let (loop (n (- count 1)))
             (when (>= n 0)
               (let ((pos (modulo (+ head n) size)))
                 (let ((packet (vector-ref packets pos)))
                   (proc packet)
                   (loop (- n 1))))))
      (mutex-unlock! mutex))))


;;;
;;;; Packet
;;;


(class UDP-Packet extends Object
  
  
  (slot timestamp getter generate)
  (slot sequence  getter generate)
  (slot frame     getter generate)
  (slot part      getter generate)
  (slot total     getter generate)
  (slot header?   getter generate)
  (slot data      getter generate)
  
  
  (method override (initialize self timestamp sequence frame part total header? data)
    (nextmethod self)
    (set! self.timestamp timestamp)
    (set! self.sequence sequence)
    (set! self.frame frame)
    (set! self.part part)
    (set! self.total total)
    (set! self.header? header?)
    (set! self.data data))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" sequence)))))


;;;
;;;; Simulator
;;;


(class UDP-Simulator extends Object
  
  
  (property latency             getter generate)
  (property lag                 getter generate)
  (property drop                getter generate)
  (property congestion          accessors generate)
  (property congestion-duration accessors generate)
  
  (slot congestion-occuring? getter generate)
  (slot congestion-ends      accessors generate)
  (slot writer               getter generate)
  (slot ring                 getter generate)
  (slot thread               getter generate)
  
  
  (method override (initialize self latency lag drop writer)
    (nextmethod self)
    (set! self.latency latency)
    (set! self.lag lag)
    (set! self.drop drop)
    (set! self.congestion udp-congestion)
    (set! self.congestion-duration udp-congestion-duration)
    (set! self.congestion-occuring? #f)
    (set! self.congestion-ends #f)
    (set! self.writer writer)
    (set! self.ring (new Time-Ring udp-simulator-size max-size: udp-simulator-max-size overflow-proc: (udp-ring-overflow 'simulator udp-ring-kind-simulator)))
    (set! self.thread (new-thread
                        (lambda ()
                          (send-loop self))
                        'simulator))
    (thread-base-priority-set! thread simulator-priority)
    (thread-start! thread))
  
  
  (method protected (send self info)
    ;; congestion
    (if congestion
        (if (not congestion-occuring?)
            (if (or (eq? congestion #t)
                    (< (random-real) (/ congestion 100.)))
                (let ((ends (if (eq? congestion-duration #t) +inf.0 (random-between 0. congestion-duration))))
                  (set! congestion-occuring? #t)
                  (set! congestion-ends ends)
                  (when udp-show-congestion?
                    (format :terminal "{s} {s} {s}{%}" remote-name 'CONGESTION 'ON)))
              (writer info (drop? self)))
          (when (or (not congestion-ends)
                    (>= (current-seconds) congestion-ends))
            (set! congestion-occuring? #f)
            (set! congestion-ends #f)
            (when udp-show-congestion?
              (format :terminal "{s} {s} {s}{%}" remote-name 'CONGESTION 'OFF))
            (writer info (drop? self))))
      ;; latency
      (if latency
          (insert ring (+ (current-seconds) latency) info)
        (writer info (drop? self)))))
  
  
  (method (drop? self)
    (and drop (< (random-real) (/ drop 100.))))
  
  
  (method (send-loop self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((info (wait ring)))
        (writer info (drop? self)))
      (loop))))


;;;
;;;; Media
;;;


(definition public (media-packet-header? data)
  (and (= (read-udp-part data) 0)
       (read-udp-media-header? data)))


;;;
;;;; Access
;;;


(definition public (scan-boolean data pos)
  (/= (scan-s8 data pos) 0))


(definition public (scan-u8vector data pos)
  (let ((len (scan-s32 data pos)))
    (let ((v (make-u8vector len))
          (pos (+ pos 4)))
      (subu8vector-move! data pos (+ pos len) v 0)
      v)))


(definition public (scan-host data pos)
  (u8vector (u8vector-ref data pos)
            (u8vector-ref data (+ pos 1))
            (u8vector-ref data (+ pos 2))
            (u8vector-ref data (+ pos 3))))


(definition public (put-boolean data pos value)
  (put-s8 data pos (if value 1 0)))


(definition public (put-u8vector data pos value)
  (let ((len (u8vector-length value)))
    (put-s32 data pos len)
    (let ((pos (+ pos 4)))
      (subu8vector-move! value 0 len data pos))))


(definition public (put-subu8vector! data pos value offset count)
  (put-s32 data pos count)
  (let ((pos (+ pos 4)))
    (subu8vector-move! value offset (+ offset count) data pos)))


(definition public (put-host data pos value)
  (u8vector-set! data pos (u8vector-ref value 0))
  (u8vector-set! data (+ pos 1) (u8vector-ref value 1))
  (u8vector-set! data (+ pos 2) (u8vector-ref value 2))
  (u8vector-set! data (+ pos 3) (u8vector-ref value 3)))


;;;
;;;; Format
;;;


;; udp
(definition public (read-udp-sent            data) (scan-double   data  0)) (definition public (write-udp-sent            data value) (put-double   data  0 value))
(definition public (read-udp-kind            data) (scan-s8       data  8)) (definition public (write-udp-kind            data value) (put-s8       data  8 value))
(definition public (read-udp-origin          data) (scan-s32      data 12)) (definition public (write-udp-origin          data value) (put-s32      data 12 value))
(definition public (read-udp-sequence        data) (scan-s32      data 16)) (definition public (write-udp-sequence        data value) (put-s32      data 16 value))
(definition public (read-udp-frame           data) (scan-s32      data 20)) (definition public (write-udp-frame           data value) (put-s32      data 20 value))
(definition public (read-udp-part            data) (scan-s32      data 24)) (definition public (write-udp-part            data value) (put-s32      data 24 value))
(definition public (read-udp-total           data) (scan-s32      data 28)) (definition public (write-udp-total           data value) (put-s32      data 28 value))
(definition public (read-udp-media-timestamp data) (scan-s64      data 32)) (definition public (write-udp-media-timestamp data value) (put-s64      data 32 value))
(definition public (read-udp-media-duration  data) (scan-s64      data 40)) (definition public (write-udp-media-duration  data value) (put-s64      data 40 value))
(definition public (read-udp-media-payload   data) (scan-u8vector data 48)) (definition public (write-udp-media-payload   data value) (put-u8vector data 48 value)) (definition public udp-media-buffer-offset (+ 48 4))
(definition public (read-udp-media-header?   data) (scan-boolean  data  9)) (definition public (write-udp-media-header?   data value) (put-boolean  data  9 value))
(definition public (read-udp-media-off?      data) (scan-boolean  data 10)) (definition public (write-udp-media-off?      data value) (put-boolean  data 10 value))

(definition public (read-udp-media-seconds data)
  (let ((timestamp (read-udp-media-timestamp data)))
    (if (= timestamp -1)
        #f
      (/ timestamp nanosecond))))

(definition public (read-udp-media-payload-size data)
  (scan-s32 data 48))

(definition public (write-udp-media-subpayload data value offset count)
  (put-subu8vector! data 48 value offset count))

;; connect
(definition public (read-udp-connect-local-host  data) (scan-host    data 16)) (definition public (write-udp-connect-local-host  data value) (put-host    data 16 value))
(definition public (read-udp-connect-local-port  data) (scan-s32     data 20)) (definition public (write-udp-connect-local-port  data value) (put-s32     data 20 value))
(definition public (read-udp-connect-latency     data) (scan-float   data 24)) (definition public (write-udp-connect-latency     data value) (put-float   data 24 value))
(definition public (read-udp-connect-lag         data) (scan-float   data 28)) (definition public (write-udp-connect-lag         data value) (put-float   data 28 value))
(definition public (read-udp-connect-drop        data) (scan-float   data 32)) (definition public (write-udp-connect-drop        data value) (put-float   data 32 value))

;; state
(definition public (read-udp-state-channels data) (scan-u8vector data 16)) (definition public (write-udp-state-channels data value) (put-u8vector data 16 value))

;; ack
(definition public (read-udp-ack-packets-sent     data) (scan-s32 data 16)) (definition public (write-udp-ack-packets-sent     data value) (put-s32 data 16 value))
(definition public (read-udp-ack-packets-received data) (scan-s32 data 20)) (definition public (write-udp-ack-packets-received data value) (put-s32 data 20 value))

;; nack
(definition public (read-udp-nack-media-kind     data) (scan-s32      data 16)) (definition public (write-udp-nack-media-kind     data value) (put-s32      data 16 value))
(definition public (read-udp-nack-latest-missing data) (scan-u8vector data 20)) (definition public (write-udp-nack-latest-missing data value) (put-u8vector data 20 value)))
