;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.udp jazz


(import (jazz.geometry)
        (jazz.io)
        (jazz.presence)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.binary)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.math)
        (world.ring)
        (world.settings)
        (world.simulate)
        (world.task)
        (world.time))


(definition protected udp-connect <fx>
  0)

(definition protected udp-connected <fx>
  1)

(definition protected udp-state <fx>
  2)

(definition protected udp-ack <fx>
  3)

(definition protected udp-nack <fx>
  4)

(definition protected udp-audio <fx>
  5)

(definition protected udp-video <fx>
  6)

(definition protected udp-alive <fx>
  7)

(definition protected udp-alive-ack <fx>
  8)

(definition protected udp-profile-pulse <fx>
  9)

(definition protected udp-profile-media <fx>
  10)

(definition protected udp-upload-ping <fx>
  11)

(definition protected udp-upload-ack <fx>
  12)


(definition udp-names
  #(connect connected state ack nack audio video alive alive-ack profile-pulse profile-media))

(definition protected (udp-name kind)
  (vector-ref udp-names kind))


;; MTU - IP HEADER - UDP HEADER
;; 1500 - 20 (60) - 8 = 1472 (1432)
(definition protected udp-datagram-max <fx>
  (world-setting 'world.udp-datagram-max 1432))

(definition protected udp-retain-size <fx>
  (world-setting 'world.udp-retain-size 256))

(definition protected udp-retain-max-size <fx>
  (world-setting 'world.udp-retain-max-size 8192))

(definition protected udp-sender-retain-window <fl>
  (world-setting 'world.udp-sender-retain-window 1.))

(definition protected udp-server-retain-window <fl>
  (world-setting 'world.udp-server-retain-window 1.))

;; gstreamer's audio buffer time
(definition protected udp-audio-buffer <fl>
  (world-setting 'world.udp-audio-buffer .2))

;; this value should be consistent with
;; gstreamer's audio sink buffer-time and
;; lets give it a slightly smaller value
(definition protected udp-audio-giveup <fl>
  (world-setting 'world.udp-audio-giveup (- udp-audio-buffer .01)))

(definition protected udp-video-giveup <fl>
  (world-setting 'world.udp-video-giveup .5))

(definition protected udp-video-late <fl>
  (world-setting 'world.udp-video-late .05))

(definition protected udp-process-size <fx>
  (world-setting 'world.udp-process-size 256))

(definition protected udp-process-max-size <fx>
  (world-setting 'world.udp-process-max-size 4096))

(definition protected udp-audio-process-window <fl>
  (world-setting 'world.udp-audio-process-window .2))

(definition protected udp-video-process-window <fl>
  (world-setting 'world.udp-video-process-window (+ udp-audio-process-window udp-audio-buffer)))

(definition protected udp-latency-threshold <fl>
  (world-setting 'world.udp-latency-threshold .01))

(definition protected udp-latency-increment <fl>
  (world-setting 'world.udp-latency-increment .01))

(definition protected udp-latency-decrement <fl>
  (world-setting 'world.udp-latency-decrement .01))

(definition protected udp-simulator-size <fx>
  (world-setting 'world.udp-simulator-size 256))

(definition protected udp-simulator-max-size <fx>
  (world-setting 'world.udp-simulator-max-size 4096))

(definition protected udp-max-gap <fx+>
  (world-setting 'world.udp-max-gap #f))

(definition protected udp-state-rate <fl>
  (world-setting 'world.udp-state-rate 5.))

(definition protected udp-state-period <fl>
  (/ 1. udp-state-rate))

(definition protected udp-throttle <fl>
  (world-setting 'world.udp-throttle 1.))


(definition protected udp-receive-buffer-size
  (world-setting 'world.udp-receive-buffer-size #f))

(definition protected udp-send-buffer-size
  (world-setting 'world.udp-send-buffer-size #f))

(definition protected (setup-udp-port-buffers port)
  (if udp-receive-buffer-size
      (udp-socket-receive-buffer-size-set! port udp-receive-buffer-size)
    (cond-expand
      (windows
       (let ((size (udp-socket-receive-buffer-size port)))
         (when (< size 65536)
           (udp-socket-receive-buffer-size-set! port 65536))))
      (else)))
  (if udp-send-buffer-size
      (udp-socket-send-buffer-size-set! port udp-send-buffer-size)
    (cond-expand
      (windows
       (let ((size (udp-socket-send-buffer-size port)))
         (when (< size 65536)
           (udp-socket-send-buffer-size-set! port 65536))))
      ;; mac os x having only a 8192 send buffer doesn't seem
      ;; to be a problem...
      (else))))


(definition protected udp-record-read/write?
  (world-setting 'world.udp-record-read/write? #f))

(definition protected udp-record-src/sink?
  (world-setting 'world.udp-record-src/sink? #f))


(definition protected udp-show-reconnect?
  (world-setting 'world.udp-show-reconnect? #f))

(definition protected udp-show-roundtrip?
  (world-setting 'world.udp-show-roundtrip? #f))

(definition protected udp-show-invalids?
  (world-setting 'world.udp-show-invalids? #f))

(definition protected udp-show-overflows?
  (world-setting 'world.udp-show-overflows? #f))

(definition protected udp-show-gaps?
  (world-setting 'world.udp-show-gaps? #f))

;; duplicates are usually a normal consequence of nacks
(definition protected udp-show-duplicates?
  (world-setting 'world.udp-show-duplicates? #f))

(definition protected udp-show-late?
  (world-setting 'world.udp-show-late? #f))

(definition protected udp-show-missing?
  (world-setting 'world.udp-show-missing? #f))

(definition protected udp-show-resend?
  (world-setting 'world.udp-show-resend? #f))

(definition protected udp-show-retries?
  (world-setting 'world.udp-show-retries? #f))

(definition protected udp-show-states?
  (world-setting 'world.udp-show-states? #f))

(definition protected udp-show-resetting?
  (world-setting 'world.udp-show-resetting? #f))

(definition protected udp-show-resets?
  (world-setting 'world.udp-show-resets? #f))

(definition protected udp-show-throttle?
  (world-setting 'world.udp-show-throttle? #f))

(definition protected udp-show-skipping?
  (world-setting 'world.udp-show-skipping? #f))

(definition protected udp-show-congestion?
  (world-setting 'world.udp-show-congestion? #f))

(definition protected udp-show-nacks?
  (world-setting 'world.udp-show-nacks? #f))

(definition protected udp-show-profile?
  (world-setting 'world.udp-show-profile? #f))

(definition protected udp-show-replay?
  (world-setting 'world.udp-show-replay? #f))

(definition protected udp-freeze-overlay
  (world-setting 'world.udp-freeze-overlay #f))

(definition protected udp-wait-overlay
  (world-setting 'world.udp-wait-overlay #f))


(definition protected udp-latency
  (world-setting 'world.udp-latency #f))

(definition protected udp-drop
  (world-setting 'world.udp-drop #f))

(definition protected udp-congestion
  (world-setting 'world.udp-congestion #f))

(definition protected udp-congestion-duration
  (world-setting 'world.udp-congestion-duration 5.))


(definition protected udp-media-off
  #u8(111 102 102))


(definition protected (present-media-kind kind)
  (if (= kind udp-audio)
      'AUDIO
    'VIDEO))


(definition protected (bytes->mbps bytes <fl>) <fl>
  (/ bytes 131072.))

(definition protected (mbps->bytes mbps <fl>) <fx>
  (fxround (* mbps 131072.)))


(definition public inline (evolutionary-udp-time    evolution <Evolution> n <fx>) <fl> (evolutionary-time  evolution n))
(definition public inline (evolutionary-udp-id      evolution <Evolution> n <fx>) <fl> (evolutionary-id    evolution n))
(definition public inline (evolutionary-udp-channel evolution <Evolution> n <fx>) <fl> (evolutionary-data1 evolution n))
(definition public inline (evolutionary-udp-origin  evolution <Evolution> n <fx>) <fl> (evolutionary-data2 evolution n))
(definition public inline (evolutionary-udp-kind    evolution <Evolution> n <fx>) <fl> (evolutionary-data3 evolution n))
(definition public inline (evolutionary-udp-data1   evolution <Evolution> n <fx>) <fl> (evolutionary-data4 evolution n))
(definition public inline (evolutionary-udp-data2   evolution <Evolution> n <fx>) <fl> (evolutionary-data5 evolution n))
(definition public inline (evolutionary-udp-data3   evolution <Evolution> n <fx>) <fl> (evolutionary-data6 evolution n))
(definition public inline (evolutionary-udp-data4   evolution <Evolution> n <fx>) <fl> (evolutionary-data7 evolution n))
(definition public inline (evolutionary-udp-data5   evolution <Evolution> n <fx>) <fl> (evolutionary-data8 evolution n))
(definition public inline (evolutionary-udp-data6   evolution <Evolution> n <fx>) <fl> (evolutionary-data9 evolution n))

(definition public inline (evolutionary-udp-sequence evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data1 evolution n)))
(definition public inline (evolutionary-udp-frame    evolution <Evolution> n <fx>) <fx> (flonum->fixnum (evolutionary-udp-data2 evolution n)))


(definition public (evolutionary-udp-receive-ack-state-sequence     evolution <Evolution> n <fx>) (evolutionary-udp-data1 evolution n))
(definition public (evolutionary-udp-receive-ack-round-trip         evolution <Evolution> n <fx>) (evolutionary-udp-data2 evolution n))
(definition public (evolutionary-udp-receive-ack-state-sent         evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-receive-ack-ack-sent           evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))

(definition public (evolutionary-udp-traffic-rate-state-sequence    evolution <Evolution> n <fx>) (evolutionary-udp-data1 evolution n))
(definition public (evolutionary-udp-traffic-rate-last-send-rate    evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-traffic-rate-last-receive-rate evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))

(definition public (evolutionary-udp-update-time-now                evolution <Evolution> n <fx>) (evolutionary-udp-data2 evolution n))
(definition public (evolutionary-udp-update-time-current-latency    evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-update-time-timestamp          evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))
(definition public (evolutionary-udp-update-time-effective-latency  evolution <Evolution> n <fx>) (evolutionary-udp-data5 evolution n))

(definition public (evolutionary-udp-insert-packet-latency          evolution <Evolution> n <fx>) (evolutionary-udp-data3 evolution n))
(definition public (evolutionary-udp-insert-packet-dts              evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))
(definition public (evolutionary-udp-insert-packet-base             evolution <Evolution> n <fx>) (evolutionary-udp-data5 evolution n))
(definition public (evolutionary-udp-insert-packet-last-latency     evolution <Evolution> n <fx>) (evolutionary-udp-data6 evolution n))

(definition public (evolutionary-udp-play-frame-pts                 evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))
(definition public (evolutionary-udp-freeze-frame-pts               evolution <Evolution> n <fx>) (evolutionary-udp-data4 evolution n))


;; relies on 0 reserved for #f in next-literal-id
(definition protected server-no
  0)

(definition protected server-sender
  "Server")


(definition protected reconnect-marker
  123456.)

(definition protected no-connection-marker
  123456.)

(definition protected (barbara-keyframe-hack keyframe?)
  (if keyframe?
      123456.
    -1.))


;;;
;;;; Ring
;;;


(definition protected udp-ring-kind-retain
  0.)

(definition protected udp-ring-kind-process
  1.)

(definition protected udp-ring-kind-simulator
  2.)


(definition protected (udp-ring-overflow name kind)
  (lambda (ring data bumped-data)
    (record-event udp-id-ring-overflow
                  (fixnum->flonum (get-no ring))
                  (fixnum->flonum (get-origin ring))
                  (fixnum->flonum (get-media-kind ring))
                  (if (= kind udp-ring-kind-simulator)
                      -1.
                    (fixnum->flonum (get-sequence data)))
                  (fixnum->flonum (get-count ring))
                  kind
                  (fixnum->flonum (get-sequence bumped-data)))
    (when udp-show-overflows?
      (format :terminal "{s} {s} {s}{%}" presence-name '***overflow*** name))))


;;;
;;;; Read/Write
;;;


(definition protected (read-data port)
  (let ((data (read port)))
    (when udp-record-read/write?
      (let ((channel (read-udp-channel data))
            (sender (read-udp-sender data))
            (media-kind (read-udp-kind data))
            (sequence (read-udp-sequence data))
            (frame (read-udp-frame data)))
        (record-event udp-id-read-data
                      (fixnum->flonum channel)
                      (fixnum->flonum sender)
                      (fixnum->flonum media-kind)
                      (fixnum->flonum sequence)
                      (fixnum->flonum frame)
                      -1.
                      (fixnum->flonum (u8vector-length data)))))
    data))


(definition protected (write-data data port)
  ;; quick temporary hack to get back the safe behavior
  ;; of retrying-write until port being false is fixed
  (when port
    (write data port)
    (when udp-record-read/write?
      (let ((channel (read-udp-channel data))
            (sender (read-udp-sender data))
            (media-kind (read-udp-kind data))
            (sequence (read-udp-sequence data))
            (frame (read-udp-frame data)))
        (record-event udp-id-write-data
                      (fixnum->flonum channel)
                      (fixnum->flonum sender)
                      (fixnum->flonum media-kind)
                      (fixnum->flonum sequence)
                      (fixnum->flonum frame)
                      -1.
                      (fixnum->flonum (u8vector-length data)))))))


;;;
;;;; Tolerance
;;;


;; retry write every 1/100s for 1s
(definition protected (safe-write data port)
  (declare (proper-tail-calls))
  (let (loop (n 0))
    (handle-exception-filter
      (lambda (exc)
        (< n 100))
      (lambda (exc)
        (sleep .01)
        (if (< n 99)
            (begin
              (when udp-show-retries?
                (format :terminal "{s} {s} {s}{%}" presence-name '***retry*** n))
              (loop (+ n 1)))
          (record-event udp-id-write-failure
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.
                        -1.)
          (bailout-client (current-client) exc (execution-stack))
          exc))
      (lambda ()
        (write-data data port)
        #f))))


;;;
;;;; Tier
;;;


(definition public (current-udp)
  (get-udp-tier (current-tier)))


(class UDP-Tier extends Object
  
  
  (slot send-streams  initialize #f getter generate)
  (slot send-channels initialize #f getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! send-streams (make-table))
    (set! send-channels (make-table))
    (register-snapshot-callback (~ snapshot-send-streams self)))
  
  
  (method (snapshot-send-streams self)
    (let ((info (map (lambda (stream)
                       (list (get-sender stream)
                             (get-name stream)
                             (get-source-kind stream)))
                     (table-values send-streams))))
      (add-snapshot-property 'live.udp-send info)))
  
  
  (method package (register-send-stream self sender name stream-no source-kind video-level)
    (let ((stream (new UDP-Send-Stream sender name stream-no client-no source-kind video-level)))
      (table-set! send-streams stream-no stream)
      stream))
  
  
  (method public (find-send-stream self stream-no)
    (table-ref send-streams stream-no #f))
  
  
  (method public (locate-send-stream self predicate)
    (table-search (lambda (no stream)
                    (and (predicate stream)
                         stream))
                  send-streams))
  
  
  (method public (find-send-channel self channel-no)
    (table-ref send-channels channel-no #f))
  
  
  (method public (find-streaming self location)
    (table-search (lambda (no stream)
                    (let ((stream-location (get-location stream)))
                      (and stream-location
                           (filename=? location stream-location)
                           stream)))
                  send-streams))
  
  
  (method public (collect-streaming self)
    (let ((queue (new-queue)))
      (iterate-table send-channels
        (lambda (no channel)
          (when (get-stream? (get-src (get-pipeline channel)))
            (enqueue queue channel))))
      (queue-list queue)))
  
  
  (method protected (gather-replay-missing self missing)
    (let ((queue (new-queue)))
      (for-each (lambda (info)
                  (bind (channel-no . missing) info
                    (let ((channel (find-send-channel self channel-no)))
                      (when channel
                        (let ((ring (get-replay-ring channel)))
                          (when ring
                            (for-each (lambda (sequence)
                                        (let ((packet (locate-packet ring sequence)))
                                          (when packet
                                            (enqueue queue (get-data packet)))))
                                      missing)))))))
                missing)
      (queue-list queue))))


;;;
;;;; Stream
;;;


(definition protected next-stream-no <fx>
  0)

(definition protected (next-stream-no!) <fx>
  (prog1 next-stream-no
    (increase! next-stream-no)))


(definition protected (stream-video-level stream profile-level)
  (let ((stream-level (get-video-level stream)))
    (and stream-level
         (let (iter (level (min stream-level profile-level)))
           (cond ;; this will need to be revisited but if no compatible
                 ;; quality found use the stream level so everything works
                 ;; and for now this will also enable showcasing high quality
                 ((< level 0)
                  stream-level)
                 ((find-level stream level)
                  level)
                 (else
                  (iter (- level 1))))))))


(class UDP-Stream extends Object
  
  
  (slot sender         getter generate)
  (slot name           getter generate)
  (slot no             getter generate)
  (slot origin         getter generate)
  (slot source-kind    getter generate)
  (slot video-level    accessors generate)
  (slot channels       getter generate)
  (slot level-channels getter generate)
  
  
  (method override (initialize self sender name no origin source-kind video-level)
    (nextmethod self)
    (set! self.sender sender)
    (set! self.name name)
    (set! self.no no)
    (set! self.origin origin)
    (set! self.source-kind source-kind)
    (set! self.video-level video-level)
    (set! self.channels (make-table test: eqv?))
    (set! self.level-channels (make-vector 5 #f)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a} {a} {a} {a}" sender name no origin source-kind video-level))))
  
  
  (method protected (add-child self channel)
    (table-set! channels (get-no channel) channel)
    (let ((level (get-level channel)))
      (when level
        (vector-set! level-channels level channel))))
  
  
  (method protected (play self)
    (iterate-table channels
      (lambda (no channel)
        (play channel))))
  
  
  (method protected (find-level self level)
    (vector-ref level-channels level))
  
  
  (method public (effective-name self)
    (if (eq? source-kind 'live)
        sender
      name)))


;;;
;;;; Send Stream
;;;


(class UDP-Send-Stream extends UDP-Stream
  
  
  (slot location    initialize #f accessors generate)
  (slot action-proc initialize #f accessors generate)
  
  
  (method protected (locate-audio-channel self)
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-audio)
                         channel))
                  channels))
  
  
  (method protected (locate-video-channel self)
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-video)
                         channel))
                  channels))
  
  
  (method protected (locate-level-channel self level)
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-video)
                         (= (get-level channel) level)
                         channel))
                  channels))
  
  
  (method protected (collect-video-channels self)
    (let ((queue (new-queue)))
      (iterate-table channels
        (lambda (no channel)
          (when (= (get-media-kind channel) udp-video)
            (enqueue queue channel))))
      (queue-list queue))))


;;;
;;;; Channel
;;;


(definition protected next-channel-no <fx>
  0)

(definition protected (next-channel-no!) <fx>
  (prog1 next-channel-no
    (increase! next-channel-no)))


(class UDP-Channel extends Object
  
  
  (slot stream      getter generate)
  (slot no          getter generate)
  (slot media-kind  getter generate)
  (slot source-kind getter generate)
  (slot level       getter generate)
  (slot resolution  getter generate)
  (slot framerate   getter generate)
  (slot bitrate     getter generate)
  (slot codec       getter generate)
  (slot caps        getter generate)
  (slot metadata    getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (nextmethod self)
    (set! self.stream stream)
    (set! self.no no)
    (set! self.media-kind media-kind)
    (set! self.source-kind source-kind)
    (set! self.level level)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.metadata metadata)
    (add-child stream self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (if (= media-kind udp-video)
            (format output "{a} {a} {a} {a} {a} {a} {a}" (get-sender stream) (get-name stream) no media-kind source-kind level resolution)
          (format output "{a} {a} {a} {a} {a}" (get-sender stream) (get-name stream) no media-kind source-kind))))))


(definition protected (streams-metadata streams)
  (map-table (lambda (no stream)
               (list
                 (get-sender stream)
                 (get-name stream)
                 (get-no stream)
                 (get-origin stream)
                 (get-source-kind stream)
                 (get-video-level stream)
                 (map-table (lambda (no channel)
                              (list
                                (get-no channel)
                                (get-media-kind channel)
                                (get-source-kind channel)
                                (get-level channel)
                                (get-resolution channel)
                                (get-framerate channel)
                                (get-bitrate channel)
                                (get-codec channel)
                                (get-caps channel)
                                (get-metadata channel)))
                            (get-channels stream))))
             streams))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Channel
  
  
  (slot pipeline       accessors generate)
  (slot action-proc    accessors generate)
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-dts       accessors generate)
  (slot last-pts       accessors generate)
  (slot last-reset     getter generate)
  (slot wait-keyframe? getter generate)
  (slot replay-ring    getter generate)
  (slot retain-ring    getter generate)
  (slot release-task   getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (nextmethod self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (set! self.pipeline #f)
    (set! self.action-proc #f)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-dts #f)
    (set! self.last-pts #f)
    (set! self.last-reset #f)
    (set! self.wait-keyframe? (= media-kind udp-video))
    (set! self.replay-ring (remember-ring media-kind source-kind level framerate))
    (set! self.retain-ring (new UDP-Ring self no (get-origin stream) media-kind udp-retain-size max-size: udp-retain-max-size overflow-proc: (udp-ring-overflow 'retain udp-ring-kind-retain) retain-window: udp-sender-retain-window))
    (unless (simulation?)
      (set! self.release-task (new Task 'udp-release (lambda (task)
                                                       (release-loop self task))
                                   priority: udp-priority))
      (start-task release-task)))
  
  
  (method override (destroy self)
    (when pipeline
      (release pipeline)
      (close pipeline))
    (terminate retain-ring)
    (thread-join! (get-thread release-task))
    (nextmethod self))
  
  
  (method protected (waiting-keyframe? self)
    wait-keyframe?)
  
  
  (method protected (wait-keyframe self)
    (when (= media-kind udp-video)
      (set! wait-keyframe? #t)))
  
  
  (method protected (got-keyframe self)
    (set! wait-keyframe? #f))
  
  
  (method (playing? self)
    (if (not pipeline)
        #f
      (playing? (get-src pipeline))))
  
  
  (method (setup self)
    (when pipeline
      (setup pipeline)))
  
  
  (method (start self)
    (when pipeline
      (start pipeline)))
  
  
  (method (play self)
    (when pipeline
      (play pipeline)))
  
  
  (method (pause self)
    (when pipeline
      (pause pipeline)))
  
  
  (method (stop self)
    (when pipeline
      (stop pipeline)))
  
  
  (method (release self)
    (when pipeline
      (release pipeline)))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (remember-media self data)
    (when replay-ring
      (remember replay-ring data)))
  
  
  (method protected (retain-media self data)
    (insert retain-ring data udp-id-retain-packet))
  
  
  (method protected (send-media self buffer dts pts duration keyframe? send)
    (let ((off? (not buffer))
          (frame (next-frame-sequence! self))
          ;; give media off a sequential dts so it gets inserted correctly
          (dts (or dts (+ (or last-dts 0) 1)))
          ;; give media off a sequential pts so it gets inserted correctly
          (pts (or pts (+ (or last-pts 0) 1)))
          (duration (or duration 1))
          ;; udp-media-off is not really used for its content anymore
          ;; but it is still useful as an empty buffer ends the logic
          (buffer (or buffer udp-media-off)))
      (set! last-dts dts)
      (set! last-pts pts)
      (let ((header-size (+ (udp-media-header-size) udp-code-size))
            (payload-size (u8vector-length buffer)))
        (let ((max-content-size (- udp-datagram-max header-size)))
          (let ((total (fxceiling/ payload-size max-content-size)))
            (let (loop-part (part 0) (pos 0))
              (let ((remain (- payload-size pos)))
                (when (> remain 0)
                  (let ((sequence (next-data-sequence! self))
                        (content-size (min remain max-content-size)))
                    (let ((size (+ header-size content-size)))
                      (let ((data (make-u8vector size)))
                        (write-udp-sent data (current-seconds))
                        (write-udp-kind data media-kind)
                        (write-udp-sender data client-no)
                        (write-udp-channel data no)
                        (write-udp-sequence data sequence)
                        (write-udp-frame data frame)
                        (write-udp-part data part)
                        (write-udp-total data total)
                        (write-udp-media-dts data dts)
                        (write-udp-media-pts data pts)
                        (write-udp-media-duration data duration)
                        (write-udp-media-subpayload data buffer pos content-size)
                        (write-udp-media-keyframe? data keyframe?)
                        (write-udp-media-off? data off?)
                        (write-udp-resent data 0)
                        (write-udp-code data)
                        ;; quick hack to make media off more robust
                        (if off?
                            (loop (repeat 3)
                                  (send data))
                          (send data))
                        (record-event udp-id-create-packet
                                      (fixnum->flonum no)
                                      (fixnum->flonum client-no)
                                      (fixnum->flonum media-kind)
                                      (fixnum->flonum sequence)
                                      (fixnum->flonum frame)
                                      (barbara-keyframe-hack keyframe?)
                                      (timestamp->flonum dts)
                                      (timestamp->flonum pts))
                        (record-event udp-id-create-info
                                      (fixnum->flonum no)
                                      (fixnum->flonum client-no)
                                      (fixnum->flonum media-kind)
                                      (fixnum->flonum sequence)
                                      (fixnum->flonum part)
                                      (fixnum->flonum total)
                                      (timestamp->flonum duration))
                        (remember-media self data)
                        (retain-media self data)
                        (loop-part (+ part 1) (+ pos content-size)))))))))))))
  
  
  (method (reset-media self)
    (when pipeline
      (let ((src (get-src pipeline)))
        (when (and (resettable? src)
                   (playing? src))
          (let ((now (current-seconds)))
            (if (and last-reset (< (- now last-reset) (reset-cooldown src)))
                (when udp-show-resetting?
                  (format :terminal "{s} {s} {s} {s} - {a} ({a}){%}" presence-name (present-media-kind media-kind) 'RESET 'COOLDOWN (effective-name stream) no))
              (reset-media src self)
              (set! last-reset now)
              (record-event udp-id-reset-media
                            (fixnum->flonum no)
                            (fixnum->flonum client-no)
                            (fixnum->flonum media-kind)
                            -1.
                            -1.
                            -1.
                            -1.)
              (when udp-show-resets?
                (format :terminal "{s} {s} {s} {s} -     {a} ({a}){%}" presence-name (present-media-kind media-kind) 'RESET 'DONE (effective-name stream) no))))))))
  
  
  (method protected (release-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((packet (retain-wait retain-ring)))
            (if (eq? packet 'terminate)
                (continuation-return exit #f)
              (site udp-release
                (release-media self packet))
              (loop)))))))
  
  
  (method protected (release-media self packet)
    (let ((data (get-data packet))
          (origin (get-origin stream)))
      (if (not data)
          (let ((removed-sequence (get-sequence packet)))
            (record-event udp-id-giveup-packet
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum removed-sequence)
                          -1.
                          -1.
                          -1.))
        (let ((sequence (read-udp-sequence data))
              (frame (read-udp-frame data))
              (dts (read-udp-media-dts data)))
          (record-event udp-id-release-packet
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        (fixnum->flonum sequence)
                        (fixnum->flonum frame)
                        -1.
                        (timestamp->flonum dts)))))))


;;;
;;;; Packet
;;;


(class UDP-Packet-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-dts object))
                              (serialize (get-pts object))
                              (serialize (get-duration object))
                              (serialize (get-sequence object))
                              (serialize (get-frame object))
                              (serialize (get-part object))
                              (serialize (get-total object))
                              (serialize (get-keyframe? object))
                              (serialize (get-data object)))))
  
  
  (method override (unmarshall-object self content)
    (bind-vector (dts pts duration sequence frame part total keyframe? data) content
      (allocate self
                (deserialize dts)
                (deserialize pts)
                (deserialize duration)
                (deserialize sequence)
                (deserialize frame)
                (deserialize part)
                (deserialize total)
                (deserialize keyframe?)
                (deserialize data)))))


(class UDP-Packet metaclass UDP-Packet-Class extends Object
  
  
  (slot dts            getter generate)
  (slot pts            getter generate)
  (slot duration       getter generate)
  (slot sequence  <fx> getter generate)
  (slot frame          getter generate)
  (slot part           getter generate)
  (slot total          getter generate)
  (slot keyframe?      getter generate)
  (slot data           accessors generate)
  
  
  (method override (initialize self dts pts duration sequence frame part total keyframe? data)
    (nextmethod self)
    (set! self.dts dts)
    (set! self.pts pts)
    (set! self.duration duration)
    (set! self.sequence sequence)
    (set! self.frame frame)
    (set! self.part part)
    (set! self.total total)
    (set! self.keyframe? keyframe?)
    (set! self.data data))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" sequence)))))


;;;
;;;; Remember
;;;

;; temporary copy/paste of UDP-Ring


(definition protected remember-audio
  (world-setting 'world.remember-audio 60))

(definition protected remember-video
  (world-setting 'world.remember-video 30))


(definition average-audio-packets/frame
  1.0)

(definition average-video-packets/frame
  (vector
    6.2
    6.2
    6.6
    9.6
    15.7))


(definition protected (remember-ring media-kind source-kind level framerate)
  (ecase media-kind
         ((udp-audio)
          (and remember-audio
               (let ((estimated-rate 60.)
                     (estimated-packets/frame average-audio-packets/frame))
                 (let ((size (fxround (* estimated-rate estimated-packets/frame remember-audio))))
                   (new Remember-Ring size)))))
         ((udp-video)
          (and remember-video
               (case source-kind
                 ((image)
                  (new Remember-Ring 8))
                 ((draw)
                  (new Remember-Ring 32))
                 ((stream live)
                  (let ((estimated-packets/frame (vector-ref average-video-packets/frame level)))
                    (let ((size (fxround (* framerate estimated-packets/frame remember-video))))
                      (new Remember-Ring size))))
                 (else
                  #f))))))


(class Remember-Ring-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-size object))
                              (serialize (get-max-size object))
                              (serialize (get-packets object))
                              (serialize (get-head object))
                              (serialize (get-tail object))
                              (serialize (get-count object))
                              (serialize (get-lowest object))
                              (serialize (get-highest object))
                              (serialize (get-last-sequence object)))))
  
  
  (method override (unmarshall-object self content <vector>)
    (bind-vector (size max-size packets head tail count lowest highest last-sequence) content
      (allocate self
                (deserialize size)
                (deserialize max-size)
                (deserialize packets)
                (make-mutex 'ring)
                (deserialize head)
                (deserialize tail)
                (deserialize count)
                (deserialize lowest)
                (deserialize highest)
                (deserialize last-sequence)))))


(class Remember-Ring metaclass Remember-Ring-Class extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot max-size     <fx>        getter generate)
  (slot packets      <vector>    getter generate)
  (slot mutex        <object>    getter generate)
  (slot head         <fx>        getter generate)
  (slot tail         <fx>        getter generate)
  (slot count        <fx>        getter generate)
  (slot lowest       <fx>        getter generate)
  (slot highest      <fx>        getter generate)
  (slot last-sequence            getter generate)
  
  
  (method override (initialize self size <fx> (max-size: max-size #f) (overflow-proc: overflow-proc #f))
    (nextmethod self)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.packets (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.last-sequence #f))
  
  
  (method protected (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  (method protected (check self)
    (when (> count 0)
      (let ((low (get-sequence (lowest-packet self)))
            (high (get-sequence (highest-packet self))))
        (assert (= lowest low))
        (assert (= highest high)))))
  
  
  (method protected (lowest-packet self) <UDP-Packet>
    (vector-ref packets head))
  
  
  (method protected (highest-packet self) <UDP-Packet>
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (index self seq)
    (modulo (+ head (- seq lowest)) size))
  
  
  (method protected (packet-ref self n) <UDP-Packet>
    (vector-ref packets (modulo (+ head n) size)))
  
  
  (method public (locate-packet self sequence) <UDP-Packet+>
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (vector-ref packets pos)))
      (mutex-unlock! mutex)))

  
  ;;;
  ;;;; Remember
  ;;;
  
  
  (method public (remember self data)
    (mutex-lock! mutex)
    (let ((dts (timestamp->flonum (read-udp-media-dts data)))
          (pts (timestamp->flonum (read-udp-media-pts data)))
          (duration (read-udp-media-duration data))
          (sequence (read-udp-sequence data))
          (frame (read-udp-frame data))
          (part (read-udp-part data))
          (total (read-udp-total data))
          (keyframe? (read-udp-media-keyframe? data)))
      (let ((in-order? (or (not last-sequence)
                           (> sequence last-sequence))))
        (cond ;; empty
              ((= count 0)
               (when in-order?
                 (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? data)))
                   (insert-before self head packet)
                   (set! last-sequence sequence)
                   (set! lowest sequence)
                   (set! highest sequence)
                   (check self))))
              ;; insert
              (in-order?
               (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? data)))
                 (let ((expected (+ last-sequence 1)))
                   (let ((gap (- sequence expected)))
                     (if (and udp-max-gap (>= gap udp-max-gap))
                         (begin
                           (set! last-sequence sequence)
                           (remove-count self count))
                       (loop (for seq from (+ highest 1) below sequence)
                             (insert-before self tail (new UDP-Packet #f #f #f seq #f #f #f #f #f)))
                       (insert-before self tail packet)
                       (set! last-sequence sequence)
                       (set! highest sequence)
                       (check self))))))
              ;; replace
              (else
               (when (between? sequence lowest highest)
                 (let ((pos (index self sequence)))
                   (let ((actual-packet <UDP-Packet> (vector-ref packets pos)))
                     (when (not (get-data actual-packet))
                       (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? data)))
                         (vector-set! packets pos packet))))))))))
    (mutex-unlock! mutex))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert-before self pos packet)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-packets (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subvector-move! packets 0 tail new-packets 0)
          (subvector-move! packets tail size new-packets head)
          (set! size new-size)
          (set! packets new-packets))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (vector-set! packets head packet)
                  (increase! count))
                 ((= pos tail)
                  (vector-set! packets tail packet)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subvector-shift! packets head pos -1)
                        (vector-set! packets (- pos 1) packet)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subvector-shift! packets pos tail 1)
                    (vector-set! packets pos packet)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (vector-set! packets tail packet)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail)
           (increase! lowest))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method public (collect-missing self)
    (mutex-lock! mutex)
    (unwind-protect (let ((missing (new-queue)))
                      (let (loop (n (- count 1)))
                        (if (< n 0)
                            (queue-list missing)
                          (let ((pos (modulo (+ head n) size)))
                            (let ((packet <UDP-Packet> (vector-ref packets pos)))
                              (when (not (get-data packet))
                                (enqueue missing (get-sequence packet)))
                              (loop (- n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (count-missing self)
    (mutex-lock! mutex)
    (unwind-protect (let ((missing 0))
                      (let (loop (n (- count 1)))
                        (if (< n 0)
                            missing
                          (let ((pos (modulo (+ head n) size)))
                            (let ((packet <UDP-Packet> (vector-ref packets pos)))
                              (when (not (get-data packet))
                                (increase! missing))
                              (loop (- n 1)))))))
      (mutex-unlock! mutex))))


(definition protected (copy-remember-ring ring <Remember-Ring>) <Remember-Ring>
  (mutex-lock! (get-mutex ring))
  (let ((copy (allocate Remember-Ring
                (get-size ring)
                (get-max-size ring)
                (vector-copy (get-packets ring))
                (make-mutex 'ring)
                (get-head ring)
                (get-tail ring)
                (get-count ring)
                (get-lowest ring)
                (get-highest ring)
                (get-last-sequence ring))))
    (mutex-unlock! (get-mutex ring))
    copy))


;;;
;;;; Ring
;;;


(proclaim (warn optimizations))


;;               ---> time
;;  wait +----+----+----+----+----+ insert
;;  <--- | T0 | T1 | T2 | T3 | T4 | <---
;;       +----+----+----+----+----+
;;       ^                        ^
;;      HEAD                     TAIL
;;   (earliest)                (latest)
;;    (lowest)                 (highest)


(class UDP-Ring extends Object
  
  
  (slot channel                   getter generate)
  (slot no                        getter generate)
  (slot origin                    getter generate)
  (slot media-kind                getter generate)
  (slot size          <fx>        getter generate)
  (slot max-size      <fx>        getter generate)
  (slot packets       <vector>    getter generate)
  (slot mutex         <object>    getter generate)
  (slot wait-condvar  <object>    getter generate)
  (slot head          <fx>        getter generate)
  (slot tail          <fx>        getter generate)
  (slot count         <fx>        getter generate)
  (slot lowest        <fx>        getter generate)
  (slot highest       <fx>        getter generate)
  (slot state                     getter generate)
  (slot last-sequence <fx+>       getter generate)
  (slot last-frame    <fx+>       getter generate)
  (slot time-base     <Time-Base> getter generate)
  (slot terminate?                getter generate)
  (slot overflow-proc             getter generate)
  (slot retain-window             getter generate)
  
  
  (method override (initialize self channel no origin media-kind size <fx> (max-size: max-size #f) (overflow-proc: overflow-proc #f) (retain-window: retain-window #f))
    (nextmethod self)
    (set! self.channel channel)
    (set! self.no no)
    (set! self.origin origin)
    (set! self.media-kind media-kind)
    (assert (> size 0))
    (set! self.size size)
    (set! self.max-size (or max-size size))
    (set! self.packets (make-vector size #f))
    (set! self.mutex (make-mutex 'ring))
    (set! self.wait-condvar (make-condition-variable 'wait))
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0)
    (set! self.state (if (eq? media-kind udp-audio) 'ok 'waiting))
    (set! self.last-sequence #f)
    (set! self.last-frame #f)
    (set! self.time-base (new Time-Base))
    (set! self.terminate? #f)
    (set! self.overflow-proc overflow-proc)
    (set! self.retain-window retain-window))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" state))))
  
  
  (method public (terminate self)
    (mutex-lock! mutex)
    (set! terminate? #t)
    (condition-variable-signal! wait-condvar)
    (mutex-unlock! mutex))
  
  
  (method public (empty self)
    (vector-fill! self.packets #f)
    (set! self.head 0)
    (set! self.tail 0)
    (set! self.count 0)
    (set! self.lowest 0)
    (set! self.highest 0))
  
  
  (method protected (check self)
    (when (> count 0)
      (let ((low (get-sequence (lowest-packet self)))
            (high (get-sequence (highest-packet self))))
        (assert (= lowest low))
        (assert (= highest high)))))
  
  
  (method protected (lowest-packet self) <UDP-Packet>
    (vector-ref packets head))
  
  
  (method protected (highest-packet self) <UDP-Packet>
    (vector-ref packets (modulo (- tail 1) size)))
  
  
  (method protected (index self seq <fx>) <fx>
    (modulo (+ head (- seq lowest)) size))

  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert self data (insert-event #f))
    (let ((now (current-seconds))
          (dts (timestamp->flonum (read-udp-media-dts data)))
          (pts (timestamp->flonum (read-udp-media-pts data))))
      (mutex-lock! mutex)
      (let ((duration (read-udp-media-duration data))
            (sequence (read-udp-sequence data))
            (frame (read-udp-frame data))
            (part (read-udp-part data))
            (total (read-udp-total data))
            (keyframe? (read-udp-media-keyframe? data)))
        (define (time-update)
          (unless (emulation?)
            (update-time time-base now dts
              (lambda (current-latency effective-latency)
                (condition-variable-signal! wait-condvar)
                (let ((sender (read-udp-sender data)))
                  (record-event udp-id-update-time
                                (fixnum->flonum no)
                                (fixnum->flonum sender)
                                (fixnum->flonum media-kind)
                                (fixnum->flonum sequence)
                                now
                                current-latency
                                dts
                                effective-latency))))))
        
        (define (insert/reset-empty)
          (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? data)))
            (record-insert)
            (insert-before self head packet)
            (set! last-sequence sequence)
            (set! lowest sequence)
            (set! highest sequence)
            (check self)
            (condition-variable-signal! wait-condvar)))
        
        (define (record-insert)
          (let ((base (get-base time-base))
                (latency (get-latency time-base))
                (last-latency (get-last-latency time-base)))
            (record-event (or insert-event udp-id-insert-packet)
                          (fixnum->flonum no)
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (fixnum->flonum frame)
                          latency
                          dts
                          (or base -1.)
                          last-latency)))
        
        (define (record-missing seq)
          (record-event udp-id-missing-packet
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        (fixnum->flonum seq)
                        (fixnum->flonum sequence)
                        -1.
                        -1.))
        
        (define (record-gap gap <fx>)
          (record-event udp-id-packet-gap
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        (fixnum->flonum sequence)
                        (fixnum->flonum frame)
                        (fixnum->flonum gap)
                        -1.)
          (when udp-show-gaps?
            (terminal presence-name (present-media-kind media-kind) '***packet-gap*** (current-seconds) gap sequence)))
        
        (cond ;; first time
              ((not last-sequence)
               (time-update)
               (insert/reset-empty))
              ;; in-order insert
              ((> sequence last-sequence)
               (let ((expected (+ (allege last-sequence) 1)))
                 (let ((gap (- sequence expected)))
                   (when (> gap 0)
                     (record-gap gap))
                   (if (and udp-max-gap (>= gap udp-max-gap))
                       (begin
                         (set! last-sequence sequence)
                         (flush self count #f)
                         (state-waiting self)
                         (condition-variable-signal! wait-condvar))
                     (let ((previous-latency (get-last-latency time-base)))
                       (time-update)
                       (let ((change (abs (- (get-last-latency time-base) previous-latency))))
                         ;; empty ring after a seek
                         (if #f @wait-do-this-correctly-as-if-this-happens-not-from-a-seek-we-just-empty-without-any-flush-events (> change 1.)
                             (begin
                               (empty self)
                               (insert/reset-empty))
                           (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? data)))
                             (if (= count 0)
                                 (loop (for seq from (+ highest 1) below sequence)
                                       (record-missing seq)
                                       (insert-before self tail (new UDP-Packet dts pts #f seq #f #f #f #f #f)))
                               (let ((highest-packet (highest-packet self)))
                                 (let ((highest-dts (get-dts highest-packet)))
                                   (loop (for seq from (+ highest 1) below sequence)
                                         (let ((dts (interpolate seq highest sequence highest-dts dts)))
                                           (record-missing seq)
                                           (insert-before self tail (new UDP-Packet dts pts #f seq #f #f #f #f #f)))))))
                             (record-insert)
                             (insert-before self tail packet)
                             (set! last-sequence sequence)
                             (set! highest sequence)
                             (check self)
                             (condition-variable-signal! wait-condvar)))))))))
              ;; out-of-order replace
              (else
               (if (between? sequence lowest highest)
                   (let ((pos (index self sequence)))
                     (let ((actual-packet <UDP-Packet> (vector-ref packets pos)))
                       (if (get-data actual-packet)
                           (let ((resent (read-udp-resent data)))
                             (record-event udp-id-duplicate-packet
                                           (fixnum->flonum no)
                                           (fixnum->flonum origin)
                                           (fixnum->flonum media-kind)
                                           (fixnum->flonum sequence)
                                           (fixnum->flonum frame)
                                           (fixnum->flonum resent)
                                           -1.))
                         (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? data)))
                           (vector-set! packets pos packet)
                           (let ((resent (read-udp-resent data)))
                             (record-event udp-id-got-packet
                                           (fixnum->flonum no)
                                           (fixnum->flonum origin)
                                           (fixnum->flonum media-kind)
                                           (fixnum->flonum sequence)
                                           (fixnum->flonum frame)
                                           (fixnum->flonum resent)
                                           -1.))
                           (condition-variable-signal! wait-condvar)))))
                 (let ((resent (read-udp-resent data)))
                   (record-event udp-id-reject-packet
                                 (fixnum->flonum no)
                                 (fixnum->flonum origin)
                                 (fixnum->flonum media-kind)
                                 (fixnum->flonum sequence)
                                 (fixnum->flonum frame)
                                 (fixnum->flonum resent)
                                 -1.))))))
      (mutex-unlock! mutex)))
  
  
  (method public (insert-before self pos <fx> packet <UDP-Packet>)
    ;; grow
    (when (and (= count size)
               (< size max-size))
      (let ((new-size (min max-size (fxround (* size GOLDEN_GROWTH)))))
        (let ((new-packets (make-vector new-size #f))
              (growth (- new-size size)))
          (set! head (+ head growth))
          (subvector-move! packets 0 tail new-packets 0)
          (subvector-move! packets tail size new-packets head)
          (set! size new-size)
          (set! packets new-packets))))
    ;; insert
    (cond ((< count size)
           (cond ((= pos head)
                  (set! head (modulo (- head 1) size))
                  (vector-set! packets head packet)
                  (increase! count))
                 ((= pos tail)
                  (vector-set! packets tail packet)
                  (set! tail (modulo (+ tail 1) size))
                  (increase! count))
                 (else
                  (if (and (> head tail)
                           (>= pos head))
                      (begin
                        (subvector-shift! packets head pos -1)
                        (vector-set! packets (- pos 1) packet)
                        (set! head (modulo (- head 1) size))
                        (increase! count))
                    (subvector-shift! packets pos tail 1)
                    (vector-set! packets pos packet)
                    (set! tail (modulo (+ tail 1) size))
                    (increase! count)))))
          (else
           (when overflow-proc
             (let ((bumped-packet <UDP-Packet> (vector-ref packets tail)))
               (overflow-proc self packet bumped-packet)))
           (vector-set! packets tail packet)
           (set! tail (modulo (+ tail 1) size))
           (set! head tail)
           (increase! lowest))))
  
  
  ;;;
  ;;;; Visualizer
  ;;;
  
  
  (method protected (visualizer-packet-ref self n <fx>) <UDP-Packet+>
    (and (< n count)
         (vector-ref packets (modulo (+ head n) size))))
  
  
  (method protected (visualizer-earliest-packet self) <UDP-Packet+>
    (visualizer-packet-ref self 0))
  
  
  (method protected (visualizer-update-time self base latency)
    (visualizer-update time-base base latency))
  
  
  (method protected (visualizer-replace-got self sequence <fx> data)
    ;; quick robust test for visualizer
    (when (between? sequence lowest highest)
      (let ((pos (index self sequence)))
        (let ((actual-packet <UDP-Packet> (vector-ref packets pos)))
          (assert (eqv? (get-sequence actual-packet) sequence)
            (assert (not (get-data actual-packet))
              (let ((dts (timestamp->flonum (read-udp-media-dts data)))
                    (pts (timestamp->flonum (read-udp-media-pts data)))
                    (duration (read-udp-media-duration data))
                    (sequence (read-udp-sequence data))
                    (frame (read-udp-frame data))
                    (part (read-udp-part data))
                    (total (read-udp-total data))
                    (keyframe? (read-udp-media-keyframe? data)))
                (let ((packet (new UDP-Packet dts pts duration sequence frame part total keyframe? data)))
                  (vector-set! packets pos packet)))))))))
  
  
  (method protected (visualizer-frame-complete? self pos <fx>)
    (let ((packet (packet-ref self pos)))
      (let ((part (get-part packet))
            (total (get-total packet)))
        (and (= part 0)
             (<= (+ pos total) count)
             (loop (for n from 0 below total)
                   (every (get-data (packet-ref self (+ pos n)))))))))
  
  
  (method protected (visualizer-remove-frame self)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (let ((part (get-part earliest))
            (total (get-total earliest)))
        (let ((cnt (- total part)))
          (remove-count self cnt)))))
  
  
  (method protected (visualizer-iterate-frame self proc)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (let ((part (get-part earliest))
            (total (get-total earliest)))
        (let ((cnt (- total part)))
          (loop (for n from 0 below cnt)
                (proc (packet-ref self n)))))))
  
  
  ;;;
  ;;;; Retain
  ;;;
  
  
  (method public (retain-wait self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((now (current-seconds))
                (earliest <UDP-Packet> (vector-ref packets head)))
            (let ((release-time (determine-release-time self earliest)))
              (if (>= now release-time)
                  (prog1 earliest
                    (vector-set! packets head #f)
                    (set! head (modulo (+ head 1) size))
                    (decrease! count)
                    (increase! lowest)
                    (check self)
                    (mutex-unlock! mutex))
                (mutex-unlock! mutex wait-condvar (- release-time now))
                (loop-wait))))))))
  
  
  (method (determine-release-time self packet <UDP-Packet>) <fl>
    (let ((dts (get-dts packet)))
      (+ (remote->local time-base dts) retain-window)))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method protected (process-audio self average debug?)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((now (current-seconds))
                (earliest <UDP-Packet> (vector-ref packets head)))
            (let ((earliest-time (determine-earliest-time self earliest))
                  (presentation-time (determine-presentation-time self earliest udp-audio-process-window)))
              (let ((giveup-time (+ presentation-time udp-audio-giveup)))
                (define (debugging what sleep)
                  (when debug?
                    (let ((sequence (get-sequence earliest))
                          (time (- now earliest-time))
                          (sleep (if (symbol? sleep) sleep (format "{r precision: 3}" sleep)))
                          (content (loop (for n from 0 below count)
                                         (collect (get-sequence (packet-ref self n))))))
                      (format :terminal
                              "{a width: 8} {a} {r precision: 3} {a width: 6} ({l}){%}"
                              what
                              sequence
                              time
                              sleep
                              content))))
                
                (cond ;; giveup
                      ((>= now giveup-time)
                       (debugging 'giveup 'loop)
                       (flush-packet self average)
                       (mutex-unlock! mutex)
                       (loop-wait))
                      ;; not ready
                      ((< now presentation-time)
                       (debugging 'sleep (- presentation-time now))
                       (mutex-unlock! mutex wait-condvar (- presentation-time now))
                       (loop-wait))
                      ;; frame
                      ((complete-frame? self)
                       (prog1 (cons presentation-time (present self now average))
                         (debugging 'play 'return)
                         (mutex-unlock! mutex)))
                      ;; not ready to giveup
                      (else
                       (debugging 'nrtgu (- giveup-time now))
                       (mutex-unlock! mutex wait-condvar (- giveup-time now))
                       (loop-wait))))))))))
  
  
  (method protected (process-video self average debug?)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          'terminate
        (mutex-lock! mutex)
        (if (= count 0)
            (if (not (get-framerate channel))
                (begin
                  (mutex-unlock! mutex wait-condvar)
                  (loop-wait))
              (mutex-unlock! mutex wait-condvar udp-video-giveup)
              (if (= count 0)
                  (begin
                    (state-waiting self)
                    (loop-wait))
                (loop-wait)))
          (let ((now (current-seconds))
                (earliest <UDP-Packet> (vector-ref packets head)))
            (let ((earliest-time (determine-earliest-time self earliest))
                  (presentation-time (determine-presentation-time self earliest udp-video-process-window)))
              (let ((late-time (+ presentation-time udp-video-late))
                    (giveup-time (+ presentation-time udp-video-giveup)))
                (define (debugging what sleep)
                  (when debug?
                    (let ((sequence (get-sequence earliest))
                          (time (- now earliest-time))
                          (sleep (if (symbol? sleep) sleep (format "{r precision: 3}" sleep)))
                          (content (loop (for n from 0 below count)
                                         (collect (get-sequence (packet-ref self n))))))
                      (format :terminal
                              "{a width: 6} {a} {r precision: 3} {a width: 6} ({l}){%}"
                              what
                              sequence
                              time
                              sleep
                              content))))
                
                (cond ;; giveup
                      ((>= now giveup-time)
                       (debugging 'giveup 'loop)
                       (flush-packet self average)
                       (state-waiting self)
                       (mutex-unlock! mutex)
                       (loop-wait))
                      ;; waiting
                      ((eq? state 'waiting)
                       (let ((keyframe (complete-keyframe self)))
                         (cond ;; keyframe
                               (keyframe
                                (let ((packet (packet-ref self keyframe)))
                                  (let ((packet-present (determine-presentation-time self packet udp-video-process-window)))
                                    (if (< now packet-present)
                                        ;; not ready
                                        (begin
                                          (mutex-unlock! mutex wait-condvar (- packet-present now))
                                          (loop-wait))
                                      ;; ready
                                      (begin
                                        (flush self keyframe average)
                                        (state-ok self)
                                        (mutex-unlock! mutex)
                                        (loop-wait))))))
                               ;; giveup
                               ((>= now giveup-time)
                                (flush-packet self average)
                                (mutex-unlock! mutex)
                                (loop-wait))
                               ;; not ready to giveup
                               (else
                                (mutex-unlock! mutex wait-condvar (- giveup-time now))
                                (loop-wait)))))
                      ;; not ready
                      ((< now presentation-time)
                       (debugging 'sleep (- presentation-time now))
                       (mutex-unlock! mutex wait-condvar (- presentation-time now))
                       (loop-wait))
                      ;; frame
                      ((complete-frame? self)
                       (prog1 (begin
                                (if (< now late-time)
                                    (state-ok self)
                                  (state-late self))
                                (present self now average))
                         (debugging (if (eq? state 'ok) 'play 'freeze) 'return)
                         (mutex-unlock! mutex)))
                      ;; ok
                      ((< now late-time)
                       (debugging 'ok (- late-time now))
                       (mutex-unlock! mutex wait-condvar (- late-time now))
                       (loop-wait))
                      ;; late
                      (else
                       (debugging 'late (- giveup-time now))
                       (state-late self)
                       (mutex-unlock! mutex wait-condvar (- giveup-time now))
                       (loop-wait))))))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method protected (packet-ref self n <fx>) <UDP-Packet>
    (vector-ref packets (modulo (+ head n) size)))
  
  
  (method (determine-earliest-time self packet <UDP-Packet>) <fl>
    (let ((dts (get-dts packet)))
      (remote->local time-base dts)))
  
  
  (method (determine-presentation-time self packet <UDP-Packet> process-window <fl>) <fl>
    (let ((dts (get-dts packet)))
      (+ (remote->local time-base dts) process-window)))
  
  
  (method protected (complete-frame? self)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (and (get-data earliest)
           (let ((part (get-part earliest))
                 (total (get-total earliest)))
             (and (= part 0)
                  (<= total count)
                  (loop (for n from 0 below total)
                        (every (get-data (packet-ref self n)))))))))
    
  
  (method (complete-keyframe self)
    (continuation-capture
      (lambda (found)
        (loop (for n from 0 below count)
              (let ((packet (packet-ref self n)))
                (when (and (get-data packet)
                           (get-keyframe? packet)
                           (= (get-part packet) 0))
                  (let ((frame (get-frame packet))
                        (total (get-total packet)))
                    (let ((last (+ n total -1)))
                      (when (and (< last count)
                                 (loop (for i from (+ n 1) to last)
                                       (every (let ((packet (packet-ref self i)))
                                                (and (get-data packet)
                                                     (= (get-frame packet) frame))))))
                        (continuation-return found n)))))))
        #f)))
  
  
  (method (present self now average)
    (let ((earliest <UDP-Packet> (vector-ref packets head)))
      (let ((frame (get-frame earliest))
            (total (get-total earliest)))
        (prog1 (loop (for n from 0 below total)
                     (collect (get-data (packet-ref self n))))
          (remove-count self total)
          (add-average self average frame 1.)))))
  
  
  (method (add-average self average frame x)
    (when (and last-frame
               (/= frame last-frame))
      (let ((gap (- frame (+ last-frame 1))))
        (loop (repeat gap)
              (add average 0.))))
    (when (or (not last-frame)
              (/= frame last-frame))
      (add average x)
      (set! last-frame frame)))
  
  
  (method (flush self cnt average)
    (loop (repeat cnt)
          (flush-packet self average)))
  
  
  (method (flush-packet self average)
    (let ((earliest (packet-ref self 0)))
      (let ((sequence (get-sequence earliest))
            (frame (get-frame earliest))
            (keyframe? (get-keyframe? earliest))
            (dts (get-dts earliest)))
        (if (get-data earliest)
            (record-discard-packet self sequence frame keyframe? dts)
          (record-lost-packet self sequence frame keyframe? dts))
        (remove-packet self)
        (when frame
          ;; quick hack fix me
          (when average
            (add-average self average frame 0.))))))
  
  
  (method protected (remove-packet self)
    (remove-count self 1))
  
  
  (method protected (remove-count self cnt <fx>)
    (loop (repeat cnt)
          (vector-set! packets head #f)
          (set! head (modulo (+ head 1) size))
          (decrease! count)
          (increase! lowest))
    (check self))
  
  
  (method protected (state-ok self)
    (unless (eq? state 'ok)
      (set! state 'ok)
      (unless (emulation?)
        (record-event udp-id-state-ok
                      (fixnum->flonum no)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      -1.
                      -1.)
        (when udp-show-states?
          (format :terminal "{s} {s} {s} {s}       - {a} ({a}){%}" presence-name (present-media-kind media-kind) 'STATE 'OK (effective-name (get-stream channel)) (get-no channel))))))
  
  
  (method protected (state-late self)
    (unless (eq? state 'late)
      (set! state 'late)
      (unless (emulation?)
        (record-event udp-id-state-late
                      (fixnum->flonum no)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      -1.
                      -1.)
        (when udp-show-states?
          (format :terminal "{s} {s} {s} {s}     - {a} ({a}){%}" presence-name (present-media-kind media-kind) 'STATE 'LATE (effective-name (get-stream channel)) (get-no channel))))))
  
  
  (method protected (state-waiting self)
    (unless (eq? state 'waiting)
      (set! state 'waiting)
      (unless (emulation?)
        (record-event udp-id-state-waiting
                      (fixnum->flonum no)
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      -1.
                      -1.)
        (when udp-show-states?
          (format :terminal "{s} {s} {s} {s}  - {a} ({a}){%}" presence-name (present-media-kind media-kind) 'STATE 'WAITING (effective-name (get-stream channel)) (get-no channel))))))
  
  
  (method (record-lost-packet self sequence frame keyframe? dts)
    (record-event udp-id-lost-packet
                  (fixnum->flonum no)
                  (fixnum->flonum origin)
                  (fixnum->flonum media-kind)
                  (fixnum->flonum sequence)
                  (if (not frame)
                      -1.
                    (fixnum->flonum frame))
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method (record-discard-packet self sequence frame keyframe? dts)
    (record-event udp-id-discard-packet
                  (fixnum->flonum no)
                  (fixnum->flonum origin)
                  (fixnum->flonum media-kind)
                  (fixnum->flonum sequence)
                  (fixnum->flonum frame)
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method public (locate-packet self sequence <fx>) <UDP-Packet+>
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (vector-ref packets pos)))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-data self sequence <fx>)
    (mutex-lock! mutex)
    (prog1 (and (>= sequence lowest)
                (<= sequence highest)
                (let ((pos (index self sequence)))
                  (let ((packet <UDP-Packet> (vector-ref packets pos)))
                    (get-data packet))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-earliest self predicate) <UDP-Packet+>
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (if (>= n count)
                          #f
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (if (predicate packet)
                                packet
                              (loop (+ n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (locate-latest self predicate) <UDP-Packet+>
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n (- count 1)))
                      (if (< n 0)
                          #f
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (if (predicate packet)
                                packet
                              (loop (- n 1)))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-indexes self proc)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (when (< n count)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc n)
                            (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-earliest self proc)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n 0))
                      (when (< n count)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc packet)
                            (loop (+ n 1))))))
      (mutex-unlock! mutex)))
  
  
  (method public (iterate-latest self proc)
    (mutex-lock! mutex)
    (unwind-protect (let (loop (n (- count 1)))
                      (when (>= n 0)
                        (let ((pos (modulo (+ head n) size)))
                          (let ((packet (vector-ref packets pos)))
                            (proc packet)
                            (loop (- n 1))))))
      (mutex-unlock! mutex))))


(proclaim (default warn optimizations))


;;;
;;;; Monitor
;;;


(class UDP-Monitor extends Object
  
  
  (slot packets-sent     initialize 0 getter generate)
  (slot bytes-sent       initialize 0 getter generate)
  (slot packets-received initialize 0 getter generate)
  (slot bytes-received   initialize 0 getter generate)
  
  
  (method protected (increase-sent self data)
    (increase! packets-sent)
    (increase! bytes-sent (u8vector-length data)))
  
  
  (method protected (increase-received self data)
    (increase! packets-received)
    (increase! bytes-received (u8vector-length data))))


;;;
;;;; UDP-Statistics
;;;


(class UDP-Statistics extends Object
  
  
  (slot last-bytes-sent       initialize 0  getter generate)
  (slot last-bytes-received   initialize 0  getter generate)
  (slot last-send-rate        initialize #f getter generate)
  (slot last-receive-rate     initialize #f getter generate)
  (slot last-time             initialize #f getter generate)
  (slot outgoing-dropped      initialize 0  getter generate)
  (slot outgoing-drop         initialize 0  getter generate)
  (slot incoming-dropped      initialize 0  getter generate)
  (slot incoming-drop         initialize 0  getter generate)
  
  
  (method protected (update self now monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received)
    ;; client
    (let ((packets-sent (get-packets-sent monitor))
          (bytes-sent (get-bytes-sent monitor))
          (packets-received (get-packets-received monitor))
          (bytes-received (get-bytes-received monitor)))
      (let ((fresh-bytes-sent (- bytes-sent last-bytes-sent))
            (fresh-bytes-received (- bytes-received last-bytes-received)))
        (set! last-bytes-sent bytes-sent)
        (set! last-bytes-received bytes-received)
        (if (not last-time)
            (begin
              (set! last-send-rate -1.)
              (set! last-receive-rate -1.)
              (set! last-time now))
          (let ((elapse (- now last-time)))
            (set! last-send-rate (/ (cast <fl> fresh-bytes-sent) elapse))
            (set! last-receive-rate (/ (cast <fl> fresh-bytes-received) elapse))
            (set! last-time now)))
        ;; client <-> server dropped
        (set! outgoing-dropped (- packets-sent server-packets-received))
        (set! incoming-dropped (- server-packets-sent packets-received))
        (set! outgoing-drop (and (> packets-sent 0) (percentage outgoing-dropped packets-sent)))
        (set! incoming-drop (and (> server-packets-sent 0) (percentage incoming-dropped server-packets-sent)))))))


;;;
;;;; Simulator
;;;


(class UDP-Simulator extends Object
  
  
  (property latency             getter generate)
  (property drop                getter generate)
  (property congestion          accessors generate)
  (property congestion-duration accessors generate)
  
  (slot latency-proc         getter generate)
  (slot congestion-occuring? getter generate)
  (slot congestion-ends      accessors generate)
  (slot writer               getter generate)
  (slot ring                 getter generate)
  (slot thread               getter generate)
  
  
  (method override (initialize self latency drop writer)
    (nextmethod self)
    (setup-latency self latency)
    (setup-drop self drop)
    (set! self.congestion udp-congestion)
    (set! self.congestion-duration udp-congestion-duration)
    (set! self.congestion-occuring? #f)
    (set! self.congestion-ends #f)
    (set! self.writer writer)
    (set! self.ring (new Time-Ring udp-simulator-size max-size: udp-simulator-max-size))
    (set! self.thread (new-thread
                        (lambda ()
                          (send-loop self))
                        'simulator))
    (thread-base-priority-set! thread simulator-priority)
    (thread-start! thread))
  
  
  (method protected (setup-latency self lat)
    (define (parse-latency lat)
      (if (and (pair? lat) (eq? (car lat) 'add))
          (add-latency (map determine-latency (cdr lat)))
        (determine-latency lat)))
    
    (define (determine-latency lat)
      (define (try name proc)
        (cond ((eq? lat name)
               (proc))
              ((and (pair? lat) (eq? (car lat) name))
               (apply proc (cdr lat)))
              (else
               #f)))
      
      (if (number? lat)
          (fixed-latency lat)
        (or (try 'rise rise-latency)
            (try 'fall fall-latency)
            (try 'updown updown-latency)
            (try 'sin sin-latency)
            (try 'random random-latency)
            (try 'recorded recorded-latency)
            lat)))
    
    (set! latency lat)
    (set! latency-proc (and lat (parse-latency lat))))
  
  
  (method protected (setup-drop self drp)
    (set! drop (and drp (cast <fl> drp))))
  
  
  (method protected (send self data info)
    (define (insert-latency latency)
      (let ((time (+ (current-seconds) latency))
            (obj (cons data info)))
        (insert-monotonic ring time obj)))
    
    (cond (congestion
           (if (not congestion-occuring?)
               (if (or (eq? congestion #t)
                       (< (random-real) (/ congestion 100.)))
                   (let ((ends (if (eq? congestion-duration #t) +inf.0 (random-between 0. congestion-duration))))
                     (set! congestion-occuring? #t)
                     (set! congestion-ends ends)
                     (when udp-show-congestion?
                       (format :terminal "{s} {s} {s}{%}" presence-name 'CONGESTION 'ON)))
                 (send-writer self data info))
             (when (or (not congestion-ends)
                       (>= (current-seconds) congestion-ends))
               (set! congestion-occuring? #f)
               (set! congestion-ends #f)
               (when udp-show-congestion?
                 (format :terminal "{s} {s} {s}{%}" presence-name 'CONGESTION 'OFF))
               (send-writer self data info))))
          (latency-proc
           (let ((kind (read-udp-kind data)))
             (if (or (= kind udp-audio)
                     (= kind udp-video))
                 (let ((latency (let ((time (- (current-monotonic) kernel-boot-monotonic)))
                                  (latency-proc time))))
                   (insert-latency latency))
               (send-writer self data info))))
          (else
           (let ((kind (read-udp-kind data)))
             (if (or (= kind udp-audio)
                     (= kind udp-video))
                 (insert-latency 0.)
               (send-writer self data info))))))
  
  
  (method (drop? self)
    (and drop (< (random-real) (/ drop 100.))))
  
  
  (method (send-writer self data info)
    (let ((drop? (drop? self)))
      (writer data info drop?)))
  
  
  (method (send-loop self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((pair (wait ring)))
        (bind (data . info) pair
          (send-writer self data info)))
      (loop))))


;;;
;;;; Media
;;;


(definition public (media-packet-keyframe? data)
  (and (= (read-udp-part data) 0)
       (read-udp-media-keyframe? data)))


;;;
;;;; Access
;;;


(definition public (scan-boolean data pos)
  (/= (scan-s8 data pos) 0))


(definition public (scan-u8vector data pos)
  (let ((len (scan-s32 data pos)))
    (let ((v (make-u8vector len))
          (pos (+ pos 4)))
      (subu8vector-move! data pos (+ pos len) v 0)
      v)))


(definition public (scan-host data pos)
  (u8vector (u8vector-ref data pos)
            (u8vector-ref data (+ pos 1))
            (u8vector-ref data (+ pos 2))
            (u8vector-ref data (+ pos 3))))


(definition public (put-boolean data pos value)
  (put-s8 data pos (if value 1 0)))


(definition public (put-u8vector data pos value)
  (let ((len (u8vector-length value)))
    (put-s32 data pos len)
    (let ((pos (+ pos 4)))
      (subu8vector-move! value 0 len data pos))))


(definition public (put-subu8vector! data pos value offset count)
  (put-s32 data pos count)
  (let ((pos (+ pos 4)))
    (subu8vector-move! value offset (+ offset count) data pos)))


(definition public (put-host data pos value)
  (u8vector-set! data pos (u8vector-ref value 0))
  (u8vector-set! data (+ pos 1) (u8vector-ref value 1))
  (u8vector-set! data (+ pos 2) (u8vector-ref value 2))
  (u8vector-set! data (+ pos 3) (u8vector-ref value 3)))


;;;
;;;; Format
;;;


;; udp
(definition public (read-udp-sent            data) <fl> (scan-double   data  0)) (definition public (write-udp-sent            data value) (put-double   data  0 value))
(definition public (read-udp-kind            data) <fx> (scan-s8       data  8)) (definition public (write-udp-kind            data value) (put-s8       data  8 value))
(definition public (read-udp-sender          data) <fx> (scan-s16      data 12)) (definition public (write-udp-sender          data value) (put-s16      data 12 value))
(definition public (read-udp-channel         data) <fx> (scan-s16      data 14)) (definition public (write-udp-channel         data value) (put-s16      data 14 value))
(definition public (read-udp-sequence        data) <fx> (scan-s32      data 16)) (definition public (write-udp-sequence        data value) (put-s32      data 16 value))
(definition public (read-udp-frame           data) <fx> (scan-s32      data 20)) (definition public (write-udp-frame           data value) (put-s32      data 20 value))
(definition public (read-udp-part            data) <fx> (scan-s32      data 24)) (definition public (write-udp-part            data value) (put-s32      data 24 value))
(definition public (read-udp-total           data) <fx> (scan-s32      data 28)) (definition public (write-udp-total           data value) (put-s32      data 28 value))
(definition public (read-udp-media-dts       data)      (scan-u64      data 32)) (definition public (write-udp-media-dts       data value) (put-u64      data 32 value))
(definition public (read-udp-media-pts       data)      (scan-u64      data 40)) (definition public (write-udp-media-pts       data value) (put-u64      data 40 value))
(definition public (read-udp-media-duration  data)      (scan-u64      data 48)) (definition public (write-udp-media-duration  data value) (put-u64      data 48 value))
(definition public (read-udp-media-payload   data)      (scan-u8vector data 56)) (definition public (write-udp-media-payload   data value) (put-u8vector data 56 value)) (definition public udp-media-buffer-offset (+ 56 4))
(definition public (read-udp-media-keyframe? data)      (scan-boolean  data  9)) (definition public (write-udp-media-keyframe? data value) (put-boolean  data  9 value))
(definition public (read-udp-media-off?      data)      (scan-boolean  data 10)) (definition public (write-udp-media-off?      data value) (put-boolean  data 10 value))
(definition public (read-udp-resent          data) <fx> (scan-s8       data 11)) (definition public (write-udp-resent          data value) (put-s8       data 11 value))

(definition public (udp-sender-header-size)
  16)

(definition public (udp-media-header-size)
  60)

(definition public (read-udp-media-payload-size data)
  (scan-s32 data 56))

(definition public (write-udp-media-subpayload data value offset count)
  (put-subu8vector! data 56 value offset count))

(definition public (increase-udp-resent data)
  (let ((resent (+ (read-udp-resent data) 1)))
    (when (<= resent 127)
      (write-udp-resent data resent))))

;; code
(definition public (read-udp-code data)
  (scan-u32 data (- (u8vector-length data) 4)))

(definition public (write-udp-code data)
  (put-u32 data (- (u8vector-length data) 4) udp-code))

(definition public udp-code-size <fx>
  4)

;; connect
@peer2peer
(definition public (read-udp-connect-local-host  data) (scan-host  data 16)) (definition public (write-udp-connect-local-host  data value) (put-host  data 16 value))
@peer2peer
(definition public (read-udp-connect-local-port  data) (scan-s32   data 20)) (definition public (write-udp-connect-local-port  data value) (put-s32   data 20 value))
(definition public (read-udp-connect-video-level data) (scan-s32   data 16)) (definition public (write-udp-connect-video-level data value) (put-s32   data 16 value))

(definition public (udp-connect-size)
  @peer2peer 28
  20)

;; state
(definition public (read-udp-state-sequence data) (scan-s32      data 16)) (definition public (write-udp-state-sequence data value) (put-s32      data 16 value))
(definition public (read-udp-state-channels data) (scan-u8vector data 20)) (definition public (write-udp-state-channels data value) (put-u8vector data 20 value))

(definition public (udp-state-size states)
  (+ 24 (u8vector-length states)))

;; ack
(definition public (read-udp-ack-state-sent       data) (scan-double data 16)) (definition public (write-udp-ack-state-sent       data value) (put-double data 16 value))
(definition public (read-udp-ack-state-sequence   data) (scan-s32    data 24)) (definition public (write-udp-ack-state-sequence   data value) (put-s32    data 24 value))
(definition public (read-udp-ack-packets-sent     data) (scan-s32    data 28)) (definition public (write-udp-ack-packets-sent     data value) (put-s32    data 28 value))
(definition public (read-udp-ack-bytes-sent       data) (scan-s32    data 32)) (definition public (write-udp-ack-bytes-sent       data value) (put-s32    data 32 value))
(definition public (read-udp-ack-packets-received data) (scan-s32    data 36)) (definition public (write-udp-ack-packets-received data value) (put-s32    data 36 value))
(definition public (read-udp-ack-bytes-received   data) (scan-s32    data 40)) (definition public (write-udp-ack-bytes-received   data value) (put-s32    data 40 value))

(definition public (udp-ack-size)
  44)

;; nack
(definition public (read-udp-nack-media-kind data) (scan-s32      data 16)) (definition public (write-udp-nack-media-kind data value) (put-s32      data 16 value))
(definition public (read-udp-nack-missing    data) (scan-u8vector data 20)) (definition public (write-udp-nack-missing    data value) (put-u8vector data 20 value))

(definition public (udp-nack-size missing)
  (+ 24 (u8vector-length missing)))

;; profile pulse
(definition public (read-udp-profile-pulse-packets-sent     data) (scan-s32 data 20)) (definition public (write-udp-profile-pulse-packets-sent     data value) (put-s32 data 20 value))
(definition public (read-udp-profile-pulse-bytes-sent       data) (scan-s32 data 24)) (definition public (write-udp-profile-pulse-bytes-sent       data value) (put-s32 data 24 value))
(definition public (read-udp-profile-pulse-packets-received data) (scan-s32 data 28)) (definition public (write-udp-profile-pulse-packets-received data value) (put-s32 data 28 value))
(definition public (read-udp-profile-pulse-bytes-received   data) (scan-s32 data 32)) (definition public (write-udp-profile-pulse-bytes-received   data value) (put-s32 data 32 value))

(definition public (udp-profile-pulse-size)
  36)

;; profile media
(definition public (read-udp-profile-media-payload data) (scan-u8vector data 20)) (definition public (write-udp-profile-media-payload data value) (put-u8vector data 20 value))

(definition public (udp-profile-media-size payload)
  (+ 24 (u8vector-length payload)))

;; upload ping
(definition public (read-udp-upload-ping-payload data) (scan-u8vector data 20)) (definition public (write-udp-upload-ping-payload data value) (put-u8vector data 20 value))

(definition public (udp-upload-ping-size payload)
  (+ 24 (u8vector-length payload))))
