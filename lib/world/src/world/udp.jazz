;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.udp jazz


(import (jazz.presence)
        (world)
        (world.context)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support))


(definition protected udp-connect
  0)

(definition protected udp-nack
  1)

(definition protected udp-audio
  2)

(definition protected udp-video
  3)


(definition udp-names
  #(connect nack audio video))

(definition protected (udp-name kind)
  (vector-ref udp-names kind))


(definition protected nanosecond
  (cast <fl> (expt 10 9)))


(definition protected udp-datagram-max
  (* (world-setting 'world.udp-datagram-max 1) 1024))

(definition protected udp-process-window
  (world-setting 'world.udp-process-window .2))

(definition protected udp-process-window-nanoseconds
  (fxround (* udp-process-window nanosecond)))


(definition protected udp-debug-discard?
  (world-setting 'world.udp-debug-discard? #f))

(definition protected udp-debug-missing?
  (world-setting 'world.udp-debug-missing? #f))

(definition protected udp-debug-nack?
  (world-setting 'world.udp-debug-nack? #f))

(definition protected udp-drop-percentage
  (world-setting 'world.udp-drop-percentage #f))


(definition protected udp-media-off
  #u8(111 102 102))


;;;
;;;; Channel
;;;


(class UDP-Channel extends Object
  
  
  (slot kind             getter generate)
  (slot origin           getter generate)
  (slot remote-timestamp getter generate)
  (slot local-seconds    getter generate)
  
  
  (method override (initialize self kind origin)
    (nextmethod self)
    (set! self.kind kind)
    (set! self.origin origin)
    (set! self.remote-timestamp #f)
    (set! self.local-seconds #f))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" kind origin))))
  
  
  (method protected (update-time self data)
    (set! remote-timestamp (read-udp-timestamp data))
    (set! local-seconds (current-seconds)))
  
  
  (method protected (now-timestamp self)
    (let ((now (current-seconds)))
      (- (+ remote-timestamp (fxround (* (- now local-seconds) nanosecond)))
         udp-process-window-nanoseconds))))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Channel
  
  
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-timestamp accessors generate)
  (slot retain-ring    getter generate)
  (slot release-thread getter generate)
  
  
  (method override (initialize self kind origin)
    (nextmethod self kind origin)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f)
    ;; make it really big until time ring is a real ring
    (set! self.retain-ring (new Time-Ring 400096 @w 512 @max-size: +inf.0 timestamp-proc: read-udp-timestamp now-proc: (~ now-timestamp self)))
    ;; development
    (set-$s retain-ring)
    (set! self.release-thread (new-thread
                                (lambda ()
                                  (release-data self))))
    (thread-start! release-thread))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (retain self data)
    (update-time self data)
    (insert retain-ring data))
  
  
  (method protected (release-data self)
    (declare (proper-tail-calls))
    (let (loop)
      (wait retain-ring)
      (loop))))


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot receive-last-sequence accessors generate)
  (slot process-last-sequence getter generate)
  (slot process-ring          getter generate)
  (slot process-thread        getter generate)
  ;; quicky for test
  (slot nack-sequences        accessors generate)
  
  
  (method override (initialize self kind origin)
    (nextmethod self kind origin)
    (set! self.receive-last-sequence #f)
    (set! self.process-last-sequence #f)
    ;; make it really big until time ring is a real ring
    (set! self.process-ring (new Time-Ring 40096 @w 512 @max-size: +inf.0 timestamp-proc: read-udp-timestamp now-proc: (~ now-timestamp self)))
    ;; development
    (set-$c self)
    (set-$r process-ring)
    (set! self.process-thread (new-thread
                                (lambda ()
                                  (process self))))
    (set! self.nack-sequences '())
    (thread-start! process-thread))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected (insert-nack self data)
    )
  
  
  (method protected (insert-media self data)
    (insert-data self data))
  
  
  (method protected (insert-data self data)
    (let ((sequence (read-udp-sequence data)))
      (let ((nack? (member? sequence nack-sequences)))
        (when (and udp-debug-nack? nack?)
          (terminal remote-name (udp-name kind) 'insert-resent sequence))
        (unless nack?
          (update-time self data))
        (let ((inserted? (insert process-ring data)))
          (when (and udp-debug-discard? (not inserted?))
            (let ((kind (read-udp-kind data))
                  (sequence (read-udp-sequence data)))
              (let ((label (if nack? '***discard-resent*** '***discard***)))
                (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name kind) label sequence))))))))
  
  
  (method protected (wait-data self)
    (wait process-ring))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((lst (wait-data self)))
        (process-missing self lst)
        (when udp-debug-nack?
          (for-each (lambda (data)
                      (let ((kind (read-udp-kind data))
                            (sequence (read-udp-sequence data)))
                        (when (member? sequence nack-sequences)
                          (terminal remote-name (udp-name kind) 'process-resent sequence))))
                    lst))
        ;; if we always receive in-order from wait then we should be able to
        ;; just validate that it is the case and just scan the list we got
        (for-each (lambda (partition)
                    (bind (frame . datas) partition
                      (process-frame self (sort < datas key: read-udp-sequence))))
                  (sort < (partition lst key: read-udp-frame) key: car)))
      (loop)))
  
  
  (method (process-missing self lst)
    (let ((sorted (sort < lst key: read-udp-sequence)))
      (for-each (lambda (data)
                  (let ((sequence (read-udp-sequence data)))
                    (when (and udp-debug-missing? process-last-sequence)
                      (let ((expected (+ process-last-sequence 1)))
                        (when (/= sequence expected)
                          (loop (for seq from expected below sequence)
                                (let ((label (if (member? seq nack-sequences) '***missing-resent*** '***missing***)))
                                  (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name kind) label seq))))))
                    (set! process-last-sequence sequence)))
                sorted)))
  
  
  (method (process-frame self datas)
    (let ((received (length datas))
          (first (car datas)))
      (let ((kind (read-udp-kind first))
            (origin (read-udp-origin first))
            (sequence (read-udp-sequence first))
            (frame (read-udp-frame first))
            (part (read-udp-part first))
            (total (read-udp-total first))
            (timestamp (read-udp-timestamp first))
            (duration (read-udp-duration first)))
        (when (= total received)
          (if (= total 1)
              (process-data self kind origin sequence frame timestamp duration (read-udp-payload first))
            (let ((chunks (map read-udp-payload datas)))
              (let ((data (apply u8vector-append chunks)))
                (process-data self kind origin sequence frame timestamp duration data))))))))
  
  
  (method (process-data self kind origin sequence frame timestamp duration buffer)
    (define (player-no->id no)
      (get-id (find-player-by-no no)))
    
    (define (process-audio)
      (if (equal? buffer udp-media-off)
          (receive-server-audio (current-audio) (player-no->id origin) #f #f #f)
        (receive-server-audio (current-audio) (player-no->id origin) buffer timestamp duration)))
    
    (define (process-video)
      (if (equal? buffer udp-media-off)
          (receive-server-video (current-video) (player-no->id origin) #f #f #f)
        (receive-server-video (current-video) (player-no->id origin) buffer timestamp duration)))
    
    (ecase kind
      ((udp-audio)
       (process-audio))
      ((udp-video)
       (process-video)))))


;;;
;;;; Access
;;;


(definition public (read-32-bit data pos)
  (let ((b1 (u8vector-ref data pos))
        (b2 (u8vector-ref data (+ pos 1)))
        (b3 (u8vector-ref data (+ pos 2)))
        (b4 (u8vector-ref data (+ pos 3))))
    (bytes->32-bit-integer b1 b2 b3 b4)))


(definition public (read-64-bit data pos)
  (let ((b1 (u8vector-ref data pos))
        (b2 (u8vector-ref data (+ pos 1)))
        (b3 (u8vector-ref data (+ pos 2)))
        (b4 (u8vector-ref data (+ pos 3)))
        (b5 (u8vector-ref data (+ pos 4)))
        (b6 (u8vector-ref data (+ pos 5)))
        (b7 (u8vector-ref data (+ pos 6)))
        (b8 (u8vector-ref data (+ pos 7))))
    (bytes->64-bit-integer b1 b2 b3 b4 b5 b6 b7 b8)))


(definition public (read-u8vector data pos)
  (let ((len (read-32-bit data pos)))
    (let ((v (make-u8vector len))
          (pos (+ pos 4)))
      (subu8vector-move! data pos (+ pos len) v 0)
      v)))


(definition public (write-32-bit data pos value)
  (32-bit-integer->bytes value
    (lambda (b1 b2 b3 b4)
      (u8vector-set! data pos b1)
      (u8vector-set! data (+ pos 1) b2)
      (u8vector-set! data (+ pos 2) b3)
      (u8vector-set! data (+ pos 3) b4))))


(definition public (write-64-bit data pos value)
  (64-bit-integer->bytes value
    (lambda (b1 b2 b3 b4 b5 b6 b7 b8)
      (u8vector-set! data pos b1)
      (u8vector-set! data (+ pos 1) b2)
      (u8vector-set! data (+ pos 2) b3)
      (u8vector-set! data (+ pos 3) b4)
      (u8vector-set! data (+ pos 4) b5)
      (u8vector-set! data (+ pos 5) b6)
      (u8vector-set! data (+ pos 6) b7)
      (u8vector-set! data (+ pos 7) b8))))


(definition public (write-u8vector data pos value)
  (let ((len (u8vector-length value)))
    (write-32-bit data pos len)
    (let ((pos (+ pos 4)))
      (subu8vector-move! value 0 len data pos))))


(definition public (write-subu8vector! data pos value offset count)
  (write-32-bit data pos count)
  (let ((pos (+ pos 4)))
    (subu8vector-move! value offset (+ offset count) data pos)))


;;;
;;;; Format
;;;


;; udp
(definition public (read-udp-kind      data) (read-32-bit   data  0)) (definition public (write-udp-kind      data value) (write-32-bit   data  0 value))
(definition public (read-udp-origin    data) (read-32-bit   data  4)) (definition public (write-udp-origin    data value) (write-32-bit   data  4 value))
(definition public (read-udp-sequence  data) (read-32-bit   data  8)) (definition public (write-udp-sequence  data value) (write-32-bit   data  8 value))
(definition public (read-udp-frame     data) (read-32-bit   data 12)) (definition public (write-udp-frame     data value) (write-32-bit   data 12 value))
(definition public (read-udp-part      data) (read-32-bit   data 16)) (definition public (write-udp-part      data value) (write-32-bit   data 16 value))
(definition public (read-udp-total     data) (read-32-bit   data 20)) (definition public (write-udp-total     data value) (write-32-bit   data 20 value))
(definition public (read-udp-timestamp data) (read-64-bit   data 24)) (definition public (write-udp-timestamp data value) (write-64-bit   data 24 value))
(definition public (read-udp-duration  data) (read-64-bit   data 32)) (definition public (write-udp-duration  data value) (write-64-bit   data 32 value))
(definition public (read-udp-payload   data) (read-u8vector data 40)) (definition public (write-udp-payload   data value) (write-u8vector data 40 value))

(definition public (read-udp-payload-size data)
  (read-32-bit data 40))

(definition public (write-udp-subpayload data value offset count)
  (write-subu8vector! data 40 value offset count))

;; nack
(definition public (read-udp-nack-kind data) (read-32-bit   data 12)) (definition public (write-udp-nack-kind data value) (write-32-bit   data 12 value)))
