;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Tessellation
;;;
;;;  The Initial Developer of the Original Code is Marc Feeley.
;;;  Portions created by the Initial Developer are Copyright (C) 2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier


(module world.tessellation jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.area)
        (world.autoload)
        (world.generate)
        (world.geometry)
        (world.mesh)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;; An icosahedron is a convex solid composed of 20 triangular faces.
;; Each face is an equilateral triangle.  Unfolding the faces onto a
;; flat surface illustrates their connectivity.
;;
;;      /\          /\          /\          /\          /\
;;     /  \        /  \        /  \        /  \        /  \
;;    /    \      /    \      /    \      /    \      /    \
;;   /  3   \    /  7   \    /  11  \    /  15  \    /  19  \
;;  /        \  /        \  /        \  /        \  /        \
;; /__________\/__________\/__________\/__________\/__________\
;; \          /\          /\          /\          /\          /\
;;  \        /  \        /  \        /  \        /  \        /  \
;;   \  2   /    \  6   /    \  10  /    \  14  /    \  18  /    \
;;    \    /  1   \    /  5   \    /  9   \    /  13  \    /  17  \
;;     \  /        \  /        \  /        \  /        \  /        \
;;      \/__________\/__________\/__________\/__________\/__________\
;;       \          /\          /\          /\          /\          /
;;        \        /  \        /  \        /  \        /  \        /
;;         \  0   /    \  4   /    \  8   /    \  12  /    \  16  /
;;          \    /      \    /      \    /      \    /      \    /
;;           \  /        \  /        \  /        \  /        \  /
;;            \/          \/          \/          \/          \/
;;
;; The bottom vertex of faces 0, 4, 8, 12, and 16 is the same point,
;; the south pole.  The top vertex of faces 3, 7, 11, 15, and 19 is
;; the same point, the north pole.
;;
;; The grid can be partitionned into 5 groups of 4 faces.  Each of
;; these groups is a "strip". Each strip can be subdivided into a grid
;; of triangular elements (trixels):
;;
;;      /\           /\           /\           /\           /\
;;     /__\         /__\         /__\         /__\         /__\
;;    /\  /\       /\  /\       /\  /\       /\  /\       /\  /\
;;   /__\/__\     /__\/__\     /__\/__\     /__\/__\     /__\/__\
;;  /\  /\  /\   /\  /\  /\   /\  /\  /\   /\  /\  /\   /\  /\  /\
;; /__\/__\/__\ /__\/__\/__\ /__\/__\/__\ /__\/__\/__\ /__\/__\/__\
;; \  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\
;;  \/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\
;;   \  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\
;;    \/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\
;;     \  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\\  /\  /\  /\
;;      \/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\\/__\/__\/__\
;;       \  /\  /\  / \  /\  /\  / \  /\  /\  / \  /\  /\  / \  /\  /\  /
;;        \/__\/__\/   \/__\/__\/   \/__\/__\/   \/__\/__\/   \/__\/__\/
;;         \  /\  /     \  /\  /     \  /\  /     \  /\  /     \  /\  /
;;          \/__\/       \/__\/       \/__\/       \/__\/       \/__\/
;;           \  /         \  /         \  /         \  /         \  /
;;            \/           \/           \/           \/           \/
;;
;;
;; A strip can be viewed as a skewed N by 2*N rectangular grid.  Each
;; cell of the rectangular grid contains two trixels.  There is a
;; total of 10*N^2 cells and 20*N^2 trixels.  A cell can be identified
;; by a (X,Y) coordinate where 0 <= X < 5*N and 0 <= Y < 2*N.  A trixel
;; can be identified by a (x,y) coordinate where 0 <= x < 10*N and
;; 0 <= y < 2*N.  A trixel at coordinate (x,y) is in the lower half of
;; cell (x/2,y) if x is even, and in the upper half of cell
;; ((x-1)/2,y) if x is odd.
;;
;;      +-------+-------+-------j
;;      | \     | \     | \     |
;;    5 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |
;;      +-------+-------+-------i
;;      | \     | \     | \     |
;;    4 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |
;;      +-------+-------+-------h
;;      | \     | \     | \     |
;;    3 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |
;;      +-------+-------+-------g    g-------h-------i-------j
;;      | \     | \     | \     |    | \     | \     | \     |
;;    2 |   \   |   \   |   \   |  5 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |    |     \ |     \ |     \ |
;;      +-------+-------+-------f    f-------+-------+-------+
;;      | \     | \     | \     |    | \     | \     | \     |
;;    1 |   \   |   \   |   \   |  4 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |    |     \ |     \ |     \ |
;;      +-------+-------+-------e    e-------+-------+-------+
;;      | \     | \     | \     |    | \     | \     | \     |
;; Y  0 |   \   |   \   |   \   |  3 |   \   |   \   |   \   |
;;      |     \ |     \ |     \ |    |     \ |     \ |     \ |
;; ^    a-------b-------c-------d    d-------+-------+-------+
;; |        0       1       2        | \     | \     | \     |
;; |           first strip         2 |   \   |   \   |   \   |
;; +-----> X                         |     \ |     \ |     \ |
;;                                   c-------+-------+-------+
;;                                   | \     | \     | \     |
;;                                 1 |   \   |   \   |   \   |   ...
;;                                   |     \ |     \ |     \ |
;;                                   b-------+-------+-------+
;;                                   | \     | \     | \     |
;;                                 0 |   \   |   \   |   \   |
;;                                   |     \ |     \ |     \ |
;;                                   a-------+-------+-------+
;;                                       3       4       5
;;                                         second strip
;;
;; Each strip shares some vertices with its neighbouring stips.  As
;; shown in the example above, two neighbouring strips share N*3+1
;; vertices (vertices "a" through "j").  The vertices at the poles
;; (vertices "a" and "j") are shared by all strips, so N*3-1 vertices
;; are shared exclusively by two neighbouring cells.  The total number
;; of vertices is equal to 10*N^2 + 2 = 5*((2*N+1)*(N+1) - (N*3+1)) + 2.

(define (trix->strip x <fx> y <fx> N <fx>) <fx>
  (quotient x (* 2 N)))

(define (trix->tile x <fx> y <fx>  N <fx>) <fx>
  (+ (* 10 N y) x))

(define (trix->face x <fx> y <fx> N <fx>) <fx>
  (+ (* 2 (quotient y N))
     (* 4 (trix->strip x y N))
     (if (> (+ (modulo x (* 2 N)) (* 2 (modulo y N))) N) 1 0)))

(define (trix->vertex-west x <fx> y <fx> N <fx>) <fx>
  (+ (* N 5 y) (quotient x 2) 1))

(define (trix->vertex-east x <fx> y <fx> N <fx>) <fx>
  (let ((x/2 (quotient x 2)))
    (cond ((= y 0)
           (+ (* N 5 (modulo x/2 N))
              (* N (modulo (+ (trix->strip x y N) 1) 5))
              1))
          ((= (modulo (+ x/2 1) N) 0)
           (if (< y N)
               (+ (* N 5 (+ y N -1))
                  (* N (modulo (+ (trix->strip x y N) 1) 5))
                  1)
             (+ (modulo y N)
                (* N 5 (+ (* 2 N) -1))
                (* N (modulo (+ (trix->strip x y N) 1) 5))
                1)))
          (else
           (+ (* N 5 (+ y -1)) x/2 2)))))

(define (trix->vertex-south-north x <fx> y <fx> N <fx>) <fx>
  (if (even? x)
      (if (= y 0)
          (if (= (modulo x (* 2 N)) 0)
              0
              (trix->vertex-east (+ x -1) y N))
          (trix->vertex-west x (+ y -1) N))
      (if (= y (+ (* 2 N) -1))
          (if (= (modulo (+ x 1) (* 2 N)) 0)
              (+ (* 10 N N) 1)
              (trix->vertex-west (+ x 1) y N))
          (trix->vertex-east x (+ y 1) N))))

(define (test-trix-fns)

  (define N <fx>
    2)

  (let ((rev-lst '()))
    (let loopy ((y 0))
      (if (< y (* 2 N))
          (let loopx ((x 0))
            (if (< x (* 10 N))
                (begin
                  (set! rev-lst
                        (cons (list (trix->face x y N)
                                    (trix->vertex-west x y N)
                                    (trix->vertex-east x y N)
                                    (trix->vertex-south-north x y N))
                              rev-lst))
                  (loopx (+ x 1)))
                (begin
                  (loopy (+ y 1)))))))

    (let ((r (reverse rev-lst)))
      (if (not (equal? r
                       '((0 1 3 0)
                         (0 1 3 2)
                         (0 2 13 3)
                         (1 2 13 23)
                         (4 3 5 0)
                         (4 3 5 4)
                         (4 4 15 5)
                         (5 4 15 25)
                         (8 5 7 0)
                         (8 5 7 6)
                         (8 6 17 7)
                         (9 6 17 27)
                         (12 7 9 0)
                         (12 7 9 8)
                         (12 8 19 9)
                         (13 8 19 29)
                         (16 9 1 0)
                         (16 9 1 10)
                         (16 10 11 1)
                         (17 10 11 21)
                         (0 11 2 1)
                         (1 11 2 12)
                         (1 12 23 2)
                         (1 12 23 33)
                         (4 13 4 3)
                         (5 13 4 14)
                         (5 14 25 4)
                         (5 14 25 35)
                         (8 15 6 5)
                         (9 15 6 16)
                         (9 16 27 6)
                         (9 16 27 37)
                         (12 17 8 7)
                         (13 17 8 18)
                         (13 18 29 8)
                         (13 18 29 39)
                         (16 19 10 9)
                         (17 19 10 20)
                         (17 20 21 10)
                         (17 20 21 31)
                         (2 21 12 11)
                         (2 21 12 22)
                         (2 22 33 12)
                         (3 22 33 34)
                         (6 23 14 13)
                         (6 23 14 24)
                         (6 24 35 14)
                         (7 24 35 36)
                         (10 25 16 15)
                         (10 25 16 26)
                         (10 26 37 16)
                         (11 26 37 38)
                         (14 27 18 17)
                         (14 27 18 28)
                         (14 28 39 18)
                         (15 28 39 40)
                         (18 29 20 19)
                         (18 29 20 30)
                         (18 30 31 20)
                         (19 30 31 32)
                         (2 31 22 21)
                         (3 31 22 32)
                         (3 32 34 22)
                         (3 32 34 41)
                         (6 33 24 23)
                         (7 33 24 34)
                         (7 34 36 24)
                         (7 34 36 41)
                         (10 35 26 25)
                         (11 35 26 36)
                         (11 36 38 26)
                         (11 36 38 41)
                         (14 37 28 27)
                         (15 37 28 38)
                         (15 38 40 28)
                         (15 38 40 41)
                         (18 39 30 29)
                         (19 39 30 40)
                         (19 40 32 30)
                         (19 40 32 41))))
          (error "test-trix-fns failed")))))

;;(test-trix-fns)

;; The faces of the icosahedron are connected to the vertices as
;; follows:
;;
;;      11          11          11          11          11
;;     /  \        /  \        /  \        /  \        /  \
;;    /    \      /    \      /    \      /    \      /    \
;;   /  3   \    /  7   \    /  11  \    /  15  \    /  19  \
;;  /        \  /        \  /        \  /        \  /        \
;;10__________2/__________4/__________6/__________8/__________10
;; \          /\          /\          /\          /\          /\
;;  \        /  \        /  \        /  \        /  \        /  \
;;   \  2   /    \  6   /    \  10  /    \  14  /    \  18  /    \
;;    \    /  1   \    /  5   \    /  9   \    /  13  \    /  17  \
;;     \  /        \  /        \  /        \  /        \  /        \
;;      1/__________3/__________5/__________7/__________9/__________1
;;       \          /\          /\          /\          /\          /
;;        \        /  \        /  \        /  \        /  \        /
;;         \  0   /    \  4   /    \  8   /    \  12  /    \  16  /
;;          \    /      \    /      \    /      \    /      \    /
;;           \  /        \  /        \  /        \  /        \  /
;;            0/          0/          0/          0/          0/

(define ico-connections <vector>
  '#( ;; 3 vertices for each face (west, east, south/north)
     #(1 3 0)   ;; face 0
     #(1 3 2)   ;; face 1
     #(10 2 1)  ;; face 2
     #(10 2 11) ;; face 3
     #(3 5 0)   ;; face 4
     #(3 5 4)   ;; face 5
     #(2 4 3)   ;; face 6
     #(2 4 11)  ;; face 7
     #(5 7 0)   ;; face 8
     #(5 7 6)   ;; face 9
     #(4 6 5)   ;; face 10
     #(4 6 11)  ;; face 11
     #(7 9 0)   ;; face 12
     #(7 9 8)   ;; face 13
     #(6 8 7)   ;; face 14
     #(6 8 11)  ;; face 15
     #(9 1 0)   ;; face 16
     #(9 1 10)  ;; face 17
     #(8 10 9)  ;; face 18
     #(8 10 11) ;; face 19
     ))

(define ico-vertices <vector>
  (let* ((+phi (/ (+ 1.0 (sqrt 5.0)) 2.0))
         (-phi (- +phi)))
    (vector (vertex -1.0 -phi  0.0)
            (vertex -phi  0.0 -1.0)
            (vertex  0.0 +1.0 -phi)
            (vertex  0.0 -1.0 -phi)
            (vertex +phi  0.0 -1.0)
            (vertex +1.0 -phi  0.0)
            (vertex +phi  0.0 +1.0)
            (vertex  0.0 -1.0 +phi)
            (vertex  0.0 +1.0 +phi)
            (vertex -phi  0.0 +1.0)
            (vertex -1.0 +phi  0.0)
            (vertex +1.0 +phi  0.0)
            )))

(define (make-ico-sphere-vertices N <fx>) <vector>

  (let ((vertices (make-vector (+ (* 10 N N) 2) #f)))

    (define (set-vertex v <fx> x <fl> y <fl> z <fl>) <void>
      (let ((norm (sqrt (+ (* x x) (+ (* y y) (* z z))))))
        (vector-set! vertices
                     v
                     (vertex (/ x norm) (/ y norm) (/ z norm)))))

    (let loop-face ((face 0))
      (if (< face 20)
          (let* ((facex (quotient face 4))
                 (facey (quotient (modulo face 4) 2))
                 (conn (vector-ref ico-connections face))
                 (w (vector-ref ico-vertices (vector-ref conn 0)))
                 (e (vector-ref ico-vertices (vector-ref conn 1)))
                 (sn (vector-ref ico-vertices (vector-ref conn 2)))
                 (dw (vertex (- (vertex-x w)
                                (vertex-x sn))
                             (- (vertex-y w)
                                (vertex-y sn))
                             (- (vertex-z w)
                                (vertex-z sn))))
                 (de (vertex (- (vertex-x e)
                                (vertex-x sn))
                             (- (vertex-y e)
                                (vertex-y sn))
                             (- (vertex-z e)
                                (vertex-z sn)))))

            (define (set v <fx> a <fx> b <fx>) <void>
              (let ((aa (/ (cast <fl> a) (cast <fl> N)))
                    (bb (/ (cast <fl> b) (cast <fl> N))))
                (set-vertex
                  v
                  (+ (vertex-x sn)
                     (+ (* aa (vertex-x de))
                        (* bb (vertex-x dw))))
                  (+ (vertex-y sn)
                     (+ (* aa (vertex-y de))
                        (* bb (vertex-y dw))))
                  (+ (vertex-z sn)
                     (+ (* aa (vertex-z de))
                        (* bb (vertex-z dw)))))))

            (let loop-i ((i 0))
              (if (< i N)
                  (let loop-j ((j 0))
                    (if (< (+ i j) N)
                        (begin

                          (if (even? face)
                              
                              (let* ((basex (* 2 N facex))
                                     (basey (* N facey))
                                     (x (+ basex (* 2 i)))
                                     (y (+ basey j))
                                     (vw (trix->vertex-west x y N)))
                                (set vw i (+ j 1)))
                            
                            (let* ((basex (- (* 2 N (+ facex 1)) 1))
                                   (basey (- (* N (+ facey 1)) 1))
                                   (x (- basex (* 2 i)))
                                   (y (- basey j))
                                   (vw (trix->vertex-west x y N)))
                              (set vw j (+ i 1))))

                          (loop-j (+ j 1)))
                        (loop-i (+ i 1))))
                  (loop-face (+ face 1)))))))

    (let ((v0 (vector-ref ico-vertices 0)))
      (set-vertex 0
                  (vertex-x v0)
                  (vertex-y v0)
                  (vertex-z v0)))

    (let ((v11 (vector-ref ico-vertices 11)))
      (set-vertex (+ (* 10 N N) 1)
                  (vertex-x v11)
                  (vertex-y v11)
                  (vertex-z v11)))

    vertices))

@old
(define (draw-ico-sphere N <fx>)
  (let ((vertices (make-ico-sphere-vertices N)))
    (let loop-x ((x 0))
      (if (< x (* 10 N))
          (let loop-y ((y 0))
            (if (< y (* 2 N))
                (let ((vw (trix->vertex-west x y N))
                      (ve (trix->vertex-east x y N))
                      (vsn (trix->vertex-south-north x y N)))
                  (let ((tl (uv-left uv))
                        (tt (uv-top uv))
                        (tr (uv-right uv))
                        (tb (uv-bottom uv))
                        (texture-depth (uv-depth uv)))
                    (if (even? x)
                        (triangle-proc
                          (vector-ref vertices vw) #f tl tb
                          (vector-ref vertices ve) #f tr tb
                          (vector-ref vertices vsn) #f tr tt
                          texture-depth)
                      (triangle-proc
                        (vector-ref vertices vsn) #f tr tt
                        (vector-ref vertices ve) #f tr tb
                        (vector-ref vertices vw) #f tl tb
                        texture-depth)))
                  (loop-y (+ y 1)))
                (loop-x (+ x 1))))))))

(define (for-each-ico-sphere-tile N <fx> vertices <vector> tile)
  (let loop-x ((x 0))
    (if (< x (* 10 N))
        (let loop-y ((y 0))
          (if (< y (* 2 N))
              (let ((vw (trix->vertex-west x y N))
                    (ve (trix->vertex-east x y N))
                    (vsn (trix->vertex-south-north x y N)))

                (if (even? x)
                    (tile
                     x
                     y
                     (vector-ref vertices vsn)
                     (vector-ref vertices vw)
                     (vector-ref vertices ve))
                    (tile
                     x
                     y
                     (vector-ref vertices vsn)
                     (vector-ref vertices ve)
                     (vector-ref vertices vw)))

                (loop-y (+ y 1)))
              (loop-x (+ x 1)))))))

(definition public (ico-sphere-generator N <fx> uv <f32vector>)
  (lambda (setup-proc triangle-proc quad-proc)
    (let* ((nb-tiles (* 20 N N))
           (vertices (make-ico-sphere-vertices N)))

      (setup-proc nb-tiles 0)

      (for-each-ico-sphere-tile
       N
       vertices
       (lambda (x y v1 v2 v3)
         (let ((tl (uv-left uv))
               (tt (uv-top uv))
               (tr (uv-right uv))
               (tb (uv-bottom uv))
               (texture-depth (uv-depth uv)))
           (triangle-proc
            (vector-ref vertices v1) #f tl tb
            (vector-ref vertices v2) #f tr tb
            (vector-ref vertices v3) #f tr tt
            texture-depth)))))))

)
