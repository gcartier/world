;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Settings
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.settings jazz


(import (jazz.component)
        (jazz.crash)
        (jazz.debuggee)
        (jazz.debuggee.configure)
        (jazz.snapshot)
        (jazz.io)
        (jazz.network)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.template)
        (time)
        (world)
        (world.server))


;;;
;;;; Settings
;;;


(definition protected settings-updates
  (list->updates
    '((version: 100000 targets: settings))))


(definition (convert-settings dir old)
  (define (convert-initial)
    100000)
  
  (case old
    ((#f) (convert-initial))
    (else #f)))


(definition (copy-settings-if-not-exists settings-root (alias #f))
  (unless (exists? settings-root)
    (let ((templates (world-templates-directory alias)))
      (copy-template (new-directory templates "settings")
                     {Directory Home}
                     '()))))


(definition (determine-settings)
  (or (command-argument "settings")
      (let ((settings-dir {Directory Build "settings"}))
        (and (exists? settings-dir)
             (versioned-directory (parse settings-dir) 'settings settings-updates convert-settings feedback?: #f)))
      (let ((settings-root (get-settings-root))
            (settings-alias (get-settings-alias)))
        (copy-settings-if-not-exists settings-root settings-alias)
        (versioned-directory (parse settings-root) 'settings settings-updates convert-settings feedback?: #f))))


(definition public (world-setting name default)
  (user-setting name default 'default))


;;;
;;;; Pathnames
;;;


(definition public (world-alias)
  (if (is-alias? 'World)
      'World
    'Build))


(definition public (world-file path (alias #f))
  (new-file (new Directory (list (or alias (world-alias))))
    path))


(definition public (world-directory path (alias #f))
  (new-directory (new Directory (list (or alias (world-alias))))
    path))


;;;
;;;; Templates
;;;


(definition public (world-templates-directory (alias #f))
  (world-directory '("devel" "templates") alias))


;;;
;;;; Setup
;;;


(definition (register-user-settings)
  (let ((file {File Settings ".settings"}))
    (when (exists? file)
      (register-settings (new File-Settings file: file)))))


(definition public options-settings
  #f)


(definition (register-options-settings)
  (let ((file {File Settings ".options"}))
    (when (not (exists? file))
      (create file))
    (set! options-settings (new File-Settings file: file))
    (register-settings options-settings)))


(initialize-aliases)

(when aliases-setup
  (aliases-setup))

(register-alias 'Settings (tokenise-filename (determine-settings)) override?: #t)

(parameterize ((walk-for #f))
  (register-user-settings)
  (register-options-settings))


;;;
;;;; Bot
;;;


(definition public bot?
  (boolean-argument "bot" #f))


;;;
;;;; Sejour
;;;


(definition public sejour?
  (world-setting 'sejour? (cond-expand (unix #t)
                                       (else #f))))


;;;
;;;; AeC
;;;


(definition public arc-en-ciel?
  (world-setting 'arc-en-ciel? #f))


;;;
;;;; Rating
;;;


(definition public young-child?
  (world-setting 'world.young-child? arc-en-ciel?))


;;;
;;;; Role
;;;


(definition public initial-role
  #f)


(definition public current-role
  #f)

(definition public (set-current-role role)
  (set! current-role role))


(definition public (user?)
  (eq? current-role 'user))

(definition public (creator?)
  (eq? current-role 'creator))

(definition public (designer?)
  (eq? current-role 'designer))

(definition public (programmer?)
  (eq? current-role 'programmer))

(definition public (admin?)
  (eq? current-role 'admin))


(definition (prepare-role)
  (define (determine-role)
    (or (symbol-argument "role" #f)
        (if (server?)
            'admin
          (world-setting 'world.role (if young-child? 'creator 'designer)))))
  
  (let ((role (determine-role)))
    (assert (memq? role (get-valid-roles))
      (set! initial-role role)
      (set! current-role role))))


(prepare-role)


;;;
;;;; Random
;;;


(random-seed)


;;;
;;;; Timezone
;;;


;; set timezone to eastern until adjusted
(let ((timezone (lambda () -18000)))
  (system-timezone-set! timezone)
  (local-timezone-set! timezone))


;;;
;;;; Debuggee
;;;


;; loading debuggee modules up front improves debugging
;; robustness and correctly sets up current process title
(default-debugger-set! (world-setting 'yownu.debugger #f))
(load-debuggee)


;;;
;;;; Snapshots
;;;


(definition public (setup-snapshots)
  (snapshots-directory {Directory Settings "work" "crashes"})
  (snapshot-max-depth (if bot? 1 3))
  (snapshot-max-width 4096)
  (snapshot-max-content 512))


(setup-snapshots)


;;;
;;;; Crashes
;;;


(setup-crash-handler #f)


;;;
;;;; Exceptions
;;;


;; need to think this through about letting gambit handle debugging
;; when there is a controlling terminal versus generating a snapshot
(unless (or (using-debugger?) (controlling-terminal?))
  (set-exception-debugger (snapshot-exception-debugger))
  (set-exception-hook exception-debugger-hook))


;;;
;;;; Load
;;;


(define profile-load?
  (world-setting 'world.profile-load? #f))

(define profile-what
  (world-setting 'world.profile-what 'time))


(define profile-load-base
  #f)

(define profile-load-previous
  #f)


(definition public (load-base)
  (when profile-load?
    (let ((time (current-seconds)))
      (set! profile-load-base kernel-boot)
      (set! profile-load-previous kernel-boot)
      (load-report 'base (- time profile-load-base) (- time profile-load-previous))
      (set! profile-load-previous time))))


(definition public (load-point name)
  (when profile-load?
    (let ((time (current-seconds)))
      (load-report name (- time profile-load-base) (- time profile-load-previous))
      (set! profile-load-previous time))))


(definition public (load-total name)
  (when profile-load?
    (let ((time (current-seconds)))
      (load-report name (- time profile-load-base) (- time profile-load-previous)))))


(definition (load-report name total delta)
  (define (meg bytes)
    (fxround (/ (cast <fl> bytes) 1024. 1024.)))
  
  (case profile-what
    ((time)
     (terminal name (string->number (format "{r precision: 3}" total)) (string->number (format "{r precision: 3}" delta))))
    (else
     (gc)
     (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
       (terminal name (meg last-gc-live) (meg last-gc-movable) (meg last-gc-nonmovable))))))


(load-base)


;;;
;;;; Slave
;;;


(definition protected slave?
  (boolean (command-argument "master")))


(definition protected master-process
  #f)

(definition protected master-cookie
  #f)


;;;
;;;; Local
;;;


(definition protected local-server/client?
  (world-setting 'world.local-server/client? #f))

(definition public (set-local-server/client? flag)
  (set! local-server/client? flag))


;;;
;;;; Server
;;;


(definition server-file
  #f)

(definition public (get-server-file)
  server-file)


(definition server-configuration
  #f)

(definition public (get-server-configuration)
  server-configuration)


(definition (start-server-listener)
  ;; aec quicky
  (set-remote-problem-handler
    (lambda (process)
      (catch (connection-problem? obj
               obj)
        (process))))
  (let ((name (command-argument "server")))
    (if (not name)
        (begin
          (start-remote-presence)
          (let ((listener (get-remote-listener)))
            (let ((file {File Settings "servers" "Local" ".server"})
                  (configuration (new Server host: (listening-host listener) service: (listening-port listener) character-name: "Gimli" character-avatar: "character/dwarfmale")))
              (set! server-file file)
              (set! server-configuration configuration))))
      (let ((file (new-file (new-directory {Directory Settings "servers"} name) ".server")))
        (if (exists? file)
            (let ((configuration (instantiate (read-form file))))
              (let ((host (get-host configuration))
                    (service (get-service configuration)))
                (assert (not (get-remote-listener))
                  (start-remote-presence host: host service: service)))
              (set! server-file file)
              (set! server-configuration configuration))
          (error "Unable to find server: {a}" name))))))


(when (server?)
  (start-tier-listener-set! start-server-listener))


;;;
;;;; Processor
;;;


(definition (start-processor-listener)
  ;; aec quicky
  (set-remote-problem-handler
    (lambda (process)
      (catch (connection-problem? obj
               obj)
        (process))))
  (let ((host (string-argument "host"))
        (service (integer-argument "service")))
    (assert (not (get-remote-listener))
      (start-remote-presence host: host service: service))))


(when (processor?)
  (start-tier-listener-set! start-processor-listener))


;;;
;;;; Slave
;;;


(definition (connect-to-master)
  (let ((master (string-argument "master"))
        (cookie (integer-argument "master-cookie")))
    (receive (host port alternate-port) (parse-host/service master)
      (let ((remote-register (connect-remote-register host port slave?: #t)))
        (set! master-process (load-object remote-register 'world.master 'world-remote-master))
        (set! master-cookie cookie)))))


(when (and slave? (not (worker?)))
  (connect-slave-to-master-set! connect-to-master)))
