;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Settings
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.settings jazz


(import (jazz.component)
        (jazz.crash)
        (jazz.debuggee)
        (jazz.debuggee.configure)
        (jazz.io)
        (jazz.network)
        (jazz.platform)
        (jazz.presence)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.template)
        (world)
        (world.capabilities)
        (world.master)
        (world.server)
        (world.stub))


;;;
;;;; Settings
;;;


(definition protected settings-updates
  (list->updates
    '((version: 100000 targets: settings))))


(definition (convert-settings dir old)
  (define (convert-initial)
    100000)
  
  (case old
    ((#f) (convert-initial))
    (else #f)))


(definition (copy-settings-if-not-exists settings-root (alias #f))
  (unless (exists? settings-root)
    (let ((templates (world-templates-directory alias)))
      (copy-template (new-directory templates "settings")
                     {Directory Home}
                     '()))))


(definition (determine-settings)
  (or (command-argument "settings")
      (let ((settings-dir {Directory Build "settings"}))
        (and (exists? settings-dir)
             (versioned-directory (parse settings-dir) 'settings settings-updates convert-settings feedback?: #f)))
      (let ((settings-root (get-settings-root))
            (settings-alias (get-settings-alias)))
        ;; not needed at the moment
        (unless together?
          (copy-settings-if-not-exists settings-root settings-alias))
        (versioned-directory (parse settings-root) 'settings settings-updates convert-settings feedback?: #f))))


(definition public (world-setting name default)
  (user-setting name default 'default))


;;;
;;;; Pathnames
;;;


(definition public (world-alias)
  (if (is-alias? 'World)
      'World
    'Build))


(definition public (world-file path (alias #f))
  (new-file (new Directory (list (or alias (world-alias))))
    path))


(definition public (world-directory path (alias #f))
  (new-directory (new Directory (list (or alias (world-alias))))
    path))


;;;
;;;; Templates
;;;


(definition public (world-templates-directory (alias #f))
  (world-directory '("devel" "templates") alias))


;;;
;;;; Setup
;;;


(definition traits-argument
  (let ((traits (command-argument "traits")))
    (if (not traits)
        '()
      (map string->symbol (split traits "/")))))

(definition traits-features
  (make-table test: eq?))


(definition public caps-settings
  #f)


(definition (register-caps-settings)
  (let ((file (if (client?)
                  {File Settings "caps" "client.caps"}
                {File Settings "caps" "server.caps"})))
    (let ((computer-speed (estimate-computer-speed)))
      (when (not (exists? file))
        (create-capabilities file computer-speed: computer-speed))
      (set! caps-settings (new File-Settings file: file))
      ;; recreate when version changed or speed improved
      (when (or (not (eqv? (get-setting caps-settings 'caps.version #f) caps-version))
                (> computer-speed (get-setting caps-settings 'caps.computer-speed)))
        (create-capabilities file computer-speed: computer-speed)
        (set! caps-settings (new File-Settings file: file))))
    (register-settings caps-settings)
    (add-snapshot-settings caps-settings)))


(definition public options-settings
  #f)


(definition (register-options-settings)
  (let ((file {File Settings ".options"}))
    (when (not (exists? file))
      (create file))
    (set! options-settings (new File-Settings))
    (let ((setup (get-options-setup)))
      (when setup
        (setup options-settings)))
    (set-file options-settings file)
    (register-settings options-settings)
    (add-snapshot-settings options-settings)))


(definition public user-settings
  #f)


(definition (register-user-settings)
  (set! user-settings (new File-Settings))
  (let ((setup (get-settings-setup)))
    (when setup
      (setup user-settings)))
  (let ((file {File Settings ".settings"}))
    (when (exists? file)
      (set-file user-settings file traits: traits-argument features: traits-features)))
  (register-settings user-settings)
  (add-snapshot-settings user-settings))


(definition protected support-settings-file
  {File Documents "support" "settings"})

(definition public support-settings
  #f)


(definition (register-support-settings)
  (let ((file support-settings-file))
    (when (exists? file)
      (set! support-settings (new File-Settings))
      (set-file support-settings file traits: traits-argument features: traits-features)
      (register-settings support-settings)
      (add-snapshot-settings support-settings))))


(initialize-aliases)

(when aliases-setup
  (aliases-setup))

(register-alias 'Settings (tokenise-filename (determine-settings)) override?: #t)

(register-alias 'Documents (get-documents-root))

(parameterize ((walk-for #f))
  (register-caps-settings)
  (register-options-settings)
  (register-user-settings)
  (register-support-settings))

(let ((override (get-settings-override)))
  (when override
    (override user-settings)))


(let ((unknown-traits (collect-if (lambda (trait)
                                    (not (table-ref traits-features trait #f)))
                                  traits-argument)))
  (when (not-null? unknown-traits)
    (error "Unknown traits: {l}" unknown-traits)))


;;;
;;;; Bot
;;;


(definition public bot?
  (boolean-argument "bot" #f))


;;;
;;;; Sejour
;;;


(definition public sejour?
  (world-setting 'sejour? (cond-expand (unix #t)
                                       (else #f))))


;;;
;;;; AeC
;;;


(definition public arc-en-ciel?
  (world-setting 'arc-en-ciel? #f))


;;;
;;;; Rating
;;;


(definition public young-child?
  (world-setting 'world.young-child? arc-en-ciel?))


;;;
;;;; Together
;;;


(definition public sphere?
  (or (not together?)
      (world-setting 'together.sphere? #t)))


;;;
;;;; Role
;;;


(definition public initial-role
  #f)


(definition public current-role
  #f)

(definition public (set-current-role role)
  (set! current-role role))


(definition public (user?)
  (eq? current-role 'user))

(definition public (creator?)
  (eq? current-role 'creator))

(definition public (designer?)
  (eq? current-role 'designer))

(definition public (developer?)
  (eq? current-role 'developer))

(definition public (admin?)
  (eq? current-role 'admin))


(definition (prepare-role)
  (define (determine-role)
    (or (symbol-argument "role" #f)
        (world-setting 'world.role 'user)))
  
  (let ((role (determine-role)))
    (assert (memq? role (get-valid-roles))
      (set! initial-role role)
      (set! current-role role))))


(prepare-role)


;;;
;;;; Random
;;;


(random-seed)


;;;
;;;; Debuggee
;;;


;; loading debuggee modules up front improves debugging
;; robustness and correctly sets up current process title
(default-debugger-set! (world-setting 'world.debugger #f))
(load-debuggee)


;;;
;;;; Snapshots
;;;


(definition public (setup-snapshots)
  (snapshots-directory {Directory Settings "work" "crashes"})
  (snapshot-max-depth (if bot? 1 3))
  (snapshot-max-width 4096)
  (snapshot-max-content 512))


(setup-snapshots)


;;;
;;;; Crashes
;;;


(setup-crash-handler #f)


;;;
;;;; Exceptions
;;;


;; need to think this through about letting gambit handle debugging
;; when there is a controlling terminal versus generating a snapshot
(unless (or (using-debugger?) (controlling-terminal?))
  (set-exception-debugger (application-exception-debugger))
  (set-exception-hook exception-debugger-hook))


;;;
;;;; Load
;;;


(define profile-load?
  (world-setting 'world.profile-load? #f))

(define profile-what
  (world-setting 'world.profile-what 'time))


(define profile-load-base
  #f)

(define profile-load-previous
  #f)

(define profile-load-done?
  #f)


(definition public (load-base)
  (when (and profile-load? (not profile-load-done?))
    (let ((time (current-seconds)))
      (set! profile-load-base kernel-boot)
      (set! profile-load-previous kernel-boot)
      (load-report 'base (- time profile-load-base) (- time profile-load-previous))
      (set! profile-load-previous time))))


(definition public (load-point name)
  (when (and profile-load? (not profile-load-done?))
    (let ((time (current-seconds)))
      (load-report name (- time profile-load-base) (- time profile-load-previous))
      (set! profile-load-previous time))))


(definition public (load-total name)
  (when (and profile-load? (not profile-load-done?))
    (let ((time (current-seconds)))
      (load-report name (- time profile-load-base) (- time profile-load-previous)))
    (set! profile-load-done? #t)))


(definition (load-report name total delta)
  (define (meg bytes)
    (fxround (/ (cast <fl> bytes) 1024. 1024.)))
  
  (case profile-what
    ((time)
     (format :terminal "{a} {a} {r precision: 3} {r precision: 3}{%}"
       presence-name
       name
       total
       delta))
    (else
     (gc)
     (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
       (format :terminal "{a} {a} {a} {a} {a}{%}"
         presence-name
         name
         (meg last-gc-live)
         (meg last-gc-movable)
         (meg last-gc-nonmovable))))))


(load-base)


;;;
;;;; Slave
;;;


(definition protected slave?
  (boolean (command-argument "master")))


(definition protected master-process
  #f)

(definition protected master-cookie
  #f)


;;;
;;;; Local
;;;


(definition protected local?
  #f)

(definition public (set-local? flag)
  (set! local? flag))


;;;
;;;; Client
;;;


(definition client-configuration
  #f)

(definition public (get-client-configuration)
  client-configuration)

(definition public (set-client-configuration configuration)
  (set! client-configuration configuration))


;;;
;;;; Server
;;;


(definition server-file
  #f)

(definition public (get-server-file)
  server-file)


(definition server-configuration
  #f)

(definition public (get-server-configuration)
  server-configuration)


(definition (start-server-listener)
  (if slave?
      (begin
        (start-remote-presence)
        (let ((listener (get-remote-listener)))
          (let ((host (listening-host listener))
                (service (listening-port listener)))
            (let ((file (new-file {Directory Settings "servers"} (list default-server ".server")))
                  (configuration (new Server host: host service: service character-name: "Server" character-avatar: 'Orb)))
              (set! server-file file)
              (set! server-configuration configuration)))))
    (let ((name (or (command-argument "server") default-server)))
      (let ((file (new-file (new-directory {Directory Settings "servers"} (tokenise-filename name)) ".server")))
        (if (exists? file)
            (let ((configuration (instantiate (read-form file))))
              (let ((host (get-host configuration))
                    (service (get-service configuration)))
                (assert (not (get-remote-listener))
                  (start-remote-presence host: host service: service))
                (set! server-file file)
                (set! server-configuration configuration)))
          (error "Unable to find server: {a}" name))))))


(when (server?)
  (start-tier-listener-set! start-server-listener))


;;;
;;;; Processor
;;;


(definition (start-processor-listener)
  (let ((host (string-argument "host"))
        (service (integer-argument "port")))
    ;; worker might end up taking our service
    (let ((alternate-service (+ service 1)))
      (assert (not (get-remote-listener))
        (start-remote-presence host: host service: service alternate-service: alternate-service)))))


(when (processor?)
  (start-tier-listener-set! start-processor-listener))


;;;
;;;; Master
;;;


(definition protected use-worker?
  (if (worker?)
      #f
    #f
    @bantoo
    (world-setting 'world.worker? #t)))


(when (or (and (not (worker?)) use-worker?)
          sphere?)
  (register-proxy 'world-remote-master
                  World-Remote-Master-Local-Proxy
                  (new World-Remote-Master))
  (register-proxy 'world-remote-master
                  World-Remote-Master-Local-Proxy
                  (new World-Remote-Master)
                  'working))


;;;
;;;; Slave
;;;


(definition (connect-to-master)
  (let ((master (string-argument "master"))
        (cookie (integer-argument "master-cookie")))
    (receive (host port alternate-port) (parse-host/service master)
      (let ((remote-register (connect-remote-register host port slave?: #t)))
        (set! master-process (load-object remote-register 'world.master 'world-remote-master))
        (set! master-cookie cookie)))))


(when (and slave? (not (worker?)))
  (connect-slave-to-master-set! connect-to-master)))
