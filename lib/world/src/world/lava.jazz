;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Lava
;;;
;;;  The Initial Developer of the Original Code is Edouard Hebert.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.lava jazz


(import (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.flow)
        (world.history)
        (world.generation)
        (world.support)
        (world.syntax (phase syntax))
        (world.task))


(definition public (lava-task task <Task>)
  (declare (proper-tail-calls))
  (let ((zone (current-zone))
        (game (current-game))
        (history (current-history))
        (me (current-me))
        (first-call? #t))
    (with-task task
      (lambda (exit)
        ;; quick hack for now
        (if (not (minecraft?~ zone))
            (task-sleep task +infinity 0. exit)
          (let ((lava-blocks (new-queue)))
            (let (iter (previous (current-seconds)))
              (let ((time (current-seconds)))
                (let ((elapse (- time previous)))
                  (unless (get-paused?~ history)
                    (with-task-mutex
                      (lambda ()
                        (unless (stopping?~ task)
                          (trace-task lava "L")
                          (if first-call?
                              (begin
                                (set! first-call? #f)
                                (set! lava-blocks (find-flowing-lava (element-sector~ zone me))))
                            (begin
                              (set! lava-blocks (merge-queues lava-blocks (get-lava-blocks~ game)))
                              (set-lava-blocks~ game (new-queue))))
                          (unless (queue-empty? lava-blocks)
                            (set! lava-blocks (tick-lava elapse lava-blocks)))))))
                  (let ((duration (- (current-seconds) time)))
                    (task-sleep task lava-period duration exit))
                  (iter time))))))))))


(definition (tick-lava elapse lava-blocks)
  (site (lava on?: #t)
    (lava-flow elapse lava-blocks)))


(definition (find-flowing-lava sector)
  (let ((zone (current-zone))
        (queue (new-queue)))
    (iterate-sector-neighbors~ zone sector 1
      (lambda (sector)
        (sector-iterate-blocks~ zone sector '(10)
          (lambda (index)
            (enqueue queue (cons sector (index->coordinates index)))))))
    queue))


(definition (lava-flow elapse lava-blocks)
  (let ((zone (current-zone))
        (new-lava-blocks (new-queue)))
    (updating-sectors~ zone
      (lambda (add-sector)
        (let (iter)
          (unless (queue-empty? lava-blocks)
            (bind (sector i j k) (dequeue lava-blocks)
              (call-with-sector~ zone sector i j k
                (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                  (with-field i j k
                    (lambda (section index)
                      (when (and section (memq? (block-ref section index) '(10 11)))
                        (let ((data (data-ref section index)))
                          (define (get-inward-flow i j k)
                            (define (side-flow side-i side-j side-k)
                              (with-field side-i side-j side-k
                                (lambda (section index)
                                  (if (and section (memq? (block-ref section index) '(10 11)))
                                      (let ((data (data-ref section index)))
                                        (cond ((< data 6)
                                               (+ data 2))
                                              ((= data 6)
                                               7)
                                              ((> data 6)
                                               (with-field side-i (- side-j 1) side-k
                                                 (lambda (section index)
                                                   (if (and section (memq? (block-ref section index) '(10 11)))
                                                       7
                                                     2))))))
                                    7))))
                            
                            (define (top-flow)
                              (with-field i (+ j 1) k
                                (lambda (section index)
                                  (if (and section (memq? (block-ref section index) '(10 11)))
                                      (let ((data (data-ref section index)))
                                        (if (< data 8)
                                            (+ data 8)
                                          data))
                                    0))))
                            
                            (max
                              (top-flow)
                              (min
                                (side-flow (+ i 1) j k)
                                (side-flow (- i 1) j k)
                                (side-flow i j (+ k 1))
                                (side-flow i j (- k 1)))))
                          
                          (define (flow i j k data)
                            (with-field i j k
                              (lambda (section1 index1)
                                (define (flow-direction side-i side-j side-k)
                                  (unless (= data 6)
                                    (with-field (+ i side-i) (+ j side-j) (+ k side-k)
                                      (lambda (section index)
                                        (when section
                                          (with-field (+ (* side-i 2) i) (+ (* side-j 2) j) (+ (* side-k 2) k)
                                            (lambda (section2 index2)
                                              (when section2
                                                (let ((block (block-ref section2 index2))
                                                      (data-id (data-ref section2 index2)))
                                                  (if (memq? (block-ref section index) '(8 9))
                                                      (begin
                                                        (data-set! section1 index1 0)
                                                        (block-set! section1 index1 (if (= data 0) 49 4)))
                                                    (if (and (memq? block '(8 9)) (not (= (block-ref section index) 4)))
                                                        (begin
                                                          (data-set! section index 0)
                                                          (block-set! section index 4)
                                                          (enqueue-sector/coordinates new-lava-blocks (get-sector~ section1) (index->coordinates index1) with-field))
                                                      (when (or (memq? (block-ref section index) can-flow-in) (and (memq? (block-ref section index) '(10 11)) (> (data-ref section index) (modulo data 8)) (< (data-ref section index) 8)))
                                                        (block-set! section index 10)
                                                        (data-set! section index (if (> data 7) 2 (+ data 2)))
                                                        (add-sector (get-sector~ section))
                                                        (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (index->coordinates index) with-field)))))))))))))
                                
                                (when section1
                                  (when (memq? (block-ref section1 index1) '(10 11))
                                    (with-field i (- j 1) k
                                      (lambda (section index)
                                        (let ((block (block-ref section index)))
                                          (if (memq? block '(8 9))
                                              (begin
                                                (data-set! section index 0)
                                                (enqueue-sector/coordinates new-lava-blocks (get-sector~ section1) (index->coordinates index1) with-field)
                                                (block-set! section index (if (= (data-ref section index) 0) 1 4)))
                                            (if (memq? block (cons 10 (cons 11 can-flow-in)))
                                                (begin
                                                  (block-set! section index 10)
                                                  (data-set! section index (if (> data 7) data (+ data 8)))
                                                  (add-sector (get-sector~ section))
                                                  (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (index->coordinates index) with-field)
                                                  (when (= data 0)
                                                    (flow-direction -1  0  0)
                                                    (flow-direction  1  0  0)
                                                    (flow-direction  0  0 -1)
                                                    (flow-direction  0  0  1)))
                                              (begin
                                                (flow-direction -1  0  0)
                                                (flow-direction  1  0  0)
                                                (flow-direction  0  0 -1)
                                                (flow-direction  0  0  1))))))))))))
                          
                          (unless (= data 0)
                            (let ((level-set (get-inward-flow i j k)))
                              (if (= level-set 7)
                                  (begin
                                    (block-set! section index 0)
                                    (data-set! section index 0)
                                    (with-field i (- j 1) k
                                      (lambda (section index)
                                        (add-sector (get-sector~ section))
                                        (when (memq? (block-ref section index) '(10 11))
                                          (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (index->coordinates index) with-field)))))
                                (when (/= level-set data)
                                  (data-set! section index level-set)))
                              (when (/= level-set data)
                                (bind (i j k) (index->coordinates index)
                                  (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (list (- i 1) j k) with-field)
                                  (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (list (+ i 1) j k) with-field)
                                  (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (list i j (- k 1)) with-field)
                                  (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (list i j (+ k 1)) with-field)))))
                          (flow i j k (data-ref section index))))
                      (add-sector (get-sector~ section)))))))
            (iter))))
      delay-update?: #t)
    new-lava-blocks)))
