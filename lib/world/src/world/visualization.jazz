;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; UDP Visualization
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.visualization jazz


(import (jazz.math)
        (jazz.stream)
        (world)
        (world.audio)
        (world.context)
        (world.event)
        (world.evolution)
        (world.client.udp)
        (world.server.udp)
        (world.settings)
        (world.simulation)
        (world.udp)
        (world.video))


(definition show-visualize?
  (world-setting 'world.show-visualize? #f))

(definition debug-visualize?
  (world-setting 'world.debug-visualize? #f))


(definition protected visualizer-render
  #f)

(definition protected (set-visualizer-render render)
  (set! visualizer-render render))


(definition protected (render-visualizer)
  (when visualizer-render
    (visualizer-render)))


;;;
;;;; Visualize
;;;


(class UDP-Visualizer extends Object
  
  
  (slot call                             getter generate)
  (slot client                           getter generate)
  (slot origin                           getter generate)
  (slot media-kind                       getter generate)
  (slot channel                          getter generate)
  (slot ring                             getter generate)
  (slot origin-audio                     getter generate)
  (slot origin-audio-header              getter generate)
  (slot origin-video                     getter generate)
  (slot origin-evolution                 getter generate)
  (slot receiver-evolution               getter generate)
  (slot audio-output                     getter generate)
  (slot video-output                     getter generate)
  (slot audio-header-played?             getter generate)
  (slot video-header-played?             getter generate)
  (slot datas                            getter generate)
  (slot adds                             getter generate)
  (slot removes                          getter generate)
  (slot last-time          initialize #f accessors generate)
  (slot last-event         initialize #f accessors generate)
  
  
  (method override (initialize self call client origin media-kind channel ring origin-audio origin-audio-header origin-video origin-evolution receiver-evolution audio-output video-output)
    (nextmethod self)
    (set! self.call call)
    (set! self.client client)
    (set! self.origin origin)
    (set! self.media-kind media-kind)
    (set! self.channel channel)
    (set! self.ring ring)
    (set! self.origin-audio origin-audio)
    (set! self.origin-audio-header origin-audio-header)
    (set! self.origin-video origin-video)
    (set! self.origin-evolution origin-evolution)
    (set! self.receiver-evolution receiver-evolution)
    (set! self.audio-output audio-output)
    (set! self.video-output video-output)
    (set! self.audio-header-played? #f)
    (set! self.video-header-played? #f)
    (set! self.datas (make-table test: eqv?))
    (set! self.adds (make-table test: eqv?))
    (set! self.removes (make-table test: eqv?))
    (setup-datas self))
  
  
  (method (setup-datas self)
    (define (locate-info create sequence)
      (loop (for info from (+ create 1) to (last-position origin-evolution))
            (when (and (= (evolutionary-udp-id origin-evolution info) udp-id-create-info)
                       (= (evolutionary-udp-kind origin-evolution info) media-kind)
                       (= (evolutionary-udp-sequence origin-evolution info) sequence))
              (return info))
            (finally #f)))
    
    (loop (for create from (first-position origin-evolution) to (last-position origin-evolution))
          (when (and (= (evolutionary-udp-id origin-evolution create) udp-id-create-packet)
                     (= (evolutionary-udp-kind origin-evolution create) media-kind))
            (let ((sequence (evolutionary-udp-sequence origin-evolution create)))
              (let ((info (locate-info create sequence)))
                (when info
                  (let ((data (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4)))
                                (let ((origin (flonum->fixnum (evolutionary-udp-origin origin-evolution create)))
                                      (kind (flonum->fixnum (evolutionary-udp-kind origin-evolution create)))
                                      (frame (evolutionary-udp-frame origin-evolution create))
                                      (part (flonum->fixnum (evolutionary-udp-data2 origin-evolution info)))
                                      (total (flonum->fixnum (evolutionary-udp-data3 origin-evolution info)))
                                      (header? (= (evolutionary-udp-data3 origin-evolution create) 123456.))
                                      (timestamp (evolutionary-udp-data4 origin-evolution create))
                                      (duration (evolutionary-udp-data4 origin-evolution info)))
                                  (let ((data (make-u8vector header-size))
                                        (nanostamp (flonum->timestamp timestamp))
                                        (nanoduration (flonum->timestamp duration)))
                                    (write-udp-kind data kind)
                                    (write-udp-origin data origin)
                                    (write-udp-sequence data sequence)
                                    (write-udp-frame data frame)
                                    (write-udp-part data part)
                                    (write-udp-total data total)
                                    (write-udp-media-timestamp data nanostamp)
                                    (write-udp-media-duration data nanoduration)
                                    (write-udp-media-header? data header?)
                                    (write-udp-media-off? data #f)
                                    (write-udp-resent data 0)
                                    data)))))
                    (table-set! datas sequence data))))))))
  
  
  (method (find-data self sequence)
    (table-ref datas sequence #f))
  
  
  (method protected (visualize-from self from-event to-time)
    (declare (proper-tail-calls))
    (let ((first (first-position receiver-evolution))
          (last (last-position receiver-evolution)))
      (let (loop (n (or from-event first)))
        (when (<= n last)
          (let ((time (evolutionary-udp-time receiver-evolution n)))
            (when (<= time to-time)
              (visualize-event self n)
              (set! last-time time)
              (set! last-event n)
              (loop (+ n 1))))))))
  
  
  (method protected (visualize-event self n)
    (define (visualized-channel?)
      (and (= (evolutionary-udp-origin receiver-evolution n) origin)
           (= (evolutionary-udp-kind receiver-evolution n) media-kind)))
    
    (let ((id (evolutionary-udp-id receiver-evolution n)))
      (ecase id
        ;; self / src / sink / draw
        ((udp-id-src-self udp-id-src-media udp-id-sink-media udp-id-draw-video))
        ;; create / info
        ((udp-id-create-packet udp-id-create-info))
        ;; retain / release
        ((udp-id-retain-packet udp-id-release-packet))
        ;; resend / absent
        ((udp-id-resend-packet udp-id-absent-packet))
        ;; time
        ((udp-id-update-time))
        ;; insert
        ((udp-id-insert-packet)
         (when (visualized-channel?)
           (let ((time (evolutionary-udp-time receiver-evolution n))
                 (sequence (evolutionary-udp-sequence receiver-evolution n)))
             (let ((time-base (let ((time-base (evolutionary-udp-data3 receiver-evolution n)))
                                ;; quick hack for timeless
                                (if (= time-base -1.)
                                    (- time (evolutionary-udp-data4 receiver-evolution n))
                                  time-base))))
               (let ((data (find-data self sequence)))
                 (when data
                   (when show-visualize?
                     (terminal 'insert sequence))
                   (visualizer-update-time ring time-base)
                   (let ((from (and (/= (get-count ring) 0) (get-highest ring))))
                     (insert ring data)
                     (table-set! adds sequence time)
                     (when from
                       (let ((to (get-highest ring)))
                         (loop (for seq from (+ from 1) below to)
                               (table-set! adds seq time)))))))))))
        ;; nack
        ((udp-id-nack-packet))
        ;; gap
        ((udp-id-packet-gap))
        ;; got
        ((udp-id-got-packet)
         (when (visualized-channel?)
           (let ((sequence (evolutionary-udp-sequence receiver-evolution n)))
             (let ((data (find-data self sequence)))
               (when data
                 (when show-visualize?
                   (terminal 'got sequence))
                 (visualizer-replace-got ring sequence data))))))
        ;; duplicate
        ((udp-id-duplicate-packet))
        ;; reject
        ((udp-id-reject-packet))
        ;; play / freeze
        ((udp-id-play-frame udp-id-freeze-frame)
         (when (visualized-channel?)
           (let ((frame (evolutionary-udp-frame receiver-evolution n)))
             (when show-visualize?
               (terminal 'play frame))
             (let ((packet (earliest-packet ring)))
               (let ((consistent? (and packet (eqv? (get-frame packet) frame))))
                 (when (if debug-visualize? (assert consistent? #t) consistent?)
                   ;; we cannot rely on having the headers in the evolution
                   ;; on the other hand playing implies state ok or late...
                   (if (= id udp-id-play-frame)
                       (state-ok ring)
                     (state-late ring))
                   (let ((complete? (frame-complete? ring 0)))
                     (visualizer-iterate-frame ring
                       (lambda (packet)
                         (table-set! removes (get-sequence packet) (list packet (evolutionary-udp-time receiver-evolution n) complete?))))
                     (when complete?
                       (let ((first (packet-ref ring 0)))
                         (let ((sequence (get-sequence first))
                               (total (get-total first))
                               (header? (get-header? first))
                               (origin-media (if (= media-kind udp-audio) origin-audio origin-video)))
                           (let ((packets (loop (for n from 0 below total)
                                                (collect (locate-packet origin-media (+ sequence n))))))
                             (when (loop (for packet in packets)
                                         (every (and packet (get-data packet))))
                               (let ((buffer (if (= total 1)
                                                 (read-udp-media-payload (get-data (car packets)))
                                               (let ((chunks (map read-udp-media-payload (map get-data packets))))
                                                 (apply u8vector-append chunks))))
                                     (timestamp (flonum->timestamp (get-timestamp packet)))
                                     (duration (get-duration packet)))
                                 (ecase media-kind
                                   ((udp-audio)
                                    (let ()
                                      (define (play-header buffer)
                                        (let ((headers (u8vector->object buffer)))
                                          (for-each (lambda (header)
                                                      (bind (buffer timestamp duration) header
                                                        (receive-visualizer-audio (current-audio) audio-output buffer timestamp duration)))
                                                    headers)
                                          (set! audio-header-played? #t)))
                                      
                                      (if (and header? (eq? audio-codec 'vorbis))
                                          (play-header buffer)
                                        (when (and origin-audio-header
                                                   (not audio-header-played?))
                                          (play-header origin-audio-header))
                                        (receive-visualizer-audio (current-audio) audio-output buffer timestamp duration))))
                                   ((udp-video)
                                    (if header?
                                        (begin
                                          (set! video-header-played? #t)
                                          (receive-visualizer-video (current-video) video-output buffer timestamp duration))
                                      (when video-header-played?
                                        (receive-visualizer-video (current-video) video-output buffer timestamp duration))))))))))))
                   (visualizer-remove-frame ring)))))))
        ;; missing
        ((udp-id-missing-packet)
         (when (visualized-channel?)
           (let ((sequence (evolutionary-udp-sequence receiver-evolution n)))
             (when show-visualize?
               (terminal 'missing sequence))
             (let ((packet (earliest-packet ring)))
               (let ((consistent? (and packet (eqv? (get-sequence packet) sequence))))
                 (when (if debug-visualize? (assert consistent? #t) consistent?)
                   (assert (not (get-data packet))
                     (table-set! removes (get-sequence packet) (list packet (evolutionary-udp-time receiver-evolution n) #f))
                     (remove-packet ring))))))))
        ;; discard
        ((udp-id-discard-packet)
         (when (visualized-channel?)
           (let ((sequence (evolutionary-udp-sequence receiver-evolution n)))
             (when show-visualize?
               (terminal 'discard sequence))
             (let ((packet (earliest-packet ring)))
               (let ((consistent? (and packet (eqv? (get-sequence packet) sequence))))
                 (when (if debug-visualize? (assert consistent? #t) consistent?)
                   (assert (get-data packet)
                     (table-set! removes (get-sequence packet) (list packet (evolutionary-udp-time receiver-evolution n) (frame-complete? ring 0)))
                     (remove-packet ring))))))))
        ;; ok
        ((udp-id-state-ok)
         (when (visualized-channel?)
           (when show-visualize?
             (terminal 'ok))
           (state-ok ring)))
        ;; late
        ((udp-id-state-late)
         (when (visualized-channel?)
           (when show-visualize?
             (terminal 'late))
           (state-late ring)))
        ;; waiting
        ((udp-id-state-waiting)
         (when (visualized-channel?)
           (when show-visualize?
             (terminal 'waiting))
           (state-waiting ring)))
        ;; ack / traffic
        ((udp-id-receive-ack udp-id-traffic-rate))
        ;; reset
        ((udp-id-reset-media))
        ;; throttle throttle-on throttle-off
        ((udp-id-throttle-frame udp-id-throttle-on udp-id-throttle-off))
        ;; system
        ((udp-id-paint-event udp-id-reshape-event udp-id-close-event udp-id-key-event udp-id-char-event udp-id-button-event udp-id-moved-event udp-id-wheel-event udp-id-file-event udp-id-drop-event udp-id-enter-event udp-id-leave-event udp-id-activate-event udp-id-deactivate-event udp-id-quit-event udp-id-user-event udp-id-other-event))
        ;; other
        (else
         (terminal 'unvisualized (evolution-id->abbrev id))))))))
