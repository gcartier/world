;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World 3D Format
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.w3d jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.system)
        (world)
        (world.animation)
        (world.atlas)
        (world.binary)
        (world.dye)
        (world.external)
        (world.foreign)
        (world.geometry)
        (world.homogeneous)
        (world.material)
        (world.mesh)
        (world.model)
        (world.renderer)
        (world.support)
        (world.texture)
        (world.triangle))


(proclaim (warn optimizations))


;;;
;;;; Vertex
;;;


(class W3D-Vertex extends Object
  
  
  (slot position     <object> initialize #f accessors generate)
  (slot normal       <object> initialize #f accessors generate)
  (slot texcoord     <object> initialize #f accessors generate)
  (slot blendweight0 <object> initialize #f accessors generate)
  (slot blendweight1 <object> initialize #f accessors generate)
  (slot blendweight2 <object> initialize #f accessors generate)
  (slot blendweight3 <object> initialize #f accessors generate))


;;;
;;;; Node
;;;


(class W3D-Node extends Object
  
  
  (slot id          <object> accessors generate)
  (slot translation <object> accessors generate)
  (slot rotation    <object> accessors generate)
  (slot scale       <object> accessors generate)
  (slot parts       <object> accessors generate)
  (slot children    <object> accessors generate)
  
  
  (method override (initialize id translation rotation scale parts children)
    (set! id~self id)
    (set! translation~self translation)
    (set! rotation~self rotation)
    (set! scale~self scale)
    (set! parts~self parts)
    (set! children~self children))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id))))
  
  
  (method (bone?)
    ;; need to improve this heuristic
    (starts-with? id "Bone"))
  
  
  (method (transformation-matrix)
    (let ((translation (if translation (make-translation-matrix& translation) (make-identity-matrix&)))
          (rotation (if rotation (make-quaternion-matrix& rotation) (make-identity-matrix&)))
          (scaling (make-identity-matrix&)))
      (matrix-multiply translation (matrix-multiply& rotation scaling)))))


;;;
;;;; Node-Part
;;;


(class W3D-Node-Part extends Object
  
  
  (slot meshpartid <object> accessors generate)
  (slot materialid <object> accessors generate)
  (slot uvMapping  <object> accessors generate)
  
  
  (method override (initialize meshpartid materialid uvMapping)
    (set! meshpartid~self meshpartid)
    (set! materialid~self materialid)
    (set! uvMapping~self uvMapping)))


;;;
;;;; Material
;;;


(class W3D-Material extends Object
  
  
  (slot id       <object> accessors generate)
  (slot ambient  <object> accessors generate)
  (slot diffuse  <object> accessors generate)
  (slot specular <object> accessors generate)
  (slot textures <object> accessors generate)
  
  
  (method override (initialize id ambient diffuse specular textures)
    (set! id~self id)
    (set! ambient~self ambient)
    (set! diffuse~self diffuse)
    (set! specular~self specular)
    (set! textures~self textures))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id)))))


;;;
;;;; Texture
;;;


(class W3D-Texture extends Object
  
  
  (slot id       <object> accessors generate)
  (slot filename <object> accessors generate)
  (slot type     <object> accessors generate)
  
  
  (method override (initialize id filename type)
    (set! id~self id)
    (set! filename~self filename)
    (set! type~self type))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id)))))


;;;
;;;; Mesh
;;;


(class W3D-Mesh extends Object
  
  
  (slot vertices   <object> accessors generate)
  (slot parts      <object> accessors generate)
  
  
  (method override (initialize vertices parts)
    (set! vertices~self vertices)
    (set! parts~self parts))
  
  
  (method (find-part part-id)
    (find-if (lambda (part)
               (equal? (get-id~ part) part-id))
             parts)))


;;;
;;;; Mesh-Part
;;;


(class W3D-Mesh-Part extends Object
  
  
  (slot id      <object> accessors generate)
  (slot indices <object> accessors generate)
  
  
  (method override (initialize id indices)
    (set! id~self id)
    (set! indices~self indices))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id)))))


;;;
;;;; Animation
;;;


(class W3D-Animation extends Object
  
  
  (slot id    <object> accessors generate)
  (slot bones <object> accessors generate)
  
  
  (method override (initialize id bones)
    (set! id~self id)
    (set! bones~self bones))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id))))
  
  
  (method (find-bone bone-id)
    (find-if (lambda (bone)
               (equal? bone-id (get-boneid~ bone)))
             bones)))


;;;
;;;; Bone-Animation
;;;


(class W3D-Bone-Animation extends Object
  
  
  (slot boneid    <object> accessors generate)
  (slot keyframes <object> accessors generate)
  
  
  (method override (initialize boneid keyframes)
    (set! boneid~self boneid)
    (set! keyframes~self keyframes))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" boneid)))))


;;;
;;;; KeyFrame
;;;


(class W3D-KeyFrame extends Object
  
  
  (slot keytime     <object> accessors generate)
  (slot translation <object> accessors generate)
  (slot rotation    <object> accessors generate)
  (slot scale       <object> accessors generate)
  
  
  (method override (initialize keytime translation rotation scale)
    (set! keytime~self keytime)
    (set! translation~self translation)
    (set! rotation~self rotation)
    (set! scale~self scale))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" keytime)))))


;;;
;;;; Model
;;;


(class W3D-Model extends Object
  
  
  (slot meshes     <object> accessors generate)
  (slot materials  <object> accessors generate)
  (slot nodes      <object> accessors generate)
  (slot animations <object> accessors generate)
  
  
  (method (find-mesh-part part-id)
    (continuation-capture
      (lambda (return)
        (for-each (lambda (mesh)
                    (for-each (lambda (part)
                                (when (equal? (get-id~ part) part-id)
                                  (continuation-return return (values mesh part))))
                              (get-parts~ mesh)))
                  meshes)
        (values #f #f))))
  
  
  (method (find-material material-id)
    (find-if (lambda (material)
               (equal? (get-id~ material) material-id))
             materials))
  
  
  (method (extract-atlas file)
    (let ((atlas (new Atlas mipmap?: #f repeat?: #t pad?: #f normalize?: #f)))
      (for-each (lambda (material)
                  (let ((textures (get-textures~ material)))
                    (when textures
                      (for-each (lambda (texture)
                                  (let ((filename (get-filename~ texture)))
                                    (add-file~ atlas (new-brother~ file filename))))
                                textures))))
                materials)
      (complete~ atlas)
      atlas))
  
  
  (method (extract-geometry file atlas mesh)
    (define (count-triangles)
      (let ((count 0))
        (loop (for part in (get-parts~ mesh))
              (let ((indices (get-indices~ part)))
                (increase! count (/ (vector-length indices) 3))))
        count))
    
    (let ((vertex-floats 10))
      (let ((triangle-floats (* 3 vertex-floats))
            (triangle-neighbors-floats (* 3 7))
            (triangles-count (count-triangles))
            (vertices (get-vertices~ mesh)))
        (let ((content (make-f32vector (* triangles-count triangle-floats)))
              (neighbors (make-f32vector (* triangles-count triangle-neighbors-floats)))
              (n 0)
              (m 0))
          (define (vertex-ref index)
            (list-ref vertices index))
          
          (define (vertex-bone v)
            (let ((b (get-blendweight0~ v)))
              (if (not b)
                  0.
                (f64vector-ref b 0))))
          
          (define (add-triangle n1 n2 n3 matrix adjust-uv)
            (define (transform vert)
              (matrix-transform matrix vert))
            
            (let ((v1 (vertex-ref n1))
                  (v2 (vertex-ref n2))
                  (v3 (vertex-ref n3)))
              (add
                (transform (get-position~ v1)) (get-normal~ v1) (adjust-uv (get-texcoord~ v1)) (vertex-bone v1)
                (transform (get-position~ v2)) (get-normal~ v2) (adjust-uv (get-texcoord~ v2)) (vertex-bone v2)
                (transform (get-position~ v3)) (get-normal~ v3) (adjust-uv (get-texcoord~ v3)) (vertex-bone v3))))
          
          (define (add v1 n1 t1 b1 v2 n2 t2 b2 v3 n3 t3 b3)
            (add-vertex v1) (add-normal n1) (add-texture t1) (add-bone b1) (add-neighbors 0. v2 v3)
            (add-vertex v2) (add-normal n2) (add-texture t2) (add-bone b2) (add-neighbors 1. v1 v3)
            (add-vertex v3) (add-normal n3) (add-texture t3) (add-bone b3) (add-neighbors 2. v1 v2))
          
          (define (add-vertex vert)
            (f32vector-set! content n (vertex-x vert))
            (f32vector-set! content (+ n 1) (vertex-y vert))
            (f32vector-set! content (+ n 2) (vertex-z vert))
            (set! n (+ n 3)))
          
          (define (add-normal normal)
            (f32vector-set! content n (vertex-x normal))
            (f32vector-set! content (+ n 1) (vertex-y normal))
            (f32vector-set! content (+ n 2) (vertex-z normal))
            (set! n (+ n 3)))
          
          (define (add-texture tex)
            (f32vector-set! content n (vertex-x tex))
            (f32vector-set! content (+ n 1) (vertex-y tex))
            (f32vector-set! content (+ n 2) (vertex-z tex))
            (set! n (+ n 3)))
          
          (define (add-bone bone-id)
            (f32vector-set! content n bone-id)
            (set! n (+ n 1)))
          
          (define (add-neighbors rank n1 n2)
            (f32vector-set! neighbors m rank)
            (set! m (+ m 1))
            (f32vector-set! neighbors m (vertex-x n1))
            (f32vector-set! neighbors (+ m 1) (vertex-y n1))
            (f32vector-set! neighbors (+ m 2) (vertex-z n1))
            (set! m (+ m 3))
            (f32vector-set! neighbors m (vertex-x n2))
            (f32vector-set! neighbors (+ m 1) (vertex-y n2))
            (f32vector-set! neighbors (+ m 2) (vertex-z n2))
            (set! m (+ m 3)))
          
          (define (add-node node)
            (let ((parts (get-parts~ node)))
              (when parts
                (let ((matrix (transformation-matrix~ node)))
                  (loop (for part in parts)
                        (let ((mesh-part (find-part~ mesh (get-meshpartid~ part))))
                          ;; for now it is possible to find no part since we
                          ;; are traversing all nodes for a single target mesh
                          (when mesh-part
                            (let ((material (find-material (get-materialid~ part))))
                              (let ((indices (get-indices~ mesh-part))
                                    (image (extract-base (get-filename~ (car (get-textures~ material))))))
                                (let ((uv (image-rect~ atlas image)))
                                  (let ((left (uv-left uv))
                                        (top (uv-top uv))
                                        (texture-depth (uv-depth uv)))
                                    (let ((width (- (uv-right uv) left))
                                          (height (- (uv-bottom uv) top)))
                                      (define (adjust-uv coord)
                                        (vertex (+ left (* (vertex-x coord) width))
                                                (+ top (* (vertex-y coord) height))
                                                texture-depth))
                                      
                                      (loop (for n from 0 below (vector-length indices) by 3)
                                            (add-triangle (vector-ref indices n)
                                                          (vector-ref indices (+ n 1))
                                                          (vector-ref indices (+ n 2))
                                                          matrix
                                                          adjust-uv)))))))))))))
            (let ((children (get-children~ node)))
              (when children
                (for-each add-node children))))
          
          (for-each add-node nodes)
          (values content neighbors)))))
  
  
  (method (extract-bounds)
    (let ((bounds #f))
      (define (process-node node)
        (unless (bone?~ node)
          (let ((parts (get-parts~ node)))
            (when parts
              (let ((matrix (transformation-matrix~ node)))
                (loop (for part in parts)
                      (receive (mesh mesh-part) (find-mesh-part (get-meshpartid~ part))
                        (let ((vertices (get-vertices~ mesh))
                              (indices (get-indices~ mesh-part)))
                          (loop (for index in-vector indices)
                                (let ((vertex (list-ref vertices index)))
                                  (let ((position (matrix-transform matrix (get-position~ vertex))))
                                    (let ((x (vertex-x position))
                                          (y (vertex-y position))
                                          (z (vertex-z position)))
                                      (if (not bounds)
                                          (set! bounds (cuboid x y z x y z))
                                        (when (< x (cuboid-left bounds))
                                          (cuboid-left-set! bounds x))
                                        (when (> x (cuboid-right bounds))
                                          (cuboid-right-set! bounds x))
                                        (when (< y (cuboid-bottom bounds))
                                          (cuboid-bottom-set! bounds y))
                                        (when (> y (cuboid-top bounds))
                                          (cuboid-top-set! bounds y))
                                        (when (< z (cuboid-back bounds))
                                          (cuboid-back-set! bounds z))
                                        (when (> z (cuboid-front bounds))
                                          (cuboid-front-set! bounds z)))))))))))))
          (let ((children (get-children~ node)))
            (when children
              (for-each process-node children)))))
      
      (for-each process-node nodes)
      bounds))
  
  
  (method (extract-animation name)
    (define (total-frames-heuristic)
      (let ((total-frames 0))
        (when animations
          (for-each (lambda (animation)
                      (for-each (lambda (bone)
                                  (let ((keyframes (get-keyframes~ bone)))
                                    (when (not-null? keyframes)
                                      (let ((last-frame (last keyframes)))
                                        (let ((time (fxceiling (get-keytime~ last-frame))))
                                          (when (> time total-frames)
                                            (set! total-frames time)))))))
                                (get-bones~ animation)))
                    animations))
        total-frames))
    
    (let ((animation-fps 1000.)
          (total-frames (total-frames-heuristic)))
      (let ((animation (new Animation name animation-fps total-frames (extract-bones))))
        (setup-bones~ animation)
        animation)))
  
  
  (method (extract-bones)
    (define (first-animation)
      (and animations (not-null? animations) (first animations)))
    
    (let ((animation (first-animation))
          (queue (new-queue)))
      (define (process-node parent-bone node)
        (let ((id (get-id~ node))
              (children (get-children~ node))
              (bone? (bone?~ node)))
          (when bone?
            (let ((translation (or (get-translation~ node) (vertex 0. 0. 0.)))
                  (rotation (or (get-rotation~ node) (quaternion 0. 0. 0. 1.)))
                  (scale (or (get-scale~ node) (vertex 1. 1. 1.))))
              (let ((scaled-translation (vertex/ translation scale)))
                (let ((translation-keys (extract-keys animation id get-translation~ (lambda (pos) (vertex- pos scaled-translation))))
                      (rotation-keys (extract-keys animation id get-rotation~ identity)))
                  (enqueue queue (new Bone 0 id parent-bone rotation scaled-translation rotation-keys translation-keys))))))
          (when children
            (let ((parent-bone (and bone? id)))
              (for-each (lambda (node)
                          (process-node parent-bone node))
                        children)))))
      
      (for-each (lambda (node)
                  (process-node #f node))
                nodes)
      (list->vector (queue-list queue))))
  
  
  (method (extract-keys animation bone-id key adjust)
    (let ((bone (find-bone~ animation bone-id)))
      (if (not bone)
          (vector)
        (list->vector (loop (for keyframe in (get-keyframes~ bone))
                            (for time = (get-keytime~ keyframe))
                            (for value = (key keyframe))
                            (if value
                                (collect (new KeyFrame time (adjust value)) into keys)
                              (return keys))
                            (finally keys)))))))


;;;
;;;; Import
;;;


(definition public (load-w3ds file (metadata: metadata #f))
  (let ((name (get-base~ file))
        (render (or (model-metadata-render metadata) '(transparent)))
        (mask (model-metadata-mask metadata)))
    (define (add-animations model)
      (let ((dir (get-parent~ file)))
        (iterate-directory~ dir
          (lambda (file)
            (when (extension=? (get-extension~ file) "w3ds")
              (let ((base (get-base~ file)))
                (unless (filename=? base name)
                  (assert (starts-with? base (concatenate name "_")))
                  (let ((name (subseq base (+ (cardinality name) 1) (cardinality base)))
                        (w3d (load-model file)))
                    (add-animation~ model name (extract-animation~ w3d name)))))))
          files?: #t
          directories?: #f)))
    
    ;; necessary as animations come from distinct files
    (define (validate-animations model)
      (unless (apply = (map (lambda (anim)
                              (vector-length (get-bones~ anim)))
                            (all-animations~ model)))
        (error "Inconsistant bones in model: {a}" name)))
    
    (let ((model (new Model name: name)))
      (set-metadata~ model metadata)
      (let ((w3d (load-model file)))
        (when (get-debug-w3d?)
          (set-native~ model w3d))
        ;; order is important as extract-atlas adjusts texture coordinates
        (let ((atlas (extract-atlas~ w3d file)))
          (when (get-debug-meshes?)
            (set-atlas~ model atlas))
          (let ((texture (get-texture~ atlas)))
            (define (extract-mesh w3d-mesh renderer)
              (let ((mesh (new Mesh material: (new Material atlas: atlas texture: texture renderer: renderer))))
                (receive (data neighbors) (extract-geometry~ w3d file atlas w3d-mesh)
                  (allocate-vertices~ mesh)
                  (set-data~ (get-vertices-buffer~ mesh) data 10)
                  (when (get-debug-meshes?)
                    (set-vertices-data~ mesh data))
                  (allocate-neighbors~ mesh)
                  (set-data~ (get-neighbors-buffer~ mesh) neighbors 6))
                mesh))
            
            (define (iterate-meshes proc)
              (let ((renderer (require-renderer 'transparent)))
                (loop (for mesh in (get-meshes~ w3d))
                      (proc mesh renderer))))
            
            (let ((queue (new-queue)))
              (iterate-meshes
                (lambda (mesh renderer)
                  (enqueue queue (extract-mesh mesh renderer))))
              (set-meshes~ model (list->vector (queue-list queue))))))
        (set-bounds~ model (extract-bounds~ w3d))
        (set-anchor~ model 'origin)
        (set-animation~ model (extract-animation~ w3d #f))
        (add-animations model)
        (validate-animations model))
      model)))


(definition (load-model file)
  (define (process w3ds)
    (let ((model (new W3D-Model))
          (meshes (getp w3ds "meshes"))
          (materials (getp w3ds "materials"))
          (nodes (getp w3ds "nodes"))
          (animations (getp w3ds "animations")))
      (set-meshes~ model (process-meshes meshes))
      (set-materials~ model (process-materials materials))
      (set-nodes~ model (process-nodes nodes))
      (set-animations~ model (process-animations animations))
      model))
  
  (define (process-meshes meshes)
    (define (process-vertices attributes vertices)
      (define (symbolize-attributes attributes)
        (loop (for attribute in-vector attributes)
              (collect (string->symbol attribute))))
      
      (let ((attributes (symbolize-attributes attributes))
            (count (vector-length vertices))
            (queue (new-queue)))
        (let (iter (scan 0))
          (if (>= scan count)
              (queue-list queue)
            (let ((vert (new W3D-Vertex)))
              (define (read-vertex)
                (prog1 (vertex (vector-ref vertices scan)
                               (vector-ref vertices (+ scan 1))
                               (vector-ref vertices (+ scan 2)))
                  (increase! scan 3)))
              
              (define (read-uv)
                (prog1 (vertex (vector-ref vertices scan)
                               (vector-ref vertices (+ scan 1))
                               0.)
                  (increase! scan 2)))
              
              (define (read-blendweight)
                (prog1 (f64vector (vector-ref vertices scan)
                                  (vector-ref vertices (+ scan 1)))
                  (increase! scan 2)))
              
              (for-each (lambda (attribute)
                          (case attribute
                            ((POSITION) (set-position~ vert (read-vertex)))
                            ((NORMAL) (set-normal~ vert (read-vertex)))
                            ((TEXCOORD0) (set-texcoord~ vert (read-uv)))
                            ((BLENDWEIGHT0) (set-blendweight0~ vert (read-blendweight)))
                            ((BLENDWEIGHT1) (set-blendweight1~ vert (read-blendweight)))
                            ((BLENDWEIGHT2) (set-blendweight2~ vert (read-blendweight)))
                            ((BLENDWEIGHT3) (set-blendweight3~ vert (read-blendweight)))))
                        attributes)
              (enqueue queue vert)
              (iter scan))))))
    
    (define (process-parts parts)
      (define (process-part part)
        (let ((id (getp part "id"))
              (type (getp part "type"))
              (indices (getp part "indices")))
          (assert (equal? type "TRIANGLES"))
          (new W3D-Mesh-Part id indices)))
      
      (loop (for part in-vector parts)
            (collect (process-part part))))
    
    (loop (for mesh in-vector meshes)
          (collect (let ((vertices (process-vertices (getp mesh "attributes") (getp mesh "vertices")))
                         (parts (process-parts (getp mesh "parts"))))
                     (new W3D-Mesh vertices parts)))))
  
  (define (process-materials materials)
    (define (process-material material)
      (define (process-textures textures)
        (when textures
          (loop (for texture in-vector textures)
                (collect (let ((id (getp texture "id"))
                               (filename (getp texture "filename"))
                               (type (getp texture "type")))
                           (new W3D-Texture id filename type))))))
      
      (let ((id (getp material "id"))
            (ambient (getp material "ambient"))
            (diffuse (getp material "diffuse"))
            (specular (getp material "specular"))
            (textures (process-textures (getp material "textures"))))
        (new W3D-Material id ambient diffuse specular textures)))
    
    (loop (for material in-vector materials)
          (collect (process-material material))))
  
  (define (process-nodes nodes)
    (define (process-node node)
      (define (process-parts parts)
        (when parts
          (loop (for part in-vector parts)
                (collect (let ((meshpartid (getp part "meshpartid"))
                               (materialid (getp part "materialid"))
                               (uvMapping (getp part "uvMapping")))
                           (new W3D-Node-Part meshpartid materialid uvMapping))))))
      
      (let ((id (getp node "id"))
            (translation (process-vertex (getp node "translation")))
            (rotation (process-quaternion (getp node "rotation")))
            (scale (process-vertex (getp node "scale")))
            (parts (process-parts (getp node "parts")))
            (children (getp node "children")))
        (new W3D-Node id translation rotation scale parts (and children (process-nodes children)))))
    
    (loop (for node in-vector nodes)
          (collect (process-node node))))
  
  (define (process-animations animations)
    (define (process-animation animation)
      (define (process-bones bones)
        (define (process-keyframes keyframes)
          (loop (for keyframe in-vector keyframes)
                (collect (let ((keytime (getp keyframe "keytime"))
                               (translation (process-vertex (getp keyframe "translation")))
                               (rotation (process-quaternion (getp keyframe "rotation")))
                               (scale (process-vertex (getp keyframe "scale"))))
                           (new W3D-KeyFrame keytime translation rotation scale)))))
        
        (loop (for bone in-vector bones)
              (collect (let ((boneid (getp bone "boneId"))
                             (keyframes (getp bone "keyframes")))
                         (new W3D-Bone-Animation boneid (process-keyframes keyframes))))))
      
      (let ((id (getp animation "id"))
            (bones (process-bones (getp animation "bones"))))
        (new W3D-Animation id bones)))
    
    (loop (for animation in-vector animations)
          (collect (process-animation animation))))
  
  (define (process-vertex vert)
    (and vert (vertex (vector-ref vert 0)
                      (vector-ref vert 1)
                      (vector-ref vert 2))))
  
  (define (process-quaternion quat)
    (and quat (quaternion (vector-ref quat 0)
                          (vector-ref quat 1)
                          (vector-ref quat 2)
                          (vector-ref quat 3))))
  
  (define (getp expr prop)
    (getf expr prop test: equal?))
  
  (let ((w3ds (call-with-input-file (path-settings file) read)))
    (process w3ds))))
