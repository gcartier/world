;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World 3D Format
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.w3d jazz


(import (jazz.io)
        (world.animation)
        (world.atlas)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.model)
        (world.renderers)
        (world.support)
        (world.texture))


(proclaim (warn optimizations))


;;;
;;;; Vertex
;;;


(class W3D-Vertex extends Object
  
  
  (slot position    <object>     initialize #f accessors generate)
  (slot normal      <object>     initialize #f accessors generate)
  (slot texcoord    <object>     initialize #f accessors generate)
  (slot blendweight <f64vector+> initialize #f accessors generate))


;;;
;;;; Node
;;;


(class W3D-Node extends Object
  
  
  (slot id          <object>    accessors generate)
  (slot parent      <W3D-Node+> accessors generate)
  (slot translation <object>    accessors generate)
  (slot rotation    <object>    accessors generate)
  (slot scale       <object>    accessors generate)
  (slot parts       <object>    accessors generate)
  (slot children    <object>    accessors generate)
  
  
  (method override (initialize id parent translation rotation scale parts)
    (set! id~self id)
    (set! parent~self parent)
    (set! translation~self translation)
    (set! rotation~self rotation)
    (set! scale~self scale)
    (set! parts~self parts))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id))))
  
  
  (method (transformation-matrix)
    (let ((scaled-translation (and translation (if scale (vertex/ translation scale) translation))))
      (let ((translation (if scaled-translation (make-translation-matrix& scaled-translation) (make-identity-matrix&)))
            (rotation (if rotation (make-quaternion-matrix& rotation) (make-identity-matrix&))))
        (matrix-multiply translation rotation)))))


;;;
;;;; Node-Part
;;;


(class W3D-Node-Part extends Object
  
  
  (slot meshpartid <object> accessors generate)
  (slot materialid <object> accessors generate)
  (slot bones      <object> accessors generate)
  (slot uvMapping  <object> accessors generate)
  
  
  (method override (initialize meshpartid materialid bones uvMapping)
    (set! meshpartid~self meshpartid)
    (set! materialid~self materialid)
    (set! bones~self bones)
    (set! uvMapping~self uvMapping)))


;;;
;;;; Node-Part-Bone
;;;


(class W3D-Node-Part-Bone extends Object
  
  
  (slot node        <object> accessors generate)
  (slot translation <object> accessors generate)
  (slot rotation    <object> accessors generate)
  (slot scale       <object> accessors generate)
  
  
  (method override (initialize node translation rotation scale)
    (set! node~self node)
    (set! translation~self translation)
    (set! rotation~self rotation)
    (set! scale~self scale))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" node)))))


;;;
;;;; Material
;;;


(class W3D-Material extends Object
  
  
  (slot id       <object> accessors generate)
  (slot ambient  <object> accessors generate)
  (slot diffuse  <object> accessors generate)
  (slot specular <object> accessors generate)
  (slot textures <object> accessors generate)
  
  
  (method override (initialize id ambient diffuse specular textures)
    (set! id~self id)
    (set! ambient~self ambient)
    (set! diffuse~self diffuse)
    (set! specular~self specular)
    (set! textures~self textures))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id)))))


;;;
;;;; Texture
;;;


(class W3D-Texture extends Object
  
  
  (slot id       <object> accessors generate)
  (slot filename <object> accessors generate)
  (slot type     <object> accessors generate)
  
  
  (method override (initialize id filename type)
    (set! id~self id)
    (set! filename~self filename)
    (set! type~self type))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id)))))


;;;
;;;; Mesh-Part
;;;


(class W3D-Mesh-Part extends Object
  
  
  (slot id      <object> accessors generate)
  (slot indices <vector> accessors generate)
  
  
  (method override (initialize id indices)
    (set! id~self id)
    (set! indices~self indices))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id)))))


;;;
;;;; Mesh
;;;


(class W3D-Mesh extends Object
  
  
  (slot vertices   <object> accessors generate)
  (slot parts      <object> accessors generate)
  
  
  (method override (initialize vertices parts)
    (set! vertices~self vertices)
    (set! parts~self parts))
  
  
  (method (find-part part-id) <W3D-Mesh-Part+>
    (find-if (lambda (part <W3D-Mesh-Part>)
               (equal? (get-id~ part) part-id))
             parts)))


;;;
;;;; Bone-Animation
;;;


(class W3D-Bone-Animation extends Object
  
  
  (slot boneid    <object> accessors generate)
  (slot keyframes <object> accessors generate)
  
  
  (method override (initialize boneid keyframes)
    (set! boneid~self boneid)
    (set! keyframes~self keyframes))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" boneid)))))


;;;
;;;; Animation
;;;


(class W3D-Animation extends Object
  
  
  (slot id    <object> accessors generate)
  (slot bones <object> accessors generate)
  
  
  (method override (initialize id bones)
    (set! id~self id)
    (set! bones~self bones))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id))))
  
  
  (method (find-bone bone-id) <W3D-Bone-Animation+>
    (find-if (lambda (bone <W3D-Bone-Animation>)
               (equal? bone-id (get-boneid~ bone)))
             bones)))


;;;
;;;; KeyFrame
;;;


(class W3D-KeyFrame extends Object
  
  
  (slot keytime     <object> accessors generate)
  (slot translation <object> accessors generate)
  (slot rotation    <object> accessors generate)
  (slot scale       <object> accessors generate)
  
  
  (method override (initialize keytime translation rotation scale)
    (set! keytime~self keytime)
    (set! translation~self translation)
    (set! rotation~self rotation)
    (set! scale~self scale))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" keytime)))))


;;;
;;;; Model
;;;


(class W3D-Model extends Object
  
  
  (slot meshes     <object> accessors generate)
  (slot materials  <object> accessors generate)
  (slot nodes      <object> accessors generate)
  (slot animations <list+>  accessors generate)
  
  
  (slot nodes-table <table> initialize (make-table test: equal?))
  (slot bones-table <table> initialize (make-table test: equal?))
  (slot bones-index <fx>    initialize 0)
  
  
  (method override (initialize meshes materials nodes animations)
    (set! meshes~self meshes)
    (set! materials~self materials)
    (set! nodes~self nodes)
    (set! animations~self animations)
    (setup-tables))
  
  
  (method (setup-tables)
    (define (process-node node <W3D-Node>)
      (let ((id (get-id~ node)))
        (if (table-ref nodes-table id #f)
            (table-set! nodes-table id #t)
          (table-set! nodes-table id node)))
      (let ((children (get-children~ node)))
        (when children
          (for-each process-node children))))
    
    (for-each process-node nodes))
  
  
  (method (find-node id)
    (let ((value (table-ref nodes-table id #f)))
      (cond ((not value)
             (error "Unable to find node id: {a}" id))
            ((eq? value #t)
             (error "Duplicate node id: {a}" id))
            (else
             value))))
  
  
  (method (find-mesh-part part-id)
    (continuation-capture
      (lambda (return)
        (for-each (lambda (mesh <W3D-Mesh>)
                    (for-each (lambda (part <W3D-Mesh-Part>)
                                (when (equal? (get-id~ part) part-id)
                                  (continuation-return return (values mesh part))))
                              (get-parts~ mesh)))
                  meshes)
        (values #f #f))))
  
  
  (method (find-material material-id) <W3D-Material>
    (or (find-if (lambda (material <W3D-Material>)
                   (equal? (get-id~ material) material-id))
                 materials)
        (error "Unable to find material: {s}" material-id)))
  
  
  (method (extract-atlas file <File>)
    (let ((dir <Directory> (get-parent~ file)))
      (define (lookup-file filename)
        (continuation-capture
          (lambda (return)
            (iterate-directory~ dir
              (lambda (file <File>)
                (when (filename=? (get-name~ file) filename)
                  (continuation-return return file))))
            (error "Unable to find FBX file: {a}" filename))))
      
      (let ((atlas (new Atlas repeat?: #t pad?: #f)))
        (for-each (lambda (material <W3D-Material>)
                    (let ((textures (get-textures~ material)))
                      (when textures
                        (for-each (lambda (texture <W3D-Texture>)
                                    (let ((filename (get-filename~ texture)))
                                      (add-file~ atlas (lookup-file filename))))
                                  textures))))
                  materials)
        (let ((texture (extract-texture~ atlas mipmap?: #f)))
          (complete~ atlas)
          (values atlas texture)))))
  
  
  (method (extract-geometry file <File> atlas <Atlas> mesh <W3D-Mesh> material <Material>)
    (define (count-triangles) <fx>
      (let ((count 0))
        (loop (for part <W3D-Mesh-Part> in (get-parts~ mesh))
              (let ((indices (get-indices~ part)))
                (increase! count (cast <fx> (/ (vector-length indices) 3)))))
        count))
    
    (let ((mesher (new Mesher (count-triangles) 0 material: material))
          (vertices (get-vertices~ mesh)))
      (define (vertex-ref index <fx>) <W3D-Vertex>
        (list-ref vertices index))
      
      (define (vertex-bone v <W3D-Vertex>)
        (let ((b (get-blendweight~ v)))
          (if (not b)
              0.
            (f64vector-ref b 0))))
      
      (define (add-triangle n1 n2 n3 matrix adjust-uv bone-ids)
        (define (transform vert)
          (matrix-transform matrix vert))
        
        (define (bone-index vert)
          (if (not bone-ids)
              0
            (cast <fx> (list-ref bone-ids (fxround (vertex-bone vert))))))
        
        (let ((v1 (vertex-ref n1))
              (v2 (vertex-ref n2))
              (v3 (vertex-ref n3)))
          (let ((t1 (adjust-uv (get-texcoord~ v1)))
                (t2 (adjust-uv (get-texcoord~ v2)))
                (t3 (adjust-uv (get-texcoord~ v3))))
            (let ((uv (f32vector (vertex-x t1) (vertex-y t1) (vertex-x t2) (vertex-y t2) (vertex-x t3) (vertex-y t3))))
              (add-triangle~ mesher
                (transform (get-position~ v1)) (get-normal~ v1) 0 1 (bone-index v1)
                (transform (get-position~ v2)) (get-normal~ v2) 2 3 (bone-index v2)
                (transform (get-position~ v3)) (get-normal~ v3) 4 5 (bone-index v3)
                uv
                (vertex-z t1))))))
      
      (define (add-node node <W3D-Node>)
        (let ((parts (get-parts~ node)))
          (when parts
            (let ((matrix (transformation-matrix~ node)))
              (loop (for part <W3D-Node-Part> in parts)
                    (let ((meshpartid (get-meshpartid~ part))
                          (materialid (get-materialid~ part))
                          (bones (get-bones~ part)))
                      (let ((mesh-part (find-part~ mesh meshpartid)))
                        ;; for now it is possible to find no part since we
                        ;; are traversing all nodes for a single target mesh
                        (when mesh-part
                          (let ((material (find-material materialid)))
                            (let ((indices (get-indices~ mesh-part))
                                  (image (extract-base (get-filename~ (cast <W3D-Texture> (car (get-textures~ material)))))))
                              (let ((uv (image-rect~ atlas image)))
                                (let ((left (uv-left uv))
                                      (top (uv-top uv))
                                      (texture-depth (uv-depth uv)))
                                  (let ((width (- (uv-right uv) left))
                                        (height (- (uv-bottom uv) top)))
                                    (define (adjust-uv coord)
                                      (vertex (+ left (* (vertex-x coord) width))
                                              (+ top (* (- 1. (vertex-y coord)) height))
                                              texture-depth))
                                    
                                    (loop (for n from 0 below (vector-length indices) by 3)
                                          (add-triangle (vector-ref indices n)
                                                        (vector-ref indices (+ n 1))
                                                        (vector-ref indices (+ n 2))
                                                        matrix
                                                        adjust-uv
                                                        (and bones (register-bones bones))))))))))))))))
        (let ((children (get-children~ node)))
          (when children
            (for-each add-node children))))
      
      (for-each add-node nodes)
      (get-mesh~ mesher)))
  
  
  (method (extract-bounds)
    (let ((bounds #f))
      (define (process-node node <W3D-Node>)
        (let ((parts (get-parts~ node)))
          (when parts
            (let ((matrix (transformation-matrix~ node)))
              (loop (for part <W3D-Node-Part> in parts)
                    (receive (mesh <W3D-Mesh> mesh-part <W3D-Mesh-Part>) (find-mesh-part (get-meshpartid~ part))
                      (let ((vertices (get-vertices~ mesh))
                            (indices (get-indices~ mesh-part)))
                        (loop (for index in-vector indices)
                              (let ((vertex <W3D-Vertex> (list-ref vertices index)))
                                (let ((position (matrix-transform matrix (get-position~ vertex))))
                                  (let ((x (vertex-x position))
                                        (y (vertex-y position))
                                        (z (vertex-z position)))
                                    (if (not bounds)
                                        (set! bounds (cuboid x y z x y z))
                                      (when (< x (cuboid-left bounds))
                                        (cuboid-left-set! bounds x))
                                      (when (> x (cuboid-right bounds))
                                        (cuboid-right-set! bounds x))
                                      (when (< y (cuboid-bottom bounds))
                                        (cuboid-bottom-set! bounds y))
                                      (when (> y (cuboid-top bounds))
                                        (cuboid-top-set! bounds y))
                                      (when (< z (cuboid-back bounds))
                                        (cuboid-back-set! bounds z))
                                      (when (> z (cuboid-front bounds))
                                        (cuboid-front-set! bounds z)))))))))))))
        (let ((children (get-children~ node)))
          (when children
            (for-each process-node children))))
      
      (for-each process-node nodes)
      bounds))
  
  
  (method (extract-animation name) <Animation>
    (define (total-frames-heuristic)
      (let ((total-frames 0))
        (when animations
          (for-each (lambda (animation <W3D-Animation>)
                      (for-each (lambda (bone <W3D-Bone-Animation>)
                                  (let ((keyframes (get-keyframes~ bone)))
                                    (when (not-null? keyframes)
                                      (let ((last-frame <W3D-KeyFrame> (last keyframes)))
                                        (let ((time (fxceiling (get-keytime~ last-frame))))
                                          (when (> time total-frames)
                                            (set! total-frames time)))))))
                                (get-bones~ animation)))
                    animations))
        total-frames))
    
    (let ((animation-fps 1000.)
          (total-frames (total-frames-heuristic)))
      (let ((animation (new Animation name animation-fps total-frames (extract-bones))))
        (setup-bones~ animation)
        animation)))
  
  
  (method (extract-bones)
    (list->vector (sort < (table-values bones-table) key: get-index~)))
  
  
  (method (register-bones bones)
    (map (lambda (bone <W3D-Node-Part-Bone>)
           (let ((node (find-node (get-node~ bone))))
             (register-bone-node node)))
         bones))
  
  
  (method (register-bone-node node <W3D-Node>)
    (let ((id (get-id~ node)))
      (let ((actual <Bone+> (table-ref bones-table id #f)))
        (if actual
            (get-index~ actual)
          (let ((parent (get-parent~ node)))
            (when parent
              (register-bone-node parent))
            (let ((animation (first-animation)))
              (allege animation
                (let ((boneanim (find-bone~ animation id)))
                  (let ((translation (or (get-translation~ node) (vertex 0. 0. 0.)))
                        (rotation (or (get-rotation~ node) (quaternion 0. 0. 0. 1.)))
                        (scale (or (get-scale~ node) (vertex 1. 1. 1.))))
                    (let ((index bones-index)
                          (parent-id (and parent (get-id~ parent)))
                          (scaled-translation (vertex/ translation scale))
                          (inverse-rotation (quaternion-inverse rotation)))
                      (let ((translation-keys (extract-keys animation id get-translation~ (lambda (pos) (vertex- pos scaled-translation))))
                            (rotation-keys (extract-keys animation id get-rotation~ (lambda (rot) (quaternion-product rot inverse-rotation)))))
                        (increase! bones-index)
                        (let ((bone (new Bone 0 id index parent-id rotation scaled-translation rotation-keys translation-keys)))
                          (table-set! bones-table id bone))
                        index)))))))))))
  
  
  (method (first-animation) <W3D-Animation+>
    (and animations (not-null? animations) (first animations)))
  
  
  (method (extract-keys animation <W3D-Animation> bone-id key adjust)
    (let ((bone (find-bone~ animation bone-id)))
      (if (not bone)
          (vector)
        (list->vector (loop (for keyframe <W3D-KeyFrame> in (get-keyframes~ bone))
                            (for time = (get-keytime~ keyframe))
                            (for value = (key keyframe))
                            (if value
                                (collect (new KeyFrame time (adjust value)) into keys)
                              (return keys))
                            (finally keys)))))))


;;;
;;;; Import
;;;


(definition public (load-w3ds file <File> (metadata: metadata #f)) <Model>
  (let ((name (get-base~ file))
        (render (or (model-metadata-render metadata) '(transparent)))
        (mask (model-metadata-mask metadata)))
    (define (add-animations model <Model>)
      (let ((dir <Directory> (get-parent~ file)))
        (iterate-directory~ dir
          (lambda (file <File>)
            (when (extension=? (get-extension~ file) "w3ds")
              (let ((base (get-base~ file)))
                (unless (filename=? base name)
                  (assert (starts-with? base (concatenate name "_")))
                  (let ((name (subseq base (+ (cardinality name) 1) (cardinality base)))
                        (w3d (load-model file)))
                    (add-animation~ model name (extract-animation~ w3d name)))))))
          files?: #t
          directories?: #f)))
    
    ;; necessary as animations come from distinct files
    (define (validate-animations model <Model>)
      (unless (apply = (map (lambda (anim <Animation>)
                              (vector-length (get-bones~ anim)))
                            (all-animations~ model)))
        (error "Inconsistant bones in model: {a}" name)))
    
    (let ((model (new Model name: name scale: (vertex .1 .1 .1))))
      (install-metadata~ model metadata)
      (let ((w3d (load-model file)))
        (when (get-debug-w3d?)
          (set-native~ model w3d))
        ;; order is important as extract-atlas adjusts texture coordinates
        (receive (atlas texture) (extract-atlas~ w3d file)
          (define (extract-mesh w3d-mesh renderer)
            (let ((material (new Material atlas: atlas texture: texture renderer: renderer)))
              (extract-geometry~ w3d file atlas w3d-mesh material)))
          
          (define (iterate-meshes proc)
            (let ((renderer (require-renderer 'transparent)))
              (loop (for mesh in (get-meshes~ w3d))
                    (proc mesh renderer))))
          
          (when (get-debug-meshes?)
            (set-atlas~ model atlas))
          (let ((queue (new-queue)))
            (iterate-meshes
              (lambda (mesh renderer)
                (enqueue queue (extract-mesh mesh renderer))))
            (set-meshes~ model (list->vector (queue-list queue)))))
        (set-bounds~ model (extract-bounds~ w3d))
        (set-anchor~ model 'origin)
        (set-animation~ model (extract-animation~ w3d "Idle"))
        (add-animations model)
        (validate-animations model))
      model)))


(definition (load-model file <File>) <W3D-Model>
  (define (process-model w3ds)
    (let ((meshes (process-meshes (getp w3ds "meshes")))
          (materials (process-materials (getp w3ds "materials")))
          (nodes (process-nodes #f (getp w3ds "nodes")))
          (animations (process-animations (getp w3ds "animations"))))
      (new W3D-Model meshes materials nodes animations)))
  
  (define (process-meshes meshes)
    (define (process-vertices attributes <vector> vertices <vector>)
      (define (symbolize-attributes attributes)
        (loop (for attribute in-vector attributes)
              (collect (string->symbol attribute))))
      
      (let ((attributes (symbolize-attributes attributes))
            (count (vector-length vertices))
            (queue (new-queue)))
        (let (iter (scan 0))
          (if (>= scan count)
              (queue-list queue)
            (let ((vert (new W3D-Vertex)))
              (define (read-vertex)
                (prog1 (vertex (vector-ref vertices scan)
                               (vector-ref vertices (+ scan 1))
                               (vector-ref vertices (+ scan 2)))
                  (increase! scan 3)))
              
              (define (read-uv)
                (prog1 (vertex (vector-ref vertices scan)
                               (vector-ref vertices (+ scan 1))
                               0.)
                  (increase! scan 2)))
              
              (define (read-blendweight)
                (prog1 (vertex (vector-ref vertices scan)
                               (vector-ref vertices (+ scan 1))
                               0.)
                  (increase! scan 2)))
              
              (for-each (lambda (attribute)
                          (case attribute
                            ((POSITION) (set-position~ vert (read-vertex)))
                            ((NORMAL) (set-normal~ vert (read-vertex)))
                            ((COLOR) (increase! scan 4))
                            ((TEXCOORD0) (set-texcoord~ vert (read-uv)))
                            ((TEXCOORD1) (increase! scan 2))
                            ((TEXCOORD2) (increase! scan 2))
                            ((TEXCOORD3) (increase! scan 2))
                            ((TEXCOORD4) (increase! scan 2))
                            ((TEXCOORD5) (increase! scan 2))
                            ((TEXCOORD6) (increase! scan 2))
                            ((TEXCOORD7) (increase! scan 2))
                            ((BLENDWEIGHT0) (set-blendweight~ vert (read-blendweight)))
                            ((BLENDWEIGHT1) (increase! scan 2))
                            ((BLENDWEIGHT2) (increase! scan 2))
                            ((BLENDWEIGHT3) (increase! scan 2))
                            ((BLENDWEIGHT4) (increase! scan 2))
                            ((BLENDWEIGHT5) (increase! scan 2))
                            ((BLENDWEIGHT6) (increase! scan 2))
                            ((BLENDWEIGHT7) (increase! scan 2))))
                        attributes)
              (enqueue queue vert)
              (iter scan))))))
    
    (define (process-parts parts)
      (define (process-part part)
        (let ((id (getp part "id"))
              (type (getp part "type"))
              (indices (getp part "indices")))
          (assert (equal? type "TRIANGLES"))
          (new W3D-Mesh-Part id indices)))
      
      (loop (for part in-vector parts)
            (collect (process-part part))))
    
    (loop (for mesh in-vector meshes)
          (collect (let ((vertices (process-vertices (getp mesh "attributes") (getp mesh "vertices")))
                         (parts (process-parts (getp mesh "parts"))))
                     (new W3D-Mesh vertices parts)))))
  
  (define (process-materials materials)
    (define (process-material material)
      (define (process-textures textures)
        (when textures
          (loop (for texture in-vector textures)
                (collect (let ((id (getp texture "id"))
                               (filename (getp texture "filename"))
                               (type (getp texture "type")))
                           (new W3D-Texture id filename type))))))
      
      (let ((id (getp material "id"))
            (ambient (getp material "ambient"))
            (diffuse (getp material "diffuse"))
            (specular (getp material "specular"))
            (textures (process-textures (getp material "textures"))))
        (new W3D-Material id ambient diffuse specular textures)))
    
    (loop (for material in-vector materials)
          (collect (process-material material))))
  
  (define (process-nodes parent nodes)
    (define (process-node node)
      (define (process-parts parts)
        (define (process-bones bones)
          (when bones
            (loop (for bone in-vector bones)
                  (collect (let ((node (getp bone "node"))
                                 (translation (process-vertex (getp bone "translation")))
                                 (rotation (process-quaternion (getp bone "rotation")))
                                 (scale (process-vertex (getp bone "scale"))))
                             (new W3D-Node-Part-Bone node translation rotation scale))))))
        
        (when parts
          (loop (for part in-vector parts)
                (collect (let ((meshpartid (getp part "meshpartid"))
                               (materialid (getp part "materialid"))
                               (bones (process-bones (getp part "bones")))
                               (uvMapping (getp part "uvMapping")))
                           (new W3D-Node-Part meshpartid materialid bones uvMapping))))))
      
      (let ((id (getp node "id"))
            (translation (process-vertex (getp node "translation")))
            (rotation (process-quaternion (getp node "rotation")))
            (scale (process-vertex (getp node "scale")))
            (parts (process-parts (getp node "parts")))
            (children (getp node "children")))
        (let ((node (new W3D-Node id parent translation rotation scale parts)))
          (set-children~ node (and children (process-nodes node children)))
          node)))
    
    (loop (for node in-vector nodes)
          (collect (process-node node))))
  
  (define (process-animations animations)
    (define (process-animation animation)
      (define (process-bones bones)
        (define (process-keyframes keyframes)
          (loop (for keyframe in-vector keyframes)
                (collect (let ((keytime (getp keyframe "keytime"))
                               (translation (process-vertex (getp keyframe "translation")))
                               (rotation (process-quaternion (getp keyframe "rotation")))
                               (scale (process-vertex (getp keyframe "scale"))))
                           (new W3D-KeyFrame keytime translation rotation scale)))))
        
        (loop (for bone in-vector bones)
              (collect (let ((boneid (getp bone "boneId"))
                             (keyframes (getp bone "keyframes")))
                         (new W3D-Bone-Animation boneid (process-keyframes keyframes))))))
      
      (let ((id (getp animation "id"))
            (bones (process-bones (getp animation "bones"))))
        (new W3D-Animation id bones)))
    
    (loop (for animation in-vector animations)
          (collect (process-animation animation))))
  
  (define (process-vertex vert <vector+>)
    (and vert (vertex (vector-ref vert 0)
                      (vector-ref vert 1)
                      (vector-ref vert 2))))
  
  (define (process-quaternion quat <vector+>)
    (and quat (quaternion (vector-ref quat 0)
                          (vector-ref quat 1)
                          (vector-ref quat 2)
                          (vector-ref quat 3))))
  
  (define (getp expr prop)
    (getf expr prop test: equal?))
  
  (let ((w3ds (call-with-input-file (path-settings file) read)))
    (process-model w3ds))))
