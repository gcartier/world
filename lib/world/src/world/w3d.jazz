;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World 3D Format
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.w3d jazz


(import (jazz.io)
        (world)
        (world.animation)
        (world.atlas)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.model)
        (world.renderers)
        (world.support)
        (world.texture))


(proclaim (warn optimizations))


;;;
;;;; Vertex
;;;


(class W3D-Vertex extends Object
  
  
  (slot position    <object>     initialize #f accessors generate)
  (slot normal      <object>     initialize #f accessors generate)
  (slot texcoord    <object>     initialize #f accessors generate)
  (slot blendweight <f64vector+> initialize #f accessors generate))


;;;
;;;; Node
;;;


(class W3D-Node extends Object
  
  
  (slot id          <object>    accessors generate)
  (slot parent      <W3D-Node+> accessors generate)
  (slot translation <object>    accessors generate)
  (slot rotation    <object>    accessors generate)
  (slot scale       <object>    accessors generate)
  (slot parts       <object>    accessors generate)
  (slot children    <object>    accessors generate)
  
  
  (method override (initialize self id parent translation rotation scale parts)
    (set! self.id id)
    (set! self.parent parent)
    (set! self.translation translation)
    (set! self.rotation rotation)
    (set! self.scale scale)
    (set! self.parts parts))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id))))
  
  
  (method package (transformation-matrix self)
    (let ((scaled-translation (and translation (if scale (vertex/ translation scale) translation))))
      (let ((translation (if scaled-translation (make-translation-matrix& scaled-translation) (make-identity-matrix&)))
            (rotation (if rotation (make-quaternion-matrix& rotation) (make-identity-matrix&))))
        (matrix-multiply translation rotation)))))


;;;
;;;; Node-Part
;;;


(class W3D-Node-Part extends Object
  
  
  (slot meshpartid <object> accessors generate)
  (slot materialid <object> accessors generate)
  (slot bones      <object> accessors generate)
  (slot uvMapping  <object> accessors generate)
  
  
  (method override (initialize self meshpartid materialid bones uvMapping)
    (set! self.meshpartid meshpartid)
    (set! self.materialid materialid)
    (set! self.bones bones)
    (set! self.uvMapping uvMapping)))


;;;
;;;; Node-Part-Bone
;;;


(class W3D-Node-Part-Bone extends Object
  
  
  (slot node        <object> accessors generate)
  (slot translation <object> accessors generate)
  (slot rotation    <object> accessors generate)
  (slot scale       <object> accessors generate)
  
  
  (method override (initialize self node translation rotation scale)
    (set! self.node node)
    (set! self.translation translation)
    (set! self.rotation rotation)
    (set! self.scale scale))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" node)))))


;;;
;;;; Material
;;;


(class W3D-Material extends Object
  
  
  (slot id       <object> accessors generate)
  (slot ambient  <object> accessors generate)
  (slot diffuse  <object> accessors generate)
  (slot specular <object> accessors generate)
  (slot textures <object> accessors generate)
  
  
  (method override (initialize self id ambient diffuse specular textures)
    (set! self.id id)
    (set! self.ambient ambient)
    (set! self.diffuse diffuse)
    (set! self.specular specular)
    (set! self.textures textures))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id)))))


;;;
;;;; Texture
;;;


(class W3D-Texture extends Object
  
  
  (slot id       <object> accessors generate)
  (slot filename <object> accessors generate)
  (slot type     <object> accessors generate)
  
  
  (method override (initialize self id filename type)
    (set! self.id id)
    (set! self.filename filename)
    (set! self.type type))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id)))))


;;;
;;;; Mesh-Part
;;;


(class W3D-Mesh-Part extends Object
  
  
  (slot id      <object> accessors generate)
  (slot indices <vector> accessors generate)
  
  
  (method override (initialize self id indices)
    (set! self.id id)
    (set! self.indices indices))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id)))))


;;;
;;;; Mesh
;;;


(class W3D-Mesh extends Object
  
  
  (slot vertices   <object> accessors generate)
  (slot parts      <object> accessors generate)
  
  
  (method override (initialize self vertices parts)
    (set! self.vertices vertices)
    (set! self.parts parts))
  
  
  (method package (find-part self part-id) <W3D-Mesh-Part+>
    (find-if (lambda (part <W3D-Mesh-Part>)
               (equal? (get-id part) part-id))
             parts)))


;;;
;;;; Bone-Animation
;;;


(class W3D-Bone-Animation extends Object
  
  
  (slot boneid    <object> accessors generate)
  (slot keyframes <object> accessors generate)
  
  
  (method override (initialize self boneid keyframes)
    (set! self.boneid boneid)
    (set! self.keyframes keyframes))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" boneid)))))


;;;
;;;; Animation
;;;


(class W3D-Animation extends Object
  
  
  (slot id    <object> accessors generate)
  (slot bones <object> accessors generate)
  
  
  (method override (initialize self id bones)
    (set! self.id id)
    (set! self.bones bones))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id))))
  
  
  (method package (find-bone self bone-id) <W3D-Bone-Animation+>
    (find-if (lambda (bone <W3D-Bone-Animation>)
               (equal? bone-id (get-boneid bone)))
             bones)))


;;;
;;;; KeyFrame
;;;


(class W3D-KeyFrame extends Object
  
  
  (slot keytime     <object> accessors generate)
  (slot translation <object> accessors generate)
  (slot rotation    <object> accessors generate)
  (slot scale       <object> accessors generate)
  
  
  (method override (initialize self keytime translation rotation scale)
    (set! self.keytime keytime)
    (set! self.translation translation)
    (set! self.rotation rotation)
    (set! self.scale scale))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" keytime)))))


;;;
;;;; Model
;;;


(class W3D-Model extends Object
  
  
  (slot meshes     <object> accessors generate)
  (slot materials  <object> accessors generate)
  (slot nodes      <object> accessors generate)
  (slot animations <list+>  accessors generate)
  
  
  (slot nodes-table <table> initialize (make-table test: equal?))
  (slot bones-table <table> initialize (make-table test: equal?))
  (slot bones-index <fx>    initialize 0)
  
  
  (method override (initialize self meshes materials nodes animations)
    (set! self.meshes meshes)
    (set! self.materials materials)
    (set! self.nodes nodes)
    (set! self.animations animations)
    (setup-tables self))
  
  
  (method (setup-tables self)
    (define (process-node node <W3D-Node>)
      (let ((id (get-id node)))
        (if (table-ref nodes-table id #f)
            (table-set! nodes-table id #t)
          (table-set! nodes-table id node)))
      (let ((children (get-children node)))
        (when children
          (for-each process-node children))))
    
    (for-each process-node nodes))
  
  
  (method package (find-node self id)
    (let ((value (table-ref nodes-table id #f)))
      (cond ((not value)
             (error "Unable to find node id: {a}" id))
            ((eq? value #t)
             (error "Duplicate node id: {a}" id))
            (else
             value))))
  
  
  (method (find-mesh-part self part-id)
    (continuation-capture
      (lambda (return)
        (for-each (lambda (mesh <W3D-Mesh>)
                    (for-each (lambda (part <W3D-Mesh-Part>)
                                (when (equal? (get-id part) part-id)
                                  (continuation-return return (values mesh part))))
                              (get-parts mesh)))
                  meshes)
        (values #f #f))))
  
  
  (method (find-material self material-id) <W3D-Material>
    (or (find-if (lambda (material <W3D-Material>)
                   (equal? (get-id material) material-id))
                 materials)
        (error "Unable to find material: {s}" material-id)))
  
  
  (method package (extract-atlas self file <File>)
    (let ((dir <Directory> (get-parent file)))
      (define (lookup-file filename)
        (continuation-capture
          (lambda (return)
            (iterate-directory dir
              (lambda (file <File>)
                (when (filename=? (get-name file) filename)
                  (continuation-return return file))))
            (error "Unable to find FBX file: {a}" filename))))
      
      (let ((atlas (new Atlas repeat?: #t pad?: #f)))
        (for-each (lambda (material <W3D-Material>)
                    (let ((textures (get-textures material)))
                      (when textures
                        (for-each (lambda (texture <W3D-Texture>)
                                    (let ((filename (get-filename texture)))
                                      (add-file atlas (lookup-file filename))))
                                  textures))))
                  materials)
        (let ((texture (extract-texture atlas mipmap?: #f)))
          (complete atlas)
          (values atlas texture)))))
  
  
  (method package (extract-geometry self file <File> atlas <Atlas> mesh <W3D-Mesh> material <Material>)
    (define (count-triangles) <fx>
      (let ((count 0))
        (loop (for part <W3D-Mesh-Part> in (get-parts mesh))
              (let ((indices (get-indices part)))
                (increase! count (cast <fx> (/ (vector-length indices) 3)))))
        count))
    
    (let ((mesher (new Mesher (count-triangles) 0 material: material))
          (vertices (get-vertices mesh)))
      (define (vertex-ref index) <W3D-Vertex>
        (list-ref vertices index))
      
      (define (vertex-bone v)
        (let ((b (get-blendweight v)))
          (if (not b)
              0.
            (f64vector-ref b 0))))
      
      (define (add-w3d-triangle n1 n2 n3 matrix adjust-uv bone-ids)
        (define (transform vert)
          (matrix-transform matrix vert))
        
        (define (bone-index vert)
          (if (not bone-ids)
              0
            (cast <fx> (list-ref bone-ids (fxround (vertex-bone vert))))))
        
        (let ((v1 (vertex-ref n1))
              (v2 (vertex-ref n2))
              (v3 (vertex-ref n3)))
          (let ((t1 (adjust-uv (get-texcoord v1)))
                (t2 (adjust-uv (get-texcoord v2)))
                (t3 (adjust-uv (get-texcoord v3))))
            (let ((uv (f32vector (vertex-x t1) (vertex-y t1) (vertex-x t2) (vertex-y t2) (vertex-x t3) (vertex-y t3))))
              (add-triangle mesher
                (transform (get-position v1)) (get-normal v1) 0 1 (bone-index v1)
                (transform (get-position v2)) (get-normal v2) 2 3 (bone-index v2)
                (transform (get-position v3)) (get-normal v3) 4 5 (bone-index v3)
                uv
                (vertex-z t1))))))
      
      (define (add-node node <W3D-Node>)
        (let ((parts (get-parts node)))
          (when parts
            (let ((matrix (transformation-matrix node)))
              (loop (for part <W3D-Node-Part> in parts)
                    (let ((meshpartid (get-meshpartid part))
                          (materialid (get-materialid part))
                          (bones (get-bones part)))
                      (let ((mesh-part (find-part mesh meshpartid)))
                        ;; for now it is possible to find no part since we
                        ;; are traversing all nodes for a single target mesh
                        (when mesh-part
                          (let ((material (find-material self materialid)))
                            (let ((indices (get-indices mesh-part))
                                  (image (filename-base (get-filename (cast <W3D-Texture> (car (get-textures material)))))))
                              (let ((uv (image-rect atlas image)))
                                (let ((left (uv-left uv))
                                      (top (uv-top uv))
                                      (texture-depth (uv-depth uv)))
                                  (let ((width (- (uv-right uv) left))
                                        (height (- (uv-bottom uv) top)))
                                    (define (adjust-uv coord)
                                      (vertex (+ left (* (vertex-x coord) width))
                                              (+ top (* (- 1. (vertex-y coord)) height))
                                              texture-depth))
                                    
                                    (loop (for n from 0 below (vector-length indices) by 3)
                                          (add-w3d-triangle (vector-ref indices n)
                                                            (vector-ref indices (+ n 1))
                                                            (vector-ref indices (+ n 2))
                                                            matrix
                                                            adjust-uv
                                                            (and bones (register-bones self bones))))))))))))))))
        (let ((children (get-children node)))
          (when children
            (for-each add-node children))))
      
      (for-each add-node nodes)
      (get-mesh mesher debuggable-mesh?: #t)))
  
  
  (method package (extract-bounds self)
    (let ((bounds #f))
      (define (process-node node <W3D-Node>)
        (let ((parts (get-parts node)))
          (when parts
            (let ((matrix (transformation-matrix node)))
              (loop (for part <W3D-Node-Part> in parts)
                    (bind-values (mesh <W3D-Mesh> mesh-part <W3D-Mesh-Part>) (find-mesh-part self (get-meshpartid part))
                      (let ((vertices (get-vertices mesh))
                            (indices (get-indices mesh-part)))
                        (loop (for index in-vector indices)
                              (let ((vertex <W3D-Vertex> (list-ref vertices index)))
                                (let ((position (matrix-transform matrix (get-position vertex))))
                                  (let ((x (vertex-x position))
                                        (y (vertex-y position))
                                        (z (vertex-z position)))
                                    (if (not bounds)
                                        (set! bounds (cuboid x y z x y z))
                                      (when (< x (cuboid-left bounds))
                                        (cuboid-left-set! bounds x))
                                      (when (> x (cuboid-right bounds))
                                        (cuboid-right-set! bounds x))
                                      (when (< y (cuboid-bottom bounds))
                                        (cuboid-bottom-set! bounds y))
                                      (when (> y (cuboid-top bounds))
                                        (cuboid-top-set! bounds y))
                                      (when (< z (cuboid-back bounds))
                                        (cuboid-back-set! bounds z))
                                      (when (> z (cuboid-front bounds))
                                        (cuboid-front-set! bounds z)))))))))))))
        (let ((children (get-children node)))
          (when children
            (for-each process-node children))))
      
      (for-each process-node nodes)
      bounds))
  
  
  (method package (extract-animation self name) <Animation>
    (define (total-frames-heuristic)
      (let ((total-frames 0))
        (when animations
          (for-each (lambda (animation <W3D-Animation>)
                      (for-each (lambda (bone <W3D-Bone-Animation>)
                                  (let ((keyframes (get-keyframes bone)))
                                    (when (not-null? keyframes)
                                      (let ((last-frame <W3D-KeyFrame> (last keyframes)))
                                        (let ((time (fxceiling (get-keytime last-frame))))
                                          (when (> time total-frames)
                                            (set! total-frames time)))))))
                                (get-bones animation)))
                    animations))
        total-frames))
    
    (let ((animation-fps 1000.)
          (total-frames (total-frames-heuristic)))
      (let ((animation (new Animation name animation-fps total-frames (extract-bones self))))
        (setup-bones animation)
        animation)))
  
  
  (method (extract-bones self)
    (list->vector (sort < (table-values bones-table) key: get-index)))
  
  
  (method (register-bones self bones)
    (map (lambda (bone <W3D-Node-Part-Bone>)
           (let ((node (find-node self (get-node bone))))
             (register-bone-node self node)))
         bones))
  
  
  (method (register-bone-node self node <W3D-Node>)
    (let ((id (get-id node)))
      (let ((actual <Bone+> (table-ref bones-table id #f)))
        (if actual
            (get-index actual)
          (let ((parent (get-parent node)))
            (when parent
              (register-bone-node self parent))
            (let ((animation (first-animation self)))
              (allege animation
                (let ((boneanim (find-bone animation id)))
                  (let ((translation (or (get-translation node) (vertex 0. 0. 0.)))
                        (rotation (or (get-rotation node) (quaternion 0. 0. 0. 1.)))
                        (scale (or (get-scale node) (vertex 1. 1. 1.))))
                    (let ((index bones-index)
                          (parent-id (and parent (get-id parent)))
                          (scaled-translation (vertex/ translation scale))
                          (inverse-rotation (quaternion-inverse rotation)))
                      (let ((translation-keys (extract-keys self animation id get-translation (lambda (pos) (vertex- pos scaled-translation))))
                            (rotation-keys (extract-keys self animation id get-rotation (lambda (rot) (quaternion-product rot inverse-rotation)))))
                        (increase! bones-index)
                        (let ((bone (new Bone 0 id index parent-id rotation scaled-translation rotation-keys translation-keys)))
                          (table-set! bones-table id bone))
                        index)))))))))))
  
  
  (method (first-animation self) <W3D-Animation+>
    (and animations (not-null? animations) (first animations)))
  
  
  (method (extract-keys self animation <W3D-Animation> bone-id key adjust)
    (let ((bone (find-bone animation bone-id)))
      (if (not bone)
          (vector)
        (list->vector (loop (for keyframe <W3D-KeyFrame> in (get-keyframes bone))
                            (for time = (get-keytime keyframe))
                            (for value = (key keyframe))
                            (if value
                                (collect (new KeyFrame time (adjust value)) into keys)
                              (return keys))
                            (finally keys)))))))


;;;
;;;; Import
;;;


(definition public (import-w3ds file <File> (metadata: metadata #f)) <Model>
  (let ((name (get-base file))
        (render (or (model-metadata-render metadata) '(transparent)))
        (mask (model-metadata-mask metadata)))
    (define (add-animations model <Model>)
      (let ((dir <Directory> (get-parent file)))
        (iterate-directory dir
          (lambda (file <File>)
            (when (extension=? (get-extension file) "w3ds")
              (let ((base (get-base file)))
                (unless (filename=? base name)
                  (assert (starts-with? base (concatenate name "_")))
                  (let ((name (subseq base (+ (cardinality name) 1) (cardinality base)))
                        (w3d (read-w3ds file)))
                    (add-animation model name (extract-animation w3d name)))))))
          files?: #t
          directories?: #f)))
    
    (let ((model (new Model name: name scale: (vertex .1 .1 .1))))
      (install-metadata model metadata)
      (let ((w3d (read-w3ds file)))
        (when debug-w3d?
          (set-native model w3d))
        ;; order is important as extract-atlas adjusts texture coordinates
        (bind-values (atlas texture) (extract-atlas w3d file)
          (define (extract-mesh w3d-mesh renderer)
            (let ((material (new Material atlas: atlas texture: texture renderer: renderer)))
              (extract-geometry w3d file atlas w3d-mesh material)))
          
          (define (iterate-meshes proc)
            (let ((renderer (require-renderer 'transparent)))
              (loop (for mesh in (get-meshes w3d))
                    (proc mesh renderer))))
          
          (when debug-meshes?
            (set-atlas model atlas))
          (let ((queue (new-queue)))
            (iterate-meshes
              (lambda (mesh renderer)
                (enqueue queue (extract-mesh mesh renderer))))
            (set-meshes model (list->vector (queue-list queue)))))
        (set-anchor model 'origin)
        (set-bounds model (extract-bounds w3d))
        (set-animation model (extract-animation w3d "Idle"))
        (add-animations model))
      model)))


(definition package (read-w3ds file <File>) <W3D-Model>
  (define (process-model w3ds)
    (let ((meshes (process-meshes (getp w3ds "meshes")))
          (materials (process-materials (getp w3ds "materials")))
          (nodes (process-nodes #f (getp w3ds "nodes")))
          (animations (process-animations (getp w3ds "animations"))))
      (new W3D-Model meshes materials nodes animations)))
  
  (define (process-meshes meshes)
    (define (process-vertices attributes vertices)
      (define (symbolize-attributes attributes)
        (loop (for attribute in-vector attributes)
              (collect (string->symbol attribute))))
      
      (let ((attributes (symbolize-attributes attributes))
            (count (vector-length vertices))
            (queue (new-queue)))
        (let (iter (scan 0))
          (if (>= scan count)
              (queue-list queue)
            (let ((vert (new W3D-Vertex)))
              (define (read-vertex)
                (prog1 (vertex (vector-ref vertices scan)
                               (vector-ref vertices (+ scan 1))
                               (vector-ref vertices (+ scan 2)))
                  (increase! scan 3)))
              
              (define (read-uv)
                (prog1 (vertex (vector-ref vertices scan)
                               (vector-ref vertices (+ scan 1))
                               0.)
                  (increase! scan 2)))
              
              (define (read-blendweight)
                (prog1 (vertex (vector-ref vertices scan)
                               (vector-ref vertices (+ scan 1))
                               0.)
                  (increase! scan 2)))
              
              (for-each (lambda (attribute)
                          (case attribute
                            ((POSITION) (set-position vert (read-vertex)))
                            ((NORMAL) (set-normal vert (read-vertex)))
                            ((COLOR) (increase! scan 4))
                            ((TEXCOORD0) (set-texcoord vert (read-uv)))
                            ((TEXCOORD1) (increase! scan 2))
                            ((TEXCOORD2) (increase! scan 2))
                            ((TEXCOORD3) (increase! scan 2))
                            ((TEXCOORD4) (increase! scan 2))
                            ((TEXCOORD5) (increase! scan 2))
                            ((TEXCOORD6) (increase! scan 2))
                            ((TEXCOORD7) (increase! scan 2))
                            ((BLENDWEIGHT0) (set-blendweight vert (read-blendweight)))
                            ((BLENDWEIGHT1) (increase! scan 2))
                            ((BLENDWEIGHT2) (increase! scan 2))
                            ((BLENDWEIGHT3) (increase! scan 2))
                            ((BLENDWEIGHT4) (increase! scan 2))
                            ((BLENDWEIGHT5) (increase! scan 2))
                            ((BLENDWEIGHT6) (increase! scan 2))
                            ((BLENDWEIGHT7) (increase! scan 2))))
                        attributes)
              (enqueue queue vert)
              (iter scan))))))
    
    (define (process-parts parts)
      (define (process-part part)
        (let ((id (getp part "id"))
              (type (getp part "type"))
              (indices (getp part "indices")))
          (assert (equal? type "TRIANGLES"))
          (new W3D-Mesh-Part id indices)))
      
      (loop (for part in-vector parts)
            (collect (process-part part))))
    
    (loop (for mesh in-vector meshes)
          (collect (let ((vertices (process-vertices (getp mesh "attributes") (getp mesh "vertices")))
                         (parts (process-parts (getp mesh "parts"))))
                     (new W3D-Mesh vertices parts)))))
  
  (define (process-materials materials)
    (define (process-material material)
      (define (process-textures textures)
        (when textures
          (loop (for texture in-vector textures)
                (collect (let ((id (getp texture "id"))
                               (filename (getp texture "filename"))
                               (type (getp texture "type")))
                           (new W3D-Texture id filename type))))))
      
      (let ((id (getp material "id"))
            (ambient (getp material "ambient"))
            (diffuse (getp material "diffuse"))
            (specular (getp material "specular"))
            (textures (process-textures (getp material "textures"))))
        (new W3D-Material id ambient diffuse specular textures)))
    
    (loop (for material in-vector materials)
          (collect (process-material material))))
  
  (define (process-nodes parent nodes)
    (define (process-node node)
      (define (process-parts parts)
        (define (process-bones bones)
          (when bones
            (loop (for bone in-vector bones)
                  (collect (let ((node (getp bone "node"))
                                 (translation (process-vertex (getp bone "translation")))
                                 (rotation (process-quaternion (getp bone "rotation")))
                                 (scale (process-vertex (getp bone "scale"))))
                             (new W3D-Node-Part-Bone node translation rotation scale))))))
        
        (when parts
          (loop (for part in-vector parts)
                (collect (let ((meshpartid (getp part "meshpartid"))
                               (materialid (getp part "materialid"))
                               (bones (process-bones (getp part "bones")))
                               (uvMapping (getp part "uvMapping")))
                           (new W3D-Node-Part meshpartid materialid bones uvMapping))))))
      
      (let ((id (getp node "id"))
            (translation (process-vertex (getp node "translation")))
            (rotation (process-quaternion (getp node "rotation")))
            (scale (process-vertex (getp node "scale")))
            (parts (process-parts (getp node "parts")))
            (children (getp node "children")))
        (let ((node (new W3D-Node id parent translation rotation scale parts)))
          (set-children node (and children (process-nodes node children)))
          node)))
    
    (loop (for node in-vector nodes)
          (collect (process-node node))))
  
  (define (process-animations animations)
    (define (process-animation animation)
      (define (process-bones bones)
        (define (process-keyframes keyframes)
          (loop (for keyframe in-vector keyframes)
                (collect (let ((keytime (getp keyframe "keytime"))
                               (translation (process-vertex (getp keyframe "translation")))
                               (rotation (process-quaternion (getp keyframe "rotation")))
                               (scale (process-vertex (getp keyframe "scale"))))
                           (new W3D-KeyFrame keytime translation rotation scale)))))
        
        (loop (for bone in-vector bones)
              (collect (let ((boneid (getp bone "boneId"))
                             (keyframes (getp bone "keyframes")))
                         (new W3D-Bone-Animation boneid (process-keyframes keyframes))))))
      
      (let ((id (getp animation "id"))
            (bones (process-bones (getp animation "bones"))))
        (new W3D-Animation id bones)))
    
    (loop (for animation in-vector animations)
          (collect (process-animation animation))))
  
  (define (process-vertex vert)
    (and vert (vertex (vector-ref vert 0)
                      (vector-ref vert 1)
                      (vector-ref vert 2))))
  
  (define (process-quaternion quat)
    (and quat (quaternion (vector-ref quat 0)
                          (vector-ref quat 1)
                          (vector-ref quat 2)
                          (vector-ref quat 3))))
  
  (define (getp expr prop)
    (getf expr prop test: equal?))
  
  (let ((w3ds (call-with-input-file (path-settings file) read)))
    (process-model w3ds))))
