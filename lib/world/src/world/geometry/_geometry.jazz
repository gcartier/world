;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Geometry
;;;


(module world.geometry jazz


(export (world.geometry.classes)
        (world.geometry.syntax (phase syntax)))

(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world.geometry.classes)
        (world.geometry.syntax)
        (world.syntax))


(proclaim (warn optimizations))


;;;
;;;; Vertex
;;;


(definition public (inner-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (inner-product! res <f32vector> u <f32vector> v <f32vector>) <f32vector>
  (f32-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v))))
  res)


(definition public (dot-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (dot-product! res <f32vector> u <f32vector> v <f32vector>) <f32vector>
  (f32-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v))))
  res)


(definition public (cross-product u <f32vector> v <f32vector>) <f32vector>
  (let ((res (make-vertex)))
    (cross-product! res u v)
    res))


(definition public (cross-product! res <f32vector> u <f32vector> v <f32vector>) <f32vector>
  (let ((a (vertex-x u))
        (b (vertex-y u))
        (c (vertex-z u))
        (d (vertex-x v))
        (e (vertex-y v))
        (f (vertex-z v)))
    (vertex-x-set! res (- (* b f) (* c e)))
    (vertex-y-set! res (- (* c d) (* a f)))
    (vertex-z-set! res (- (* a e) (* b d))))
  res)


(definition public (vector-angle v1 <f32vector> v2 <f32vector>) <fl>
  (acos (inner-product v1 v2)))


(definition public (vertical-angle vert up)
  (- (vector-angle vert up)
     PI/2))


(definition public (plane-normal v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (plane-normal! (make-vertex) v1 v2 v3))


(definition public (plane-normal! res <f32vector> v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (cross-product! res
                  (vertex- v2 v1)
                  (vertex- v3 v1))
  (vertex-normalize! res res)
  res)


(definition public (triangle-center v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3)) 3.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3)) 3.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3)) 3.)))


(definition public (quad-center v1 <f32vector> v2 <f32vector> v3 <f32vector> v4 <f32vector>) <f32vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3) (vertex-x v4)) 4.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3) (vertex-y v4)) 4.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3) (vertex-z v4)) 4.)))


(definition public (ray-triangle-distance p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <fl>
  (f32-ref (ray-triangle-distance! (make-f32&) p d v0 v1 v2)))


(definition public (ray-triangle-distance! res <f32vector> p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <f32vector>
  (let ((e1 (vertex-& v1 v0))
        (e2 (vertex-& v2 v0)))
    (let ((h (cross-product& d e2)))
      (let ((a (inner-product& e1 h))
            (f (make-f32&))
            (u (make-f32&))
            (v (make-f32&))
            (t (make-f32&)))
        (if (and (> (f32-ref a) -0.00001) (< (f32-ref a) 0.00001))
            (f32-set! res -1.)
          (f32-set! f (/ 1. (f32-ref a)))
          (let ((s (vertex-& p v0)))
            (let ((b (inner-product& s h)))
              (f32-set! u (* (f32-ref f) (f32-ref b)))
              (if (or (< (f32-ref u) 0.0) (> (f32-ref u) 1.0))
                  (f32-set! res -1.)
                (let ((q (cross-product& s e1)))
                  (let ((c (inner-product& d q)))
                    (f32-set! v (* (f32-ref f) (f32-ref c)))
                    (if (or (< (f32-ref v) 0.0) (> (+ (f32-ref u) (f32-ref v)) 1.0))
                        (f32-set! res -1.)
                      ;; at this stage we can compute t to find out where
                      ;; the intersection point is on the line
                      (let ((d (inner-product& e2 q)))
                        (f32-set! t (* (f32-ref f) (f32-ref d)))
                        (if (> (f32-ref t) 0.00001) ;; ray intersection
                            (f32-set! res (f32-ref t))
                          ;; this means that there is a line intersection
                          ;; but not a ray intersection
                          (f32-set! res -1.)))))))))))))
  res)


(definition public (ray-intersects-triangle? p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <bool>
  (let ((d (make-f32&)))
    (ray-triangle-distance! d p d v0 v1 v2)
    (/= (f32-ref d) -1.)))


(definition public (ray-intersects-sphere? p <f32vector> d <f32vector> s <f32vector> r <fl>) <bool>
  (let ((t (vertex-& p s)))
    (let ((i (inner-product& t d))
          (b (make-f32&))
          (det (make-f32&)))
      (f32-set! b (- (f32-ref i)))
      (let ((j (inner-product& t t)))
        (f32-set! det (+ (- (* (f32-ref b) (f32-ref b)) (f32-ref j)) (* r r)))
        (if (< (f32-ref det) 0.)
            #f
          (f32-set! det (sqrt (f32-ref det)))
          (let ((i (+ (f32-ref b) (f32-ref det))))
            (>= i 0.)))))))


;;;
;;;; OpenGL
;;;


(definition public (gl-plane-normal v1 v2 v3)
  (let ((normal (plane-normal v1 v2 v3)))
    (glNormal3f (vertex-x normal)
                (vertex-y normal)
                (vertex-z normal))))


;;;
;;;; Random
;;;


(definition public (random-in max)
  (- (* (random-real) max 2) max)))
