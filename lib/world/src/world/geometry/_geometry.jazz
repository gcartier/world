;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Geometry
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.geometry jazz


(export (world.geometry.base)
        (world.geometry.classes)
        (world.geometry.syntax (phase syntax)))

(import (jazz.geometry)
        (world.geometry.base)
        (world.geometry.classes)
        (world.geometry.syntax (phase syntax))
        (world.homogeneous)
        (world.lookat)
        (world.movement)
        (world.parallelepiped)
        (world.plane)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Float
;;;


(definition protected EPSILON <fl>
  1e-5)


(definition public (float-near? f1 <fl> f2 <fl>) <bool>
  (< (abs (- f1 f2)) EPSILON))


;;;
;;;; Vertex
;;;


(definition public (vertex-distance v1 <f64vector> v2 <f64vector>) <fl>
  (vertex-norm (vertex-& v2 v1)))


(definition public (vertex-distance! res <f64vector> v1 <f64vector> v2 <f64vector>) <f64vector>
  (vertex-norm! res (vertex-& v2 v1))
  res)


(definition public (vertex-near? v1 <f64vector> v2 <f64vector>) <bool>
  (< (f64-ref (vertex-distance& v1 v2)) EPSILON))


(definition public (vertex-64->32 vert)
  (let ((x (f32& (vertex-x vert)))
        (y (f32& (vertex-y vert)))
        (z (f32& (vertex-z vert))))
    (vertex (f32-ref x)
            (f32-ref y)
            (f32-ref z))))


(definition public (rotate-upon angle <fl> axis <f64vector> dir <f64vector>) <f64vector>
  (rotate-upon! (make-vertex) angle axis dir))


(definition public (rotate-upon! res <f64vector> angle <fl> axis <f64vector> dir <f64vector>) <f64vector>
  (let ((c <fl> (cos angle))
        (s <fl> (sin angle))
        (x (vertex-x axis))
        (y (vertex-y axis))
        (z (vertex-z axis))
        (i (vertex-x dir))
        (j (vertex-y dir))
        (k (vertex-z dir)))
    (vertex-x-set! res (+ (* i (+ (* x x (- 1. c)) c))
                          (* j (- (* x y (- 1. c)) (* z s)))
                          (* k (+ (* x z (- 1. c)) (* y s)))))
    (vertex-y-set! res (+ (* i (+ (* y x (- 1. c)) (* z s)))
                          (* j (+ (* y y (- 1. c)) c))
                          (* k (- (* y z (- 1. c)) (* x s)))))
    (vertex-z-set! res (+ (* i (- (* x z (- 1. c)) (* y s)))
                          (* j (+ (* y z (- 1. c)) (* x s)))
                          (* k (+ (* z z (- 1. c)) c)))))
  res)


(definition public (inner-product u <f64vector> v <f64vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (inner-product! res <f64vector> u <f64vector> v <f64vector>) <f64vector>
  (f64-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v))))
  res)


(definition public (dot-product u <f64vector> v <f64vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (dot-product! res <f64vector> u <f64vector> v <f64vector>) <f64vector>
  (f64-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v))))
  res)


(definition public (cross-product u <f64vector> v <f64vector>) <f64vector>
  (let ((res (make-vertex)))
    (cross-product! res u v)
    res))


(definition public (cross-product! res <f64vector> u <f64vector> v <f64vector>) <f64vector>
  (let ((a (vertex-x u))
        (b (vertex-y u))
        (c (vertex-z u))
        (d (vertex-x v))
        (e (vertex-y v))
        (f (vertex-z v)))
    (vertex-x-set! res (- (* b f) (* c e)))
    (vertex-y-set! res (- (* c d) (* a f)))
    (vertex-z-set! res (- (* a e) (* b d))))
  res)


(definition public (cross-normal u <f64vector> v <f64vector>) <f64vector>
  (cross-normal! (make-vertex) u v))


(definition public (cross-normal! res <f64vector> u <f64vector> v <f64vector>) <f64vector>
  (cross-product! res u v)
  (vertex-normalize! res res)
  res)


(definition public (cross-normal-safe! res <f64vector> u <f64vector> v <f64vector>) <f64vector>
  (cross-product! res u v)
  (vertex-normalize-safe! res res)
  res)


(definition public (plane-normal v1 <f64vector> v2 <f64vector> v3 <f64vector>) <f64vector>
  (plane-normal! (make-vertex) v1 v2 v3))


(definition public (plane-normal! res <f64vector> v1 <f64vector> v2 <f64vector> v3 <f64vector>) <f64vector>
  (cross-normal! res
                 (vertex-& v2 v1)
                 (vertex-& v3 v1)))


(definition public (plane-normal-safe v1 <f64vector> v2 <f64vector> v3 <f64vector>) <f64vector>
  (plane-normal-safe! (make-vertex) v1 v2 v3))


(definition public (plane-normal-safe! res <f64vector> v1 <f64vector> v2 <f64vector> v3 <f64vector>) <f64vector>
  (cross-normal-safe! res
                      (vertex-& v2 v1)
                      (vertex-& v3 v1)))


(definition public (vector-angle v1 <f64vector> v2 <f64vector>) <fl>
  (let ((dot (inner-product v1 v2)))
    (cond ((< dot -1.) PI)
          ((> dot 1.) 0.)
          (else (acos dot)))))


(definition public (vertical-angle vert <f64vector> up <f64vector>) <fl>
  (- (vector-angle vert up)
     PI/2))


(definition public (plane-angle x1 <fl> y1 <fl> x2 <fl> y2 <fl>) <fl>
  (let ((atanA (atan x1 y1))
        (atanB (atan x2 y2)))
    (let ((angle (- atanB atanA)))
      (if (>= angle 0.)
          angle
        (+ PI*2 angle)))))


(definition public (triangle-center v1 <f64vector> v2 <f64vector> v3 <f64vector>) <f64vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3)) 3.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3)) 3.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3)) 3.)))


(definition public (quad-center v1 <f64vector> v2 <f64vector> v3 <f64vector> v4 <f64vector>) <f64vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3) (vertex-x v4)) 4.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3) (vertex-y v4)) 4.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3) (vertex-z v4)) 4.)))


(definition public (center-of-mass vertices <vector>) <f64vector>
  (center-of-mass! (make-vertex) vertices))


(definition public (center-of-mass! res <f64vector> vertices <vector>) <f64vector>
  (vertex-init! res 0. 0. 0.)
  (loop (for vertex in-vector vertices)
        (vertex+! res res vertex))
  (vertex-scalar*! res res (/ 1. (vector-length vertices))))


(definition public (polygon-normal vertices <vector>) <f64vector>
  (plane-normal (vector-ref vertices 0)
                (vector-ref vertices 1)
                (vector-ref vertices 2)))


(definition public (polygon-normal! res <f64vector> vertices <vector>) <f64vector>
  (plane-normal! res
                 (vector-ref vertices 0)
                 (vector-ref vertices 1)
                 (vector-ref vertices 2)))


(definition public (polygon-radius center <f64vector> vertices <vector>) <fl>
  (let ((radius -1.))
    (loop (for vertex in-vector vertices)
          (let ((dist (vertex-distance center vertex)))
            (when (> dist radius)
              (set! radius dist))))
    radius))


(definition public (transform-normal normal <f64vector> inverse-matrix <f64vector>) <f64vector>
  (matrix-transform-normal inverse-matrix normal))


(definition public (transform-ray origin <f64vector> dir <f64vector> matrix <f64vector>) <values>
  (let ((new-origin (matrix-transform-3x4 matrix origin))
        (new-dest (matrix-transform-3x4 matrix (vertex+& origin dir))))
    (values new-origin (vertex-& new-dest new-origin))))


(definition public (transform-ray/normalize origin <f64vector> dir <f64vector> matrix <f64vector>) <values>
  (receive (new-origin new-dir) (transform-ray origin dir matrix)
    (values new-origin (vertex-normalize new-dir))))


(definition public (ray-point-distance p <f64vector> d <f64vector> vert <f64vector>) <fl>
  (vertex-norm (cross-product& d (vertex-& vert p))))


(definition public (ray-point-distance! res <f64vector> p <f64vector> d <f64vector> vert <f64vector>) <f64vector>
  (vertex-norm! res (cross-product& d (vertex-& vert p))))


(definition public (ray-point-horizontal-distance p <f64vector> d <f64vector> v <f64vector>) <fl>
  (let ((d (vertex-normalize& (vertex& (vertex-x d) 0. (vertex-z d))))
        (v (vertex& (vertex-x v) (vertex-y p) (vertex-z v))))
    (ray-point-distance p d v)))


(definition public (ray-triangle-distance p <f64vector> d <f64vector> v0 <f64vector> v1 <f64vector> v2 <f64vector>) <fl>
  (f64-ref (ray-triangle-distance! (make-f64&) p d v0 v1 v2)))


(definition public (ray-triangle-distance! res <f64vector> p <f64vector> d <f64vector> v0 <f64vector> v1 <f64vector> v2 <f64vector>) <f64vector>
  (let ((e1 (vertex-& v1 v0))
        (e2 (vertex-& v2 v0)))
    (let ((h (cross-product& d e2)))
      (let ((a (inner-product& e1 h)))
        (if (and (> (f64-ref a) -0.00001) (< (f64-ref a) 0.00001))
            (f64-set! res -1.)
          (let ((f (f64& (/ 1. (f64-ref a))))
                (s (vertex-& p v0)))
            (let ((b (inner-product& s h)))
              (let ((u (f64& (* (f64-ref f) (f64-ref b)))))
                (if (or (< (f64-ref u) 0.0) (> (f64-ref u) 1.0))
                    (f64-set! res -1.)
                  (let ((q (cross-product& s e1)))
                    (let ((c (inner-product& d q)))
                      (let ((v (f64& (* (f64-ref f) (f64-ref c)))))
                        (if (or (< (f64-ref v) 0.0) (> (+ (f64-ref u) (f64-ref v)) 1.0))
                            (f64-set! res -1.)
                          ;; at this stage we can compute t to find out where
                          ;; the intersection point is on the line
                          (let ((d (inner-product& e2 q)))
                            (let ((t (f64& (* (f64-ref f) (f64-ref d)))))
                              (if (> (f64-ref t) 0.00001) ;; ray intersection
                                  (f64-set! res (f64-ref t))
                                ;; this means that there is a line intersection
                                ;; but not a ray intersection
                                (f64-set! res -1.))))))))))))))))
  res)


(definition public (ray-intersects-triangle? p <f64vector> d <f64vector> v0 <f64vector> v1 <f64vector> v2 <f64vector>) <bool>
  (let ((d (make-f64&)))
    (ray-triangle-distance! d p d v0 v1 v2)
    (/= (f64-ref d) -1.)))


(definition public (ray-intersects-sphere? p <f64vector> d <f64vector> s <f64vector> r <fl>) <bool>
  (let ((t (vertex-& p s)))
    (let ((i (inner-product& t d)))
      (let ((b (f64& (- (f64-ref i)))))
        (let ((j (inner-product& t t)))
          (let ((det (f64& (+ (- (* (f64-ref b) (f64-ref b)) (f64-ref j)) (* r r)))))
            (if (< (f64-ref det) 0.)
                #f
              (f64-set! det (sqrt (f64-ref det)))
              (let ((i (+ (f64-ref b) (f64-ref det))))
                (>= i 0.)))))))))


(definition public (validate-vertex-normalized vert)
  (unless (float-near? (vertex-norm vert) 1.)
    (error "Vertex {s} is not normalized" vert)))


;;;
;;;; Quaternion
;;;


(definition public (quaternion-inverse quat <f64vector>) <f64vector>
  (quaternion-scalar/ (quaternion-conjugate quat)
                      (quaternion-squared-norm quat)))


(definition public (quaternion-conjugate quat <f64vector>) <f64vector>
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (quaternion (- x)
                (- y)
                (- z)
                w)))


(definition public (quaternion-norm quat <f64vector>) <fl>
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (sqrt (+ (* x x)
             (* y y)
             (* z z)
             (* w w)))))


(definition public (quaternion-squared-norm quat <f64vector>) <fl>
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (+ (* x x)
       (* y y)
       (* z z)
       (* w w))))


(definition public (quaternion-scalar* quat <f64vector> r <fl>) <f64vector>
  (quaternion
    (* (quaternion-x quat) r)
    (* (quaternion-y quat) r)
    (* (quaternion-z quat) r)
    (* (quaternion-w quat) r)))


(definition public (quaternion-scalar/ quat <f64vector> r <fl>) <f64vector>
  (quaternion
    (/ (quaternion-x quat) r)
    (/ (quaternion-y quat) r)
    (/ (quaternion-z quat) r)
    (/ (quaternion-w quat) r)))


(definition public (quaternion-product q1 <f64vector> q2 <f64vector>) <f64vector>
  (let ((x1 (quaternion-x q1))
        (y1 (quaternion-y q1))
        (z1 (quaternion-z q1))
        (w1 (quaternion-w q1))
        (x2 (quaternion-x q2))
        (y2 (quaternion-y q2))
        (z2 (quaternion-z q2))
        (w2 (quaternion-w q2)))
    (quaternion (+ (* w1 x2) (* x1 w2) (* y1 z2) (- (* z1 y2)))
                (+ (* w1 y2) (* y1 w2) (* z1 x2) (- (* x1 z2)))
                (+ (* w1 z2) (* z1 w2) (* x1 y2) (- (* y1 x2)))
                (+ (* w1 w2) (- (* x1 x2)) (- (* y1 y2)) (- (* z1 z2))))))


(definition public (translate-matrix! res <f64vector> trans <f64vector>) <f64vector>
  (declare (optimize-dead-local-variables))
  (matrix-set! res 12 (vertex-x trans))
  (matrix-set! res 13 (vertex-y trans))
  (matrix-set! res 14 (vertex-z trans))
  res)


(definition public (euler-quaternion angles <f64vector>) <f64vector>
  (euler-quaternion! (make-quaternion) angles))


(definition public (euler-quaternion! res <f64vector> angles <f64vector>) <f64vector>
  (declare (optimize-dead-local-variables))
  (let ((rx (vertex-x angles))
        (ry (vertex-y angles))
        (rz (vertex-z angles)))
    (let ((sr (sin (* rx .5)))
          (sp (sin (* ry .5)))
          (sy (sin (* rz .5)))
          (cr (cos (* rx .5)))
          (cp (cos (* ry .5)))
          (cy (cos (* rz .5))))
      (quaternion-x-set! res (- (* sr cp cy) (* cr sp sy)))
      (quaternion-y-set! res (+ (* cr sp cy) (* sr cp sy)))
      (quaternion-z-set! res (- (* cr cp sy) (* sr sp cy)))
      (quaternion-w-set! res (+ (* cr cp cy) (* sr sp sy)))))
  res)


(definition public (quaternion-euler quat <f64vector>) <f64vector>
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (vertex (atan (* 2. (+ (* w x) (* y z))) (- 1. (* 2. (+ (* x x) (* y y)))))
            (asin (* 2. (- (* w y) (* z x))))
            (atan (* 2. (+ (* w z) (* x y))) (- 1. (* 2. (+ (* y y) (* z z))))))))


(definition public (quaternion-matrix! res <f64vector> quat <f64vector>) <f64vector>
  (declare (optimize-dead-local-variables))
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (matrix-set! res  0 (- (- 1. (* 2. y y)) (* 2. z z)))
    (matrix-set! res  1 (+ (* 2. x y) (* 2. w z)))
    (matrix-set! res  2 (- (* 2. x z) (* 2. w y)))
    (matrix-set! res  4 (- (* 2. x y) (* 2. w z)))
    (matrix-set! res  5 (- (- 1. (* 2. x x)) (* 2. z z)))
    (matrix-set! res  6 (+ (* 2. y z) (* 2. w x)))
    (matrix-set! res  8 (+ (* 2. x z) (* 2. w y)))
    (matrix-set! res  9 (- (* 2. y z) (* 2. w x)))
    (matrix-set! res 10 (- (- 1. (* 2. x x)) (* 2. y y))))
  res)


(definition public (quaternion-slerp! res <f64vector> p <f64vector> q <f64vector> t <fl>) <f64vector>
  (declare (optimize-dead-local-variables))
  ;; decide if one of the quaternions is backwards
  (let ((a (f64& 0.))
        (b (f64& 0.)))
    (loop (for i from 0 below 4)
          (let ((pi (f64vector-ref p i))
                (qi (f64vector-ref q i)))
            (f64-set! a (+ (f64-ref a) (* (- pi qi) (- pi qi))))
            (f64-set! b (+ (f64-ref b) (* (+ pi qi) (+ pi qi))))))
    (when (> (f64-ref a) (f64-ref b))
      (loop (for i from 0 below 4)
            (f64vector-set! q i (- (f64vector-ref q i)))))
    (let ((cosom
            (f64& (+ (* (quaternion-x p) (quaternion-x q))
                     (* (quaternion-y p) (quaternion-y q))
                     (* (quaternion-z p) (quaternion-z q))
                     (* (quaternion-w p) (quaternion-w q))))))
      (if (> (+ 1. (f64-ref cosom)) 1e-8)
          (let ((sclp (make-f64&))
                (sclq (make-f64&)))
            (if (> (- 1. (f64-ref cosom)) 1e-8)
                (let ((omega (acos (f64-ref cosom))))
                  (let ((sinom (sin omega)))
                    (f64-set! sclp (/ (sin (* (- 1. t) omega)) sinom))
                    (f64-set! sclq (/ (sin (* t omega)) sinom))))
              (begin
                (f64-set! sclp (- 1. t))
                (f64-set! sclq t)))
            (loop (for i from 0 below 4)
                  (f64vector-set! res i (+ (* (f64-ref sclp) (f64vector-ref p i))
                                           (* (f64-ref sclq) (f64vector-ref q i))))))
        (quaternion-x-set! res (- (quaternion-y p)))
        (quaternion-y-set! res (quaternion-x p))
        (quaternion-z-set! res (- (quaternion-w p)))
        (quaternion-w-set! res (quaternion-z p))
        (let ((sclp (sin (* (- 1. t) .5 PI)))
              (sclq (sin (* t .5 PI))))
          (loop (for i from 0 below 3)
                (f64vector-set! res i (+ (* sclp (f64vector-ref p i))
                                         (* sclq (f64vector-ref res i)))))))))
  res)


(definition public (euler-radian->degree angles <f64vector>) <f64vector>
  (vertex (radian->degree (vertex-x angles))
          (radian->degree (vertex-y angles))
          (radian->degree (vertex-z angles))))


(definition public (euler-degree->radian angles <f64vector>) <f64vector>
  (vertex (degree->radian (vertex-x angles))
          (degree->radian (vertex-y angles))
          (degree->radian (vertex-z angles))))


;;;
;;;; Cuboid
;;;


(definition public (cuboid-size cuboid <f64vector>) <f64vector>
  (vertex (- (cuboid-right cuboid) (cuboid-left cuboid))
          (- (cuboid-top cuboid) (cuboid-bottom cuboid))
          (- (cuboid-front cuboid) (cuboid-back cuboid))))


(definition public (cuboid-radiuses cuboid <f64vector>) <f64vector>
  (vertex (/ (- (cuboid-right cuboid) (cuboid-left cuboid)) 2.)
          (/ (- (cuboid-top cuboid) (cuboid-bottom cuboid)) 2.)
          (/ (- (cuboid-front cuboid) (cuboid-back cuboid)) 2.)))


(definition public (cuboid-center cuboid <f64vector>) <f64vector>
  (vertex (/ (+ (cuboid-right cuboid) (cuboid-left cuboid)) 2.)
          (/ (+ (cuboid-top cuboid) (cuboid-bottom cuboid)) 2.)
          (/ (+ (cuboid-front cuboid) (cuboid-back cuboid)) 2.)))


(definition public (unit-cube pos)
  (let ((x (vertex-x pos))
        (y (vertex-y pos))
        (z (vertex-z pos)))
    (cuboid (floor x)
            (floor y)
            (floor z)
            (ceiling x)
            (ceiling y)
            (ceiling z))))


(definition public (compute-vertices-bounds proc) <f64vector>
  (let ((left +inf.0)
        (bottom +inf.0)
        (back +inf.0)
        (right -inf.0)
        (top -inf.0)
        (front -inf.0))
    (proc (lambda (vert)
            (let ((x (vertex-x vert))
                  (y (vertex-y vert))
                  (z (vertex-z vert)))
              (when (< x left) (set! left x))
              (when (< y bottom) (set! bottom y))
              (when (< z back) (set! back z))
              (when (> x right) (set! right x))
              (when (> y top) (set! top y))
              (when (> z front) (set! front z)))))
    (cuboid left bottom back right top front)))


;;;
;;;; Matrix
;;;


(definition public (make-identity-matrix) <f64vector>
  (make-identity-matrix! (make-matrix)))


(definition public (make-identity-matrix! res <f64vector>) <f64vector>
  (matrix-set! res  0 1.)
  (matrix-set! res  1 0.)
  (matrix-set! res  2 0.)
  (matrix-set! res  3 0.)
  (matrix-set! res  4 0.)
  (matrix-set! res  5 1.)
  (matrix-set! res  6 0.)
  (matrix-set! res  7 0.)
  (matrix-set! res  8 0.)
  (matrix-set! res  9 0.)
  (matrix-set! res 10 1.)
  (matrix-set! res 11 0.)
  (matrix-set! res 12 0.)
  (matrix-set! res 13 0.)
  (matrix-set! res 14 0.)
  (matrix-set! res 15 1.)
  res)


(definition public (identity-matrix? mat <f64vector>) <bool>
  (matrix=? mat (make-identity-matrix&)))


(definition public (matrix-transpose-3x3! dst <f64vector> src <f64vector>) <void>
  (matrix-set! dst 0 (matrix-ref src 0))
  (matrix-set! dst 1 (matrix-ref src 4))
  (matrix-set! dst 2 (matrix-ref src 8))
  (matrix-set! dst 4 (matrix-ref src 1))
  (matrix-set! dst 5 (matrix-ref src 5))
  (matrix-set! dst 6 (matrix-ref src 9))
  (matrix-set! dst 8 (matrix-ref src 2))
  (matrix-set! dst 9 (matrix-ref src 6))
  (matrix-set! dst 10 (matrix-ref src 10)))


(definition public (matrix-multiply a <f64vector> b <f64vector>) <f64vector>
  (matrix-multiply! (make-matrix) a b))


(definition public (matrix-multiply! res <f64vector> a <f64vector> b <f64vector>) <f64vector>
  (let ((a0 (matrix-ref a 0)) (a4 (matrix-ref a 4)) (a8  (matrix-ref a 8))  (a12 (matrix-ref a 12))
        (a1 (matrix-ref a 1)) (a5 (matrix-ref a 5)) (a9  (matrix-ref a 9))  (a13 (matrix-ref a 13))
        (a2 (matrix-ref a 2)) (a6 (matrix-ref a 6)) (a10 (matrix-ref a 10)) (a14 (matrix-ref a 14))
        (a3 (matrix-ref a 3)) (a7 (matrix-ref a 7)) (a11 (matrix-ref a 11)) (a15 (matrix-ref a 15))
        (b0 (matrix-ref b 0)) (b4 (matrix-ref b 4)) (b8  (matrix-ref b 8))  (b12 (matrix-ref b 12))
        (b1 (matrix-ref b 1)) (b5 (matrix-ref b 5)) (b9  (matrix-ref b 9))  (b13 (matrix-ref b 13))
        (b2 (matrix-ref b 2)) (b6 (matrix-ref b 6)) (b10 (matrix-ref b 10)) (b14 (matrix-ref b 14))
        (b3 (matrix-ref b 3)) (b7 (matrix-ref b 7)) (b11 (matrix-ref b 11)) (b15 (matrix-ref b 15)))
    (matrix-set! res  0 (+ (* a0 b0)  (* a4 b1)  (* a8 b2)   (* a12 b3)))
    (matrix-set! res  4 (+ (* a0 b4)  (* a4 b5)  (* a8 b6)   (* a12 b7)))
    (matrix-set! res  8 (+ (* a0 b8)  (* a4 b9)  (* a8 b10)  (* a12 b11)))
    (matrix-set! res 12 (+ (* a0 b12) (* a4 b13) (* a8 b14)  (* a12 b15)))
    (matrix-set! res  1 (+ (* a1 b0)  (* a5 b1)  (* a9 b2)   (* a13 b3)))
    (matrix-set! res  5 (+ (* a1 b4)  (* a5 b5)  (* a9 b6)   (* a13 b7)))
    (matrix-set! res  9 (+ (* a1 b8)  (* a5 b9)  (* a9 b10)  (* a13 b11)))
    (matrix-set! res 13 (+ (* a1 b12) (* a5 b13) (* a9 b14)  (* a13 b15)))
    (matrix-set! res  2 (+ (* a2 b0)  (* a6 b1)  (* a10 b2)  (* a14 b3)))
    (matrix-set! res  6 (+ (* a2 b4)  (* a6 b5)  (* a10 b6)  (* a14 b7)))
    (matrix-set! res 10 (+ (* a2 b8)  (* a6 b9)  (* a10 b10) (* a14 b11)))
    (matrix-set! res 14 (+ (* a2 b12) (* a6 b13) (* a10 b14) (* a14 b15)))
    (matrix-set! res  3 (+ (* a3 b0)  (* a7 b1)  (* a11 b2)  (* a15 b3)))
    (matrix-set! res  7 (+ (* a3 b4)  (* a7 b5)  (* a11 b6)  (* a15 b7)))
    (matrix-set! res 11 (+ (* a3 b8)  (* a7 b9)  (* a11 b10) (* a15 b11)))
    (matrix-set! res 15 (+ (* a3 b12) (* a7 b13) (* a11 b14) (* a15 b15))))
  res)


(definition public (matrix-transform mat <f64vector> vert <f64vector>) <f64vector>
  (matrix-transform! (make-vertex) mat vert))


(definition public (matrix-transform! res <f64vector> mat <f64vector> vert <f64vector>) <f64vector>
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    (let ((s (+ (* (matrix-ref mat 3) x) (* (matrix-ref mat 7) y) (* (matrix-ref mat 11) z) (matrix-ref mat 15))))
      (vertex-x-set! res (/ (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)) s))
      (vertex-y-set! res (/ (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)) s))
      (vertex-z-set! res (/ (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14)) s))))
  res)


(definition public (matrix-transform-3x4 mat <f64vector> vert <f64vector>) <f64vector>
  (matrix-transform-3x4! (make-vertex) mat vert))


(definition public (matrix-transform-3x4! res <f64vector> mat <f64vector> vert <f64vector>) <f64vector>
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    (vertex-x-set! res (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)))
    (vertex-y-set! res (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)))
    (vertex-z-set! res (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14))))
  res)


(definition public (matrix-transform-normal inverse-mat <f64vector> vert <f64vector>) <f64vector>
  (matrix-transform-normal! (make-vertex) inverse-mat vert))


(definition public (matrix-transform-normal! res <f64vector> inverse-mat <f64vector> vert <f64vector>) <f64vector>
  ;; use inverse-transpose matrix
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    (assert (= (matrix-ref inverse-mat 3) 0))
    (assert (= (matrix-ref inverse-mat 7) 0))
    (assert (= (matrix-ref inverse-mat 11) 0))
    (vertex-x-set! res (+ (* (matrix-ref inverse-mat 0) x) (* (matrix-ref inverse-mat 1) y) (* (matrix-ref inverse-mat 2) z)))
    (vertex-y-set! res (+ (* (matrix-ref inverse-mat 4) x) (* (matrix-ref inverse-mat 5) y) (* (matrix-ref inverse-mat 6) z)))
    (vertex-z-set! res (+ (* (matrix-ref inverse-mat 8) x) (* (matrix-ref inverse-mat 9) y) (* (matrix-ref inverse-mat 10) z))))
  (vertex-normalize! res res)
  res)


(definition public (matrix+-transform-3x4 mat <f64vector+> vert <f64vector>) <f64vector>
  (if mat
      (matrix-transform-3x4 mat vert)
    vert))


(definition public (matrix+-transform-3x4! res <f64vector> mat <f64vector+> vert <f64vector>) <f64vector>
  (if mat
      (matrix-transform-3x4! res mat vert)
    (vertex-copy! res vert)))


(definition public (matrix-transform-3x4-offset! res <f64vector> mat <f64vector> vec <f64vector> offset <fx>) <f64vector>
  (let ((x (f64vector-ref vec offset))
        (y (f64vector-ref vec (+ offset 1)))
        (z (f64vector-ref vec (+ offset 2))))
    (vertex-x-set! res (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)))
    (vertex-y-set! res (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)))
    (vertex-z-set! res (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14))))
  res)


(definition public (matrix+-transform-3x4-offset! res <f64vector> mat <f64vector+> vec <f64vector> offset <fx>) <f64vector>
  (if mat
      (matrix-transform-3x4-offset! res mat vec offset)
    (vertex-init! res
                  (f64vector-ref vec offset)
                  (f64vector-ref vec (+ offset 1))
                  (f64vector-ref vec (+ offset 2)))))


(definition public (matrix-transform-3x4->offset! res <f64vector> offset <fx> mat <f64vector> vert <f64vector>) <f64vector>
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    (f64vector-set! res offset       (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)))
    (f64vector-set! res (+ offset 1) (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)))
    (f64vector-set! res (+ offset 2) (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14))))
  res)


(definition public (matrix+-transform-3x4->offset! res <f64vector> offset <fx> mat <f64vector+> vert <f64vector>) <f64vector>
  (if mat
      (matrix-transform-3x4->offset! res offset mat vert)
    (f64vector-set! res offset       (vertex-x vert))
    (f64vector-set! res (+ offset 1) (vertex-y vert))
    (f64vector-set! res (+ offset 2) (vertex-z vert))
    res))


(definition public (make-translation-matrix t <f64vector>) <f64vector>
  (make-translation-matrix! (make-matrix) t))


(definition public (make-translation-matrix! res <f64vector> t <f64vector>) <f64vector>
  (make-identity-matrix! res)
  (matrix-set! res 12 (vertex-x t))
  (matrix-set! res 13 (vertex-y t))
  (matrix-set! res 14 (vertex-z t))
  res)


(definition public (make-x-rotation-matrix phi <fl>) <f64vector>
  (make-x-rotation-matrix! (make-matrix) phi))


(definition public (make-x-rotation-matrix! res <f64vector> phi <fl>) <f64vector>
  (make-identity-matrix! res)
  (let ((cos (cos phi))
        (sin (sin phi)))
    (matrix-set! res 5 cos)
    (matrix-set! res 6 (- sin))
    (matrix-set! res 9 sin)
    (matrix-set! res 10 cos))
  res)


(definition public (make-y-rotation-matrix theta <fl>) <f64vector>
  (make-y-rotation-matrix! (make-matrix) theta))


(definition public (make-y-rotation-matrix! res <f64vector> theta <fl>) <f64vector>
  (make-identity-matrix! res)
  (let ((cos (cos theta))
        (sin (sin theta)))
    (matrix-set! res 0 cos)
    (matrix-set! res 2 sin)
    (matrix-set! res 8 (- sin))
    (matrix-set! res 10 cos))
  res)


(definition public (make-z-rotation-matrix psi <fl>) <f64vector>
  (make-z-rotation-matrix! (make-matrix) psi))


(definition public (make-z-rotation-matrix! res <f64vector> psi <fl>) <f64vector>
  (make-identity-matrix! res)
  (let ((cos (cos psi))
        (sin (sin psi)))
    (matrix-set! res 0 cos)
    (matrix-set! res 1 (- sin))
    (matrix-set! res 4 sin)
    (matrix-set! res 5 cos))
  res)


(definition public (make-rotation-matrix r <f64vector>) <f64vector>
  (make-rotation-matrix! (make-matrix) r))


(definition public (make-rotation-matrix! res <f64vector> r <f64vector>) <f64vector>
  (matrix-multiply! res
                    (make-x-rotation-matrix& (vertex-x r))
                    (matrix-multiply& (make-y-rotation-matrix& (vertex-y r))
                                      (make-z-rotation-matrix& (vertex-z r)))))


(definition public (make-quaternion-matrix quat <f64vector>) <f64vector>
  (make-quaternion-matrix! (make-matrix) quat))


(definition public (make-quaternion-matrix! res <f64vector> quat <f64vector>) <f64vector>
  (declare (optimize-dead-local-variables))
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (matrix-set! res  0 (- (- 1. (* 2. y y)) (* 2. z z)))
    (matrix-set! res  1 (+ (* 2. x y) (* 2. w z)))
    (matrix-set! res  2 (- (* 2. x z) (* 2. w y)))
    (matrix-set! res  3 0.)
    (matrix-set! res  4 (- (* 2. x y) (* 2. w z)))
    (matrix-set! res  5 (- (- 1. (* 2. x x)) (* 2. z z)))
    (matrix-set! res  6 (+ (* 2. y z) (* 2. w x)))
    (matrix-set! res  7 0.)
    (matrix-set! res  8 (+ (* 2. x z) (* 2. w y)))
    (matrix-set! res  9 (- (* 2. y z) (* 2. w x)))
    (matrix-set! res 10 (- (- 1. (* 2. x x)) (* 2. y y)))
    (matrix-set! res 11 0.)
    (matrix-set! res 12 0.)
    (matrix-set! res 13 0.)
    (matrix-set! res 14 0.)
    (matrix-set! res 15 1.))
  res)


(definition public (make-scaling-matrix s <f64vector>) <f64vector>
  (make-scaling-matrix! (make-matrix) s))


(definition public (make-scaling-matrix! res <f64vector> s <f64vector>) <f64vector>
  (make-identity-matrix! res)
  (matrix-set! res 0 (vertex-x s))
  (matrix-set! res 5 (vertex-y s))
  (matrix-set! res 10 (vertex-z s))
  res)


(definition public (make-lookat-matrix lookat <LookAt>) <f64vector>
  (make-lookat-matrix! (make-matrix) lookat))


(definition public (make-lookat-matrix! res <f64vector> lookat <LookAt>) <f64vector>
  (make-identity-matrix! res)
  (let ((sight (get-sight~ lookat))
        (up (get-up~ lookat))
        (right (get-right~ lookat)))
    (matrix-set! res 0 (- (vertex-x right))) (matrix-set! res 4 (vertex-x up)) (matrix-set! res  8 (vertex-x sight))
    (matrix-set! res 1 (- (vertex-y right))) (matrix-set! res 5 (vertex-y up)) (matrix-set! res  9 (vertex-y sight))
    (matrix-set! res 2 (- (vertex-z right))) (matrix-set! res 6 (vertex-z up)) (matrix-set! res 10 (vertex-z sight)))
  res)


(definition public (make-inverse-lookat-matrix lookat <LookAt>) <f64vector>
  (make-inverse-lookat-matrix! (make-matrix) lookat))


(definition public (make-inverse-lookat-matrix! res <f64vector> lookat <LookAt>) <f64vector>
  (make-identity-matrix! res)
  (let ((sight (get-sight~ lookat))
        (up (get-up~ lookat))
        (right (get-right~ lookat)))
    (matrix-set! res 0 (- (vertex-x right))) (matrix-set! res 1 (vertex-x up)) (matrix-set! res  2 (vertex-x sight))
    (matrix-set! res 4 (- (vertex-y right))) (matrix-set! res 5 (vertex-y up)) (matrix-set! res  6 (vertex-y sight))
    (matrix-set! res 8 (- (vertex-z right))) (matrix-set! res 9 (vertex-z up)) (matrix-set! res 10 (vertex-z sight)))
  res)


(definition public (sphere-matrices! sphere-matrix <f64vector> inverse-matrix <f64vector> origin <f64vector> lookat <LookAt> radiuses <f64vector>) <void>
  (matrix-multiply! sphere-matrix
                    (make-scaling-matrix& (vertex-inverse& radiuses))
                    (matrix-multiply& (make-inverse-lookat-matrix& lookat)
                                      (make-translation-matrix& (vertex-negate& origin))))
  (matrix-multiply! inverse-matrix
                    (make-translation-matrix& origin)
                    (matrix-multiply& (make-lookat-matrix& lookat)
                                      (make-scaling-matrix& radiuses))))


(definition public (make-projection-matrix fov <fl> ratio <fl> near <fl> far <fl>) <f64vector>
  (make-projection-matrix! (make-matrix) fov ratio near far))


(definition public (make-projection-matrix! res <f64vector> fov <fl> ratio <fl> near <fl> far <fl>) <f64vector>
  (make-identity-matrix! res)
  (let ((f (/ 1.0 (tan (* fov (/ PI 360.))))))
    (matrix-set! res  0 (/ f ratio))
    (matrix-set! res  5 f)
    (matrix-set! res 10 (/ (+ far near) (- near far)))
    (matrix-set! res 14 (/ (* 2.0 far near) (- near far)))
    (matrix-set! res 11 -1.)
    (matrix-set! res 15 0.))
  res)


(definition public (make-view-matrix position <f64vector> lookat <LookAt>) <f64vector>
  (make-view-matrix! (make-matrix) position lookat))


(definition public (make-view-matrix! res <f64vector> position <f64vector> lookat <LookAt>) <f64vector>
  (make-identity-matrix! res)
  (let* ((sight (get-sight~ lookat))
         (up (get-up~ lookat))
         (right (get-right~ lookat))
         (view (matrix (vertex-x right)     (vertex-y right)     (vertex-z right)     0.0
                       (vertex-x up)        (vertex-y up)        (vertex-z up)        0.0
                       (- (vertex-x sight)) (- (vertex-y sight)) (- (vertex-z sight)) 0.0
                       0.0                  0.0                  0.0                  1.0))
         (translate (make-translation-matrix& (vertex-negate& position))))
    (matrix-multiply! res view translate)))


;; for debugging
(definition public (matrix-translation mat <f64vector>) <f64vector>
  (vertex (matrix-ref mat 12)
          (matrix-ref mat 13)
          (matrix-ref mat 14)))


;;;
;;;; LookAt
;;;


(definition public (make-lookat) <LookAt>
  (new LookAt))


(definition public (make-standard-lookat) <LookAt>
  (let ((lookat (make-lookat)))
    (standardize-lookat! lookat)
    lookat))


(definition public (lookat=? l1 <LookAt> l2 <LookAt>) <bool>
  (and (vertex=? (get-sight~ l1) (get-sight~ l2))
       (vertex=? (get-up~ l1) (get-up~ l2))))


(definition public (lookat/=? l1 <LookAt> l2 <LookAt>) <bool>
  (or (vertex/=? (get-sight~ l1) (get-sight~ l2))
      (vertex/=? (get-up~ l1) (get-up~ l2))))


(definition public (lookat-near? l1 <LookAt> l2 <LookAt>) <bool>
  (and (vertex-near? (get-sight~ l1) (get-sight~ l2))
       (vertex-near? (get-up~ l1) (get-up~ l2))))


(definition public (lookat sight <f64vector> up <f64vector> right <f64vector>) <LookAt>
  (let ((lookat (make-lookat)))
    (set-sight~ lookat sight)
    (set-up~ lookat up)
    (set-right~ lookat right)
    lookat))


(definition public (lookat-init! lookat <LookAt> sight <f64vector> up <f64vector> right <f64vector>) <LookAt>
  (set-sight~ lookat sight)
  (set-up~ lookat up)
  (set-right~ lookat right)
  lookat)


(definition public (copy-lookat lookat <LookAt>) <LookAt>
  (let ((copy (make-lookat)))
    (set-sight~ copy (get-sight~ lookat))
    (set-up~ copy (get-up~ lookat))
    (set-right~ copy (get-right~ lookat))
    copy))


(definition public (lookat-copy! dst <LookAt> src <LookAt>) <LookAt>
  (set-sight~ dst (get-sight~ src))
  (set-up~ dst (get-up~ src))
  (set-right~ dst (get-right~ src))
  dst)


(definition public (standardize-lookat! lookat <LookAt>) <void>
  (vertex-init! (get-sight~ lookat)  0.0  0.0 -1.0)
  (vertex-init! (get-up~ lookat)     0.0  1.0  0.0)
  (vertex-init! (get-right~ lookat)  1.0  0.0  0.0))


(definition public (realign-lookat! res <LookAt> lookat <LookAt> new-up <f64vector>) <LookAt>
  (let ((old-sight (get-sight~ lookat)))
    (let ((new-right (cross-product& old-sight new-up)))
      (let ((new-sight (cross-product& new-up new-right)))
        (set-sight~ res (vertex-normalize& new-sight))
        (set-up~ res (vertex-normalize& new-up))
        (set-right~ res (vertex-normalize& new-right)))))
  res)


(definition public (realign-lookat-horizon! res <LookAt> lookat <LookAt> up <f64vector> initial-gravity final-gravity) <LookAt>
  (let ((old-sight (get-sight~ lookat)))
    (let ((new-right (cross-normal& old-sight up)))
      ;; calculate plane rotation
      (let ((angle (vector-angle (cross-normal& final-gravity new-right)
                                 (cross-normal& initial-gravity new-right))))
        (let ((new-up (vertex-normalize& (rotate-upon& (- angle) new-right (cross-normal& new-right old-sight)))))
          (set-sight~ res (cross-normal& new-up new-right))
          (set-up~ res new-up)
          (set-right~ res new-right)))))
  res)


(definition public (rotate-lookat-vertical! lookat <LookAt> angle <fl>) <void>
  (set-sight~ lookat (vertex-normalize& (rotate-upon& angle (get-right~ lookat) (get-sight~ lookat))))
  (set-up~ lookat (vertex-normalize& (rotate-upon& angle (get-right~ lookat) (get-up~ lookat)))))


(definition public (rotate-lookat-vertical-up! lookat <LookAt> angle <fl> up <f64vector>) <void>
  (let ((up-angle (vertical-angle (get-up~ lookat) up)))
    (let ((down-angle (+ PI up-angle)))
      (let ((angle (cond ((<= angle up-angle 0.) (+ up-angle .001))
                         ((>= angle (- up-angle) 0.) (- up-angle .001))
                         (else angle))))
        (set-sight~ lookat (vertex-normalize& (rotate-upon& angle (get-right~ lookat) (get-sight~ lookat))))
        (set-up~ lookat (vertex-normalize& (rotate-upon& angle (get-right~ lookat) (get-up~ lookat))))))))


(definition public (rotate-lookat! res <LookAt> lookat <LookAt> angle <fl> vert <f64vector>) <LookAt>
  (let ((sight (get-sight~ res))
        (up (get-up~ res))
        (right (get-right~ res)))
    ;; sight
    (rotate-upon! sight angle vert (get-sight~ lookat))
    (vertex-normalize! sight sight)
    ;; up
    (rotate-upon! up angle vert (get-up~ lookat))
    (vertex-normalize! up up)
    ;; right
    (rotate-upon! right angle vert (get-right~ lookat))
    (vertex-normalize! right right))
  res)


(definition public (tilt-free-up dir <f64vector>) <f64vector>
  (let ((x (vertex-x dir))
        (y (vertex-y dir))
        (z (vertex-z dir)))
    (let ((xz-norm (sqrt (+ (* x x) (* z z)))))
      (if (= xz-norm 0.)
          (vertex 0. 0. 1.)
        (let ((new-x (- (/ (* x y) xz-norm)))
              (new-z (- (/ (* z y) xz-norm))))
          (vertex new-x xz-norm new-z))))))


(definition public (remove-tilt up <f64vector> right <f64vector>) <f64vector>
  (vertex-normalize (vertex-& up (vertex-scalar*& right (dot-product right up)))))


(definition public (validate-lookat-normalized lookat <LookAt>) <void>
  (validate-vertex-normalized (get-sight~ lookat))
  (validate-vertex-normalized (get-up~ lookat))
  (validate-vertex-normalized (get-right~ lookat)))


(definition public (validate-lookat lookat <LookAt>) <void>
  (validate-lookat-normalized lookat)
  (let ((sight (get-sight~ lookat))
        (up (get-up~ lookat))
        (right (get-right~ lookat)))
    (assert (vertex-near? sight (cross-normal& up right)))
    (assert (vertex-near? up (cross-normal& right sight)))
    (assert (vertex-near? right (cross-normal& sight up)))))


(definition public (present-lookat lookat <LookAt>) <void>
  (format "~{LookAt {a} {a} {a}}"
          (present-vertex (get-sight~ lookat))
          (present-vertex (get-up~ lookat))
          (present-vertex (get-right~ lookat))))


;;;
;;;; Parallelepiped
;;;


(definition public (parallelepiped left/bottom/back <f64vector> left/bottom/front <f64vector> left/top/back <f64vector> left/top/front <f64vector> right/bottom/back <f64vector> right/bottom/front <f64vector> right/top/back <f64vector> right/top/front <f64vector>) <Parallelepiped>
  (let ((para (new Parallelepiped)))
    (set-left/bottom/back~ para left/bottom/back)
    (set-left/bottom/front~ para left/bottom/front)
    (set-left/top/back~ para left/top/back)
    (set-left/top/front~ para left/top/front)
    (set-right/bottom/back~ para right/bottom/back)
    (set-right/bottom/front~ para right/bottom/front)
    (set-right/top/back~ para right/top/back)
    (set-right/top/front~ para right/top/front)
    para))


(definition public (make-parallelepiped) <Parallelepiped>
  (new Parallelepiped))


;;;
;;;; Gravity
;;;


(definition public (gravity-up gravity <f64vector>) <f64vector>
  (vertex-scalar* (vertex-normalize& gravity) -1.))


;;;
;;;; Movement
;;;


(definition public (copy-movement mvt <Movement>) <Movement>
  (new Movement (get-origin~ mvt) (get-vector~ mvt)))


(definition public (copy-movement! dst <Movement> src <Movement>) <Movement>
  (set-origin~ dst (get-origin~ src))
  (set-vector~ dst (get-vector~ src))
  dst)


(definition public (movement-end mvt <Movement>) <f64vector>
  (vertex+ (get-origin~ mvt) (get-vector~ mvt)))


(definition public (movement-end! res <f64vector> mvt <Movement>) <f64vector>
  (vertex+! res (get-origin~ mvt) (get-vector~ mvt)))


(definition public (movement-end-to mvt <Movement> d <fl>) <f64vector>
  (vertex+ (get-origin~ mvt) (vertex-scalar*& (get-normal~ mvt) d)))


(definition public (movement-end-to! res <f64vector> mvt <Movement> d <fl>) <f64vector>
  (vertex+! res (get-origin~ mvt) (vertex-scalar*& (get-normal~ mvt) d)))


(definition public (movement-transform-3x4 mvt <Movement> matrix <f64vector>) <void>
  (let ((origin (get-origin~ mvt))
        (vector (get-vector~ mvt)))
    (let ((new-origin (matrix-transform-3x4 matrix origin)))
      (let ((new-vector (vertex-& (matrix-transform-3x4 matrix (vertex+& vector origin)) new-origin)))
        (new Movement new-origin new-vector)))))


(definition public (movement-transform-3x4! mvt <Movement> matrix <f64vector>) <void>
  (let ((origin (get-origin~ mvt))
        (vector (get-vector~ mvt)))
    (let ((new-origin (matrix-transform-3x4 matrix origin)))
      (let ((new-vector (vertex-& (matrix-transform-3x4 matrix (vertex+& vector origin)) new-origin)))
        (set-origin~ mvt new-origin)
        (set-vector~ mvt new-vector)))))


;;;
;;;; Plane
;;;


(definition public (copy-plane plane <Plane>) <Plane>
  (allocate Plane
            (copy-vertex (get-origin~ plane))
            (copy-vertex (get-normal~ plane))))


(definition public (transform-plane plane <Plane> matrix <f64vector> inverse-matrix) <Plane>
  (let ((origin (get-origin~ plane))
        (normal (get-normal~ plane)))
    (new Plane
      (matrix-transform-3x4 matrix origin)
      (transform-normal normal
                        inverse-matrix))))


(definition public (plane-to-point-distance plane <Plane> point <f64vector>) <fl>
  (dot-product (get-normal~ plane) (vertex-& point (get-origin~ plane))))


(definition public (intersect-plane plane <Plane> r <Movement>) <values>
  (let ((res (make-f64)))
    (let ((intersect? (intersect-plane! res plane r)))
      (values (f64-ref res) intersect?))))


(definition public (intersect-plane! res <f64vector> plane <Plane> r <Movement>) <bool>
  (let ((origin (get-origin~ plane))
        (normal (get-normal~ plane)))
    (let ((denom (f64-ref (dot-product& normal (get-normal~ r)))))
      (if (= denom 0.)
          (begin
            (f64-set! res 0.)
            #f)
        (let ((numer (f64-ref (dot-product& normal (get-origin~ r))))
              (distance (- (f64-ref (dot-product& origin normal)))))
          (f64-set! res (- (/ (+ numer distance) denom)))
          #t)))))


(definition public (plane-closest plane <Plane> point <f64vector>) <f64vector>
  (plane-closest! (make-vertex) plane point))


(definition public (plane-closest! res <f64vector> plane <Plane> point <f64vector>) <f64vector>
  (let ((t (plane-to-point-distance plane point)))
    (vertex-! res point (vertex-scalar*& (get-normal~ plane) t)))
  res)


;;;
;;;; Polygon
;;;


(definition public (closest-point-on-line-segment a <f64vector> b <f64vector> p <f64vector>) <values>
  (let ((pt (make-vertex)))
    (let ((edge? (closest-point-on-line-segment! pt a b p)))
      (values pt edge?))))


(definition public (closest-point-on-line-segment! res <f64vector> a <f64vector> b <f64vector> p <f64vector>) <bool>
  (let ((on-edge #t)
        (c (vertex-& p a))
        (v (vertex-normalize& (vertex-& b a))))
    (let ((t (f64-ref (dot-product& v c))))
      (if (< t 0.)
          (begin
            (vertex-copy! res a)
            (not on-edge))
        (let ((d (f64-ref (vertex-distance& b a))))
          (if (> t d)
              (begin
                (vertex-copy! res b)
                (not on-edge))
            (vertex+! res a (vertex-scalar*& v t))
            on-edge))))))


(definition public (closest-point-on-line a <f64vector> b <f64vector> p <f64vector>) <f64vector>
  (closest-point-on-line! (make-vertex) a b p))


(definition public (closest-point-on-line! res <f64vector> a <f64vector> b <f64vector> p <f64vector>) <f64vector>
  (let ((c (vertex-& p a))
        (v (vertex-normalize& (vertex-& b a))))
    (let ((t (f64-ref (dot-product& v c)))
          (d (f64-ref (vertex-distance& b a))))
      (vertex+! res a (vertex-scalar*& v t))))
  res)


;;;
;;;; Random
;;;


(definition public (random-between min <fl> max <fl>) <fl>
  (+ (* (random-real) (- max min)) min))


(definition public (random-in max <fl>) <fl>
  (- (* (random-real) max 2.) max))


(definition public (random-direction)
  (let ((x (random-between -1. 1.))
        (y (random-between -1. 1.))
        (z (random-between -1. 1.)))
    (let ((dir (vertex-normalize-safe (vertex x y z))))
      (if (vertex-zero? dir)
          (random-direction)
        dir)))))
