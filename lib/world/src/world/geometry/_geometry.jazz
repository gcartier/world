;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Geometry
;;;


(module world.geometry jazz


(export (world.geometry.classes)
        (world.geometry.syntax (phase syntax)))

(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world.geometry.classes)
        (world.geometry.syntax)
        (world.syntax))


(proclaim (warn optimizations))


;;;
;;;; Vertex
;;;


(definition public (inner-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (inner-product! res <f32vector> u <f32vector> v <f32vector>) <void>
  (f32-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v)))))


(definition public (dot-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (dot-product! res <f32vector> u <f32vector> v <f32vector>) <void>
  (f32-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v)))))


(definition public (cross-product u <f32vector> v <f32vector>) <f32vector>
  (let ((res (make-vertex)))
    (cross-product! res u v)
    res))


(definition public (cross-product! res <f32vector> u <f32vector> v <f32vector>) <void>
  (let ((a (vertex-x u))
        (b (vertex-y u))
        (c (vertex-z u))
        (d (vertex-x v))
        (e (vertex-y v))
        (f (vertex-z v)))
    (vertex-x-set! res (- (* b f) (* c e)))
    (vertex-y-set! res (- (* c d) (* a f)))
    (vertex-z-set! res (- (* a e) (* b d)))))


(definition public (vector-angle v1 <f32vector> v2 <f32vector>) <fl>
  (acos (inner-product v1 v2)))


(definition public (vertical-angle vert up)
  (- (vector-angle vert up)
     PI/2))


(definition public (plane-normal v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (let ((res (make-vertex)))
    (plane-normal! res v1 v2 v3)
    res))


(definition public (plane-normal! res <f32vector> v1 <f32vector> v2 <f32vector> v3 <f32vector>) <void>
  (cross-product! res
                  (vertex- v2 v1)
                  (vertex- v3 v1))
  (vertex-normalize! res))


(definition public (triangle-center v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3)) 3.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3)) 3.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3)) 3.)))


(definition public (quad-center v1 <f32vector> v2 <f32vector> v3 <f32vector> v4 <f32vector>) <f32vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3) (vertex-x v4)) 4.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3) (vertex-y v4)) 4.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3) (vertex-z v4)) 4.)))


(definition public (ray-triangle-distance p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <fl>
  (let ((r! (make-f32&)))
    (ray-triangle-distance! r! p d v0 v1 v2)
    (f32-ref r!)))


(definition public (ray-triangle-distance! r! <f32vector> p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <fl+>
  (let ((e1! (make-vertex&))
        (e2! (make-vertex&))
        (h! (make-vertex&))
        (a! (make-f32&))
        (s! (make-vertex&))
        (b! (make-f32&))
        (q! (make-vertex&))
        (c! (make-f32&))
        (d! (make-f32&))
        (f! (make-f32&))
        (u! (make-f32&))
        (v! (make-f32&))
        (t! (make-f32&)))
    (vertex-! e1! v1 v0)
    (vertex-! e2! v2 v0)
    (cross-product! h! d e2!)
    (inner-product! a! e1! h!)
    (if (and (> (f32-ref a!) -0.00001) (< (f32-ref a!) 0.00001))
        (f32-set! r! -1.)
      (f32-set! f! (/ 1. (f32-ref a!)))
      (vertex-! s! p v0)
      (inner-product! b! s! h!)
      (f32-set! u! (* (f32-ref f!) (f32-ref b!)))
      (if (or (< (f32-ref u!) 0.0) (> (f32-ref u!) 1.0))
          (f32-set! r! -1.)
        (cross-product! q! s! e1!)
        (inner-product! c! d q!)
        (f32-set! v! (* (f32-ref f!) (f32-ref c!)))
        (if (or (< (f32-ref v!) 0.0) (> (+ (f32-ref u!) (f32-ref v!)) 1.0))
            (f32-set! r! -1.)
          ;; at this stage we can compute t to find out where
          ;; the intersection point is on the line
          (inner-product! d! e2! q!)
          (f32-set! t! (* (f32-ref f!) (f32-ref d!)))
          (if (> (f32-ref t!) 0.00001) ;; ray intersection
              (f32-set! r! (f32-ref t!))
            ;; this means that there is a line intersection
            ;; but not a ray intersection
            (f32-set! r! -1.)))))))


(definition public (ray-intersects-triangle? p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <bool>
  (let ((d! (make-f32&)))
    (ray-triangle-distance! d! p d v0 v1 v2)
    (/= (f32-ref d!) -1.)))


(definition public (ray-intersects-sphere? p <f32vector> d <f32vector> s <f32vector> r <fl>) <bool>
  (let ((t! (make-vertex&))
        (i! (make-f32&))
        (j! (make-f32&))
        (b! (make-f32&))
        (det! (make-f32&)))
    (vertex-! t! p s)
    (inner-product! i! t! d)
    (f32-set! b! (- (f32-ref i!)))
    (inner-product! j! t! t!)
    (f32-set! det! (+ (- (* (f32-ref b!) (f32-ref b!)) (f32-ref j!)) (* r r)))
    (if (< (f32-ref det!) 0.)
        #f
      (f32-set! det! (sqrt (f32-ref det!)))
      (let ((i (+ (f32-ref b!) (f32-ref det!))))
        (>= i 0.)))))


;;;
;;;; OpenGL
;;;


(definition public (gl-plane-normal v1 v2 v3)
  (let ((normal (plane-normal v1 v2 v3)))
    (glNormal3f (vertex-x normal)
                (vertex-y normal)
                (vertex-z normal))))


;;;
;;;; Random
;;;


(definition public (random-in max)
  (- (* (random-real) max 2) max)))
