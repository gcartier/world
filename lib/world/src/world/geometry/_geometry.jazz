;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Geometry
;;;


(module world.geometry jazz


(export (world.geometry.base)
        (world.geometry.classes)
        (world.geometry.syntax (phase syntax)))

(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world.geometry.base)
        (world.geometry.classes)
        (world.geometry.syntax (phase syntax))
        (world.homogeneous)
        (world.lookat)
        (world.movement)
        (world.plane)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Vertex
;;;


(definition public (vertex-distance v1 <f32vector> v2 <f32vector>) <fl>
  (vertex-norm (vertex- v2 v1)))


(definition public (vertex-distance! res <f32vector> v1 <f32vector> v2 <f32vector>) <f32vector>
  (vertex-norm! res (vertex-& v2 v1))
  res)


(definition public (rotate-upon angle <fl> u <f32vector> v <f32vector>) <f32vector>
  (rotate-upon! (make-vertex) angle u v))


(definition public (rotate-upon! res <f32vector> angle <fl> u <f32vector> v <f32vector>) <f32vector>
  (let ((c <fl> (cos angle))
        (s <fl> (sin angle))
        (x (vertex-x u))
        (y (vertex-y u))
        (z (vertex-z u))
        (i (vertex-x v))
        (j (vertex-y v))
        (k (vertex-z v)))
    (vertex-x-set! res (+ (* i (+ (* x x (- 1. c)) c))
                          (* j (- (* x y (- 1. c)) (* z s)))
                          (* k (+ (* x z (- 1. c)) (* y s)))))
    (vertex-y-set! res (+ (* i (+ (* y x (- 1. c)) (* z s)))
                          (* j (+ (* y y (- 1. c)) c))
                          (* k (- (* y z (- 1. c)) (* x s)))))
    (vertex-z-set! res (+ (* i (- (* x z (- 1. c)) (* y s)))
                          (* j (+ (* y z (- 1. c)) (* x s)))
                          (* k (+ (* z z (- 1. c)) c)))))
  res)


(definition public (inner-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (inner-product! res <f32vector> u <f32vector> v <f32vector>) <f32vector>
  (f32-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v))))
  res)


(definition public (dot-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (dot-product! res <f32vector> u <f32vector> v <f32vector>) <f32vector>
  (f32-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v))))
  res)


(definition public (cross-product u <f32vector> v <f32vector>) <f32vector>
  (let ((res (make-vertex)))
    (cross-product! res u v)
    res))


(definition public (cross-product! res <f32vector> u <f32vector> v <f32vector>) <f32vector>
  (let ((a (vertex-x u))
        (b (vertex-y u))
        (c (vertex-z u))
        (d (vertex-x v))
        (e (vertex-y v))
        (f (vertex-z v)))
    (vertex-x-set! res (- (* b f) (* c e)))
    (vertex-y-set! res (- (* c d) (* a f)))
    (vertex-z-set! res (- (* a e) (* b d))))
  res)


(definition public (vector-angle v1 <f32vector> v2 <f32vector>) <fl>
  (acos (inner-product v1 v2)))


(definition public (vertical-angle vert up)
  (- (vector-angle vert up)
     PI/2))


(definition public (plane-normal v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (plane-normal! (make-vertex) v1 v2 v3))


(definition public (plane-normal! res <f32vector> v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (cross-product! res
                  (vertex- v2 v1)
                  (vertex- v3 v1))
  (vertex-normalize! res res)
  res)


(definition public (plane-normal-safe v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (plane-normal-safe! (make-vertex) v1 v2 v3))


(definition public (plane-normal-safe! res <f32vector> v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (cross-product! res
                  (vertex- v2 v1)
                  (vertex- v3 v1))
  (vertex-normalize-safe! res res)
  res)


(definition public (triangle-center v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3)) 3.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3)) 3.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3)) 3.)))


(definition public (quad-center v1 <f32vector> v2 <f32vector> v3 <f32vector> v4 <f32vector>) <f32vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3) (vertex-x v4)) 4.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3) (vertex-y v4)) 4.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3) (vertex-z v4)) 4.)))


(definition public (center-of-mass vertices <vector>) <f32vector>
  (center-of-mass! (make-vertex) vertices))


(definition public (center-of-mass! res <f32vector> vertices <vector>) <f32vector>
  (vertex-init! res 0. 0. 0.)
  (loop (for vertex in-vector vertices)
        (vertex+! res res vertex))
  (vertex-scalar*! res res (/ 1. (vector-length vertices))))


(definition public (ray-triangle-distance p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <fl>
  (f32-ref (ray-triangle-distance! (make-f32&) p d v0 v1 v2)))


(definition public (ray-triangle-distance! res <f32vector> p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <f32vector>
  (let ((e1 (vertex-& v1 v0))
        (e2 (vertex-& v2 v0)))
    (let ((h (cross-product& d e2)))
      (let ((a (inner-product& e1 h)))
        (if (and (> (f32-ref a) -0.00001) (< (f32-ref a) 0.00001))
            (f32-set! res -1.)
          (let ((f (f32& (/ 1. (f32-ref a))))
                (s (vertex-& p v0)))
            (let ((b (inner-product& s h)))
              (let ((u (f32& (* (f32-ref f) (f32-ref b)))))
                (if (or (< (f32-ref u) 0.0) (> (f32-ref u) 1.0))
                    (f32-set! res -1.)
                  (let ((q (cross-product& s e1)))
                    (let ((c (inner-product& d q)))
                      (let ((v (f32& (* (f32-ref f) (f32-ref c)))))
                        (if (or (< (f32-ref v) 0.0) (> (+ (f32-ref u) (f32-ref v)) 1.0))
                            (f32-set! res -1.)
                          ;; at this stage we can compute t to find out where
                          ;; the intersection point is on the line
                          (let ((d (inner-product& e2 q)))
                            (let ((t (f32& (* (f32-ref f) (f32-ref d)))))
                              (if (> (f32-ref t) 0.00001) ;; ray intersection
                                  (f32-set! res (f32-ref t))
                                ;; this means that there is a line intersection
                                ;; but not a ray intersection
                                (f32-set! res -1.))))))))))))))))
  res)


(definition public (ray-intersects-triangle? p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <bool>
  (let ((d (make-f32&)))
    (ray-triangle-distance! d p d v0 v1 v2)
    (/= (f32-ref d) -1.)))


(definition public (ray-intersects-sphere? p <f32vector> d <f32vector> s <f32vector> r <fl>) <bool>
  (let ((t (vertex-& p s)))
    (let ((i (inner-product& t d)))
      (let ((b (f32& (- (f32-ref i)))))
        (let ((j (inner-product& t t)))
          (let ((det (f32& (+ (- (* (f32-ref b) (f32-ref b)) (f32-ref j)) (* r r)))))
            (if (< (f32-ref det) 0.)
                #f
              (f32-set! det (sqrt (f32-ref det)))
              (let ((i (+ (f32-ref b) (f32-ref det))))
                (>= i 0.)))))))))


;;;
;;;; Quaternion
;;;


(definition public (translate-matrix! res <f32vector> trans <f32vector>) <f32vector>
  (declare (optimize-dead-local-variables))
  (matrix-set! res 12 (vertex-x trans))
  (matrix-set! res 13 (vertex-y trans))
  (matrix-set! res 14 (vertex-z trans))
  res)


(definition public (angle-matrix! res <f32vector> angles <f32vector>) <f32vector>
  (declare (optimize-dead-local-variables))
  (let ((rx (vertex-x angles))
        (ry (vertex-y angles))
        (rz (vertex-z angles)))
    (let ((sr (sin rx))
          (sp (sin ry))
          (sy (sin rz))
          (cr (cos rx))
          (cp (cos ry))
          (cy (cos rz)))
      ;; res = (Z * Y) * X
      (matrix-set! res  0 (* cp cy))
      (matrix-set! res  1 (* cp sy))
      (matrix-set! res  2 (- sp))
      (matrix-set! res  4 (+ (* (* sr sp) cy) (* cr (- sy))))
      (matrix-set! res  5 (+ (* (* sr sp) sy) (* cr cy)))
      (matrix-set! res  6 (* sr cp))
      (matrix-set! res  8 (+ (* (* cr sp) cy) (* (- sr) (- sy))))
      (matrix-set! res  9 (+ (* (* cr sp) sy) (* (- sr) cy)))
      (matrix-set! res 10 (* cr cp))
      (matrix-set! res 12 0.)
      (matrix-set! res 13 0.)
      (matrix-set! res 14 0.)))
  res)


(definition public (angle-quaternion! res <f32vector> angles <f32vector>) <f32vector>
  (declare (optimize-dead-local-variables))
  (let ((rx (vertex-x angles))
        (ry (vertex-y angles))
        (rz (vertex-z angles)))
    (let ((sr (sin (* rx .5)))
          (sp (sin (* ry .5)))
          (sy (sin (* rz .5)))
          (cr (cos (* rx .5)))
          (cp (cos (* ry .5)))
          (cy (cos (* rz .5))))
      (quaternion-x-set! res (- (* sr cp cy) (* cr sp sy)))
      (quaternion-y-set! res (+ (* cr sp cy) (* sr cp sy)))
      (quaternion-z-set! res (- (* cr cp sy) (* sr sp cy)))
      (quaternion-w-set! res (+ (* cr cp cy) (* sr sp sy)))))
  res)


(definition public (quaternion-matrix! res <f32vector> quat <f32vector>) <f32vector>
  (declare (optimize-dead-local-variables))
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (matrix-set! res  0 (- (- 1. (* 2. y y)) (* 2. z z)))
    (matrix-set! res  1 (+ (* 2. x y) (* 2. w z)))
    (matrix-set! res  2 (- (* 2. x z) (* 2. w y)))
    (matrix-set! res  4 (- (* 2. x y) (* 2. w z)))
    (matrix-set! res  5 (- (- 1. (* 2. x x)) (* 2. z z)))
    (matrix-set! res  6 (+ (* 2. y z) (* 2. w x)))
    (matrix-set! res  8 (+ (* 2. x z) (* 2. w y)))
    (matrix-set! res  9 (- (* 2. y z) (* 2. w x)))
    (matrix-set! res 10 (- (- 1. (* 2. x x)) (* 2. y y))))
  res)


(definition public (quaternion-slerp! res <f32vector> p <f32vector> q <f32vector> t <fl>) <f32vector>
  (declare (optimize-dead-local-variables))
  ;; decide if one of the quaternions is backwards
  (let ((a (f32& 0.))
        (b (f32& 0.)))
    (for (i 0 4)
         (let ((pi (f32vector-ref p i))
               (qi (f32vector-ref q i)))
           (f32-set! a (+ (f32-ref a) (* (- pi qi) (- pi qi))))
           (f32-set! b (+ (f32-ref b) (* (+ pi qi) (+ pi qi))))))
    (when (> (f32-ref a) (f32-ref b))
      (for (i 0 4)
           (f32vector-set! q i (- (f32vector-ref q i)))))
    (let ((cosom
            (f32& (+ (* (quaternion-x p) (quaternion-x q))
                     (* (quaternion-y p) (quaternion-y q))
                     (* (quaternion-z p) (quaternion-z q))
                     (* (quaternion-w p) (quaternion-w q))))))
      (if (> (+ 1. (f32-ref cosom)) 1e-8)
          (let ((sclp (make-f32&))
                (sclq (make-f32&)))
            (if (> (- 1. (f32-ref cosom)) 1e-8)
                (let ((omega (cast <fl> (acos (f32-ref cosom)))))
                  (let ((sinom (sin omega)))
                    (f32-set! sclp (/ (sin (* (- 1. t) omega)) sinom))
                    (f32-set! sclq (/ (sin (* t omega)) sinom))))
              (begin
                (f32-set! sclp (- 1. t))
                (f32-set! sclq t)))
            (for (i 0 4)
                 (f32vector-set! res i (+ (* (f32-ref sclp) (f32vector-ref p i))
                                          (* (f32-ref sclq) (f32vector-ref q i))))))
        (quaternion-x-set! res (- (quaternion-y p)))
        (quaternion-y-set! res (quaternion-x p))
        (quaternion-z-set! res (- (quaternion-w p)))
        (quaternion-w-set! res (quaternion-z p))
        (let ((sclp (sin (* (- 1. t) .5 PI)))
              (sclq (sin (* t .5 PI))))
          (for (i 0 3)
               (f32vector-set! res i (+ (* sclp (f32vector-ref p i))
                                        (* sclq (f32vector-ref res i)))))))))
  res)


;;;
;;;; Cuboid
;;;


(definition public (cuboid-size cuboid <f32vector>) <f32vector>
  (vertex (- (cuboid-right cuboid) (cuboid-left cuboid))
          (- (cuboid-top cuboid) (cuboid-bottom cuboid))
          (- (cuboid-front cuboid) (cuboid-back cuboid))))


(definition public (cuboid-radiuses cuboid <f32vector>) <f32vector>
  (vertex (/ (- (cuboid-right cuboid) (cuboid-left cuboid)) 2.)
          (/ (- (cuboid-top cuboid) (cuboid-bottom cuboid)) 2.)
          (/ (- (cuboid-front cuboid) (cuboid-back cuboid)) 2.)))


;;;
;;;; Matrix Operations
;;;


(definition public (make-identity-matrix) <f32vector>
  (make-identity-matrix! (make-matrix)))


(definition public (make-identity-matrix! res <f32vector>) <f32vector>
  (matrix-set! res  0 1.)
  (matrix-set! res  1 0.)
  (matrix-set! res  2 0.)
  (matrix-set! res  3 0.)
  (matrix-set! res  4 0.)
  (matrix-set! res  5 1.)
  (matrix-set! res  6 0.)
  (matrix-set! res  7 0.)
  (matrix-set! res  8 0.)
  (matrix-set! res  9 0.)
  (matrix-set! res 10 1.)
  (matrix-set! res 11 0.)
  (matrix-set! res 12 0.)
  (matrix-set! res 13 0.)
  (matrix-set! res 14 0.)
  (matrix-set! res 15 1.)
  res)


(definition public (matrix-transpose-3x3! dst <f32vector> src <f32vector>) <void>
  (matrix-set! dst 0 (matrix-ref src 0))
  (matrix-set! dst 1 (matrix-ref src 4))
  (matrix-set! dst 2 (matrix-ref src 8))
  (matrix-set! dst 4 (matrix-ref src 1))
  (matrix-set! dst 5 (matrix-ref src 5))
  (matrix-set! dst 6 (matrix-ref src 9))
  (matrix-set! dst 8 (matrix-ref src 2))
  (matrix-set! dst 9 (matrix-ref src 6))
  (matrix-set! dst 10 (matrix-ref src 10)))


(definition public (matrix-multiply a <f32vector> b <f32vector>) <f32vector>
  (matrix-multiply! (make-matrix) a b))


(definition public (matrix-multiply! res <f32vector> a <f32vector> b <f32vector>) <f32vector>
  (let ((a0 (matrix-ref a 0)) (a4 (matrix-ref a 4)) (a8  (matrix-ref a 8))  (a12 (matrix-ref a 12))
        (a1 (matrix-ref a 1)) (a5 (matrix-ref a 5)) (a9  (matrix-ref a 9))  (a13 (matrix-ref a 13))
        (a2 (matrix-ref a 2)) (a6 (matrix-ref a 6)) (a10 (matrix-ref a 10)) (a14 (matrix-ref a 14))
        (a3 (matrix-ref a 3)) (a7 (matrix-ref a 7)) (a11 (matrix-ref a 11)) (a15 (matrix-ref a 15))
        (b0 (matrix-ref b 0)) (b4 (matrix-ref b 4)) (b8  (matrix-ref b 8))  (b12 (matrix-ref b 12))
        (b1 (matrix-ref b 1)) (b5 (matrix-ref b 5)) (b9  (matrix-ref b 9))  (b13 (matrix-ref b 13))
        (b2 (matrix-ref b 2)) (b6 (matrix-ref b 6)) (b10 (matrix-ref b 10)) (b14 (matrix-ref b 14))
        (b3 (matrix-ref b 3)) (b7 (matrix-ref b 7)) (b11 (matrix-ref b 11)) (b15 (matrix-ref b 15)))
    (matrix-set! res  0 (+ (* a0 b0)  (* a4 b1)  (* a8 b2)   (* a12 b3)))
    (matrix-set! res  4 (+ (* a0 b4)  (* a4 b5)  (* a8 b6)   (* a12 b7)))
    (matrix-set! res  8 (+ (* a0 b8)  (* a4 b9)  (* a8 b10)  (* a12 b11)))
    (matrix-set! res 12 (+ (* a0 b12) (* a4 b13) (* a8 b14)  (* a12 b15)))
    (matrix-set! res  1 (+ (* a1 b0)  (* a5 b1)  (* a9 b2)   (* a13 b3)))
    (matrix-set! res  5 (+ (* a1 b4)  (* a5 b5)  (* a9 b6)   (* a13 b7)))
    (matrix-set! res  9 (+ (* a1 b8)  (* a5 b9)  (* a9 b10)  (* a13 b11)))
    (matrix-set! res 13 (+ (* a1 b12) (* a5 b13) (* a9 b14)  (* a13 b15)))
    (matrix-set! res  2 (+ (* a2 b0)  (* a6 b1)  (* a10 b2)  (* a14 b3)))
    (matrix-set! res  6 (+ (* a2 b4)  (* a6 b5)  (* a10 b6)  (* a14 b7)))
    (matrix-set! res 10 (+ (* a2 b8)  (* a6 b9)  (* a10 b10) (* a14 b11)))
    (matrix-set! res 14 (+ (* a2 b12) (* a6 b13) (* a10 b14) (* a14 b15)))
    (matrix-set! res  3 (+ (* a3 b0)  (* a7 b1)  (* a11 b2)  (* a15 b3)))
    (matrix-set! res  7 (+ (* a3 b4)  (* a7 b5)  (* a11 b6)  (* a15 b7)))
    (matrix-set! res 11 (+ (* a3 b8)  (* a7 b9)  (* a11 b10) (* a15 b11)))
    (matrix-set! res 15 (+ (* a3 b12) (* a7 b13) (* a11 b14) (* a15 b15))))
  res)


(definition public (matrix-tranform mat <f32vector> vert <f32vector>) <f32vector>
  (matrix-tranform! (make-vertex) mat vert))


(definition public (matrix-tranform! res <f32vector> mat <f32vector> vert <f32vector>) <f32vector>
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    (let ((s (+ (* (matrix-ref mat 3) x) (* (matrix-ref mat 7) y) (* (matrix-ref mat 11) z) (matrix-ref mat 15))))
      (vertex-x-set! res (/ (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)) s))
      (vertex-y-set! res (/ (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)) s))
      (vertex-z-set! res (/ (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14)) s))))
  res)


(definition public (make-translation-matrix tx <fl> ty <fl> tz <fl>) <f32vector>
  (make-translation-matrix! (make-matrix) tx ty tz))


(definition public (make-translation-matrix! res <f32vector> tx <fl> ty <fl> tz <fl>) <f32vector>
  (make-identity-matrix! res)
  (matrix-set! res 12 tx)
  (matrix-set! res 13 ty)
  (matrix-set! res 14 tz)
  res)


(definition public (make-x-rotation-matrix phi <fl>) <f32vector>
  (make-x-rotation-matrix! (make-matrix) phi))


(definition public (make-x-rotation-matrix! res <f32vector> phi <fl>) <f32vector>
  (make-identity-matrix! res)
  (let ((cos (cos phi))
        (sin (sin phi)))
    (matrix-set! res 5 cos)
    (matrix-set! res 6 (- sin))
    (matrix-set! res 9 sin)
    (matrix-set! res 10 cos))
  res)


(definition public (make-y-rotation-matrix theta <fl>) <f32vector>
  (make-y-rotation-matrix! (make-matrix) theta))


(definition public (make-y-rotation-matrix! res <f32vector> theta <fl>) <f32vector>
  (make-identity-matrix! res)
  (let ((cos (cos theta))
        (sin (sin theta)))
    (matrix-set! res 0 cos)
    (matrix-set! res 2 sin)
    (matrix-set! res 8 (- sin))
    (matrix-set! res 10 cos))
  res)


(definition public (make-z-rotation-matrix psi <fl>) <f32vector>
  (make-z-rotation-matrix! (make-matrix) psi))


(definition public (make-z-rotation-matrix! res <f32vector> psi <fl>) <f32vector>
  (make-identity-matrix! res)
  (let ((cos (cos psi))
        (sin (sin psi)))
    (matrix-set! res 0 cos)
    (matrix-set! res 1 (- sin))
    (matrix-set! res 4 sin)
    (matrix-set! res 5 cos))
  res)


(definition public (make-rotation-matrix rx <fl> ry <fl> rz <fl>) <f32vector>
  (make-rotation-matrix! (make-matrix) rx ry rz))


(definition public (make-rotation-matrix! res <f32vector> rx <fl> ry <fl> rz <fl>) <f32vector>
  (matrix-multiply! res
                    (make-x-rotation-matrix& rx)
                    (matrix-multiply& (make-y-rotation-matrix& ry)
                                      (make-z-rotation-matrix& rz))))


(definition public (make-scaling-matrix sx <fl> sy <fl> sz <fl>) <f32vector>
  (make-scaling-matrix! (make-matrix) sx sy sz))


(definition public (make-scaling-matrix! res <f32vector> sx <fl> sy <fl> sz <fl>) <f32vector>
  (make-identity-matrix! res)
  (matrix-set! res 0 sx)
  (matrix-set! res 5 sy)
  (matrix-set! res 10 sz)
  res)


(definition public (make-lookat-matrix lookat <LookAt>) <f32vector>
  (make-lookat-matrix! (make-matrix) lookat))


(definition public (make-lookat-matrix! res <f32vector> lookat <LookAt>) <f32vector>
  (make-identity-matrix! res)
  (let ((sight (get-sight~ lookat))
        (up (get-up~ lookat))
        (right (get-right~ lookat)))
    (matrix-set! res 0 (vertex-x right)) (matrix-set! res 4 (vertex-x up)) (matrix-set! res  8 (vertex-x sight))
    (matrix-set! res 1 (vertex-y right)) (matrix-set! res 5 (vertex-y up)) (matrix-set! res  9 (vertex-y sight))
    (matrix-set! res 2 (vertex-z right)) (matrix-set! res 6 (vertex-z up)) (matrix-set! res 10 (vertex-z sight)))
  res)


(definition public (make-projection-matrix fov <fl> ratio <fl> near <fl> far <fl>) <f32vector>
  (make-projection-matrix! (make-identity-matrix) fov ratio near far))


(definition public (make-projection-matrix! res <f32vector> fov <fl> ratio <fl> near <fl> far <fl>) <f32vector>
  (let ((f (/ 1.0 (tan (* fov (/ PI 360.))))))
    (matrix-set! res  0 (/ f ratio))
    (matrix-set! res  5 f)
    (matrix-set! res 10 (/ (+ far near) (- near far)))
    (matrix-set! res 14 (/ (* 2.0 far near) (- near far)))
    (matrix-set! res 11 -1.)
    (matrix-set! res 15 0.))
  res)


(definition public (make-view-matrix position <f32vector> lookat <LookAt>) <f32vector>
  (make-view-matrix! (make-identity-matrix) position lookat))


(definition public (make-view-matrix! res <f32vector> position <f32vector> lookat <LookAt>) <f32vector>
  (let* ((sight (get-sight~ lookat))
         (up (get-up~ lookat))
         (right (get-right~ lookat))
         (view (matrix (vertex-x right)     (vertex-y right)     (vertex-z right)     0.0
                       (vertex-x up)        (vertex-y up)        (vertex-z up)        0.0
                       (- (vertex-x sight)) (- (vertex-y sight)) (- (vertex-z sight)) 0.0
                       0.0                  0.0                  0.0                  1.0))
         (translate (make-translation-matrix (- (vertex-x position))
                                             (- (vertex-y position))
                                             (- (vertex-z position)))))
    (matrix-multiply! res view translate)))


;;;
;;;; LookAt
;;;


(definition public (make-lookat) <LookAt>
  (new LookAt))


(definition public (make-standard-lookat) <LookAt>
  (let ((lookat (make-lookat)))
    (standardize-lookat! lookat)
    lookat))


(definition public (copy-lookat lookat <LookAt>) <LookAt>
  (let ((copy (make-lookat)))
    (set-sight~ copy (get-sight~ lookat))
    (set-up~ copy (get-up~ lookat))
    (set-right~ copy (get-right~ lookat))
    copy))


(definition public (standardize-lookat! lookat <LookAt>) <void>
  (vertex-init! (get-sight~ lookat) 0.0  0.0 -1.0)
  (vertex-init! (get-up~ lookat)    0.0  1.0  0.0)
  (vertex-init! (get-right~ lookat) 1.0  0.0  0.0))


(definition public (rotate-lookat! lookat <LookAt> angle <fl> vert <f32vector>) <void>
  (let ((sight (get-sight~ lookat))
        (up (get-up~ lookat))
        (right (get-right~ lookat)))
    ;; sight
    (rotate-upon! sight angle vert sight)
    (vertex-normalize! sight sight)
    ;; up
    (rotate-upon! up angle vert up)
    (vertex-normalize! up up)
    ;; right
    (rotate-upon! right angle vert right)
    (vertex-normalize! right right)))


(definition public (validate-lookat-normalized lookat <LookAt>) <void>
  (define (validate vert)
    (unless (near? (vertex-norm vert) 1. .0001)
      (error "Vertex {s} is not normalized" vert)))
  
  (validate (get-sight~ lookat))
  (validate (get-up~ lookat))
  (validate (get-right~ lookat)))


;;;
;;;; Movement
;;;


(definition public (movement-end mvt <Movement>) <f32vector>
  (vertex+ (get-origin~ mvt) (get-vector~ mvt)))


(definition public (movement-end-to mvt <Movement> d <fl>) <f32vector>
  (vertex+ (get-origin~ mvt) (vertex-scalar*& (get-normal~ mvt) d)))


;;;
;;;; Plane
;;;


(definition public (plane-to-point-distance plane <Plane> point <f32vector>) <fl>
  @new-alain-code-that-doesnt-work-as-is
  (dot-product (get-normal~ plane) (vertex- point (get-origin~ plane)))
  (let ((res (make-f32)))
    (intersect-plane! res plane (new Movement point (vertex-negate (get-normal~ plane))))
    (f32-ref res)))


(definition public (intersect-plane plane <Plane> r <Movement>) <values>
  (let ((res (make-f32)))
    (let ((intersect? (intersect-plane! res plane r)))
      (values (f32-ref res) intersect?))))


(definition public (intersect-plane! res <f32vector> plane <Plane> r <Movement>) <bool>
  (let ((origin (get-origin~ plane))
        (normal (get-normal~ plane)))
    (let ((denom (f32-ref (dot-product& normal (get-normal~ r)))))
      (if (= denom 0.)
          (begin
            (f32-set! res 0.)
            #f)
        (let ((numer (f32-ref (dot-product& normal (get-origin~ r))))
              (distance (- (f32-ref (dot-product& origin normal)))))
          (f32-set! res (- (/ (+ numer distance) denom)))
          #t)))))


(definition public (plane-closest plane <Plane> point <f32vector>) <f32vector>
  (plane-closest! (make-vertex) plane point))


(definition public (plane-closest! res <f32vector> plane <Plane> point <f32vector>) <f32vector>
  (let ((t (plane-to-point-distance plane point)))
    (vertex-! res point (vertex-scalar*& (get-normal~ plane) t)))
  res)


;;;
;;;; Polygon
;;;


(definition public (closest-point-on-line-segment a <f32vector> b <f32vector> p <f32vector>) <values>
  (let ((pt (make-vertex)))
    (let ((edge? (closest-point-on-line-segment! pt a b p)))
      (values pt edge?))))


(definition public (closest-point-on-line-segment! res <f32vector> a <f32vector> b <f32vector> p <f32vector>) <bool>
  (let ((on-edge #t)
        (c (vertex-& p a))
        (v (vertex-normalize& (vertex-& b a))))
    (let ((t (f32-ref (dot-product& v c))))
      (if (< t 0.)
          (begin
            (vertex-copy! res a)
            (not on-edge))
        (let ((d (f32-ref (vertex-distance& b a))))
          (if (> t d)
              (begin
                (vertex-copy! res b)
                (not on-edge))
            (vertex+! res a (vertex-scalar*& v t))
            on-edge))))))


(definition public (closest-point-on-line a <f32vector> b <f32vector> p <f32vector>) <f32vector>
  (closest-point-on-line! (make-vertex) a b p))


(definition public (closest-point-on-line! res <f32vector> a <f32vector> b <f32vector> p <f32vector>) <f32vector>
  (let ((c (vertex-& p a))
        (v (vertex-normalize& (vertex-& b a))))
    (let ((t (f32-ref (dot-product& v c)))
          (d (f32-ref (vertex-distance& b a))))
      (vertex+! res a (vertex-scalar*& v t))))
  res)


;;;
;;;; Random
;;;


(definition public (random-in max <fl>) <fl>
  (- (* (random-real) max 2.) max)))
