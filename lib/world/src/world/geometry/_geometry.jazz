;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Geometry
;;;


(module world.geometry jazz


(export (world.geometry.base)
        (world.geometry.classes)
        (world.geometry.syntax (phase syntax)))

(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world.geometry.base)
        (world.geometry.classes)
        (world.geometry.syntax (phase syntax))
        (world.lookat)
        (world.movement)
        (world.plane)
        (world.syntax))


(proclaim (warn optimizations))


;;;
;;;; Vertex
;;;


(definition public (vertex-distance v1 <f32vector> v2 <f32vector>) <fl>
  (vertex-norm (vertex- v2 v1)))


(definition public (vertex-distance! res <f32vector> v1 <f32vector> v2 <f32vector>) <f32vector>
  (vertex-norm! res (vertex-& v2 v1))
  res)


(definition public (rotate-upon angle <fl> u <f32vector> v <f32vector>) <f32vector>
  (rotate-upon! (make-vertex) angle u v))


(definition public (rotate-upon! res <f32vector> angle <fl> u <f32vector> v <f32vector>) <f32vector>
  (let ((c <fl> (cos angle))
        (s <fl> (sin angle))
        (x (vertex-x u))
        (y (vertex-y u))
        (z (vertex-z u))
        (i (vertex-x v))
        (j (vertex-y v))
        (k (vertex-z v)))
    (vertex-x-set! res (+ (* i (+ (* x x (- 1. c)) c))
                          (* j (- (* x y (- 1. c)) (* z s)))
                          (* k (+ (* x z (- 1. c)) (* y s)))))
    (vertex-y-set! res (+ (* i (+ (* y x (- 1. c)) (* z s)))
                          (* j (+ (* y y (- 1. c)) c))
                          (* k (- (* y z (- 1. c)) (* x s)))))
    (vertex-z-set! res (+ (* i (- (* x z (- 1. c)) (* y s)))
                          (* j (+ (* y z (- 1. c)) (* x s)))
                          (* k (+ (* z z (- 1. c)) c)))))
  res)


(definition public (inner-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (inner-product! res <f32vector> u <f32vector> v <f32vector>) <f32vector>
  (f32-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v))))
  res)


(definition public (dot-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (dot-product! res <f32vector> u <f32vector> v <f32vector>) <f32vector>
  (f32-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v))))
  res)


(definition public (cross-product u <f32vector> v <f32vector>) <f32vector>
  (let ((res (make-vertex)))
    (cross-product! res u v)
    res))


(definition public (cross-product! res <f32vector> u <f32vector> v <f32vector>) <f32vector>
  (let ((a (vertex-x u))
        (b (vertex-y u))
        (c (vertex-z u))
        (d (vertex-x v))
        (e (vertex-y v))
        (f (vertex-z v)))
    (vertex-x-set! res (- (* b f) (* c e)))
    (vertex-y-set! res (- (* c d) (* a f)))
    (vertex-z-set! res (- (* a e) (* b d))))
  res)


(definition public (vector-angle v1 <f32vector> v2 <f32vector>) <fl>
  (acos (inner-product v1 v2)))


(definition public (vertical-angle vert up)
  (- (vector-angle vert up)
     PI/2))


(definition public (plane-normal v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (plane-normal! (make-vertex) v1 v2 v3))


(definition public (plane-normal! res <f32vector> v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (cross-product! res
                  (vertex- v2 v1)
                  (vertex- v3 v1))
  (vertex-normalize! res res)
  res)


(definition public (triangle-center v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3)) 3.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3)) 3.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3)) 3.)))


(definition public (quad-center v1 <f32vector> v2 <f32vector> v3 <f32vector> v4 <f32vector>) <f32vector>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3) (vertex-x v4)) 4.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3) (vertex-y v4)) 4.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3) (vertex-z v4)) 4.)))


(definition public (ray-triangle-distance p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <fl>
  (f32-ref (ray-triangle-distance! (make-f32&) p d v0 v1 v2)))


(definition public (ray-triangle-distance! res <f32vector> p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <f32vector>
  (let ((e1 (vertex-& v1 v0))
        (e2 (vertex-& v2 v0)))
    (let ((h (cross-product& d e2)))
      (let ((a (inner-product& e1 h))
            (f (make-f32&))
            (u (make-f32&))
            (v (make-f32&))
            (t (make-f32&)))
        (if (and (> (f32-ref a) -0.00001) (< (f32-ref a) 0.00001))
            (f32-set! res -1.)
          (f32-set! f (/ 1. (f32-ref a)))
          (let ((s (vertex-& p v0)))
            (let ((b (inner-product& s h)))
              (f32-set! u (* (f32-ref f) (f32-ref b)))
              (if (or (< (f32-ref u) 0.0) (> (f32-ref u) 1.0))
                  (f32-set! res -1.)
                (let ((q (cross-product& s e1)))
                  (let ((c (inner-product& d q)))
                    (f32-set! v (* (f32-ref f) (f32-ref c)))
                    (if (or (< (f32-ref v) 0.0) (> (+ (f32-ref u) (f32-ref v)) 1.0))
                        (f32-set! res -1.)
                      ;; at this stage we can compute t to find out where
                      ;; the intersection point is on the line
                      (let ((d (inner-product& e2 q)))
                        (f32-set! t (* (f32-ref f) (f32-ref d)))
                        (if (> (f32-ref t) 0.00001) ;; ray intersection
                            (f32-set! res (f32-ref t))
                          ;; this means that there is a line intersection
                          ;; but not a ray intersection
                          (f32-set! res -1.)))))))))))))
  res)


(definition public (ray-intersects-triangle? p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <bool>
  (let ((d (make-f32&)))
    (ray-triangle-distance! d p d v0 v1 v2)
    (/= (f32-ref d) -1.)))


(definition public (ray-intersects-sphere? p <f32vector> d <f32vector> s <f32vector> r <fl>) <bool>
  (let ((t (vertex-& p s)))
    (let ((i (inner-product& t d))
          (b (make-f32&))
          (det (make-f32&)))
      (f32-set! b (- (f32-ref i)))
      (let ((j (inner-product& t t)))
        (f32-set! det (+ (- (* (f32-ref b) (f32-ref b)) (f32-ref j)) (* r r)))
        (if (< (f32-ref det) 0.)
            #f
          (f32-set! det (sqrt (f32-ref det)))
          (let ((i (+ (f32-ref b) (f32-ref det))))
            (>= i 0.)))))))


;;;
;;;; Matrix Operations
;;;


(definition public (make-identity-matrix) <f32vector>
  (make-identity-matrix! (make-matrix)))


(definition public (make-identity-matrix! res <f32vector>) <f32vector>
  (matrix-set! res  0 1.)
  (matrix-set! res  1 0.)
  (matrix-set! res  2 0.)
  (matrix-set! res  3 0.)
  (matrix-set! res  4 0.)
  (matrix-set! res  5 1.)
  (matrix-set! res  6 0.)
  (matrix-set! res  7 0.)
  (matrix-set! res  8 0.)
  (matrix-set! res  9 0.)
  (matrix-set! res 10 1.)
  (matrix-set! res 11 0.)
  (matrix-set! res 12 0.)
  (matrix-set! res 13 0.)
  (matrix-set! res 14 0.)
  (matrix-set! res 15 1.)
  res)


(definition public (matrix-multiply a <f32vector> b <f32vector>) <f32vector>
  (matrix-multiply! (make-matrix) a b))


(definition public (matrix-multiply! res <f32vector> a <f32vector> b <f32vector>) <f32vector>
  (loop (for i from 0 below 4)
        (loop (for j from 0 below 4)
              (let ((ind (+ (* j 4) i)))
                (matrix-set! res ind 0.)
                (loop (for k from 0 below 4)
                      (matrix-set! res ind (+ (matrix-ref res ind)
                                              (* (matrix-ref a (+ (* k 4) i))
                                                 (matrix-ref b (+ (* j 4) k)))))))))
  res)


(definition public (matrix-tranform mat <f32vector> vert <f32vector>) <f32vector>
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    (let ((s (+ (* (matrix-ref mat 3) x) (* (matrix-ref mat 7) y) (* (matrix-ref mat 11) z) (matrix-ref mat 15))))
      (vertex (/ (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)) s)
              (/ (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)) s)
              (/ (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14)) s)))))


(definition public (make-translation-matrix tx <fl> ty <fl> tz <fl>) <f32vector>
  (make-translation-matrix! (make-matrix) tx ty tz))


(definition public (make-translation-matrix! res <f32vector> tx <fl> ty <fl> tz <fl>) <f32vector>
  (make-identity-matrix! res)
  (matrix-set! res 12 tx)
  (matrix-set! res 13 ty)
  (matrix-set! res 14 tz)
  res)


(definition public (make-x-rotation-matrix phi <fl>) <f32vector>
  (make-x-rotation-matrix! (make-matrix) phi))


(definition public (make-x-rotation-matrix! res <f32vector> phi <fl>)
  (make-identity-matrix! res)
  (let ((cos (cos phi))
        (sin (sin phi)))
    (matrix-set! res 5 cos)
    (matrix-set! res 6 (- sin))
    (matrix-set! res 9 sin)
    (matrix-set! res 10 cos)))


(definition public (make-y-rotation-matrix theta <fl>) <f32vector>
  (make-y-rotation-matrix! (make-matrix) theta))


(definition public (make-y-rotation-matrix! res <f32vector> theta <fl>)
  (make-identity-matrix! res)
  (let ((cos (cos theta))
        (sin (sin theta)))
    (matrix-set! res 0 cos)
    (matrix-set! res 2 sin)
    (matrix-set! res 8 (- sin))
    (matrix-set! res 10 cos)))


(definition public (make-z-rotation-matrix psi <fl>) <f32vector>
  (make-z-rotation-matrix! (make-matrix) psi))


(definition public (make-z-rotation-matrix! res <f32vector> psi <fl>)
  (make-identity-matrix! res)
  (let ((cos (cos psi))
        (sin (sin psi)))
    (matrix-set! res 0 cos)
    (matrix-set! res 1 (- sin))
    (matrix-set! res 4 sin)
    (matrix-set! res 5 cos)))


(definition public (make-rotation-matrix rx <fl> ry <fl> rz <fl>) <f32vector>
  (matrix-multiply (make-x-rotation-matrix rx)
                   (matrix-multiply (make-y-rotation-matrix ry)
                                    (make-z-rotation-matrix rz))))


(definition public (make-scaling-matrix sx <fl> sy <fl> sz <fl>) <f32vector>
  (make-scaling-matrix! (make-matrix) sx sy sz))


(definition public (make-scaling-matrix! res <f32vector> sx <fl> sy <fl> sz <fl>) <f32vector>
  (make-identity-matrix! res)
  (matrix-set! res 0 sx)
  (matrix-set! res 5 sy)
  (matrix-set! res 10 sz)
  res)


(definition public (make-lookat-matrix lookat <LookAt>) <f32vector>
  (make-lookat-matrix! (make-matrix) lookat))


(definition public (make-lookat-matrix! res <f32vector> lookat <LookAt>) <f32vector>
  (make-identity-matrix! res)
  (let ((sight (get-sight~ lookat))
        (up (get-up~ lookat))
        (right (get-right~ lookat)))
    (matrix-set! res 0 (vertex-x right)) (matrix-set! res 4 (vertex-x up)) (matrix-set! res  8 (vertex-x sight))
    (matrix-set! res 1 (vertex-y right)) (matrix-set! res 5 (vertex-y up)) (matrix-set! res  9 (vertex-y sight))
    (matrix-set! res 2 (vertex-z right)) (matrix-set! res 6 (vertex-z up)) (matrix-set! res 10 (vertex-z sight)))
  res)


(definition public (make-projection-matrix fov <fl> ratio <fl> near <fl> far <fl>) <f32vector>
  (make-projection-matrix! (make-identity-matrix) fov ratio near far))


(definition public (make-projection-matrix! res <f32vector> fov <fl> ratio <fl> near <fl> far <fl>) <f32vector>
  (let ((f (/ 1.0 (tan (* fov (/ PI 360.))))))
    (matrix-set! res  0 (/ f ratio))
    (matrix-set! res  5 f)
    (matrix-set! res 10 (/ (+ far near) (- near far)))
    (matrix-set! res 14 (/ (* 2.0 far near) (- near far)))
    (matrix-set! res 11 -1.)
    (matrix-set! res 15 0.))
  res)


(definition public (make-view-matrix position <f32vector> lookat <LookAt>) <f32vector>
  (make-view-matrix! (make-identity-matrix) position lookat))


(definition public (make-view-matrix! res <f32vector> position <f32vector> lookat <LookAt>) <f32vector>
  (let* ((sight (get-sight~ lookat))
         (up (get-up~ lookat))
         (right (get-right~ lookat))
         (view (matrix (vertex-x right)     (vertex-y right)     (vertex-z right)     0.0
                       (vertex-x up)        (vertex-y up)        (vertex-z up)        0.0
                       (- (vertex-x sight)) (- (vertex-y sight)) (- (vertex-z sight)) 0.0
                       0.0                  0.0                  0.0                  1.0))
         (translate (make-translation-matrix (- (vertex-x position))
                                             (- (vertex-y position))
                                             (- (vertex-z position)))))
    (matrix-multiply! res view translate)))


;;;
;;;; LookAt
;;;


(definition public (rotate-lookat! lookat <LookAt> angle <fl> vert <f32vector>) <void>
  (let ((sight (get-sight~ lookat))
        (up (get-up~ lookat))
        (right (get-right~ lookat)))
    ;; sight
    (rotate-upon! sight angle vert sight)
    (vertex-normalize! sight sight)
    ;; up
    (rotate-upon! up angle vert up)
    (vertex-normalize! up up)
    ;; right
    (rotate-upon! right angle vert right)
    (vertex-normalize! right right)))


(definition public (validate-lookat-normalized lookat <LookAt>) <void>
  (define (validate vert)
    (unless (near? (vertex-norm vert) 1. .0001)
      (error "Vertex {s} is not normalized" vert)))
  
  (validate (get-sight~ lookat))
  (validate (get-up~ lookat))
  (validate (get-right~ lookat)))


(definition public (make-lookat) <LookAt>
  (new LookAt))


(definition public (copy-lookat lookat <LookAt>) <LookAt>
  (let ((copy (make-lookat)))
    (set-sight~ copy (get-sight~ lookat))
    (set-up~ copy (get-up~ lookat))
    (set-right~ copy (get-right~ lookat))
    copy))
  

;;;
;;;; Movement
;;;


(definition public (movement-end mvt <Movement>) <f32vector>
  (vertex+ (get-origin~ mvt) (get-vector~ mvt)))


(definition public (movement-end-to mvt <Movement> d <fl>) <f32vector>
  (vertex+ (get-origin~ mvt) (vertex-scalar*& (get-normal~ mvt) d)))


;;;
;;;; Plane
;;;


(definition public (plane-to-point-distance plane <Plane> point <f32vector>) <fl>
  (let ((res (make-f32)))
    (intersect-plane! res plane (new Movement point (vertex-negate (get-normal~ plane))))
    (f32-ref res)))


(definition public (intersect-plane plane <Plane> r <Movement>) <values>
  (let ((res (make-f32)))
    (let ((intersect? (intersect-plane! res plane r)))
      (values (f32-ref res) intersect?))))


(definition public (intersect-plane! res <f32vector> plane <Plane> r <Movement>) <bool>
  (let ((origin (get-origin~ plane))
        (normal (get-normal~ plane)))
    (let ((denom (f32-ref (dot-product& normal (get-normal~ r)))))
      (if (= denom 0.)
          (begin
            (f32-set! res 0.)
            #f)
        (let ((numer (f32-ref (dot-product& normal (get-origin~ r))))
              (distance (- (f32-ref (dot-product& origin normal)))))
          (f32-set! res (- (/ (+ numer distance) denom)))
          #t)))))


(definition public (plane-closest plane <Plane> point <f32vector>) <f32vector>
  (plane-closest! (make-vertex) plane point))


(definition public (plane-closest! res <f32vector> plane <Plane> point <f32vector>) <f32vector>
  (let ((t (plane-to-point-distance plane point)))
    (vertex-! res point (vertex-scalar*& (get-normal~ plane) t)))
  res)


(definition public (gl-plane-normal v1 v2 v3)
  (let ((normal (plane-normal v1 v2 v3)))
    (glNormal3f (vertex-x normal)
                (vertex-y normal)
                (vertex-z normal))))


;;;
;;;; Polygon
;;;


(definition public (closest-point-on-line-segment a <f32vector> b <f32vector> p <f32vector>) <values>
  (let ((pt (make-vertex)))
    (let ((edge? (closest-point-on-line-segment! pt a b p)))
      (values pt edge?))))


(definition public (closest-point-on-line-segment! res <f32vector> a <f32vector> b <f32vector> p <f32vector>) <bool>
  (let ((on-edge #t)
        (c (vertex-& p a))
        (v (vertex-normalize& (vertex-& b a))))
    (let ((t (f32-ref (dot-product& v c))))
      (if (< t 0.)
          (begin
            (vertex-copy! res a)
            (not on-edge))
        (let ((d (f32-ref (vertex-distance& b a))))
          (if (> t d)
              (begin
                (vertex-copy! res b)
                (not on-edge))
            (vertex+! res a (vertex-scalar*& v t))
            on-edge))))))


(definition public (closest-point-on-line a <f32vector> b <f32vector> p <f32vector>) <f32vector>
  (closest-point-on-line! (make-vertex) a b p))


(definition public (closest-point-on-line! res <f32vector> a <f32vector> b <f32vector> p <f32vector>) <f32vector>
  (let ((c (vertex-& p a))
        (v (vertex-normalize& (vertex-& b a))))
    (let ((t (f32-ref (dot-product& v c)))
          (d (f32-ref (vertex-distance& b a))))
      (vertex+! res a (vertex-scalar*& v t))))
  res)


;;;
;;;; Random
;;;


(definition public (random-in max <fl>) <fl>
  (- (* (random-real) max 2.) max)))
