;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; MilkShape 3D
;;;


;; This code is a port to Jazz of Mete Ciragan's msViewer
;;
;; email:          mciragan@gmx.net
;; web:            http://www.milkshape3d.com


(module world.external.milkshape jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (world)
        (world.atlas)
        (world.binary)
        (world.dye)
        (world.foreign)
        (world.geometry)
        (world.joint)
        (world.material)
        (world.model)
        (world.texture))


;;;
;;;; Math
;;;


(define (make-mat)
  (let ((mat (make-vector 3)))
    (loop (for i from 0 below 3)
          (vector-set! mat i (make-vector 4 0.)))
    mat))


(define (mat-ref mat <Vector> i <fx> j <fx>) <fl>
  (vector-ref (vector-ref mat i) j))

(define (mat-set! mat <Vector> i <fx> j <fx> val <fl>) <void>
  (vector-set! (vector-ref mat i) j val))


(define (mat-copy! dst <Vector> src <Vector>) <void>
  (mat-set! dst 0 0 (mat-ref src 0 0))
  (mat-set! dst 1 0 (mat-ref src 1 0))
  (mat-set! dst 2 0 (mat-ref src 2 0))
  (mat-set! dst 0 1 (mat-ref src 0 1))
  (mat-set! dst 1 1 (mat-ref src 1 1))
  (mat-set! dst 2 1 (mat-ref src 2 1))
  (mat-set! dst 0 2 (mat-ref src 0 2))
  (mat-set! dst 1 2 (mat-ref src 1 2))
  (mat-set! dst 2 2 (mat-ref src 2 2))
  (mat-set! dst 0 3 (mat-ref src 0 3))
  (mat-set! dst 1 3 (mat-ref src 1 3))
  (mat-set! dst 2 3 (mat-ref src 2 3)))


(define (AngleMatrix! angles <f32vector> mat <Vector>) <void>
  (let ((sr (sin (f32vector-ref angles 0)))
        (sp (sin (f32vector-ref angles 1)))
        (sy (sin (f32vector-ref angles 2)))
        (cr (cos (f32vector-ref angles 0)))
        (cp (cos (f32vector-ref angles 1)))
        (cy (cos (f32vector-ref angles 2))))
    ;; mat = (Z * Y) * X
    (mat-set! mat 0 0 (* cp cy))
    (mat-set! mat 1 0 (* cp sy))
    (mat-set! mat 2 0 (- sp))
    (mat-set! mat 0 1 (+ (* (* sr sp) cy) (* cr (- sy))))
    (mat-set! mat 1 1 (+ (* (* sr sp) sy) (* cr cy)))
    (mat-set! mat 2 1 (* sr cp))
    (mat-set! mat 0 2 (+ (* (* cr sp) cy) (* (- sr) (- sy))))
    (mat-set! mat 1 2 (+ (* (* cr sp) sy) (* (- sr) cy)))
    (mat-set! mat 2 2 (* cr cp))
    (mat-set! mat 0 3 0.)
    (mat-set! mat 1 3 0.)
    (mat-set! mat 2 3 0.)))


(define (R_ConcatTransforms in1 <Vector> in2 <Vector> out <Vector>) <void>
  (mat-set! out 0 0 (+ (* (mat-ref in1 0 0) (mat-ref in2 0 0)) (* (mat-ref in1 0 1) (mat-ref in2 1 0)) (* (mat-ref in1 0 2) (mat-ref in2 2 0))))
  (mat-set! out 0 1 (+ (* (mat-ref in1 0 0) (mat-ref in2 0 1)) (* (mat-ref in1 0 1) (mat-ref in2 1 1)) (* (mat-ref in1 0 2) (mat-ref in2 2 1))))
  (mat-set! out 0 2 (+ (* (mat-ref in1 0 0) (mat-ref in2 0 2)) (* (mat-ref in1 0 1) (mat-ref in2 1 2)) (* (mat-ref in1 0 2) (mat-ref in2 2 2))))
  (mat-set! out 0 3 (+ (* (mat-ref in1 0 0) (mat-ref in2 0 3)) (* (mat-ref in1 0 1) (mat-ref in2 1 3)) (* (mat-ref in1 0 2) (mat-ref in2 2 3)) (mat-ref in1 0 3)))
  (mat-set! out 1 0 (+ (* (mat-ref in1 1 0) (mat-ref in2 0 0)) (* (mat-ref in1 1 1) (mat-ref in2 1 0)) (* (mat-ref in1 1 2) (mat-ref in2 2 0))))
  (mat-set! out 1 1 (+ (* (mat-ref in1 1 0) (mat-ref in2 0 1)) (* (mat-ref in1 1 1) (mat-ref in2 1 1)) (* (mat-ref in1 1 2) (mat-ref in2 2 1))))
  (mat-set! out 1 2 (+ (* (mat-ref in1 1 0) (mat-ref in2 0 2)) (* (mat-ref in1 1 1) (mat-ref in2 1 2)) (* (mat-ref in1 1 2) (mat-ref in2 2 2))))
  (mat-set! out 1 3 (+ (* (mat-ref in1 1 0) (mat-ref in2 0 3)) (* (mat-ref in1 1 1) (mat-ref in2 1 3)) (* (mat-ref in1 1 2) (mat-ref in2 2 3)) (mat-ref in1 1 3)))
  (mat-set! out 2 0 (+ (* (mat-ref in1 2 0) (mat-ref in2 0 0)) (* (mat-ref in1 2 1) (mat-ref in2 1 0)) (* (mat-ref in1 2 2) (mat-ref in2 2 0))))
  (mat-set! out 2 1 (+ (* (mat-ref in1 2 0) (mat-ref in2 0 1)) (* (mat-ref in1 2 1) (mat-ref in2 1 1)) (* (mat-ref in1 2 2) (mat-ref in2 2 1))))
  (mat-set! out 2 2 (+ (* (mat-ref in1 2 0) (mat-ref in2 0 2)) (* (mat-ref in1 2 1) (mat-ref in2 1 2)) (* (mat-ref in1 2 2) (mat-ref in2 2 2))))
  (mat-set! out 2 3 (+ (* (mat-ref in1 2 0) (mat-ref in2 0 3)) (* (mat-ref in1 2 1) (mat-ref in2 1 3)) (* (mat-ref in1 2 2) (mat-ref in2 2 3)) (mat-ref in1 2 3))))


(define (DotProduct x <Vector> y <Vector>) <fl>
  (+ (* (vector-ref x 0) (vector-ref y 0))
     (* (vector-ref x 1) (vector-ref y 1))
     (* (vector-ref x 2) (vector-ref y 2))))


(define (VectorRotate vert <f32vector> mat <Vector> out <f32vector>) <void>
  (f32vector-set! out 0 (DotProduct vert (vector-ref mat 0)))
  (f32vector-set! out 1 (DotProduct vert (vector-ref mat 1)))
  (f32vector-set! out 2 (DotProduct vert (vector-ref mat 2))))


;; rotate by the inverse of the matrix
(define (VectorIRotate vert <f32vector> mat <Vector> out <f32vector>) <void>
  (f32vector-set! out 0 (+ (* (f32vector-ref vert 0) (mat-ref mat 0 0)) (* (f32vector-ref vert 1) (mat-ref mat 1 0)) (* (f32vector-ref vert 2) (mat-ref mat 2 0))))
  (f32vector-set! out 1 (+ (* (f32vector-ref vert 0) (mat-ref mat 0 1)) (* (f32vector-ref vert 1) (mat-ref mat 1 1)) (* (f32vector-ref vert 2) (mat-ref mat 2 1))))
  (f32vector-set! out 2 (+ (* (f32vector-ref vert 0) (mat-ref mat 0 2)) (* (f32vector-ref vert 1) (mat-ref mat 1 2)) (* (f32vector-ref vert 2) (mat-ref mat 2 2)))))


(define (VectorTransform vert <f32vector> mat <Vector> out <f32vector>) <void>
  (f32vector-set! out 0 (+ (DotProduct vert (vector-ref mat 0)) (mat-ref mat 0 3)))
  (f32vector-set! out 1 (+ (DotProduct vert (vector-ref mat 1)) (mat-ref mat 1 3)))
  (f32vector-set! out 2 (+ (DotProduct vert (vector-ref mat 2)) (mat-ref mat 2 3))))


(define (VectorITransform vert <f32vector> mat <Vector> out <f32vector>) <void>
  (let ((tmp (make-vertex)))
    (f32vector-set! tmp 0 (- (f32vector-ref vert 0) (mat-ref mat 0 3)))
    (f32vector-set! tmp 1 (- (f32vector-ref vert 1) (mat-ref mat 1 3)))
    (f32vector-set! tmp 2 (- (f32vector-ref vert 2) (mat-ref mat 2 3)))
    (VectorIRotate tmp mat out)))


(define (AngleQuaternion angles <f32vector> quaternion <f32vector>) <void>
  (let ((sr (sin (* (f32vector-ref angles 0) .5)))
        (sp (sin (* (f32vector-ref angles 1) .5)))
        (sy (sin (* (f32vector-ref angles 2) .5)))
        (cr (cos (* (f32vector-ref angles 0) .5)))
        (cp (cos (* (f32vector-ref angles 1) .5)))
        (cy (cos (* (f32vector-ref angles 2) .5))))
    (f32vector-set! quaternion 0 (- (* sr cp cy) (* cr sp sy))) ;; X
    (f32vector-set! quaternion 1 (+ (* cr sp cy) (* sr cp sy))) ;; Y
    (f32vector-set! quaternion 2 (- (* cr cp sy) (* sr sp cy))) ;; Z
    (f32vector-set! quaternion 3 (+ (* cr cp cy) (* sr sp sy))))) ;; W


(define (QuaternionMatrix quaternion <f32vector> mat <Vector>) <void>
  (mat-set! mat 0 0 (- (- 1. (* 2. (f32vector-ref quaternion 1) (f32vector-ref quaternion 1))) (* 2. (f32vector-ref quaternion 2) (f32vector-ref quaternion 2))))
  (mat-set! mat 1 0 (+ (* 2. (f32vector-ref quaternion 0) (f32vector-ref quaternion 1)) (* 2. (f32vector-ref quaternion 3) (f32vector-ref quaternion 2))))
  (mat-set! mat 2 0 (- (* 2. (f32vector-ref quaternion 0) (f32vector-ref quaternion 2)) (* 2. (f32vector-ref quaternion 3) (f32vector-ref quaternion 1))))
  
  (mat-set! mat 0 1 (- (* 2. (f32vector-ref quaternion 0) (f32vector-ref quaternion 1)) (* 2. (f32vector-ref quaternion 3) (f32vector-ref quaternion 2))))
  (mat-set! mat 1 1 (- (- 1. (* 2. (f32vector-ref quaternion 0) (f32vector-ref quaternion 0))) (* 2. (f32vector-ref quaternion 2) (f32vector-ref quaternion 2))))
  (mat-set! mat 2 1 (+ (* 2. (f32vector-ref quaternion 1) (f32vector-ref quaternion 2)) (* 2. (f32vector-ref quaternion 3) (f32vector-ref quaternion 0))))
  
  (mat-set! mat 0 2 (+ (* 2. (f32vector-ref quaternion 0) (f32vector-ref quaternion 2)) (* 2. (f32vector-ref quaternion 3) (f32vector-ref quaternion 1))))
  (mat-set! mat 1 2 (- (* 2. (f32vector-ref quaternion 1) (f32vector-ref quaternion 2)) (* 2. (f32vector-ref quaternion 3) (f32vector-ref quaternion 0))))
  (mat-set! mat 2 2 (- (- 1. (* 2. (f32vector-ref quaternion 0) (f32vector-ref quaternion 0))) (* 2. (f32vector-ref quaternion 1) (f32vector-ref quaternion 1)))))


(define (QuaternionSlerp p <f32vector> q <f32vector> t <fl> qt <f32vector>) <void>
  (let ((i 0)
        (omega 0.)
        (cosom 0.)
        (sinom 0.)
        (sclp 0.)
        (sclq 0.))
    ;; decide if one of the quaternions is backwards
    (let ((a 0.)
          (b 0.))
      (loop (for i iterate (set! i 0) (< i 4) (increase! i))
            (increase! a (* (- (f32vector-ref p i) (f32vector-ref q i)) (- (f32vector-ref p i) (f32vector-ref q i))))
            (increase! b (* (+ (f32vector-ref p i) (f32vector-ref q i)) (+ (f32vector-ref p i) (f32vector-ref q i)))))
      (when (> a b)
        (loop (for i iterate (set! i 0) (< i 4) (increase! i))
              (f32vector-set! q i (- (f32vector-ref q i)))))
      (set! cosom
            (+ (* (f32vector-ref p 0) (f32vector-ref q 0))
               (* (f32vector-ref p 1) (f32vector-ref q 1))
               (* (f32vector-ref p 2) (f32vector-ref q 2))
               (* (f32vector-ref p 3) (f32vector-ref q 3))))
      (if (> (+ 1. cosom) 1e-8)
          (begin
            (if (> (- 1. cosom) 1e-8)
                (begin
                  (set! omega (acos cosom))
                  (set! sinom (sin omega))
                  (set! sclp (/ (sin (* (- 1. t) omega)) sinom))
                  (set! sclq (/ (sin (* t omega)) sinom)))
              (begin
                (set! sclp (- 1. t))
                (set! sclq t)))
            (loop (for i iterate (set! i 0) (< i 4) (increase! i))
                  (f32vector-set!
                    qt
                    i
                    (+ (* sclp (f32vector-ref p i))
                       (* sclq (f32vector-ref q i))))))
        (begin
          (f32vector-set! qt 0 (- (f32vector-ref p 1)))
          (f32vector-set! qt 1 (f32vector-ref p 0))
          (f32vector-set! qt 2 (- (f32vector-ref p 3)))
          (f32vector-set! qt 3 (f32vector-ref p 2))
          (set! sclp (sin (* (- 1. t) .5 PI)))
          (set! sclq (sin (* t .5 PI)))
          (loop (for i iterate (set! i 0) (< i 3) (increase! i))
                (f32vector-set!
                  qt
                  i
                  (+ (* sclp (f32vector-ref p i))
                     (* sclq (f32vector-ref qt i))))))))))


;;;
;;;; Model
;;;


(constant TRANSPARENCY_MODE_SIMPLE               0)
(constant TRANSPARENCY_MODE_DEPTHSORTEDTRIANGLES 1)
(constant TRANSPARENCY_MODE_ALPHAREF             2)


(class MS3D-Model extends Object
  
  
  (slot animation-fps      <fl+> initialize #f accessors generate)
  (slot current-time       <fl+> initialize #f accessors generate)
  (slot total-frames       <fx+> initialize #f accessors generate)
  
  
  (slot m_vertices         <object> accessors generate)
  (slot m_triangles        <object> accessors generate)
  (slot m_groups           <object> accessors generate)
  (slot m_materials        <object> accessors generate)
  
  (slot m_animationFps     <fl>     accessors generate)
  (slot m_currentTime      <fl>     accessors generate)
  (slot m_totalFrames      <fx>     accessors generate)

  (slot m_joints           <object> accessors generate)
  (slot m_comment          <object> accessors generate)
  
  (slot m_jointSize        <fl>     accessors generate)
  (slot m_transparencyMode <fx>     accessors generate)
  (slot m_alphaRef         <fl>     accessors generate)
  
  
  (method (Clear)
    (clear~ m_vertices)
    (clear~ m_triangles)
    (clear~ m_groups)
    (clear~ m_materials)
    (set! m_animationFps 24.)
    (set! m_currentTime 1.)
    (set! m_totalFrames 30)
    (clear~ m_joints)
    (clear~ m_comment)
    (set! m_jointSize 1.)
    (set! m_transparencyMode TRANSPARENCY_MODE_SIMPLE)
    (set! m_alphaRef .5))
  
  
  (method (GetNumGroups) (vector-length m_groups))
  (method (GetGroup index <fx>) (vector-ref m_groups index))
  (method (GetNumTriangles) (vector-length m_triangles))
  (method (GetTriangle index <fx>) (vector-ref m_triangles index))
  (method (GetNumVertices) (vector-length m_vertices))
  (method (GetVertex index <fx>) (vector-ref m_vertices index))
  (method (GetNumMaterials) (vector-length m_materials))
  (method (GetMaterial index <fx>) (vector-ref m_materials index))
  (method (GetNumJoints) (vector-length m_joints))
  (method (GetJoint index <fx>) (vector-ref m_joints index))
  (method (GetJointSize) m_jointSize)
  (method (GetTransparencyMode) m_transparencyMode)
  (method (GetAlphaRef) m_alphaRef)
  
  
  (method (FindJointByName name) <fx>
    (loop (for i iterate (set! i 0) (< i (vector-length m_joints)) (increase! i))
          (when (equal? (get-name~ (vector-ref m_joints i)) name)
            (return i)))
    -1)
  
  
  (method (SetupJoints) <void>
    (loop (for i iterate (set! i 0) (< i (vector-length m_joints)) (increase! i))
          (let ((joint <MS3D-Joint> (vector-ref m_joints i)))
            (set-parentIndex~ joint (FindJointByName (get-parentName~ joint)))))
    (loop (for i iterate (set! i 0) (< i (vector-length m_joints)) (increase! i))
          (let ((joint <MS3D-Joint> (vector-ref m_joints i)))
            (AngleMatrix! (get-rot~ joint) (get-matLocalSkeleton~ joint))
            (mat-set! (get-matLocalSkeleton~ joint) 0 3 (f32vector-ref (get-pos~ joint) 0))
            (mat-set! (get-matLocalSkeleton~ joint) 1 3 (f32vector-ref (get-pos~ joint) 1))
            (mat-set! (get-matLocalSkeleton~ joint) 2 3 (f32vector-ref (get-pos~ joint) 2))
            (if (= (get-parentIndex~ joint) -1)
                (mat-copy! (get-matGlobalSkeleton~ joint) (get-matLocalSkeleton~ joint))
              (let ((parentJoint <MS3D-Joint> (vector-ref m_joints (get-parentIndex~ joint))))
                (R_ConcatTransforms
                  (get-matGlobalSkeleton~ parentJoint)
                  (get-matLocalSkeleton~ joint)
                  (get-matGlobalSkeleton~ joint))))
            (SetupTangents))))
  
  
  (method (SetupTangents) <void>
    (loop (for j iterate (set! j 0) (< j (vector-length m_joints)) (increase! j))
          (let ((joint <MS3D-Joint> (vector-ref m_joints j)))
            (let ((numPositionKeys <fx> (vector-length (get-positionKeys~ joint))))
              (set-tangents~ joint (make-vector numPositionKeys))
              (loop (for i from 0 below numPositionKeys)
                    (vector-set! (get-tangents~ joint) i (new MS3D-Tangent)))
              ;; clear all tangents (zero derivatives)
              (loop (for k iterate (set! k 0) (< k numPositionKeys) (increase! k))
                    (f32vector-set! (get-tangentIn~ (vector-ref (get-tangents~ joint) k)) 0 0.)
                    (f32vector-set! (get-tangentIn~ (vector-ref (get-tangents~ joint) k)) 1 0.)
                    (f32vector-set! (get-tangentIn~ (vector-ref (get-tangents~ joint) k)) 2 0.)
                    (f32vector-set! (get-tangentOut~ (vector-ref (get-tangents~ joint) k)) 0 0.)
                    (f32vector-set! (get-tangentOut~ (vector-ref (get-tangents~ joint) k)) 1 0.)
                    (f32vector-set! (get-tangentOut~ (vector-ref (get-tangents~ joint) k)) 2 0.))
              ;; if there are more than 2 keys, we can calculate tangents, otherwise we use zero derivatives
              (when (> numPositionKeys 2)
                (loop (for k iterate (set! k 0) (< k numPositionKeys) (increase! k))
                      ;; make the curve tangents looped
                      (let ((k0 <fx> (- k 1)))
                        (when (< k0 0) (set! k0 (- numPositionKeys 1)))
                        (let ((k1 <fx> k)
                              (k2 <fx> (+ k 1)))
                          (when (>= k2 numPositionKeys) (set! k2 0))
                          ;; calculate the tangent, which is the vector from key[k - 1] to key[k + 1]
                          (let ((tangent (make-vertex)))
                            (f32vector-set! tangent 0 (- (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) k2)) 0) (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) k0)) 0)))
                            (f32vector-set! tangent 1 (- (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) k2)) 1) (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) k0)) 1)))
                            (f32vector-set! tangent 2 (- (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) k2)) 2) (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) k0)) 2)))
                            ;; weight the incoming and outgoing tangent by their time to avoid changes in speed, if the keys are not within the same interval
                            (let ((dt1 <fl> (- (get-time~ (vector-ref (get-positionKeys~ joint) k1)) (get-time~ (vector-ref (get-positionKeys~ joint) k0))))
                                  (dt2 <fl> (- (get-time~ (vector-ref (get-positionKeys~ joint) k2)) (get-time~ (vector-ref (get-positionKeys~ joint) k1)))))
                              (let ((dt <fl> (+ dt1 dt2)))
                                (f32vector-set! (get-tangentIn~ (vector-ref (get-tangents~ joint) k1)) 0 (/ (* (f32vector-ref tangent 0) dt1) dt))
                                (f32vector-set! (get-tangentIn~ (vector-ref (get-tangents~ joint) k1)) 1 (/ (* (f32vector-ref tangent 1) dt1) dt))
                                (f32vector-set! (get-tangentIn~ (vector-ref (get-tangents~ joint) k1)) 2 (/ (* (f32vector-ref tangent 2) dt1) dt))
                                (f32vector-set! (get-tangentOut~ (vector-ref (get-tangents~ joint) k1)) 0 (/ (* (f32vector-ref tangent 0) dt2) dt))
                                (f32vector-set! (get-tangentOut~ (vector-ref (get-tangents~ joint) k1)) 1 (/ (* (f32vector-ref tangent 1) dt2) dt))
                                (f32vector-set! (get-tangentOut~ (vector-ref (get-tangents~ joint) k1)) 2 (/ (* (f32vector-ref tangent 2) dt2) dt)))))))))))))
  
  
  (method (SetFrame frame <fl>) <void>
    (if (< frame 0.)
        (loop (for i iterate (set! i 0) (< i (vector-length m_joints)) (increase! i))
              (let ((joint <MS3D-Joint> (vector-ref m_joints i)))
                (mat-copy! (get-matLocal~ joint) (get-matLocalSkeleton~ joint))
                (mat-copy! (get-matGlobal~ joint) (get-matGlobalSkeleton~ joint))))
      (loop (for i iterate (set! i 0) (< i (vector-length m_joints)) (increase! i))
            (EvaluateJoint i frame)))
    (set! m_currentTime frame))
  
  
  (method (EvaluateJoint index <fx> frame <fl>) <void>
    (let ((joint <MS3D-Joint> (vector-ref m_joints index)))
      ;;
      ;; calculate joint animation matrix, this matrix will animate matLocalSkeleton
      ;;
      (let ((pos <f32vector> #f32(0. 0. 0.)))
        (let ((numPositionKeys <fx> (vector-length (get-positionKeys~ joint))))
          (when (> numPositionKeys 0)
            (let ((i1 <fx> -1)
                  (i2 <fx> -1))
              ;; find the two keys, where "frame" is in between for the position channel
              (loop (for i iterate (set! i 0) (< i (- numPositionKeys 1)) (increase! i))
                    (when (and (>= frame (get-time~ (vector-ref (get-positionKeys~ joint) i)))
                               (< frame (get-time~ (vector-ref (get-positionKeys~ joint) (+ i 1)))))
                      (set! i1 i)
                      (set! i2 (+ i 1))
                      (return)))
              ;; if there are no such keys
              (if (or (= i1 -1) (= i2 -1))
                  (begin
                    ;; either take the first
                    (if (< frame (get-time~ (vector-ref (get-positionKeys~ joint) 0)))
                        (begin
                          (f32vector-set! pos 0 (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) 0)) 0))
                          (f32vector-set! pos 1 (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) 0)) 1))
                          (f32vector-set! pos 2 (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) 0)) 2)))
                      (when (>= frame (get-time~ (vector-ref (get-positionKeys~ joint) (- numPositionKeys 1))))
                        ;; or the last key
                        (f32vector-set! pos 0 (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) (- numPositionKeys 1))) 0))
                        (f32vector-set! pos 1 (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) (- numPositionKeys 1))) 1))
                        (f32vector-set! pos 2 (f32vector-ref (get-key~ (vector-ref (get-positionKeys~ joint) (- numPositionKeys 1))) 2)))))
                (begin
                  ;; there are such keys, so interpolate using hermite interpolation
                  (let ((p0 <MS3D-KeyFrame> (vector-ref (get-positionKeys~ joint) i1))
                        (p1 <MS3D-KeyFrame> (vector-ref (get-positionKeys~ joint) i2))
                        (m0 <MS3D-Tangent> (vector-ref (get-tangents~ joint) i1))
                        (m1 <MS3D-Tangent> (vector-ref (get-tangents~ joint) i2)))
                    ;; normalize the time between the keys into [0..1]
                    (let ((t <fl>
                            (/ (- frame
                                  (get-time~ (vector-ref (get-positionKeys~ joint) i1)))
                               (- (get-time~ (vector-ref (get-positionKeys~ joint) i2))
                                  (get-time~ (vector-ref (get-positionKeys~ joint) i1))))))
                      (let ((t2 <fl> (* t t)))
                        (let ((t3 <fl> (* t2 t)))
                          ;; calculate hermite basis
                          (let ((h1 <fl> (+ (- (* 2. t3) (* 3. t2)) 1.))
                                (h2 <fl> (+ (* (- 2.) t3) (* 3. t2)))
                                (h3 <fl> (+ (- t3 (* 2. t2)) t))
                                (h4 <fl> (- t3 t2)))
                            ;; do hermite interpolation
                            (f32vector-set! pos 0 (+ (* h1 (f32vector-ref (get-key~ p0) 0)) (* h3 (f32vector-ref (get-tangentOut~ m0) 0)) (* h2 (f32vector-ref (get-key~ p1) 0)) (* h4 (f32vector-ref (get-tangentIn~ m1) 0))))
                            (f32vector-set! pos 1 (+ (* h1 (f32vector-ref (get-key~ p0) 1)) (* h3 (f32vector-ref (get-tangentOut~ m0) 1)) (* h2 (f32vector-ref (get-key~ p1) 1)) (* h4 (f32vector-ref (get-tangentIn~ m1) 1))))
                            (f32vector-set! pos 2 (+ (* h1 (f32vector-ref (get-key~ p0) 2)) (* h3 (f32vector-ref (get-tangentOut~ m0) 2)) (* h2 (f32vector-ref (get-key~ p1) 2)) (* h4 (f32vector-ref (get-tangentIn~ m1) 2)))))))))))))
          (let ((quat <f32vector> #f32(0. 0. 0. 1.)))
            (let ((numRotationKeys <fx> (vector-length (get-rotationKeys~ joint))))
              (when (> numRotationKeys 0)
                (let ((i1 <fx> -1)
                      (i2 <fx> -1))
                  ;; find the two keys, where "frame" is in between for the rotation channel
                  (loop (for i iterate (set! i 0) (< i (- numRotationKeys 1)) (increase! i))
                        (when (and (>= frame (get-time~ (vector-ref (get-rotationKeys~ joint) i)))
                                   (< frame (get-time~ (vector-ref (get-rotationKeys~ joint) (+ i 1)))))
                          (set! i1 i)
                          (set! i2 (+ i 1))
                          (return)))
                  ;; if there are no such keys
                  (if (or (= i1 -1) (= i2 -1))
                      (begin
                        ;; either take the first key
                        (if (< frame (get-time~ (vector-ref (get-rotationKeys~ joint) 0)))
                            (AngleQuaternion (get-key~ (vector-ref (get-rotationKeys~ joint) 0)) quat)
                          (when (>= frame (get-time~ (vector-ref (get-rotationKeys~ joint) (- numRotationKeys 1))))
                            ;; or the last key
                            (AngleQuaternion (get-key~ (vector-ref (get-rotationKeys~ joint) (- numRotationKeys 1))) quat))))
                    (begin
                      ;; there are such keys, so do the quaternion slerp interpolation
                      (let ((t <fl>
                              (/ (- frame
                                    (get-time~ (vector-ref (get-rotationKeys~ joint) i1)))
                                 (- (get-time~ (vector-ref (get-rotationKeys~ joint) i2))
                                    (get-time~ (vector-ref (get-rotationKeys~ joint) i1))))))
                        (let ((q1 <f32vector> (make-quaternion)))
                          (AngleQuaternion (get-key~ (vector-ref (get-rotationKeys~ joint) i1)) q1)
                          (let ((q2 <f32vector> (make-quaternion)))
                            (AngleQuaternion (get-key~ (vector-ref (get-rotationKeys~ joint) i2)) q2)
                            (QuaternionSlerp q1 q2 t quat))))))))
              ;; make a matrix from pos/quat
              (let ((matAnimate (make-mat)))
                (QuaternionMatrix quat matAnimate)
                (mat-set! matAnimate 0 3 (f32vector-ref pos 0))
                (mat-set! matAnimate 1 3 (f32vector-ref pos 1))
                (mat-set! matAnimate 2 3 (f32vector-ref pos 2))
                ;; animate the local joint matrix using: matLocal = matLocalSkeleton * matAnimate
                (R_ConcatTransforms (get-matLocalSkeleton~ joint) matAnimate (get-matLocal~ joint))
                ;; build up the hierarchy if joints
                ;; matGlobal = matGlobal(parent) * matLocal
                (if (= (get-parentIndex~ joint) -1)
                    (mat-copy! (get-matGlobal~ joint) (get-matLocal~ joint))
                  (let ((parentJoint <MS3D-Joint> (vector-ref m_joints (get-parentIndex~ joint))))
                    (R_ConcatTransforms
                      (get-matGlobal~ parentJoint)
                      (get-matLocal~ joint)
                      (get-matGlobal~ joint)))))))))))
  
  
  (method (GetAnimationFps) m_animationFps)
  (method (GetCurrentFrame) m_currentTime)
  (method (GetTotalFrames) m_totalFrames)
  
  
  (method (TransformVertex vertex <f32vector> out <f32vector>) <void>
    (let ((jointIndices (make-vector 4)))
      (let ((jointWeights (make-vector 4)))
        (FillJointIndicesAndWeights vertex jointIndices jointWeights)
        (if (or (or (< (vector-ref jointIndices 0) 0)
                    (>= (vector-ref jointIndices 0) (vector-length m_joints)))
                (< m_currentTime 0.))
            (begin
              (f32vector-set! out 0 (f32vector-ref (get-vertex~ vertex) 0))
              (f32vector-set! out 1 (f32vector-ref (get-vertex~ vertex) 1))
              (f32vector-set! out 2 (f32vector-ref (get-vertex~ vertex) 2)))
          (begin
            ;; count valid weights
            (let ((numWeights <fx> 0))
              ;; using continuations is a quick hack
              (continuation-capture
                (lambda (return)
                  (loop (for i iterate (set! i 0) (< i 4) (increase! i))
                        (if (and (and (> (vector-ref jointWeights i) 0)
                                      (>= (vector-ref jointIndices i) 0))
                                 (< (vector-ref jointIndices i) (vector-length m_joints)))
                            (unimplemented numWeights)
                          (continuation-return return)))))
              ;; init
              (f32vector-set! out 0 0.)
              (f32vector-set! out 1 0.)
              (f32vector-set! out 2 0.)
              (let ((weights (f32vector (/ (vector-ref jointWeights 0) 100.)
                                        (/ (vector-ref jointWeights 1) 100.)
                                        (/ (vector-ref jointWeights 2) 100.)
                                        (/ (vector-ref jointWeights 3) 100.))))
                (when (= numWeights 0)
                  (set! numWeights 1)
                  (vector-set! weights 0 1.))
                ;; add weighted vertices
                (loop (for i iterate (set! i 0) (< i numWeights) (increase! i))
                      (let ((joint <MS3D-Joint> (vector-ref m_joints (vector-ref jointIndices i))))
                        (let ((tmp <f32vector> (make-vertex)))
                          (let ((vert <f32vector> (make-vertex)))
                            (VectorITransform (get-vertex~ vertex) (get-matGlobalSkeleton~ joint) tmp)
                            (VectorTransform tmp (get-matGlobal~ joint) vert)
                            (f32vector-set! out 0 (+ (f32vector-ref out 0) (* (f32vector-ref vert 0) (vector-ref weights i))))
                            (f32vector-set! out 1 (+ (f32vector-ref out 1) (* (f32vector-ref vert 1) (vector-ref weights i))))
                            (f32vector-set! out 2 (+ (f32vector-ref out 2) (* (f32vector-ref vert 2) (vector-ref weights i)))))))))))))))
  
  
  (method (TransformNormal vertex <f32vector> normal <f32vector> out <f32vector>) <void>
    (let ((jointIndices (make-vector 4)))
      (let ((jointWeights (make-vector 4)))
        (FillJointIndicesAndWeights vertex jointIndices jointWeights)
        (if (or (or (< (vector-ref jointIndices 0) 0)
                    (>= (vector-ref jointIndices 0) (vector-length m_joints)))
                (< m_currentTime 0.))
            (begin
              (f32vector-set! out 0 (f32vector-ref normal 0))
              (f32vector-set! out 1 (f32vector-ref normal 1))
              (f32vector-set! out 2 (f32vector-ref normal 2)))
          (begin
            ;; count valid weights
            (let ((numWeights <fx> 0))
              ;; using continuations is a quick hack
              (continuation-capture
                (lambda (return)
                  (loop (for i iterate (set! i 0) (< i 4) (increase! i))
                        (if (and (and (> (vector-ref jointWeights i) 0)
                                      (>= (vector-ref jointIndices i) 0))
                                 (< (vector-ref jointIndices i) (vector-length m_joints)))
                            (unimplemented numWeights)
                          (continuation-return return)))))
              ;; init
              (f32vector-set! out 0 0.)
              (f32vector-set! out 1 0.)
              (f32vector-set! out 2 0.)
              (let ((weights (f32vector (/ (vector-ref jointWeights 0) 100.)
                                        (/ (vector-ref jointWeights 1) 100.)
                                        (/ (vector-ref jointWeights 2) 100.)
                                        (/ (vector-ref jointWeights 3) 100.))))
                (when (= numWeights 0)
                  (set! numWeights 1)
                  (vector-set! weights 0 1.))
                ;; add weighted vertices
                (loop (for i iterate (set! i 0) (< i numWeights) (increase! i))
                      (let ((joint <MS3D-Joint> (vector-ref m_joints (vector-ref jointIndices i))))
                        (let ((tmp <f32vector> (make-vertex)))
                          (let ((norm <f32vector> (make-vertex)))
                            (VectorIRotate normal (get-matGlobalSkeleton~ joint) tmp)
                            (VectorRotate tmp (get-matGlobal~ joint) norm)
                            (f32vector-set! out 0 (+ (f32vector-ref out 0) (* (f32vector-ref norm 0) (vector-ref weights i))))
                            (f32vector-set! out 1 (+ (f32vector-ref out 1) (* (f32vector-ref norm 1) (vector-ref weights i))))
                            (f32vector-set! out 2 (+ (f32vector-ref out 2) (* (f32vector-ref norm 2) (vector-ref weights i)))))))))))))))
  
  
  (method (FillJointIndicesAndWeights vertex <f32vector> jointIndices jointWeights) <void>
    (vector-set! jointIndices 0 (get-boneId~ vertex))
    (vector-set! jointIndices 1 (vector-ref (get-boneIds~ vertex) 0))
    (vector-set! jointIndices 2 (vector-ref (get-boneIds~ vertex) 1))
    (vector-set! jointIndices 3 (vector-ref (get-boneIds~ vertex) 2))
    (vector-set! jointWeights 0 100)
    (vector-set! jointWeights 1 0)
    (vector-set! jointWeights 2 0)
    (vector-set! jointWeights 3 0)
    (when (or (or (/= (vector-ref (get-weights~ vertex) 0) 0)
                  (/= (vector-ref (get-weights~ vertex) 1) 0))
              (/= (vector-ref (get-weights~ vertex) 2) 0))
      (vector-set! jointWeights 0 (vector-ref (get-weights~ vertex) 0))
      (vector-set! jointWeights 1 (vector-ref (get-weights~ vertex) 1))
      (vector-set! jointWeights 2 (vector-ref (get-weights~ vertex) 2))
      (vector-set! jointWeights 3 (- 100 (+ (+ (vector-ref (get-weights~ vertex) 0)
                                               (vector-ref (get-weights~ vertex) 1))
                                            (vector-ref (get-weights~ vertex) 2)))))))


;;;
;;;; Vertex
;;;


(class MS3D-Vertex extends Object
  
  
  (slot flags          <fx>                                 accessors generate)
  (slot vertex         <f32vector> initialize (make-vertex) accessors generate)
  (slot boneId         <fx>                                 accessors generate)
  (slot referenceCount <fx>                                 accessors generate)
  (slot boneIds        <object>                             accessors generate)
  (slot weights        <object>                             accessors generate)
  (slot extra          <object>                             accessors generate)
  (slot renderColor    <f32vector> initialize (make-dye)    accessors generate)
  
  
  (method override (initialize flags vertex bone-id)
    (set! flags~self flags)
    (set! vertex~self vertex)
    (set! boneId~self bone-id)))


;;;
;;;; Triangle
;;;


(class MS3D-Triangle extends Object
  
  
  (slot flags           <fx+>       initialize #f accessors generate)
  (slot vertex-indices  <object>    initialize #f accessors generate)
  (slot vertex-normals  <object>    initialize #f accessors generate)
  (slot s               <f32vector> initialize #f accessors generate)
  (slot t               <f32vector> initialize #f accessors generate)
  (slot normal          <f32vector> initialize #f accessors generate)
  (slot smoothing-group <fx+>       initialize #f accessors generate)
  (slot group-index     <fx+>       initialize #f accessors generate)
  
  
  (method override (initialize flags vertex-indices vertex-normals s t smoothing-group group-index)
    (set! flags~self flags)
    (set! vertex-indices~self vertex-indices)
    (set! vertex-normals~self vertex-normals)
    (set! s~self s)
    (set! t~self t)
    (set! smoothing-group~self smoothing-group)
    (set! group-index~self group-index)))


;;;
;;;; Group
;;;


(class MS3D-Group extends Object
  
  
  (slot flags          <fx+>     initialize #f accessors generate)
  (slot name           <string+> initialize #f accessors generate)
  (slot triangles      <object>  initialize #f accessors generate)
  (slot material-index <fx+>     initialize #f accessors generate)
  (slot comment        <object>  initialize #f accessors generate)
  
  
  (method override (initialize flags name triangles material-index)
    (set! flags~self flags)
    (set! name~self name)
    (set! triangles~self triangles)
    (set! material-index~self material-index)))


;;;
;;;; KeyFrame
;;;


(class MS3D-KeyFrame extends Object

  
  (slot time <fl>                                 accessors generate)
  (slot key  <f32vector> initialize (make-vertex) accessors generate)
  
  
  (method override (initialize time key)
    (set! time~self time)
    (set! key~self key)))


;;;
;;;; Tangent
;;;


(class MS3D-Tangent extends Object
  
  
  (slot tangentIn  <f32vector> initialize (make-vertex) accessors generate)
  (slot tangentOut <f32vector> initialize (make-vertex) accessors generate))


;;;
;;;; Joint
;;;


(class MS3D-Joint extends Object
  
  
  (slot flags             <fx>                                 accessors generate)
  (slot name              <object>                             accessors generate)
  (slot parentName        <object>                             accessors generate)
  
  (slot rot               <f32vector> initialize (make-vertex) accessors generate)
  (slot pos               <f32vector> initialize (make-vertex) accessors generate)
  
  (slot rotationKeys      <Vector>                             accessors generate)
  (slot positionKeys      <Vector>                             accessors generate)
  (slot tangents          <Vector>                             accessors generate)
  
  (slot comment           <object>                             accessors generate)
  (slot color             <f32vector> initialize (make-dye)    accessors generate)
  
  ;; used for rendering
  (slot parentIndex       <fx>                                 accessors generate)
  (slot matLocalSkeleton  <Vector>    initialize (make-mat)    accessors generate)
  (slot matGlobalSkeleton <Vector>    initialize (make-mat)    accessors generate)
  
  (slot matLocal          <Vector>    initialize (make-mat)    accessors generate)
  (slot matGlobal         <Vector>    initialize (make-mat)    accessors generate)
  
  
  (method override (initialize flags name parentName rot pos rotationKeys positionKeys)
    (set! flags~self flags)
    (set! name~self name)
    (set! parentName~self parentName)
    (set! rot~self rot)
    (set! pos~self pos)
    (set! rotationKeys~self rotationKeys)
    (set! positionKeys~self positionKeys)))


;;;
;;;; Import
;;;


(definition debug-level
  #f)


(definition public (load-ms3d file)
  (let ((model (new Model)))
    (let ((mesh (get-mesh~ model)))
      (allocate-vertices~ mesh)
      (receive (data texture) (import-ms3d file)
        (set-data~ (get-vertices-buffer~ mesh) data 9)
        (set-material~ mesh (new Material texture: texture))))
    model))


(definition public (import-ms3d file (ms3d? #f))
  (call-with-input-file (path-settings file)
    (lambda (port)
      (let ((MAX_TEXTURE_FILENAME_SIZE 128)
            (size (input-port-byte-position port 0 2)))
        (input-port-byte-position port 0)
        (let ((content (make-u8vector size))
              (pos 0))
          (define (<-s8)
            (prog1 (scan-s8 content pos)
              (increase! pos 1)))
          
          (define (<-u8)
            (prog1 (scan-u8 content pos)
              (increase! pos 1)))
          
          (define (<-s16)
            (prog1 (scan-s16 content pos)
              (increase! pos 2)))
          
          (define (<-u16)
            (prog1 (scan-u16 content pos)
              (increase! pos 2)))
          
          (define (<-s32)
            (prog1 (scan-s32 content pos)
              (increase! pos 4)))
          
          (define (<-float)
            (prog1 (scan-float content pos)
              (increase! pos float-size)))
          
          (define (<-string size)
            (prog1 (scan-string content pos size)
              (increase! pos size)))
          
          (define (<-vertex)
            (let ((vertex (make-vertex)))
              (scan-floats! content pos vertex 3)
              (increase! pos (* 3 float-size))
              vertex))
          
          (define (<-indices)
            (list
              (<-u16)
              (<-u16)
              (<-u16)))
          
          (define (<-normals)
            (list
              (<-vertex)
              (<-vertex)
              (<-vertex)))
          
          (define (<-color)
            (let ((color (make-vertex)))
              (scan-floats! content pos color 4)
              (increase! pos (* 4 float-size))
              color))
          
          ;; vertices
          (define (<-vertices)
            (let ((num-vertices (<-u16)))
              (let ((vertices (make-vector num-vertices)))
                (loop (for i from 0 below num-vertices)
                      (let ((flags (<-u8))
                            (vertex (<-vertex))
                            (bone-id (<-s8))
                            (reference-count (<-u8)))
                        (if ms3d?
                            (vector-set! vertices i (new MS3D-Vertex flags vertex bone-id))
                          (vector-set! vertices i vertex))))
                vertices)))
          
          ;; triangles
          (define (<-triangles)
            (let ((num-triangles (<-u16)))
              (let ((triangles (make-vector num-triangles)))
                (loop (for i from 0 below num-triangles)
                      (let ((flags (<-u16))
                            (vertex-indices (<-indices))
                            (vertex-normals (<-normals))
                            (s (<-vertex))
                            (t (<-vertex))
                            (smoothing-group (<-u8))
                            (group-index (<-u8)))
                        (define (standardize v)
                          ;; quick fix until a clean solution to values out of the [0. 1.] range
                          (cond ((< v 0.) 0.)
                                ((> v 1.) 1.)
                                (else v)))
                        
                        (vertex-x-set! s (standardize (vertex-x s)))
                        (vertex-y-set! s (standardize (vertex-y s)))
                        (vertex-z-set! s (standardize (vertex-z s)))
                        (vertex-x-set! t (standardize (vertex-x t)))
                        (vertex-y-set! t (standardize (vertex-y t)))
                        (vertex-z-set! t (standardize (vertex-z t)))
                        (let ((triangle
                                (new MS3D-Triangle
                                  flags
                                  vertex-indices
                                  vertex-normals
                                  s
                                  t
                                  smoothing-group
                                  group-index)))
                          (vector-set! triangles i triangle))))
                ;; TODO: calculate triangle normal (comment from msViewer)
                triangles)))
          
          ;; groups
          (define (<-groups)
            (let ((num-groups (<-u16)))
              (let ((groups (make-vector num-groups)))
                (loop (for i from 0 below num-groups)
                      (let ((flags (<-u8))
                            (name (<-string 32))
                            (triangles
                              (let ((num-group-triangles (<-u16)))
                                (loop (for j from 0 below num-group-triangles)
                                      (collect (<-u16)))))
                            (material-index (<-s8)))
                        (let ((group
                                (new MS3D-Group
                                  flags
                                  name
                                  triangles
                                  material-index)))
                          (vector-set! groups i group))))
                groups)))
          
          ;; materials
          (define (<-materials)
            (let ((num-materials (<-u16)))
              (let ((materials (make-vector num-materials)))
                (loop (for i from 0 below num-materials)
                      (let ((name (<-string 32))
                            (ambient (<-color))
                            (diffuse (<-color))
                            (specular (<-color))
                            (emissive (<-color))
                            (shininess (<-float))
                            (transparency (<-float))
                            (mode (<-u8))
                            (texture (<-string MAX_TEXTURE_FILENAME_SIZE))
                            (alphamap (<-string MAX_TEXTURE_FILENAME_SIZE)))
                        ;; set alpha
                        (dye-alpha-set! ambient transparency)
                        (dye-alpha-set! diffuse transparency)
                        (dye-alpha-set! specular transparency)
                        (dye-alpha-set! emissive transparency)
                        (let ((material
                                (new Material
                                  name: name
                                  ambient: ambient
                                  diffuse: diffuse
                                  specular: specular
                                  emissive: emissive
                                  shininess: shininess
                                  transparency: transparency
                                  mode: mode
                                  texture: texture
                                  alphamap: alphamap)))
                          (vector-set! materials i material))))
                materials)))
          
          ;; joints
          (define (<-joints animationFps)
            (let ((num-joints (<-u16)))
              (let ((joints (make-vector num-joints)))
                (loop (for i from 0 below num-joints)
                      (let ((flags (<-u8))
                            (name (<-string 32))
                            (parent-name (<-string 32))
                            (rot (<-vertex))
                            (pos (<-vertex))
                            (num-key-frames-rot (<-u16))
                            (num-key-frames-pos (<-u16)))
                        (let ((rotationKeys (make-vector num-key-frames-rot))
                              (positionKeys (make-vector num-key-frames-pos)))
                          ;; the frame time is in seconds, so multiply it by the animation fps
                          ;; to get the frames rotation channel
                          (loop (for j from 0 below num-key-frames-rot)
                                (let ((time (<-float))
                                      (key (<-vertex)))
                                  (let ((time (* time animationFps)))
                                    (vector-set! rotationKeys j (new MS3D-KeyFrame time key)))))
                          ;; translation channel
                          (loop (for j from 0 below num-key-frames-pos)
                                (let ((time (<-float))
                                      (key (<-vertex)))
                                  (let ((time (* time animationFps)))
                                    (vector-set! positionKeys j (new MS3D-KeyFrame time key)))))
                          (let ((joint (if ms3d?
                                           (new MS3D-Joint flags name parent-name rot pos rotationKeys positionKeys)
                                         (new Joint
                                           flags: flags
                                           name: name
                                           parent-name: parent-name
                                           rot: rot
                                           pos: pos))))
                            (vector-set! joints i joint)))))
                joints)))
          
          (read-subu8vector content 0 size port)
          
          ;; header
          (assert (equal? (<-string 10) "MS3D000000"))
          (assert (= (<-s32) 4))
          
          ;; content
          (let ((model (new MS3D-Model))
                (vertices (<-vertices))
                (triangles (<-triangles))
                (groups (<-groups))
                (materials (<-materials)))
            (define (vertex-ref index)
              (vector-ref vertices index))
            
            (define (triangle-ref index)
              (vector-ref triangles index))
            
            (define (material-ref index)
              (vector-ref materials index))
            
            ;; vertices
            (when ms3d?
              (set-m_vertices~ model vertices))
            ;; triangles
            (when ms3d?
              (set-m_triangles~ model triangles))
            ;; groups
            (when ms3d?
              (set-m_groups~ model groups))
            ;; materials
            (when ms3d?
              (set-m_materials~ model materials))
            ;; animation
            (let ((animation-fps (max 1. (<-float)))
                  (current-time (<-float))
                  (total-frames (<-s32)))
              (set-animation-fps~ model animation-fps) (set-m_animationFps~ model animation-fps)
              (set-current-time~ model current-time) (set-m_currentTime~ model current-time)
              (set-total-frames~ model total-frames) (set-m_totalFrames~ model total-frames))
            (let ((joints (<-joints (get-m_animationFps~ model))))
              ;; joints
              (when ms3d?
                (set-m_joints~ model joints))
              ;; debug
              (when debug-level
                (debug vertices: (vector-length vertices))
                (debug triangles: (vector-length triangles))
                (debug groups: (vector-length groups))
                (when (eq? debug-level 'high)
                  (for-each (lambda (group)
                              (format :console "  {a}: {a} {a} {a}{%}" (get-name~ group) (get-flags~ group) (length (get-triangles~ group)) (get-material-index~ group)))
                            (vector->list groups)))
                (debug materials: (vector-length materials))
                (when (eq? debug-level 'high)
                  (for-each (lambda (material)
                              (format :console "  {a}: {a} {a} {a} {a} {a} {a} {a} {a} {a}{%}"
                                (get-name~ material)
                                (get-ambient~ material)
                                (get-diffuse~ material)
                                (get-specular~ material)
                                (get-emissive~ material)
                                (get-shininess~ material)
                                (get-transparency~ material)
                                (get-mode~ material)
                                (get-texture~ material)
                                (get-alphamap~ material)))
                            (vector->list materials)))
                (debug joints: (vector-length joints))
                (when (eq? debug-level 'high)
                  (for-each (lambda (joint)
                              (format :console "  {a}: {a}{%}" (get-name~ joint) (get-flags~ joint)))
                            (vector->list joints))))
              ;; atlas
              (let ((atlas (new Atlas mipmap?: #f pad?: #f))
                    (textures (remove-duplicates (remove-empty (map get-texture~ (vector->list materials))) test: filename=?)))
                (for-each (lambda (texture)
                            (add-file~ atlas (new-brother~ file texture)))
                          textures)
                (complete~ atlas)
                (loop (for group in-vector groups)
                      (let ((material (material-ref (get-material-index~ group))))
                        (let ((rect (image-rect~ atlas (extract-base (get-texture~ material)))))
                          (let ((left (get-left~ rect))
                                (top (get-top~ rect)))
                            (let ((width (- (get-right~ rect) left))
                                  (height (- (get-bottom~ rect) top)))
                              ;; debug
                              (when (eq? debug-level 'atlas)
                                (let ((min 1000.)
                                      (max -1000.))
                                  (define (test v)
                                    (if (< v min)
                                        (set! min v)
                                      (if (> v max)
                                          (set! max v))))
                                  
                                  (for-each (lambda (triangle-index)
                                              (let ((triangle (triangle-ref triangle-index)))
                                                (let ((s (get-s~ triangle))
                                                      (t (get-t~ triangle)))
                                                  (test (vertex-x s))
                                                  (test (vertex-y s))
                                                  (test (vertex-z s))
                                                  (test (vertex-x t))
                                                  (test (vertex-y t))
                                                  (test (vertex-z t)))))
                                            (get-triangles~ group))
                                (debug (get-name~ group)
                                       min
                                       max)))
                              ;; adjust
                              (for-each (lambda (triangle-index)
                                          (let ((triangle (triangle-ref triangle-index)))
                                            (let ((s (get-s~ triangle))
                                                  (t (get-t~ triangle)))
                                              (vertex-x-set! s (+ left (* (vertex-x s) width)))
                                              (vertex-y-set! s (+ left (* (vertex-y s) width)))
                                              (vertex-z-set! s (+ left (* (vertex-z s) width)))
                                              (vertex-x-set! t (+ top (* (- 1. (vertex-x t)) height)))
                                              (vertex-y-set! t (+ top (* (- 1. (vertex-y t)) height)))
                                              (vertex-z-set! t (+ top (* (- 1. (vertex-z t)) height))))))
                                        (get-triangles~ group)))))))
                (if ms3d?
                    model
                ;; mesh
                (let ((triangle-floats (* 3 3 3))
                      (triangles-count (vector-length triangles)))
                  (let ((content (make-f32vector (* triangles-count triangle-floats)))
                        (n 0))
                    (define (add-triangle triangle)
                      (let ((indices (get-vertex-indices~ triangle))
                            (normals (get-vertex-normals~ triangle))
                            (s (get-s~ triangle))
                            (t (get-t~ triangle)))
                        (let ((v1 (vertex-ref (first indices)))
                              (v2 (vertex-ref (second indices)))
                              (v3 (vertex-ref (third indices))))
                          (add
                            v1 (vertex (vertex-x s) (vertex-x t) 1.) (first normals)
                            v2 (vertex (vertex-y s) (vertex-y t) 1.) (second normals)
                            v3 (vertex (vertex-z s) (vertex-z t) 1.) (third normals)))))
                    
                    (define (add v1 t1 n1 v2 t2 n2 v3 t3 n3)
                      (add-vertex v1) (add-texture t1) (add-normal n1)
                      (add-vertex v2) (add-texture t2) (add-normal n2)
                      (add-vertex v3) (add-texture t3) (add-normal n3))
                    
                    (define (add-vertex vert)
                      (f32vector-set! content n (vertex-x vert))
                      (f32vector-set! content (+ n 1) (vertex-y vert))
                      (f32vector-set! content (+ n 2) (vertex-z vert))
                      (set! n (+ n 3)))
                    
                    (define (add-texture tex)
                      (f32vector-set! content n (vertex-x tex))
                      (f32vector-set! content (+ n 1) (vertex-y tex))
                      (f32vector-set! content (+ n 2) 0.)
                      (set! n (+ n 3)))
                    
                    (define (add-normal normal)
                      (f32vector-set! content n (vertex-x normal))
                      (f32vector-set! content (+ n 1) (vertex-y normal))
                      (f32vector-set! content (+ n 2) (vertex-z normal))
                      (set! n (+ n 3)))
                    
                    (loop (for triangle in-vector triangles)
                          (add-triangle triangle))
                    (values content (get-texture~ atlas)))))))
          
          ;; comments
          ;; vertex extra
          ;; joint extra
          ;; model extra
          )))))))
