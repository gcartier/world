;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; MilkShape 3D
;;;


;; This is a port to Jazz of Mete Ciragan's msViewer
;;
;; email:          mciragan@gmx.net
;; web:            http://www.milkshape3d.com


(module world.external.milkshape jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (world)
        (world.atlas)
        (world.binary)
        (world.dye)
        (world.foreign)
        (world.geometry)
        (world.joint)
        (world.material)
        (world.model)
        (world.texture))


(proclaim (warn optimizations))


;;;
;;;; Math
;;;


(define (translate-matrix! res <f32vector> trans <f32vector>) <f32vector>
  (matrix-set! res 12 (vertex-x trans))
  (matrix-set! res 13 (vertex-y trans))
  (matrix-set! res 14 (vertex-z trans))
  res)


(define (angle-matrix! res <f32vector> angles <f32vector>) <f32vector>
  (let ((rx (vertex-x angles))
        (ry (vertex-y angles))
        (rz (vertex-z angles)))
    (let ((sr (sin rx))
          (sp (sin ry))
          (sy (sin rz))
          (cr (cos rx))
          (cp (cos ry))
          (cy (cos rz)))
      ;; res = (Z * Y) * X
      (matrix-set! res  0 (* cp cy))
      (matrix-set! res  1 (* cp sy))
      (matrix-set! res  2 (- sp))
      (matrix-set! res  4 (+ (* (* sr sp) cy) (* cr (- sy))))
      (matrix-set! res  5 (+ (* (* sr sp) sy) (* cr cy)))
      (matrix-set! res  6 (* sr cp))
      (matrix-set! res  8 (+ (* (* cr sp) cy) (* (- sr) (- sy))))
      (matrix-set! res  9 (+ (* (* cr sp) sy) (* (- sr) cy)))
      (matrix-set! res 10 (* cr cp))
      (matrix-set! res 12 0.)
      (matrix-set! res 13 0.)
      (matrix-set! res 14 0.)))
  res)


(define (angle-quaternion! res <f32vector> angles <f32vector>) <f32vector>
  (let ((rx (vertex-x angles))
        (ry (vertex-y angles))
        (rz (vertex-z angles)))
    (let ((sr (sin (* rx .5)))
          (sp (sin (* ry .5)))
          (sy (sin (* rz .5)))
          (cr (cos (* rx .5)))
          (cp (cos (* ry .5)))
          (cy (cos (* rz .5))))
      (quaternion-x-set! res (- (* sr cp cy) (* cr sp sy)))
      (quaternion-y-set! res (+ (* cr sp cy) (* sr cp sy)))
      (quaternion-z-set! res (- (* cr cp sy) (* sr sp cy)))
      (quaternion-w-set! res (+ (* cr cp cy) (* sr sp sy)))))
  res)


(define (quaternion-matrix! res <f32vector> quat <f32vector>) <f32vector>
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (matrix-set! res  0 (- (- 1. (* 2. y y)) (* 2. z z)))
    (matrix-set! res  1 (+ (* 2. x y) (* 2. w z)))
    (matrix-set! res  2 (- (* 2. x z) (* 2. w y)))
    (matrix-set! res  4 (- (* 2. x y) (* 2. w z)))
    (matrix-set! res  5 (- (- 1. (* 2. x x)) (* 2. z z)))
    (matrix-set! res  6 (+ (* 2. y z) (* 2. w x)))
    (matrix-set! res  8 (+ (* 2. x z) (* 2. w y)))
    (matrix-set! res  9 (- (* 2. y z) (* 2. w x)))
    (matrix-set! res 10 (- (- 1. (* 2. x x)) (* 2. y y))))
  res)


(define (quaternion-slerp! res <f32vector> p <f32vector> q <f32vector> t <fl>) <f32vector>
  (let ((i 0)
        (omega 0.)
        (cosom 0.)
        (sinom 0.)
        (sclp 0.)
        (sclq 0.))
    ;; decide if one of the quaternions is backwards
    (let ((a 0.)
          (b 0.))
      (loop (for i <fx> iterate (set! i 0) (< i 4) (increase! i))
            (let ((pi (f32vector-ref p i))
                  (qi (f32vector-ref q i)))
              (increase! a (* (- pi qi) (- pi qi)))
              (increase! b (* (+ pi qi) (+ pi qi)))))
      (when (> a b)
        (loop (for i <fx> iterate (set! i 0) (< i 4) (increase! i))
              (f32vector-set! q i (- (f32vector-ref q i)))))
      (set! cosom
            (+ (* (quaternion-x p) (quaternion-x q))
               (* (quaternion-y p) (quaternion-y q))
               (* (quaternion-z p) (quaternion-z q))
               (* (quaternion-w p) (quaternion-w q))))
      (if (> (+ 1. cosom) 1e-8)
          (begin
            (if (> (- 1. cosom) 1e-8)
                (begin
                  (set! omega (cast <fl> (acos cosom)))
                  (set! sinom (sin omega))
                  (set! sclp (/ (sin (* (- 1. t) omega)) sinom))
                  (set! sclq (/ (sin (* t omega)) sinom)))
              (begin
                (set! sclp (- 1. t))
                (set! sclq t)))
            (loop (for i <fx> iterate (set! i 0) (< i 4) (increase! i))
                  (f32vector-set! res i (+ (* sclp (f32vector-ref p i))
                                           (* sclq (f32vector-ref q i))))))
        (begin
          (quaternion-x-set! res (- (quaternion-y p)))
          (quaternion-y-set! res (quaternion-x p))
          (quaternion-z-set! res (- (quaternion-w p)))
          (quaternion-w-set! res (quaternion-z p))
          (set! sclp (sin (* (- 1. t) .5 PI)))
          (set! sclq (sin (* t .5 PI)))
          (loop (for i <fx> iterate (set! i 0) (< i 3) (increase! i))
                (f32vector-set! res i (+ (* sclp (f32vector-ref p i))
                                         (* sclq (f32vector-ref res i)))))))))
  res)


;;;
;;;; Vertex
;;;


(class MS3D-Vertex extends Object
  
  
  (slot flags   <fx>                                 accessors generate)
  (slot vertex  <f32vector> initialize (make-vertex) accessors generate)
  (slot bone-id <fx>                                 accessors generate)
  
  
  (method override (initialize flags vertex bone-id)
    (set! flags~self flags)
    (set! vertex~self vertex)
    (set! bone-id~self bone-id)))


;;;
;;;; Triangle
;;;


(class MS3D-Triangle extends Object
  
  
  (slot flags           <fx+>       initialize #f accessors generate)
  (slot vertex-indices  <object>    initialize #f accessors generate)
  (slot vertex-normals  <object>    initialize #f accessors generate)
  (slot s               <f32vector> initialize #f accessors generate)
  (slot t               <f32vector> initialize #f accessors generate)
  (slot normal          <f32vector> initialize #f accessors generate)
  (slot smoothing-group <fx+>       initialize #f accessors generate)
  (slot group-index     <fx+>       initialize #f accessors generate)
  
  
  (method override (initialize flags vertex-indices vertex-normals s t smoothing-group group-index)
    (set! flags~self flags)
    (set! vertex-indices~self vertex-indices)
    (set! vertex-normals~self vertex-normals)
    (set! s~self s)
    (set! t~self t)
    (set! smoothing-group~self smoothing-group)
    (set! group-index~self group-index)))


;;;
;;;; Group
;;;


(class MS3D-Group extends Object
  
  
  (slot flags          <fx+>     initialize #f accessors generate)
  (slot name           <string+> initialize #f accessors generate)
  (slot triangles      <object>  initialize #f accessors generate)
  (slot material-index <fx+>     initialize #f accessors generate)
  
  
  (method override (initialize flags name triangles material-index)
    (set! flags~self flags)
    (set! name~self name)
    (set! triangles~self triangles)
    (set! material-index~self material-index)))


;;;
;;;; KeyFrame
;;;


(class MS3D-KeyFrame extends Object

  
  (slot time <fl>                                 accessors generate)
  (slot key  <f32vector> initialize (make-vertex) accessors generate)
  
  
  (method override (initialize time key)
    (set! time~self time)
    (set! key~self key)))


;;;
;;;; Tangent
;;;


(class MS3D-Tangent extends Object
  
  
  (slot in  <f32vector> initialize (make-vertex) accessors generate)
  (slot out <f32vector> initialize (make-vertex) accessors generate))


;;;
;;;; Joint
;;;


(class MS3D-Joint extends Object
  
  
  (slot flags                  <fx>                                          accessors generate)
  (slot name                   <object>                                      accessors generate)
  (slot parent-name            <object>                                      accessors generate)
  
  (slot rot                    <f32vector> initialize (make-vertex)          accessors generate)
  (slot pos                    <f32vector> initialize (make-vertex)          accessors generate)
  
  (slot rotation-keys          <Vector>                                      accessors generate)
  (slot position-keys          <Vector>                                      accessors generate)
  (slot tangents               <Vector>                                      accessors generate)
  
  ;; used for rendering
  (slot parent-index           <fx>                                          accessors generate)
  (slot local-skeleton-matrix  <f32vector> initialize (make-identity-matrix) accessors generate)
  (slot global-skeleton-matrix <f32vector> initialize (make-identity-matrix) accessors generate)
  
  (slot local-matrix           <f32vector> initialize (make-identity-matrix) accessors generate)
  (slot global-matrix          <f32vector> initialize (make-identity-matrix) accessors generate)
  
  (slot bone-transformation    <f32vector> initialize (make-identity-matrix) accessors generate)
  
  
  (method override (initialize flags name parent-name rot pos rotation-keys position-keys)
    (set! flags~self flags)
    (set! name~self name)
    (set! parent-name~self parent-name)
    (set! rot~self rot)
    (set! pos~self pos)
    (set! rotation-keys~self rotation-keys)
    (set! position-keys~self position-keys)))


;;;
;;;; Model
;;;


(class MS3D-Model extends Object
  
  
  (slot file                   getter generate)
  
  (slot vertices      <object> accessors generate)
  (slot triangles     <object> accessors generate)
  (slot groups        <object> accessors generate)
  (slot materials     <object> accessors generate)
  (slot animation-fps <fl>     accessors generate)
  (slot current-time  <fl>     accessors generate)
  (slot total-frames  <fx>     accessors generate)
  (slot joints        <object> accessors generate)
  
  (slot texture       <object> accessors generate)
  (slot data          <object> accessors generate)
  
  
  (method override (initialize file)
    (set! file~self file))
  
  
  (method (find-joint-index name) <fx>
    (loop (for i <fx> iterate (set! i 0) (< i (cast <fx> (vector-length joints))) (increase! i))
          (when (equal? (get-name~ (cast <MS3D-Joint> (vector-ref joints i))) name)
            (return i))
          (finally -1)))
  
  
  (method (setup-joints) <void>
    (loop (for i <fx> iterate (set! i 0) (< i (cast <fx> (vector-length joints))) (increase! i))
          (let ((joint <MS3D-Joint> (vector-ref joints i)))
            (set-parent-index~ joint (find-joint-index (get-parent-name~ joint)))))
    (loop (for i <fx> iterate (set! i 0) (< i (cast <fx> (vector-length joints))) (increase! i))
          (let ((joint <MS3D-Joint> (vector-ref joints i)))
            (let ((joint-pos (get-pos~ joint))
                  (joint-rot (get-rot~ joint))
                  (joint-local-skeleton-matrix (get-local-skeleton-matrix~ joint))
                  (joint-global-skeleton-matrix (get-global-skeleton-matrix~ joint)))
              (angle-matrix! joint-local-skeleton-matrix joint-rot)
              (translate-matrix! joint-local-skeleton-matrix joint-pos)
              (if (= (get-parent-index~ joint) -1)
                  (matrix-copy! joint-global-skeleton-matrix joint-local-skeleton-matrix)
                (let ((parent-joint <MS3D-Joint> (vector-ref joints (get-parent-index~ joint))))
                  (matrix-multiply!
                    joint-global-skeleton-matrix
                    (get-global-skeleton-matrix~ parent-joint)
                    joint-local-skeleton-matrix)))
              (setup-tangents)))))
  
  
  (method (setup-tangents) <void>
    (loop (for j <fx> iterate (set! j 0) (< j (cast <fx> (vector-length joints))) (increase! j))
          (let ((joint <MS3D-Joint> (vector-ref joints j)))
            (let ((position-keys (get-position-keys~ joint)))
              (let ((num-position-keys <fx> (vector-length position-keys)))
                (let ((tangents (make-vector num-position-keys)))
                  (set-tangents~ joint tangents)
                  (loop (for i from 0 below num-position-keys)
                        (vector-set! tangents i (new MS3D-Tangent)))
                  ;; clear all tangents (zero derivatives)
                  (loop (for k <fx> iterate (set! k 0) (< k num-position-keys) (increase! k))
                        (vertex-init! (get-in~ (vector-ref tangents k)) 0. 0. 0.)
                        (vertex-init! (get-out~ (vector-ref tangents k)) 0. 0. 0.))
                  ;; if there are more than 2 keys, we can calculate tangents, otherwise we use zero derivatives
                  (when (> num-position-keys 2)
                    (loop (for k <fx> iterate (set! k 0) (< k num-position-keys) (increase! k))
                          ;; make the curve tangents looped
                          (let ((k0 <fx> (- k 1)))
                            (when (< k0 0) (set! k0 (- num-position-keys 1)))
                            (let ((k1 <fx> k)
                                  (k2 <fx> (+ k 1)))
                              (when (>= k2 num-position-keys) (set! k2 0))
                              ;; calculate the tangent, which is the vector from key[k - 1] to key[k + 1]
                              (let ((tangent (vertex- (get-key~ (vector-ref position-keys k2))
                                                      (get-key~ (vector-ref position-keys k0)))))
                                ;; weight the incoming and outgoing tangents by their time to avoid changes in speed if the keys are not within the same interval
                                (let ((dt1 <fl> (- (get-time~ (vector-ref position-keys k1)) (get-time~ (vector-ref position-keys k0))))
                                      (dt2 <fl> (- (get-time~ (vector-ref position-keys k2)) (get-time~ (vector-ref position-keys k1)))))
                                  (let ((dt <fl> (+ dt1 dt2)))
                                    (vertex-scalar*! (get-in~  (vector-ref tangents k1)) tangent (/ dt1 dt))
                                    (vertex-scalar*! (get-out~ (vector-ref tangents k1)) tangent (/ dt2 dt)))))))))))))))
  
  
  (method (set-frame frame <fl>) <void>
    (if (< frame 0.)
        (loop (for i <fx> iterate (set! i 0) (< i (cast <fx> (vector-length joints))) (increase! i))
              (let ((joint <MS3D-Joint> (vector-ref joints i)))
                (matrix-copy! (get-local-matrix~ joint) (get-local-skeleton-matrix~ joint))
                (matrix-copy! (get-global-matrix~ joint) (get-global-skeleton-matrix~ joint))))
      (loop (for i <fx> iterate (set! i 0) (< i (cast <fx> (vector-length joints))) (increase! i))
            (evaluate-joint i frame)))
    (set! current-time frame))
  
  
  (method (evaluate-joint index <fx> frame <fl>) <void>
    (let ((joint <MS3D-Joint> (vector-ref joints index)))
      ;; calculate joint animation matrix, this matrix will animate local-skeleton-matrix
      (let ((pos (vertex& 0. 0. 0.)))
        (let ((position-keys (get-position-keys~ joint)))
          (let ((num-position-keys <fx> (vector-length position-keys)))
            (when (> num-position-keys 0)
              (let ((i1 <fx> -1)
                    (i2 <fx> -1))
                ;; find the two keys, where "frame" is in between for the position channel
                (loop (for i <fx> iterate (set! i 0) (< i (- num-position-keys 1)) (increase! i))
                      (when (and (>= frame (get-time~ (cast <MS3D-KeyFrame> (vector-ref position-keys i))))
                                 (< frame (get-time~ (cast <MS3D-KeyFrame> (vector-ref position-keys (+ i 1))))))
                        (set! i1 i)
                        (set! i2 (+ i 1))
                        (return)))
                ;; if there are no such keys
                (if (or (= i1 -1) (= i2 -1))
                    ;; either take the first
                    (let ((first-key (cast <MS3D-KeyFrame> (vector-ref position-keys 0))))
                      (if (< frame (get-time~ first-key))
                          (vertex-copy! pos (get-key~ first-key))
                        (let ((last-key (cast <MS3D-KeyFrame> (vector-ref position-keys (- num-position-keys 1)))))
                          (when (>= frame (get-time~ last-key))
                            ;; or the last key
                            (vertex-copy! pos (get-key~ last-key))))))
                  ;; there are such keys, so interpolate using hermite interpolation
                  (let ((p0 <MS3D-KeyFrame> (vector-ref position-keys i1))
                        (p1 <MS3D-KeyFrame> (vector-ref position-keys i2))
                        (m0 <MS3D-Tangent> (vector-ref (get-tangents~ joint) i1))
                        (m1 <MS3D-Tangent> (vector-ref (get-tangents~ joint) i2)))
                    ;; normalize the time between the keys into [0..1]
                    (let ((t <fl>
                            (let ((key1 (cast <MS3D-KeyFrame> (vector-ref position-keys i1)))
                                  (key2 (cast <MS3D-KeyFrame> (vector-ref position-keys i2))))
                              (/ (- frame (get-time~ key1))
                                 (- (get-time~ key2) (get-time~ key1))))))
                      (let ((t2 <fl> (* t t)))
                        (let ((t3 <fl> (* t2 t)))
                          ;; calculate hermite basis
                          (let ((h1 <fl> (+ (- (* 2. t3) (* 3. t2)) 1.))
                                (h2 <fl> (+ (* (- 2.) t3) (* 3. t2)))
                                (h3 <fl> (+ (- t3 (* 2. t2)) t))
                                (h4 <fl> (- t3 t2)))
                            ;; do hermite interpolation
                            (vertex-x-set! pos (+ (* h1 (vertex-x (get-key~ p0))) (* h3 (vertex-x (get-out~ m0))) (* h2 (vertex-x (get-key~ p1))) (* h4 (vertex-x (get-in~ m1)))))
                            (vertex-y-set! pos (+ (* h1 (vertex-y (get-key~ p0))) (* h3 (vertex-y (get-out~ m0))) (* h2 (vertex-y (get-key~ p1))) (* h4 (vertex-y (get-in~ m1)))))
                            (vertex-z-set! pos (+ (* h1 (vertex-z (get-key~ p0))) (* h3 (vertex-z (get-out~ m0))) (* h2 (vertex-z (get-key~ p1))) (* h4 (vertex-z (get-in~ m1)))))))))))))
            (let ((quat (quaternion& 0. 0. 0. 1.))
                  (rotation-keys (get-rotation-keys~ joint)))
              (let ((num-rotation-keys <fx> (vector-length rotation-keys)))
                (when (> num-rotation-keys 0)
                  (let ((i1 <fx> -1)
                        (i2 <fx> -1))
                    ;; find the two keys, where "frame" is in between for the rotation channel
                    (loop (for i <fx> iterate (set! i 0) (< i (- num-rotation-keys 1)) (increase! i))
                          (when (and (>= frame (get-time~ (cast <MS3D-KeyFrame> (vector-ref rotation-keys i))))
                                     (< frame (get-time~ (cast <MS3D-KeyFrame> (vector-ref rotation-keys (+ i 1))))))
                            (set! i1 i)
                            (set! i2 (+ i 1))
                            (return)))
                    ;; if there are no such keys
                    (if (or (= i1 -1) (= i2 -1))
                        ;; either take the first key
                        (let ((first-key (cast <MS3D-KeyFrame> (vector-ref rotation-keys 0))))
                          (if (< frame (get-time~ first-key))
                              (angle-quaternion! quat (get-key~ first-key))
                            (let ((last-key (cast <MS3D-KeyFrame> (vector-ref rotation-keys (- num-rotation-keys 1)))))
                              (when (>= frame (get-time~ last-key))
                                ;; or the last key
                                (angle-quaternion! quat (get-key~ last-key))))))
                      ;; there are such keys, so do the quaternion slerp interpolation
                      (let ((t <fl>
                              (let ((key1 (cast <MS3D-KeyFrame> (vector-ref rotation-keys i1)))
                                    (key2 (cast <MS3D-KeyFrame> (vector-ref rotation-keys i2))))
                                (/ (- frame (get-time~ key1))
                                   (- (get-time~ key2) (get-time~ key1))))))
                        (let ((q1 (make-quaternion&)))
                          (angle-quaternion! q1 (get-key~ (cast <MS3D-KeyFrame> (vector-ref rotation-keys i1))))
                          (let ((q2 (make-quaternion&)))
                            (angle-quaternion! q2 (get-key~ (cast <MS3D-KeyFrame> (vector-ref rotation-keys i2))))
                            (quaternion-slerp! quat q1 q2 t)))))))
                ;; make a matrix from pos/quat
                (let ((animation-matrix (make-identity-matrix&)))
                  (quaternion-matrix! animation-matrix quat)
                  (translate-matrix! animation-matrix pos)
                  ;; animate the local joint matrix using: local-matrix = local-skeleton-matrix * animation-matrix
                  (matrix-multiply! (get-local-matrix~ joint) (get-local-skeleton-matrix~ joint) animation-matrix)
                  ;; build up the hierarchy if joints
                  ;; global-matrix = global-matrix(parent) * local-matrix
                  (if (= (get-parent-index~ joint) -1)
                      (matrix-copy! (get-global-matrix~ joint) (get-local-matrix~ joint))
                    (let ((parent-joint <MS3D-Joint> (vector-ref joints (get-parent-index~ joint))))
                      (matrix-multiply!
                        (get-global-matrix~ joint)
                        (get-global-matrix~ parent-joint)
                        (get-local-matrix~ joint)))))
                ;; construct the bone transformation
                (let ((t (make-identity-matrix&))
                      (u (make-identity-matrix&))
                      (v (make-identity-matrix&))
                      (joint-global-skeleton-matrix (get-global-skeleton-matrix~ joint)))
                  (matrix-set! t 12 (- (matrix-ref joint-global-skeleton-matrix 12)))
                  (matrix-set! t 13 (- (matrix-ref joint-global-skeleton-matrix 13)))
                  (matrix-set! t 14 (- (matrix-ref joint-global-skeleton-matrix 14)))
                  (matrix-transpose-3x3! u joint-global-skeleton-matrix)
                  (matrix-set! u 12 0.)
                  (matrix-set! u 13 0.)
                  (matrix-set! u 14 0.)
                  (matrix-multiply! v t u)
                  (matrix-multiply! (get-bone-transformation~ joint) (get-global-matrix~ joint) v)))))))))
  
  
  (method public (extract-mesh)
    (let ((floats-per-indice 10))
      (let ((triangle-floats (* 3 floats-per-indice))
            (triangles-count (vector-length triangles)))
        (let ((content (make-f32vector (* triangles-count triangle-floats)))
              (n 0))
          (define (vertex-ref index)
            (vector-ref vertices index))
          
          (define (add-triangle triangle)
            (let ((indices (get-vertex-indices~ triangle))
                  (normals (get-vertex-normals~ triangle))
                  (s (get-s~ triangle))
                  (t (get-t~ triangle)))
              (let ((v1 (vertex-ref (first indices)))
                    (v2 (vertex-ref (second indices)))
                    (v3 (vertex-ref (third indices))))
                (add
                  (get-vertex~ v1) (vertex (vertex-x s) (vertex-x t) 1.) (first  normals) (get-bone-id~ v1)
                  (get-vertex~ v2) (vertex (vertex-y s) (vertex-y t) 1.) (second normals) (get-bone-id~ v2)
                  (get-vertex~ v3) (vertex (vertex-z s) (vertex-z t) 1.) (third  normals) (get-bone-id~ v3)))))
          
          (define (add v1 t1 n1 b1 v2 t2 n2 b2 v3 t3 n3 b3)
            (add-vertex v1) (add-texture t1) (add-normal n1) (add-bone b1)
            (add-vertex v2) (add-texture t2) (add-normal n2) (add-bone b2)
            (add-vertex v3) (add-texture t3) (add-normal n3) (add-bone b3))
          
          (define (add-vertex vert)
            (f32vector-set! content n (vertex-x vert))
            (f32vector-set! content (+ n 1) (vertex-y vert))
            (f32vector-set! content (+ n 2) (vertex-z vert))
            (set! n (+ n 3)))
          
          (define (add-texture tex)
            (f32vector-set! content n (vertex-x tex))
            (f32vector-set! content (+ n 1) (vertex-y tex))
            (f32vector-set! content (+ n 2) 0.)
            (set! n (+ n 3)))
          
          (define (add-normal normal)
            (f32vector-set! content n (vertex-x normal))
            (f32vector-set! content (+ n 1) (vertex-y normal))
            (f32vector-set! content (+ n 2) (vertex-z normal))
            (set! n (+ n 3)))
          
          (define (add-bone bone-id)
            (f32vector-set! content n (cast <fl> bone-id))
            (set! n (+ n 1)))
          
          (loop (for triangle in-vector triangles)
                (add-triangle triangle))
          content)))))


;;;
;;;; Import
;;;


(definition public (load-ms3d file)
  (let ((model (new Model)))
    (let ((mesh (get-mesh~ model)))
      (allocate-vertices~ mesh)
      (let ((imported (import-ms3d file)))
        (setup-joints~ imported)
        (set-imported~ model imported)
        (let ((data (extract-mesh~ imported))
              (texture (get-texture~ imported)))
          (set-data~ (get-vertices-buffer~ mesh) data 10)
          (set-material~ mesh (new Material texture: texture)))))
    model))


(definition public (import-ms3d file)
  (call-with-input-file (path-settings file)
    (lambda (port)
      (let ((MAX_TEXTURE_FILENAME_SIZE 128)
            (fileSize (input-port-byte-position port 0 2)))
        (input-port-byte-position port 0)
        (let ((content (make-u8vector fileSize))
              (pos 0))
          (define (<-s8)
            (prog1 (scan-s8 content pos)
              (increase! pos 1)))
          
          (define (<-u8)
            (prog1 (scan-u8 content pos)
              (increase! pos 1)))
          
          (define (<-s16)
            (prog1 (scan-s16 content pos)
              (increase! pos 2)))
          
          (define (<-u16)
            (prog1 (scan-u16 content pos)
              (increase! pos 2)))
          
          (define (<-s32)
            (prog1 (scan-s32 content pos)
              (increase! pos 4)))
          
          (define (<-float)
            (prog1 (scan-float content pos)
              (increase! pos float-size)))
          
          (define (<-floats! vec)
            (let ((len (f32vector-length vec)))
              (scan-floats! content pos vec len)
              (increase! pos (* len float-size))
              vec))
          
          (define (<-string size)
            (prog1 (scan-string content pos size)
              (increase! pos size)))
          
          (define (<-vertex)
            (<-floats! (make-vertex)))
          
          (define (<-color)
            (<-floats! (make-dye)))
          
          (define (<-indices)
            (list
              (<-u16)
              (<-u16)
              (<-u16)))
          
          (define (<-normals)
            (list
              (<-vertex)
              (<-vertex)
              (<-vertex)))
          
          ;; vertices
          (define (<-vertices)
            (let ((num-vertices (<-u16)))
              (let ((vertices (make-vector num-vertices)))
                (loop (for i from 0 below num-vertices)
                      (let ((flags (<-u8))
                            (vertex (<-vertex))
                            (bone-id (<-s8))
                            (reference-count (<-u8)))
                        (vector-set! vertices i (new MS3D-Vertex flags vertex bone-id))))
                vertices)))
          
          ;; triangles
          (define (<-triangles)
            (let ((num-triangles (<-u16)))
              (let ((triangles (make-vector num-triangles)))
                (loop (for i from 0 below num-triangles)
                      (let ((flags (<-u16))
                            (vertex-indices (<-indices))
                            (vertex-normals (<-normals))
                            (s (<-vertex))
                            (t (<-vertex))
                            (smoothing-group (<-u8))
                            (group-index (<-u8)))
                        (define (standardize v)
                          ;; quick fix until a clean solution to values out of the [0. 1.] range
                          (cond ((< v 0.) 0.)
                                ((> v 1.) 1.)
                                (else v)))
                        
                        (vertex-x-set! s (standardize (vertex-x s)))
                        (vertex-y-set! s (standardize (vertex-y s)))
                        (vertex-z-set! s (standardize (vertex-z s)))
                        (vertex-x-set! t (standardize (vertex-x t)))
                        (vertex-y-set! t (standardize (vertex-y t)))
                        (vertex-z-set! t (standardize (vertex-z t)))
                        (let ((triangle
                                (new MS3D-Triangle
                                  flags
                                  vertex-indices
                                  vertex-normals
                                  s
                                  t
                                  smoothing-group
                                  group-index)))
                          (vector-set! triangles i triangle))))
                ;; TODO: calculate triangle normal (comment from msViewer)
                triangles)))
          
          ;; groups
          (define (<-groups)
            (let ((num-groups (<-u16)))
              (let ((groups (make-vector num-groups)))
                (loop (for i from 0 below num-groups)
                      (let ((flags (<-u8))
                            (name (<-string 32))
                            (triangles
                              (let ((num-group-triangles (<-u16)))
                                (loop (for j from 0 below num-group-triangles)
                                      (collect (<-u16)))))
                            (material-index (<-s8)))
                        (let ((group
                                (new MS3D-Group
                                  flags
                                  name
                                  triangles
                                  material-index)))
                          (vector-set! groups i group))))
                groups)))
          
          ;; materials
          (define (<-materials)
            (let ((num-materials (<-u16)))
              (let ((materials (make-vector num-materials)))
                (loop (for i from 0 below num-materials)
                      (let ((name (<-string 32))
                            (ambient (<-color))
                            (diffuse (<-color))
                            (specular (<-color))
                            (emissive (<-color))
                            (shininess (<-float))
                            (transparency (<-float))
                            (mode (<-u8))
                            (texture (<-string MAX_TEXTURE_FILENAME_SIZE))
                            (alphamap (<-string MAX_TEXTURE_FILENAME_SIZE)))
                        ;; set alpha
                        (dye-alpha-set! ambient transparency)
                        (dye-alpha-set! diffuse transparency)
                        (dye-alpha-set! specular transparency)
                        (dye-alpha-set! emissive transparency)
                        (let ((material
                                (new Material
                                  name: name
                                  ambient: ambient
                                  diffuse: diffuse
                                  specular: specular
                                  emissive: emissive
                                  shininess: shininess
                                  transparency: transparency
                                  mode: mode
                                  texture: texture
                                  alphamap: alphamap)))
                          (vector-set! materials i material))))
                materials)))
          
          ;; joints
          (define (<-joints animation-fps)
            (let ((num-joints (<-u16)))
              (let ((joints (make-vector num-joints)))
                (loop (for i from 0 below num-joints)
                      (let ((flags (<-u8))
                            (name (<-string 32))
                            (parent-name (<-string 32))
                            (rot (<-vertex))
                            (pos (<-vertex))
                            (num-key-frames-rot (<-u16))
                            (num-key-frames-pos (<-u16)))
                        (let ((rotation-keys (make-vector num-key-frames-rot))
                              (position-keys (make-vector num-key-frames-pos)))
                          ;; the frame time is in seconds, so multiply it by the animation fps
                          ;; to get the frames rotation channel
                          (loop (for j from 0 below num-key-frames-rot)
                                (let ((time (<-float))
                                      (key (<-vertex)))
                                  (let ((time (* time animation-fps)))
                                    (vector-set! rotation-keys j (new MS3D-KeyFrame time key)))))
                          ;; translation channel
                          (loop (for j from 0 below num-key-frames-pos)
                                (let ((time (<-float))
                                      (key (<-vertex)))
                                  (let ((time (* time animation-fps)))
                                    (vector-set! position-keys j (new MS3D-KeyFrame time key)))))
                          (let ((joint (new MS3D-Joint flags name parent-name rot pos rotation-keys position-keys)))
                            (vector-set! joints i joint)))))
                joints)))
          
          (read-subu8vector content 0 fileSize port)
          
          ;; header
          (assert (equal? (<-string 10) "MS3D000000"))
          (assert (= (<-s32) 4))
          
          ;; content
          (let ((model (new MS3D-Model file))
                (vertices (<-vertices))
                (triangles (<-triangles))
                (groups (<-groups))
                (materials (<-materials)))
            (define (vertex-ref index)
              (get-vertex~ (vector-ref vertices index)))
            
            (define (triangle-ref index)
              (vector-ref triangles index))
            
            (define (material-ref index)
              (vector-ref materials index))
            
            ;; vertices
            (set-vertices~ model vertices)
            ;; triangles
            (set-triangles~ model triangles)
            ;; groups
            (set-groups~ model groups)
            ;; materials
            (set-materials~ model materials)
            ;; animation
            (let ((animation-fps (max 1. (<-float)))
                  (current-time (<-float))
                  (total-frames (<-s32)))
              (set-animation-fps~ model animation-fps)
              (set-current-time~ model current-time)
              (set-total-frames~ model total-frames))
            ;; joints
            (set-joints~ model (<-joints (get-animation-fps~ model)))
            ;; comments
            ;; vertex extra
            ;; joint extra
            ;; model extra
            ;; atlas
            (let ((atlas (new Atlas mipmap?: #f pad?: #f))
                  (textures (remove-duplicates (remove-empty (map get-texture~ (vector->list materials))) test: filename=?)))
              (for-each (lambda (texture)
                          (add-file~ atlas (new-brother~ file texture)))
                        textures)
              (complete~ atlas)
              (loop (for group in-vector groups)
                    (let ((material (material-ref (get-material-index~ group))))
                      (let ((rect (image-rect~ atlas (extract-base (get-texture~ material)))))
                        (let ((left (get-left~ rect))
                              (top (get-top~ rect)))
                          (let ((width (- (get-right~ rect) left))
                                (height (- (get-bottom~ rect) top)))
                            ;; adjust
                            (for-each (lambda (triangle-index)
                                        (let ((triangle (triangle-ref triangle-index)))
                                          (let ((s (get-s~ triangle))
                                                (t (get-t~ triangle)))
                                            (vertex-x-set! s (+ left (* (vertex-x s) width)))
                                            (vertex-y-set! s (+ left (* (vertex-y s) width)))
                                            (vertex-z-set! s (+ left (* (vertex-z s) width)))
                                            (vertex-x-set! t (+ top (* (- 1. (vertex-x t)) height)))
                                            (vertex-y-set! t (+ top (* (- 1. (vertex-y t)) height)))
                                            (vertex-z-set! t (+ top (* (- 1. (vertex-z t)) height))))))
                                      (get-triangles~ group)))))))
              (set-texture~ model (get-texture~ atlas)))
            model)))))))
