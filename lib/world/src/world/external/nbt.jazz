;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Minecraft NBT
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.external.nbt jazz


(import (world.external))


(proclaim (warn optimizations))


;;;
;;;; Tag
;;;


(constant inline TAG_End        <fx>  0)
(constant inline TAG_Byte       <fx>  1)
(constant inline TAG_Short      <fx>  2)
(constant inline TAG_Int        <fx>  3)
(constant inline TAG_Long       <fx>  4)
(constant inline TAG_Float      <fx>  5)
(constant inline TAG_Double     <fx>  6)
(constant inline TAG_Byte_Array <fx>  7)
(constant inline TAG_String     <fx>  8)
(constant inline TAG_List       <fx>  9)
(constant inline TAG_Compound   <fx> 10)
(constant inline TAG_Int_Array  <fx> 11)


(definition public inline (make-tag name type value)
  (cons name (cons type value)))

(definition public inline (tag-name tag)
  (car tag))

(definition public inline (tag-type tag)
  (cadr tag))

(definition public inline (tag-value tag)
  (cddr tag))

(definition public inline (tag-assoc name alist)
  (let ((tag (assoc name alist)))
    (and tag (tag-value tag))))


(definition public inline (make-list-payload type <fx> content <list>) <pair>
  (cons type content))

(definition public inline (list-payload-type payload <pair>) <fx>
  (car payload))

(definition public inline (list-payload-content payload <pair>) <list>
  (cdr payload))


;;;
;;;; Reader
;;;


(class NBT-Reader extends Binary-Stream
  
  
  (method (read-tag)
    (define (read-tag)
      (let ((type <fx> (<-u8)))
        (if (= type TAG_End)
            #f
          (let ((name (read-name)))
            (make-tag name type (read-data type))))))
    
    (define (read-data type)
      (ecase type
        ((TAG_End)        (read-end))
        ((TAG_Byte)       (read-byte))
        ((TAG_Short)      (read-short))
        ((TAG_Int)        (read-int))
        ((TAG_Long)       (read-long))
        ((TAG_Float)      (read-float))
        ((TAG_Double)     (read-double))
        ((TAG_Byte_Array) (read-byte-array))
        ((TAG_String)     (read-name))
        ((TAG_List)       (read-list))
        ((TAG_Compound)   (read-compound))
        ((TAG_Int_Array)  (read-int-array))
        (else (error "Unknown NBT tag: {s}" type))))
    
    (define (read-end)
      (error "Invalid NBT tag: TAG_End"))
    
    (define (read-byte)
      (<-s8))
    
    (define (read-short)
      (<-s16-big-endian))
    
    (define (read-int)
      (<-s32-big-endian))
    
    (define (read-long)
      (<-s64-big-endian))
    
    (define (read-float)
      (<-float-big-endian))
    
    (define (read-double)
      (<-double-big-endian))
    
    (define (read-byte-array)
      (let ((size <fx> (read-int)))
        (<-u8vector size)))
    
    (define (read-name)
      (let ((size <fx> (read-short)))
        (<-utf-8-string size)))
    
    (define (read-list)
      (let ((type <fx> (read-byte))
            (size <fx> (read-int)))
        (let ((content (loop (repeat size)
                             (collect (read-data type)))))
          (make-list-payload type content))))
    
    (define (read-compound)
      (let ((tag (read-tag)))
        (if (not tag)
            '()
          (cons tag (read-compound)))))
    
    (define (read-int-array)
      (let ((size <fx> (read-int)))
        (let ((data (make-vector size)))
          (loop (for i from 0 below size)
                (vector-set! data i (read-int)))
          data)))
    
    (read-tag)))


;;;
;;;; Writer
;;;


(class NBT-Writer extends Binary-Writer
  
  
  (method (write-tag tag)
    (define (write-tag tag)
      (let ((name (tag-name tag))
            (type (tag-type tag))
            (val (tag-value tag)))
        (->u8 type)
        (write-name name)
        (write-data type val)))
    
    (define (write-data type val)
      (ecase type
        ((TAG_End)        (write-end val))
        ((TAG_Byte)       (write-byte val))
        ((TAG_Short)      (write-short val))
        ((TAG_Int)        (write-int val))
        ((TAG_Long)       (write-long val))
        ((TAG_Float)      (write-float val))
        ((TAG_Double)     (write-double val))
        ((TAG_Byte_Array) (write-byte-array val))
        ((TAG_String)     (write-name val))
        ((TAG_List)       (write-list val))
        ((TAG_Compound)   (write-compound val))
        ((TAG_Int_Array)  (write-int-array val))
        (else (error "Unknown NBT tag: {s}" type))))
    
    (define (write-end)
      (->u8 TAG_End))
    
    (define (write-byte val)
      (->s8 val))
    
    (define (write-short val)
      (->s16-big-endian val))
    
    (define (write-int val)
      (->s32-big-endian val))
    
    (define (write-long val)
      (->s64-big-endian val))
    
    (define (write-float val)
      (->float-big-endian val))
    
    (define (write-double val)
      (->double-big-endian val))
    
    (define (write-byte-array val <u8vector>)
      (let ((size (u8vector-length val)))
        (write-int size)
        (->u8vector val)))
    
    (define (write-name val)
      (let ((port (open-u8vector)))
        (write-string val port)
        (let ((u8vec (get-output-u8vector port)))
          (close-port port)
          (let ((size (u8vector-length u8vec)))
            (write-short size)
            (->u8vector u8vec)))))
    
    (define (write-list val)
      (let ((type (list-payload-type val))
            (content (list-payload-content val)))
        (let ((size (length content)))
          (write-byte type)
          (write-int size)
          (loop (for elem in content)
                (write-data type elem)))))
    
    (define (write-compound val)
      (loop (for tag in val)
            (write-tag tag))
      (write-end))
    
    (define (write-int-array val <vector>)
      (let ((size (vector-length val)))
        (write-int size)
        (loop (for i from 0 below size)
              (write-int (vector-ref val i)))))
    
    (write-tag tag))))
