;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World External
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.external jazz


(import (jazz.io)
        (zlib)
        (world.binary)
        (world.foreign))


(proclaim (warn optimizations))


;;;
;;;; Binary-Stream
;;;


(class Binary-Stream extends Object
  
  
  (slot content  <u8vector> getter generate)
  (slot position <fx>       getter generate)
  
  
  (method override (initialize file/content (compressed?: compressed? #t))
    ;; quick try
    (if (pair? file/content)
        (begin
          (set! content (car file/content))
          (set! position (cdr file/content)))
      (let ((u8vec (load-file-content file/content)))
        (set! content (if compressed? (gunzip-u8vector u8vec) u8vec)))
      (set! position 0)))
  
  
  (method public (<-s8)
    (prog1 (scan-s8 content position)
      (increase! position 1)))
  
  
  (method public (<-u8)
    (prog1 (scan-u8 content position)
      (increase! position 1)))
  
  
  (method public (<-u8vector size <fx>)
    (prog1 (subu8vector content position (+ position size))
      (increase! position size)))
  
  
  (method public (<-s16)
    (prog1 (scan-s16 content position)
      (increase! position 2)))
  
  
  (method public (<-s16-big-endian)
    (prog1 (scan-s16-big-endian content position)
      (increase! position 2)))
  
  
  (method public (<-u16)
    (prog1 (scan-u16 content position)
      (increase! position 2)))
  
  
  (method public (<-s32)
    (prog1 (scan-s32 content position)
      (increase! position 4)))
  
  
  (method public (<-s32-big-endian)
    (prog1 (scan-s32-big-endian content position)
      (increase! position 4)))
  
  
  (method public (<-s64)
    (prog1 (scan-s64 content position)
      (increase! position 8)))
  
  
  (method public (<-s64-big-endian)
    (prog1 (scan-s64-big-endian content position)
      (increase! position 8)))
  
  
  (method public (<-float)
    (prog1 (scan-float content position)
      (increase! position float-size)))
  
  
  (method public (<-floats! vec <f64vector>)
    (let ((len (f64vector-length vec)))
      (scan-floats64! content position vec len)
      (increase! position (* len float-size))
      vec))
  
  
  (method public (<-float-big-endian)
    (prog1 (scan-float-big-endian content position)
      (increase! position float-size)))
  
  
  (method public (<-double)
    (prog1 (scan-double content position)
      (increase! position double-size)))
  
  
  (method public (<-double-big-endian)
    (prog1 (scan-double-big-endian content position)
      (increase! position double-size)))
  
  
  (method public (<-string size <fx>)
    (prog1 (scan-string content position size)
      (increase! position size)))
  
  
  (method public (<-utf-8-string size <fx>)
    (prog1 (let ((end (+ position size)))
             (if (>= end (u8vector-length content))
                 (scan-utf-8-string content position)
               ;; quick hack add a terminating 0
               (let ((byte (u8vector-ref content end)))
                 (u8vector-set! content end 0)
                 (prog1 (scan-utf-8-string content position)
                   (u8vector-set! content end byte)))))
      (increase! position size))))


;;;
;;;; Binary-Writer
;;;


(class Binary-Writer extends Object
  
  
  (slot file        <File>     getter generate)
  (slot compressed? <bool>     getter generate)
  (slot port        <port>     getter generate)
  (slot buffer      <u8vector> getter generate)
  
  
  (method override (initialize file (compressed?: compressed? #t))
    (set! file~self file)
    (set! compressed?~self compressed?)
    (set! port (open-u8vector))
    (set! buffer (make-u8vector 8)))
  
  
  (method override (destroy)
    (when file
      (let ((content (get-content)))
        (call-with-output-file (path-settings file)
          (lambda (port)
            (write-subu8vector content 0 (u8vector-length content) port)))))
    (nextmethod))
  
  
  (method public (get-content) <u8vector>
    (let ((content (get-output-u8vector port)))
      (close-port port)
      (if compressed?
          (deflate-u8vector content)
        content)))
  
  
  (method public (->s8 val)
    (put-s8 buffer 0 val)
    (write-subu8vector buffer 0 1 port))
  
  
  (method public (->u8 val)
    (put-u8 buffer 0 val)
    (write-subu8vector buffer 0 1 port))
  
  
  (method public (->s16 val)
    (put-s16 buffer 0 val)
    (write-subu8vector buffer 0 2 port))
  
  
  (method public (->s16-big-endian val)
    (put-s16-big-endian buffer 0 val)
    (write-subu8vector buffer 0 2 port))
  
  
  (method public (->u16 val)
    (put-u16 buffer 0 val)
    (write-subu8vector buffer 0 2 port))
  
  
  (method public (->s32 val)
    (put-s32 buffer 0 val)
    (write-subu8vector buffer 0 4 port))
  
  
  (method public (->s32-big-endian val)
    (put-s32-big-endian buffer 0 val)
    (write-subu8vector buffer 0 4 port))
  
  
  (method public (->s64 val)
    (put-s64 buffer 0 val)
    (write-subu8vector buffer 0 8 port))
  
  
  (method public (->s64-big-endian val)
    (put-s64-big-endian buffer 0 val)
    (write-subu8vector buffer 0 8 port))
  
  
  (method public (->float val)
    (put-float buffer 0 val)
    (write-subu8vector buffer 0 4 port))
  
  
  @convert
  (method public (->floats! vec <f64vector>)
    (let ((len (f64vector-length vec)))
      (scan-floats64! content position vec len)
      (increase! position (* len float-size))
      vec))
  
  
  (method public (->float-big-endian val)
    (put-float-big-endian buffer 0 val)
    (write-subu8vector buffer 0 4 port))
  
  
  (method public (->double val)
    (put-double buffer 0 val)
    (write-subu8vector buffer 0 8 port))
  
  
  (method public (->double-big-endian val)
    (put-double-big-endian buffer 0 val)
    (write-subu8vector buffer 0 8 port))
  
  
  @convert
  (method public (->string size <fx>)
    (prog1 (scan-string content position size)
      (increase! position size)))
  
  
  (method public (->utf-8-string val)
    (write-string val port))
  
  
  (method public (->u8vector val <u8vector>)
    (write-subu8vector val 0 (u8vector-length val) port)))


;;;
;;;; Utility
;;;


(definition public (load-file-content file)
  (call-with-input-file (path-settings file)
    (lambda (port)
      (let ((fileSize <fx> (input-port-byte-position port 0 2)))
        (input-port-byte-position port 0)
        (let ((content (make-u8vector fileSize)))
          (read-subu8vector content 0 fileSize port)
          content))))))
