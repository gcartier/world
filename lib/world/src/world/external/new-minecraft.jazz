;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; New Minecraft
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.external.new-minecraft jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.system)
        (jazz.ui.window)
        (zlib)
        (world)
        (world.animation)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.binary)
        (world.dye)
        (world.external)
        (world.external.minecraft)
        (world.external.minecraft-syntax (phase syntax))
        (world.external.nbt)
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.homogeneous)
        (world.material)
        (world.mesh)
        (world.model)
        (world.profiling)
        (world.quad)
        (world.sector)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle)
        (profiler))


(proclaim (warn optimizations))


(class New-Minecraft-Zone extends Minecraft-Zone
  
  
  (method override (nmc?)
    #t)
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method override (update-content)
    (let ((world (current-world))
          (zone (current-zone)))
      (when (or (not content-uptodate?)
                (< content-revision current-content-revision))
        (cond ((< (get-sectors-generating~ zone)
                  (generate-threshold~ world))
               (if (generate-content?~ zone)
                   (begin
                     (increase-sectors-generating~ zone 1)
                     (push-content
                       (lambda (exit)
                         (generate-content~ zone self))))
                 (set! content-revision current-content-revision)
                 (set! content-uptodate? #t)))
              (else
               (add-eye-queued~ zone self))))))
  
  
  ;;;
  ;;;; Generate
  ;;;
  
  
  (method override (sector-generated sector)
    (add-eye-sector sector))
  
  
  ;;;
  ;;;; Render
  ;;;
    
  
  (definition nmc-eye-index
    #f)
  
  (definition nmc-eye-sectors
    (new-queue))
  
  (definition nmc-eye-queued
    (new-queue))
  
  
  (method (reset-nmc-eye-sectors)
    (set! nmc-eye-index #f)
    (reset-queue nmc-eye-sectors)
    (reset-queue nmc-eye-queued))
  
  
  (method (get-nmc-eye-sectors)
    (queue-list nmc-eye-sectors))
  
  
  (method (add-nmc-eye-sector sector)
    ;; quicky. should add sector only if it passes the frustum tests
    (enqueue nmc-eye-sectors sector))
  
  
  (method (count-nmc-eye-sectors)
    (length (queue-list nmc-eye-sectors)))
  
  
  (method (get-nmc-eye-queued)
    nmc-eye-queued)
  
  
  (method (add-nmc-eye-queued sector)
    (unless (get-queued?~ sector)
      (set-queued?~ sector #t)
      (enqueue nmc-eye-queued sector)))
  
  
  (method (count-nmc-eye-queued)
    (length (queue-list nmc-eye-queued)))
  
  
  (method (nmc-eye-neighbor-sectors pos distance <fx>)
    (let ((index (position-sector-index pos)))
      (if (equal? index nmc-eye-index)
          (begin
            (unless (queue-empty? nmc-eye-queued)
              (loop (for n from 1 to (- (generate-threshold~ (current-world)) sectors-generating))
                    (unless (queue-empty? nmc-eye-queued)
                      (let ((sector (dequeue nmc-eye-queued)))
                        (set-queued?~ sector #f)
                        (update~ sector)))))
            (get-nmc-eye-sectors))
        (reset-nmc-eye-sectors)
        (let ((a <fx> (vector-ref index 0))
              (b <fx> (vector-ref index 1))
              (c <fx> (vector-ref index 2)))
          (define (add sector)
            (update~ sector)
            (when (not (empty?~ sector))
              (add-nmc-eye-sector sector)))
          
          (add (index-sector index))
          (loop (for radius from 1 to distance)
                (let ((radius-1 (- radius 1)))
                  ;; left
                  (let ((i (- a radius)))
                    (loop (for j from (- radius) to radius)
                          (loop (for k from (- radius) to radius)
                                (add (coordinates-sector i (+ b j) (+ c k))))))
                  ;; right
                  (let ((i (+ a radius)))
                    (loop (for j from (- radius) to radius)
                          (loop (for k from (- radius) to radius)
                                (add (coordinates-sector i (+ b j) (+ c k))))))
                  ;; bottom
                  (let ((j (- b radius)))
                    (loop (for i from (- radius-1) to radius-1)
                          (loop (for k from (- radius) to radius)
                                (add (coordinates-sector (+ a i) j (+ c k))))))
                  ;; top
                  (let ((j (+ b radius)))
                    (loop (for i from (- radius-1) to radius-1)
                          (loop (for k from (- radius) to radius)
                                (add (coordinates-sector (+ a i) j (+ c k))))))
                  ;; back
                  (let ((k (- c radius)))
                    (loop (for i from (- radius-1) to radius-1)
                          (loop (for j from (- radius-1) to radius-1)
                                (add (coordinates-sector (+ a i) (+ b j) k)))))
                  ;; front
                  (let ((k (+ c radius)))
                    (loop (for i from (- radius-1) to radius-1)
                          (loop (for j from (- radius-1) to radius-1)
                                (add (coordinates-sector (+ a i) (+ b j) k)))))))
          (set! nmc-eye-index index)
          (get-nmc-eye-sectors)))))
  
  
  (method override (draw-eye-neighbors eye-position <f64vector> view-distance <fx> @radius <fl> proc)
    (let ((world (current-world)))
      (let ((eye (get-eye~ world))
            (sectors (eye-neighbor-sectors eye-position view-distance)))
        (for-each (lambda (sector <Sector>)
                    (when (in-frustum?~ eye (get-center~ sector))
                      (update~ sector)
                      (proc sector)))
                  sectors))))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  ;; convert to info
  (method (add-zone-info)
    (define (present-queued)
      (let ((queued (count-ncm-eye-queued)))
        (format "{a} queued" queued)))
    
    (define (present-generating)
      (let ((generating (get-sectors-generating)))
        (format "{a} {a}" generating (if idle? "idle" "busy"))))
      
    (let ((queued (present-queued))
          (generating (present-generating)))
      `(,(format "render: {a}, {a}, {a}"  (count-ncm-eye-sectors~ zone) queued generating))))
  
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method (test-eye distance <fx>)
    (let* ((size (+ distance 1 distance))
           (double (* size size))
           (a <fx> 0)
           (b <fx> 0)
           (c <fx> 0))
        (define (index i <fx> j <fx> k <fx>) <fx>
          (+ (* (+ j distance) double) (* (+ k distance) size) (+ i distance)))
        
        (let ((sectors (make-vector (* size size size))))
          (define (ref i <fx> j <fx> k <fx>)
            (vector-ref sectors (index i j k)))
          
          (define (add sector)
            (vector-set! sectors (ref 0 0 0) (vector-ref sectors (ref 0 0 0))))
          
          (define (test)
            (add (ref 0 0 0))
            (loop (for radius from 1 to distance)
                  (let ((radius-1 (- radius 1)))
                    ;; left
                    (let ((i (- a radius)))
                      (loop (for j from (- radius) to radius)
                            (loop (for k from (- radius) to radius)
                                  (add (ref i (+ b j) (+ c k))))))
                    ;; right
                    (let ((i (+ a radius)))
                      (loop (for j from (- radius) to radius)
                            (loop (for k from (- radius) to radius)
                                  (add (ref i (+ b j) (+ c k))))))
                    ;; bottom
                    (let ((j (- b radius)))
                      (loop (for i from (- radius-1) to radius-1)
                            (loop (for k from (- radius) to radius)
                                  (add (ref (+ a i) j (+ c k))))))
                    ;; top
                    (let ((j (+ b radius)))
                      (loop (for i from (- radius-1) to radius-1)
                            (loop (for k from (- radius) to radius)
                                  (add (ref (+ a i) j (+ c k))))))
                    ;; back
                    (let ((k (- c radius)))
                      (loop (for i from (- radius-1) to radius-1)
                            (loop (for j from (- radius-1) to radius-1)
                                  (add (ref (+ a i) (+ b j) k)))))
                    ;; front
                    (let ((k (+ c radius)))
                      (loop (for i from (- radius-1) to radius-1)
                            (loop (for j from (- radius-1) to radius-1)
                                  (add (ref (+ a i) (+ b j) k))))))))
          
          (loop (for n from 0 below (vector-length sectors))
                (vector-set! sectors n n))
          (time (test)))))))
