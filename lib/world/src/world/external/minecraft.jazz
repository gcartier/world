;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Minecraft
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.external.minecraft jazz


(import (gambit.log)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.system)
        (jazz.ui.window)
        (zlib)
        (world)
        (world.animation)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.binary)
        (world.dye)
        (world.external)
        (world.external.minecraft-syntax (phase syntax))
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.homogeneous)
        (world.info)
        (world.log)
        (world.material)
        (world.mesh)
        (world.model)
        (world.profiling)
        (world.quad)
        (world.renderer)
        (world.sector)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.texture)
        (world.triangle)
        (profiler))


(proclaim (warn optimizations))


(constant region-size <fx>
  32)


;;;
;;;; NBT
;;;


(constant TAG_End        <fx>  0)
(constant TAG_Byte       <fx>  1)
(constant TAG_Short      <fx>  2)
(constant TAG_Int        <fx>  3)
(constant TAG_Long       <fx>  4)
(constant TAG_Float      <fx>  5)
(constant TAG_Double     <fx>  6)
(constant TAG_Byte_Array <fx>  7)
(constant TAG_String     <fx>  8)
(constant TAG_List       <fx>  9)
(constant TAG_Compound   <fx> 10)
(constant TAG_Int_Array  <fx> 11)


(class NBT-Stream extends Binary-Stream
  
  
  (method (read-tag read)
    (define (read-tag read)
      (let ((type <fx> (<-u8)))
        (if (= type TAG_End)
            #t
          (let ((name (read-name read)))
            (cond ((not read)
                   (read-data type read)
                   #f)
                  ((eq? read #t)
                   (cons name (read-data type read)))
                  (else
                   (read type name read-data)))))))
    
    (define (read-name read)
      (let ((size <fx> (read-short #t)))
        (cond ((not read)
               (increase! position size))
              ((= size 0)
               "")
              (else
               (<-utf-8-string size)))))
    
    (define (read-data type read)
      (ecase type
        ((TAG_End)        (read-end read))
        ((TAG_Byte)       (read-byte read))
        ((TAG_Short)      (read-short read))
        ((TAG_Int)        (read-int read))
        ((TAG_Long)       (read-long read))
        ((TAG_Float)      (read-float read))
        ((TAG_Double)     (read-double read))
        ((TAG_Byte_Array) (read-byte-array read))
        ((TAG_String)     (read-name read))
        ((TAG_List)       (read-list read))
        ((TAG_Compound)   (read-compound read))
        ((TAG_Int_Array)  (read-int-array read))
        (else (error "Unknown NBT tag: {s}" type))))
    
    (define (read-end read)
      (error "Invalid NBT tag: TAG_End"))
    
    (define (read-byte read)
      (if (not read)
          (increase! position 1)
        (<-s8)))
    
    (define (read-short read)
      (if (not read)
          (increase! position 2)
        (<-s16-big-endian)))
    
    (define (read-int read)
      (if (not read)
          (increase! position 4)
        (<-s32-big-endian)))
    
    (define (read-long read)
      (if (not read)
          (increase! position 8)
        (<-s64-big-endian)))
    
    (define (read-float read)
      (if (not read)
          (increase! position 4)
        (<-float-big-endian)))
    
    (define (read-double read)
      (if (not read)
          (increase! position 8)
        (<-double-big-endian)))
    
    (define (read-byte-array read)
      (let ((size <fx> (read-int #t)))
        (if (not read)
            (increase! position size)
          (let ((data (make-s8vector size)))
            (loop (for i from 0 below size)
                  (s8vector-set! data i (read-byte read)))
            data))))
    
    (define (read-int-array read)
      (let ((size <fx> (read-int #t)))
        (if (not read)
            (increase! position (* size 4))
          (let ((data (make-vector size)))
            (loop (for i from 0 below size)
                  (vector-set! data i (read-int read)))
            data))))
    
    (define (read-list read)
      (let ((type <fx> (read-byte #t))
            (size <fx> (read-int #t)))
        (loop (repeat size)
              (collect (read-data type read)))))
    
    (define (read-compound read)
      (let ((tag (read-tag read)))
        (cond ((eq? tag #t)
               '())
              ((or (not tag)
                   (not read))
               (read-compound read))
              (else
               (cons tag (read-compound read))))))
    
    (read-tag read)))


;;;
;;;; Atlas
;;;


(definition (cache-atlas)
  (or (registered-atlas 'minecraft)
      (let ((atlas (create-minecraft-atlas)))
        (register-atlas 'minecraft atlas)
        atlas)))


(definition (cache-atlas-nearest)
  (or (registered-atlas 'minecraft-nearest)
      (let ((atlas (create-minecraft-atlas nearest?: #t)))
        (register-atlas 'minecraft-nearest atlas)
        atlas)))


(definition (create-minecraft-atlas (nearest?: nearest? #f))
  (define (determine-texture-dir)
    (let ((world (current-world)))
      (let ((dir ;; quick hack to test
              (if (is-alias? 'Yownu-World)
                  {Directory Yownu-World "assets" "minecraft" "textures"}
                (new-directory~ (first (get-user-assets~ world)) "textures"))))
        (new-directory~ dir texture-dir))))
  
  (let ((world (current-world)))
    (let ((mipmap? (find-setting 'minecraft.generate-mipmap? 32)))
      (let ((effective-mipmap? (if (integer? mipmap?) (>= tile-resolution mipmap?) mipmap?)))
        (let ((min-filter (if (or nearest? (not effective-mipmap?))
                              GL_NEAREST
                            #f))
              (mag-filter (if (not effective-mipmap?)
                              GL_NEAREST
                            #f)))
          (let ((atlas (new Atlas min-filter: min-filter mag-filter: mag-filter mipmap?: effective-mipmap?)))
            (add-directory~ atlas (determine-texture-dir))
            (complete~ atlas)
            atlas))))))


;;;
;;;; Material
;;;


(definition (opaque-material)
  (let ((world (current-world)))
    (get-block-opaque~ world)))


(definition (transparent-material)
  (let ((world (current-world)))
    (get-block-transparent~ world)))


(definition water-material
  (let ((material #f))
    (lambda ()
      (or material
          (let ((atlas (cache-atlas-nearest)))
            (let ((mat (new Material atlas: atlas texture: (get-texture~ atlas) renderer: water-renderer)))
              (set! material mat)
              mat))))))


(definition wet-material
  (let ((material #f))
    (lambda ()
      (or material
          (let ((atlas (cache-atlas)))
            (let ((mat (new Material atlas: atlas texture: (get-texture~ atlas) renderer: wet-renderer)))
              (set! material mat)
              mat))))))


(definition multitexture-material
  (let ((material #f))
    (lambda ()
      (or material
          (let ((atlas (cache-atlas-nearest)))
            (let ((mat (new Material atlas: atlas texture: (get-texture~ atlas) renderer: multitexture-renderer)))
              (set! material mat)
              mat))))))


;;;
;;;; Block
;;;


(class Minecraft-Block-Model extends Object
  
  
  (slot name                getter generate)
  (slot id                  getter generate)
  (slot subid               getter generate)
  (slot texture             getter generate)
  (slot texture-coordinates accessors generate)
  (slot material            getter generate)
  (slot material-cache      getter generate)
  (slot opaque-cube?        getter generate)
  (slot generate            getter generate)
  
  
  (method override (initialize name id subid texture material opaque-cube? generate)
    (set! name~self name)
    (set! id~self id)
    (set! subid~self subid)
    (set! texture~self texture)
    (set! texture-coordinates~self #f)
    (set! material~self (or material opaque-material))
    (set! material-cache~self #f)
    (set! opaque-cube?~self opaque-cube?)
    (set! generate~self generate))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method (cache-material)
    (or material-cache
        (let ((mat (material)))
          (set! material-cache mat)
          mat))))


(definition blocks <table>
  (make-table test: eq?))

(definition blockids <vector>
  (make-vector 256 #f))


(definition (register-minecraft-block name id (texture: texture #f) (material: material #f) (opaque-cube?: opaque-cube? #t) (generate: generate #f))
  (let ((id <fx> (if (pair? id) (car id) id))
        (subid (if (pair? id) (cadr id) #f)))
    (when (not subid)
      (let ((block (new Minecraft-Block-Model name id subid texture material opaque-cube? generate)))
        (table-set! blocks name block)
        (vector-set! blockids id block)))))


(definition public inline (blockid->block id <fx>) <Minecraft-Block-Model>
  (vector-ref blockids id))


(definition protected tile-resolution <fx>
  (find-setting 'minecraft.tile-resolution 32))

(definition protected tile-size <fl>
  (cast <fl> tile-resolution))

(definition protected tile-period <fx>
  16)

(definition protected texture-size <fl>
  (* tile-size (cast <fl> tile-period)))

(definition protected texture-dir
  (format "{a}x{a}" tile-resolution tile-resolution))

(definition protected texture-mipmap?
  #f)


(definition (block-texture-coordinates block <Minecraft-Block-Model>)
  (or (get-texture-coordinates~ block)
      (let ((texture (get-texture~ block)))
        (let ((coords (and texture (image-rect~ (cache-atlas) texture))))
          (set-texture-coordinates~ block coords)
          coords))))


(definition name-mutex
  (make-mutex 'name))

(definition name-coordinates <table>
  (make-table test: equal?))

(definition (get-name-coordinates name <string>) <f32vector>
  (mutex-lock! name-mutex)
  (prog1 (or (table-ref name-coordinates name #f)
             (let ((coords (image-rect~ (cache-atlas) name)))
               (table-set! name-coordinates name coords)
               coords))
    (mutex-unlock! name-mutex)))


;;;
;;;; Blocks
;;;


(define-minecraft-block Air
  0
  opaque-cube?: #f)

(define-minecraft-block Stone
  1
  texture: "stone")

;; todo fix grass top
(define-minecraft-block Grass
  2
  texture: "grass_side"
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((top (get-name-coordinates "wool_colored_green" @w "grass_top")))
                (add-opaque-cube uv uv uv top uv uv lighting material))))

(define-minecraft-block Dirt
  3
  texture: "dirt")

(define-minecraft-block Cobblestone
  4
  texture: "cobblestone")

(define-minecraft-block WoodenPlank
  5
  texture: "planks_spruce")

(definition Sapling-Textures <vector>
  #("sapling_oak"
    "sapling_spruce"
    "sapling_birch"
    "sapling_jungle"))

(define-minecraft-block Sapling
  6
  texture: "sapling_jungle"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((uv (get-name-coordinates (vector-ref Sapling-Textures (bitwise-and data-id #x3)))))
                (add-cross-faces x y z block-radius uv lighting material add-transparent-face))))

(define-minecraft-block RedwoodSapling
  (6 1))

(define-minecraft-block BirchSapling
  (6 2))

(define-minecraft-block Bedrock
  7
  texture: "enchanting_table_bottom")

(define-minecraft-block Water
  8
  material: water-material
  texture: "water")

(define-minecraft-block StationaryWater
  9
  material: water-material
  texture: "water")

(define-minecraft-block Lava
  10
  material: multitexture-material
  texture: "lava")

(define-minecraft-block StationaryLava
  11
  material: multitexture-material
  texture: "lava")

(define-minecraft-block Sand
  12
  texture: "sand")

(define-minecraft-block Gravel
  13
  texture: "gravel")

(define-minecraft-block GoldOre
  14
  texture: "gold_ore")

(define-minecraft-block IronOre
  15
  texture: "iron_ore")

(define-minecraft-block CoalOre
  16
  texture: "coal_ore")

(define-minecraft-block Wood
  17
  texture: "planks_jungle")

(define-minecraft-block Redwood
  (17 1))

(define-minecraft-block Birchwood
  (17 2))

(define-minecraft-block Leaves
  18
  texture: "leaves_birch_green"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-cube-faces x y z block-radius uv lighting material add-face)))

(define-minecraft-block RedwoodLeaves
  (18 1))

(define-minecraft-block BirchwoodLeaves
  (18 2))

(define-minecraft-block Sponge
  19
  texture: "sponge")

(define-minecraft-block Glass
  20
  texture: "glass"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-cube-faces x y z block-radius uv lighting material add-face)))

(define-minecraft-block LapisOre
  21
  texture: "lapis_ore")

(define-minecraft-block LapisBlock
  22
  texture: "lapis_block")

(define-minecraft-block Dispenser
  23
  texture: "dispenser_front_vertical")

(define-minecraft-block Sandstone
  24
  texture: "sandstone_top")

(define-minecraft-block NoteBlock
  25
  texture: "noteblock")

;; improve
(define-minecraft-block BedBlock
  26
  texture: "bed_feet_side"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-cube-faces x y z block-radius uv lighting material add-face)))

(define-minecraft-block PoweredRail
  27
  texture: "rail_activator_powered"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-rail data-id x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block DetectorRail
  28
  texture: "rail_detector"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-rail data-id x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block StickyPiston
  29
  texture: "piston_side")

(define-minecraft-block Web
  30
  texture: "web"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block TallGrass
  31
  texture: "wheat_stage_4" ; "tallgrass" is not nice in sphax textures
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block DeadBush
  32
  texture: "deadbush"
  material: transparent-material
  opaque-cube?: #f)

;; improve
(define-minecraft-block Piston
  33
  texture: "piston_side")

;; improve
(define-minecraft-block PistonHead
  34
  texture: "piston_side")

(definition Wool-Textures <vector>
  #("wool_colored_white"
    "wool_colored_orange"
    "wool_colored_magenta"
    "wool_colored_light_blue"
    "wool_colored_yellow"
    "wool_colored_lime"
    "wool_colored_pink"
    "wool_colored_gray"
    "wool_colored_silver"
    "wool_colored_cyan"
    "wool_colored_purple"
    "wool_colored_blue"
    "wool_colored_brown"
    "wool_colored_green"
    "wool_colored_red"
    "wool_colored_black"))

(define-minecraft-block Wool
  35
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((uv (get-name-coordinates (vector-ref Wool-Textures data-id))))
                (add-opaque-cube uv uv uv uv uv uv lighting material))))

(define-minecraft-block Dandelion
  37
  texture: "flower_dandelion"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block Rose
  38
  texture: "flower_rose"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block BrownMushroom
  39
  texture: "mushroom_brown"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block RedMushroom
  40
  texture: "mushroom_red"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block GoldBlock
  41
  texture: "gold_block")

(define-minecraft-block IronBlock
  42
  texture: "iron_block")

(define-minecraft-block DoubleStoneSlab
  43
  texture: "stone_slab_top")

(define-minecraft-block DoubleSandstoneSlab
  (43 1))

(define-minecraft-block DoubleWoodenSlab
  (43 2))

(define-minecraft-block DoubleCobblestoneSlab
  (43 3))

(define-minecraft-block DoubleBrickSlab
  (43 4))

(define-minecraft-block DoubleStoneBrickSlab
  (43 5))

(define-minecraft-block StoneSlab
  44
  texture: "stone_slab_top"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-slab x y z block-radius uv lighting material add-face)))

(define-minecraft-block SandstoneSlab
  (44 1))

(define-minecraft-block WoodenSlab
  (44 2))

(define-minecraft-block CobblestoneSlab
  (44 3))

(define-minecraft-block BrickSlab
  (44 4))

(define-minecraft-block StoneBrickSlab
  (44 5))

(define-minecraft-block Brick
  45
  texture: "brick")

(define-minecraft-block TNT
  46
  texture: "tnt_side"
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((top (get-name-coordinates "tnt_top")))
                (add-opaque-cube uv uv uv top uv uv lighting material))))

(define-minecraft-block Bookshelf
  47
  texture: "bookshelf"
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((top (get-name-coordinates "planks_jungle")))
                (add-opaque-cube uv uv uv top uv uv lighting material))))

(define-minecraft-block MossyCobblestone
  48
  texture: "cobblestone_mossy")

(define-minecraft-block Obsidian
  49
  texture: "obsidian")

(define-minecraft-block Torch
  50
  texture: "torch_on"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-transparent data-id 2 1 3 4 x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block Fire
  51
  texture: "furnace_front_on")

(define-minecraft-block MonsterSpawner
  52
  texture: "mob_spawner"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-cube-faces x y z block-radius uv lighting material add-face)))

(define-minecraft-block WoodenStairs
  53
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-stairs x y z block-radius uv lighting material add-face)))

(define-minecraft-block Chest
  54
  texture: "log_birch_top")

(define-minecraft-block RedstoneWire
  55
  texture: "redstone_dust_line"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-bottom x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block DiamondOre
  56
  texture: "diamond_ore")

(define-minecraft-block DiamondBlock
  57
  texture: "diamond_block")

(define-minecraft-block Workbench
  58
  texture: "log_oak")

(define-minecraft-block WheatCrops
  59
  texture: "wheat_stage_7"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block Soil
  60
  texture: "dirt")

(define-minecraft-block Furnace
  61
  texture: "furnace_side")

(define-minecraft-block BurningFurnace
  62
  texture: "furnace_front_on")

;; improve
(define-minecraft-block SignPost
  63
  texture: "trip_wire_source"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-right x y z block-radius uv lighting material add-transparent-face)))

;; quick hack remove all doors
(define-minecraft-block WoodenDoorBlock
  64
  texture: "door_wood_upper"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              #f))

(define-minecraft-block Ladder
  65
  texture: "ladder"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-transparent data-id 5 4 3 2 x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block Rails
  66
  texture: "rail_normal"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-rail data-id x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block CobblestoneStairs
  67
  texture: "cobblestone"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top y)
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   left right bottom top back front uv lighting material))
                (add-face (right-face  left right bottom top back front uv lighting material))
                (add-face (bottom-face left right bottom top back front uv lighting material))
                (add-face (top-face    left right bottom top back front uv lighting material))
                (add-face (back-face   left right bottom top back front uv lighting material))
                (add-face (front-face  left right bottom top back front uv lighting material)))))

;; improve
(define-minecraft-block WallSign
  68
  texture: "trip_wire_source"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-right x y z block-radius uv lighting material add-transparent-face)))

;; improve
(define-minecraft-block Lever
  69
  texture: "lever"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-transparent data-id 2 1 3 4 x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block StonePressurePlate
  70
  texture: "stone_slab_top"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top y)
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   left right bottom top back front uv lighting material))
                (add-face (right-face  left right bottom top back front uv lighting material))
                (add-face (bottom-face left right bottom top back front uv lighting material))
                (add-face (top-face    left right bottom top back front uv lighting material))
                (add-face (back-face   left right bottom top back front uv lighting material))
                (add-face (front-face  left right bottom top back front uv lighting material)))))

;; quick hack remove all doors
(define-minecraft-block IronDoorBlock
  71
  texture: "door_iron_upper"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              #f))

(define-minecraft-block WoodenPressurePlate
  72
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top y)
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   left right bottom top back front uv lighting material))
                (add-face (right-face  left right bottom top back front uv lighting material))
                (add-face (bottom-face left right bottom top back front uv lighting material))
                (add-face (top-face    left right bottom top back front uv lighting material))
                (add-face (back-face   left right bottom top back front uv lighting material))
                (add-face (front-face  left right bottom top back front uv lighting material)))))

(define-minecraft-block RedstoneOre
  73
  texture: "redstone_ore")

(define-minecraft-block GlowingRedstoneOre
  74
  texture: "repeater_on")

(define-minecraft-block RedstoneTorchOff
  75
  texture: "redstone_torch_off"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-transparent data-id 2 1 3 4 x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block RedstoneTorchOn
  76
  texture: "redstone_torch_on"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-transparent data-id 2 1 3 4 x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block StoneButton
  77
  texture: "endframe_side")

(define-minecraft-block Snow
  78
  texture: "snow"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) .625))
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   left right bottom top back front uv lighting material))
                (add-face (right-face  left right bottom top back front uv lighting material))
                (add-face (bottom-face left right bottom top back front uv lighting material))
                (add-face (top-face    left right bottom top back front uv lighting material))
                (add-face (back-face   left right bottom top back front uv lighting material))
                (add-face (front-face  left right bottom top back front uv lighting material)))))

(define-minecraft-block Ice
  79
  texture: "ice")

(define-minecraft-block SnowBlock
  80
  texture: "snow")

;; todo other faces
(define-minecraft-block Cactus
  81
  texture: "cactus_side")

(define-minecraft-block Clay
  82
  texture: "clay")

(define-minecraft-block SugarCane
  83
  texture: "reeds"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block Jukebox
  84
  texture: "jukebox_side"
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((top (get-name-coordinates "jukebox_top")))
                (add-opaque-cube uv uv uv top uv uv lighting material))))

;; improve
(define-minecraft-block Fence
  85
  texture: "iron_bars"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-transparent data-id 2 1 3 4 x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block Pumpkin
  86
  texture: "pumpkin_side"
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((top (get-name-coordinates "pumpkin_top")))
                (add-opaque-cube uv uv uv top uv uv lighting material))))

(define-minecraft-block Netherrack
  87
  material: water-material
  texture: "netherrack")

(define-minecraft-block SoulSand
  88
  material: water-material
  texture: "soul_sand")

(define-minecraft-block Glowstone
  89
  material: multitexture-material
  texture: "glowstone")

;; improve
(define-minecraft-block Portal
  90
  material: multitexture-material
  texture: "portal")

(define-minecraft-block Jack-O-Lantern
  91
  texture: "pumpkin_top")

;; todo other faces
(define-minecraft-block CakeBlock
  92
  texture: "cake_side"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-cube-faces x y z block-radius uv lighting material add-face)))

;; improve
(define-minecraft-block RedstoneRepeaterBlockOff
  93
  texture: "repeater_off")

;; improve
(define-minecraft-block RedstoneRepeaterBlockOn
  94
  texture: "repeater_on")

;; improve
(define-minecraft-block LockedChest
  95
  texture: "piston_top_normal")

(define-minecraft-block Trapdoor
  96
  texture: "trapdoor"
  material: transparent-material
  opaque-cube?: #f)

;; improve with data
(define-minecraft-block StoneSilverfish
  97
  texture: "stone")

(define-minecraft-block CobblestoneSilverfish
  (97 1))

(define-minecraft-block StoneBrickSilverfish
  (97 2))

(define-minecraft-block StoneBrick
  98
  texture: "stonebrick_cracked")

(define-minecraft-block MossyStoneBrick
  (98 1))

(define-minecraft-block CrackedStoneBrick
  (98 2))

(define-minecraft-block BrownMushroomCap
  99
  texture: "mushroom_block_skin_brown")

(define-minecraft-block RedMushroomCap
  100
  texture: "mushroom_block_skin_red")

(define-minecraft-block IronBars
  101
  texture: "iron_bars"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-cube-faces x y z block-radius uv lighting material add-face)))

(define-minecraft-block GlassPane
  102
  texture: "glass"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-cube-faces x y z block-radius uv lighting material add-face)))

(define-minecraft-block MelonBlock
  103
  texture: "melon_side"
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((top (get-name-coordinates "melon_top")))
                (add-opaque-cube uv uv uv top uv uv lighting material))))

(define-minecraft-block PumpkinStem
  104
  texture: "pumpkin_stem_disconnected_ochre"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-cross-faces x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block MelonStem
  105
  texture: "melon_stem_disconnected_ochre"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-cross-faces x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block Vines
  106
  texture: "vine_green"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-transparent data-id 2 8 4 1 x y z block-radius uv lighting material add-transparent-face)))

(define-minecraft-block FenceGate
  107
  texture: "iron_bars"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block BrickStairs
  108
  texture: "brick"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-stairs x y z block-radius uv lighting material add-face)))

(define-minecraft-block StoneBrickStairs
  109
  texture: "stonebrick"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-stairs x y z block-radius uv lighting material add-face)))

(define-minecraft-block Mycelium
  110
  texture: "mycelium_side"
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((top (get-name-coordinates "mycelium_top")))
                (add-opaque-cube uv uv uv top uv uv lighting material))))

(define-minecraft-block LilyPad
  111
  texture: "waterlily_green"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block NetherBrick
  112
  texture: "nether_brick")

(define-minecraft-block NetherBrickFence
  113
  texture: "iron_bars"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block NetherBrickStairs
  114
  texture: "nether_brick"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-stairs x y z block-radius uv lighting material add-face)))

;; improve
(define-minecraft-block NetherWart
  115
  texture: "nether_wart_stage_1")

(define-minecraft-block EnchantmentTable
  116
  texture: "enchanting_table_side"
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((top (get-name-coordinates "enchanting_table_top")))
                (add-opaque-cube uv uv uv top uv uv lighting material))))

(define-minecraft-block BrewingStand
  117
  texture: "brewing_stand"
  material: transparent-material
  opaque-cube?: #f)

(define-minecraft-block Cauldron
  118
  texture: "cauldron_side"
  material: transparent-material
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (let ((top (get-name-coordinates "cauldron_top")))
                (add-opaque-cube uv uv uv top uv uv lighting material))))

;; improve
(define-minecraft-block EndPortal
  119
  texture: "stone_slab_top"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-slab x y z block-radius uv lighting material add-face)))

(define-minecraft-block EndPortalFrame
  120
  texture: "endframe_side")

(define-minecraft-block EndStone
  121
  texture: "end_stone")

;; improve
(define-minecraft-block DragonEgg
  122
  texture: "dragon_egg")

(define-minecraft-block RedstoneLampOff
  123
  texture: "redstone_lamp_off")

(define-minecraft-block RedstoneLampOn
  124
  texture: "redstone_lamp_on")

;; improve
(define-minecraft-block DoubleWoodenSlab
  125
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-slab x y z block-radius uv lighting material add-face)))

(define-minecraft-block WoodenSlab
  126
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-slab x y z block-radius uv lighting material add-face)))

(define-minecraft-block CocoaPlant
  127
  texture: "cocoa_stage_2")

(define-minecraft-block SandstoneStairs
  128
  texture: "sandstone_normal"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-stairs x y z block-radius uv lighting material add-face)))

(define-minecraft-block EmeraldOre
  129
  texture: "emerald_ore")

;; improve
(define-minecraft-block EnderChest
  130
  texture: "farmland_wet")

;; improve
(define-minecraft-block TripwireHook
  131
  texture: "farmland_wet")

;; improve
(define-minecraft-block Tripwire
  132
  texture: "farmland_wet")

(define-minecraft-block EmeraldBlock
  133
  texture: "emerald_block")

(define-minecraft-block SpruceWoodStairs
  134
  texture: "planks_spruce"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-stairs x y z block-radius uv lighting material add-face)))

(define-minecraft-block BirchWoodStairs
  135
  texture: "planks_birch"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-stairs x y z block-radius uv lighting material add-face)))

(define-minecraft-block JungleWoodStairs
  136
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting material add-face add-transparent-face add-opaque-cube)
              (add-stairs x y z block-radius uv lighting material add-face)))

;; improve
(define-minecraft-block CommandBlock
  137
  texture: "farmland_wet")

;; improve
(define-minecraft-block BeaconBlock
  138
  texture: "beacon")

;; improve
(define-minecraft-block CobblestoneWall
  139
  texture: "cobblestone")

;; improve
(define-minecraft-block FlowerPot
  140
  texture: "farmland_wet")

;; improve
(define-minecraft-block Carrots
  141
  texture: "farmland_wet"
  material: transparent-material
  opaque-cube?: #f)

;; improve
(define-minecraft-block Potatoes
  142
  texture: "farmland_wet"
  material: transparent-material
  opaque-cube?: #f)

;; improve
(define-minecraft-block WoodenButton
  143
  texture: "farmland_wet")


(loop (for id from 0 below 256)
      (unless (vector-ref blockids id)
        (register-minecraft-block 'Unknown id)))


;;;
;;;; Face
;;;


(class Minecraft-Face extends Face
  
  
  (slot l1 accessors generate)
  (slot l2 accessors generate)
  (slot l3 accessors generate)
  (slot l4 accessors generate)
  
  
  (method override (initialize material texture-coordinates texture-depth polygon l1 l2 l3 l4)
    (nextmethod material texture-coordinates texture-depth polygon)
    (set! l1~self l1)
    (set! l2~self l2)
    (set! l3~self l3)
    (set! l4~self l4))
  
  
  (method (iterate-lighting proc)
    (proc l1 l2 l3)
    (proc l3 l4 l1)))


(definition public (make-minecraft-face material texture-coordinates texture-depth polygon l1 l2 l3 l4)
  (new Minecraft-Face material texture-coordinates texture-depth polygon l1 l2 l3 l4))


;;;
;;;; Section
;;;


(class Minecraft-Section extends Object
  
  
  (slot blocks     getter generate)
  (slot data       getter generate)
  (slot blocklight getter generate)
  (slot skylight   getter generate)
  
  
  (method override (initialize blocks data blocklight skylight)
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)
    (set! skylight~self skylight)))


;;;
;;;; Chunk
;;;


(class Minecraft-Chunk extends Object
  
  
  (slot heightmap             getter generate)
  (slot heightmap-revision    accessors generate)
  (slot heightmap-uptodate?   accessors generate)
  (slot heightmap-generating? accessors generate)
  (slot entities              getter generate)
  (slot sections              getter generate)
  
  
  (method override (initialize heightmap entities sections)
    (set! heightmap~self heightmap)
    (set! heightmap-revision~self 0)
    (set! heightmap-uptodate?~self #f)
    (set! heightmap-generating?~self #f)
    (set! entities~self entities)
    (set! sections~self sections)))


;;;
;;;; Region
;;;


(class Minecraft-Region extends Object
  
  
  (slot x            <fx>                                            getter generate)
  (slot z            <fx>                                            getter generate)
  (slot port         <port>                                          getter generate)
  (slot header       <u8vector>                                      getter generate)
  (slot chunks-mutex <object>   initialize (make-mutex 'chunks)      getter generate)
  (slot chunks       <table>    initialize (make-table test: equal?) getter generate)
  
  
  (method override (initialize x z port)
    (set! x~self x)
    (set! z~self z)
    (set! port~self port)
    (set! header (read-header)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" x z))))
  
  
  (method override (destroy)
    (close-port port)
    (nextmethod))
  
  
  (method (read-header)
    (let ((size (* 8 1024)))
      (let ((content (make-u8vector size)))
        (read-subu8vector content 0 size port)
        content)))
  
  
  (method (with-chunks-mutex thunk)
    (mutex-lock! chunks-mutex)
    (prog1 (thunk)
      (mutex-unlock! chunks-mutex)))
  
  
  (method (get-chunk sector-x <fx> sector-z <fx>) <Minecraft-Chunk+>
    (with-chunks-mutex
      (lambda ()
        (let ((chunk-index (chunk-index sector-x sector-z)))
          (let ((value (table-ref chunks chunk-index #t)))
            (if (neq? value #t)
                value
              (let ((chunk (read-chunk chunk-index)))
                (table-set! chunks chunk-index chunk)
                chunk)))))))
  
  
  (method (chunk-index sector-x <fx> sector-z <fx>) <pair>
    ;; looks like we don't need to adjust for negative values like stated on the wiki
    (cons (modulo sector-x 32)
          (modulo sector-z 32)))
  
  
  (method (read-chunk chunk-index <pair>) <Minecraft-Chunk+>
    (let ((zone <Minecraft-Zone> (current-zone))
          (chunk-x <fx> (car chunk-index))
          (chunk-z <fx> (cdr chunk-index)))
      (let ((offset (* 4 (+ chunk-x (* chunk-z 32)))))
        (assert (<= offset 4092))
        (let ((b1 (u8vector-ref header offset))
              (b2 (u8vector-ref header (+ offset 1)))
              (b3 (u8vector-ref header (+ offset 2)))
              (b4 (u8vector-ref header (+ offset 3))))
          (if (and (= b1 0)
                   (= b2 0)
                   (= b3 0)
                   (= b4 0))
              #f
            (let ((offset (* (+ (cast <fx> (arithmetic-shift-left b1 16))
                                (cast <fx> (arithmetic-shift-left b2 8))
                                b3)
                             (* 4 1024))))
              (input-port-byte-position port offset)
              (let ((chunk-header (make-u8vector 5)))
                (read-subu8vector chunk-header 0 5 port)
                (let ((size <fx> (scan-u32-big-endian chunk-header 0))
                      (compression-type (u8vector-ref chunk-header 4)))
                  ;; skip two bytes for deflate
                  (read-u8 port)
                  (read-u8 port)
                  (let ((chunk-raw (make-u8vector size)))
                    (read-subu8vector chunk-raw 0 size port)
                    (let ((chunk-data (inflate-u8vector chunk-raw)))
                      (let ((s (new NBT-Stream (cons chunk-data 0))))
                        (let ((tag-data
                                (read-tag~ s
                                  (lambda (type name read-data)
                                    (read-data type
                                      (lambda (type name read-data)
                                        (read-data type
                                          (lambda (type name read-data)
                                            (cond ((equal? name "HeightMap")
                                                   (cons name (read-data type #t)))
                                                  @wait ((equal? name "Entities")
                                                         (cons name (read-data type #t)))
                                                  ((equal? name "Sections")
                                                   (cons name (read-data type
                                                                (lambda (type name read-data)
                                                                  (if (or (equal? name "Y")
                                                                          (equal? name "Blocks")
                                                                          (equal? name "Data")
                                                                          (equal? name "BlockLight")
                                                                          (equal? name "SkyLight"))
                                                                      (cons name (read-data type #t))
                                                                    (read-data type #f)
                                                                    #f)))))
                                                  (else
                                                   (read-data type #f)
                                                   #f))))))))))
                          (let ((alist (car tag-data)))
                            (let ((heightmap (assoc "HeightMap" alist))
                                  (entities (assoc "Entities" alist))
                                  (sections (assoc "Sections" alist)))
                              (let ((sections-table (and sections (make-table test: eq?))))
                                (when sections-table
                                  (let ((truncate-y (get-truncate-y~ zone)))
                                    (for-each (lambda (section)
                                                (let ((yPos (- (cast <fx> (cdr (assoc "Y" section))) 4)) ;; lower everything by 64
                                                      (blocks (cdr (assoc "Blocks" section)))
                                                      (data (cdr (assoc "Data" section)))
                                                      (blocklight (cdr (assoc "BlockLight" section)))
                                                      (skylight (cdr (assoc "SkyLight" section))))
                                                  (when (or (not truncate-y)
                                                            (>= yPos (cast <fx> truncate-y)))
                                                    (table-set! sections-table yPos (new Minecraft-Section blocks data blocklight skylight)))))
                                              (cdr sections))))
                                (new Minecraft-Chunk
                                  (and heightmap (cdr heightmap))
                                  (and entities (cdr entities))
                                  sections-table))))))))))))))))
  
  
  (method (get-section sector-x <fx> sector-y <fx> sector-z <fx>) <Minecraft-Section+>
    (let ((chunk (get-chunk sector-x sector-z)))
      (when chunk
        (let ((sections (get-sections~ chunk)))
          (when sections
            (table-ref sections sector-y #f))))))
  
  
  (method (get-blocks sector-x <fx> sector-y <fx> sector-z <fx>) <s8vector+>
    (let ((section (get-section sector-x sector-y sector-z)))
      (when section
        (get-blocks~ section)))))


;;;
;;;; Level
;;;


(definition public (import-minecraft-level file)
  (let ((s (new NBT-Stream file)))
    (read-tag~ s #t)))


;;;
;;;; Sector
;;;


(class Minecraft-Sector extends Sector
  
  
  (method override (prepare-lightmap faces)
    (define (convert-light lighting <fx>) <fl>
      (cast <fl> (expt .8 (/ (- 60. (cast <fl> lighting)) 5.))))
    
    (let ((zone <Minecraft-Zone> (current-zone)))
      (if (or heightmap? (not (get-day-cycle~ zone)))
          (nextmethod faces)
        (let ((triangles-count <fx> 0)
              (triangle-floats (* 3 3)))
          (for-each (lambda (face <Minecraft-Face>)
                      (increase! triangles-count (cast <fx> (triangle-count~ face))))
                    faces)
          (let ((f32 <f32vector> (make-f32vector (* triangles-count triangle-floats) 0.))
                (n <fx> 0))
            (for-each (lambda (face <Minecraft-Face>)
                        (iterate-lighting~ face
                          (lambda (l1 l2 l3)
                            (let ((l1 (convert-light l1))
                                  (l2 (convert-light l2))
                                  (l3 (convert-light l3)))
                              (f32vector-set! f32 n l1)
                              (f32vector-set! f32 (+ n 1) l1)
                              (f32vector-set! f32 (+ n 2) l1)
                              (f32vector-set! f32 (+ n 3) l2)
                              (f32vector-set! f32 (+ n 4) l2)
                              (f32vector-set! f32 (+ n 5) l2)
                              (f32vector-set! f32 (+ n 6) l3)
                              (f32vector-set! f32 (+ n 7) l3)
                              (f32vector-set! f32 (+ n 8) l3)
                              (increase! n 9)))))
                      faces)
            f32))))))


;;;
;;;; Zone
;;;


(definition heightmap?
  (find-setting 'minecraft.heightmap? #f))

(definition public (get-heightmap?)
  heightmap?)

(definition public (set-heightmap? flag)
  (set! heightmap? flag))


(class Minecraft-Zone extends Zone
  
  
  (property level-dir  <Directory> initialize #f   accessors generate)
  (property truncate-y <fx+>       initialize #f   accessors generate)
  (property day-cycle  <object>    initialize 'day accessors generate)
  
  
  (slot regions-dir   <Directory> initialize #f                        getter explicit)
  (slot regions-mutex <object>    initialize (make-mutex 'regions)     getter generate)
  (slot regions       <table>     initialize (make-table test: equal?) getter generate)
  
  
  (form
    (<install> floor-level: #f start-grid?: #f start-axes?: #f jump-impulsion: .3))
  
  
  ;; quicky for tests
  (method override (minecraft?)
    #t)
  
  
  (method override (needs-pumps?)
    #t)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! ambient-color (dye 0. 0. 0. 0.))
    (set! day-cycle (world-setting 'minecraft.day-cycle 'night 'default))
    (if heightmap?
        (set! sun-cycle? #t)
      (set! sun-cycle? (not day-cycle))))
  
  
  (method override (effective-lights)
    '())
  
  
  (method override (default-lights)
    '())
  
  
  (method override (create-atlas)
    (cache-atlas))
  
  
  (method override (create-atlas-nearest)
    (cache-atlas-nearest))
  
  
  (method override (sector-class)
    Minecraft-Sector)
  
  
  (method override (zone-editable?)
    #f)
  
  
  (method (with-regions-mutex thunk)
    (mutex-lock! regions-mutex)
    (prog1 (thunk)
      (mutex-unlock! regions-mutex)))
  
  
  (method (close-regions)
    (with-regions-mutex
      (lambda ()
        (iterate-table regions
          (lambda (index region)
            (when region
              (close~ region))))
        (empty-table regions))))
  
  
  (method (iterate-regions proc)
    (iterate-directory~ (get-regions-dir)
      (lambda (file)
        (when (extension=? (get-extension~ file) "mca")
          (let ((base (get-base~ file)))
            (bind (x z) (split (substring base 2 (string-length base)) ".")
              (let ((x (string->number x))
                    (z (string->number z)))
                (proc file x z))))))))
  
  
  (method (compute-boundaries)
    (let ((left +inf.0)
          (right -inf.0)
          (back +inf.0)
          (front -inf.0))
      (iterate-regions
        (lambda (file x z)
          (when (< x left)
            (set! left x))
          (when (> x right)
            (set! right x))
          (when (< z back)
            (set! back z))
          (when (> z front)
            (set! front z))))
      (values left right back front)))
  
  
  (method (get-regions-dir) <Directory>
    (or regions-dir (let ((dir (new-directory~ level-dir "region")))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method (get-region region-index <pair>) <Minecraft-Region+>
    (define (region-name)
      (bind (region-x . region-z) region-index
        (format "r.{a}.{a}.mca" region-x region-z)))
    
    (with-regions-mutex
      (lambda ()
        (let ((value (table-ref regions region-index #t)))
          (if (neq? value #t)
              value
            (let ((dir (get-regions-dir))
                  (name (region-name)))
              (let ((file (new-file~ dir name)))
                (let ((region (if (exists?~ file)
                                  (bind (region-x . region-z) region-index
                                    (let ((port (open-input-file (path-settings file))))
                                      (new Minecraft-Region region-x region-z port)))
                                #f)))
                  (table-set! regions region-index region)
                  region))))))))
  
  
  (method (sector-region sector-x <fx> sector-y <fx> sector-z <fx>) <Minecraft-Region+>
    (define (region-index)
      (cons (fxfloor/ sector-x region-size)
            (fxfloor/ sector-z region-size)))
    
    (get-region (region-index)))
  
  
  (method (sector-blocks sector-x <fx> sector-y <fx> sector-z <fx>) <s8vector+>
    (let ((region (sector-region sector-x sector-y sector-z)))
      (when region
        (get-blocks~ region sector-x sector-y sector-z))))
  
  
  (method override (generate-content?)
    #t)
  
  
  (method override (generate-content sector <Sector>)
    (site (generate on?: #t)
      (generate-sector sector 'render)))
  
  
  (method override (generate-physical sector <Sector>)
    (site (generate-physical on?: #f)
      (generate-sector sector 'physical)))
  
  
  (method (generate-sector sector <Sector> what)
    (define (prepare-faces faces)
      (when (not-null? faces)
        (receive (vertices neighbors) (prepare-vertices/neighbors~ sector faces)
          (let ((lightmap (prepare-lightmap~ sector faces)))
            (list vertices neighbors lightmap)))))
    
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (decrease-sectors-generating sector))
    
    (when (eq? self (current-zone))
      (if (get-heightmap?)
          (generate-sector-heightmap sector what)
      (let ((sector-index (get-index~ sector)))
        (let ((sector-x <fx> (vector-ref sector-index 0))
              (sector-y <fx> (vector-ref sector-index 1))
              (sector-z <fx> (vector-ref sector-index 2)))
          (let ((region (sector-region sector-x sector-y sector-z)))
            (if (not region)
                (when (eq? what 'render)
                  (generate-done))
              (let ((region-x (get-x~ region))
                    (region-z (get-z~ region))
                    (section (get-section~ region sector-x sector-y sector-z))
                    (chunk-index (chunk-index~ region sector-x sector-z)))
                (assert (= region-x (fxfloor/ sector-x region-size)))
                (assert (= region-z (fxfloor/ sector-z region-size)))
                (if (not section)
                    (when (eq? what 'render)
                      (generate-done))
                  (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                        (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                        (section-y (* sector-y 16))
                        (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                        (sections <vector> (make-vector 27 #t))
                        (cache <s8vector> (make-s8vector (* 18 18 18 2) -1))
                        (block-size 1.)
                        (block-radius .5)
                        (faces '())
                        (transparent-faces '())
                        (water-faces '())
                        (wet-faces '())
                        (multitexture-faces '())
                        (opaque-material (opaque-material))
                        (transparent-material (transparent-material))
                        (water-material (water-material))
                        (wet-material (wet-material))
                        (multitexture-material (multitexture-material))
                        (areas (and (eq? what 'physical) (make-table test: eq?))))
                    (define (section-ref a <fx> b <fx> c <fx>) <Minecraft-Section+>
                      (if (and (= a 0)
                               (= b 0)
                               (= c 0))
                          section
                        (let ((index (section-index a b c)))
                          (let ((section (vector-ref sections index)))
                            (if (neq? section #t)
                                section
                              (let ((x (+ sector-x a))
                                    (y (+ sector-y b))
                                    (z (+ sector-z c)))
                                (let ((region (sector-region x y z)))
                                  (let ((section (and region (get-section~ (cast <Minecraft-Region> region) x y z))))
                                    (vector-set! sections index section)
                                    section))))))))
                    
                    (define (section-index a <fx> b <fx> c <fx>) <fx>
                      (+ (* (+ b 1) 9) (* (+ c 1) 3) (+ a 1)))
                    
                    (define (cache-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* (+ j 1) 324) (* (+ k 1) 18) (+ i 1)) 2))
                    
                    (define (blocks-get section <Minecraft-Section>) <s8vector>
                      (get-blocks~ section))
                    
                    (define (data-get section <Minecraft-Section>) <s8vector>
                      (get-data~ section))
                    
                    (define (blocklight-get section <Minecraft-Section>) <s8vector>
                      (get-blocklight~ section))
                    
                    (define (skylight-get section <Minecraft-Section>) <s8vector>
                      (get-skylight~ section))
                    
                    (define (normalize-block-id id <fx>) <fx>
                      (if (>= id 0)
                          id
                        0 @w
                        (+ 256 id)))
                    
                    (define (block-ref i <fx> j <fx> k <fx>) <fx>
                      (normalize-block-id (field-ref i j k blocks-get s8vector-ref 0 1)))
                    
                    (define (data-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k data-get s4vector-ref 0 0))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (cache-index i j k)))
                        (let ((value (s8vector-ref cache index)))
                          (if (/= value -1)
                              value
                            ;; need to use data information here
                            (let ((value (block-ref i j k)))
                              (s8vector-set! cache index value)
                              value)))))
                    
                    (define (blocklight-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k blocklight-get s4vector-ref 0 0))
                    
                    (define (skylight-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k skylight-get s4vector-ref 15 15))
                    
                    (define (light-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (+ (cache-index i j k) 1)))
                        (let ((value (s8vector-ref cache index)))
                          (if (/= value -1)
                              value
                            (let ((value (max (blocklight-ref i j k)
                                              (cast <fx> (let ((skylight (skylight-ref i j k)))
                                                           (if (eq? day-cycle 'day)
                                                               skylight
                                                             (- skylight 11)))))))
                              (s8vector-set! cache index value)
                              value)))))
                    
                    (define (s4vector-ref field <s8vector> index <fx>) <fx>
                      (let ((byte (s8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (let ((a 0)
                            (b 0)
                            (c 0))
                        (cond ((< i 0) (set! a -1) (set! i 15))
                              ((> i 15) (set! a 1) (set! i 0)))
                        (cond ((< j 0) (set! b -1) (set! j 15))
                              ((> j 15) (set! b 1) (set! j 0)))
                        (cond ((< k 0) (set! c -1) (set! k 15))
                              ((> k 15) (set! c 1) (set! k 0)))
                        (let ((section (section-ref a b c)))
                          (if (not section)
                              (if (and bottom-section? (= b -1)) bottom empty)
                            (let ((field (get-field section)))
                              (if (not field)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (ref field (index i j k))))))))
                    
                    (define (index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (let ((x (* block-size (cast <fl> section-x)))
                          (y (* block-size (cast <fl> section-y)))
                          (z (* block-size (cast <fl> section-z))))
                      (loop (for j from 0 below 16)
                            (loop (for k from 0 below 16)
                                  (loop (for i from 0 below 16)
                                        (let ((block-y (+ section-y j)))
                                          (let ((block-id <fx> (effective-block-ref i j k)))
                                            (when (/= block-id 0)
                                              (let ((x (+ section-x i))
                                                    (y block-y)
                                                    (z (+ section-z k))
                                                    (block (blockid->block block-id))
                                                    (data-id (data-ref i j k)))
                                                (let ((uv (block-texture-coordinates block)))
                                                  (let ((x (+ block-radius (* block-size (cast <fl> x))))
                                                        (y (+ block-radius (* block-size (cast <fl> y))))
                                                        (z (+ block-radius (* block-size (cast <fl> z))))
                                                        (material (cache-material~ block))
                                                        (opaque-cube? (get-opaque-cube?~ block))
                                                        (generate (get-generate~ block)))
                                                    (define (add-face face <Face>)
                                                      (cond ((eq? material transparent-material)
                                                             (add-transparent-face face))
                                                            ((or (= block-id 8)
                                                                 (= block-id 9)
                                                                 (= block-id 87)
                                                                 (= block-id 88))
                                                             (add-water-face face))
                                                            ((or (= block-id 10)
                                                                 (= block-id 11)
                                                                 (= block-id 89)
                                                                 (= block-id 90))
                                                             (add-multitexture-face face))
                                                            (else
                                                             (set! faces (cons face faces))))
                                                      (when (eq? what 'physical)
                                                        (let ((center (get-center~ (get-polygon~ face))))
                                                          (let ((area (index-area (position-area-index center) #f)))
                                                            (table-add areas area (get-polygon~ face))))))
                                                    
                                                    (define (add-transparent-face face <Face>)
                                                      (set! transparent-faces (cons face transparent-faces)))
                                                    
                                                    (define (add-water-face face <Face>)
                                                      (set! water-faces (cons face water-faces)))
                                                    
                                                    (define (add-wet-face face <Face>)
                                                      (set! wet-faces (cons face wet-faces)))
                                                    
                                                    (define (add-multitexture-face face <Face>)
                                                      (set! multitexture-faces (cons face multitexture-faces)))
                                                    
                                                    (define (add-face2 mat face)
                                                      (if (eq? mat wet-material)
                                                          (add-wet-face face)
                                                        (add-face face)))
                                                    
                                                    (define (add-opaque-cube left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting material)
                                                      (if (or (= block-id 8)
                                                              (= block-id 9))
                                                          (begin
                                                            (unless (water-opaque? (effective-block-ref (- i 1) j k)) (add-face (left-side   x y z block-radius left-uv lighting material)))
                                                            (unless (water-opaque? (effective-block-ref (+ i 1) j k)) (add-face (right-side  x y z block-radius right-uv lighting material)))
                                                            (unless (water-opaque? (effective-block-ref i (- j 1) k)) (add-face (bottom-side x y z block-radius bottom-uv lighting material)))
                                                            (unless (water-opaque? (effective-block-ref i (+ j 1) k)) (add-face (top-side    x y z block-radius top-uv lighting material)))
                                                            (unless (water-opaque? (effective-block-ref i j (- k 1))) (add-face (back-side   x y z block-radius back-uv lighting material)))
                                                            (unless (water-opaque? (effective-block-ref i j (+ k 1))) (add-face (front-side  x y z block-radius front-uv lighting material))))
                                                        (let ((mat (transparent-mat (effective-block-ref (- i 1) j k)))) (when mat (add-face2 mat (left-side   x y z block-radius left-uv lighting mat))))
                                                        (let ((mat (transparent-mat (effective-block-ref (+ i 1) j k)))) (when mat (add-face2 mat (right-side  x y z block-radius right-uv lighting mat))))
                                                        (let ((mat (transparent-mat (effective-block-ref i (- j 1) k)))) (when mat (add-face2 mat (bottom-side x y z block-radius bottom-uv lighting mat))))
                                                        (let ((mat (transparent-mat (effective-block-ref i (+ j 1) k)))) (when mat (add-face2 mat (top-side    x y z block-radius top-uv lighting mat))))
                                                        (let ((mat (transparent-mat (effective-block-ref i j (- k 1))))) (when mat (add-face2 mat (back-side   x y z block-radius back-uv lighting mat))))
                                                        (let ((mat (transparent-mat (effective-block-ref i j (+ k 1))))) (when mat (add-face2 mat (front-side  x y z block-radius front-uv lighting mat))))))
                                                    
                                                    (define (transparent-mat block-id <fx>)
                                                      (if (or (= block-id 8)
                                                              (= block-id 9))
                                                          wet-material
                                                        (if (not (get-opaque-cube?~ (blockid->block block-id)))
                                                            transparent-material
                                                          #f)))
                                                    
                                                    (define (opaque? block-id <fx>)
                                                      (and (/= block-id 0)
                                                           (/= block-id 8)
                                                           (/= block-id 9)
                                                           (get-opaque-cube?~ (blockid->block block-id))))
                                                    
                                                    (define (water-opaque? block-id <fx>)
                                                      (and (/= block-id 0)
                                                           (or (get-opaque-cube?~ (blockid->block block-id))
                                                               (= block-id 8)
                                                               (= block-id 9))))
                                                    
                                                    (define (compute-lighting ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                                                      (+ (light-ref (+ i ax) (+ j ay) (+ k az))
                                                         (light-ref (+ i bx) (+ j by) (+ k bz))
                                                         (light-ref (+ i cx) (+ j cy) (+ k cz))
                                                         (light-ref (+ i dx) (+ j dy) (+ k dz))))
                                                    
                                                    (define (no-lighting ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                                                      0.)
                                                    
                                                    (let ((lighting (if day-cycle compute-lighting no-lighting)))
                                                      (cond (generate
                                                              (generate block-id data-id x y z block-radius uv lighting material add-face add-transparent-face add-opaque-cube))
                                                            (opaque-cube?
                                                              (add-opaque-cube uv uv uv uv uv uv lighting opaque-material))
                                                            (else
                                                             (add-cross-faces x y z block-radius uv lighting transparent-material add-transparent-face))))))))))))))
                    (case what
                      ((physical)
                       (when (eq? self (current-zone))
                         (iterate-table areas
                           (lambda (area <Area> polygons)
                             (add-polygons~ area #f polygons #f)))))
                      ((render)
                       (let ((opaque (prepare-faces faces))
                             (transparent (prepare-faces transparent-faces))
                             (water (prepare-faces water-faces))
                             (wet (prepare-faces wet-faces))
                             (multitexture (prepare-faces multitexture-faces)))
                         (write-render-event
                           (lambda ()
                             (when (eq? self (current-zone))
                               (free-mesh~ sector)
                               (when opaque
                                 (bind (vertices neighbors lightmap) opaque
                                   (setup-mesh~ sector)
                                   (let ((mesh (get-mesh~ sector)))
                                     (fill-vertices/neighbors~ sector mesh vertices neighbors)
                                     (fill-lightmap~ sector mesh lightmap))))
                               (when transparent
                                 (bind (vertices neighbors lightmap) transparent
                                   (setup-other-meshes~ sector)
                                   (let ((mesh (new Mesh material: (get-block-transparent~ (current-world)))))
                                     (let ((material (get-material~ mesh)))
                                       (table-set! (get-other-meshes~ sector) material mesh)
                                       (fill-vertices/neighbors~ sector mesh vertices neighbors)
                                       (fill-lightmap~ sector mesh lightmap)))))
                               (when water
                                 (bind (vertices neighbors lightmap) water
                                   (setup-other-meshes~ sector)
                                   (let ((mesh (new Mesh material: water-material)))
                                     (let ((material (get-material~ mesh)))
                                       (table-set! (get-other-meshes~ sector) material mesh)
                                       (fill-vertices/neighbors~ sector mesh vertices neighbors)
                                       (fill-lightmap~ sector mesh lightmap)))))
                               (when wet
                                 (bind (vertices neighbors lightmap) wet
                                   (setup-other-meshes~ sector)
                                   (let ((mesh (new Mesh material: wet-material)))
                                     (let ((material (get-material~ mesh)))
                                       (table-set! (get-other-meshes~ sector) material mesh)
                                       (fill-vertices/neighbors~ sector mesh vertices neighbors)
                                       (fill-lightmap~ sector mesh lightmap)))))
                               (when multitexture
                                 (bind (vertices neighbors lightmap) multitexture
                                   (setup-other-meshes~ sector)
                                   (let ((mesh (new Mesh material: multitexture-material)))
                                     (let ((material (get-material~ mesh)))
                                       (table-set! (get-other-meshes~ sector) material mesh)
                                       (fill-vertices/neighbors~ sector mesh vertices neighbors)
                                       (fill-lightmap~ sector mesh lightmap)))))
                               (set-vertices-uptodate?~ sector #t)
                               (set-lightmap-uptodate?~ sector #t)
                               (sector-generated sector)
                               (generate-done)))))))))))))))))
  
  
  (method virtual (sector-generated sector)
    )
  
  
  (method (generate-sector-heightmap sector <Sector> what)
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (decrease-sectors-generating sector))
    
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region sector-x sector-y sector-z)))
          (if (not region)
              (when (eq? what 'render)
                (generate-done))
            (let ((chunk (get-chunk~ region sector-x sector-z)))
              (if (not chunk)
                  (when (eq? what 'render)
                    (generate-done))
                (if (or (get-heightmap-uptodate?~ chunk)
                        (get-heightmap-generating?~ chunk))
                    (generate-done)
                  (set-heightmap-generating?~ chunk #t)
                  (let ((from-x (* sector-x 16))
                        (width 16)
                        (from-z (* sector-z 16))
                        (depth 16)
                        (heightmap (get-heightmap~ chunk)))
                    (define (index i <fx> k <fx>) <fx>
                      (+ (* k 16) i))
                    
                    (let ((x-count (+ width 1))
                          (z-count (+ depth 1)))
                      (let ((f32heightmap (make-f32vector (* x-count z-count))))
                        (define (f32index i <fx> k <fx>) <fx>
                          (+ (* i z-count) k))
                        
                        (loop (for k from 0 to 16)
                              (loop (for i from 0 to 16)
                                    (let ((height (vector-ref heightmap (index (min i 15) (min k 15)))))
                                      (f32vector-set! f32heightmap (f32index i k) (cast <fl> height)))))
                        (generate-heightmap-content sector f32heightmap from-x width from-z depth what)
                        (set-heightmap-uptodate?~ chunk #t))))))))))))
  
  
  ;;;
  ;;;; Model
  ;;;
  
  
  (method (minecraft-blocks)
    blocks)
  
  
  (method (minecraft-blockids)
    blockids)
  
  
  (method (minecraft-block-model block x y z)
    (let ((faces '())
          (block-radius .5)
          (block-id (get-id~ block))
          (uv (block-texture-coordinates block))
          (generate (get-generate~ block))
          (opaque-cube? (get-opaque-cube?~ block))
          (material (cache-material~ block))
          (transparent-material (transparent-material)))
      (define (add-face face <Face>)
        (set! faces (cons face faces)))
      
      (define (add-transparent-face face <Face>)
        (set! faces (cons face faces)))
      
      (define (add-opaque-cube left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting material)
        (add-face (left-side   x y z block-radius left-uv lighting material))
        (add-face (right-side  x y z block-radius right-uv lighting material))
        (add-face (bottom-side x y z block-radius bottom-uv lighting material))
        (add-face (top-side    x y z block-radius top-uv lighting material))
        (add-face (back-side   x y z block-radius back-uv lighting material))
        (add-face (front-side  x y z block-radius front-uv lighting material)))
      
      (define (no-lighting ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
        0.)
      
      (let ((lighting no-lighting))
        (cond (generate
               (generate block-id 0 x y z block-radius uv lighting material add-face add-transparent-face add-opaque-cube))
              (opaque-cube?
               (add-opaque-cube uv uv uv uv uv uv lighting material))
              (else
               (add-cross-faces x y z block-radius uv lighting transparent-material add-transparent-face))))
      faces))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (proclaim (not warn optimizations))
  
  
  (method override (target-update target face face-rank poly)
    (define (count-chunks)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (when region
              (increase! count (table-length (get-chunks~ region))))))
        count))
    
    (define (count-sections)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (when region
              (iterate-table (get-chunks~ region)
                (lambda (index chunk)
                  (when chunk
                    (increase! count (table-length (get-sections~ chunk)))))))))
        count))
    
    (define (center-info title center)
      (let ((sector (position-sector center))
            (area (position-area center))
            (x (fxround (/ (- (vertex-x center) .5) 1.)))
            (y (fxround (/ (- (vertex-y center) .5) 1.)))
            (z (fxround (/ (- (vertex-z center) .5) 1.))))
        (let ((block (vector x y z))
              (sector-index (get-index~ sector)))
          (let ((sector-x (vector-ref sector-index 0))
                (sector-y (vector-ref sector-index 1))
                (sector-z (vector-ref sector-index 2)))
            (let ((region (sector-region sector-x sector-y sector-z)))
              (let ((section (get-section~ region sector-x sector-y sector-z)))
                (when section
                  (let ((blocks (get-blocks~ section))
                        (data (get-data~ section))
                        (blocklight (get-blocklight~ section))
                        (skylight (get-skylight~ section)))
                    (define (block-ref i <fx> j <fx> k <fx>)
                      (normalize-block-id (s8vector-ref blocks (+ (* j 256) (* k 16) i))))
                    
                    (define (normalize-block-id id <fx>)
                      (if (>= id 0)
                          id
                        (+ 256 id)))
                    
                    (define (index i <fx> j <fx> k <fx>)
                      (+ (* j 256) (* k 16) i))
                    
                    (define (nibble4 array index)
                      (let ((byte (s8vector-ref array (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (data-ref i <fx> j <fx> k <fx>)
                      (nibble4 data (index i j k)))
                    
                    (define (blocklight-ref i <fx> j <fx> k <fx>)
                      (nibble4 blocklight (index i j k)))
                    
                    (define (skylight-ref i <fx> j <fx> k <fx>)
                      (nibble4 skylight (index i j k)))
                    
                    (define (block-info i <fx> j <fx> k <fx>)
                      (let ((id (block-ref i j k))
                            (data (data-ref i j k))
                            (blocklight (blocklight-ref i j k))
                            (skylight (skylight-ref i j k)))
                        (let ((block (blockid->block id)))
                          (list (cons title (get-name~ block))
                                (cons "id" id)
                                (cons "data" data)
                                (cons "block light" blocklight)
                                (cons "sky light" skylight)
                                (cons "sector" (format "{r precision: 3}, {r precision: 3}, {r precision: 3}" sector-x sector-y sector-z))
                                (cons "coord" (format "{a} {a} {a}" i j k))))))
                    
                    (let ((i (- x (* sector-x 16)))
                          (j (- y (* sector-y 16)))
                          (k (- z (* sector-z 16))))
                      (block-info i j k))))))))))
    
    (register-info 'minecraft
      (lambda (add-section add-info)
        (with-regions-mutex
          (lambda ()
            (let ((section (add-section "Minecraft")))
              (add-info section "regions" (table-length regions))
              (add-info section "chunks" (count-chunks))
              (add-info section "sections" (count-sections)))))))
    (if (not poly)
        (begin
          (unregister-info 'block)
          (unregister-info 'top))
      (let ((block (vertex+ (get-center~ poly) (vertex-scalar*& (get-normal~ poly) -.5))))
        (let ((info (center-info "Block" block)))
          (register-info 'block
            (lambda (add-section add-info)
              (let ((section (add-section "Block")))
                (for-each (lambda (info)
                            (add-info section (car info) (cdr info)))
                          info)))))
        (let ((top (vertex+ block (vertex 0. 1. 0.))))
          (let ((info (center-info "Top" top)))
            (if (not info)
                (unregister-info 'top)
              (register-info 'top
                (lambda (add-section add-info)
                  (let ((section (add-section "Top")))
                    (for-each (lambda (info)
                                (add-info section (car info) (cdr info)))
                              info))))))))))
  
  
  (proclaim (warn optimizations)))


;;;
;;;; Add
;;;


(definition public (left-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting material)
  (left-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting material))


(definition public (left-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting material)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face material
                         (f32vector tl tt tl tb tr tb tr tt)
                         texture-depth
                         (make-quad #f
                                    (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front))
                         (lighting -1  0 -1 -1  0  0 -1  1 -1 -1  1  0)
                         (lighting -1 -1 -1 -1 -1  0 -1  0 -1 -1  0  0)
                         (lighting -1 -1  0 -1 -1  1 -1  0  0 -1  0  1)
                         (lighting -1  0  0 -1  0  1 -1  1  0 -1  1  1))))


(definition public (right-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting material)
  (right-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting material))


(definition public (right-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting material)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face material
                         (f32vector tl tt tl tb tr tb tr tt)
                         texture-depth
                         (make-quad #f
                                    (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back))
                         (lighting  1  0  0  1  0  1  1  1  0  1  1  1)
                         (lighting  1 -1  0  1 -1  1  1  0  0  1  0  1)
                         (lighting  1 -1 -1  1 -1  0  1  0 -1  1  0  0)
                         (lighting  1  0 -1  1  0  0  1  1 -1  1  1  0))))


(definition public (bottom-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting material)
  (bottom-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting material))


(definition public (bottom-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting material)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face material
                         (f32vector tl tt tl tb tr tb tr tt)
                         texture-depth
                         (make-quad #f
                                    (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front))
                         (lighting -1 -1  0 -1 -1  1  0 -1  0  0 -1  1)
                         (lighting -1 -1 -1 -1 -1  0  0 -1 -1  0 -1  0)
                         (lighting  0 -1 -1  0 -1  0  1 -1 -1  1 -1  0)
                         (lighting  0 -1  0  0 -1  1  1 -1  0  1 -1  1))))


(definition public (top-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting material)
  (top-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting material))


(definition public (top-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting material)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face material
                         (f32vector tl tb tl tt tr tt tr tb)
                         texture-depth
                         (make-quad #f
                                    (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back))
                         (lighting -1  1 -1 -1  1  0  0  1 -1  0  1  0)
                         (lighting -1  1  0 -1  1  1  0  1  0  0  1  1)
                         (lighting  0  1  0  0  1  1  1  1  0  1  1  1)
                         (lighting  0  1 -1  0  1  0  1  1 -1  1  1  0))))


(definition public (back-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting material)
  (back-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting material))


(definition public (back-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting material)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face material
                         (f32vector tr tt tr tb tl tb tl tt)
                         texture-depth
                         (make-quad #f
                                    (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back))
                         (lighting  0  0 -1  0  1 -1  1  0 -1  1  1 -1)
                         (lighting  0 -1 -1  0  0 -1  1 -1 -1  1  0 -1)
                         (lighting -1 -1 -1 -1  0 -1  0 -1 -1  0  0 -1)
                         (lighting -1  0 -1 -1  1 -1  0  0 -1  0  1 -1))))


(definition public (front-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting material)
  (front-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting material))


(definition public (front-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting material)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face material
                         (f32vector tl tt tl tb tr tb tr tt)
                         texture-depth
                         (make-quad #f
                                    (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front))
                         (lighting -1  0  1 -1  1  1  0  0  1  0  1  1)
                         (lighting -1 -1  1 -1  0  1  0 -1  1  0  0  1)
                         (lighting  0 -1  1  0  0  1  1 -1  1  1  0  1)
                         (lighting  0  0  1  0  1  1  1  0  1  1  1  1))))


(definition public (add-cube-faces x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting material add-face)
  (let ((left (- x radius))
        (right (+ x radius))
        (bottom (- y radius))
        (top (+ y radius))
        (back (- z radius))
        (front (+ z radius)))
    (add-face (left-face   left right bottom top back front uv lighting material))
    (add-face (right-face  left right bottom top back front uv lighting material))
    (add-face (bottom-face left right bottom top back front uv lighting material))
    (add-face (top-face    left right bottom top back front uv lighting material))
    (add-face (back-face   left right bottom top back front uv lighting material))
    (add-face (front-face  left right bottom top back front uv lighting material))))


(definition public (add-cross-faces x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting material add-transparent-face)
  (let ((left (- x radius))
        (right (+ x radius))
        (bottom (- y radius))
        (top (+ y radius))
        (back (- z radius))
        (front (+ z radius))
        (tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (add-transparent-face (make-minecraft-face material
                                               (f32vector tl tt tl tb tr tb tr tt)
                                               texture-depth
                                               (make-quad #f
                                                          (vertex right top back) (vertex right bottom back) (vertex left bottom front) (vertex left top front))
                                               0 0 0 0))
    (add-transparent-face (make-minecraft-face material
                                               (f32vector tl tt tl tb tr tb tr tt)
                                               texture-depth
                                               (make-quad #f
                                                          (vertex right top front) (vertex right bottom front) (vertex left bottom back) (vertex left top back))
                                               0 0 0 0))))


(definition (add-stairs x <fl> y <fl> z <fl> block-radius <fl> uv lighting material add-face)
  (let ((left (- x block-radius))
        (right (+ x block-radius))
        (bottom (- y block-radius))
        (top y)
        (back (- z block-radius))
        (front (+ z block-radius)))
    (add-face (left-face   left right bottom top back front uv lighting material))
    (add-face (right-face  left right bottom top back front uv lighting material))
    (add-face (bottom-face left right bottom top back front uv lighting material))
    (add-face (top-face    left right bottom top back front uv lighting material))
    (add-face (back-face   left right bottom top back front uv lighting material))
    (add-face (front-face  left right bottom top back front uv lighting material))))


(definition (add-slab x <fl> y <fl> z <fl> block-radius <fl> uv lighting material add-face)
  (let ((left (- x block-radius))
        (right (+ x block-radius))
        (bottom (- y block-radius))
        (top y)
        (back (- z block-radius))
        (front (+ z block-radius)))
    (add-face (left-face   left right bottom top back front uv lighting material))
    (add-face (right-face  left right bottom top back front uv lighting material))
    (add-face (bottom-face left right bottom top back front uv lighting material))
    (add-face (top-face    left right bottom top back front uv lighting material))
    (add-face (back-face   left right bottom top back front uv lighting material))
    (add-face (front-face  left right bottom top back front uv lighting material))))


(definition (add-rail data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv lighting material add-transparent-face)
  (case (bitwise-and data-id #x7)
    ((0) (add-bottom x y z block-radius uv lighting material add-transparent-face))
    ((1) (add-bottom x y z block-radius uv lighting material add-transparent-face))
    ((2) (add-right  x y z block-radius uv lighting material add-transparent-face))
    ((3) (add-left   x y z block-radius uv lighting material add-transparent-face))
    ((4) (add-front  x y z block-radius uv lighting material add-transparent-face))
    ((5) (add-back   x y z block-radius uv lighting material add-transparent-face))))


(definition add-epsilon <fl>
  .1)


(definition (add-left x <fl> y <fl> z <fl> radius <fl> uv lighting material add-transparent-face)
  (add-transparent-face (left-face (+ (- x radius) add-epsilon) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting material)))


(definition (add-right x <fl> y <fl> z <fl> radius <fl> uv lighting material add-transparent-face)
  (add-transparent-face (right-face (- x radius) (- (+ x radius) add-epsilon) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting material)))


(definition (add-bottom x <fl> y <fl> z <fl> radius <fl> uv lighting material add-transparent-face)
  (add-transparent-face (bottom-face (- x radius) (+ x radius) (+ (- y radius) add-epsilon) (+ y radius) (- z radius) (+ z radius) uv lighting material)))


(definition (add-top x <fl> y <fl> z <fl> radius <fl> uv lighting material add-transparent-face)
  (add-transparent-face (top-face (- x radius) (+ x radius) (- y radius) (- (+ y radius) add-epsilon) (- z radius) (+ z radius) uv lighting material)))


(definition (add-back x <fl> y <fl> z <fl> radius <fl> uv lighting material add-transparent-face)
  (add-transparent-face (back-face (- x radius) (+ x radius) (- y radius) (+ y radius) (+ (- z radius) add-epsilon) (+ z radius) uv lighting material)))


(definition (add-front x <fl> y <fl> z <fl> radius <fl> uv lighting material add-transparent-face)
  (add-transparent-face (front-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (- (+ z radius) add-epsilon) uv lighting material)))


(definition (add-transparent data-id left right back front x y z block-radius uv lighting material add-transparent-face)
  (ecase data-id
    ((left)  (add-left  x y z block-radius uv lighting material add-transparent-face))
    ((right) (add-right x y z block-radius uv lighting material add-transparent-face))
    ((back)  (add-back  x y z block-radius uv lighting material add-transparent-face))
    (else    (add-front x y z block-radius uv lighting material add-transparent-face))))


;;;
;;;; World
;;;


(class Minecraft-World extends World))
