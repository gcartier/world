;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Minecraft
;;;


(module world.external.minecraft jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.system)
        (jazz.ui.window)
        (zlib)
        (world)
        (world.animation)
        (world.atlas)
        (world.autoload)
        (world.binary)
        (world.block)
        (world.dye)
        (world.external)
        (world.external.minecraft-syntax (phase syntax))
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.homogeneous)
        (world.material)
        (world.mesh)
        (world.model)
        (world.sector)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle))


(proclaim (warn optimizations))


(constant region-size <fx>
  32)


;;;
;;;; NBT
;;;


(constant TAG_End        <fx>  0)
(constant TAG_Byte       <fx>  1)
(constant TAG_Short      <fx>  2)
(constant TAG_Int        <fx>  3)
(constant TAG_Long       <fx>  4)
(constant TAG_Float      <fx>  5)
(constant TAG_Double     <fx>  6)
(constant TAG_Byte_Array <fx>  7)
(constant TAG_String     <fx>  8)
(constant TAG_List       <fx>  9)
(constant TAG_Compound   <fx> 10)
(constant TAG_Int_Array  <fx> 11)


(class NBT-Stream extends Binary-Stream
  
  
  (method (read-tag read)
    (define (read-tag read)
      (let ((type <fx> (<-u8)))
        (if (= type TAG_End)
            #t
          (let ((name (read-name read)))
            (cond ((not read)
                   (read-data type read)
                   #f)
                  ((eq? read #t)
                   (cons name (read-data type read)))
                  (else
                   (read type name read-data)))))))
    
    (define (read-name read)
      (let ((size <fx> (read-short #t)))
        (cond ((not read)
               (increase! position size))
              ((= size 0)
               "")
              (else
               (<-utf-8-string size)))))
    
    (define (read-data type read)
      (ecase type
        ((TAG_End)        (read-end read))
        ((TAG_Byte)       (read-byte read))
        ((TAG_Short)      (read-short read))
        ((TAG_Int)        (read-int read))
        ((TAG_Long)       (read-long read))
        ((TAG_Float)      (read-float read))
        ((TAG_Double)     (read-double read))
        ((TAG_Byte_Array) (read-byte-array read))
        ((TAG_String)     (read-name read))
        ((TAG_List)       (read-list read))
        ((TAG_Compound)   (read-compound read))
        ((TAG_Int_Array)  (read-int-array read))
        (else (error "Unknown NBT tag: {s}" type))))
    
    (define (read-end read)
      (error "Invalid NBT tag: TAG_End"))
    
    (define (read-byte read)
      (if (not read)
          (increase! position 1)
        (<-s8)))
    
    (define (read-short read)
      (if (not read)
          (increase! position 2)
        (<-s16-big-endian)))
    
    (define (read-int read)
      (if (not read)
          (increase! position 4)
        (<-s32-big-endian)))
    
    (define (read-long read)
      (if (not read)
          (increase! position 8)
        (<-s64-big-endian)))
    
    (define (read-float read)
      (if (not read)
          (increase! position 4)
        (<-float-big-endian)))
    
    (define (read-double read)
      (if (not read)
          (increase! position 8)
        (<-double-big-endian)))
    
    (define (read-byte-array read)
      (let ((size <fx> (read-int #t)))
        (if (not read)
            (increase! position size)
          (let ((data (make-s8vector size)))
            (loop (for i from 0 below size)
                  (s8vector-set! data i (read-byte read)))
            data))))
    
    (define (read-int-array read)
      (let ((size <fx> (read-int #t)))
        (if (not read)
            (increase! position (* size 4))
          (let ((data (make-vector size)))
            (loop (for i from 0 below size)
                  (vector-set! data i (read-int read)))
            data))))
    
    (define (read-list read)
      (let ((type <fx> (read-byte #t))
            (size <fx> (read-int #t)))
        (loop (repeat size)
              (collect (read-data type read)))))
    
    (define (read-compound read)
      (let ((tag (read-tag read)))
        (cond ((eq? tag #t)
               '())
              ((or (not tag)
                   (not read))
               (read-compound read))
              (else
               (cons tag (read-compound read))))))
    
    (read-tag read)))


;;;
;;;; Block
;;;


(class Minecraft-Block-Model extends Object
  
  
  (slot name                getter generate)
  (slot id                  getter generate)
  (slot subid               getter generate)
  (slot texture             getter generate)
  (slot texture-coordinates accessors generate)
  (slot transparent?        getter generate)
  
  
  (method override (initialize name id subid texture transparent?)
    (set! name~self name)
    (set! id~self id)
    (set! subid~self subid)
    (set! texture~self texture)
    (set! texture-coordinates~self #f)
    (set! transparent?~self transparent?))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition blocks
  (make-table test: eq?))

(definition blockids
  (make-vector 256 #f))


(definition dont-care-texture
  #x17)

(definition unknown-texture
  #x1A)


(definition (register-block name id (texture #f) (transparent? #f))
  (let ((id (if (pair? id) (car id) id))
        (subid (if (pair? id) (cadr id) #f)))
    (when (not subid)
      (let ((texture (case texture
                       ((#t) dont-care-texture)
                       ((#f) unknown-texture)
                       (else texture))))
        (let ((block (new Minecraft-Block-Model name id subid texture transparent?)))
          (table-set! blocks name block)
          (vector-set! blockids id block))))))


(definition inline (blockid->block id <fx>) <Minecraft-Block-Model>
  (vector-ref blockids id))


(definition tile-resolution <fx>
  (find-setting 'minecraft.tile-resolution 16))

(definition tile-size <fl>
  (cast <fl> tile-resolution))

(definition tile-period <fx>
  16)

(definition texture-size <fl>
  (* tile-size (cast <fl> tile-period)))

(definition texture-pack
  (format "terrain{a}x{a}.png" tile-resolution tile-resolution))


(definition (block-texture-coordinates block <Minecraft-Block-Model>)
  (or (get-texture-coordinates~ block)
      (let ((coords (rank-texture-coordinates (get-texture~ block))))
        (set-texture-coordinates~ block coords)
        coords)))


(definition (rank-texture-coordinates texture-rank <fx>)
  (let ((x (modulo texture-rank tile-period)))
    (let ((y (/ (- texture-rank x) tile-period)))
      (let ((l (* (cast <fl> x) tile-size))
            (t (* (cast <fl> y) tile-size)))
        (let ((r (+ l tile-size -1.))
              (b (+ t tile-size -1.)))
          (list (/ (+ l .5) texture-size)
                (/ (+ t .5) texture-size)
                (/ (- r .5) texture-size)
                (/ (- b .5) texture-size)))))))


;;;
;;;; Blocks
;;;


(define-block Air
  0)

(define-block Stone
  1
  #x00)

(define-block Grass
  2
  #x03)

(define-block Dirt
  3
  #x02)

(define-block Cobblestone
  4
  #x11)

(define-block WoodenPlank
  5
  #x14)

(define-block Sapling
  6)

(define-block RedwoodSapling
  (6 1))

(define-block BirchSapling
  (6 2))

(define-block Bedrock
  7
  #x25)

(define-block Water
  8
  #xCD)

(define-block StationaryWater
  9
  #xCD)

(define-block Lava
  10
  #xFF)

(define-block StationaryLava
  11
  #xFF)

(define-block Sand
  12
  #x12)

(define-block Gravel
  13
  #x01)

(define-block GoldOre
  14
  #x20)

(define-block IronOre
  15
  #x10)

(define-block CoalOre
  16
  #x11)

(define-block Wood
  17
  #x04)

(define-block Redwood
  (17 1))

(define-block Birchwood
  (17 2))

(define-block Leaves
  18
  #x45)

(define-block RedwoodLeaves
  (18 1))

(define-block BirchwoodLeaves
  (18 2))

(define-block Sponge
  19)

(define-block Glass
  20
  #x31)

(define-block LapisLazuliOre
  21
  #t)

(define-block LapisLazuliBlock
  22)

(define-block Dispenser
  23)

(define-block Sandstone
  24
  #xB0)

(define-block NoteBlock
  25)

(define-block BedBlock
  26
  #t)

(define-block PoweredRail
  27
  #xB3)

(define-block DetectorRail
  28)

(define-block StickyPiston
  29)

(define-block Web
  30
  #x0B)

(define-block DeadShrub
  31
  #x5C
  #t)

(define-block TallGrass
  (31 1))

(define-block LiveShrub
  (31 2))

(define-block DeadShrub
  32
  #x37)

(define-block Piston
  33)

(define-block PistonHead
  34)

(define-block WhiteWool
  35
  #t)

(define-block OrangeWool
  (35 1))

(define-block MagentaWool
  (35 2))

(define-block LightBlueWool
  (35 3))

(define-block YellowWool
  (35 4))

(define-block LightGreenWool
  (35 5))

(define-block PinkWool
  (35 6))

(define-block GrayWool
  (35 7))

(define-block LightGrayWool
  (35 8))

(define-block CyanWool
  (35 9))

(define-block PurpleWool
  (35 10))

(define-block BlueWool
  (35 11))

(define-block BrownWool
  (35 12))

(define-block DarkGreenWool
  (35 13))

(define-block RedWool
  (35 14))

(define-block BlackWool
  (35 15))

(define-block Dandelion
  37
  #x0D
  #t)

(define-block Rose
  38
  #x0C
  #t)

(define-block BrownMushroom
  39
  #t)

(define-block RedMushroom
  40
  #x1C)

(define-block GoldBlock
  41)

(define-block IronBlock
  42)

(define-block DoubleStoneSlab
  43
  #t)

(define-block DoubleSandstoneSlab
  (43 1))

(define-block DoubleWoodenSlab
  (43 2))

(define-block DoubleCobblestoneSlab
  (43 3))

(define-block DoubleBrickSlab
  (43 4))

(define-block DoubleStoneBrickSlab
  (43 5))

(define-block StoneSlab
  44
  #t)

(define-block SandstoneSlab
  (44 1))

(define-block WoodenSlab
  (44 2))

(define-block CobblestoneSlab
  (44 3))

(define-block BrickSlab
  (44 4))

(define-block StoneBrickSlab
  (44 5))

(define-block Brick
  45)

(define-block TNT
  46)

(define-block Bookshelf
  47
  #t)

(define-block MossyCobblestone
  48
  #t)

(define-block Obsidian
  49
  #t)

(define-block Torch
  50
  #x63)

(define-block Fire
  51)

(define-block MonsterSpawner
  52
  #x41)

(define-block WoodenStairs
  53)

(define-block Chest
  54
  #t)

(define-block RedstoneWire
  55
  #xA6)

(define-block DiamondOre
  56
  #t)

(define-block DiamondBlock
  57)

(define-block Workbench
  58
  #x4A)

(define-block WheatCrops
  59
  #x5F
  #t)

(define-block Soil
  60
  #t)

(define-block Furnace
  61
  #t)

(define-block BurningFurnace
  62)

(define-block SignPost
  63)

(define-block WoodenDoorBlock
  64
  #x51)

(define-block Ladder
  65
  #x53)

(define-block Rails
  66
  #x80)

(define-block CobblestoneStairs
  67
  #t)

(define-block WallSign
  68
  #t)

(define-block Lever
  69)

(define-block StonePressurePlate
  70)

(define-block IronDoorBlock
  71)

(define-block WoodenPressurePlate
  72)

(define-block RedstoneOre
  73
  #x33)

(define-block GlowingRedstoneOre
  74)

(define-block RedstoneTorchOff
  75
  #x73)

(define-block RedstoneTorchOn
  76
  #x63)

(define-block StoneButton
  77
  #x9F)

(define-block Snow
  78)

(define-block Ice
  79)

(define-block SnowBlock
  80)

(define-block Cactus
  81
  #x46)

(define-block Clay
  82
  #t)

(define-block SugarCane
  83
  #x49)

(define-block Jukebox
  84)

(define-block Fence
  85
  #x55)

(define-block Pumpkin
  86
  #t)

(define-block Netherrack
  87)

(define-block SoulSand
  88)

(define-block Glowstone
  89)

(define-block Portal
  90)

(define-block Jack-O-Lantern
  91)

(define-block CakeBlock
  92)

(define-block RedstoneRepeaterBlockOff
  93)

(define-block RedstoneRepeaterBlockOn
  94)

(define-block LockedChest
  95)

(define-block Trapdoor
  96)

(define-block StoneSilverfish
  97)

(define-block CobblestoneSilverfish
  (97 1))

(define-block StoneBrickSilverfish
  (97 2))

(define-block StoneBrick
  98)

(define-block MossyStoneBrick
  (98 1))

(define-block CrackedStoneBrick
  (98 2))

(define-block RedMushroomCap
  99)

(define-block BrownMushroomCap
  100)

(define-block IronBars
  101)

(define-block GlassPane
  102
  #x42)

(define-block MelonBlock
  103)

(define-block PumpkinStem
  104)

(define-block MelonStem
  105)

(define-block Vines
  106
  #x1E)

(define-block FenceGate
  107)

(define-block BrickStairs
  108)

(define-block StoneBrickStairs
  109)

(define-block Mycelium
  110)

(define-block LilyPad
  111
  #t)

(define-block NetherBrick
  112)

(define-block NetherBrickFence
  113)

(define-block NetherBrickStairs
  114)

(define-block NetherWart
  115)

(define-block EnchantmentTable
  116
  #t)

(define-block BrewingStand
  117)

(define-block Cauldron
  118)

(define-block EndPortal
  119)

(define-block EndPortalFrame
  120)

(define-block EndStone
  121)

(define-block DragonEgg
  122)

(define-block RedstoneLampInactive
  123)

(define-block RedstoneLampActive
  124)

(define-block DoubleWoodenSlab
  125)

(define-block WoodenSlab
  126)

(define-block CocoaPlant
  127
  #t)

(define-block SandstoneStairs
  128)

(define-block EmeraldOre
  129)

(define-block EnderChest
  130)

(define-block TripwireHook
  131)

(define-block Tripwire
  132)

(define-block EmeraldBlock
  133)

(define-block SpruceWoodStairs
  134)

(define-block BirchWoodStairs
  135)

(define-block JungleWoodStairs
  136)

(define-block CommandBlock
  137)

(define-block BeaconBlock
  138)

(define-block CobblestoneWall
  139)

(define-block FlowerPot
  140)

(define-block Carrots
  141)

(define-block Potatoes
  142)

(define-block WoodenButton
  143)


(loop (for id from 0 below 256)
      (unless (vector-ref blockids id)
        (register-block 'Unknown id)))


;;;
;;;; Chunk
;;;


(class Minecraft-Chunk extends Object
  
  
  (slot entities getter generate)
  (slot sections getter generate)
  
  
  (method override (initialize entities sections)
    (set! entities~self entities)
    (set! sections~self sections)))


;;;
;;;; Region
;;;


(class Minecraft-Region extends Object
  
  
  (slot x      <fx>                                            getter generate)
  (slot z      <fx>                                            getter generate)
  (slot port   <port>                                          getter generate)
  (slot header <u8vector>                                      getter generate)
  (slot chunks <table>    initialize (make-table test: equal?) getter generate)
  
  
  (method override (initialize x z port)
    (set! x~self x)
    (set! z~self z)
    (set! port~self port)
    (set! header (read-header)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" x z))))
  
  
  (method (read-header)
    (let ((size (* 8 1024)))
      (let ((content (make-u8vector size)))
        (read-subu8vector content 0 size port)
        content)))
  
  
  (method (get-chunk x <fx> z <fx>) <Minecraft-Chunk+>
    (let ((chunk-index (chunk-index x z)))
      (or (table-ref chunks chunk-index #f)
          (let ((chunk (read-chunk chunk-index)))
            (table-set! chunks chunk-index chunk)
            chunk))))
  
  
  (method (chunk-index x <fx> z <fx>) <pair>
    ;; looks like we don't need to adjust for negative values like stated on the wiki
    (cons (modulo x 32)
          (modulo z 32)))
  
  
  (method (read-chunk chunk-index <pair>) <Minecraft-Chunk+>
    (let ((x <fx> (car chunk-index))
          (z <fx> (cdr chunk-index)))
      (let ((offset (* 4 (+ x (* z 32)))))
        (assert (<= offset 4092))
        (let ((b1 (u8vector-ref header offset))
              (b2 (u8vector-ref header (+ offset 1)))
              (b3 (u8vector-ref header (+ offset 2)))
              (b4 (u8vector-ref header (+ offset 3))))
          (if (and (= b1 0)
                   (= b2 0)
                   (= b3 0)
                   (= b4 0))
              #f
            (let ((offset (* (+ (cast <fx> (arithmetic-shift b1 16))
                                (cast <fx> (arithmetic-shift b2 8))
                                b3)
                             (* 4 1024))))
              (input-port-byte-position port offset)
              (let ((chunk-header (make-u8vector 5)))
                (read-subu8vector chunk-header 0 5 port)
                (let ((size <fx> (scan-u32-big-endian chunk-header 0))
                      (compression-type (u8vector-ref chunk-header 4)))
                  ;; skip two bytes for deflate
                  (read-u8 port)
                  (read-u8 port)
                  (let ((chunk-raw (make-u8vector size)))
                    (read-subu8vector chunk-raw 0 size port)
                    (let ((chunk-data (inflate-u8vector chunk-raw)))
                      (let ((s (new NBT-Stream (cons chunk-data 0))))
                        (let ((tag-data
                                (read-tag~ s
                                  (lambda (type name read-data)
                                    (read-data type
                                      (lambda (type name read-data)
                                        (read-data type
                                          (lambda (type name read-data)
                                            (cond @wait ((equal? name "Entities")
                                                         (cons name (read-data type #t)))
                                                  ((equal? name "Sections")
                                                   (cons name (read-data type
                                                                (lambda (type name read-data)
                                                                  (if (or (equal? name "Y")
                                                                          (equal? name "Blocks"))
                                                                      (cons name (read-data type #t))
                                                                    (read-data type #f)
                                                                    #f)))))
                                                  (else
                                                   (read-data type #f)
                                                   #f))))))))))
                          (let ((alist (car tag-data)))
                            (let ((entities (assoc "Entities" alist))
                                  (sections (assoc "Sections" alist)))
                              (let ((sections-table (and sections (make-table test: eq?))))
                                (when sections-table
                                  (for-each (lambda (section)
                                              (let ((yPos (- (cdr (assoc "Y" section)) 4)) ;; lower everything by 64
                                                    (blocks (cdr (assoc "Blocks" section))))
                                                (table-set! sections-table yPos blocks)))
                                            (cdr sections)))
                                (new Minecraft-Chunk
                                  (and entities (cdr entities))
                                  sections-table))))))))))))))))
  
  
  (method (get-blocks x <fx> y <fx> z <fx>) <s8vector+>
    (let ((chunk (get-chunk x z)))
      (when chunk
        (let ((sections (get-sections~ chunk)))
          (when sections
            (table-ref sections y #f)))))))


;;;
;;;; Level
;;;


(definition public (import-minecraft-level file)
  (let ((s (new NBT-Stream file)))
    (read-tag~ s #t)))


;;;
;;;; Sector
;;;


(class Minecraft-Sector extends Sector
  
  
  (method override (collect-apparent-faces)
    faces))


;;;
;;;; Zone
;;;


(definition generate-count <fl>
  0.)

(definition generate-total <fl>
  0.)


(definition public (generate-average)
  (/ generate-total generate-count))


(class Minecraft-Zone extends Zone
  
  
  (property level-dir <Directory> initialize #f accessors generate)
  
  
  (slot regions-dir <Directory> initialize #f                        getter explicit)
  (slot regions     <table>     initialize (make-table test: equal?) getter generate)
  
  
  (form
    (<install> floor-level: -500.))
  
  
  (method (get-regions-dir) <Directory>
    (or regions-dir (let ((dir (new-directory~ level-dir "region")))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method (get-region region-index <pair>) <Minecraft-Region+>
    (define (region-name)
      (bind (region-x . region-z) region-index
        (format "r.{a}.{a}.mca" region-x region-z)))
    
    (let ((value (table-ref regions region-index #t)))
      (if (neq? value #t)
          value
        (let ((dir (get-regions-dir))
              (name (region-name)))
          (let ((file (new-file~ dir name)))
            (let ((region (if (exists?~ file)
                              (bind (region-x . region-z) region-index
                                (let ((port (open-input-file (path-settings file))))
                                  (new Minecraft-Region region-x region-z port)))
                            #f)))
              (table-set! regions region-index region)
              region))))))
  
  
  (method (sector-region sector-x <fx> sector-y <fx> sector-z <fx>) <Minecraft-Region+>
    (define (region-index)
      (cons (fxfloor/ sector-x region-size)
            (fxfloor/ sector-z region-size)))
    
    (get-region (region-index)))
  
  
  (method (sector-blocks sector-x <fx> sector-y <fx> sector-z <fx>) <s8vector+>
    (let ((region (sector-region sector-x sector-y sector-z)))
      (when region
        (get-blocks~ region sector-x sector-y sector-z))))
  
  
  (method override (sector-class)
    Minecraft-Sector)
  
  
  (method override (generate-content?)
    #t)
  
  
  ;; for testing
  (definition generated
    0)
  
  
  (method override (generate-content sector <Minecraft-Sector>)
    (define (generate)
      (let ((before (real-time)))
        (generate-content-threaded sector)
        (let ((after (real-time)))
          (let ((duration (- after before)))
            (set! generate-count (+ generate-count 1.))
            (set! generate-total (+ generate-total duration))))))
    
    (let ((mesh (get-mesh~ sector)))
      (set-content-uptodate?~ sector #t)
      (free-vertices~ mesh)
      (free-neighbors~ mesh)
      (set-vertices-uptodate?~ sector #t)
      (free-lightmap~ mesh)
      (set-lightmap-uptodate?~ sector #t))
    
    (let ((max-generate (find-setting 'world.max-generate #f)))
      (when (or (not max-generate) (< generated max-generate))
        (if (find-setting 'world.generate-threaded? #t)
            (post-content generate)
          (generate))
        (increase! generated))))
  
  
  (method (generate-content-threaded sector <Minecraft-Sector>)
    (bind (sector-x <fx> sector-y <fx> sector-z <fx>) (get-index~ sector)
      (let ((region (sector-region sector-x sector-y sector-z)))
        (when region
          (let ((region-x (get-x~ region))
                (region-z (get-z~ region))
                (blocks (get-blocks~ region sector-x sector-y sector-z))
                (chunk-index (chunk-index~ region sector-x sector-z)))
            (assert (= region-x (fxfloor/ sector-x region-size)))
            (assert (= region-z (fxfloor/ sector-z region-size)))
            (when blocks
              (let* ((yPos (fxfloor/ sector-y region-size))
                     (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                     (section-y (* sector-y 16))
                     (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                     (block-size 5.)
                     (block-radius (/ block-size 2.))
                     (block-radiuses (vertex block-radius block-radius block-radius))
                     (all-faces '())
                     (opaque-faces '())
                     (physical? (find-setting 'world.physical? #t)))
                (define (block-ref i <fx> j <fx> k <fx>)
                  (normalize-id (s8vector-ref blocks (+ (* j 256) (* k 16) i))))
                
                (define (blocks-ref blocks <s8vector> i <fx> j <fx> k <fx>)
                  (normalize-id (s8vector-ref blocks (+ (* j 256) (* k 16) i))))
                
                (define (normalize-id id <fx>)
                  (if (>= id 0)
                      id
                    (+ 256 id)))
                
                (define (left-ref i <fx> j <fx> k <fx>)
                  (if (> i 0)
                      (block-ref (- i 1) j k)
                    (let ((blocks (sector-blocks (- sector-x 1) sector-y sector-z)))
                      (if (not blocks)
                          1
                        (blocks-ref blocks 15 j k)))))
                
                (define (right-ref i <fx> j <fx> k <fx>)
                  (if (< i 15)
                      (block-ref (+ i 1) j k)
                    (let ((blocks (sector-blocks (+ sector-x 1) sector-y sector-z)))
                      (if (not blocks)
                          1
                        (blocks-ref blocks 0 j k)))))
                
                (define (bottom-ref i <fx> j <fx> k <fx>)
                  (if (> j 0)
                      (block-ref i (- j 1) k)
                    (let ((blocks (sector-blocks sector-x (- sector-y 1) sector-z)))
                      (if (not blocks)
                          1
                        (blocks-ref blocks i 15 k)))))
                
                (define (top-ref i <fx> j <fx> k <fx>)
                  (if (< j 15)
                      (block-ref i (+ j 1) k)
                    (let ((blocks (sector-blocks sector-x (+ sector-y 1) sector-z)))
                      (if (not blocks)
                          1
                        (blocks-ref blocks i 0 k)))))
                
                (define (back-ref i <fx> j <fx> k <fx>)
                  (if (> k 0)
                      (block-ref i j (- k 1))
                    (let ((blocks (sector-blocks sector-x sector-y (- sector-z 1))))
                      (if (not blocks)
                          1
                        (blocks-ref blocks i j 15)))))
                
                (define (front-ref i <fx> j <fx> k <fx>)
                  (if (< k 15)
                      (block-ref i j (+ k 1))
                    (let ((blocks (sector-blocks sector-x sector-y (+ sector-z 1))))
                      (if (not blocks)
                          1
                        (blocks-ref blocks i j 0)))))
                
                (let ((x (* block-size (cast <fl> section-x)))
                      (y (* block-size (cast <fl> section-y)))
                      (z (* block-size (cast <fl> section-z))))
                  (loop (for j from 0 below 16)
                        (loop (for k from 0 below 16)
                              (loop (for i from 0 below 16)
                                    (let ((block-y (+ section-y j)))
                                      (let ((block-id <fx> (block-ref i j k)))
                                        (when (/= block-id 0)
                                          (let ((x (+ section-x i))
                                                (y block-y)
                                                (z (+ section-z k))
                                                (block (blockid->block block-id)))
                                            (bind (tl tt tr tb) (block-texture-coordinates block)
                                              (let ((x (+ block-radius (* block-size (cast <fl> x))))
                                                    (y (+ block-radius (* block-size (cast <fl> y))))
                                                    (z (+ block-radius (* block-size (cast <fl> z))))
                                                    (transparent? (get-transparent?~ block)))
                                                (define (add-face face <Face>)
                                                  (set! all-faces (cons face all-faces))
                                                  (set! opaque-faces (cons face opaque-faces)))
                                                
                                                (define (add-transparent-face face <Face>)
                                                  (set! all-faces (cons face all-faces)))
                                                
                                                (define (opaque? block-id <fx>)
                                                  (and (/= block-id 0)
                                                       (not (get-transparent?~ (blockid->block block-id)))))
                                                
                                                (if transparent?
                                                    (add-cross-faces x y z block-radius tl tt tr tb add-transparent-face)
                                                  (unless (opaque? (left-ref   i j k)) (add-face (left-face   x y z block-radius tl tt tr tb)))
                                                  (unless (opaque? (right-ref  i j k)) (add-face (right-face  x y z block-radius tl tt tr tb)))
                                                  (unless (opaque? (bottom-ref i j k)) (add-face (bottom-face x y z block-radius tl tt tr tb)))
                                                  (unless (opaque? (top-ref    i j k)) (add-face (top-face    x y z block-radius tl tt tr tb)))
                                                  (unless (opaque? (back-ref   i j k)) (add-face (back-face   x y z block-radius tl tt tr tb)))
                                                  (unless (opaque? (front-ref  i j k)) (add-face (front-face  x y z block-radius tl tt tr tb))))))))))))))
                (when physical?
                  (let ((areas (make-table test: eq?)))
                    (for-each (lambda (face)
                                (let ((area (index-area (position-area-index (get-center~ face)))))
                                  (table-add areas area face)))
                              opaque-faces)
                    (iterate-table areas
                      (lambda (area faces)
                        (add-faces~ area faces)))))
                (let ((faces (list->vector all-faces)))
                  (receive (vertices neighbors) (prepare-vertices/neighbors~ sector faces)
                    (let ((lightmap (prepare-lightmap~ sector faces)))
                      (delay-event
                        (lambda ()
                          (fill-vertices/neighbors~ sector vertices neighbors)
                          (set-vertices-uptodate?~ sector #t)
                          (fill-lightmap~ sector lightmap)
                          (set-lightmap-uptodate?~ sector #t))))))))))))))


(definition cross-normal1
  (vertex-normalize (vertex -1. 0. -1.)))

(definition cross-normal2
  (vertex-normalize (vertex 1. 0. -1.)))


(definition public (add-cross-faces x <fl> y <fl> z <fl> radius <fl> tl <fl> tt <fl> tr <fl> tb <fl> add-face)
  (let ((l (- x radius))
        (r (+ x radius))
        (b (- y radius))
        (t (+ y radius))
        (f (- z radius))
        (n (+ z radius)))
    ;; FIX normals
    (add-face
      (make-face #f
                 #f
                 (vertex x y z)
                 4.33013
                 (make-triangle cross-normal1
                                (vertex r t f) (vertex l t n) (vertex l b n)
                                (vertex tl tt 1.) (vertex tr tt 1.) (vertex tr tb 1.))
                 (make-triangle cross-normal1
                                (vertex l b n) (vertex r b f) (vertex r t f)
                                (vertex tr tb 1.) (vertex tl tb 1.) (vertex tl tt 1.))))
    (add-face
      (make-face #f
                 #f
                 ;; QUICK HACK
                 (vertex (+ x 0.0001) y z)
                 4.33013
                 (make-triangle cross-normal2
                                (vertex r t n) (vertex l t f) (vertex l b f)
                                (vertex tl tt 1.) (vertex tr tt 1.) (vertex tr tb 1.))
                 (make-triangle cross-normal2
                                (vertex l b f) (vertex r b n) (vertex r t n)
                                (vertex tr tb 1.) (vertex tl tb 1.) (vertex tl tt 1.))))))


;;;
;;;; World
;;;


(class Minecraft-World extends World
  
  
  (method override (prepare-tile)
    (define (make-terrain-texture)
      (let ((dir (new-directory~ user-assets "pack")))
        (let ((file (new-file~ dir texture-pack)))
          (let ((mipmap? (find-setting 'minecraft.mipmap? (> tile-resolution 16))))
            (if mipmap?
                (make-file-texture file)
              (make-file-texture file min-filter: GL_NEAREST mag-filter: GL_NEAREST mipmap?: #f))))))
    
    (nextmethod)
    (let ((texture (make-terrain-texture)))
      (set! tile-texture texture)
      (set! tile-mesh (new Mesh material: (new Material texture: texture)))))))
