;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Minecraft
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.external.minecraft jazz


(import (gambit.log)
        (jazz.debuggee)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (zlib)
        (world)
        (world.animation)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.binary)
        (world.dye)
        (world.external)
        (world.external.minecraft-syntax (phase syntax))
        (world.face)
        (world.foreign)
        (world.generate)
        (world.geometry)
        (world.homogeneous)
        (world.info)
        (world.log)
        (world.material)
        (world.mesh)
        (world.model)
        (world.profiling)
        (world.quad)
        (world.renderers)
        (world.sector)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.texture)
        (world.triangle)
        (profiler))


(proclaim (warn optimizations))


(constant region-size <fx>
  32)


;;;
;;;; NBT
;;;


(constant TAG_End        <fx>  0)
(constant TAG_Byte       <fx>  1)
(constant TAG_Short      <fx>  2)
(constant TAG_Int        <fx>  3)
(constant TAG_Long       <fx>  4)
(constant TAG_Float      <fx>  5)
(constant TAG_Double     <fx>  6)
(constant TAG_Byte_Array <fx>  7)
(constant TAG_String     <fx>  8)
(constant TAG_List       <fx>  9)
(constant TAG_Compound   <fx> 10)
(constant TAG_Int_Array  <fx> 11)


(definition inline (make-tag name type value)
  (cons name (cons type value)))

(definition inline (tag-name tag)
  (car tag))

(definition inline (tag-type tag)
  (cadr tag))

(definition inline (tag-value tag)
  (cddr tag))

(definition inline (tag-assoc name alist)
  (let ((tag (assoc name alist)))
    (and tag (tag-value tag))))


(definition inline (make-list-payload type content)
  (cons type content))

(definition inline (list-payload-type payload)
  (car payload))

(definition inline (list-payload-content payload)
  (cdr payload))


(class NBT-Stream extends Binary-Stream
  
  
  (method (read-tag)
    (define (read-tag)
      (let ((type <fx> (<-u8)))
        (if (= type TAG_End)
            #f
          (let ((name (read-name)))
            (make-tag name type (read-data type))))))
    
    (define (read-data type)
      (ecase type
        ((TAG_End)        (read-end))
        ((TAG_Byte)       (read-byte))
        ((TAG_Short)      (read-short))
        ((TAG_Int)        (read-int))
        ((TAG_Long)       (read-long))
        ((TAG_Float)      (read-float))
        ((TAG_Double)     (read-double))
        ((TAG_Byte_Array) (read-byte-array))
        ((TAG_String)     (read-name))
        ((TAG_List)       (read-list))
        ((TAG_Compound)   (read-compound))
        ((TAG_Int_Array)  (read-int-array))
        (else (error "Unknown NBT tag: {s}" type))))
    
    (define (read-end)
      (error "Invalid NBT tag: TAG_End"))
    
    (define (read-byte)
      (<-s8))
    
    (define (read-short)
      (<-s16-big-endian))
    
    (define (read-int)
      (<-s32-big-endian))
    
    (define (read-long)
      (<-s64-big-endian))
    
    (define (read-float)
      (<-float-big-endian))
    
    (define (read-double)
      (<-double-big-endian))
    
    (define (read-byte-array)
      (let ((size <fx> (read-int)))
        (let ((data (make-s8vector size)))
          (loop (for i from 0 below size)
                (s8vector-set! data i (read-byte)))
          data)))
    
    (define (read-name)
      (let ((size <fx> (read-short)))
        (<-utf-8-string size)))
    
    (define (read-list)
      (let ((type <fx> (read-byte))
            (size <fx> (read-int)))
        (let ((content (loop (repeat size)
                             (collect (read-data type)))))
          (make-list-payload type content))))
    
    (define (read-compound)
      (let ((tag (read-tag)))
        (if (not tag)
            '()
          (cons tag (read-compound)))))
    
    (define (read-int-array)
      (let ((size <fx> (read-int)))
        (let ((data (make-vector size)))
          (loop (for i from 0 below size)
                (vector-set! data i (read-int)))
          data)))
    
    (read-tag)))


(class NBT-Writer extends Binary-Writer
  
  
  (method (write-tag tag)
    (define (write-tag tag)
      (let ((name (tag-name tag))
            (type (tag-type tag))
            (val (tag-value tag)))
        (->u8 type)
        (write-name name)
        (write-data type val)))
    
    (define (write-data type val)
      (ecase type
        ((TAG_End)        (write-end val))
        ((TAG_Byte)       (write-byte val))
        ((TAG_Short)      (write-short val))
        ((TAG_Int)        (write-int val))
        ((TAG_Long)       (write-long val))
        ((TAG_Float)      (write-float val))
        ((TAG_Double)     (write-double val))
        ((TAG_Byte_Array) (write-byte-array val))
        ((TAG_String)     (write-name val))
        ((TAG_List)       (write-list val))
        ((TAG_Compound)   (write-compound val))
        ((TAG_Int_Array)  (write-int-array val))
        (else (error "Unknown NBT tag: {s}" type))))
    
    (define (write-end)
      (->u8 TAG_End))
    
    (define (write-byte val)
      (->s8 val))
    
    (define (write-short val)
      (->s16-big-endian val))
    
    (define (write-int val)
      (->s32-big-endian val))
    
    (define (write-long val)
      (->s64-big-endian val))
    
    (define (write-float val)
      (->float-big-endian val))
    
    (define (write-double val)
      (->double-big-endian val))
    
    (define (write-byte-array val)
      (let ((size (s8vector-length val)))
        (write-int size)
        (loop (for i from 0 below size)
              (write-byte (s8vector-ref val i)))))
    
    (define (write-name val)
      (let ((port (open-u8vector)))
        (write-string val port)
        (let ((u8vec (get-output-u8vector port)))
          (close-port port)
          (let ((size (u8vector-length u8vec)))
            (write-short size)
            (->u8vector u8vec)))))
    
    (define (write-list val)
      (let ((type (list-payload-type val))
            (content (list-payload-content val)))
        (let ((size (length content)))
          (write-byte type)
          (write-int size)
          (loop (for elem in content)
                (write-data type elem)))))
    
    (define (write-compound val)
      (loop (for tag in val)
            (write-tag tag))
      (write-end))
    
    (define (write-int-array val)
      (let ((size (vector-length val)))
        (write-int size)
        (loop (for i from 0 below size)
              (write-int (vector-ref val i)))))
    
    (write-tag tag)))


;;;
;;;; Atlas
;;;


(definition (cache-atlas) <Atlas>
  (or (registered-atlas 'minecraft)
      (let ((atlas (create-minecraft-atlas)))
        (register-atlas 'minecraft atlas)
        atlas)))


(definition (cache-atlas-nearest) <Atlas>
  (or (registered-atlas 'minecraft-nearest)
      (let ((atlas (create-minecraft-atlas nearest?: #t)))
        (register-atlas 'minecraft-nearest atlas)
        atlas)))


(definition (create-minecraft-atlas (nearest?: nearest? #f)) <Atlas>
  (define (determine-texture-dir)
    (let ((world (current-world)))
      (let ((dir ;; quick hack to test
              (if (is-alias? 'Yownu-World)
                  {Directory Yownu-World "assets" "minecraft" "textures"}
                (new-directory~ (cast <Directory> (car (get-user-assets~ world))) "textures"))))
        (new-directory~ dir texture-dir))))
  
  (let ((world (current-world)))
    (let ((mipmap? (find-setting 'minecraft.generate-mipmap? 32)))
      (let ((effective-mipmap? (if (integer? mipmap?) (>= tile-resolution (cast <fx> mipmap?)) mipmap?)))
        (let ((min-filter (if (or nearest? (not effective-mipmap?))
                              GL_NEAREST
                            #f))
              (mag-filter (if (not effective-mipmap?)
                              GL_NEAREST
                            #f)))
          (let ((atlas (new Atlas min-filter: min-filter mag-filter: mag-filter mipmap?: effective-mipmap?)))
            (add-directory~ atlas (determine-texture-dir))
            (complete~ atlas)
            atlas))))))


;;;
;;;; Mesher
;;;


(class Minecraft-Mesher extends Mesher
  
  
  (method (add-lighting face)
    (define (blocklight lighting <u8vector>) <fl>
      (cast <fl> (u8vector-ref lighting 0)))
    
    (define (skylight lighting <u8vector>) <fl>
      (cast <fl> (u8vector-ref lighting 1)))
    
    (define (ambience lighting <u8vector>) <fl>
      (/ (cast <fl> (u8vector-ref lighting 2))
         4.))
    
    (iterate-lighting~ face
      (lambda (l1 l2 l3)
        (f32vector-set! lightmap k (blocklight l1))
        (f32vector-set! lightmap (+ k 1) (skylight l1))
        (f32vector-set! lightmap (+ k 2) (ambience l1))
        (f32vector-set! lightmap (+ k 3) (blocklight l2))
        (f32vector-set! lightmap (+ k 4) (skylight l2))
        (f32vector-set! lightmap (+ k 5) (ambience l2))
        (f32vector-set! lightmap (+ k 6) (blocklight l3))
        (f32vector-set! lightmap (+ k 7) (skylight l3))
        (f32vector-set! lightmap (+ k 8) (ambience l3))
        (increase! k 9)))))


;;;
;;;; Rendering
;;;


(class Minecraft-Rendering extends Object
  
  
  (slot material  <Material>               getter generate)
  (slot triangles <fx>       initialize 0  accessors generate)
  (slot quads     <fx>       initialize 0  accessors generate)
  (slot mesher    <Mesher+>  initialize #f accessors generate)
  
  
  (method override (initialize material)
    (set! material~self material))
  
  
  (method (reset)
    (set! triangles 0)
    (set! quads 0)
    (set! mesher #f))
  
  
  (method (setup)
    (when (or (/= triangles 0)
              (/= quads 0))
      (set! mesher (new Minecraft-Mesher triangles quads material: material)))))


(definition package opaque-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas)))
            (let ((rend (new Minecraft-Rendering (new Material name: 'opaque atlas: atlas texture: (get-texture~ atlas) renderer: (get-opaque-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package transparent-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas)))
            (let ((rend (new Minecraft-Rendering (new Material name: 'transparent atlas: atlas texture: (get-texture~ atlas) renderer: (get-transparent-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package coverage-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas)))
            (let ((rend (new Minecraft-Rendering (new Material name: 'coverage atlas: atlas texture: (get-texture~ atlas) renderer: (get-coverage-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package water-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas-nearest)))
            (let ((rend (new Minecraft-Rendering (new Material name: 'water atlas: atlas texture: (get-texture~ atlas) renderer: (get-water-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package wet-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas)))
            (let ((rend (new Minecraft-Rendering (new Material name: 'wet atlas: atlas texture: (get-texture~ atlas) renderer: (get-wet-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package multitexture-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas-nearest)))
            (let ((rend (new Minecraft-Rendering (new Material name: 'multitexture atlas: atlas texture: (get-texture~ atlas) renderer: (get-multitexture-renderer)))))
              (set! rendering rend)
              rend))))))


;;;
;;;; Block
;;;


(class Minecraft-Block-Model extends Object
  
  
  (slot name                getter generate)
  (slot id                  getter generate)
  (slot subid               getter generate)
  (slot texture             getter generate)
  (slot texture-coordinates accessors generate)
  (slot rendering           getter generate)
  (slot rendering-cache     getter generate)
  (slot opaque-cube?        getter generate)
  (slot water-cube?         getter generate)
  (slot generate            getter generate)
  
  
  (method override (initialize name id subid texture rendering opaque-cube? water-cube? generate)
    (set! name~self name)
    (set! id~self id)
    (set! subid~self subid)
    (set! texture~self texture)
    (set! texture-coordinates~self #f)
    (set! rendering~self (or rendering opaque-rendering))
    (set! rendering-cache~self #f)
    (set! opaque-cube?~self opaque-cube?)
    (set! water-cube?~self water-cube?)
    (set! generate~self generate))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method (cache-rendering)
    (or rendering-cache
        (let ((rend (rendering)))
          (set! rendering-cache rend)
          rend))))


(definition blocks <table>
  (make-table test: eq?))

(definition blockids <vector>
  (make-vector 256 #f))


(definition (register-minecraft-block name id (texture: texture #f) (rendering: rendering #f) (opaque-cube?: opaque-cube? #t) (water-cube?: water-cube? #f) (generate: generate #f))
  (let ((id <fx> (if (pair? id) (car id) id))
        (subid (if (pair? id) (cadr id) #f)))
    (when (not subid)
      (let ((block (new Minecraft-Block-Model name id subid texture rendering opaque-cube? water-cube? generate)))
        (table-set! blocks name block)
        (vector-set! blockids id block)))))


(definition public inline (blockid->block id <fx>) <Minecraft-Block-Model>
  (vector-ref blockids id))


(definition protected tile-resolution <fx>
  (find-setting 'minecraft.tile-resolution 32))

(definition protected tile-size <fl>
  (cast <fl> tile-resolution))

(definition protected tile-period <fx>
  16)

(definition protected texture-size <fl>
  (* tile-size (cast <fl> tile-period)))

(definition protected texture-dir
  (format "{a}x{a}" tile-resolution tile-resolution))

(definition protected texture-mipmap?
  #f)


(definition (block-texture-coordinates block <Minecraft-Block-Model>)
  (or (get-texture-coordinates~ block)
      (let ((texture (get-texture~ block)))
        (let ((coords (and texture (image-rect~ (cache-atlas) texture))))
          (set-texture-coordinates~ block coords)
          coords))))


(definition name-mutex
  (make-mutex 'name))

(definition name-coordinates <table>
  (make-table test: equal?))

(definition (get-name-coordinates name <string>) <f32vector>
  (mutex-lock! name-mutex)
  (prog1 (or (table-ref name-coordinates name #f)
             (let ((coords (image-rect~ (cache-atlas) name)))
               (table-set! name-coordinates name coords)
               coords))
    (mutex-unlock! name-mutex)))


;;;
;;;; Blocks
;;;


(definition air-id <fx>
  0)


(define-minecraft-block Air
  0
  opaque-cube?: #f)

(define-minecraft-block Stone
  1
  texture: "stone")

;; todo fix grass top
(define-minecraft-block Grass
  2
  texture: "grass_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((top (get-name-coordinates "wool_colored_green" @w "grass_top"))
                    (bottom (get-name-coordinates "dirt")))
                (add-opaque-cube i j k x y z uv uv bottom top uv uv lighting rendering add-face))))

(define-minecraft-block Dirt
  3
  texture: "dirt")

(define-minecraft-block Cobblestone
  4
  texture: "cobblestone")

(define-minecraft-block WoodenPlank
  5
  texture: "planks_spruce")

(definition Sapling-Textures <vector>
  #("sapling_oak"
    "sapling_spruce"
    "sapling_birch"
    "sapling_jungle"))

(define-minecraft-block Sapling
  6
  texture: "sapling_jungle"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((uv (get-name-coordinates (vector-ref Sapling-Textures (bitwise-and data-id #x3)))))
                (add-cross-faces x y z block-radius uv lighting rendering add-face))))

(define-minecraft-block RedwoodSapling
  (6 1))

(define-minecraft-block BirchSapling
  (6 2))

(define-minecraft-block Bedrock
  7
  texture: "enchanting_table_bottom")

(define-minecraft-block Water
  8
  water-cube?: #t
  rendering: water-rendering
  texture: "water")

(define-minecraft-block StationaryWater
  9
  water-cube?: #t
  rendering: water-rendering
  texture: "water")

(define-minecraft-block Lava
  10
  rendering: multitexture-rendering
  texture: "lava")

(define-minecraft-block StationaryLava
  11
  rendering: multitexture-rendering
  texture: "lava")

(define-minecraft-block Sand
  12
  texture: "sand")

(define-minecraft-block Gravel
  13
  texture: "gravel")

(define-minecraft-block GoldOre
  14
  texture: "gold_ore")

(define-minecraft-block IronOre
  15
  texture: "iron_ore")

(define-minecraft-block CoalOre
  16
  texture: "coal_ore")

(define-minecraft-block Wood
  17
  texture: "planks_jungle")

(define-minecraft-block Redwood
  (17 1))

(define-minecraft-block Birchwood
  (17 2))

(define-minecraft-block Leaves
  18
  texture: "leaves_birch_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-cube-faces i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block RedwoodLeaves
  (18 1))

(define-minecraft-block BirchwoodLeaves
  (18 2))

(define-minecraft-block Sponge
  19
  texture: "sponge")

(define-minecraft-block Glass
  20
  texture: "glass"
  rendering: coverage-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-cube-faces i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block LapisOre
  21
  texture: "lapis_ore")

(define-minecraft-block LapisBlock
  22
  texture: "lapis_block")

(define-minecraft-block Dispenser
  23
  texture: "dispenser_front_vertical")

(define-minecraft-block Sandstone
  24
  texture: "sandstone_top")

(define-minecraft-block NoteBlock
  25
  texture: "noteblock")

;; improve
(define-minecraft-block BedBlock
  26
  texture: "bed_feet_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-cube-faces i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block PoweredRail
  27
  texture: "rail_activator_powered"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-rail data-id i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block DetectorRail
  28
  texture: "rail_detector"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-rail data-id i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block StickyPiston
  29
  texture: "piston_side")

(define-minecraft-block Web
  30
  texture: "web"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block TallGrass
  31
  texture: "wheat_stage_4" ; "tallgrass" is not nice in sphax textures
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block DeadBush
  32
  texture: "deadbush"
  rendering: transparent-rendering
  opaque-cube?: #f)

;; improve
(define-minecraft-block Piston
  33
  texture: "piston_side")

;; improve
(define-minecraft-block PistonHead
  34
  texture: "piston_side")

(definition Wool-Textures <vector>
  #("wool_colored_white"
    "wool_colored_orange"
    "wool_colored_magenta"
    "wool_colored_light_blue"
    "wool_colored_yellow"
    "wool_colored_lime"
    "wool_colored_pink"
    "wool_colored_gray"
    "wool_colored_silver"
    "wool_colored_cyan"
    "wool_colored_purple"
    "wool_colored_blue"
    "wool_colored_brown"
    "wool_colored_green"
    "wool_colored_red"
    "wool_colored_black"))

(define-minecraft-block Wool
  35
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((uv (get-name-coordinates (vector-ref Wool-Textures data-id))))
                (add-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering add-face))))

(define-minecraft-block Dandelion
  37
  texture: "flower_dandelion"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block Rose
  38
  texture: "flower_rose"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block BrownMushroom
  39
  texture: "mushroom_brown"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block RedMushroom
  40
  texture: "mushroom_red"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block GoldBlock
  41
  texture: "gold_block")

(define-minecraft-block IronBlock
  42
  texture: "iron_block")

(define-minecraft-block DoubleStoneSlab
  43
  texture: "stone_slab_top")

(define-minecraft-block DoubleSandstoneSlab
  (43 1))

(define-minecraft-block DoubleWoodenSlab
  (43 2))

(define-minecraft-block DoubleCobblestoneSlab
  (43 3))

(define-minecraft-block DoubleBrickSlab
  (43 4))

(define-minecraft-block DoubleStoneBrickSlab
  (43 5))

(define-minecraft-block StoneSlab
  44
  texture: "stone_slab_top"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-slab i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block SandstoneSlab
  (44 1))

(define-minecraft-block WoodenSlab
  (44 2))

(define-minecraft-block CobblestoneSlab
  (44 3))

(define-minecraft-block BrickSlab
  (44 4))

(define-minecraft-block StoneBrickSlab
  (44 5))

(define-minecraft-block Brick
  45
  texture: "brick")

(define-minecraft-block TNT
  46
  texture: "tnt_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((top (get-name-coordinates "tnt_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering add-face))))

(define-minecraft-block Bookshelf
  47
  texture: "bookshelf"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((top (get-name-coordinates "planks_jungle")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering add-face))))

(define-minecraft-block MossyCobblestone
  48
  texture: "cobblestone_mossy")

(define-minecraft-block Obsidian
  49
  texture: "obsidian")

(define-minecraft-block Torch
  50
  texture: "torch_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-transparent data-id 1 2 3 4 i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block Fire
  51
  texture: "furnace_front_on")

(define-minecraft-block MonsterSpawner
  52
  texture: "mob_spawner"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-cube-faces i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block WoodenStairs
  53
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-stairs i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block Chest
  54
  texture: "log_birch_top")

(define-minecraft-block RedstoneWire
  55
  texture: "redstone_dust_line"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-bottom i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block DiamondOre
  56
  texture: "diamond_ore")

(define-minecraft-block DiamondBlock
  57
  texture: "diamond_block")

(define-minecraft-block Workbench
  58
  texture: "log_oak")

(define-minecraft-block WheatCrops
  59
  texture: "wheat_stage_7"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block Soil
  60
  texture: "dirt")

(define-minecraft-block Furnace
  61
  texture: "furnace_side")

(define-minecraft-block BurningFurnace
  62
  texture: "furnace_front_on")

;; improve
(define-minecraft-block SignPost
  63
  texture: "trip_wire_source"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-right i j k x y z block-radius uv lighting rendering add-face)))

;; quick hack remove all doors
(define-minecraft-block WoodenDoorBlock
  64
  texture: "door_wood_upper"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              #f))

(define-minecraft-block Ladder
  65
  texture: "ladder"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-transparent data-id 5 4 3 2 i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block Rails
  66
  texture: "rail_normal"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-rail data-id i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block CobblestoneStairs
  67
  texture: "cobblestone"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top y)
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (right-face  i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (bottom-face i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (top-face    i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (back-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (front-face  i j k left right bottom top back front uv lighting rendering) rendering #t))))

;; improve
(define-minecraft-block WallSign
  68
  texture: "trip_wire_source"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-right i j k x y z block-radius uv lighting rendering add-face)))

;; improve
(define-minecraft-block Lever
  69
  texture: "lever"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-transparent data-id 1 2 3 4 i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block StonePressurePlate
  70
  texture: "stone_slab_top"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top y)
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (right-face  i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (bottom-face i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (top-face    i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (back-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (front-face  i j k left right bottom top back front uv lighting rendering) rendering #t))))

;; quick hack remove all doors
(define-minecraft-block IronDoorBlock
  71
  texture: "door_iron_upper"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              #f))

(define-minecraft-block WoodenPressurePlate
  72
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top y)
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (right-face  i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (bottom-face i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (top-face    i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (back-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (front-face  i j k left right bottom top back front uv lighting rendering) rendering #t))))

(define-minecraft-block RedstoneOre
  73
  texture: "redstone_ore")

(define-minecraft-block GlowingRedstoneOre
  74
  texture: "repeater_on")

(define-minecraft-block RedstoneTorchOff
  75
  texture: "redstone_torch_off"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-transparent data-id 1 2 3 4 i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block RedstoneTorchOn
  76
  texture: "redstone_torch_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-transparent data-id 1 2 3 4 i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block StoneButton
  77
  texture: "endframe_side")

(define-minecraft-block Snow
  78
  texture: "snow"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) .625))
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (right-face  i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (bottom-face i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (top-face    i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (back-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
                (add-face (front-face  i j k left right bottom top back front uv lighting rendering) rendering #t))))

(define-minecraft-block Ice
  79
  texture: "ice")

(define-minecraft-block SnowBlock
  80
  texture: "snow")

;; todo other faces
(define-minecraft-block Cactus
  81
  texture: "cactus_side")

(define-minecraft-block Clay
  82
  texture: "clay")

(define-minecraft-block SugarCane
  83
  texture: "reeds"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block Jukebox
  84
  texture: "jukebox_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((top (get-name-coordinates "jukebox_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering add-face))))

;; improve
(define-minecraft-block Fence
  85
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-transparent data-id 1 2 3 4 i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block Pumpkin
  86
  texture: "pumpkin_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((top (get-name-coordinates "pumpkin_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering add-face))))

(define-minecraft-block Netherrack
  87
  rendering: water-rendering
  texture: "netherrack")

(define-minecraft-block SoulSand
  88
  rendering: water-rendering
  texture: "soul_sand")

(define-minecraft-block Glowstone
  89
  rendering: multitexture-rendering
  texture: "glowstone")

;; improve
(define-minecraft-block Portal
  90
  rendering: multitexture-rendering
  texture: "portal")

(define-minecraft-block Jack-O-Lantern
  91
  texture: "pumpkin_top")

;; todo other faces
(define-minecraft-block CakeBlock
  92
  texture: "cake_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-cube-faces i j k x y z block-radius uv lighting rendering add-face)))

;; improve
(define-minecraft-block RedstoneRepeaterBlockOff
  93
  texture: "repeater_off")

;; improve
(define-minecraft-block RedstoneRepeaterBlockOn
  94
  texture: "repeater_on")

;; improve
(define-minecraft-block LockedChest
  95
  texture: "piston_top_normal")

(define-minecraft-block Trapdoor
  96
  texture: "trapdoor"
  rendering: transparent-rendering
  opaque-cube?: #f)

;; improve with data
(define-minecraft-block StoneSilverfish
  97
  texture: "stone")

(define-minecraft-block CobblestoneSilverfish
  (97 1))

(define-minecraft-block StoneBrickSilverfish
  (97 2))

(define-minecraft-block StoneBrick
  98
  texture: "stonebrick_cracked")

(define-minecraft-block MossyStoneBrick
  (98 1))

(define-minecraft-block CrackedStoneBrick
  (98 2))

(define-minecraft-block BrownMushroomCap
  99
  texture: "mushroom_block_skin_brown")

(define-minecraft-block RedMushroomCap
  100
  texture: "mushroom_block_skin_red")

(define-minecraft-block IronBars
  101
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-cube-faces i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block GlassPane
  102
  texture: "glass"
  rendering: coverage-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-cube-faces i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block MelonBlock
  103
  texture: "melon_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((top (get-name-coordinates "melon_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering add-face))))

(define-minecraft-block PumpkinStem
  104
  texture: "pumpkin_stem_disconnected_ochre"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-cross-faces x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block MelonStem
  105
  texture: "melon_stem_disconnected_ochre"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-cross-faces x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block Vines
  106
  texture: "vine_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-transparent data-id 2 8 4 1 i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block FenceGate
  107
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block BrickStairs
  108
  texture: "brick"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-stairs i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block StoneBrickStairs
  109
  texture: "stonebrick"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-stairs i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block Mycelium
  110
  texture: "mycelium_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((top (get-name-coordinates "mycelium_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering add-face))))

(define-minecraft-block LilyPad
  111
  texture: "waterlily_green"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block NetherBrick
  112
  texture: "nether_brick")

(define-minecraft-block NetherBrickFence
  113
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block NetherBrickStairs
  114
  texture: "nether_brick"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-stairs i j k x y z block-radius uv lighting rendering add-face)))

;; improve
(define-minecraft-block NetherWart
  115
  texture: "nether_wart_stage_1")

(define-minecraft-block EnchantmentTable
  116
  texture: "enchanting_table_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((top (get-name-coordinates "enchanting_table_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering add-face))))

(define-minecraft-block BrewingStand
  117
  texture: "brewing_stand"
  rendering: transparent-rendering
  opaque-cube?: #f)

(define-minecraft-block Cauldron
  118
  texture: "cauldron_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (let ((top (get-name-coordinates "cauldron_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering add-face))))

;; improve
(define-minecraft-block EndPortal
  119
  texture: "stone_slab_top"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-slab i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block EndPortalFrame
  120
  texture: "endframe_side")

(define-minecraft-block EndStone
  121
  texture: "end_stone")

;; improve
(define-minecraft-block DragonEgg
  122
  texture: "dragon_egg")

(define-minecraft-block RedstoneLampOff
  123
  texture: "redstone_lamp_off")

(define-minecraft-block RedstoneLampOn
  124
  texture: "redstone_lamp_on")

;; improve
(define-minecraft-block DoubleWoodenSlab
  125
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-slab i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block WoodenSlab
  126
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-slab i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block CocoaPlant
  127
  texture: "cocoa_stage_2")

(define-minecraft-block SandstoneStairs
  128
  texture: "sandstone_normal"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-stairs i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block EmeraldOre
  129
  texture: "emerald_ore")

;; improve
(define-minecraft-block EnderChest
  130
  texture: "farmland_wet")

;; improve
(define-minecraft-block TripwireHook
  131
  texture: "farmland_wet")

;; improve
(define-minecraft-block Tripwire
  132
  texture: "farmland_wet")

(define-minecraft-block EmeraldBlock
  133
  texture: "emerald_block")

(define-minecraft-block SpruceWoodStairs
  134
  texture: "planks_spruce"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-stairs i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block BirchWoodStairs
  135
  texture: "planks_birch"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-stairs i j k x y z block-radius uv lighting rendering add-face)))

(define-minecraft-block JungleWoodStairs
  136
  texture: "planks_jungle"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube)
              (add-stairs i j k x y z block-radius uv lighting rendering add-face)))

;; improve
(define-minecraft-block CommandBlock
  137
  texture: "farmland_wet")

;; improve
(define-minecraft-block BeaconBlock
  138
  texture: "beacon")

;; improve
(define-minecraft-block CobblestoneWall
  139
  texture: "cobblestone")

;; improve
(define-minecraft-block FlowerPot
  140
  texture: "farmland_wet")

;; improve
(define-minecraft-block Carrots
  141
  texture: "farmland_wet"
  rendering: transparent-rendering
  opaque-cube?: #f)

;; improve
(define-minecraft-block Potatoes
  142
  texture: "farmland_wet"
  rendering: transparent-rendering
  opaque-cube?: #f)

;; improve
(define-minecraft-block WoodenButton
  143
  texture: "farmland_wet")


(let ((unknown-texture "gold_ore"))
  (loop (for id from 0 below 256)
        (unless (vector-ref blockids id)
          (register-minecraft-block 'Unknown id
            texture: unknown-texture))))


;;;
;;;; Face
;;;


(class Minecraft-Face extends Face
  
  
  (slot l1 accessors generate)
  (slot l2 accessors generate)
  (slot l3 accessors generate)
  (slot l4 accessors generate)
  
  
  (method override (initialize material texture-coordinates texture-depth polygon l1 l2 l3 l4)
    (nextmethod material texture-coordinates texture-depth polygon)
    (set! l1~self l1)
    (set! l2~self l2)
    (set! l3~self l3)
    (set! l4~self l4))
  
  
  (method (iterate-lighting proc)
    (proc l1 l2 l3)
    (proc l3 l4 l1)))


(definition public (make-minecraft-face rendering texture-coordinates texture-depth polygon l1 l2 l3 l4)
  (new Minecraft-Face (get-material~ rendering) texture-coordinates texture-depth polygon l1 l2 l3 l4))


;;;
;;;; Section
;;;


(class Minecraft-Section extends Object
  
  
  (slot blocks     getter generate)
  (slot data       getter generate)
  (slot blocklight getter generate)
  (slot skylight   getter generate)
  
  
  (method override (initialize blocks data blocklight skylight)
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)
    (set! skylight~self skylight)))


;;;
;;;; Chunk
;;;


(class Minecraft-Chunk extends Object
  
  
  (slot heightmap             <vector+> getter generate)
  (slot heightmap-revision              accessors generate)
  (slot heightmap-uptodate?             accessors generate)
  (slot heightmap-generating?           accessors generate)
  (slot entities                        getter generate)
  (slot sections              <table+>  getter generate)
  
  
  (method override (initialize heightmap entities sections)
    (set! heightmap~self heightmap)
    (set! heightmap-revision~self 0)
    (set! heightmap-uptodate?~self #f)
    (set! heightmap-generating?~self #f)
    (set! entities~self entities)
    (set! sections~self sections)))


;;;
;;;; Region
;;;


(class Minecraft-Region extends Object
  
  
  (slot x            <fx>                                            getter generate)
  (slot z            <fx>                                            getter generate)
  (slot port         <port>                                          getter generate)
  (slot header       <u8vector>                                      getter generate)
  (slot chunks-mutex <object>   initialize (make-mutex 'chunks)      getter generate)
  (slot chunks       <table>    initialize (make-table test: equal?) getter generate)
  
  
  (method override (initialize x z port)
    (set! x~self x)
    (set! z~self z)
    (set! port~self port)
    (set! header (read-header)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" x z))))
  
  
  (method override (destroy)
    (close-port port)
    (nextmethod))
  
  
  (method (read-header)
    (let ((size (* 8 1024)))
      (let ((content (make-u8vector size)))
        (read-subu8vector content 0 size port)
        content)))
  
  
  (method (with-chunks-mutex thunk)
    (mutex-lock! chunks-mutex)
    (prog1 (thunk)
      (mutex-unlock! chunks-mutex)))
  
  
  (method (get-chunk sector-x <fx> sector-z <fx>) <Minecraft-Chunk+>
    (with-chunks-mutex
      (lambda ()
        (let ((chunk-index (chunk-index sector-x sector-z)))
          (let ((value (table-ref chunks chunk-index #t)))
            (if (neq? value #t)
                value
              (let ((chunk (read-chunk chunk-index)))
                (table-set! chunks chunk-index chunk)
                chunk)))))))
  
  
  (method (chunk-index sector-x <fx> sector-z <fx>) <pair>
    ;; looks like we don't need to adjust for negative values like stated on the wiki
    (cons (modulo sector-x 32)
          (modulo sector-z 32)))
  
  
  (method (read-chunk chunk-index <pair>) <Minecraft-Chunk+>
    (let ((zone <Minecraft-Zone> (current-zone))
          (chunk-x <fx> (car chunk-index))
          (chunk-z <fx> (cdr chunk-index)))
      (let ((offset (* 4 (+ chunk-x (* chunk-z 32)))))
        (assert (<= offset 4092))
        (let ((b1 (u8vector-ref header offset))
              (b2 (u8vector-ref header (+ offset 1)))
              (b3 (u8vector-ref header (+ offset 2)))
              (b4 (u8vector-ref header (+ offset 3))))
          (if (and (= b1 0)
                   (= b2 0)
                   (= b3 0)
                   (= b4 0))
              #f
            (site (read-chunk on?: #t parent: generate)
              (let ((offset (* (+ (arithmetic-shift-left b1 16)
                                  (arithmetic-shift-left b2 8)
                                  b3)
                               (* 4 1024))))
                (input-port-byte-position port offset)
                (let ((chunk-header (make-u8vector 5)))
                  (read-subu8vector chunk-header 0 5 port)
                  (let ((size <fx> (scan-u32-big-endian chunk-header 0))
                        (compression-type (u8vector-ref chunk-header 4)))
                    ;; skip two bytes for deflate
                    (read-u8 port)
                    (read-u8 port)
                    (let ((chunk-raw (make-u8vector size)))
                      (read-subu8vector chunk-raw 0 size port)
                      (let ((chunk-data (inflate-u8vector chunk-raw)))
                        (with ((s (new NBT-Stream (cons chunk-data 0))))
                          (let ((compound (tag-assoc "Level" (tag-value (read-tag~ s)))))
                            (let ((heightmap (tag-assoc "HeightMap" compound))
                                  (entities (list-payload-content (tag-assoc "Entities" compound)))
                                  (sections (list-payload-content (tag-assoc "Sections" compound))))
                              (let ((sections-table (and sections (make-table test: eq?))))
                                (when sections-table
                                  (let ((truncate-y (get-truncate-y~ zone)))
                                    (for-each (lambda (section)
                                                (let ((yPos (- (cast <fx> (tag-assoc "Y" section)) 4)) ;; lower everything by 64
                                                      (blocks (tag-assoc "Blocks" section))
                                                      (data (tag-assoc "Data" section))
                                                      (blocklight (tag-assoc "BlockLight" section))
                                                      (skylight (tag-assoc "SkyLight" section)))
                                                  (when (or (not truncate-y)
                                                            (>= yPos (cast <fx> truncate-y)))
                                                    (table-set! sections-table yPos (new Minecraft-Section blocks data blocklight skylight)))))
                                              sections)))
                                (new Minecraft-Chunk heightmap entities sections-table))))))))))))))))
  
  
  (method (get-section sector-x <fx> sector-y <fx> sector-z <fx>) <Minecraft-Section+>
    (let ((chunk (get-chunk sector-x sector-z)))
      (when chunk
        (let ((sections (get-sections~ chunk)))
          (when sections
            (table-ref sections sector-y #f))))))
  
  
  (method (get-blocks sector-x <fx> sector-y <fx> sector-z <fx>) <s8vector+>
    (let ((section (get-section sector-x sector-y sector-z)))
      (when section
        (get-blocks~ section)))))


;;;
;;;; Level
;;;


(definition public (import-minecraft-level file)
  (with ((s (new NBT-Stream file)))
    (read-tag~ s)))


;;;
;;;; Sector
;;;


(class Minecraft-Sector extends Sector)


;;;
;;;; Zone
;;;


(definition heightmap?
  (find-setting 'minecraft.heightmap? #f))

(definition public (get-heightmap?)
  heightmap?)

(definition public (set-heightmap? flag)
  (set! heightmap? flag))


(class Minecraft-Zone extends Zone
  
  
  (property level-dir   <Directory> initialize #f   accessors generate)
  (property truncate-y  <fx+>       initialize #f   accessors generate)
  (property day-cycle   <object>    initialize 'day accessors generate)
  (property player-glow <fl>        initialize -1.  accessors generate)
  
  
  (slot regions-dir   <Directory> initialize #f                        getter explicit)
  (slot regions-mutex <object>    initialize (make-mutex 'regions)     getter generate)
  (slot regions       <table>     initialize (make-table test: equal?) getter generate)
  
  
  (form
    (<install> floor-level: #f start-grid?: #f start-axes?: #f jump-impulsion: .3))
  
  
  ;; quicky for tests
  (method override (minecraft?)
    #t)
  
  
  (method override (needs-pumps?)
    #t)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! ambient-color (dye .1 .05 0. 1.)))


  (proclaim (not warn optimizations))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set! day-cycle (world-setting 'minecraft.day-cycle 'night 'default))
    (when (not sun-cycle?)
      (set! daytime (case day-cycle
                      ((day) 12000.)
                      (else 0.))))
    (let ((world (current-world)))
      (update-actions~ (get-application)
        (lambda ()
          (set-visible?~ (child~ (get-bindings) '(world-minecraft toggle-player-glow)) #t)))
      (set-visible?~ (child~ (get-interface~ world) 'minecraft) #t)))
  
  
  (method override (destroy)
    (let ((world (current-world)))
      (update-actions~ (get-application)
        (lambda ()
          (set-visible?~ (child~ (get-bindings) '(world-minecraft toggle-player-glow)) #f)))
      (set-visible?~ (child~ (get-interface~ world) 'minecraft) #f))
    (nextmethod))


  (proclaim (warn optimizations))
  
  
  (method override (effective-lights)
    '())
  
  
  (method override (effective-player-glow)
    player-glow)
  
  
  (method override (sun-update-lighting effective coord)
    )
  
  
  (method override (sun-update)
    (let ((day 24000.)
          (angle (flmodulo sun-angle PI*2)))
      (set! daytime (flmodulo (+ (/ (* angle day) PI*2) 6000.) day))))
  
  
  (method override (create-atlas)
    (cache-atlas))
  
  
  (method override (create-atlas-nearest)
    (cache-atlas-nearest))
  
  
  (method override (create-opaque-material atlas)
    (get-material~ (opaque-rendering)))
  
  
  (method override (create-transparent-material atlas)
    (get-material~ (transparent-rendering)))
  
  
  (method override (sample-program-image program)
    (case program
      ((opaque) "stone")
      ((transparent) "flower_rose")
      (else "wool_colored_light_blue")))
  
  
  (method override (sector-class)
    Minecraft-Sector)
  
  
  (method override (zone-editable?)
    #f)
  
  
  (method (on-toggle-player-glow evt)
    (if (= player-glow -1.)
        (set! player-glow 300.)
      (set! player-glow -1.)))
  
  
  (method (with-regions-mutex thunk)
    (mutex-lock! regions-mutex)
    (prog1 (thunk)
      (mutex-unlock! regions-mutex)))
  
  
  (method (close-regions)
    (with-regions-mutex
      (lambda ()
        (iterate-table regions
          (lambda (index region <Minecraft-Region>)
            (when region
              (close~ region))))
        (empty-table regions))))
  
  
  (method (iterate-regions proc)
    (iterate-directory~ (get-regions-dir)
      (lambda (file <File>)
        (when (extension=? (get-extension~ file) "mca")
          (let ((base <string> (get-base~ file)))
            (bind (x z) (split (substring base 2 (string-length base)) ".")
              (let ((x (string->number x))
                    (z (string->number z)))
                (proc file x z))))))))
  
  
  (method (compute-boundaries)
    (let ((inf 1000000))
      (let ((left inf)
            (right (- inf))
            (back inf)
            (front (- inf)))
        (iterate-regions
          (lambda (file x <fx> z <fx>)
            (when (< x left)
              (set! left x))
            (when (> x right)
              (set! right x))
            (when (< z back)
              (set! back z))
            (when (> z front)
              (set! front z))))
        (values left right back front))))
  
  
  (method (get-regions-dir) <Directory>
    (or regions-dir (let ((dir (new-directory~ level-dir "region")))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method (get-region region-index <pair>) <Minecraft-Region+>
    (define (region-name)
      (bind (region-x . region-z) region-index
        (format "r.{a}.{a}.mca" region-x region-z)))
    
    (with-regions-mutex
      (lambda ()
        (let ((value (table-ref regions region-index #t)))
          (if (neq? value #t)
              value
            (let ((dir (get-regions-dir))
                  (name (region-name)))
              (let ((file (new-file~ dir name)))
                (let ((region (if (exists?~ file)
                                  (bind (region-x . region-z) region-index
                                    (let ((port (open-input-file (path-settings file))))
                                      (new Minecraft-Region region-x region-z port)))
                                #f)))
                  (table-set! regions region-index region)
                  region))))))))
  
  
  (method (sector-region sector-x <fx> sector-y <fx> sector-z <fx>) <Minecraft-Region+>
    (define (region-index)
      (cons (fxfloor/ sector-x region-size)
            (fxfloor/ sector-z region-size)))
    
    (get-region (region-index)))
  
  
  (method (sector-blocks sector-x <fx> sector-y <fx> sector-z <fx>) <s8vector+>
    (let ((region (sector-region sector-x sector-y sector-z)))
      (when region
        (get-blocks~ region sector-x sector-y sector-z))))
  
  
  (method override (generate-content?)
    #t)
  
  
  (definition generate-mutex
    (make-mutex 'generate))
  
  
  (add-debugger-release 'generate-mutex
    (lambda ()
      (when (eq? (mutex-owner generate-mutex) (current-thread))
        (mutex-unlock! generate-mutex))))
  
  
  (method override (generate-content sector <Sector>)
    (mutex-lock! generate-mutex)
    (generate-sector sector 'render)
    (mutex-unlock! generate-mutex))
  
  
  (method override (generate-physical sector <Sector>)
    (mutex-lock! generate-mutex)
    (generate-sector sector 'physical)
    (mutex-unlock! generate-mutex))
  
  
  (definition block-cache <u16vector>
    (make-u16vector (* 18 18 18 4)))
  
  (definition (initialize-block-cache cache-uninitialized <fx>) <u16vector>
    (loop (for i from 0 below (* 18 18 18 4))
          (u16vector-set! block-cache i cache-uninitialized))
    block-cache)
  
  
  (method (generate-sector sector <Sector> what)
    (define (conclude-rendering rendering)
      (let ((mesher (get-mesher~ rendering)))
        (when mesher
          (prog1 (cons (get-material~ rendering) (get-info~ mesher))
            (reset~ rendering)))))
    
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (decrease-sectors-generating sector))
    
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (checkpoint)
    (checkpoint 1)
    (when (eq? self (current-zone))
      (if (get-heightmap?)
          (generate-sector-heightmap sector what)
      (let ((sector-index (get-index~ sector)))
        (let ((sector-x <fx> (vector-ref sector-index 0))
              (sector-y <fx> (vector-ref sector-index 1))
              (sector-z <fx> (vector-ref sector-index 2)))
          (let ((region (sector-region sector-x sector-y sector-z)))
            (if (not region)
                (when (eq? what 'render)
                  (generate-done))
              (let ((region-x (get-x~ region))
                    (region-z (get-z~ region))
                    (section (get-section~ region sector-x sector-y sector-z))
                    (chunk-index (chunk-index~ region sector-x sector-z))
                    (cache-uninitialized 65535))
                (assert (= region-x (fxfloor/ sector-x region-size)))
                (assert (= region-z (fxfloor/ sector-z region-size)))
                (if (not section)
                    (when (eq? what 'render)
                      (generate-done))
                  (site (content on?: #t parent: generate)
                  (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                        (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                        (section-y (* sector-y 16))
                        (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                        (sections <vector> (make-vector 27 #t))
                        (cache <u16vector> (initialize-block-cache cache-uninitialized))
                        (block-radius .5)
                        (opaque-rendering <Minecraft-Rendering> (opaque-rendering))
                        (transparent-rendering <Minecraft-Rendering> (transparent-rendering))
                        (coverage-rendering <Minecraft-Rendering> (coverage-rendering))
                        (water-rendering <Minecraft-Rendering> (water-rendering))
                        (wet-rendering <Minecraft-Rendering> (wet-rendering))
                        (multitexture-rendering <Minecraft-Rendering> (multitexture-rendering))
                        (areas (and (eq? what 'physical) (make-table test: eq?))))
                    (define (section-ref a <fx> b <fx> c <fx>) <Minecraft-Section+>
                      (if (and (= a 0)
                               (= b 0)
                               (= c 0))
                          section
                        (let ((index (section-index a b c)))
                          (let ((section (vector-ref sections index)))
                            (if (neq? section #t)
                                section
                              (let ((x (+ sector-x a))
                                    (y (+ sector-y b))
                                    (z (+ sector-z c)))
                                (let ((region (sector-region x y z)))
                                  (let ((section (and region (get-section~ (cast <Minecraft-Region> region) x y z))))
                                    (vector-set! sections index section)
                                    section))))))))
                    
                    (define (section-index a <fx> b <fx> c <fx>) <fx>
                      (+ (* (+ b 1) 9) (* (+ c 1) 3) (+ a 1)))
                    
                    (define (cache-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* (+ j 1) 324) (* (+ k 1) 18) (+ i 1)) 4))
                    
                    (define (blocks-get section <Minecraft-Section>) <s8vector>
                      (get-blocks~ section))
                    
                    (define (data-get section <Minecraft-Section>) <s8vector>
                      (get-data~ section))
                    
                    (define (blocklight-get section <Minecraft-Section>) <s8vector>
                      (get-blocklight~ section))
                    
                    (define (skylight-get section <Minecraft-Section>) <s8vector>
                      (get-skylight~ section))
                    
                    (define (normalize-block-id id <fx>) <fx>
                      (if (>= id 0)
                          id
                        (+ 256 id)))
                    
                    (define (block-ref i <fx> j <fx> k <fx>) <fx>
                      (normalize-block-id (field-ref i j k blocks-get s8vector-ref 0 1)))
                    
                    (define (data-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k data-get s4vector-ref 0 0))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (cache-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            ;; need to use data information here
                            (let ((value (block-ref i j k)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (blocklight-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k blocklight-get s4vector-ref 0 0))
                    
                    (define (skylight-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k skylight-get s4vector-ref 15 15))
                    
                    (define (light-ref! i <fx> j <fx> k <fx> lighting <u8vector>) <void>
                      (let ((index (cache-index i j k)))
                        (let ((value (u16vector-ref cache (+ index 1))))
                          (if (/= value cache-uninitialized)
                              (begin
                                (u8vector-set! lighting 0 (+ (u8vector-ref lighting 0) value))
                                (u8vector-set! lighting 1 (+ (u8vector-ref lighting 1) (u16vector-ref cache (+ index 2))))
                                (u8vector-set! lighting 2 (+ (u8vector-ref lighting 2) (u16vector-ref cache (+ index 3)))))
                            (let ((blocklight (blocklight-ref i j k))
                                  (skylight (skylight-ref i j k))
                                  (ambience (if (= (effective-block-ref i j k) 0) 1 0)))
                              (u16vector-set! cache (+ index 1) blocklight)
                              (u16vector-set! cache (+ index 2) skylight)
                              (u16vector-set! cache (+ index 3) ambience)
                              (u8vector-set! lighting 0 (+ (u8vector-ref lighting 0) blocklight))
                              (u8vector-set! lighting 1 (+ (u8vector-ref lighting 1) skylight))
                              (u8vector-set! lighting 2 (+ (u8vector-ref lighting 2) ambience)))))))
                    
                    (define (s4vector-ref field <s8vector> index <fx>) <fx>
                      (let ((byte (s8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (index i j k)))))))
                          
                          (cond ((< k 0) (bind-k -1 15))
                                ((> k 15) (bind-k 1 0))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j -1 15))
                              ((> j 15) (bind-j 1 0))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i -1 15))
                            ((> i 15) (bind-i 1 0))
                            (else (bind-i 0 i))))
                    
                    (define (index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (count-polygons face <Face> rendering <Minecraft-Rendering> physical? <bool>)
                      (set-quads~ rendering (+ (get-quads~ rendering) 1)))
                    
                    (define (add-face face <Face> rendering <Minecraft-Rendering> physical? <bool>)
                      (let ((mesher (get-mesher~ rendering)))
                        (add-face~ mesher face)
                        (add-lighting~ mesher face))
                      (when (and physical? (eq? what 'physical))
                        (let ((center (get-center~ (get-polygon~ face))))
                          (let ((area (index-area (position-area-index center) #f)))
                            (table-add areas area (get-polygon~ face))))))
                    
                    (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering add-face)
                      (let ((rendering (effective-rendering (effective-block-ref (- i 1) j k) rendering))) (when rendering (add-face (left-side   i j k x y z block-radius left-uv lighting rendering) rendering #t)))
                      (let ((rendering (effective-rendering (effective-block-ref (+ i 1) j k) rendering))) (when rendering (add-face (right-side  i j k x y z block-radius right-uv lighting rendering) rendering #t)))
                      (let ((rendering (effective-rendering (effective-block-ref i (- j 1) k) rendering))) (when rendering (add-face (bottom-side i j k x y z block-radius bottom-uv lighting rendering) rendering #t)))
                      (let ((rendering (effective-rendering (effective-block-ref i (+ j 1) k) rendering))) (when rendering (add-face (top-side    i j k x y z block-radius top-uv lighting rendering) rendering #t)))
                      (let ((rendering (effective-rendering (effective-block-ref i j (- k 1)) rendering))) (when rendering (add-face (back-side   i j k x y z block-radius back-uv lighting rendering) rendering #t)))
                      (let ((rendering (effective-rendering (effective-block-ref i j (+ k 1)) rendering))) (when rendering (add-face (front-side  i j k x y z block-radius front-uv lighting rendering) rendering #t))))
                    
                    (define (effective-rendering block-id <fx> rendering <Minecraft-Rendering>)
                      (let ((block (blockid->block block-id)))
                        (cond ((get-water-cube?~ block)
                               wet-rendering)
                              ((get-opaque-cube?~ block)
                               #f)
                              (else
                               rendering))))
                    
                    (define (add-water-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering add-face)
                      (unless (opaque? (effective-block-ref (- i 1) j k)) (add-face (left-side   i j k x y z block-radius left-uv lighting rendering) rendering #t))
                      (unless (opaque? (effective-block-ref (+ i 1) j k)) (add-face (right-side  i j k x y z block-radius right-uv lighting rendering) rendering #t))
                      (unless (opaque? (effective-block-ref i (- j 1) k)) (add-face (bottom-side i j k x y z block-radius bottom-uv lighting rendering) rendering #t))
                      (unless (opaque? (effective-block-ref i (+ j 1) k)) (add-face (top-side    i j k x y z block-radius top-uv lighting rendering) rendering #t))
                      (unless (opaque? (effective-block-ref i j (- k 1))) (add-face (back-side   i j k x y z block-radius back-uv lighting rendering) rendering #t))
                      (unless (opaque? (effective-block-ref i j (+ k 1))) (add-face (front-side  i j k x y z block-radius front-uv lighting rendering) rendering #t)))
                    
                    (define (opaque? block-id <fx>)
                      (get-opaque-cube?~ (blockid->block block-id)))
                    
                    (define (compute-lighting i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                      (let ((lighting (make-u8vector 3)))
                        (light-ref! (+ i ax) (+ j ay) (+ k az) lighting)
                        (light-ref! (+ i bx) (+ j by) (+ k bz) lighting)
                        (light-ref! (+ i cx) (+ j cy) (+ k cz) lighting)
                        (light-ref! (+ i dx) (+ j dy) (+ k dz) lighting)
                        lighting))
                    
                    (define (iterate-blocks add-face)
                      (loop (for j from 0 below 16)
                          (loop (for k from 0 below 16)
                                (loop (for i from 0 below 16)
                                      (let ((block-id <fx> (effective-block-ref i j k)))
                                        (when (/= block-id air-id)
                                          (let ((x (+ section-x i))
                                                (y (+ section-y j))
                                                (z (+ section-z k))
                                                (block (blockid->block block-id))
                                                (data-id (data-ref i j k)))
                                            (let ((uv (block-texture-coordinates block))
                                                  (x (fl& (+ block-radius (cast <fl> x))))
                                                  (y (fl& (+ block-radius (cast <fl> y))))
                                                  (z (fl& (+ block-radius (cast <fl> z))))
                                                  (rendering (cache-rendering~ block))
                                                  (opaque-cube? (get-opaque-cube?~ block))
                                                  (water-cube? (get-water-cube?~ block))
                                                  (generate (get-generate~ block)))
                                              (let ((lighting compute-lighting))
                                                (cond (generate
                                                       (generate block-id data-id i j k x y z block-radius uv lighting rendering add-face add-opaque-cube))
                                                      (water-cube?
                                                       (add-water-cube i j k x y z uv uv uv uv uv uv lighting rendering add-face))
                                                      (opaque-cube?
                                                       (add-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering add-face))
                                                      (else
                                                       (add-cross-faces x y z block-radius uv lighting rendering add-face))))))))))))
                    
                    (reset~ opaque-rendering)
                    (reset~ transparent-rendering)
                    (reset~ coverage-rendering)
                    (reset~ water-rendering)
                    (reset~ wet-rendering)
                    (reset~ multitexture-rendering)
                    
                    (checkpoint 2)
                    (iterate-blocks count-polygons)
                    
                    (setup~ opaque-rendering)
                    (setup~ transparent-rendering)
                    (setup~ coverage-rendering)
                    (setup~ water-rendering)
                    (setup~ wet-rendering)
                    (setup~ multitexture-rendering)
                    
                    (checkpoint 3)
                    (iterate-blocks add-face)
                    
                    (checkpoint 4)
                    (case what
                      ((physical)
                       (when (eq? self (current-zone))
                         (iterate-table areas
                           (lambda (area <Area> polygons)
                             (add-polygons~ area #f polygons #f)))))
                      ((render)
                       (let ((opaque (conclude-rendering opaque-rendering))
                             (transparent (conclude-rendering transparent-rendering))
                             (coverage (conclude-rendering coverage-rendering))
                             (water (conclude-rendering water-rendering))
                             (wet (conclude-rendering wet-rendering))
                             (multitexture (conclude-rendering multitexture-rendering)))
                         (write-render-event
                           (lambda ()
                             (define (prepare-mesh info)
                               (when info
                                 (bind (material vertices neighbors lightmap) info
                                   (setup-mesh~ sector)
                                   (let ((mesh (get-mesh~ sector)))
                                     (fill-vertices/neighbors~ sector mesh vertices neighbors)
                                     (fill-lightmap~ sector mesh lightmap)))))
                             
                             (define (prepare-other-mesh info)
                               (when info
                                 (bind (material vertices neighbors lightmap) info
                                   (setup-other-meshes~ sector)
                                   (let ((mesh (new Mesh material: material)))
                                     (let ((material (get-material~ mesh)))
                                       (table-set! (allege (get-other-meshes~ sector)) material mesh)
                                       (fill-vertices/neighbors~ sector mesh vertices neighbors)
                                       (fill-lightmap~ sector mesh lightmap))))))
                             
                             (when (eq? self (current-zone))
                               (free-mesh~ sector)
                               (prepare-mesh opaque)
                               (prepare-other-mesh transparent)
                               (prepare-other-mesh coverage)
                               (prepare-other-mesh water)
                               (prepare-other-mesh wet)
                               (prepare-other-mesh multitexture)
                               (set-vertices-uptodate?~ sector #t)
                               (set-lightmap-uptodate?~ sector #t)
                               (sector-generated sector)
                               (generate-done)))))))
                    (checkpoint 9))))))))))))
  
  
  (method virtual (sector-generated sector)
    )
  
  
  (method (generate-sector-heightmap sector <Sector> what)
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (decrease-sectors-generating sector))
    
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region sector-x sector-y sector-z)))
          (if (not region)
              (when (eq? what 'render)
                (generate-done))
            (let ((chunk (get-chunk~ region sector-x sector-z)))
              (if (not chunk)
                  (when (eq? what 'render)
                    (generate-done))
                (if (or (get-heightmap-uptodate?~ chunk)
                        (get-heightmap-generating?~ chunk))
                    (generate-done)
                  (set-heightmap-generating?~ chunk #t)
                  (let ((from-x (* sector-x 16))
                        (width 16)
                        (from-z (* sector-z 16))
                        (depth 16)
                        (heightmap <vector> (get-heightmap~ chunk)))
                    (define (index i <fx> k <fx>) <fx>
                      (+ (* k 16) i))
                    
                    (let ((x-count (+ width 1))
                          (z-count (+ depth 1)))
                      (let ((f32heightmap (make-f32vector (* x-count z-count))))
                        (define (f32index i <fx> k <fx>) <fx>
                          (+ (* i z-count) k))
                        
                        (loop (for k from 0 to 16)
                              (loop (for i from 0 to 16)
                                    (let ((height <fx> (vector-ref heightmap (index (min i 15) (min k 15)))))
                                      (f32vector-set! f32heightmap (f32index i k) (cast <fl> height)))))
                        (generate-heightmap-content sector f32heightmap from-x width from-z depth what)
                        (set-heightmap-uptodate?~ chunk #t))))))))))))
  
  
  ;;;
  ;;;; Model
  ;;;
  
  
  (method (minecraft-blocks)
    blocks)
  
  
  (method (minecraft-blockids)
    blockids)
  
  
  (method (minecraft-block-model block <Minecraft-Block-Model> x y z)
    (let ((faces '())
          (block-radius .5)
          (block-id (get-id~ block))
          (uv (block-texture-coordinates block))
          (generate (get-generate~ block))
          (opaque-cube? (get-opaque-cube?~ block))
          (rendering (cache-rendering~ block))
          (transparent-rendering (transparent-rendering)))
      (define (add-face face <Face> rendering <Minecraft-Rendering> physical? <bool>)
        (set! faces (cons face faces)))
      
      (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering add-face)
        (add-face (left-side   i j k x y z block-radius left-uv lighting rendering) rendering #t)
        (add-face (right-side  i j k x y z block-radius right-uv lighting rendering) rendering #t)
        (add-face (bottom-side i j k x y z block-radius bottom-uv lighting rendering) rendering #t)
        (add-face (top-side    i j k x y z block-radius top-uv lighting rendering) rendering #t)
        (add-face (back-side   i j k x y z block-radius back-uv lighting rendering) rendering #t)
        (add-face (front-side  i j k x y z block-radius front-uv lighting rendering) rendering #t))
      
      (define (no-lighting i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
        (default-lighting))
      
      (let ((lighting no-lighting))
        (cond (generate
               (generate block-id 0 0 0 0 x y z block-radius uv lighting rendering add-face add-opaque-cube))
              (opaque-cube?
               (add-opaque-cube 0 0 0 x y z uv uv uv uv uv uv lighting rendering add-face))
              (else
               (add-cross-faces x y z block-radius uv lighting transparent-rendering add-face))))
      faces))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (proclaim (not warn optimizations))
  
  
  (method override (target-update target face face-rank poly)
    (define (count-chunks)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (when region
              (increase! count (table-length (get-chunks~ region))))))
        count))
    
    (define (count-sections)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (when region
              (iterate-table (get-chunks~ region)
                (lambda (index chunk)
                  (when chunk
                    (increase! count (table-length (get-sections~ chunk)))))))))
        count))
    
    (define (center-info title center)
      (let ((sector (position-sector center))
            (area (position-area center))
            (x (fxround (/ (- (vertex-x center) .5) 1.)))
            (y (fxround (/ (- (vertex-y center) .5) 1.)))
            (z (fxround (/ (- (vertex-z center) .5) 1.))))
        (let ((block (vector x y z))
              (sector-index (get-index~ sector)))
          (let ((sector-x (vector-ref sector-index 0))
                (sector-y (vector-ref sector-index 1))
                (sector-z (vector-ref sector-index 2)))
            (let ((region (sector-region sector-x sector-y sector-z)))
              (let ((section (get-section~ region sector-x sector-y sector-z)))
                (when section
                  (let ((blocks (get-blocks~ section))
                        (data (get-data~ section))
                        (blocklight (get-blocklight~ section))
                        (skylight (get-skylight~ section)))
                    (define (block-ref i <fx> j <fx> k <fx>)
                      (normalize-block-id (s8vector-ref blocks (+ (* j 256) (* k 16) i))))
                    
                    (define (normalize-block-id id <fx>)
                      (if (>= id 0)
                          id
                        (+ 256 id)))
                    
                    (define (index i <fx> j <fx> k <fx>)
                      (+ (* j 256) (* k 16) i))
                    
                    (define (s4vector-ref field <s8vector> index <fx>) <fx>
                      (let ((byte (s8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (data-ref i <fx> j <fx> k <fx>)
                      (s4vector-ref data (index i j k)))
                    
                    (define (blocklight-ref i <fx> j <fx> k <fx>)
                      (s4vector-ref blocklight (index i j k)))
                    
                    (define (skylight-ref i <fx> j <fx> k <fx>)
                      (s4vector-ref skylight (index i j k)))
                    
                    (define (block-info i <fx> j <fx> k <fx>)
                      (let ((id (block-ref i j k))
                            (data (data-ref i j k))
                            (blocklight (blocklight-ref i j k))
                            (skylight (skylight-ref i j k)))
                        (let ((block (blockid->block id)))
                          (list (cons title (get-name~ block))
                                (cons "id" id)
                                (cons "data" data)
                                (cons "block light" blocklight)
                                (cons "sky light" skylight)
                                (cons "sector" (format "{r precision: 3}, {r precision: 3}, {r precision: 3}" sector-x sector-y sector-z))
                                (cons "coord" (format "{a} {a} {a}" i j k))))))
                    
                    (let ((i (- x (* sector-x 16)))
                          (j (- y (* sector-y 16)))
                          (k (- z (* sector-z 16))))
                      (block-info i j k))))))))))
    
    (register-info 'minecraft
      (lambda (add-section add-info)
        (with-regions-mutex
          (lambda ()
            (let ((section (add-section "Minecraft")))
              (add-info section "regions" (table-length regions))
              (add-info section "chunks" (count-chunks))
              (add-info section "sections" (count-sections)))))))
    (if (not poly)
        (begin
          (unregister-info 'block)
          (unregister-info 'top))
      (let ((block (vertex+ (get-center~ poly) (vertex-scalar*& (get-normal~ poly) -.5))))
        (let ((info (center-info "Block" block)))
          (register-info 'block
            (lambda (add-section add-info)
              (let ((section (add-section "Block")))
                (for-each (lambda (info)
                            (add-info section (car info) (cdr info)))
                          info)))))
        (let ((top (vertex+ block (vertex 0. 1. 0.))))
          (let ((info (center-info "Top" top)))
            (if (not info)
                (unregister-info 'top)
              (register-info 'top
                (lambda (add-section add-info)
                  (let ((section (add-section "Top")))
                    (for-each (lambda (info)
                                (add-info section (car info) (cdr info)))
                              info)))))))
        @wait
        (let ((back (vertex+ block (vertex 0. 0. -1.))))
          (let ((info (center-info "Back" back)))
            (if (not info)
                (unregister-info 'back)
              (register-info 'back
                (lambda (add-section add-info)
                  (let ((section (add-section "Back")))
                    (for-each (lambda (info)
                                (add-info section (car info) (cdr info)))
                              info)))))))
        @wait
        (let ((left (vertex+ block (vertex -1. 0. 0.))))
          (let ((info (center-info "Left" left)))
            (if (not info)
                (unregister-info 'left)
              (register-info 'left
                (lambda (add-section add-info)
                  (let ((section (add-section "Left")))
                    (for-each (lambda (info)
                                (add-info section (car info) (cdr info)))
                              info))))))))))
  
  
  (proclaim (warn optimizations)))


;;;
;;;; Add
;;;


(definition public (left-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting rendering)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (left-face i j k left right bottom top back front uv lighting rendering)))


(definition public (left-face i <fx> j <fx> k <fx> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting rendering)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face rendering
                         (f32vector tl tt tl tb tr tb tr tt)
                         texture-depth
                         (make-quad #f
                                    (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front))
                         (lighting i j k -1  0 -1 -1  0  0 -1  1 -1 -1  1  0)
                         (lighting i j k -1 -1 -1 -1 -1  0 -1  0 -1 -1  0  0)
                         (lighting i j k -1 -1  0 -1 -1  1 -1  0  0 -1  0  1)
                         (lighting i j k -1  0  0 -1  0  1 -1  1  0 -1  1  1))))


(definition public (right-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting rendering)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (right-face i j k left right bottom top back front uv lighting rendering)))


(definition public (right-face i <fx> j <fx> k <fx> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting rendering)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face rendering
                         (f32vector tl tt tl tb tr tb tr tt)
                         texture-depth
                         (make-quad #f
                                    (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back))
                         (lighting i j k  1  0  0  1  0  1  1  1  0  1  1  1)
                         (lighting i j k  1 -1  0  1 -1  1  1  0  0  1  0  1)
                         (lighting i j k  1 -1 -1  1 -1  0  1  0 -1  1  0  0)
                         (lighting i j k  1  0 -1  1  0  0  1  1 -1  1  1  0))))


(definition public (bottom-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting rendering)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (bottom-face i j k left right bottom top back front uv lighting rendering)))


(definition public (bottom-face i <fx> j <fx> k <fx> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting rendering)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face rendering
                         (f32vector tl tt tl tb tr tb tr tt)
                         texture-depth
                         (make-quad #f
                                    (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front))
                         (lighting i j k -1 -1  0 -1 -1  1  0 -1  0  0 -1  1)
                         (lighting i j k -1 -1 -1 -1 -1  0  0 -1 -1  0 -1  0)
                         (lighting i j k  0 -1 -1  0 -1  0  1 -1 -1  1 -1  0)
                         (lighting i j k  0 -1  0  0 -1  1  1 -1  0  1 -1  1))))


(definition public (top-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting rendering)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (top-face i j k left right bottom top back front uv lighting rendering)))


(definition public (top-face i <fx> j <fx> k <fx> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting rendering)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face rendering
                         (f32vector tl tb tl tt tr tt tr tb)
                         texture-depth
                         (make-quad #f
                                    (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back))
                         (lighting i j k -1  1 -1 -1  1  0  0  1 -1  0  1  0)
                         (lighting i j k -1  1  0 -1  1  1  0  1  0  0  1  1)
                         (lighting i j k  0  1  0  0  1  1  1  1  0  1  1  1)
                         (lighting i j k  0  1 -1  0  1  0  1  1 -1  1  1  0))))


(definition public (back-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting rendering)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (back-face i j k left right bottom top back front uv lighting rendering)))


(definition public (back-face i <fx> j <fx> k <fx> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting rendering)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face rendering
                         (f32vector tr tt tr tb tl tb tl tt)
                         texture-depth
                         (make-quad #f
                                    (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back))
                         (lighting i j k  0  0 -1  0  1 -1  1  0 -1  1  1 -1)
                         (lighting i j k  0 -1 -1  0  0 -1  1 -1 -1  1  0 -1)
                         (lighting i j k -1 -1 -1 -1  0 -1  0 -1 -1  0  0 -1)
                         (lighting i j k -1  0 -1 -1  1 -1  0  0 -1  0  1 -1))))


(definition public (front-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting rendering)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (front-face i j k left right bottom top back front uv lighting rendering)))


(definition public (front-face i <fx> j <fx> k <fx> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting rendering)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face rendering
                         (f32vector tl tt tl tb tr tb tr tt)
                         texture-depth
                         (make-quad #f
                                    (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front))
                         (lighting i j k -1  0  1 -1  1  1  0  0  1  0  1  1)
                         (lighting i j k -1 -1  1 -1  0  1  0 -1  1  0  0  1)
                         (lighting i j k  0 -1  1  0  0  1  1 -1  1  1  0  1)
                         (lighting i j k  0  0  1  0  1  1  1  0  1  1  1  1))))


(definition public (add-cube-faces i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting rendering add-face)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (add-face (left-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (right-face  i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (bottom-face i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (top-face    i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (back-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (front-face  i j k left right bottom top back front uv lighting rendering) rendering #t)))


(definition public (add-cross-faces x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting rendering add-face)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius)))
        (tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv))
        (lighting (default-lighting)))
    (add-face (make-minecraft-face rendering
                                   (f32vector tl tt tl tb tr tb tr tt)
                                   texture-depth
                                   (make-quad #f
                                              (vertex right top back) (vertex right bottom back) (vertex left bottom front) (vertex left top front))
                                   lighting lighting lighting lighting)
              rendering
              #f)
    (add-face (make-minecraft-face rendering
                                   (f32vector tl tt tl tb tr tb tr tt)
                                   texture-depth
                                   (make-quad #f
                                              (vertex right top front) (vertex right bottom front) (vertex left bottom back) (vertex left top back))
                                   lighting lighting lighting lighting)
              rendering
              #f)))


(definition (add-stairs i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv lighting rendering add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top y)
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (right-face  i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (bottom-face i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (top-face    i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (back-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (front-face  i j k left right bottom top back front uv lighting rendering) rendering #t)))


(definition (add-slab i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv lighting rendering add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top y)
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (right-face  i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (bottom-face i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (top-face    i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (back-face   i j k left right bottom top back front uv lighting rendering) rendering #t)
    (add-face (front-face  i j k left right bottom top back front uv lighting rendering) rendering #t)))


(definition (add-rail data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-radius <fl> uv lighting rendering add-face)
  (case (bitwise-and data-id #x7)
    ((0) (add-bottom i j k x y z block-radius uv lighting rendering add-face))
    ((1) (add-bottom i j k x y z block-radius uv lighting rendering add-face))
    ((2) (add-right  i j k x y z block-radius uv lighting rendering add-face))
    ((3) (add-left   i j k x y z block-radius uv lighting rendering add-face))
    ((4) (add-back   i j k x y z block-radius uv lighting rendering add-face))
    ((5) (add-front  i j k x y z block-radius uv lighting rendering add-face))))


(definition add-epsilon <fl>
  .01)


(definition (add-left i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv lighting rendering add-face)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (add-face (right-face i j k left (+ left add-epsilon) bottom top back front uv lighting rendering) rendering #f)))


(definition (add-right i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv lighting rendering add-face)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (add-face (left-face i j k (- right add-epsilon) right bottom top back front uv lighting rendering) rendering #f)))


(definition (add-bottom i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv lighting rendering add-face)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (add-face (top-face i j k left right bottom (+ bottom add-epsilon) back front uv lighting rendering) rendering #f)))


(definition (add-top i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv lighting rendering add-face)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (add-face (bottom-face i j k left right (- top add-epsilon) top back front uv lighting rendering) rendering #f)))


(definition (add-back i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv lighting rendering add-face)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (add-face (front-face i j k left right bottom top back (+ back add-epsilon) uv lighting rendering) rendering #f)))


(definition (add-front i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> radius <fl> uv lighting rendering add-face)
  (let ((left (fl& (- x radius)))
        (right (fl& (+ x radius)))
        (bottom (fl& (- y radius)))
        (top (fl& (+ y radius)))
        (back (fl& (- z radius)))
        (front (fl& (+ z radius))))
    (add-face (back-face i j k left right bottom top (- front add-epsilon) front uv lighting rendering) rendering #f)))


(definition (add-transparent data-id left right back front i j k x y z block-radius uv lighting rendering add-face)
  (ecase data-id
    ((left)  (add-left  i j k x y z block-radius uv lighting rendering add-face))
    ((right) (add-right i j k x y z block-radius uv lighting rendering add-face))
    ((back)  (add-back  i j k x y z block-radius uv lighting rendering add-face))
    (else    (add-front i j k x y z block-radius uv lighting rendering add-face))))


(definition (default-lighting)
  (u8vector 0 60 4))


;;;
;;;; World
;;;


(class Minecraft-World extends World))
