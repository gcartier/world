;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Minecraft
;;;


(module world.external.minecraft jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.system)
        (jazz.ui.window)
        (zlib)
        (world)
        (world.animation)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.binary)
        (world.block)
        (world.dye)
        (world.external)
        (world.external.minecraft-syntax (phase syntax))
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.homogeneous)
        (world.material)
        (world.mesh)
        (world.model)
        (world.quad)
        (world.sector)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle)
        (profiler))


(proclaim (warn optimizations))


(constant region-size <fx>
  32)


;;;
;;;; NBT
;;;


(constant TAG_End        <fx>  0)
(constant TAG_Byte       <fx>  1)
(constant TAG_Short      <fx>  2)
(constant TAG_Int        <fx>  3)
(constant TAG_Long       <fx>  4)
(constant TAG_Float      <fx>  5)
(constant TAG_Double     <fx>  6)
(constant TAG_Byte_Array <fx>  7)
(constant TAG_String     <fx>  8)
(constant TAG_List       <fx>  9)
(constant TAG_Compound   <fx> 10)
(constant TAG_Int_Array  <fx> 11)


(class NBT-Stream extends Binary-Stream
  
  
  (method (read-tag read)
    (define (read-tag read)
      (let ((type <fx> (<-u8)))
        (if (= type TAG_End)
            #t
          (let ((name (read-name read)))
            (cond ((not read)
                   (read-data type read)
                   #f)
                  ((eq? read #t)
                   (cons name (read-data type read)))
                  (else
                   (read type name read-data)))))))
    
    (define (read-name read)
      (let ((size <fx> (read-short #t)))
        (cond ((not read)
               (increase! position size))
              ((= size 0)
               "")
              (else
               (<-utf-8-string size)))))
    
    (define (read-data type read)
      (ecase type
        ((TAG_End)        (read-end read))
        ((TAG_Byte)       (read-byte read))
        ((TAG_Short)      (read-short read))
        ((TAG_Int)        (read-int read))
        ((TAG_Long)       (read-long read))
        ((TAG_Float)      (read-float read))
        ((TAG_Double)     (read-double read))
        ((TAG_Byte_Array) (read-byte-array read))
        ((TAG_String)     (read-name read))
        ((TAG_List)       (read-list read))
        ((TAG_Compound)   (read-compound read))
        ((TAG_Int_Array)  (read-int-array read))
        (else (error "Unknown NBT tag: {s}" type))))
    
    (define (read-end read)
      (error "Invalid NBT tag: TAG_End"))
    
    (define (read-byte read)
      (if (not read)
          (increase! position 1)
        (<-s8)))
    
    (define (read-short read)
      (if (not read)
          (increase! position 2)
        (<-s16-big-endian)))
    
    (define (read-int read)
      (if (not read)
          (increase! position 4)
        (<-s32-big-endian)))
    
    (define (read-long read)
      (if (not read)
          (increase! position 8)
        (<-s64-big-endian)))
    
    (define (read-float read)
      (if (not read)
          (increase! position 4)
        (<-float-big-endian)))
    
    (define (read-double read)
      (if (not read)
          (increase! position 8)
        (<-double-big-endian)))
    
    (define (read-byte-array read)
      (let ((size <fx> (read-int #t)))
        (if (not read)
            (increase! position size)
          (let ((data (make-s8vector size)))
            (for (i 0 size)
                 (s8vector-set! data i (read-byte read)))
            data))))
    
    (define (read-int-array read)
      (let ((size <fx> (read-int #t)))
        (if (not read)
            (increase! position (* size 4))
          (let ((data (make-vector size)))
            (for (i 0 size)
                 (vector-set! data i (read-int read)))
            data))))
    
    (define (read-list read)
      (let ((type <fx> (read-byte #t))
            (size <fx> (read-int #t)))
        (loop (repeat size)
              (collect (read-data type read)))))
    
    (define (read-compound read)
      (let ((tag (read-tag read)))
        (cond ((eq? tag #t)
               '())
              ((or (not tag)
                   (not read))
               (read-compound read))
              (else
               (cons tag (read-compound read))))))
    
    (read-tag read)))


;;;
;;;; Block
;;;


(class Minecraft-Block-Model extends Object
  
  
  (slot name                getter generate)
  (slot id                  getter generate)
  (slot subid               getter generate)
  (slot texture             getter generate)
  (slot texture-coordinates accessors generate)
  (slot transparent?        getter generate)
  (slot generate            getter generate)
  
  
  (method override (initialize name id subid texture transparent? generate)
    (set! name~self name)
    (set! id~self id)
    (set! subid~self subid)
    (set! texture~self texture)
    (set! texture-coordinates~self #f)
    (set! transparent?~self transparent?)
    (set! generate~self generate))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition blocks <table>
  (make-table test: eq?))

(definition blockids <vector>
  (make-vector 256 #f))


(definition unknown-texture <fx>
  #x17)


(definition (register-block name id (texture #f) (transparent? #f) (generate #f))
  (let ((id <fx> (if (pair? id) (car id) id))
        (subid (if (pair? id) (cadr id) #f)))
    (when (not subid)
      (let ((texture (case texture
                       ((#f) unknown-texture)
                       (else texture))))
        (let ((block (new Minecraft-Block-Model name id subid texture transparent? generate)))
          (table-set! blocks name block)
          (vector-set! blockids id block))))))


(definition public inline (blockid->block id <fx>) <Minecraft-Block-Model>
  (vector-ref blockids id))


(definition tile-custom <fx+>
  (find-setting 'minecraft.tile-resolution #f))

(definition tile-resolution <fx>
  (or tile-custom 16))

(definition tile-size <fl>
  (cast <fl> tile-resolution))

(definition tile-period <fx>
  16)

(definition texture-size <fl>
  (* tile-size (cast <fl> tile-period)))

(definition texture-pack
  (if (not tile-custom)
      "terrain.png"
    (format "terrain{a}x{a}.png" tile-resolution tile-resolution)))

(definition texture-mipmap?
  #f)


(definition (block-texture-coordinates block <Minecraft-Block-Model>)
  (or (get-texture-coordinates~ block)
      (let ((coords (rank-texture-coordinates (get-texture~ block))))
        (set-texture-coordinates~ block coords)
        coords)))


(definition pack-mutex
  (make-mutex 'pack))

(definition pack-coordinates <vector>
  (make-vector 256 #f))

(definition (get-pack-coordinates pack-rank <fx>) <f32vector>
  (mutex-lock! pack-mutex)
  (prog1 (or (vector-ref pack-coordinates pack-rank)
             (let ((coords (rank-texture-coordinates pack-rank)))
               (vector-set! pack-coordinates pack-rank coords)
               coords))
    (mutex-unlock! pack-mutex)))


(definition (rank-texture-coordinates texture-rank <fx>) <f32vector>
  (let ((x (modulo texture-rank tile-period)))
    (let ((y (/ (- texture-rank x) tile-period)))
      (let ((l (* (cast <fl> x) tile-size))
            (t (* (cast <fl> y) tile-size)))
        (if (get-texture-arrays?)
            (uv 0.
                0.
                1.
                1.
                (cast <fl> texture-rank))
          ;; these adjustments are hacks until texture arrays
          (if (not texture-mipmap?)
              (let ((r (+ l tile-size))
                    (b (+ t tile-size)))
                (uv (/ (+ l .05) texture-size)
                    (/ (+ t .05) texture-size)
                    (/ (- r .05) texture-size)
                    (/ (- b .05) texture-size)
                    0.))
            (let ((r (+ l tile-size -1.))
                  (b (+ t tile-size -1.)))
              (uv (/ (+ l .5) texture-size)
                  (/ (+ t .5) texture-size)
                  (/ (- r .5) texture-size)
                  (/ (- b .5) texture-size)
                  0.))))))))


;;;
;;;; Blocks
;;;


(define-block Air
  0
  #f
  #t)

(define-block Stone
  1
  #x00)

(define-block Grass
  2
  #x03
  #f
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x91)))
      (add-block uv uv uv top uv uv lighting))))

(define-block Dirt
  3
  #x02)

(define-block Cobblestone
  4
  #x11)

(define-block WoodenPlank
  5
  #x14)

(definition Sapling-Textures <vector>
  #(#x3F ;; Oak
    #x0F ;; Spruce
    #x4F ;; Birch
    #x1E ;; Jungle Tree
    ))

(define-block Sapling
  6
  #x3F
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((uv (get-pack-coordinates (vector-ref Sapling-Textures (bitwise-and data-id #x3)))))
      (add-cross-faces x y z block-radius uv lighting add-transparent-face))))

(define-block RedwoodSapling
  (6 1))

(define-block BirchSapling
  (6 2))

(define-block Bedrock
  7
  #x25)

(define-block Water
  8
  #xB1
  @wait-translucency
  #xCD
  @wait-translucency
  #t
  @wait-translucency
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-block uv uv uv uv uv uv lighting)))

(define-block StationaryWater
  9
  #xB1
  @wait-translucency
  #xCD
  @wait-translucency
  #t
  @wait-translucency
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-block uv uv uv uv uv uv lighting)))

(define-block Lava
  10
  #xFF)

(define-block StationaryLava
  11
  #xFF)

(define-block Sand
  12
  #x12)

(define-block Gravel
  13
  #x01)

(define-block GoldOre
  14
  #x20)

(define-block IronOre
  15
  #x10)

(define-block CoalOre
  16
  #x11)

(define-block Wood
  17
  #x04)

(define-block Redwood
  (17 1))

(define-block Birchwood
  (17 2))

(define-block Leaves
  18
  #x34)

(define-block RedwoodLeaves
  (18 1))

(define-block BirchwoodLeaves
  (18 2))

(define-block Sponge
  19
  #x30)

(define-block Glass
  20
  #x31)

(define-block LapisLazuliOre
  21
  #xA0)

(define-block LapisLazuliBlock
  22
  #x90)

(define-block Dispenser
  23
  #x2E)

(define-block Sandstone
  24
  #xB0)

(define-block NoteBlock
  25
  #x4A)

(define-block BedBlock
  26
  #x87)

(define-block PoweredRail
  27
  #xB3
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-rail data-id x y z block-radius uv lighting add-transparent-face)))

(define-block DetectorRail
  28
  #xC3
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-rail data-id x y z block-radius uv lighting add-transparent-face)))

(define-block StickyPiston
  29
  #x6A)

(define-block Web
  30
  #x0B)

(define-block DeadShrub
  31
  #x5C
  #t)

(define-block TallGrass
  (31 1))

(define-block LiveShrub
  (31 2))

(define-block DeadShrub
  32
  #x37)

(define-block Piston
  33
  #x6A)

;; improve
(define-block PistonHead
  34
  #x6A)

(definition Wool-Textures <vector>
  #(#x40 ;; White
    #xD2 ;; Orange
    #xC2 ;; Magenta
    #xB2 ;; LightBlue
    #xA2 ;; Yellow
    #x92 ;; LightGreen
    #x82 ;; Pink
    #x72 ;; Gray
    #xE1 ;; LightGray
    #xD1 ;; Cyan
    #xC1 ;; Purple
    #xB1 ;; Blue
    #xA1 ;; Brown
    #x91 ;; DarkGreen
    #x81 ;; Red
    #x71 ;; Black
    ))

(define-block WhiteWool
  35
  #f
  #f
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((uv (get-pack-coordinates (vector-ref Wool-Textures data-id))))
      (add-block uv uv uv uv uv uv lighting))))

(define-block Dandelion
  37
  #x0D
  #t)

(define-block Rose
  38
  #x0C
  #t)

(define-block BrownMushroom
  39
  #x1D
  #t)

(define-block RedMushroom
  40
  #x1C
  #t)

(define-block GoldBlock
  41
  #x30
  @temp-because-this-block-is-used-to-render-unknown
  #x17)

(define-block IronBlock
  42
  #x16)

(define-block DoubleStoneSlab
  43
  #x10)

(define-block DoubleSandstoneSlab
  (43 1))

(define-block DoubleWoodenSlab
  (43 2))

(define-block DoubleCobblestoneSlab
  (43 3))

(define-block DoubleBrickSlab
  (43 4))

(define-block DoubleStoneBrickSlab
  (43 5))

(define-block StoneSlab
  44
  #x06
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-slab x y z block-radius uv lighting add-face)))

(define-block SandstoneSlab
  (44 1))

(define-block WoodenSlab
  (44 2))

(define-block CobblestoneSlab
  (44 3))

(define-block BrickSlab
  (44 4))

(define-block StoneBrickSlab
  (44 5))

(define-block Brick
  45
  #x07)

(define-block TNT
  46
  #x08
  #f
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x09)))
      (add-block uv uv uv top uv uv lighting))))

(define-block Bookshelf
  47
  #x23
  #f
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x04)))
      (add-block uv uv uv top uv uv lighting))))

(define-block MossyCobblestone
  48
  #x24)

(define-block Obsidian
  49
  #x25)

(define-block Torch
  50
  #x63
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-transparent data-id 2 1 3 4 x y z block-radius uv lighting add-transparent-face)))

(define-block Fire
  51
  #x3D)

(define-block MonsterSpawner
  52
  #x41)

(define-block WoodenStairs
  53
  #x04
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-stairs x y z block-radius uv lighting add-face)))

(define-block Chest
  54
  #x6B)

(define-block RedstoneWire
  55
  #xA5
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-bottom x y z block-radius uv lighting add-transparent-face)))

(define-block DiamondOre
  56
  #x32)

(define-block DiamondBlock
  57
  #x18)

(define-block Workbench
  58
  #x4A)

(define-block WheatCrops
  59
  #x5F
  #t)

(define-block Soil
  60
  #x02)

(define-block Furnace
  61
  #x2C)

(define-block BurningFurnace
  62
  #x3D)

(define-block SignPost
  63
  #x50
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-right x y z block-radius uv lighting add-transparent-face)))

(define-block WoodenDoorBlock
  64
  #x51)

(define-block Ladder
  65
  #x53
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-transparent data-id 5 4 3 2 x y z block-radius uv lighting add-transparent-face)))

(define-block Rails
  66
  #x80
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-rail data-id x y z block-radius uv lighting add-transparent-face)))

(define-block CobblestoneStairs
  67
  #x10
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((left (- x block-radius))
          (right (+ x block-radius))
          (bottom (- y block-radius))
          (top y)
          (back (- z block-radius))
          (front (+ z block-radius)))
      (add-face (left-face   left right bottom top back front uv lighting))
      (add-face (right-face  left right bottom top back front uv lighting))
      (add-face (bottom-face left right bottom top back front uv lighting))
      (add-face (top-face    left right bottom top back front uv lighting))
      (add-face (back-face   left right bottom top back front uv lighting))
      (add-face (front-face  left right bottom top back front uv lighting)))))

(define-block WallSign
  68
  #x50
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-right x y z block-radius uv lighting add-transparent-face)))

;; improve
(define-block Lever
  69
  #x60
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-transparent data-id 2 1 3 4 x y z block-radius uv lighting add-transparent-face)))

(define-block StonePressurePlate
  70
  #x06
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((left (- x block-radius))
          (right (+ x block-radius))
          (bottom (- y block-radius))
          (top y)
          (back (- z block-radius))
          (front (+ z block-radius)))
      (add-face (left-face   left right bottom top back front uv lighting))
      (add-face (right-face  left right bottom top back front uv lighting))
      (add-face (bottom-face left right bottom top back front uv lighting))
      (add-face (top-face    left right bottom top back front uv lighting))
      (add-face (back-face   left right bottom top back front uv lighting))
      (add-face (front-face  left right bottom top back front uv lighting)))))

(define-block IronDoorBlock
  71
  #x52)

(define-block WoodenPressurePlate
  72
  #x04
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((left (- x block-radius))
          (right (+ x block-radius))
          (bottom (- y block-radius))
          (top y)
          (back (- z block-radius))
          (front (+ z block-radius)))
      (add-face (left-face   left right bottom top back front uv lighting))
      (add-face (right-face  left right bottom top back front uv lighting))
      (add-face (bottom-face left right bottom top back front uv lighting))
      (add-face (top-face    left right bottom top back front uv lighting))
      (add-face (back-face   left right bottom top back front uv lighting))
      (add-face (front-face  left right bottom top back front uv lighting)))))

(define-block RedstoneOre
  73
  #x33)

(define-block GlowingRedstoneOre
  74
  #x33)

(define-block RedstoneTorchOff
  75
  #x73
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-transparent data-id 2 1 3 4 x y z block-radius uv lighting add-transparent-face)))

(define-block RedstoneTorchOn
  76
  #x63
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-transparent data-id 2 1 3 4 x y z block-radius uv lighting add-transparent-face)))

(define-block StoneButton
  77
  #x9F)

(define-block Snow
  78
  #x40
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((left (- x block-radius))
          (right (+ x block-radius))
          (bottom (- y block-radius))
          (top (+ (- y block-radius) .625))
          (back (- z block-radius))
          (front (+ z block-radius)))
      (add-face (left-face   left right bottom top back front uv lighting))
      (add-face (right-face  left right bottom top back front uv lighting))
      (add-face (bottom-face left right bottom top back front uv lighting))
      (add-face (top-face    left right bottom top back front uv lighting))
      (add-face (back-face   left right bottom top back front uv lighting))
      (add-face (front-face  left right bottom top back front uv lighting)))))

(define-block Ice
  79
  #xD1
  @wait-translucency
  #x43)

(define-block SnowBlock
  80
  #x40)

(define-block Cactus
  81
  #x46)

(define-block Clay
  82
  #x48)

(define-block SugarCane
  83
  #x49)

(define-block Jukebox
  84
  #x4A
  #f
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x4B)))
      (add-block uv uv uv top uv uv lighting))))

(define-block Fence
  85
  #x55
  #t)

(define-block Pumpkin
  86
  #x77
  #f
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x66)))
      (add-block uv uv uv top uv uv lighting))))

(define-block Netherrack
  87
  #x67)

(define-block SoulSand
  88
  #x68)

(define-block Glowstone
  89
  #x69)

;; improve
(define-block Portal
  90
  #x0E)

(define-block Jack-O-Lantern
  91
  #x66)

(define-block CakeBlock
  92
  #x79)

;; improve
(define-block RedstoneRepeaterBlockOff
  93
  #x83)

;; improve
(define-block RedstoneRepeaterBlockOn
  94
  #x93)

;; improve
(define-block LockedChest
  95
  #x6B)

(define-block Trapdoor
  96
  #x41)

;; improve with data
(define-block StoneSilverfish
  97
  #x01)

(define-block CobblestoneSilverfish
  (97 1))

(define-block StoneBrickSilverfish
  (97 2))

(define-block StoneBrick
  98
  #x65)

(define-block MossyStoneBrick
  (98 1))

(define-block CrackedStoneBrick
  (98 2))

(define-block BrownMushroomCap
  99
  #x7E)

(define-block RedMushroomCap
  100
  #x7D)

(define-block IronBars
  101
  #x55)

(define-block GlassPane
  102
  #x42)

(define-block MelonBlock
  103
  #x88
  #f
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x89)))
      (add-block uv uv uv top uv uv lighting))))

(define-block PumpkinStem
  104
  #x6F
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-cross-faces x y z block-radius uv lighting add-transparent-face)))

(define-block MelonStem
  105
  #x6F
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-cross-faces x y z block-radius uv lighting add-transparent-face)))

(define-block Vines
  106
  #x1E
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-transparent data-id 2 8 4 1 x y z block-radius uv lighting add-transparent-face)))

(define-block FenceGate
  107
  #x55)

(define-block BrickStairs
  108
  #x07
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-stairs x y z block-radius uv lighting add-face)))

(define-block StoneBrickStairs
  109
  #x36
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-stairs x y z block-radius uv lighting add-face)))

(define-block Mycelium
  110
  #x4D
  #f
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x4E)))
      (add-block uv uv uv top uv uv lighting))))

(define-block LilyPad
  111
  #x4C)

(define-block NetherBrick
  112
  #xE0)

(define-block NetherBrickFence
  113
  #x55)

(define-block NetherBrickStairs
  114
  #xE0
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-stairs x y z block-radius uv lighting add-face)))

;; improve
(define-block NetherWart
  115
  #xE3)

(define-block EnchantmentTable
  116
  #xB6
  #f
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #xA6)))
      (add-block uv uv uv top uv uv lighting))))

(define-block BrewingStand
  117
  #x9C)

(define-block Cauldron
  118
  #x9A
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x8A)))
      (add-block uv uv uv top uv uv lighting))))

;; improve
(define-block EndPortal
  119
  #x06
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-slab x y z block-radius uv lighting add-face)))

(define-block EndPortalFrame
  120
  #x9E)

(define-block EndStone
  121
  #xAF)

;; improve
(define-block DragonEgg
  122
  #x25)

(define-block RedstoneLampInactive
  123
  #xD3)

(define-block RedstoneLampActive
  124
  #xD4)

;; improve
(define-block DoubleWoodenSlab
  125
  #x04
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-slab x y z block-radius uv lighting add-face)))

(define-block WoodenSlab
  126
  #x04
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-slab x y z block-radius uv lighting add-face)))

(define-block CocoaPlant
  127
  #xA8)

(define-block SandstoneStairs
  128
  #xC0
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-stairs x y z block-radius uv lighting add-face)))

(define-block EmeraldOre
  129
  #xAB)

;; improve
(define-block EnderChest
  130
  #x02)

;; improve
(define-block TripwireHook
  131
  #x02)

;; improve
(define-block Tripwire
  132
  #x02)

(define-block EmeraldBlock
  133
  #x19)

(define-block SpruceWoodStairs
  134
  #xC6
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-stairs x y z block-radius uv lighting add-face)))

(define-block BirchWoodStairs
  135
  #xD6
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-stairs x y z block-radius uv lighting add-face)))

(define-block JungleWoodStairs
  136
  #xC7
  #t
  (lambda (block-id <fx> data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv <f32vector> lighting add-face add-transparent-face add-block)
    (add-stairs x y z block-radius uv lighting add-face)))

;; improve
(define-block CommandBlock
  137
  #x02)

;; improve
(define-block BeaconBlock
  138
  #x02)

;; improve
(define-block CobblestoneWall
  139
  #x02)

;; improve
(define-block FlowerPot
  140
  #x02)

;; improve
(define-block Carrots
  141
  #x02)

;; improve
(define-block Potatoes
  142
  #x02)

;; improve
(define-block WoodenButton
  143
  #x02)


(for (id 0 256)
     (unless (vector-ref blockids id)
       (register-block 'Unknown id)))


;;;
;;;; Face
;;;


(class Minecraft-Face extends Face
  
  
  (slot l1 accessors generate)
  (slot l2 accessors generate)
  (slot l3 accessors generate)
  (slot l4 accessors generate)
  
  
  (method override (initialize texture texture-coordinates texture-depth polygon l1 l2 l3 l4)
    (nextmethod texture texture-coordinates texture-depth polygon)
    (set! l1~self l1)
    (set! l2~self l2)
    (set! l3~self l3)
    (set! l4~self l4))
  
  
  (method (iterate-lighting proc)
    (proc l1 l2 l3)
    (proc l3 l4 l1)))


(definition public (make-minecraft-face texture texture-coordinates texture-depth polygon l1 l2 l3 l4)
  (new Minecraft-Face texture texture-coordinates texture-depth polygon l1 l2 l3 l4))


;;;
;;;; Section
;;;


(class Minecraft-Section extends Object
  
  
  (slot blocks     getter generate)
  (slot data       getter generate)
  (slot blocklight getter generate)
  (slot skylight   getter generate)
  
  
  (method override (initialize blocks data blocklight skylight)
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)
    (set! skylight~self skylight)))


;;;
;;;; Chunk
;;;


(class Minecraft-Chunk extends Object
  
  
  (slot heightmap             getter generate)
  (slot heightmap-revision    accessors generate)
  (slot heightmap-uptodate?   accessors generate)
  (slot heightmap-generating? accessors generate)
  (slot entities              getter generate)
  (slot sections              getter generate)
  
  
  (method override (initialize heightmap entities sections)
    (set! heightmap~self heightmap)
    (set! heightmap-revision~self 0)
    (set! heightmap-uptodate?~self #f)
    (set! heightmap-generating?~self #f)
    (set! entities~self entities)
    (set! sections~self sections)))


;;;
;;;; Region
;;;


(class Minecraft-Region extends Object
  
  
  (slot x            <fx>                                            getter generate)
  (slot z            <fx>                                            getter generate)
  (slot port         <port>                                          getter generate)
  (slot header       <u8vector>                                      getter generate)
  (slot chunks-mutex <object>   initialize (make-mutex 'chunks)      getter generate)
  (slot chunks       <table>    initialize (make-table test: equal?) getter generate)
  
  
  (method override (initialize x z port)
    (set! x~self x)
    (set! z~self z)
    (set! port~self port)
    (set! header (read-header)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" x z))))
  
  
  (method override (destroy)
    (close-port port)
    (nextmethod))
  
  
  (method (read-header)
    (let ((size (* 8 1024)))
      (let ((content (make-u8vector size)))
        (read-subu8vector content 0 size port)
        content)))
  
  
  (method (with-chunks-mutex thunk)
    (mutex-lock! chunks-mutex)
    (prog1 (thunk)
      (mutex-unlock! chunks-mutex)))
  
  
  (method (get-chunk sector-x <fx> sector-z <fx>) <Minecraft-Chunk+>
    (with-chunks-mutex
      (lambda ()
        (let ((chunk-index (chunk-index sector-x sector-z)))
          (let ((value (table-ref chunks chunk-index #t)))
            (if (neq? value #t)
                value
              (let ((chunk (read-chunk chunk-index)))
                (table-set! chunks chunk-index chunk)
                chunk)))))))
  
  
  (method (chunk-index sector-x <fx> sector-z <fx>) <pair>
    ;; looks like we don't need to adjust for negative values like stated on the wiki
    (cons (modulo sector-x 32)
          (modulo sector-z 32)))
  
  
  (method (read-chunk chunk-index <pair>) <Minecraft-Chunk+>
    (let ((zone <Minecraft-Zone> (current-zone))
          (chunk-x <fx> (car chunk-index))
          (chunk-z <fx> (cdr chunk-index)))
      (let ((offset (* 4 (+ chunk-x (* chunk-z 32)))))
        (assert (<= offset 4092))
        (let ((b1 (u8vector-ref header offset))
              (b2 (u8vector-ref header (+ offset 1)))
              (b3 (u8vector-ref header (+ offset 2)))
              (b4 (u8vector-ref header (+ offset 3))))
          (if (and (= b1 0)
                   (= b2 0)
                   (= b3 0)
                   (= b4 0))
              #f
            (let ((offset (* (+ (cast <fx> (arithmetic-shift-left b1 16))
                                (cast <fx> (arithmetic-shift-left b2 8))
                                b3)
                             (* 4 1024))))
              (input-port-byte-position port offset)
              (let ((chunk-header (make-u8vector 5)))
                (read-subu8vector chunk-header 0 5 port)
                (let ((size <fx> (scan-u32-big-endian chunk-header 0))
                      (compression-type (u8vector-ref chunk-header 4)))
                  ;; skip two bytes for deflate
                  (read-u8 port)
                  (read-u8 port)
                  (let ((chunk-raw (make-u8vector size)))
                    (read-subu8vector chunk-raw 0 size port)
                    (let ((chunk-data (inflate-u8vector chunk-raw)))
                      (let ((s (new NBT-Stream (cons chunk-data 0))))
                        (let ((tag-data
                                (read-tag~ s
                                  (lambda (type name read-data)
                                    (read-data type
                                      (lambda (type name read-data)
                                        (read-data type
                                          (lambda (type name read-data)
                                            (cond ((equal? name "HeightMap")
                                                   (cons name (read-data type #t)))
                                                  @wait ((equal? name "Entities")
                                                         (cons name (read-data type #t)))
                                                  ((equal? name "Sections")
                                                   (cons name (read-data type
                                                                (lambda (type name read-data)
                                                                  (if (or (equal? name "Y")
                                                                          (equal? name "Blocks")
                                                                          (equal? name "Data")
                                                                          (equal? name "BlockLight")
                                                                          (equal? name "SkyLight"))
                                                                      (cons name (read-data type #t))
                                                                    (read-data type #f)
                                                                    #f)))))
                                                  (else
                                                   (read-data type #f)
                                                   #f))))))))))
                          (let ((alist (car tag-data)))
                            (let ((heightmap (assoc "HeightMap" alist))
                                  (entities (assoc "Entities" alist))
                                  (sections (assoc "Sections" alist)))
                              (let ((sections-table (and sections (make-table test: eq?))))
                                (when sections-table
                                  (let ((truncate-y (get-truncate-y~ zone)))
                                    (for-each (lambda (section)
                                                (let ((yPos (- (cast <fx> (cdr (assoc "Y" section))) 4)) ;; lower everything by 64
                                                      (blocks (cdr (assoc "Blocks" section)))
                                                      (data (cdr (assoc "Data" section)))
                                                      (blocklight (cdr (assoc "BlockLight" section)))
                                                      (skylight (cdr (assoc "SkyLight" section))))
                                                  (when (or (not truncate-y)
                                                            (>= yPos (cast <fx> truncate-y)))
                                                    (table-set! sections-table yPos (new Minecraft-Section blocks data blocklight skylight)))))
                                              (cdr sections))))
                                (new Minecraft-Chunk
                                  (and heightmap (cdr heightmap))
                                  (and entities (cdr entities))
                                  sections-table))))))))))))))))
  
  
  (method (get-section sector-x <fx> sector-y <fx> sector-z <fx>) <Minecraft-Section+>
    (let ((chunk (get-chunk sector-x sector-z)))
      (when chunk
        (let ((sections (get-sections~ chunk)))
          (when sections
            (table-ref sections sector-y #f))))))
  
  
  (method (get-blocks sector-x <fx> sector-y <fx> sector-z <fx>) <s8vector+>
    (let ((section (get-section sector-x sector-y sector-z)))
      (when section
        (get-blocks~ section)))))


;;;
;;;; Level
;;;


(definition public (import-minecraft-level file)
  (let ((s (new NBT-Stream file)))
    (read-tag~ s #t)))


;;;
;;;; Sector
;;;


(class Minecraft-Sector extends Sector
  
  
  (method override (prepare-lightmap faces <vector>)
    (define (convert-light lighting <fx>) <fl>
      (cast <fl> (expt .8 (/ (- 60. (cast <fl> lighting)) 5.))))
    
    (let ((zone <Minecraft-Zone> (current-zone)))
      (if (or heightmap? (not (get-day-cycle~ zone)))
          (nextmethod faces)
        (let ((triangles-count <fx> 0)
              (triangle-floats (* 3 3)))
          (for (i 0 (vector-length faces))
               (let ((face <Minecraft-Face> (vector-ref faces i)))
                 (increase! triangles-count (cast <fx> (triangle-count~ face)))))
          (let ((f32 <f32vector> (make-f32vector (* triangles-count triangle-floats) 0.))
                (n <fx> 0))
            (for (i 0 (vector-length faces))
                 (let ((face <Minecraft-Face> (vector-ref faces i)))
                   (iterate-lighting~ face
                     (lambda (l1 l2 l3)
                       (let ((l1 (convert-light l1))
                             (l2 (convert-light l2))
                             (l3 (convert-light l3)))
                         (f32vector-set! f32 n l1)
                         (f32vector-set! f32 (+ n 1) l1)
                         (f32vector-set! f32 (+ n 2) l1)
                         (f32vector-set! f32 (+ n 3) l2)
                         (f32vector-set! f32 (+ n 4) l2)
                         (f32vector-set! f32 (+ n 5) l2)
                         (f32vector-set! f32 (+ n 6) l3)
                         (f32vector-set! f32 (+ n 7) l3)
                         (f32vector-set! f32 (+ n 8) l3)
                         (increase! n 9))))))
            f32))))))


;;;
;;;; Zone
;;;


(definition generate-count <fl>
  0.)

(definition generate-total <fl>
  0.)


(definition public (generate-average)
  (/ generate-total generate-count))


(definition heightmap?
  (find-setting 'minecraft.heightmap? #f))

(definition public (get-heightmap?)
  heightmap?)

(definition public (set-heightmap? flag)
  (set! heightmap? flag))


(class Minecraft-Zone extends Zone
  
  
  (property level-dir  <Directory> initialize #f   accessors generate)
  (property truncate-y <fx+>       initialize #f   accessors generate)
  (property day-cycle  <object>    initialize 'day accessors generate)
  
  
  (slot regions-dir   <Directory> initialize #f                        getter explicit)
  (slot regions-mutex <object>    initialize (make-mutex 'regions)     getter generate)
  (slot regions       <table>     initialize (make-table test: equal?) getter generate)
  
  
  (form
    (<install> floor-level: -500.))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set! day-cycle (find-setting 'minecraft.day-cycle 'day))
    (if heightmap?
        (set! sun-cycle? #t)
      (set! sun-cycle? (not day-cycle))))
  
  
  (method override (sector-class)
    Minecraft-Sector)
  
  
  (method (with-regions-mutex thunk)
    (mutex-lock! regions-mutex)
    (prog1 (thunk)
      (mutex-unlock! regions-mutex)))
  
  
  (method (close-regions)
    (with-regions-mutex
      (lambda ()
        (iterate-table regions
          (lambda (index region)
            (when region
              (close~ region))))
        (empty-table regions))))
  
  
  (method (iterate-regions proc)
    (iterate-directory~ (get-regions-dir)
      (lambda (file)
        (when (extension=? (get-extension~ file) "mca")
          (let ((base (get-base~ file)))
            (bind (x z) (split (substring base 2 (string-length base)) ".")
              (let ((x (string->number x))
                    (z (string->number z)))
                (proc file x z))))))))
  
  
  (method (compute-boundaries)
    (let ((left +inf.0)
          (right -inf.0)
          (back +inf.0)
          (front -inf.0))
      (iterate-regions
        (lambda (file x z)
          (when (< x left)
            (set! left x))
          (when (> x right)
            (set! right x))
          (when (< z back)
            (set! back z))
          (when (> z front)
            (set! front z))))
      (values left right back front)))
  
  
  (method (get-regions-dir) <Directory>
    (or regions-dir (let ((dir (new-directory~ level-dir "region")))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method (get-region region-index <pair>) <Minecraft-Region+>
    (define (region-name)
      (bind (region-x . region-z) region-index
        (format "r.{a}.{a}.mca" region-x region-z)))
    
    (with-regions-mutex
      (lambda ()
        (let ((value (table-ref regions region-index #t)))
          (if (neq? value #t)
              value
            (let ((dir (get-regions-dir))
                  (name (region-name)))
              (let ((file (new-file~ dir name)))
                (let ((region (if (exists?~ file)
                                  (bind (region-x . region-z) region-index
                                    (let ((port (open-input-file (path-settings file))))
                                      (new Minecraft-Region region-x region-z port)))
                                #f)))
                  (table-set! regions region-index region)
                  region))))))))
  
  
  (method (sector-region sector-x <fx> sector-y <fx> sector-z <fx>) <Minecraft-Region+>
    (define (region-index)
      (cons (fxfloor/ sector-x region-size)
            (fxfloor/ sector-z region-size)))
    
    (get-region (region-index)))
  
  
  (method (sector-blocks sector-x <fx> sector-y <fx> sector-z <fx>) <s8vector+>
    (let ((region (sector-region sector-x sector-y sector-z)))
      (when region
        (get-blocks~ region sector-x sector-y sector-z))))
  
  
  (method override (generate-content?)
    #t)
  
  
  (method override (generate-content sector <Sector>)
    (let ((before (real-time)))
      (generate-sector sector 'render)
      @profile
      (with-profile 'generate
        (lambda ()
          (generate-sector sector 'render)))
      (let ((after (real-time)))
        (let ((duration (- after before)))
          (set! generate-count (+ generate-count 1.))
          (set! generate-total (+ generate-total duration))))))
  
  
  (method override (generate-physical sector <Sector>)
    (generate-sector sector 'physical))
  
  
  (method (generate-sector sector <Sector> what)
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (decrease-sectors-generating sector))
    
    (when (eq? self (current-zone))
      (if (get-heightmap?)
          (generate-sector-heightmap sector what)
      (let ((sector-index (get-index~ sector)))
        (let ((sector-x <fx> (vector-ref sector-index 0))
              (sector-y <fx> (vector-ref sector-index 1))
              (sector-z <fx> (vector-ref sector-index 2)))
          (let ((region (sector-region sector-x sector-y sector-z)))
            (if (not region)
                (when (eq? what 'render)
                  (generate-done))
              (let ((region-x (get-x~ region))
                    (region-z (get-z~ region))
                    (section (get-section~ region sector-x sector-y sector-z))
                    (chunk-index (chunk-index~ region sector-x sector-z)))
                (assert (= region-x (fxfloor/ sector-x region-size)))
                (assert (= region-z (fxfloor/ sector-z region-size)))
                (if (not section)
                    (when (eq? what 'render)
                      (generate-done))
                  (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                        (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                        (section-y (* sector-y 16))
                        (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                        (sections <vector> (make-vector 27 #t))
                        (cache <s8vector> (make-s8vector (* 18 18 18 2) -1))
                        (block-size 5.)
                        (block-radius 2.5)
                        (faces '())
                        (areas (make-table test: eq?)))
                    (define (section-ref a <fx> b <fx> c <fx>) <Minecraft-Section+>
                      (if (and (= a 0)
                               (= b 0)
                               (= c 0))
                          section
                        (let ((index (section-index a b c)))
                          (let ((section (vector-ref sections index)))
                            (if (neq? section #t)
                                section
                              (let ((x (+ sector-x a))
                                    (y (+ sector-y b))
                                    (z (+ sector-z c)))
                                (let ((region (sector-region x y z)))
                                  (let ((section (and region (get-section~ (cast <Minecraft-Region> region) x y z))))
                                    (vector-set! sections index section)
                                    section))))))))
                    
                    (define (section-index a <fx> b <fx> c <fx>) <fx>
                      (+ (* (+ b 1) 9) (* (+ c 1) 3) (+ a 1)))
                    
                    (define (cache-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* (+ j 1) 324) (* (+ k 1) 18) (+ i 1)) 2))
                    
                    (define (blocks-get section <Minecraft-Section>) <s8vector>
                      (get-blocks~ section))
                    
                    (define (data-get section <Minecraft-Section>) <s8vector>
                      (get-data~ section))
                    
                    (define (blocklight-get section <Minecraft-Section>) <s8vector>
                      (get-blocklight~ section))
                    
                    (define (skylight-get section <Minecraft-Section>) <s8vector>
                      (get-skylight~ section))
                    
                    (define (normalize-block-id id <fx>) <fx>
                      (if (>= id 0)
                          id
                        0 @w
                        (+ 256 id)))
                    
                    (define (block-ref i <fx> j <fx> k <fx>) <fx>
                      (normalize-block-id (field-ref i j k blocks-get s8vector-ref 0 1)))
                    
                    (define (data-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k data-get s4vector-ref 0 0))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (cache-index i j k)))
                        (let ((value (s8vector-ref cache index)))
                          (if (/= value -1)
                              value
                            ;; need to use data information here
                            (let ((value (block-ref i j k)))
                              (s8vector-set! cache index value)
                              value)))))
                    
                    (define (blocklight-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k blocklight-get s4vector-ref 0 0))
                    
                    (define (skylight-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k skylight-get s4vector-ref 0 0))
                    
                    (define (light-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (+ (cache-index i j k) 1)))
                        (let ((value (s8vector-ref cache index)))
                          (if (/= value -1)
                              value
                            (let ((value (max (blocklight-ref i j k)
                                              (cast <fx> (let ((skylight (skylight-ref i j k)))
                                                           (if (eq? day-cycle 'day)
                                                               skylight
                                                             (- skylight 11)))))))
                              (s8vector-set! cache index value)
                              value)))))
                    
                    (define (s4vector-ref field <s8vector> index <fx>) <fx>
                      (let ((byte (s8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (let ((a 0)
                            (b 0)
                            (c 0))
                        (cond ((< i 0) (set! a -1) (set! i 15))
                              ((> i 15) (set! a 1) (set! i 0)))
                        (cond ((< j 0) (set! b -1) (set! j 15))
                              ((> j 15) (set! b 1) (set! j 0)))
                        (cond ((< k 0) (set! c -1) (set! k 15))
                              ((> k 15) (set! c 1) (set! k 0)))
                        (let ((section (section-ref a b c)))
                          (if (not section)
                              (if (and bottom-section? (= b -1)) bottom empty)
                            (let ((field (get-field section)))
                              (if (not field)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (ref field (index i j k))))))))
                    
                    (define (index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (let ((x (* block-size (cast <fl> section-x)))
                          (y (* block-size (cast <fl> section-y)))
                          (z (* block-size (cast <fl> section-z))))
                      (for (j 0 16)
                           (for (k 0 16)
                                (for (i 0 16)
                                     (let ((block-y (+ section-y j)))
                                       (let ((block-id <fx> (effective-block-ref i j k)))
                                         (when (/= block-id 0)
                                           (let ((x (+ section-x i))
                                                 (y block-y)
                                                 (z (+ section-z k))
                                                 (block (blockid->block block-id)))
                                             (let ((uv (block-texture-coordinates block)))
                                               (let ((x (+ block-radius (* block-size (cast <fl> x))))
                                                     (y (+ block-radius (* block-size (cast <fl> y))))
                                                     (z (+ block-radius (* block-size (cast <fl> z))))
                                                     (transparent? (get-transparent?~ block))
                                                     (generate (get-generate~ block)))
                                                 (define (add-face face <Face>)
                                                   (set! faces (cons face faces))
                                                   (when (eq? what 'physical)
                                                     (let ((center (get-center~ (get-polygon~ face))))
                                                       (let ((area (index-area (position-area-index center) #f)))
                                                         (table-add areas area (get-polygon~ face))))))
                                                 
                                                 (define (add-transparent-face face <Face>)
                                                   (set! faces (cons face faces)))
                                                 
                                                 (define (add-block left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting)
                                                   (unless (opaque? (effective-block-ref (- i 1) j k)) (add-face (left-side   x y z block-radius left-uv lighting)))
                                                   (unless (opaque? (effective-block-ref (+ i 1) j k)) (add-face (right-side  x y z block-radius right-uv lighting)))
                                                   (unless (opaque? (effective-block-ref i (- j 1) k)) (add-face (bottom-side x y z block-radius bottom-uv lighting)))
                                                   (unless (opaque? (effective-block-ref i (+ j 1) k)) (add-face (top-side    x y z block-radius top-uv lighting)))
                                                   (unless (opaque? (effective-block-ref i j (- k 1))) (add-face (back-side   x y z block-radius back-uv lighting)))
                                                   (unless (opaque? (effective-block-ref i j (+ k 1))) (add-face (front-side  x y z block-radius front-uv lighting))))
                                                 
                                                 (define (opaque? block-id <fx>)
                                                   (and (/= block-id 0)
                                                        (not (get-transparent?~ (blockid->block block-id)))))
                                                 
                                                 (define (compute-lighting ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                                                   (+ (light-ref (+ i ax) (+ j ay) (+ k az))
                                                      (light-ref (+ i bx) (+ j by) (+ k bz))
                                                      (light-ref (+ i cx) (+ j cy) (+ k cz))
                                                      (light-ref (+ i dx) (+ j dy) (+ k dz))))
                                                 
                                                 (define (no-lighting ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                                                   0.)
                                                 
                                                 (let ((lighting (if day-cycle compute-lighting no-lighting)))
                                                   (cond (generate
                                                          (generate block-id (data-ref i j k) x y z block-radius uv lighting add-face add-transparent-face add-block))
                                                         (transparent?
                                                          (add-cross-faces x y z block-radius uv lighting add-transparent-face))
                                                         (else
                                                          (add-block uv uv uv uv uv uv lighting))))))))))))))
                    (case what
                      ((physical)
                       (when (eq? self (current-zone))
                         (iterate-table areas
                           (lambda (area <Area> polygons)
                             (add-polygons~ area #f polygons)))))
                      ((render)
                       (let ((faces (list->vector faces)))
                         (receive (vertices neighbors) (prepare-vertices/neighbors~ sector faces)
                           (let ((lightmap (prepare-lightmap~ sector faces)))
                             (post-event
                               (lambda ()
                                 (when (eq? self (current-zone))
                                   (free-mesh~ sector)
                                   (fill-vertices/neighbors~ sector vertices neighbors)
                                   (set-vertices-uptodate?~ sector #t)
                                   (fill-lightmap~ sector lightmap)
                                   (set-lightmap-uptodate?~ sector #t)
                                   (generate-done)))))))))))))))))))
  
  
  (method (generate-sector-heightmap sector <Sector> what)
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (decrease-sectors-generating sector))
    
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region sector-x sector-y sector-z)))
          (if (not region)
              (when (eq? what 'render)
                (generate-done))
            (let ((chunk (get-chunk~ region sector-x sector-z)))
              (if (not chunk)
                  (when (eq? what 'render)
                    (generate-done))
                (if (or (get-heightmap-uptodate?~ chunk)
                        (get-heightmap-generating?~ chunk))
                    (generate-done)
                  (set-heightmap-generating?~ chunk #t)
                  (let ((from-x (* sector-x 16))
                        (width 16)
                        (from-z (* sector-z 16))
                        (depth 16)
                        (heightmap (get-heightmap~ chunk)))
                    (define (index i <fx> k <fx>) <fx>
                      (+ (* k 16) i))
                    
                    (let ((x-count (+ width 1))
                          (z-count (+ depth 1)))
                      (let ((f32heightmap (make-f32vector (* x-count z-count))))
                        (define (f32index i <fx> k <fx>) <fx>
                          (+ (* i z-count) k))
                        
                        (for-to (k 0 16)
                                (for-to (i 0 16)
                                        (let ((height (vector-ref heightmap (index (min i 15) (min k 15)))))
                                          (f32vector-set! f32heightmap (f32index i k) (* (cast <fl> height) 5.)))))
                        (generate-heightmap-content sector f32heightmap from-x width from-z depth what)
                        (set-heightmap-uptodate?~ chunk #t))))))))))))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (method override (target-update target face poly)
    (define (count-chunks)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (when region
              (increase! count (table-length (get-chunks~ region))))))
        count))
    
    (define (count-sections)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (when region
              (iterate-table (get-chunks~ region)
                (lambda (index chunk)
                  (when chunk
                    (increase! count (table-length (get-sections~ chunk)))))))))
        count))
    
    (let ((world (current-world)))
      (if (not poly)
          (with-regions-mutex
            (lambda ()
              (set-information~ world
                (list (format "Regions: {a}" (table-length regions))
                      (format "Chunks: {a}" (count-chunks))
                      (format "Sections: {a}" (count-sections))))))
        (let ((center (vertex+ (get-center~ poly) (vertex-scalar* (get-normal~ poly) -2.5))))
          (let ((sector (position-sector center))
                (area (position-area center))
                (x (fxround (/ (- (vertex-x center) 2.5) 5.)))
                (y (fxround (/ (- (vertex-y center) 2.5) 5.)))
                (z (fxround (/ (- (vertex-z center) 2.5) 5.))))
            (let ((block (vector x y z))
                  (sector-index (get-index~ sector)))
              (let ((sector-x (vector-ref sector-index 0))
                    (sector-y (vector-ref sector-index 1))
                    (sector-z (vector-ref sector-index 2)))
                (let ((region (sector-region sector-x sector-y sector-z)))
                  (let ((section (get-section~ region sector-x sector-y sector-z)))
                    (let ((blocks (get-blocks~ section))
                          (data (get-data~ section))
                          (blocklight (get-blocklight~ section))
                          (skylight (get-skylight~ section)))
                      (define (block-ref i <fx> j <fx> k <fx>)
                        (normalize-block-id (s8vector-ref blocks (+ (* j 256) (* k 16) i))))
                      
                      (define (normalize-block-id id <fx>)
                        (if (>= id 0)
                            id
                          (+ 256 id)))
                      
                      (define (index i <fx> j <fx> k <fx>)
                        (+ (* j 256) (* k 16) i))
                      
                      (define (nibble4 array index)
                        (let ((byte (s8vector-ref array (quotient index 2))))
                          (if (even? index)
                              (bitwise-and byte #x0F)
                            (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                      
                      (define (data-ref i <fx> j <fx> k <fx>)
                        (nibble4 data (index i j k)))
                      
                      (define (blocklight-ref i <fx> j <fx> k <fx>)
                        (nibble4 blocklight (index i j k)))
                      
                      (define (skylight-ref i <fx> j <fx> k <fx>)
                        (nibble4 skylight (index i j k)))
                      
                      (define (block-info i <fx> j <fx> k <fx>)
                        (let ((id (block-ref i j k))
                              (data (data-ref i j k))
                              (blocklight (blocklight-ref i j k))
                              (skylight (skylight-ref i j k)))
                          (let ((block (blockid->block id)))
                            (list (format "Block: {a}" (get-name~ block))
                                  (format "Id: {a}" id)
                                  (format "Data: {a}" data)
                                  (format "BlockLight: {a}" blocklight)
                                  (format "SkyLight: {a}" skylight)
                                  (format "Sector: {a} {a} {a}" sector-x sector-y sector-z)
                                  (format "Coord: {a} {a} {a}" i j k)))))
                      
                      (let ((i (- x (* sector-x 16)))
                            (j (- y (* sector-y 16)))
                            (k (- z (* sector-z 16))))
                        (set-information~ world
                          (append (block-info i j k)
                                  (list "")
                                  (block-info i (+ j 1) k)))))))))))))))


;;;
;;;; Add
;;;


(definition public (left-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting)
  (left-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting))


(definition public (left-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face #f
                         (f32vector tl tt tr tt tr tb tl tb)
                         texture-depth
                         (make-quad #f
                                    (vertex -1. 0. 0.)
                                    (vertex left top back) (vertex left top front) (vertex left bottom front) (vertex left bottom back))
                         (lighting -1  0 -1 -1  0  0 -1  1 -1 -1  1  0)
                         (lighting -1  0  0 -1  0  1 -1  1  0 -1  1  1)
                         (lighting -1 -1  0 -1 -1  1 -1  0  0 -1  0  1)
                         (lighting -1 -1 -1 -1 -1  0 -1  0 -1 -1  0  0))))


(definition public (right-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting)
  (right-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting))


(definition public (right-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face #f
                         (f32vector tl tt tr tt tr tb tl tb)
                         texture-depth
                         (make-quad #f
                                    (vertex 1. 0. 0.)
                                    (vertex right top front) (vertex right top back) (vertex right bottom back) (vertex right bottom front))
                         (lighting  1  0  0  1  0  1  1  1  0  1  1  1)
                         (lighting  1  0 -1  1  0  0  1  1 -1  1  1  0)
                         (lighting  1 -1 -1  1 -1  0  1  0 -1  1  0  0)
                         (lighting  1 -1  0  1 -1  1  1  0  0  1  0  1))))


(definition public (bottom-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting)
  (bottom-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting))


(definition public (bottom-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face #f
                         (f32vector tl tt tr tt tr tb tl tb)
                         texture-depth
                         (make-quad #f
                                    (vertex 0. -1. 0.)
                                    (vertex left bottom front) (vertex right bottom front) (vertex right bottom back) (vertex left bottom back))
                         (lighting -1 -1  0 -1 -1  1  0 -1  0  0 -1  1)
                         (lighting  0 -1  0  0 -1  1  1 -1  0  1 -1  1)
                         (lighting  0 -1 -1  0 -1  0  1 -1 -1  1 -1  0)
                         (lighting -1 -1 -1 -1 -1  0  0 -1 -1  0 -1  0))))


(definition public (top-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting)
  (top-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting))


(definition public (top-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face #f
                         (f32vector tl tb tr tb tr tt tl tt)
                         texture-depth
                         (make-quad #f
                                    (vertex 0. 1. 0.)
                                    (vertex left top back) (vertex right top back) (vertex right top front) (vertex left top front))
                         (lighting -1  1 -1 -1  1  0  0  1 -1  0  1  0)
                         (lighting  0  1 -1  0  1  0  1  1 -1  1  1  0)
                         (lighting  0  1  0  0  1  1  1  1  0  1  1  1)
                         (lighting -1  1  0 -1  1  1  0  1  0  0  1  1))))


(definition public (back-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting)
  (back-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting))


(definition public (back-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face #f
                         (f32vector tr tt tl tt tl tb tr tb)
                         texture-depth
                         (make-quad #f
                                    (vertex 0. 0. -1.)
                                    (vertex right top back) (vertex left top back) (vertex left bottom back) (vertex right bottom back))
                         (lighting  0  0 -1  0  1 -1  1  0 -1  1  1 -1)
                         (lighting -1  0 -1 -1  1 -1  0  0 -1  0  1 -1)
                         (lighting -1 -1 -1 -1  0 -1  0 -1 -1  0  0 -1)
                         (lighting  0 -1 -1  0  0 -1  1 -1 -1  1  0 -1))))


(definition public (front-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting)
  (front-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting))


(definition public (front-face left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> lighting)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (make-minecraft-face #f
                         (f32vector tl tt tr tt tr tb tl tb)
                         texture-depth
                         (make-quad #f
                                    (vertex 0. 0. 1.)
                                    (vertex left top front) (vertex right top front) (vertex right bottom front) (vertex left bottom front))
                         (lighting -1  0  1 -1  1  1  0  0  1  0  1  1)
                         (lighting  0  0  1  0  1  1  1  0  1  1  1  1)
                         (lighting  0 -1  1  0  0  1  1 -1  1  1  0  1)
                         (lighting -1 -1  1 -1  0  1  0 -1  1  0  0  1))))


(definition cross-normal1
  (vertex-normalize (vertex -1. 0. -1.)))

(definition cross-normal2
  (vertex-normalize (vertex 1. 0. -1.)))


(definition public (add-cross-faces x <fl> y <fl> z <fl> radius <fl> uv <f32vector> lighting add-face)
  (let ((left (- x radius))
        (right (+ x radius))
        (bottom (- y radius))
        (top (+ y radius))
        (back (- z radius))
        (front (+ z radius))
        (tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv)))
    (add-face (make-minecraft-face #f
                                   (f32vector tl tt tr tt tr tb tl tb)
                                   texture-depth
                                   (make-quad #f
                                              cross-normal1
                                              (vertex right top back) (vertex left top front) (vertex left bottom front) (vertex right bottom back))
                                   0 0 0 0))
    (add-face (make-minecraft-face #f
                                   (f32vector tl tt tr tt tr tb tl tb)
                                   texture-depth
                                   (make-quad #f
                                              cross-normal2
                                              (vertex right top front) (vertex left top back) (vertex left bottom back) (vertex right bottom front))
                                   0 0 0 0))))


(definition (add-stairs x <fl> y <fl> z <fl> block-radius <fl> uv lighting add-face)
  (let ((left (- x block-radius))
        (right (+ x block-radius))
        (bottom (- y block-radius))
        (top y)
        (back (- z block-radius))
        (front (+ z block-radius)))
    (add-face (left-face   left right bottom top back front uv lighting))
    (add-face (right-face  left right bottom top back front uv lighting))
    (add-face (bottom-face left right bottom top back front uv lighting))
    (add-face (top-face    left right bottom top back front uv lighting))
    (add-face (back-face   left right bottom top back front uv lighting))
    (add-face (front-face  left right bottom top back front uv lighting))))


(definition (add-slab x <fl> y <fl> z <fl> block-radius <fl> uv lighting add-face)
  (let ((left (- x block-radius))
        (right (+ x block-radius))
        (bottom (- y block-radius))
        (top y)
        (back (- z block-radius))
        (front (+ z block-radius)))
    (add-face (left-face   left right bottom top back front uv lighting))
    (add-face (right-face  left right bottom top back front uv lighting))
    (add-face (bottom-face left right bottom top back front uv lighting))
    (add-face (top-face    left right bottom top back front uv lighting))
    (add-face (back-face   left right bottom top back front uv lighting))
    (add-face (front-face  left right bottom top back front uv lighting))))


(definition (add-rail data-id <fx> x <fl> y <fl> z <fl> block-radius <fl> uv lighting add-transparent-face)
  (case (bitwise-and data-id #x7)
    ((0) (add-bottom x y z block-radius uv lighting add-transparent-face))
    ((1) (add-bottom x y z block-radius uv lighting add-transparent-face))
    ((2) (add-right  x y z block-radius uv lighting add-transparent-face))
    ((3) (add-left   x y z block-radius uv lighting add-transparent-face))
    ((4) (add-front  x y z block-radius uv lighting add-transparent-face))
    ((5) (add-back   x y z block-radius uv lighting add-transparent-face))))


(definition add-epsilon <fl>
  .1)


(definition (add-left x <fl> y <fl> z <fl> radius <fl> uv lighting add-transparent-face)
  (add-transparent-face (left-face (+ (- x radius) add-epsilon) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting)))


(definition (add-right x <fl> y <fl> z <fl> radius <fl> uv lighting add-transparent-face)
  (add-transparent-face (right-face (- x radius) (- (+ x radius) add-epsilon) (- y radius) (+ y radius) (- z radius) (+ z radius) uv lighting)))


(definition (add-bottom x <fl> y <fl> z <fl> radius <fl> uv lighting add-transparent-face)
  (add-transparent-face (bottom-face (- x radius) (+ x radius) (+ (- y radius) add-epsilon) (+ y radius) (- z radius) (+ z radius) uv lighting)))


(definition (add-top x <fl> y <fl> z <fl> radius <fl> uv lighting add-transparent-face)
  (add-transparent-face (top-face (- x radius) (+ x radius) (- y radius) (- (+ y radius) add-epsilon) (- z radius) (+ z radius) uv lighting)))


(definition (add-back x <fl> y <fl> z <fl> radius <fl> uv lighting add-transparent-face)
  (add-transparent-face (back-face (- x radius) (+ x radius) (- y radius) (+ y radius) (+ (- z radius) add-epsilon) (+ z radius) uv lighting)))


(definition (add-front x <fl> y <fl> z <fl> radius <fl> uv lighting add-transparent-face)
  (add-transparent-face (front-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (- (+ z radius) add-epsilon) uv lighting)))


(definition (add-transparent data-id left right back front x y z block-radius uv lighting add-transparent-face)
  (ecase data-id
    ((left)  (add-left  x y z block-radius uv lighting add-transparent-face))
    ((right) (add-right x y z block-radius uv lighting add-transparent-face))
    ((back)  (add-back  x y z block-radius uv lighting add-transparent-face))
    (else    (add-front x y z block-radius uv lighting add-transparent-face))))


;;;
;;;; World
;;;


(class Minecraft-World extends World
  
  
  (method override (prepare-tile)
    (define (make-terrain-texture)
      (let ((dir (new-directory~ user-assets "pack")))
        (let ((file (new-file~ dir texture-pack)))
          (let ((mipmap? (find-setting 'minecraft.generate-mipmap? 32)))
            (let ((effective-mipmap? (if (integer? mipmap?) (>= tile-resolution mipmap?) mipmap?)))
              (if (get-texture-arrays?)
                  (receive (image-width image-height pack) (cairo-surface-from-file file)
                    (let ((queue (new-queue))
                          (width tile-resolution)
                          (height tile-resolution)
                          (depth 0))
                      (for (j 0 16)
                           (for (i 0 16)
                                (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
                                  (blit-surface-ext~ surface pack (* i width) (* j height) width height 0 0)
                                  (enqueue queue (list surface width height depth))
                                  (increase! depth))))
                      (let ((surfaces (queue-list queue)))
                        (let ((atlas (if effective-mipmap?
                                         (new Atlas)
                                       (new Atlas min-filter: GL_NEAREST mag-filter: GL_NEAREST mipmap?: #f))))
                          (for-each (lambda (info)
                                      (bind (surface width height depth) info
                                        (add-surface~ atlas surface width height depth)))
                                    surfaces)
                          (complete~ atlas)
                          (for-each (lambda (info)
                                      (bind (surface) info
                                        (close~ surface)))
                                    surfaces)
                          (cairo_surface_destroy pack)
                          (get-texture~ atlas)))))
                (set! texture-mipmap? effective-mipmap?)
                (if effective-mipmap?
                    (make-file-texture file)
                  (make-file-texture file min-filter: GL_NEAREST mag-filter: GL_NEAREST mipmap?: #f))))))))
    
    (nextmethod)
    (if heightmap?
        ;; temp for tests
        (set! default-image "ElwynnFlowerBase")
      (let ((texture (make-terrain-texture)))
        (set! tile-texture texture)
        (set! tile-mesh (new Mesh material: (new Material texture: texture))))))
  
  
  ;;;
  ;;;; Atlas
  ;;;
  
  
  (method override (draw-atlas)
    (let ((width 100.)
          (height 100.))
      (map-texture~ tile-texture)
      (textured-quad~ tile-texture
        (lambda () (glVertex3f 0.0 0.0 0.0))
        (lambda () (glVertex3f width 0.0 0.0))
        (lambda () (glVertex3f width height 0.0))
        (lambda () (glVertex3f 0.0 height 0.0)))))))
