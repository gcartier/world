;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Minecraft
;;;


(module world.external.minecraft jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.system)
        (jazz.ui.window)
        (zlib)
        (world)
        (world.animation)
        (world.atlas)
        (world.autoload)
        (world.binary)
        (world.block)
        (world.dye)
        (world.external)
        (world.external.minecraft-syntax (phase syntax))
        (world.face)
        (world.foreign)
        (world.geometry)
        (world.homogeneous)
        (world.material)
        (world.mesh)
        (world.model)
        (world.quad)
        (world.sector)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle))


(proclaim (warn optimizations))


(constant region-size <fx>
  32)


;;;
;;;; NBT
;;;


(constant TAG_End        <fx>  0)
(constant TAG_Byte       <fx>  1)
(constant TAG_Short      <fx>  2)
(constant TAG_Int        <fx>  3)
(constant TAG_Long       <fx>  4)
(constant TAG_Float      <fx>  5)
(constant TAG_Double     <fx>  6)
(constant TAG_Byte_Array <fx>  7)
(constant TAG_String     <fx>  8)
(constant TAG_List       <fx>  9)
(constant TAG_Compound   <fx> 10)
(constant TAG_Int_Array  <fx> 11)


(class NBT-Stream extends Binary-Stream
  
  
  (method (read-tag read)
    (define (read-tag read)
      (let ((type <fx> (<-u8)))
        (if (= type TAG_End)
            #t
          (let ((name (read-name read)))
            (cond ((not read)
                   (read-data type read)
                   #f)
                  ((eq? read #t)
                   (cons name (read-data type read)))
                  (else
                   (read type name read-data)))))))
    
    (define (read-name read)
      (let ((size <fx> (read-short #t)))
        (cond ((not read)
               (increase! position size))
              ((= size 0)
               "")
              (else
               (<-utf-8-string size)))))
    
    (define (read-data type read)
      (ecase type
        ((TAG_End)        (read-end read))
        ((TAG_Byte)       (read-byte read))
        ((TAG_Short)      (read-short read))
        ((TAG_Int)        (read-int read))
        ((TAG_Long)       (read-long read))
        ((TAG_Float)      (read-float read))
        ((TAG_Double)     (read-double read))
        ((TAG_Byte_Array) (read-byte-array read))
        ((TAG_String)     (read-name read))
        ((TAG_List)       (read-list read))
        ((TAG_Compound)   (read-compound read))
        ((TAG_Int_Array)  (read-int-array read))
        (else (error "Unknown NBT tag: {s}" type))))
    
    (define (read-end read)
      (error "Invalid NBT tag: TAG_End"))
    
    (define (read-byte read)
      (if (not read)
          (increase! position 1)
        (<-s8)))
    
    (define (read-short read)
      (if (not read)
          (increase! position 2)
        (<-s16-big-endian)))
    
    (define (read-int read)
      (if (not read)
          (increase! position 4)
        (<-s32-big-endian)))
    
    (define (read-long read)
      (if (not read)
          (increase! position 8)
        (<-s64-big-endian)))
    
    (define (read-float read)
      (if (not read)
          (increase! position 4)
        (<-float-big-endian)))
    
    (define (read-double read)
      (if (not read)
          (increase! position 8)
        (<-double-big-endian)))
    
    (define (read-byte-array read)
      (let ((size <fx> (read-int #t)))
        (if (not read)
            (increase! position size)
          (let ((data (make-s8vector size)))
            (for (i 0 size)
                 (s8vector-set! data i (read-byte read)))
            data))))
    
    (define (read-int-array read)
      (let ((size <fx> (read-int #t)))
        (if (not read)
            (increase! position (* size 4))
          (let ((data (make-vector size)))
            (for (i 0 size)
                 (vector-set! data i (read-int read)))
            data))))
    
    (define (read-list read)
      (let ((type <fx> (read-byte #t))
            (size <fx> (read-int #t)))
        (loop (repeat size)
              (collect (read-data type read)))))
    
    (define (read-compound read)
      (let ((tag (read-tag read)))
        (cond ((eq? tag #t)
               '())
              ((or (not tag)
                   (not read))
               (read-compound read))
              (else
               (cons tag (read-compound read))))))
    
    (read-tag read)))


;;;
;;;; Block
;;;


(class Minecraft-Block-Model extends Object
  
  
  (slot name                getter generate)
  (slot id                  getter generate)
  (slot subid               getter generate)
  (slot texture             getter generate)
  (slot texture-coordinates accessors generate)
  (slot transparent?        getter generate)
  (slot generate            getter generate)
  
  
  (method override (initialize name id subid texture transparent? generate)
    (set! name~self name)
    (set! id~self id)
    (set! subid~self subid)
    (set! texture~self texture)
    (set! texture-coordinates~self #f)
    (set! transparent?~self transparent?)
    (set! generate~self generate))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition blocks
  (make-table test: eq?))

(definition blockids
  (make-vector 256 #f))


(definition unknown-texture
  #x17)


(definition (register-block name id (texture #f) (transparent? #f) (generate #f))
  (let ((id (if (pair? id) (car id) id))
        (subid (if (pair? id) (cadr id) #f)))
    (when (not subid)
      (let ((texture (case texture
                       ((#f) unknown-texture)
                       (else texture))))
        (let ((block (new Minecraft-Block-Model name id subid texture transparent? generate)))
          (table-set! blocks name block)
          (vector-set! blockids id block))))))


(definition public inline (blockid->block id <fx>) <Minecraft-Block-Model>
  (vector-ref blockids id))


(definition tile-custom <fx+>
  (find-setting 'minecraft.tile-resolution #f))

(definition tile-resolution <fx>
  (or tile-custom 16))

(definition tile-size <fl>
  (cast <fl> tile-resolution))

(definition tile-period <fx>
  16)

(definition texture-size <fl>
  (* tile-size (cast <fl> tile-period)))

(definition texture-pack
  (if (not tile-custom)
      "terrain.png"
    (format "terrain{a}x{a}.png" tile-resolution tile-resolution)))


(definition (block-texture-coordinates block <Minecraft-Block-Model>)
  (or (get-texture-coordinates~ block)
      (let ((coords (rank-texture-coordinates (get-texture~ block))))
        (set-texture-coordinates~ block coords)
        coords)))


(definition pack-mutex
  (make-mutex 'pack))

(definition pack-coordinates
  (make-vector 256 #f))

(definition (get-pack-coordinates pack-rank <fx>)
  (mutex-lock! pack-mutex)
  (prog1 (or (vector-ref pack-coordinates pack-rank)
             (let ((coords (rank-texture-coordinates pack-rank)))
               (vector-set! pack-coordinates pack-rank coords)
               coords))
    (mutex-unlock! pack-mutex)))


(definition (rank-texture-coordinates texture-rank <fx>)
  (let ((x (modulo texture-rank tile-period)))
    (let ((y (/ (- texture-rank x) tile-period)))
      (let ((l (* (cast <fl> x) tile-size))
            (t (* (cast <fl> y) tile-size)))
        (let ((r (+ l tile-size -1.))
              (b (+ t tile-size -1.)))
          (uv (/ (+ l .5) texture-size)
              (/ (+ t .5) texture-size)
              (/ (- r .5) texture-size)
              (/ (- b .5) texture-size)))))))


;;;
;;;; Blocks
;;;


;; helper function for overviewer
;; (define (f x) (format "#x{x}{x}" (quotient x 16) (modulo x 16)))


;; find blocks not defined
;; (define (bnd) (iterate-table blocks (lambda (name block) (when (= (get-texture~ block) #x17) (debug name)))))


(define-block Air
  0
  #f
  #t)

(define-block Stone
  1
  #x00)

(define-block Grass
  2
  #x03
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x88)))
      (add-block center uv uv uv top uv uv))))

(define-block Dirt
  3
  #x02)

(define-block Cobblestone
  4
  #x11)

(define-block WoodenPlank
  5
  #x14)

;; improve with data
(define-block Sapling
  6
  #x3F)

(define-block RedwoodSapling
  (6 1))

(define-block BirchSapling
  (6 2))

(define-block Bedrock
  7
  #x25)

(define-block Water
  8
  #xCD)

(define-block StationaryWater
  9
  #xCD)

(define-block Lava
  10
  #xFF)

(define-block StationaryLava
  11
  #xFF)

(define-block Sand
  12
  #x12)

(define-block Gravel
  13
  #x01)

(define-block GoldOre
  14
  #x20)

(define-block IronOre
  15
  #x10)

(define-block CoalOre
  16
  #x11)

(define-block Wood
  17
  #x04)

(define-block Redwood
  (17 1))

(define-block Birchwood
  (17 2))

(define-block Leaves
  18
  #x34)

(define-block RedwoodLeaves
  (18 1))

(define-block BirchwoodLeaves
  (18 2))

(define-block Sponge
  19
  #x30)

(define-block Glass
  20
  #x31)

(define-block LapisLazuliOre
  21
  #xA0)

(define-block LapisLazuliBlock
  22
  #x90)

(define-block Dispenser
  23
  #x2E)

(define-block Sandstone
  24
  #xB0)

(define-block NoteBlock
  25
  #x4A)

(define-block BedBlock
  26
  #x87)

(define-block PoweredRail
  27
  #xB3)

(define-block DetectorRail
  28
  #xC3)

(define-block StickyPiston
  29
  #x6A)

(define-block Web
  30
  #x0B)

(define-block DeadShrub
  31
  #x5C
  #t)

(define-block TallGrass
  (31 1))

(define-block LiveShrub
  (31 2))

(define-block DeadShrub
  32
  #x37)

(define-block Piston
  33
  #x6A)

;; improve
(define-block PistonHead
  34
  #x6A)

(define-block WhiteWool
  35
  #f
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((uv (get-pack-coordinates (vector-ref Wool-Textures data-id))))
      (add-block center uv uv uv uv uv uv))))

(define Wool-Textures
  #(#x40 ;; White
    #xD2 ;; Orange
    #xC2 ;; Magenta
    #xB2 ;; LightBlue
    #xA2 ;; Yellow
    #x92 ;; LightGreen
    #x82 ;; Pink
    #x72 ;; Gray
    #xE1 ;; LightGray
    #xD1 ;; Cyan
    #xC1 ;; Purple
    #xB1 ;; Blue
    #xA1 ;; Brown
    #x91 ;; DarkGreen
    #x81 ;; Red
    #x71 ;; Black
    ))

(define-block Dandelion
  37
  #x0D
  #t)

(define-block Rose
  38
  #x0C
  #t)

(define-block BrownMushroom
  39
  #x1D
  #t)

(define-block RedMushroom
  40
  #x1C
  #t)

(define-block GoldBlock
  41
  #x30
  @temp-because-this-block-is-used-to-render-unknown
  #x17)

(define-block IronBlock
  42
  #x16)

(define-block DoubleStoneSlab
  43
  #x10)

(define-block DoubleSandstoneSlab
  (43 1))

(define-block DoubleWoodenSlab
  (43 2))

(define-block DoubleCobblestoneSlab
  (43 3))

(define-block DoubleBrickSlab
  (43 4))

(define-block DoubleStoneBrickSlab
  (43 5))

(define-block StoneSlab
  44
  #x06
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-slab center x y z block-radius uv add-face)))

(define-block SandstoneSlab
  (44 1))

(define-block WoodenSlab
  (44 2))

(define-block CobblestoneSlab
  (44 3))

(define-block BrickSlab
  (44 4))

(define-block StoneBrickSlab
  (44 5))

(define-block Brick
  45
  #x07)

(define-block TNT
  46
  #x08
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x09)))
      (add-block center uv uv uv top uv uv))))

(define-block Bookshelf
  47
  #x23
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x04)))
      (add-block center uv uv uv top uv uv))))

(define-block MossyCobblestone
  48
  #x24)

(define-block Obsidian
  49
  #x25)

(define-block Torch
  50
  #x63
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (case data-id
      ((1) (add-transparent-face center (right-side x y z block-radius uv)))
      ((2) (add-transparent-face center (left-side x y z block-radius uv)))
      ((3) (add-transparent-face center (back-side x y z block-radius uv)))
      (else (add-transparent-face center (front-side x y z block-radius uv))))))

(define-block Fire
  51
  #x3D)

(define-block MonsterSpawner
  52
  #x41)

(define-block WoodenStairs
  53
  #x04
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-stairs center x y z block-radius uv add-face)))

(define-block Chest
  54
  #x6B)

(define-block RedstoneWire
  55
  #xA6)

(define-block DiamondOre
  56
  #x32)

(define-block DiamondBlock
  57
  #x18)

(define-block Workbench
  58
  #x4A)

(define-block WheatCrops
  59
  #x5F
  #t)

(define-block Soil
  60
  #x02)

(define-block Furnace
  61
  #x2C)

(define-block BurningFurnace
  62
  #x3D)

(define-block SignPost
  63
  #x50
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-transparent-face center (right-side x y z block-radius uv))))

(define-block WoodenDoorBlock
  64
  #x51)

(define-block Ladder
  65
  #x53)

(define-block Rails
  66
  #x80)

(define-block CobblestoneStairs
  67
  #x10
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((l (- x block-radius))
          (r (+ x block-radius))
          (b (- y block-radius))
          (t y)
          (f (- z block-radius))
          (n (+ z block-radius)))
      (add-face center (left-face   l r b t f n uv))
      (add-face center (right-face  l r b t f n uv))
      (add-face center (bottom-face l r b t f n uv))
      (add-face center (top-face    l r b t f n uv))
      (add-face center (back-face   l r b t f n uv))
      (add-face center (front-face  l r b t f n uv)))))

(define-block WallSign
  68
  #x50
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-transparent-face center (right-side x y z block-radius uv))))

;; improve
(define-block Lever
  69
  #x60)

(define-block StonePressurePlate
  70
  #x06
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((l (- x block-radius))
          (r (+ x block-radius))
          (b (- y block-radius))
          (t y)
          (f (- z block-radius))
          (n (+ z block-radius)))
      (add-face center (left-face   l r b t f n uv))
      (add-face center (right-face  l r b t f n uv))
      (add-face center (bottom-face l r b t f n uv))
      (add-face center (top-face    l r b t f n uv))
      (add-face center (back-face   l r b t f n uv))
      (add-face center (front-face  l r b t f n uv)))))

(define-block IronDoorBlock
  71
  #x52)

(define-block WoodenPressurePlate
  72
  #x04
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((l (- x block-radius))
          (r (+ x block-radius))
          (b (- y block-radius))
          (t y)
          (f (- z block-radius))
          (n (+ z block-radius)))
      (add-face center (left-face   l r b t f n uv))
      (add-face center (right-face  l r b t f n uv))
      (add-face center (bottom-face l r b t f n uv))
      (add-face center (top-face    l r b t f n uv))
      (add-face center (back-face   l r b t f n uv))
      (add-face center (front-face  l r b t f n uv)))))

(define-block RedstoneOre
  73
  #x33)

(define-block GlowingRedstoneOre
  74
  #x33)

(define-block RedstoneTorchOff
  75
  #x73)

(define-block RedstoneTorchOn
  76
  #x63)

(define-block StoneButton
  77
  #x9F)

(define-block Snow
  78
  #x40
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((l (- x block-radius))
          (r (+ x block-radius))
          (b (- y block-radius))
          (t (+ (- y block-radius) .625))
          (f (- z block-radius))
          (n (+ z block-radius)))
      (add-face center (left-face   l r b t f n uv))
      (add-face center (right-face  l r b t f n uv))
      (add-face center (bottom-face l r b t f n uv))
      (add-face center (top-face    l r b t f n uv))
      (add-face center (back-face   l r b t f n uv))
      (add-face center (front-face  l r b t f n uv)))))

(define-block Ice
  79
  #x43)

(define-block SnowBlock
  80
  #x40)

(define-block Cactus
  81
  #x46)

(define-block Clay
  82
  #x48)

(define-block SugarCane
  83
  #x49)

(define-block Jukebox
  84
  #x4A
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x4B)))
      (add-block center uv uv uv top uv uv))))

(define-block Fence
  85
  #x55)

(define-block Pumpkin
  86
  #x77
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x66)))
      (add-block center uv uv uv top uv uv))))

(define-block Netherrack
  87
  #x67)

(define-block SoulSand
  88
  #x68)

(define-block Glowstone
  89
  #x69)

;; improve
(define-block Portal
  90
  #x0E)

(define-block Jack-O-Lantern
  91
  #x66)

(define-block CakeBlock
  92
  #x79)

;; improve
(define-block RedstoneRepeaterBlockOff
  93
  #x83)

;; improve
(define-block RedstoneRepeaterBlockOn
  94
  #x93)

;; improve
(define-block LockedChest
  95
  #x6B)

(define-block Trapdoor
  96
  #x41)

;; improve with data
(define-block StoneSilverfish
  97
  #x01)

(define-block CobblestoneSilverfish
  (97 1))

(define-block StoneBrickSilverfish
  (97 2))

(define-block StoneBrick
  98
  #x65)

(define-block MossyStoneBrick
  (98 1))

(define-block CrackedStoneBrick
  (98 2))

(define-block RedMushroomCap
  99
  #x7D)

(define-block BrownMushroomCap
  100
  #x7E)

(define-block IronBars
  101
  #x55)

(define-block GlassPane
  102
  #x42)

(define-block MelonBlock
  103
  #x88
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x89)))
      (add-block center uv uv uv top uv uv))))

(define-block PumpkinStem
  104
  #x6F)

(define-block MelonStem
  105
  #x6F)

(define-block Vines
  106
  #x1E)

(define-block FenceGate
  107
  #x55)

(define-block BrickStairs
  108
  #x07
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-stairs center x y z block-radius uv add-face)))

(define-block StoneBrickStairs
  109
  #x36
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-stairs center x y z block-radius uv add-face)))

(define-block Mycelium
  110
  #x4D
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x4E)))
      (add-block center uv uv uv top uv uv))))

(define-block LilyPad
  111
  #x4C)

(define-block NetherBrick
  112
  #xE0)

(define-block NetherBrickFence
  113
  #x55)

(define-block NetherBrickStairs
  114
  #xE0
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-stairs center x y z block-radius uv add-face)))

;; improve
(define-block NetherWart
  115
  #xE3)

(define-block EnchantmentTable
  116
  #xB6
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #xA6)))
      (add-block center uv uv uv top uv uv))))

(define-block BrewingStand
  117
  #x9C)

(define-block Cauldron
  118
  #x9A
  #f
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (let ((top (get-pack-coordinates #x8A)))
      (add-block center uv uv uv top uv uv))))

;; improve
(define-block EndPortal
  119
  #x06
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-slab center x y z block-radius uv add-face)))

(define-block EndPortalFrame
  120
  #x9E)

(define-block EndStone
  121
  #xAF)

;; improve
(define-block DragonEgg
  122
  #x25)

(define-block RedstoneLampInactive
  123
  #xD3)

(define-block RedstoneLampActive
  124
  #xD4)

;; improve
(define-block DoubleWoodenSlab
  125
  #x04
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-slab center x y z block-radius uv add-face)))

(define-block WoodenSlab
  126
  #x04
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-slab center x y z block-radius uv add-face)))

(define-block CocoaPlant
  127
  #xA8)

(define-block SandstoneStairs
  128
  #xC0
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-stairs center x y z block-radius uv add-face)))

(define-block EmeraldOre
  129
  #xAB)

;; improve
(define-block EnderChest
  130
  #x02)

;; improve
(define-block TripwireHook
  131
  #x02)

;; improve
(define-block Tripwire
  132
  #x02)

(define-block EmeraldBlock
  133
  #x19)

(define-block SpruceWoodStairs
  134
  #xC6
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-stairs center x y z block-radius uv add-face)))

(define-block BirchWoodStairs
  135
  #xD6
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-stairs center x y z block-radius uv add-face)))

(define-block JungleWoodStairs
  136
  #xC7
  #t
  (lambda (block-id data-id center x y z block-radius uv add-face add-transparent-face add-block)
    (add-stairs center x y z block-radius uv add-face)))

;; improve
(define-block CommandBlock
  137
  #x02)

;; improve
(define-block BeaconBlock
  138
  #x02)

;; improve
(define-block CobblestoneWall
  139
  #x02)

;; improve
(define-block FlowerPot
  140
  #x02)

;; improve
(define-block Carrots
  141
  #x02)

;; improve
(define-block Potatoes
  142
  #x02)

;; improve
(define-block WoodenButton
  143
  #x02)


(for (id 0 256)
     (unless (vector-ref blockids id)
       (register-block 'Unknown id)))


(definition (add-stairs center x y z block-radius uv add-face)
  (let ((l (- x block-radius))
        (r (+ x block-radius))
        (b (- y block-radius))
        (t y)
        (f (- z block-radius))
        (n (+ z block-radius)))
    (add-face center (left-face   l r b t f n uv))
    (add-face center (right-face  l r b t f n uv))
    (add-face center (bottom-face l r b t f n uv))
    (add-face center (top-face    l r b t f n uv))
    (add-face center (back-face   l r b t f n uv))
    (add-face center (front-face  l r b t f n uv))))


(definition (add-slab center x y z block-radius uv add-face)
  (let ((l (- x block-radius))
        (r (+ x block-radius))
        (b (- y block-radius))
        (t y)
        (f (- z block-radius))
        (n (+ z block-radius)))
    (add-face center (left-face   l r b t f n uv))
    (add-face center (right-face  l r b t f n uv))
    (add-face center (bottom-face l r b t f n uv))
    (add-face center (top-face    l r b t f n uv))
    (add-face center (back-face   l r b t f n uv))
    (add-face center (front-face  l r b t f n uv))))


;;;
;;;; Section
;;;


(class Minecraft-Section extends Object
  
  
  (slot blocks     getter generate)
  (slot data       getter generate)
  (slot blocklight getter generate)
  
  
  (method override (initialize blocks data blocklight)
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)))


;;;
;;;; Chunk
;;;


(class Minecraft-Chunk extends Object
  
  
  (slot entities getter generate)
  (slot sections getter generate)
  
  
  (method override (initialize entities sections)
    (set! entities~self entities)
    (set! sections~self sections)))


;;;
;;;; Region
;;;


(class Minecraft-Region extends Object
  
  
  (slot x            <fx>                                            getter generate)
  (slot z            <fx>                                            getter generate)
  (slot port         <port>                                          getter generate)
  (slot header       <u8vector>                                      getter generate)
  (slot chunks-mutex <object>   initialize (make-mutex 'chunks)      getter generate)
  (slot chunks       <table>    initialize (make-table test: equal?) getter generate)
  
  
  (method override (initialize x z port)
    (set! x~self x)
    (set! z~self z)
    (set! port~self port)
    (set! header (read-header)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" x z))))
  
  
  (method override (destroy)
    (close-port port)
    (nextmethod))
  
  
  (method (read-header)
    (let ((size (* 8 1024)))
      (let ((content (make-u8vector size)))
        (read-subu8vector content 0 size port)
        content)))
  
  
  (method (with-chunks-mutex thunk)
    (mutex-lock! chunks-mutex)
    (prog1 (thunk)
      (mutex-unlock! chunks-mutex)))
  
  
  (method (get-chunk x <fx> z <fx>) <Minecraft-Chunk+>
    (with-chunks-mutex
      (lambda ()
        (let ((chunk-index (chunk-index x z)))
          (or (table-ref chunks chunk-index #f)
              (let ((chunk (read-chunk chunk-index)))
                (table-set! chunks chunk-index chunk)
                chunk))))))
  
  
  (method (chunk-index x <fx> z <fx>) <pair>
    ;; looks like we don't need to adjust for negative values like stated on the wiki
    (cons (modulo x 32)
          (modulo z 32)))
  
  
  (method (read-chunk chunk-index <pair>) <Minecraft-Chunk+>
    (let ((zone (current-zone))
          (x <fx> (car chunk-index))
          (z <fx> (cdr chunk-index)))
      (let ((offset (* 4 (+ x (* z 32)))))
        (assert (<= offset 4092))
        (let ((b1 (u8vector-ref header offset))
              (b2 (u8vector-ref header (+ offset 1)))
              (b3 (u8vector-ref header (+ offset 2)))
              (b4 (u8vector-ref header (+ offset 3))))
          (if (and (= b1 0)
                   (= b2 0)
                   (= b3 0)
                   (= b4 0))
              #f
            (let ((offset (* (+ (cast <fx> (arithmetic-shift b1 16))
                                (cast <fx> (arithmetic-shift b2 8))
                                b3)
                             (* 4 1024))))
              (input-port-byte-position port offset)
              (let ((chunk-header (make-u8vector 5)))
                (read-subu8vector chunk-header 0 5 port)
                (let ((size <fx> (scan-u32-big-endian chunk-header 0))
                      (compression-type (u8vector-ref chunk-header 4)))
                  ;; skip two bytes for deflate
                  (read-u8 port)
                  (read-u8 port)
                  (let ((chunk-raw (make-u8vector size)))
                    (read-subu8vector chunk-raw 0 size port)
                    (let ((chunk-data (inflate-u8vector chunk-raw)))
                      (let ((s (new NBT-Stream (cons chunk-data 0))))
                        (let ((tag-data
                                (read-tag~ s
                                  (lambda (type name read-data)
                                    (read-data type
                                      (lambda (type name read-data)
                                        (read-data type
                                          (lambda (type name read-data)
                                            (cond @wait ((equal? name "Entities")
                                                         (cons name (read-data type #t)))
                                                  ((equal? name "Sections")
                                                   (cons name (read-data type
                                                                (lambda (type name read-data)
                                                                  (if (or (equal? name "Y")
                                                                          (equal? name "Blocks")
                                                                          (equal? name "Data")
                                                                          (equal? name "BlockLight"))
                                                                      (cons name (read-data type #t))
                                                                    (read-data type #f)
                                                                    #f)))))
                                                  (else
                                                   (read-data type #f)
                                                   #f))))))))))
                          (let ((alist (car tag-data)))
                            (let ((entities (assoc "Entities" alist))
                                  (sections (assoc "Sections" alist)))
                              (let ((sections-table (and sections (make-table test: eq?))))
                                (when sections-table
                                  (let ((truncate-y (get-truncate-y~ zone)))
                                    (for-each (lambda (section)
                                                (let ((yPos (- (cdr (assoc "Y" section)) 4)) ;; lower everything by 64
                                                      (blocks (cdr (assoc "Blocks" section)))
                                                      (data (cdr (assoc "Data" section)))
                                                      (blocklight (cdr (assoc "BlockLight" section))))
                                                  (when (or (not truncate-y)
                                                            (>= yPos truncate-y))
                                                    (table-set! sections-table yPos (new Minecraft-Section blocks data blocklight)))))
                                              (cdr sections))))
                                (new Minecraft-Chunk
                                  (and entities (cdr entities))
                                  sections-table))))))))))))))))
  
  
  (method (get-section x <fx> y <fx> z <fx>)
    (let ((chunk (get-chunk x z)))
      (when chunk
        (let ((sections (get-sections~ chunk)))
          (when sections
            (table-ref sections y #f))))))
  
  
  (method (get-blocks x <fx> y <fx> z <fx>) <s8vector+>
    (let ((section (get-section x y z)))
      (when section
        (get-blocks~ section)))))


;;;
;;;; Level
;;;


(definition public (import-minecraft-level file)
  (let ((s (new NBT-Stream file)))
    (read-tag~ s #t)))


;;;
;;;; Sector
;;;


(class Minecraft-Sector extends Sector
  
  
  (method override (initialize index center)
    (nextmethod index center)
    (set! physical-uptodate? #f)))


;;;
;;;; Zone
;;;


(definition generate-count <fl>
  0.)

(definition generate-total <fl>
  0.)


(definition public (generate-average)
  (/ generate-total generate-count))


(class Minecraft-Zone extends Zone
  
  
  (property level-dir  <Directory> initialize #f accessors generate)
  (property truncate-y <fx+>       initialize #f accessors generate)
  
  
  (slot regions-dir   <Directory> initialize #f                        getter explicit)
  (slot regions-mutex <object>    initialize (make-mutex 'regions)     getter generate)
  (slot regions       <table>     initialize (make-table test: equal?) getter generate)
  
  
  (form
    (<install> floor-level: -500.))
  
  
  (method override (sector-class)
    Minecraft-Sector)
  
  
  (method (with-regions-mutex thunk)
    (mutex-lock! regions-mutex)
    (prog1 (thunk)
      (mutex-unlock! regions-mutex)))
  
  
  (method (close-regions)
    (with-regions-mutex
      (lambda ()
        (iterate-table regions
          (lambda (index region)
            (close~ region)))
        (empty-table regions))))
  
  
  (method (get-regions-dir) <Directory>
    (or regions-dir (let ((dir (new-directory~ level-dir "region")))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method (get-region region-index <pair>) <Minecraft-Region+>
    (define (region-name)
      (bind (region-x . region-z) region-index
        (format "r.{a}.{a}.mca" region-x region-z)))
    
    (with-regions-mutex
      (lambda ()
        (let ((value (table-ref regions region-index #t)))
          (if (neq? value #t)
              value
            (let ((dir (get-regions-dir))
                  (name (region-name)))
              (let ((file (new-file~ dir name)))
                (let ((region (if (exists?~ file)
                                  (bind (region-x . region-z) region-index
                                    (let ((port (open-input-file (path-settings file))))
                                      (new Minecraft-Region region-x region-z port)))
                                #f)))
                  (table-set! regions region-index region)
                  region))))))))
  
  
  (method (sector-region sector-x <fx> sector-y <fx> sector-z <fx>) <Minecraft-Region+>
    (define (region-index)
      (cons (fxfloor/ sector-x region-size)
            (fxfloor/ sector-z region-size)))
    
    (get-region (region-index)))
  
  
  (method (sector-blocks sector-x <fx> sector-y <fx> sector-z <fx>) <s8vector+>
    (let ((region (sector-region sector-x sector-y sector-z)))
      (when region
        (get-blocks~ region sector-x sector-y sector-z))))
  
  
  (method override (generate-content?)
    #t)
  
  
  (method override (generate-content sector <Sector> priority)
    (define (generate)
      (if (get-content-uptodate?~ sector)
          (decrease-sectors-generating)
        (let ((world (current-world)))
          (let ((view-radius (* sector-radius (get-view-distance~ world))))
            (if (> (f32-ref (vertex-distance& (get-eye~ world) (get-center~ sector))) view-radius)
                (begin
                  (set-content-priority~ sector #f)
                  (decrease-sectors-generating))
              (let ((before (real-time)))
                (generate-sector sector 'render)
                (let ((after (real-time)))
                  (let ((duration (- after before)))
                    (set! generate-count (+ generate-count 1.))
                    (set! generate-total (+ generate-total duration))))))))))
    
    (let ((mesh (get-mesh~ sector)))
      (free-vertices~ mesh)
      (free-neighbors~ mesh)
      (set-vertices-uptodate?~ sector #t)
      (free-lightmap~ mesh)
      (set-lightmap-uptodate?~ sector #t))
    
    (if (find-setting 'world.generate-threaded? #t)
        (begin
          (increase-sectors-generating)
          (if (= priority 1)
              (post-priority-content generate)
            (post-content generate)))
      (generate)))
  
  
  (method override (generate-physical sector <Sector>)
    (generate-sector sector 'physical))
  
  
  (method (generate-sector sector <Sector> what)
    (define (generate-done)
      (set-content-priority~ sector #f)
      (set-content-uptodate?~ sector #t)
      (decrease-sectors-generating))
    
    (when (eq? self (current-zone))
      (let ((sector-index (get-index~ sector)))
        (let ((sector-x (vector-ref sector-index 0))
              (sector-y (vector-ref sector-index 1))
              (sector-z (vector-ref sector-index 2)))
          (let ((region (sector-region sector-x sector-y sector-z)))
            (if (not region)
                (when (eq? what 'render)
                  (generate-done))
              (let ((region-x (get-x~ region))
                    (region-z (get-z~ region))
                    (section (get-section~ region sector-x sector-y sector-z))
                    (chunk-index (chunk-index~ region sector-x sector-z)))
                (assert (= region-x (fxfloor/ sector-x region-size)))
                (assert (= region-z (fxfloor/ sector-z region-size)))
                (if (not section)
                    (when (eq? what 'render)
                      (generate-done))
                  (let* ((yPos (fxfloor/ sector-y region-size))
                         (blocks (get-blocks~ section))
                         (data (get-data~ section))
                         (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                         (section-y (* sector-y 16))
                         (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                         (block-size 5.)
                         (block-radius (/ block-size 2.))
                         (block-radiuses (vertex block-radius block-radius block-radius))
                         (faces '())
                         (areas (make-table test: eq?)))
                    (define (block-ref i <fx> j <fx> k <fx>)
                      (normalize-id (s8vector-ref blocks (+ (* j 256) (* k 16) i))))
                    
                    (define (blocks-ref blocks <s8vector> i <fx> j <fx> k <fx>)
                      (normalize-id (s8vector-ref blocks (+ (* j 256) (* k 16) i))))
                    
                    (define (normalize-id id <fx>)
                      (if (>= id 0)
                          id
                        (+ 256 id)))
                    
                    (define (index i <fx> j <fx> k <fx>)
                      (+ (* j 256) (* k 16) i))
                    
                    (define (nibble4 array index)
                      (let ((byte (s8vector-ref array (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift byte -4) #x0F))))
                    
                    (define (data-ref i <fx> j <fx> k <fx>)
                      (nibble4 data (index i j k)))
                    
                    (define (left-ref i <fx> j <fx> k <fx>)
                      (if (> i 0)
                          (block-ref (- i 1) j k)
                        (let ((blocks (sector-blocks (- sector-x 1) sector-y sector-z)))
                          (if (not blocks)
                              0
                            (blocks-ref blocks 15 j k)))))
                    
                    (define (right-ref i <fx> j <fx> k <fx>)
                      (if (< i 15)
                          (block-ref (+ i 1) j k)
                        (let ((blocks (sector-blocks (+ sector-x 1) sector-y sector-z)))
                          (if (not blocks)
                              0
                            (blocks-ref blocks 0 j k)))))
                    
                    (define (bottom-ref i <fx> j <fx> k <fx>)
                      (if (> j 0)
                          (block-ref i (- j 1) k)
                        (let ((blocks (sector-blocks sector-x (- sector-y 1) sector-z)))
                          (if (not blocks)
                              0
                            (blocks-ref blocks i 15 k)))))
                    
                    (define (top-ref i <fx> j <fx> k <fx>)
                      (if (< j 15)
                          (block-ref i (+ j 1) k)
                        (let ((blocks (sector-blocks sector-x (+ sector-y 1) sector-z)))
                          (if (not blocks)
                              0
                            (blocks-ref blocks i 0 k)))))
                    
                    (define (back-ref i <fx> j <fx> k <fx>)
                      (if (> k 0)
                          (block-ref i j (- k 1))
                        (let ((blocks (sector-blocks sector-x sector-y (- sector-z 1))))
                          (if (not blocks)
                              0
                            (blocks-ref blocks i j 15)))))
                    
                    (define (front-ref i <fx> j <fx> k <fx>)
                      (if (< k 15)
                          (block-ref i j (+ k 1))
                        (let ((blocks (sector-blocks sector-x sector-y (+ sector-z 1))))
                          (if (not blocks)
                              0
                            (blocks-ref blocks i j 0)))))
                    
                    (let ((x (* block-size (cast <fl> section-x)))
                          (y (* block-size (cast <fl> section-y)))
                          (z (* block-size (cast <fl> section-z))))
                      (for (j 0 16)
                           (for (k 0 16)
                                (for (i 0 16)
                                     (let ((block-y (+ section-y j)))
                                       (let ((block-id <fx> (block-ref i j k)))
                                         (when (/= block-id 0)
                                           (let ((x (+ section-x i))
                                                 (y block-y)
                                                 (z (+ section-z k))
                                                 (block (blockid->block block-id)))
                                             (let ((uv (block-texture-coordinates block)))
                                               (let ((x (+ block-radius (* block-size (cast <fl> x))))
                                                     (y (+ block-radius (* block-size (cast <fl> y))))
                                                     (z (+ block-radius (* block-size (cast <fl> z))))
                                                     (transparent? (get-transparent?~ block))
                                                     (generate (get-generate~ block)))
                                                 (define (add-face center <f32vector> face <Face>)
                                                   (set! faces (cons face faces))
                                                   (when (eq? what 'physical)
                                                     (let ((area (index-area (position-area-index center) #f)))
                                                       (table-add areas area (get-polygon~ face)))))
                                                 
                                                 (define (add-transparent-face center <f32vector> face <Face>)
                                                   (set! faces (cons face faces)))
                                                 
                                                 (define (add-block center <f32vector> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector>)
                                                   (unless (opaque? (left-ref   i j k)) (add-face center (left-side   x y z block-radius left-uv)))
                                                   (unless (opaque? (right-ref  i j k)) (add-face center (right-side  x y z block-radius right-uv)))
                                                   (unless (opaque? (bottom-ref i j k)) (add-face center (bottom-side x y z block-radius bottom-uv)))
                                                   (unless (opaque? (top-ref    i j k)) (add-face center (top-side    x y z block-radius top-uv)))
                                                   (unless (opaque? (back-ref   i j k)) (add-face center (back-side   x y z block-radius back-uv)))
                                                   (unless (opaque? (front-ref  i j k)) (add-face center (front-side  x y z block-radius front-uv))))
                                                 
                                                 (define (opaque? block-id <fx>)
                                                   (and (/= block-id 0)
                                                        (not (get-transparent?~ (blockid->block block-id)))))
                                                 
                                                 (let ((center (vertex x y z)))
                                                   (cond (generate
                                                          (generate block-id (data-ref i j k) center x y z block-radius uv add-face add-transparent-face add-block))
                                                         (transparent?
                                                          (add-cross-faces x y z block-radius uv center add-transparent-face))
                                                         (else
                                                          (add-block center uv uv uv uv uv uv))))))))))))))
                    (case what
                      ((physical)
                       (when (eq? self (current-zone))
                         (iterate-table areas
                           (lambda (area polygons)
                             (add-polygons~ area #f polygons)))))
                      ((render)
                       (let ((faces (list->vector faces)))
                         (receive (vertices neighbors) (prepare-vertices/neighbors~ sector faces)
                           (let ((lightmap (prepare-lightmap~ sector faces)))
                             (post-event
                               (lambda ()
                                 (when (eq? self (current-zone))
                                   (fill-vertices/neighbors~ sector vertices neighbors)
                                   (set-vertices-uptodate?~ sector #t)
                                   (fill-lightmap~ sector lightmap)
                                   (set-lightmap-uptodate?~ sector #t)
                                   (generate-done))))))))))))))))))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (method override (target-update target face poly)
    (define (count-chunks)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (increase! count (table-length (get-chunks~ region)))))
        count))
    
    (define (count-sections)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (iterate-table (get-chunks~ region)
              (lambda (index chunk)
                (increase! count (table-length (get-sections~ chunk)))))))
        count))
    
    (let ((world (current-world)))
      (if (not poly)
          (with-regions-mutex
            (lambda ()
              (set-information~ world
                (list (format "Regions: {a}" (table-length regions))
                      (format "Chunks: {a}" (count-chunks))
                      (format "Sections: {a}" (count-sections))))))
        (let ((center (vertex+ (get-center~ poly) (vertex-scalar* (get-normal~ poly) -2.5))))
          (let ((sector (position-sector center))
                (area (position-area center))
                (x (fxround (/ (- (vertex-x center) 2.5) 5.)))
                (y (fxround (/ (- (vertex-y center) 2.5) 5.)))
                (z (fxround (/ (- (vertex-z center) 2.5) 5.))))
            (let ((block (vector x y z))
                  (sector-index (get-index~ sector)))
              (let ((sector-x (vector-ref sector-index 0))
                    (sector-y (vector-ref sector-index 1))
                    (sector-z (vector-ref sector-index 2)))
                (let ((region (sector-region sector-x sector-y sector-z)))
                  (let ((section (get-section~ region sector-x sector-y sector-z)))
                    (let ((blocks (get-blocks~ section))
                          (data (get-data~ section))
                          (blocklight (get-blocklight~ section)))
                      (define (block-ref i <fx> j <fx> k <fx>)
                        (normalize-id (s8vector-ref blocks (+ (* j 256) (* k 16) i))))
                      
                      (define (normalize-id id <fx>)
                        (if (>= id 0)
                            id
                          (+ 256 id)))
                      
                      (define (index i <fx> j <fx> k <fx>)
                        (+ (* j 256) (* k 16) i))
                      
                      (define (nibble4 array index)
                        (let ((byte (s8vector-ref array (quotient index 2))))
                          (if (even? index)
                              (bitwise-and byte #x0F)
                            (bitwise-and (arithmetic-shift byte -4) #x0F))))
                      
                      (define (data-ref i <fx> j <fx> k <fx>)
                        (nibble4 data (index i j k)))
                      
                      (define (blocklight-ref i <fx> j <fx> k <fx>)
                        (nibble4 blocklight (index i j k)))
                      
                      (let ((i (- x (* sector-x 16)))
                            (j (- y (* sector-y 16)))
                            (k (- z (* sector-z 16))))
                        (let ((id (block-ref i j k))
                              (data (data-ref i j k))
                              (light (blocklight-ref i j k)))
                          (let ((block (blockid->block id)))
                            (set-information~ world
                              (list (format "Block: {a}" (get-name~ block))
                                    (format "Id: {a}" id)
                                    (format "Data: {a}" data)
                                    (format "Light: {a}" light)
                                    (format "Sector: {a} {a} {a}" sector-x sector-y sector-z)
                                    (format "Coord: {a} {a} {a}" i j k)))))))))))))))))


(definition public (left-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector>)
  (left-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv))


(definition public (left-face l <fl> r <fl> b <fl> t <fl> f <fl> n <fl> uv <f32vector>)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (make-face #f
               (f32vector tl tt tr tt tr tb tl tb)
               (make-quad #f
                          (vertex -1. 0. 0.)
                          (vertex l t f) (vertex l t n) (vertex l b n) (vertex l b f)))))


(definition public (right-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector>)
  (right-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv))


(definition public (right-face l <fl> r <fl> b <fl> t <fl> f <fl> n <fl> uv <f32vector>)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (make-face #f
               (f32vector tl tt tr tt tr tb tl tb)
               (make-quad #f
                          (vertex 1. 0. 0.)
                          (vertex r t n) (vertex r t f) (vertex r b f) (vertex r b n)))))


(definition public (bottom-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector>)
  (bottom-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv))


(definition public (bottom-face l <fl> r <fl> b <fl> t <fl> f <fl> n <fl> uv <f32vector>)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (make-face #f
               (f32vector tl tt tr tt tr tb tl tb)
               (make-quad #f
                          (vertex 0. -1. 0.)
                          (vertex l b n) (vertex r b n) (vertex r b f) (vertex l b f)))))


(definition public (top-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector>)
  (top-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv))


(definition public (top-face l <fl> r <fl> b <fl> t <fl> f <fl> n <fl> uv <f32vector>)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (make-face #f
               (f32vector tl tb tr tb tr tt tl tt)
               (make-quad #f
                          (vertex 0. 1. 0.)
                          (vertex l t f) (vertex r t f) (vertex r t n) (vertex l t n)))))


(definition public (back-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector>)
  (back-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv))


(definition public (back-face l <fl> r <fl> b <fl> t <fl> f <fl> n <fl> uv <f32vector>)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (make-face #f
               (f32vector tr tt tl tt tl tb tr tb)
               (make-quad #f
                          (vertex 0. 0. -1.)
                          (vertex r t f) (vertex l t f) (vertex l b f) (vertex r b f)))))


(definition public (front-side x <fl> y <fl> z <fl> radius <fl> uv <f32vector>)
  (front-face (- x radius) (+ x radius) (- y radius) (+ y radius) (- z radius) (+ z radius) uv))


(definition public (front-face l <fl> r <fl> b <fl> t <fl> f <fl> n <fl> uv <f32vector>)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (make-face #f
               (f32vector tl tt tr tt tr tb tl tb)
               (make-quad #f
                          (vertex 0. 0. 1.)
                          (vertex l t n) (vertex r t n) (vertex r b n) (vertex l b n)))))


(definition cross-normal1
  (vertex-normalize (vertex -1. 0. -1.)))

(definition cross-normal2
  (vertex-normalize (vertex 1. 0. -1.)))


(definition public (add-cross-faces x <fl> y <fl> z <fl> radius <fl> uv <f32vector> center <f32vector> add-face)
  (let ((l (- x radius))
        (r (+ x radius))
        (b (- y radius))
        (t (+ y radius))
        (f (- z radius))
        (n (+ z radius))
        (tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (add-face center
      (make-face #f
                 (f32vector tl tt tr tt tr tb tl tb)
                 (make-quad #f
                            cross-normal1
                            (vertex r t f) (vertex l t n) (vertex l b n) (vertex r b f))))
    (add-face center
      (make-face #f
                 (f32vector tl tt tr tt tr tb tl tb)
                 (make-quad #f
                            cross-normal2
                            (vertex r t n) (vertex l t f) (vertex l b f) (vertex r b n))))))


;;;
;;;; World
;;;


(class Minecraft-World extends World
  
  
  (method override (prepare-tile)
    (define (make-terrain-texture)
      (let ((dir (new-directory~ user-assets "pack")))
        (let ((file (new-file~ dir texture-pack)))
          (let ((mipmap? (find-setting 'minecraft.mipmap? (> tile-resolution 16))))
            (if mipmap?
                (make-file-texture file)
              (make-file-texture file min-filter: GL_NEAREST mag-filter: GL_NEAREST mipmap?: #f))))))
    
    (nextmethod)
    (let ((texture (make-terrain-texture)))
      (set! tile-texture texture)
      (set! tile-mesh (new Mesh material: (new Material texture: texture)))))))
