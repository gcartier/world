;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Minecraft
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Édouard Hébert


;; BUG
;; in dwarft at spawn point
;; {Minecraft-Region -1 0 #70}
;; chunk-index == '(30 . 5)
;; in deserialize-chunk at (cast <fx> (tag-assoc "Y" section))
;; failed <fx> assertion of #f
;; (map (lambda (s) (map car s)) sections)
;; (("Data" "SkyLight" "BlockLight" "Y" "Blocks")
;;  ("Data" "SkyLight" "BlockLight" "Y" "Blocks")
;;  ("Data" "SkyLight" "BlockLight" "Y" "Blocks")
;;  ("Data")
;;  ()
;;  ()
;;  ()
;;  ())
;; it cannot be reproduced... so how did it happen?


(module world.external.minecraft jazz


(export (world.external.minecraft.generate))
(import (jazz.debuggee)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.json)
        (jazz.library)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.system)
        (jazz.ui)
        (world)
        (world.album)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.chunk)
        (world.configure)
        (world.dye)
        (world.enemy)
        (world.entity)
        (world.external.minecraft.generate)
        (world.external.minecraft.syntax (phase syntax))
        (world.external.nbt)
        (world.face)
        (world.foreign)
        (world.game)
        (world.generate)
        (world.geometry)
        (world.homogeneous)
        (world.info)
        (world.interface.blocks)
        (world.interface.inventory)
        (world.interface.propagation)
        (world.lighting)
        (world.log)
        (world.material)
        (world.mesh)
        (world.model)
        (world.models)
        (world.object)
        (world.profiling)
        (world.quad)
        (world.quad-texture)
        (world.region)
        (world.renderers)
        (world.role)
        (world.section)
        (world.sector)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.texture))


;;;
;;;; Game
;;;


(class Minecraft-Game extends World-Game
  
  
  (definition powerable-redstone-components
    '(23 25 29 33 46 71 96 107 123 124))
  
  (definition redstone-transmission-components
    '(55 93 94)) ;;redstone_wire repeaters_ON/OFF
  
  (definition redstone-power-components
    '(28 69 70 72 75 76 77 143)) ;;detector_rail lever pressure_plates torches_ON/OFF stone_button wooden_button
  
  (definition torch->repeater
    '(0 3 1 0 2 8))
  
  (definition unmovable-objects
    '(7 23 25 34 49 52 54 61 63 84 90 116 117 119 120 130 138))
  
  (definition break-extend
    '(0  8 9 10 11 18 26 30 37 38 39 40 50 51 55 59 64 70 71 72 75 76 77 81 83 86 91 92 93 94 103 122 140 141 142 143))
  
  
  (method override (on-toggle-inventory evt)
    (toggle-inventory))
  
  
  (method (toggle-inventory)
    (let ((world (current-world)))
      (if (get-showcase~ world)
          (begin
            (deactivate~ (get-showcase~ world))
            (set-showcase~ world #f))
        (let ((show (find-showcase~ world 'blocks)))
          (set-showcase~ world show)
          (activate~ show)))))
  
  
  (method (with-interaction proc)
    (let ((world (current-world))
          (camera (current-camera)))
      (let ((pos (get-down-point~ world)))
        (when pos
          (receive (position direction) (screen->ray~ camera (get-h~ pos) (get-v~ pos))
            (let ((closest (ray-closest-polygon~ world (get-position~ camera) direction (get-view-radius~ world) ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
              (when closest
                (let ((poly (car closest)))
                  (let ((center (get-center~ poly))
                        (normal (get-normal~ poly)))
                    (let ((block (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly)))
                          (fore (vertex+ center (vertex-scalar*& normal .5))))
                      (proc poly block fore)))))))))))
  
  
  (method (add-block-at poly fore id)
    (let ((zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (call-with-position~ zone fore
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
              (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)))))))
  

  (method (delete-block-at block)
    (let ((world (current-world))
          (zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (call-with-position~ zone block
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
              (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)))))
      (reset-target~ world)))

  
  (method (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
    (with-field i j k
      (lambda (section index)
        (define (set-blockid id)
          (define (determine-torch-rotation)
            (let ((normal (get-normal~ poly)))
              (if (/= (vertex-y normal) 0.)
                  5
                (let ((angle (plane-angle 1. 0. (vertex-x normal) (vertex-z normal))))
                  (cond ((or (between? angle 0. PI/4) (between? angle (- PI*2 PI/4) PI*2)) 1)
                        ((between? angle PI/4 (* 3. PI/4)) 4)
                        ((between? angle (* 3. PI/4) (* 5. PI/4)) 2)
                        (else 3))))))
          
          (define (determine-lever-rotation)
            (let ((normal (get-normal~ poly)))
              (if (> (vertex-y normal) 0.)
                  5
                (if (< (vertex-y normal) 0.)
                    7
                  (let ((angle (plane-angle 1. 0. (vertex-x normal) (vertex-z normal))))
                    (cond ((or (between? angle 0. PI/4) (between? angle (- PI*2 PI/4) PI*2)) 1)
                          ((between? angle PI/4 (* 3. PI/4)) 4)
                          ((between? angle (* 3. PI/4) (* 5. PI/4)) 2)
                          (else 3)))))))
          
          (define (determine-other-rotation)
            (let ((camera (current-camera)))
              (let ((sight (get-sight~ (get-lookat~ camera))))
                (let ((direction (vertex-normalize (vertex (vertex-x sight) 0. (vertex-z sight)))))
                  (let ((angle (plane-angle 1. 0. (vertex-x direction) (vertex-z direction))))
                    (cond ((or (between? angle 0. PI/4) (between? angle (* 7 PI/4) (* 2 PI)))
                           1)
                          ((between? angle PI/4 (* 3 PI/4))
                           0)
                          ((between? angle (* 3 PI/4) (* 5 PI/4))
                           3)
                          (else
                           2)))))))
                
          
          (block-set! section index id)
          (when poly
            (case id
              ((50)
               (data-set! section index (determine-torch-rotation)))
              ((69)
               (data-set! section index (determine-lever-rotation)))
              ((76)
               (data-set! section index (determine-torch-rotation))
               @w(redstone-torch-update (determine-torch-rotation) i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
              ((93)
               (data-set! section index (determine-other-rotation))))
            (redstone-update i j k 'place add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
            @w(when (memv? id powerable-redstone-components)
              (let ((power (powered-redstone-component? id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
                (when (> power 0)
                  (activate-redstone-component power id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))))))
        
        (let ((brightness (get-brightness~ (blockid->block id))))
          (when (= (block-ref section index) air-id)
            (cond (brightness
                    (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                    (propagate-light i j k brightness add-sector with-field block-ref blocklight-ref blocklight-set!)
                  @w(propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
                    (set-blockid id))
                  (else
                   (set-blockid id)
                   (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                 @w(inverse-propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
                   (blocklight-set! section index 0)))))
        (add-sector sector))))
  
  
  (method (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
    ;; can be improved by testing for opaque blocks in all directions
    ;; and then testing that every block in all directions is opaque
    (define (add-neighbors add-sector)
      (define (add i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))))))
      
      (add (- i 1) j k)
      (add (+ i 1) j k)
      (add i (- j 1) k)
      (add i (+ j 1) k)
      (add i j (- k 1))
      (add i j (+ k 1)))
    
    (add-neighbors add-sector)
    (with-field i j k
      (lambda (section index)
        (define (find-max-light-around i j k)
          (define (find-light i j k)
            (with-field i j k
              (lambda (section index)
                (if (not section)
                    0
                  (blocklight-ref section index)))))
          
          (let ((left (find-light (- i 1) j k))
                (right (find-light (+ i 1) j k))
                (down (find-light i (- j 1) k))
                (up (find-light i (+ j 1) k))
                (back (find-light i j (- k 1)))
                (front (find-light i j (+ k 1))))
            (max left right down up back front)))
        
        (let ((brightness (get-brightness~ (blockid->block (block-ref section index)))))
          (cond (brightness
                 (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                 (inverse-propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
                 (block-set! section index 0)
                 (powerlevel-set! section index 0))
                (else
                 (block-set! section index 0)
                 (blocklight-set! section index 0)
                 (powerlevel-set! section index 0)
                 (propagate-light i j k (- (find-max-light-around i j k) 1) add-sector with-field block-ref blocklight-ref blocklight-set!)
                 (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)))))))
  
  
  (method (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (propagate i j k light)
        (with-field i j k
          (lambda (section index)
            (when section
              ;; always adding the sector covers the case where the light changes
              ;; and we need to update all neighboring sectors even if no light changes for
              ;; them like when putting a torch next to a wall that is in the next sector
              (add-sector (get-sector~ section))
              (when (and (> light 0)
                         (< (blocklight-ref section index) light)
                         (not (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                (blocklight-set! section index light)
                (let ((light (- light 1)))
                  (define (add-queue i j k)
                    (enqueue queue (list i j k light)))
                  
                  (add-queue (- i 1) j k)
                  (add-queue (+ i 1) j k)
                  (add-queue i (- j 1) k)
                  (add-queue i (+ j 1) k)
                  (add-queue i j (- k 1))
                  (add-queue i j (+ k 1))))
              (let (iter)
                (unless (queue-empty? queue)
                  (apply propagate (dequeue queue))
                  (iter)))))))
      
      (propagate i j k light)))
  
  
  (method (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (inverse-propagate i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (let ((light (blocklight-ref section index)))
                (define (look-around i j k light)
                  (with-field i j k
                    (lambda (section index)
                      (when section
                        (add-sector (get-sector~ section))
                        (let ((new-light (blocklight-ref section index)))
                          (unless (= new-light 0)
                            (if (< new-light light)
                                (inverse-propagate i j k)
                              (enqueue queue (list i j k)))))))))
                
                (with-field i j k
                  (lambda (section index)
                    (unless (= (blocklight-ref section index) 0)
                      (blocklight-set! section index 0)
                      (look-around (- i 1) j k light)
                      (look-around (+ i 1) j k light)
                      (look-around i (- j 1) k light)
                      (look-around i (+ j 1) k light)
                      (look-around i j (- k 1) light)
                      (look-around i j (+ k 1) light)))))))))
      
      (inverse-propagate i j k)
      (let (iter)
        (unless (queue-empty? queue)
          (bind (i j k) (dequeue queue)
            (with-field i j k
              (lambda (section index)
                (let ((light (blocklight-ref section index)))
                  (unless (= light 0)
                    (blocklight-set! section index 0)
                    (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!))))))
          (iter)))))
  
  
  ;; when removing a block
  (method (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((queue (new-queue)))
      (with-field i j k
        (lambda (section index)
          (define (propagate i j k light)
            (with-field i j k
              (lambda (section index)
                (when section
                  (add-sector (get-sector~ section))
                  (when (and (> light 0)
                             (> light (skylight-ref section index))
                             (not (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                    (skylight-set! section index light)
                    (let ((light (- light 1)))
                      (define (add-queue i j k (light light))
                        (enqueue queue (list i j k light)))
                      
                      (add-queue (- i 1) j k)
                      (add-queue (+ i 1) j k)
                      (if (= light 14)
                          (add-queue i (- j 1) k 15)
                        (add-queue i (- j 1) k))
                      (unless (= light 14)
                        (add-queue i (+ j 1) k))
                      (add-queue i j (- k 1))
                      (add-queue i j (+ k 1))))
                  (let (iter)
                    (unless (queue-empty? queue)
                      (apply propagate (dequeue queue))
                      (iter)))))))
          
          (propagate i (+ j 1) k (skylight-ref section index))))))
  
  
  ;; when adding a block
  (method (inverse-propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((queue (new-queue)))
      (define (inverse-propagate i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (let ((light (skylight-ref section index)))
                (define (look-around i j k light)
                  (with-field i j k
                    (lambda (section index)
                      (when section
                        (add-sector (get-sector~ section))
                        (let ((new-light (skylight-ref section index)))
                          (unless (= new-light 0)
                            (if (< new-light light)
                                (inverse-propagate i j k)
                              (enqueue queue (list i j k)))))))))
                
                (with-field i j k
                  (lambda (section index)
                    (unless (= (skylight-ref section index) 0)
                      (skylight-set! section index 0)
                      (look-around (- i 1) j k light)
                      (look-around (+ i 1) j k light)
                      (look-around i (- j 1) k light)
                      (unless (= light 15)
                        (look-around i (+ j 1) k light))
                      (look-around i j (- k 1) light)
                      (look-around i j (+ k 1) light)))))))))
      
      (inverse-propagate i j k)
      (let (iter)
        (unless (queue-empty? queue)
          (bind (i j k) (dequeue queue)
            (with-field i j k
              (lambda (section index)
                (let ((light (skylight-ref section index)))
                  (unless (= light 0)
                    (skylight-set! section index 0)
                    (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!))))))
          (iter)))))
  
  
  (method (redstone-update i j k action add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (define (with-block i j k proc)
      (with-field i j k
        (lambda (section index)
          (proc section index (block-ref section index) (data-ref section index)))))
    
    (define (effective-block-ref i j k)
      (with-block i j k
        (lambda (section index block data)
          block)))
    
    (define (effective-data-ref i j k)
      (with-block i j k
        (lambda (section index block data)
          data)))
    
    (define (powerlevel-update section index power)
      (when (> power (powerlevel-ref section index))
        (powerlevel-set! section index power)
        (when (= (block-ref section index) 55)
          (data-set! section index power))))
    
    (define (powerlevel-update! section index power)
      (powerlevel-set! section index power)
      (when (= (block-ref section index) 55)
        (data-set! section index power)))
    
    (define (strong-power-side side-i side-j side-k from-i from-j from-k)
      (with-block side-i side-j side-k
        (lambda (section index block data)
          (unless (= (powerlevel-ref section index) 15)
            (cond ((memv? block powerable-redstone-components)
                   (powerlevel-update section index 15)
                   (power-redstone-component side-i side-j side-k 15))
                  ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)))
                   (power-block side-i side-j side-k 15))
                  ((= block 55)
                   (power-wire side-i side-j side-k 15))
                  ((and (= block 93) (= (bitwise-and data #b11) (repeater-data-out side-i side-k from-i from-k)))
                   (powerlevel-update section index 15)
                   (power-repeater side-i side-j side-k)))))))
    
    (define (weak-power-side side-i side-j side-k from-i from-j from-k)
      (with-block side-i side-j side-k
        (lambda (section index block data)
          (cond ((memv? block powerable-redstone-components)
                 (powerlevel-update section index 1)
                 (power-redstone-component side-i side-j side-k 1))
                ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)))
                 (power-block side-i side-j side-k 1))
                ((and (= block 93) (= (bitwise-and data #b11) (repeater-data-out side-i side-k from-i from-k)))
                 (powerlevel-update section index 15)
                 (power-repeater side-i side-j side-k))))))
    
    (define (component-power-side side-i side-j side-k from-i from-j from-k)
      (with-block side-i side-j side-k
        (lambda (section index block data)
          (cond ((memv? block powerable-redstone-components)
                 (powerlevel-update section index 0)
                 (power-redstone-component side-i side-j side-k 0))
                ((= block 55)
                 (power-wire side-i side-j side-k 15))
                ((and (= block 93) (= (bitwise-and data #b11) (repeater-data-out side-i side-k from-i from-k)))
                 (powerlevel-update section index 15)
                 (power-repeater side-i side-j side-k))))))
    
    (define (unpower-side side-i side-j side-k) ;; todo
      (with-block side-i side-j side-k
        (lambda (section index block data)
          (powerlevel-update section index 0))))
    
    (define (power-torch i j k)
      (with-block i j k
        (lambda (section index block data)
          (powerlevel-update section index 15)
          (strong-power-side i (+ j 1) k i j k)
          (unless (= data 1)
            (component-power-side (- i 1) j k i j k))
          (unless (= data 2)
            (component-power-side (+ i 1) j k i j k))
          (unless (= data 3)
            (component-power-side i j (- k 1) i j k))
          (unless (= data 4)
            (component-power-side i j (+ k 1) i j k))
          (unless (= data 5)
            (component-power-side i (- j 1) k i j k))
          (add-sector (get-sector~ section)))))
    
    (define (torch-powered? i j k)
      (with-block i j k
        (lambda (section index block data)
          (bind (a b c) (case data
                          ((1) '(-1  0  0))
                          ((2) '( 1  0  0))
                          ((3) '( 0  0 -1))
                          ((4) '( 0  0  1))
                          ((5) '( 0 -1  0)))
            (with-field (+ i a) (+ j b) (+ k c)
              (lambda (section index)
                (> (powerlevel-ref section index) 0)))))))
    
    (define (unpower-torch i j k)
      (with-block i j k
        (lambda (section index block data)
          (powerlevel-update section index 0)
          (block-set! section index 75)
          (unpower-side i (+ j 1) k)
          (unless (= data 1)
            (unpower-side (- i 1) j k))
          (unless (= data 2)
            (unpower-side (+ i 1) j k))
          (unless (= data 3)
            (unpower-side i j (- k 1)))
          (unless (= data 4)
            (unpower-side i j (+ k 1)))
          (unless (= data 5)
            (unpower-side i (- j 1) k))
          (add-sector (get-sector~ section)))))
    
    (define (power-lever i j k)
      (with-block i j k
        (lambda (section index block data)
          (set! data (bitwise-and data #b111))
          (bind (attach-i attach-j attach-k) (case data
                                               ((0 7) (list i (+ j 1) k))
                                               ((1)   (list (- i 1) j k))
                                               ((2)   (list (+ i 1) j k))
                                               ((3)   (list i j (- k 1)))
                                               ((4)   (list i j (+ k 1)))
                                               ((5 6) (list i (- j 1) k)))
            (strong-power-side attach-i attach-j attach-k i j k)
            (unless (memv? data '(0 7))
              (component-power-side i (+ j 1) k i j k))
            (unless (memv? data '(5 6))
              (component-power-side i (- j 1) k i j k))
            (unless (= data 1)
              (component-power-side (- i 1) j k i j k))
            (unless (= data 2)
              (component-power-side (+ i 1) j k i j k))
            (unless (= data 3)
              (component-power-side i j (- k 1) i j k))
            (unless (= data 4)
              (component-power-side i j (+ k 1) i j k)))
          (add-sector (get-sector~ section)))))
    
    (define (unpower-lever i j k)
      (unpower-block i j k))
    
    (define (power-block i j k power)
      (let ((proc (if (= power 15) strong-power-side weak-power-side)))
        (define (block-power-side side-i side-j side-k)
          (with-block side-i side-j side-k
            (lambda (section index block data)
              (if (and (= block 76) (memv? data (attached-to-data i j k side-i side-j side-k)))
                  (unpower-torch side-i side-j side-k)
                (proc side-i side-j side-k i j k)))))
        
        (with-field i j k
          (lambda (section index)
            (when (> power (powerlevel-ref section index))
              (powerlevel-update section index power)
              (block-power-side (- i 1) j k)
              (block-power-side (+ i 1) j k)
              (block-power-side i (- j 1) k)
              (block-power-side i (+ j 1) k)
              (block-power-side i j (- k 1))
              (block-power-side i j (+ k 1))
              (with-field i j k
                (lambda (section index)
                  (add-sector (get-sector~ section)))))))))
    
    (define (powered-block? i j k)
      (define (side-powered? side-i side-j side-k)
        (with-block side-i side-j side-k
          (lambda (section index block data)
              (cond ((and (< side-j j) (= block 76))
                     15)
                    ((and (> side-j j) (memv? block '(70 72)) (bit-set? 0 data))
                     15)
                    ((and (= block 94) (= (bitwise-and data #b11) (repeater-data-in side-i side-k i k)))
                     15)
                    ((and (memv? block '(69 77 143)) (bit-set? 3 data) (= (bitwise-and data #b111) (attached-to-data i j k side-i side-j side-k)))
                     15)
                    ((and (not (< side-j j)) (= block 55) (> (powerlevel-ref section index) 0) (or (> side-j j) (connected-redstone-to? i j k side-i side-j side-k)))
                     1)
                    (else 0)))))
      
      (let ((power (max (side-powered? (- i 1) j k)
                        (side-powered? (+ i 1) j k)
                        (side-powered? i (- j 1) k)
                        (side-powered? i (+ j 1) k)
                        (side-powered? i j (- k 1))
                        (side-powered? i j (+ k 1)))))
        (if (= power 0) #f power)))
    
    (define (unpower-block i j k)
      (unpower-side (- i 1) j k)
      (unpower-side (+ i 1) j k)
      (unpower-side i (- j 1) k)
      (unpower-side i (+ j 1) k)
      (unpower-side i j (- k 1))
      (unpower-side i j (+ k 1))
      (with-field i j k
        (lambda (section index)
          (add-sector (get-sector~ section)))))
    
    (define (repeater-data-out r-i r-k from-i from-k)
      (cond ((< r-i from-i) 3)
            ((> r-i from-i) 1)
            ((< r-k from-k) 0)
            ((> r-k from-k) 2)))
    
    (define (repeater-data-in r-i r-k from-i from-k)
      (cond ((< r-i from-i) 1)
            ((> r-i from-i) 3)
            ((< r-k from-k) 2)
            ((> r-k from-k) 0)))
    
    (define (power-repeater i j k)
      (with-block i j k
        (lambda (section index block data)
          (block-set! section index 94)
          (add-sector (get-sector~ section))
          (case (bitwise-and data #b11)
            ((0) (strong-power-side i j (+ k 1) i j k))
            ((1) (strong-power-side (+ i 1) j k i j k))
            ((2) (strong-power-side i j (- k 1) i j k))
            ((3) (strong-power-side (- i 1) j k i j k)))
          (add-sector (get-sector~ section)))))
    
    (define (powered-repeater? i j k)
      (with-block i j k
        (lambda (section index block data)
          (bind (a b c) (case (bitwise-and data #b11)
                          ((0) (list  0 0  1))
                          ((1) (list -1 0  0))
                          ((2) (list  0 0 -1))
                          ((3) (list  1 0  0)))
            (with-field (+ i a) (+ j b) (+ k c)
              (lambda (section index)
                (> (powerlevel-ref section index) 0)))))))
    
    (define (unpower-repeater i j k)
      (with-block i j k
        (lambda (section index block data)
          (block-set! section index 93)
          (add-sector (get-sector~ section))
          (case (bitwise-and data #b11)
            ((0) (unpower-side i j (- k 1)))
            ((1) (unpower-side (- i 1) j k))
            ((2) (unpower-side i j (+ k 1)))
            ((3) (unpower-side (+ i 1) j k)))
          (add-sector (get-sector~ section)))))
    
    (define (power-wire i j k power)
      (define (power-side side-i side-j side-k)
        (when (connected-redstone-to? side-i side-j side-k i j k)
          (let ((block (effective-block-ref side-i side-j side-k)))
            (if (= block 55)
                (power-wire side-i side-j side-k (- power 1))
              (let ((top (effective-block-ref i (+ j 1) k))
                    (upper (effective-block-ref side-i (+ side-j 1) side-k))
                    (lower (effective-block-ref side-i (- side-j 1) side-k)))
                (cond ((and (not (get-cube?~ (blockid->block top))) (= upper 55))
                       (power-wire side-i (+ side-j 1) side-k (- power 1)))
                      ((and (not (get-cube?~ (blockid->block block))) (= lower 55))
                       (power-wire side-i (- side-j 1) side-k (- power 1)))
                      (else
                       (weak-power-side side-i side-j side-k i j k))))))))
      
      (unless (= power 0)
        (with-field i j k
          (lambda (section index)
            (debug power)
            (when (> power (powerlevel-ref section index))
              (powerlevel-update section index power)
              (add-sector (get-sector~ section))
              (power-side (- i 1) j k)
              (power-side (+ i 1) j k)
              (power-side i j (- k 1))
              (power-side i j (+ k 1))
              (weak-power-side i (- j 1) k i j k))))))
    
    (define (powered-wire? i j k)
      (define (powered? i j k from-i from-j from-k)
        (let ((from (list from-i from-j from-k)))
          (define (side-powered? side-i side-j side-k)
            (with-block side-i side-j side-k
              (lambda (section index block data)
                (cond ((and (= block 55) (> (powerlevel-ref section index) 0))
                       (- (powered? side-i side-j side-k i j k) 1))
                      ((= block 76)
                       15)
                      ((and (memv? block '(69 77 143)) (bit-set? 3 data))
                       15)
                      ((and (memv? block '(70 72)) (bit-set? 0 data))
                       15)
                      ((and (= block 94) (= (bitwise-and data #b11) (repeater-data-in side-i side-k i k)))
                       15)
                      ((and (> (powerlevel-ref section index) 1) (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)))
                       15)
                      (else
                       (or
                         (unless (equal? (list side-i (+ side-j 1) side-k) from)
                           (with-block side-i (+ side-j 1) side-k
                             (lambda (section index upper data)
                               (and (= upper 55) (> (powerlevel-ref section index) 0) (not (get-cube?~ (blockid->block (effective-block-ref i (+ j 1) k)))) (- (powered? side-i (+ side-j 1) side-k i j k) 1)))))
                         (unless (equal? (list side-i (- side-j 1) side-k) from)
                           (with-block side-i (- side-j 1) side-k
                             (lambda (section index under data)
                               (and (= under 55) (> (powerlevel-ref section index) 0) (not (get-cube?~ (blockid->block block))) (- (powered? side-i (- side-j 1) side-k i j k) 1))))))
                       0)))))
          
          (define (top-powered?)
            (with-block i (+ j 1) k
              (lambda (section index block data)
                (if (or (= block 76)
                        (and (memv? block '(69 77 143)) (bit-set? 3 data))
                        (and (> (powerlevel-ref section index) 1) (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block))))
                    15
                  0))))
          
          (let ((power (max
                         ;; left
                         (if (equal? (list (- i 1) j k) from)
                             0
                           (side-powered? (- i 1) j k))
                         ;; right
                         (if (equal? (list (+ i 1) j k) from)
                             0
                           (side-powered? (+ i 1) j k))
                         ;; bottom
                         (with-block i (- j 1) k
                           (lambda (section index block data)
                             (if (and (> (powerlevel-ref section index) 0) (get-opaque-cube?~ (blockid->block block)) (get-cube?~ (blockid->block block)))
                                 15
                               0)))
                         ;; top
                         (top-powered?)
                         ;; back
                         (if (equal? (list i j (- k 1)) from)
                             0
                           (side-powered? i j (- k 1)))
                         ;; front
                         (if (equal? (list i j (+ k 1)) from)
                             0
                           (side-powered? i j (+ k 1))))))
            (if (= power 0) #f power))))
      
      (powered? i j k i j k))
    
    (define (unpower-wire i j k) ;; todo
      (with-block i j k
        (lambda (section index block data)
          )))
    
    (define (attached-to-data block-i block-j block-k comp-i comp-j comp-k)
      (cond ((> block-i comp-i) '(2))
            ((< block-i comp-i) '(1))
            ((> block-j comp-j) '(0 7))
            ((< block-j comp-j) '(5 6))
            ((> block-k comp-k) '(4))
            ((< block-k comp-k) '(3))))
    
    (define (power-redstone-component i j k power)
      (with-block i j k
        (lambda (section index block data)
          (case block
            ((123) (block-set! section index 124)))
          (add-sector (get-sector~ section)))))
    
    (define (connected-redstone-to? block-i block-j block-k wire-i wire-j wire-k)
      (define (side-connected? side-i side-j side-k)
        (let ((side-id (effective-block-ref side-i side-j side-k))
              (side-data-id (effective-data-ref side-i side-j side-k)))
          (cond ((memv? side-id (cons 55 redstone-power-components)) #t)
                ((or (get-opaque-cube?~ (blockid->block side-id)) ;;solid block...
                     (= side-id 89) ;;glowstone...
                     (and (memv? side-id '(44 126)) (> side-data-id 7))) ;;upside-down slab...
                 (and (= (effective-block-ref side-i (+ side-j 1) side-k) 55) ;;...with redstone on it..
                      (or (not (get-cube?~ (blockid->block (effective-block-ref wire-i (+ wire-j 1) wire-k)))) ;;...and nothing blocks the way
                          (memv? (effective-block-ref wire-i (+ wire-j 1) wire-k) '(20 138))))) ;;glass and beacons dont block
                ((or (not (get-cube?~ (blockid->block side-id))) 
                     (memv? side-id '(20 138)))
                 (= (effective-block-ref side-i (- side-j 1) side-k) 55))
                ((memv? side-id '(93 94))
                 (let ((required-data-id (cond ((/= wire-i side-i) '(1 3))
                                               (else               '(0 2)))))
                   (memv? (bitwise-and side-data-id #b11) required-data-id)))
                (else #f))))
      
      (let ((wire-side (cond ((< block-i wire-i) 'left)
                             ((> block-i wire-i) 'right)
                             ((< block-k wire-k) 'back)
                             ((> block-k wire-k) 'front)))
            (left?  (side-connected? (- wire-i 1) wire-j wire-k))
            (right? (side-connected? (+ wire-i 1) wire-j wire-k))
            (back?  (side-connected? wire-i wire-j (- wire-k 1)))
            (front? (side-connected? wire-i wire-j (+ wire-k 1))))
        (or (not (or left? right? back? front?))
            (case wire-side
              ((left) (or left? (and right? (not back?) (not front?))))
              ((right) (or right? (and left? (not back?) (not front?))))
              ((back) (or back? (and front? (not left?) (not right?))))
              ((front) (or front? (and back? (not left?) (not right?))))))))
    
    (with-block i j k
      (lambda (section index block data)
        (case action
          ((place) (case block
                     ((55) (let ((power (powered-wire? i j k)))
                             (when power
                               (power-wire i j k power))))
                     ((76) (if (torch-powered? i j k)
                               (block-set! section index 75)
                             (power-torch i j k)))
                     ((93) (when (powered-repeater? i j k)
                               (power-repeater i j k)))
                     ((123) (let ((power (powered-block? i j k)))
                              (when power
                                (power-redstone-component i j k power))))))))))
  
  
  (method (redstone-torch-update data-id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (define (effective-block-ref i j k)
      (with-field i j k
        (lambda (section index)
          (block-ref section index))))
    
    (let ((left (effective-block-ref (- i 1) j k))
          (right (effective-block-ref (+ i 1) j k))
          (bottom (effective-block-ref i (- j 1) k))
          (top (effective-block-ref i (+ j 1) k))
          (back (effective-block-ref i j (- k 1)))
          (front (effective-block-ref i j (+ k 1))))
      (define (power-side side dont i j k)
        (unless (= data-id dont)
          (with-field i j k
            (lambda (section index)
              (cond ((memv? side powerable-redstone-components)
                     (activate-redstone-component 1 side i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                    ((= side 55)
                     (update-redstone-wire 15 i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                    ((and (= side 93) (= (bitwise-and (data-ref section index) #b11) (list-ref torch->repeater dont)))
                     (block-set! section index 94)
                     (update-redstone-repeater i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))))))
      
      (cond ((memv? top powerable-redstone-components)
             (activate-redstone-component 15 top i (+ j 1) k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
            ((and (get-cube?~ (blockid->block top)) (get-opaque-cube?~ (blockid->block top)))
             (powerlevel-set! top 15)
             (block-redstone-update i (+ j 1) k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
      (power-side left 1 (- i 1) j k)
      (power-side right 2 (+ i 1) j k)
      (power-side back 3 i j (- k 1))
      (power-side front 4 i j (+ k 1))
      (power-side bottom 5 i (- j 1) k)))
  
  (method (redstone-torch-close data-id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (define (unpower-side side-i side-j side-k dont)
      (unless (= data-id dont)
        (with-field side-i side-j side-k
          (lambda (section index)
            (let ((block (block-ref section index))
                  (block-data (data-ref section index)))
              (cond ((memv? block powerable-redstone-components)
                     (unless (powered-redstone-component? block side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
                       (deactivate-redstone-component block side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
                    ((= block 55)
                     (unless (powered-redstone-wire? side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
                       (unpower-redstone-wire side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
                    ((and (= block 94) (= (bitwise-and (data-ref section index) #b11) (list-ref torch->repeater dont)))
                     (unpower-repeater i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))))))))
    
    (with-field i (+ j 1) k
      (lambda (section index)
        (let ((top-id (block-ref section index))
              (top-data (data-ref section index)))
          (cond ((memv? top-id powerable-redstone-components)
                 (unless (powered-redstone-component? top-id i (+ j 1) k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
                   (deactivate-redstone-component top-id i (+ j 1) k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
                ((and (get-cube?~ (blockid->block top-id)) (get-opaque-cube?~ (blockid->block top-id)))
                 (unless (block-powered? i (+ j 1) k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
                   (unpower-block i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))))))
    (unpower-side (- i 1) j k 1)
    (unpower-side (+ i 1) j k 2)
    (unpower-side i j (- k 1) 3)
    (unpower-side i j (+ k 1) 4)
    (unpower-side i (- j 1) k 5))
  
  
  (method (lever-update data-id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (define (power-side side-i side-j side-k)
      (with-field side-i side-j side-k
        (lambda (section index)
          (let ((side-id (block-ref section index)))
            (cond ((memv? side-id powerable-redstone-components)
                   (activate-redstone-component 1 side-id side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                  ((= side-id 55)
                   (update-redstone-wire 15 side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                  ((and (= side-id 93) (= (bitwise-and (data-ref section index) #b11) (cond ((< side-i i) 0)
                                                                                          ((> side-i i) 2)
                                                                                          ((< side-k k) 1)
                                                                                          ((> side-k k) 3)
                                                                                          (else         8))))
                   (block-set! section index 94)
                   (update-redstone-repeater side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))))))
    
    (bind (attach-i attach-j attach-k) (case data-id
                                         ((0 7) (list i (+ j 1) k))
                                         ((1)   (list (- i 1) j k))
                                         ((2)   (list (+ i 1) j k))
                                         ((3)   (list i j (- k 1)))
                                         ((4)   (list i j (+ k 1)))
                                         ((5 6) (list i (- j 1) k)))
      (with-field attach-i attach-j attach-k
        (lambda (section index)
          (when (and (get-opaque-cube?~ (blockid->block (block-ref section index)))
                     (get-cube?~ (blockid->block (block-ref section index))))
            (with-field attach-i attach-j attach-k
              (lambda (section index)
                (cond ((memv? (block-ref section index) powerable-redstone-components)
                       (activate-redstone-component 15 (block-ref section index) i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                      ((get-opaque-cube?~ (blockid->block (block-ref section index)))
                       (powerlevel-set! section index 15)
                       (block-redstone-update attach-i attach-j attach-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))))))))
    (let ((rotation (bitwise-and data-id #b111)))
      (unless (memv? rotation '(0 7))
        (power-side i (+ j 1) k))
      (unless (= rotation 1)
        (power-side (- i 1) j k))
      (unless (= rotation 2)
        (power-side (+ i 1) j k))
      (unless (= rotation 3)
        (power-side i j (- k 1)))
      (unless (= rotation 4)
        (power-side i j (+ k 1)))
      (unless (memv? rotation '(5 6))
        (power-side i (- j 1) k)))
    (with-field i j k
      (lambda (section index)
        (add-sector (get-sector~ section)))))
  
  
  (method (button-update data-id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (lever-update data-id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
  
  
  (method (block-redstone-update i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (with-field i j k
      (lambda (section index)
        (let ((power (powerlevel-ref section index)))
          (define (power-side side-i side-j side-k)
            (with-field side-i side-j side-k
              (lambda (section index)
                (let ((block-id (block-ref section index))
                      (data-id (data-ref section index)))
                  (bind (repeater-id torch-id) (cond ((> side-i i) '(1 1))
                                                     ((< side-i i) '(3 2))
                                                     ((> side-k k) '(2 3))
                                                     ((< side-k k) '(0 4))
                                                     ((> side-j j) '(8 5))
                                                     (else         '(8 8)))
                    (cond ((memv? block-id powerable-redstone-components)
                           (activate-redstone-component 1 block-id side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                          ((= block-id 55)
                           (when (= power 15)
                             (update-redstone-wire 15 side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
                          ((and (= block-id 93) (= data-id repeater-id))
                           (block-set! section index 94)
                           (update-redstone-repeater side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                          ((and (= block-id 75) (= data-id torch-id))
                           (block-set! section index 76)
                           ;(update-off-torch bla bla bla)
                           )))))))
          
          (power-side (+ i 1) j k)
          (power-side (- i 1) j k)
          (power-side i (+ j 1) k)
          (power-side i (- j 1) k)
          (power-side i j (+ k 1))
          (power-side i j (- k 1))
          (add-sector (get-sector~ section))))))
  
  (method (block-powered? i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    )
  
  (method (unpower-block i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    )
  
  
  (method (update-redstone-wire power-level i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (define (effective-block-ref i j k)
      (with-field i j k
        (lambda (section index)
          (block-ref section index))))
    
    (define (power-side side-i side-j side-k)
      (with-field side-i side-j side-k
        (lambda (section index)
          (let ((block (block-ref section index))
                (data-id (data-ref section index))
                (repeater-data (cond ((> side-i i) 1)
                                     ((< side-i i) 3)
                                     ((> side-k k) 2)
                                     (else         0))))
            (cond ((and (memv? block powerable-redstone-components)
                        (connected-redstone-to? side-i side-j side-k i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                   (activate-redstone-component 1 block side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                  ((and (= block 93) (= data-id repeater-data))
                   (block-set! section index 94)
                   (update-redstone-repeater side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                  ((= block 55)
                   (update-redstone-wire (- power-level 1) side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                  ((and (not (get-cube?~ (blockid->block block))) (= (effective-block-ref side-i (- side-j 1) side-k) 55))
                   (update-redstone-wire (- power-level 1) side-i (- side-j 1) side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                  ((and (not (get-cube?~ (blockid->block (effective-block-ref i (+ j 1) k)))) (= (effective-block-ref side-i (+ side-j 1) side-k) 55))
                   (update-redstone-wire (- power-level 1) side-i (+ side-j 1) side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                  ((and (get-opaque-cube?~ (blockid->block block))
                        (get-cube?~ (blockid->block block))
                        (connected-redstone-to? side-i side-j side-k i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                   (powerlevel-set! section index 1)
                   (block-redstone-update side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))))))
    
    (with-field i j k
      (lambda (section index)
        (when (> power-level (powerlevel-ref section index))
          (powerlevel-set! section index power-level)
          (power-side (- i 1) j k)
          (power-side (+ i 1) j k)
          (power-side i j (- k 1))
          (power-side i j (+ k 1))
          (add-sector (get-sector~ section)))))
    (with-field i (- j 1) k
      (lambda (section index)
        (debug 'under power-level (powerlevel-ref section index))
        (when (> power-level (powerlevel-ref section index))
          (add-sector (get-sector~ section))
          (powerlevel-set! section index 1)
          (block-redstone-update i (- j 1) k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))))
  
  (method (unpower-redstone-wire i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    )
  
  (method (powered-redstone-wire? i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    )
  
  
  (method (update-redstone-repeater i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (with-field i j k
      (lambda (section index)
        (let ((data-id (data-ref section index)))
          (bind (i j k) (case (bitwise-and data-id #b11)
                          ((0) (list i j (- k 1)))
                          ((1) (list (+ i 1) j k))
                          ((2) (list i j (+ k 1)))
                          ((3) (list (- i 1) j k)))
            (with-field i j k
              (lambda (section index)
                (let ((fore (block-ref section index)))
                  (cond ((memv? fore powerable-redstone-components)
                         (activate-redstone-component 15 fore i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                        ((= fore 55)
                         (update-redstone-wire 15 i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                        ((and (= fore 93) (= (bitwise-and (data-ref section index) #b11) (bitwise-and data-id #b11)))
                         (block-set! section index 94)
                         (update-redstone-repeater i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
                        ((get-opaque-cube?~ (blockid->block fore))
                         (powerlevel-set! section index 15)
                         (block-redstone-update i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))))))))
        
        (add-sector (get-sector~ section)))))
  
  (method (unpower-repeater i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    )
  

  (method (activate-redstone-component power-level block-id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (with-field i j k
      (lambda (section index)
        (case block-id
          ((123)
           (block-set! section index 124)
           (powerlevel-set! section index power-level)
           (propagate-light i j k 15 add-sector with-field block-ref blocklight-ref blocklight-set!)
           (when (= power-level 15)
             (block-redstone-update i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
          ((25)
           (unless (> (powerlevel-ref section index) 0)
             (powerlevel-set! section index 15)))
          ((29 33)
           (let ((data-id (data-ref section index)))
             (unless (bit-set? 3 data-id)
               (piston-extend i j k data-id add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))))
          ((71)
           (if (bit-set? 3 (data-ref section index))
               (with-field i (- j 1) k
                 (lambda (section index)
                   (data-set! section index (bit-set (data-ref section index) 2 #t))))
             (data-set! section index (bit-set (data-ref section index) 2 #t)))))
        (add-sector (get-sector~ section)))))
  
  (method (deactivate-redstone-component block-id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (with-field i j k
      (lambda (section index)
        (case block-id
          ((124)
           (block-set! section index 123)
           (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
           (let ((power (powerlevel-ref section index)))
             (when (= power 15)
               (unpower-block i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))
             (powerlevel-set! section index 0)))
          ((33)
           (let ((data-id (data-ref section index)))
             (when (bit-set? 3 data-id)
               (case (bitwise-and data-id #b111)
                 ((0) (block-set! section index 0))))))))))
           
  (method (piston-retract block-id i j k data-id add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (define (retract a b c)
      (with-field (+ i a) (+ j b) (+ k c)
        (lambda (section index)
          (block-set! section index 0)
          (when (= block-id 29)
            (let ((fore 0))
              (with-field (+ i (* 2 a)) (+ j (* 2 b)) (+ k (* 2 c))
                (lambda (section index)
                  (let ((block (block-ref section index)))
                    (unless (memv? block unmovable-objects)
                      )))))))))
            
    
    (with-field i j k
      (lambda (section index)
        (data-set! section index (bit-set data-id 3 #f))
        (case data-id
          ((0) (retract  0 -1  0))
          ((1) (retract  0  1  0))
          ((2) (retract  0  0 -1))
          ((3) (retract  0  0  1))
          ((4) (retract -1  0  0))
          ((5) (retract  1  0  0)))
        (add-sector (get-sector~ section)))))
  
  (method (piston-extend i j k data-id add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (define (count-blocks a b c number)
      (let ((next (+ number 1)))
        (with-field (+ i (* a next)) (+ j (* b next)) (+ k (* c next))
          (lambda (section index)
            (if section
                (let ((block (block-ref section index)))
                  (cond ((memv? block unmovable-objects)
                         #f)
                        ((memv? block break-extend)
                         number)
                        (else
                         (if (= number 12)
                             #f
                           (count-blocks a b c next)))))
              #f)))))
    
    (let ((number (case data-id
                    ((0) (count-blocks  0 -1  0 0))
                    ((1) (count-blocks  0  1  0 0))
                    ((2) (count-blocks  0  0 -1 0))
                    ((3) (count-blocks  0  0  1 0))
                    ((4) (count-blocks -1  0  0 0))
                    ((5) (count-blocks  1  0  0 0)))))
      (when number
        (let ((block #f)
              (block-data #f)
              (temp #f)
              (temp-data #f))
          (loop (for x from 0 to number)
                (bind (i j k) (case data-id
                                ((0) (list i (- j (+ x 1)) k))
                                ((1) (list i (+ j (+ x 1)) k))
                                ((2) (list i j (- k (+ x 1))))
                                ((3) (list i j (+ k (+ x 1))))
                                ((4) (list (- i (+ x 1)) j k))
                                ((5) (list (+ i (+ x 1)) j k)))
                  (with-field i j k
                    (lambda (section index)
                      (if (= x 0)
                          (begin
                            (set! block (block-ref section index))
                            (set! block-data (data-ref section index))
                            (block-set! section index 34)
                            (data-set! section index data-id))
                        (begin
                          (set! temp (block-ref section index))
                          (set! temp-data (data-ref section index))
                          (block-set! section index block)
                          (data-set! section index block-data)
                          (set! block temp)
                          (set! block-data temp-data)))))))))))
                            
  
  (method (powered-redstone-component? block-id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (define (power-from-side side-i side-j side-k)
      (bind (attached-data-id repeater-id) (cond ((> i side-i) '(2 1))
                                                 ((< i side-i) '(1 3))
                                                 ((< j side-j) '(5 8))
                                                 ((> k side-k) '(4 2))
                                                 (else         '(3 0)))
        (with-field side-i side-j side-k
          (lambda (section index)
            (let ((side-id (block-ref section index))
                  (side-data-id (data-ref section index)))
              (or (case side-id
                    ((94) (when (= (bitwise-and side-data-id #b11) repeater-id) 15)) ;;repeater
                    ((28 69 77 143) (when (bit-set? 3 side-data-id) 1))             ;;detector_rail lever button
                    ((76) (when (/= side-data-id attached-data-id) (if (> side-j j) 15 1))) ;;redstone_torch
                    ((70 72) (when (bit-set? 0 side-data-id) 1))                     ;;pressure_plates
                    ((55) (and (> (powerlevel-ref section index) 0)
                               (when (connected-redstone-to? i j k side-i side-j side-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!) 1)))
                    (else (and (get-opaque-cube?~ (blockid->block side-id))
                               (when (= (powerlevel-ref section index) 15) 1))))
                  0))))))
    
    (let ((left   (power-from-side (- i 1) j k))
          (right  (power-from-side (+ i 1) j k))
          (bottom (power-from-side i (- j 1) k))
          (top    (power-from-side i (+ j 1) k))
          (back   (power-from-side i j (- k 1)))
          (front  (power-from-side i j (+ k 1))))
      (max left right bottom top back front)))
  
  ;;waiting to support block_states
  (method (connected-redstone-to? block-i block-j block-k from-i from-j from-k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (define (effective-block-ref i j k)
      (with-field i j k
        (lambda (section index)
          (block-ref section index))))
    
    (define (effective-data-ref i j k)
      (with-field i j k
        (lambda (section index)
          (data-ref section index))))
    
    (define (side-connected? side-i side-j side-k)
      (let ((side-id (effective-block-ref side-i side-j side-k))
            (side-data-id (effective-data-ref side-i side-j side-k)))
        (cond ((memv? side-id (cons 55 redstone-power-components)) #t)
              ((or (get-opaque-cube?~ (blockid->block side-id)) ;;solid block...
                   (= side-id 89) ;;glowstone...
                   (and (memv? side-id '(44 126)) (> side-data-id 7))) ;;upside-down slab...
               (and (= (effective-block-ref side-i (+ side-j 1) side-k) 55) ;;...with redstone on it..
                    (or (not (get-cube?~ (blockid->block (effective-block-ref from-i (+ from-j 1) from-k)))) ;;...and nothing blocks the way
                        (memv? (effective-block-ref from-i (+ from-j 1) from-k) '(20 138))))) ;;glass and beacons dont block
              ((or (not (get-cube?~ (blockid->block side-id))) 
                   (memv? side-id '(20 138)))
               (= (effective-block-ref side-i (- side-j 1) side-k) 55))
              ((memv? side-id '(93 94))
               (let ((required-data-id (cond ((/= from-i side-i) '(1 3))
                                             (else               '(0 2)))))
                 (memv? (bitwise-and side-data-id #b11) required-data-id)))
              (else #f))))
    
    (let ((from-side (cond ((< block-i from-i) 'left)
                           ((> block-i from-i) 'right)
                           ((< block-k from-k) 'back)
                           ((> block-k from-k) 'front)))
          (left?  (side-connected? (- from-i 1) from-j from-k))
          (right? (side-connected? (+ from-i 1) from-j from-k))
          (back?  (side-connected? from-i from-j (- from-k 1)))
          (front? (side-connected? from-i from-j (+ from-k 1))))
      (or (not (or left? right? back? front?))
          (case from-side
            ((left) (or left? (and right? (not back?) (not front?))))
            ((right) (or right? (and left? (not back?) (not front?))))
            ((back) (or back? (and front? (not left?) (not right?))))
            ((front) (or front? (and back? (not left?) (not right?))))))))
  
  
  (method override (mouse-up h v)
    (with-interaction
      (lambda (poly block fore)
        (delete-block-at block))))
  
  
  (method override (right-mouse-up h v)
    (let ((world (current-world))
          (zone (current-zone)))
      (with-interaction
        (lambda (poly block fore)
          (call-with-position~ zone block
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
              (let ((block (blockid->block block-id)))
                (let ((right-mouse (get-right-mouse~ block)))
                  (if (not right-mouse)
                      (let ((id (get-id~ (selected-slot~ (child~ (get-interface~ world) 'belt)))))
                        (when id
                          (add-block-at poly fore id)))
                    (right-mouse region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!))))))))))
  
  
  (method override (mouse-wheel h v delta)
    (let ((world (current-world)))
      (if (shift-down?)
          (let ((d (get-h~ delta)))
            (cond ((> d 0)
                   (zoom-in~ world))
                  ((< d 0)
                   (zoom-out~ world))))
        (let ((d (get-v~ delta)))
          (cycle-selection~ (child~ (get-interface~ world) 'belt) d)))))))
