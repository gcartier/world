;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Minecraft
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Édouard Hébert


(module world.external.minecraft jazz


(export (world.external.minecraft.generate))
(import (jazz.geometry)
        (jazz.platform)
        (world)
        (world.audio)
        (world.autoload)
        (world.external.minecraft.generate)
        (world.game)
        (world.geometry)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Game
;;;


(class Minecraft-Game extends World-Game
  
  
  (slot repeaters    initialize (new-queue) accessors generate)
  (slot lava-blocks  initialize (new-queue) accessors generate)
  (slot water-blocks initialize (new-queue) accessors generate)
  
  
  (definition powerable-redstone-components
    '(23 25 29 33 46 71 96 107 123 124))
  
  (definition redstone-transmission-components
    '(55 93 94)) ;; redstone_wire repeaters_ON/OFF
  
  (definition redstone-power-components
    '(28 69 70 72 75 76 77 143)) ;; detector_rail lever pressure_plates torches_ON/OFF stone_button wooden_button
  
  (definition torch->repeater
    '(0 3 1 0 2 8))
  
  (definition unmovable-objects
    '(7 23 25 34 49 52 54 61 63 84 90 116 117 119 120 130 138))
  
  (definition break-extend
    '(0 8 9 10 11 18 26 30 37 38 39 40 50 51 55 59 64 70 71 72 75 76 77 81 83 86 91 92 93 94 103 122 140 141 142 143))
  
  (definition old-redstone? ;;;;;;;;;;;;;;;;
    #t)
  
  (method (index->coordinates index)
    (let ((i (modulo index 16))
          (k (modulo (quotient index 16) 16))
          (j (modulo (quotient (quotient index 16) 16) 16)))
      (list i j k)))
  
  
  (method (with-interaction proc)
    (let ((world (current-world))
          (camera (current-camera)))
      (let ((pos (get-down-point~ world)))
        (when pos
          (receive (position direction) (screen->ray~ camera (get-h~ pos) (get-v~ pos))
            (let ((closest (ray-closest-polygon~ world (get-position~ camera) direction (get-view-radius~ world) ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
              (when closest
                (let ((poly (car closest)))
                  (with-polygon-interaction poly
                    proc)))))))))
  
  
  (method (with-polygon-interaction poly proc)
    (let ((center (get-center~ poly))
          (normal (get-normal~ poly)))
      (let ((block (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly)))
            (fore (vertex+ center (vertex-scalar*& normal .5))))
        (proc poly block fore))))
  
  
  (method (add-block-at poly fore id)
    (let ((zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (call-with-position~ zone fore
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
              (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)))))))
  

  (method (delete-block-at block)
    (let ((world (current-world))
          (zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (call-with-position~ zone block
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
              (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)))))
      (reset-selection~ world)))

  
  (method (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
    (with-field i j k
      (lambda (section index)
        (define (set-blockid id)
          (define (determine-torch-rotation)
            (let ((normal (get-normal~ poly)))
              (if (/= (vertex-y normal) 0.)
                  5
                (let ((angle (plane-angle 1. 0. (vertex-x normal) (vertex-z normal))))
                  (cond ((or (between? angle 0. PI/4) (between? angle (- PI*2 PI/4) PI*2)) 1)
                        ((between? angle PI/4 (* 3. PI/4)) 4)
                        ((between? angle (* 3. PI/4) (* 5. PI/4)) 2)
                        (else 3))))))
          
          (define (determine-lever-rotation)
            (let ((normal (get-normal~ poly)))
              (if (> (vertex-y normal) 0.)
                  5
                (if (< (vertex-y normal) 0.)
                    7
                  (let ((angle (plane-angle 1. 0. (vertex-x normal) (vertex-z normal))))
                    (cond ((or (between? angle 0. PI/4) (between? angle (- PI*2 PI/4) PI*2)) 1)
                          ((between? angle PI/4 (* 3. PI/4)) 4)
                          ((between? angle (* 3. PI/4) (* 5. PI/4)) 2)
                          (else 3)))))))
          
          (define (determine-other-rotation)
            (let ((camera (current-camera)))
              (let ((sight (get-sight~ (get-lookat~ camera))))
                (let ((direction (vertex-normalize (vertex (vertex-x sight) 0. (vertex-z sight)))))
                  (let ((angle (plane-angle 1. 0. (vertex-x direction) (vertex-z direction))))
                    (cond ((or (between? angle 0. PI/4) (between? angle (* 7 PI/4) (* 2 PI)))
                           1)
                          ((between? angle PI/4 (* 3 PI/4))
                           0)
                          ((between? angle (* 3 PI/4) (* 5 PI/4))
                           3)
                          (else
                           2)))))))
          
          (define (determine-piston-rotation)
            (let ((normal (get-normal~ poly)))
              (cond ((> (vertex-y normal) 0.) 1)
                    ((< (vertex-y normal) 0.) 0)
                    ((> (vertex-x normal) 0.) 5)
                    ((< (vertex-x normal) 0.) 4)
                    ((> (vertex-z normal) 0.) 2)
                    ((< (vertex-z normal) 0.) 3))))
          
          (define (add-liquid-blocks)
            (define (add-side-block side-i side-j side-k)
              (with-field side-i side-j side-k
                (lambda (section index)
                  (when (and section (memq? (block-ref section index) '(8 9)))
                    (enqueue water-blocks (cons (get-sector~ section) (index->coordinates index))))
                  (when (and section (memq? (block-ref section index) '(10 11)))
                    (enqueue lava-blocks (cons (get-sector~ section) (index->coordinates index)))))))
            
            (when (memq? id '(8 9))
              (enqueue water-blocks (list sector i j k)))
            (when (memq? id '(10 11))
              (enqueue lava-blocks (list sector i j k)))
            (add-side-block (- i 1) j k)
            (add-side-block (+ i 1) j k)
            (add-side-block i (- j 1) k)
            (add-side-block i (+ j 1) k)
            (add-side-block i j (- k 1))
            (add-side-block i j (+ k 1)))
          
          (block-set! section index id)
          (powerlevel-set! section index 0)
          (when poly
            (case id
              ((29 33)
               (data-set! section index (determine-piston-rotation)))
              ((50)
               (data-set! section index (determine-torch-rotation)))
              ((69)
               (data-set! section index (determine-lever-rotation)))
              ((76)
               (data-set! section index (determine-torch-rotation)))
              ((93)
               (data-set! section index (determine-other-rotation))))
            (add-liquid-blocks)
            (redstone-update sector i j k id 'place add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
        
        (let ((brightness (get-brightness~ (blockid->block id))))
          (when (= (block-ref section index) air-id)
            (cond (brightness
                    (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                    (propagate-light i j k brightness add-sector with-field block-ref blocklight-ref blocklight-set!)
                  @w(propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
                    (set-blockid id))
                  (else
                   (set-blockid id)
                   (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                 @w(inverse-propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
                   (blocklight-set! section index 0)))))
        (add-sector sector))))
  
  
  (method (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
    ;; can be improved by testing for opaque blocks in all directions
    ;; and then testing that every block in all directions is opaque
    (define (add-neighbors add-sector)
      (define (add i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (when (memq? (block-ref section index) '(8 9))
                (enqueue water-blocks (cons (get-sector~ section) (index->coordinates index))))
              (when (memq? (block-ref section index) '(10 11))
                (enqueue lava-blocks (cons (get-sector~ section) (index->coordinates index))))))))
      
      (add (- i 1) j k)
      (add (+ i 1) j k)
      (add i (- j 1) k)
      (add i (+ j 1) k)
      (add i j (- k 1))
      (add i j (+ k 1)))
    
    (add-neighbors add-sector)
    (with-field i j k
      (lambda (section index)
        (define (find-max-light-around i j k)
          (define (find-light i j k)
            (with-field i j k
              (lambda (section index)
                (if (not section)
                    0
                  (blocklight-ref section index)))))
          
          (let ((left (find-light (- i 1) j k))
                (right (find-light (+ i 1) j k))
                (down (find-light i (- j 1) k))
                (up (find-light i (+ j 1) k))
                (back (find-light i j (- k 1)))
                (front (find-light i j (+ k 1))))
            (max left right down up back front)))
        
        (let ((brightness (get-brightness~ (blockid->block block-id))))
          (block-set! section index 0)
          (if brightness
              (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
            (begin
              (blocklight-set! section index 0)
              (propagate-light i j k (- (find-max-light-around i j k) 1) add-sector with-field block-ref blocklight-ref blocklight-set!)))
          
          (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
          (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
          (redstone-update sector i j k block-id 'delete add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
          (data-set! section index 0)
          (powerlevel-set! section index 0)))))
  
  
  (method (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (propagate i j k light)
        (with-field i j k
          (lambda (section index)
            (when section
              ;; always adding the sector covers the case where the light changes
              ;; and we need to update all neighboring sectors even if no light changes for
              ;; them like when putting a torch next to a wall that is in the next sector
              (add-sector (get-sector~ section))
              (when (and (> light 0)
                         (< (blocklight-ref section index) light)
                         (not (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                (blocklight-set! section index light)
                (let ((light (- light 1)))
                  (define (add-queue i j k)
                    (enqueue queue (list i j k light)))
                  
                  (add-queue (- i 1) j k)
                  (add-queue (+ i 1) j k)
                  (add-queue i (- j 1) k)
                  (add-queue i (+ j 1) k)
                  (add-queue i j (- k 1))
                  (add-queue i j (+ k 1))))
              (let (iter)
                (unless (queue-empty? queue)
                  (apply propagate (dequeue queue))
                  (iter)))))))
      
      (propagate i j k light)))
  
  
  (method (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (inverse-propagate i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (let ((light (blocklight-ref section index)))
                (define (look-around i j k light)
                  (with-field i j k
                    (lambda (section index)
                      (when section
                        (add-sector (get-sector~ section))
                        (let ((new-light (blocklight-ref section index)))
                          (unless (= new-light 0)
                            (if (< new-light light)
                                (inverse-propagate i j k)
                              (enqueue queue (list i j k)))))))))
                
                (unless (= light 0)
                  (blocklight-set! section index 0)
                  (look-around (- i 1) j k light)
                  (look-around (+ i 1) j k light)
                  (look-around i (- j 1) k light)
                  (look-around i (+ j 1) k light)
                  (look-around i j (- k 1) light)
                  (look-around i j (+ k 1) light)))))))
      
      (inverse-propagate i j k)
      (let (iter)
        (unless (queue-empty? queue)
          (bind (i j k) (dequeue queue)
            (with-field i j k
              (lambda (section index)
                (let ((light (blocklight-ref section index)))
                  (unless (= light 0)
                    (blocklight-set! section index 0)
                    (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!))))))
          (iter)))))
  
  
  ;; when removing a block
  (method (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((queue (new-queue)))
      (with-field i j k
        (lambda (section index)
          (define (propagate i j k light)
            (with-field i j k
              (lambda (section index)
                (when section
                  (add-sector (get-sector~ section))
                  (when (and (> light 0)
                             (> light (skylight-ref section index))
                             (not (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                    (skylight-set! section index light)
                    (let ((light (- light 1)))
                      (define (add-queue i j k (light light))
                        (enqueue queue (list i j k light)))
                      
                      (add-queue (- i 1) j k)
                      (add-queue (+ i 1) j k)
                      (if (= light 14)
                          (add-queue i (- j 1) k 15)
                        (add-queue i (- j 1) k))
                      (unless (= light 14)
                        (add-queue i (+ j 1) k))
                      (add-queue i j (- k 1))
                      (add-queue i j (+ k 1))))
                  (let (iter)
                    (unless (queue-empty? queue)
                      (apply propagate (dequeue queue))
                      (iter)))))))
          
          (propagate i (+ j 1) k (skylight-ref section index))))))
  
  
  ;; when adding a block
  (method (inverse-propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((queue (new-queue)))
      (define (inverse-propagate i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (let ((light (skylight-ref section index)))
                (define (look-around i j k light)
                  (with-field i j k
                    (lambda (section index)
                      (when section
                        (add-sector (get-sector~ section))
                        (let ((new-light (skylight-ref section index)))
                          (unless (= new-light 0)
                            (if (< new-light light)
                                (inverse-propagate i j k)
                              (enqueue queue (list i j k)))))))))
                
                (with-field i j k
                  (lambda (section index)
                    (unless (= (skylight-ref section index) 0)
                      (skylight-set! section index 0)
                      (look-around (- i 1) j k light)
                      (look-around (+ i 1) j k light)
                      (look-around i (- j 1) k light)
                      (unless (= light 15)
                        (look-around i (+ j 1) k light))
                      (look-around i j (- k 1) light)
                      (look-around i j (+ k 1) light)))))))))
      
      (inverse-propagate i j k)
      (let (iter)
        (unless (queue-empty? queue)
          (bind (i j k) (dequeue queue)
            (with-field i j k
              (lambda (section index)
                (let ((light (skylight-ref section index)))
                  (unless (= light 0)
                    (skylight-set! section index 0)
                    (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!))))))
          (iter)))))
  
  
  (method (redstone-update sector i j k block action add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
    (let ((check-cache? #f))
      (define (with-block i j k proc)
        (with-field i j k
          (lambda (section index)
            (proc section index (block-ref section index) (data-ref section index)))))
      
      (define (with-section section index proc)
        (let ((section-index (get-index~ (get-sector~ section)))
              (sector-index (get-index~ sector)))
          (let ((a (- (vector-ref section-index 0) (vector-ref sector-index 0)))
                (b (- (vector-ref section-index 1) (vector-ref sector-index 1)))
                (c (- (vector-ref section-index 2) (vector-ref sector-index 2))))
            (let* ((i (modulo index 16))
                   (k (modulo (/ (- index i) 16) 16))
                   (j (/ (- index i (* k 16)) 256)))
              (proc (+ (* a 16) i) (+ (* b 16) j) (+ (* c 16) k))))))
      
      (define (effective-block-ref i j k)
        (with-block i j k
          (lambda (section index block data)
            block)))
      
      (define (effective-data-ref i j k)
        (with-block i j k
          (lambda (section index block data)
            data)))
      
      (define (block-update i j k)
        (define (update-side side-i side-j side-k)
          (with-field (+ i side-i) (+ j side-j) (+ k side-k)
            (lambda (section index)
              (let ((block (block-ref section index)))
                (when (memq? block '(8 9))
                  (enqueue water-blocks (cons (get-sector~ section) (index->coordinates index))))
                (when (memq? block '(10 11))
                  (enqueue lava-blocks (cons (get-sector~ section) (index->coordinates index))))))))
        
        (update-side -1  0  0)
        (update-side  1  0  0)
        (update-side  0 -1  0)
        (update-side  0  1  0)
        (update-side  0  0 -1)
        (update-side  0  0  1))
      
      (define (powerlevel-update section index power)
        (when (and (/= (block-ref section index) 0) (> power (cache-powerlevel section index)))
          (powerlevel-set! section index power)
          (when (= (block-ref section index) 55)
            (data-set! section index power))))
      
      (define (powerlevel-update! section index power) ;; destructive for unpowering
        (when (/= (block-ref section index) 0)
          (powerlevel-set! section index power)
          (when (= (block-ref section index) 55)
            (data-set! section index power))))
      
      (define (cache-powerlevel section index (deleted-block #f))
        (let ((power (powerlevel-ref section index)))
          (if (/= power 255)
              power
            (begin
              (powerlevel-set! section index 0)
              (let ((p (calculate-power-level section index deleted-block)))
                (powerlevel-update! section index p)
                p)))))
      
      (define (calculate-power-level section index deleted-block)
        (with-section section index
          (lambda (i j k)
            (let ((block (or deleted-block (block-ref section index)))
                  (data-id (data-ref section index)))
              (cond ((= block 76)
                     15)
                    ((= block 94)
                     15)
                    ((= block 55)
                     (data-ref section index))
                    ((memv? block powerable-redstone-components)
                     (or (powered-redstone-component? i j k) 0))
                    ((and (memv? block '(69 77 143)) (bit-set? 3 data-id))
                     15)
                    ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)) (> (cache-powerlevel section index) 0))
                     (or (powered-block? i j k i j k) 0))
                    (else 0))))))
      
      (define (strong-power-side side-i side-j side-k from-i from-j from-k)
        (with-block side-i side-j side-k
          (lambda (section index block data)
            (when (or (not check-cache?) (= (powerlevel-ref section index) 255))
              (when (or (= (powerlevel-ref section index) 255) (/= (cache-powerlevel section index) 15))
                (cond ((memv? block powerable-redstone-components)
                       (power-redstone-component side-i side-j side-k 15))
                      ((= block 55)
                       (power-wire side-i side-j side-k 15))
                      ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)))
                       (power-block side-i side-j side-k 15))
                      ((and (= block 93) (= (bitwise-and data #b11) (repeater-data-out side-i side-k from-i from-k)))
                       (powerlevel-update section index 15)
                       (power-repeater side-i side-j side-k))))))))
      
      (define (weak-power-side side-i side-j side-k from-i from-j from-k)
        (with-block side-i side-j side-k
          (lambda (section index block data)
            (when (or (not check-cache?) (= (powerlevel-ref section index) 255))
              (cond ((memv? block powerable-redstone-components)
                     (power-redstone-component side-i side-j side-k 1))
                    ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)))
                     (power-block side-i side-j side-k 1))
                    ((and (= block 93) (= (bitwise-and data #b11) (repeater-data-out side-i side-k from-i from-k)))
                     (powerlevel-update section index 15)
                     (power-repeater side-i side-j side-k)))))))
      
      (define (component-power-side side-i side-j side-k from-i from-j from-k)
        (with-block side-i side-j side-k
          (lambda (section index block data)
            (when (or (not check-cache?) (= (powerlevel-ref section index) 255))
              (cond ((memv? block powerable-redstone-components)
                     (powerlevel-update section index 0)
                     (power-redstone-component side-i side-j side-k 0))
                    ((= block 55)
                     (power-wire side-i side-j side-k 15))
                    ((and (= block 93) (= (bitwise-and data #b11) (repeater-data-out side-i side-k from-i from-k)))
                     (powerlevel-update section index 15)
                     (power-repeater side-i side-j side-k)))))))
      
      (define (unpower-side side-i side-j side-k from-i from-j from-k)
        (with-block side-i side-j side-k
          (lambda (section index block data)
            (define (cache-and-unpower)
              (set! check-cache? #t)
              (cond ((= block 55)
                     (power-wire side-i side-j side-k data))
                    ((and (= block 94) (= (bitwise-and data #b11) (repeater-data-out side-i side-k from-i from-k)))
                     (effective-power-repeater side-i side-j side-k))
                    ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)) (> (cache-powerlevel section index) 0))
                     (power-block side-i side-j side-k 1)))
              (set! check-cache? #f))
            
            (when (= (powerlevel-ref section index) 255)
              (cache-and-unpower))
            (cond ((memv? block powerable-redstone-components)
                   (let ((power (powered-redstone-component? side-i side-j side-k)))
                     (if power
                         (when (< power (powerlevel-ref section index))
                           (unpower-redstone-component side-i side-j side-k)
                           (powerlevel-update! section index power)
                           (power-redstone-component side-i side-j side-k 0))
                       (unpower-redstone-component side-i side-j side-k))))
                  ((and (= block 55) (> (cache-powerlevel section index) 0))
                   (unpower-wire side-i side-j side-k))
                  ((and (= block 94) (= (bitwise-and data #b11) (repeater-data-out side-i side-k from-i from-k)))
                   (unless (powered-repeater? side-i side-j side-k)
                     (powerlevel-update! section index 0)
                     (unpower-repeater side-i side-j side-k)))
                  ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)) (> (cache-powerlevel section index) 0))
                   (unless (powered-block? side-i side-j side-k from-i from-j from-k)
                     (powerlevel-update! section index 0)
                     (unpower-block side-i side-j side-k)))))))
      
      (define (power-torch i j k)
        (with-block i j k
          (lambda (section index block data)
            (powerlevel-update section index 15)
            (block-set! section index 76) 
            (strong-power-side i (+ j 1) k i j k)
            (unless (= data 1)
              (component-power-side (- i 1) j k i j k))
            (unless (= data 2)
              (component-power-side (+ i 1) j k i j k))
            (unless (= data 3)
              (component-power-side i j (- k 1) i j k))
            (unless (= data 4)
              (component-power-side i j (+ k 1) i j k))
            (unless (= data 5)
              (component-power-side i (- j 1) k i j k))
            (add-sector (get-sector~ section)))))
      
      (define (powered-torch? i j k)
        (with-block i j k
          (lambda (section index block data)
            (bind (a b c) (case data
                            ((1) '(-1  0  0))
                            ((2) '( 1  0  0))
                            ((3) '( 0  0 -1))
                            ((4) '( 0  0  1))
                            ((5) '( 0 -1  0)))
              (with-field (+ i a) (+ j b) (+ k c)
                (lambda (section index)
                  (> (cache-powerlevel section index) 0)))))))
      
      (define (unpower-torch i j k)
        (with-block i j k
          (lambda (section index block data)
            (powerlevel-update! section index 0)
            (unless (= block 0)
              (block-set! section index 75))
            (with-field i (+ j 1) k
              (lambda (section index)
                (when (= (powerlevel-ref section index) 255)
                  (powerlevel-update section index 15))))
            (unpower-side i (+ j 1) k i j k)
            (unless (= data 1)
              (unpower-side (- i 1) j k i j k))
            (unless (= data 2)
              (unpower-side (+ i 1) j k i j k))
            (unless (= data 3)
              (unpower-side i j (- k 1) i j k))
            (unless (= data 4)
              (unpower-side i j (+ k 1) i j k))
            (unless (= data 5)
              (unpower-side i (- j 1) k i j k))
            (add-sector (get-sector~ section)))))
      
      (define (power-lever i j k)
        (with-block i j k
          (lambda (section index block data)
            (powerlevel-update section index 15)
            (bind (attach-i attach-j attach-k) (case (bitwise-and data #b111)
                                                 ((0 7) (list i (+ j 1) k))
                                                 ((1)   (list (- i 1) j k))
                                                 ((2)   (list (+ i 1) j k))
                                                 ((3)   (list i j (- k 1)))
                                                 ((4)   (list i j (+ k 1)))
                                                 ((5 6) (list i (- j 1) k)))
              (strong-power-side attach-i attach-j attach-k i j k)
              (data-set! section index (bit-set data 3 #t))
              (unless (memv? data '(0 7))
                (component-power-side i (+ j 1) k i j k))
              (unless (memv? data '(5 6))
                (component-power-side i (- j 1) k i j k))
              (unless (= data 1)
                (component-power-side (- i 1) j k i j k))
              (unless (= data 2)
                (component-power-side (+ i 1) j k i j k))
              (unless (= data 3)
                (component-power-side i j (- k 1) i j k))
              (unless (= data 4)
                (component-power-side i j (+ k 1) i j k)))
            (add-sector (get-sector~ section)))))
      
      (define (power-button i j k)
        (enqueue repeaters (list sector i j k 10))
        (power-lever i j k))
      
      (define (unpower-button i j k)
        (with-field i j k
          (lambda (section index)
            (data-set! section index (bit-set (data-ref section index) 3 #f))))
        (unpower-lever i j k))
      
      (define (unpower-lever i j k)
        (with-field i j k
          (lambda (section index)
            (bind (attach-i attach-j attach-k) (case (bit-set (data-ref section index) 3 #f)
                                                 ((0 7) (list i (+ j 1) k))
                                                 ((1)   (list (- i 1) j k))
                                                 ((2)   (list (+ i 1) j k))
                                                 ((3)   (list i j (- k 1)))
                                                 ((4)   (list i j (+ k 1)))
                                                 ((5 6) (list i (- j 1) k)))
              (with-field attach-i attach-j attach-k
                (lambda (section index)
                  (when (= (powerlevel-ref section index) 255)
                    (powerlevel-update section index 15)))))
            (data-set! section index (bit-set (data-ref section index) 3 #f))
            (powerlevel-update! section index 0)
            (add-sector (get-sector~ section))
            (unpower-side (- i 1) j k i j k)
            (unpower-side (+ i 1) j k i j k)
            (unpower-side i (- j 1) k i j k)
            (unpower-side i (+ j 1) k i j k)
            (unpower-side i j (- k 1) i j k)
            (unpower-side i j (+ k 1) i j k))))
      
      (define (power-block i j k power (component? #f))
        (let ((proc (if (= power 15) strong-power-side weak-power-side)))
          (define (block-power-side side-i side-j side-k)
            (with-block side-i side-j side-k
              (lambda (section index block data)
                (cond ((and (= block 76) (memv? data (attached-to-data i j k side-i side-j side-k)))
                       (unpower-torch side-i side-j side-k))
                      ((memv? block powerable-redstone-components)
                       (power-redstone-component side-i side-j side-k 0))
                      ((not (or (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block))))
                       (proc side-i side-j side-k i j k))))))
          
          (with-field i j k
            (lambda (section index)
              (when (or (= (powerlevel-ref section index) 255) (> power (cache-powerlevel section index)))
                (unless component?
                  (powerlevel-update section index power))
                (block-power-side (- i 1) j k)
                (block-power-side (+ i 1) j k)
                (block-power-side i (- j 1) k)
                (block-power-side i (+ j 1) k)
                (block-power-side i j (- k 1))
                (block-power-side i j (+ k 1))
                (with-field i j k
                  (lambda (section index)
                    (add-sector (get-sector~ section)))))))))
      
      (define (powered-block? i j k from-i from-j from-k)
        (define (side-powered? side-i side-j side-k)
          (if (equal? (list side-i side-j side-k) (list from-i from-j from-k))
              -1
            (with-block side-i side-j side-k
              (lambda (section index block data)
                (cond ((and (< side-j j) (= block 76))
                       15)
                      ((and (> side-j j) (memv? block '(70 72)) (bit-set? 0 data))
                       15)
                      ((and (= block 94) (= (bitwise-and data #b11) (repeater-data-in side-i side-k i k)))
                       15)
                      ((and (memv? block '(69 77 143)) (bit-set? 3 data) (memv? (bitwise-and data #b111) (attached-to-data i j k side-i side-j side-k)))
                       15)
                      ((and (not (< side-j j)) (= block 55) (or (> side-j j) (connected-redstone-to? i j k side-i side-j side-k)) (> (cache-powerlevel section index) 0) (> (get-wire-power side-i side-j side-k i j k) 0))
                       1)
                      (else 0))))))
        
        (let ((power (max (side-powered? (- i 1) j k)
                          (side-powered? (+ i 1) j k)
                          (side-powered? i (- j 1) k)
                          (side-powered? i (+ j 1) k)
                          (side-powered? i j (- k 1))
                          (side-powered? i j (+ k 1)))))
          (if (= power 0) #f power)))
      
      (define (unpower-block i j k)
        (define (unpower-block-side side-i side-j side-k)
          (with-block side-i side-j side-k
            (lambda (section index block data)
              (if (and (= block 75) (memv? data (attached-to-data i j k side-i side-j side-k)))
                  (power-torch side-i side-j side-k)
                (unpower-side side-i side-j side-k i j k)))))
        
        (with-field i j k
          (lambda (section index)
            (powerlevel-update! section index 0)
            (add-sector (get-sector~ section))
            (unpower-block-side (- i 1) j k)
            (unpower-block-side (+ i 1) j k)
            (unpower-block-side i (- j 1) k)
            (unpower-block-side i (+ j 1) k)
            (unpower-block-side i j (- k 1))
            (unpower-block-side i j (+ k 1)))))
      
      (define (repeater-data-out r-i r-k from-i from-k)
        (cond ((< r-i from-i) 3)
              ((> r-i from-i) 1)
              ((< r-k from-k) 0)
              ((> r-k from-k) 2)
              (else -1)))
      
      (define (repeater-data-in r-i r-k from-i from-k)
        (cond ((< r-i from-i) 1)
              ((> r-i from-i) 3)
              ((< r-k from-k) 2)
              ((> r-k from-k) 0)
              (else -1)))
      
      (define (power-repeater i j k)
        (with-block i j k
          (lambda (section index block data)
            (let ((delay (arithmetic-shift-right (bitwise-and data #b1100) 2)))
              (enqueue repeaters (list sector i j k delay))))))
      
      (define (effective-power-repeater i j k)
        (with-block i j k
          (lambda (section index block data)
            (block-set! section index 94)
            (add-sector (get-sector~ section))
            (case (bitwise-and data #b11)
              ((0) (strong-power-side i j (- k 1) i j k))
              ((1) (strong-power-side (+ i 1) j k i j k))
              ((2) (strong-power-side i j (+ k 1) i j k))
              ((3) (strong-power-side (- i 1) j k i j k)))
            (add-sector (get-sector~ section)))))
      
      (define (powered-repeater? i j k)
        (with-block i j k
          (lambda (section index block data)
            (bind (a b c) (case (bitwise-and data #b11)
                            ((0) (list  0 0  1))
                            ((1) (list -1 0  0))
                            ((2) (list  0 0 -1))
                            ((3) (list  1 0  0)))
              (with-field (+ i a) (+ j b) (+ k c)
                (lambda (section index)
                  (> (cache-powerlevel section index) 0)))))))
      
      (define (unpower-repeater i j k)
        (with-block i j k
          (lambda (section index block data)
            (let ((delay (arithmetic-shift-right (bitwise-and data #b1100) 2)))
              (enqueue repeaters (list sector i j k delay))))))
      
      (define (effective-unpower-repeater i j k)
        (with-block i j k
          (lambda (section index block data)
            (unless (= block 0)
              (block-set! section index 93))
            (add-sector (get-sector~ section))
            (case (bitwise-and data #b11)
              ((0) (unpower-side i j (- k 1) i j k))
              ((1) (unpower-side (+ i 1) j k i j k))
              ((2) (unpower-side i j (+ k 1) i j k))
              ((3) (unpower-side (- i 1) j k i j k)))
            (add-sector (get-sector~ section)))))
      
      (define (power-wire i j k power)
        (define (power-side side-i side-j side-k)
          (when (connected-redstone-to? side-i side-j side-k i j k)
            (let ((block (effective-block-ref side-i side-j side-k)))
              (if (= block 55)
                  (power-wire side-i side-j side-k (- power 1))
                (let ((top (effective-block-ref i (+ j 1) k))
                      (upper (effective-block-ref side-i (+ side-j 1) side-k))
                      (lower (effective-block-ref side-i (- side-j 1) side-k)))
                  (cond ((and (not (get-cube?~ (blockid->block top))) (= upper 55))
                         (power-wire side-i (+ side-j 1) side-k (- power 1)))
                        ((and (not (get-cube?~ (blockid->block block))) (= lower 55))
                         (power-wire side-i (- side-j 1) side-k (- power 1)))
                        (else
                         (weak-power-side side-i side-j side-k i j k))))))))
        
        (unless (= power 0)
          (with-field i j k
            (lambda (section index)
              (when (or (= (powerlevel-ref section index) 255) (> power (cache-powerlevel section index)))
                (powerlevel-update section index power)
                (add-sector (get-sector~ section))
                (power-side (- i 1) j k)
                (power-side (+ i 1) j k)
                (power-side i j (- k 1))
                (power-side i j (+ k 1))
                (weak-power-side i (- j 1) k i j k))))))
      
      (define (get-wire-power i j k from-i from-j from-k (other-from #f))
        (define (side-power side-i side-j side-k)
          (if (equal? (list side-i side-j side-k) (list from-i from-j from-k))
              0
            (with-block side-i side-j side-k
              (lambda (section index block data)
                (let ((p (max
                           (cond ((= block 55)
                                  (- (get-wire-power side-i side-j side-k i j k) 1))
                                 ((= block 76)
                                  15)
                                 ((and (memv? block '(69 77 143)) (bit-set? 3 data))
                                  15)
                                 ((and (= block 94) (= (bitwise-and data #b11) (repeater-data-in side-i side-k i k)))
                                  15)
                                 ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)) (> (cache-powerlevel section index) 1) (if other-from (not (equal? (list side-i side-j side-k) other-from)) #t))
                                  15)
                                 (else
                                  0))
                           (or
                             (with-block side-i (- side-j 1) side-k
                               (lambda (section index under data)
                                 (and (not (equal? (list side-i (- side-j 1) side-k) (list from-i from-j from-k))) (= under 55) (not (get-cube?~ (blockid->block block))) (> (cache-powerlevel section index) 0) (- (get-wire-power side-i (- side-j 1) side-k i j k (list from-i from-j from-k)) 1))))
                             (with-block side-i (+ side-j 1) side-k
                               (lambda (section index upper data)
                                 (and (not (equal? (list side-i (+ side-j 1) side-k) (list from-i from-j from-k))) (= upper 55) (not (get-cube?~ (blockid->block (effective-block-ref i (+ j 1) k)))) (> (cache-powerlevel section index) 0) (- (get-wire-power side-i (+ side-j 1) side-k i j k (list from-i from-j from-k)) 1))))
                             0))))
                  p)))))
        
        (define (top-power)
          (with-block i (+ j 1) k
            (lambda (section index block data)
              (if (or (= block 76)
                      (and (memv? block '(69 77 143)) (bit-set? 3 data))
                      (and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)) (> (cache-powerlevel section index) 1)))
                  15
                0))))
        
        (max
          (side-power (- i 1) j k)
          (side-power (+ i 1) j k)
          (side-power i j (- k 1))
          (side-power i j (+ k 1))
          (if (equal? (list i (+ j 1) k) (list from-i from-j from-k))
              0
            (top-power))
          (if (equal? (list i (- j 1) k) (list from-i from-j from-k))
              0
            (with-block i (- j 1) k
              (lambda (section index block data)
                (if (and (get-opaque-cube?~ (blockid->block block)) (get-cube?~ (blockid->block block)) (> (cache-powerlevel section index) 1))
                    15
                  0))))))
      
      (define (unpower-wire-part i j k)
        (define (unpower-wire-side side-i side-j side-k)
          (when (and (/= (effective-block-ref side-i side-j side-k) 55) (connected-redstone-to? side-i side-j side-k i j k))
            (unpower-side side-i side-j side-k i j k)))
        
        (unpower-wire-side (- i 1) j k)
        (unpower-wire-side (+ i 1) j k)
        (unpower-wire-side i j (- k 1))
        (unpower-wire-side i j (+ k 1))
        (unpower-side i (- j 1) k i j k))
      
      (define (unpower-wire i j k (delete? #f))
        (let ((changed (new-queue))
              (propagate-spots (new-queue)))
          (define (unpower i j k)
            (with-field i j k
              (lambda (section index)
                (add-sector (get-sector~ section))
                (let ((power (if delete? (begin (set! delete? #f) (cache-powerlevel section index 55)) (cache-powerlevel section index))))
                  (define (check-side side-i side-j side-k)
                    (with-block side-i side-j side-k
                      (lambda (section index block data)
                        (when section
                          (if (= block 55)
                              (let ((new-power (cache-powerlevel section index)))
                                (unless (= new-power 0)
                                  (if (< new-power power)
                                      (unpower side-i side-j side-k)
                                    (enqueue propagate-spots (list side-i side-j side-k)))))
                            (begin
                              (with-block side-i (+ side-j 1) side-k
                                (lambda (section index upper data)
                                  (when (and (= upper 55) (not (get-cube?~ (blockid->block (effective-block-ref i (+ j 1) k)))))
                                    (let ((new-power (cache-powerlevel section index)))
                                      (unless (= new-power 0)
                                        (if (< new-power power)
                                            (unpower side-i (+ side-j 1) side-k)
                                          (enqueue propagate-spots (list side-i (+ side-j 1) side-k))))))))
                              (with-block side-i (- side-j 1) side-k
                                (lambda (section index lower data)
                                  (when (and (= lower 55) (not (get-cube?~ (blockid->block block))))
                                    (let ((new-power (cache-powerlevel section index)))
                                      (unless (= new-power 0)
                                        (if (< new-power power)
                                            (unpower side-i (- side-j 1) side-k)
                                          (enqueue propagate-spots (list side-i (- side-j 1) side-k))))))))
                              (cond ((and (= block 94) (= (bitwise-and data #b11) (repeater-data-in side-i side-k i k)))
                                     (enqueue propagate-spots (list side-i side-j side-k)))
                                    ((= block 76)
                                     (enqueue propagate-spots (list side-i side-j side-k)))
                                    ((and (memv? block '(69 77 143)) (bit-set? 3 data))
                                     (enqueue propagate-spots (list side-i side-j side-k)))
                                    ((and (memv? block '(70 72)) (bit-set? 0 data))
                                     (enqueue propagate-spots (list side-i side-j side-k)))
                                    ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)) (= (cache-powerlevel section index) 15))
                                     (enqueue propagate-spots (list side-i side-j side-k))))))))))
                  
                  (define (top-powered?)
                    (with-block i (+ j 1) k
                      (lambda (section index block data)
                        (when (or
                                (= block 76)
                                (and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)) (= (cache-powerlevel section index) 15))
                                (and (memv? block '(69 77 143)) (bit-set? 3 data)))
                          (enqueue propagate-spots (list i (+ j 1) k))))))
                  
                  (unless (= power 0)
                    (powerlevel-update! section index 0)
                    (enqueue changed (list i j k))
                    (check-side (- i 1) j k)
                    (check-side (+ i 1) j k)
                    (check-side i j (- k 1))
                    (check-side i j (+ k 1))
                    (top-powered?)
                    (with-block i (- j 1) k
                      (lambda (section index block data)
                        (when (and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)) (= (cache-powerlevel section index) 15))
                          (enqueue propagate-spots (list i (- j 1) k))))))))))
          
          (unpower i j k)
          (let (propagate)
            (unless (queue-empty? propagate-spots)
              (bind (i j k) (dequeue propagate-spots)
                (with-block i j k
                  (lambda (section index block data)
                    (let ((power (cache-powerlevel section index)))
                      (cond ((= block 55)
                             (powerlevel-update! section index 0)
                             (power-wire i j k power))
                            ((= block 94)
                             (power-repeater i j k))
                            ((= block 69)
                             (power-lever i j k))
                            ((= block 76)
                             (power-torch i j k))
                            ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)))
                             (power-block i j k 1)))
                      (add-sector (get-sector~ section))))))
              (propagate)))
          (let (update)
            (unless (queue-empty? changed)
              (bind (i j k) (dequeue changed)
                (with-field i j k
                  (lambda (section index)
                    (when (= (cache-powerlevel section index) 0)
                      (unpower-wire-part i j k)))))
              (update)))))
      
      (define (attached-to-data block-i block-j block-k comp-i comp-j comp-k)
        (cond ((> block-i comp-i) '(2))
              ((< block-i comp-i) '(1))
              ((> block-j comp-j) '(0 7))
              ((< block-j comp-j) '(5 6))
              ((> block-k comp-k) '(4))
              ((< block-k comp-k) '(3))))
      
      (define (power-redstone-component i j k power)
        (with-block i j k
          (lambda (section index block data)
            (case block
              ((123)
               (when (> power 0)
                 (power-block i j k 1))
               (powerlevel-update section index power)
               (block-set! section index 124))
              ((29 33)
               (unless (bit-set? 3 data)
                 (piston-extend i j k))
               (when old-redstone? ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 (when (> power 0)
                   (power-block i j k 1))
                 (powerlevel-update section index power)))
              ((64 71)
               (if (bit-set? 3 data)
                   (with-block i (- j 1) k
                     (lambda (section index block data)
                       (unless (bit-set? 2 data)
                         (data-set! section index (bit-set data 2 #t))
                         (add-sector (get-sector~ section)))))
                 (unless (bit-set? 2 data)
                   (data-set! section index (bit-set data 2 #t))))))
            (add-sector (get-sector~ section)))))
      
      (define (powered-redstone-component? i j k)
        (define (side-powered? side-i side-j side-k)
          (with-block side-i side-j side-k
            (lambda (section index block data)
              (cond ((and (memv? block (if old-redstone? '(29 33 124) '(124))) (> (cache-powerlevel section index) 0)) ;;;;;;;;;;;;;;;;
                     0)
                    ((and (get-cube?~ (blockid->block block)) (get-opaque-cube?~ (blockid->block block)) (> (cache-powerlevel section index) 0))
                     0)
                    ((and (= block 76) (not (memv? data (attached-to-data i j k side-i side-j side-k))))
                     (if (< side-j j)
                         15
                       0))
                    ((and (memv? block '(70 72)) (bit-set? 0 data))
                     (if (> side-j j)
                         15
                       0))
                    ((and (= block 94) (= j side-j) (= (bitwise-and data #b11) (repeater-data-in side-i side-k i k)))
                     15)
                    ((and (memv? block '(69 77 143)) (bit-set? 3 data))
                     (if (memv? (bitwise-and data #b111) (attached-to-data i j k side-i side-j side-k))
                         15
                       0))
                    ((and (not (< side-j j)) (= block 55) (or (> side-j j) (connected-redstone-to? i j k side-i side-j side-k)) (> (cache-powerlevel section index) 0))
                     1)
                    (else
                     -1)))))
        
        (let ((power (max (side-powered? (- i 1) j k)
                          (side-powered? (+ i 1) j k)
                          (side-powered? i (- j 1) k)
                          (side-powered? i (+ j 1) k)
                          (side-powered? i j (- k 1))
                          (side-powered? i j (+ k 1)))))
          (if (= power -1) #f power)))
      
      (define (piston-extend i j k)
        (define (count-blocks a b c number)
          (let ((next (+ number 1)))
            (with-block (+ i (* a next)) (+ j (* b next)) (+ k (* c next))
              (lambda (section index block data)
                (if section
                    (cond ((or (memv? block unmovable-objects) (and (memv? block '(29 33)) (not (bit-set? 3 data))))
                           #f)
                          ((memv? block break-extend)
                           number)
                          (else
                           (if (= number 12)
                               #f
                             (count-blocks a b c next))))
                  #f)))))
        
        (with-block i j k
          (lambda (section index block data)
            (let ((number (case data
                            ((0) (count-blocks  0 -1  0 0))
                            ((1) (count-blocks  0  1  0 0))
                            ((2) (count-blocks  0  0 -1 0))
                            ((3) (count-blocks  0  0  1 0))
                            ((4) (count-blocks -1  0  0 0))
                            ((5) (count-blocks  1  0  0 0)))))
              (when number
                (let ((block #f)
                      (block-data #f)
                      (temp #f)
                      (temp-data #f))
                  (data-set! section index (bit-set data 3 #t))
                  (loop (for x from 0 to number)
                        (bind (i j k) (case data
                                        ((0) (list i (- j (+ x 1)) k))
                                        ((1) (list i (+ j (+ x 1)) k))
                                        ((2) (list i j (- k (+ x 1))))
                                        ((3) (list i j (+ k (+ x 1))))
                                        ((4) (list (- i (+ x 1)) j k))
                                        ((5) (list (+ i (+ x 1)) j k)))
                          (with-field i j k
                            (lambda (section index)
                              (add-sector (get-sector~ section))
                              (if (= x 0)
                                  (begin
                                    (set! block (block-ref section index))
                                    (set! block-data (data-ref section index))
                                    (block-set! section index 34)
                                    (data-set! section index data)
                                    (blocklight-set! section index 0))
                                (begin
                                  (set! temp (block-ref section index))
                                  (set! temp-data (data-ref section index))
                                  (block-set! section index block)
                                  (data-set! section index block-data)
                                  (blocklight-set! section index 0)
                                  (set! block temp)
                                  (set! block-data temp-data)))))
                          (block-update i j k))))
                (play-sound-file "sound/piston/out" volume: .1))))))
      
      (define (piston-retract i j k block-id)
        (define (retract-direction a b c)
          (with-block (+ i a) (+ j b) (+ k c)
            (lambda (section index block data)
              (block-set! section index 0)
              (data-set! section index 0)
              (add-sector (get-sector~ section))
              (block-update (+ i a) (+ j b) (+ k c))
              (when (= block-id 29)
                (with-block (+ i (* a 2)) (+ j (* b 2)) (+ k (* c 2))
                  (lambda (fore-section fore-index fore-block fore-data)
                    (unless (or (memv? fore-block unmovable-objects) (memv? fore-block break-extend) (and (memv? fore-block '(29 33)) (bit-set? 3 fore-data)))
                      (add-sector (get-sector~ fore-section))
                      (block-set! section index fore-block)
                      (data-set! section index fore-data)
                      (block-set! fore-section fore-index 0)
                      (data-set! fore-section fore-index 0)
                      (with-section fore-section fore-index
                        (lambda (i j k)
                          (block-update i j k)
                          (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!))))))))))
        
        (with-block i j k
          (lambda (section index block data)
            (data-set! section index (bit-set data 3 #f))
            (add-sector (get-sector~ section))
            (case (bit-set data 3 #f)
              ((0) (retract-direction  0 -1  0))
              ((1) (retract-direction  0  1  0))
              ((2) (retract-direction  0  0 -1))
              ((3) (retract-direction  0  0  1))
              ((4) (retract-direction -1  0  0))
              ((5) (retract-direction  1  0  0)))))
        (play-sound-file "sound/piston/in" volume: .1))
      
      (define (unpower-redstone-component i j k)
        (with-block i j k
          (lambda (section index block data)
            (let ((power (cache-powerlevel section index)))
              (case block
                ((124)
                 (block-set! section index 123)
                 (powerlevel-update! section index 0)
                 (when (> power 0)
                   (unpower-block i j k)))
                ((29 33)
                 (powerlevel-update! section index 0)
                 (when (bit-set? 3 data)
                   (piston-retract i j k block)
                   (when old-redstone? ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     (unpower-block i j k))))
                ((64 71)
                 (if (bit-set? 3 data)
                     (with-block i (- j 1) k
                       (lambda (section index block data)
                         (when (bit-set? 2 data)
                           (data-set! section index (bit-set data 2 #f))
                           (add-sector (get-sector~ section)))))
                   (when (bit-set? 2 data)
                     (data-set! section index (bit-set data 2 #f))))))
              (add-sector (get-sector~ section))))))
      
      (define (connected-redstone-to? block-i block-j block-k wire-i wire-j wire-k)
        (define (side-connected? side-i side-j side-k)
          (let ((side-id (effective-block-ref side-i side-j side-k))
                (side-data-id (effective-data-ref side-i side-j side-k)))
            (cond ((memv? side-id (cons 55 redstone-power-components))
                   #t)
                  ((and (memv? side-id '(93 94)) (memv? (bitwise-and side-data-id #b11) (cond ((/= side-i wire-i) '(1 3))
                                                                                              (else '(0 2)))))
                   #t)
                  ((or (get-opaque-cube?~ (blockid->block side-id)) ;;solid block...
                       (= side-id 89) ;;glowstone...
                       (and (memv? side-id '(44 126)) (> side-data-id 7))) ;;upside-down slab...
                   (and (= (effective-block-ref side-i (+ side-j 1) side-k) 55) ;;...with redstone on it..
                        (or (not (get-cube?~ (blockid->block (effective-block-ref wire-i (+ wire-j 1) wire-k)))) ;;...and nothing blocks the way
                            (memv? (effective-block-ref wire-i (+ wire-j 1) wire-k) '(20 138))))) ;;glass and beacons dont block
                  ((or (not (get-cube?~ (blockid->block side-id))) 
                       (memv? side-id '(20 138)))
                   (= (effective-block-ref side-i (- side-j 1) side-k) 55))
                  ((memv? side-id '(93 94))
                   (let ((required-data-id (cond ((/= wire-i side-i) '(1 3))
                                                 (else               '(0 2)))))
                     (memv? (bitwise-and side-data-id #b11) required-data-id)))
                  (else #f))))
        
        (let ((wire-side (cond ((< block-i wire-i) 'left)
                               ((> block-i wire-i) 'right)
                               ((< block-k wire-k) 'back)
                               ((> block-k wire-k) 'front)))
              (left?  (side-connected? (- wire-i 1) wire-j wire-k))
              (right? (side-connected? (+ wire-i 1) wire-j wire-k))
              (back?  (side-connected? wire-i wire-j (- wire-k 1)))
              (front? (side-connected? wire-i wire-j (+ wire-k 1))))
          (or (not (or left? right? back? front?))
              (case wire-side
                ((left) (or left? (and right? (not back?) (not front?))))
                ((right) (or right? (and left? (not back?) (not front?))))
                ((back) (or back? (and front? (not left?) (not right?))))
                ((front) (or front? (and back? (not left?) (not right?))))))))
      
      (with-field i j k
        (lambda (section index)
          (case action
            ((place) (case block
                       ((55) (power-wire i j k (get-wire-power i j k i j k)))
                       ((76) (if (powered-torch? i j k)
                                 (block-set! section index 75)
                               (power-torch i j k)))
                       ((93) (when (powered-repeater? i j k)
                               (power-repeater i j k)))
                       ((29 33 123) (let ((power (powered-redstone-component? i j k)))
                                (when power
                                  (power-redstone-component i j k power))))))
            ((activate) (case block
                          ((69) (power-lever i j k))
                          ((77 143) (power-button i j k))
                          ((93) (effective-power-repeater i j k))))
            ((deactivate) (case block
                            ((77 143) (unpower-button i j k))
                            ((69) (unpower-lever i j k))
                            ((94) (effective-unpower-repeater i j k))))
            ((delete) (case block
                        ((55)
                         (unpower-wire i j k #t)
                         (unpower-wire-part i j k))
                        ((76) (unpower-torch i j k))
                        ((94) (effective-unpower-repeater i j k)))))))))
  
  
  (method override (mouse-up h v)
    (with-interaction
      (lambda (poly block fore)
        (delete-block-at block))))
  
  
  (method override (right-mouse-up h v)
    (let ((world (current-world))
          (zone (current-zone)))
      (with-interaction
        (lambda (poly block fore)
          (call-with-position~ zone block
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
              (let ((block (blockid->block block-id)))
                (let ((right-mouse (get-right-mouse~ block)))
                  (if (not right-mouse)
                      (let ((slot (selected-slot~ (child~ (get-interface~ world) 'belt))))
                        (let ((id (get-id~ slot)))
                          (when id
                            (add-block-at poly fore id)
                            (decrease-count~ slot))))
                    (right-mouse region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!))))))))))
  
  
  (method override (mouse-wheel h v delta)
    (let ((world (current-world)))
      (if (shift-down?)
          (let ((d (get-h~ delta)))
            (cond ((> d 0)
                   (zoom-in~ world))
                  ((< d 0)
                   (zoom-out~ world))))
        (let ((d (get-v~ delta)))
          (cycle-selection~ (child~ (get-interface~ world) 'belt) d)))))))
