;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Minecraft
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Édouard Hébert


(module world.external.minecraft jazz


(export (world.external.minecraft.generate))
(import (jazz.geometry)
        (jazz.platform)
        (world)
        (world.audio)
        (world.autoload)
        (world.external.minecraft.generate)
        (world.game)
        (world.geometry)
        (world.interface.inventory)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Game
;;;


(class Minecraft-Game extends World-Game
  
  
  (slot repeaters       initialize '()                          accessors generate)
  (slot pressure-plates initialize (make-table)                 accessors generate)
  (slot lava-blocks     initialize (new-queue)                  accessors generate)
  (slot water-blocks    initialize (new-queue)                  accessors generate)
  (slot fall-blocks     initialize (new-queue)                  accessors generate)
  
  
  (definition redstone-power-components
    '(28 69 70 72 75 76 77 143)) ;; DetectorRail Lever StonePressurePlate WoodenPressurePlate RedstoneTorchOff RedstoneTorchOn StoneButton WoodenButton
  
  (definition unmovable-objects
    '(7 23 25 34 49 52 54 61 63 84 90 116 117 119 120 130 138)) ;; Bedrock Dispenser NoteBlock PistonHead Obsidian MonsterSpawner Chest Furnace SignPost Jukebox Portal EnchantmentTable BrewingStand EndPortal EndPortalFrame EnderChest BeaconBlock
  
  (definition break-extend
    '(0 8 9 10 11 18 26 30 37 38 39 40 50 51 55 59 64 70 71 72 75 76 77 81 83 86 91 92 93 94 103 122 140 141 142 143)) ;; Air Water StationaryWater Lava StationaryLava Leaves BedBlock Web Dandelion Rose BrownMushroom RedMushroom Torch Fire RedstoneWire WheatCrops WoodenDoorBlock StonePressurePlate IronDoorBlock WoodenPressurePlate RedstoneTorchOff RedstoneTorchOn StoneButton Cactus SugarCane Pumpkin Jack-O-Lantern CakeBlock RedstoneRepeaterBlockOff RedstoneRepeaterBlockOn MelonBlock DragonEgg FlowerPot Carrots Potatoes WoodenButton
  
  (definition updatable-components
    '(29 33 34 46 55 64 71 75 76 93 94 123 124 137))
  
  (definition double-abc
    '((-1 0 0) (0 0 1) (1 0 0) (0 0 -1) (0 -1 0) (0 1 0) (-2 0 0) (-1 0 -1) (0 0 2) (1 0 1) (2 0 0) (1 0 -1) (0 0 -2) (-1 0 -1) (-1 -1 0) (0 -1 1) (1 -1 0) (0 -1 -1) (0 -2 0) (-1 1 0) (0 1 1) (1 1 0) (0 1 -1) (0 2 0)))
  
  (definition single-abc
    '((-1 0 0) (0 0 1) (1 0 0) (0 0 -1) (0 -1 0) (0 1 0)))
  
  (definition attached-abc
    #(((-1 0 0) (0 0 1) (1 0 0) (0 0 -1) (0 -1 0) (0 1 0) (-1 1 0) (0 1 1) (1 1 0) (0 1 -1) (0 2 0))
      ((-1 0 0) (0 0 1) (1 0 0) (0 0 -1) (0 -1 0) (0 1 0) (-2 0 0) (-1 0 1) (-1 0 -1) (-1 -1 0) (-1 1 0))
      ((-1 0 0) (0 0 1) (1 0 0) (0 0 -1) (0 -1 0) (0 1 0) (1 0 1) (2 0 0) (1 0 -1) (1 -1 0) (1 1 0))
      ((-1 0 0) (0 0 1) (1 0 0) (0 0 -1) (0 -1 0) (0 1 0) (-1 0 -1) (1 0 -1) (0 0 -2) (0 -1 -1) (0 1 -1))
      ((-1 0 0) (0 0 1) (1 0 0) (0 0 -1) (0 -1 0) (0 1 0) (-1 0 1) (0 0 2) (1 0 1) (0 -1 1) (0 1 1))
      ((-1 0 0) (0 0 1) (1 0 0) (0 0 -1) (0 -1 0) (0 1 0) (-1 -1 0) (0 -1 1) (1 -1 0) (0 -1 -1) (0 -2 0))))
  
  (method (add-fall-block sector i j k)
    (let ((item (list sector i j k)))
      (unless (member? item (queue-list fall-blocks))
        (enqueue fall-blocks item))))
  
  (method (with-interaction proc)
    (let ((world (current-world))
          (camera (current-camera)))
      (let ((pos (get-down-point~ world)))
        (when pos
          (receive (position direction) (screen->ray~ camera (get-h~ pos) (get-v~ pos))
            (let ((max-distance (get-view-radius~ world)))
              (let ((closest (ray-closest-polygon~ world (get-position~ camera) direction max-distance ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
                (when closest
                  (let ((poly (car closest)))
                    (with-polygon-interaction poly
                      proc))))))))))
  
  
  (method (with-polygon-interaction poly proc)
    (let ((center (get-center~ poly))
          (normal (get-normal~ poly)))
      (let ((block (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly)))
            (fore (vertex+ center (vertex-scalar*& normal .5))))
        (proc poly block fore))))
  
  
  (method (add-block-at poly fore id)
    (let ((zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (call-with-position~ zone fore
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
              (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)))))))
  

  (method (delete-block-at block)
    (let ((world (current-world))
          (zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (call-with-position~ zone block
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
              (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)))))
      (reset-selection~ world)))

  
  (method (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
    (with-field i j k
      (lambda (section index)
        (define (set-blockid id)
          (define (determine-torch-rotation)
            (case (polygon-orientation)
              ((up down) 5)
              ((east) 1)
              ((west) 2)
              ((south) 3)
              ((north) 4)))
          
          (define (determine-lever-rotation)
            (case (polygon-orientation)
              ((up) 5)
              ((down) 7)
              ((east) 1)
              ((west) 2)
              ((south) 3)
              ((north) 4)))
          
          (define (determine-button-rotation)
            (case (polygon-orientation)
              ((up) 5)
              ((down) 0)
              ((east) 1)
              ((west) 2)
              ((south) 3)
              ((north) 4)))
          
          (define (determine-ladder-rotation)
            (case (polygon-orientation)
              ((up down) 2)
              ((north) 2)
              ((south) 3)
              ((west) 4)
              ((east) 5)))
          
          (define (polygon-orientation)
            (let ((normal (get-normal~ poly)))
              (if (> (vertex-y normal) 0.)
                  'up
                (if (< (vertex-y normal) 0.)
                    'down
                  (let ((angle (plane-angle 1. 0. (vertex-x normal) (vertex-z normal))))
                    (cond ((or (between? angle 0. PI/4) (between? angle (- PI*2 PI/4) PI*2)) 'east)
                          ((between? angle PI/4 (* 3. PI/4)) 'north)
                          ((between? angle (* 3. PI/4) (* 5. PI/4)) 'west)
                          (else 'south)))))))
          
          (define (determine-piston-rotation)
            (let ((normal (get-normal~ poly)))
              (cond ((> (vertex-y normal) 0.) 1)
                    ((< (vertex-y normal) 0.) 0)
                    ((> (vertex-x normal) 0.) 5)
                    ((< (vertex-x normal) 0.) 4)
                    ((> (vertex-z normal) 0.) 2)
                    ((< (vertex-z normal) 0.) 3))))
          
          (define (determine-other-rotation)
            (let ((camera (current-camera)))
              (let ((sight (get-sight~ (get-lookat~ camera))))
                (let ((direction (vertex-normalize (vertex (vertex-x sight) 0. (vertex-z sight)))))
                  (let ((angle (plane-angle 1. 0. (vertex-x direction) (vertex-z direction))))
                    (cond ((or (between? angle 0. PI/4) (between? angle (* 7 PI/4) (* 2 PI)))
                           1)
                          ((between? angle PI/4 (* 3 PI/4))
                           0)
                          ((between? angle (* 3 PI/4) (* 5 PI/4))
                           3)
                          (else
                           2)))))))
          
          (define (add-liquid-blocks)
            (define (add-side-block side-i side-j side-k)
              (with-field side-i side-j side-k
                (lambda (section index)
                  (when (and section (memq? (block-ref section index) '(8 9)))
                    (enqueue water-blocks (cons (get-sector~ section) (index->coordinates index))))
                  (when (and section (memq? (block-ref section index) '(10 11)))
                    (enqueue lava-blocks (cons (get-sector~ section) (index->coordinates index)))))))
            
            (when (memq? id '(8 9))
              (enqueue water-blocks (list sector i j k)))
            (when (memq? id '(10 11))
              (enqueue lava-blocks (list sector i j k)))
            (add-side-block (- i 1) j k)
            (add-side-block (+ i 1) j k)
            (add-side-block i (- j 1) k)
            (add-side-block i (+ j 1) k)
            (add-side-block i j (- k 1))
            (add-side-block i j (+ k 1)))
          
          (block-set! section index id)
          (if poly
              (ccase id
                     ((RedstoneTorchOn Torch)
                      (data-set! section index (determine-torch-rotation)))
                     ((Lever)
                      (data-set! section index (determine-lever-rotation)))
                     ((WoodenButton StoneButton)
                      (data-set! section index (determine-button-rotation)))
                     ((Ladder)
                      (data-set! section index (determine-ladder-rotation)))
                     ((Piston StickyPiston)
                      (data-set! section index (determine-piston-rotation)))
                     ((RedstoneRepeaterBlockOff)
                      (data-set! section index (determine-other-rotation)))
                     ((Sand Gravel)
                      (add-fall-block sector i j k)))
            (data-set! section index 0))
          @w(add-liquid-blocks)
          (redstone-update sector (list i j k id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!))
        
        (if (and poly (id? (fxround (get-data1~ poly)) Vines DeadBush RedMushroom BrownMushroom  TallGrass DoublePlant))
            (call-with-position~ (current-zone) (vertex (get-data2~ poly)
                                                        (get-data3~ poly)
                                                        (get-data4~ poly))
              (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                (let ((new-poly (new world.polygon:Polygon (get-element~ poly) (vector (vertex& (- x .5) (- y 1.) (- z .5)) (vertex& (- x .5) (- y 1.) (+ z .5)) (vertex& (+ x .5) (- y 1.) (- z .5)) (vertex& (+ x .5) (- y 1.) (+ z .5))))))
                  (with-field i j k
                    (lambda (section index)
                      (add-sector (get-sector~ section))
                      (block-set! section index Air)))
                  (set-data1~ new-poly 1.)
                  (add-block #f id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
          (begin
            (case id
              ((54)
               (block-entity-add region sector i j k)))
            
            (let ((brightness (get-brightness~ (blockid->block id))))
              (when (= (block-ref section index) air-id)
                (cond (brightness
                        (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                        (propagate-light i j k brightness add-sector with-field block-ref blocklight-ref blocklight-set!)
                        (set-blockid id)
                        (inverse-propagate-skylight i j k (skylight-ref section index) add-sector with-field block-ref skylight-ref skylight-set!))
                      (else
                       (set-blockid id)
                       (inverse-propagate-skylight i j k (skylight-ref section index) add-sector with-field block-ref skylight-ref skylight-set!)
                       (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                       (when (get-opaque-cube?~ (blockid->block id))
                         (blocklight-set! section index 0))))))
            (add-sector sector))))))
  
  
  (method (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
    ;; can be improved by testing for opaque blocks in all directions
    ;; and then testing that every block in all directions is opaque
    (define (add-neighbors add-sector)
      (define (add i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              @w(when (memq? (block-ref section index) '(8 9))
                (enqueue water-blocks (cons (get-sector~ section) (index->coordinates index))))
              @w(when (memq? (block-ref section index) '(10 11))
                (enqueue lava-blocks (cons (get-sector~ section) (index->coordinates index))))))))
      
      (add (- i 1) j k)
      (add (+ i 1) j k)
      (add i (- j 1) k)
      (add i (+ j 1) k)
      (add i j (- k 1))
      (add i j (+ k 1)))
    
    (add-neighbors add-sector)
    (with-field i j k
      (lambda (section index)
        (define (find-max-light-around i j k)
          (define (find-light i j k)
            (with-field i j k
              (lambda (section index)
                (if (not section)
                    0
                  (blocklight-ref section index)))))
          
          (let ((left (find-light (- i 1) j k))
                (right (find-light (+ i 1) j k))
                (down (find-light i (- j 1) k))
                (up (find-light i (+ j 1) k))
                (back (find-light i j (- k 1)))
                (front (find-light i j (+ k 1))))
            (max left right down up back front)))
        
        (define (get-skylight i j k)
          (define (top-skylight)
            (with-field i (+ j 1) k
              (lambda (section index)
                (or (when section
                      (let ((light (skylight-ref section index)))
                        (if (= light 15) 15 (- light 1))))
                    0))))
          
          (define (side-skylight i j k)
            (with-field i j k
              (lambda (section index)
                (or (when section
                      (- (skylight-ref section index) 1))
                    0))))
          
          (max (top-skylight)
               (side-skylight (- i 1) j k)
               (side-skylight (+ i 1) j k)
               (side-skylight i j (- k 1))
               (side-skylight i j (+ k 1))
               (side-skylight i (- j 1) k)
               0))
        
        (let ((brightness (get-brightness~ (blockid->block block-id))))
          (block-set! section index 0)
          (when (id? block-id IronDoorBlock WoodenDoorBlock DoublePlant)
            (with-field i ((if (bit-set? 3 data-id) - +) j 1) k
              (lambda (section index)
                (block-set! section index 0)
                (data-set! section index 0))))
          (if brightness
              (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
            (begin
              (blocklight-set! section index 0)
              (propagate-light i j k (- (find-max-light-around i j k) 1) add-sector with-field block-ref blocklight-ref blocklight-set!)))
          (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
          (skylight-set! section index (get-skylight i j k))
          (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
          (redstone-update sector (list i j k block-id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!)
          (data-set! section index 0)))))
  
  
  (method (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (propagate i j k light)
        (with-field i j k
          (lambda (section index)
            (when section
              ;; always adding the sector covers the case where the light changes
              ;; and we need to update all neighboring sectors even if no light changes for
              ;; them like when putting a torch next to a wall that is in the next sector
              (add-sector (get-sector~ section))
              (when (and (> light 0)
                         (< (blocklight-ref section index) light)
                         (not (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                (blocklight-set! section index light)
                (let ((light (- light 1)))
                  (define (add-queue i j k)
                    (enqueue queue (list i j k light)))
                  
                  (add-queue (- i 1) j k)
                  (add-queue (+ i 1) j k)
                  (add-queue i (- j 1) k)
                  (add-queue i (+ j 1) k)
                  (add-queue i j (- k 1))
                  (add-queue i j (+ k 1))))
              (let (iter)
                (unless (queue-empty? queue)
                  (apply propagate (dequeue queue))
                  (iter)))))))
      
      (propagate i j k light)))
  
  
  (method (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (inverse-propagate i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (let ((light (blocklight-ref section index)))
                (define (look-around i j k light)
                  (with-field i j k
                    (lambda (section index)
                      (when section
                        (add-sector (get-sector~ section))
                        (let ((new-light (blocklight-ref section index)))
                          (unless (= new-light 0)
                            (if (< new-light light)
                                (inverse-propagate i j k)
                              (enqueue queue (list i j k)))))))))
                
                (unless (= light 0)
                  (blocklight-set! section index 0)
                  (look-around (- i 1) j k light)
                  (look-around (+ i 1) j k light)
                  (look-around i (- j 1) k light)
                  (look-around i (+ j 1) k light)
                  (look-around i j (- k 1) light)
                  (look-around i j (+ k 1) light)))))))
      
      (inverse-propagate i j k)
      (let (iter)
        (unless (queue-empty? queue)
          (bind (i j k) (dequeue queue)
            (with-field i j k
              (lambda (section index)
                (let ((light (blocklight-ref section index)))
                  (unless (= light 0)
                    (blocklight-set! section index 0)
                    (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!))))))
          (iter)))))
  
  
  (method (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((queue (new-queue)))
      (define (propagate i j k light (first #f))
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (when (and (> light 0)
                         (or first (> light (skylight-ref section index)))
                         (not (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                (skylight-set! section index light)
                (let ((light2 (- light 1)))
                  (define (add-queue i j k (amount light2))
                    (enqueue queue (list i j k amount)))
                  
                  (add-queue (- i 1) j k)
                  (add-queue (+ i 1) j k)
                  (add-queue i (- j 1) k (if (= light 15) 15 light2))
                  (unless (= light 15)
                    (add-queue i (+ j 1) k))
                  (add-queue i j (- k 1))
                  (add-queue i j (+ k 1))))
              (let (iter)
                (unless (queue-empty? queue)
                  (apply propagate (dequeue queue))
                  (iter)))))))
      
      (with-field i j k
        (lambda (section index)
          (propagate i j k (skylight-ref section index) #t)))))
  
  
  (method (inverse-propagate-skylight i j k first-light add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((inverse-spots (new-queue))
          (propagate-spots (new-queue)))
      (define (add-queue item queue)
        (unless (member? item (queue-list queue))
          (enqueue queue item)))
      
      (define (inverse-propagate i j k previous (first #f))
        (with-field i j k
          (lambda (section index)
            (when section
              (let ((current-light (if first first-light (skylight-ref section index))))
                (define (add-around)
                  (add-queue (list (- i 1) j k current-light) inverse-spots)
                  (add-queue (list (+ i 1) j k current-light) inverse-spots)
                  (add-queue (list i j (- k 1) current-light) inverse-spots)
                  (add-queue (list i j (+ k 1) current-light) inverse-spots)
                  (add-queue (list i (+ j 1) k current-light) inverse-spots)
                  (add-queue (list i (- j 1) k (if (= current-light 15) 16 current-light)) inverse-spots))
                
                (unless (and (not first)
                             (or (= current-light 0)
                                 (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                  (if (or first (< current-light previous))
                      (begin
                        (skylight-set! section index 0)
                        (add-sector (get-sector~ section))
                        (add-around))
                    (begin
                      (add-queue (list i j k) propagate-spots)))))))))
      
      (inverse-propagate i j k 0 #t)
      (let (iter-inverse)
        (unless (queue-empty? inverse-spots)
          (apply inverse-propagate (dequeue inverse-spots))
          (iter-inverse)))
      (let (iter-propagate)
        (unless (queue-empty? propagate-spots)
          (bind (i j k) (dequeue propagate-spots)
            (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
            (iter-propagate))))))
  
  
  (method (pressure-plates-update add-to remove-from actor) ;; bug: getting off and on quickly
    (define (table-remove table key)
      (list->table (map (lambda (x) (cons x (table-ref table x))) (remove key (table-keys table) test: equal?))))
    
    (define (pp-test pp1 pp2)
      (when (and (is? pp1 Pressure-Plate) (is? pp2 Pressure-Plate))
        (equal? (location~ pp1) (location~ pp2))))
    
    (let ((zone (current-zone)))
      (for-each (lambda (pos)
                  (let ((pp (table-ref pressure-plates pos #f)))
                    (if pp
                        (begin
                          (set-colliders~ pp (cons actor (get-colliders~ pp)))
                          (table-set! pressure-plates pos pp))
                      (call-with-position~ zone pos ;; add new pressure plate
                        (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                          (table-set! pressure-plates pos (new-pressure-plate sector i j k 5 actor with-field))
                          (set-repeaters~ self (remove pp repeaters test: pp-test))
                          ;; play sound
                          (updating-sectors~ zone
                            (lambda (add-sector)
                              (redstone-update sector (list i j k block-id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! #t))))))))
                add-to)
      (for-each (lambda (pos) ;; remove actor from pressure plates
                  (let ((pp (table-ref pressure-plates pos #f)))
                    (let ((colliders (get-colliders~ pp)))
                      (set! colliders (remove actor colliders))
                      (if (null? colliders)
                          (begin
                            (set! pressure-plates (table-remove pressure-plates pos)) ;; test weak-values
                            (set! repeaters (cons pp repeaters))) ;; unpower
                        (begin
                          (set-colliders~ pp colliders)
                          (table-set! pressure-plates pos pp))))))
                remove-from)))
  
  
  (method (redstone-update sector item add-sector with-field block-ref effective-block-set! data-ref effective-data-set! blocklight-ref blocklight-set! (delayed? #f))
    (let ((update-queue (new-queue))
          (first-call? #t)
          (change? #f))
      (define (add-queue i j k)
        (let ((component (list i j k (effective-block-ref i j k))))
          (unless (member? component (queue-list update-queue))
            (enqueue update-queue component))))
      
      (define (add-range lst)
        (for-each (lambda (component)
                    (apply add-queue component))
                  lst))
      
      (define (effective-block-ref i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (block-ref section index)))))
      
      (define (effective-data-ref i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (data-ref section index)))))
      
      (define (block-set! i j k block)
        (with-field i j k
          (lambda (section index)
            (unless (= (block-ref section index) block)
              (set! change? #t)
              (effective-block-set! section index block)
              (add-sector (get-sector~ section))))))
      
      (define (data-set! i j k data)
        (with-field i j k
          (lambda (section index)
            (unless (= (data-ref section index) data)
              (set! change? #t)
              (effective-data-set! section index data)
              (add-sector (get-sector~ section))))))
      
      (define (piston-block-set! section index block)
        (unless (= (block-ref section index) block)
          (set! change? #t)
          (effective-block-set! section index block)
          (add-sector (get-sector~ section))))
      
      (define (piston-data-set! section index data)
        (unless (= (data-ref section index) data)
          (set! change? #t)
          (effective-data-set! section index data)
          (add-sector (get-sector~ section))))
      
      (define (with-block i j k proc)
        (with-field i j k
          (lambda (section index)
            (when section
              (proc section index (block-ref section index) (data-ref section index))))))
      
      (define (update-blocks i j k lst) ;; list of where to look for components
        (let ((blocks (new-queue))
              (block #f))
          (for-each (lambda (abc)
                      (bind (a b c) abc
                        (set! block (effective-block-ref (+ i a) (+ j b) (+ k c)))
                        (when block
                          (cond ((memq? block updatable-components)
                                 (enqueue blocks (list (+ i a) (+ j b) (+ k c))))
                                ((id? block Water StationaryWater)
                                 (enqueue water-blocks (normalize-sector/coordinates sector (+ i a) (+ j b) (+ k c) with-field list)))
                                ((id? block Lava StationaryLava)
                                 (enqueue lava-blocks (normalize-sector/coordinates sector (+ i a) (+ j b) (+ k c) with-field list)))
                                ((id? block Gravel Sand)
                                 (normalize-sector/coordinates sector (+ i a) (+ j b) (+ k c) with-field
                                   (lambda (sector i j k)
                                     (add-fall-block sector i j k))))))))
                    lst)
          (add-range (queue-list blocks))))
      
      (define (opaque? block-id)
        (let ((block (blockid->block block-id)))
          (and (get-cube?~ block) (get-opaque-cube?~ block))))
      
      (define (powered-torch? i j k)
        (apply receives-power? (case (effective-data-ref i j k)
                                 ((1) (list (- i 1) j k #t))
                                 ((2) (list (+ i 1) j k #t))
                                 ((3) (list i j (- k 1) #t))
                                 ((4) (list i j (+ k 1) #t))
                                 ((0 5) (list i (- j 1) k #t)))))
      
      (define (receives-power? i j k (check-block? #f) (ignore #f))
        (define (side-powered? side-i side-j side-k)
          (unless (and ignore (equal? ignore (list side-i side-j side-k)))
            (with-block side-i side-j side-k
              (lambda (side-section side-index block data)
                (or (and (not check-block?) (id? block WoodenPressurePlate StonePressurePlate) (bit-set? 0 data))
                    (and (id? block RedstoneWire) (> data 0) (connected-redstone-to? i j k side-i side-j side-k))
                    (and (id? block RedstoneRepeaterBlockOn) (= (bitwise-and data #b11) (repeater-data-in side-i side-k i k)))
                    (and (not check-block?) (id? block RedstoneTorchOn) (not (memq? data (attached-to-data i j k side-i side-j side-k))))
                    (and (id? block Lever StoneButton WoodenButton) (bit-set? 3 data) (or (not check-block?) (memq? (bitwise-and data #b111) (attached-to-data i j k side-i side-j side-k))))
                    (and (not check-block?) (opaque? block) (strong-powered-block? side-i side-j side-k i j k)))))))
        
        (define (top-powered?)
          (unless (and ignore (equal? ignore (list i (+ j 1) k)))
            (with-block i (+ j 1) k
              (lambda (top-section top-index block data)
                (or (and (id? block WoodenPressurePlate StonePressurePlate) (bit-set? 0 data) (opaque? (effective-block-ref i j k)))
                    (and (not check-block?) (id? block RedstoneTorchOn) (/= data 5))
                    (and (id? block RedstoneWire) (> data 0))
                    (and (id? block Lever StoneButton WoodenButton) (bit-set? 3 data) (or (not check-block?) (memq? (bitwise-and data #b111) (attached-to-data i j k i (+ j 1) k))))
                    (and (not check-block?) (opaque? block) (strong-powered-block? i (+ j 1) k i j k)))))))
        
        (define (bottom-powered?)
          (unless (and ignore (equal? ignore (list i (- j 1) k)))
            (with-block i (- j 1) k
              (lambda (bottom-section bottom-index block data)
                (or (id? block RedstoneTorchOn)
                    (and (not check-block?) (id? block WoodenPressurePlate StonePressurePlate) (bit-set? 0 data))
                    (and (id? block Lever StoneButton WoodenButton) (bit-set? 3 data) (or (not check-block?) (memq? (bitwise-and data #b111) (attached-to-data i j k i (- j 1) k))))
                    (and (not check-block?) (opaque? block) (strong-powered-block? i (- j 1) k i j k)))))))
        
        (and (or (not check-block?)
                 (opaque? (effective-block-ref i j k)))
             (or (side-powered? (- i 1) j k)
                 (side-powered? (+ i 1) j k)
                 (side-powered? i j (- k 1))
                 (side-powered? i j (+ k 1))
                 (top-powered?)
                 (bottom-powered?))))
      
      (define (strong-powered-block? i j k from-i from-j from-k (check-block? #f))
        (define (side-strong? side-i side-j side-k)
          (with-block side-i side-j side-k
            (lambda (section index block data)
              (or (and (id? block RedstoneRepeaterBlockOn) (= (bitwise-and data #b11) (repeater-data-in side-i side-k i k)))
                  (and (id? block Lever StoneButton WoodenButton) (bit-set? 3 data) (memq? (bitwise-and data #b111) (attached-to-data i j k side-i side-j side-k)))
                  (and (not check-block?) (id? block RedstoneWire) (> data 0) (connected-redstone-to? i j k side-i side-j side-k))))))
        
        (define (top-strong?)
          (unless (> from-j j)
            (with-block i (+ j 1) k
              (lambda (section index block data)
                (or (and (id? block WoodenPressurePlate StonePressurePlate) (bit-set? 0 data))
                    (and (not check-block?) (id? block RedstoneWire) (> data 0))
                    (and (id? block Lever StoneButton WoodenButton) (bit-set? 3 data) (memq? (bitwise-and data #b111) (attached-to-data i j k i (+ j 1) k))))))))
        
        (define (bottom-strong?)
          (unless (< from-j j)
            (with-block i (- j 1) k
              (lambda (section index block data)
                (or (id? block RedstoneTorchOn)
                    (and (id? block Lever StoneButton WoodenButton) (bit-set? 3 data) (memq? (bitwise-and data #b111) (attached-to-data i j k i (- j 1) k))))))))
        
        (and
          (or (not check-block?) (opaque? (effective-block-ref i j k)))
          (or (unless (< from-i i)
                (side-strong? (- i 1) j k))
              (unless (> from-i i)
                (side-strong? (+ i 1) j k))
              (unless (< from-k k)
                (side-strong? i j (- k 1)))
              (unless (> from-k k)
                (side-strong? i j (+ k 1)))
              (top-strong?)
              (bottom-strong?))))
      
      (define (wire-power i j k)
        (define (side-power side-i side-j side-k)
          (with-block side-i side-j side-k
            (lambda (section index block data)
              (or (and (id? block RedstoneWire)
                       (- data 1))
                  (and (or (id? block RedstoneTorchOn) (and (id? block RedstoneRepeaterBlockOn) (= (bitwise-and data #b11) (repeater-data-in side-i side-k i k))) (and (id? block WoodenPressurePlate StonePressurePlate) (bit-set? 0 data)) (and (id? block Lever StoneButton WoodenButton) (bit-set? 3 data)))
                       15)
                  (and (with-field i (+ j 1) k
                         (lambda (section index)
                           (or (not (get-cube?~ (blockid->block (block-ref section index)))) (id? (block-ref section index) Glass BeaconBlock))))
                       (with-block side-i (+ side-j 1) side-k
                         (lambda (section index up-block up-data)
                           (and (id? up-block RedstoneWire) (> up-data 0) (- up-data 1)))))
                  (and (or (not (get-cube?~ (blockid->block block))) (id? (block-ref section index) Glass BeaconBlock))
                       (with-block side-i (- side-j 1) side-k
                         (lambda (section index block data)
                           (and (id? block RedstoneWire) (> data 0) (- data 1)))))
                  (and (strong-powered-block? side-i side-j side-k i j k #t)
                       15)
                  0))))
        
        (define (top-power)
          (with-block i (+ j 1) k
            (lambda (section index block data)
              (if (or (id? block RedstoneTorchOn) (and (id? block Lever StoneButton WoodenButton) (bit-set? 3 data)) (strong-powered-block? i (+ j 1) k i j k #t))
                  15
                0))))
        
        (define (bottom-power)
          (if (strong-powered-block? i (- j 1) k i j k #t)
              15
            0))
        
        (max
          (side-power (- i 1) j k)
          (side-power (+ i 1) j k)
          (side-power i j (- k 1))
          (side-power i j (+ k 1))
          (top-power)
          (bottom-power)))
      
      (define (powered-repeater? i j k)
        (define (side-powered? a b c)
          (with-block (+ i a) (+ j b) (+ k c)
            (lambda (section index block data)
              (or (id? block RedstoneTorchOn)
                  (and (id? block StonePressurePlate WoodenPressurePlate) (bit-set? 0 data))
                  (and (id? block RedstoneWire) (> data 0))
                  (and (id? block Lever StoneButton WoodenButton) (bit-set? 3 data))
                  (and (id? block RedstoneRepeaterBlockOn) (= (bitwise-and data #b11) (repeater-data-in (+ i a) (+ k c) i k)))
                  (receives-power? (+ i a) (+ j b) (+ k c) #t)))))
        
        (bind (a b c) (case (bitwise-and (effective-data-ref i j k) #b11)
                        ((0) (list  0 0  1))
                        ((1) (list -1 0  0))
                        ((2) (list  0 0 -1))
                        ((3) (list  1 0  0)))
          (side-powered? a b c)))
      
      (define (repeater-update-list data)
        (case (bitwise-and data #b11)
          ((0) (vector-ref attached-abc 3))
          ((1) (vector-ref attached-abc 2))
          ((2) (vector-ref attached-abc 4))
          ((3) (vector-ref attached-abc 1))))
      
      (define (powered-piston? i j k data)
        (or (receives-power? i (+ j 1) k)
            (receives-power? i j k #f (case (bitwise-and data #b111)
                                        ((0) (list i (- j 1) k))
                                        ((1) (list i (+ j 1) k))
                                        ((2) (list i j (- k 1)))
                                        ((3) (list i j (+ k 1)))
                                        ((4) (list (- i 1) j k))
                                        ((5) (list (+ i 1) j k))
                                        (else (list i j k))))))
      
      (define (piston-update-list data)
        (case (bitwise-and data #b111)
          ((0) (vector-ref attached-abc 5))
          ((1) (vector-ref attached-abc 0))
          ((2) (vector-ref attached-abc 3))
          ((3) (vector-ref attached-abc 4))
          ((4) (vector-ref attached-abc 1))
          ((5) (vector-ref attached-abc 2))
          (else '())))
      
      (define (piston-extend i j k data)
        (define (count-blocks a b c number)
          (let ((next (+ number 1)))
            (with-block (+ i (* a next)) (+ j (* b next)) (+ k (* c next))
              (lambda (section index block data)
                (if section
                    (cond ((or (memq? block unmovable-objects) (and (id? block Piston StickyPiston) (bit-set? 3 data)))
                           #f)
                          ((memq? block break-extend)
                           number)
                          (else
                           (if (= number 12)
                               #f
                             (count-blocks a b c next))))
                  #f)))))
        
        (let ((number (case data
                        ((0) (count-blocks  0 -1  0 0))
                        ((1) (count-blocks  0  1  0 0))
                        ((2) (count-blocks  0  0 -1 0))
                        ((3) (count-blocks  0  0  1 0))
                        ((4) (count-blocks -1  0  0 0))
                        ((5) (count-blocks  1  0  0 0)))))
          (when number
            (let ((block #f)
                  (block-data #f)
                  (temp #f)
                  (temp-data #f))
              (data-set! i j k (bit-set data 3 #t))
              (loop (for x from 0 to number)
                    (bind (i j k) (case data
                                    ((0) (list i (- j (+ x 1)) k))
                                    ((1) (list i (+ j (+ x 1)) k))
                                    ((2) (list i j (- k (+ x 1))))
                                    ((3) (list i j (+ k (+ x 1))))
                                    ((4) (list (- i (+ x 1)) j k))
                                    ((5) (list (+ i (+ x 1)) j k)))
                      (with-field i j k
                        (lambda (section index)
                          (if (= x 0)
                              (begin
                                (set! block (block-ref section index))
                                (set! block-data (data-ref section index))
                                (piston-block-set! section index 34)
                                (piston-data-set! section index data)
                                (blocklight-set! section index 0))
                            (begin
                              (set! temp (block-ref section index))
                              (set! temp-data (data-ref section index))
                              (piston-block-set! section index block)
                              (piston-data-set! section index block-data)
                              (blocklight-set! section index 0)
                              (set! block temp)
                              (set! block-data temp-data)))
                          (update-blocks i j k single-abc))))))
            (with-field i j k
              (lambda (section index)
                (play-3d-sound "sound/piston/out" (section/index->position section index)))))))
      
      (define (piston-retract i j k block-id data-id)
        (define (retract-direction a b c)
          (with-block (+ i a) (+ j b) (+ k c)
            (lambda (section index block data)
              (piston-block-set! section index 0)
              (piston-data-set! section index 0)
              (update-blocks (+ i a) (+ j b) (+ k c) single-abc)
              (when (= block-id 29)
                (with-block (+ i (* a 2)) (+ j (* b 2)) (+ k (* c 2))
                  (lambda (fore-section fore-index fore-block fore-data)
                    (unless (or (memq? fore-block unmovable-objects) (memq? fore-block break-extend) (and (id? fore-block Piston StickyPiston) (bit-set? 3 fore-data)))
                      (piston-block-set! section index fore-block)
                      (piston-data-set! section index fore-data)
                      (piston-block-set! fore-section fore-index 0)
                      (piston-data-set! fore-section fore-index 0)
                      (update-blocks (+ i a) (+ j b) (+ k c) (piston-update-list data-id)))))))))
        
        (data-set! i j k (bit-set data-id 3 #f))
        (case (bitwise-and data-id #b111)
          ((0) (retract-direction  0 -1  0))
          ((1) (retract-direction  0  1  0))
          ((2) (retract-direction  0  0 -1))
          ((3) (retract-direction  0  0  1))
          ((4) (retract-direction -1  0  0))
          ((5) (retract-direction  1  0  0)))
        (with-field i j k
          (lambda (section index)
            (play-3d-sound "sound/piston/in" (section/index->position section index)))))
      
      (define (update-piston-head i j k data)
        (bind (i j k) (case (bitwise-and data #b111)
                        ((0) (list i (+ j 1) k))
                        ((1) (list i (- j 1) k))
                        ((2) (list i j (+ k 1)))
                        ((3) (list i j (- k 1)))
                        ((4) (list (+ i 1) j k))
                        ((5) (list (- i 1) j k))
                        (else (list #f #f #f)))
          (when i
            (update-redstone-component i j k (effective-block-ref i j k)))))
      
      (define (update-redstone-component i j k block)
        (ccase block
               ((RedstoneLampOn RedstoneLampOff)
                (if (receives-power? i j k)
                    (block-set! i j k RedstoneLampOn)
                  (block-set! i j k RedstoneLampOff)))
               ((Piston StickyPiston)
                (let ((data (effective-data-ref i j k)))
                  (if (powered-piston? i j k data)
                      (unless (bit-set? 3 data)
                        (piston-extend i j k data))
                    (when (bit-set? 3 data)
                      (piston-retract i j k block data)))))
               ((WoodenDoorBlock IronDoorBlock)
                (let ((data (effective-data-ref i j k)))
                  (if (bit-set? 3 data)
                      (begin
                        (data-set! i j k (bit-set data 1 (receives-power? i j k)))
                        (add-queue i (- j 1) k))
                    (let ((open? (or (receives-power? i j k) (bit-set? 1 (effective-data-ref i (+ j 1) k)))))
                      (data-set! i j k (bit-set data 2 open?))
                      (when change?
                        (door-sound open?))))))))
      
      (define (door-sound open?)
        (play-sound-file
          (if open?
              "sound/random/door_open"
            "sound/random/door_close")
          volume: .5))                    
      
      (define (repeater-data-out r-i r-k from-i from-k)
        (cond ((< r-i from-i) 3)
              ((> r-i from-i) 1)
              ((< r-k from-k) 0)
              ((> r-k from-k) 2)
              (else -1)))
      
      (define (repeater-data-in r-i r-k from-i from-k)
        (cond ((< r-i from-i) 1)
              ((> r-i from-i) 3)
              ((< r-k from-k) 2)
              ((> r-k from-k) 0)
              (else -1)))
      
      (define (attached-to-data block-i block-j block-k comp-i comp-j comp-k)
        (cond ((> block-i comp-i) '(2))
              ((< block-i comp-i) '(1))
              ((> block-j comp-j) '(0 7))
              ((< block-j comp-j) '(5 6))
              ((> block-k comp-k) '(4))
              ((< block-k comp-k) '(3))))
      
      (define (attached-update-list data)
        (case (bitwise-and data #b111)
          ((0 7) (vector-ref attached-abc 0))
          ((1)   (vector-ref attached-abc 1))
          ((2)   (vector-ref attached-abc 2))
          ((3)   (vector-ref attached-abc 3))
          ((4)   (vector-ref attached-abc 4))
          ((5 6) (vector-ref attached-abc 5))))
      
      (define (connected-redstone-to? block-i block-j block-k wire-i wire-j wire-k)
        (define (side-connected? side-i side-j side-k)
          (with-block side-i side-j side-k
            (lambda (section index side-id side-data-id)
              (or (id? side-id RedstoneWire)
                  (memq? side-id redstone-power-components)
                  (and (id? side-id RedstoneRepeaterBlockOn RedstoneRepeaterBlockOff) (memq? (bitwise-and side-data-id #b11) (cond ((/= side-i wire-i) '(1 3))
                                                                                                                                   (else '(0 2)))))
                  (and (or (not (get-cube?~ (blockid->block side-id))) 
                           (id? side-id Glass BeaconBlock))
                       (id? (effective-block-ref side-i (- side-j 1) side-k) RedstoneWire))
                  (and (or (get-opaque-cube?~ (blockid->block side-id))
                           (id? side-id Glowstone)
                           (and (id? side-id StoneSlab WoodenSlab) (> side-data-id 7)))
                       (= (effective-block-ref side-i (+ side-j 1) side-k) RedstoneWire)
                       (or (not (get-cube?~ (blockid->block (effective-block-ref wire-i (+ wire-j 1) wire-k))))
                           (id? (effective-block-ref wire-i (+ wire-j 1) wire-k) Glass BeaconBlock)))))))
        
        (let ((wire-side (cond ((< block-i wire-i) 'left)
                               ((> block-i wire-i) 'right)
                               ((< block-k wire-k) 'back)
                               ((> block-k wire-k) 'front)))
              (left?  (side-connected? (- wire-i 1) wire-j wire-k))
              (right? (side-connected? (+ wire-i 1) wire-j wire-k))
              (back?  (side-connected? wire-i wire-j (- wire-k 1)))
              (front? (side-connected? wire-i wire-j (+ wire-k 1))))
          (or (not (or left? right? back? front?))
              (case wire-side
                ((left) (or left? (and right? (not back?) (not front?))))
                ((right) (or right? (and left? (not back?) (not front?))))
                ((back) (or back? (and front? (not left?) (not right?))))
                ((front) (or front? (and back? (not left?) (not right?))))))))
      
      (let (iter (component item))
        (bind (i j k block) component
          (let ((real-block (effective-block-ref i j k)))
            (ccase block
              ((RedstoneTorchOff RedstoneTorchOn)
               (when (= block real-block)
                 (if (or delayed? first-call?)
                     (block-set! i j k (if (powered-torch? i j k) RedstoneTorchOff RedstoneTorchOn))
                   (let ((power? (powered-torch? i j k)))
                     (when (not (id? real-block (if power? RedstoneTorchOff RedstoneTorchOn)))
                       (set! repeaters (cons (new-repeater sector i j k 1 (if power? 'off 'on) with-field) repeaters))))))
               (when (or (and first-call? (not delayed?)) change?)
                 (update-blocks i j k double-abc)))
              
              ((RedstoneWire)
               (when (= block real-block)
                 (data-set! i j k (wire-power i j k)))
               (when (or first-call? change?)
                 (update-blocks i j k double-abc)))
              
              ((RedstoneRepeaterBlockOn RedstoneRepeaterBlockOff)
               (when (= block real-block)
                 (if delayed?
                     (block-set! i j k (if (eq? delayed? 'on) RedstoneRepeaterBlockOn RedstoneRepeaterBlockOff))
                   (let ((power? (powered-repeater? i j k)))
                     (when (not (id? real-block (if power? RedstoneRepeaterBlockOn RedstoneRepeaterBlockOff)))
                       (set! repeaters (cons (new-repeater sector i j k (arithmetic-shift-right (bitwise-and (effective-data-ref i j k) #b1100) 2) (if power? 'on 'off) with-field) repeaters))))))
               (when (or (and first-call? (not delayed?)) change?)
                 (update-blocks i j k (repeater-update-list (effective-data-ref i j k)))))
              
              ((Lever)
               (update-blocks i j k (attached-update-list (effective-data-ref i j k))))
              
              ((WoodenButton StoneButton)
               (let ((data (effective-data-ref i j k)))
                 (when (and delayed? (bit-set? 3 data))
                   (set! repeaters (cons (new-repeater sector i j k (if (id? block WoodenButton) 15 10) #f with-field) repeaters)))
                 (update-blocks i j k (attached-update-list data))))
              
              ((WoodenPressurePlate StonePressurePlate)
               (when delayed?
                 (data-set! i j k 1))
               (update-blocks i j k (vector-ref attached-abc 5)))
              
              ((RedstoneLampOn RedstoneLampOff Piston StickyPiston WoodenDoorBlock IronDoorBlock)
               (when (= block real-block)
                 (update-redstone-component i j k block))
               (when (or first-call? (and change? (id? block Piston StickyPiston)))
                 (update-blocks i j k single-abc)))
              
              ((TNT)
               (when (receives-power? i j k)
                 (with-field i j k
                   (lambda (section index)
                     (invoke-block-action (section/index->position section index)))))
               (when first-call?
                 (update-blocks i j k single-abc)))
              
              ((CommandBlock)
               (let ((data (effective-data-ref i j k)))
                 (if (bit-set? 0 data)
                     (unless (receives-power? i j k)
                       (data-set! i j k (bit-set data 0 #f)))
                   (when (receives-power? i j k)
                     (with-field i j k
                       (lambda (section index)
                         (data-set! i j k (bit-set data 0 #t))
                         (invoke-block-action (section/index->position section index)))))))
               (when first-call?
                 (update-blocks i j k single-abc)))
              
              ((PistonHead)
               (when (= block real-block)
                 (update-piston-head i j k (effective-data-ref i j k)))
               (when (or first-call? change?)
                 (update-blocks i j k single-abc)))
              
              (else
               (unless delayed?
                 (update-blocks i j k single-abc))))))
        (when first-call?
          (set! first-call? #f))
        (when change?
          (set! change? #f))
        (when delayed?
          (set! delayed? #f))
        (unless (queue-empty? update-queue)
          (iter (dequeue update-queue))))))
  
  
  (definition interaction-distance <fl>
    (world-setting 'world.interaction-distance 8.))
  
  
  (method (max-interaction-distance)
    (let ((world (current-world)))
      (if (user-role?)
          interaction-distance
        (get-view-radius~ world))))
  
  
  (method override (deposit-block h v)
    (let ((zone (current-zone)))
      (with-interaction
        (lambda (poly block fore)
          (call-with-position~ zone block
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
              (let ((count (if (shift-down?) 10 1)))
                (deposit-inventory block-id count: count))))))))
  
  
  (method override (mouse-up h v)
    (let ((me (current-me)))
      (with-interaction
        (lambda (poly block fore)
          (let ((distance (vertex-distance block (get-position~ me)))
                (max-distance (max-interaction-distance)))
            (when (<= distance max-distance)
              (delete-block-at block)))))))
  
  
  (method override (right-mouse-up h v)
    (let ((world (current-world))
          (zone (current-zone))
          (me (current-me)))
      (with-interaction
        (lambda (poly block fore)
          (let ((distance (vertex-distance block (get-position~ me)))
                (max-distance (max-interaction-distance)))
            (when (<= distance max-distance)
              (call-with-position~ zone block
                (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                  (let ((block (blockid->block block-id)))
                    (let ((right-mouse (get-right-mouse~ block)))
                      (if (not right-mouse)
                          (let ((slot (selected-slot~ (child~ (get-interface~ world) 'belt))))
                            (let ((id (get-id~ slot)))
                              (when id
                                (if (>= id 256)
                                    (bell)
                                  (add-block-at poly fore id)
                                  (decrease-count~ slot)))))
                        (right-mouse region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))))))))))
  
  
  (method override (mouse-wheel h v d)
    (let ((world (current-world)))
      (if (xor (shift-down?) (world-setting 'world.wheel-zoom? #f))
          (cond ((> d 0)
                 (zoom-in~ world))
                ((< d 0)
                 (zoom-out~ world)))
        (cycle-selection~ (child~ (get-interface~ world) 'belt) d))))))
