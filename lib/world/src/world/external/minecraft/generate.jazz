;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Minecraft Generate
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Édouard Hébert


(module protected world.external.minecraft.generate jazz


(import (jazz.debuggee)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.json)
        (jazz.library)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.system)
        (jazz.ui)
        (world)
        (world.album)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.chunk)
        (world.configure)
        (world.dye)
        (world.enemy)
        (world.entity)
        (world.external.minecraft.autoload)
        (world.external.minecraft.syntax (phase syntax))
        (world.external.nbt)
        (world.face)
        (world.foreign)
        (world.game)
        (world.generate)
        (world.geometry)
        (world.homogeneous)
        (world.info)
        (world.interface.blocks)
        (world.interface.inventory)
        (world.interface.propagation)
        (world.lighting)
        (world.log)
        (world.material)
        (world.mesh)
        (world.model)
        (world.models)
        (world.object)
        (world.profiling)
        (world.quad)
        (world.quad-texture)
        (world.region)
        (world.renderers)
        (world.role)
        (world.section)
        (world.sector)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.texture))


(proclaim (warn optimizations))


(definition protected aa 0) ;; 10421010
(definition protected oo 0) ;; 12248627
(definition protected gg 0) ;; 745240
(definition protected ww 0) ;; 697473
(definition protected cc 0) ;; 54050


;;;
;;;; Atlas
;;;


(definition (cache-atlas) <Atlas>
  (let ((world (current-world)))
    (get-block-atlas~ world)))


(definition (cache-texture) <Image-Texture>
  (let ((world (current-world)))
    (get-block-texture~ world)))


(definition (cache-texture-nearest) <Image-Texture>
  (let ((world (current-world)))
    (get-block-texture-nearest~ world)))


(definition (cache-texture-clamped) <Image-Texture>
  (let ((world (current-world)))
    (get-block-texture-nearest~ world)))


(definition (create-minecraft-atlas (nearest?: nearest? #f)) <Atlas>
  (define (find-minecraft-assets)
    (let ((world (current-world)))
      (find-if (lambda (assets)
                 (and (eq? (get-where~ assets) 'world)
                      (equal? (get-spine~ assets) '("minecraft"))))
               (get-world-assets~ world))))
  
  (let ((atlas (new Atlas))
        (assets (find-minecraft-assets))
        (path (list "textures" texture-dir)))
    (add-assets-directory~ atlas assets path)
    (generate-textures atlas assets path)
    atlas))


(definition (create-minecraft-texture atlas (nearest?: nearest? #f) (wrap: wrap #f)) <Image-Texture>
  (let ((mipmap? (world-setting 'minecraft.generate-mipmap? 32))
        (min-nearest? (world-setting 'minecraft.min-nearest? #f))
        (mag-nearest? (world-setting 'minecraft.mag-nearest? #f)))
    (let ((effective-mipmap? (if (integer? mipmap?) (>= tile-resolution (cast <fx> mipmap?)) mipmap?)))
      (let ((min-filter (if (or nearest? min-nearest? (not effective-mipmap?))
                            GL_NEAREST
                          #f))
            (mag-filter (if (or mag-nearest? (not effective-mipmap?))
                            GL_NEAREST
                          #f)))
        (extract-texture~ atlas min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: effective-mipmap? warn-non-uniform?: (programmer-role?))))))


;;;
;;;; Textures
;;;


(definition textures-subuvs
  '())

(definition (add-textures-subuv name subuv)
  (set! textures-subuvs (cons (cons name subuv) textures-subuvs)))

(definition (update-textures-subuvs atlas)
  (for-each (lambda (info)
              (bind (name . subuv) info
                (update-coordinates~ atlas name subuv)))
            textures-subuvs)
  (set! textures-subuvs '()))


(definition (generate-textures atlas assets path)
  (let ((dir (make-directory~ assets (append path '("blocks")))))
    (define (add-colored base suffix color)
      (let ((gray (new-file~ dir (add-extension base "png")))
            (name (format "{a}_{a}" base suffix)))
        (assert (exists?~ gray))
        (apply-operator CAIRO_OPERATOR_MULTIPLY gray color
          (lambda (surf width height)
            (let ((surface (new Surface surf)))
              (add-surface~ atlas name surface width height))))))

    (define (apply-operator operator gray color proc)
      (receive (width height msk) (cairo-surface-from-png gray)
        (receive (width height dst) (cairo-surface-from-png gray)
          (let ((size (new Dimension width height))
                (mask (new Surface msk))
                (dest (new Surface dst)))
            (set-operator~ dest operator)
            (set-color~ dest color)
            (draw-rectangle~ dest (size-rect size))
            (cairo_mask_surface (get-context~ dest) (get-handle~ mask) 0. 0.)
            (close~ mask)
            (proc dst width height)))))
    
    (define (mirror-pad name left top right bottom (save-to #f))
      (bind (surface width height depth) (get-image~ atlas name)
        (let ((cairo-surface
                (when (u8vector? surface)
                  (let ((cairo-format CAIRO_FORMAT_ARGB32))
                    (let ((stride (cairo_format_stride_for_width cairo-format width)))
                      (new Surface (cairo_image_surface_create_for_data (still-u8vector-body surface) CAIRO_FORMAT_ARGB32 width height stride)))))))
          (let ((surface (or cairo-surface surface))
                (l (* left width))
                (t (* top height))
                (r (* right width))
                (b (* bottom height)))
            (let ((w (- r l))
                  (h (- b t)))
              (let ((subimage (new Image-Surface surface (new Dimension (fxround w) (fxround h))))
                    (pattern (cairo_pattern_create_for_surface (get-handle~ surface))))
                (let ((surface (if (not save-to) surface (new Image-Surface surface (new Dimension width height)))))
                  (let ((cr (get-context~ subimage))
                        (matrix (cairo_matrix_t-make)))
                    (cairo_set_source cr pattern)
                    (cairo_matrix_init_translate matrix l t)
                    (cairo_pattern_set_matrix pattern matrix)
                    (cairo_rectangle cr 0. 0. (fl w) (fl h))
                    (cairo_fill cr)
                    (cairo_matrix_t-free matrix)
                    (cairo_pattern_destroy pattern)
                    (loop (for i from -1 to 1)
                          (loop (for j from -1 to 1)
                                (let ((sx (if (= i 0) 1 -1))
                                      (sy (if (= j 0) 1 -1)))
                                  (let ((l (if (= sx 1) l (+ l w)))
                                        (t (if (= sy 1) t (+ t h))))
                                    (let ((tx (+ l (* i w)))
                                          (ty (+ t (* j h))))
                                      (cairo_identity_matrix (get-context~ surface))
                                      (translate~ surface tx ty)
                                      (scale~ surface sx sy)
                                      (blit-surface~ surface subimage))))))
                    (close~ subimage)
                    (when cairo-surface
                      (close~ cairo-surface))
                    (if (not save-to)
                        (add-textures-subuv name (uv left top right bottom (cast <fl> depth)))
                      (add-surface~ atlas save-to surface width height)
                      (bind (surface width height depth) (get-image~ atlas save-to)
                        (add-textures-subuv save-to (uv left top right bottom (cast <fl> depth)))))))))))))
    
    (add-colored "leaves_birch" "green" {Color red: .003 green: .619 blue: .003})
    (add-colored "melon_stem_disconnected" "ochre" {Color red: .747 green: .563 blue: .004})
    (add-colored "pumpkin_stem_disconnected" "ochre" {Color red: .747 green: .563 blue: .004})
    (add-colored "vine" "green" {Color red: .160 green: .619 blue: .160})
    (add-colored "waterlily" "green" {Color red: .003 green: .619 blue: .003})
    
    (mirror-pad "cake_side"             1m 8m 15m 16m)
    (mirror-pad "cake_top"              1m 1m 15m 15m)
    (mirror-pad "cake_bottom"           1m 1m 15m 15m)
    (mirror-pad "chest_side"            1m 2m 15m 16m)
    (mirror-pad "chest_front"           1m 2m 15m 16m)
    (mirror-pad "chest_back"            1m 2m 15m 16m)
    (mirror-pad "chest_bottom"          1m 1m 15m 15m)
    (mirror-pad "chest_top"             1m 1m 15m 15m)
    (mirror-pad "bed_head_side"         0m 7m 16m 16m)
    (mirror-pad "bed_head_end"          0m 7m 16m 16m)
    (mirror-pad "bed_feet_side"         0m 7m 16m 16m)
    (mirror-pad "bed_feet_end"          0m 7m 16m 16m)
    (mirror-pad "enchanting_table_side" 0m 4m 16m 16m)
    (mirror-pad "endframe_side"         0m 3m 16m 16m)
    (mirror-pad "endframe_eye"          4m 0m 12m 4m "endframe_eye_side")
    (mirror-pad "endframe_eye"          4m 4m 12m 12m)))


;;;
;;;; Face
;;;


@anisotropy-xp
(definition protected YYY
  0)

@anisotropy-xp
(definition protected NNN
  0)


(class Minecraft-Face extends Face
  
  
  (slot l1 accessors generate)
  (slot l2 accessors generate)
  (slot l3 accessors generate)
  (slot l4 accessors generate)
  
  
  (method override (initialize material texture-coordinates texture-depth polygon l1 l2 l3 l4)
    (nextmethod material texture-coordinates texture-depth polygon)
    (set! l1~self l1)
    (set! l2~self l2)
    (set! l3~self l3)
    (set! l4~self l4))
  
  
  @anisotropy-xp
  (method override (initialize material texture-coordinates texture-depth polygon l1 l2 l3 l4)
    (let ((a00 (+ (u8vector-ref l1 0) (u8vector-ref l1 1)))
          (a01 (+ (u8vector-ref l2 0) (u8vector-ref l2 1)))
          (a11 (+ (u8vector-ref l3 0) (u8vector-ref l3 1)))
          (a10 (+ (u8vector-ref l4 0) (u8vector-ref l4 1))))
      (cond ((> (+ a00 a11) (+ a01 a10))
             (increase! YYY)
             (nextmethod material texture-coordinates texture-depth polygon)
             (set! l1~self l1)
             (set! l2~self l2)
             (set! l3~self l3)
             (set! l4~self l4))
            (else
             (increase! NNN)
             (let ((other-coordinates
                     (let ((t1u (f32vector-ref texture-coordinates 0))
                           (t1v (f32vector-ref texture-coordinates 1))
                           (t2u (f32vector-ref texture-coordinates 2))
                           (t2v (f32vector-ref texture-coordinates 3))
                           (t3u (f32vector-ref texture-coordinates 4))
                           (t3v (f32vector-ref texture-coordinates 5))
                           (t4u (f32vector-ref texture-coordinates 6))
                           (t4v (f32vector-ref texture-coordinates 7)))
                       (f32vector t4u t4v t1u t1v t2u t2v t3u t3v)))
                   (other-polygon
                     (make-minecraft-quad (get-v4~ polygon) (get-v1~ polygon) (get-v2~ polygon) (get-v3~ polygon)
                       (fxround (get-data1~ polygon))
                       (get-data2~ polygon)
                       (get-data3~ polygon)
                       (get-data4~ polygon))))
               (nextmethod material other-coordinates texture-depth other-polygon)
               (set! l1~self l4)
               (set! l2~self l1)
               (set! l3~self l2)
               (set! l4~self l3))))))
  
  
  (method (iterate-lighting proc)
    (proc l1 l2 l3)
    (proc l3 l4 l1)))


;;;
;;;; Mesher
;;;


(class Minecraft-Mesher extends Mesher
  
  
  (method (add-lighting face <Minecraft-Face>)
    (define (blocklight! offset <fx> lighting <u8vector>) <void>
      (f32vector-set! lightmap offset (cast <fl> (u8vector-ref lighting 0))))
    
    (define (skylight! offset <fx> lighting <u8vector>) <void>
      (f32vector-set! lightmap offset (cast <fl> (u8vector-ref lighting 1))))
    
    (define (ambience! offset <fx> lighting <u8vector>) <void>
      (f32vector-set! lightmap offset (/ (cast <fl> (u8vector-ref lighting 2)) 4.)))
    
    (iterate-lighting~ face
      (lambda (l1 l2 l3)
        (blocklight!    k    l1)
        (skylight!   (+ k 1) l1)
        (ambience!   (+ k 2) l1)
        (blocklight! (+ k 3) l2)
        (skylight!   (+ k 4) l2)
        (ambience!   (+ k 5) l2)
        (blocklight! (+ k 6) l3)
        (skylight!   (+ k 7) l3)
        (ambience!   (+ k 8) l3)
        (increase! k 9)))))


;;;
;;;; Rendering
;;;


(class Minecraft-Rendering extends Object
  
  
  (slot material <Material> getter generate)
  (slot mesher   <Mesher>   getter generate)
  
  
  (method override (initialize initial-reserved material)
    (set! material~self material)
    (set! mesher~self (new Minecraft-Mesher initial-reserved 0 material: material)))
  
  
  (method (reset-mesher)
    (reset~ mesher)))


(definition package opaque-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Minecraft-Rendering 8192 (new Material name: 'opaque atlas: atlas texture: texture renderer: (get-opaque-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package transparent-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Minecraft-Rendering 20480 (new Material name: 'transparent atlas: atlas texture: texture renderer: (get-transparent-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package coverage-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Minecraft-Rendering 2048 (new Material name: 'coverage atlas: atlas texture: texture renderer: (get-coverage-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package water-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture-nearest)))
            (let ((rend (new Minecraft-Rendering 2048 (new Material name: 'water atlas: atlas texture: texture renderer: (get-water-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package wet-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Minecraft-Rendering 2048 (new Material name: 'wet atlas: atlas texture: texture renderer: (get-wet-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package multitexture-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture-nearest)))
            (let ((rend (new Minecraft-Rendering 2048 (new Material name: 'multitexture atlas: atlas texture: texture renderer: (get-multitexture-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package (dr)
  (define (d rendering <Minecraft-Rendering>)
    (let ((mesher (get-mesher~ rendering)))
      (list (get-growths~ mesher) (get-reserved~ mesher))))

  (debug (d (opaque-rendering))
         (d (transparent-rendering))
         (d (coverage-rendering))
         (d (water-rendering))
         (d (wet-rendering))
         (d (multitexture-rendering))))


;;;
;;;; Block
;;;


(class Minecraft-Block-Model extends Object
  
  
  (slot name                     getter generate)
  (slot id                  <fx> getter generate)
  (slot subid                    getter generate)
  (slot texture                  getter generate)
  (slot texture-coordinates      accessors generate)
  (slot rendering                getter generate)
  (slot rendering-cache          getter generate)
  (slot opaque-cube?             getter generate)
  (slot water-cube?              getter generate)
  (slot physical?                getter generate)
  (slot cube?                    accessors generate)
  (slot brightness               getter generate)
  (slot generate                 getter generate)
  (slot right-mouse              getter generate)
  
  
  (method override (initialize name id subid texture rendering opaque-cube? water-cube? physical? cube? brightness generate right-mouse)
    (set! name~self name)
    (set! id~self id)
    (set! subid~self subid)
    (set! texture~self texture)
    (set! texture-coordinates~self #f)
    (set! rendering~self (or rendering opaque-rendering))
    (set! rendering-cache~self #f)
    (set! opaque-cube?~self opaque-cube?)
    (set! water-cube?~self water-cube?)
    (set! physical?~self physical?)
    (set! cube?~self cube?)
    (set! brightness~self brightness)
    (set! generate~self generate)
    (set! right-mouse~self right-mouse))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method (cache-rendering)
    (or rendering-cache
        (let ((rend (rendering)))
          (set! rendering-cache rend)
          rend))))


(definition blocks <table>
  (make-table test: eq?))

(definition blockids <vector>
  (make-vector 256 #f))


(definition (register-minecraft-block name id (texture: texture #f) (rendering: rendering #f) (opaque-cube?: opaque-cube? #t) (water-cube?: water-cube? #f) (physical?: physical? #t) (cube?: cube? #t) (brightness: brightness #f) (generate: generate #f) (right-mouse: right-mouse #f))
  (let ((id <fx> (if (pair? id) (car id) id))
        (subid (if (pair? id) (cadr id) #f)))
    (when (not subid)
      (let ((block (new Minecraft-Block-Model name id subid texture rendering opaque-cube? water-cube? physical? cube? brightness generate right-mouse)))
        (table-set! blocks name block)
        (vector-set! blockids id block)
        (unspecified)))))


(definition public (name->block name) <Minecraft-Block-Model>
  (table-ref blocks name))

(definition public inline (blockid->block id <fx>) <Minecraft-Block-Model>
  (assert (and (>= id 0)
               (<= id 255))
    (vector-ref blockids id)))


(definition protected tile-resolution <fx>
  (world-setting 'minecraft.tile-resolution 32))

(definition protected tile-size <fl>
  (cast <fl> tile-resolution))

(definition protected tile-period <fx>
  16)

(definition protected texture-size <fl>
  (* tile-size (cast <fl> tile-period)))

(definition protected texture-dir
  (format "{a}x{a}" tile-resolution tile-resolution))

(definition protected texture-mipmap?
  #f)


(definition (block-texture-coordinates block <Minecraft-Block-Model>)
  (or (get-texture-coordinates~ block)
      (let ((texture (get-texture~ block)))
        (let ((coords (and texture (image-rect~ (cache-atlas) texture))))
          (set-texture-coordinates~ block coords)
          coords))))


(definition coordinates-mutex
  (make-mutex 'coordinates))

(definition coordinates <table>
  (make-table test: equal?))

(definition (get-coordinates name <string>) <f32vector>
  (mutex-lock! coordinates-mutex)
  (prog1 (or (table-ref coordinates name #f)
             (let ((coords (image-rect~ (cache-atlas) name)))
               (table-set! coordinates name coords)
               coords))
    (mutex-unlock! coordinates-mutex)))


;;;
;;;; Blocks
;;;


(definition use-models?
  (world-setting 'minecraft.use-models? #t))


(constant inline block-radius <fl>
  .5)


(constant inline air-id <fx>
  0)


(constant inline mixel
  .0625)

(constant inline  0m 0.)
(constant inline  1m .0625)
(constant inline  2m .125)
(constant inline  3m .1875)
(constant inline  4m .25)
(constant inline  5m .3125)
(constant inline  6m .375)
(constant inline  7m .4375)
(constant inline  8m .5)
(constant inline  9m .5625)
(constant inline 10m .625)
(constant inline 11m .6875)
(constant inline 12m .75)
(constant inline 13m .8125)
(constant inline 14m .875)
(constant inline 15m .9375)
(constant inline 16m 1.)


(define-minecraft-block Air
  0
  opaque-cube?: #f
  cube?: #f)

(define-minecraft-block Stone
  1
  texture: "stone")

(define-minecraft-block Grass
  2
  texture: "grass_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "wool_colored_green" @w "grass_top"))
                    (bottom (get-coordinates "dirt")))
                (add-opaque-cube i j k x y z uv uv bottom top uv uv lighting rendering block-id add-face))))

(define-minecraft-block Dirt
  3
  texture: "dirt")

(define-minecraft-block Cobblestone
  4
  texture: "cobblestone")

(define-minecraft-block WoodenPlank
  5
  texture: "planks_oak")

(definition Sapling-Textures <vector>
  #("sapling_oak"
    "sapling_spruce"
    "sapling_birch"
    "sapling_jungle"))

(define-minecraft-block Sapling
  6
  texture: "sapling_jungle"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Sapling-Textures (bitwise-and data-id #b11)))))
                (add-cross-faces i j k x y z uv lighting rendering block-id add-face))))

(define-minecraft-block RedwoodSapling
  (6 1))

(define-minecraft-block BirchSapling
  (6 2))

(define-minecraft-block Bedrock
  7
  texture: "bedrock")

(define-minecraft-block Water
  8
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  physical?: #f
  rendering: water-rendering
  texture: "water")

(define-minecraft-block StationaryWater
  9
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  physical?: #f
  rendering: water-rendering
  texture: "water")

(define-minecraft-block Lava
  10
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  physical?: #f
  rendering: multitexture-rendering
  texture: "lava")

(define-minecraft-block StationaryLava
  11
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  physical?: #f
  rendering: multitexture-rendering
  texture: "lava")

(define-minecraft-block Sand
  12
  texture: "sand")

(define-minecraft-block Gravel
  13
  texture: "gravel")

(define-minecraft-block GoldOre
  14
  texture: "gold_ore")

(define-minecraft-block IronOre
  15
  texture: "iron_ore")

(define-minecraft-block CoalOre
  16
  texture: "coal_ore")

(definition Wood-Textures <vector>
  #("log_oak"
    "log_spruce"
    "log_birch"
    "log_jungle"))

(definition WoodTop-Textures <vector>
  #("log_oak_top"
    "log_spruce"
    "log_birch"
    "log_jungle"))
  
(define-minecraft-block Wood
  17
  texture: "planks_jungle"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wood-Textures (bitwise-and data-id #b11))))
                    (uv-top (get-coordinates (vector-ref WoodTop-Textures (bitwise-and data-id #b11)))))
                (add-opaque-cube i j k x y z uv uv uv-top uv-top uv uv lighting rendering block-id add-face))))

(define-minecraft-block Redwood
  (17 1))

(define-minecraft-block Birchwood
  (17 2))

(define-minecraft-block Leaves
  18
  texture: "leaves_birch_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block RedwoodLeaves
  (18 1))

(define-minecraft-block BirchwoodLeaves
  (18 2))

(define-minecraft-block Sponge
  19
  texture: "sponge")

(define-minecraft-block Glass ;;
  20
  texture: "glass"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block LapisOre
  21
  texture: "lapis_ore")

(define-minecraft-block LapisBlock
  22
  texture: "lapis_block")

(define-minecraft-block Dispenser
  23
  texture: "dispenser_front_vertical"
  opaque-cube?: #f)

(define-minecraft-block Sandstone
  24
  texture: "sandstone_top")

(define-minecraft-block NoteBlock
  25
  texture: "noteblock"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block BedBlock
  26
  texture: "bed_feet_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((matrix (make-lookat-matrix& (horizon-lookat& (case (bitwise-and data-id #b11)
                                                                    ((0) (vertex&  0. 0.  1.))
                                                                    ((1) (vertex& -1. 0.  0.))
                                                                    ((2) (vertex&  0. 0. -1.))
                                                                    ((3) (vertex&  1. 0.  0.))))))
                    (head? (bit-set? 3 data-id))
                    (left (- block-radius))
                    (right (+ block-radius))
                    (bottom (- block-radius))
                    (top 1m)
                    (back (- block-radius))
                    (front (+ block-radius))
                    (bedbottom (+ (- block-radius) 3m))
                    (bedtop (- 9m block-radius)))
                (if head?
                    (let ((uv-top (get-coordinates "bed_head_top"))
                          (uv-side (get-coordinates "bed_head_side"))
                          (uv-end (get-coordinates "bed_head_end"))
                          (uv-bottom (get-coordinates "planks_oak")))
                      (add-face (left-generic   i j k x y z left right bottom top back front uv-side generic-coordinates lighting rendering block-id matrix) rendering)
                      (add-face (right-generic  i j k x y z left right bottom top back front uv-side transpose-coordinates lighting rendering block-id matrix) rendering)
                      (add-face (bottom-generic i j k x y z left right bedbottom top back front uv-bottom generic-coordinates lighting rendering block-id matrix) rendering)
                      (add-face (top-generic    i j k x y z left right bottom bedtop back front uv-top rotate-coordinates lighting rendering block-id matrix) rendering)
                      (add-face (front-generic  i j k x y z left right bottom top back front uv-end generic-coordinates lighting rendering block-id matrix) rendering))
                  (let ((uv-top (get-coordinates "bed_feet_top"))
                        (uv-side (get-coordinates "bed_feet_side"))
                        (uv-end (get-coordinates "bed_feet_end"))
                        (uv-bottom (get-coordinates "planks_oak")))
                    (add-face (left-generic   i j k x y z left right bottom top back front uv-side generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (right-generic  i j k x y z left right bottom top back front uv-side transpose-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (bottom-generic i j k x y z left right bedbottom top back front uv-bottom generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (top-generic    i j k x y z left right bottom bedtop back front uv-top rotate-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (back-generic   i j k x y z left right bottom top back front uv-end generic-coordinates lighting rendering block-id matrix) rendering)))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (when (or (> get-daytime~ ?z 18500.) (< get-daytime~ ?z 6000.))
                   (goto-daytime~ ?z 6000.))))

(define-minecraft-block PoweredRail
  27
  texture: "rail_activator"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-rail-gadget data-id i j k x y z uv (get-coordinates "rail_activator_powered") lighting rendering block-id add-face)))

(define-minecraft-block DetectorRail
  28
  texture: "rail_detector"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-rail-gadget data-id i j k x y z uv (get-coordinates "rail_detector_powered") lighting rendering block-id add-face)))

(define-minecraft-block StickyPiston
  29
  texture: "piston_side"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "piston_top_sticky")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering block-id add-face))))

(define-minecraft-block Web
  30
  texture: "web"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)

(define-minecraft-block TallGrass
  31
  texture: "wheat_stage_4" ; "tallgrass" is not nice in sphax textures
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)

(define-minecraft-block DeadBush
  32
  texture: "deadbush"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)

;; improve
(define-minecraft-block Piston
  33
  texture: "piston_side"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "piston_top_normal"))
                    (bottom (get-coordinates "piston_bottom")))
                (add-opaque-cube i j k x y z uv uv bottom top uv uv lighting rendering block-id add-face))))

;; improve
(define-minecraft-block PistonHead
  34
  texture: "planks_oak")

(definition Wool-Textures <vector>
  #("wool_colored_white"
    "wool_colored_orange"
    "wool_colored_magenta"
    "wool_colored_light_blue"
    "wool_colored_yellow"
    "wool_colored_lime"
    "wool_colored_pink"
    "wool_colored_gray"
    "wool_colored_silver"
    "wool_colored_cyan"
    "wool_colored_purple"
    "wool_colored_blue"
    "wool_colored_brown"
    "wool_colored_green"
    "wool_colored_red"
    "wool_colored_black"))

(define-minecraft-block Wool
  35
  texture: "wool_colored_white"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wool-Textures data-id))))
                (add-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering block-id add-face))))

(define-minecraft-block Dandelion
  37
  texture: "flower_dandelion"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)

(define-minecraft-block Rose
  38
  texture: "flower_rose"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)

(define-minecraft-block BrownMushroom
  39
  texture: "mushroom_brown"
  rendering: transparent-rendering
  physical?: #f
  cube?: #f
  opaque-cube?: #f)

(define-minecraft-block RedMushroom
  40
  texture: "mushroom_red"
  rendering: transparent-rendering
  physical?: #f
  cube?: #f
  opaque-cube?: #f)

(define-minecraft-block GoldBlock
  41
  texture: "gold_block")

(define-minecraft-block IronBlock
  42
  texture: "iron_block")

(define-minecraft-block DoubleStoneSlab
  43
  texture: "stone_slab_top")

(define-minecraft-block DoubleSandstoneSlab
  (43 1))

(define-minecraft-block DoubleWoodenSlab
  (43 2))

(define-minecraft-block DoubleCobblestoneSlab
  (43 3))

(define-minecraft-block DoubleBrickSlab
  (43 4))

(define-minecraft-block DoubleStoneBrickSlab
  (43 5))

(definition Slab-Textures <vector>
  #("stone_slab_top"
    "sandstone_top"
    "planks_oak"
    "cobblestone"
    "brick"
    "stonebrick"))

(define-minecraft-block StoneSlab
  44
  texture: "stone_slab_top"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Slab-Textures (modulo data-id 6)))))
                (if (< data-id 6)
                    (add-slab i j k x y z uv (uv-rect uv 0. .5 1. 1.) lighting rendering block-id add-face)
                  (add-slab i j k x (+ y block-radius) z uv (uv-rect uv 0. 0. 1. .5) lighting rendering block-id add-face)))))

(define-minecraft-block SandstoneSlab
  (44 1))

(define-minecraft-block WoodenSlab
  (44 2))

(define-minecraft-block CobblestoneSlab
  (44 3))

(define-minecraft-block BrickSlab
  (44 4))

(define-minecraft-block StoneBrickSlab
  (44 5))

(define-minecraft-block Brick
  45
  texture: "brick")

(define-minecraft-block TNT
  46
  texture: "tnt_side"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "tnt_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering block-id add-face))))

(define-minecraft-block Bookshelf
  47
  texture: "bookshelf"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "planks_jungle")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering block-id add-face))))

(define-minecraft-block MossyCobblestone
  48
  texture: "cobblestone_mossy")

(define-minecraft-block Obsidian
  49
  texture: "obsidian")

(define-minecraft-block Torch
  50
  texture: "torch_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  brightness: 14
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (if (or (= data-id 0) ;; for showcase
                          (= data-id 5))
                      (add-json-model "torch.json" block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref 0. 0.)
                    (let ((rot (case data-id
                                 ((1) 180.)
                                 ((2) 0.)
                                 ((3) 270.)
                                 ((4) 90.))))
                      (add-json-model "torch_wall.json" block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref rot 0.)))
                (add-torch block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref "pumpkin_face_on" "planks_spruce"))))

(define-minecraft-block Fire
  51
  texture: "furnace_front_on"
  brightness: 15
  opaque-cube?: #f
  cube?: #f
  physical?: #f)

(define-minecraft-block MonsterSpawner
  52
  texture: "mob_spawner"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block WoodenStairs
  53
  texture: "planks_oak"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block Chest
  54
  texture: "chest_top"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (- x 7m))
                    (right (+ x 7m))
                    (bottom (- y block-radius))
                    (top (+ y 7m))
                    (back (- z 7m))
                    (front (+ z 7m)))
                (let ((side-uv (get-coordinates "chest_side"))
                      (front-uv (get-coordinates "chest_front"))
                      (back-uv (get-coordinates "chest_back"))
                      (bottom-uv (get-coordinates "chest_bottom"))
                      (top-uv uv))
                  (add-face (left-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (right-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (back-face   i j k x y z left right bottom top back front back-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (front-face  i j k x y z left right bottom top back front front-uv generic-coordinates lighting rendering block-id) rendering))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (let ((world (current-world))
                       (index (get-index~ sector)))
                   (let ((data (block-entity-data i j k region (vector-ref index 0) (vector-ref index 1) (vector-ref index 2))))
                     (chest-pane~ world data)
                     (bag-pane~ world)))))

(define-minecraft-block RedstoneWire
  55
  texture: "redstone_dust_line"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-bottom i j k x y z uv generic-coordinates lighting rendering block-id add-face)))

(define-minecraft-block DiamondOre
  56
  texture: "diamond_ore")

(define-minecraft-block DiamondBlock
  57
  texture: "diamond_block")

(define-minecraft-block Workbench
  58
  texture: "log_oak")

(define-minecraft-block WheatCrops
  59
  texture: "wheat_stage_7"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)

(define-minecraft-block Soil
  60
  texture: "dirt"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-opaque-cube i j k x y z uv uv uv (get-coordinates "farmland_dry") uv uv lighting rendering block-id add-face)))

(define-minecraft-block Furnace
  61
  texture: "furnace_side")

(define-minecraft-block BurningFurnace
  62
  texture: "furnace_front_on"
  brightness: 13)

(class Sign-Element extends Element
  
  (property quad <Quad> initialize #f accessors generate)
  (property data        initialize #f accessors generate)
  
  (slot quad-texture <Quad-Texture+> initialize #f)
  
  (method override (destroy)
    (nextmethod)
    (when quad-texture
      (close~ quad-texture)))
  
  (method (sign-quad-texture)
    (let ((quad-texture <Quad-Texture> (make-quad-texture 100 50 (get-v1~ quad) (get-v2~ quad) (get-v3~ quad) (get-v4~ quad))))
      (let ((texture (get-texture~ quad-texture)))
        (let ((surface (get-surface~ texture))
              (font {Font font-name: tahoma point-size: 11 antialias: none})
              (color {Color Black})
              (width (get-width~ texture)))
          (define (draw-line v text)
            (let ((w (get-text-width~ surface text)))
              (let ((h (fxceiling (/ (cast <fl> (- width w)) 2.))))
                (draw-text~ surface h v text color))))
          
          (clear~ surface)
          (set-font~ surface font)
          (draw-line 0 (tag-assoc "Text1" data))
          (draw-line 12 (tag-assoc "Text2" data))
          (draw-line 24 (tag-assoc "Text3" data))
          (draw-line 36 (tag-assoc "Text4" data))
          (map-texture~ texture)))
      quad-texture))
  
  (method override (draw)
    (when (not quad-texture)
      (set! quad-texture (sign-quad-texture)))
    (allege quad-texture
      (render-texture~ quad-texture))))

(definition (contains-text? data)
  (or (not (equal? (tag-assoc "Text1" data) ""))
      (not (equal? (tag-assoc "Text2" data) ""))
      (not (equal? (tag-assoc "Text3" data) ""))
      (not (equal? (tag-assoc "Text4" data) ""))))

(definition (make-sign-element position v1 v2 v3 v4 matrix data)
  (let ((v1 (vertex+ position (matrix-transform-3x4 matrix v1)))
        (v2 (vertex+ position (matrix-transform-3x4 matrix v2)))
        (v3 (vertex+ position (matrix-transform-3x4 matrix v3)))
        (v4 (vertex+ position (matrix-transform-3x4 matrix v4))))
    (let ((quad (make-quad #f v1 v2 v3 v4)))
      (new Sign-Element position: position quad: quad data: data))))

(define-minecraft-block SignPost
  63
  texture: "planks_birch"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((matrix (make-lookat-matrix& (horizon-lookat& (rotate-upon& (- (* (cast <fl> data-id) PI/8)) (vertex& 0. 1. 0.) (vertex& 0. 0. 1.))))))
                ;; sign
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom 0.)
                      (top (+ block-radius))
                      (back (- .05))
                      (front (+ .05)))
                  (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face)
                  ;; text
                  (unless (minecraft-model?)
                    (add-texture-element
                      (lambda (region sector-x sector-y sector-z adder)
                        (let ((data (block-entity-data i j k region sector-x sector-y sector-z)))
                          (when (contains-text? data)
                            (let ((front (+ front add-epsilon)))
                              (let ((v1 (vertex left top front))
                                    (v2 (vertex left bottom front))
                                    (v3 (vertex right bottom front))
                                    (v4 (vertex right top front)))
                                (adder
                                  (make-sign-element (vertex& x y z) v1 v2 v3 v4 matrix data))))))))))
                ;; post
                (let ((left (- .05))
                      (right (+ .05))
                      (bottom (- block-radius))
                      (top 0.)
                      (back (- .05))
                      (front (+ .05)))
                  (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face)))))


(define-minecraft-block WoodenDoorBlock
  64
  texture: "door_wood_lower"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (choose-door-model "wooden_door.json" block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
                ;; quick hack to remove all doors
                ))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (let ((zone (current-zone)))
                   (updating-sectors~ zone
                     (lambda (add-sector)
                       (if (bit-set? 3 data-id)
                           (with-field i (- j 1) k
                             (lambda (section index)
                               (let ((data (data-ref section index)))
                                 (data-set! section index
                                   (if (bit-set? 2 data)
                                       (bit-set data 2 #f)
                                     (bit-set data 2 #t)))
                                 (add-sector sector)
                                 (add-sector (get-sector~ section)))))
                         (begin
                           (with-field i j k
                             (lambda (section index)
                               (data-set! section index
                                 (if (bit-set? 2 data-id)
                                     (bit-set data-id 2 #f)
                                   (bit-set data-id 2 #t)))
                               (add-sector sector)
                               (add-sector (get-sector~ section)))))))))))


(definition block-states
  (make-table))

(definition (cache-block-states filename)
  (or (table-ref block-states filename #f)
      (begin
        (set-current-directory {Directory Yownu-World "assets" "minecraft" "block_states"})
        (if (file-exists? filename)
            (let ((variants (table-ref (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "block_states"} filename)) "variants")))
              (table-set! block-states filename variants)
              variants)
          (let ((variants (table-ref (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "block_states" "minecraft"} filename)) "variants")))
            (table-set! block-states filename variants)
            variants)))))

(definition (with-block-state filename key proc)
  (let ((variants (cache-block-states filename)))
    (let ((variant (table-ref variants key)))
      (let ((model (string-append (table-ref variant "model") ".json"))
            (rotation-y (table-ref variant "y" 0))
            (rotation-x (table-ref variant "x" 0)))
        (proc model rotation-y rotation-x)))))


(definition (choose-door-model filename block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
  (let ((lower-data (if (bit-set? 3 data-id) (data-ref i (- j 1) k) data-id))
        (upper-data (if (bit-set? 3 data-id) data-id (data-ref i (+ j 1) k))))
    (let ((key
            (string-append
              "facing="
              (case (bitwise-and lower-data #b11)
                ((0) "east,half=")
                ((1) "south,half=")
                ((2) "west,half=")
                ((3) "north,half="))
              (if (bit-set? 3 data-id)
                  "upper,hinge="
                "lower,hinge=")
              (if (bit-set? 0 upper-data)
                  "right,open="
                "left,open=")
              (if (bit-set? 2 lower-data)
                  "true"
                "false"))))
      (with-block-state filename key
        (lambda (model rotation-y rotation-x)
          (add-json-model model block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref rotation-y rotation-x))))))


(define-minecraft-block Ladder
  65
  texture: "ladder"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-transparent (bitwise-and data-id #b111) 5 4 3 2 i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block Rail
  66
  texture: "rail_normal"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-rail data-id i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block CobblestoneStairs
  67
  texture: "cobblestone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block WallSign
  68
  texture: "planks_birch"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (- block-radius))
                    (right (+ block-radius))
                    (bottom (- (/ block-radius 2.)))
                    (top (+ (/ block-radius 2.)))
                    (back (+ (- block-radius) .025))
                    (front (+ (- block-radius) .125)))
                (let ((matrix (make-lookat-matrix& (horizon-lookat& (case data-id
                                                                      ((2) (vertex&  0. 0. -1.))
                                                                      ((3) (vertex&  0. 0.  1.))
                                                                      ((4) (vertex& -1. 0.  0.))
                                                                      ((5) (vertex&  1. 0.  0.))
                                                                      ;; for the model
                                                                      ((0) (vertex&  0. 0.  1.)))))))
                  ;; sign
                  (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face)
                  ;; text
                  (unless (minecraft-model?)
                    (add-texture-element
                      (lambda (region sector-x sector-y sector-z adder)
                        (let ((data (block-entity-data i j k region sector-x sector-y sector-z)))
                          (when (contains-text? data)
                            (let ((front (+ front add-epsilon)))
                              (let ((v1 (vertex left top front))
                                    (v2 (vertex left bottom front))
                                    (v3 (vertex right bottom front))
                                    (v4 (vertex right top front)))
                                (adder
                                  (make-sign-element (vertex& x y z) v1 v2 v3 v4 matrix data)))))))))))))

;; improve
(define-minecraft-block Lever
  69
  texture: "lever"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (lever-model "lever.json" block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
                (let ((matrix (make-lookat-matrix& (horizon-lookat& (case (bitwise-and data-id #b111)
                                                                      ((0) (vertex&  0.  0.  1.))
                                                                      ((1) (vertex&  0.  0.  1.))
                                                                      ((2) (vertex&  0.  0. -1.))
                                                                      ((3) (vertex& -1.  0.  0.))
                                                                      ((4) (vertex&  1.  0.  0.))
                                                                      ((5) (vertex&  0.  0.  1.))
                                                                      ((6) (vertex&  0.  0.  1.))
                                                                      ((7) (vertex&  0.  0.  0.))))))
                      (margin 3m)
                      (cobble (get-coordinates "cobblestone")))
                  (let ((left (+ (- block-radius) .01))
                        (right (+ (- block-radius) margin))
                        (bottom (- .25))
                        (top (+ .25))
                        (back (- margin))
                        (front (+ margin))
                        (right-uv (uv-rect cobble 0. .5 .375 1.))
                        (front-uv (uv-rect cobble 0. 0. margin .5))
                        (top-uv (uv-rect cobble .8125 .6125 1. 1.)))
                    (add-face (left-generic   i j k x y z left right bottom top back front right-uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (right-generic  i j k x y z left right bottom top back front right-uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (bottom-generic i j k x y z left right bottom top back front top-uv   generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (top-generic    i j k x y z left right bottom top back front top-uv   generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (back-generic   i j k x y z left right bottom top back front front-uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (front-generic  i j k x y z left right bottom top back front front-uv generic-coordinates lighting rendering block-id matrix) rendering)))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (with-field i j k
                   (lambda (section index)
                     (updating-sectors~ ?z
                       (lambda (add-sector)
                         (add-sector (get-sector~ section))
                         (if (bit-set? 3 data-id)
                             (data-set! section index (bit-set data-id 3 #f))
                           (begin
                             (data-set! section index (bit-set data-id 3 #t))
                             (lever-update~ (current-game) data-id i j k add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))))))))

(definition (lever-model filename block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
  (let ((key
          (string-append
            "facing="
            (case (bitwise-and data-id #b111)
              ((0) "down_z")
              ((1) "east")
              ((2) "west")
              ((3) "south")
              ((4) "north")
              ((5) "up_x")
              ((6) "up_z")
              ((7) "down_x"))
            ",powered="
            (if (bit-set? 3 data-id)
                "false"
              "true"))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model model block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref rotation-y rotation-x)))))

        
(define-minecraft-block StonePressurePlate
  70
  texture: "stone_slab_top"
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (+ (- x block-radius) 1m))
                    (right (- (+ x block-radius) 1m))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) 1m))
                    (back (+ (- z block-radius) 1m))
                    (front (- (+ z block-radius) 1m)))
                (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering))))

(define-minecraft-block IronDoorBlock
  71
  texture: "door_iron_lower"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (choose-door-model "iron_door.json"block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
                ;; quick hack to remove all doors
                )))

(define-minecraft-block WoodenPressurePlate
  72
  texture: "planks_oak"
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (+ (- x block-radius) 1m))
                    (right (- (+ x block-radius) 1m))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) 1m))
                    (back (+ (- z block-radius) 1m))
                    (front (- (+ z block-radius) 1m)))
                (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering))))

(define-minecraft-block RedstoneOre
  73
  texture: "redstone_ore")

(define-minecraft-block GlowingRedstoneOre
  74
  texture: "repeater_on"
  brightness: 9)

(define-minecraft-block RedstoneTorchOff
  75
  texture: "redstone_torch_off"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-torch block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref "melon_top" "planks_spruce")))

(define-minecraft-block RedstoneTorchOn
  76
  texture: "redstone_torch_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  brightness: 7
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (redstone-torch-model "redstone_torch.json" block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
                (add-torch block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref "pumpkin_top" "planks_spruce"))))

(definition (redstone-torch-model filename block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
  (let ((key (string-append
                 "facing="
                 (case data-id
                   ((1) "west")
                   ((2) "east")
                   ((3) "north")
                   ((4) "south")
                   (else "up")))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model model block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref rotation-y rotation-x)))))

(define-minecraft-block StoneButton
  77
  texture: "cobblestone"
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-button block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)))

(define-minecraft-block Snow
  78
  texture: "snow"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) (* (+ data-id 1) (/ 1. 8.))))
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering))))

(define-minecraft-block Ice
  79
  texture: "ice")

(define-minecraft-block SnowBlock
  80
  texture: "snow")

;; todo other faces
(define-minecraft-block Cactus
  81
  texture: "cactus_side"
  opaque-cube?: #f
  cube?: #f)

(define-minecraft-block Clay
  82
  texture: "clay")

(define-minecraft-block SugarCane
  83
  texture: "reeds"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)

(define-minecraft-block Jukebox
  84
  texture: "jukebox_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "jukebox_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering block-id add-face))))

(define-minecraft-block Fence
  85
  texture: "planks_oak"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-fence data-id i j k x y z uv lighting rendering block-id add-face block-ref '(85 @quick-hack-to-remove-all-doors 107))))

(define-minecraft-block Pumpkin
  86
  texture: "pumpkin_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "pumpkin_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering block-id add-face))))

(define-minecraft-block Netherrack
  87
  rendering: water-rendering
  texture: "netherrack")

(define-minecraft-block SoulSand
  88
  rendering: water-rendering
  texture: "soul_sand")

(define-minecraft-block Glowstone
  89
  rendering: multitexture-rendering
  texture: "glowstone"
  brightness: 15)

;; improve
(define-minecraft-block Portal
  90
  rendering: multitexture-rendering
  texture: "portal"
  opaque-cube?: #f
  cube?: #f)

(define-minecraft-block Jack-O-Lantern
  91
  texture: "pumpkin_top"
  brightness: 15)

(define-minecraft-block CakeBlock
  92
  texture: "cake_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 1m)
                    (half (/ 1. 32.)))
                (let ((left (+ (- x block-radius) margin))
                      (right (- (+ x block-radius) margin))
                      (bottom (- y block-radius))
                      (top y)
                      (back (+ (- z block-radius) margin))
                      (front (- (+ z block-radius) margin))
                      (side-uv uv)
                      (bottom-uv (get-coordinates "cake_bottom"))
                      (top-uv (get-coordinates "cake_top")))
                  (add-face (left-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (right-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (back-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (front-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)))))

;; improve
(define-minecraft-block RedstoneRepeaterBlockOff
  93
  texture: "repeater_off"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 2m)
                    (matrix (make-y-rotation-matrix (* PI/2 (cast <fl> (bitwise-and data-id #b11))))))
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom (- block-radius))
                      (top (+ margin (- block-radius)))
                      (back (- block-radius))
                      (front (+ block-radius)))
                  (let ((side-uv (uv-rect (get-coordinates "stone")  0. .875 0. 1.)))
                    (add-face (left-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (right-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (bottom-generic i j k x y z left right bottom top back front (get-coordinates "stone") generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (top-generic    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (back-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (front-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering))))))

;; improve
(define-minecraft-block RedstoneRepeaterBlockOn
  94
  texture: "repeater_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 2m)
                    (matrix (make-y-rotation-matrix (* PI/2 (cast <fl> (bitwise-and data-id #b11))))))
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom (- block-radius))
                      (top (+ margin (- block-radius)))
                      (back (- block-radius))
                      (front (+ block-radius)))
                  (let ((side-uv (uv-rect (get-coordinates "stone")  0. .875 0. 1.)))
                    (add-face (left-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (right-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (bottom-generic i j k x y z left right bottom top back front (get-coordinates "stone") generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (top-generic    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (back-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering)
                    (add-face (front-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering))))))

;; improve
(define-minecraft-block LockedChest
  95
  texture: "piston_top_normal"
  cube?: #f)

(define-minecraft-block Trapdoor
  96
  texture: "trapdoor"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (choose-trapdoor-model "trapdoor.json" block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
                (add-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering block-id add-face)))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (let ((zone (current-zone)))
                   (updating-sectors~ zone
                     (lambda (add-sector)
                       (with-field i j k
                         (lambda (section index)
                           (data-set! section index
                             (if (bit-set? 2 data-id)
                                 (bit-set data-id 2 #f)
                               (bit-set data-id 2 #t)))
                           (add-sector sector))))))))

(definition (choose-trapdoor-model filename block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
  (let ((key
          (string-append
            "facing="
            (case (bitwise-and data-id #b11)
              ((0) "south,half=")
              ((1) "north,half=")
              ((2) "east,half=")
              ((3) "west,half="))
            (if (bit-set? 3 data-id)
                "top,open="
              "bottom,open=")
            (if (bit-set? 2 data-id)
                "true"
              "false"))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model model block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref rotation-y rotation-x)))))


;; improve with data
(define-minecraft-block StoneSilverfish
  97
  texture: "stone")

(define-minecraft-block CobblestoneSilverfish
  (97 1))

(define-minecraft-block StoneBrickSilverfish
  (97 2))

(define-minecraft-block StoneBrick
  98
  texture: "stonebrick_cracked")

(define-minecraft-block MossyStoneBrick
  (98 1))

(define-minecraft-block CrackedStoneBrick
  (98 2))

(define-minecraft-block BrownMushroomCap
  99
  texture: "mushroom_block_skin_brown")

(define-minecraft-block RedMushroomCap
  100
  texture: "mushroom_block_skin_red")

(define-minecraft-block IronBars
  101
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (choose-fence-model "iron_bars.json" block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom (- block-radius))
                      (top (+ block-radius))
                      (back (- block-radius))
                      (front (+ block-radius))
                      (left?  (/= (cast <fx> (block-ref (- i 1) j k)) air-id))
                      (right? (/= (cast <fx> (block-ref (+ i 1) j k)) air-id))
                      (back?  (/= (cast <fx> (block-ref i j (- k 1))) air-id))
                      (front? (/= (cast <fx> (block-ref i j (+ k 1))) air-id))
                      (matrix (make-lookat-matrix& (horizon-lookat& (vertex&  0. 0.  1.)))))
                  (if (and (not left?)
                           (not right?)
                           (not back?)
                           (not front?))
                      (begin
                        (add-face (x-generic i j k x y z 0. 0. bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering)
                        (add-face (z-generic i j k x y z left right bottom top 0. 0. uv generic-coordinates lighting rendering block-id matrix) rendering))
                    (let ((uv (uv-rect uv 0. 0. .5 1.)))
                      (when left?
                        (add-face (z-generic i j k x y z left 0. bottom top 0. 0. uv generic-coordinates lighting rendering block-id matrix) rendering))
                      (when right?
                        (add-face (z-generic i j k x y z 0. right bottom top 0. 0. uv generic-coordinates lighting rendering block-id matrix) rendering))
                      (when back?
                        (add-face (x-generic i j k x y z 0. 0. bottom top back 0. uv generic-coordinates lighting rendering block-id matrix) rendering))
                      (when front?
                        (add-face (x-generic i j k x y z 0. 0. bottom top 0. front uv generic-coordinates lighting rendering block-id matrix) rendering))))))))

(definition (choose-fence-model filename block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
  (define (connects? i j k)
    (let ((block (block-ref i j k)))
      (or (= block 101) (and (get-cube?~ (blockid->block block)) (not (memv? block '(29 33 79 138)))))))
  
  (let ((key (string-append
               "east="
               (if (connects? (- i 1) j k)
                   "true"
                 "false")
               ",north="
               (if (connects? i j (+ k 1))
                   "true"
                 "false")
               ",south="
               (if (connects? i j (- k 1))
                   "true"
                 "false")
               ",west="
               (if (connects? (+ i 1) j k)
                   "true"
                 "false"))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model model block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref rotation-y rotation-x)))))

(define-minecraft-block GlassPane
  102
  texture: "glass"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block MelonBlock
  103
  texture: "melon_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "melon_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering block-id add-face))))

(define-minecraft-block PumpkinStem
  104
  texture: "pumpkin_stem_disconnected_ochre"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cross-faces i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block MelonStem
  105
  texture: "melon_stem_disconnected_ochre"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cross-faces i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block Vines
  106
  texture: "vine_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-transparent data-id 2 8 4 1 i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block FenceGate
  107
  texture: "planks_oak"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              ;; quick hack to remove all doors
              #f
              @w
              (let ((matrix (make-lookat-matrix& (horizon-lookat& (case (bitwise-and data-id #b11)
                                                                    ((0 2) (vertex&  0. 0.  1.))
                                                                    ((1 3) (vertex& -1. 0.  0.))))))
                    (opened? (bit-set? 2 data-id)))
                (define (add-trunk left <fl> right <fl>)
                  (let ((bottom (+ (- block-radius) .35))
                        (top (+ block-radius))
                        (back (- .075))
                        (front (+ .075)))
                    (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face)))
                
                (define (add-branches left <fl> right <fl> back <fl> front <fl>)
                  ;; upper
                  (let ((bottom (- .35 .075))
                        (top (+ .35 .075)))
                    (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face))
                  ;; lower
                  (let ((bottom (- .075))
                        (top (+ .075)))
                    (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face)))
                
                (define (add-middle left <fl> right <fl> back <fl> front <fl>)
                  (let ((bottom -.075)
                        (top (+ .35 .075)))
                    (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face)))
                
                ;; trunk
                (add-trunk (- block-radius) (+ (- block-radius) .2))
                (add-trunk (- (+ block-radius) .2) (+ block-radius))
                ;; branches
                (cond (opened?
                       (add-branches (- block-radius) (+ (- block-radius) .2) .075 (- (+ block-radius) .2))
                       (add-branches (- (+ block-radius) .2) (+ block-radius) .075 (- (+ block-radius) .2)))
                      (else
                       (add-branches (+ (- block-radius) .2) -.1 (- .075) (+ .075))
                       (add-branches .1 (- (+ block-radius) .2) (- .075) (+ .075))))
                ;; middle
                (cond (opened?
                       (add-middle (- block-radius) (+ (- block-radius) .2) (- (+ block-radius) .2) (+ block-radius))
                       (add-middle (- (+ block-radius) .2) (+ block-radius) (- (+ block-radius) .2) (+ block-radius)))
                      (else
                       (add-middle -.1 0. (- .075) (+ .075))
                       (add-middle 0. .1 (- .075) (+ .075)))))))

(define-minecraft-block BrickStairs
  108
  texture: "brick"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block StoneBrickStairs
  109
  texture: "stonebrick"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block Mycelium
  110
  texture: "mycelium_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "mycelium_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering block-id add-face))))

(define-minecraft-block LilyPad
  111
  texture: "waterlily_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-bottom i j k x y z uv generic-coordinates lighting rendering block-id add-face)))

(define-minecraft-block NetherBrick
  112
  texture: "nether_brick")

(define-minecraft-block NetherBrickFence
  113
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates "nether_brick")))
                (add-fence data-id i j k x y z uv lighting rendering block-id add-face block-ref '(113)))))

(define-minecraft-block NetherBrickStairs
  114
  texture: "nether_brick"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering block-id add-face)))

;; improve
(define-minecraft-block NetherWart
  115
  texture: "nether_wart_stage_1"
  opaque-cube?: #f
  cube?: #f)

(define-minecraft-block EnchantmentTable
  116
  texture: "enchanting_table_side"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 4m))
                (let ((left (- x block-radius))
                      (right (+ x block-radius))
                      (bottom (- y block-radius))
                      (top (+ y margin))
                      (back (- z block-radius))
                      (front (+ z block-radius))
                      (top-uv (get-coordinates "enchanting_table_top"))
                      (bottom-uv (get-coordinates "enchanting_table_bottom")))
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)))))

(define-minecraft-block BrewingStand
  117
  texture: "brewing_stand"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)

(define-minecraft-block Cauldron
  118
  texture: "cauldron_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 4m)
                    (half 2m))
                (let ((left (- x block-radius))
                      (right (+ x block-radius))
                      (bottom (- y block-radius))
                      (top (+ y block-radius))
                      (back (- z block-radius))
                      (front (+ z block-radius))
                      (top-uv (get-coordinates "cauldron_top"))
                      (bottom-uv (get-coordinates "cauldron_bottom"))
                      (inner-uv (get-coordinates "cauldron_inner")))
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (left-face   i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (right-face  i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (back-face   i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (front-face  i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (top-face    i j k x y z left right bottom (+ bottom margin) back front inner-uv generic-coordinates lighting rendering block-id) rendering)
                  (if (> data-id 0)
                      (let ((water-uv (get-coordinates "water"))
                            (wtop (/ (+ 6. (* 3. data-id)) 16.)))
                        (add-face (top-face i j k x y z left right bottom wtop back front water-uv generic-coordinates lighting rendering block-id) rendering)))))))

;; improve
(define-minecraft-block EndPortal
  119
  texture: "stone_slab_top"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-slab i j k x y z uv uv lighting rendering block-id add-face)))

(define-minecraft-block EndPortalFrame
  120
  texture: "endframe_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 5m))
                (let ((left (- x block-radius))
                      (right (+ x block-radius))
                      (bottom (- y block-radius))
                      (top (+ y margin))
                      (back (- z block-radius))
                      (front (+ z block-radius))
                      (top-uv (get-coordinates "endframe_top"))
                      (bottom-uv (get-coordinates "end_stone")))
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
                  (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)))
              (when (= data-id 4)
                (let ((margin 4m))
                  (let ((top (+ y block-radius))
                        (bottom (+ y 5m))
                        (left (- x margin))
                        (right (+ x margin))
                        (back (- z margin))
                        (front (+ z margin))
                        (side-uv (get-coordinates "endframe_eye_side"))
                        (top-uv (get-coordinates "endframe_eye")))
                    (add-face (left-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
                    (add-face (right-face i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
                    (add-face (front-face i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
                    (add-face (back-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
                    (add-face (top-face   i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering))))))


(define-minecraft-block EndStone
  121
  texture: "end_stone")

;; improve
(define-minecraft-block DragonEgg
  122
  texture: "dragon_egg"
  opaque-cube?: #f
  cube?: #f)

(define-minecraft-block RedstoneLampOff
  123
  texture: "redstone_lamp_off"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "redstone_lamp_top_off")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering block-id add-face))))

(define-minecraft-block RedstoneLampOn
  124
  texture: "redstone_lamp_on"
  brightness: 15
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "redstone_lamp_top_on")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering block-id add-face))))

(definition Wood-Slab-Textures <vector>
  #("planks_oak"
    "planks_spruce"
    "planks_birch"
    "planks_jungle"))

;; improve
(define-minecraft-block DoubleWoodenSlab
  125
  texture: "planks_oak"
  opaque-cube?: #t
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wood-Slab-Textures (modulo data-id 4)))))
                (add-slab i j k x y z uv (uv-rect uv 0. .5 1. 1.) lighting rendering block-id add-face)
                (add-slab i j k x (+ y block-radius) z uv (uv-rect uv 0. 0. 1. .5) lighting rendering block-id add-face))))

(define-minecraft-block WoodenSlab
  126
  texture: "planks_oak"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wood-Slab-Textures (modulo data-id 4)))))
                (if (< data-id 3)
                    (add-slab i j k x y z uv (uv-rect uv 0. .5 1. 1.) lighting rendering block-id add-face)
                  (add-slab i j k x (+ y block-radius) z uv (uv-rect uv 0. 0. 1. .5) lighting rendering block-id add-face)))))

(define-minecraft-block CocoaPlant
  127
  texture: "cocoa_stage_2"
  opaque-cube?: #f
  cube?: #f)

(define-minecraft-block SandstoneStairs
  128
  texture: "sandstone_normal"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block EmeraldOre
  129
  texture: "emerald_ore")

;; improve
(define-minecraft-block EnderChest
  130
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)

;; improve
(define-minecraft-block TripwireHook
  131
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)

;; improve
(define-minecraft-block Tripwire
  132
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)

(define-minecraft-block EmeraldBlock
  133
  texture: "emerald_block")

(define-minecraft-block SpruceWoodStairs
  134
  texture: "planks_spruce"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block BirchWoodStairs
  135
  texture: "planks_birch"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering block-id add-face)))

(define-minecraft-block JungleWoodStairs
  136
  texture: "planks_jungle"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering block-id add-face)))

;; improve
(define-minecraft-block CommandBlock
  137
  texture: "farmland_wet")

;; improve
(define-minecraft-block BeaconBlock ;;
  138
  texture: "beacon"
  brightness: 15)

;; improve
(define-minecraft-block CobblestoneWall
  139
  texture: "cobblestone"
  opaque-cube?: #f
  cube?: #f)

;; improve
(define-minecraft-block FlowerPot
  140
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)

;; improve
(define-minecraft-block Carrots
  141
  texture: "farmland_wet"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)

;; improve
(define-minecraft-block Potatoes
  142
  texture: "farmland_wet"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)

;; improve
(define-minecraft-block WoodenButton
  143
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-button block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)))


(let ((unknown-texture "gold_ore"))
  (loop (for id from 0 below 256)
        (unless (vector-ref blockids id)
          (register-minecraft-block 'Unknown id
            texture: unknown-texture))))


;;;
;;;; Model
;;;


(class Minecraft-Block extends Entity
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! physical? #t))
  
  
  (method override (resolve-model)
    (find-minecraft-model model)))


(definition minecraft-models <table>
  (make-table test: eq?))


(definition minecraft-model?
  (make-parameter #f))


(definition (register-minecraft-models)
  (parameterize ((minecraft-model? #t))
    (loop (for n from 0 below (vector-length blockids))
          (let ((block <Minecraft-Block-Model> (vector-ref blockids n)))
            (let ((name (get-name~ block))
                  (id (get-id~ block)))
              (unless (or (= id 0)
                          (eq? name 'Unknown))
                (table-set! minecraft-models name
                  (lambda ()
                    (minecraft-model block)))))))))


(definition public (find-minecraft-model name)
  (let ((model (table-ref minecraft-models name #f)))
    (if (is? model Model)
        model
      (let ((model <Model> (model)))
        (set-name~ model name)
        (table-set! minecraft-models name model)
        model))))


(definition (minecraft-model block <Minecraft-Block-Model>)
  (let ((faces '())
        (block-id (get-id~ block))
        (uv (block-texture-coordinates block))
        (generate (get-generate~ block))
        (rendering (cache-rendering~ block))
        (transparent-rendering (transparent-rendering)))
    (define (block-ref i <fx> j <fx> k <fx>) <fx>
      air-id)
    
    (define (data-ref i <fx> j <fx> k <fx>) <fx>
      0)
    
    (define (add-face face <Face> rendering <Minecraft-Rendering>)
      (set! faces (cons face faces)))
    
    (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering block-id add-face)
      (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering)
      (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering)
      (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering)
      (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering)
      (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering)
      (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering))
    
    (define (add-texture-element element)
      )
    
    (define default-lighting
      (u8vector 0 60 4))
    
    (define (no-lighting i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      default-lighting)
    
    (let ((lighting no-lighting))
      (cond (generate
             (generate block-id 0 0 0 0 0. 0. 0. uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref))
            ((get-opaque-cube?~ block)
             (add-opaque-cube 0 0 0 0. 0. 0. uv uv uv uv uv uv lighting rendering block-id add-face))
            (else
             (add-cross-faces 0 0 0 0. 0. 0. uv lighting transparent-rendering block-id add-face))))
    (make-model faces)))


(register-minecraft-models)


;;;
;;;; Section
;;;


(class Minecraft-Section extends World-Section)


;;;
;;;; Chunk
;;;


(class Minecraft-Chunk extends World-Chunk
  
  
  (slot tag                      getter generate)
  (slot heightmap      <vector+> getter generate)
  (slot entities                 getter generate)
  (slot block-entities <table+>  getter generate)
  
  
  (method override (initialize sections tag heightmap entities block-entities)
    (nextmethod sections)
    (set! tag~self tag)
    (set! heightmap~self heightmap)
    (set! entities~self entities)
    (set! block-entities~self (index-block-entities block-entities)))
  
  
  (method (index-block-entities block-entities)
    (if (null? block-entities)
        #f
      (let ((table (make-table test: equal?)))
        (for-each (lambda (block-entity)
                    (let ((x (tag-assoc "x" block-entity))
                          (y (tag-assoc "y" block-entity))
                          (z (tag-assoc "z" block-entity)))
                      (let ((index (vector x y z)))
                        (table-set! table index block-entity))))
                  block-entities)
        table)))
  
  
  (method (find-block-entity index)
    (and block-entities (table-ref block-entities index #f))))


(definition (block-entity-data i <fx> j <fx> k <fx> region <World-Region> sector-x <fx> sector-y <fx> sector-z <fx>)
  (let ((chunk <Minecraft-Chunk> (get-chunk~ region sector-x sector-z))
        (index (vector (+ i (* sector-x 16))
                       (+ j (* sector-y 16) 64)
                       (+ k (* sector-z 16)))))
    (find-block-entity~ chunk index)))


;;;
;;;; Region
;;;


(class Minecraft-Region extends World-Region
  
  
  (method override (deserialize-chunk chunk-data <u8vector>) <Minecraft-Chunk>
    (let ((zone <Minecraft-Zone> (current-zone)))
      (with ((reader <NBT-Reader> (new NBT-Reader chunk-data compressed?: #f)))
        (let ((tag (read-tag~ reader)))
          (let ((compound (tag-assoc "Level" (tag-value tag))))
            (let ((heightmap (tag-assoc "HeightMap" compound))
                  (entities (list-payload-content (tag-assoc "Entities" compound)))
                  (block-entities (list-payload-content (tag-assoc "TileEntities" compound)))
                  (sections (list-payload-content (tag-assoc "Sections" compound))))
              (let ((sections-table (and sections (make-table test: eq?))))
                (when sections-table
                  (let ((truncate-y (get-truncate-y~ zone)))
                    (for-each (lambda (section)
                                (let ((yPos (- (cast <fx> (tag-assoc "Y" section)) 4)) ;; lower everything by 64
                                      (blocks (tag-assoc "Blocks" section))
                                      (data (tag-assoc "Data" section))
                                      (blocklight (tag-assoc "BlockLight" section))
                                      (skylight (tag-assoc "SkyLight" section)))
                                  (when (or (not truncate-y)
                                            (>= yPos (cast <fx> truncate-y)))
                                    (table-set! sections-table yPos (new Minecraft-Section blocks data blocklight skylight)))))
                              sections)))
                (new Minecraft-Chunk sections-table tag heightmap entities block-entities))))))))
  
  
  (method override (serialize-chunk chunk <Minecraft-Chunk>) <u8vector>
    (with ((writer <NBT-Writer> (new NBT-Writer #f)))
      (write-tag~ writer (get-tag~ chunk))
      (get-content~ writer))))


;;;
;;;; Zone
;;;


(definition protected day-duration <fl>
  24000.)

(definition protected dawn-daytime <fl>
  6000.)

(definition protected day-daytime <fl>
  12000.)

(definition protected dusk-daytime <fl>
  18000.)

(definition protected night-daytime <fl>
  0.)


(class Minecraft-Zone extends Zone
  
  
  (property level-dir   <Directory> initialize #f   accessors generate)
  (property truncate-y  <fx+>       initialize #f   accessors generate)
  (property player-glow <fl>        initialize -1.  accessors generate)
  
  
  (slot level-file initialize #f)
  (slot level-nbt  initialize #f)
  
  
  (form
    (<install> floor-level: #f start-grid?: #f start-axes?: #f jump-impulsion: .3))
  
  
  ;; quicky for tests
  (method override (minecraft?)
    #t)
  
  
  (method override (needs-pumps?)
    #t)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! ambient-color (dye .1 .05 0. 1.)))


  (proclaim (not warn optimizations))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set-daytime (effective-daytime start-time))
    (set! sun-angle (daytime->sun-angle daytime)))
  
  
  (method override (install-interface)
    (let ((world (current-world)))
      (update-actions~ (get-application)
        (lambda ()
          (set-visible?~ (child~ (get-bindings) '(world-minecraft toggle-player-glow)) #t)))
      (let ((interface (get-interface~ world)))
        (set-visible?~ (child~ interface 'minecraft) #t)
        (set-visible?~ (child~ interface 'bag) #f)
        (view-inventory~ (child~ interface 'belt))
        (set-visible?~ (child~ interface 'belt) #t)
        (set-visible?~ (child~ interface 'chest) #f))))
  
  
  (method override (uninstall-interface)
    (let ((world (current-world)))
      (update-actions~ (get-application)
        (lambda ()
          (set-visible?~ (child~ (get-bindings) '(world-minecraft toggle-player-glow)) #f)))
      (let ((interface (get-interface~ world)))
        (set-visible?~ (child~ interface 'minecraft) #f)
        (set-visible?~ (child~ interface 'bag) #f)
        (set-visible?~ (child~ interface 'belt) #f)
        (set-visible?~ (child~ interface 'chest) #f))))
  
  
  (method (bag-pane)
    (let ((world (current-world)))
      (child~ (get-interface~ world) 'bag)))
  
  (method (belt-pane)
    (let ((world (current-world)))
      (child~ (get-interface~ world) 'belt)))
  
  
  (method override (save-zone)
    (nextmethod)
    (when game?
      (save-inventory (bag-pane) (belt-pane))
      (save-level-nbt)))


  (proclaim (warn optimizations))
  
  
  (method override (setup-game)
    (set-current-game (new Minecraft-Game)))
  
  
  (method protected (get-level-file)
    (or level-file
        (let ((file (new-file~ level-dir "level.dat")))
          (set! level-file file)
          file)))
  
  
  (method public (get-level-nbt)
    (or level-nbt
        (let ((nbt (read-level (get-level-file))))
          (set! level-nbt nbt)
          nbt)))
  
  
  (method (read-level file)
    (with ((reader <NBT-Reader> (new NBT-Reader file compressed?: #t gzip?: #t)))
      (read-tag~ reader)))
  
  
  (method public (save-level-nbt)
    (save-level (get-level-nbt) (get-level-file)))
  
  
  (method (save-level level file)
    (with ((writer (new NBT-Writer file compressed?: #t gzip?: #t)))
      (write-tag~ writer level)))
  
  
  @not-working
  (method override (get-start-position)
    (bind (type x y z) (tag-assoc "Pos" (tag-assoc "Player" (tag-assoc "Data" (tag-value (get-level-nbt)))))
      (vertex x y z)))
  
  
  @not-working
  (method override (set-start-position pos)
    (nextmethod pos)
    (let ((tag (tag-assoc "Pos" (tag-assoc "Player" (tag-assoc "Data" (tag-value (get-level-nbt)))))))
      (set-second! tag (vertex-x pos))
      (set-third! tag (vertex-y pos))
      (set-fourth! tag (vertex-z pos)))
    (save-level-nbt))
  
  
  (method override (default-block-program)
    'minecraft)
  
  
  (method override (lighting-setup)
    (let ((world (current-world)))
      (let ((lights (effective-lights)))
        (let ((light (/ daylight 5.)))
          (set-ambient-color~ lighting (dye (+ (dye-red ambient-color) light)
                                            (+ (dye-green ambient-color) light)
                                            (+ (dye-blue ambient-color) light)
                                            1.0)))
        (set-lights~ lighting lights)
        (set-lights-count~ lighting (min (get-dynamic-lights~ world) (length lights)))
        (set-current-lighting lighting))))
  
  
  (method override (block-lighting-setup)
    (let ((world (current-world)))
      (let ((lights '()))
        (set-ambient-color~ block-lighting ambient-color)
        (set-lights~ block-lighting lights)
        (set-lights-count~ block-lighting 0)
        (set-current-block-lighting block-lighting))))
  
  
  (method override (default-lights)
    '())
  
  
  (method override (effective-player-glow)
    player-glow)
  
  
  (method override (sun-light?)
    #f)
  
  
  (method override (sun-update-lighting effective coord)
    )
  
  
  (method override (sun-update)
    (set-daytime (sun-angle->daytime sun-angle)))
  
  
  (method (goto-daytime daytime)
    (if sun-cycle?
        (position-sun (daytime->sun-angle daytime))
      (set-daytime daytime)))
  
  
  (method (update-daylight)
    )
  
  
  (method (sun-angle->daytime sun-angle)
    (let ((angle (flmodulo sun-angle PI*2)))
      (flmodulo (+ (/ (* angle day-duration) PI*2) dawn-daytime) day-duration)))
  
  
  (method (daytime->sun-angle daytime)
    (/ (* (- daytime dawn-daytime) PI*2) day-duration))
  
  
  (method (effective-daytime daytime)
    (cond ((flonum? daytime) daytime)
          ((or (eq? daytime 'default) (ci=? daytime "default")) dawn-daytime)
          ((or (eq? daytime 'dawn) (ci=? daytime "dawn")) dawn-daytime)
          ((or (eq? daytime 'day) (ci=? daytime "day")) day-daytime)
          ((or (eq? daytime 'dusk) (ci=? daytime "dusk")) dusk-daytime)
          ((or (eq? daytime 'night) (ci=? daytime "night")) night-daytime)
          ((string? daytime) (cast <fl> (string->number daytime)))
          (else "Invalid daytime: {s}" daytime)))
  
  
  (method override (album-name)
    'minecraft)
  
  
  (method override (create-album)
    (let ((album (nextmethod)))
      (update-textures-subuvs (get-atlas~ album))
      album))
  
  
  (method override (create-atlas)
    (create-minecraft-atlas))
  
  
  (method override (create-textures atlas)
    (list->table
      (list
        ;; clamp to edge is necessary for joins like between the rails
        (cons 'linear (create-minecraft-texture atlas wrap: GL_CLAMP_TO_EDGE))
        (cons 'nearest (create-minecraft-texture atlas nearest?: #t)))))
  
  
  (method override (create-opaque-material atlas texture)
    (get-material~ (cast <Minecraft-Rendering> (opaque-rendering))))
  
  
  (method override (create-transparent-material atlas texture)
    (get-material~ (cast <Minecraft-Rendering> (transparent-rendering))))
  
  
  (method override (sample-program-image program)
    (case program
      ((opaque) "stone")
      ((transparent) "flower_rose")
      (else "wool_colored_light_blue")))
  
  
  (method override (default-block-class)
    (new Minecraft-Block model: 'Stone))
  
  
  (method override (zone-destructible?)
    #f)
  
  
  (method override (region-class)
    Minecraft-Region)
  
  
  (method override (get-regions-dir) <Directory>
    (or regions-dir (let ((dir (new-directory~ level-dir "region")))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method override (resurrect-player player)
    (let ((level (get-level-nbt)))
      (let ((compound (tag-assoc "Data" (tag-value level))))
        (let ((x (tag-assoc "SpawnX" compound))
              (y (tag-assoc "SpawnY" compound))
              (z (tag-assoc "SpawnZ" compound)))
          (let ((old-position (copy-vertex (get-position~ player)))
                (new-position (vertex (fl x) (- (fl y) 63.) (fl z))))
            (set-position~ player new-position)
            (set-velocity~ player (vertex 0. 0. 0.))
            (update-element player old-position))))))
  
  
  (method (on-toggle-player-glow evt)
    (if (= player-glow -1.)
        (set! player-glow 300.)
      (set! player-glow -1.)))
  
  
  (method override (generate-content?)
    #t)
  
  
  (definition generate-mutex
    (make-mutex 'generate))
  
  
  (add-debugger-release 'generate-mutex
    (lambda ()
      (when (eq? (mutex-owner generate-mutex) (current-thread))
        (mutex-unlock! generate-mutex))))
  
  
  (method override (generate-content sector <Sector>)
    (mutex-lock! generate-mutex)
    (generate-sector sector 'render)
    (mutex-unlock! generate-mutex))
  
  
  (method override (generate-physical sector <Sector>)
    (mutex-lock! generate-mutex)
    (generate-sector sector 'physical)
    (mutex-unlock! generate-mutex))
  
  
  (definition block-cache-size <fx>
    (* 18 18 18 4))
  
  (definition block-cache <u16vector>
    (make-u16vector block-cache-size))
  
  (definition (initialize-block-cache cache-uninitialized <fx>) <u16vector>
    (loop (for i from 0 below block-cache-size)
          (u16vector-set! block-cache i cache-uninitialized))
    block-cache)
  
  
  (method (generate-sector sector <Sector> what)
    (define (conclude-rendering rendering <Minecraft-Rendering>)
      (let ((content (get-mesh-content~ (get-mesher~ rendering))))
        (when content
          (cons (get-material~ rendering) content))))
    
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (set-generating?~ sector #f)
      (decrease-sectors-generating 1))
    
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (checkpoint)
    (checkpoint 1)
    (when (eq? self (current-zone))
      (let ((sector-index (get-index~ sector)))
        (let ((sector-x <fx> (vector-ref sector-index 0))
              (sector-y <fx> (vector-ref sector-index 1))
              (sector-z <fx> (vector-ref sector-index 2)))
          (let ((region (sector-region sector-x sector-y sector-z)))
            (if (not region)
                (when (eq? what 'render)
                  (generate-done))
              (let ((region-x (get-x~ region))
                    (region-z (get-z~ region))
                    (section (get-section~ region sector-x sector-y sector-z))
                    (chunk-index (chunk-index~ region sector-x sector-z))
                    (cache-uninitialized 65535))
                (if (not section)
                    (when (eq? what 'render)
                      (generate-done))
                  (site (content on?: #t parent: generate)
                  (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                        (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                        (section-y (* sector-y 16))
                        (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                        (sections <vector> (make-vector 27 #t))
                        (cache <u16vector> (initialize-block-cache cache-uninitialized))
                        (blocks <u8vector> (get-blocks~ section))
                        (data <u8vector> (get-data~ section))
                        (blocklight <u8vector> (get-blocklight~ section))
                        (skylight <u8vector> (get-skylight~ section))
                        (opaque-rendering <Minecraft-Rendering> (opaque-rendering))
                        (transparent-rendering <Minecraft-Rendering> (transparent-rendering))
                        (coverage-rendering <Minecraft-Rendering> (coverage-rendering))
                        (water-rendering <Minecraft-Rendering> (water-rendering))
                        (wet-rendering <Minecraft-Rendering> (wet-rendering))
                        (multitexture-rendering <Minecraft-Rendering> (multitexture-rendering))
                        (areas (and (eq? what 'physical) (make-table test: eq?)))
                        (areas-bounds (sector-areas-bounds sector))
                        (texture-elements '()))
                    (define (section-ref a <fx> b <fx> c <fx>) <Minecraft-Section+>
                      (if (and (= a 0)
                               (= b 0)
                               (= c 0))
                          section
                        (let ((index (section-index a b c)))
                          (let ((section (vector-ref sections index)))
                            (if (neq? section #t)
                                section
                              (let ((x (+ sector-x a))
                                    (y (+ sector-y b))
                                    (z (+ sector-z c)))
                                (let ((region (sector-region x y z)))
                                  (let ((section (and region (get-section~ (cast <Minecraft-Region> region) x y z))))
                                    (vector-set! sections index section)
                                    section))))))))
                    
                    (define (section-index a <fx> b <fx> c <fx>) <fx>
                      (+ (* b 9) (* c 3) a 13))
                    
                    (define (local-index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (effective-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* j 324) (* k 18) i 343) 4))
                    
                    (define (blocks-get section <Minecraft-Section>) <u8vector>
                      (get-blocks~ section))
                    
                    (define (data-get section <Minecraft-Section>) <u8vector>
                      (get-data~ section))
                    
                    (define (blocklight-get section <Minecraft-Section>) <u8vector>
                      (get-blocklight~ section))
                    
                    (define (skylight-get section <Minecraft-Section>) <u8vector>
                      (get-skylight~ section))
                    
                    (define (local-block-ref i <fx> j <fx> k <fx>) <fx>
                      (u8vector-ref blocks (local-index i j k)))
                    
                    (define (local-data-ref i <fx> j <fx> k <fx>) <fx>
                      (u4vector-ref data (local-index i j k)))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (effective-data-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k data-get u4vector-ref 0 0))
                    
                    (define (effective-light-ref! i <fx> j <fx> k <fx> lighting <u8vector>) <void>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache (+ index 1))))
                          (if (/= value cache-uninitialized)
                              (begin
                                (u8vector-set! lighting 0 (+ (u8vector-ref lighting 0) value))
                                (u8vector-set! lighting 1 (+ (u8vector-ref lighting 1) (u16vector-ref cache (+ index 2))))
                                (u8vector-set! lighting 2 (+ (u8vector-ref lighting 2) (u16vector-ref cache (+ index 3)))))
                            (let ((blocklight (field-ref i j k blocklight-get u4vector-ref 0 0))
                                  (skylight (field-ref i j k skylight-get u4vector-ref 15 15))
                                  (ambience (if (= (effective-block-ref i j k) air-id) 1 0)))
                              (u16vector-set! cache (+ index 1) blocklight)
                              (u16vector-set! cache (+ index 2) skylight)
                              (u16vector-set! cache (+ index 3) ambience)
                              (u8vector-set! lighting 0 (+ (u8vector-ref lighting 0) blocklight))
                              (u8vector-set! lighting 1 (+ (u8vector-ref lighting 1) skylight))
                              (u8vector-set! lighting 2 (+ (u8vector-ref lighting 2) ambience)))))))
                    
                    (define (inner-light-ref! i <fx> j <fx> k <fx> lighting <u8vector>) <void>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache (+ index 1))))
                          (if (/= value cache-uninitialized)
                              (begin
                                (u8vector-set! lighting 0 (+ (u8vector-ref lighting 0) value))
                                (u8vector-set! lighting 1 (+ (u8vector-ref lighting 1) (u16vector-ref cache (+ index 2))))
                                (u8vector-set! lighting 2 (+ (u8vector-ref lighting 2) (u16vector-ref cache (+ index 3)))))
                            (let ((local-index (local-index i j k)))
                              (let ((blocklight (u4vector-ref blocklight local-index))
                                    (skylight (u4vector-ref skylight local-index))
                                    (ambience (if (= (u8vector-ref blocks local-index) air-id) 1 0)))
                                (u16vector-set! cache (+ index 1) blocklight)
                                (u16vector-set! cache (+ index 2) skylight)
                                (u16vector-set! cache (+ index 3) ambience)
                                (u8vector-set! lighting 0 (+ (u8vector-ref lighting 0) blocklight))
                                (u8vector-set! lighting 1 (+ (u8vector-ref lighting 1) skylight))
                                (u8vector-set! lighting 2 (+ (u8vector-ref lighting 2) ambience))))))))
                    
                    (define (u4vector-ref field <u8vector> index <fx>) <fx>
                      (let ((byte (u8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (local-index i j k)))))))
                          
                          (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                ((> k 15) (bind-k 1 (- k 16)))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j -1 (+ 16 j)))
                              ((> j 15) (bind-j 1 (- j 16)))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i -1 (+ 16 i)))
                            ((> i 15) (bind-i 1 (- i 16)))
                            (else (bind-i 0 i))))
                    
                    (define (add-face-render face <Face> rendering <Minecraft-Rendering>)
                      (let ((mesher <Minecraft-Mesher> (get-mesher~ rendering)))
                        (add-face~ mesher face)
                        (add-lighting~ mesher face)))
                    
                    (define (add-face-physical face <Face> rendering <Minecraft-Rendering>)
                      (let ((poly (get-polygon~ face)))
                        (let ((center (get-center~ poly)))
                          (let ((index (position-area-index center)))
                            ;; it is critical for clearing polygons that every
                            ;; areas polygons are registered to belong to the zone
                            (let ((in-sector-index (vector (between (vector-ref areas-bounds 0) (vector-ref index 0) (vector-ref areas-bounds 3))
                                                           (between (vector-ref areas-bounds 1) (vector-ref index 1) (vector-ref areas-bounds 4))
                                                           (between (vector-ref areas-bounds 2) (vector-ref index 2) (vector-ref areas-bounds 5)))))
                              (let ((area (index-area in-sector-index #f)))
                                (table-add areas area poly)))))))
                    
                    (define add-face
                      (case what
                        ((render) add-face-render)
                        ((physical) add-face-physical)))
                    
                    (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering block-id add-face)
                      (let ((rendering (effective-rendering (effective-block-ref (- i 1) j k) rendering))) (when rendering (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (effective-block-ref (+ i 1) j k) rendering))) (when rendering (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (effective-block-ref i (- j 1) k) rendering))) (when rendering (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (effective-block-ref i (+ j 1) k) rendering))) (when rendering (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (effective-block-ref i j (- k 1)) rendering))) (when rendering (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (effective-block-ref i j (+ k 1)) rendering))) (when rendering (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering))))
                    
                    (define (add-inner-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering block-id add-face)
                      (let ((rendering (effective-rendering (local-block-ref (- i 1) j k) rendering))) (when rendering (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (local-block-ref (+ i 1) j k) rendering))) (when rendering (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (local-block-ref i (- j 1) k) rendering))) (when rendering (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (local-block-ref i (+ j 1) k) rendering))) (when rendering (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (local-block-ref i j (- k 1)) rendering))) (when rendering (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering)))
                      (let ((rendering (effective-rendering (local-block-ref i j (+ k 1)) rendering))) (when rendering (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering))))
                    
                    (define (effective-rendering block-id <fx> rendering <Minecraft-Rendering>)
                      (let ((block (blockid->block block-id)))
                        (cond ((get-opaque-cube?~ block)
                               #f)
                              ((get-water-cube?~ block)
                               wet-rendering)
                              (else
                               rendering))))
                    
                    (define (add-water-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering block-id add-face)
                      (unless (water-opaque? (effective-block-ref (- i 1) j k)) (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (effective-block-ref (+ i 1) j k)) (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (effective-block-ref i (- j 1) k)) (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (effective-block-ref i (+ j 1) k)) (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (effective-block-ref i j (- k 1))) (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (effective-block-ref i j (+ k 1))) (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering)))
                    
                    (define (add-inner-water-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering block-id add-face)
                      (unless (water-opaque? (local-block-ref (- i 1) j k)) (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (local-block-ref (+ i 1) j k)) (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (local-block-ref i (- j 1) k)) (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (local-block-ref i (+ j 1) k)) (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (local-block-ref i j (- k 1))) (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering))
                      (unless (water-opaque? (local-block-ref i j (+ k 1))) (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering)))
                    
                    (define (water-opaque? block-id <fx>)
                      (let ((block (blockid->block block-id)))
                        (or (get-water-cube?~ block)
                            (get-opaque-cube?~ block))))
                    
                    (define (compute-lighting i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                      (let ((lighting (make-u8vector 3)))
                        (effective-light-ref! (+ i ax) (+ j ay) (+ k az) lighting)
                        (effective-light-ref! (+ i bx) (+ j by) (+ k bz) lighting)
                        (effective-light-ref! (+ i cx) (+ j cy) (+ k cz) lighting)
                        (effective-light-ref! (+ i dx) (+ j dy) (+ k dz) lighting)
                        lighting))
                    
                    (define (compute-inner-lighting i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                      (let ((lighting (make-u8vector 3)))
                        (inner-light-ref! (+ i ax) (+ j ay) (+ k az) lighting)
                        (inner-light-ref! (+ i bx) (+ j by) (+ k bz) lighting)
                        (inner-light-ref! (+ i cx) (+ j cy) (+ k cz) lighting)
                        (inner-light-ref! (+ i dx) (+ j dy) (+ k dz) lighting)
                        lighting))
                    
                    (define (add-texture-element proc)
                      (proc region sector-x sector-y sector-z texture-element-adder))
                    
                    (define (texture-element-adder element)
                      (set! texture-elements (cons element texture-elements)))
                    
                    (reset-mesher~ opaque-rendering)
                    (reset-mesher~ transparent-rendering)
                    (reset-mesher~ coverage-rendering)
                    (reset-mesher~ water-rendering)
                    (reset-mesher~ wet-rendering)
                    (reset-mesher~ multitexture-rendering)
                    
                    ;; inner
                    (loop (for j from 1 below 15)
                          (loop (for k from 1 below 15)
                                (loop (for i from 1 below 15)
                                      (let ((block-id (local-block-ref i j k)))
                                        (when (/= block-id air-id)
                                          (let ((x (+ section-x i))
                                                (y (+ section-y j))
                                                (z (+ section-z k))
                                                (block (blockid->block block-id)))
                                            (let ((x (fl& (+ block-radius (cast <fl> x))))
                                                  (y (fl& (+ block-radius (cast <fl> y))))
                                                  (z (fl& (+ block-radius (cast <fl> z))))
                                                  (uv (block-texture-coordinates block))
                                                  (lighting compute-inner-lighting)
                                                  (rendering (cache-rendering~ block))
                                                  (generate (get-generate~ block)))
                                              (cond (generate
                                                     (generate block-id (local-data-ref i j k) i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element effective-block-ref effective-data-ref))
                                                    ((get-opaque-cube?~ block)
                                                     (add-inner-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering block-id add-face))
                                                    ((get-water-cube?~ block)
                                                     (add-inner-water-cube i j k x y z uv uv uv uv uv uv lighting rendering block-id add-face))
                                                    (else
                                                     (add-cross-faces i j k x y z uv lighting rendering block-id add-face))))))))))
                    
                    ;; outer
                    (let ()
                      (define (add i <fx> j <fx> k <fx>)
                        (let ((block-id (local-block-ref i j k)))
                          (when (/= block-id air-id)
                            (let ((x (+ section-x i))
                                  (y (+ section-y j))
                                  (z (+ section-z k))
                                  (block (blockid->block block-id)))
                              (let ((x (fl& (+ block-radius (cast <fl> x))))
                                    (y (fl& (+ block-radius (cast <fl> y))))
                                    (z (fl& (+ block-radius (cast <fl> z))))
                                    (uv (block-texture-coordinates block))
                                    (lighting compute-lighting)
                                    (rendering (cache-rendering~ block))
                                    (generate (get-generate~ block)))
                                (cond (generate
                                       (generate block-id (local-data-ref i j k) i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element effective-block-ref effective-data-ref))
                                      ((get-opaque-cube?~ block)
                                       (add-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering block-id add-face))
                                      ((get-water-cube?~ block)
                                       (add-water-cube i j k x y z uv uv uv uv uv uv lighting rendering block-id add-face))
                                      (else
                                       (add-cross-faces i j k x y z uv lighting rendering block-id add-face))))))))
                      
                      ;; left
                      (let ((i 0))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; right
                      (let ((i 15))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; bottom
                      (let ((j 0))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; top
                      (let ((j 15))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; back
                      (let ((k 0))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k))))
                      ;; front
                      (let ((k 15))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k)))))
                    (case what
                      ((physical)
                       (when (eq? self (current-zone))
                         (iterate-table areas
                           (lambda (area <Area> polygons)
                             (add-polygons~ area #f polygons #f)))))
                      ((render)
                       (let ((opaque (conclude-rendering opaque-rendering))
                             (transparent (conclude-rendering transparent-rendering))
                             (coverage (conclude-rendering coverage-rendering))
                             (water (conclude-rendering water-rendering))
                             (wet (conclude-rendering wet-rendering))
                             (multitexture (conclude-rendering multitexture-rendering)))
                         (write-render-event
                           (lambda ()
                             (define (prepare-mesh info)
                               (when info
                                 (bind (material triangles vertices neighbors lightmap) info
                                   (setup-mesh~ sector)
                                   (let ((mesh (get-mesh~ sector)))
                                     (allege mesh
                                       (fill-vertices/neighbors~ sector mesh triangles vertices neighbors)
                                       (fill-lightmap~ sector mesh triangles lightmap)
                                       (setup-array~ mesh))))))
                             
                             (define (prepare-other-mesh info)
                               (when info
                                 (bind (material triangles vertices neighbors lightmap) info
                                   (setup-other-meshes~ sector)
                                   (let ((mesh (new Mesh material: material)))
                                     (let ((material (get-material~ mesh)))
                                       (table-set! (allege (get-other-meshes~ sector)) material mesh)
                                       (fill-vertices/neighbors~ sector mesh triangles vertices neighbors)
                                       (fill-lightmap~ sector mesh triangles lightmap)
                                       (setup-array~ mesh))))))
                             
                             (when (eq? self (current-zone))
                               (free-mesh~ sector)
                               (prepare-mesh opaque)
                               (prepare-other-mesh transparent)
                               (prepare-other-mesh coverage)
                               (prepare-other-mesh water)
                               (prepare-other-mesh wet)
                               (prepare-other-mesh multitexture)
                               (set-vertices-uptodate?~ sector #t)
                               (set-lightmap-uptodate?~ sector #t)
                               (set-section~ sector section)
                               (when (not-null? texture-elements)
                                 (set-texture-elements~ sector texture-elements))
                               (sector-generated sector)
                               (generate-done)))))))
                    (checkpoint 9)))))))))))
  
  
  (method virtual (sector-generated sector)
    )
  
  
  ;;;
  ;;;; Spawn
  ;;;
  
  
  (method override (spawn-task task <Task>)
    (declare (proper-tail-calls))
    (let ((world (current-world)))
      (with-task task "spawn" spawn-id support-state
        (lambda (log-context exit)
          (if (not spawn?)
              (task-sleep +infinity exit support-state)
            (let ((sector #f)
                  (spawners #f))
              (let (iter (previous (current-seconds)))
                (let ((time (current-seconds)))
                  (let ((elapse (- time previous)))
                    (unless (get-paused?~ world)
                      (with-task-mutex spawn-sequential-state
                        (lambda ()
                          (unless (task-stopping?)
                            (trace-task spawn "W")
                            (let ((current-sector (element-sector (current-me))))
                              (let ((current-spawners (if (eq? sector current-sector)
                                                          spawners
                                                        (find-spawners current-sector))))
                                (set! sector current-sector)
                                (set! spawners current-spawners)
                                (tick-spawn elapse current-spawners)))))))
                    (let ((duration (- (current-seconds) time)))
                      (task-sleep (- spawn-rate duration) exit #f))
                    (iter time))))))))))
  
  
  (method (tick-spawn elapse spawners)
    (site (spawn on?: #t)
      (spawn-enemies elapse spawners)))
  
  
  (method (find-spawners sector)
    (let ((queue (new-queue)))
      (iterate-sector-neighbors sector 1
        (lambda (sector)
          (sector-iterate-blocks sector '(52)
            (lambda (index)
              ;; spawn faster the first time to compensate for not having natural spawning
              (enqueue queue (cons sector (cons 0. (cons (random-between 5. 20.) (index->coordinates index)))))))))
      (queue-list queue)))
  
  
  (method (spawn-enemies elapse spawners)
    (let ((world (current-world)))
      (for-each (lambda (spawner)
                  (bind (sector time-since-last time-for-spawn i j k) spawner
                    (call-with-sector sector i j k
                      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                        (define (find-spawning-places)
                          (let ((queue (new-queue)))
                            (loop (for a from (- i 4) to (+ i 4))
                                  (loop (for c from (- k 4) to (+ k 4))
                                        (loop (for b from (- j 1) to (+ j 1))
                                              (with-field a b c
                                                (lambda (section index)
                                                  (when (and section (= (block-ref section index) 0) (< (blocklight-ref section index) 8))
                                                    (bind (i j k) (index->coordinates index)
                                                      (call-with-sector (get-sector~ section) i j k
                                                        (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                                                          (enqueue queue (vertex x y z)))))))))))
                            (queue-list queue)))
                        
                        (let ((time-now (+ time-since-last elapse)))
                          (if (> time-now time-for-spawn)
                              (let ((possible-spawn-places (find-spawning-places)))
                                (loop (for number from 0 below (random-element '(2 3 4)))
                                      (unless (null? possible-spawn-places)
                                        (let ((position (random-element possible-spawn-places)))
                                          (set! possible-spawn-places (remove! position possible-spawn-places))
                                          (let ((enemy (new (random-element (list Spider Wolf Jumper)) parent: world position: position)))
                                            (add-element enemy)))))
                                (list-set! spawner 1 0.)
                                (list-set! spawner 2 (random-between 10. 40.)))
                            (list-set! spawner 1 time-now)))))))
                spawners)))
  
  
  ;;;
  ;;;; Model
  ;;;
  
  
  (method (minecraft-blocks)
    blocks)
  
  
  (method (minecraft-blockids)
    blockids)
  
  
  (method (minecraft-block-class)
    Minecraft-Block)
  
  
  (method (minecraft-find-model name)
    (find-minecraft-model name))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method override (evaluate-hook forms syntax str container line col)
    (let ((ids (collect (lambda (form)
                          (when (and (pair? form) (eq? (car form) 'define-minecraft-block))
                            (third form)))
                        forms)))
      (cond ((not-null? ids)
             (updating-sectors
               (lambda (add-sector)
                 (finding-visual-blocks ids
                   add-sector)
                 (finding-physical-blocks ids
                   (lambda (area)
                     (add-sector (area-sector area)))))))
            ((search container "world/external/minecraft")
             (updating-sectors
               (lambda (add-sector)
                 (add-sector (element-sector (current-me)))))))))
  
  
  (method (finding-visual-blocks ids proc)
    (let ((zone (current-zone))
          (count 0))
      (iterate-sectors~ zone
        (lambda (index sector)
          (when (sector-contains-blocks? sector ids)
            (proc sector))))))
  
  
  (method (sector-contains-blocks? sector ids)
    (continuation-capture
      (lambda (found)
        (sector-iterate-blocks sector ids
          (lambda (ignore)
            (continuation-return found #t)))
        #f)))
  
  
  (method (sector-iterate-blocks sector ids proc)
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region sector-x sector-y sector-z)))
          (when region
            (let ((section (get-section~ region sector-x sector-y sector-z)))
              (when section
                (let ((blocks (get-blocks~ section)))
                  (for-each (lambda (id)
                              (let (iter (pos 0))
                                (let ((found (u8vector-find id blocks (u8vector-length blocks) pos)))
                                  (when found
                                    (proc found)
                                    (iter (+ found 1))))))
                            ids)))))))))
  
  
  (method (finding-physical-blocks ids proc)
    (let ((zone (current-zone)))
      (iterate-areas~ zone
        (lambda (index area)
          (iterate-polygons~ area
            (lambda (elem polygons offset)
              (let ((data1 (f64vector-ref polygons (+ offset 16))))
                (when (and (/= data1 0.) (memq? (fxround data1) ids))
                  (proc area)))))))))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (proclaim (not warn optimizations))
  
  
  (method override (target-update target face face-rank poly vert)
    (define (count-chunks)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (when region
              (increase! count (table-length (get-chunks~ region))))))
        count))
    
    (define (count-sections)
      (let ((count 0))
        (iterate-table regions
          (lambda (index region)
            (when region
              (iterate-table (get-chunks~ region)
                (lambda (index chunk)
                  (when chunk
                    (increase! count (table-length (get-sections~ chunk)))))))))
        count))
    
    (define (center-info title center (poly #f))
      (let ((sector (position-sector center))
            (x (fxfloor (vertex-x center)))
            (y (fxfloor (vertex-y center)))
            (z (fxfloor (vertex-z center))))
        (let ((block (vector x y z))
              (sector-index (get-index~ sector)))
          (let ((sector-x (vector-ref sector-index 0))
                (sector-y (vector-ref sector-index 1))
                (sector-z (vector-ref sector-index 2)))
            (let ((region (sector-region sector-x sector-y sector-z)))
              (let ((section (get-section~ region sector-x sector-y sector-z))
                    (cache-uninitialized 65535))
                (when section
                  (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                        (sections <vector> (make-vector 27 #t))
                        (cache <u16vector> (initialize-block-cache cache-uninitialized))
                        (blocks (get-blocks~ section))
                        (data (get-data~ section))
                        (blocklight (get-blocklight~ section))
                        (skylight (get-skylight~ section)))
                    (define (section-ref a <fx> b <fx> c <fx>) <Minecraft-Section+>
                      (if (and (= a 0)
                               (= b 0)
                               (= c 0))
                          section
                        (let ((index (section-index a b c)))
                          (let ((section (vector-ref sections index)))
                            (if (neq? section #t)
                                section
                              (let ((x (+ sector-x a))
                                    (y (+ sector-y b))
                                    (z (+ sector-z c)))
                                (let ((region (sector-region x y z)))
                                  (let ((section (and region (get-section~ (cast <Minecraft-Region> region) x y z))))
                                    (vector-set! sections index section)
                                    section))))))))
                    
                    (define (section-index a <fx> b <fx> c <fx>) <fx>
                      (+ (* b 9) (* c 3) a 13))
                    
                    (define (local-index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (effective-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* j 324) (* k 18) i 343) 4))
                    
                    (define (blocks-get section <Minecraft-Section>) <u8vector>
                      (get-blocks~ section))
                    
                    (define (blocklight-get section <Minecraft-Section>) <u8vector>
                      (get-blocklight~ section))
                    
                    (define (blocklight-ref i <fx> j <fx> k <fx>)
                      (u4vector-ref blocklight (local-index i j k)))
                    
                    (define (skylight-ref i <fx> j <fx> k <fx>)
                      (u4vector-ref skylight (local-index i j k)))
                    
                    (define (local-block-ref i <fx> j <fx> k <fx>)
                      (u8vector-ref blocks (local-index i j k)))
                    
                    (define (local-data-ref i <fx> j <fx> k <fx>)
                      (u4vector-ref data (local-index i j k)))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (effective-light-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k blocklight-get u4vector-ref 0 0))
                    
                    (define (u4vector-ref field <u8vector> index <fx>) <fx>
                      (let ((byte (u8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (local-index i j k)))))))
                          
                          (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                ((> k 15) (bind-k 1 (- k 16)))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j -1 (+ 16 j)))
                              ((> j 15) (bind-j 1 (- j 16)))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i -1 (+ 16 i)))
                            ((> i 15) (bind-i 1 (- i 16)))
                            (else (bind-i 0 i))))
                    
                    (define (compute-lighting i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                      (format "{a} {a} {a} {a}"
                              (effective-light-ref (+ i ax) (+ j ay) (+ k az))
                              (effective-light-ref (+ i bx) (+ j by) (+ k bz))
                              (effective-light-ref (+ i cx) (+ j cy) (+ k cz))
                              (effective-light-ref (+ i dx) (+ j dy) (+ k dz))))
                    
                    (define (ambient-light i <fx> j <fx> k <fx> vert)
                      (let ((origin (vertex- (vertex-& vert (vertex& (cast <fl> x) (cast <fl> y) (cast <fl> z))) (vertex& .5 .5 .5)))
                            (normal (get-normal~ poly)))
                        (generic-lighting i j k origin normal compute-lighting)))
                    
                    (define (block-info i <fx> j <fx> k <fx>)
                      (let ((id (local-block-ref i j k))
                            (data (local-data-ref i j k))
                            (blocklight (blocklight-ref i j k))
                            (skylight (skylight-ref i j k)))
                        (let ((block (blockid->block id)))
                          (append (list (cons title (get-name~ block))
                                        (cons "id" id)
                                        (cons "data" data)
                                        (cons "block light" blocklight)
                                        (cons "sky light" skylight)
                                        (cons "sector" (format "{a} {a} {a}" sector-x sector-y sector-z))
                                        (cons "coord" (format "{a} {a} {a}" i j k)))
                                  (if poly
                                      (list (cons "block-id" (fxround (get-data1~ poly)))
                                            (cons "ambient1" (ambient-light i j k (get-v1~ poly)))
                                            (cons "ambient2" (ambient-light i j k (get-v2~ poly)))
                                            (cons "ambient3" (ambient-light i j k (get-v3~ poly)))
                                            (cons "ambient4" (ambient-light i j k (get-v4~ poly))))
                                    '())))))
                    
                    (let ((i (- x (* sector-x 16)))
                          (j (- y (* sector-y 16)))
                          (k (- z (* sector-z 16))))
                      (block-info i j k))))))))))
    
    (define (update-info)
      (register-info 'minecraft
        (lambda (add-section add-info)
          (define (count-regions)
            (let ((count 0))
              (iterate-table regions
                (lambda (index region)
                  (when region
                    (increase! count))))
              count))
          
          (with-regions-mutex
            (lambda ()
              (let ((section (add-section "Minecraft")))
                (add-info section "regions" (count-regions))
                (add-info section "chunks" (count-chunks))
                (add-info section "sections" (count-sections)))))))
      (if (not poly)
          (begin
            (unregister-info 'block)
            (unregister-info 'top))
        (let ((block (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly))))
          (let ((info (center-info "Block" block poly)))
            (register-info 'block
              (lambda (add-section add-info)
                (let ((section (add-section "Block")))
                  (for-each (lambda (info)
                              (add-info section (car info) (cdr info)))
                            info)))))
          (let ((top (vertex+ block (vertex 0. 1. 0.))))
            (let ((info (center-info "Top" top)))
              (if (not info)
                  (unregister-info 'top)
                (register-info 'top
                  (lambda (add-section add-info)
                    (let ((section (add-section "Top")))
                      (for-each (lambda (info)
                                  (add-info section (car info) (cdr info)))
                                info))))))))))
    
    (mutex-lock! generate-mutex)
    (update-info)
    (mutex-unlock! generate-mutex))
  
  
  (proclaim (warn optimizations))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (call-with-position pos <f64vector> proc)
    (let ((sector (position-sector pos))
          (x (fxfloor (vertex-x pos)))
          (y (fxfloor (vertex-y pos)))
          (z (fxfloor (vertex-z pos))))
      (let ((sector-index (get-index~ sector)))
        (let ((sector-x <fx> (vector-ref sector-index 0))
              (sector-y <fx> (vector-ref sector-index 1))
              (sector-z <fx> (vector-ref sector-index 2)))
          (let ((i (- x (* sector-x 16)))
                (j (- y (* sector-y 16)))
                (k (- z (* sector-z 16))))
            (call-with-sector sector i j k proc))))))
  
  
  (method (call-with-sector sector i j k proc)
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region sector-x sector-y sector-z)))
          (let ((region-x (get-x~ region))
                (region-z (get-z~ region))
                (section (get-section~ region sector-x sector-y sector-z))
                (chunk-index (chunk-index~ region sector-x sector-z)))
            (when section
              (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                    (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                    (section-y (* sector-y 16))
                    (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                    (sections <vector> (make-vector 27 #t))
                    (blocks (get-blocks~ section))
                    (data (get-data~ section))
                    (blocklight (get-blocklight~ section))
                    (skylight (get-skylight~ section)))
                (define (section-ref a <fx> b <fx> c <fx>) <Minecraft-Section+>
                  (if (and (= a 0)
                           (= b 0)
                           (= c 0))
                      section
                    (let ((index (section-index a b c)))
                      (let ((section (vector-ref sections index)))
                        (if (neq? section #t)
                            section
                          (let ((x (+ sector-x a))
                                (y (+ sector-y b))
                                (z (+ sector-z c)))
                            (let ((region (sector-region x y z)))
                              (let ((section (and region (get-section~ (cast <Minecraft-Region> region) x y z))))
                                (vector-set! sections index section)
                                section))))))))
                
                (define (section-index a <fx> b <fx> c <fx>) <fx>
                  (+ (* b 9) (* c 3) a 13))
                
                (define (local-index i <fx> j <fx> k <fx>) <fx>
                  (+ (* j 256) (* k 16) i))
                
                (define (block-ref section local-index <fx>) <fx>
                  (u8vector-ref (get-blocks~ section) local-index))
                
                (define (block-set! section local-index <fx> block-id <fx>)
                  (u8vector-set! (get-blocks~ section) local-index block-id))
                
                (define (data-ref section local-index <fx>) <fx>
                  (u4vector-ref (get-data~ section) local-index))
                
                (define (data-set! section local-index <fx> data-id <fx>)
                  (u4vector-set! (get-data~ section) local-index data-id))
                
                (define (blocklight-ref section local-index <fx>) <fx>
                  (u4vector-ref (get-blocklight~ section) local-index))
                
                (define (blocklight-set! section local-index <fx> blocklight <fx>)
                  (u4vector-set! (get-blocklight~ section) local-index blocklight))
                
                (define (skylight-ref section local-index <fx>) <fx>
                  (u4vector-ref (get-skylight~ section) local-index))
                
                (define (skylight-set! section local-index <fx> skylight <fx>)
                  (u4vector-set! (get-skylight~ section) local-index skylight))
                
                (define (powerlevel-ref section local-index <fx>) <fx>
                  (u8vector-ref (get-powerlevels~ section) local-index))
                
                (define (powerlevel-set! section local-index <fx> level <fx>)
                  (u8vector-set! (get-powerlevels~ section) local-index level))
                
                (define (u4vector-ref field <u8vector> index <fx>) <fx>
                  (let ((byte (u8vector-ref field (quotient index 2))))
                    (if (even? index)
                        (bitwise-and byte #x0F)
                      (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                
                (define (u4vector-set! field <u8vector> index <fx> value <fx>)
                  (let ((byte (u8vector-ref field (quotient index 2))))
                    (u8vector-set! field (quotient index 2)
                      (if (even? index)
                          (bitwise-ior value (bitwise-and byte #xF0))
                        (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4))))))
                
                (define (with-field i <fx> j <fx> k <fx> proc)
                  (define (bind-i a <fx> i <fx>)
                    (define (bind-j b <fx> j <fx>)
                      (define (bind-k c <fx> k <fx>)
                        (let ((section (section-ref a b c)))
                          (if (not section)
                              (proc #f (and bottom-section? (= b -1)))
                            (proc section (local-index i j k)))))
                      
                      (cond ((< k 0) (bind-k (- (quotient k 16) 1) (modulo k 16)))
                            ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                            (else (bind-k 0 k))))
                    
                    (cond ((< j 0) (bind-j (- (quotient j 16) 1) (modulo j 16)))
                          ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                          (else (bind-j 0 j))))
                  
                  (cond ((< i 0) (bind-i (- (quotient i 16) 1) (modulo i 16)))
                        ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                        (else (bind-i 0 i))))
                
                (let ((index (local-index i j k)))
                  (let ((block-id (block-ref section index))
                        (data-id (data-ref section index)))
                    (let ((x (+ section-x i))
                          (y (+ section-y j))
                          (z (+ section-z k))
                          (block (blockid->block block-id)))
                      (let ((x (fl& (+ block-radius (cast <fl> x))))
                            (y (fl& (+ block-radius (cast <fl> y))))
                            (z (fl& (+ block-radius (cast <fl> z))))
                            (uv (block-texture-coordinates block))
                            (rendering (cache-rendering~ block))
                            (generate (get-generate~ block)))
                        (proc region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!))))))))))))
  
  
  (method (updating-sectors proc)
    (define (update-sectors sectors)
      (for-each (lambda (sector)
                  (iterate-sector-areas sector
                                        (lambda (area)
                                          (clear-polygons~ area)))
                  (set-physical-uptodate?~ sector #f)
                  ;; no need to generate the physical explicitly
                  ;; (generate-sector sector 'physical)
                  (set-content-uptodate?~ sector #f)
                  (generate-sector sector 'render))
                sectors))
    
    (mutex-lock! generate-mutex)
    (let ((sectors '()))
      (define (add-sector sector)
        (unless (memq? sector sectors)
          (set! sectors (cons sector sectors))))
      
      (let ((timer (new Timer)))
        (proc add-sector)
        (update-sectors sectors)
        (mutex-unlock! generate-mutex)
        (when (world-setting 'minecraft.report-updating? #f)
          (let ((world (current-world)))
            (let ((count (length sectors)))
              (display-message~ world (format "Updated {a} sector{a} ({a}ms)" count (format-plural count) (real-duration-in-milliseconds~ timer)))))))))
  
  
  (method (index->coordinates index)
    (let ((i (modulo index 16))
          (k (modulo (quotient index 16) 16))
          (j (modulo (quotient (quotient index 16) 16) 16)))
      (list i j k))))


;;;
;;;; Add
;;;


(definition (make-minecraft-face rendering <Minecraft-Rendering> texture-coordinates texture-depth polygon l1 l2 l3 l4) <Minecraft-Face>
  (new Minecraft-Face (get-material~ rendering) texture-coordinates texture-depth polygon l1 l2 l3 l4))


(definition (make-minecraft-quad v1 v2 v3 v4 block-id <fx> x <fl> y <fl> z <fl>) <Quad>
  (let ((quad <Quad> (make-quad #f v1 v2 v3 v4)))
    (set-data1~ quad (cast <fl> block-id))
    (set-data2~ quad x)
    (set-data3~ quad y)
    (set-data4~ quad z)
    quad))


(definition (generic-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tt tl tb tr tb tr tt)))


;;90 degrees to the left
(definition (rotate-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tb tr tb tr tt tl tt)))


;;90 degrees to the right
(definition (rotate-inverse-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tl tt tl tb tr tb)))


(definition (rotate-other-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tb tr tt tl tt tl tb)))


(definition (transpose-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tr tb tl tb tl tt)))


(definition (generic-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <f64vector> v2 <f64vector> v3 <f64vector> v4 <f64vector> uv <f32vector> lighting rendering block-id)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv))
        (origin (vertex& x y z)))
    (let ((quad (make-minecraft-quad (vertex+ origin v1) (vertex+ origin v2) (vertex+ origin v3) (vertex+ origin v4) block-id x y z)))
      (let ((normal (get-normal~ quad)))
        (make-minecraft-face rendering
                             (f32vector tl tt tl tb tr tb tr tt)
                             texture-depth
                             quad
                             (generic-lighting i j k v1 normal lighting)
                             (generic-lighting i j k v2 normal lighting)
                             (generic-lighting i j k v3 normal lighting)
                             (generic-lighting i j k v4 normal lighting))))))


(definition (generic-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <f64vector> v2 <f64vector> v3 <f64vector> v4 <f64vector> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3))
        (v4 (matrix-transform-3x4 matrix v4)))
    (let ((quad (make-minecraft-quad (vertex+xyz v1 x y z)
                                     (vertex+xyz v2 x y z)
                                     (vertex+xyz v3 x y z)
                                     (vertex+xyz v4 x y z)
                                     block-id
                                     x
                                     y
                                     z)))
      (let ((normal (get-normal~ quad)))
        (make-minecraft-face rendering
                             (uv-coordinates uv)
                             (uv-depth uv)
                             quad
                             (generic-lighting i j k v1 normal lighting)
                             (generic-lighting i j k v2 normal lighting)
                             (generic-lighting i j k v3 normal lighting)
                             (generic-lighting i j k v4 normal lighting))))))


(definition (generic-transparent-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <f64vector> v2 <f64vector> v3 <f64vector> v4 <f64vector> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3))
        (v4 (matrix-transform-3x4 matrix v4)))
    (let ((quad (make-minecraft-quad (vertex+xyz v1 x y z)
                                     (vertex+xyz v2 x y z)
                                     (vertex+xyz v3 x y z)
                                     (vertex+xyz v4 x y z)
                                     block-id
                                     x
                                     y
                                     z)))
      (let ((normal (get-normal~ quad)))
        (let ((inverse (vertex-scalar*& normal -1.)))
          (define (average-lightings l1 <u8vector> l2 <u8vector>)
            (u8vector (quotient (+ (u8vector-ref l1 0) (u8vector-ref l2 0)) 2)
                      (quotient (+ (u8vector-ref l1 1) (u8vector-ref l2 1)) 2)
                      (quotient (+ (u8vector-ref l1 2) (u8vector-ref l2 2)) 2)))
          
          (make-minecraft-face rendering
                               (uv-coordinates uv)
                               (uv-depth uv)
                               quad
                               (average-lightings (generic-lighting i j k v1 normal lighting) (generic-lighting i j k v1 inverse lighting))
                               (average-lightings (generic-lighting i j k v2 normal lighting) (generic-lighting i j k v2 inverse lighting))
                               (average-lightings (generic-lighting i j k v3 normal lighting) (generic-lighting i j k v3 inverse lighting))
                               (average-lightings (generic-lighting i j k v4 normal lighting) (generic-lighting i j k v4 inverse lighting))))))))


(constant inline 1/SQRT2 <fl>
  (/ 1. (sqrt 2.)))

;; minimal value for door to clear itself
(constant inline ambient-forward <fl>
  .3)

;; minimal value for stair top to clear itself and fence to be uniform
(constant inline ambient-angled <fl>
  .9)


;; for debugging
(definition protected (get-ambient-forward/angled)
  (values ambient-forward ambient-angled))

;; for debugging
(definition protected (set-ambient-forward/angled forward angled)
  (set! ambient-forward forward)
  (set! ambient-angled angled))


(definition (generic-lighting i <fx> j <fx> k <fx> vert <f64vector> normal <f64vector> lighting)
  (if (u8vector? lighting)
      lighting
    ;; the .5 is because the shape is centered at 0 0 0
    (let ((adjusted (vertex+& (vertex+& vert (vertex& .5 .5 .5)) (vertex-scalar*& normal ambient-forward)))
          (r1 (make-vertex&))
          (r2 (make-vertex&))
          (r3 (make-vertex&))
          (r4 (make-vertex&)))
      (define (ambient-rays!)
        (let ((up (roll-free-up normal)))
          (let ((right (cross-product& normal up)))
            (let ((advance (vertex-scalar*& normal 1/SQRT2)))
              (let ((up/+2 (vertex-scalar/& up  2.))
                    (up/-2 (vertex-scalar/& up -2.))
                    (right/+2 (vertex-scalar/& right  2.))
                    (right/-2 (vertex-scalar/& right -2.)))
                (vertex+! r1 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/+2)) ambient-angled))
                (vertex+! r2 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/-2)) ambient-angled))
                (vertex+! r3 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/-2)) ambient-angled))
                (vertex+! r4 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/+2)) ambient-angled)))))))
      
      (ambient-rays!)
      (lighting i j k
        (fxfloor (vertex-x r1)) (fxfloor (vertex-y r1)) (fxfloor (vertex-z r1))
        (fxfloor (vertex-x r2)) (fxfloor (vertex-y r2)) (fxfloor (vertex-z r2))
        (fxfloor (vertex-x r3)) (fxfloor (vertex-y r3)) (fxfloor (vertex-z r3))
        (fxfloor (vertex-x r4)) (fxfloor (vertex-y r4)) (fxfloor (vertex-z r4))))))


(definition public (left-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (left-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (left-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-face rendering
                       (uv-coordinates uv)
                       (uv-depth uv)
                       (make-minecraft-quad (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front) block-id x y z)
                       (lighting i j k -1  0 -1 -1  0  0 -1  1 -1 -1  1  0)
                       (lighting i j k -1 -1 -1 -1 -1  0 -1  0 -1 -1  0  0)
                       (lighting i j k -1 -1  0 -1 -1  1 -1  0  0 -1  0  1)
                       (lighting i j k -1  0  0 -1  0  1 -1  1  0 -1  1  1)))


;; simple solution for shapes that don't work well with ambient vectors
(definition (uniform-lighting i <fx> j <fx> k <fx> lighting)
  (lighting i j k 0 0 1 0 0 -1 1 0 0 -1 0 0))


(definition public (x-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left top front)))
    (generic-transparent-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting rendering block-id matrix)))


(definition public (z-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex right top back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left top back)))
    (generic-transparent-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting rendering block-id matrix)))


(definition public (left-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left top front)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting rendering block-id matrix)))


(definition public (right-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (right-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (right-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-face rendering
                       (uv-coordinates uv)
                       (uv-depth uv)
                       (make-minecraft-quad (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back) block-id x y z)
                       (lighting i j k  1  0  0  1  0  1  1  1  0  1  1  1)
                       (lighting i j k  1 -1  0  1 -1  1  1  0  0  1  0  1)
                       (lighting i j k  1 -1 -1  1 -1  0  1  0 -1  1  0  0)
                       (lighting i j k  1  0 -1  1  0  0  1  1 -1  1  1  0)))


(definition public (right-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex right top front))
        (v2 (vertex right bottom front))
        (v3 (vertex right bottom back))
        (v4 (vertex right top back)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting rendering block-id matrix)))


(definition public (bottom-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (bottom-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-face rendering
                       (uv-coordinates uv)
                       (uv-depth uv)
                       (make-minecraft-quad (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front) block-id x y z)
                       (lighting i j k -1 -1  0 -1 -1  1  0 -1  0  0 -1  1)
                       (lighting i j k -1 -1 -1 -1 -1  0  0 -1 -1  0 -1  0)
                       (lighting i j k  0 -1 -1  0 -1  0  1 -1 -1  1 -1  0)
                       (lighting i j k  0 -1  0  0 -1  1  1 -1  0  1 -1  1)))


(definition public (bottom-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left bottom front))
        (v2 (vertex left bottom back))
        (v3 (vertex right bottom back))
        (v4 (vertex right bottom front)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting rendering block-id matrix)))


(definition public (top-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (top-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (top-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-face rendering
                       (uv-coordinates uv)
                       (uv-depth uv)
                       (make-minecraft-quad (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back) block-id x y z)
                       (lighting i j k -1  1 -1 -1  1  0  0  1 -1  0  1  0)
                       (lighting i j k -1  1  0 -1  1  1  0  1  0  0  1  1)
                       (lighting i j k  0  1  0  0  1  1  1  1  0  1  1  1)
                       (lighting i j k  0  1 -1  0  1  0  1  1 -1  1  1  0)))


(definition public (top-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left top front))
        (v3 (vertex right top front))
        (v4 (vertex right top back)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting rendering block-id matrix)))


(definition public (back-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (back-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (back-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-face rendering
                       (uv-coordinates uv)
                       (uv-depth uv)
                       (make-minecraft-quad (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back) block-id x y z)
                       (lighting i j k  0  0 -1  0  1 -1  1  0 -1  1  1 -1)
                       (lighting i j k  0 -1 -1  0  0 -1  1 -1 -1  1  0 -1)
                       (lighting i j k -1 -1 -1 -1  0 -1  0 -1 -1  0  0 -1)
                       (lighting i j k -1  0 -1 -1  1 -1  0  0 -1  0  1 -1)))


(definition public (back-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex right top back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left top back)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting rendering block-id matrix)))


(definition public (front-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (front-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (front-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-face rendering
                       (uv-coordinates uv)
                       (uv-depth uv)
                       (make-minecraft-quad (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front) block-id x y z)
                       (lighting i j k -1  0  1 -1  1  1  0  0  1  0  1  1)
                       (lighting i j k -1 -1  1 -1  0  1  0 -1  1  0  0  1)
                       (lighting i j k  0 -1  1  0  0  1  1 -1  1  1  0  1)
                       (lighting i j k  0  0  1  0  1  1  1  0  1  1  1  1)))


(definition public (front-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top front))
        (v2 (vertex left bottom front))
        (v3 (vertex right bottom front))
        (v4 (vertex right top front)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting rendering block-id matrix)))


(definition (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face)
  (add-face (left-generic   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering)
  (add-face (right-generic  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering)
  (add-face (bottom-generic i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering)
  (add-face (top-generic    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering)
  (add-face (back-generic   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering)
  (add-face (front-generic  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering))


(definition public (add-cube-faces i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)))


(definition public (add-cross-faces i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius)))
        (tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv))
        (lighting (uniform-lighting i j k lighting)))
    (add-face (make-minecraft-face rendering
                                   (f32vector tl tt tl tb tr tb tr tt)
                                   texture-depth
                                   (make-minecraft-quad (vertex right top back) (vertex right bottom back) (vertex left bottom front) (vertex left top front) block-id x y z)
                                   lighting lighting lighting lighting)
              rendering)
    (add-face (make-minecraft-face rendering
                                   (f32vector tl tt tl tb tr tb tr tt)
                                   texture-depth
                                   (make-minecraft-quad (vertex right top front) (vertex right bottom front) (vertex left bottom back) (vertex left top back) block-id x y z)
                                   lighting lighting lighting lighting)
              rendering)))


(definition (add-torch block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref top-texture bottom-texture)
  (define (position-torch proc)
    (let ((margin .32))
      (ecase data-id
        ((1) (proc (- margin) 0.))
        ((2) (proc margin 0.))
        ((3) (proc 0. (- margin)))
        ((4) (proc 0. margin))
        (else (proc 0. 0.)))))
  
  (position-torch
    (lambda (dx dz)
      (let ((margin 1m)
            (left (- x block-radius))
            (right (+ x block-radius))
            (bottom (- y block-radius))
            (top (+ y block-radius))
            (back (- z block-radius))
            (front (+ z block-radius))
            (top-uv (get-coordinates top-texture))
            (bottom-uv (get-coordinates bottom-texture)))
        (add-face (top-face    i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) top-uv generic-coordinates lighting rendering block-id) rendering)
        (add-face (bottom-face i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) bottom-uv generic-coordinates lighting rendering block-id) rendering)
        (add-face (left-face   i j k x y z (+ dx (- x margin)) (+ dx right) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id) rendering)
        (add-face (right-face  i j k x y z (+ dx left) (+ dx (+ x margin)) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id) rendering)
        (add-face (back-face   i j k x y z (+ dx left) (+ dx right) bottom top (+ dz (- z margin)) (+ dz front) uv generic-coordinates lighting rendering block-id) rendering)
        (add-face (front-face  i j k x y z (+ dx left) (+ dx right) bottom top (+ dz back) (+ dz (+ z margin)) uv generic-coordinates lighting rendering block-id) rendering)))))


(definition (add-button block-id data-id i j k x y z uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref)
  (define (position-button proc)
    (let ((orientation (bitwise-and data-id #b111))
          (active? (bit-set? 3 data-id))
          (margin 3m)
          (thick 2m)
          (thin 1m))
      (ecase orientation
        ((0) (proc (- x margin) (+ x margin) (- y block-radius) (+ (- y block-radius) thick) (- z thick) (+ z thick)))
        ((1) (proc (- x block-radius) (+ (- x block-radius) thick) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((2) (proc (- (+ x block-radius) thick) (+ x block-radius) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((3) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- z block-radius) (+ (- z block-radius) thick)))
        ((4) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- (+ z block-radius) thick) (+ z block-radius)))
        ((5) (proc (- x margin) (+ x margin) (- (+ y block-radius) thick) (+ y block-radius) (- z thick) (+ z thick))))))
  
  (position-button
    (lambda (left right bottom top back front)
      (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
      (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
      (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
      (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
      (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
      (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering))))


(definition block-models
  (make-table))

(definition (cache-block-models filename)
  (or (table-ref block-models filename #f)
      (begin
        (set-current-directory {Directory Yownu-World "assets" "minecraft" "models"})
        (if (file-exists? filename)
            (let ((models (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "models"} filename))))
              (unless (table-ref models "parent" #f)
                (table-set! block-models filename models))
              models)
          (let ((models (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "models" "minecraft"} filename))))
            (unless (table-ref models "parent" #f)
              (table-set! block-models filename models))
            models)))))


(definition (add-json-model filename block-id data-id i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering add-face add-opaque-cube add-texture-element block-ref data-ref y-rotation x-rotation)
  (define (read-json-model proc)
    (let ((models (cache-block-models filename)))
      (let ((has-parent? (table-ref models "parent" #f)))
        (let ((textures (table-ref models "textures")))
          (when has-parent?
            (set! models (cache-block-models (string-append (string-trailer has-parent? #\/) ".json")))
            (iterate-table (table-ref models "textures")
              (lambda (key value)
                (unless (table-ref textures key #f)
                  (table-set! textures key value)))))
          (let ((elements (table-ref models "elements")))
            (iterate-table-safe textures
                                (lambda (key value)
                                  (table-set! textures key (string-trailer value #\/))))
            (proc elements textures))))))
  
  (read-json-model
    (lambda (elements textures) (let ((matrix (matrix-multiply (make-y-rotation-matrix (degree->radian (cast <fl> y-rotation)))
                                                               (make-x-rotation-matrix (degree->radian (cast <fl> x-rotation))))))
        (for-each
          (lambda (element)
            (define (get-file-texture face-name)
              (let ((face (table-ref (table-ref element "faces") face-name #f)))
                (when face
                  (let ((texture (get-coordinates (table-ref textures (string-trailer (table-ref face "texture") #\#)))))
                    (bind (l t r b) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref face "uv"))
                      (uv-rect texture l t r b))))))
            
            (define (get-texture-rotation face-name)
              (let ((face (table-ref (table-ref element "faces") face-name #f)))
                (when face
                  (let ((rot (or (table-ref face "rotation" #f) 0)))
                    (case rot
                      ((0)   generic-coordinates)
                      ((90)  rotate-inverse-coordinates)
                      ((180) rotate-other-coordinates)
                      ((270) rotate-coordinates))))))
            
            (define (get-element-matrix)
              (let ((rotation (table-ref element "rotation" #f)))
                (if rotation
                    (bind (x y z) (map (lambda (r) (/ (cast <fl> r) 16.)) (table-ref rotation "origin"))
                      (let ((origin (vertex (- .5 x) (- .5 y) (- .5 z)))
                            (rotation-matrix (case (string->symbol (table-ref rotation "axis"))
                                               ((x) (make-x-rotation-matrix (degree->radian (cast <fl> (table-ref rotation "angle")))))
                                               ((y) (make-y-rotation-matrix (- (degree->radian (cast <fl> (table-ref rotation "angle"))))))
                                               ((z) (make-z-rotation-matrix (degree->radian (cast <fl> (table-ref rotation "angle"))))))))
                        (matrix-multiply (make-translation-matrix (vertex-negate origin))
                                         (matrix-multiply rotation-matrix (make-translation-matrix origin)))))
                  (make-identity-matrix))))
            
            (bind (a b c) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref element "from"))
              (bind (d e f) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref element "to"))
                (unless (and (= a d) (= b e) (= c f))
                  (let ((left (- a .5))
                        (right (- d .5))
                        (bottom (- b .5))
                        (top (- e .5))
                        (back (- c .5))
                        (front (- f .5))
                        (left-uv (get-file-texture "west"))
                        (right-uv (get-file-texture "east"))
                        (bottom-uv (get-file-texture "down"))
                        (top-uv (get-file-texture "up"))
                        (back-uv (get-file-texture "north"))
                        (front-uv (get-file-texture "south"))
                        (left-rotation (get-texture-rotation "west"))
                        (right-rotation (get-texture-rotation "east"))
                        (bottom-rotation (get-texture-rotation "down"))
                        (top-rotation (get-texture-rotation "up"))
                        (back-rotation (get-texture-rotation "north"))
                        (front-rotation (get-texture-rotation "south"))
                        (matrix (matrix-multiply matrix (get-element-matrix))))
                    (when left-uv   (add-face (left-generic   i j k x y z left right bottom top back front left-uv left-rotation lighting rendering block-id matrix) rendering))
                    (when right-uv  (add-face (right-generic  i j k x y z left right bottom top back front right-uv right-rotation lighting rendering block-id matrix) rendering))
                    (when bottom-uv (add-face (bottom-generic i j k x y z left right bottom top back front bottom-uv bottom-rotation lighting rendering block-id matrix) rendering))
                    (when top-uv    (add-face (top-generic    i j k x y z left right bottom top back front top-uv top-rotation lighting rendering block-id matrix) rendering))
                    (when back-uv   (add-face (back-generic   i j k x y z left right bottom top back front back-uv back-rotation lighting rendering block-id matrix) rendering))
                    (when front-uv  (add-face (front-generic  i j k x y z left right bottom top back front front-uv front-rotation lighting rendering block-id matrix) rendering)))))))
          elements)))))


(definition (add-stairs data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering block-id add-face)
  (let ((matrix (make-lookat-matrix& (horizon-lookat& (case (bitwise-and data-id #b11)
                                                        ((3) (vertex&  0. 0. -1.))
                                                        ((2) (vertex&  0. 0.  1.))
                                                        ((1) (vertex& -1. 0.  0.))
                                                        ((0) (vertex&  1. 0.  0.)))))))
    ;; bottom
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom (fl& (- block-radius)))
          (top 0.)
          (back (fl& (- block-radius)))
          (front (fl& (+ block-radius))))
      (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face))
    ;; top
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom 0.)
          (top (fl& (+ block-radius)))
          (back 0.)
          (front (fl& (+ block-radius))))
      (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face))))


(definition (add-fence data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering block-id add-face block-ref connects)
  (let ((matrix (make-lookat-matrix& (horizon-lookat& (vertex&  0. 0.  1.)))))
    (define (connect? block-id <fx>)
      (memv? block-id connects))
    
    (define (add-trunk)
      (let ((left (- .1))
            (right (+ .1))
            (bottom (- block-radius))
            (top (+ block-radius))
            (back (- .1))
            (front (+ .1)))
        (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face)))
    
    (define (add-branches left <fl> right <fl> back <fl> front <fl>)
      ;; upper
      (let ((bottom (- .35 .075))
            (top (+ .35 .075)))
        (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face))
      ;; lower
      (let ((bottom (- .075))
            (top (+ .075)))
        (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering block-id matrix add-face)))
    
    ;; trunk
    (add-trunk)
    ;; left
    (when (connect? (block-ref (- i 1) j k))
      (add-branches (- block-radius) -.1 (- .075) (+ .075)))
    ;; right
    (when (connect? (block-ref (+ i 1) j k))
      (add-branches .1 (+ block-radius) (- .075) (+ .075)))
    ;; back
    (when (connect? (block-ref i j (- k 1)))
      (add-branches (- .075) (+ .075) (- block-radius) -.1))
    ;; front
    (when (connect? (block-ref i j (+ k 1)))
      (add-branches (- .075) (+ .075) .1 (+ block-radius)))))


(definition (add-slab i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv side-uv lighting rendering block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top y)
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (right-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (back-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)
    (add-face (front-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering)))


(definition (add-sloped i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering block-id add-face horizon)
  (let ((left (fl& (- block-radius)))
        (right (fl& (+ block-radius)))
        (bottom (fl& (- block-radius)))
        (top (fl& (+ block-radius)))
        (back (fl& (- block-radius)))
        (front (fl& (+ block-radius))))
    (let ((v1 (vertex left top back))
          (v2 (vertex left bottom front))
          (v3 (vertex right bottom front))
          (v4 (vertex right top back))
          (matrix (make-lookat-matrix& (horizon-lookat& horizon))))
      (add-face (generic-face i j k x y z v1 v2 v3 v4 uv generic-coordinates lighting rendering block-id matrix) rendering))))


(definition (add-rail data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering block-id add-face)
  (case data-id
    ((0) (add-bottom i j k x y z uv generic-coordinates lighting rendering block-id add-face))
    ((1) (add-bottom i j k x y z uv rotate-coordinates lighting rendering block-id add-face))
    ((2) (add-sloped i j k x y z uv lighting rendering block-id add-face (vertex& -1. 0.  0.)))
    ((3) (add-sloped i j k x y z uv lighting rendering block-id add-face (vertex&  1. 0.  0.)))
    ((4) (add-sloped i j k x y z uv lighting rendering block-id add-face (vertex&  0. 0.  1.)))
    ((5) (add-sloped i j k x y z uv lighting rendering block-id add-face (vertex&  0. 0. -1.)))
    ((6) (add-bottom i j k x y z (get-coordinates "rail_normal_turned") generic-coordinates lighting rendering block-id add-face))
    ((7) (add-bottom i j k x y z (get-coordinates "rail_normal_turned") rotate-coordinates lighting rendering block-id add-face))
    ((8) (add-bottom i j k x y z (get-coordinates "rail_normal_turned") rotate-other-coordinates lighting rendering block-id add-face))
    ((9) (add-bottom i j k x y z (get-coordinates "rail_normal_turned") rotate-inverse-coordinates lighting rendering block-id add-face))))


(definition (add-rail-gadget data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-powered lighting rendering block-id add-face)
  (let ((powered? (bit-set? 3 data-id)))
    (let ((uv (if powered? uv-powered uv)))
      (case (bitwise-and data-id #b111)
        ((0) (add-bottom i j k x y z uv generic-coordinates lighting rendering block-id add-face))
        ((1) (add-bottom i j k x y z uv rotate-coordinates lighting rendering block-id add-face))
        ((2) (add-sloped i j k x y z uv lighting rendering block-id add-face (vertex& -1. 0.  0.)))
        ((3) (add-sloped i j k x y z uv lighting rendering block-id add-face (vertex&  1. 0.  0.)))
        ((4) (add-sloped i j k x y z uv lighting rendering block-id add-face (vertex&  0. 0.  1.)))
        ((5) (add-sloped i j k x y z uv lighting rendering block-id add-face (vertex&  0. 0. -1.)))))))


(definition add-epsilon <fl>
  .01)


(definition (add-left i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (right-face i j k x y z left (+ left add-epsilon) bottom top back front uv uv-coordinates lighting rendering block-id) rendering)))


(definition (add-right i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face i j k x y z (- right add-epsilon) right bottom top back front uv uv-coordinates lighting rendering block-id) rendering)))


(definition (add-bottom i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (top-face i j k x y z left right bottom (+ bottom add-epsilon) back front uv uv-coordinates lighting rendering block-id) rendering)))


(definition (add-top i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (bottom-face i j k x y z left right (- top add-epsilon) top back front uv uv-coordinates lighting rendering block-id) rendering)))


(definition (add-back i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (front-face i j k x y z left right bottom top back (+ back add-epsilon) uv uv-coordinates lighting rendering block-id) rendering)))


(definition (add-front i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (back-face i j k x y z left right bottom top (- front add-epsilon) front uv uv-coordinates lighting rendering block-id) rendering)))


(definition (add-transparent data-id left right back front i j k x <fl> y <fl> z <fl> uv lighting rendering block-id add-face)
  (ecase data-id
    ((left)  (add-left  i j k x y z uv generic-coordinates lighting rendering block-id add-face))
    ((right) (add-right i j k x y z uv generic-coordinates lighting rendering block-id add-face))
    ((back)  (add-back  i j k x y z uv generic-coordinates lighting rendering block-id add-face))
    (else    (add-front i j k x y z uv generic-coordinates lighting rendering block-id add-face))))


;;;
;;;; World
;;;


(class Minecraft-World extends World))
