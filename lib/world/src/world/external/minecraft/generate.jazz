;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Minecraft Generate
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Édouard Hébert


(module protected world.external.minecraft.generate jazz


(import (jazz.action)
        (jazz.application)
        (jazz.cairo)
        (jazz.debuggee)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.json)
        (jazz.opengl.glew)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (world)
        (world.area)
        (world.atlas)
        (world.audio)
        (world.autoload)
        (world.chunk)
        (world.configure)
        (world.dye)
        (world.enemy)
        (world.entity)
        (world.external.minecraft.autoload)
        (world.external.minecraft.syntax (phase syntax))
        (world.external.nbt)
        (world.face)
        (world.foreign)
        (world.game)
        (world.generate)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.info)
        (world.interface.inventory)
        (world.light-syntax)
        (world.lighting)
        (world.material)
        (world.mesh)
        (world.model)
        (world.models)
        (world.profiling)
        (world.quad)
        (world.quad-texture)
        (world.region)
        (world.render)
        (world.renderers)
        (world.section)
        (world.sector)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.texture)
        (world.triangle))


;; LEXICON
;; - index: sector-local i j k coordinates
;; - location: integer vector representing a block in the block entities format
;; - position: block center position


;; WARNING
;; - the temporary hack of duplicating non thread-safe geometry functions
;;   like horizon-lookat&^ is super dangerous and should be improved upon


(proclaim (warn optimizations))


(definition protected aa 0) ;; 10421010
(definition protected oo 0) ;; 12248627
(definition protected gg 0) ;; 745240
(definition protected ww 0) ;; 697473
(definition protected cc 0) ;; 54050


;;;
;;;; Atlas
;;;


(definition (cache-atlas) <Atlas>
  (let ((world (current-world)))
    (get-block-atlas~ world)))


(definition (cache-texture) <Image-Texture>
  (let ((world (current-world)))
    (get-block-texture~ world)))


(definition (cache-texture-repeat) <Image-Texture>
  (let ((world (current-world)))
    (get-block-texture-repeat~ world)))


(definition (create-minecraft-atlas) <Atlas>
  (define (find-minecraft-assets)
    (let ((world (current-world)))
      (find-if (lambda (assets)
                 (and (eq? (get-where~ assets) 'world)
                      (equal? (get-spine~ assets) '("minecraft"))))
               (get-world-assets~ world))))
  
  (let ((atlas (new Atlas))
        (assets (find-minecraft-assets))
        (path (list "textures" texture-dir)))
    (add-assets-directory~ atlas assets path)
    (generate-textures atlas assets path)
    atlas))


(definition (create-minecraft-texture atlas (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f)) <Image-Texture>
  (let ((mipmap? (world-setting 'minecraft.generate-mipmap? 32))
        (min-filter (world-setting 'minecraft.min-filter (or min-filter 'nearest)))
        (mag-filter (world-setting 'minecraft.mag-filter (or mag-filter 'linear))))
    (let ((effective-mipmap? (if (integer? mipmap?) (>= tile-resolution (cast <fx> mipmap?)) mipmap?)))
      (let ((min-filter (if (not effective-mipmap?)
                            (case min-filter
                              ((nearest) GL_NEAREST)
                              ((linear) GL_LINEAR))
                          (case min-filter
                            ((nearest) GL_NEAREST_MIPMAP_LINEAR)
                            ((linear) GL_LINEAR_MIPMAP_LINEAR))))
            (mag-filter (case mag-filter
                          ((nearest) GL_NEAREST)
                          ((linear) GL_LINEAR))))
        (extract-texture~ atlas min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: effective-mipmap? warn-non-uniform?: (programmer-role?))))))


;;;
;;;; Textures
;;;


(definition textures-subuvs
  '())

(definition (add-textures-subuv name subuv)
  (set! textures-subuvs (cons (cons name subuv) textures-subuvs)))

(definition (update-textures-subuvs atlas)
  (for-each (lambda (info)
              (bind (name . subuv) info
                (update-coordinates~ atlas name subuv)))
            textures-subuvs)
  (set! textures-subuvs '()))


(definition (generate-textures atlas assets path)
  (let ((dir (make-directory~ assets (append path '("blocks")))))
    (define (add-colored base suffix color (overlay #f))
      (let ((gray (new-file~ dir (add-extension (or overlay base) "png")))
            (overlaid (and overlay (new-file~ dir (add-extension base "png"))))
            (name (format "{a}_{a}" base suffix)))
        (assert (exists?~ gray))
        (apply-operator CAIRO_OPERATOR_MULTIPLY gray color
          (lambda (surface width height)
            (if (not overlay)
                (add-surface~ atlas name surface width height)
              (receive (width height overlaid) (cairo-surface-from-png overlaid)
                (let ((overlaid (new Surface overlaid)))
                  (blit-surface~ overlaid surface)
                  (close~ surface)
                  (add-surface~ atlas name overlaid width height))))))))

    (define (apply-operator operator gray color proc)
      (receive (width height msk) (cairo-surface-from-png gray)
        (receive (width height dst) (cairo-surface-from-png gray)
          (let ((size (new Dimension width height))
                (mask (new Surface msk))
                (dest (new Surface dst)))
            (set-operator~ dest operator)
            (set-color~ dest color)
            (draw-rectangle~ dest (size-rect size))
            (set-mask-surface~ dest mask)
            (close~ mask)
            (proc dest width height)))))
    
    (define (redstone-dust base)
      (let ((off .35)
            (on 1.))
        (loop (for n from 0 to 15)
              (add-colored base (->string n) (new Color red: (+ off (* (- on off) (/ (cast <fl> n) 15.))))))))
    
    (define (mirror-pad name left top right bottom (save-to #f))
      (bind (surface width height depth) (get-image~ atlas name)
        (let ((cairo-surface
                (when (u8vector? surface)
                  (let ((cairo-format CAIRO_FORMAT_ARGB32))
                    (let ((stride (cairo_format_stride_for_width cairo-format width)))
                      (new Surface (cairo_image_surface_create_for_data (still-u8vector-body surface) CAIRO_FORMAT_ARGB32 width height stride)))))))
          (let ((surface (or cairo-surface surface))
                (l (* left width))
                (t (* top height))
                (r (* right width))
                (b (* bottom height)))
            (let ((w (- r l))
                  (h (- b t)))
              (let ((subimage (new Image-Surface surface (new Dimension (fxround w) (fxround h))))
                    (pattern (cairo_pattern_create_for_surface (get-handle~ surface))))
                (let ((surface (if (not save-to) surface (new Image-Surface surface (new Dimension width height)))))
                  (let ((cr (get-context~ subimage))
                        (matrix (cairo_matrix_t-make)))
                    (cairo_set_source cr pattern)
                    (cairo_matrix_init_translate matrix l t)
                    (cairo_pattern_set_matrix pattern matrix)
                    (cairo_rectangle cr 0. 0. (fl w) (fl h))
                    (cairo_fill cr)
                    (cairo_matrix_t-free matrix)
                    (cairo_pattern_destroy pattern)
                    (loop (for i from -1 to 1)
                          (loop (for j from -1 to 1)
                                (let ((sx (if (= i 0) 1 -1))
                                      (sy (if (= j 0) 1 -1)))
                                  (let ((l (if (= sx 1) l (+ l w)))
                                        (t (if (= sy 1) t (+ t h))))
                                    (let ((tx (+ l (* i w)))
                                          (ty (+ t (* j h))))
                                      (cairo_identity_matrix (get-context~ surface))
                                      (translate~ surface tx ty)
                                      (scale~ surface sx sy)
                                      (blit-surface~ surface subimage))))))
                    (close~ subimage)
                    (when cairo-surface
                      (close~ cairo-surface))
                    (if (not save-to)
                        (add-textures-subuv name (uv left top right bottom (cast <fl> depth)))
                      (add-surface~ atlas save-to surface width height)
                      (bind (surface width height depth) (get-image~ atlas save-to)
                        (add-textures-subuv save-to (uv left top right bottom (cast <fl> depth)))))))))))))
    
    (add-colored "tallgrass" "green" {Color red: .403 green: .577 blue: .336})
    (add-colored "leaves_birch" "green" {Color red: .403 green: .577 blue: .336})
    (add-colored "melon_stem_disconnected" "ochre" {Color red: .747 green: .563 blue: .004})
    (add-colored "pumpkin_stem_disconnected" "ochre" {Color red: .747 green: .563 blue: .004})
    (add-colored "vine" "green" {Color red: .160 green: .619 blue: .160})
    (add-colored "waterlily" "green" {Color red: .003 green: .619 blue: .003})
    (add-colored "grass_top" "green" {Color red: .403 green: .577 blue: .336})
    (add-colored "grass_side" "green" {Color red: .403 green: .577 blue: .336} "grass_side_overlay")
    
    (redstone-dust "redstone_dust_cross")
    (redstone-dust "redstone_dust_line")
    
    (mirror-pad "cake_side"             1m 8m 15m 16m)
    (mirror-pad "cake_top"              1m 1m 15m 15m)
    (mirror-pad "cake_bottom"           1m 1m 15m 15m)
    (mirror-pad "chest_side"            1m 2m 15m 16m)
    (mirror-pad "chest_front"           1m 2m 15m 16m)
    (mirror-pad "chest_back"            1m 2m 15m 16m)
    (mirror-pad "chest_bottom"          1m 1m 15m 15m)
    (mirror-pad "chest_top"             1m 1m 15m 15m)
    (mirror-pad "bed_head_side"         0m 7m 16m 16m)
    (mirror-pad "bed_head_end"          0m 7m 16m 16m)
    (mirror-pad "bed_feet_side"         0m 7m 16m 16m)
    (mirror-pad "bed_feet_end"          0m 7m 16m 16m)
    (mirror-pad "enchanting_table_side" 0m 4m 16m 16m)
    (mirror-pad "endframe_side"         0m 3m 16m 16m)
    (mirror-pad "endframe_eye"          4m 0m 12m 4m "endframe_eye_side")
    (mirror-pad "endframe_eye"          4m 4m 12m 12m)))


;;;
;;;; Face
;;;


(class Minecraft-Face extends Face
  
  
  (method protected virtual (iterate-lighting proc)
    ))


(class Minecraft-Triangle-Face extends Minecraft-Face
  
  
  (slot l1 accessors generate)
  (slot l2 accessors generate)
  (slot l3 accessors generate)
  
  
  (method override (initialize material texture-coordinates <f32vector> texture-depth triangle <Triangle> l1 <f32vector> l2 <f32vector> l3 <f32vector>)
    (nextmethod material texture-coordinates texture-depth triangle)
    (set! l1~self l1)
    (set! l2~self l2)
    (set! l3~self l3))
  
  
  (method override (iterate-lighting proc)
    (proc l1 l2 l3)))


(class Minecraft-Quad-Face extends Minecraft-Face
  
  
  (slot l1 accessors generate)
  (slot l2 accessors generate)
  (slot l3 accessors generate)
  (slot l4 accessors generate)
  (slot inverse? getter generate)
  
  
  (method override (initialize material texture-coordinates <f32vector> texture-depth quad <Quad> l1 <f32vector> l2 <f32vector> l3 <f32vector> l4 <f32vector>)
    (let ((a00 (max (f32vector-ref l1 0) (f32vector-ref l1 1)))
          (a01 (max (f32vector-ref l2 0) (f32vector-ref l2 1)))
          (a11 (max (f32vector-ref l3 0) (f32vector-ref l3 1)))
          (a10 (max (f32vector-ref l4 0) (f32vector-ref l4 1))))
      ;; inversing the quad solves lighting anisotropy
      (set! inverse? (< (+ a00 a11) (+ a01 a10)))
      (set-inverse?~ quad inverse?)
      (nextmethod material texture-coordinates texture-depth quad)
      (set! l1~self l1)
      (set! l2~self l2)
      (set! l3~self l3)
      (set! l4~self l4)))
  
  
  (method override (iterate-lighting proc)
    (cond ((not inverse?)
           (proc l1 l2 l3)
           (proc l3 l4 l1))
          (else
           (proc l4 l1 l2)
           (proc l2 l3 l4)))))


;;;
;;;; Mesher
;;;


(class Minecraft-Mesher extends Mesher
  
  
  (method (add-lighting face <Minecraft-Face>)
    (define (blocklight! offset <fx> lighting <f32vector>) <void>
      (f32vector-set! lightmap offset (f32vector-ref lighting 0)))
    
    (define (skylight! offset <fx> lighting <f32vector>) <void>
      (f32vector-set! lightmap offset (f32vector-ref lighting 1)))
    
    (define (ambience! offset <fx> lighting <f32vector>) <void>
      (f32vector-set! lightmap offset (/ (f32vector-ref lighting 2) 4.)))
    
    (iterate-lighting~ face
      (lambda (l1 l2 l3)
        (blocklight!    k    l1)
        (skylight!   (+ k 1) l1)
        (ambience!   (+ k 2) l1)
        (blocklight! (+ k 3) l2)
        (skylight!   (+ k 4) l2)
        (ambience!   (+ k 5) l2)
        (blocklight! (+ k 6) l3)
        (skylight!   (+ k 7) l3)
        (ambience!   (+ k 8) l3)
        (increase! k 9))))
  
  
  (method (add-full-lighting face <Minecraft-Face>)
    (define (blocklight! offset <fx>) <void>
      (f32vector-set! lightmap offset 60.))
    
    (define (skylight! offset <fx>) <void>
      (f32vector-set! lightmap offset 60.))
    
    (define (ambience! offset <fx>) <void>
      (f32vector-set! lightmap offset 15.))
    
    (iterate-lighting~ face
      (lambda (l1 l2 l3)
        (blocklight!    k)
        (skylight!   (+ k 1))
        (ambience!   (+ k 2))
        (blocklight! (+ k 3))
        (skylight!   (+ k 4))
        (ambience!   (+ k 5))
        (blocklight! (+ k 6))
        (skylight!   (+ k 7))
        (ambience!   (+ k 8))
        (increase! k 9)))))


;;;
;;;; Rendering
;;;


(class Minecraft-Rendering extends Object
  
  
  (slot material <Material> getter generate)
  (slot mesher   <Mesher>   getter generate)
  
  
  (method override (initialize initial-reserved material)
    (set! material~self material)
    (set! mesher~self (new Minecraft-Mesher initial-reserved 0 material: material)))
  
  
  (method (reset-mesher)
    (reset~ mesher)))


(definition package opaque-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Minecraft-Rendering 8192 (new Material name: 'opaque atlas: atlas texture: texture renderer: (get-opaque-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package transparent-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Minecraft-Rendering 20480 (new Material name: 'transparent atlas: atlas texture: texture renderer: (get-transparent-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package coverage-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Minecraft-Rendering 2048 (new Material name: 'coverage atlas: atlas texture: texture renderer: (get-coverage-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package water-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture-repeat)))
            (let ((rend (new Minecraft-Rendering 2048 (new Material name: 'water atlas: atlas texture: texture renderer: (get-water-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package wet-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Minecraft-Rendering 2048 (new Material name: 'wet atlas: atlas texture: texture renderer: (get-wet-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package multitexture-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture-repeat)))
            (let ((rend (new Minecraft-Rendering 2048 (new Material name: 'multitexture atlas: atlas texture: texture renderer: (get-multitexture-renderer)))))
              (set! rendering rend)
              rend))))))


(definition inline cake-category
  'cake)

(definition inline redstone-category
  'redstone)


(definition package category-renderings
  (make-table test: eq?))

(definition (get-category-rendering category)
  (or (table-ref category-renderings category #f)
      (let ((atlas (cache-atlas))
            (texture (cache-texture)))
        (let ((rend (new Minecraft-Rendering 20480 (new Material name: category atlas: atlas texture: texture renderer: (get-transparent-renderer)))))
          (table-set! category-renderings category rend)
          rend))))

(definition (reset-category-renderings)
  (iterate-table category-renderings
    (lambda (category rendering)
      (reset-mesher~ rendering))))


(definition package (dr)
  (define (d rendering <Minecraft-Rendering>)
    (let ((mesher (get-mesher~ rendering)))
      (list (get-growths~ mesher) (get-reserved~ mesher))))

  (debug (d (opaque-rendering))
         (d (transparent-rendering))
         (d (coverage-rendering))
         (d (water-rendering))
         (d (wet-rendering))
         (d (multitexture-rendering))))


;;;
;;;; Block
;;;


(class Minecraft-Block-Model extends Object
  
  
  (slot name                       getter generate)
  (slot id                  <fx>   getter generate)
  (slot subid                      getter generate)
  (slot category                   getter generate)
  (slot image                      getter generate)
  (slot texture                    getter generate)
  (slot texture-coordinates        accessors generate)
  (slot rendering                  getter generate)
  (slot rendering-cache            getter generate)
  (slot opaque-cube?        <bool> getter generate)
  (slot water-cube?         <bool> getter generate)
  (slot physical?           <bool> getter generate)
  (slot cube?               <bool> accessors generate)
  (slot brightness                 getter generate)
  (slot generate                   getter generate)
  (slot right-mouse                getter generate)
  
  
  (method override (initialize name id subid category image texture rendering opaque-cube? water-cube? physical? cube? brightness generate right-mouse)
    (set! name~self name)
    (set! id~self id)
    (set! subid~self subid)
    (set! category~self category)
    (set! image~self image)
    (set! texture~self texture)
    (set! texture-coordinates~self #f)
    (set! rendering~self (or rendering opaque-rendering))
    (set! rendering-cache~self #f)
    (set! opaque-cube?~self opaque-cube?)
    (set! water-cube?~self water-cube?)
    (set! physical?~self physical?)
    (set! cube?~self cube?)
    (set! brightness~self brightness)
    (set! generate~self generate)
    (set! right-mouse~self right-mouse))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method (cache-rendering)
    (or rendering-cache
        (let ((rend (rendering)))
          (set! rendering-cache rend)
          rend))))


(definition blocks <table>
  (make-table test: eq?))

(definition blockids <vector>
  (make-vector 256 #f))


(definition (register-minecraft-block name id (category: category #f) (image: image #f) (texture: texture #f) (rendering: rendering #f) (opaque-cube?: opaque-cube? #t) (water-cube?: water-cube? #f) (physical?: physical? #t) (cube?: cube? #t) (brightness: brightness #f) (generate: generate #f) (right-mouse: right-mouse #f))
  (let ((id <fx> (if (pair? id) (car id) id))
        (subid (if (pair? id) (cadr id) #f)))
    (when (not subid)
      (let ((block (new Minecraft-Block-Model name id subid category image texture rendering opaque-cube? water-cube? physical? cube? brightness generate right-mouse)))
        (table-set! blocks name block)
        (vector-set! blockids id block)
        (unspecified)))))


(definition public (name->block name) <Minecraft-Block-Model>
  (table-ref blocks name))

(definition public inline (blockid->block id <fx>) <Minecraft-Block-Model>
  (vector-ref blockids id))


(definition protected tile-resolution <fx>
  (world-setting 'minecraft.tile-resolution 128))

(definition protected tile-size <fl>
  (cast <fl> tile-resolution))

(definition protected tile-period <fx>
  16)

(definition protected texture-size <fl>
  (* tile-size (cast <fl> tile-period)))

(definition protected texture-dir
  (format "{a}x{a}" tile-resolution tile-resolution))

(definition protected texture-mipmap?
  #f)


(definition (block-texture-coordinates block <Minecraft-Block-Model>)
  (or (get-texture-coordinates~ block)
      (let ((texture (get-texture~ block)))
        (let ((coords (and texture (image-rect~ (cache-atlas) texture))))
          (set-texture-coordinates~ block coords)
          coords))))


(definition coordinates-mutex
  (make-mutex 'coordinates))

(definition coordinates <table>
  (make-table test: equal?))

(definition (get-coordinates name <string>) <f32vector>
  (mutex-lock! coordinates-mutex)
  (prog1 (or (table-ref coordinates name #f)
             (let ((coords (image-rect~ (cache-atlas) name)))
               (table-set! coordinates name coords)
               coords))
    (mutex-unlock! coordinates-mutex)))


;;;
;;;; Blocks
;;;


(definition use-models?
  (world-setting 'minecraft.use-models? #t))


(constant inline block-radius <fl>
  .5)


(constant inline air-id <fx>
  0)


(constant inline mixel
  .0625)

(constant inline  0m 0.)
(constant inline  1m .0625)
(constant inline  2m .125)
(constant inline  3m .1875)
(constant inline  4m .25)
(constant inline  5m .3125)
(constant inline  6m .375)
(constant inline  7m .4375)
(constant inline  8m .5)
(constant inline  9m .5625)
(constant inline 10m .625)
(constant inline 11m .6875)
(constant inline 12m .75)
(constant inline 13m .8125)
(constant inline 14m .875)
(constant inline 15m .9375)
(constant inline 16m 1.)


(define-minecraft-block Air
  0
  opaque-cube?: #f
  cube?: #f)


(define-minecraft-block Stone
  1
  texture: "stone")


(define-minecraft-block Grass
  2
  texture: "grass_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              ;; this is so much nicer than the grass in the texture pack
              (let ((side (get-coordinates "grass_side"))
                    (top (get-coordinates "wool_colored_green"))
                    (bottom (get-coordinates "dirt")))
                (add-opaque-cube i j k x y z side side bottom top side side lighting rendering category block-id add-face))))


(define-minecraft-block Dirt
  3
  texture: "dirt")


(define-minecraft-block Cobblestone
  4
  texture: "cobblestone")


(define-minecraft-block WoodenPlank
  5
  texture: "planks_oak")


(definition Sapling-Textures <vector>
  #("sapling_oak"
    "sapling_spruce"
    "sapling_birch"
    "sapling_jungle"))


(define-minecraft-block Sapling
  6
  texture: "sapling_jungle"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Sapling-Textures (bitwise-and data-id #b11)))))
                (add-cross-faces i j k x y z uv lighting rendering category block-id add-face))))

(define-minecraft-block RedwoodSapling
  (6 1))

(define-minecraft-block BirchSapling
  (6 2))


(define-minecraft-block Bedrock
  7
  texture: "bedrock")


(definition (water-side-heights i j k block-ref data-ref (blocks '(8 9)))
  (define (side-data side-i side-k)
    (data-ref (+ i side-i) j (+ k side-k)))
  
  (define (data->height data)
    (if (< data 8)
        (- (* 2m (- 8 data)) 1m)
      16m))
  
  (define (corner-height side-i side-k data)
    (if (= data 0)
        7m
      (let ((block1 (block-ref (+ i side-i) j k))
            (block2 (block-ref i j (+ k side-k)))
            (block3 (block-ref (+ i side-i) j (+ k side-k)))
            (data1 (side-data side-i 0))
            (data2 (side-data 0 side-k))
            (data3 (side-data side-i side-k)))
        (let ((height1 (if (memq? block1 blocks)
                           (if (or (< data1 data) (> data1 7))
                               (data->height data1)
                             (data->height data))
                         1m))
              (height2 (if (memq? block2 blocks)
                           (if (or (< data2 data) (> data2 7))
                               (data->height data2)
                             (data->height data))
                         1m))
              (height3 (if (memq? block3 blocks)
                           (if (or (< data3 data) (> data3 7))
                               (data->height data3)
                             (data->height data))
                         1m)))
          (+ (- block-radius) (max height1 height2 height3))))))
  
  (let ((data (data-ref i j k)))
    (if (> data 7)
        (f64vector 8m 8m 8m 8m)
      (let ((left-back   (corner-height -1 -1 data))
            (left-front  (corner-height -1  1 data))
            (right-front (corner-height  1  1 data))
            (right-back  (corner-height  1 -1 data))
            @w(direction #f))
        (f64vector left-back left-front right-front right-back)))))


(definition (lava-side-heights i j k block-ref data-ref)
  (water-side-heights i j k block-ref data-ref '(10 11)))


(define-minecraft-block Water
  8
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  rendering: water-rendering
  texture: "water"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (water-side-heights i j k block-ref data-ref))
                    (left (- block-radius))
                    (right block-radius)
                    (bottom (if (memq? (block-ref i (- j 1) k) '(8 9)) (- (- block-radius) 1m) (- block-radius)))
                    (back (- block-radius))
                    (front block-radius))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref (- i 1) j k))) (not (memq? (block-ref (- i 1) j k) '(20)))) (memq? (block-ref (- i 1) j k) '(8 9))))
                  (add-face (left-generic-quad   i j k x y z left right bottom (f64vector (first top) (second top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref (+ i 1) j k))) (not (memq? (block-ref (+ i 1) j k) '(20)))) (memq? (block-ref (+ i 1) j k) '(8 9))))
                  (add-face (right-generic-quad  i j k x y z left right bottom (f64vector (third top) (fourth top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i (- j 1) k))) (not (memq? (block-ref i (- j 1) k) '(20)))) (memq? (block-ref i (- j 1) k) '(8 9))))
                  (add-face (bottom-generic i j k x y z left right bottom (first top) back front uv generic-coordinates lighting rendering block-id (make-identity-matrix)) rendering category))
                (unless (memq? (block-ref i (+ j 1) k) '(8 9 20))
                  (let ((face (top-sloped   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))
                    (add-face (car face) rendering category)
                    (when (not (equal? (first face) (last face)))
                      (add-face (last face) rendering category))))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i j (- k 1)))) (not (memq? (block-ref i j (- k 1)) '(20)))) (memq? (block-ref i j (- k 1)) '(8 9))))
                  (add-face (back-generic-quad   i j k x y z left right bottom (f64vector (fourth top) (first top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i j (+ k 1)))) (not (memq? (block-ref i j (+ k 1)) '(20)))) (memq? (block-ref i j (+ k 1)) '(8 9))))
                  (add-face (front-generic-quad  i j k x y z left right bottom (f64vector (second top) (third top)) back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-minecraft-block StationaryWater
  9
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  rendering: water-rendering
  texture: "water"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (water-side-heights i j k block-ref data-ref))
                    (left (- block-radius))
                    (right block-radius)
                    (bottom (if (memq? (block-ref i (- j 1) k) '(8 9)) (- (- block-radius) 1m) (- block-radius)))
                    (back (- block-radius))
                    (front block-radius))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref (- i 1) j k))) (not (memq? (block-ref (- i 1) j k) '(20)))) (memq? (block-ref (- i 1) j k) '(8 9))))
                  (add-face (left-generic-quad   i j k x y z left right bottom (f64vector (first top) (second top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref (+ i 1) j k))) (not (memq? (block-ref (+ i 1) j k) '(20)))) (memq? (block-ref (+ i 1) j k) '(8 9))))
                  (add-face (right-generic-quad  i j k x y z left right bottom (f64vector (third top) (fourth top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i (- j 1) k))) (not (memq? (block-ref i (- j 1) k) '(20)))) (memq? (block-ref i (- j 1) k) '(8 9))))
                  (add-face (bottom-generic i j k x y z left right bottom (first top) back front uv generic-coordinates lighting rendering block-id (make-identity-matrix)) rendering category))
                (unless (memq? (block-ref i (+ j 1) k) '(8 9 20))
                  (let ((face (top-sloped   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))
                    (add-face (car face) rendering category)
                    (when (not (equal? (first face) (last face)))
                      (add-face (last face) rendering category))))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i j (- k 1)))) (not (memq? (block-ref i j (- k 1)) '(20)))) (memq? (block-ref i j (- k 1)) '(8 9))))
                  (add-face (back-generic-quad   i j k x y z left right bottom (f64vector (fourth top) (first top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i j (+ k 1)))) (not (memq? (block-ref i j (+ k 1)) '(20)))) (memq? (block-ref i j (+ k 1)) '(8 9))))
                  (add-face (front-generic-quad  i j k x y z left right bottom (f64vector (second top) (third top)) back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-minecraft-block Lava
  10
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  rendering: multitexture-rendering
  texture: "lava"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (lava-side-heights i j k block-ref data-ref))
                    (left (- block-radius))
                    (right block-radius)
                    (bottom (if (memq? (block-ref i (- j 1) k) '(10 11)) (- (- block-radius) 1m) (- block-radius)))
                    (back (- block-radius))
                    (front block-radius))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref (- i 1) j k))) (not (memq? (block-ref (- i 1) j k) '(20)))) (memq? (block-ref (- i 1) j k) '(10 11))))
                  (add-face (left-generic-quad   i j k x y z left right bottom (f64vector (first top) (second top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref (+ i 1) j k))) (not (memq? (block-ref (+ i 1) j k) '(20)))) (memq? (block-ref (+ i 1) j k) '(10 11))))
                  (add-face (right-generic-quad  i j k x y z left right bottom (f64vector (third top) (fourth top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i (- j 1) k))) (not (memq? (block-ref i (- j 1) k) '(20)))) (memq? (block-ref i (- j 1) k) '(10 11))))
                  (add-face (bottom-generic i j k x y z left right bottom (first top) back front uv generic-coordinates lighting rendering block-id (make-identity-matrix)) rendering category))
                (unless (memq? (block-ref i (+ j 1) k) '(10 11 20))
                  (let ((face (top-sloped   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))
                    (add-face (car face) rendering category)
                    (when (not (equal? (first face) (last face)))
                      (add-face (last face) rendering category))))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i j (- k 1)))) (not (memq? (block-ref i j (- k 1)) '(20)))) (memq? (block-ref i j (- k 1)) '(10 11))))
                  (add-face (back-generic-quad   i j k x y z left right bottom (f64vector (fourth top) (first top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i j (+ k 1)))) (not (memq? (block-ref i j (+ k 1)) '(20)))) (memq? (block-ref i j (+ k 1)) '(10 11))))
                  (add-face (front-generic-quad  i j k x y z left right bottom (f64vector (second top) (third top)) back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-minecraft-block StationaryLava
  11
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  rendering: multitexture-rendering
  texture: "lava"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (lava-side-heights i j k block-ref data-ref))
                    (left (- block-radius))
                    (right block-radius)
                    (bottom (if (memq? (block-ref i (- j 1) k) '(10 11)) (- (- block-radius) 1m) (- block-radius)))
                    (back (- block-radius))
                    (front block-radius))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref (- i 1) j k))) (not (memq? (block-ref (- i 1) j k) '(20)))) (memq? (block-ref (- i 1) j k) '(10 11))))
                  (add-face (left-generic-quad   i j k x y z left right bottom (f64vector (first top) (second top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref (+ i 1) j k))) (not (memq? (block-ref (+ i 1) j k) '(20)))) (memq? (block-ref (+ i 1) j k) '(10 11))))
                  (add-face (right-generic-quad  i j k x y z left right bottom (f64vector (third top) (fourth top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i (- j 1) k))) (not (memq? (block-ref i (- j 1) k) '(20)))) (memq? (block-ref i (- j 1) k) '(10 11))))
                  (add-face (bottom-generic i j k x y z left right bottom (first top) back front uv generic-coordinates lighting rendering block-id (make-identity-matrix)) rendering category))
                (unless (memq? (block-ref i (+ j 1) k) '(10 11 20))
                  (let ((face (top-sloped   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))
                    (add-face (car face) rendering category)
                    (when (not (equal? (first face) (last face)))
                      (add-face (last face) rendering category))))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i j (- k 1)))) (not (memq? (block-ref i j (- k 1)) '(20)))) (memq? (block-ref i j (- k 1)) '(10 11))))
                  (add-face (back-generic-quad   i j k x y z left right bottom (f64vector (fourth top) (first top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (blockid->block (block-ref i j (+ k 1)))) (not (memq? (block-ref i j (+ k 1)) '(20)))) (memq? (block-ref i j (+ k 1)) '(10 11))))
                  (add-face (front-generic-quad  i j k x y z left right bottom (f64vector (second top) (third top)) back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-minecraft-block Sand
  12
  texture: "sand")


(define-minecraft-block Gravel
  13
  texture: "gravel")


(define-minecraft-block GoldOre
  14
  texture: "gold_ore")


(define-minecraft-block IronOre
  15
  texture: "iron_ore")


(define-minecraft-block CoalOre
  16
  texture: "coal_ore")


(definition Wood-Textures <vector>
  #("log_oak"
    "log_spruce"
    "log_birch"
    "log_jungle"))

(definition WoodTop-Textures <vector>
  #("log_oak_top"
    "log_spruce"
    "log_birch"
    "log_jungle"))
  
(define-minecraft-block Wood
  17
  texture: "planks_jungle"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wood-Textures (bitwise-and data-id #b11))))
                    (uv-top (get-coordinates (vector-ref WoodTop-Textures (bitwise-and data-id #b11)))))
                (add-opaque-cube i j k x y z uv uv uv-top uv-top uv uv lighting rendering category block-id add-face))))

(define-minecraft-block Redwood
  (17 1))

(define-minecraft-block Birchwood
  (17 2))


(define-minecraft-block Leaves
  18
  image: "leaves_birch"
  texture: "leaves_birch_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering category block-id add-face)))

(define-minecraft-block RedwoodLeaves
  (18 1))

(define-minecraft-block BirchwoodLeaves
  (18 2))


(define-minecraft-block Sponge
  19
  texture: "sponge")


(define-minecraft-block Glass
  20
  texture: "glass"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block LapisOre
  21
  texture: "lapis_ore")


(define-minecraft-block LapisBlock
  22
  texture: "lapis_block")


(define-minecraft-block Dispenser
  23
  category: redstone-category
  texture: "dispenser_front_vertical"
  opaque-cube?: #f)


(define-minecraft-block Sandstone
  24
  texture: "sandstone_top")


(define-minecraft-block NoteBlock
  25
  category: redstone-category
  texture: "noteblock"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block BedBlock
  26
  texture: "bed_feet_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case (bitwise-and data-id #b11)
                                                                     ((0) (vertex&  0. 0.  1.))
                                                                     ((1) (vertex& -1. 0.  0.))
                                                                     ((2) (vertex&  0. 0. -1.))
                                                                     ((3) (vertex&  1. 0.  0.))))))
                    (head? (bit-set? 3 data-id))
                    (left (- block-radius))
                    (right (+ block-radius))
                    (bottom (- block-radius))
                    (top 1m)
                    (back (- block-radius))
                    (front (+ block-radius))
                    (bedbottom (+ (- block-radius) 3m))
                    (bedtop (- 9m block-radius)))
                (if head?
                    (let ((uv-top (get-coordinates "bed_head_top"))
                          (uv-side (get-coordinates "bed_head_side"))
                          (uv-end (get-coordinates "bed_head_end"))
                          (uv-bottom (get-coordinates "planks_oak")))
                      (add-face (left-generic   i j k x y z left right bottom top back front uv-side generic-coordinates lighting rendering block-id matrix) rendering category)
                      (add-face (right-generic  i j k x y z left right bottom top back front uv-side transpose-coordinates lighting rendering block-id matrix) rendering category)
                      (add-face (bottom-generic i j k x y z left right bedbottom top back front uv-bottom generic-coordinates lighting rendering block-id matrix) rendering category)
                      (add-face (top-generic    i j k x y z left right bottom bedtop back front uv-top rotate-coordinates lighting rendering block-id matrix) rendering category)
                      (add-face (front-generic  i j k x y z left right bottom top back front uv-end generic-coordinates lighting rendering block-id matrix) rendering category))
                  (let ((uv-top (get-coordinates "bed_feet_top"))
                        (uv-side (get-coordinates "bed_feet_side"))
                        (uv-end (get-coordinates "bed_feet_end"))
                        (uv-bottom (get-coordinates "planks_oak")))
                    (add-face (left-generic   i j k x y z left right bottom top back front uv-side generic-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (right-generic  i j k x y z left right bottom top back front uv-side transpose-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (bottom-generic i j k x y z left right bedbottom top back front uv-bottom generic-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (top-generic    i j k x y z left right bottom bedtop back front uv-top rotate-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (back-generic   i j k x y z left right bottom top back front uv-end generic-coordinates lighting rendering block-id matrix) rendering category)))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (let ((world (current-world))
                       (me (current-me)))
                   ;; we cannot spawn on top of the bed because some beds have too low a ceiling over them
                   (set-spawn-point~ me (copy-vertex (get-position~ me)))
                   (when (or (> (get-daytime~ (current-zone)) 18500.) (< (get-daytime~ (current-zone)) 6000.))
                     (goto-daytime~ (current-zone) 6000.))
                   (display-message~ world "Bedpoint set!"))))


(define-minecraft-block PoweredRail
  27
  texture: "rail_activator"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-rail-gadget data-id i j k x y z uv (get-coordinates "rail_activator_powered") lighting rendering category block-id add-face)))


(define-minecraft-block DetectorRail
  28
  category: redstone-category
  texture: "rail_detector"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-rail-gadget data-id i j k x y z uv (get-coordinates "rail_detector_powered") lighting rendering category block-id add-face)))


(define-minecraft-block StickyPiston
  29
  category: redstone-category
  texture: "piston_side"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((matrix (case (bit-set data-id 3 #f)
                              ((0) (make-x-rotation-matrix PI))
                              ((1) (make-identity-matrix))
                              ((2) (make-x-rotation-matrix PI/2))
                              ((3) (make-x-rotation-matrix (- PI/2)))
                              ((4) (make-z-rotation-matrix (- PI/2)))
                              ((5) (make-z-rotation-matrix PI/2)))))
                (let ((left (- block-radius))
                      (right block-radius)
                      (bottom (- block-radius))
                      (top (if (bit-set? 3 data-id)
                               4m
                             block-radius))
                      (back (- block-radius))
                      (front block-radius)
                      (side-uv (if (bit-set? 3 data-id)
                              (uv-rect uv 0. 4m 1. 1.)
                                 uv))
                      (top-uv (if (bit-set? 3 data-id)
                                  (get-coordinates "piston_inner")
                                (get-coordinates "piston_top_sticky")))
                      (bottom-uv (get-coordinates "piston_bottom")))
                  (add-face (left-generic   i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (right-generic  i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (bottom-generic i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (top-generic    i j k x y z left right bottom top back front top-uv    generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (back-generic   i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (front-generic  i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)))))


(define-minecraft-block Web
  30
  texture: "web"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-minecraft-block TallGrass
  31
  image: "tallgrass"
  texture: "tallgrass_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-minecraft-block DeadBush
  32
  texture: "deadbush"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-minecraft-block Piston
  33
  category: redstone-category
  texture: "piston_side"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((matrix (case (bit-set data-id 3 #f)
                              ((0) (make-x-rotation-matrix PI))
                              ((1) (make-identity-matrix))
                              ((2) (make-x-rotation-matrix PI/2))
                              ((3) (make-x-rotation-matrix (- PI/2)))
                              ((4) (make-z-rotation-matrix (- PI/2)))
                              ((5) (make-z-rotation-matrix PI/2)))))
                (let ((left (- block-radius))
                      (right block-radius)
                      (bottom (- block-radius))
                      (top (if (bit-set? 3 data-id)
                               4m
                             block-radius))
                      (back (- block-radius))
                      (front block-radius)
                      (side-uv (if (bit-set? 3 data-id)
                              (uv-rect uv 0. 4m 1. 1.)
                                 uv))
                      (top-uv (if (bit-set? 3 data-id)
                                  (get-coordinates "piston_inner")
                                (get-coordinates "piston_top_normal")))
                      (bottom-uv (get-coordinates "piston_bottom")))
                  (add-face (left-generic   i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (right-generic  i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (bottom-generic i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (top-generic    i j k x y z left right bottom top back front top-uv    generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (back-generic   i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (front-generic  i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)))))


(define-minecraft-block PistonHead
  34
  texture: "piston_inner"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((matrix (case (bit-set data-id 3 #f)
                              ((0) (make-x-rotation-matrix PI))
                              ((1) (make-identity-matrix))
                              ((2) (make-x-rotation-matrix PI/2))
                              ((3) (make-x-rotation-matrix (- PI/2)))
                              ((4) (make-z-rotation-matrix (- PI/2)))
                              ((5) (make-z-rotation-matrix PI/2)))))
                (let ((left (- block-radius))
                      (right block-radius)
                      (bottom 4m)
                      (top block-radius)
                      (back (- block-radius))
                      (front block-radius)
                      (side-uv (uv-rect (get-coordinates "piston_side") 0. 0. 1. 4m))
                      (top-uv (if (bit-set? 3 data-id)
                                  (get-coordinates "piston_top_sticky")
                                (get-coordinates "piston_top_normal")))
                      (stick-top 4m)
                      (stick-bottom (- 12m))
                      (margin 2m))
                  (add-face (left-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (right-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (bottom-generic i j k x y z left right bottom top back front uv      generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (top-generic    i j k x y z left right bottom top back front top-uv  generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (back-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (front-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (left-generic   i j k x y z (- margin) margin stick-bottom stick-top (- margin) margin side-uv rotate-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (right-generic  i j k x y z (- margin) margin stick-bottom stick-top (- margin) margin side-uv rotate-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (back-generic   i j k x y z (- margin) margin stick-bottom stick-top (- margin) margin side-uv rotate-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (front-generic  i j k x y z (- margin) margin stick-bottom stick-top (- margin) margin side-uv rotate-coordinates lighting rendering block-id matrix) rendering category)))))


(definition Wool-Textures <vector>
  #("wool_colored_white"
    "wool_colored_orange"
    "wool_colored_magenta"
    "wool_colored_light_blue"
    "wool_colored_yellow"
    "wool_colored_lime"
    "wool_colored_pink"
    "wool_colored_gray"
    "wool_colored_silver"
    "wool_colored_cyan"
    "wool_colored_purple"
    "wool_colored_blue"
    "wool_colored_brown"
    "wool_colored_green"
    "wool_colored_red"
    "wool_colored_black"))

(define-minecraft-block Wool
  35
  texture: "wool_colored_white"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wool-Textures data-id))))
                (add-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering category block-id add-face))))


(define-minecraft-block Dandelion
  37
  texture: "flower_dandelion"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-minecraft-block Rose
  38
  texture: "flower_rose"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-minecraft-block BrownMushroom
  39
  texture: "mushroom_brown"
  rendering: transparent-rendering
  physical?: #f
  cube?: #f
  opaque-cube?: #f)


(define-minecraft-block RedMushroom
  40
  texture: "mushroom_red"
  rendering: transparent-rendering
  physical?: #f
  cube?: #f
  opaque-cube?: #f)


(define-minecraft-block GoldBlock
  41
  texture: "gold_block")


(define-minecraft-block IronBlock
  42
  texture: "iron_block")


(define-minecraft-block DoubleStoneSlab
  43
  texture: "stone_slab_top")

(define-minecraft-block DoubleSandstoneSlab
  (43 1))

(define-minecraft-block DoubleWoodenSlab
  (43 2))

(define-minecraft-block DoubleCobblestoneSlab
  (43 3))

(define-minecraft-block DoubleBrickSlab
  (43 4))

(define-minecraft-block DoubleStoneBrickSlab
  (43 5))


(definition Slab-Textures <vector>
  #("stone_slab_top"
    "sandstone_top"
    "planks_oak"
    "cobblestone"
    "brick"
    "stonebrick"))

(define-minecraft-block StoneSlab
  44
  texture: "stone_slab_top"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Slab-Textures (modulo data-id 6)))))
                (if (< data-id 6)
                    (add-slab i j k x y z uv (uv-rect uv 0. .5 1. 1.) lighting rendering category block-id add-face)
                  (add-slab i j k x (+ y block-radius) z uv (uv-rect uv 0. 0. 1. .5) lighting rendering category block-id add-face)))))

(define-minecraft-block SandstoneSlab
  (44 1))

(define-minecraft-block WoodenSlab
  (44 2))

(define-minecraft-block CobblestoneSlab
  (44 3))

(define-minecraft-block BrickSlab
  (44 4))

(define-minecraft-block StoneBrickSlab
  (44 5))


(define-minecraft-block Brick
  45
  texture: "brick")


(define-minecraft-block TNT
  46
  category: redstone-category
  texture: "tnt_side"
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "tnt_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-minecraft-block Bookshelf
  47
  texture: "bookshelf"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "planks_jungle")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-minecraft-block MossyCobblestone
  48
  texture: "cobblestone_mossy")


(define-minecraft-block Obsidian
  49
  texture: "obsidian")


(define-minecraft-block Torch
  50
  texture: "torch_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  brightness: 14
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (if (or (= data-id 0) ;; for showcase
                          (= data-id 5))
                      (add-json-model "torch.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref 0. 0.)
                    (let ((rot (case data-id
                                 ((1) 180.)
                                 ((2) 0.)
                                 ((3) 270.)
                                 ((4) 90.))))
                      (add-json-model "torch_wall.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref rot 0.)))
                (add-torch block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref "pumpkin_face_on" "planks_spruce"))))


(define-minecraft-block Fire
  51
  texture: "furnace_front_on"
  brightness: 15
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-minecraft-block MonsterSpawner
  52
  texture: "mob_spawner"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block WoodenStairs
  53
  texture: "planks_oak"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block Chest
  54
  texture: "chest_top"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (- x 7m))
                    (right (+ x 7m))
                    (bottom (- y block-radius))
                    (top (+ y 7m))
                    (back (- z 7m))
                    (front (+ z 7m)))
                (let ((side-uv (get-coordinates "chest_side"))
                      (front-uv (get-coordinates "chest_front"))
                      (back-uv (get-coordinates "chest_back"))
                      (bottom-uv (get-coordinates "chest_bottom"))
                      (top-uv uv))
                  (add-face (left-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   i j k x y z left right bottom top back front back-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  i j k x y z left right bottom top back front front-uv generic-coordinates lighting rendering block-id) rendering category))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (with-field i j k
                   (lambda (section index)
                     (updating-sectors~ (current-zone)
                       (lambda (add-sector)
                         (add-sector (get-sector~ section))
                         (let ((world (current-world))
                               (zone (current-zone))
                               (index (get-index~ sector)))
                           (let ((chest (list index i j k))
                                 (data (block-entity-data region sector i j k)))
                             (cond ((not (get-opened-chest~ zone))
                                    (play-sound-file "sound/random/chestopen" volume: .5)
                                    (show-chest~ world section data)
                                    (show-bag~ world blocks?: #f)
                                    (set-opened-chest~ zone chest))
                                   ((equal? chest (get-opened-chest~ zone))
                                    (play-sound-file "sound/random/chestclosed" volume: .5)
                                    (hide-chest~ world)
                                    (hide-bag~ world)
                                    (set-opened-chest~ zone #f))
                                   (else
                                    (play-sound-file "sound/random/chestopen" volume: .5)
                                    (hide-chest~ world)
                                    (show-chest~ world section data)
                                    (hide-bag~ world)
                                    (show-bag~ world blocks?: #f)
                                    (set-opened-chest~ zone chest)))))))))))


(definition RedstoneDustLine-Textures <vector>
  #("redstone_dust_line_0"
    "redstone_dust_line_1"
    "redstone_dust_line_2"
    "redstone_dust_line_3"
    "redstone_dust_line_4"
    "redstone_dust_line_5"
    "redstone_dust_line_6"
    "redstone_dust_line_7"
    "redstone_dust_line_8"
    "redstone_dust_line_9"
    "redstone_dust_line_10"
    "redstone_dust_line_11"
    "redstone_dust_line_12"
    "redstone_dust_line_13"
    "redstone_dust_line_14"
    "redstone_dust_line_15"))

(define-minecraft-block RedstoneWire
  55
  category: redstone-category
  texture: "redstone_dust_line"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref RedstoneDustLine-Textures data-id))))
                (add-bottom i j k x y z uv generic-coordinates lighting rendering category block-id add-face)))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (with-field i j k
                   (lambda (section index)
                     (powerlevel-ref section index)))))


(define-minecraft-block DiamondOre
  56
  texture: "diamond_ore")


(define-minecraft-block DiamondBlock
  57
  texture: "diamond_block")


(define-minecraft-block Workbench
  58
  texture: "log_oak")


(define-minecraft-block WheatCrops
  59
  texture: "wheat_stage_7"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-minecraft-block Soil
  60
  texture: "dirt"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-opaque-cube i j k x y z uv uv uv (get-coordinates "farmland_dry") uv uv lighting rendering category block-id add-face)))


(define-minecraft-block Furnace
  61
  texture: "furnace_side")


(define-minecraft-block BurningFurnace
  62
  texture: "furnace_front_on"
  brightness: 13)


(class Sign-Element extends Element
  
  (property quad <Quad> initialize #f accessors generate)
  (property data        initialize #f accessors generate)
  
  (slot quad-texture <Quad-Texture+> initialize #f)
  
  (method override (destroy)
    (nextmethod)
    (when quad-texture
      (close~ quad-texture)))
  
  (method override (element-radiuses)
    (vertex 1. 1. 1.))
  
  
  (method override (lens-center)
    (quad-center (get-v1~ quad)
                 (get-v2~ quad)
                 (get-v3~ quad)
                 (get-v4~ quad)))
  
  (method (sign-quad-texture)
    (let ((quad-texture <Quad-Texture> (make-quad-texture 100 50 (get-v1~ quad) (get-v2~ quad) (get-v3~ quad) (get-v4~ quad))))
      (let ((texture (get-texture~ quad-texture)))
        (let ((surface (get-surface~ texture))
              (font {Font font-name: tahoma point-size: 11 antialias: none})
              (color {Color Black})
              (width (get-width~ texture)))
          (define (draw-line v text)
            (let ((text (effective-sign-text text)))
              (let ((w (get-text-width~ surface text)))
                (let ((h (fxceiling (/ (cast <fl> (- width w)) 2.))))
                  (draw-text~ surface h v text color)))))
          
          (clear~ surface)
          (set-font~ surface font)
          (draw-line 0 (tag-assoc "Text1" data))
          (draw-line 12 (tag-assoc "Text2" data))
          (draw-line 24 (tag-assoc "Text3" data))
          (draw-line 36 (tag-assoc "Text4" data))
          (map-texture~ texture)))
      quad-texture))
  
  (method override (draw)
    (when (not quad-texture)
      (set! quad-texture (sign-quad-texture)))
    (allege quad-texture
      (render-texture~ quad-texture))))


(definition (contains-text? data)
  (or (not (equal? (tag-assoc "Text1" data) ""))
      (not (equal? (tag-assoc "Text2" data) ""))
      (not (equal? (tag-assoc "Text3" data) ""))
      (not (equal? (tag-assoc "Text4" data) ""))))


(definition (make-sign-element position v1 v2 v3 v4 matrix data)
  (let ((v1 (vertex+ position (matrix-transform-3x4 matrix v1)))
        (v2 (vertex+ position (matrix-transform-3x4 matrix v2)))
        (v3 (vertex+ position (matrix-transform-3x4 matrix v3)))
        (v4 (vertex+ position (matrix-transform-3x4 matrix v4))))
    (let ((quad (make-quad #f v1 v2 v3 v4)))
      (new Sign-Element position: position quad: quad data: data))))


;; hacks for minecraft 1.8 format
(definition public (effective-sign-text text)
  (cond ((equal? text "null")
         "")
        ((starts-with? text "\"")
         (substring text 1 (- (string-length text) 1)))
        (else
         text)))


(definition public (find-sign text)
  (let ((context (->search-context text)))
    (continuation-capture
      (lambda (return)
        (iterate-signs
          (lambda (sign)
            (let ((data (get-data~ sign)))
              (when (or (search (tag-assoc "Text1" data) context)
                        (search (tag-assoc "Text2" data) context)
                        (search (tag-assoc "Text3" data) context)
                        (search (tag-assoc "Text4" data) context))
                (continuation-return return sign)))))
        #f))))

(definition public (iterate-signs proc)
  (let ((zone (current-zone)))
    (iterate-table (get-sectors~ zone)
      (lambda (index sector)
        (for-each (lambda (element)
                    (when (is? element Sign-Element)
                      (proc element)))
                  (get-texture-elements~ sector))))))


(define-minecraft-block SignPost
  63
  texture: "planks_birch"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (rotate-upon& (- (* (cast <fl> data-id) PI/8)) (vertex& 0. 1. 0.) (vertex& 0. 0. 1.))))))
                ;; sign
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom 0.)
                      (top (+ block-radius))
                      (back (- .05))
                      (front (+ .05)))
                  (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)
                  ;; text
                  (unless (minecraft-model?)
                    (add-texture-element
                      (lambda (region sector adder)
                        (let ((data (block-entity-data region sector i j k)))
                          (when (contains-text? data)
                            (let ((front (+ front add-epsilon)))
                              (let ((v1 (vertex left top front))
                                    (v2 (vertex left bottom front))
                                    (v3 (vertex right bottom front))
                                    (v4 (vertex right top front)))
                                (adder
                                  (make-sign-element (vertex& x y z) v1 v2 v3 v4 matrix data))))))))))
                ;; post
                (let ((left (- .05))
                      (right (+ .05))
                      (bottom (- block-radius))
                      (top 0.)
                      (back (- .05))
                      (front (+ .05)))
                  (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))))


(define-minecraft-block WoodenDoorBlock
  64
  texture: "door_wood_lower"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (when use-models?
                (choose-door-model "wooden_door.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (let ((zone (current-zone)))
                   (updating-sectors~ zone
                     (lambda (add-sector)
                       (define (door-sound open?)
                         (play-sound-file
                           (if open?
                               "sound/random/door_close"
                             "sound/random/door_open")
                           volume: .5))
                       
                       (cond ((bit-set? 3 data-id)
                              (with-field i (- j 1) k
                                (lambda (section index)
                                  (let ((data (data-ref section index)))
                                    (data-set! section index
                                      (if (bit-set? 2 data)
                                          (bit-set data 2 #f)
                                        (bit-set data 2 #t)))
                                    (add-sector sector)
                                    (add-sector (get-sector~ section))))))
                             (else
                              (with-field i j k
                                (lambda (section index)
                                  (door-sound (bit-set? 2 data-id))
                                  (data-set! section index
                                    (if (bit-set? 2 data-id)
                                        (bit-set data-id 2 #f)
                                      (bit-set data-id 2 #t)))
                                  (add-sector sector)
                                  (add-sector (get-sector~ section)))))))))))


(definition block-states
  (make-table))

(definition (cache-block-states filename)
  (or (table-ref block-states filename #f)
      (begin
        (set-current-directory {Directory Yownu-World "assets" "minecraft" "block_states"})
        (if (file-exists? filename)
            (let ((variants (table-ref (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "block_states"} filename)) "variants")))
              (table-set! block-states filename variants)
              variants)
          (let ((variants (table-ref (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "block_states" "minecraft"} filename)) "variants")))
            (table-set! block-states filename variants)
            variants)))))

(definition (with-block-state filename key proc)
  (let ((variants (cache-block-states filename)))
    (let ((variant (table-ref variants key)))
      (let ((model (string-append (table-ref variant "model") ".json"))
            (rotation-y (table-ref variant "y" 0))
            (rotation-x (table-ref variant "x" 0)))
        (proc model rotation-y rotation-x)))))


(definition (choose-door-model filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
  (let ((lower-data (if (bit-set? 3 data-id) (data-ref i (- j 1) k) data-id))
        (upper-data (if (bit-set? 3 data-id) data-id (data-ref i (+ j 1) k))))
    (let ((key
            (string-append
              "facing="
              (case (bitwise-and lower-data #b11)
                ((0) "east,half=")
                ((1) "south,half=")
                ((2) "west,half=")
                ((3) "north,half="))
              (if (bit-set? 3 data-id)
                  "upper,hinge="
                "lower,hinge=")
              (if (bit-set? 0 upper-data)
                  "right,open="
                "left,open=")
              (if (bit-set? 2 lower-data)
                  "true"
                "false"))))
      (with-block-state filename key
        (lambda (model rotation-y rotation-x)
          (add-json-model model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref rotation-y rotation-x))))))


(define-minecraft-block Ladder
  65
  texture: "ladder"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-transparent (bitwise-and data-id #b111) 5 4 3 2 i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block Rail
  66
  texture: "rail_normal"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-rail data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block CobblestoneStairs
  67
  texture: "cobblestone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block WallSign
  68
  texture: "planks_birch"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (- block-radius))
                    (right (+ block-radius))
                    (bottom (- (/ block-radius 2.)))
                    (top (+ (/ block-radius 2.)))
                    (back (+ (- block-radius) .025))
                    (front (+ (- block-radius) .125)))
                (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case data-id
                                                                       ((2) (vertex&  0. 0. -1.))
                                                                       ((3) (vertex&  0. 0.  1.))
                                                                       ((4) (vertex& -1. 0.  0.))
                                                                       ((5) (vertex&  1. 0.  0.))
                                                                       ;; for the model
                                                                       ((0) (vertex&  0. 0.  1.)))))))
                  ;; sign
                  (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)
                  ;; text
                  (unless (minecraft-model?)
                    (add-texture-element
                      (lambda (region sector adder)
                        (let ((data (block-entity-data region sector i j k)))
                          (when (contains-text? data)
                            (let ((front (+ front add-epsilon)))
                              (let ((v1 (vertex left top front))
                                    (v2 (vertex left bottom front))
                                    (v3 (vertex right bottom front))
                                    (v4 (vertex right top front)))
                                (adder
                                  (make-sign-element (vertex& x y z) v1 v2 v3 v4 matrix data)))))))))))))


(define-minecraft-block Lever
  69
  category: redstone-category
  texture: "lever"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (lever-model "lever.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
                (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case (bitwise-and data-id #b111)
                                                                       ((0) (vertex&  0.  0.  1.))
                                                                       ((1) (vertex&  0.  0.  1.))
                                                                       ((2) (vertex&  0.  0. -1.))
                                                                       ((3) (vertex& -1.  0.  0.))
                                                                       ((4) (vertex&  1.  0.  0.))
                                                                       ((5) (vertex&  0.  0.  1.))
                                                                       ((6) (vertex&  0.  0.  1.))
                                                                       ((7) (vertex&  0.  0.  0.))))))
                      (margin 3m)
                      (cobble (get-coordinates "cobblestone")))
                  (let ((left (+ (- block-radius) .01))
                        (right (+ (- block-radius) margin))
                        (bottom (- .25))
                        (top (+ .25))
                        (back (- margin))
                        (front (+ margin))
                        (right-uv (uv-rect cobble 0. .5 .375 1.))
                        (front-uv (uv-rect cobble 0. 0. margin .5))
                        (top-uv (uv-rect cobble .8125 .6125 1. 1.)))
                    (add-face (left-generic   i j k x y z left right bottom top back front right-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (right-generic  i j k x y z left right bottom top back front right-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (bottom-generic i j k x y z left right bottom top back front top-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (top-generic    i j k x y z left right bottom top back front top-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (back-generic   i j k x y z left right bottom top back front front-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (front-generic  i j k x y z left right bottom top back front front-uv generic-coordinates lighting rendering block-id matrix) rendering category)))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (with-field i j k
                   (lambda (section index)
                     (updating-sectors~ (current-zone)
                       (lambda (add-sector)
                         (add-sector (get-sector~ section))
                         (if (bit-set? 3 data-id)
                             (redstone-update~ (current-game) sector i j k block-id 'deactivate add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)
                           (redstone-update~ (current-game) sector i j k block-id 'activate add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))))))))


(definition (lever-model filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
  (let ((key
          (string-append
            "facing="
            (case (bitwise-and data-id #b111)
              ((0) "down_z")
              ((1) "east")
              ((2) "west")
              ((3) "south")
              ((4) "north")
              ((5) "up_x")
              ((6) "up_z")
              ((7) "down_x"))
            ",powered="
            (if (bit-set? 3 data-id)
                "false"
              "true"))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref rotation-y rotation-x)))))

        
(define-minecraft-block StonePressurePlate
  70
  category: redstone-category
  texture: "stone_slab_top"
  opaque-cube?: #f
  cube?: #f
  physical?: #t
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (+ (- x block-radius) 1m))
                    (right (- (+ x block-radius) 1m))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) 1m))
                    (back (+ (- z block-radius) 1m))
                    (front (- (+ z block-radius) 1m)))
                (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category))))


(define-minecraft-block IronDoorBlock
  71
  ;; too much category: redstone-category
  texture: "door_iron_lower"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (when use-models?
                (choose-door-model "iron_door.json"block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref))))


(define-minecraft-block WoodenPressurePlate
  72
  category: redstone-category
  texture: "planks_oak"
  opaque-cube?: #f
  cube?: #f
  physical?: #t
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (+ (- x block-radius) 1m))
                    (right (- (+ x block-radius) 1m))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) 1m))
                    (back (+ (- z block-radius) 1m))
                    (front (- (+ z block-radius) 1m)))
                (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category))))


(define-minecraft-block RedstoneOre
  73
  texture: "redstone_ore")


(define-minecraft-block GlowingRedstoneOre
  74
  texture: "repeater_on"
  brightness: 9)


(define-minecraft-block RedstoneTorchOff
  75
  category: redstone-category
  texture: "redstone_torch_off"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-torch block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref "melon_top" "planks_spruce")))


(define-minecraft-block RedstoneTorchOn
  76
  category: redstone-category
  texture: "redstone_torch_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  brightness: 7
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (redstone-torch-model "redstone_torch.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
                (add-torch block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref "pumpkin_top" "planks_spruce"))))

(definition (redstone-torch-model filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
  (let ((key (string-append
                 "facing="
                 (case data-id
                   ((1) "west")
                   ((2) "east")
                   ((3) "north")
                   ((4) "south")
                   (else "up")))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref (+ rotation-y 180) rotation-x)))))


(define-minecraft-block StoneButton
  77
  category: redstone-category
  texture: "cobblestone"
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-button block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (with-field i j k
                   (lambda (section index)
                     (updating-sectors~ (current-zone)
                       (lambda (add-sector)
                         (add-sector (get-sector~ section))
                         (unless (bit-set? 3 data-id)
                           (data-set! section index (bit-set data-id 3 #t))
                           (redstone-update~ (current-game) sector i j k 77 'activate add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))))))))


(define-minecraft-block Snow
  78
  texture: "snow"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) (* (+ data-id 1) (/ 1. 8.))))
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category))))


(define-minecraft-block Ice
  79
  texture: "ice")


(define-minecraft-block SnowBlock
  80
  texture: "snow")


;; todo other faces
(define-minecraft-block Cactus
  81
  texture: "cactus_side"
  opaque-cube?: #f
  cube?: #f)


(define-minecraft-block Clay
  82
  texture: "clay")


(define-minecraft-block SugarCane
  83
  texture: "reeds"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-minecraft-block Jukebox
  84
  texture: "jukebox_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "jukebox_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-minecraft-block Fence
  85
  texture: "planks_oak"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-fence data-id i j k x y z uv lighting rendering category block-id add-face block-ref '(85 @quick-hack-to-remove-all-doors 107))))


(define-minecraft-block Pumpkin
  86
  texture: "pumpkin_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "pumpkin_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-minecraft-block Netherrack
  87
  rendering: water-rendering
  texture: "netherrack")


(define-minecraft-block SoulSand
  88
  rendering: water-rendering
  texture: "soul_sand")


(define-minecraft-block Glowstone
  89
  rendering: multitexture-rendering
  texture: "glowstone"
  brightness: 15)


;; improve
(define-minecraft-block Portal
  90
  rendering: multitexture-rendering
  texture: "portal"
  opaque-cube?: #f
  cube?: #f)


(define-minecraft-block Jack-O-Lantern
  91
  texture: "pumpkin_top"
  brightness: 15)


(define-minecraft-block CakeBlock
  92
  texture: "cake_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 1m)
                    (half (/ 1. 32.)))
                (let ((left (+ (- x block-radius) margin))
                      (right (- (+ x block-radius) margin))
                      (bottom (- y block-radius))
                      (top y)
                      (back (+ (- z block-radius) margin))
                      (front (- (+ z block-radius) margin))
                      (side-uv uv)
                      (bottom-uv (get-coordinates "cake_bottom"))
                      (top-uv (get-coordinates "cake_top")))
                  (add-face (left-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering cake-category)
                  (add-face (right-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering cake-category)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering cake-category)
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering cake-category)
                  (add-face (back-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering cake-category)
                  (add-face (front-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering cake-category)))))


;; improve
(define-minecraft-block RedstoneRepeaterBlockOff
  93
  category: redstone-category
  texture: "repeater_off"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 2m)
                    (small 1m)
                    (matrix (make-y-rotation-matrix (* PI/2 (cast <fl> (bitwise-and data-id #b11))))))
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom (- block-radius))
                      (top (+ margin (- block-radius)))
                      (back (- block-radius))
                      (front (+ block-radius))
                      (torch-back (+ (- 2m) (* (arithmetic-shift-right (bitwise-and data-id #b1100) 2) 2m))))
                  (let ((side-uv (uv-rect (get-coordinates "stone")  0. .875 0. 1.))
                        (torch-uv (uv-rect (get-coordinates "redstone_torch_off") 6m 5m 10m 11m))
                        (torch-top-uv (uv-rect (get-coordinates "redstone_torch_off") 7m 6m 9m 8m)))
                    (add-face (left-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (right-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (bottom-generic i j k x y z left right bottom top back front (get-coordinates "stone") generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (top-generic    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (back-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (front-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (left-generic   i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (right-generic  i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (back-generic   i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (front-generic  i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (top-generic    i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-top-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (left-generic   i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (right-generic  i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (back-generic   i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (front-generic  i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (top-generic    i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-top-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (updating-sectors~ (current-zone)
                   (lambda (add-sector)
                     (with-field i j k
                       (lambda (section index)
                         (let ((delay (arithmetic-shift-right (bitwise-and data-id #b1100) 2)))
                           (let ((ajust (if (= delay 3) -12 4)))
                             (add-sector (get-sector~ section))
                             (data-set! section index (+ data-id ajust))))))))))


;; improve
(define-minecraft-block RedstoneRepeaterBlockOn
  94
  category: redstone-category
  texture: "repeater_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 2m)
                    (small 1m)
                    (matrix (make-y-rotation-matrix (* PI/2 (cast <fl> (bitwise-and data-id #b11))))))
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom (- block-radius))
                      (top (+ margin (- block-radius)))
                      (back (- block-radius))
                      (front (+ block-radius))
                      (torch-back (+ (- 2m) (* (arithmetic-shift-right (bitwise-and data-id #b1100) 2) 2m))))
                  (let ((side-uv (uv-rect (get-coordinates "stone")  0. .875 0. 1.))
                        (torch-uv (uv-rect (get-coordinates "redstone_torch_on") 6m 5m 10m 11m))
                        (torch-top-uv (uv-rect (get-coordinates "redstone_torch_on") 7m 6m 9m 8m)))
                    (add-face (left-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (right-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (bottom-generic i j k x y z left right bottom top back front (get-coordinates "stone") generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (top-generic    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (back-generic   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (front-generic  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (left-generic   i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (right-generic  i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (back-generic   i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (front-generic  i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (top-generic    i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-top-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (left-generic   i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (right-generic  i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (back-generic   i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (front-generic  i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)
                    (add-face (top-generic    i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-top-uv generic-coordinates lighting rendering block-id matrix) rendering redstone-category)))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (updating-sectors~ (current-zone)
                   (lambda (add-sector)
                     (with-field i j k
                       (lambda (section index)
                         (let ((delay (arithmetic-shift-right (bitwise-and data-id #b1100) 2)))
                           (let ((ajust (if (= delay 3) -12 4)))
                             (add-sector (get-sector~ section))
                             (data-set! section index (+ data-id ajust))))))))))


;; improve
(define-minecraft-block LockedChest
  95
  texture: "piston_top_normal"
  cube?: #f)


(define-minecraft-block Trapdoor
  96
  ;; too much category: redstone-category
  texture: "trapdoor"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (choose-trapdoor-model "trapdoor.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
                (add-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering category block-id add-face)))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (let ((zone (current-zone)))
                   (updating-sectors~ zone
                     (lambda (add-sector)
                       (with-field i j k
                         (lambda (section index)
                           (data-set! section index
                             (if (bit-set? 2 data-id)
                                 (bit-set data-id 2 #f)
                               (bit-set data-id 2 #t)))
                           (add-sector sector))))))))

(definition (choose-trapdoor-model filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
  (let ((key
          (string-append
            "facing="
            (case (bitwise-and data-id #b11)
              ((0) "south,half=")
              ((1) "north,half=")
              ((2) "east,half=")
              ((3) "west,half="))
            (if (bit-set? 3 data-id)
                "top,open="
              "bottom,open=")
            (if (bit-set? 2 data-id)
                "true"
              "false"))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref rotation-y rotation-x)))))


;; improve with data
(define-minecraft-block StoneSilverfish
  97
  texture: "stone")

(define-minecraft-block CobblestoneSilverfish
  (97 1))

(define-minecraft-block StoneBrickSilverfish
  (97 2))


(define-minecraft-block StoneBrick
  98
  texture: "stonebrick_cracked")

(define-minecraft-block MossyStoneBrick
  (98 1))

(define-minecraft-block CrackedStoneBrick
  (98 2))


(define-minecraft-block BrownMushroomCap
  99
  texture: "mushroom_block_skin_brown")


(define-minecraft-block RedMushroomCap
  100
  texture: "mushroom_block_skin_red")


(define-minecraft-block IronBars
  101
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (if use-models?
                  (choose-fence-model "iron_bars.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom (- block-radius))
                      (top (+ block-radius))
                      (back (- block-radius))
                      (front (+ block-radius))
                      (left?  (/= (cast <fx> (block-ref (- i 1) j k)) air-id))
                      (right? (/= (cast <fx> (block-ref (+ i 1) j k)) air-id))
                      (back?  (/= (cast <fx> (block-ref i j (- k 1))) air-id))
                      (front? (/= (cast <fx> (block-ref i j (+ k 1))) air-id))
                      (matrix (make-lookat-matrix& (horizon-lookat&^ (vertex&  0. 0.  1.)))))
                  (if (and (not left?)
                           (not right?)
                           (not back?)
                           (not front?))
                      (begin
                        (add-face (x-generic i j k x y z 0. 0. bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
                        (add-face (z-generic i j k x y z left right bottom top 0. 0. uv generic-coordinates lighting rendering block-id matrix) rendering category))
                    (let ((uv (uv-rect uv 0. 0. .5 1.)))
                      (when left?
                        (add-face (z-generic i j k x y z left 0. bottom top 0. 0. uv generic-coordinates lighting rendering block-id matrix) rendering category))
                      (when right?
                        (add-face (z-generic i j k x y z 0. right bottom top 0. 0. uv generic-coordinates lighting rendering block-id matrix) rendering category))
                      (when back?
                        (add-face (x-generic i j k x y z 0. 0. bottom top back 0. uv generic-coordinates lighting rendering block-id matrix) rendering category))
                      (when front?
                        (add-face (x-generic i j k x y z 0. 0. bottom top 0. front uv generic-coordinates lighting rendering block-id matrix) rendering category))))))))


(definition (choose-fence-model filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
  (define (connects? i j k)
    (let ((block (block-ref i j k)))
      (or (= block 101) (and (get-cube?~ (blockid->block block)) (not (memv? block '(29 33 79 138)))))))
  
  (let ((key (string-append
               "east="
               (if (connects? (- i 1) j k)
                   "true"
                 "false")
               ",north="
               (if (connects? i j (+ k 1))
                   "true"
                 "false")
               ",south="
               (if (connects? i j (- k 1))
                   "true"
                 "false")
               ",west="
               (if (connects? (+ i 1) j k)
                   "true"
                 "false"))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref (+ rotation-y 180) rotation-x)))))


(define-minecraft-block GlassPane
  102
  texture: "glass"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cube-faces i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block MelonBlock
  103
  texture: "melon_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "melon_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-minecraft-block PumpkinStem
  104
  image: "pumpkin_stem_disconnected"
  texture: "pumpkin_stem_disconnected_ochre"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cross-faces i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block MelonStem
  105
  image: "melon_stem_disconnected"
  texture: "melon_stem_disconnected_ochre"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-cross-faces i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block Vines
  106
  image: "vine"
  texture: "vine_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-transparent data-id 2 8 4 1 i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block FenceGate
  107
  ;; too much category: redstone-category
  texture: "planks_oak"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              ;; quick hack to remove all fences
              #f
              @w
              (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case (bitwise-and data-id #b11)
                                                                     ((0 2) (vertex&  0. 0.  1.))
                                                                     ((1 3) (vertex& -1. 0.  0.))))))
                    (opened? (bit-set? 2 data-id)))
                (define (add-trunk left <fl> right <fl>)
                  (let ((bottom (+ (- block-radius) .35))
                        (top (+ block-radius))
                        (back (- .075))
                        (front (+ .075)))
                    (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
                
                (define (add-branches left <fl> right <fl> back <fl> front <fl>)
                  ;; upper
                  (let ((bottom (- .35 .075))
                        (top (+ .35 .075)))
                    (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face))
                  ;; lower
                  (let ((bottom (- .075))
                        (top (+ .075)))
                    (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
                
                (define (add-middle left <fl> right <fl> back <fl> front <fl>)
                  (let ((bottom -.075)
                        (top (+ .35 .075)))
                    (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
                
                ;; trunk
                (add-trunk (- block-radius) (+ (- block-radius) .2))
                (add-trunk (- (+ block-radius) .2) (+ block-radius))
                ;; branches
                (cond (opened?
                       (add-branches (- block-radius) (+ (- block-radius) .2) .075 (- (+ block-radius) .2))
                       (add-branches (- (+ block-radius) .2) (+ block-radius) .075 (- (+ block-radius) .2)))
                      (else
                       (add-branches (+ (- block-radius) .2) -.1 (- .075) (+ .075))
                       (add-branches .1 (- (+ block-radius) .2) (- .075) (+ .075))))
                ;; middle
                (cond (opened?
                       (add-middle (- block-radius) (+ (- block-radius) .2) (- (+ block-radius) .2) (+ block-radius))
                       (add-middle (- (+ block-radius) .2) (+ block-radius) (- (+ block-radius) .2) (+ block-radius)))
                      (else
                       (add-middle -.1 0. (- .075) (+ .075))
                       (add-middle 0. .1 (- .075) (+ .075)))))))


(define-minecraft-block BrickStairs
  108
  texture: "brick"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block StoneBrickStairs
  109
  texture: "stonebrick"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block Mycelium
  110
  texture: "mycelium_side"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "mycelium_top")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-minecraft-block LilyPad
  111
  image: "waterlily"
  texture: "waterlily_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-bottom i j k x y z uv generic-coordinates lighting rendering category block-id add-face)))


(define-minecraft-block NetherBrick
  112
  texture: "nether_brick")


(define-minecraft-block NetherBrickFence
  113
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates "nether_brick")))
                (add-fence data-id i j k x y z uv lighting rendering category block-id add-face block-ref '(113)))))


(define-minecraft-block NetherBrickStairs
  114
  texture: "nether_brick"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering category block-id add-face)))


;; improve
(define-minecraft-block NetherWart
  115
  texture: "nether_wart_stage_1"
  opaque-cube?: #f
  cube?: #f)


(define-minecraft-block EnchantmentTable
  116
  texture: "enchanting_table_side"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 4m))
                (let ((left (- x block-radius))
                      (right (+ x block-radius))
                      (bottom (- y block-radius))
                      (top (+ y margin))
                      (back (- z block-radius))
                      (front (+ z block-radius))
                      (top-uv (get-coordinates "enchanting_table_top"))
                      (bottom-uv (get-coordinates "enchanting_table_bottom")))
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-minecraft-block BrewingStand
  117
  texture: "brewing_stand"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)


(define-minecraft-block Cauldron
  118
  texture: "cauldron_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 4m)
                    (half 2m))
                (let ((left (- x block-radius))
                      (right (+ x block-radius))
                      (bottom (- y block-radius))
                      (top (+ y block-radius))
                      (back (- z block-radius))
                      (front (+ z block-radius))
                      (top-uv (get-coordinates "cauldron_top"))
                      (bottom-uv (get-coordinates "cauldron_bottom"))
                      (inner-uv (get-coordinates "cauldron_inner")))
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (left-face   i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (top-face    i j k x y z left right bottom (+ bottom margin) back front inner-uv generic-coordinates lighting rendering block-id) rendering category)
                  (if (> data-id 0)
                      (let ((water-uv (get-coordinates "water"))
                            (wtop (/ (+ 6. (* 3. data-id)) 16.)))
                        (add-face (top-face i j k x y z left right bottom wtop back front water-uv generic-coordinates lighting rendering block-id) rendering category)))))))


;; improve
(define-minecraft-block EndPortal
  119
  texture: "stone_slab_top"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-slab i j k x y z uv uv lighting rendering category block-id add-face)))


(define-minecraft-block EndPortalFrame
  120
  texture: "endframe_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((margin 5m))
                (let ((left (- x block-radius))
                      (right (+ x block-radius))
                      (bottom (- y block-radius))
                      (top (+ y margin))
                      (back (- z block-radius))
                      (front (+ z block-radius))
                      (top-uv (get-coordinates "endframe_top"))
                      (bottom-uv (get-coordinates "end_stone")))
                  (add-face (top-face    i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (bottom-face i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)))
              (when (= data-id 4)
                (let ((margin 4m))
                  (let ((top (+ y block-radius))
                        (bottom (+ y 5m))
                        (left (- x margin))
                        (right (+ x margin))
                        (back (- z margin))
                        (front (+ z margin))
                        (side-uv (get-coordinates "endframe_eye_side"))
                        (top-uv (get-coordinates "endframe_eye")))
                    (add-face (left-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                    (add-face (right-face i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                    (add-face (front-face i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                    (add-face (back-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                    (add-face (top-face   i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category))))))


(define-minecraft-block EndStone
  121
  texture: "end_stone")


;; improve
(define-minecraft-block DragonEgg
  122
  texture: "dragon_egg"
  opaque-cube?: #f
  cube?: #f)


(define-minecraft-block RedstoneLampOff
  123
  category: redstone-category
  texture: "redstone_lamp_off"
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "redstone_lamp_top_off")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-minecraft-block RedstoneLampOn
  124
  category: redstone-category
  texture: "redstone_lamp_on"
  brightness: 15
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((top (get-coordinates "redstone_lamp_top_on")))
                (add-opaque-cube i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(definition Wood-Slab-Textures <vector>
  #("planks_oak"
    "planks_spruce"
    "planks_birch"
    "planks_jungle"))

;; improve
(define-minecraft-block DoubleWoodenSlab
  125
  texture: "planks_oak"
  opaque-cube?: #t
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wood-Slab-Textures (modulo data-id 4)))))
                (add-slab i j k x y z uv (uv-rect uv 0. .5 1. 1.) lighting rendering category block-id add-face)
                (add-slab i j k x (+ y block-radius) z uv (uv-rect uv 0. 0. 1. .5) lighting rendering category block-id add-face))))


(define-minecraft-block WoodenSlab
  126
  texture: "planks_oak"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wood-Slab-Textures (modulo data-id 4)))))
                (if (< data-id 3)
                    (add-slab i j k x y z uv (uv-rect uv 0. .5 1. 1.) lighting rendering category block-id add-face)
                  (add-slab i j k x (+ y block-radius) z uv (uv-rect uv 0. 0. 1. .5) lighting rendering category block-id add-face)))))


(define-minecraft-block CocoaPlant
  127
  texture: "cocoa_stage_2"
  opaque-cube?: #f
  cube?: #f)


(define-minecraft-block SandstoneStairs
  128
  texture: "sandstone_normal"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block EmeraldOre
  129
  texture: "emerald_ore")


;; improve
(define-minecraft-block EnderChest
  130
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-minecraft-block TripwireHook
  131
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-minecraft-block Tripwire
  132
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)


(define-minecraft-block EmeraldBlock
  133
  texture: "emerald_block")


(define-minecraft-block SpruceWoodStairs
  134
  texture: "planks_spruce"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block BirchWoodStairs
  135
  texture: "planks_birch"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-minecraft-block JungleWoodStairs
  136
  texture: "planks_jungle"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-stairs data-id i j k x y z uv lighting rendering category block-id add-face)))


;; improve
(define-minecraft-block CommandBlock
  137
  texture: "farmland_wet")


;; improve
(define-minecraft-block BeaconBlock
  138
  texture: "beacon"
  brightness: 15)


;; improve
(define-minecraft-block CobblestoneWall
  139
  texture: "cobblestone"
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-minecraft-block FlowerPot
  140
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-minecraft-block Carrots
  141
  texture: "farmland_wet"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-minecraft-block Potatoes
  142
  texture: "farmland_wet"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-minecraft-block WoodenButton
  143
  category: redstone-category
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
              (add-button block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                 (with-field i j k
                   (lambda (section index)
                     (updating-sectors~ (current-zone)
                       (lambda (add-sector)
                         (add-sector (get-sector~ section))
                         (unless (bit-set? 3 data-id)
                           (data-set! section index (bit-set data-id 3 #t))
                           (redstone-update~ (current-game) sector i j k 143 'activate add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!))))))))


(let ((unknown-texture "gold_ore"))
  (loop (for id from 0 below 256)
        (unless (vector-ref blockids id)
          (register-minecraft-block 'Unknown id
            texture: unknown-texture))))


;;;
;;;; Model
;;;


(class Minecraft-Block extends Entity
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! physical? #t))
  
  
  (method override (resolve-model)
    (find-minecraft-model model)))


(definition minecraft-models <table>
  (make-table test: eq?))


(definition minecraft-model?
  (make-parameter #f))


(definition (register-minecraft-models)
  (parameterize ((minecraft-model? #t))
    (loop (for n from 0 below (vector-length blockids))
          (let ((block <Minecraft-Block-Model> (vector-ref blockids n)))
            (let ((name (get-name~ block))
                  (id (get-id~ block)))
              (unless (or (= id 0)
                          (eq? name 'Unknown))
                (table-set! minecraft-models name
                  (lambda ()
                    (minecraft-model block)))))))))


(definition public (find-minecraft-model name)
  (let ((model (table-ref minecraft-models name)))
    (if (is? model Model)
        model
      (let ((model <Model> (model)))
        (set-name~ model name)
        (table-set! minecraft-models name model)
        model))))


(definition public (minecraft-model block <Minecraft-Block-Model>)
  (let ((faces '())
        (block-id (get-id~ block))
        (category (get-category~ block))
        (uv (block-texture-coordinates block))
        (generate (get-generate~ block))
        (rendering (cache-rendering~ block))
        (transparent-rendering (transparent-rendering)))
    (define (block-ref i <fx> j <fx> k <fx>) <fx>
      air-id)
    
    (define (data-ref i <fx> j <fx> k <fx>) <fx>
      0)
    
    (define (add-face face <Face> rendering <Minecraft-Rendering> category)
      (set! faces (cons face faces)))
    
    (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id add-face)
      (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering category)
      (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering category)
      (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering category)
      (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering category)
      (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering category)
      (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering category))
    
    (define (add-texture-element element)
      )
    
    (define default-lighting
      (f32vector 0. 60. 4.))
    
    (define (no-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      default-lighting)
    
    (let ((lighting no-lighting))
      (cond (generate
             (generate block-id 0 0 0 0 0. 0. 0. uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref))
            ((get-opaque-cube?~ block)
             (add-opaque-cube 0 0 0 0. 0. 0. uv uv uv uv uv uv lighting rendering category block-id add-face))
            (else
             (add-cross-faces 0 0 0 0. 0. 0. uv lighting transparent-rendering category block-id add-face))))
    (make-model faces)))


(register-minecraft-models)


;;;
;;;; Section
;;;


(class Minecraft-Section extends World-Section)


;;;
;;;; Chunk
;;;


(class Minecraft-Chunk extends World-Chunk
  
  
  (slot tag                            getter generate)
  (slot heightmap      <vector+>       getter generate)
  (slot entities                       getter generate)
  (slot block-entities                 getter generate)
  (slot block-entities-index <table+>  getter generate)
  
  
  (method override (initialize region tag heightmap entities block-entities)
    (nextmethod region)
    (set! tag~self tag)
    (set! heightmap~self heightmap)
    (set! entities~self entities)
    (set! block-entities~self block-entities)
    (set! block-entities-index~self (index-block-entities (list-payload-content block-entities))))
  
  
  (method (index-block-entities block-entities)
    (if (null? block-entities)
        #f
      (let ((table (make-table test: equal?)))
        (for-each (lambda (block-entity)
                    (let ((x (tag-assoc "x" block-entity))
                          (y (tag-assoc "y" block-entity))
                          (z (tag-assoc "z" block-entity)))
                      (let ((index (vector x y z)))
                        (table-set! table index block-entity))))
                  block-entities)
        table)))
  
  
  (method (find-block-entity index)
    (and block-entities-index (table-ref block-entities-index index #f)))
  
  
  (method (add-block-entity index)
    (let ((x (vector-ref index 0))
          (y (vector-ref index 1))
          (z (vector-ref index 2)))
      (let ((block-entity (list (make-tag "Items" TAG_List (make-list-payload TAG_Compound '()))
                                (make-tag "id" TAG_String "Chest")
                                (make-tag "x" TAG_Int x)
                                (make-tag "y" TAG_Int y)
                                (make-tag "z" TAG_Int z))))
        (set-list-payload-content block-entities (cons block-entity (list-payload-content block-entities)))
        (table-set! block-entities-index index block-entity)
        block-entity))))


(definition protected (block-entity-data region <World-Region> sector <Sector> i <fx> j <fx> k <fx>)
  (let ((index (get-index~ sector)))
    (let ((sector-x (vector-ref index 0))
          (sector-z (vector-ref index 2)))
      (let ((chunk <Minecraft-Chunk> (get-chunk~ region sector-x sector-z))
            (index (sector/coordinates->location sector i j k)))
        (find-block-entity~ chunk index)))))


(definition protected (block-entity-add region <World-Region> sector <Sector> i <fx> j <fx> k <fx>)
  (let ((index (get-index~ sector)))
    (let ((sector-x (vector-ref index 0))
          (sector-z (vector-ref index 2)))
      (let ((chunk <Minecraft-Chunk> (get-chunk~ region sector-x sector-z))
            (index (sector/coordinates->location sector i j k)))
        (add-block-entity~ chunk index)))))


;;;
;;;; Region
;;;


(definition bedrock-cut <fx>
  64)

(definition bedrock-sectors-cut <fx>
  (quotient bedrock-cut 16))


(class Minecraft-Region extends World-Region
  
  
  (method override (deserialize-chunk chunk-data <u8vector>) <Minecraft-Chunk>
    (let ((zone <Minecraft-Zone> (current-zone)))
      (with ((reader <NBT-Reader> (new NBT-Reader chunk-data compressed?: #f)))
        (let ((tag (read-tag~ reader)))
          (let ((compound (tag-assoc "Level" (tag-value tag))))
            (let ((heightmap (tag-assoc "HeightMap" compound))
                  (entities (list-payload-content (tag-assoc "Entities" compound)))
                  (block-entities (tag-assoc "TileEntities" compound))
                  (sections (list-payload-content (tag-assoc "Sections" compound))))
              (let ((chunk (new Minecraft-Chunk self tag heightmap entities block-entities)))
                (when sections
                  (let ((truncate-y (get-truncate-y~ zone)))
                    (for-each (lambda (section)
                                (let ((yPos (- (cast <fx> (tag-assoc "Y" section)) bedrock-sectors-cut))
                                      (blocks (tag-assoc "Blocks" section))
                                      (data (tag-assoc "Data" section))
                                      (blocklight (tag-assoc "BlockLight" section))
                                      (skylight (tag-assoc "SkyLight" section)))
                                  (when (or (not truncate-y)
                                            (>= yPos (cast <fx> truncate-y)))
                                    (add-section~ chunk yPos (new Minecraft-Section chunk blocks data blocklight skylight)))))
                              sections)))
                chunk)))))))
  
  
  (method override (serialize-chunk chunk <Minecraft-Chunk>) <u8vector>
    (with ((writer <NBT-Writer> (new NBT-Writer #f)))
      (write-tag~ writer (get-tag~ chunk))
      (get-content~ writer))))


;;;
;;;; Zone
;;;


(definition protected day-duration <fl>
  24000.)

(definition protected dawn-daytime <fl>
  6000.)

(definition protected day-daytime <fl>
  12000.)

(definition protected dusk-daytime <fl>
  18000.)

(definition protected night-daytime <fl>
  0.)


(class Minecraft-Zone extends Zone
  
  
  (property level-dir   <Directory> initialize #f    accessors generate)
  (property dimension   <symbol>    initialize 'over accessors generate)
  (property truncate-y  <fx+>       initialize #f    accessors generate)
  (property player-glow <fl>        initialize -1.   accessors generate)
  
  
  (slot level-file   initialize #f)
  (slot level-nbt    initialize #f)
  (slot opened-chest initialize #f accessors generate)

  
  (form
    (<install> floor-level: -150. start-grid?: #f start-axes?: #f jump-impulsion: .265))
  
  
  ;; quicky for tests
  (method override (minecraft?)
    #t)
  
  
  (method override (needs-pumps?)
    #t)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! ambient-color (dye .1 .05 0. 1.)))


  (proclaim (not warn optimizations))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set-daytime (effective-daytime start-time))
    (set! sun-angle (daytime->sun-angle daytime)))
  
  
  (method override (setup-persistence)
    (nextmethod)
    (let ((moniker (get-moniker)))
      (when (and moniker (not level-dir))
        (set! level-dir (new-directory~ (get-parent~ moniker) "level")))))
  
  
  (method override (install-interface)
    (let ((world (current-world)))
      (updating-actions~ (get-application)
        (lambda ()
          (set-visible?~ (child~ (get-bindings) 'world-minecraft) #t)))
      (let ((interface (get-interface~ world)))
        (set-visible?~ (child~ interface 'minecraft) (not (user-role?)))
        (set-visible?~ (child~ interface 'bag) #f)
        (view-inventory~ (child~ interface 'belt))
        (set-visible?~ (child~ interface 'belt) (get-show-belt?~ world))
        (set-visible?~ (child~ interface 'chest) #f))))
  
  
  (method override (uninstall-interface)
    (let ((world (current-world)))
      (updating-actions~ (get-application)
        (lambda ()
          (set-visible?~ (child~ (get-bindings) 'world-minecraft) #f)))
      (let ((interface (get-interface~ world)))
        (set-show-belt?~ world (get-visible?~ (child~ interface 'belt)))
        (set-visible?~ (child~ interface 'minecraft) #f)
        (set-visible?~ (child~ interface 'bag) #f)
        (set-visible?~ (child~ interface 'belt) #f)
        (set-visible?~ (child~ interface 'chest) #f))))
  
  
  (method override (save-zone)
    (nextmethod)
    (save-chest save-region?: #t)
    (save-inventory)
    (save-level-nbt))


  (proclaim (warn optimizations))
  
  
  (method override (setup-game)
    (set-current-game (new Minecraft-Game)))
  
  
  (method protected (get-level-file)
    (or level-file
        (let ((file (new-file~ level-dir "level.dat")))
          (set! level-file file)
          file)))
  
  
  (method public (get-level-nbt)
    (or level-nbt
        (let ((nbt (read-level (get-level-file))))
          (set! level-nbt nbt)
          nbt)))
  
  
  (method (read-level file)
    (with ((reader <NBT-Reader> (new NBT-Reader file compressed?: #t gzip?: #t)))
      (read-tag~ reader)))
  
  
  (method public (save-level-nbt)
    (save-level (get-level-nbt) (get-level-file)))
  
  
  (method (save-level level file)
    (with ((writer (new NBT-Writer file compressed?: #t gzip?: #t)))
      (write-tag~ writer level)))
  
  
  (method (get-spawnpoint)
    (let ((tag (get-level-nbt)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-assoc "SpawnX" compound))
              (y (tag-assoc "SpawnY" compound))
              (z (tag-assoc "SpawnZ" compound)))
          (vertex (cast <fl> x) (cast <fl> (- y 63)) (cast <fl> z))))))
  
  
  (method (set-spawnpoint pos)
    (let ((tag (get-level-nbt)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-find "SpawnX" compound))
              (y (tag-find "SpawnY" compound))
              (z (tag-find "SpawnZ" compound)))
          (tag-set-value x (fxround (vertex-x pos)))
          (tag-set-value y (+ (fxround (vertex-y pos)) 63))
          (tag-set-value z (fxround (vertex-z pos)))))))
  
  
  (method (teleport pos (sight #f))
    (let ((world (current-world))
          (me (current-me)))
      (let ((eye (get-eye~ world)))
        (person-motion~ world feedback?: #f)
        (set-position~ me pos)
        (cond ((not sight)
               (derive-target~ eye)
               (camera-update~ eye))
              (else
               (set-lookat~ me (horizon-lookat sight))
               (eye-behind-player~ world)
               (follow-player~ world))))))
  
  
  (method (explode-blocks tnts blocks)
    (let ((game (current-game)))
      (play-sound-file "sound/random/explode" volume: .25)
      (updating-sectors
        (lambda (add-sector)
          (define (remove-block pos)
            (call-with-position pos
              (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                (delete-block~ game region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!))))
          
          (for-each remove-block tnts)
          (for-each remove-block blocks))
        delay-update?: #t)))
  
  
  (method override (lighting-setup)
    (let ((world (current-world)))
      (let ((lights (effective-lights)))
        (let ((light (/ daylight 5.)))
          (set-ambient-color~ lighting (dye (+ (dye-red ambient-color) light)
                                            (+ (dye-green ambient-color) light)
                                            (+ (dye-blue ambient-color) light)
                                            1.0)))
        (set-lights~ lighting lights)
        (set-lights-count~ lighting (min (get-dynamic-lights~ world) (length lights)))
        (set-current-lighting lighting))))
  
  
  (method override (block-lighting-setup)
    (let ((world (current-world)))
      (let ((lights '()))
        (set-ambient-color~ block-lighting ambient-color)
        (set-lights~ block-lighting lights)
        (set-lights-count~ block-lighting 0)
        (set-current-block-lighting block-lighting))))
  
  
  (method override (default-lights)
    '())
  
  
  (method override (effective-player-glow)
    player-glow)
  
  
  (method override (sun-light?)
    #f)
  
  
  (method override (sun-update-lighting effective coord)
    )
  
  
  (method override (sun-update)
    (set-daytime (sun-angle->daytime sun-angle)))
  
  
  (method (goto-daytime daytime)
    (if sun-cycle?
        (position-sun (daytime->sun-angle daytime))
      (set-daytime daytime)))
  
  
  (method (update-daylight)
    )
  
  
  (method (sun-angle->daytime sun-angle)
    (let ((angle (flmodulo sun-angle PI*2)))
      (flmodulo (+ (/ (* angle day-duration) PI*2) dawn-daytime) day-duration)))
  
  
  (method (daytime->sun-angle daytime)
    (/ (* (- daytime dawn-daytime) PI*2) day-duration))
  
  
  (method (effective-daytime daytime)
    (cond ((flonum? daytime) daytime)
          ((or (eq? daytime 'default) (ci=? daytime "default")) dawn-daytime)
          ((or (eq? daytime 'dawn) (ci=? daytime "dawn")) dawn-daytime)
          ((or (eq? daytime 'day) (ci=? daytime "day")) day-daytime)
          ((or (eq? daytime 'dusk) (ci=? daytime "dusk")) dusk-daytime)
          ((or (eq? daytime 'night) (ci=? daytime "night")) night-daytime)
          ((string? daytime) (cast <fl> (string->number daytime)))
          (else "Invalid daytime: {s}" daytime)))
  
  
  (method override (album-name)
    'minecraft)
  
  
  (method override (create-album)
    (let ((album (nextmethod)))
      (update-textures-subuvs (get-atlas~ album))
      album))
  
  
  (method override (create-atlas)
    (create-minecraft-atlas))
  
  
  (method override (create-textures atlas)
    (list->table
      (list
        ;; clamp to edge is necessary for joins like between the rails
        (cons 'clamp (create-minecraft-texture atlas wrap: GL_CLAMP_TO_EDGE))
        (cons 'repeat (create-minecraft-texture atlas min-filter: 'nearest)))))
  
  
  (method override (create-opaque-material atlas texture)
    (get-material~ (cast <Minecraft-Rendering> (opaque-rendering))))
  
  
  (method override (create-transparent-material atlas texture)
    (get-material~ (cast <Minecraft-Rendering> (transparent-rendering))))
  
  
  (method override (sample-program-image program)
    (case program
      ((opaque) "stone")
      ((transparent) "flower_rose")
      (else "wool_colored_light_blue")))
  
  
  (method override (default-block-class)
    (new Minecraft-Block model: 'Stone))
  
  
  (method override (zone-destructible?)
    #f)
  
  
  (method public (change-dimension)
    (mutex-lock! generate-mutex)
    (set! dimension (case dimension
                      ((over) 'nether)
                      ((nether) 'end)
                      ((end) 'over)))
    (set! regions-dir #f)
    (set! regions (make-table test: equal?))
    (set! sectors (make-table test: equal?))
    (set! areas (make-table test: equal?))
    (mutex-unlock! generate-mutex))
  
  
  (method override (region-class)
    Minecraft-Region)
  
  
  (method override (get-regions-dir) <Directory>
    (or regions-dir (let ((dir (new-directory~ level-dir (case dimension
                                                           ((over) "region")
                                                           ((nether) '("DIM-1" "region"))
                                                           ((end) '("DIM1" "region"))))))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method override (resurrect-player player)
    (let ((old-position (copy-vertex (get-position~ player)))
          (new-position (get-spawn-point~ player)))
      (set-position~ player new-position)
      (set-velocity~ player (vertex 0. 0. 0.))
      (update-element player old-position)))
  
  
  (method (on-toggle-player-glow evt)
    (if (= player-glow -1.)
        (set! player-glow 300.)
      (set! player-glow -1.)))
  
  
  ;; exploration
  (method (explore-chests)
    (preload-regions)
    (let ((items '()))
      (for-each (lambda (info)
                  (bind (sector i j k) info
                    (call-with-sector sector i j k
                      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                        (let ((data (block-entity-data region sector i j k)))
                          (let ((inventory (list-payload-content (tag-assoc "Items" data))))
                            (for-each (lambda (item)
                                        (let ((id (tag-assoc "id" item)))
                                          (unless (memv? id items)
                                            (set! items (cons id items)))))
                                      inventory)))))))
                (find-visual-blocks '(54)))
      (sort < items)))
  
  
  ;;;
  ;;;; Generate
  ;;;
  
  
  (method override (generate-content?)
    #t)
  
  
  (definition generate-mutex
    (make-mutex 'generate))
  
  
  (add-debugger-release 'generate-mutex
    (lambda ()
      (when (eq? (mutex-owner generate-mutex) (current-thread))
        (mutex-unlock! generate-mutex))))
  
  
  (method override (generate-content sector <Sector>)
    (mutex-lock! generate-mutex)
    (generate-sector sector 'render)
    (mutex-unlock! generate-mutex))
  
  
  (method override (generate-physical sector <Sector>)
    (mutex-lock! generate-mutex)
    (generate-sector sector 'physical)
    (mutex-unlock! generate-mutex))
  
  
  ;; we need to go two in every direction instead of just one
  ;; because of door tops that are rendered by door bottom blocks
  (definition block-cache-size <fx>
    (* 20 20 20 4))
  
  (definition block-cache <u16vector>
    (make-u16vector block-cache-size))
  
  (definition (initialize-block-cache cache-uninitialized <fx>) <u16vector>
    (loop (for i from 0 below block-cache-size)
          (u16vector-set! block-cache i cache-uninitialized))
    block-cache)
  
  
  (method (generate-sector sector <Sector> what)
    (define (conclude-rendering rendering <Minecraft-Rendering>)
      (let ((content (get-mesh-content~ (get-mesher~ rendering))))
        (when content
          (cons (get-material~ rendering) content))))
    
    (define (conclude-category-renderings)
      (let ((all '()))
        (iterate-table category-renderings
          (lambda (category rendering)
            (let ((content (get-mesh-content~ (get-mesher~ rendering))))
              (when content
                (let ((info (cons (get-material~ rendering) content)))
                  (set! all (cons (cons category info) all)))))))
        all))
    
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (set-generating?~ sector #f)
      (set-priority-update?~ sector #f)
      (decrease-sectors-generating 1))
    
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (checkpoint)
    (checkpoint 1)
    (when (eq? self (current-zone))
      (let ((sector-index (get-index~ sector)))
        (let ((sector-x <fx> (vector-ref sector-index 0))
              (sector-y <fx> (vector-ref sector-index 1))
              (sector-z <fx> (vector-ref sector-index 2)))
          (let ((region (sector-region sector-x sector-y sector-z)))
            (if (not region)
                (when (eq? what 'render)
                  (generate-done))
              (let ((region-x (get-x~ region))
                    (region-z (get-z~ region))
                    (section (get-section~ region what sector-x sector-y sector-z))
                    (chunk-index (chunk-index~ region sector-x sector-z))
                    (cache-uninitialized 65535))
                (if (not section)
                    (when (eq? what 'render)
                      (generate-done))
                  (site (content on?: #t parent: generate)
                  (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                        (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                        (section-y (* sector-y 16))
                        (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                        (sections <vector> (make-vector 27 #t))
                        (cache <u16vector> (initialize-block-cache cache-uninitialized))
                        (blocks <u8vector> (get-blocks~ section))
                        (data <u8vector> (get-data~ section))
                        (blocklight <u8vector> (get-blocklight~ section))
                        (skylight <u8vector> (get-skylight~ section))
                        (opaque-rendering <Minecraft-Rendering> (opaque-rendering))
                        (transparent-rendering <Minecraft-Rendering> (transparent-rendering))
                        (coverage-rendering <Minecraft-Rendering> (coverage-rendering))
                        (water-rendering <Minecraft-Rendering> (water-rendering))
                        (wet-rendering <Minecraft-Rendering> (wet-rendering))
                        (multitexture-rendering <Minecraft-Rendering> (multitexture-rendering))
                        (debug-categories? (get-debug-categories?))
                        (areas (and (eq? what 'physical) (make-table test: eq?)))
                        (areas-bounds (sector-areas-bounds sector))
                        (texture-elements '()))
                    (define (section-ref a <fx> b <fx> c <fx>) <Minecraft-Section+>
                      (if (and (= a 0)
                               (= b 0)
                               (= c 0))
                          section
                        (let ((index (section-index a b c)))
                          (let ((section (vector-ref sections index)))
                            (if (neq? section #t)
                                section
                              (let ((x (+ sector-x a))
                                    (y (+ sector-y b))
                                    (z (+ sector-z c)))
                                (let ((region (sector-region x y z)))
                                  (let ((section (and region (get-section~ (cast <Minecraft-Region> region) what x y z))))
                                    (vector-set! sections index section)
                                    section))))))))
                    
                    (define (section-index a <fx> b <fx> c <fx>) <fx>
                      (+ (* b 9) (* c 3) a 13))
                    
                    (define (local-index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (effective-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* j 400) (* k 20) i 842) 4))
                    
                    (define (blocks-get section <Minecraft-Section>) <u8vector>
                      (get-blocks~ section))
                    
                    (define (data-get section <Minecraft-Section>) <u8vector>
                      (get-data~ section))
                    
                    (define (blocklight-get section <Minecraft-Section>) <u8vector>
                      (get-blocklight~ section))
                    
                    (define (skylight-get section <Minecraft-Section>) <u8vector>
                      (get-skylight~ section))
                    
                    (define (local-block-ref i <fx> j <fx> k <fx>) <fx>
                      (u8vector-ref blocks (local-index i j k)))
                    
                    (define (local-data-ref i <fx> j <fx> k <fx>) <fx>
                      (u4vector-ref data (local-index i j k)))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (effective-data-ref i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k data-get u4vector-ref 0 0))
                    
                    (define (effective-light-ref! i <fx> j <fx> k <fx> lighting <f32vector>) <void>
                      (unless (get-opaque-cube?~ (blockid->block (effective-block-ref i j k)))
                        (let ((index (effective-index i j k)))
                          (let ((value (u16vector-ref cache (+ index 1))))
                            (if (/= value cache-uninitialized)
                                (begin
                                  (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> value)))
                                  (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> (u16vector-ref cache (+ index 2)))))
                                  (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> (u16vector-ref cache (+ index 3)))))
                                  (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))
                              (let ((blocklight (field-ref i j k blocklight-get u4vector-ref 0 0))
                                    (skylight (field-ref i j k skylight-get u4vector-ref 15 15))
                                    (ambience (if (= (effective-block-ref i j k) air-id) 1 0)))
                                (u16vector-set! cache (+ index 1) blocklight)
                                (u16vector-set! cache (+ index 2) skylight)
                                (u16vector-set! cache (+ index 3) ambience)
                                (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> blocklight)))
                                (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> skylight)))
                                (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> ambience)))
                                (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.))))))))
                    
                    (define (inner-light-ref! i <fx> j <fx> k <fx> lighting <f32vector>) <void>
                      (unless (get-opaque-cube?~ (blockid->block (effective-block-ref i j k)))
                        (let ((index (effective-index i j k)))
                          (let ((value (u16vector-ref cache (+ index 1))))
                            (if (/= value cache-uninitialized)
                                (begin
                                  (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> value)))
                                  (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> (u16vector-ref cache (+ index 2)))))
                                  (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> (u16vector-ref cache (+ index 3)))))
                                  (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))
                              (let ((local-index (local-index i j k)))
                                (let ((blocklight (u4vector-ref blocklight local-index))
                                      (skylight (u4vector-ref skylight local-index))
                                      (ambience (if (= (u8vector-ref blocks local-index) air-id) 1 0)))
                                  (u16vector-set! cache (+ index 1) blocklight)
                                  (u16vector-set! cache (+ index 2) skylight)
                                  (u16vector-set! cache (+ index 3) ambience)
                                  (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> blocklight)))
                                  (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> skylight)))
                                  (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> ambience)))
                                  (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))))))))
                    
                    (define (u4vector-ref field <u8vector> index <fx>) <fx>
                      (let ((byte (u8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (local-index i j k)))))))
                          
                          (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                ((> k 15) (bind-k 1 (- k 16)))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j -1 (+ 16 j)))
                              ((> j 15) (bind-j 1 (- j 16)))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i -1 (+ 16 i)))
                            ((> i 15) (bind-i 1 (- i 16)))
                            (else (bind-i 0 i))))
                    
                    (define (add-face-render face <Face> rendering <Minecraft-Rendering> category)
                      (let ((mesher <Minecraft-Mesher> (get-mesher~ rendering)))
                        (add-face~ mesher face)
                        (add-lighting~ mesher face))
                      (when (and debug-categories? category)
                        (let ((rendering (get-category-rendering category)))
                          (let ((mesher <Minecraft-Mesher> (get-mesher~ rendering)))
                            (add-face~ mesher face)
                            (add-full-lighting~ mesher face)))))
                    
                    (define (add-face-physical face <Face> rendering <Minecraft-Rendering> category)
                      (let ((poly (get-polygon~ face)))
                        (let ((center (get-center~ poly)))
                          (let ((index (position-area-index center)))
                            ;; it is critical for clearing polygons that every
                            ;; areas polygons are registered to belong to the zone
                            (let ((in-sector-index (vector (between (vector-ref areas-bounds 0) (vector-ref index 0) (vector-ref areas-bounds 3))
                                                           (between (vector-ref areas-bounds 1) (vector-ref index 1) (vector-ref areas-bounds 4))
                                                           (between (vector-ref areas-bounds 2) (vector-ref index 2) (vector-ref areas-bounds 5)))))
                              (let ((area (index-area in-sector-index #f)))
                                (table-add areas area poly)))))))
                    
                    (define add-face
                      (case what
                        ((render) add-face-render)
                        ((physical) add-face-physical)))
                    
                    (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id add-face)
                      (let ((rendering (effective-rendering (effective-block-ref (- i 1) j k) rendering))) (when rendering (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (effective-block-ref (+ i 1) j k) rendering))) (when rendering (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (effective-block-ref i (- j 1) k) rendering))) (when rendering (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (effective-block-ref i (+ j 1) k) rendering))) (when rendering (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (effective-block-ref i j (- k 1)) rendering))) (when rendering (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (effective-block-ref i j (+ k 1)) rendering))) (when rendering (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering category))))
                    
                    (define (add-inner-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id add-face)
                      (let ((rendering (effective-rendering (local-block-ref (- i 1) j k) rendering))) (when rendering (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (local-block-ref (+ i 1) j k) rendering))) (when rendering (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (local-block-ref i (- j 1) k) rendering))) (when rendering (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (local-block-ref i (+ j 1) k) rendering))) (when rendering (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (local-block-ref i j (- k 1)) rendering))) (when rendering (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering category)))
                      (let ((rendering (effective-rendering (local-block-ref i j (+ k 1)) rendering))) (when rendering (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering category))))
                    
                    (define (effective-rendering block-id <fx> rendering <Minecraft-Rendering>)
                      (let ((block (blockid->block block-id)))
                        (cond ((get-opaque-cube?~ block)
                               #f)
                              ((get-water-cube?~ block)
                               wet-rendering)
                              (else
                               rendering))))
                    
                    (define (add-water-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id add-face)
                      (unless (water-opaque? (effective-block-ref (- i 1) j k)) (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (effective-block-ref (+ i 1) j k)) (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (effective-block-ref i (- j 1) k)) (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (effective-block-ref i (+ j 1) k)) (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (effective-block-ref i j (- k 1))) (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (effective-block-ref i j (+ k 1))) (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering category)))
                    
                    (define (add-inner-water-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id add-face)
                      (unless (water-opaque? (local-block-ref (- i 1) j k)) (add-face (left-side   i j k x y z left-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (local-block-ref (+ i 1) j k)) (add-face (right-side  i j k x y z right-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (local-block-ref i (- j 1) k)) (add-face (bottom-side i j k x y z bottom-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (local-block-ref i (+ j 1) k)) (add-face (top-side    i j k x y z top-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (local-block-ref i j (- k 1))) (add-face (back-side   i j k x y z back-uv lighting rendering block-id) rendering category))
                      (unless (water-opaque? (local-block-ref i j (+ k 1))) (add-face (front-side  i j k x y z front-uv lighting rendering block-id) rendering category)))
                    
                    (define (water-opaque? block-id <fx>)
                      (let ((block (blockid->block block-id)))
                        (or (get-water-cube?~ block)
                            (get-opaque-cube?~ block))))
                    
                    (define (compute-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                      (let ((lighting (make-f32vector 4)))
                        (effective-light-ref! (+ i ax) (+ j ay) (+ k az) lighting)
                        (effective-light-ref! (+ i bx) (+ j by) (+ k bz) lighting)
                        (effective-light-ref! (+ i cx) (+ j cy) (+ k cz) lighting)
                        (effective-light-ref! (+ i dx) (+ j dy) (+ k dz) lighting)
                        (adjust-lighting lighting 0 shade)
                        (adjust-lighting lighting 1 shade)
                        lighting))
                    
                    (define (compute-inner-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                      (let ((lighting (make-f32vector 4)))
                        (inner-light-ref! (+ i ax) (+ j ay) (+ k az) lighting)
                        (inner-light-ref! (+ i bx) (+ j by) (+ k bz) lighting)
                        (inner-light-ref! (+ i cx) (+ j cy) (+ k cz) lighting)
                        (inner-light-ref! (+ i dx) (+ j dy) (+ k dz) lighting)
                        (adjust-lighting lighting 0 shade)
                        (adjust-lighting lighting 1 shade)
                        lighting))
                    
                    (define (add-texture-element proc)
                      (proc region sector texture-element-adder))
                    
                    (define (texture-element-adder element)
                      (set! texture-elements (cons element texture-elements)))
                    
                    (reset-mesher~ opaque-rendering)
                    (reset-mesher~ transparent-rendering)
                    (reset-mesher~ coverage-rendering)
                    (reset-mesher~ water-rendering)
                    (reset-mesher~ wet-rendering)
                    (reset-mesher~ multitexture-rendering)
                    (when debug-categories?
                      (reset-category-renderings))
                    
                    ;; inner
                    (loop (for j from 1 below 15)
                          (loop (for k from 1 below 15)
                                (loop (for i from 1 below 15)
                                      (let ((block-id (local-block-ref i j k)))
                                        (when (/= block-id air-id)
                                          (let ((x (+ section-x i))
                                                (y (+ section-y j))
                                                (z (+ section-z k))
                                                (block (blockid->block block-id)))
                                            (let ((x (fl& (+ block-radius (cast <fl> x))))
                                                  (y (fl& (+ block-radius (cast <fl> y))))
                                                  (z (fl& (+ block-radius (cast <fl> z))))
                                                  (uv (block-texture-coordinates block))
                                                  (lighting compute-lighting @generic-lighting-can-go-outside-local-cube compute-inner-lighting)
                                                  (rendering (cache-rendering~ block))
                                                  (category (get-category~ block))
                                                  (generate (get-generate~ block)))
                                              (cond (generate
                                                     (generate block-id (local-data-ref i j k) i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element effective-block-ref effective-data-ref))
                                                    ((get-opaque-cube?~ block)
                                                     (add-inner-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering category block-id add-face))
                                                    ((get-water-cube?~ block)
                                                     (add-inner-water-cube i j k x y z uv uv uv uv uv uv lighting rendering category block-id add-face))
                                                    (else
                                                     (add-cross-faces i j k x y z uv lighting rendering category block-id add-face))))))))))
                    
                    ;; outer
                    (let ()
                      (define (add i <fx> j <fx> k <fx>)
                        (let ((block-id (local-block-ref i j k)))
                          (when (/= block-id air-id)
                            (let ((x (+ section-x i))
                                  (y (+ section-y j))
                                  (z (+ section-z k))
                                  (block (blockid->block block-id)))
                              (let ((x (fl& (+ block-radius (cast <fl> x))))
                                    (y (fl& (+ block-radius (cast <fl> y))))
                                    (z (fl& (+ block-radius (cast <fl> z))))
                                    (uv (block-texture-coordinates block))
                                    (lighting compute-lighting)
                                    (rendering (cache-rendering~ block))
                                    (category (get-category~ block))
                                    (generate (get-generate~ block)))
                                (cond (generate
                                       (generate block-id (local-data-ref i j k) i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element effective-block-ref effective-data-ref))
                                      ((get-opaque-cube?~ block)
                                       (add-opaque-cube i j k x y z uv uv uv uv uv uv lighting rendering category block-id add-face))
                                      ((get-water-cube?~ block)
                                       (add-water-cube i j k x y z uv uv uv uv uv uv lighting rendering category block-id add-face))
                                      (else
                                       (add-cross-faces i j k x y z uv lighting rendering category block-id add-face))))))))
                      
                      ;; left
                      (let ((i 0))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; right
                      (let ((i 15))
                        (loop (for j from 0 to 15)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; bottom
                      (let ((j 0))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; top
                      (let ((j 15))
                        (loop (for i from 1 to 14)
                              (loop (for k from 0 to 15)
                                    (add i j k))))
                      ;; back
                      (let ((k 0))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k))))
                      ;; front
                      (let ((k 15))
                        (loop (for i from 1 to 14)
                              (loop (for j from 1 to 14)
                                    (add i j k)))))
                    (case what
                      ((physical)
                       (when (eq? self (current-zone))
                         (iterate-table areas
                           (lambda (area <Area> polygons)
                             (add-polygons~ area #f polygons #f)))))
                      ((render)
                       (let ((opaque (conclude-rendering opaque-rendering))
                             (transparent (conclude-rendering transparent-rendering))
                             (coverage (conclude-rendering coverage-rendering))
                             (water (conclude-rendering water-rendering))
                             (wet (conclude-rendering wet-rendering))
                             (multitexture (conclude-rendering multitexture-rendering))
                             (categorized (and debug-categories? (conclude-category-renderings))))
                         (write-render-event
                           (lambda ()
                             (define (prepare-mesh info)
                               (when info
                                 (bind (material triangles vertices neighbors lightmap) info
                                   (setup-mesh~ sector)
                                   (let ((mesh (get-mesh~ sector)))
                                     (allege mesh
                                       (fill-vertices/neighbors~ sector mesh triangles vertices neighbors)
                                       (fill-lightmap~ sector mesh triangles lightmap)
                                       (setup-array~ mesh))))))
                             
                             (define (prepare-other-mesh info)
                               (when info
                                 (bind (material triangles vertices neighbors lightmap) info
                                   (setup-other-meshes~ sector)
                                   (let ((mesh (new Mesh material: material)))
                                     (let ((material (get-material~ mesh)))
                                       (table-set! (allege (get-other-meshes~ sector)) material mesh)
                                       (fill-vertices/neighbors~ sector mesh triangles vertices neighbors)
                                       (fill-lightmap~ sector mesh triangles lightmap)
                                       (setup-array~ mesh))))))
                             
                             (define (prepare-categorized-meshes)
                               (when (not-null? categorized)
                                 (for-each (lambda (info)
                                             (bind (category material triangles vertices neighbors lightmap) info
                                               (setup-categorized-meshes~ sector)
                                               (let ((mesh (new Mesh material: material)))
                                                 (let ((material (get-material~ mesh)))
                                                   (table-set! (allege (get-categorized-meshes~ sector)) material mesh)
                                                   (fill-vertices/neighbors~ sector mesh triangles vertices neighbors)
                                                   (fill-lightmap~ sector mesh triangles lightmap)
                                                   (setup-array~ mesh)))))
                                           categorized)))
                             
                             (when (eq? self (current-zone))
                               (free-mesh~ sector)
                               (prepare-mesh opaque)
                               (prepare-other-mesh transparent)
                               (prepare-other-mesh coverage)
                               (prepare-other-mesh water)
                               (prepare-other-mesh wet)
                               (prepare-other-mesh multitexture)
                               (when debug-categories?
                                 (prepare-categorized-meshes))
                               (set-vertices-uptodate?~ sector #t)
                               (set-lightmap-uptodate?~ sector #t)
                               ;; quick test
                               (when (eq? what 'render)
                                 (refcount-increase~ section))
                               (set-section~ sector section)
                               (when (not-null? texture-elements)
                                 (set-texture-elements~ sector texture-elements))
                               (sector-generated sector)
                               (generate-done)))))))
                    (checkpoint 9)))))))))))
  
  
  (method virtual (sector-generated sector)
    )
  
  
  ;;;
  ;;;; Spawn
  ;;;
  
  
  (definition spawner-list
    #f)
  
  
  (method override (spawn-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (if (not spawn?)
              (task-sleep +infinity exit)
            (let ((sector #f))
              (let (iter (previous (current-seconds)))
                (let ((time (current-seconds)))
                  (let ((elapse (- time previous)))
                    (unless (get-paused?~ history)
                      (with-task-mutex
                        (lambda ()
                          (unless (task-stopping?)
                            (trace-task spawn "W")
                            (let ((current-sector (element-sector (current-me))))
                              (let ((current-spawners (if (eq? sector current-sector)
                                                          spawner-list
                                                        (find-spawners current-sector spawner-list))))
                                (set! sector current-sector)
                                (set! spawner-list current-spawners)
                                (tick-spawn elapse current-spawners)))))))
                    (let ((duration (- (current-seconds) time)))
                      (task-sleep (- spawn-rate duration) exit))
                    (iter time))))))))))
  
  
  (method (tick-spawn elapse spawners)
    (site (spawn on?: #t)
      (when (world-setting 'minecraft.spawn-enemies? #t)
        (spawn-enemies elapse spawners))))
  
  
  (method (remove-enemy coords)
    (let ((spawner (find-object (lambda (spawner)
                                  (when (equal? (get-coordinates~ spawner) coords)
                                    spawner))
                                (or spawner-list '()))))
      (when spawner
        (set-enemy-count~ spawner (- (get-enemy-count~ spawner) 1)))))
  
  
  (method (find-spawners sector old-spawners)
    (let ((queue (new-queue)))
      (iterate-sector-neighbors sector 1
        (lambda (sector)
          (sector-iterate-blocks sector '(52)
            (lambda (index)
              ;; spawn faster the first time to compensate for not having natural spawning
              (let ((coords (index->coordinates index)))
                (let ((spawner (find-object (lambda (spawner)
                                              (when (equal? (get-coordinates~ spawner) coords)
                                                spawner))
                                            (or old-spawners '()))))
                  (if spawner
                      (enqueue queue spawner)
                    (enqueue queue (new Spawner sector 0. (random-between 5. 20.) 0 coords)))))))))
      (queue-list queue)))
  
  
  (method (spawn-enemies elapse spawners)
    (let ((world (current-world)))
      (for-each (lambda (spawner)
                  (let ((sector (get-sector~ spawner))
                        (time-since-last (get-time-since-last~ spawner))
                        (time-for-spawn (get-time-for-spawn~ spawner))
                        (enemy-count (get-enemy-count~ spawner))
                        (coordinates (get-coordinates~ spawner)))
                    (bind (i j k) coordinates
                      (call-with-sector sector i j k
                        (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                          (define (find-spawning-places)
                            (let ((queue (new-queue)))
                              (loop (for a from (- i 4) to (+ i 4))
                                    (loop (for c from (- k 4) to (+ k 4))
                                          (loop (for b from (- j 1) to (+ j 1))
                                                (with-field a b c
                                                  (lambda (section index)
                                                    (when (and section (= (block-ref section index) 0) (< (blocklight-ref section index) 8))
                                                      (enqueue queue (section/index->position section index))))))))
                              (queue-list queue)))
                          
                          (let ((time-now (+ time-since-last elapse)))
                            (if (and (> time-now time-for-spawn))
                                (let ((possible-spawn-places (find-spawning-places)))
                                  (loop (for number from 0 below (random-element '(2 3 4)))
                                        (unless (or (null? possible-spawn-places) (>= enemy-count 10))
                                          (let ((position (random-element possible-spawn-places)))
                                            (set! possible-spawn-places (remove! position possible-spawn-places))
                                            (let ((enemy (new (random-element (list Spider Wolf Jumper)) parent: world position: position)))
                                              (set-spawner-coordinates~ enemy (list i j k))
                                              (add-element enemy)
                                              (increase! enemy-count 1)))))
                                  (set-time-since-last~ spawner 0.)
                                  (set-time-for-spawn~ spawner (random-between 10. 40.))
                                  (set-enemy-count~ spawner enemy-count))
                              (set-time-since-last~ spawner time-now))))))))
                spawners)))
  
  
  ;;;
  ;;;; Redstone
  ;;;
  
  
  (method override (redstone-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (if (not redstone?)
              (task-sleep +infinity exit)
            (let (iter (previous (current-seconds)))
              (let ((time (current-seconds)))
                (let ((elapse (- time previous)))
                  (unless (get-paused?~ history)
                    (with-task-mutex
                      (lambda ()
                        (unless (task-stopping?)
                          (trace-task redstone "R")
                          (let ((current-repeaters (get-repeaters~ (current-game))))
                            (unless (null? current-repeaters)
                              (set-repeaters~ (current-game) '())
                              (tick-repeaters elapse current-repeaters)))))))
                  (let ((duration (- (current-seconds) time)))
                    (task-sleep (- redstone-rate duration) exit))
                  (iter time)))))))))
  
  
  (method (tick-repeaters elapse repeaters)
    (site (redstone on?: #t)
      (power-repeaters elapse repeaters)))
  
  
  (method (power-repeaters elapse repeater-list)
    (let ((world (current-world))
          (current-sector (element-sector (current-me)))
          (game (current-game)))
      (updating-sectors~ (current-zone)
        (lambda (add-sector)
          (let (iter (repeaters repeater-list))
            (unless (null? repeaters)
              (let ((repeater (car repeaters)))
                (let ((sector (get-sector~ repeater))
                      (i (get-i~ repeater))
                      (j (get-j~ repeater))
                      (k (get-k~ repeater))
                      (power? (get-power?~ repeater))
                      (delay (get-delay~ repeater)))
                  (if (< delay 0)
                      (call-with-sector sector i j k
                        (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                          (case block-id
                            ((93) (when power? (redstone-update~ (current-game) sector i j k block-id 'activate add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
                            ((94) (unless power? (redstone-update~ (current-game) sector i j k block-id 'deactivate add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))
                            ((70 72 77 143) (redstone-update~ (current-game) sector i j k block-id 'deactivate add-sector with-field block-ref block-set! data-ref data-set! powerlevel-ref powerlevel-set! blocklight-ref blocklight-set!)))))
                    (begin
                      (set-delay~ repeater (- delay 1))
                      (set-repeaters~ game (cons repeater (get-repeaters~ game)))))))
              (iter (cdr repeaters)))))
        delay-update?: #t)))
  
  
  ;;;
  ;;;; Lava
  ;;;
  
  
  (definition can-flow-in
    '(0 6 27 28 30 31 32 37 38 39 40 50 51 55 59 66 69 75 76 77 78 83 93 94 104 105 106 111 127 131 132 140 141 142 143))
  
  
  (method override (lava-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history))
          (first-call? #t))
      (with-task task
        (lambda (exit)
          (if (not lava?)
              (task-sleep +infinity exit)
            (let ((lava-blocks (new-queue)))
              (let (iter (previous (current-seconds)))
                (let ((time (current-seconds)))
                  (let ((elapse (- time previous)))
                    (unless (get-paused?~ history)
                      (with-task-mutex
                        (lambda ()
                          (unless (task-stopping?)
                            (trace-task lava "L")
                            (if first-call?
                                (begin
                                  (set! first-call? #f)
                                  (set! lava-blocks (find-flowing-lava (element-sector (current-me)))))
                              (begin
                                (set! lava-blocks (merge-queues lava-blocks (get-lava-blocks~ (current-game))))
                                (set-lava-blocks~ (current-game) (new-queue))))
                            (unless (queue-empty? lava-blocks)
                              (set! lava-blocks (tick-lava elapse lava-blocks)))))))
                    (let ((duration (- (current-seconds) time)))
                      (task-sleep (- lava-rate duration) exit))
                    (iter time))))))))))
  
  
  (method (tick-lava elapse lava-blocks)
    (site (lava on?: #t)
      (lava-flow elapse lava-blocks)))
  
  
  (method (find-flowing-lava sector)
    (let ((queue (new-queue)))
      (iterate-sector-neighbors sector 1
        (lambda (sector)
          (sector-iterate-blocks sector '(10)
            (lambda (index)
              (enqueue queue (cons sector (index->coordinates index)))))))
      queue))
  
  
  (method (merge-queues q1 q2)
    (for-each (lambda (element)
                (enqueue q1 element))
              (queue-list q2))
    q1)
  
  
  (method (lava-flow elapse lava-blocks)
    (let ((world (current-world))
          (new-lava-blocks (new-queue)))
      (updating-sectors~ (current-zone)
        (lambda (add-sector)
          (let (iter)
            (unless (queue-empty? lava-blocks)
              (bind (sector i j k) (dequeue lava-blocks)
                (call-with-sector sector i j k
                  (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                    (with-field i j k
                      (lambda (section index)
                        (when (and section (memq? (block-ref section index) '(10 11)))
                          (let ((data (data-ref section index)))
                            (define (get-inward-flow i j k)
                              (define (side-flow side-i side-j side-k)
                                (with-field side-i side-j side-k
                                  (lambda (section index)
                                    (if (and section (memq? (block-ref section index) '(10 11)))
                                        (let ((data (data-ref section index)))
                                          (cond ((< data 6)
                                                 (+ data 2))
                                                ((= data 6)
                                                 7)
                                                ((> data 6)
                                                 (with-field side-i (- side-j 1) side-k
                                                   (lambda (section index)
                                                     (if (and section (memq? (block-ref section index) '(10 11)))
                                                         7
                                                       2))))))
                                      7))))
                              
                              (define (top-flow)
                                (with-field i (+ j 1) k
                                  (lambda (section index)
                                    (if (and section (memq? (block-ref section index) '(10 11)))
                                        (let ((data (data-ref section index)))
                                          (if (< data 8)
                                              (+ data 8)
                                            data))
                                      0))))
                              
                              (max
                                (top-flow)
                                (min
                                  (side-flow (+ i 1) j k)
                                  (side-flow (- i 1) j k)
                                  (side-flow i j (+ k 1))
                                  (side-flow i j (- k 1)))))
                            
                            (define (flow i j k data)
                              (with-field i j k
                                (lambda (section1 index1)
                                  (define (flow-direction side-i side-j side-k)
                                    (unless (= data 6)
                                      (with-field (+ i side-i) (+ j side-j) (+ k side-k)
                                        (lambda (section index)
                                          (when section
                                            (with-field (+ (* side-i 2) i) (+ (* side-j 2) j) (+ (* side-k 2) k)
                                              (lambda (section2 index2)
                                                (when section2
                                                  (let ((block (block-ref section2 index2))
                                                        (data-id (data-ref section2 index2)))
                                                    (if (memq? (block-ref section index) '(8 9))
                                                        (begin
                                                          (data-set! section1 index1 0)
                                                          (block-set! section1 index1 (if (= data 0) 49 4)))
                                                      (if (and (memq? block '(8 9)) (not (= (block-ref section index) 4)))
                                                          (begin
                                                            (data-set! section index 0)
                                                            (block-set! section index 4)
                                                            (enqueue-sector/coordinates new-lava-blocks (get-sector~ section1) (index->coordinates index1) with-field))
                                                        (when (or (memq? (block-ref section index) can-flow-in) (and (memq? (block-ref section index) '(10 11)) (> (data-ref section index) (modulo data 8)) (< (data-ref section index) 8)))
                                                          (block-set! section index 10)
                                                          (data-set! section index (if (> data 7) 2 (+ data 2)))
                                                          (add-sector (get-sector~ section))
                                                          (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (index->coordinates index) with-field)))))))))))))
                                  
                                  (when section1
                                    (when (memq? (block-ref section1 index1) '(10 11))
                                      (with-field i (- j 1) k
                                        (lambda (section index)
                                          (let ((block (block-ref section index)))
                                            (if (memq? block '(8 9))
                                                (begin
                                                  (data-set! section index 0)
                                                  (enqueue-sector/coordinates new-lava-blocks (get-sector~ section1) (index->coordinates index1) with-field)
                                                  (block-set! section index (if (= (data-ref section index) 0) 1 4)))
                                              (if (memq? block (cons 10 (cons 11 can-flow-in)))
                                                  (begin
                                                    (block-set! section index 10)
                                                    (data-set! section index (if (> data 7) data (+ data 8)))
                                                    (add-sector (get-sector~ section))
                                                    (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (index->coordinates index) with-field)
                                                    (when (= data 0)
                                                      (flow-direction -1  0  0)
                                                      (flow-direction  1  0  0)
                                                      (flow-direction  0  0 -1)
                                                      (flow-direction  0  0  1)))
                                                (begin
                                                  (flow-direction -1  0  0)
                                                  (flow-direction  1  0  0)
                                                  (flow-direction  0  0 -1)
                                                  (flow-direction  0  0  1))))))))))))
                            
                            (unless (= data 0)
                              (let ((level-set (get-inward-flow i j k)))
                                (if (= level-set 7)
                                    (begin
                                      (block-set! section index 0)
                                      (data-set! section index 0)
                                      (with-field i (- j 1) k
                                        (lambda (section index)
                                          (add-sector (get-sector~ section))
                                          (when (memq? (block-ref section index) '(10 11))
                                            (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (index->coordinates index) with-field)))))
                                  (when (/= level-set data)
                                    (data-set! section index level-set)))
                                (when (/= level-set data)
                                  (bind (i j k) (index->coordinates index)
                                    (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (list (- i 1) j k) with-field)
                                    (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (list (+ i 1) j k) with-field)
                                    (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (list i j (- k 1)) with-field)
                                    (enqueue-sector/coordinates new-lava-blocks (get-sector~ section) (list i j (+ k 1)) with-field)))))
                            (flow i j k (data-ref section index))))
                        (add-sector (get-sector~ section)))))))
              (iter))))
        delay-update?: #t)
      new-lava-blocks))
  
  
  ;;;
  ;;;; Water
  ;;;
  
  
  (method override (water-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history))
          (first-call? #t))
      (with-task task
        (lambda (exit)
          (if (not water?)
              (task-sleep +infinity exit)
            (let ((water-blocks (new-queue)))
              (let (iter (previous (current-seconds)))
                (let ((time (current-seconds)))
                  (let ((elapse (- time previous)))
                    (unless (get-paused?~ history)
                      (with-task-mutex
                        (lambda ()
                          (unless (task-stopping?)
                            (trace-task water "L")
                            (if first-call?
                                (begin
                                  (set! first-call? #f)
                                  (set! water-blocks (find-flowing-water (element-sector (current-me)))))
                              (begin
                                (set! water-blocks (merge-queues water-blocks (get-water-blocks~ (current-game))))
                                (set-water-blocks~ (current-game) (new-queue))))
                            (unless (queue-empty? water-blocks)
                              (set! water-blocks (tick-water elapse water-blocks)))))))
                    (let ((duration (- (current-seconds) time)))
                      (task-sleep (- water-rate duration) exit))
                    (iter time))))))))))
  
  
  (method (tick-water elapse water-blocks)
    (site (water on?: #t)
      (water-flow elapse water-blocks)))
  
  
  (method (find-flowing-water sector)
    (let ((queue (new-queue)))
      (iterate-sector-neighbors sector 1
        (lambda (sector)
          (sector-iterate-blocks sector '(8)
            (lambda (index)
              (enqueue queue (cons sector (index->coordinates index)))))))
      queue))
  
  
  (method (water-flow elapse water-blocks)
    (let ((world (current-world))
          (new-water-blocks (new-queue)))
      (updating-sectors~ (current-zone)
        (lambda (add-sector)
          (let (iter)
            (unless (queue-empty? water-blocks)
              (bind (sector i j k) (dequeue water-blocks)
                (call-with-sector sector i j k
                  (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
                    (with-field i j k
                      (lambda (section index)
                        (when section
                          (when (memq? (block-ref section index) '(8 9))
                            (let ((data (data-ref section index)))
                              (define (get-inward-flow i j k)
                                (define (side-flow side-i side-j side-k)
                                  (with-field side-i side-j side-k
                                    (lambda (section index)
                                      (if section
                                          (if (memq? (block-ref section index) '(8 9))
                                              (let ((data (data-ref section index)))
                                                (cond ((< data 7)
                                                       (+ data 1))
                                                      ((= data 7)
                                                       16)
                                                      ((> data 7)
                                                       (with-field side-i (- side-j 1) side-k
                                                         (lambda (section index)
                                                           (if (memq? (block-ref section index) '(8 9))
                                                               16
                                                             1))))))
                                            16)
                                        16))))
                                
                                (define (top-flow)
                                  (with-field i (+ j 1) k
                                    (lambda (section index)
                                      (if section
                                        (if (memq? (block-ref section index) '(8 9))
                                            (let ((data (data-ref section index)))
                                              (if (< data 8)
                                                  (+ data 8)
                                                data))
                                          #f)
                                        #f))))
                                
                                (or
                                  (top-flow)
                                  (min
                                    (side-flow (+ i 1) j k)
                                    (side-flow (- i 1) j k)
                                    (side-flow i j (+ k 1))
                                    (side-flow i j (- k 1)))))
                              
                              (define (flow i j k data)
                                (with-field i j k
                                  (lambda (section1 index1)
                                    (define (flow-direction side-i side-j side-k)
                                      (unless (= data 7)
                                        (with-field (+ i side-i) (+ j side-j) (+ k side-k)
                                          (lambda (section index)
                                            (when section
                                              (with-field (+ i (* side-i 2)) (+ j (* side-j 2)) (+ k (* side-k 2))
                                                (lambda (section2 index2)
                                                  (when section2
                                                    (let ((block2 (block-ref section2 index2))
                                                          (data2 (data-ref section2 index2))
                                                          (block (block-ref section index))
                                                          (data-id (data-ref section index)))
                                                      (if (memq? block '(10 11))
                                                          (begin
                                                            (block-set! section1 index1 4)
                                                            (data-set! section1 index1 0)
                                                            (add-sector (get-sector~ section1)))
                                                        (when (or (memq? block can-flow-in) (and (memq? block '(8 9)) (> data-id (modulo data 8)) (< data-id 8)))
                                                          (let ((lava? (memq? block2 '(10 11)))
                                                                (source? (= data2 0)))
                                                            (when (or (not lava?) (and lava? source?))
                                                              (block-set! section index 8)
                                                              (data-set! section index (if (> data 7) 1 (+ data 1)))
                                                              (add-sector (get-sector~ section))
                                                              (enqueue-sector/coordinates new-water-blocks (get-sector~ section) (index->coordinates index) with-field)
                                                              (when lava?
                                                                (data-set! section2 index2 0)
                                                                (block-set! section2 index2 49)
                                                                (add-sector (get-sector~ section2))
                                                                (enqueue-sector/coordinates new-water-blocks (get-sector~ section2) (index->coordinates index2) with-field)))
                                                            (when (and lava? (not source?))
                                                              (data-set! section index 0)
                                                              (block-set! section index 4)
                                                              (add-sector (get-sector~ section))
                                                              (enqueue-sector/coordinates new-water-blocks (get-sector~ section1) (index->coordinates index1) with-field))))))))))))))
                                    
                                    (when section1
                                      (when (memq? (block-ref section1 index1) '(8 9))
                                        (with-field i (- j 1) k
                                          (lambda (section index)
                                            (when section
                                              (let ((block (block-ref section index)))
                                                (if (memq? block '(10 11))
                                                    (begin
                                                      (enqueue-sector/coordinates new-water-blocks (get-sector~ section1) (index->coordinates index1) with-field)
                                                      (block-set! section index (if (= (data-ref section index) 0) 49 4))
                                                      (data-set! section index 0))
                                                  (if (memq? block (cons 8 (cons 9 can-flow-in)))
                                                      (begin
                                                        (block-set! section index 8)
                                                        (data-set! section index (if (> data 7) data (+ data 8)))
                                                        (add-sector (get-sector~ section))
                                                        (enqueue-sector/coordinates new-water-blocks (get-sector~ section) (index->coordinates index) with-field)
                                                        (when (= data 0)
                                                          (flow-direction -1  0  0)
                                                          (flow-direction  1  0  0)
                                                          (flow-direction  0  0 -1)
                                                          (flow-direction  0  0  1)))
                                                    (begin
                                                      (flow-direction -1  0  0)
                                                      (flow-direction  1  0  0)
                                                      (flow-direction  0  0 -1)
                                                      (flow-direction  0  0  1)))))))))))))
                              
                              (unless (= data 0)
                                (let ((level-set (get-inward-flow i j k)))
                                  (if (= level-set 16)
                                      (begin
                                        (block-set! section index 0)
                                        (data-set! section index 0)
                                        (with-field i (- j 1) k
                                          (lambda (section index)
                                            (when section
                                              (add-sector (get-sector~ section))
                                              (when (memq? (block-ref section index) '(8 9))
                                                (enqueue-sector/coordinates new-water-blocks (get-sector~ section) (index->coordinates index) with-field))))))
                                    (when (/= level-set data)
                                      (data-set! section index level-set)))
                                  (when (/= level-set data)
                                    (bind (i j k) (index->coordinates index)
                                      (enqueue-sector/coordinates new-water-blocks (get-sector~ section) (list (- i 1) j k) with-field)
                                      (enqueue-sector/coordinates new-water-blocks (get-sector~ section) (list (+ i 1) j k) with-field)
                                      (enqueue-sector/coordinates new-water-blocks (get-sector~ section) (list i j (- k 1)) with-field)
                                      (enqueue-sector/coordinates new-water-blocks (get-sector~ section) (list i j (+ k 1)) with-field)))))
                              (flow i j k (data-ref section index))))
                          (add-sector (get-sector~ section))))))))
              (iter))))
        delay-update?: #t)
      new-water-blocks))
  
  
  ;;;
  ;;;; Model
  ;;;
  
  
  (method (minecraft-blocks)
    blocks)
  
  
  (method (minecraft-blockids)
    blockids)
  
  
  (method (minecraft-block-class)
    Minecraft-Block)
  
  
  (method (minecraft-find-model name)
    (find-minecraft-model name))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method override (evaluate-hook forms syntax str container line col)
    (let ((ids (collect (lambda (form)
                          (when (and (pair? form) (eq? (car form) 'define-minecraft-block))
                            (third form)))
                        forms)))
      (cond ((not-null? ids)
             (updating-sectors
               (lambda (add-sector)
                 (finding-visual-blocks ids
                   add-sector)
                 (finding-physical-blocks ids
                   (lambda (area)
                     (add-sector (area-sector area)))))))
            ((search container "world/external/minecraft")
             (updating-sectors
               (lambda (add-sector)
                 (add-sector (element-sector (current-me)))))))))
  
  
  (method (find-visual-blocks ids)
    (let ((zone (current-zone))
          (queue (new-queue)))
      (iterate-sectors~ zone
        (lambda (index sector)
          (sector-iterate-blocks sector ids
            (lambda (found)
              (enqueue queue (cons sector (index->coordinates found)))))))
      (queue-list queue)))
  
  
  (method (finding-visual-blocks ids proc)
    (let ((zone (current-zone)))
      (iterate-sectors~ zone
        (lambda (index sector)
          (when (sector-contains-blocks? sector ids)
            (proc sector))))))
  
  
  (method (sector-contains-blocks? sector ids)
    (continuation-capture
      (lambda (found)
        (sector-iterate-blocks sector ids
          (lambda (ignore)
            (continuation-return found #t)))
        #f)))
  
  
  (method (sector-iterate-blocks sector ids proc)
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region sector-x sector-y sector-z)))
          (when region
            (let ((section (get-section~ region 'physical sector-x sector-y sector-z)))
              (when section
                (let ((blocks (get-blocks~ section)))
                  (for-each (lambda (id)
                              (let (iter (pos 0))
                                (let ((found (u8vector-find id blocks (u8vector-length blocks) pos)))
                                  (when found
                                    (proc found)
                                    (iter (+ found 1))))))
                            ids)))))))))
  
  
  (method (finding-physical-blocks ids proc)
    (let ((zone (current-zone)))
      (iterate-areas~ zone
        (lambda (index area)
          (iterate-polygons~ area
            (lambda (elem polygons offset)
              (let ((data1 (f64vector-ref polygons (+ offset 16))))
                (when (and (/= data1 0.) (memq? (fxround data1) ids))
                  (proc area)))))))))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (proclaim (not warn optimizations))
  
  
  (method override (target-update target face face-rank poly vert)
    (define (center-info title center (poly #f))
      (let ((sector (position-sector center))
            (x (fxfloor (vertex-x center)))
            (y (fxfloor (vertex-y center)))
            (z (fxfloor (vertex-z center))))
        (let ((block (vector x y z))
              (sector-index (get-index~ sector)))
          (let ((sector-x (vector-ref sector-index 0))
                (sector-y (vector-ref sector-index 1))
                (sector-z (vector-ref sector-index 2)))
            (let ((region (sector-region sector-x sector-y sector-z)))
              (when region
                (let ((section (get-section~ region 'physical sector-x sector-y sector-z))
                      (cache-uninitialized 65535))
                  (when section
                    (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                          (sections <vector> (make-vector 27 #t))
                          (cache <u16vector> (initialize-block-cache cache-uninitialized))
                          (blocks (get-blocks~ section))
                          (data (get-data~ section))
                          (blocklight (get-blocklight~ section))
                          (skylight (get-skylight~ section))
                          (powerlevel (get-powerlevels~ section)))
                      (define (section-ref a <fx> b <fx> c <fx>) <Minecraft-Section+>
                        (if (and (= a 0)
                                 (= b 0)
                                 (= c 0))
                            section
                          (let ((index (section-index a b c)))
                            (let ((section (vector-ref sections index)))
                              (if (neq? section #t)
                                  section
                                (let ((x (+ sector-x a))
                                      (y (+ sector-y b))
                                      (z (+ sector-z c)))
                                  (let ((region (sector-region x y z)))
                                    (let ((section (and region (get-section~ (cast <Minecraft-Region> region) 'physical x y z))))
                                      (vector-set! sections index section)
                                      section))))))))
                      
                      (define (section-index a <fx> b <fx> c <fx>) <fx>
                        (+ (* b 9) (* c 3) a 13))
                      
                      (define (local-index i <fx> j <fx> k <fx>) <fx>
                        (+ (* j 256) (* k 16) i))
                      
                      (define (effective-index i <fx> j <fx> k <fx>) <fx>
                        (* (+ (* j 324) (* k 18) i 343) 4))
                      
                      (define (blocks-get section <Minecraft-Section>) <u8vector>
                        (get-blocks~ section))
                      
                      (define (blocklight-get section <Minecraft-Section>) <u8vector>
                        (get-blocklight~ section))
                      
                      (define (blocklight-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref blocklight (local-index i j k)))
                      
                      (define (skylight-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref skylight (local-index i j k)))
                      
                      (define (powerlevel-ref i <fx> j <fx> k <fx>) <fx>
                        (u8vector-ref powerlevel (local-index i j k)))
                      
                      (define (local-block-ref i <fx> j <fx> k <fx>)
                        (u8vector-ref blocks (local-index i j k)))
                      
                      (define (local-data-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref data (local-index i j k)))
                      
                      (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                        (let ((index (effective-index i j k)))
                          (let ((value (u16vector-ref cache index)))
                            (if (/= value cache-uninitialized)
                                value
                              (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                                (u16vector-set! cache index value)
                                value)))))
                      
                      (define (effective-light-ref shade <fl> i <fx> j <fx> k <fx>) <fx>
                        (field-ref i j k blocklight-get u4vector-ref 0 0))
                      
                      (define (u4vector-ref field <u8vector> index <fx>) <fx>
                        (let ((byte (u8vector-ref field (quotient index 2))))
                          (if (even? index)
                              (bitwise-and byte #x0F)
                            (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                      
                      (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                        (define (bind-i a <fx> i <fx>)
                          (define (bind-j b <fx> j <fx>)
                            (define (bind-k c <fx> k <fx>)
                              (let ((section (section-ref a b c)))
                                (if (not section)
                                    (if (and bottom-section? (= b -1)) bottom empty)
                                  (let ((field (get-field section)))
                                    (if (not field)
                                        (if (and bottom-section? (= b -1)) bottom empty)
                                      (ref field (local-index i j k)))))))
                            
                            (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                  ((> k 15) (bind-k 1 (- k 16)))
                                  (else (bind-k 0 k))))
                          
                          (cond ((< j 0) (bind-j -1 (+ 16 j)))
                                ((> j 15) (bind-j 1 (- j 16)))
                                (else (bind-j 0 j))))
                        
                        (cond ((< i 0) (bind-i -1 (+ 16 i)))
                              ((> i 15) (bind-i 1 (- i 16)))
                              (else (bind-i 0 i))))
                      
                      (define (compute-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                        (format "{a} {a} {a} {a}"
                                (effective-light-ref shade (+ i ax) (+ j ay) (+ k az))
                                (effective-light-ref shade (+ i bx) (+ j by) (+ k bz))
                                (effective-light-ref shade (+ i cx) (+ j cy) (+ k cz))
                                (effective-light-ref shade (+ i dx) (+ j dy) (+ k dz))))
                      
                      (define (ambient-light i <fx> j <fx> k <fx> vert)
                        (let ((origin (vertex- (vertex-& vert (vertex& (cast <fl> x) (cast <fl> y) (cast <fl> z))) (vertex& .5 .5 .5)))
                              (normal (get-normal~ poly)))
                          (generic-lighting i j k origin normal compute-lighting no-shade)))
                      
                      (define (block-info i <fx> j <fx> k <fx>)
                        (let ((id (local-block-ref i j k))
                              (data (local-data-ref i j k))
                              (blocklight (blocklight-ref i j k))
                              (skylight (skylight-ref i j k))
                              (powerlevel (powerlevel-ref i j k)))
                          (let ((block (blockid->block id)))
                            (append (list (cons title (get-name~ block))
                                          (cons "id" id)
                                          (cons "data" data)
                                          (cons "block light" blocklight)
                                          (cons "sky light" skylight)
                                          (cons "power level" powerlevel)
                                          (cons "sector" (format "{a} {a} {a}" sector-x sector-y sector-z))
                                          (cons "coordinates" (format "{a} {a} {a}" i j k)))
                                    (if poly
                                        (list (cons "global" (present-vertex (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly))))
                                              (cons "ambient" (ambient-light i j k vert)))
                                      '())))))
                      
                      (define (present-vertex vert)
                        (format "{r precision: 1}, {r precision: 1}, {r precision: 1}"
                                (vertex-x vert)
                                (vertex-y vert)
                                (vertex-z vert)))
                      
                      (let ((i (- x (* sector-x 16)))
                            (j (- y (* sector-y 16)))
                            (k (- z (* sector-z 16))))
                        (block-info i j k)))))))))))
    
    (define (update-info)
      (if (not poly)
          (begin
            (unregister-info 'block)
            (unregister-info 'fore)
            (let ((eye (get-position~ (current-camera))))
              (let ((info (center-info "Eye" eye)))
                (if (not info)
                    (unregister-info 'eye)
                  (register-info 'eye
                    (lambda (add-section add-info)
                      (let ((section (add-section "Eye")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info))))))))
        (let ((game (current-game)))
          (with-polygon-interaction~ game poly
            (lambda (poly block fore)
              (let ((info (center-info "Block" block poly)))
                (register-info 'block
                  (lambda (add-section add-info)
                    (let ((section (add-section "Block")))
                      (for-each (lambda (info)
                                  (add-info section (car info) (cdr info)))
                                info)))))
              (let ((info (center-info "Fore" fore)))
                (if (not info)
                    (unregister-info 'fore)
                  (register-info 'fore
                    (lambda (add-section add-info)
                      (let ((section (add-section "Fore")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info)))))))))
        (unregister-info 'eye)))
    
    (mutex-lock! generate-mutex)
    (update-info)
    (mutex-unlock! generate-mutex))
  
  
  (proclaim (warn optimizations))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (call-with-position pos <f64vector> proc)
    (let ((sector (position-sector pos))
          (x (fxfloor (vertex-x pos)))
          (y (fxfloor (vertex-y pos)))
          (z (fxfloor (vertex-z pos))))
      (let ((sector-index (get-index~ sector)))
        (let ((sector-x <fx> (vector-ref sector-index 0))
              (sector-y <fx> (vector-ref sector-index 1))
              (sector-z <fx> (vector-ref sector-index 2)))
          (let ((i (- x (* sector-x 16)))
                (j (- y (* sector-y 16)))
                (k (- z (* sector-z 16))))
            (call-with-sector sector i j k proc))))))
  
  
  (method (call-with-sector sector i j k proc)
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region sector-x sector-y sector-z)))
          (let ((region-x (get-x~ region))
                (region-z (get-z~ region))
                (section (get-section~ region 'physical sector-x sector-y sector-z))
                (chunk-index (chunk-index~ region sector-x sector-z)))
            (when section
              (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                    (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                    (section-y (* sector-y 16))
                    (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                    (sections <vector> (make-vector 27 #t))
                    (blocks (get-blocks~ section))
                    (data (get-data~ section))
                    (blocklight (get-blocklight~ section))
                    (skylight (get-skylight~ section)))
                (define (section-ref a <fx> b <fx> c <fx>) <Minecraft-Section+>
                  (if (and (= a 0)
                           (= b 0)
                           (= c 0))
                      section
                    ;; quick hack for test
                    (if (or (< a -1)
                            (< b -1)
                            (< c -1)
                            (> a 1)
                            (> b 1)
                            (> c 1))
                        (let ((x (+ sector-x a))
                              (y (+ sector-y b))
                              (z (+ sector-z c)))
                          (let ((region (sector-region x y z)))
                            (get-section~ (cast <Minecraft-Region> region) 'physical x y z)))
                      (let ((index (section-index a b c)))
                        (let ((section (vector-ref sections index)))
                          (if (neq? section #t)
                              section
                            (let ((x (+ sector-x a))
                                  (y (+ sector-y b))
                                  (z (+ sector-z c)))
                              (let ((region (sector-region x y z)))
                                (let ((section (and region (get-section~ (cast <Minecraft-Region> region) 'physical x y z))))
                                  (vector-set! sections index section)
                                  section)))))))))
                
                (define (section-index a <fx> b <fx> c <fx>) <fx>
                  (+ (* b 9) (* c 3) a 13))
                
                (define (local-index i <fx> j <fx> k <fx>) <fx>
                  (+ (* j 256) (* k 16) i))
                
                (define (block-ref section local-index <fx>) <fx>
                  (u8vector-ref (get-blocks~ section) local-index))
                
                (define (block-set! section local-index <fx> block-id <fx>)
                  (u8vector-set! (get-blocks~ section) local-index block-id))
                
                (define (data-ref section local-index <fx>) <fx>
                  (u4vector-ref (get-data~ section) local-index))
                
                (define (data-set! section local-index <fx> data-id <fx>)
                  (u4vector-set! (get-data~ section) local-index data-id))
                
                (define (blocklight-ref section local-index <fx>) <fx>
                  (u4vector-ref (get-blocklight~ section) local-index))
                
                (define (blocklight-set! section local-index <fx> blocklight <fx>)
                  (u4vector-set! (get-blocklight~ section) local-index blocklight))
                
                (define (skylight-ref section local-index <fx>) <fx>
                  (u4vector-ref (get-skylight~ section) local-index))
                
                (define (skylight-set! section local-index <fx> skylight <fx>)
                  (u4vector-set! (get-skylight~ section) local-index skylight))
                
                (define (powerlevel-ref section local-index <fx>) <fx>
                  (u8vector-ref (get-powerlevels~ section) local-index))
                
                (define (powerlevel-set! section local-index <fx> level <fx>)
                  (u8vector-set! (get-powerlevels~ section) local-index level))
                
                (define (u4vector-ref field <u8vector> index <fx>) <fx>
                  (let ((byte (u8vector-ref field (quotient index 2))))
                    (if (even? index)
                        (bitwise-and byte #x0F)
                      (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                
                (define (u4vector-set! field <u8vector> index <fx> value <fx>)
                  (let ((byte (u8vector-ref field (quotient index 2))))
                    (u8vector-set! field (quotient index 2)
                      (if (even? index)
                          (bitwise-ior value (bitwise-and byte #xF0))
                        (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4))))))
                
                (define (with-field i <fx> j <fx> k <fx> proc)
                  (define (bind-i a <fx> i <fx>)
                    (define (bind-j b <fx> j <fx>)
                      (define (bind-k c <fx> k <fx>)
                        (let ((section (section-ref a b c)))
                          (proc section (local-index i j k))))
                      
                      (cond ((< k 0) (bind-k (- (quotient k 16) 1) (modulo k 16)))
                            ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                            (else (bind-k 0 k))))
                    
                    (cond ((< j 0) (bind-j (- (quotient j 16) 1) (modulo j 16)))
                          ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                          (else (bind-j 0 j))))
                  
                  @debug-infinite-loop
                  (continuation-capture
                    (lambda (cont)
                      (let ((max 1000))
                        (when (>= (length (get-continuation-stack cont (+ max 10))) max)
                          (break)))))
                  (cond ((< i 0) (bind-i (- (quotient i 16) 1) (modulo i 16)))
                        ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                        (else (bind-i 0 i))))
                
                ;; debugging
                (assert (and (between? i 0 15)
                             (between? j 0 15)
                             (between? k 0 15)))
                (let ((index (local-index i j k)))
                  (let ((block-id (block-ref section index))
                        (data-id (data-ref section index)))
                    (let ((x (+ section-x i))
                          (y (+ section-y j))
                          (z (+ section-z k))
                          (block (blockid->block block-id)))
                      (let ((x (fl& (+ block-radius (cast <fl> x))))
                            (y (fl& (+ block-radius (cast <fl> y))))
                            (z (fl& (+ block-radius (cast <fl> z))))
                            (uv (block-texture-coordinates block))
                            (rendering (cache-rendering~ block))
                            (generate (get-generate~ block)))
                        (proc region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!))))))))))))
  
  
  (method (updating-sectors proc (delay-update?: delay-update? #f))
    (define (update-sectors sectors)
      (for-each (lambda (sector)
                  (iterate-sector-areas sector
                    (lambda (area)
                      (clear-polygons~ area)))
                  (set-physical-uptodate?~ sector #f)
                  ;; no need to generate the physical explicitly
                  ;; (generate-sector sector 'physical)
                  (let ((eye-sector (find-eye-sector (get-index~ sector))))
                    (when eye-sector
                      (set-content-uptodate?~ eye-sector #f)
                      (if (and delay-update? (world-setting 'minecraft.delay-updating? #t))
                          (set-priority-update?~ eye-sector #t)
                        (generate-sector eye-sector 'render))))
                  ;; this test should not be necessary
                  (let ((section (get-section~ sector)))
                    (when section
                      (modified~ (get-chunk~ section)))))
                sectors))
    
    (define (save-regions)
      (with-regions-mutex
        (lambda ()
          (iterate-table regions
            (lambda (index region)
              (when region
                (save-region~ region)))))))
    
    (let ((sectors '()))
      (define (add-sector sector)
        (unless (memq? sector sectors)
          (set! sectors (cons sector sectors))))
      
      (let ((timer (new Timer)))
        (mutex-lock! generate-mutex)
        (proc add-sector)
        (update-sectors sectors)
        (save-regions)
        (mutex-unlock! generate-mutex)
        (when (world-setting 'minecraft.report-updating? #f)
          (let ((world (current-world)))
            (let ((count (length sectors))
                  (duration (real-duration-in-milliseconds~ timer)))
              (display-message~ world (format "Updated {a} sector{a} ({a}ms)" count (format-plural count) duration)))))))))


(definition protected (index->coordinates index)
  (let ((i (modulo index 16))
        (k (modulo (quotient index 16) 16))
        (j (modulo (quotient (quotient index 16) 16) 16)))
    (list i j k)))


(definition protected (normalize-sector/coordinates sector i j k with-field proc)
  (if (and (between? i 0 15)
           (between? j 0 15)
           (between? k 0 15))
      (proc sector i j k)
    (with-field i j k
      (lambda (section index)
        (let ((sector (get-sector~ section)))
          (bind (i j k) (index->coordinates index)
            (proc sector i j k)))))))


(definition protected (enqueue-sector/coordinates queue sector coordinates with-field)
  (bind (i j k) coordinates
    (normalize-sector/coordinates sector i j k with-field
      (lambda (sector i j k)
        (enqueue queue (list sector i j k))))))


(definition protected (sector/coordinates->location sector <Sector> i <fx> j <fx> k <fx>)
  (let ((index (get-index~ sector)))
    (let ((sector-x (vector-ref index 0))
          (sector-y (vector-ref index 1))
          (sector-z (vector-ref index 2)))
      (vector (+ i (* sector-x 16))
              (+ j (* sector-y 16) bedrock-cut)
              (+ k (* sector-z 16))))))


(definition protected (section/index->position section index)
  (sector/index->position (get-sector~ section) index))


(definition protected (sector/index->position sector index)
  (bind (i j k) (index->coordinates index)
    (let ((location (sector/coordinates->location sector i j k)))
      (let ((x (vector-ref location 0))
            (y (vector-ref location 1))
            (z (vector-ref location 2)))
        (vertex (+ (cast <fl> x) .5)
                (- (+ (cast <fl> y) .5) (cast <fl> bedrock-cut))
                (+ (cast <fl> z) .5))))))


(definition protected (taxicab-distance sector1 <Sector> sector2 <Sector>)
  (let ((index1 (get-index~ sector1))
        (index2 (get-index~ sector2)))
    (+ (abs (- (vector-ref index1 0) (vector-ref index2 0)))
       (abs (- (vector-ref index1 1) (vector-ref index2 1)))
       (abs (- (vector-ref index1 2) (vector-ref index2 2))))))


;;;
;;;; Repeater
;;;


(definition protected (new-repeater sector i j k delay power? with-field)
  (normalize-sector/coordinates sector i j k with-field
    (lambda (sector i j k)
      (new Repeater sector i j k delay power?))))


(class Repeater extends Object
  
  
  (slot sector getter generate)
  (slot i      getter generate)
  (slot j      getter generate)
  (slot k      getter generate)
  (slot power? getter generate)
  (slot delay  accessors generate)
  
  
  (method override (initialize sector i j k delay power?)
    (set! sector~self sector)
    (set! i~self i)
    (set! j~self j)
    (set! k~self k)
    (set! power?~self power?)
    (set! delay~self delay)))


;;;
;;;; Pressure plate
;;;


(definition protected (new-pressure-plate sector i j k actor power? with-field)
  (normalize-sector/coordinates sector i j k with-field
    (lambda (sector i j k)
      (new Pressure-Plate sector i j k actor power?))))


(class Pressure-Plate extends Object
  
  
  (slot sector    getter    generate)
  (slot i         getter    generate)
  (slot j         getter    generate)
  (slot k         getter    generate)
  (slot power?    getter    generate)
  (slot colliders accessors generate)
  (slot delay initialize 5 accessors generate)
  
  
  (method override (initialize sector i j k actor power?)
    (set! sector~self sector)
    (set! i~self i)
    (set! j~self j)
    (set! k~self k)
    (set! colliders~self (cons actor '())))
  
  (method (location)
    (list sector i j k)))


;;;
;;;; Spawner
;;;


(class Spawner extends Object
  
  
  (slot sector          getter generate)
  (slot time-since-last accessors generate)
  (slot time-for-spawn  accessors generate)
  (slot enemy-count     accessors generate)
  (slot coordinates     getter generate)
  
  
  (method override (initialize sector time-since-last time-for-spawn enemy-count coordinates)
    (set! sector~self sector)
    (set! time-since-last~self time-since-last)
    (set! time-for-spawn~self time-for-spawn)
    (set! enemy-count~self enemy-count)
    (set! coordinates~self coordinates)))


;;;
;;;; Burnout
;;;


@code-to-implement-redstone-torch-burnout (
(class Powerer extends Object
  
  
  (slot i    getter generate)
  (slot j    getter generate)
  (slot time getter generate)
  
  
  (method override (initialize i j time)
    (set! i~self i)
    (set! j~self j)
    (set! time~self time)))


(define burnout-delay
  3)


(define last-torches
  (list #f))


(define (add-torch powerer)
  (set-cdr! last-torches (cons powerer (cdr last-torches))))


(define (count-powerings i j time)
  (define (powering? powerer)
    (and (= (get-i~ powerer) i)
         (= (get-j~ powerer) j)))
  
  (define (past-delay? powerer)
    (> (- time (get-time~ powerer)) burnout-delay))
  
  (let (iter (scan last-torches) (count 0))
    (let ((torches (cdr scan)))
      (if (null? torches)
          count
        (let ((torch (car torches)))
          (if (past-delay? torch)
              (begin
                (set-cdr! scan '())
                count)
            (iter (cdr scan) (if (powering? torch) (+ count 1) count))))))))


(add-torch (new Powerer 1 2 10)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 10)         (debug 'count (length (cdr last-torches)))
(add-torch (new Powerer 1 2 11)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 11)         (debug 'count (length (cdr last-torches)))
(add-torch (new Powerer 1 2 14)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 14)         (debug 'count (length (cdr last-torches)))
(count-powerings 1 2 20)         (debug 'count (length (cdr last-torches))))


;;;
;;;; Actions
;;;


(definition protected block-actions
  (make-table test: equal?))


(definition public (registered-block-action pos)
  (table-ref block-actions pos #f))


(definition public (register-block-action pos action)
  (if (pair? pos)
      (for-each (lambda (pos)
                  (table-set! block-actions pos action))
                pos)
    (table-set! block-actions pos action)))


;;;
;;;; Add
;;;


(definition (make-minecraft-quad-face rendering <Minecraft-Rendering> texture-coordinates texture-depth quad l1 l2 l3 l4) <Minecraft-Quad-Face>
  (new Minecraft-Quad-Face (get-material~ rendering) texture-coordinates texture-depth quad l1 l2 l3 l4))


(definition (make-minecraft-triangle-face rendering <Minecraft-Rendering> texture-coordinates texture-depth quad l1 l2 l3) <Minecraft-Triangle-Face>
  (new Minecraft-Triangle-Face (get-material~ rendering) texture-coordinates texture-depth quad l1 l2 l3))


(definition (make-minecraft-quad v1 v2 v3 v4 block-id <fx> x <fl> y <fl> z <fl>) <Quad>
  (let ((quad <Quad> (make-quad #f v1 v2 v3 v4)))
    (set-data1~ quad (cast <fl> block-id))
    (set-data2~ quad x)
    (set-data3~ quad y)
    (set-data4~ quad z)
    quad))


(definition (make-minecraft-triangle v1 v2 v3 block-id <fx> x <fl> y <fl> z <fl>) <Triangle>
  (let ((triangle <Triangle> (make-triangle #f v1 v2 v3)))
    (set-data1~ triangle (cast <fl> block-id))
    (set-data2~ triangle x)
    (set-data3~ triangle y)
    (set-data4~ triangle z)
    triangle))


(definition (generic-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tt tl tb tr tb tr tt)))


;;90 degrees to the left
(definition (rotate-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tb tr tb tr tt tl tt)))


;;90 degrees to the right
(definition (rotate-inverse-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tl tt tl tb tr tb)))


(definition (rotate-other-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tb tr tt tl tt tl tb)))


(definition (transpose-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tr tb tl tb tl tt)))


(definition (generic-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <f64vector> v2 <f64vector> v3 <f64vector> v4 <f64vector> uv <f32vector> lighting shade rendering block-id)
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv))
        (origin (vertex& x y z)))
    (let ((quad (make-minecraft-quad (vertex+ origin v1) (vertex+ origin v2) (vertex+ origin v3) (vertex+ origin v4) block-id x y z)))
      (let ((normal (get-normal~ quad)))
        (make-minecraft-quad-face rendering
                                  (f32vector tl tt tl tb tr tb tr tt)
                                  texture-depth
                                  quad
                                  (generic-lighting i j k v1 normal lighting shade)
                                  (generic-lighting i j k v2 normal lighting shade)
                                  (generic-lighting i j k v3 normal lighting shade)
                                  (generic-lighting i j k v4 normal lighting shade))))))


(definition (generic-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <f64vector> v2 <f64vector> v3 <f64vector> v4 <f64vector> uv <f32vector> uv-coordinates lighting shade rendering block-id matrix)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3))
        (v4 (matrix-transform-3x4 matrix v4)))
    (let ((quad (make-minecraft-quad (vertex+xyz v1 x y z)
                                     (vertex+xyz v2 x y z)
                                     (vertex+xyz v3 x y z)
                                     (vertex+xyz v4 x y z)
                                     block-id
                                     x
                                     y
                                     z)))
      (let ((normal (get-normal~ quad)))
        (make-minecraft-quad-face rendering
                                  (uv-coordinates uv)
                                  (uv-depth uv)
                                  quad
                                  (generic-lighting i j k v1 normal lighting shade)
                                  (generic-lighting i j k v2 normal lighting shade)
                                  (generic-lighting i j k v3 normal lighting shade)
                                  (generic-lighting i j k v4 normal lighting shade))))))


(definition (generic-triangle i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <f64vector> v2 <f64vector> v3 <f64vector> uv <f32vector> uv-coordinates lighting shade rendering block-id matrix)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3)))
    (let ((triangle (make-minecraft-triangle (vertex+xyz v1 x y z)
                                             (vertex+xyz v2 x y z)
                                             (vertex+xyz v3 x y z)
                                             block-id
                                             x
                                             y
                                             z)))
      (let ((normal (get-normal~ triangle)))
        (make-minecraft-triangle-face rendering
                                      (uv-coordinates uv)
                                      (uv-depth uv)
                                      triangle
                                      (generic-lighting i j k v1 normal lighting shade)
                                      (generic-lighting i j k v2 normal lighting shade)
                                      (generic-lighting i j k v3 normal lighting shade))))))


(definition (generic-transparent-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <f64vector> v2 <f64vector> v3 <f64vector> v4 <f64vector> uv <f32vector> uv-coordinates lighting shade rendering block-id matrix)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3))
        (v4 (matrix-transform-3x4 matrix v4)))
    (let ((quad (make-minecraft-quad (vertex+xyz v1 x y z)
                                     (vertex+xyz v2 x y z)
                                     (vertex+xyz v3 x y z)
                                     (vertex+xyz v4 x y z)
                                     block-id
                                     x
                                     y
                                     z)))
      (let ((normal (get-normal~ quad)))
        (let ((inverse (vertex-scalar*& normal -1.)))
          (define (average-lightings l1 <u8vector> l2 <u8vector>)
            (u8vector (quotient (+ (u8vector-ref l1 0) (u8vector-ref l2 0)) 2)
                      (quotient (+ (u8vector-ref l1 1) (u8vector-ref l2 1)) 2)
                      (quotient (+ (u8vector-ref l1 2) (u8vector-ref l2 2)) 2)))
          
          (make-minecraft-quad-face rendering
                                    (uv-coordinates uv)
                                    (uv-depth uv)
                                    quad
                                    (average-lightings (generic-lighting i j k v1 normal lighting shade) (generic-lighting i j k v1 inverse lighting shade))
                                    (average-lightings (generic-lighting i j k v2 normal lighting shade) (generic-lighting i j k v2 inverse lighting shade))
                                    (average-lightings (generic-lighting i j k v3 normal lighting shade) (generic-lighting i j k v3 inverse lighting shade))
                                    (average-lightings (generic-lighting i j k v4 normal lighting shade) (generic-lighting i j k v4 inverse lighting shade))))))))


(constant inline 1/SQRT2 <fl>
  (/ 1. (sqrt 2.)))

;; minimal value for door to clear itself
(constant inline ambient-forward <fl>
  .3)

;; minimal value for stair top to clear itself and fence to be uniform
(constant inline ambient-angled <fl>
  .9)


@debugging
(definition protected (get-ambient-forward/angled)
  (values ambient-forward ambient-angled))

@debugging
(definition protected (set-ambient-forward/angled forward angled)
  (set! ambient-forward forward)
  (set! ambient-angled angled))


(definition (generic-lighting i <fx> j <fx> k <fx> vert <f64vector> normal <f64vector> lighting shade)
  (if (u8vector? lighting)
      lighting
    ;; the .5 is because the shape is centered at 0 0 0
    (let ((adjusted (vertex+& (vertex+& vert (vertex& .5 .5 .5)) (vertex-scalar*& normal ambient-forward)))
          (r1 (make-vertex&))
          (r2 (make-vertex&))
          (r3 (make-vertex&))
          (r4 (make-vertex&)))
      (define (ambient-rays!)
        (let ((up (roll-free-up& normal)))
          (let ((right (cross-product& normal up)))
            (let ((advance (vertex-scalar*& normal 1/SQRT2)))
              (let ((up/+2 (vertex-scalar/& up  2.))
                    (up/-2 (vertex-scalar/& up -2.))
                    (right/+2 (vertex-scalar/& right  2.))
                    (right/-2 (vertex-scalar/& right -2.)))
                (vertex+! r1 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/+2)) ambient-angled))
                (vertex+! r2 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/-2)) ambient-angled))
                (vertex+! r3 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/-2)) ambient-angled))
                (vertex+! r4 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/+2)) ambient-angled)))))))
      
      (ambient-rays!)
      (lighting shade i j k
        (fxfloor (vertex-x r1)) (fxfloor (vertex-y r1)) (fxfloor (vertex-z r1))
        (fxfloor (vertex-x r2)) (fxfloor (vertex-y r2)) (fxfloor (vertex-z r2))
        (fxfloor (vertex-x r3)) (fxfloor (vertex-y r3)) (fxfloor (vertex-z r3))
        (fxfloor (vertex-x r4)) (fxfloor (vertex-y r4)) (fxfloor (vertex-z r4))))))


(constant inline no-shade     <fl> 1.)
(constant inline top-shade    <fl> 1.)
(constant inline bottom-shade <fl> .5)
(constant inline left-shade   <fl> .6)
(constant inline right-shade  <fl> .6)
(constant inline back-shade   <fl> .8)
(constant inline front-shade  <fl> .8)


(definition public (left-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (left-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (left-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-quad-face rendering
                            (uv-coordinates uv)
                            (uv-depth uv)
                            (make-minecraft-quad (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front) block-id x y z)
                            (lighting left-shade i j k -1  0 -1 -1  0  0 -1  1 -1 -1  1  0)
                            (lighting left-shade i j k -1 -1 -1 -1 -1  0 -1  0 -1 -1  0  0)
                            (lighting left-shade i j k -1 -1  0 -1 -1  1 -1  0  0 -1  0  1)
                            (lighting left-shade i j k -1  0  0 -1  0  1 -1  1  0 -1  1  1)))


;; simple solution for shapes that don't work well with ambient vectors
(definition (uniform-lighting i <fx> j <fx> k <fx> lighting)
  (lighting no-shade i j k 0 0 1 0 0 -1 1 0 0 -1 0 0))


(definition public (x-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left top front)))
    (generic-transparent-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting left-shade rendering block-id matrix)))


(definition public (z-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex right top back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left top back)))
    (generic-transparent-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting back-shade rendering block-id matrix)))


(definition public (left-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left top front)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting left-shade rendering block-id matrix)))


(definition public (left-generic-quad i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex left (first top) back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left (second top) front)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting left-shade rendering block-id (make-identity-matrix))))


(definition public (right-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (right-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (right-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-quad-face rendering
                            (uv-coordinates uv)
                            (uv-depth uv)
                            (make-minecraft-quad (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back) block-id x y z)
                            (lighting right-shade i j k  1  0  0  1  0  1  1  1  0  1  1  1)
                            (lighting right-shade i j k  1 -1  0  1 -1  1  1  0  0  1  0  1)
                            (lighting right-shade i j k  1 -1 -1  1 -1  0  1  0 -1  1  0  0)
                            (lighting right-shade i j k  1  0 -1  1  0  0  1  1 -1  1  1  0)))


(definition public (right-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex right top front))
        (v2 (vertex right bottom front))
        (v3 (vertex right bottom back))
        (v4 (vertex right top back)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting right-shade rendering block-id matrix)))


(definition public (right-generic-quad i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex right (first top) front))
        (v2 (vertex right bottom front))
        (v3 (vertex right bottom back))
        (v4 (vertex right (second top) back)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting right-shade rendering block-id (make-identity-matrix))))


(definition public (bottom-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (bottom-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-quad-face rendering
                            (uv-coordinates uv)
                            (uv-depth uv)
                            (make-minecraft-quad (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front) block-id x y z)
                            (lighting bottom-shade i j k -1 -1  0 -1 -1  1  0 -1  0  0 -1  1)
                            (lighting bottom-shade i j k -1 -1 -1 -1 -1  0  0 -1 -1  0 -1  0)
                            (lighting bottom-shade i j k  0 -1 -1  0 -1  0  1 -1 -1  1 -1  0)
                            (lighting bottom-shade i j k  0 -1  0  0 -1  1  1 -1  0  1 -1  1)))


(definition public (bottom-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left bottom front))
        (v2 (vertex left bottom back))
        (v3 (vertex right bottom back))
        (v4 (vertex right bottom front)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting bottom-shade rendering block-id matrix)))


(definition public (top-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (top-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (top-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-quad-face rendering
                            (uv-coordinates uv)
                            (uv-depth uv)
                            (make-minecraft-quad (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back) block-id x y z)
                            (lighting top-shade i j k -1  1 -1 -1  1  0  0  1 -1  0  1  0)
                            (lighting top-shade i j k -1  1  0 -1  1  1  0  1  0  0  1  1)
                            (lighting top-shade i j k  0  1  0  0  1  1  1  1  0  1  1  1)
                            (lighting top-shade i j k  0  1 -1  0  1  0  1  1 -1  1  1  0)))

(definition public (top-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left top front))
        (v3 (vertex right top front))
        (v4 (vertex right top back)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting top-shade rendering block-id matrix)))


(definition public (top-sloped i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex left (first top) back))
        (v2 (vertex left (second top) front))
        (v3 (vertex right (third top) front))
        (v4 (vertex right (fourth top) back))
        (matrix (make-identity-matrix)))
    (define (needs-triangles?)
      (/= (/ (+ (vertex-y v1) (vertex-y v3)) 2) (/ (+ (vertex-y v2) (vertex-y v4)) 2)))
    
    (if (needs-triangles?)
        (list
          (generic-triangle i j k x y z v1 v2 v4 uv uv-coordinates lighting top-shade rendering block-id matrix)
          (generic-triangle i j k x y z v3 v4 v2 uv uv-coordinates lighting top-shade rendering block-id matrix))
      (list
        (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting top-shade rendering block-id matrix)))))


(definition public (back-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (back-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (back-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-quad-face rendering
                            (uv-coordinates uv)
                            (uv-depth uv)
                            (make-minecraft-quad (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back) block-id x y z)
                            (lighting back-shade i j k  0  0 -1  0  1 -1  1  0 -1  1  1 -1)
                            (lighting back-shade i j k  0 -1 -1  0  0 -1  1 -1 -1  1  0 -1)
                            (lighting back-shade i j k -1 -1 -1 -1  0 -1  0 -1 -1  0  0 -1)
                            (lighting back-shade i j k -1  0 -1 -1  1 -1  0  0 -1  0  1 -1)))


(definition public (back-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex right top back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left top back)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting back-shade rendering block-id matrix)))


(definition public (back-generic-quad i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex right (first top) back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left (second top) back)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting back-shade rendering block-id (make-identity-matrix))))


(definition public (front-side i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (front-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (front-face i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-minecraft-quad-face rendering
                            (uv-coordinates uv)
                            (uv-depth uv)
                            (make-minecraft-quad (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front) block-id x y z)
                            (lighting front-shade i j k -1  0  1 -1  1  1  0  0  1  0  1  1)
                            (lighting front-shade i j k -1 -1  1 -1  0  1  0 -1  1  0  0  1)
                            (lighting front-shade i j k  0 -1  1  0  0  1  1 -1  1  1  0  1)
                            (lighting front-shade i j k  0  0  1  0  1  1  1  0  1  1  1  1)))


(definition public (front-generic i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top front))
        (v2 (vertex left bottom front))
        (v3 (vertex right bottom front))
        (v4 (vertex right top front)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting front-shade rendering block-id matrix)))


(definition public (front-generic-quad i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex left (first top) front))
        (v2 (vertex left bottom front))
        (v3 (vertex right bottom front))
        (v4 (vertex right (second top) front)))
    (generic-face i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting front-shade rendering block-id (make-identity-matrix))))


(definition (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)
  (add-face (left-generic   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (right-generic  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (bottom-generic i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (top-generic    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (back-generic   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (front-generic  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category))


(definition public (add-cube-faces i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)))


(definition public (add-cross-faces i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius)))
        (tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv))
        (lighting (uniform-lighting i j k lighting)))
    (add-face (make-minecraft-quad-face rendering
                                        (f32vector tl tt tl tb tr tb tr tt)
                                        texture-depth
                                        (make-minecraft-quad (vertex right top back) (vertex right bottom back) (vertex left bottom front) (vertex left top front) block-id x y z)
                                        lighting lighting lighting lighting)
              rendering
              category)
    (add-face (make-minecraft-quad-face rendering
                                        (f32vector tl tt tl tb tr tb tr tt)
                                        texture-depth
                                        (make-minecraft-quad (vertex right top front) (vertex right bottom front) (vertex left bottom back) (vertex left top back) block-id x y z)
                                        lighting lighting lighting lighting)
              rendering
              category)))


(definition (add-torch block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref top-texture bottom-texture)
  (define (position-torch proc)
    (let ((margin .32))
      (ecase data-id
        ((1) (proc (- margin) 0.))
        ((2) (proc margin 0.))
        ((3) (proc 0. (- margin)))
        ((4) (proc 0. margin))
        (else (proc 0. 0.)))))
  
  (position-torch
    (lambda (dx dz)
      (let ((margin 1m)
            (left (- x block-radius))
            (right (+ x block-radius))
            (bottom (- y block-radius))
            (top (+ y block-radius))
            (back (- z block-radius))
            (front (+ z block-radius))
            (top-uv (get-coordinates top-texture))
            (bottom-uv (get-coordinates bottom-texture)))
        (add-face (top-face    i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) top-uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (bottom-face i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) bottom-uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (left-face   i j k x y z (+ dx (- x margin)) (+ dx right) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (right-face  i j k x y z (+ dx left) (+ dx (+ x margin)) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (back-face   i j k x y z (+ dx left) (+ dx right) bottom top (+ dz (- z margin)) (+ dz front) uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (front-face  i j k x y z (+ dx left) (+ dx right) bottom top (+ dz back) (+ dz (+ z margin)) uv generic-coordinates lighting rendering block-id) rendering category)))))


(definition (add-button block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref)
  (define (position-button proc)
    (let ((orientation (bitwise-and data-id #b111))
          (active? (bit-set? 3 data-id))
          (margin 3m)
          (thick 2m)
          (thin 1m))
      (ecase orientation
        ((0) (proc (- x margin) (+ x margin) (- y block-radius) (+ (- y block-radius) thick) (- z thick) (+ z thick)))
        ((1) (proc (- x block-radius) (+ (- x block-radius) thick) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((2) (proc (- (+ x block-radius) thick) (+ x block-radius) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((3) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- z block-radius) (+ (- z block-radius) thick)))
        ((4) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- (+ z block-radius) thick) (+ z block-radius)))
        ((5) (proc (- x margin) (+ x margin) (- (+ y block-radius) thick) (+ y block-radius) (- z thick) (+ z thick))))))
  
  (position-button
    (lambda (left right bottom top back front)
      (add-face (left-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (right-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (back-face   i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (front-face  i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category))))


(definition block-models
  (make-table))

(definition (cache-block-models filename)
  (or (table-ref block-models filename #f)
      (begin
        (set-current-directory {Directory Yownu-World "assets" "minecraft" "models"})
        (if (file-exists? filename)
            (let ((models (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "models"} filename))))
              (unless (table-ref models "parent" #f)
                (table-set! block-models filename models))
              models)
          (let ((models (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "models" "minecraft"} filename))))
            (unless (table-ref models "parent" #f)
              (table-set! block-models filename models))
            models)))))


(definition (add-json-model filename block-id data-id i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category add-face add-opaque-cube add-texture-element block-ref data-ref y-rotation x-rotation)
  (define (read-json-model proc)
    (let ((models (cache-block-models filename)))
      (let ((has-parent? (table-ref models "parent" #f)))
        (let ((textures (table-ref models "textures")))
          (when has-parent?
            (set! models (cache-block-models (string-append (string-trailer has-parent? #\/) ".json")))
            (iterate-table (table-ref models "textures")
              (lambda (key value)
                (unless (table-ref textures key #f)
                  (table-set! textures key value)))))
          (let ((elements (table-ref models "elements")))
            (iterate-table-safe textures
                                (lambda (key value)
                                  (table-set! textures key (string-trailer value #\/))))
            (proc elements textures))))))
  
  (read-json-model
    (lambda (elements textures) (let ((matrix (matrix-multiply (make-y-rotation-matrix (degree->radian (cast <fl> y-rotation)))
                                                               (make-x-rotation-matrix (degree->radian (cast <fl> x-rotation))))))
        (for-each
          (lambda (element)
            (define (get-file-texture face-name)
              (let ((face (table-ref (table-ref element "faces") face-name #f)))
                (when face
                  (let ((texture (get-coordinates (table-ref textures (string-trailer (table-ref face "texture") #\#)))))
                    (bind (l t r b) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref face "uv"))
                      (uv-rect texture l t r b))))))
            
            (define (get-texture-rotation face-name)
              (let ((face (table-ref (table-ref element "faces") face-name #f)))
                (when face
                  (let ((rot (or (table-ref face "rotation" #f) 0)))
                    (case rot
                      ((0)   generic-coordinates)
                      ((90)  rotate-inverse-coordinates)
                      ((180) rotate-other-coordinates)
                      ((270) rotate-coordinates))))))
            
            (define (get-element-matrix)
              (let ((rotation (table-ref element "rotation" #f)))
                (if rotation
                    (bind (x y z) (map (lambda (r) (/ (cast <fl> r) 16.)) (table-ref rotation "origin"))
                      (let ((origin (vertex (- .5 x) (- .5 y) (- .5 z)))
                            (rotation-matrix (case (string->symbol (table-ref rotation "axis"))
                                               ((x) (make-x-rotation-matrix (degree->radian (cast <fl> (table-ref rotation "angle")))))
                                               ((y) (make-y-rotation-matrix (- (degree->radian (cast <fl> (table-ref rotation "angle"))))))
                                               ((z) (make-z-rotation-matrix (degree->radian (cast <fl> (table-ref rotation "angle"))))))))
                        (matrix-multiply (make-translation-matrix (vertex-negate origin))
                                         (matrix-multiply rotation-matrix (make-translation-matrix origin)))))
                  (make-identity-matrix))))
            
            (bind (a b c) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref element "from"))
              (bind (d e f) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref element "to"))
                (unless (and (= a d) (= b e) (= c f))
                  (let ((left (- a .5))
                        (right (- d .5))
                        (bottom (- b .5))
                        (top (- e .5))
                        (back (- c .5))
                        (front (- f .5))
                        (left-uv (get-file-texture "west"))
                        (right-uv (get-file-texture "east"))
                        (bottom-uv (get-file-texture "down"))
                        (top-uv (get-file-texture "up"))
                        (back-uv (get-file-texture "north"))
                        (front-uv (get-file-texture "south"))
                        (left-rotation (get-texture-rotation "west"))
                        (right-rotation (get-texture-rotation "east"))
                        (bottom-rotation (get-texture-rotation "down"))
                        (top-rotation (get-texture-rotation "up"))
                        (back-rotation (get-texture-rotation "north"))
                        (front-rotation (get-texture-rotation "south"))
                        (matrix (matrix-multiply matrix (get-element-matrix))))
                    (when left-uv   (add-face (left-generic   i j k x y z left right bottom top back front left-uv left-rotation lighting rendering block-id matrix) rendering category))
                    (when right-uv  (add-face (right-generic  i j k x y z left right bottom top back front right-uv right-rotation lighting rendering block-id matrix) rendering category))
                    (when bottom-uv (add-face (bottom-generic i j k x y z left right bottom top back front bottom-uv bottom-rotation lighting rendering block-id matrix) rendering category))
                    (when top-uv    (add-face (top-generic    i j k x y z left right bottom top back front top-uv top-rotation lighting rendering block-id matrix) rendering category))
                    (when back-uv   (add-face (back-generic   i j k x y z left right bottom top back front back-uv back-rotation lighting rendering block-id matrix) rendering category))
                    (when front-uv  (add-face (front-generic  i j k x y z left right bottom top back front front-uv front-rotation lighting rendering block-id matrix) rendering category)))))))
          elements)))))


(definition (add-stairs data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category block-id add-face)
  (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case (bitwise-and data-id #b11)
                                                         ((3) (vertex&  0. 0. -1.))
                                                         ((2) (vertex&  0. 0.  1.))
                                                         ((1) (vertex& -1. 0.  0.))
                                                         ((0) (vertex&  1. 0.  0.)))))))
    ;; bottom
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom (fl& (- block-radius)))
          (top 0.)
          (back (fl& (- block-radius)))
          (front (fl& (+ block-radius))))
      (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face))
    ;; top
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom 0.)
          (top (fl& (+ block-radius)))
          (back 0.)
          (front (fl& (+ block-radius))))
      (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face))))


(definition (add-fence data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category block-id add-face block-ref connects)
  (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (vertex&  0. 0.  1.)))))
    (define (connect? block-id <fx>)
      (memv? block-id connects))
    
    (define (add-trunk)
      (let ((left (- .1))
            (right (+ .1))
            (bottom (- block-radius))
            (top (+ block-radius))
            (back (- .1))
            (front (+ .1)))
        (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
    
    (define (add-branches left <fl> right <fl> back <fl> front <fl>)
      ;; upper
      (let ((bottom (- .35 .075))
            (top (+ .35 .075)))
        (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face))
      ;; lower
      (let ((bottom (- .075))
            (top (+ .075)))
        (add-cuboid-generic i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
    
    ;; trunk
    (add-trunk)
    ;; left
    (when (connect? (block-ref (- i 1) j k))
      (add-branches (- block-radius) -.1 (- .075) (+ .075)))
    ;; right
    (when (connect? (block-ref (+ i 1) j k))
      (add-branches .1 (+ block-radius) (- .075) (+ .075)))
    ;; back
    (when (connect? (block-ref i j (- k 1)))
      (add-branches (- .075) (+ .075) (- block-radius) -.1))
    ;; front
    (when (connect? (block-ref i j (+ k 1)))
      (add-branches (- .075) (+ .075) .1 (+ block-radius)))))


(definition (add-slab i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv side-uv lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top y)
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (right-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (bottom-face i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (top-face    i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (back-face   i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (front-face  i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)))


(definition (add-sloped i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category block-id add-face horizon)
  (let ((left (fl& (- block-radius)))
        (right (fl& (+ block-radius)))
        (bottom (fl& (- block-radius)))
        (top (fl& (+ block-radius)))
        (back (fl& (- block-radius)))
        (front (fl& (+ block-radius))))
    (let ((v1 (vertex left top back))
          (v2 (vertex left bottom front))
          (v3 (vertex right bottom front))
          (v4 (vertex right top back))
          (matrix (make-lookat-matrix& (horizon-lookat&^ horizon))))
      (add-face (generic-face i j k x y z v1 v2 v3 v4 uv generic-coordinates lighting no-shade rendering block-id matrix) rendering category))))


(definition (add-rail data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category block-id add-face)
  (case data-id
    ((0) (add-bottom i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
    ((1) (add-bottom i j k x y z uv rotate-coordinates lighting rendering category block-id add-face))
    ((2) (add-sloped i j k x y z uv lighting rendering category block-id add-face (vertex& -1. 0.  0.)))
    ((3) (add-sloped i j k x y z uv lighting rendering category block-id add-face (vertex&  1. 0.  0.)))
    ((4) (add-sloped i j k x y z uv lighting rendering category block-id add-face (vertex&  0. 0.  1.)))
    ((5) (add-sloped i j k x y z uv lighting rendering category block-id add-face (vertex&  0. 0. -1.)))
    ((6) (add-bottom i j k x y z (get-coordinates "rail_normal_turned") generic-coordinates lighting rendering category block-id add-face))
    ((7) (add-bottom i j k x y z (get-coordinates "rail_normal_turned") rotate-coordinates lighting rendering category block-id add-face))
    ((8) (add-bottom i j k x y z (get-coordinates "rail_normal_turned") rotate-other-coordinates lighting rendering category block-id add-face))
    ((9) (add-bottom i j k x y z (get-coordinates "rail_normal_turned") rotate-inverse-coordinates lighting rendering category block-id add-face))))


(definition (add-rail-gadget data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-powered lighting rendering category block-id add-face)
  (let ((powered? (bit-set? 3 data-id)))
    (let ((uv (if powered? uv-powered uv)))
      (case (bitwise-and data-id #b111)
        ((0) (add-bottom i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
        ((1) (add-bottom i j k x y z uv rotate-coordinates lighting rendering category block-id add-face))
        ((2) (add-sloped i j k x y z uv lighting rendering category block-id add-face (vertex& -1. 0.  0.)))
        ((3) (add-sloped i j k x y z uv lighting rendering category block-id add-face (vertex&  1. 0.  0.)))
        ((4) (add-sloped i j k x y z uv lighting rendering category block-id add-face (vertex&  0. 0.  1.)))
        ((5) (add-sloped i j k x y z uv lighting rendering category block-id add-face (vertex&  0. 0. -1.)))))))


(definition add-epsilon <fl>
  .01)


(definition (add-left i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (right-face i j k x y z left (+ left add-epsilon) bottom top back front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-right i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face i j k x y z (- right add-epsilon) right bottom top back front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-bottom i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (top-face i j k x y z left right bottom (+ bottom add-epsilon) back front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-top i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (bottom-face i j k x y z left right (- top add-epsilon) top back front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-back i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (front-face i j k x y z left right bottom top back (+ back add-epsilon) uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-front i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (back-face i j k x y z left right bottom top (- front add-epsilon) front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-transparent data-id left right back front i j k x <fl> y <fl> z <fl> uv lighting rendering category block-id add-face)
  (ecase data-id
    ((left)  (add-left  i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
    ((right) (add-right i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
    ((back)  (add-back  i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
    (else    (add-front i j k x y z uv generic-coordinates lighting rendering category block-id add-face))))


;;;
;;;; World
;;;


(class Minecraft-World extends World))
