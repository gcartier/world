;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Motion Controllers
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.motion jazz


(import (jazz.geometry)
        (jazz.graphic.opengl.glew)
        (jazz.system)
        (world)
        (world.autoload)
        (world.camera)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.geometry)
        (world.homogeneous)
        (world.lookat)
        (world.opengl)
        (world.syntax (phase syntax)))


(definition public (person-motion?)
  (is? (current-motion) Person-Motion))


(definition public (orbit-motion?)
  (is? (current-motion) Orbit-Motion))


(definition public (free-motion?)
  (is? (current-motion) Free-Motion))


(definition public (make-person-motion world camera person)
  (new Person-Motion world camera person))


(definition public (make-orbit-motion world camera target)
  (new Orbit-Motion world camera target))


(definition public (make-free-motion world camera)
  (new Free-Motion world camera))


(definition recenter-mouse? <bool>
  #t)

(definition public (get-recenter-mouse?) <bool>
  recenter-mouse?)

(definition public (set-recenter-mouse? flag <bool>)
  (set! recenter-mouse? flag))


(definition track-sensitivity <fl>
  200.)

(definition public (get-track-sensitivity) <fl>
  track-sensitivity)

(definition public (set-track-sensitivity sensitivity <fl>)
  (set! track-sensitivity sensitivity))


;;;
;;;; Motion
;;;


(class Motion extends Object
  
  
  (slot world  <World>  getter generate)
  (slot camera <Camera> getter generate)
  
  
  (method override (initialize world camera)
    (set! world~self world)
    (set! camera~self camera))
  
  
  (method protected virtual (move-forward)
    )
  
  
  (method protected virtual (move-backward)
    )
  
  
  (method protected virtual (blink-forward)
    )
  
  
  (method protected virtual (blink-backward)
    )
  
  
  (method protected virtual (warp-forward)
    )
  
  
  (method protected virtual (warp-backward)
    )
  
  
  (method protected virtual (move-left)
    )
  
  
  (method protected virtual (move-right)
    )
  
  
  (method protected virtual (move-up)
    )
  
  
  (method protected virtual (move-down)
    )
  
  
  (method protected virtual (rotate-left)
    )
  
  
  (method protected virtual (rotate-right)
    )
  
  
  (method protected virtual (zoom-in)
    )
  
  
  (method protected virtual (zoom-out)
    )
  
  
  (method protected virtual (follow-player)
    )
  
  
  (method protected virtual (follow-actor actor)
    )
  
  
  (method protected virtual (eye-behind-player)
    )
  
  
  (method protected virtual (eye-behind-actor actor)
    )
  
  
  (method protected virtual (restore-desired-distance elapse)
    )
  
  
  (method protected virtual (eye-center-player)
    )
  
  
  (method protected virtual (reset-roll actor)
    )
  
  
  (method protected virtual (process-roll actor)
    )
  
  
  (method (track-camera dh <fx> dv <fx>)
    (when (hook-eye~ world)
      (rotate-horizontal~ camera (/ (- (cast <fl> dh)) track-sensitivity))
      (rotate-vertical~ camera (/ (- (cast <fl> dv)) track-sensitivity)))))


;;;
;;;; Target
;;;


(class Target-Motion extends Motion
  
  
  (slot target            <Element> initialize #f   accessors generate)
  (slot max-distance      <fl>      initialize 30.0 getter generate)
  (slot desired-distance  <fl>      initialize 3.5  getter generate)
  (slot distance-override <fl+>     initialize #f   getter generate)
  (slot distance-goal     <fl+>     initialize #f   getter generate)
  (slot distance-restore  <fl+>     initialize #f   getter generate)
  
  
  (method override (initialize world camera target)
    (nextmethod world camera)
    (set! target~self target))
  
  
  (method protected virtual (motion-target)
    target)
  
  
  (method (setup-motion distance)
    (set! desired-distance distance)
    (set! distance-override #f)
    (set! distance-goal #f)
    (align-eye-behind (player-lens (motion-target)))
    (adjust-player-alpha))
  
  
  (method (effective-distance)
    (or distance-override desired-distance))
  
  
  (method (desired-distance-closer (speed: speed #f))
    (let ((speed (or speed .75)))
      (set! desired-distance (* desired-distance speed))
      (update-first-restore)))
  
  
  (method (desired-distance-further (speed: speed #f))
    (let ((speed (or speed .75)))
      (set! desired-distance (min (/ desired-distance speed) max-distance))
      (update-first-restore)))
  
  
  (method (update-first-restore)
    (when (and distance-restore distance-override)
      (set! distance-restore (/ (- desired-distance distance-override) eye-restore-duration))))
  
  
  (method (adjust-player-alpha)
    (let ((me (current-me)))
      (dye-alpha-set! (get-color~ me)
                      (if (contains-vertex?~ me (get-position~ camera))
                          0.
                        (max 0.2 (min 1. (/ (effective-distance) 2.)))))))
  
  
  (method override (follow-player)
    (follow-actor (current-controlled~ world)))
  
  
  (method override (follow-actor actor)
    (when (person-motion?)
      (unless (or (get-viewing?~ world) (eq? (get-first-camera~ world) 'free))
        (eye-behind-actor actor))
      (when actor
        (let ((lens (player-lens actor)))
          (align-eye-behind lens)
          (remove-eye-occlusion lens)))))
  
  
  (method override (eye-behind-player)
    (eye-behind-actor (current-controlled~ world)))
  
  
  (method override (eye-behind-actor actor)
    (when (and actor (person-motion?))
      (set-lookat~ camera (realign-lookat& (get-lookat~ actor) (get-world-up~ world)))
      (camera-update~ camera)))
  
  
  (method (player-lens player)
    (let ((model (cache-model~ player)))
      (let ((center (get-center~ model))
            (bounds (get-bounds~ model))
            (matrix (get-matrix~ player)))
        (let ((model-lens (vertex+ center (vertex 0. (* (cuboid-height bounds) .15) 0.))))
          (matrix-transform-3x4 matrix model-lens)))))
  
  
  (definition eye-restore-duration
    1.6)
  
  
  ;; lens   override   goal   distance
  ;; |      |          |      |
  ;; |      |          |      | - user desired distance
  ;; |      |          | - new override target
  ;; |      | - override to clear any occlusion
  ;; | - camera target
  (method override (restore-desired-distance elapse)
    (let ((me (current-me)))
      (when distance-goal
        (let ((augmented-override (+ distance-override (* elapse distance-restore))))
          (cond ((>= augmented-override desired-distance)
                 (set! distance-override #f)
                 (set! distance-goal #f))
                ((>= augmented-override distance-goal)
                 (set! distance-override distance-goal)
                 (set! distance-goal #f))
                (else
                 (set! distance-override augmented-override))))
        (align-eye-behind (player-lens me))
        (adjust-player-alpha))))
  
  
  (method (remove-eye-occlusion lens)
    (let ((sight (get-sight~ camera)))
      (define (determine-eye-occlusion lens)
        ;; the + 5. is a quick hack until a full solution
        ;; problem comes from the align-eye-behind call in follow-actor
        ;; that can bring the camera too close to a polygon but not touching
        ;; so remove-eye-occlusion doesn't kick in
        (let ((closest (ray-closest-polygon~ world lens (vertex-negate& sight) (+ desired-distance 5.) ignore-players?: #t)))
          (if (not closest)
              (values #f #f)
            (bind (poly distance) closest
              (values distance (get-normal~ poly))))))
      
      (define (closer-eye-occlusion occlusion normal)
        (let ((epsilon .1)
              (trend (dot-product sight normal)))
          (if (= trend 0.)
              occlusion
            (let ((safe (- occlusion (/ epsilon trend))))
              (if (< safe desired-distance)
                  safe
                desired-distance)))))
      
      (receive (occlusion normal) (determine-eye-occlusion lens)
        (let ((effective (effective-distance))
              (goal (if occlusion
                        (closer-eye-occlusion occlusion normal)
                      desired-distance)))
          (when (and (/= goal effective)
                     (or (not distance-goal)
                         (/= goal distance-goal)))
            (if (< goal effective)
                (begin
                  (set! distance-override goal)
                  (set! distance-goal #f)
                  (set! distance-restore (/ (- desired-distance goal) eye-restore-duration))
                  (align-eye-behind lens)
                  (adjust-player-alpha))
              (set! distance-goal goal)))))))
  
  
  (method (align-eye-behind pos)
    (let ((sight (get-sight~ camera)))
      (set-position~ camera (vertex-& pos (vertex-scalar*& sight (effective-distance))))
      (derive-target~ camera)
      (camera-update~ camera)))
  
  
  (method (orbit-behind elem)
    (set! distance-override #f)
    (align-eye-behind (transformed-center~ elem)))
  
  
  (method (orbit-behind-target)
    (orbit-behind (motion-target)))
  
  
  (method override (eye-center-player)
    (unless (get-paused?~ world)
      (follow-player))))


;;;
;;;; Person
;;;


(class Person-Motion extends Target-Motion
  
  
  (slot desired-roll   <fl>  initialize 0. getter generate)
  (slot roll-speed     <fl+> initialize #f getter generate)
  (slot last-roll-time <fl+> initialize #f getter generate)
  
  
  (method override (motion-target)
    (or target (current-me)))
  
  
  (method override (move-forward)
    (move-forward~ (motion-target) (get-commands~ world)))
  
  
  (method override (move-backward)
    (move-backward~ (motion-target) (get-commands~ world)))
  
  
  (method override (blink-forward)
    (blink-forward~ (motion-target) (get-commands~ world)))
  
  
  (method override (blink-backward)
    (blink-backward~ (motion-target) (get-commands~ world)))
  
  
  (method override (warp-forward)
    (warp-forward~ (motion-target)))
  
  
  (method override (warp-backward)
    (warp-backward~ (motion-target)))
  
  
  (method override (move-left)
    (move-left~ (motion-target) (get-commands~ world)))
  
  
  (method override (move-right)
    (move-right~ (motion-target) (get-commands~ world)))
  
  
  (method override (move-up)
    (move-up~ (motion-target) (get-commands~ world)))
  
  
  (method override (move-down)
    (move-down~ (motion-target) (get-commands~ world)))
  
  
  (method override (rotate-left)
    (rotate-left~ (motion-target) (get-commands~ world)))
  
  
  (method override (rotate-right)
    (rotate-right~ (motion-target) (get-commands~ world)))
  
  
  (method override (zoom-in)
    (desired-distance-closer)
    (eye-center-player)
    (adjust-player-alpha))
  
  
  (method override (zoom-out)
    (desired-distance-further)
    (eye-center-player)
    (adjust-player-alpha))
  
  
  (method (force-up distance)
    (let ((target (motion-target))
          (position (get-position~ camera)))
      (set-position~ camera (vertex+& position (vertex-scalar*& (get-up~ (get-lookat~ target)) distance)))
      (derive-target~ camera)
      (camera-update~ camera)
      (set-y~ target (+ (get-y~ target) distance))
      (follow-player)))
  
  
  @new
  (method (rotate-actor-horizontal actor angle (follow-actor?: follow-actor? #t))
    (let ((me (current-controlled~ world)))
      (let ((lookat (get-lookat~ actor)))
        (let ((person-sight (get-sight~ lookat))
              (sight (get-sight~ camera))
              (up (get-up~ lookat)))
          (let ((flat-sight (vertex-normalize (vertex (vertex-x person-sight) 0. (vertex-z person-sight))))
                (flat-eye-sight (vertex-normalize (vertex (vertex-x sight) 0. (vertex-z sight)))))
            (set-lookat~ actor (rotate-lookat& lookat angle up))
            (update-matrix~ me)
            (when (and (eq? actor me) (not (get-paused?~ world)))
              (unless (and (get-down?~ world) (not (get-moving?~ world)))
                ;; the sign multiplication is a quick solution
                ;; quaternions could be used to simplify all this
                (let ((adjusted-angle (* (cast <fl> (sign angle)) (vector-angle flat-eye-sight flat-sight))))
                  (set-lookat~ camera (rotate-lookat& (get-lookat~ camera) adjusted-angle (get-world-up~ world)))))
              (when follow-actor?
                (follow-actor actor))))))))
  
  
  (method (rotate-actor-horizontal actor angle (follow-actor?: follow-actor? #t))
    (let ((me (current-controlled~ world)))
      (let ((lookat (get-lookat~ actor)))
        (let ((up (get-up~ lookat)))
          (set-lookat~ actor (rotate-lookat& lookat angle up))
          (update-matrix~ me)
          (when (and (eq? actor me) (not (get-paused?~ world)))
            (unless (and (get-down?~ world) (not (get-moving?~ world)))
              ;; EYEACTORLOOKATPROBLEM
              (set-lookat~ camera (rotate-lookat& (get-lookat~ camera) angle up)))
            (when follow-actor?
              (follow-actor actor)))))))
  
  
  (method (rotate-actor-vertical actor angle (follow-actor?: follow-actor? #t))
    (let ((me (current-controlled~ world)))
      (let ((lookat (get-lookat~ actor)))
        (set-lookat~ actor (rotate-lookat& lookat angle (get-right~ lookat)))
        (update-matrix~ me))
      (when (and (eq? actor me) (not (get-paused?~ world)))
        (set-lookat~ camera (rotate-lookat& (get-lookat~ camera) angle (get-right~ camera)))
        (when follow-actor?
          (follow-actor actor)))))
  
  
  (method (track-actor actor dh dv local-sight local-up local-right first?)
    (if (get-fly?~ world)
        (track-fly actor dh dv local-sight local-up local-right first?)
      (track-ground actor dh dv local-sight local-up local-right first?)))
  
  
  (method (track-ground actor dh dv camera-sight camera-up camera-right first?)
    (let ((me (current-controlled~ world))
          (camera (current-camera)))
      (let ((me? (eq? actor me))
            (angleh (/ (- (cast <fl> dh)) track-sensitivity))
            (anglev (/ (- (cast <fl> dv)) track-sensitivity))
            (actor-lookat (get-lookat~ actor))
            (camera-lookat (lookat camera-sight camera-up camera-right)))
        (let ((pitch (vertical-angle camera-sight (get-world-up~ world))))
          ;; remove pitch
          (when (and me? (not (get-paused?~ world)))
            (rotate-lookat-vertical! camera-lookat pitch))
          ;; start from camera lookat
          (when first?
            (lookat-copy! actor-lookat camera-lookat))
          (rotate-actor-horizontal actor angleh follow-actor?: #f)
          ;; add pitch
          (when (and me? (not (get-paused?~ world)))
            (rotate-vertical-up~ camera anglev (get-up~ (get-lookat~ actor))))
          ;; camera follows actor
          (when (and me? (not (get-paused?~ world)))
            (follow-actor actor))))))
  
  
  (method (track-fly actor dh dv camera-sight camera-up camera-right first?)
    (let ((me (current-controlled~ world))
          (camera (current-camera)))
      (let ((me? (eq? actor me))
            (angleh (/ (- (cast <fl> dh)) track-sensitivity))
            (anglev (/ (- (cast <fl> dv)) track-sensitivity))
            (eye-lookat (get-lookat~ camera))
            (actor-lookat (get-lookat~ actor))
            (camera-lookat (lookat camera-sight camera-up camera-right)))
        ;; start from camera lookat
        (when first?
          (lookat-copy! actor-lookat camera-lookat))
        ;; adjust pitch
        (let ((actor-horizon (cross-normal& (get-sight~ actor-lookat) (get-world-up~ world))))
          (set-lookat~ actor (rotate-lookat& actor-lookat anglev actor-horizon))
          (set-lookat~ camera (rotate-lookat& eye-lookat anglev actor-horizon)))
        ;; adjust roll
        (roll-actor actor angleh)
        ;; adjust rotation
        (set-lookat~ actor (rotate-lookat& actor-lookat angleh (get-world-up~ world)))
        (set-lookat~ camera (rotate-lookat& eye-lookat angleh (get-world-up~ world)))
        ;; update matrix
        (update-matrix~ me)
        ;; camera follows actor
        (when (and me? (not (get-paused?~ world)))
          (follow-actor actor)))))
  
  
  (method override (reset-roll actor)
    (set! desired-roll 0.)
    (set! roll-speed .25)
    (process-roll actor))
  
  
  (method (roll-actor actor angle)
    (let ((max-roll PI/4))
      (let ((desired (max (- max-roll) (min max-roll (* (- angle) 25.)))))
        (set! desired-roll desired)
        (set! roll-speed .25)
        (process-roll actor))))
  
  
  (method override (process-roll actor)
    (when (and roll-speed (or (not last-roll-time) (> (- (current-seconds) last-roll-time) .01)))
      (let ((lookat (get-lookat~ actor)))
        (let ((current (vertical-angle (get-right~ lookat) (get-world-up~ world))))
          (if (near? current desired-roll .001)
              (set! roll-speed #f)
            (let ((damper 10.))
              (let ((target-roll (/ (+ desired-roll (* damper current)) (+ 1. damper))))
                (increase-roll actor (max (- roll-speed) (min roll-speed (- target-roll current)))))))))))
  
  
  (method (increase-roll actor inc)
    (let ((lookat (get-lookat~ actor)))
      (when (or (not last-roll-time)
                (> (abs inc) .01)
                (> (- (current-seconds) last-roll-time) .05))
        (set! last-roll-time (current-seconds))
        (set-lookat~ actor (rotate-lookat& lookat inc (get-sight~ lookat))))))
  
  
  (method (exit-fly)
    (let ((target (motion-target)))
      (let ((lookat (get-lookat~ target)))
        (rotate-actor-vertical target (vertical-angle (get-sight~ lookat) (get-up~ lookat)))
        (follow-player)))))


;;;
;;;; Orbit
;;;


(class Orbit-Motion extends Target-Motion
  
  
  (method override (motion-target)
    (or target (first-target~ world) (current-me)))
  
  
  (method override (move-forward)
    (desired-distance-closer speed: .95)
    (orbit-behind (motion-target)))
  
  
  (method override (move-backward)
    (desired-distance-further speed: .95)
    (orbit-behind (motion-target)))
  
  
  (method override (move-left)
    (rotate-right~ camera)
    (orbit-behind (motion-target)))
  
  
  (method override (move-right)
    (rotate-left~ camera)
    (orbit-behind (motion-target)))
  
  
  (method override (move-up)
    (rotate-down~ camera)
    (orbit-behind (motion-target)))
  
  
  (method override (move-down)
    (rotate-up~ camera)
    (orbit-behind (motion-target)))
  
  
  (method override (rotate-left)
    (rotate-right~ camera)
    (orbit-behind (motion-target)))
  
  
  (method override (rotate-right)
    (rotate-left~ camera)
    (orbit-behind (motion-target)))
  
  
  (method override (zoom-in)
    (desired-distance-closer)
    (orbit-behind (motion-target)))
  
  
  (method override (zoom-out)
    (desired-distance-further)
    (orbit-behind (motion-target)))
  
  
  (method (track-orbit dh <fx> dv <fx>)
    (rotate-horizontal~ camera (/ (- (cast <fl> dh)) track-sensitivity))
    (rotate-vertical~ camera (/ (- (cast <fl> dv)) track-sensitivity))
    (orbit-behind-target)))


;;;
;;;; Free
;;;


(class Free-Motion extends Motion
  
  
  (method override (move-forward)
    (when (hook-eye~ world)
      (move-forward~ camera)))
  
  
  (method override (move-backward)
    (when (hook-eye~ world)
      (move-backward~ camera)))
  
  
  (method override (blink-forward)
    (when (hook-eye~ world)
      (blink-forward~ camera)))
  
  
  (method override (blink-backward)
    (when (hook-eye~ world)
      (blink-backward~ camera)))
  
  
  (method override (warp-forward)
    (when (hook-eye~ world)
      (warp-forward~ camera)))
  
  
  (method override (warp-backward)
    (when (hook-eye~ world)
      (warp-backward~ camera)))
  
  
  (method override (move-left)
    (when (hook-eye~ world)
      (move-left~ camera)))
  
  
  (method override (move-right)
    (when (hook-eye~ world)
      (move-right~ camera)))
  
  
  (method override (move-up)
    (when (hook-eye~ world)
      (move-up~ camera)))
  
  
  (method override (move-down)
    (when (hook-eye~ world)
      (move-down~ camera)))
  
  
  (method override (rotate-left)
    (when (hook-eye~ world)
      (rotate-left~ camera)))
  
  
  (method override (rotate-right)
    (when (hook-eye~ world)
      (rotate-right~ camera)))
  
  
  (method override (zoom-in)
    (zoom-in~ camera))
  
  
  (method override (zoom-out)
    (zoom-out~ camera))))
