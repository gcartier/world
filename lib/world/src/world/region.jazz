;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Regions
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.region jazz


(import (jazz.geometry)
        (jazz.io)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.autoload)
        (world.binary)
        (world.chunk)
        (world.generation.block)
        (world.geometry.syntax (phase syntax))
        (world.geometry)
        (world.homogeneous)
        (world.index)
        (world.layer)
        (world.section)
        (world.syntax (phase syntax))
        (world.tag))


(proclaim (warn optimizations))


(constant inline region-size <fx>
  32)

(constant inline region-header-size <fx>
  8192
  @wait-constant-folding
  (* 8 1024))

(constant inline chunk-padding <fx>
  4096
  @wait-constant-folding
  (* 4 1024))

(constant inline chunk-header-size <fx>
  5)

(constant inline zlib-header-size <fx>
  2)

(constant inline zlib-footer-size <fx>
  4)


(definition protected chunk-buffer
  (make-u8vector 262144))


;; looks like we don't need to adjust for negative values like stated on the wiki
(definition protected inline (section->chunk x/z <fx>) <fx>
  (modulo x/z 32))


(definition protected (section->chunk-index index <planar-index>) <planar-index>
  (section->chunk-index! (make-planar-index) index))


(definition protected (section->chunk-index! result <planar-index> index <planar-index>) <planar-index>
  (planar-index! result
                 (section->chunk (planar-index-x index))
                 (section->chunk (planar-index-z index))))


;;;
;;;; Pool
;;;


(constant sections-cardinality <fx>
  (* 6 32))

(definition protected sections-pool <vector>
  (make-vector sections-cardinality #f))

(definition protected sections-allocated <fx>
  0)

(definition protected sections-available <fx>
  0)


(definition protected (make-section$ section-y) <World-Section>
  (if (= sections-available 0)
      (assert (< sections-allocated sections-cardinality)
        (increase! sections-allocated)
        (make-section section-y))
    (decrease! sections-available)
    (let ((section (vector-ref sections-pool sections-available)))
      (set-y~ section section-y)
      (vector-set! sections-pool sections-available #f)
      section)))


(definition protected (free-section$ section <World-Section>) <void>
  (assert (< sections-available sections-cardinality))
  (vector-set! sections-pool sections-available section)
  (increase! sections-available))


(definition protected (keep-section$ section)
  (assert (> sections-allocated 0))
  (decrease! sections-allocated))


;;;
;;;; Region
;;;


(class World-Region extends Object
  
  
  (slot index                <index>                                         getter generate)
  (slot mutex                <object>                                        getter generate)
  (slot file                 <File>                                          getter generate)
  (slot port                 <port>                                          getter generate)
  (slot header               <u8vector>                                      getter generate)
  (slot chunks-mutex         <object>   initialize (make-mutex 'chunks)      getter generate)
  (slot chunk-access-mutexes <object>   initialize (make-table test: equal?) getter generate)
  (slot chunks               <table>    initialize #f                        getter generate)
  (slot modified?            <bool>     initialize #f                        accessors generate)
  (slot compact?             <bool>     initialize #f                        accessors generate)
  (slot zone                 <bool>     initialize #f                        accessors generate)
  
  
  (method override (initialize index file zone)
    (set! index~self index)
    (set! mutex~self (make-mutex 'region))
    (set! file~self file)
    (set! port~self (open-file (path-settings file)))
    (set! header (read-header))
    ;; temporary simplification by having processor retain everything
    (set! chunks (make-table test: equal? weak-values: (local?) @wait-client-caching-chunks (not (processing?))))
    (set! zone~self zone)
    (make-will self
      (lambda (obj)
        ;; because of the will, the object will only be recycled on
        ;; the next garbage collection, so we have to remove it from
        ;; table ourself to make sure it cannot be referenced anymore
        (when zone ;; test zone in case we got gced after zone destruction
          (unlink-region~ zone obj)
          (close-port port)))))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a}" (get-x) (get-y) (get-z)))))
  
  
  (method override (destroy)
    (compact-region)
    (nextmethod))
  
  
  (method (get-x) <fx>
    (index-x index))
  
  (method (get-y) <fx>
    (index-y index))
  
  (method (get-z) <fx>
    (index-z index))
  
  
  (method (with-mutex thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  (method (read-header)
    (let ((size region-header-size))
      (let ((content (make-u8vector size)))
        (read-subu8vector content 0 size port)
        content)))
  
  
  (method (with-chunks-mutex thunk)
    (mutex-lock! chunks-mutex)
    (prog1 (thunk)
      (mutex-unlock! chunks-mutex)))
  
  
  (method (chunk-access-mutex index)
    (with-chunks-mutex
      (lambda ()
        (or (table-ref chunk-access-mutexes index #f)
            (let ((mutex (make-mutex 'chunk-access)))
              (table-set! chunk-access-mutexes index mutex)
              mutex)))))
  
  
  (method (iterate-chunks proc)
    (with-chunks-mutex
      (lambda ()
        (iterate-table chunks
          (lambda (index chunk)
            (proc chunk))))))
  
  
  (method (count-chunks)
    (with-chunks-mutex
      (lambda ()
        (table-length chunks))))
  
  
  ;; protecting the generation code makes sense
  ;; as it is mostly C so uninterruptible anyways
  (definition protected shapings-mutex
    (make-mutex 'shapings))
  
  
  (definition protected (with-shapings-mutex thunk)
    (prog1 (begin
             (mutex-lock! shapings-mutex)
             (thunk))
      (mutex-unlock! shapings-mutex)))
  
  
  (method (setup-shapings shapings <vector> chunk <World-Chunk>)
    (let ((table (get-sections-table~ chunk)))
      (when table
        (iterate-table table
          (lambda (y section)
            (let ((actual <World-Section+> (vector-ref shapings y)))
              (when actual
                (free-section$ actual))
              (vector-set! shapings y section))))))
    (loop (for y from 0 below 32)
          (let ((section <World-Section+> (vector-ref shapings y)))
            (if section
                (set-touched~ section 0)
              (vector-set! shapings y (make-section$ y)))))
    (vector-set! shapings 32 chunk))
  
  
  (method (extract-shapings shapings <vector> chunk <World-Chunk>)
    (loop (for y from 0 below 32)
          (let ((section <World-Section> (vector-ref shapings y)))
            (if (= (get-touched~ section) 0)
                (when (get-chunk~ section)
                  (vector-set! shapings y #f))
              (if (get-chunk~ section)
                  (modified~ chunk)
                (keep-section$ section)
                (setup-section~ chunk section))
              (vector-set! shapings y #f)))))
  
  
  (definition shape-shapings <vector>
    (make-vector 33 #f))
  
  
  (method (shape-chunk index <planar-index>) <World-Chunk>
    (let ((zone (current-zone)))
      (define (make-chunk)
        (let ((biomes (make-tag "Biomes" TAG_Byte_Array (generate-u8biomes (get-x) (get-z) (planar-index-x index) (planar-index-z index))))
              (heightmap (make-tag "HeightMap" TAG_Int_Array (make-vector 256 0)))
              (entities (make-tag "Entities" TAG_List (make-list-payload 0 '())))
              (block-entities (make-tag "TileEntities" TAG_List (make-list-payload 0 '())))
              (sections (make-tag "Sections" TAG_List (make-list-payload TAG_Compound '()))))
          (let ((tag (make-tag "" TAG_Compound
                       (list
                         (make-tag "Level" TAG_Compound
                           (list
                             biomes heightmap entities block-entities sections))))))
            (let ((chunk (new World-Chunk index Shaped #f #f self tag (tag-value biomes) (tag-value heightmap) (tag-value entities) (tag-value block-entities) (tag-value sections) #f)))
              (with-shapings-mutex
                (lambda ()
                  (setup-shapings shape-shapings chunk)
                  (let ((generator (get-generator~ zone)))
                    (shape~ generator chunk shape-shapings))
                  (extract-shapings shape-shapings chunk)))
              (generated~ chunk)
              (modified~ chunk)
              chunk))))
      
      (let ((chunk (with-chunks-mutex
                     (lambda ()
                       (table-ref chunks index #f)))))
        (if chunk
            (let ((generator (get-generator~ zone)))
              (when (< (get-generator-revision~ chunk) (get-revision~ generator))
                (regenerate~ chunk))
              chunk)
          (let ((read-chunk (continuation-capture
                              (lambda (corrupted)
                                (read-chunk index corrupted)))))
            (let ((chunk (or read-chunk (make-chunk))))
              (with-chunks-mutex
                (lambda ()
                  (table-set! chunks (copy-planar-index index) chunk)))
              chunk))))))
  
  
  (definition chunk-shapings <vector>
    (make-vector 33 #f))
  
  (definition front-shapings <vector>
    (make-vector 33 #f))
  
  (definition corner-shapings <vector>
    (make-vector 33 #f))
  
  (definition right-shapings <vector>
    (make-vector 33 #f))
  
  
  (method (populate-chunk index <planar-index> i <fx> k <fx> shaped-chunks <vector>) <World-Chunk>
    (let ((zone (current-zone))
          (access-index (neighbor-index i k)))
      (let ((chunk (vector-ref shaped-chunks access-index)))
        (if (>= (get-state~ chunk) Populated)
            chunk
          (let ((region-x (get-x))
                (region-y (get-y))
                (region-z (get-z))
                (chunk-x (planar-index-x index))
                (chunk-z (planar-index-z index)))
            (define (shaped-chunk a <fx> c <fx>) <World-Chunk>
              (vector-ref shaped-chunks (neighbor-index (+ i a) (+ k c))))
            
            (let ((front (shaped-chunk 0 1))
                  (corner (shaped-chunk 1 1))
                  (right (shaped-chunk 1 0)))
              (with-shapings-mutex
                (lambda ()
                  (setup-shapings chunk-shapings chunk)
                  (setup-shapings front-shapings front)
                  (setup-shapings corner-shapings corner)
                  (setup-shapings right-shapings right)
                  (let ((generator (get-generator~ zone)))
                    (populate~ generator chunk-shapings front-shapings corner-shapings right-shapings))
                  (extract-shapings chunk-shapings chunk)
                  (extract-shapings front-shapings front)
                  (extract-shapings corner-shapings corner)
                  (extract-shapings right-shapings right)))
              (change-state~ chunk Populated)
              (modified~ chunk)
              chunk))))))
  
  
  ;;  +-------+-------+-------+   +-------+-------+-------+   +-------+-------+-------+
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  |       |       |       |   |   P   |   P   |       |   |  P S  |  P S  |   S   |
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  +-------+-------+-------+   +-------+-------+-------+   +-------+-------+-------+
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  |       |   G   |       |   |   P   |  G P  |       |   |  P S  | G P S |   S   |
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  +-------+-------+-------+   +-------+-------+-------+   +-------+-------+-------+
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  |       |       |       |   |       |       |       |   |   S   |   S   |   S   |
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  +-------+-------+-------+   +-------+-------+-------+   +-------+-------+-------+
  

  (definition generate-shapings <vector>
    (make-vector 33 #f))
  
  
  (method (generate-chunk index <planar-index>) <World-Chunk>
    (let ((zone (current-zone)))
      (let ((chunk (with-chunks-mutex
                     (lambda ()
                       (table-ref chunks index #f)))))
        (if (and chunk (>= (get-state~ chunk) Generated))
            chunk
          (site (generate on?: #t)
            (let ((region-x (get-x))
                  (region-y (get-y))
                  (region-z (get-z))
                  (chunk-x (planar-index-x index))
                  (chunk-z (planar-index-z index))
                  (access-mutexes (make-vector 9 #f))
                  (shaped-chunks (make-vector 9 #f)))
              (loop (for i from -1 to 1)
                    (loop (for k from -1 to 1)
                          (let ((x (+ chunk-x i))
                                (z (+ chunk-z k)))
                            (let ((region (load-region~ zone (indexed (+ region-x (fxfloor/ x 32)) region-y (+ region-z (fxfloor/ z 32)))))
                                  (index (planar-index (modulo x 32) (modulo z 32))))
                              (let ((mutex (chunk-access-mutex~ region index))
                                    (chunk (shape-chunk~ region index))
                                    (access-index (neighbor-index i k)))
                                (vector-set! access-mutexes access-index mutex)
                                (vector-set! shaped-chunks access-index chunk))))))
              (let ((chunk (populate-chunk index 0 0 shaped-chunks)))
                (define (populate i <fx> k <fx>) <World-Chunk>
                  (let ((x (+ chunk-x i))
                        (z (+ chunk-z k)))
                    (let ((region (load-region~ zone (indexed (+ region-x (fxfloor/ x 32)) region-y (+ region-z (fxfloor/ z 32))))))
                      (populate-chunk~ region (planar-index (modulo x 32) (modulo z 32)) i k shaped-chunks))))
                
                (populate -1 0)
                (populate 0 -1)
                (populate -1 -1)
                (with-shapings-mutex
                  (lambda ()
                    (setup-shapings generate-shapings chunk)
                    (let ((generator (get-generator~ zone)))
                      ;; should move out of generator
                      (generate-skylight~ generator chunk generate-shapings))
                    (extract-shapings generate-shapings chunk)))
                (change-state~ chunk Generated)
                (modified~ chunk)
                (loop (for i from -1 to 1)
                      (loop (for k from -1 to 1)
                            (mutex-unlock! (vector-ref access-mutexes (neighbor-index i k)))))
                (site (save on:? #t parent: generate)
                  (save-region))
                chunk)))))))
  
  
  (method (load-chunk index <planar-index>) <World-Chunk>
    (if (client?)
        (or (with-chunks-mutex
              (lambda ()
                (table-ref chunks index #f)))
            (let ((chunk (read-chunk index)))
              (with-chunks-mutex
                (lambda ()
                  (table-set! chunks (copy-planar-index index) chunk)))
              (instantiate-elements~ chunk)
              chunk))
      (let ((chunk (generate-chunk index)))
        (instantiate-elements~ chunk)
        chunk)))
  
  @reintegrate
  (let ((generator (get-generator~ (current-zone))))
    (when (< (get-generator-revision~ chunk) (get-revision~ generator))
      (regenerate~ chunk)))

  
  (method (load-section-chunk section-index <planar-index>) <World-Chunk>
    (load-chunk (section->chunk-index section-index)))
  
  
  (method (find-chunk section-index <planar-index>) <World-Chunk+>
    (table-ref chunks (section->chunk-index section-index) #f))
  
  
  (method (chunk-header-offset chunk-x <fx> chunk-z <fx>) <fx>
    (* 4 (+ chunk-x (* chunk-z 32))))
  
  
  (method (get-chunk-offset header-offset <fx>) <fx+>
    (let ((b1 (u8vector-ref header header-offset))
          (b2 (u8vector-ref header (+ header-offset 1)))
          (b3 (u8vector-ref header (+ header-offset 2)))
          (b4 (u8vector-ref header (+ header-offset 3))))
      (if (and (= b1 0)
               (= b2 0)
               (= b3 0)
               (= b4 0))
          #f
        (* (+ (arithmetic-shift-left b1 16)
              (arithmetic-shift-left b2 8)
              b3)
           chunk-padding))))
  
  
  (method (get-chunk-size header-offset <fx>) <fx+>
    (* (u8vector-ref header (+ header-offset 3)) chunk-padding))
  
  
  (method (set-chunk-offset header-offset <fx> offset <fx+>)
    (if (not offset)
        (begin
          (u8vector-set! header header-offset 0)
          (u8vector-set! header (+ header-offset 1) 0)
          (u8vector-set! header (+ header-offset 2) 0)
          (u8vector-set! header (+ header-offset 3) 0))
      (assert (= (modulo offset chunk-padding) 0))
      (let ((offset <fx> (/ offset chunk-padding)))
        (let ((b1 (modulo (arithmetic-shift offset -16) 256))
              (b2 (modulo (arithmetic-shift offset -8) 256))
              (b3 (modulo offset 256)))
          (u8vector-set! header header-offset b1)
          (u8vector-set! header (+ header-offset 1) b2)
          (u8vector-set! header (+ header-offset 2) b3)))))
  
  
  (method (set-chunk-size header-offset <fx> size <fx>)
    (let ((count (/ size chunk-padding)))
      (assert (fixnum? count))
      (u8vector-set! header (+ header-offset 3) count)))
  
  
  (method (read-chunk chunk-index <planar-index> (corrupted #f)) <World-Chunk+>
    (let ((chunk-x (planar-index-x chunk-index))
          (chunk-z (planar-index-z chunk-index)))
      (let ((header-offset (chunk-header-offset chunk-x chunk-z)))
        (assert (<= header-offset 4092))
        ;; quick hack to always retrieve until bugs fixed
        (if (eq? tier-kind 'client)
            (let ((server-chunk-raw (retrieve-chunk~ (client-tier) index chunk-index #f)))
              (assert server-chunk-raw
                (let ((digest #f @always-retrieve (object->u8vector (digest-u8vector server-chunk-raw 'SHA-1))))
                  (deserialize-chunk chunk-x chunk-z digest server-chunk-raw))))
          (let ((offset (get-chunk-offset header-offset)))
            (if (not offset)
                (let ((server-chunk-raw (and (eq? tier-kind 'client) (error "not now") (retrieve-chunk~ (client-tier) index chunk-index #f))))
                  (if server-chunk-raw
                      (let ((digest #f @always-retrieve (object->u8vector (digest-u8vector server-chunk-raw 'SHA-1))))
                        (deserialize-chunk chunk-x chunk-z digest server-chunk-raw))
                    #f))
              (input-port-byte-position port offset)
              (let ((chunk-header (u8vector 0 0 0 0 0)))
                (read-subu8vector chunk-header 0 5 port)
                (let ((deflated-size <fx> (scan-u32-big-endian chunk-header 0))
                      (compression-type (u8vector-ref chunk-header 4)))
                  (if (/= compression-type 2)
                      (if corrupted
                          (continuation-return corrupted #f)
                        (assert (= compression-type 2)))
                    (let ((chunk-raw (make-u8vector deflated-size)))
                      (read-subu8vector chunk-raw 0 deflated-size port)
                      (let ((digest #f @always-retrieve (object->u8vector (digest-u8vector chunk-raw 'SHA-1))))
                        (let ((server-chunk-raw (and (eq? tier-kind 'client) (error "not now") (retrieve-chunk~ (client-tier) index chunk-index digest))))
                          (if server-chunk-raw
                              (let ((digest #f @always-retrieve (object->u8vector (digest-u8vector server-chunk-raw 'SHA-1))))
                                (let ((chunk (deserialize-chunk chunk-x chunk-z digest server-chunk-raw)))
                                  (modified~ chunk)
                                  chunk))
                            (deserialize-chunk chunk-x chunk-z digest chunk-raw))))))))))))))
  
  
  (definition inflate-mutex
    (make-mutex 'inflate))
  
  (definition (with-inflate-mutex thunk)
    (mutex-lock! inflate-mutex)
    (prog1 (thunk)
      (mutex-unlock! inflate-mutex)))
  
  
  (method (deserialize-chunk chunk-x chunk-z digest raw) <World-Chunk>
    (define (inflate-chunk chunk-raw)
      (with-inflate-mutex
        (lambda ()
          (let (iter)
            (let ((inflated (zlib-inflate! chunk-buffer chunk-raw)))
              (or inflated
                  (begin
                    (set! chunk-buffer (make-u8vector (fxround (* (u8vector-length chunk-buffer) GOLDEN_GROWTH))))
                    (iter))))))))
    
    (let ((zone <Zone> (current-zone)))
      (let ((chunk-data <u8vector> (inflate-chunk raw)))
        (with ((reader <NBT-Reader> (new NBT-Reader chunk-data compressed?: #f)))
          (let ((tag (read-tag~ reader)))
            (let ((compound (tag-assoc "Level" (tag-value tag))))
              (let ((state (or (tag-assoc "State" compound) Generated))
                    (biomes (tag-assoc "Biomes" compound))
                    (heightmap (tag-assoc "HeightMap" compound))
                    (entities (tag-assoc "Entities" compound))
                    (block-entities (tag-assoc "TileEntities" compound))
                    (sections (tag-assoc "Sections" compound))
                    (elements (tag-assoc "Elements" compound)))
                (let ((chunk (new World-Chunk (planar-index chunk-x chunk-z) state digest (and (processing?) raw) self tag biomes heightmap entities block-entities sections elements)))
                  (when sections
                    (let ((truncate-y (get-truncate-y~ zone)))
                      (for-each (lambda (section)
                                  (let ((yPos (cast <fx> (tag-assoc "Y" section)))
                                        (blocks (tag-assoc "Blocks" section))
                                        (data (tag-assoc "Data" section))
                                        (blocklight (tag-assoc "BlockLight" section))
                                        (skylight (tag-assoc "SkyLight" section)))
                                    (when (or (not truncate-y)
                                              (>= yPos (cast <fx> truncate-y)))
                                      (register-section~ chunk yPos (new World-Section chunk yPos blocks data blocklight skylight)))))
                                (list-payload-content sections))))
                  (generated~ chunk)
                  chunk))))))))
  
  
  (method (load-section section-x <fx> section-y <fx> section-z <fx> (create?: create? #f)) <World-Section+>
    (let ((chunk (load-section-chunk (planar-index section-x section-z))))
      (load-section~ chunk section-y create?: create?)))
  
  
  (method (save-header port)
    (output-port-byte-position port 0)
    (let ((size (u8vector-length header)))
      (write-subu8vector header 0 size port)))
  
  
  (method (save-region)
    (define (save-chunks port)
      (iterate-chunk-indices
        (lambda (x z)
          (let ((chunk (find-chunk (planar-index x z))))
            (when (and chunk (get-modified?~ chunk) (>= (get-state~ chunk) Generated))
              (let ((header-offset (chunk-header-offset x z))
                    (raw-content (serialize-chunk chunk)))
                (set-digest~ chunk #f @always-retrieve (object->u8vector (digest-u8vector raw-content 'SHA-1)))
                (when (processing?)
                  (set-raw~ chunk raw-content))
                (let ((deflated-size (u8vector-length raw-content)))
                  (let ((chunk-size (pad-chunk (+ chunk-header-size deflated-size)))
                        (actual-size (allege (get-chunk-size header-offset))))
                    (define (position-port)
                      (if (<= chunk-size actual-size)
                          (let ((offset (allege (get-chunk-offset header-offset))))
                            (output-port-byte-position port offset)
                            offset)
                        (output-port-byte-position port 0 2)
                        (let ((end (pad-chunk (output-port-byte-position port))))
                          (output-port-byte-position port end)
                          end)))
                    
                    (let ((offset (position-port)))
                      (let ((chunk-header (u8vector 0 0 0 0 0)))
                        (put-u32-big-endian chunk-header 0 deflated-size)
                        (u8vector-set! chunk-header 4 2)
                        (write-subu8vector chunk-header 0 5 port)
                        (write-subu8vector raw-content 0 deflated-size port)
                        (set-chunk-offset header-offset offset)
                        (set-chunk-size header-offset chunk-size))))))
              (reset-modified~ chunk))))))
    
    (define (pad-chunk size <fx>) <fx>
      (let ((mod (modulo size chunk-padding)))
        (if (= mod 0)
            size
          (+ size (- chunk-padding mod)))))
    
    (define (needs-compaction? port)
      (define (actual-size)
        (output-port-byte-position port 0 2)
        (output-port-byte-position port))
      
      (define (compact-size)
        (let ((size region-header-size))
          (iterate-chunk-indices
            (lambda (x z)
              (let ((header-offset (chunk-header-offset x z)))
                (increase! size (get-chunk-size header-offset)))))
          size))
      
      (let ((percentage-threshold 125.))
        (>= (percentage (actual-size) (compact-size)) percentage-threshold)))
    
    (define (save)
      (save-chunks port)
      (save-header port)
      (when (needs-compaction? port)
        (set! compact? #t)))
    
    (with-mutex
      (lambda ()
        (when modified?
          (save)
          (reset-modified)))))
  
  
  (method (compact-region)
    (define (read-chunks)
      (let ((chunks (new-queue)))
        (iterate-chunk-indices
          (lambda (x z)
            (let ((header-offset (chunk-header-offset x z)))
              (let ((offset (get-chunk-offset header-offset)))
                (if (not offset)
                    (enqueue chunks #f)
                  (let ((size (get-chunk-size header-offset)))
                    (input-port-byte-position port offset)
                    (let ((chunk (make-u8vector size)))
                      (read-subu8vector chunk 0 size port)
                      (enqueue chunks chunk))))))))
        (queue-list chunks)))
    
    (define (save-chunks port chunks)
      (let ((offset region-header-size))
        (output-port-byte-position port offset)
        (iterate-chunk-indices
          (lambda (x z)
            (let ((header-offset (chunk-header-offset x z))
                  (chunk (car chunks)))
              (set! chunks (cdr chunks))
              (if (not chunk)
                  (set-chunk-offset header-offset #f)
                (let ((size (u8vector-length chunk)))
                  (write-subu8vector chunk 0 size port)
                  (set-chunk-offset header-offset offset)
                  (set-chunk-size header-offset size)
                  (increase! offset size))))))))
    
    (define (compact)
      (let ((chunks (read-chunks)))
        (close-port port)
        (call-with-output-file (path-settings file truncate: #t)
          (lambda (port)
            (save-chunks port chunks)
            (save-header port)))))
    
    (if (not compact?)
        (close-port port)
      (compact)
      (set! compact? #f)))
  
  
  (method (iterate-chunk-indices proc)
    (loop (for z from 0 below 32)
          (loop (for x from 0 below 32)
                (proc x z))))
  
  
  (method (serialize-chunk chunk <World-Chunk>) <u8vector>
    (with ((writer <NBT-Writer> (new NBT-Writer #f)))
      (write-tag~ writer (get-tag~ chunk))
      (get-content~ writer)))
  
  
  (method protected (reset-modified)
    (set! modified? #f))
  
  
  (method protected (modified)
    (set! modified? #t))))
