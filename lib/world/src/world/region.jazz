;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Regions
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.region jazz


(import (jazz.geometry)
        (jazz.io)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.autoload)
        (world.binary)
        (world.chunk)
        (world.generation.block)
        (world.geometry)
        (world.homogeneous)
        (world.index)
        (world.layer)
        (world.section)
        (world.syntax (phase syntax))
        (world.tag))


(proclaim (warn optimizations))


(constant inline region-size <fx>
  32)

(constant inline region-header-size <fx>
  8192
  @wait-constant-folding
  (* 8 1024))

(constant inline chunk-padding <fx>
  4096
  @wait-constant-folding
  (* 4 1024))

(constant inline chunk-header-size <fx>
  5)

(constant inline zlib-header-size <fx>
  2)

(constant inline zlib-footer-size <fx>
  4)


(definition protected chunk-buffer
  (make-u8vector 262144))


;; looks like we don't need to adjust for negative values like stated on the wiki
(definition protected inline (section->chunk x/z <fx>) <fx>
  (modulo x/z 32))


(definition chunks-mutex
  (make-mutex 'chunks))


(definition (with-chunks-mutex thunk)
  (mutex-lock! chunks-mutex)
  (prog1 (thunk)
    (mutex-unlock! chunks-mutex)))


(definition region-mutex
  (make-mutex 'region))


(definition (with-region-mutex thunk)
  (mutex-lock! region-mutex)
  (prog1 (thunk)
    (mutex-unlock! region-mutex)))


;;;
;;;; Pool
;;;


(constant sections-cardinality <fx>
  (* 5 32))

(definition protected sections-pool <vector>
  (make-vector sections-cardinality #f))

(definition protected sections-allocated <fx>
  0)

(definition protected sections-available <fx>
  0)


(definition protected (make-section$ section-y) <World-Section>
  (if (= sections-available 0)
      (assert (< sections-allocated sections-cardinality)
        (increase! sections-allocated)
        (make-section section-y))
    (decrease! sections-available)
    (let ((section (vector-ref sections-pool sections-available)))
      (set-y~ section section-y)
      (vector-set! sections-pool sections-available #f)
      section)))


(definition protected (free-section$ section <World-Section>) <void>
  (assert (< sections-available sections-cardinality))
  (vector-set! sections-pool sections-available section)
  (increase! sections-available))


(definition protected (keep-section$ section)
  (assert (> sections-allocated 0))
  (decrease! sections-allocated))


;;;
;;;; Region
;;;


(class World-Region extends Object
  
  
  (slot x         <fx>                                            getter generate)
  (slot y         <fx>                                            getter generate)
  (slot z         <fx>                                            getter generate)
  (slot file      <File>                                          getter generate)
  (slot port      <port>                                          getter generate)
  (slot header    <u8vector>                                      getter generate)
  (slot chunks    <table>    initialize (make-table test: equal? weak-values: #t) getter generate)
  (slot modified? <bool>     initialize #f                        accessors generate)
  (slot compact?  <bool>     initialize #f                        accessors generate)
  
  
  (method override (initialize x y z file)
    (set! x~self x)
    (set! y~self y)
    (set! z~self z)
    (set! file~self file)
    (set! port~self (open-file (path-settings file)))
    (set! header (read-header))
    (make-will self
      (lambda (obj)
        ;; because of the will, the object will only be recycled on
        ;; the next garbage collection, so we have to remove it from
        ;; table ourself to make sure it cannot be referenced anymore
        (unlink-region~ (current-zone) obj)
        (close-port port))))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a} {a}" x y z))))
  
  
  (method override (destroy)
    (compact-region)
    (nextmethod))
  
  
  (method (get-index&)
    (index& x y z))
  
  
  (method (read-header)
    (with-region-mutex
      (lambda ()
        (let ((size region-header-size))
          (let ((content (make-u8vector size)))
            (read-subu8vector content 0 size port)
            content)))))
  
  
  (definition shapings <vector>
    (make-vector 33 #f))
  
  
  (method (setup-shapings shapings <vector> chunk <World-Chunk>)
    (let ((table (get-sections-table~ chunk)))
      (when table
        (iterate-table table
          (lambda (y section)
            (let ((actual <World-Section+> (vector-ref shapings y)))
              (when actual
                (free-section$ actual))
              (vector-set! shapings y section))))))
    (loop (for y from 0 below 32)
          (let ((section <World-Section+> (vector-ref shapings y)))
            (if section
                (set-touched~ section 0)
              (vector-set! shapings y (make-section$ y)))))
    (vector-set! shapings 32 chunk))
  
  
  (method (extract-shapings shapings <vector> chunk <World-Chunk>)
    (loop (for y from 0 below 32)
          (let ((section <World-Section> (vector-ref shapings y)))
            (if (= (get-touched~ section) 0)
                (when (get-chunk~ section)
                  (vector-set! shapings y #f))
              (if (get-chunk~ section)
                  (modified~ chunk)
                (keep-section$ section)
                (setup-section~ chunk section))
              (vector-set! shapings y #f)))))
  
  
  (method (shape-chunk chunk-x <fx> chunk-z <fx>) <World-Chunk>
    (let ((zone (current-zone)))
      (let ((chunk-index (planar-index& chunk-x chunk-z)))
        (define (make-chunk)
          (let ((biomes (make-tag "Biomes" TAG_Byte_Array (generate-u8biomes x z chunk-x chunk-z)))
                (heightmap (make-tag "HeightMap" TAG_Int_Array (make-vector 256 0)))
                (entities (make-tag "Entities" TAG_List (make-list-payload 0 '())))
                (block-entities (make-tag "TileEntities" TAG_List (make-list-payload 0 '())))
                (sections (make-tag "Sections" TAG_List (make-list-payload TAG_Compound '()))))
            (let ((tag (make-tag "" TAG_Compound
                         (list
                           (make-tag "Level" TAG_Compound
                             (list
                               biomes heightmap entities block-entities sections))))))
              (let ((chunk (new World-Chunk Shaped #f #f self tag (tag-value biomes) (tag-value heightmap) (tag-value entities) (tag-value block-entities) (tag-value sections) #f chunk-index)))
                (setup-shapings shapings chunk)
                (let ((generator (get-generator~ zone)))
                  (shape~ generator chunk shapings))
                (extract-shapings shapings chunk)
                (generated~ chunk)
                (modified~ chunk)
                chunk))))
        
        (let ((chunk (table-ref chunks chunk-index #f)))
          (if chunk
              (let ((generator (get-generator~ zone)))
                (when (< (get-generator-revision~ chunk) (get-revision~ generator))
                  (regenerate~ chunk))
                chunk)
            (let ((read-chunk (read-chunk chunk-index)))
              (let ((chunk (or read-chunk (make-chunk))))
                (table-set! chunks (copy-planar-index chunk-index) chunk)
                chunk)))))))
  
  
  (definition chunk-shapings <vector>
    (make-vector 33 #f))
  
  (definition front-shapings <vector>
    (make-vector 33 #f))
  
  (definition corner-shapings <vector>
    (make-vector 33 #f))
  
  (definition right-shapings <vector>
    (make-vector 33 #f))
  
  
  (method (populate-chunk chunk-x <fx> chunk-z <fx>) <World-Chunk>
    (let ((zone (current-zone)))
      (let ((chunk (shape-chunk chunk-x chunk-z)))
        (if (>= (get-state~ chunk) Populated)
            chunk
          (let ((region-x x)
                (region-y y)
                (region-z z))
            (define (shape x <fx> z <fx>) <World-Chunk>
              (let ((region (load-region~ zone (+ region-x (fxfloor/ x 32)) region-y (+ region-z (fxfloor/ z 32)))))
                (shape-chunk~ region (modulo x 32) (modulo z 32))))
            
            (let ((front (shape chunk-x (+ chunk-z 1)))
                  (corner (shape (+ chunk-x 1) (+ chunk-z 1)))
                  (right (shape (+ chunk-x 1) chunk-z)))
              (setup-shapings chunk-shapings chunk)
              (setup-shapings front-shapings front)
              (setup-shapings corner-shapings corner)
              (setup-shapings right-shapings right)
              (let ((generator (get-generator~ zone)))
                (populate~ generator chunk-shapings front-shapings corner-shapings right-shapings))
              (extract-shapings chunk-shapings chunk)
              (extract-shapings front-shapings front)
              (extract-shapings corner-shapings corner)
              (extract-shapings right-shapings right)
              (change-state~ chunk Populated)
              (modified~ chunk)
              chunk))))))
  
  
  ;;  +-------+-------+-------+   +-------+-------+-------+   +-------+-------+-------+
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  |       |       |       |   |   P   |   P   |       |   |  P S  |  P S  |   S   |
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  +-------+-------+-------+   +-------+-------+-------+   +-------+-------+-------+
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  |       |   G   |       |   |   P   |  G P  |       |   |  P S  | G P S |   S   |
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  +-------+-------+-------+   +-------+-------+-------+   +-------+-------+-------+
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  |       |       |       |   |       |       |       |   |   S   |   S   |   S   |
  ;;  |       |       |       |   |       |       |       |   |       |       |       |
  ;;  +-------+-------+-------+   +-------+-------+-------+   +-------+-------+-------+
  
  (method (generate-chunk chunk-x <fx> chunk-z <fx>) <World-Chunk>
    (let ((zone (current-zone)))
      (let ((chunk-index (planar-index& chunk-x chunk-z)))
        (let ((chunk (table-ref chunks chunk-index #f)))
          (if (and chunk (>= (get-state~ chunk) Generated))
              chunk
            (site (generate on?: #t)
              (let ((chunk (populate-chunk chunk-x chunk-z))
                    (region-x x)
                    (region-y y)
                    (region-z z))
                (define (populate x <fx> z <fx>) <World-Chunk>
                  (let ((region (load-region~ zone (+ region-x (fxfloor/ x 32)) region-y (+ region-z (fxfloor/ z 32)))))
                    (populate-chunk~ region (modulo x 32) (modulo z 32))))
                
                (populate (- chunk-x 1) chunk-z)
                (populate chunk-x (- chunk-z 1))
                (populate (- chunk-x 1) (- chunk-z 1))
                (setup-shapings shapings chunk)
                (let ((generator (get-generator~ zone)))
                  ;; should move out of generator
                  (generate-skylight~ generator chunk shapings))
                (extract-shapings shapings chunk)
                (change-state~ chunk Generated)
                (modified~ chunk)
                (site (save on:? #t parent: generate)
                  (save-region))
                chunk)))))))
  
  
  (method (load-chunk chunk-x <fx> chunk-z <fx>) <World-Chunk>
    (with-chunks-mutex
      (lambda ()
        (let ((chunk (generate-chunk chunk-x chunk-z)))
          (instantiate-elements~ chunk)
          chunk))))
  
  @reintegrate
  (let ((generator (get-generator~ (current-zone))))
    (when (< (get-generator-revision~ chunk) (get-revision~ generator))
      (regenerate~ chunk)))

  
  (method (load-section-chunk section-x <fx> section-z <fx>) <World-Chunk>
    (load-chunk (section->chunk section-x) (section->chunk section-z)))
  
  
  (method (find-chunk section-x <fx> section-z <fx>) <World-Chunk+>
    (table-ref chunks (planar-index& (section->chunk section-x) (section->chunk section-z)) #f))
  
  
  (method (chunk-header-offset chunk-x <fx> chunk-z <fx>) <fx>
    (* 4 (+ chunk-x (* chunk-z 32))))
  
  
  (method (get-chunk-offset header-offset <fx>) <fx+>
    (let ((b1 (u8vector-ref header header-offset))
          (b2 (u8vector-ref header (+ header-offset 1)))
          (b3 (u8vector-ref header (+ header-offset 2)))
          (b4 (u8vector-ref header (+ header-offset 3))))
      (if (and (= b1 0)
               (= b2 0)
               (= b3 0)
               (= b4 0))
          #f
        (* (+ (arithmetic-shift-left b1 16)
              (arithmetic-shift-left b2 8)
              b3)
           chunk-padding))))
  
  
  (method (get-chunk-size header-offset <fx>) <fx+>
    (* (u8vector-ref header (+ header-offset 3)) chunk-padding))
  
  
  (method (set-chunk-offset header-offset <fx> offset <fx+>)
    (if (not offset)
        (begin
          (u8vector-set! header header-offset 0)
          (u8vector-set! header (+ header-offset 1) 0)
          (u8vector-set! header (+ header-offset 2) 0)
          (u8vector-set! header (+ header-offset 3) 0))
      (assert (= (modulo offset chunk-padding) 0))
      (let ((offset <fx> (/ offset chunk-padding)))
        (let ((b1 (modulo (arithmetic-shift offset -16) 256))
              (b2 (modulo (arithmetic-shift offset -8) 256))
              (b3 (modulo offset 256)))
          (u8vector-set! header header-offset b1)
          (u8vector-set! header (+ header-offset 1) b2)
          (u8vector-set! header (+ header-offset 2) b3)))))
  
  
  (method (set-chunk-size header-offset <fx> size <fx>)
    (let ((count (/ size chunk-padding)))
      (assert (fixnum? count))
      (u8vector-set! header (+ header-offset 3) count)))
  
  
  (method (read-chunk chunk-index <planar-index>) <World-Chunk+>
    (with-region-mutex
      (lambda ()
        (let ((chunk-x (planar-index-x chunk-index))
              (chunk-z (planar-index-z chunk-index)))
          (let ((header-offset (chunk-header-offset chunk-x chunk-z)))
            (assert (<= header-offset 4092))
            ;; quick hack to always retrieve until bugs fixed
            (if (eq? tier-kind 'client)
                (let ((server-chunk-raw (retrieve-chunk~ (client-tier) x y z chunk-x chunk-z #f)))
                  (assert server-chunk-raw
                    (let ((digest #f @always-retrieve (object->u8vector (digest-u8vector server-chunk-raw 'SHA-1))))
                      (deserialize-chunk 1 chunk-x chunk-z digest server-chunk-raw))))
              (let ((offset (get-chunk-offset header-offset)))
                (if (not offset)
                    (let ((server-chunk-raw (and (eq? tier-kind 'client) (error "not now") (retrieve-chunk~ (client-tier) x y z chunk-x chunk-z #f))))
                      (if server-chunk-raw
                          (let ((digest #f @always-retrieve (object->u8vector (digest-u8vector server-chunk-raw 'SHA-1))))
                            (deserialize-chunk 2 chunk-x chunk-z digest server-chunk-raw))
                        #f))
                  (input-port-byte-position port offset)
                  (let ((chunk-header (u8vector 0 0 0 0 0)))
                    (read-subu8vector chunk-header 0 5 port)
                    (let ((deflated-size <fx> (scan-u32-big-endian chunk-header 0))
                          (compression-type (u8vector-ref chunk-header 4)))
                      (assert (= compression-type 2))
                      (let ((chunk-raw (make-u8vector deflated-size)))
                        (read-subu8vector chunk-raw 0 deflated-size port)
                        (let ((digest #f @always-retrieve (object->u8vector (digest-u8vector chunk-raw 'SHA-1))))
                          (let ((server-chunk-raw (and (eq? tier-kind 'client) (error "not now") (retrieve-chunk~ (client-tier) x y z chunk-x chunk-z digest))))
                            (if server-chunk-raw
                                (let ((digest #f @always-retrieve (object->u8vector (digest-u8vector server-chunk-raw 'SHA-1))))
                                  (let ((chunk (deserialize-chunk 3 chunk-x chunk-z digest server-chunk-raw)))
                                    (modified~ chunk)
                                    chunk))
                              (deserialize-chunk 4 chunk-x chunk-z digest chunk-raw)))))))))))))))
  
  
  (method (deserialize-chunk which chunk-x chunk-z digest raw) <World-Chunk>
    (define (inflate-chunk chunk-raw)
      (let (iter)
        (let ((inflated (zlib-inflate! chunk-buffer chunk-raw)))
          (or inflated
              (begin
                (set! chunk-buffer (make-u8vector (fxround (* (u8vector-length chunk-buffer) GOLDEN_GROWTH))))
                (iter))))))
    
    (let ((zone <Zone> (current-zone)))
      (let ((chunk-data <u8vector> (inflate-chunk raw)))
        (with ((reader <NBT-Reader> (new NBT-Reader chunk-data compressed?: #f)))
          (let ((tag (read-tag~ reader)))
            (let ((compound (tag-assoc "Level" (tag-value tag))))
              (let ((state (or (tag-assoc "State" compound) Generated))
                    (biomes (tag-assoc "Biomes" compound))
                    (heightmap (tag-assoc "HeightMap" compound))
                    (entities (tag-assoc "Entities" compound))
                    (block-entities (tag-assoc "TileEntities" compound))
                    (sections (tag-assoc "Sections" compound))
                    (elements (tag-assoc "Elements" compound)))
                (let ((chunk (new World-Chunk state digest (and (or (eq? tier-kind 'server) (eq? tier-kind 'processor)) raw) self tag biomes heightmap entities block-entities sections elements (planar-index chunk-x chunk-z))))
                  (when sections
                    (let ((truncate-y (get-truncate-y~ zone)))
                      (for-each (lambda (section)
                                  (let ((yPos (cast <fx> (tag-assoc "Y" section)))
                                        (blocks (tag-assoc "Blocks" section))
                                        (data (tag-assoc "Data" section))
                                        (blocklight (tag-assoc "BlockLight" section))
                                        (skylight (tag-assoc "SkyLight" section)))
                                    (when (or (not truncate-y)
                                              (>= yPos (cast <fx> truncate-y)))
                                      (register-section~ chunk yPos (new World-Section chunk yPos blocks data blocklight skylight)))))
                                (list-payload-content sections))))
                  (generated~ chunk)
                  chunk))))))))
  
  
  (method (load-section section-x <fx> section-y <fx> section-z <fx> (create?: create? #f)) <World-Section+>
    (let ((chunk (load-section-chunk section-x section-z)))
      (load-section~ chunk section-x section-y section-z create?: create?)))
  
  
  (method (save-header port)
    (output-port-byte-position port 0)
    (let ((size (u8vector-length header)))
      (write-subu8vector header 0 size port)))
  
  
  (method (save-region)
    (define (save-chunks port)
      (iterate-chunks
        (lambda (x z)
          (let ((chunk (find-chunk x z)))
            (when (and chunk (get-modified?~ chunk) (>= (get-state~ chunk) Generated))
              (let ((header-offset (chunk-header-offset x z))
                    (raw-content (serialize-chunk chunk)))
                (set-digest~ chunk #f @always-retrieve (object->u8vector (digest-u8vector raw-content 'SHA-1)))
                (when (or (eq? tier-kind 'server)
                          (eq? tier-kind 'processor))
                  (set-raw~ chunk raw-content))
                (let ((deflated-size (u8vector-length raw-content)))
                  (let ((chunk-size (pad-chunk (+ chunk-header-size deflated-size)))
                        (actual-size (allege (get-chunk-size header-offset))))
                    (define (position-port)
                      (if (<= chunk-size actual-size)
                          (let ((offset (allege (get-chunk-offset header-offset))))
                            (output-port-byte-position port offset)
                            offset)
                        (output-port-byte-position port 0 2)
                        (let ((end (pad-chunk (output-port-byte-position port))))
                          (output-port-byte-position port end)
                          end)))
                    
                    (let ((offset (position-port)))
                      (let ((chunk-header (u8vector 0 0 0 0 0)))
                        (put-u32-big-endian chunk-header 0 deflated-size)
                        (u8vector-set! chunk-header 4 2)
                        (write-subu8vector chunk-header 0 5 port)
                        (write-subu8vector raw-content 0 deflated-size port)
                        (set-chunk-offset header-offset offset)
                        (set-chunk-size header-offset chunk-size))))))
              (reset-modified~ chunk))))))
    
    (define (pad-chunk size <fx>) <fx>
      (let ((mod (modulo size chunk-padding)))
        (if (= mod 0)
            size
          (+ size (- chunk-padding mod)))))
    
    (define (needs-compaction? port)
      (define (actual-size)
        (output-port-byte-position port 0 2)
        (output-port-byte-position port))
      
      (define (compact-size)
        (let ((size region-header-size))
          (iterate-chunks
            (lambda (x z)
              (let ((header-offset (chunk-header-offset x z)))
                (increase! size (get-chunk-size header-offset)))))
          size))
      
      (let ((percentage-threshold 125.))
        (>= (percentage (actual-size) (compact-size)) percentage-threshold)))
    
    (define (save)
      (save-chunks port)
      (save-header port)
      (when (needs-compaction? port)
        (set! compact? #t)))
    
    (when modified?
      (with-region-mutex
        (lambda ()
          (save)
          (reset-modified)))))
  
  
  (method (compact-region)
    (define (read-chunks)
      (let ((chunks (new-queue)))
        (iterate-chunks
          (lambda (x z)
            (let ((header-offset (chunk-header-offset x z)))
              (let ((offset (get-chunk-offset header-offset)))
                (if (not offset)
                    (enqueue chunks #f)
                  (let ((size (get-chunk-size header-offset)))
                    (input-port-byte-position port offset)
                    (let ((chunk (make-u8vector size)))
                      (read-subu8vector chunk 0 size port)
                      (enqueue chunks chunk))))))))
        (queue-list chunks)))
    
    (define (save-chunks port chunks)
      (let ((offset region-header-size))
        (output-port-byte-position port offset)
        (iterate-chunks
          (lambda (x z)
            (let ((header-offset (chunk-header-offset x z))
                  (chunk (car chunks)))
              (set! chunks (cdr chunks))
              (if (not chunk)
                  (set-chunk-offset header-offset #f)
                (let ((size (u8vector-length chunk)))
                  (write-subu8vector chunk 0 size port)
                  (set-chunk-offset header-offset offset)
                  (set-chunk-size header-offset size)
                  (increase! offset size))))))))
    
    (define (compact)
      (let ((chunks (read-chunks)))
        (close-port port)
        (call-with-output-file (path-settings file truncate: #t)
          (lambda (port)
            (save-chunks port chunks)
            (save-header port)))))
    
    (if (not compact?)
        (close-port port)
      (with-region-mutex
        (lambda ()
          (compact)
          (set! compact? #f)))))
  
  
  (method protected (iterate-chunks proc)
    (loop (for z from 0 below 32)
          (loop (for x from 0 below 32)
                (proc x z))))
  
  
  (method (serialize-chunk chunk <World-Chunk>) <u8vector>
    (with ((writer <NBT-Writer> (new NBT-Writer #f)))
      (write-tag~ writer (get-tag~ chunk))
      (get-content~ writer)))
  
  
  (method protected (reset-modified)
    (set! modified? #f))
  
  
  (method protected (modified)
    (set! modified? #t))))
