;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.io)
        (jazz.stream)
        (world)
        (world.audio)
        (world.context)
        (world.event)
        (world.media)
        (world.settings)
        (world.stream)
        (world.udp)
        (world.video))


;;;
;;;; Stream
;;;


(definition public (make-stream name source-kind video-level (can-local?: can-local? #f))
  (let ((client (current-client)))
    (let ((recipient (if (and can-local? stream-local?) client-no #f)))
      (register-stream client name source-kind video-level recipient #f))))


(definition protected (stream-controller-action stream action arguments)
  (case action
    ((pause)
     (stream-pause stream))
    ((play)
     (stream-play stream))
    ((seek)
     (bind (pos) arguments
       (stream-seek stream pos)))
    ((mute)
     (stream-mute stream))
    ((unmute)
     (stream-unmute stream))))


(definition (stream-pause stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (pause channel))))


(definition (stream-play stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (play channel))))


(definition (stream-seek stream pos)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (let ((src (get-src (get-pipeline channel))))
        (seek src pos)))))


(definition (stream-mute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (mute src))))


(definition (stream-unmute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (unmute src))))


;;;
;;;; Audio
;;;


(definition (client-audio-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer timestamp duration)
    (case audio-codec
      ((opus)
       (when mirror?
         (receive-audio (current-audio) channel-no buffer timestamp duration))
       (unless local?
         (let ((header? (and buffer (audio-buffer-header? buffer))))
           (send-client-media client channel-no buffer header? timestamp duration))))
      ((vorbis)
       (cond ((pair? buffer)
              (when mirror?
                (let ((headers (u8vector->object (car buffer))))
                  (for-each (lambda (header)
                              (bind (buffer timestamp duration) header
                                (receive-audio (current-audio) channel-no buffer timestamp duration)))
                            headers)))
              (unless local?
                (send-client-media client channel-no (car buffer) #t -1 GST_CLOCK_TIME_NONE)))
             (else
              (when mirror?
                (receive-audio (current-audio) channel-no buffer timestamp duration))
              (unless local?
                (send-client-media client channel-no buffer #f timestamp duration))))))))


(definition public (add-audio-channel stream-no location)
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (add-channel client stream-no udp-audio 'stream #f #f #f #f audio-codec recipient #f)))
        (let ((channel-no (get-no channel)))
          (let ((src (new File-Stream-Audio-Src
                       location))
                (sink (new Stream-Consumer
                        consumer: (client-audio-consumer client channel-no mirror?: #t local?: stream-local?))))
            (let ((pipeline (pipeline (list src sink))))
              (set-pipeline channel pipeline)
              channel)))))))


(definition public (add-mic-channel stream-no)
  (let ((client (current-client)))
    (let ((channel (add-channel client stream-no udp-audio 'live #f #f #f #f audio-codec #f #t)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Mic-Audio-Src))
              (sink (new Stream-Consumer
                      consumer: (client-audio-consumer client channel-no))))
          (let ((pipeline (pipeline (list src sink))))
            (set-pipeline channel pipeline)
            channel))))))


;;;
;;;; Video
;;;


(definition (client-video-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer timestamp duration)
    (when mirror?
      (receive-video (current-video) channel-no buffer timestamp duration))
    (unless local?
      (let ((header? (and buffer (video-buffer-header? buffer))))
        (send-client-media client channel-no buffer header? timestamp duration)))))


(definition public (add-draw-channel draw-proc action-proc)
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (add-channel client udp-video 'draw #f draw-resolution #f draw-bitrate #f recipient #f)))
        (let ((channel-no (get-no channel)))
          (let ((src (new Draw-Video-Src
                       draw-proc: draw-proc))
                (sink (new Stream-Consumer
                        consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
            (let ((pipeline (pipeline (list src sink))))
              (set-pipeline channel pipeline)
              (set-action-proc channel action-proc)
              channel)))))))


(definition public (add-image-channel stream-no location (action-proc: action-proc #f))
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (add-channel client stream-no udp-video 'image #f draw-resolution #f draw-bitrate #f recipient #f)))
        (let ((channel-no (get-no channel)))
          (let ((src (new Image-Stream-Video-Src
                       location))
                (sink (new Stream-Consumer
                        consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
            (let ((pipeline (pipeline (list src sink))))
              (set-pipeline channel pipeline)
              (set-action-proc channel action-proc)
              channel)))))))


(definition public (add-video-channels stream-no location (action-proc: action-proc #f))
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (collect (lambda (profile)
                 (and (exists? (new-file {Directory Settings} (list "streams" (add-extension location (get-extension profile)))))
                      (let ((level (get-level profile))
                            (resolution (get-resolution profile))
                            (framerate (get-framerate profile))
                            (bitrate (get-bitrate profile))
                            (codec (get-codec profile)))
                        (let ((channel (add-channel client stream-no udp-video 'stream level resolution framerate bitrate codec recipient #f)))
                          (let ((channel-no (get-no channel)))
                            (let ((src (new File-Stream-Video-Src
                                         profile
                                         location))
                                  (sink (new Stream-Consumer
                                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
                              (let ((pipeline (pipeline (list src sink))))
                                (set-pipeline channel pipeline)
                                (set-action-proc channel action-proc)
                                channel)))))))
           (streaming-video-profiles)))))


(definition public (add-camera-channels stream-no)
  (let ((client (current-client)))
    (let ((camera-profile (name->video-profile camera-profile)))
      (let ((profiles (streaming-profiles camera-profile)))
        (let ((channels (map (lambda (profile)
                               (let ((level (get-level profile))
                                     (resolution (get-resolution profile))
                                     (framerate (get-framerate profile))
                                     (bitrate (get-bitrate profile))
                                     (codec (get-codec profile)))
                                 (add-channel client stream-no udp-video 'live level resolution framerate bitrate codec #f #t)))
                             profiles)))
          (let ((src (new Camera-Video-Src
                       resolution: (get-resolution camera-profile)
                       framerate: (get-framerate camera-profile)
                       bitrate: (get-bitrate camera-profile)
                       codec: (get-codec camera-profile)))
                (sinks (map (lambda (channel profile)
                              (new Camera-Video-Consumer
                                (get-no channel)
                                profile))
                            channels
                            profiles))
                (self-sink (new Self-Consumer
                             caps: 'self
                             resolution: (get-resolution camera-profile))))
            (let ((pipeline (pipeline `(,src ,@sinks ,self-sink))))
              (for-each (lambda (channel)
                          (set-pipeline channel pipeline))
                        channels)
              channels)))))))


(definition public (add-screen-channel stream-no)
  (let ((client (current-client)))
    (let ((channel (add-channel client stream-no udp-video 'screen #f screen-share-resolution screen-share-framerate screen-share-bitrate screen-share-codec #f #t)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Screen-Video-Src
                     resolution: screen-share-resolution
                     framerate: screen-share-framerate
                     bitrate: screen-share-bitrate
                     codec: screen-share-codec))
              (sink (new Screen-Video-Consumer
                      channel-no))
              @wait (self-sink (new Self-Consumer
                                 resolution: screen-share-resolution)))
          (let ((pipeline (pipeline (list src sink) @wait (list src sink self-sink))))
            (set-pipeline channel pipeline)
            channel))))))


;;;
;;;; Streams
;;;


(definition protected stream-multiple?
  (world-setting 'world.stream-multiple? #f))

(definition protected stream-repeatable?
  (world-setting 'world.stream-repeatable? #f))

(definition protected stream-private?
  (world-setting 'world.stream-private? #f))

(definition protected stream-silent?
  (world-setting 'world.stream-silent? #f))

(definition protected stream-local?
  (world-setting 'world.stream-local? #f))


(definition public streams-dir
  {Directory Settings "streams"})


(definition protected (iterate-streams subdir proc)
  (define (iterate dir private?)
    (unless (and (eq? stream-private? 'only)
                 (not private?))
      (iterate-directory dir
        (lambda (file)
          (proc file))
        files?: #t
        directories?: #f
        recursive?: #f))
    (iterate-directory dir
      (lambda (subdir)
        (let ((private-dir? (filename=? (get-name subdir) "private")))
          (when (or stream-private?
                    (not private-dir?))
            (iterate subdir (or private? private-dir?)))))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (let ((dir (new-directory streams-dir subdir)))
    (when (exists? dir)
      (iterate dir #f))))


;;;
;;;; Streaming
;;;


(definition protected (delay-streaming thunk (delay #f))
  ;; so that the channel-add calls are not blocked
  (delay-event
    (lambda ()
      ;; because the channel-add calls use tcp, the first udp packets
      ;; will often arrive before them hence the need for a small delay
      (sleep (or delay .1))
      (thunk))))


;;;
;;;; Convert
;;;


(definition protected (convert-streams dir (dry?: dry? #f))
  (iterate-directory dir
    (lambda (file)
      (let ((extension (get-extension file)))
        (when (member? extension '("streamaudio"
                                   "streamvideo0"
                                   "streamvideo1"
                                   "streamvideo2"
                                   "streamvideo3"
                                   "streamvideo4"))
          (convert-stream file dry?: dry?))))
    files?: #t
    directories?: #f
    recursive?: #t))


(definition protected (convert-stream file (dry?: dry? #f))
  (declare (proper-tail-calls))
  (let ((name (get-name file))
        (base (get-base file))
        (extension (get-extension file)))
    (define (determine-information)
      (cond ((starts-with? extension "streamaudio")
             (values 'audio #f #f #f #f 'vorbis))
            ((starts-with? extension "streamvideo")
             (let ((level (string->number (substring extension (string-length "streamvideo") (string-length extension)))))
               (let ((profile (level->video-profile level)))
                 (values 'video level (get-resolution profile) (get-framerate profile) (get-bitrate profile) (get-codec profile)))))
            (else
             (error "Unable to convert stream: {a}" name))))
    
    (define (convert-to temp-file)
      (receive (kind level resolution framerate bitrate codec) (determine-information)
        (let ((start-time (current-seconds)))
          (let ((reader (new Stream-Reader file))
                (writer (new Stream-Writer2 temp-file kind level resolution framerate bitrate codec)))
            (terminal-string (format "{a}" name))
            (let (loop (count 0))
              (receive (buffer timestamp duration) (read-frame reader #t)
                (if buffer
                    (begin
                      (write-frame writer buffer timestamp duration)
                      (when (= (modulo count 100) 0)
                        (terminal-string "."))
                      (loop (+ count 1)))
                  (close reader)
                  (close writer)
                  (terminal-string (format "({a})" (present-seconds (- (current-seconds) start-time))))
                  (terminal-newline))))))))
    
    (if dry?
        (terminal name)
      (let ((temp-extension (string-append "temp" extension)))
        (let ((temp-file (new-brother file (add-extension base temp-extension))))
          (convert-to temp-file)
          (delete file)
          (rename temp-file file)))))))
