;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.io)
        (jazz.stream)
        (world)
        (world.audio)
        (world.context)
        (world.event)
        (world.media)
        (world.settings)
        (world.stream)
        (world.udp)
        (world.video))


(definition protected camera-single?
  (world-setting 'world.camera-single? #f))


;;;
;;;; Channel
;;;


(class Channel-Creator extends Object
  
  
  (slot descriptor     getter generate)
  (slot create         getter generate)
  (slot share-pipeline getter generate)
  
  
  (method override (initialize self descriptor create (share-pipeline #f))
    (nextmethod self)
    (set! self.descriptor descriptor)
    (set! self.create create)
    (set! self.share-pipeline share-pipeline)))


;;;
;;;; Stream
;;;


(definition public (determine-stream-video-level creators)
  (let ((levels (map (lambda (creator)
                       (bind (media-kind source-kind level) (get-descriptor creator)
                         (assert (= media-kind udp-video)
                           level)))
                     creators)))
    (if (memv? #f levels)
        #f
      (maximum levels))))


(definition public (make-stream name source-kind video-level creators (location: location #f) (can-local?: can-local? #f))
  (let ((client (current-client)))
    (let ((recipient (if (and can-local? stream-local?)
                         '()
                       #f))
          (channels (map get-descriptor creators)))
      (bind (stream-no . channel-nos) (register-stream client name source-kind video-level channels recipient)
        (let ((stream (register-send-stream (get-udp-client client) (get-character-name client) name stream-no source-kind video-level)))
          (set-location stream location)
          (for-each (lambda (channel-no creator)
                      (let ((create (get-create creator)))
                        (create stream-no channel-no)))
                    channel-nos
                    creators)
          stream)))))


(definition protected (stream-controller-action stream action arguments)
  (case action
    ((pause)
     (stream-pause stream))
    ((play)
     (stream-play stream))
    ((seek)
     (bind (pos) arguments
       (stream-seek stream pos)))
    ((backward)
     (stream-backward stream))
    ((forward)
     (stream-forward stream))
    ((mute)
     (stream-mute stream))
    ((unmute)
     (stream-unmute stream))))


(definition (stream-pause stream)
  (table-iterate (get-channels stream)
    (lambda (no channel)
      (pause channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (pause-stream src)))))


(definition (stream-play stream)
  (table-iterate (get-channels stream)
    (lambda (no channel)
      (play channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (play-stream src)))))


(definition (stream-seek stream pos)
  (if (not pos)
      (table-iterate (get-channels stream)
        (lambda (no channel)
          (let ((src (get-src (get-pipeline channel))))
            (goto-stream src #f #f))))
    (let ((highest-video (locate-highest-video-channel stream)))
      (let ((src (get-src (get-pipeline highest-video))))
        (let ((reader (get-reader src)))
          ;; video seeks to keyframe so use its
          ;; frame's dts to seek in all channels
          (let ((frame (seek->keyframe reader pos)))
            (receive (size dts pts duration keyframe?) (read-header reader frame)
              (let ((pos (frame->position reader frame))
                    (normalized-dts (normalize-timestamp reader dts)))
                (table-iterate (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (if (eq? channel highest-video)
                          (goto-stream src pos normalized-dts)
                        (goto-delayed src pos normalized-dts)))))))))))))


(definition (stream-backward stream)
  (let ((highest-video (locate-highest-video-channel stream)))
    (let ((src (get-src (get-pipeline highest-video))))
      (let ((reader (get-reader src)))
        ;; video seeks to keyframe so use its
        ;; frame's dts to seek in all channels
        (let ((frame (previous-keyframe reader)))
          (when frame
            (receive (size dts pts duration keyframe?) (read-header reader frame)
              (let ((pos (frame->position reader frame))
                    (normalized-dts (normalize-timestamp reader dts)))
                (table-iterate (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (backward-stream src pos normalized-dts))))))))))))


(definition (stream-forward stream)
  (let ((highest-video (locate-highest-video-channel stream)))
    (let ((src (get-src (get-pipeline highest-video))))
      (let ((reader (get-reader src)))
        ;; video seeks to keyframe so use its
        ;; frame's dts to seek in all channels
        (let ((frame (next-keyframe reader)))
          (when frame
            (receive (size dts pts duration keyframe?) (read-header reader frame)
              (let ((pos (frame->position reader frame))
                    (normalized-dts (normalize-timestamp reader dts)))
                (table-iterate (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (forward-stream src pos normalized-dts))))))))))))


(definition (stream-mute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (mute-stream src))))


(definition (stream-unmute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (unmute-stream src))))


(definition (locate-highest-video-channel stream)
  (let ((highest-channel #f))
    (table-iterate (get-channels stream)
      (lambda (no channel)
        (when (= (get-media-kind channel) udp-video)
          (let ((src (get-src (get-pipeline channel))))
            (when (get-stream? src)
              (when (or (not highest-channel)
                        (> (get-level channel)
                           (get-level highest-channel)))
                (set! highest-channel channel)))))))
    highest-channel))


;;;
;;;; Audio
;;;


(definition protected (client-audio-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer dts pts duration keyframe?)
    (when mirror?
      (receive-audio (current-audio) channel-no buffer dts pts duration))
    (unless local?
      (send-client-media client channel-no buffer dts pts duration keyframe?))))


(definition public (make-stream-audio-channel location)
  (let ((file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
    (let ((reader (new Stream-Reader file)))
      (let ((media-kind udp-audio)
            (source-kind 'stream)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec (get-codec reader))
            (caps (get-caps reader))
            (metadata '()))
        (close reader)
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
          (lambda (stream-no channel-no)
            (let ((client (current-client)))
              (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                (channel-output (current-audio) channel)
                (let ((src (new File-Stream-Audio-Src
                             location))
                      (sink (new Stream-Consumer
                              consumer: (client-audio-consumer client channel-no mirror?: #t local?: stream-local?))))
                  (let ((pipeline (pipeline (list src sink))))
                    (set-pipeline channel pipeline)))))))))))


(definition public (make-mic-channel)
  (let ((src (new Mic-Audio-Src))
        (sink (new Mic-Audio-Consumer)))
    (let ((pipeline (pipeline (list src sink))))
      (let ((media-kind udp-audio)
            (source-kind 'live)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec audio-codec)
            (caps (require-caps src))
            (metadata '()))
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
          (lambda (stream-no channel-no)
            (let ((client (current-client)))
              (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                (set-consumer sink (client-audio-consumer client channel-no))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Video
;;;


(definition protected (existing-video-profiles location)
  (let ((profiles (streaming-video-profiles)))
    (collect-if (lambda (profile)
                  (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
                    (exists? file)))
                profiles)))


(definition protected (client-video-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer dts pts duration keyframe?)
    (when mirror?
      (receive-video (current-video) channel-no buffer dts pts duration keyframe?))
    (unless local?
      (send-client-media client channel-no buffer dts pts duration keyframe?))))


(definition public (make-draw-channel draw-proc action-proc)
  (let ((media-kind udp-video)
        (source-kind 'draw)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Draw-Video-Src
                         draw-proc: draw-proc))
                  (sink (new Stream-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc)))))))))


(definition public (make-image-channel location (action-proc: action-proc #f))
  (let ((media-kind udp-video)
        (source-kind 'image)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Image-Stream-Video-Src
                         location))
                  (sink (new Stream-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc)))))))))


(definition public (make-stream-video-channels location (action-proc: action-proc #f))
  (let ((existing-profiles (existing-video-profiles location))
        (active-profile (active-video-profile)))
    (let ((unique-profile? (= 1 (length existing-profiles))))
      (map (lambda (profile)
             (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
               (let ((reader (new Stream-Reader file)))
                 (let ((media-kind udp-video)
                       (source-kind 'stream)
                       (level (get-level profile)))
                   (let ((resolution (get-resolution reader))
                         (framerate (get-framerate reader))
                         (bitrate (get-bitrate reader))
                         (codec (get-codec reader))
                         (caps (get-caps reader))
                         (metadata (list start: (get-start reader) end: (get-end reader))))
                     (close reader)
                     (new Channel-Creator
                       (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                       (lambda (stream-no channel-no)
                         (let ((client (current-client)))
                           (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                             (when (or (eq? profile active-profile) unique-profile?)
                               (let ((video (current-video)))
                                 (let ((output (channel-output video channel sync-audio?: #t)))
                                   (when (not (get-focused-output video))
                                     (change-focused-output video output))
                                   output)))
                             (let ((stream? (or (<= level (get-level active-profile)) unique-profile?)))
                               (let ((src (new File-Stream-Video-Src
                                            profile
                                            location
                                            stream?: stream?))
                                     (sink (new Stream-Consumer
                                             consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
                                 (let ((pipeline (pipeline (list src sink))))
                                   (set-pipeline channel pipeline)
                                   (set-action-proc channel action-proc)))))))))))))
           existing-profiles))))


(definition protected (camera-profiles profile)
  (if camera-single?
      (list profile)
    (let ((level (get-level profile)))
      (loop (for l from level downto 0)
            (collect (level->video-profile l))))))


(definition public (make-camera-channels)
  (let ((camera-profile (maximum-camera-profile)))
    (let ((profiles (camera-profiles camera-profile)))
      (map (lambda (profile)
             (let ((media-kind udp-video)
                   (source-kind 'live)
                   (level (get-level profile))
                   (resolution (get-resolution profile))
                   (framerate (get-framerate profile))
                   (bitrate (get-bitrate profile))
                   (codec (get-codec profile))
                   (caps #f)
                   (metadata '()))
               (new Channel-Creator
                 (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                 (lambda (stream-no channel-no)
                   (let ((client (current-client)))
                     (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata))))))
           profiles))))


(definition protected (make-shared-camera-pipeline channels)
  (let ((camera-profile (maximum-camera-profile)))
    (let ((profiles (camera-profiles camera-profile))
          (level-override (camera-profile-override-level)))
      (let ((src (new Camera-Video-Src
                   resolution: (get-resolution camera-profile)
                   framerate: (get-framerate camera-profile)
                   selfrate: (get-selfrate camera-profile)))
            (self-sinks (map (lambda (profile)
                               (new Camera-Self-Consumer
                                 caps: 'self
                                 profile: profile
                                 processing?: (or self-contrast? (= (get-level profile) level-override))))
                             profiles))
            (sinks (map (lambda (profile)
                          (let ((channel (find-if (lambda (channel)
                                                    (= (get-level channel) (get-level profile)))
                                                  channels)))
                            (new Camera-Video-Consumer
                              channel-no: (get-no channel)
                              profile: profile
                              processing?: (<= (get-level profile) level-override))))
                        profiles)))
        (pipeline `(,src ,@self-sinks ,@sinks))))))


(definition public (make-screen-channel)
  (let ((media-kind udp-video)
        (source-kind 'screen)
        (level #f)
        (resolution screen-share-resolution)
        (framerate screen-share-framerate)
        (bitrate screen-share-bitrate)
        (codec screen-share-codec)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Screen-Video-Src
                         resolution: screen-share-resolution
                         framerate: screen-share-framerate
                         bitrate: screen-share-bitrate
                         codec: screen-share-codec))
                  (sink (new Screen-Video-Consumer
                          channel-no)))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Streams
;;;


(definition protected (iterate-stream-directories proc)
  (let ((dirnames (or stream-directories '("streams"))))
    (for-each (lambda (dirname)
                (let ((dir (new-directory {Directory Documents} dirname)))
                  (when (exists? dir)
                    (proc dir))))
              dirnames)))


(definition protected (iterate-streams proc)
  (define (iterate dir)
    (iterate-directory dir
      (lambda (file)
        (proc file))
      files?: #t
      directories?: #f
      recursive?: #f)
    (iterate-directory dir
      (lambda (subdir)
        (iterate subdir))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (iterate-stream-directories iterate))


;;;
;;;; Streaming
;;;


;; because the channel-add calls use tcp, the first udp packets
;; will often arrive before them hence the need for a small delay
(definition protected streaming-delay
  .2)


(definition protected (delay-streaming thunk (delay #f))
  ;; so that the channel-add calls are not blocked
  (delay-event
    (lambda ()
      (sleep (or delay streaming-delay))
      (thunk))))


;;;
;;;; Stitch
;;;


(definition public (stitch-streams files dest)
  (let ((start-time (current-seconds)))
    (define (determine-properties)
      (let ((properties #f)
            (bitrate #f)
            (caps #f))
        (for-each (lambda (file)
                    (with ((reader (new Stream-Reader file)))
                      (let ((p (list (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-codec reader)))
                            ;; ignore bitrate
                            (b (get-bitrate reader))
                            ;; ignore caps as they are not always consistent
                            (c (get-caps reader)))
                        (if (or (not properties)
                                (nu=? p properties))
                            (begin
                              (set! properties p)
                              (set! bitrate b)
                              (set! caps c))
                          (terminal properties)
                          (terminal p)
                          (error "Inconsistent stream properties")))))
                  files)
        (bind (kind level resolution framerate codec) properties
          (list kind level resolution framerate bitrate codec caps))))
    
    (bind (kind level resolution framerate bitrate codec caps) (determine-properties)
      (with ((writer (new Stream-Writer dest kind level resolution framerate bitrate codec caps: caps)))
        (let ((offset 0))
          (for-each (lambda (file)
                      (let ((start-time (current-seconds)))
                        (with ((reader (new Stream-Reader file)))
                          (format :terminal "{a}" (get-name file))
                          (let (loop (last-dts #f) (last-duration #f) (count 0))
                            (receive (buffer dts pts duration keyframe?) (read-frame reader)
                              (if buffer
                                  (let ((dts (+ offset (normalize-timestamp reader dts)))
                                        (pts (+ offset (normalize-timestamp reader pts))))
                                    (write-frame writer buffer dts pts duration keyframe?)
                                    (when (= (modulo count 100) 0)
                                      (format :terminal "."))
                                    (loop dts duration (+ count 1)))
                                (set! offset (+ last-dts last-duration))
                                (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time)))))))))
                    files))))
    (format :terminal "done ({a}){%}" (present-seconds (- (current-seconds) start-time)))))


;;;
;;;; Convert
;;;


(definition protected (convert-streams dir (what: what #f) (dry?: dry? #f))
  (iterate-directory dir
    (lambda (file)
      (let ((extension (get-extension file)))
        (define (audio-extension?)
          (member? extension '("streamaudio")))
        
        (define (video-extension?)
          (member? extension '("streamvideo0"
                               "streamvideo1"
                               "streamvideo2"
                               "streamvideo3"
                               "streamvideo4")))
        
        (when (case what
                ((audio) (audio-extension?))
                ((video) (video-extension?))
                (else (or (audio-extension?)
                          (video-extension?))))
          (convert-stream file dry?: dry?))))
    files?: #t
    directories?: #f
    recursive?: #t))


(definition protected (convert-stream file (dry?: dry? #f))
  (declare (proper-tail-calls))
  (let ((name (get-name file))
        (base (get-base file))
        (extension (get-extension file)))
    (define (convert-to temp-file)
      (let ((start-time (current-seconds)))
        (let ((reader (new Stream-Reader file)))
          (let ((writer (new Stream-Writer temp-file (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-bitrate reader) (get-codec reader) caps: (get-caps reader))))
            (format :terminal "{a}" name)
            (let (loop (count 0))
              (receive (buffer dts pts duration keyframe?) (read-frame reader)
                (if buffer
                    (begin
                      (write-frame writer buffer dts pts duration keyframe?)
                      (when (= (modulo count 100) 0)
                        (format :terminal "."))
                      (loop (+ count 1)))
                  (close reader)
                  (close writer)
                  (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time))))))))))
    
    (if dry?
        (terminal name)
      (let ((temp-extension (string-append "temp" extension)))
        (let ((temp-file (new-brother file (add-extension base temp-extension))))
          (convert-to temp-file)
          (delete file)
          (rename temp-file file)))))))
