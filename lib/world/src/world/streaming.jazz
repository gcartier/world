;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.io)
        (jazz.stream)
        (world)
        (world.audio)
        (world.context)
        (world.event)
        (world.media)
        (world.settings)
        (world.stream)
        (world.udp)
        (world.video))


(definition protected camera-single?
  (world-setting 'world.camera-single? #f))


;;;
;;;; Channel
;;;


(class Channel-Creator extends Object
  
  
  (slot descriptor     getter generate)
  (slot create         getter generate)
  (slot share-pipeline getter generate)
  
  
  (method override (initialize self descriptor create (share-pipeline #f))
    (nextmethod self)
    (set! self.descriptor descriptor)
    (set! self.create create)
    (set! self.share-pipeline share-pipeline)))


;;;
;;;; Stream
;;;


(definition public (determine-stream-video-level creators)
  (let ((levels (map (lambda (creator)
                       (bind (media-kind source-kind level) (get-descriptor creator)
                         (assert (= media-kind udp-video)
                           level)))
                     creators)))
    (if (memv? #f levels)
        #f
      (maximum levels))))


(definition public (make-stream name source-kind video-level creators (location: location #f) (can-local?: can-local? #f))
  (let ((client (current-client)))
    (let ((recipient (if (and can-local? stream-local?)
                         '()
                       #f))
          (channels (map get-descriptor creators)))
      (bind (stream-no . channel-nos) (register-stream client name source-kind video-level channels recipient)
        (let ((stream (register-send-stream (get-udp-client client) (get-character-name client) name stream-no source-kind video-level)))
          (set-location stream location)
          (for-each (lambda (channel-no creator)
                      (let ((create (get-create creator)))
                        (create stream-no channel-no)))
                    channel-nos
                    creators)
          stream)))))


(definition protected (stream-controller-action stream action arguments)
  (case action
    ((pause)
     (stream-pause stream))
    ((play)
     (stream-play stream))
    ((seek)
     (bind (pos) arguments
       (stream-seek stream pos)))
    ((backward)
     (stream-backward stream))
    ((forward)
     (stream-forward stream))
    ((mute)
     (stream-mute stream))
    ((unmute)
     (stream-unmute stream))))


(definition (stream-pause stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (pause channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (pause-stream src)))))


(definition (stream-play stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (play channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (play-stream src)))))


(definition (stream-seek stream pos)
  (if (not pos)
      (iterate-table (get-channels stream)
        (lambda (no channel)
          (let ((src (get-src (get-pipeline channel))))
            (goto-stream src #f #f))))
    (let ((highest-video (locate-highest-video-channel stream)))
      (let ((src (get-src (get-pipeline highest-video))))
        (let ((reader (get-reader src)))
          ;; video seeks to keyframe so use its
          ;; frame's dts to seek in all channels
          (let ((frame (seek->keyframe reader pos)))
            (receive (size dts pts duration keyframe?) (read-header reader frame)
              (let ((pos (frame->position reader frame))
                    (normalized-dts (normalize-timestamp reader dts)))
                (iterate-table (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (if (eq? channel highest-video)
                          (goto-stream src pos normalized-dts)
                        (goto-delayed src pos normalized-dts)))))))))))))


(definition (stream-backward stream)
  (let ((highest-video (locate-highest-video-channel stream)))
    (let ((src (get-src (get-pipeline highest-video))))
      (let ((reader (get-reader src)))
        ;; video seeks to keyframe so use its
        ;; frame's dts to seek in all channels
        (let ((frame (previous-keyframe reader)))
          (when frame
            (receive (size dts pts duration keyframe?) (read-header reader frame)
              (let ((pos (frame->position reader frame))
                    (normalized-dts (normalize-timestamp reader dts)))
                (iterate-table (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (backward-stream src pos normalized-dts))))))))))))


(definition (stream-forward stream)
  (let ((highest-video (locate-highest-video-channel stream)))
    (let ((src (get-src (get-pipeline highest-video))))
      (let ((reader (get-reader src)))
        ;; video seeks to keyframe so use its
        ;; frame's dts to seek in all channels
        (let ((frame (next-keyframe reader)))
          (when frame
            (receive (size dts pts duration keyframe?) (read-header reader frame)
              (let ((pos (frame->position reader frame))
                    (normalized-dts (normalize-timestamp reader dts)))
                (iterate-table (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (forward-stream src pos normalized-dts))))))))))))


(definition (stream-mute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (mute-stream src))))


(definition (stream-unmute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (unmute-stream src))))


(definition (locate-highest-video-channel stream)
  (let ((highest-channel #f))
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (when (= (get-media-kind channel) udp-video)
          (let ((src (get-src (get-pipeline channel))))
            (when (get-stream? src)
              (when (or (not highest-channel)
                        (> (get-level channel)
                           (get-level highest-channel)))
                (set! highest-channel channel)))))))
    highest-channel))


;;;
;;;; Audio
;;;


(definition protected (client-audio-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer dts pts duration keyframe?)
    (when mirror?
      (receive-audio (current-audio) channel-no buffer dts pts duration))
    (unless local?
      (send-client-media client channel-no buffer dts pts duration keyframe?))))


(definition public (make-stream-audio-channel location)
  (let ((file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
    (let ((reader (new Stream-Reader file)))
      (let ((media-kind udp-audio)
            (source-kind 'stream)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec (get-codec reader))
            (caps (get-caps reader))
            (metadata '()))
        (close reader)
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
          (lambda (stream-no channel-no)
            (let ((client (current-client)))
              (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                (channel-output (current-audio) channel)
                (let ((src (new File-Stream-Audio-Src
                             location))
                      (sink (new Stream-Consumer
                              consumer: (client-audio-consumer client channel-no mirror?: #t local?: stream-local?))))
                  (let ((pipeline (pipeline (list src sink))))
                    (set-pipeline channel pipeline)))))))))))


(definition public (make-mic-channel)
  (let ((src (new Mic-Audio-Src))
        (sink (new Mic-Audio-Consumer)))
    (let ((pipeline (pipeline (list src sink))))
      (let ((media-kind udp-audio)
            (source-kind 'live)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec audio-codec)
            (caps (require-caps src))
            (metadata '()))
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
          (lambda (stream-no channel-no)
            (let ((client (current-client)))
              (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                (set-consumer sink (client-audio-consumer client channel-no))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Video
;;;


(definition protected (existing-video-profiles location)
  (let ((profiles (streaming-video-profiles)))
    (collect-if (lambda (profile)
                  (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
                    (exists? file)))
                profiles)))


(definition protected (client-video-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer dts pts duration keyframe?)
    (when mirror?
      (receive-video (current-video) channel-no buffer dts pts duration keyframe?))
    (unless local?
      (send-client-media client channel-no buffer dts pts duration keyframe?))))


(definition public (make-draw-channel draw-proc action-proc)
  (let ((media-kind udp-video)
        (source-kind 'draw)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Draw-Video-Src
                         draw-proc: draw-proc))
                  (sink (new Stream-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc)))))))))


(definition public (make-image-channel location (action-proc: action-proc #f))
  (let ((media-kind udp-video)
        (source-kind 'image)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Image-Stream-Video-Src
                         location))
                  (sink (new Stream-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc)))))))))


(definition public (make-stream-video-channels location (action-proc: action-proc #f))
  (let ((existing-profiles (existing-video-profiles location)))
    ;; use highest level profile for self output
    (let ((self-output-profile (car existing-profiles)))
      (map (lambda (profile)
             (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
               (let ((reader (new Stream-Reader file)))
                 (let ((media-kind udp-video)
                       (source-kind 'stream)
                       (level (get-level profile)))
                   (let ((resolution (get-resolution reader))
                         (framerate (get-framerate reader))
                         (bitrate (get-bitrate reader))
                         (codec (get-codec reader))
                         (caps (get-caps reader))
                         (metadata (list start: (get-start reader) end: (get-end reader))))
                     (close reader)
                     (new Channel-Creator
                       (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                       (lambda (stream-no channel-no)
                         (let ((client (current-client)))
                           (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                             (when (eq? profile self-output-profile)
                               (let ((video (current-video)))
                                 (let ((output (channel-output video channel sync-audio?: #t)))
                                   (when (not (get-focused-output video))
                                     (change-focused-output video output))
                                   output)))
                             (let ((src (new File-Stream-Video-Src
                                          profile
                                          location))
                                   (sink (new Stream-Consumer
                                           consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
                               (let ((pipeline (pipeline (list src sink))))
                                 (set-pipeline channel pipeline)
                                 (set-action-proc channel action-proc))))))))))))
           existing-profiles))))


(definition protected (camera-profiles profile)
  (if camera-single?
      (list profile)
    (let ((level (get-level profile)))
      (loop (for l from level downto 0)
            (collect (level->video-profile l))))))


(definition public (make-camera-channels)
  (let ((camera-profile (active-camera-profile)))
    (let ((profiles (camera-profiles camera-profile)))
      (map (lambda (profile)
             (let ((media-kind udp-video)
                   (source-kind 'live)
                   (level (get-level profile))
                   (resolution (get-resolution profile))
                   (framerate (get-framerate profile))
                   (bitrate (get-bitrate profile))
                   (codec (get-codec profile))
                   (caps #f)
                   (metadata '()))
               (new Channel-Creator
                 (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                 (lambda (stream-no channel-no)
                   (let ((client (current-client)))
                     (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata))))))
           profiles))))


(definition protected (make-shared-camera-pipeline channels)
  (let ((camera-profile (active-camera-profile)))
    (let ((profiles (camera-profiles camera-profile))
          (level-override (camera-profile-override-level)))
      (let ((src (new Camera-Video-Src
                   resolution: (get-resolution camera-profile)
                   framerate: (get-framerate camera-profile)
                   selfrate: (get-selfrate camera-profile)))
            (self-sinks (map (lambda (profile)
                               (new Camera-Self-Consumer
                                 caps: 'self
                                 profile: profile
                                 processing?: (or self-contrast? (= (get-level profile) level-override))))
                             profiles))
            (sinks (map (lambda (profile)
                          (let ((channel (find-if (lambda (channel)
                                                    (= (get-level channel) (get-level profile)))
                                                  channels)))
                            (new Camera-Video-Consumer
                              channel-no: (get-no channel)
                              profile: profile
                              processing?: (<= (get-level profile) level-override))))
                        profiles)))
        (pipeline `(,src ,@self-sinks ,@sinks))))))


(definition public (make-screen-channel)
  (let ((media-kind udp-video)
        (source-kind 'screen)
        (level #f)
        (resolution screen-share-resolution)
        (framerate screen-share-framerate)
        (bitrate screen-share-bitrate)
        (codec screen-share-codec)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Screen-Video-Src
                         resolution: screen-share-resolution
                         framerate: screen-share-framerate
                         bitrate: screen-share-bitrate
                         codec: screen-share-codec))
                  (sink (new Screen-Video-Consumer
                          channel-no)))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Streams
;;;


(definition protected (iterate-stream-directories proc)
  (let ((dirnames (or stream-directories '("streams"))))
    (for-each (lambda (dirname)
                (let ((dir (new-directory {Directory Documents} dirname)))
                  (when (exists? dir)
                    (proc dir))))
              dirnames)))


(definition protected (iterate-streams proc)
  (define (iterate dir)
    (iterate-directory dir
      (lambda (file)
        (proc file))
      files?: #t
      directories?: #f
      recursive?: #f)
    (iterate-directory dir
      (lambda (subdir)
        (iterate subdir))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (iterate-stream-directories iterate))


;;;
;;;; Streaming
;;;


;; because the channel-add calls use tcp, the first udp packets
;; will often arrive before them hence the need for a small delay
(definition protected streaming-delay
  .2)


(definition protected (delay-streaming thunk (delay #f))
  ;; so that the channel-add calls are not blocked
  (delay-event
    (lambda ()
      (sleep (or delay streaming-delay))
      (thunk))))


;;;
;;;; Stitch
;;;


(definition public (stitch-streams files dest)
  (let ((start-time (current-seconds)))
    (define (determine-properties)
      (let ((properties #f)
            (caps #f))
        (for-each (lambda (file)
                    (with ((reader (new Stream-Reader file)))
                      (let ((p (list (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-bitrate reader) (get-codec reader)))
                            (c (get-caps reader)))
                        ;; ignore caps as they are not always consistent
                        (if (or (not properties)
                                (nu=? p properties))
                            (begin
                              (set! properties p)
                              (set! caps c))
                          (terminal properties)
                          (terminal p)
                          (error "Inconsistent stream properties")))))
                  files)
        (append properties (list caps))))
    
    (bind (kind level resolution framerate bitrate codec caps) (determine-properties)
      (with ((writer (new Stream-Writer dest kind level resolution framerate bitrate codec caps: caps)))
        (let ((offset 0))
          (for-each (lambda (file)
                      (let ((start-time (current-seconds)))
                        (with ((reader (new Stream-Reader file)))
                          (format :terminal "{a}" (get-name file))
                          (let (loop (last-dts #f) (last-duration #f) (count 0))
                            (receive (buffer dts pts duration keyframe?) (read-frame reader)
                              (if buffer
                                  (let ((dts (+ offset (normalize-timestamp reader dts)))
                                        (pts (+ offset (normalize-timestamp reader pts))))
                                    (write-frame writer buffer dts pts duration keyframe?)
                                    (when (= (modulo count 100) 0)
                                      (format :terminal "."))
                                    (loop dts duration (+ count 1)))
                                (set! offset (+ last-dts last-duration))
                                (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time)))))))))
                    files))))
    (format :terminal "done ({a}){%}" (present-seconds (- (current-seconds) start-time)))))


;;;
;;;; Convert
;;;


(definition protected (convert-streams dir (what: what #f) (dry?: dry? #f))
  (iterate-directory dir
    (lambda (file)
      (let ((extension (get-extension file)))
        (define (audio-extension?)
          (member? extension '("streamaudio")))
        
        (define (video-extension?)
          (member? extension '("streamvideo0"
                               "streamvideo1"
                               "streamvideo2"
                               "streamvideo3"
                               "streamvideo4")))
        
        (when (case what
                ((audio) (audio-extension?))
                ((video) (video-extension?))
                (else (or (audio-extension?)
                          (video-extension?))))
          (convert-stream file dry?: dry?))))
    files?: #t
    directories?: #f
    recursive?: #t))


(definition protected (convert-stream file (dry?: dry? #f))
  (declare (proper-tail-calls))
  (let ((name (get-name file))
        (base (get-base file))
        (extension (get-extension file)))
    (define (convert-to temp-file)
      (let ((start-time (current-seconds)))
        (let ((reader (new Stream-Reader file)))
          (let ((writer (new Stream-Writer temp-file (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-bitrate reader) (get-codec reader) caps: (get-caps reader))))
            (format :terminal "{a}" name)
            (let (loop (count 0))
              (receive (buffer dts pts duration keyframe?) (read-frame reader)
                (if buffer
                    (begin
                      (write-frame writer buffer dts pts duration keyframe?)
                      (when (= (modulo count 100) 0)
                        (format :terminal "."))
                      (loop (+ count 1)))
                  (close reader)
                  (close writer)
                  (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time))))))))))
    
    (if dry?
        (terminal name)
      (let ((temp-extension (string-append "temp" extension)))
        (let ((temp-file (new-brother file (add-extension base temp-extension))))
          (convert-to temp-file)
          (delete file)
          (rename temp-file file)))))))
