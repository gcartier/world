;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.io)
        (jazz.stream)
        (world)
        (world.audio)
        (world.context)
        (world.settings)
        (world.udp)
        (world.video))


;;;
;;;; Audio
;;;


(definition (client-audio-consumer client channel-no (mirror?: mirror? #f))
  (lambda (buffer timestamp duration)
    (case audio-codec
      ((opus)
       (when mirror?
         (receive-audio (current-audio) channel-no buffer timestamp duration))
       (unless stream-local?
         (let ((header? (and buffer (audio-buffer-header? buffer))))
           (send-client-audio client channel-no buffer header? timestamp duration))))
      ((vorbis)
       (cond ((pair? buffer)
              (when mirror?
                (let ((headers (u8vector->object (car buffer))))
                  (for-each (lambda (header)
                              (bind (buffer timestamp duration) header
                                (receive-audio (current-audio) channel-no buffer timestamp duration)))
                            headers)))
              (unless stream-local?
                (send-client-audio client channel-no (car buffer) #t -1 GST_CLOCK_TIME_NONE)))
             (else
              (when mirror?
                (receive-audio (current-audio) channel-no buffer timestamp duration))
              (unless stream-local?
                (send-client-audio client channel-no buffer #f timestamp duration))))))))


(definition public (make-audio-channel location name)
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (register-channel client name udp-audio 'stream #f #f #f audio-codec recipient #t)))
        (let ((channel-no (get-no channel)))
          (let ((src (new File-Stream-Audio-Src
                       location))
                (sink (new Stream-Sink
                        consumer: (client-audio-consumer client channel-no mirror?: #t))))
            (let ((pipeline (pipeline src sink)))
              (set-pipeline channel pipeline)
              channel)))))))


(definition public (make-mic-channel name)
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-audio 'live #f #f #f audio-codec #f #f)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Mic-Audio-Src))
              (sink (new Stream-Sink
                      consumer: (client-audio-consumer client channel-no))))
          (let ((pipeline (pipeline src sink)))
            (set-pipeline channel pipeline)
            channel))))))


;;;
;;;; Video
;;;


(definition protected stream-resolution
  (world-setting 'world.stream-resolution {Dimension 640 360}))

(definition protected stream-framerate
  (world-setting 'world.stream-framerate 15))

(definition protected stream-bitrate
  (world-setting 'world.stream-bitrate 1024))


(definition (client-video-consumer client channel-no (mirror?: mirror? #f))
  (lambda (buffer timestamp duration)
    (when mirror?
      (receive-video (current-video) channel-no buffer timestamp duration))
    (unless stream-local?
      (let ((header? (and buffer (video-buffer-header? buffer))))
        (send-client-video client channel-no buffer header? timestamp duration)))))


(definition public (make-draw-channel name draw-proc action-proc)
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (register-channel client name udp-video 'draw video-resolution #f video-bitrate #f recipient #t)))
        (let ((channel-no (get-no channel)))
          (let ((src (new Draw-Video-Src
                       draw-proc: draw-proc))
                (sink (new Stream-Sink
                        consumer: (client-video-consumer client channel-no mirror?: #t))))
            (let ((pipeline (pipeline src sink)))
              (set-pipeline channel pipeline)
              (set-action-proc channel action-proc)
              channel)))))))


(definition public (make-image-channel location name (action-proc: action-proc #f))
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (register-channel client name udp-video 'image video-resolution #f video-bitrate #f recipient #t)))
        (let ((channel-no (get-no channel)))
          (let ((src (new Image-Stream-Video-Src
                       location))
                (sink (new Stream-Sink
                        consumer: (client-video-consumer client channel-no mirror?: #t))))
            (let ((pipeline (pipeline src sink)))
              (set-pipeline channel pipeline)
              (set-action-proc channel action-proc)
              channel)))))))


(definition public (make-video-channel location name (action-proc: action-proc #f))
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (register-channel client name udp-video 'stream stream-resolution stream-framerate stream-bitrate #f recipient #t)))
        (let ((channel-no (get-no channel)))
          (let ((src (new File-Stream-Video-Src
                       location))
                (sink (new Stream-Sink
                        consumer: (client-video-consumer client channel-no mirror?: #t))))
            (let ((pipeline (pipeline src sink)))
              (set-pipeline channel pipeline)
              (set-action-proc channel action-proc)
              channel)))))))


(definition public (make-camera-channel name)
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-video 'live video-resolution video-framerate video-bitrate video-codec #f #f)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Camera-Video-Src
                     resolution: video-resolution
                     framerate: video-framerate
                     bitrate: video-bitrate
                     codec: video-codec))
              (sink (new Stream-Sink
                      consumer: (client-video-consumer client channel-no)))
              (self-sink (new Self-Sink)))
          (let ((pipeline (pipeline src (list sink self-sink))))
            (set-pipeline channel pipeline)
            channel))))))


(definition public (make-screen-channel name)
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-video 'screen screen-share-resolution screen-share-framerate screen-share-bitrate screen-share-codec #f #f)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Screen-Video-Src
                     resolution: screen-share-resolution
                     framerate: screen-share-framerate
                     bitrate: screen-share-bitrate
                     codec: screen-share-codec))
              (sink (new Stream-Sink
                      consumer: (client-video-consumer client channel-no)))
              @wait (self-sink (new Self-Sink)))
          (let ((pipeline (pipeline src sink @wait (list sink self-sink))))
            (set-pipeline channel pipeline)
            channel))))))


;;;
;;;; Streams
;;;


(definition protected stream-multiple?
  (world-setting 'world.stream-multiple? #f))

(definition protected stream-repeatable?
  (world-setting 'world.stream-repeatable? #f))

(definition protected stream-private?
  (world-setting 'world.stream-private? #f))

(definition protected stream-local?
  (world-setting 'world.stream-local? #f))


(definition public streams-dir
  {Directory Settings "streams"})


(definition protected (iterate-streams subdir proc)
  (define (iterate dir private?)
    (unless (and (eq? stream-private? 'only)
                 (not private?))
      (iterate-directory dir
        (lambda (file)
          (proc file))
        files?: #t
        directories?: #f
        recursive?: #f))
    (iterate-directory dir
      (lambda (subdir)
        (let ((private-dir? (filename=? (get-name subdir) "private")))
          (when (or stream-private?
                    (not private-dir?))
            (iterate subdir (or private? private-dir?)))))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (let ((dir (new-directory streams-dir subdir)))
    (when (exists? dir)
      (iterate dir #f))))


;;;
;;;; Streaming
;;;


(definition protected (delay-streaming thunk)
  ;; so that the add-channel calls are not blocked
  (delay-event
    (lambda ()
      ;; because the add-channel calls use tcp, the first udp packets
      ;; will often arrive before them hence the need for a small delay
      (sleep .1)
      (thunk)))))
