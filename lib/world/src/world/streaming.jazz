;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.io)
        (jazz.stream)
        (world)
        (world.audio)
        (world.context)
        (world.event)
        (world.media)
        (world.settings)
        (world.stream)
        (world.udp)
        (world.video))


(definition protected camera-single?
  (world-setting 'world.camera-single? #f))


;;;
;;;; Channel
;;;


(class Channel-Creator extends Object
  
  
  (slot descriptor     getter generate)
  (slot create         getter generate)
  (slot share-pipeline getter generate)
  
  
  (method override (initialize self descriptor create (share-pipeline #f))
    (nextmethod self)
    (set! self.descriptor descriptor)
    (set! self.create create)
    (set! self.share-pipeline share-pipeline)))


;;;
;;;; Stream
;;;


(definition public (determine-stream-video-level creators)
  (let ((levels (map (lambda (creator)
                       (bind (media-kind source-kind level) (get-descriptor creator)
                         (assert (= media-kind udp-video)
                           level)))
                     creators)))
    (if (memv? #f levels)
        #f
      (maximum levels))))


(definition public (make-stream name source-kind video-level creators (location: location #f) (can-local?: can-local? #f))
  (let ((client (current-client)))
    (let ((recipient (if (and can-local? stream-local?)
                         '()
                       #f))
          (channels (map get-descriptor creators)))
      (bind (stream-no . channel-nos) (register-stream client name source-kind video-level channels recipient)
        (let ((stream (register-send-stream (get-udp-client client) (get-character-name client) name stream-no source-kind video-level)))
          (set-location stream location)
          (for-each (lambda (channel-no creator)
                      (let ((create (get-create creator)))
                        (create stream-no channel-no)))
                    channel-nos
                    creators)
          stream)))))


(definition protected (stream-controller-action stream action arguments)
  (case action
    ((pause)
     (stream-pause stream))
    ((play)
     (stream-play stream))
    ((seek)
     (bind (pos) arguments
       (stream-seek stream pos)))
    ((backward)
     (stream-backward stream))
    ((forward)
     (stream-forward stream))
    ((mute)
     (stream-mute stream))
    ((unmute)
     (stream-unmute stream))))


(definition (stream-pause stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (pause channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (pause-stream src)))))


(definition (stream-play stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (play channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (play-stream src)))))


(definition (stream-seek stream pos)
  (if (not pos)
      (iterate-table (get-channels stream)
        (lambda (no channel)
          (let ((src (get-src (get-pipeline channel))))
            (goto-stream src #f #f))))
    (let ((highest-video (locate-highest-video-channel stream)))
      (let ((src (get-src (get-pipeline highest-video))))
        (let ((reader (get-reader src)))
          ;; video seeks to header so use its
          ;; frame's pts to seek all channels
          (let ((frame (seek->frame reader pos)))
            (receive (dts pts duration size header?) (read-header reader frame)
              (let ((normalized-pts (normalize-timestamp reader pts)))
                (iterate-table (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (goto-stream src pos normalized-pts))))))))))))


(definition (stream-backward stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (let ((src (get-src (get-pipeline channel))))
        (backward-stream src)))))


(definition (stream-forward stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (let ((src (get-src (get-pipeline channel))))
        (forward-stream src)))))


(definition (stream-mute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (mute-stream src))))


(definition (stream-unmute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (unmute-stream src))))


(definition (locate-highest-video-channel stream)
  (let ((highest-channel #f))
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (when (= (get-media-kind channel) udp-video)
          (let ((src (get-src (get-pipeline channel))))
            (when (get-stream? src)
              (when (or (not highest-channel)
                        (> (get-level channel)
                           (get-level highest-channel)))
                (set! highest-channel channel)))))))
    highest-channel))


;;;
;;;; Audio
;;;


(definition protected (client-audio-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer dts pts duration)
    (case audio-codec
      ((opus)
       (when mirror?
         (receive-audio (current-audio) channel-no buffer dts pts duration))
       (unless local?
         (let ((header? (and buffer (audio-buffer-header? buffer))))
           (send-client-media client channel-no buffer header? dts pts duration))))
      ((vorbis)
       (cond ((pair? buffer)
              (when mirror?
                (let ((headers (u8vector->object (car buffer))))
                  (for-each (lambda (header)
                              (bind (buffer dts pts duration) header
                                (receive-audio (current-audio) channel-no buffer dts pts duration)))
                            headers)))
              (unless local?
                (send-client-media client channel-no (car buffer) #t GST_CLOCK_TIME_NONE GST_CLOCK_TIME_NONE GST_CLOCK_TIME_NONE)))
             (else
              (when mirror?
                (receive-audio (current-audio) channel-no buffer dts pts duration))
              (unless local?
                (send-client-media client channel-no buffer #f dts pts duration))))))))


(definition public (make-stream-audio-channel location)
  (let ((media-kind udp-audio)
        (source-kind 'stream)
        (level #f)
        (resolution #f)
        (framerate #f)
        (bitrate #f)
        (codec audio-codec)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-audio) channel)
            (let ((src (new File-Stream-Audio-Src
                         location))
                  (sink (new Audio-Consumer
                          consumer: (client-audio-consumer client channel-no mirror?: #t local?: stream-local?))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)))))))))


(definition public (make-mic-channel)
  (let ((media-kind udp-audio)
        (source-kind 'live)
        (level #f)
        (resolution #f)
        (framerate #f)
        (bitrate #f)
        (codec audio-codec)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (let ((src (new Mic-Audio-Src))
                  (sink (new Mic-Audio-Consumer
                          consumer: (client-audio-consumer client channel-no))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Video
;;;


(definition protected (existing-video-profiles location)
  (let ((profiles (streaming-video-profiles)))
    (collect-if (lambda (profile)
                  (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
                    (exists? file)))
                profiles)))


(definition protected (client-video-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer dts pts duration)
    (when mirror?
      (receive-video (current-video) channel-no buffer dts pts duration))
    (unless local?
      (let ((header? (and buffer (video-buffer-header? buffer))))
        (send-client-media client channel-no buffer header? dts pts duration)))))


(definition public (make-draw-channel draw-proc action-proc)
  (let ((media-kind udp-video)
        (source-kind 'draw)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Draw-Video-Src
                         draw-proc: draw-proc))
                  (sink (new Stream-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc)))))))))


(definition public (make-image-channel location (action-proc: action-proc #f))
  (let ((media-kind udp-video)
        (source-kind 'image)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Image-Stream-Video-Src
                         location))
                  (sink (new Stream-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc)))))))))


(definition public (make-stream-video-channels location (action-proc: action-proc #f))
  (let ((existing-profiles (existing-video-profiles location)))
    ;; use highest level profile for self output
    (let ((self-output-profile (car existing-profiles)))
      (map (lambda (profile)
             (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
               (let ((reader (new Stream-Reader file)))
                 (let ((media-kind udp-video)
                       (source-kind 'stream)
                       (level (get-level profile)))
                   (let ((resolution (if (not level) (get-resolution reader) (get-resolution profile)))
                         (framerate (get-framerate profile))
                         (bitrate (get-bitrate profile))
                         (codec (get-codec profile))
                         (caps (get-caps reader))
                         (metadata (list start: (get-start reader) end: (get-end reader))))
                     (close reader)
                     (new Channel-Creator
                       (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                       (lambda (stream-no channel-no)
                         (let ((client (current-client)))
                           (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                             (when (eq? profile self-output-profile)
                               (channel-output (current-video) channel sync-audio?: #t))
                             (let ((src (new File-Stream-Video-Src
                                          profile
                                          location))
                                   (sink (new Stream-Consumer
                                           consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
                               (let ((pipeline (pipeline (list src sink))))
                                 (set-pipeline channel pipeline)
                                 (set-action-proc channel action-proc))))))))))))
           existing-profiles))))


(definition protected (camera-profiles profile)
  (if camera-single?
      (list profile)
    (let ((level (get-level profile)))
      (loop (for l from level downto 0)
            (collect (level->video-profile l))))))


(definition public (make-camera-channels)
  (let ((camera-profile (active-camera-profile)))
    (let ((profiles (camera-profiles camera-profile)))
      (map (lambda (profile)
             (let ((media-kind udp-video)
                   (source-kind 'live)
                   (level (get-level profile))
                   (resolution (get-resolution profile))
                   (framerate (get-framerate profile))
                   (bitrate (get-bitrate profile))
                   (codec (get-codec profile))
                   (caps #f)
                   (metadata '()))
               (new Channel-Creator
                 (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                 (lambda (stream-no channel-no)
                   (let ((client (current-client)))
                     (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata))))))
           profiles))))


(definition protected (make-shared-camera-pipeline channels)
  (let ((camera-profile (active-camera-profile)))
    (let ((profiles (camera-profiles camera-profile))
          (level-override (camera-profile-override-level)))
      (let ((src (new Camera-Video-Src
                   resolution: (get-resolution camera-profile)
                   framerate: (get-framerate camera-profile)
                   selfrate: (get-selfrate camera-profile)))
            (self-sinks (map (lambda (profile)
                               (new Camera-Self-Consumer
                                 caps: 'self
                                 profile: profile
                                 processing?: (or self-contrast? (= (get-level profile) level-override))))
                             profiles))
            (sinks (map (lambda (profile)
                          (let ((channel (find-if (lambda (channel)
                                                    (= (get-level channel) (get-level profile)))
                                                  channels)))
                            (new Camera-Video-Consumer
                              channel-no: (get-no channel)
                              profile: profile
                              processing?: (<= (get-level profile) level-override))))
                        profiles)))
        (pipeline `(,src ,@self-sinks ,@sinks))))))


(definition public (make-screen-channel)
  (let ((media-kind udp-video)
        (source-kind 'screen)
        (level #f)
        (resolution screen-share-resolution)
        (framerate screen-share-framerate)
        (bitrate screen-share-bitrate)
        (codec screen-share-codec)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Screen-Video-Src
                         resolution: screen-share-resolution
                         framerate: screen-share-framerate
                         bitrate: screen-share-bitrate
                         codec: screen-share-codec))
                  (sink (new Screen-Video-Consumer
                          channel-no)))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Streams
;;;


(definition protected (iterate-stream-directories proc)
  (let ((dirnames (or stream-directories '("streams"))))
    (for-each (lambda (dirname)
                (let ((dir (new-directory {Directory Documents} dirname)))
                  (when (exists? dir)
                    (proc dir))))
              dirnames)))


(definition protected (iterate-streams proc)
  (define (iterate dir)
    (iterate-directory dir
      (lambda (file)
        (proc file))
      files?: #t
      directories?: #f
      recursive?: #f)
    (iterate-directory dir
      (lambda (subdir)
        (iterate subdir))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (iterate-stream-directories iterate))


;;;
;;;; Streaming
;;;


;; because the channel-add calls use tcp, the first udp packets
;; will often arrive before them hence the need for a small delay
(definition protected streaming-delay
  .2)


(definition protected (delay-streaming thunk (delay #f))
  ;; so that the channel-add calls are not blocked
  (delay-event
    (lambda ()
      (sleep (or delay streaming-delay))
      (thunk))))


;;;
;;;; Convert
;;;


@convert
(definition protected (convert-streams dir (dry?: dry? #f))
  (iterate-directory dir
    (lambda (file)
      (let ((extension (get-extension file)))
        (when (member? extension '("streamaudio"
                                   "streamvideo0"
                                   "streamvideo1"
                                   "streamvideo2"
                                   "streamvideo3"
                                   "streamvideo4"))
          (convert-stream file dry?: dry?))))
    files?: #t
    directories?: #f
    recursive?: #t))


@convert
(definition protected (convert-stream file (dry?: dry? #f))
  (declare (proper-tail-calls))
  (let ((name (get-name file))
        (base (get-base file))
        (extension (get-extension file)))
    (define (determine-information)
      (cond ((starts-with? extension "streamaudio")
             (values 'audio #f #f #f #f 'vorbis))
            ((starts-with? extension "streamvideo")
             (let ((level (string->number (substring extension (string-length "streamvideo") (string-length extension)))))
               (let ((profile (level->video-profile level)))
                 (values 'video level (get-resolution profile) (get-framerate profile) (get-bitrate profile) (get-codec profile)))))
            (else
             (error "Unable to convert stream: {a}" name))))
    
    (define (convert-to temp-file)
      (receive (kind level resolution framerate bitrate codec) (determine-information)
        (let ((start-time (current-seconds)))
          (let ((reader (new Stream-Reader-Old file))
                (writer (new Stream-Writer temp-file kind level resolution framerate bitrate codec))
                (first-timestamp #f))
            (format :terminal "{a}" name)
            (let (loop (count 0))
              (receive (buffer timestamp duration) (read-frame reader #t)
                (if buffer
                    (begin
                      (when (not first-timestamp)
                        (set! first-timestamp timestamp))
                      (let ((adjusted (- timestamp first-timestamp)))
                        (write-frame writer buffer adjusted adjusted duration))
                      (when (= (modulo count 100) 0)
                        (format :terminal "."))
                      (loop (+ count 1)))
                  (close reader)
                  (close writer)
                  (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time))))))))))
    
    (if dry?
        (terminal name)
      (let ((temp-extension (string-append "temp" extension)))
        (let ((temp-file (new-brother file (add-extension base temp-extension))))
          (convert-to temp-file)
          (delete file)
          (rename temp-file file)))))))
