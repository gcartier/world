;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.io)
        (jazz.listener)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (world)
        (world.audio)
        (world.configure)
        (world.context)
        (world.event)
        (world.media)
        (world.settings)
        (world.stream)
        (world.udp)
        (world.video))


(definition protected camera-single?
  (world-setting 'world.camera-single? #f))


;;;
;;;; Channel
;;;


(class Channel-Creator extends Object
  
  
  (slot descriptor     getter generate)
  (slot create         getter generate)
  (slot share-pipeline getter generate)
  
  
  (method override (initialize self descriptor create (share-pipeline #f))
    (nextmethod self)
    (set! self.descriptor descriptor)
    (set! self.create create)
    (set! self.share-pipeline share-pipeline)))


;;;
;;;; Stream
;;;


(definition public (determine-stream-video-level creators)
  (let ((levels (map (lambda (creator)
                       (bind (media-kind source-kind level) (get-descriptor creator)
                         (assert (= media-kind udp-video)
                           level)))
                     creators)))
    (if (memv? #f levels)
        #f
      (maximum levels))))


(definition public (make-stream name source-kind video-level creators (location: location #f) (can-local?: can-local? #f))
  (let ((client (current-client)))
    (let ((recipient (if (and can-local? stream-local?)
                         '()
                       #f))
          (channels (map get-descriptor creators)))
      (bind (stream-no . channel-nos) (register-stream client name source-kind video-level channels recipient)
        (let ((stream (register-send-stream (get-udp-client client) (get-character-name client) name stream-no source-kind video-level)))
          (set-location stream location)
          (for-each (lambda (channel-no creator)
                      (let ((create (get-create creator)))
                        (create stream-no channel-no)))
                    channel-nos
                    creators)
          stream)))))


(definition protected (stream-controller-action stream action arguments)
  (case action
    ((pause)
     (stream-pause stream))
    ((play)
     (stream-play stream))
    ((seek)
     (bind (pos) arguments
       (stream-seek stream pos)))
    ((backward)
     (stream-backward stream))
    ((forward)
     (stream-forward stream))
    ((mute)
     (stream-mute stream))
    ((unmute)
     (stream-unmute stream))))


(definition (stream-pause stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (pause channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (pause-stream src)))))


(definition (stream-play stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (play channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (play-stream src)))))


(definition (stream-seek stream pos)
  (if (not pos)
      (iterate-table (get-channels stream)
        (lambda (no channel)
          (let ((src (get-src (get-pipeline channel))))
            (goto-stream src #f #f))))
    (let ((highest-video (locate-highest-video-channel stream)))
      (let ((src (get-src (get-pipeline highest-video))))
        (let ((reader (get-reader src)))
          ;; video seeks to keyframe so use its
          ;; frame's dts to seek in all channels
          (let ((frame (seek->keyframe reader pos)))
            (receive (size dts pts duration keyframe?) (read-header reader frame)
              (let ((pos (frame->position reader frame))
                    (normalized-dts (normalize-timestamp reader dts)))
                (iterate-table (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (if (eq? channel highest-video)
                          (goto-stream src pos normalized-dts)
                        (goto-delayed src pos normalized-dts)))))))))))))


(definition (stream-backward stream)
  (let ((highest-video (locate-highest-video-channel stream)))
    (let ((src (get-src (get-pipeline highest-video))))
      (let ((reader (get-reader src)))
        ;; video seeks to keyframe so use its
        ;; frame's dts to seek in all channels
        (let ((frame (previous-keyframe reader)))
          (when frame
            (receive (size dts pts duration keyframe?) (read-header reader frame)
              (let ((pos (frame->position reader frame))
                    (normalized-dts (normalize-timestamp reader dts)))
                (iterate-table (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (backward-stream src pos normalized-dts))))))))))))


(definition (stream-forward stream)
  (let ((highest-video (locate-highest-video-channel stream)))
    (let ((src (get-src (get-pipeline highest-video))))
      (let ((reader (get-reader src)))
        ;; video seeks to keyframe so use its
        ;; frame's dts to seek in all channels
        (let ((frame (next-keyframe reader)))
          (when frame
            (receive (size dts pts duration keyframe?) (read-header reader frame)
              (let ((pos (frame->position reader frame))
                    (normalized-dts (normalize-timestamp reader dts)))
                (iterate-table (get-channels stream)
                  (lambda (no channel)
                    (let ((src (get-src (get-pipeline channel))))
                      (forward-stream src pos normalized-dts))))))))))))


(definition (stream-mute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (mute-stream src))))


(definition (stream-unmute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (unmute-stream src))))


(definition (locate-highest-video-channel stream)
  (let ((highest-channel #f))
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (when (= (get-media-kind channel) udp-video)
          (let ((src (get-src (get-pipeline channel))))
            (when (get-stream? src)
              (when (or (not highest-channel)
                        (> (get-level channel)
                           (get-level highest-channel)))
                (set! highest-channel channel)))))))
    highest-channel))


;;;
;;;; Audio
;;;


(definition protected (client-audio-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer dts pts duration keyframe?)
    (when mirror?
      (receive-audio (current-audio) channel-no buffer dts pts duration))
    (unless local?
      (send-client-media client channel-no buffer dts pts duration keyframe?))))


(definition public (make-stream-audio-channel location)
  (let ((file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
    (let ((reader (new Stream-Reader file)))
      (let ((media-kind udp-audio)
            (source-kind 'stream)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec (get-codec reader))
            (caps (get-caps reader))
            (metadata '()))
        (close reader)
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
          (lambda (stream-no channel-no)
            (let ((client (current-client)))
              (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                (channel-output (current-audio) channel)
                (let ((src (new File-Stream-Audio-Src
                             location))
                      (sink (new Stream-Consumer
                              consumer: (client-audio-consumer client channel-no mirror?: #t local?: stream-local?))))
                  (let ((pipeline (pipeline (list src sink))))
                    (set-pipeline channel pipeline)))))))))))


(definition public (make-mic-channel)
  (let ((src (new Mic-Audio-Src))
        (sink (new Mic-Audio-Consumer)))
    (let ((pipeline (pipeline (list src sink))))
      (let ((media-kind udp-audio)
            (source-kind 'live)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec audio-codec)
            (caps #f)
            (metadata '()))
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
          (lambda (stream-no channel-no)
            (let ((client (current-client)))
              (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                (set-consumer sink (client-audio-consumer client channel-no))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Video
;;;


(definition protected (existing-video-profiles location)
  (let ((profiles (streaming-video-profiles)))
    (collect-if (lambda (profile)
                  (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
                    (exists? file)))
                profiles)))


(definition protected (client-video-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer dts pts duration keyframe?)
    (when mirror?
      (receive-video (current-video) channel-no buffer dts pts duration keyframe?))
    (unless local?
      (send-client-media client channel-no buffer dts pts duration keyframe?))))


(definition public (make-draw-channel draw-proc action-proc)
  (let ((media-kind udp-video)
        (source-kind 'draw)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Draw-Video-Src
                         draw-proc: draw-proc))
                  (sink (new Stream-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc)))))))))


;(import jazz.graphic)
(definition public (make-image-channel location (action-proc: action-proc #f))
  ;; try
  ;; we have problems like x264 wanting even height
  (let ((image #f @w (new Image moniker: (new-file {Directory Documents} location))))
  (let ((media-kind udp-video)
        (source-kind 'image)
        (level #f)
        (resolution draw-resolution @w (image-size image))
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Image-Stream-Video-Src
                         location
                         resolution: resolution))
                  (sink (new Stream-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc))))))))))


(definition public (make-stream-video-channels location (action-proc: action-proc #f))
  (let ((existing-profiles (existing-video-profiles location))
        (active-profile (active-video-profile)))
    (let ((unique-profile? (= 1 (length existing-profiles))))
      (map (lambda (profile)
             (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
               (let ((reader (new Stream-Reader file)))
                 (let ((media-kind udp-video)
                       (source-kind 'stream)
                       (level (get-level profile)))
                   (let ((resolution (get-resolution reader))
                         (framerate (get-framerate reader))
                         (bitrate (get-bitrate reader))
                         (codec (get-codec reader))
                         (caps (get-caps reader))
                         (metadata (list start: (get-start reader) end: (get-end reader))))
                     (close reader)
                     (new Channel-Creator
                       (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                       (lambda (stream-no channel-no)
                         (let ((client (current-client)))
                           (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                             (when (or (eq? profile active-profile) unique-profile?)
                               (let ((video (current-video)))
                                 (let ((output (channel-output video channel sync-audio?: #t)))
                                   (when (not (get-focused-output video))
                                     (change-focused-output video output))
                                   output)))
                             (let ((stream? (or (<= level (get-level active-profile)) unique-profile?)))
                               (let ((src (new File-Stream-Video-Src
                                            profile
                                            location
                                            stream?: stream?))
                                     (sink (new Stream-Consumer
                                             consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
                                 (let ((pipeline (pipeline (list src sink))))
                                   (set-pipeline channel pipeline)
                                   (set-action-proc channel action-proc)))))))))))))
           existing-profiles))))


(definition protected (camera-profiles profile)
  (if camera-single?
      (list profile)
    (let ((level (get-level profile)))
      (loop (for l from level downto 0)
            (collect (level->video-profile l))))))


(definition public (make-camera-channels)
  (let ((camera-profile (maximum-camera-profile)))
    (let ((profiles (camera-profiles camera-profile)))
      (map (lambda (profile)
             (let ((media-kind udp-video)
                   (source-kind 'live)
                   (level (get-level profile))
                   (resolution (get-resolution profile))
                   (framerate (get-framerate profile))
                   (bitrate (get-bitrate profile))
                   (codec (get-codec profile))
                   (caps #f)
                   (metadata '()))
               (new Channel-Creator
                 (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
                 (lambda (stream-no channel-no)
                   (let ((client (current-client)))
                     (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata))))))
           profiles))))


(definition protected (make-shared-camera-pipeline channels)
  (let ((client (current-client)))
    (let ((camera-profile (maximum-camera-profile)))
      (let ((profiles (camera-profiles camera-profile))
            (level-override (camera-profile-override-level)))
        (let ((src (new Camera-Video-Src
                     resolution: (get-resolution camera-profile)
                     framerate: (get-framerate camera-profile)
                     selfrate: (get-selfrate camera-profile)))
              (self-sinks (map (lambda (profile)
                                 (new Camera-Self-Consumer
                                   caps: 'self
                                   profile: profile
                                   processing?: (or self-contrast? (= (get-level profile) level-override))))
                               profiles))
              (sinks (map (lambda (profile)
                            (let ((channel (find-if (lambda (channel)
                                                      (= (get-level channel) (get-level profile)))
                                                    channels)))
                              (new Camera-Video-Consumer
                                channel-no: (get-no channel)
                                profile: profile
                                processing?: (and (<= (get-level profile) level-override)
                                                  (streaming-level? client (get-level profile) level-override)))))
                          profiles)))
          (pipeline `(,src ,@self-sinks ,@sinks)))))))


(definition public (make-screen-channel)
  (let ((media-kind udp-video)
        (source-kind 'screen)
        (level #f)
        (resolution screen-share-resolution)
        (framerate screen-share-framerate)
        (bitrate screen-share-bitrate)
        (codec screen-share-codec)
        (caps #f)
        (metadata '()))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
            (channel-output (current-video) channel)
            (let ((src (new Screen-Video-Src
                         resolution: screen-share-resolution
                         framerate: screen-share-framerate
                         bitrate: screen-share-bitrate
                         codec: screen-share-codec))
                  (sink (new Screen-Video-Consumer
                          channel-no)))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Streams
;;;


(definition protected (iterate-stream-directories proc)
  (let ((dirnames (or stream-directories '("streams"))))
    (for-each (lambda (dirname)
                (let ((dir (new-directory {Directory Documents} dirname)))
                  (when (exists? dir)
                    (proc dir))))
              dirnames)))


(definition protected (iterate-streams proc)
  (define (iterate dir)
    (iterate-directory dir
      (lambda (file)
        (proc file))
      files?: #t
      directories?: #f
      recursive?: #f)
    (iterate-directory dir
      (lambda (subdir)
        (iterate subdir))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (iterate-stream-directories iterate))


;;;
;;;; Streaming
;;;


;; because the channel-add calls use tcp, the first udp packets
;; will often arrive before them hence the need for a small delay
(definition protected streaming-delay
  .2)


(definition protected (delay-streaming thunk (delay #f))
  ;; so that the channel-add calls are not blocked
  (delay-event
    (lambda ()
      (sleep (or delay streaming-delay))
      (thunk))))


;;;
;;;; Mux
;;;


(definition public (mux-streams audio video output)
  (let ((audio-reader (new Stream-Reader audio))
        (video-reader (new Stream-Reader video)))
    (let ((audio-caps (get-caps audio-reader))
          (video-caps (get-caps video-reader))
          (location (path-normalize (parse output))))
      (let ((pipeline (gst-pipeline (format "appsrc caps=\"{a}\" name=audio" audio-caps)
                                    "qtmux name=mux"
                                    (tie "filesink location={location} name=sink")
                                    (list
                                      (format "appsrc caps=\"{a}\" name=video" video-caps)
                                      "h264parse"
                                      "mux^."))))
        (with-unref ((audiosrc (gst_bin_get_by_name pipeline "audio"))
                     (videosrc (gst_bin_get_by_name pipeline "video")))
          (define (process-audio)
            (declare (proper-tail-calls))
            (let (loop)
              (let ((frame (read-frame audio-reader)))
                (when frame
                  (receive (buffer dts pts duration keyframe?) frame
                    (gst_app_src_write audiosrc buffer (u8vector-length buffer) dts pts duration 0)
                    (loop))))))
          
          (define (process-video)
            (declare (proper-tail-calls))
            (let (loop)
              (let ((frame (read-frame video-reader)))
                (when frame
                  (receive (buffer dts pts duration keyframe?) frame
                    (gst_app_src_write videosrc buffer (u8vector-length buffer) dts pts duration 0)
                    (loop))))))
          
          (g-object-set audiosrc
                        "stream-type" 'int GST_APP_STREAM_TYPE_STREAM
                        "format"      'int GST_FORMAT_TIME)
          (g-object-set videosrc
                        "stream-type" 'int GST_APP_STREAM_TYPE_STREAM
                        "format"      'int GST_FORMAT_TIME)
          (gst_element_set_state pipeline GST_STATE_PLAYING)
          (let ((audio-thread (new-thread process-audio 'mux-audio))
                (video-thread (new-thread process-video 'mux-video)))
            (thread-start! audio-thread)
            (thread-start! video-thread)
            (thread-join! audio-thread)
            (thread-join! video-thread)
            (close audio-reader)
            (close video-reader)
            ;; quick hack as somehow waiting for eos doesn't ensure
            ;; all data has been processed and saved to the filesink
            (sleep 1)
            (set-pipeline-flushing? pipeline #f)
            (gst_element_send_event pipeline (gst_event_new_eos))
            ;; wait for eos message
            (with-unref ((bus (gst_pipeline_get_bus pipeline)))
              (let (loop)
                (let ((msg (gst_bus_pop bus)))
                  (if (not msg)
                      (begin
                        (sleep .001)
                        (loop))
                    (let ((type (GST_MESSAGE_TYPE msg)))
                      (if (/= type GST_MESSAGE_EOS)
                          (begin
                            (gst_message_unref msg)
                            (sleep .001)
                            (loop))
                        (gst_message_unref msg)))))))
            (set-pipeline-flushing? pipeline #t)
            (gst_bin_release pipeline)))))))


;;;
;;;; Stitch
;;;


(definition public (stitch-streams files dest)
  (let ((start-time (current-seconds)))
    (define (determine-properties)
      (let ((properties #f)
            (bitrate #f)
            (caps #f))
        (for-each (lambda (file)
                    (with ((reader (new Stream-Reader file)))
                      (let ((p (list (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-codec reader)))
                            ;; ignore bitrate
                            (b (get-bitrate reader))
                            ;; ignore caps as they are not always consistent
                            (c (get-caps reader)))
                        (if (or (not properties)
                                (nu=? p properties))
                            (begin
                              (set! properties p)
                              (set! bitrate b)
                              (set! caps c))
                          (terminal properties)
                          (terminal p)
                          (error "Inconsistent stream properties")))))
                  files)
        (bind (kind level resolution framerate codec) properties
          (list kind level resolution framerate bitrate codec caps))))
    
    (bind (kind level resolution framerate bitrate codec caps) (determine-properties)
      (with ((writer (new Stream-Writer dest kind level resolution framerate bitrate codec caps: caps)))
        (let ((offset 0))
          (for-each (lambda (file)
                      (let ((start-time (current-seconds)))
                        (with ((reader (new Stream-Reader file)))
                          (format :terminal "{a}" (get-name file))
                          (let (loop (last-dts #f) (last-duration #f) (count 0))
                            (let ((frame (read-frame reader)))
                              (if frame
                                  (receive (buffer dts pts duration keyframe?) frame
                                    (let ((dts (+ offset (normalize-timestamp reader dts)))
                                          (pts (+ offset (normalize-timestamp reader pts))))
                                      (write-frame writer buffer dts pts duration keyframe?)
                                      (when (= (modulo count 100) 0)
                                        (format :terminal "."))
                                      (loop dts duration (+ count 1))))
                                (set! offset (+ last-dts last-duration))
                                (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time)))))))))
                    files))))
    (format :terminal "done ({a}){%}" (present-seconds (- (current-seconds) start-time)))))


;;;
;;;; Convert
;;;


(definition protected (convert-streams dir (what: what #f) (dry?: dry? #f))
  (iterate-directory dir
    (lambda (file)
      (let ((extension (get-extension file)))
        (define (audio-extension?)
          (member? extension '("streamaudio")))
        
        (define (video-extension?)
          (member? extension '("streamvideo0"
                               "streamvideo1"
                               "streamvideo2"
                               "streamvideo3"
                               "streamvideo4")))
        
        (when (case what
                ((audio) (audio-extension?))
                ((video) (video-extension?))
                (else (or (audio-extension?)
                          (video-extension?))))
          (convert-stream file dry?: dry?))))
    files?: #t
    directories?: #f
    recursive?: #t))


(definition protected (convert-stream file (dry?: dry? #f))
  (declare (proper-tail-calls))
  (let ((name (get-name file))
        (base (get-base file))
        (extension (get-extension file)))
    (define (convert-to temp-file)
      (let ((start-time (current-seconds)))
        (let ((reader (new Stream-Reader file)))
          (let ((writer (new Stream-Writer temp-file (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-bitrate reader) (get-codec reader) caps: (get-caps reader))))
            (format :terminal "{a}" name)
            (let (loop (count 0))
              (let ((frame (read-frame reader)))
                (if frame
                    (receive (buffer dts pts duration keyframe?) frame
                      (write-frame writer buffer dts pts duration keyframe?)
                      (when (= (modulo count 100) 0)
                        (format :terminal "."))
                      (loop (+ count 1)))
                  (close reader)
                  (close writer)
                  (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time))))))))))
    
    (if dry?
        (terminal name)
      (let ((temp-extension (string-append "temp" extension)))
        (let ((temp-file (new-brother file (add-extension base temp-extension))))
          (convert-to temp-file)
          (delete file)
          (rename temp-file file))))))


;;;
;;;; Record
;;;


(definition pad-recording?
  #f)

(definition pad-monitors
  #f)


(definition protected (record-start pads)
  (let ((dir {Directory Settings "work" "records"})
        (pipeline (get-pipeline (cache-audio))))
    (define (parse-info info proc)
      (cond ((string? info)
             (proc info 'file))
            ((pair? info)
             (proc (first info) (second info)))))
    
    (define (parse-bin info)
      (let ((parts (split info "%")))
        (if (> (length parts) 1)
            parts
          (list #f info))))
    
    (define (find-bin bin-name)
      (if (not bin-name)
          pipeline
        (if (equal? bin-name "mic")
            (get-pipeline (get-src (get-pipeline (get-mic-channel (current-client)))))
          (let ((sink (let ((sinks (get-ordered-outputs (current-audio))))
                        (if (empty-string? bin-name)
                            (car sinks)
                          (find-if (lambda (sink)
                                     (search (gst_object_get_name (get-bin sink)) bin-name ignore-case?: #t))
                                   sinks)))))
            (get-bin sink)))))
    
    (define (monitor info)
      (parse-info info
        (lambda (info what)
          (bind (bin-name pad-info) (parse-bin info)
            (let ((bin (find-bin bin-name)))
              (define (monitor-file)
                (let ((file #f))
                  (define (filename pad)
                    (let ((info (rawaudio-pad-info pad)))
                      (let ((extension (rawaudio-extension info)))
                        (set! file (new-file dir (format "{a}.{a}" info extension)))
                        (path-normalize (parse file)))))
                  
                  (let ((monitored (gst_monitor bin pad-info 'file filename)))
                    (cons 'file (list monitored file)))))
              
              (define (monitor-analyse)
                (let ((listener (open-stream-listener)))
                  (let ((monitored (gst_monitor bin pad-info 'analyse (get-write-file listener)))
                        (thread (new-thread
                                  (lambda ()
                                    (declare (proper-tail-calls))
                                    (let ((discont 0)
                                          (gap 0)
                                          (expected 0)
                                          (silence 0))
                                      (let (loop)
                                        (case (wait listener)
                                          ((#\d)
                                           (increase! discont)
                                           (format :terminal "{a} : discont -> {a}{%}" pad-info discont)
                                           (loop))
                                          ((#\g)
                                           (increase! gap)
                                           (format :terminal "{a} : gap -> {a}{%}" pad-info gap)
                                           (loop))
                                          ((#\e)
                                           (increase! expected)
                                           (format :terminal "{a} : expected -> {a}{%}" pad-info expected)
                                           (loop))
                                          ((#\s)
                                           (increase! silence)
                                           (format :terminal "{a} : silence -> {a}{%}" pad-info silence)
                                           (loop))))))
                                  'monitor)))
                    (thread-base-priority-set! thread background-priority)
                    (thread-start! thread)
                    (cons 'analyse (list monitored listener thread)))))
              
              (define (monitor-other)
                (let ((monitored (gst_monitor bin pad-info what pipeline)))
                  (cons what monitored)))
              
              (case what
                ((file)
                 (monitor-file))
                ((analyse)
                 (monitor-analyse))
                (else
                 (monitor-other))))))))
      
    (when (not pad-recording?)
      (create-directories dir)
      (set! pad-monitors (map monitor pads))
      (set! pad-recording? #t))))


(definition protected (record-done)
  (define (unmonitor info)
    (define (unmonitor-file rest)
      (bind (monitored file) rest
        (gst_unmonitor monitored)))
    
    (define (unmonitor-analyse rest)
      (bind (monitored listener thread) rest
        (exit-thread thread)
        (close-stream-listener listener)
        (gst_unmonitor monitored)))
    
    (define (unmonitor-other monitored)
      (gst_unmonitor monitored))
    
    (bind (what . rest) info
      (case what
        ((file)
         (unmonitor-file rest))
        ((analyse)
         (unmonitor-analyse rest))
        (else
         (unmonitor-other rest)))))
  
  (when pad-recording?
    (for-each unmonitor pad-monitors)
    (set! pad-recording? #f)))


(definition protected (recorded-files)
  (and pad-monitors (collect (lambda (info)
                               (bind (what . rest) info
                                 (and (eq? what 'file)
                                      (bind (monitored file) rest
                                        file))))
                             pad-monitors))))
