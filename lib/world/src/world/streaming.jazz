;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.listener)
        (jazz.platform)
        (jazz.screen)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (jazz.window)
        (world)
        (world.audio)
        (world.autoload)
        (world.buffers)
        (world.client.autoload)
        (world.configure)
        (world.context)
        (world.event)
        (world.media)
        (world.profile)
        (world.settings)
        (world.stream)
        (world.task)
        (world.udp)
        (world.video))


;;;
;;;; Channel
;;;


(class Channel-Creator extends Object
  
  
  (slot descriptor     getter generate)
  (slot create         getter generate)
  (slot share-pipeline getter generate)
  
  
  (method override (initialize self descriptor create (share-pipeline #f))
    (nextmethod self)
    (set! self.descriptor descriptor)
    (set! self.create create)
    (set! self.share-pipeline share-pipeline)))


;;;
;;;; Stream
;;;


(definition public (determine-stream-video-levels creators)
  (sort < (collect (lambda (creator)
                     (bind (media-kind source-kind level) (get-descriptor creator)
                       (and (= media-kind udp-video)
                            (assert level
                              level))))
                   creators)))


(definition public (make-stream name source-kind video-levels video-on? creators (location: location #f))
  (let ((client (current-client)))
    (let ((channels (map get-descriptor creators)))
      (bind (stream-no . channel-nos) (register-stream client name source-kind video-levels video-on? channels)
        (let ((stream (register-send-stream (get-udp-client client) (get-character-name client) name stream-no source-kind video-levels)))
          (set-location stream location)
          (for-each (lambda (channel-no creator)
                      (let ((create (get-create creator)))
                        (create stream channel-no)))
                    channel-nos
                    creators)
          stream)))))


(definition protected (stream-controller-action stream action arguments)
  (case action
    ((pause)
     (stream-pause stream))
    ((play)
     (stream-play stream))
    ((seek)
     (bind (pos) arguments
       (stream-seek stream pos)))
    ((backward)
     (stream-backward stream))
    ((forward)
     (stream-forward stream))
    ((mute)
     (stream-mute stream))
    ((unmute)
     (stream-unmute stream))))


(definition (stream-pause stream)
  (table-iterate-safe (get-channels stream)
    (lambda (no channel)
      (pause channel)
      ;; kinda quicky needing more thought
      (let ((pipeline (get-pipeline channel)))
        (when pipeline
          (let ((src (get-src pipeline)))
            (pause-stream src)))))))


(definition (stream-play stream)
  (table-iterate-safe (get-channels stream)
    (lambda (no channel)
      (play channel)
      ;; kinda quicky needing more thought
      (let ((pipeline (get-pipeline channel)))
        (when pipeline
          (let ((src (get-src pipeline)))
            (play-stream src)))))))


(definition (stream-seek stream pos)
  (if (not pos)
      (table-iterate-safe (get-channels stream)
        (lambda (no channel)
          (let ((pipeline (get-pipeline channel)))
            (when pipeline
              (let ((src (get-src pipeline)))
                (goto-stream src #f #f))))))
    (let ((highest-video (find-highest-video-channel stream))
          (reader (locate-seek-reader stream)))
      ;; video seeks to keyframe so use its
      ;; frame's dts to seek in all channels
      (let ((frame (seek->keyframe reader pos)))
        (receive (size dts pts duration flags) (read-header reader frame)
          (let ((pos (frame->position reader frame))
                (normalized-dts (normalize-timestamp reader dts)))
            (table-iterate-safe (get-channels stream)
              (lambda (no channel)
                (let ((pipeline (get-pipeline channel)))
                  (when pipeline
                    (let ((src (get-src pipeline)))
                      (if (eq? channel highest-video)
                          (goto-stream src pos normalized-dts)
                        (goto-delayed src pos normalized-dts)))))))))))))


(definition (stream-backward stream)
  (let ((reader (locate-seek-reader stream)))
    ;; video seeks to keyframe so use its
    ;; frame's dts to seek in all channels
    (let ((frame (previous-keyframe reader)))
      (when frame
        (receive (size dts pts duration flags) (read-header reader frame)
          (let ((pos (frame->position reader frame))
                (normalized-dts (normalize-timestamp reader dts)))
            (table-iterate-safe (get-channels stream)
              (lambda (no channel)
                (let ((pipeline (get-pipeline channel)))
                  (when pipeline
                    (let ((src (get-src pipeline)))
                      (backward-stream src pos normalized-dts))))))))))))


(definition (stream-forward stream)
  (let ((reader (locate-seek-reader stream)))
    ;; video seeks to keyframe so use its
    ;; frame's dts to seek in all channels
    (let ((frame (next-keyframe reader)))
      (when frame
        (receive (size dts pts duration flags) (read-header reader frame)
          (let ((pos (frame->position reader frame))
                (normalized-dts (normalize-timestamp reader dts)))
            (table-iterate-safe (get-channels stream)
              (lambda (no channel)
                (let ((pipeline (get-pipeline channel)))
                  (when pipeline
                    (let ((src (get-src pipeline)))
                      (forward-stream src pos normalized-dts))))))))))))


(definition (stream-mute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (mute-stream src))))


(definition (stream-unmute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (unmute-stream src))))


(definition (locate-seek-reader stream)
  (let ((highest-video (find-highest-video-channel stream)))
    (if highest-video
        (let ((src (get-src (get-pipeline highest-video))))
          (get-reader src))
      (let ((audio (locate-stream-audio-channel stream)))
        (let ((src (get-src (get-pipeline audio))))
          (get-reader src))))))


(definition (find-highest-video-channel stream)
  (let ((highest-channel #f))
    (table-iterate (get-channels stream)
      (lambda (no channel)
        (when (= (get-media-kind channel) udp-video)
          (let ((pipeline (get-pipeline channel)))
            (when pipeline
              (let ((src (get-src pipeline)))
                (when (get-stream? src)
                  (when (or (not highest-channel)
                            (> (get-level channel)
                               (get-level highest-channel)))
                    (set! highest-channel channel)))))))))
    highest-channel))


;;;
;;;; Audio
;;;


(definition protected (client-audio-consumer client channel (mirror?: mirror? #f))
  (let ((channel-no (get-no channel)))
    (lambda (buffer dts pts duration flags)
      (when mirror?
        (let ((output (get-output channel)))
          (when output
            (let ((mutex (get-audio-mirror-mutex channel)))
              (mutex-lock! mutex)
              (receive-audio (current-audio) output buffer dts pts duration #f)
              (mutex-unlock! mutex)))))
      (when (get-sending? channel)
        (send-client-media client channel-no buffer dts pts duration flags))
      (let ((recorder (get-recorder channel)))
        (when recorder
          (world.recording:record-media recorder buffer dts pts duration flags))))))


(definition public (make-stream-audio-channel location (audio-only?: audio-only? #f))
  (let ((file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
    (let ((reader (new Stream-Reader file)))
      (let ((media-kind udp-audio)
            (source-kind 'stream)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec (get-codec reader))
            (caps (get-caps reader))
            (metadata '())
            (send-state 'on))
        (close reader)
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
          (lambda (stream channel-no)
            (let ((client (current-client)))
              (let ((stream-no (get-no stream)))
                (let ((channel (register-send-channel (get-udp-client client) upload-stream-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                  (set-sending? channel #t)
                  (let ((output (channel-output (current-audio) channel)))
                    (set-output channel output)
                    (let ((src (new File-Stream-Audio-Src
                                 location))
                          (sink (new Stream-Frame-Consumer
                                  consumer: (client-audio-consumer client channel mirror?: #t))))
                      (let ((pipeline (pipeline (list src sink))))
                        (set-pipeline channel pipeline))))
                  (when audio-only?
                    (set-video-output stream (channel-output (current-video) channel process?: #f))))))))))))


(definition public (make-microphone-channel)
  (let ((src (new Microphone-Audio-Src))
        (sink (new Microphone-Audio-Consumer)))
    (let ((pipeline (pipeline (list src sink))))
      (let ((media-kind udp-audio)
            (source-kind 'live)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec audio-codec)
            (caps #f)
            (metadata '())
            (send-state 'off))
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
          (lambda (stream channel-no)
            (let ((client (current-client)))
              (let ((stream-no (get-no stream)))
                (let ((channel (register-send-channel (get-udp-client client) upload-microphone-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                  (set-sending? channel #t)
                  (set-consumer sink (client-audio-consumer client channel))
                  (set-pipeline channel pipeline))))))))))


;;;
;;;; Video
;;;


(definition protected (existing-video-profiles location)
  (let ((profiles (streaming-video-profiles)))
    (collect-if (lambda (profile)
                  (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
                    (exists? file)))
                profiles)))


(definition protected (client-video-consumer client channel (mirror?: mirror? #f))
  (let ((channel-no (get-no channel)))
    (lambda (buffer dts pts duration flags)
      (when mirror?
        (let ((output (get-output channel)))
          (when output
            (receive-video (current-video) output buffer dts pts duration flags #f))))
      (when (get-sending? channel)
        (send-client-media client channel-no buffer dts pts duration flags))
      (let ((udp-client (get-udp-client client)))
        (when udp-client
          (let ((channel (find-send-channel udp-client channel-no)))
            (when channel
              (let ((recorder (get-recorder channel)))
                (when recorder
                  (world.recording:record-media recorder buffer dts pts duration flags))))))))))


(definition public (make-draw-channel draw-proc action-proc)
  (let ((media-kind udp-video)
        (source-kind 'draw)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '())
        (send-state 'on))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
      (lambda (stream channel-no)
        (let ((client (current-client)))
          (let ((stream-no (get-no stream)))
            (let ((channel (register-send-channel (get-udp-client client) upload-stream-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
              (let ((output (channel-output (current-video) channel)))
                (set-video-output stream output)
                (set-output channel output)
                (let ((src (new Draw-Video-Src
                             draw-proc: draw-proc))
                      (sink (new Stream-Frame-Consumer
                              consumer: (client-video-consumer client channel mirror?: #t))))
                  (let ((pipeline (pipeline (list src sink))))
                    (set-pipeline channel pipeline)
                    (set-action-proc channel action-proc)))))))))))


(definition public (make-image-channel location (action-proc: action-proc #f))
  (let ((file (new-file {Directory Documents} (add-extension location "streamimage"))))
    (let ((reader (new Stream-Reader file)))
      (let ((media-kind udp-video)
            (source-kind 'image)
            (resolution (get-resolution reader))
            (framerate (get-framerate reader))
            (bitrate (get-bitrate reader))
            (codec (get-codec reader))
            (caps (get-caps reader))
            (metadata '())
            (send-state 'on))
        (let ((level (get-level (estimate-resolution-profile resolution))))
          (close reader)
          (new Channel-Creator
            (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
            (lambda (stream channel-no)
              (let ((client (current-client)))
                (let ((stream-no (get-no stream)))
                  (let ((channel (register-send-channel (get-udp-client client) upload-stream-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                    (let ((output (channel-output (current-video) channel)))
                      (set-video-output stream output)
                      (set-output channel output)
                      (let ((src (new File-Stream-Image-Src
                                   location))
                            (sink (new Stream-Frame-Consumer
                                    consumer: (client-video-consumer client channel mirror?: #t))))
                        (let ((pipeline (pipeline (list src sink))))
                          (set-pipeline channel pipeline)
                          (set-action-proc channel action-proc))))))))))))))


(definition public (make-stream-video-channels location (action-proc: action-proc #f))
  (let ((client (current-client)))
    (let ((existing-profiles (existing-video-profiles location)))
      (let ((video-levels (reverse (map get-level existing-profiles))))
        (let ((self-level (find-video-level (max-streaming-level client) video-levels)))
          (map (lambda (profile)
                 (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
                   (let ((reader (new Stream-Reader file)))
                     (let ((media-kind udp-video)
                           (source-kind 'stream)
                           (level (get-level profile)))
                       (let ((resolution (get-resolution reader))
                             (framerate (get-framerate reader))
                             (bitrate (get-bitrate reader))
                             (codec (get-codec reader))
                             (caps (get-caps reader))
                             (metadata (list start: (get-start reader) end: (get-end reader)))
                             (send-state 'on))
                         (close reader)
                         (new Channel-Creator
                           (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
                           (lambda (stream channel-no)
                             (let ((client (current-client)))
                               (let ((stream-no (get-no stream)))
                                 (let ((channel (register-send-channel (get-udp-client client) upload-stream-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                                   (when (= level self-level)
                                     (let ((video (current-video)))
                                       (let ((output (channel-output video channel sync-audio?: #t)))
                                         (set-video-output stream output)
                                         (set-output channel output)
                                         (when (not (get-focused-output video))
                                           (change-focused-output video output)))))
                                   (let ((stream? (= level self-level)))
                                     (let ((src (new File-Stream-Video-Src
                                                  profile
                                                  location
                                                  stream?: stream?))
                                           (sink (new Stream-Frame-Consumer
                                                   consumer: (client-video-consumer client channel mirror?: #t))))
                                       (let ((pipeline (pipeline (list src sink))))
                                         (set-pipeline channel pipeline)
                                         (set-action-proc channel action-proc))))))))))))))
               existing-profiles))))))


(definition protected (camera-profiles profile)
  (let ((level (get-level profile)))
    (loop (for l from level downto 0)
          (collect (level->graphic-profile l)))))


(definition public (make-camera-channels)
  (let ((camera-profile (maximum-camera-profile)))
    (let ((profiles (camera-profiles camera-profile)))
      (map (lambda (profile)
             (let ((media-kind udp-video)
                   (source-kind 'live)
                   (level (get-level profile))
                   (resolution (get-resolution profile))
                   (framerate (get-framerate profile))
                   (bitrate (get-bitrate profile))
                   (codec (get-codec profile))
                   (caps #f)
                   (metadata '())
                   (send-state 'off))
               (new Channel-Creator
                 (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
                 (lambda (stream channel-no)
                   (let ((client (current-client)))
                     (let ((stream-no (get-no stream)))
                       (register-send-channel (get-udp-client client) upload-camera-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))))))
           profiles))))


(definition protected (make-shared-camera-pipeline stream-no channels)
  (let ((client (current-client))
        (video (current-video)))
    (let ((camera-profile (maximum-camera-profile)))
      (let ((profiles (camera-profiles camera-profile)))
        (let ((video-levels (reverse (map get-level profiles))))
          (let ((self-level (find-video-level (determine-self-level video #t) video-levels)))
            (let ((src (new Camera-Video-Src
                         resolution: (get-resolution camera-profile)
                         framerate: (get-framerate camera-profile)))
                  (self-sinks (map (lambda (profile)
                                     (new Camera-Self-Consumer
                                       stream-no: stream-no
                                       caps: 'self
                                       profile: profile
                                       processing?: (= (get-level profile) self-level)))
                                   profiles))
                  (sinks (map (lambda (profile)
                                (let ((channel (find-if (lambda (channel)
                                                          (= (get-level channel) (get-level profile)))
                                                        channels)))
                                  (let ((consumer (new Camera-Video-Consumer
                                                    channel-no: (get-no channel)
                                                    profile: profile
                                                    processing?: #f)))
                                    (set-consumer channel consumer)
                                    consumer)))
                              profiles)))
              (pipeline `(,src ,@self-sinks ,@sinks)))))))))


(definition public (make-window-channel)
  (let ((world (current-world)))
    (receive (width height multisampling) (render-settings (get-multisampled-framebuffer world))
      (let ((media-kind udp-video)
            (source-kind 'window)
            (resolution (new Dimension width height))
            (framerate window-share-framerate)
            (bitrate window-share-bitrate)
            (codec window-share-codec)
            (caps #f)
            (metadata '())
            (send-state 'on))
        (let ((level (get-level (estimate-resolution-profile resolution))))
          (new Channel-Creator
            (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
            (lambda (stream channel-no)
              (let ((client (current-client)))
                (let ((stream-no (get-no stream)))
                  (let ((channel (register-send-channel (get-udp-client client) upload-share-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                    (let ((output (channel-output (current-video) channel process?: #f)))
                      (set-video-output stream output)
                      (set-output channel output)
                      (let ((src (new Window-Video-Src
                                   resolution: resolution
                                   framerate: window-share-framerate
                                   min-bitrate: window-share-min-bitrate
                                   bitrate: window-share-bitrate
                                   codec: window-share-codec))
                            (sink (new Window-Video-Consumer
                                    channel-no)))
                        (let ((pipeline (pipeline (list src sink))))
                          (set-pipeline channel pipeline)
                          (set-consumer channel sink))))))))))))))


(definition public (make-screen-channel)
  (let ((media-kind udp-video)
        (source-kind 'screen)
        (resolution (determine-screen-size))
        (framerate screen-share-framerate)
        (bitrate screen-share-bitrate)
        (codec screen-share-codec)
        (caps #f)
        (metadata '())
        (send-state 'on))
    (let ((level (get-level (estimate-resolution-profile resolution))))
      (new Channel-Creator
        (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
        (lambda (stream channel-no)
          (let ((client (current-client)))
            (let ((stream-no (get-no stream)))
              (let ((channel (register-send-channel (get-udp-client client) upload-share-priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                (let ((output (channel-output (current-video) channel process?: #f)))
                  (set-video-output stream output)
                  (set-output channel output)
                  (let ((src (new Screen-Video-Src
                               resolution: resolution
                               framerate: screen-share-framerate
                               min-bitrate: screen-share-min-bitrate
                               bitrate: screen-share-bitrate
                               codec: screen-share-codec))
                        (sink (new Screen-Video-Consumer
                                channel-no)))
                    (let ((pipeline (pipeline (list src sink))))
                      (set-pipeline channel pipeline)
                      (set-consumer channel sink))))))))))))


(definition protected (determine-screen-size)
  (cond-expand
    (mac
     (let ((screen (main-screen)))
       (let ((size (rect-size (get-frame-rect screen)))
             (scale (main-screen-scale-factor)))
         (new Dimension
           (* (get-width size) scale)
           (* (get-height size) scale)))))
    (windows
     (rect-size (get-display-area (current-monitor))))
    (else
     (new Dimension 1280 720))))


;;;
;;;; Streams
;;;


(definition protected image-extensions
  '("jpg" "jpeg" "png"))

(definition protected text-extensions
  '("txt"))


(definition protected streaming-image-extension
  "streamimage")


(definition protected (iterate-stream-directories proc)
  (let ((dirnames (or stream-directories '("streams"))))
    (for-each (lambda (dirname)
                (let ((dir (new-directory {Directory Documents} dirname)))
                  (when (exists? dir)
                    (proc dir))))
              dirnames)))


(definition protected (iterate-streams proc)
  (define (iterate dir)
    (iterate-directory dir
      (lambda (file)
        (proc file))
      files?: #t
      directories?: #f
      recursive?: #f)
    (iterate-directory dir
      (lambda (subdir)
        (iterate subdir))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (iterate-stream-directories iterate))


(definition protected (gather-streams)
  (let ((video-extensions (streaming-video-extensions))
        (audio-extensions (streaming-audio-extensions))
        (queue (new-queue)))
    (iterate-streams
      (lambda (file)
        (let ((location (filename-spine (join (subpath {Directory Documents} file) "/")))
              (extension (get-extension file)))
          (cond ((extension=? extension streaming-image-extension)
                 (enqueue queue (list 'image location #t #f)))
                ((member? extension audio-extensions test: extension=?)
                 (let ((info (find (queue-list queue) location key: second test: filename=? return: 'item)))
                   (if (not info)
                       (enqueue queue (list 'audio location #t #f))
                     (set-third! info #t))))
                ((member? extension video-extensions test: extension=?)
                 (let ((info (find (queue-list queue) location key: second test: filename=? return: 'item))
                       (profile (find graphic-profiles extension key: get-extension test: extension=? return: 'item)))
                   (if (not info)
                       (enqueue queue (list 'video location #f (list profile)))
                     (set-fourth! info (cons profile (or (fourth info) '()))))))))))
    (queue-list queue)))


(definition protected (streaming-information udp-client base files audio-extensions video-profiles preprocess-extensions)
  (define (determine-kind files)
    (let ((count (length files)))
      (cond @wait-not-working-at-the-moment
            ((and (= count 1)
                  (member? (get-extension (car files)) text-extensions test: extension=?))
             (values 'text #f))
            ((some? (lambda (file)
                      (extension=? (get-extension file) streaming-image-extension))
                    files)
             (values 'image #f))
            (else
             (let ((audio? (some? (lambda (file)
                                    (member? (get-extension file) audio-extensions test: extension=?))
                                  files))
                   (video (collect (lambda (file)
                                     (find video-profiles (get-extension file) key: get-extension test: extension=? return: 'item))
                                   files)))
               (let ((video? (not-null? video)))
                 (cond ((and audio? video?)
                        (values 'video video))
                       (audio?
                        (values 'audio #f))
                       (video?
                        (values 'video video))
                       ((and (= count 1)
                             (member? (get-extension (car files)) preprocess-extensions test: extension=?))
                        (values 'preprocess #f))
                       (else
                        (values #f #f)))))))))
  
  (receive (kind profiles) (determine-kind files)
    (if (not kind)
        (values #f #f #f #f #f #f)
      (let ((location (and kind (join (subpath {Directory Documents} (car files)) "/"))))
        (let ((location (if (memq? kind '(preprocess))
                            location
                          (filename-spine location))))
          (let ((streaming (find-streaming udp-client location)))
            (let ((title (streaming-title streaming kind base profiles))
                  (color (streaming-color streaming kind)))
              (values kind location files profiles title color))))))))


(definition protected (streaming-title streaming kind base profiles)
  (let ((title (string-append base (streaming-level-suffix profiles))))
    (if streaming
        (format "{a} (playing)" title)
      title)))


(definition protected (streaming-color streaming kind)
  (if streaming
      {Color World-Blue}
    {Color White}))


(definition protected (streaming-level-suffix profiles)
  (if (not profiles)
      ""
    (let ((names (map get-name profiles)))
      (cond ((equal? names '(high))
             " [high]")
            ((equal? names '(full))
             " [full]")
            (else
             "")))))


;;;
;;;; Stream
;;;


;; because the channel-add calls use tcp, the first udp packets
;; will often arrive before them hence the need for a small delay
(definition protected stream-delay
  .2)


(definition protected (delay-stream stream (delay #f))
  (start-background-thread
    (lambda ()
      (sleep (or delay stream-delay))
      (with-task-mutex
        (lambda ()
          (let ((udp (current-udp)))
            (when (and udp (table-find (get-send-streams udp) stream))
              (play stream))))))
    'stream))


;;;
;;;; Mux
;;;


(definition public (mux-streams audio video output)
  (declare (proper-tail-calls))
  (let ((audio-reader (new Stream-Reader audio))
        (video-reader (new Stream-Reader video)))
    (let ((audio-caps (get-caps audio-reader))
          (video-caps (get-caps video-reader))
          (location (path-normalize (parse output))))
      (assert audio-caps)
      (assert video-caps)
      (let ((pipeline (gst-pipeline (format "appsrc caps=\"{a}\" name=audio" audio-caps)
                                    ;"audioconvert"
                                    ;"audioresample"
                                    ;(tie "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2")
                                    ;"opusenc name=enc"
                                    "qtmux name=mux"
                                    (tie "filesink location={location} name=sink")
                                    (list
                                      (format "appsrc caps=\"{a}\" name=video" video-caps)
                                      "h264parse"
                                      "mux^."))))
        (with-unref ((audiosrc (gst_bin_get_by_name pipeline "audio"))
                     (videosrc (gst_bin_get_by_name pipeline "video")))
          (define (process-audio)
            (let (loop)
              (let ((frame (read-frame audio-reader)))
                (when frame
                  (receive (buffer dts pts duration flags) frame
                    (gst_app_src_write audiosrc buffer (u8vector-length buffer) dts pts duration)
                    (loop))))))
          
          (define (process-video)
            (let (loop)
              (let ((frame (read-frame video-reader)))
                (when frame
                  (receive (buffer dts pts duration flags) frame
                    (gst_app_src_write videosrc buffer (u8vector-length buffer) dts pts duration)
                    (loop))))))
          
          (g-object-set audiosrc
                        "stream-type" 'int GST_APP_STREAM_TYPE_STREAM
                        "format"      'int GST_FORMAT_TIME)
          (g-object-set videosrc
                        "stream-type" 'int GST_APP_STREAM_TYPE_STREAM
                        "format"      'int GST_FORMAT_TIME)
          (gst_element_set_state pipeline GST_STATE_PLAYING)
          (let ((audio-thread (new-thread process-audio 'mux-audio))
                (video-thread (new-thread process-video 'mux-video)))
            (thread-start! audio-thread)
            (thread-start! video-thread)
            (thread-join! audio-thread)
            (thread-join! video-thread)
            (close audio-reader)
            (close video-reader)
            (set-pipeline-flushing? pipeline #f)
            (gst_element_send_event pipeline (gst_event_new_eos))
            ;; wait for eos message
            (with-unref ((bus (gst_pipeline_get_bus pipeline)))
              (let (loop (n 0))
                (if (> n 1000)
                    (error "Did not receive eos message")
                  (let ((msg (gst_bus_pop bus)))
                    (if (not msg)
                        (begin
                          (sleep .001)
                          (loop (+ n 1)))
                      (let ((type (GST_MESSAGE_TYPE msg)))
                        (if (/= type GST_MESSAGE_EOS)
                            (begin
                              (gst_message_unref msg)
                              (sleep .001)
                              (loop (+ n 1)))
                          (gst_message_unref msg))))))))
            (set-pipeline-flushing? pipeline #t)
            ;; quick hack as somehow waiting for eos doesn't ensure
            ;; all data has been processed and saved to the filesink
            (sleep 1)
            (gst_bin_release pipeline)))))))


;;;
;;;; Stitch
;;;


(definition public (stitch-streams files dest)
  (let ((start-time (current-seconds)))
    (define (determine-properties)
      (let ((properties #f)
            (bitrate #f)
            (caps #f))
        (for-each (lambda (file)
                    (with ((reader (new Stream-Reader file)))
                      (let ((p (list (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-codec reader)))
                            ;; ignore bitrate
                            (b (get-bitrate reader))
                            ;; ignore caps as they are not always consistent
                            (c (get-caps reader)))
                        (if (or (not properties)
                                (nu=? p properties))
                            (begin
                              (set! properties p)
                              (set! bitrate b)
                              (set! caps c))
                          (terminal properties)
                          (terminal p)
                          (error "Inconsistent stream properties")))))
                  files)
        (bind (kind level resolution framerate codec) properties
          (list kind level resolution framerate bitrate codec caps))))
    
    (bind (kind level resolution framerate bitrate codec caps) (determine-properties)
      (with ((writer (new Stream-Writer dest kind level resolution framerate bitrate codec caps)))
        (let ((offset 0))
          (for-each (lambda (file)
                      (let ((start-time (current-seconds)))
                        (with ((reader (new Stream-Reader file)))
                          (format :terminal "{a}" (get-name file))
                          (let (loop (last-dts #f) (last-duration #f) (count 0))
                            (let ((frame (read-frame reader)))
                              (if frame
                                  (receive (buffer dts pts duration flags) frame
                                    (let ((dts (+ offset (normalize-timestamp reader dts)))
                                          (pts (+ offset (normalize-timestamp reader pts))))
                                      (write-frame writer buffer dts pts duration flags)
                                      (when (= (modulo count 100) 0)
                                        (format :terminal "."))
                                      (loop dts duration (+ count 1))))
                                (set! offset (+ last-dts last-duration))
                                (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time)))))))))
                    files))))
    (format :terminal "done ({a}){%}" (present-seconds (- (current-seconds) start-time)))))


;;;
;;;; Convert
;;;


(definition protected (convert-streams dir (what: what #f) (dry?: dry? #f))
  (iterate-directory dir
    (lambda (file)
      (let ((extension (get-extension file)))
        (define (audio-extension?)
          (member? extension '("streamaudio")))
        
        (define (video-extension?)
          (member? extension '("streamvideo0"
                               "streamvideo1"
                               "streamvideo2"
                               "streamvideo3"
                               "streamvideo4")))
        
        (when (case what
                ((audio) (audio-extension?))
                ((video) (video-extension?))
                (else (or (audio-extension?)
                          (video-extension?))))
          (convert-stream file dry?: dry?))))
    files?: #t
    directories?: #f
    recursive?: #t))


(definition protected (convert-stream file (dry?: dry? #f))
  (declare (proper-tail-calls))
  (let ((name (get-name file))
        (base (get-base file))
        (extension (get-extension file)))
    (define (convert-to temp-file)
      (let ((start-time (current-seconds)))
        (let ((reader (new Stream-Reader file)))
          (let ((writer (new Stream-Writer temp-file (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-bitrate reader) (get-codec reader) (get-caps reader))))
            (format :terminal "{a}" name)
            (let (loop (count 0))
              (let ((frame (read-frame reader)))
                (if frame
                    (receive (buffer dts pts duration flags) frame
                      (write-frame writer buffer dts pts duration flags)
                      (when (= (modulo count 100) 0)
                        (format :terminal "."))
                      (loop (+ count 1)))
                  (close reader)
                  (close writer)
                  (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time))))))))))
    
    (if dry?
        (terminal name)
      (let ((temp-extension (string-append "temp" extension)))
        (let ((temp-file (new-brother file (add-extension base temp-extension))))
          (convert-to temp-file)
          (delete file)
          (rename temp-file file))))))


;;;
;;;; Parse
;;;


(definition protected (parse-stream file)
  (let ((temp (new-brother file (add-extension (get-base file) "temp"))))
    (with ((reader (new Stream-Reader file)))
      (let ((pipeline (gst-pipeline "appsrc name=src"
                                    "queue"
                                    "h264parse"
                                    "video/x-h264, stream-format=avc"
                                    "appsink sync=false name=sink")))
        (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                     (appsink (gst_bin_get_by_name pipeline "sink")))
          (let ((dts-flags (make-table))
                (dts-mutex (make-mutex 'dts))
                (read-count 0)
                (write-count 0)
                (done? #f))
            (define (run-read)
              (declare (proper-tail-calls))
              (let (loop)
                (let ((frame (read-frame reader)))
                  (if (not frame)
                      (set! done? #t)
                    (increase! read-count)
                    (receive (buffer dts pts duration flags) frame
                      (mutex-lock! dts-mutex)
                      (table-set! dts-flags dts flags)
                      (mutex-unlock! dts-mutex)
                      (gst_app_src_write appsrc buffer (u8vector-length buffer) dts pts duration))
                    (loop)))))
            
            (define (run-write)
              (declare (proper-tail-calls))
              (let ((kind (get-kind reader))
                    (level (get-level reader))
                    (resolution (get-resolution reader))
                    (framerate (get-framerate reader))
                    (bitrate (get-bitrate reader))
                    (codec (get-codec reader))
                    (caps (get-caps reader)))
                (let ((width (get-width resolution))
                      (height (get-height resolution)))
                  (let ((data (make-u8vector (* width height 4)))
                        (info (make-u64vector app-sink-info-size)))
                    (with ((writer (new Stream-Writer temp kind level resolution framerate bitrate codec caps)))
                      (let (loop)
                        (let ((size (gst_app_sink_try_pull_frame appsink data info)))
                          (if (= size -1)
                              (begin
                                (sleep .01)
                                (loop))
                            (increase! write-count)
                            (let ((buffer (subu8vector data 0 size))
                                  (dts (u64vector-ref info 0))
                                  (pts (u64vector-ref info 1))
                                  (duration (u64vector-ref info 2)))
                              (let ((flags (prog1 (begin
                                                    (mutex-lock! dts-mutex)
                                                    (table-ref dts-flags dts))
                                             (mutex-unlock! dts-mutex))))
                                (write-frame writer buffer dts pts duration flags)
                                (if (and done? (>= write-count read-count))
                                    (with-unref ((pad (gst_element_get_static_pad appsink "sink")))
                                      (let ((caps (gst_pad_get_current_caps pad)))
                                        (let ((caps-string (gst_caps_to_string caps)))
                                          (set-caps writer caps-string))
                                        (gst_caps_unref caps)))
                                  (loop))))))))))))
            
            (let ((read-thread (new-thread run-read 'read))
                  (write-thread (new-thread run-write 'write)))
              (gst-app-src-set-caps appsrc "video/x-h264"
                "stream-format" 'string   "byte-stream"
                "alignment"     'string   "au")
              (g-object-set appsrc
                            "is-live"     'boolean #t
                            "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                            "format"      'int     GST_FORMAT_TIME)
              (gst_element_set_state pipeline GST_STATE_PLAYING)
              (thread-start! read-thread)
              (thread-start! write-thread)
              (thread-join! read-thread)
              (thread-join! write-thread)
              (gst_element_release pipeline))))))
    (delete file)
    (rename temp file)))


;;;
;;;; Record
;;;


(definition pad-recording?
  #f)

(definition pad-monitors
  #f)


(definition protected (record-start pads)
  (let ((dir {Directory Settings "work" "records"})
        (pipeline (get-pipeline (cache-audio))))
    (define (parse-info info proc)
      (cond ((string? info)
             (proc info 'file))
            ((pair? info)
             (proc (first info) (second info)))))
    
    (define (parse-bin info)
      (let ((parts (split info "%")))
        (if (> (length parts) 1)
            parts
          (list #f info))))
    
    (define (find-bin bin-name)
      (if (not bin-name)
          pipeline
        (if (equal? bin-name "microphone")
            (get-pipeline (get-src (get-pipeline (get-microphone-channel (current-client)))))
          (let ((sink (let ((sinks (get-ordered-outputs (current-audio))))
                        (if (empty-string? bin-name)
                            (car sinks)
                          (find-if (lambda (sink)
                                     (search (gst_object_get_name (get-bin sink)) bin-name ignore-case?: #t))
                                   sinks)))))
            (get-bin sink)))))
    
    (define (monitor info)
      (parse-info info
        (lambda (info what)
          (bind (bin-name pad-info) (parse-bin info)
            (let ((bin (find-bin bin-name)))
              (define (monitor-file)
                (let ((file #f))
                  (define (filename pad)
                    (let ((info (rawaudio-pad-info pad)))
                      (let ((extension (rawaudio-extension info)))
                        (set! file (new-file dir (format "{a}.{a}" info extension)))
                        (path-normalize (parse file)))))
                  
                  (let ((monitored (gst_monitor bin pad-info 'file filename)))
                    (cons 'file (list monitored file)))))
              
              (define (monitor-analyse)
                (let ((listener (open-stream-listener)))
                  (let ((monitored (gst_monitor bin pad-info 'analyse (get-write-file listener)))
                        (thread (new-thread
                                  (lambda ()
                                    (declare (proper-tail-calls))
                                    (let ((discont 0)
                                          (gap 0)
                                          (expected 0)
                                          (silence 0))
                                      (let (loop)
                                        (case (wait listener)
                                          ((#\d)
                                           (increase! discont)
                                           (format :terminal "{a} : discont -> {a}{%}" pad-info discont)
                                           (loop))
                                          ((#\g)
                                           (increase! gap)
                                           (format :terminal "{a} : gap -> {a}{%}" pad-info gap)
                                           (loop))
                                          ((#\e)
                                           (increase! expected)
                                           (format :terminal "{a} : expected -> {a}{%}" pad-info expected)
                                           (loop))
                                          ((#\s)
                                           (increase! silence)
                                           (format :terminal "{a} : silence -> {a}{%}" pad-info silence)
                                           (loop))))))
                                  'monitor)))
                    (thread-base-priority-set! thread background-priority)
                    (thread-start! thread)
                    (cons 'analyse (list monitored listener thread)))))
              
              (define (monitor-other)
                (let ((monitored (gst_monitor bin pad-info what pipeline)))
                  (cons what monitored)))
              
              (case what
                ((file)
                 (monitor-file))
                ((analyse)
                 (monitor-analyse))
                (else
                 (monitor-other))))))))
      
    (when (not pad-recording?)
      (create-directories dir)
      (set! pad-monitors (map monitor pads))
      (set! pad-recording? #t))))


(definition protected (record-done)
  (define (unmonitor info)
    (define (unmonitor-file rest)
      (bind (monitored file) rest
        (gst_unmonitor monitored)))
    
    (define (unmonitor-analyse rest)
      (bind (monitored listener thread) rest
        (exit-thread thread)
        (close-stream-listener listener)
        (gst_unmonitor monitored)))
    
    (define (unmonitor-other monitored)
      (gst_unmonitor monitored))
    
    (bind (what . rest) info
      (case what
        ((file)
         (unmonitor-file rest))
        ((analyse)
         (unmonitor-analyse rest))
        (else
         (unmonitor-other rest)))))
  
  (when pad-recording?
    (for-each unmonitor pad-monitors)
    (set! pad-recording? #f)))


(definition protected (recorded-files)
  (and pad-monitors (collect (lambda (info)
                               (bind (what . rest) info
                                 (and (eq? what 'file)
                                      (bind (monitored file) rest
                                        file))))
                             pad-monitors))))
