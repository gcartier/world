;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.io)
        (jazz.stream)
        (world)
        (world.audio)
        (world.context)
        (world.settings)
        (world.udp)
        (world.video))


;;;
;;;; Audio
;;;


(definition (client-audio-consumer client channel-no)
  (lambda (buffer timestamp duration)
    (case audio-codec
      ((opus)
       (let ((header? (and buffer (audio-buffer-header? buffer))))
         (send-client-audio client channel-no buffer header? timestamp duration)))
      ((vorbis)
       (if (pair? buffer)
           (send-client-audio client channel-no (car buffer) #t -1 GST_CLOCK_TIME_NONE)
         (send-client-audio client channel-no buffer #f timestamp duration))))))


(definition public (make-audio-channel location name)
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-audio #f #f #t)))
      (let ((channel-no (get-no channel)))
        (let ((src (new File-Stream-Audio-Src
                     location))
              (sink (new Stream-Sink
                      consumer: (client-audio-consumer client channel-no))))
          (let ((pipeline (pipeline src sink)))
            (set-pipeline channel pipeline)
            channel))))))


(definition public (make-mic-channel name)
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-audio #f #f #f)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Mic-Audio-Src))
              (sink (new Stream-Sink
                      consumer: (client-audio-consumer client channel-no))))
          (let ((pipeline (pipeline src sink)))
            (set-pipeline channel pipeline)
            channel))))))


;;;
;;;; Video
;;;


(definition (client-video-consumer client channel-no)
  (lambda (buffer timestamp duration)
    (let ((header? (and buffer (video-buffer-header? buffer))))
      (send-client-video client channel-no buffer header? timestamp duration))))


(definition public (make-draw-channel name draw-proc action-proc)
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-video #f #f #t)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Draw-Video-Src
                     draw-proc: draw-proc))
              (sink (new Stream-Sink
                      consumer: (client-video-consumer client channel-no))))
          (let ((pipeline (pipeline src sink)))
            (set-pipeline channel pipeline)
            (set-action-proc channel action-proc)
            channel))))))


(definition public (make-image-channel location name (action-proc: action-proc #f))
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-video #f #f #t)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Image-Stream-Video-Src
                     location))
              (sink (new Stream-Sink
                      consumer: (client-video-consumer client channel-no))))
          (let ((pipeline (pipeline src sink)))
            (set-pipeline channel pipeline)
            (set-action-proc channel action-proc)
            channel))))))


(definition public (make-video-channel location name (action-proc: action-proc #f))
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-video #f #f #t)))
      (let ((channel-no (get-no channel)))
        (let ((src (new File-Stream-Video-Src
                     location))
              (sink (new Stream-Sink
                      consumer: (client-video-consumer client channel-no))))
          (let ((pipeline (pipeline src sink)))
            (set-pipeline channel pipeline)
            (set-action-proc channel action-proc)
            channel))))))


(definition public (make-camera-channel name)
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-video #f #f #f)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Camera-Video-Src
                     resolution: video-resolution
                     framerate: video-framerate
                     bitrate: video-bitrate
                     codec: video-codec))
              (sink (new Stream-Sink
                      consumer: (client-video-consumer client channel-no)))
              (self-sink (new Self-Sink)))
          (let ((pipeline (pipeline src (list sink self-sink))))
            (set-pipeline channel pipeline)
            channel))))))


(definition public (make-screen-channel name)
  (let ((client (current-client)))
    (let ((channel (register-channel client name udp-video screen-share-resolution #f #f)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Screen-Video-Src
                     resolution: screen-share-resolution
                     framerate: screen-share-framerate
                     bitrate: screen-share-bitrate
                     codec: video-codec))
              (sink (new Stream-Sink
                      consumer: (client-video-consumer client channel-no)))
              @wait (self-sink (new Self-Sink)))
          (let ((pipeline (pipeline src sink @wait (list sink self-sink))))
            (set-pipeline channel pipeline)
            channel))))))


;;;
;;;; Streams
;;;


(definition protected private-streams?
  (world-setting 'world.private-streams? #f))


(definition public streams-dir
  {Directory Settings "streams"})


(definition protected (iterate-streams subdir proc)
  (define (iterate dir)
    (iterate-directory dir
      (lambda (file)
        (proc file))
      files?: #t
      directories?: #f
      recursive?: #f)
    (iterate-directory dir
      (lambda (subdir)
        (when (or private-streams?
                  (not (filename=? (get-name subdir) "private")))
          (iterate subdir)))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (let ((dir (new-directory streams-dir subdir)))
    (when (exists? dir)
      (iterate dir))))


;;;
;;;; Streaming
;;;


(definition protected (delay-streaming thunk)
  ;; so that the add-channel calls are not blocked
  (delay-event
    (lambda ()
      ;; because the add-channel calls use tcp, the first udp packets
      ;; will often arrive before them hence the need for a small delay
      (sleep .1)
      (thunk)))))
