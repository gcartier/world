;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.io)
        (jazz.stream)
        (world)
        (world.audio)
        (world.context)
        (world.settings)
        (world.udp)
        (world.video))


;;;
;;;; Stream
;;;


(definition public (make-stream name source-kind (can-local?: can-local? #f))
  (let ((client (current-client)))
    (let ((recipient (if (and can-local? stream-local?) client-no #f)))
      (register-stream client name source-kind recipient #f))))


;;;
;;;; Audio
;;;


(definition (client-audio-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer timestamp duration)
    (case audio-codec
      ((opus)
       (when mirror?
         (receive-audio (current-audio) channel-no buffer timestamp duration))
       (unless local?
         (let ((header? (and buffer (audio-buffer-header? buffer))))
           (send-client-audio client channel-no buffer header? timestamp duration))))
      ((vorbis)
       (cond ((pair? buffer)
              (when mirror?
                (let ((headers (u8vector->object (car buffer))))
                  (for-each (lambda (header)
                              (bind (buffer timestamp duration) header
                                (receive-audio (current-audio) channel-no buffer timestamp duration)))
                            headers)))
              (unless local?
                (send-client-audio client channel-no (car buffer) #t -1 GST_CLOCK_TIME_NONE)))
             (else
              (when mirror?
                (receive-audio (current-audio) channel-no buffer timestamp duration))
              (unless local?
                (send-client-audio client channel-no buffer #f timestamp duration))))))))


(definition public (add-audio-channel stream-no location)
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (register-channel client stream-no udp-audio 'stream #f #f #f audio-codec recipient #f)))
        (let ((channel-no (get-no channel)))
          (let ((src (new File-Stream-Audio-Src
                       location))
                (sink (new Stream-Sink
                        consumer: (client-audio-consumer client channel-no mirror?: #t local?: stream-local?))))
            (let ((pipeline (pipeline src sink)))
              (set-pipeline channel pipeline)
              channel)))))))


(definition public (add-mic-channel stream-no)
  (let ((client (current-client)))
    (let ((channel (register-channel client stream-no udp-audio 'live #f #f #f audio-codec #f #t)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Mic-Audio-Src))
              (sink (new Stream-Sink
                      consumer: (client-audio-consumer client channel-no))))
          (let ((pipeline (pipeline src sink)))
            (set-pipeline channel pipeline)
            channel))))))


;;;
;;;; Video
;;;


(definition (client-video-consumer client channel-no (mirror?: mirror? #f) (local?: local? #f))
  (lambda (buffer timestamp duration)
    (when mirror?
      (receive-video (current-video) channel-no buffer timestamp duration))
    (unless local?
      (let ((header? (and buffer (video-buffer-header? buffer))))
        (send-client-video client channel-no buffer header? timestamp duration)))))


(definition public (add-draw-channel draw-proc action-proc)
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (register-channel client udp-video 'draw draw-resolution #f draw-bitrate #f recipient #f)))
        (let ((channel-no (get-no channel)))
          (let ((src (new Draw-Video-Src
                       draw-proc: draw-proc))
                (sink (new Stream-Sink
                        consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
            (let ((pipeline (pipeline src sink)))
              (set-pipeline channel pipeline)
              (set-action-proc channel action-proc)
              channel)))))))


(definition public (add-image-channel stream-no location (action-proc: action-proc #f))
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (let ((channel (register-channel client stream-no udp-video 'image draw-resolution #f draw-bitrate #f recipient #f)))
        (let ((channel-no (get-no channel)))
          (let ((src (new Image-Stream-Video-Src
                       location))
                (sink (new Stream-Sink
                        consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
            (let ((pipeline (pipeline src sink)))
              (set-pipeline channel pipeline)
              (set-action-proc channel action-proc)
              channel)))))))


(definition public (add-video-channels stream-no location (action-proc: action-proc #f))
  (let ((client (current-client)))
    (let ((recipient (if stream-local? client-no #f)))
      (collect (lambda (profile)
                 (and (exists? (new-file {Directory Settings} (list "streams" (add-extension location (get-extension profile)))))
                      (let ((resolution (get-resolution profile))
                            (framerate (get-framerate profile))
                            (bitrate (get-bitrate profile)))
                        (let ((channel (register-channel client stream-no udp-video 'stream resolution framerate bitrate #f recipient #f)))
                          (let ((channel-no (get-no channel)))
                            (let ((src (new File-Stream-Video-Src
                                         profile
                                         location))
                                  (sink (new Stream-Sink
                                          consumer: (client-video-consumer client channel-no mirror?: #t local?: stream-local?))))
                              (let ((pipeline (pipeline src sink)))
                                (set-pipeline channel pipeline)
                                (set-action-proc channel action-proc)
                                channel)))))))
           (streaming-video-profiles)))))


(definition public (add-camera-channel stream-no)
  (let ((client (current-client)))
    (let ((channel (register-channel client stream-no udp-video 'live camera-resolution camera-framerate camera-bitrate camera-codec #f #t)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Camera-Video-Src
                     resolution: camera-resolution
                     framerate: camera-framerate
                     bitrate: camera-bitrate
                     codec: camera-codec))
              (sink (new Stream-Sink
                      consumer: (client-video-consumer client channel-no)))
              (self-sink (new Self-Sink
                           resolution: camera-resolution)))
          (let ((pipeline (pipeline src (list sink self-sink))))
            (set-pipeline channel pipeline)
            channel))))))


(definition public (add-screen-channel stream-no)
  (let ((client (current-client)))
    (let ((channel (register-channel client stream-no udp-video 'screen screen-share-resolution screen-share-framerate screen-share-bitrate screen-share-codec #f #t)))
      (let ((channel-no (get-no channel)))
        (let ((src (new Screen-Video-Src
                     resolution: screen-share-resolution
                     framerate: screen-share-framerate
                     bitrate: screen-share-bitrate
                     codec: screen-share-codec))
              (sink (new Stream-Sink
                      consumer: (client-video-consumer client channel-no)))
              @wait (self-sink (new Self-Sink
                                 resolution: screen-share-resolution)))
          (let ((pipeline (pipeline src sink @wait (list sink self-sink))))
            (set-pipeline channel pipeline)
            channel))))))


;;;
;;;; Streams
;;;


(definition protected stream-multiple?
  (world-setting 'world.stream-multiple? #f))

(definition protected stream-repeatable?
  (world-setting 'world.stream-repeatable? #f))

(definition protected stream-private?
  (world-setting 'world.stream-private? #f))

(definition protected stream-silent?
  (world-setting 'world.stream-silent? #f))

(definition protected stream-local?
  (world-setting 'world.stream-local? #f))


(definition public streams-dir
  {Directory Settings "streams"})


(definition protected (iterate-streams subdir proc)
  (define (iterate dir private?)
    (unless (and (eq? stream-private? 'only)
                 (not private?))
      (iterate-directory dir
        (lambda (file)
          (proc file))
        files?: #t
        directories?: #f
        recursive?: #f))
    (iterate-directory dir
      (lambda (subdir)
        (let ((private-dir? (filename=? (get-name subdir) "private")))
          (when (or stream-private?
                    (not private-dir?))
            (iterate subdir (or private? private-dir?)))))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (let ((dir (new-directory streams-dir subdir)))
    (when (exists? dir)
      (iterate dir #f))))


;;;
;;;; Streaming
;;;


(definition protected (delay-streaming thunk (delay #f))
  ;; so that the add-channel calls are not blocked
  (delay-event
    (lambda ()
      ;; because the add-channel calls use tcp, the first udp packets
      ;; will often arrive before them hence the need for a small delay
      (sleep (or delay .1))
      (thunk)))))
