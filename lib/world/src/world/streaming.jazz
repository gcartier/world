;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.streaming jazz


(import (jazz.event)
        (jazz.graphic)
        (jazz.io)
        (jazz.listener)
        (jazz.screen)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (world)
        (world.audio)
        (world.buffers)
        (world.configure)
        (world.context)
        (world.event)
        (world.media)
        (world.settings)
        (world.stream)
        (world.task)
        (world.udp)
        (world.video))


(definition protected camera-single?
  (world-setting 'world.camera-single? #f))

(definition protected camera-all?
  (world-setting 'world.camera-all? #f))


;;;
;;;; Channel
;;;


(class Channel-Creator extends Object
  
  
  (slot descriptor     getter generate)
  (slot create         getter generate)
  (slot share-pipeline getter generate)
  
  
  (method override (initialize self descriptor create (share-pipeline #f))
    (nextmethod self)
    (set! self.descriptor descriptor)
    (set! self.create create)
    (set! self.share-pipeline share-pipeline)))


;;;
;;;; Stream
;;;


(definition public (determine-stream-video-level creators)
  (let ((levels (map (lambda (creator)
                       (bind (media-kind source-kind level) (get-descriptor creator)
                         (assert (= media-kind udp-video)
                           level)))
                     creators)))
    (if (memv? #f levels)
        #f
      (maximum levels))))


(definition public (make-stream name source-kind video-level creators (location: location #f))
  (let ((client (current-client)))
    (let ((recipient #f)
          (channels (map get-descriptor creators)))
      (bind (stream-no . channel-nos) (register-stream client name source-kind video-level channels recipient)
        (let ((stream (register-send-stream (get-udp-client client) (get-character-name client) name stream-no source-kind video-level)))
          (set-location stream location)
          (for-each (lambda (channel-no creator)
                      (let ((create (get-create creator)))
                        (create stream-no channel-no)))
                    channel-nos
                    creators)
          stream)))))


(definition protected (stream-controller-action stream action arguments)
  (case action
    ((pause)
     (stream-pause stream))
    ((play)
     (stream-play stream))
    ((seek)
     (bind (pos) arguments
       (stream-seek stream pos)))
    ((backward)
     (stream-backward stream))
    ((forward)
     (stream-forward stream))
    ((mute)
     (stream-mute stream))
    ((unmute)
     (stream-unmute stream))))


(definition (stream-pause stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (pause channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (pause-stream src)))))


(definition (stream-play stream)
  (iterate-table (get-channels stream)
    (lambda (no channel)
      (play channel)
      ;; kinda quicky needing more thought
      (let ((src (get-src (get-pipeline channel))))
        (play-stream src)))))


(definition (stream-seek stream pos)
  (if (not pos)
      (iterate-table (get-channels stream)
        (lambda (no channel)
          (let ((src (get-src (get-pipeline channel))))
            (goto-stream src #f #f))))
    (let ((highest-video (locate-highest-video-channel stream))
          (reader (locate-seek-reader stream)))
      ;; video seeks to keyframe so use its
      ;; frame's dts to seek in all channels
      (let ((frame (seek->keyframe reader pos)))
        (receive (size dts pts duration flags) (read-header reader frame)
          (let ((pos (frame->position reader frame))
                (normalized-dts (normalize-timestamp reader dts)))
            (iterate-table (get-channels stream)
              (lambda (no channel)
                (let ((src (get-src (get-pipeline channel))))
                  (if (eq? channel highest-video)
                      (goto-stream src pos normalized-dts)
                    (goto-delayed src pos normalized-dts)))))))))))


(definition (stream-backward stream)
  (let ((reader (locate-seek-reader stream)))
    ;; video seeks to keyframe so use its
    ;; frame's dts to seek in all channels
    (let ((frame (previous-keyframe reader)))
      (when frame
        (receive (size dts pts duration flags) (read-header reader frame)
          (let ((pos (frame->position reader frame))
                (normalized-dts (normalize-timestamp reader dts)))
            (iterate-table (get-channels stream)
              (lambda (no channel)
                (let ((src (get-src (get-pipeline channel))))
                  (backward-stream src pos normalized-dts))))))))))


(definition (stream-forward stream)
  (let ((reader (locate-seek-reader stream)))
    ;; video seeks to keyframe so use its
    ;; frame's dts to seek in all channels
    (let ((frame (next-keyframe reader)))
      (when frame
        (receive (size dts pts duration flags) (read-header reader frame)
          (let ((pos (frame->position reader frame))
                (normalized-dts (normalize-timestamp reader dts)))
            (iterate-table (get-channels stream)
              (lambda (no channel)
                (let ((src (get-src (get-pipeline channel))))
                  (forward-stream src pos normalized-dts))))))))))


(definition (stream-mute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (mute-stream src))))


(definition (stream-unmute stream)
  (let ((audio-channel (locate-stream-audio-channel stream)))
    (let ((src (get-src (get-pipeline audio-channel))))
      (unmute-stream src))))


(definition (locate-seek-reader stream)
  (let ((highest-video (locate-highest-video-channel stream)))
    (if highest-video
        (let ((src (get-src (get-pipeline highest-video))))
          (get-reader src))
      (let ((audio (locate-stream-audio-channel stream)))
        (let ((src (get-src (get-pipeline audio))))
          (get-reader src))))))


(definition (locate-highest-video-channel stream)
  (let ((highest-channel #f))
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (when (= (get-media-kind channel) udp-video)
          (let ((src (get-src (get-pipeline channel))))
            (when (get-stream? src)
              (when (or (not highest-channel)
                        (> (get-level channel)
                           (get-level highest-channel)))
                (set! highest-channel channel)))))))
    highest-channel))


;;;
;;;; Audio
;;;


(definition protected (client-audio-consumer client channel (mirror?: mirror? #f))
  (let ((channel-no (get-no channel)))
    (lambda (buffer dts pts duration flags)
      (when mirror?
        (let ((mutex (get-audio-mirror-mutex channel)))
          (mutex-lock! mutex)
          (receive-audio (current-audio) channel-no buffer dts pts duration)
          (mutex-unlock! mutex)))
      (send-client-media client channel-no buffer dts pts duration flags))))


(definition public (make-stream-audio-channel location)
  (let ((file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
    (let ((reader (new Stream-Reader file)))
      (let ((media-kind udp-audio)
            (source-kind 'stream)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec (get-codec reader))
            (caps (get-caps reader))
            (metadata '())
            (send-state 'on))
        (close reader)
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
          (lambda (stream-no channel-no)
            (let ((client (current-client)))
              (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                (channel-output (current-audio) channel)
                (let ((src (new File-Stream-Audio-Src
                             location))
                      (sink (new Stream-Frame-Consumer
                              consumer: (client-audio-consumer client channel mirror?: #t))))
                  (let ((pipeline (pipeline (list src sink))))
                    (set-pipeline channel pipeline)))))))))))


(definition public (make-microphone-channel)
  (let ((src (new Microphone-Audio-Src))
        (sink (new Microphone-Audio-Consumer)))
    (let ((pipeline (pipeline (list src sink))))
      (let ((media-kind udp-audio)
            (source-kind 'live)
            (level #f)
            (resolution #f)
            (framerate #f)
            (bitrate #f)
            (codec audio-codec)
            (caps #f)
            (metadata '())
            (send-state 'off))
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
          (lambda (stream-no channel-no)
            (let ((client (current-client)))
              (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                (set-consumer sink (client-audio-consumer client channel))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Video
;;;


(definition protected (existing-video-profiles location)
  (let ((profiles (streaming-video-profiles)))
    (collect-if (lambda (profile)
                  (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
                    (exists? file)))
                profiles)))


(definition protected (client-video-consumer client channel-no (mirror?: mirror? #f))
  (lambda (buffer dts pts duration flags)
    (when mirror?
      (receive-video (current-video) channel-no buffer dts pts duration flags))
    (send-client-media client channel-no buffer dts pts duration flags)))


(definition public (make-draw-channel draw-proc action-proc)
  (let ((media-kind udp-video)
        (source-kind 'draw)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '())
        (send-state 'on))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
            (channel-output (current-video) stream-no channel)
            (let ((src (new Draw-Video-Src
                         draw-proc: draw-proc))
                  (sink (new Stream-Frame-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc)))))))))


(definition public (make-image-channel location (action-proc: action-proc #f))
  (let ((media-kind udp-video)
        (source-kind 'image)
        (level #f)
        (resolution draw-resolution)
        (framerate #f)
        (bitrate draw-bitrate)
        (codec #f)
        (caps #f)
        (metadata '())
        (send-state 'on))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
            (channel-output (current-video) stream-no channel)
            (let ((src (new Image-Stream-Video-Src
                         location
                         resolution: resolution))
                  (sink (new Stream-Frame-Consumer
                          consumer: (client-video-consumer client channel-no mirror?: #t))))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)
                (set-action-proc channel action-proc)))))))))


(definition public (make-stream-video-channels location (action-proc: action-proc #f))
  (let ((existing-profiles (existing-video-profiles location))
        (active-profile (active-video-profile)))
    (let ((unique-profile? (= 1 (length existing-profiles))))
      (map (lambda (profile)
             (let ((file (new-file {Directory Documents} (add-extension location (get-extension profile)))))
               (let ((reader (new Stream-Reader file)))
                 (let ((media-kind udp-video)
                       (source-kind 'stream)
                       (level (get-level profile)))
                   (let ((resolution (get-resolution reader))
                         (framerate (get-framerate reader))
                         (bitrate (get-bitrate reader))
                         (codec (get-codec reader))
                         (caps (get-caps reader))
                         (metadata (list start: (get-start reader) end: (get-end reader)))
                         (send-state 'on))
                     (close reader)
                     (new Channel-Creator
                       (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
                       (lambda (stream-no channel-no)
                         (let ((client (current-client)))
                           (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                             (when (or (eq? profile active-profile) unique-profile?)
                               (let ((video (current-video)))
                                 (let ((output (channel-output video stream-no channel sync-audio?: #t)))
                                   (when (not (get-focused-output video))
                                     (change-focused-output video output))
                                   output)))
                             (let ((stream? (or (<= level (get-level active-profile)) unique-profile?)))
                               (let ((src (new File-Stream-Video-Src
                                            profile
                                            location
                                            stream?: stream?))
                                     (sink (new Stream-Frame-Consumer
                                             consumer: (client-video-consumer client channel-no mirror?: #t))))
                                 (let ((pipeline (pipeline (list src sink))))
                                   (set-pipeline channel pipeline)
                                   (set-action-proc channel action-proc)))))))))))))
           existing-profiles))))


(definition protected (camera-profiles profile)
  (let ((level (get-level profile)))
    (loop (for l from level downto 0)
          (collect (level->video-profile l)))))


(definition public (make-camera-channels)
  (let ((camera-profile (maximum-camera-profile)))
    (let ((profiles (camera-profiles camera-profile)))
      (map (lambda (profile)
             (let ((media-kind udp-video)
                   (source-kind 'live)
                   (level (get-level profile))
                   (resolution (get-resolution profile))
                   (framerate (get-framerate profile))
                   (bitrate (get-bitrate profile))
                   (codec (get-codec profile))
                   (caps #f)
                   (metadata '())
                   (send-state 'off))
               (new Channel-Creator
                 (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
                 (lambda (stream-no channel-no)
                   (let ((client (current-client)))
                     (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state))))))
           profiles))))


(definition protected (make-shared-camera-pipeline stream-no channels)
  (let ((client (current-client)))
    (let ((camera-profile (maximum-camera-profile)))
      (let ((profiles (camera-profiles camera-profile))
            (level-override (camera-profile-override-level)))
        (let ((src (new Camera-Video-Src
                     resolution: (get-resolution camera-profile)
                     framerate: (get-framerate camera-profile)
                     selfrate: (get-selfrate camera-profile)))
              (self-sinks (map (lambda (profile)
                                 (new Camera-Self-Consumer
                                   stream-no: stream-no
                                   caps: 'self
                                   profile: profile
                                   processing?: (= (get-level profile) level-override)))
                               profiles))
              (sinks (map (lambda (profile)
                            (let ((channel (find-if (lambda (channel)
                                                      (= (get-level channel) (get-level profile)))
                                                    channels)))
                              (new Camera-Video-Consumer
                                channel-no: (get-no channel)
                                profile: profile
                                processing?: (and (<= (get-level profile) level-override)
                                                  (streaming-level? client (get-level profile) level-override)))))
                          profiles)))
          (pipeline `(,src ,@self-sinks ,@sinks)))))))


(definition public (make-view-channel)
  (let ((world (current-world)))
    (receive (width height multisampling) (render-settings (get-render-target world))
      (let ((media-kind udp-video)
            (source-kind 'view)
            (level #f)
            (resolution (new Dimension width height))
            (framerate view-share-framerate)
            (bitrate view-share-bitrate)
            (codec view-share-codec)
            (caps #f)
            (metadata '())
            (send-state 'on))
        (new Channel-Creator
          (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
          (lambda (stream-no channel-no)
            (let ((client (current-client)))
              (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                (channel-output (current-video) stream-no channel)
                (let ((src (new View-Video-Src
                             resolution: resolution
                             framerate: view-share-framerate
                             min-bitrate: view-share-min-bitrate
                             bitrate: view-share-bitrate
                             codec: view-share-codec))
                      (sink (new View-Video-Consumer
                              channel-no)))
                  (let ((pipeline (pipeline (list src sink))))
                    (set-pipeline channel pipeline)))))))))))


(definition public (make-screen-channel)
  (let ((media-kind udp-video)
        (source-kind 'screen)
        (level #f)
        (resolution screen-share-resolution)
        (framerate screen-share-framerate)
        (bitrate screen-share-bitrate)
        (codec screen-share-codec)
        (caps #f)
        (metadata '())
        (send-state 'on))
    (new Channel-Creator
      (list media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
      (lambda (stream-no channel-no)
        (let ((client (current-client)))
          (let ((channel (register-send-channel (get-udp-client client) stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
            (channel-output (current-video) stream-no channel)
            (let ((src (new Screen-Video-Src
                         resolution: screen-share-resolution
                         framerate: screen-share-framerate
                         min-bitrate: screen-share-min-bitrate
                         bitrate: screen-share-bitrate
                         codec: screen-share-codec))
                  (sink (new Screen-Video-Consumer
                          channel-no)))
              (let ((pipeline (pipeline (list src sink))))
                (set-pipeline channel pipeline)))))))))


;;;
;;;; Streams
;;;


(definition protected image-extensions
  '("jpg" "jpeg" "png"))

(definition protected text-extensions
  '("txt"))


(definition protected (iterate-stream-directories proc)
  (let ((dirnames (or stream-directories '("streams"))))
    (for-each (lambda (dirname)
                (let ((dir (new-directory {Directory Documents} dirname)))
                  (when (exists? dir)
                    (proc dir))))
              dirnames)))


(definition protected (iterate-streams proc)
  (define (iterate dir)
    (iterate-directory dir
      (lambda (file)
        (proc file))
      files?: #t
      directories?: #f
      recursive?: #f)
    (iterate-directory dir
      (lambda (subdir)
        (iterate subdir))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  (iterate-stream-directories iterate))


(definition protected (gather-streams)
  (let ((video-extensions (streaming-video-extensions))
        (audio-extensions (streaming-audio-extensions))
        (queue (new-queue)))
    (iterate-streams
      (lambda (file)
        (let ((location (filename-spine (join (subpath {Directory Documents} file) "/")))
              (extension (get-extension file)))
          (cond ((member? extension audio-extensions test: extension=?)
                 (let ((info (find (queue-list queue) location key: first test: filename=? return: 'item)))
                   (if (not info)
                       (enqueue queue (list location #t #f))
                     (set-second! info #t))))
                ((member? extension video-extensions test: extension=?)
                 (let ((info (find (queue-list queue) location key: first test: filename=? return: 'item))
                       (profile (find video-profiles extension key: get-extension test: extension=? return: 'item)))
                   (if (not info)
                       (enqueue queue (list location #f (list profile)))
                     (set-third! info (cons profile (or (third info) '()))))))))))
    (queue-list queue)))


(definition protected (streaming-information udp-client base files audio-extensions video-profiles preprocess-extensions)
  (define (determine-kind files)
    (let ((count (length files)))
      (cond ((and (= count 1)
                  (member? (get-extension (car files)) image-extensions test: extension=?))
             (values 'image #f))
            ((and (= count 1)
                  (member? (get-extension (car files)) text-extensions test: extension=?))
             (values 'text #f))
            (else
             (let ((audio? (some? (lambda (file)
                                    (member? (get-extension file) audio-extensions test: extension=?))
                                  files))
                   (video (collect (lambda (file)
                                     (find video-profiles (get-extension file) key: get-extension test: extension=? return: 'item))
                                   files)))
               (let ((video? (not-null? video)))
                 (cond ((and audio? video?)
                        (values 'video video))
                       (audio?
                        (values 'audio #f))
                       (video?
                        (values 'video video))
                       ((and (= count 1)
                             (member? (get-extension (car files)) preprocess-extensions test: extension=?))
                        (values 'preprocess #f))
                       (else
                        (values #f #f)))))))))
  
  (receive (kind profiles) (determine-kind files)
    (if (not kind)
        (values #f #f #f #f #f #f)
      (let ((location (and kind (join (subpath {Directory Documents} (car files)) "/"))))
        (let ((location (if (memq? kind '(image preprocess))
                            location
                          (filename-spine location))))
          (let ((streaming (find-streaming udp-client location)))
            (let ((title (streaming-title streaming kind base profiles))
                  (color (streaming-color streaming kind)))
              (values kind location files profiles title color))))))))


(definition protected (streaming-title streaming kind base profiles)
  (let ((title (string-append base (streaming-level-suffix profiles))))
    (if streaming
        (format "{a} (playing)" title)
      title)))


(definition protected (streaming-color streaming kind)
  (if streaming
      {Color World-Blue}
    {Color White}))


(definition protected (streaming-level-suffix profiles)
  (if (not profiles)
      ""
    (let ((names (map get-name profiles)))
      (cond ((equal? names '(high))
             " [high]")
            ((equal? names '(full))
             " [full]")
            (else
             "")))))


;;;
;;;; Stream
;;;


;; because the channel-add calls use tcp, the first udp packets
;; will often arrive before them hence the need for a small delay
(definition protected stream-delay
  .2)


(definition protected (delay-stream stream (delay #f))
  (start-background-thread
    (lambda ()
      (sleep (or delay stream-delay))
      (with-task-mutex
        (lambda ()
          (let ((udp (current-udp)))
            (when (and udp (table-find (get-send-streams udp) stream))
              (play stream))))))
    'stream))


;;;
;;;; Mux
;;;


(definition public (mux-streams audio video output)
  (let ((audio-reader (new Stream-Reader audio))
        (video-reader (new Stream-Reader video)))
    (let ((audio-caps (get-caps audio-reader))
          (video-caps (get-caps video-reader))
          (location (path-normalize (parse output))))
      (let ((pipeline (gst-pipeline (format "appsrc caps=\"{a}\" name=audio" audio-caps)
                                    "qtmux name=mux"
                                    (tie "filesink location={location} name=sink")
                                    (list
                                      (format "appsrc caps=\"{a}\" name=video" video-caps)
                                      "h264parse"
                                      "mux^."))))
        (with-unref ((audiosrc (gst_bin_get_by_name pipeline "audio"))
                     (videosrc (gst_bin_get_by_name pipeline "video")))
          (define (process-audio)
            (declare (proper-tail-calls))
            (let (loop)
              (let ((frame (read-frame audio-reader)))
                (when frame
                  (receive (buffer dts pts duration flags) frame
                    (gst_app_src_write audiosrc buffer (u8vector-length buffer) dts pts duration)
                    (loop))))))
          
          (define (process-video)
            (declare (proper-tail-calls))
            (let (loop)
              (let ((frame (read-frame video-reader)))
                (when frame
                  (receive (buffer dts pts duration flags) frame
                    (gst_app_src_write videosrc buffer (u8vector-length buffer) dts pts duration)
                    (loop))))))
          
          (g-object-set audiosrc
                        "stream-type" 'int GST_APP_STREAM_TYPE_STREAM
                        "format"      'int GST_FORMAT_TIME)
          (g-object-set videosrc
                        "stream-type" 'int GST_APP_STREAM_TYPE_STREAM
                        "format"      'int GST_FORMAT_TIME)
          (gst_element_set_state pipeline GST_STATE_PLAYING)
          (let ((audio-thread (new-thread process-audio 'mux-audio))
                (video-thread (new-thread process-video 'mux-video)))
            (thread-start! audio-thread)
            (thread-start! video-thread)
            (thread-join! audio-thread)
            (thread-join! video-thread)
            (close audio-reader)
            (close video-reader)
            ;; quick hack as somehow waiting for eos doesn't ensure
            ;; all data has been processed and saved to the filesink
            (sleep 1)
            (set-pipeline-flushing? pipeline #f)
            (gst_element_send_event pipeline (gst_event_new_eos))
            ;; wait for eos message
            (with-unref ((bus (gst_pipeline_get_bus pipeline)))
              (let (loop)
                (let ((msg (gst_bus_pop bus)))
                  (if (not msg)
                      (begin
                        (sleep .001)
                        (loop))
                    (let ((type (GST_MESSAGE_TYPE msg)))
                      (if (/= type GST_MESSAGE_EOS)
                          (begin
                            (gst_message_unref msg)
                            (sleep .001)
                            (loop))
                        (gst_message_unref msg)))))))
            (set-pipeline-flushing? pipeline #t)
            (gst_bin_release pipeline)))))))


;;;
;;;; Stitch
;;;


(definition public (stitch-streams files dest)
  (let ((start-time (current-seconds)))
    (define (determine-properties)
      (let ((properties #f)
            (bitrate #f)
            (caps #f))
        (for-each (lambda (file)
                    (with ((reader (new Stream-Reader file)))
                      (let ((p (list (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-codec reader)))
                            ;; ignore bitrate
                            (b (get-bitrate reader))
                            ;; ignore caps as they are not always consistent
                            (c (get-caps reader)))
                        (if (or (not properties)
                                (nu=? p properties))
                            (begin
                              (set! properties p)
                              (set! bitrate b)
                              (set! caps c))
                          (terminal properties)
                          (terminal p)
                          (error "Inconsistent stream properties")))))
                  files)
        (bind (kind level resolution framerate codec) properties
          (list kind level resolution framerate bitrate codec caps))))
    
    (bind (kind level resolution framerate bitrate codec caps) (determine-properties)
      (with ((writer (new Stream-Writer dest kind level resolution framerate bitrate codec caps: caps)))
        (let ((offset 0))
          (for-each (lambda (file)
                      (let ((start-time (current-seconds)))
                        (with ((reader (new Stream-Reader file)))
                          (format :terminal "{a}" (get-name file))
                          (let (loop (last-dts #f) (last-duration #f) (count 0))
                            (let ((frame (read-frame reader)))
                              (if frame
                                  (receive (buffer dts pts duration flags) frame
                                    (let ((dts (+ offset (normalize-timestamp reader dts)))
                                          (pts (+ offset (normalize-timestamp reader pts))))
                                      (write-frame writer buffer dts pts duration flags)
                                      (when (= (modulo count 100) 0)
                                        (format :terminal "."))
                                      (loop dts duration (+ count 1))))
                                (set! offset (+ last-dts last-duration))
                                (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time)))))))))
                    files))))
    (format :terminal "done ({a}){%}" (present-seconds (- (current-seconds) start-time)))))


;;;
;;;; Convert
;;;


(definition protected (convert-streams dir (what: what #f) (dry?: dry? #f))
  (iterate-directory dir
    (lambda (file)
      (let ((extension (get-extension file)))
        (define (audio-extension?)
          (member? extension '("streamaudio")))
        
        (define (video-extension?)
          (member? extension '("streamvideo0"
                               "streamvideo1"
                               "streamvideo2"
                               "streamvideo3"
                               "streamvideo4")))
        
        (when (case what
                ((audio) (audio-extension?))
                ((video) (video-extension?))
                (else (or (audio-extension?)
                          (video-extension?))))
          (convert-stream file dry?: dry?))))
    files?: #t
    directories?: #f
    recursive?: #t))


(definition protected (convert-stream file (dry?: dry? #f))
  (declare (proper-tail-calls))
  (let ((name (get-name file))
        (base (get-base file))
        (extension (get-extension file)))
    (define (convert-to temp-file)
      (let ((start-time (current-seconds)))
        (let ((reader (new Stream-Reader file)))
          (let ((writer (new Stream-Writer temp-file (get-kind reader) (get-level reader) (get-resolution reader) (get-framerate reader) (get-bitrate reader) (get-codec reader) caps: (get-caps reader))))
            (format :terminal "{a}" name)
            (let (loop (count 0))
              (let ((frame (read-frame reader)))
                (if frame
                    (receive (buffer dts pts duration flags) frame
                      (write-frame writer buffer dts pts duration flags)
                      (when (= (modulo count 100) 0)
                        (format :terminal "."))
                      (loop (+ count 1)))
                  (close reader)
                  (close writer)
                  (format :terminal "({a}){%}" (present-seconds (- (current-seconds) start-time))))))))))
    
    (if dry?
        (terminal name)
      (let ((temp-extension (string-append "temp" extension)))
        (let ((temp-file (new-brother file (add-extension base temp-extension))))
          (convert-to temp-file)
          (delete file)
          (rename temp-file file))))))


;;;
;;;; Record
;;;


(definition pad-recording?
  #f)

(definition pad-monitors
  #f)


(definition protected (record-start pads)
  (let ((dir {Directory Settings "work" "records"})
        (pipeline (get-pipeline (cache-audio))))
    (define (parse-info info proc)
      (cond ((string? info)
             (proc info 'file))
            ((pair? info)
             (proc (first info) (second info)))))
    
    (define (parse-bin info)
      (let ((parts (split info "%")))
        (if (> (length parts) 1)
            parts
          (list #f info))))
    
    (define (find-bin bin-name)
      (if (not bin-name)
          pipeline
        (if (equal? bin-name "microphone")
            (get-pipeline (get-src (get-pipeline (get-microphone-channel (current-client)))))
          (let ((sink (let ((sinks (get-ordered-outputs (current-audio))))
                        (if (empty-string? bin-name)
                            (car sinks)
                          (find-if (lambda (sink)
                                     (search (gst_object_get_name (get-bin sink)) bin-name ignore-case?: #t))
                                   sinks)))))
            (get-bin sink)))))
    
    (define (monitor info)
      (parse-info info
        (lambda (info what)
          (bind (bin-name pad-info) (parse-bin info)
            (let ((bin (find-bin bin-name)))
              (define (monitor-file)
                (let ((file #f))
                  (define (filename pad)
                    (let ((info (rawaudio-pad-info pad)))
                      (let ((extension (rawaudio-extension info)))
                        (set! file (new-file dir (format "{a}.{a}" info extension)))
                        (path-normalize (parse file)))))
                  
                  (let ((monitored (gst_monitor bin pad-info 'file filename)))
                    (cons 'file (list monitored file)))))
              
              (define (monitor-analyse)
                (let ((listener (open-stream-listener)))
                  (let ((monitored (gst_monitor bin pad-info 'analyse (get-write-file listener)))
                        (thread (new-thread
                                  (lambda ()
                                    (declare (proper-tail-calls))
                                    (let ((discont 0)
                                          (gap 0)
                                          (expected 0)
                                          (silence 0))
                                      (let (loop)
                                        (case (wait listener)
                                          ((#\d)
                                           (increase! discont)
                                           (format :terminal "{a} : discont -> {a}{%}" pad-info discont)
                                           (loop))
                                          ((#\g)
                                           (increase! gap)
                                           (format :terminal "{a} : gap -> {a}{%}" pad-info gap)
                                           (loop))
                                          ((#\e)
                                           (increase! expected)
                                           (format :terminal "{a} : expected -> {a}{%}" pad-info expected)
                                           (loop))
                                          ((#\s)
                                           (increase! silence)
                                           (format :terminal "{a} : silence -> {a}{%}" pad-info silence)
                                           (loop))))))
                                  'monitor)))
                    (thread-base-priority-set! thread background-priority)
                    (thread-start! thread)
                    (cons 'analyse (list monitored listener thread)))))
              
              (define (monitor-other)
                (let ((monitored (gst_monitor bin pad-info what pipeline)))
                  (cons what monitored)))
              
              (case what
                ((file)
                 (monitor-file))
                ((analyse)
                 (monitor-analyse))
                (else
                 (monitor-other))))))))
      
    (when (not pad-recording?)
      (create-directories dir)
      (set! pad-monitors (map monitor pads))
      (set! pad-recording? #t))))


(definition protected (record-done)
  (define (unmonitor info)
    (define (unmonitor-file rest)
      (bind (monitored file) rest
        (gst_unmonitor monitored)))
    
    (define (unmonitor-analyse rest)
      (bind (monitored listener thread) rest
        (exit-thread thread)
        (close-stream-listener listener)
        (gst_unmonitor monitored)))
    
    (define (unmonitor-other monitored)
      (gst_unmonitor monitored))
    
    (bind (what . rest) info
      (case what
        ((file)
         (unmonitor-file rest))
        ((analyse)
         (unmonitor-analyse rest))
        (else
         (unmonitor-other rest)))))
  
  (when pad-recording?
    (for-each unmonitor pad-monitors)
    (set! pad-recording? #f)))


(definition protected (recorded-files)
  (and pad-monitors (collect (lambda (info)
                               (bind (what . rest) info
                                 (and (eq? what 'file)
                                      (bind (monitored file) rest
                                        file))))
                             pad-monitors))))
