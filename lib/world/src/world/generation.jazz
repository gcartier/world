;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Generation
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Edouard Hebert


(module world.generation jazz


(import (jazz.action)
        (jazz.application)
        (jazz.cairo)
        (jazz.debuggee)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.json)
        (jazz.opengl.glew)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (profiler)
        (world)
        (world.album)
        (world.area)
        (world.atlas)
        (world.audio)
        (world.autoload)
        (world.block)
        (world.chunk)
        (world.configure)
        (world.creature)
        (world.draw)
        (world.dye)
        (world.entity)
        (world.face)
        (world.foreign)
        (world.generate)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.info)
        (world.interface.inventory)
        (world.light-syntax)
        (world.lighting)
        (world.material)
        (world.mesh)
        (world.model)
        (world.models)
        (world.polygon)
        (world.profiling)
        (world.quad)
        (world.quad-texture)
        (world.region)
        (world.render)
        (world.renderers)
        (world.section)
        (world.sector)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.tag)
        (world.task)
        (world.template)
        (world.texture)
        (world.triangle))


;; LEXICON
;; - index: sector-local i j k coordinates
;; - location: integer vector representing a block in the block entities format
;; - position: block center position


;; WARNING
;; - the temporary hack of duplicating non thread-safe geometry functions
;;   like horizon-lookat&^ is super dangerous and should be improved upon


(proclaim (warn optimizations))


(definition protected aa 0) ;; 10421010
(definition protected oo 0) ;; 12248627
(definition protected gg 0) ;; 745240
(definition protected ww 0) ;; 697473
(definition protected cc 0) ;; 54050


;;;
;;;; Atlas
;;;


(definition (cache-atlas) <Atlas>
  (let ((world (current-world)))
    (get-block-atlas~ world)))


(definition (cache-texture) <Image-Texture>
  (let ((world (current-world)))
    (get-block-texture~ world)))


(definition (cache-texture-repeat) <Image-Texture>
  (let ((world (current-world)))
    (get-block-texture-repeat~ world)))


(definition protected (create-block-atlas) <Atlas>
  (define (find-assets)
    (let ((world (current-world)))
      (find-if (lambda (assets)
                 (and (eq? (get-where~ assets) 'world)
                      (equal? (get-spine~ assets) '("minecraft"))))
               (get-world-assets~ world))))
  
  (let ((atlas (new Atlas))
        (assets (find-assets))
        (path (list "textures" texture-dir)))
    (add-assets-directory~ atlas assets path)
    (generate-textures atlas assets path)
    atlas))


(definition protected (create-texture atlas (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f)) <Image-Texture>
  (let ((mipmap? (world-setting 'world.generate-mipmap? 32))
        (min-filter (world-setting 'world.min-filter (or min-filter 'nearest)))
        (mag-filter (world-setting 'world.mag-filter (or mag-filter 'linear))))
    (let ((effective-mipmap? (if (integer? mipmap?) (>= tile-resolution (cast <fx> mipmap?)) mipmap?)))
      (let ((min-filter (if (not effective-mipmap?)
                            (case min-filter
                              ((nearest) GL_NEAREST)
                              ((linear) GL_LINEAR))
                          (case min-filter
                            ((nearest) GL_NEAREST_MIPMAP_LINEAR)
                            ((linear) GL_LINEAR_MIPMAP_LINEAR))))
            (mag-filter (case mag-filter
                          ((nearest) GL_NEAREST)
                          ((linear) GL_LINEAR))))
        (extract-texture~ atlas min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: effective-mipmap? warn-non-uniform?: (programmer-role?))))))


;;;
;;;; Textures
;;;


(definition textures-subuvs
  '())

(definition (add-textures-subuv name subuv)
  (set! textures-subuvs (cons (cons name subuv) textures-subuvs)))

(definition protected (update-textures-subuvs atlas)
  (for-each (lambda (info)
              (bind (name . subuv) info
                (update-coordinates~ atlas name subuv)))
            textures-subuvs)
  (set! textures-subuvs '()))


(definition (generate-textures atlas assets path)
  (let ((dir (make-directory~ assets (append path '("blocks")))))
    (define (add-colored base suffix color (overlay #f))
      (let ((gray (new-file~ dir (add-extension (or overlay base) "png")))
            (overlaid (and overlay (new-file~ dir (add-extension base "png"))))
            (name (format "{a}_{a}" base suffix)))
        (assert (exists?~ gray))
        (apply-operator CAIRO_OPERATOR_MULTIPLY gray color
          (lambda (surface width height)
            (if (not overlay)
                (add-surface~ atlas name surface width height)
              (bind-values (width height overlaid) (cairo-surface-from-png overlaid)
                (let ((overlaid (new Surface overlaid)))
                  (blit-surface~ overlaid surface)
                  (close~ surface)
                  (add-surface~ atlas name overlaid width height))))))))

    (define (apply-operator operator gray color proc)
      (bind-values (width height msk) (cairo-surface-from-png gray)
        (bind-values (width height dst) (cairo-surface-from-png gray)
          (let ((size (new Dimension width height))
                (mask (new Surface msk))
                (dest (new Surface dst)))
            (set-operator~ dest operator)
            (set-color~ dest color)
            (draw-rectangle~ dest (size-rect size))
            (set-mask-surface~ dest mask)
            (close~ mask)
            (proc dest width height)))))
    
    (define (redstone-dust base)
      (let ((off .35)
            (on 1.))
        (loop (for n from 0 to 15)
              (add-colored base (->string n) (new Color red: (+ off (* (- on off) (/ (cast <fl> n) 15.))))))))
    
    (define (mirror-pad name left top right bottom (save-to #f))
      (bind (surface width height depth) (get-image~ atlas name)
        (let ((cairo-surface
                (when (u8vector? surface)
                  (let ((cairo-format CAIRO_FORMAT_ARGB32))
                    (let ((stride (cairo_format_stride_for_width cairo-format width)))
                      (new Surface (cairo_image_surface_create_for_data (still-u8vector-body surface) CAIRO_FORMAT_ARGB32 width height stride)))))))
          (let ((surface (or cairo-surface surface))
                (l (* left width))
                (t (* top height))
                (r (* right width))
                (b (* bottom height)))
            (let ((w (- r l))
                  (h (- b t)))
              (let ((subimage (new Image-Surface surface (new Dimension (fxround w) (fxround h))))
                    (pattern (cairo_pattern_create_for_surface (get-handle~ surface))))
                (let ((surface (if (not save-to) surface (new Image-Surface surface (new Dimension width height)))))
                  (let ((cr (get-context~ subimage))
                        (matrix (cairo_matrix_t-make)))
                    (cairo_set_source cr pattern)
                    (cairo_matrix_init_translate matrix l t)
                    (cairo_pattern_set_matrix pattern matrix)
                    (cairo_rectangle cr 0. 0. (fl w) (fl h))
                    (cairo_fill cr)
                    (cairo_matrix_t-free matrix)
                    (cairo_pattern_destroy pattern)
                    (loop (for i from -1 to 1)
                          (loop (for j from -1 to 1)
                                (let ((sx (if (= i 0) 1 -1))
                                      (sy (if (= j 0) 1 -1)))
                                  (let ((l (if (= sx 1) l (+ l w)))
                                        (t (if (= sy 1) t (+ t h))))
                                    (let ((tx (+ l (* i w)))
                                          (ty (+ t (* j h))))
                                      (cairo_identity_matrix (get-context~ surface))
                                      (translate~ surface tx ty)
                                      (scale~ surface sx sy)
                                      (blit-surface~ surface subimage))))))
                    (close~ subimage)
                    (when cairo-surface
                      (close~ cairo-surface))
                    (if (not save-to)
                        (add-textures-subuv name (uv left top right bottom (cast <fl> depth)))
                      (add-surface~ atlas save-to surface width height)
                      (bind (surface width height depth) (get-image~ atlas save-to)
                        (add-textures-subuv save-to (uv left top right bottom (cast <fl> depth)))))))))))))
    
    (add-colored "tallgrass" "green" {Color red: .403 green: .577 blue: .336})
    (add-colored "leaves_birch" "green" {Color red: .403 green: .577 blue: .336})
    (add-colored "leaves_big_oak" "green" {Color red: .275 green: .435 blue: .157})
    (add-colored "leaves_acacia" "green" {Color red: .275 green: .435 blue: .157})
    (add-colored "double_plant_grass_top" "green" {Color red: .329 green: .482 blue: .153})
    (add-colored "double_plant_grass_bottom" "green" {Color red: .329 green: .482 blue: .153})
    (add-colored "melon_stem_disconnected" "ochre" {Color red: .747 green: .563 blue: .004})
    (add-colored "pumpkin_stem_disconnected" "ochre" {Color red: .747 green: .563 blue: .004})
    (add-colored "vine" "green" {Color red: .160 green: .619 blue: .160})
    (add-colored "waterlily" "green" {Color red: .003 green: .619 blue: .003})
    (add-colored "grass_top" "green" {Color red: .403 green: .577 blue: .336})
    (add-colored "grass_side" "green" {Color red: .403 green: .577 blue: .336} "grass_side_overlay")
    
    (redstone-dust "redstone_dust_cross")
    (redstone-dust "redstone_dust_line")
    
    (mirror-pad "cake_side"             1m 8m 15m 16m)
    (mirror-pad "cake_top"              1m 1m 15m 15m)
    (mirror-pad "cake_bottom"           1m 1m 15m 15m)
    (mirror-pad "chest_side"            1m 2m 15m 16m)
    (mirror-pad "chest_front"           1m 2m 15m 16m)
    (mirror-pad "chest_back"            1m 2m 15m 16m)
    (mirror-pad "chest_bottom"          1m 1m 15m 15m)
    (mirror-pad "chest_top"             1m 1m 15m 15m)
    (mirror-pad "bed_head_side"         0m 7m 16m 16m)
    (mirror-pad "bed_head_end"          0m 7m 16m 16m)
    (mirror-pad "bed_feet_side"         0m 7m 16m 16m)
    (mirror-pad "bed_feet_end"          0m 7m 16m 16m)
    (mirror-pad "enchanting_table_side" 0m 4m 16m 16m)
    (mirror-pad "endframe_side"         0m 3m 16m 16m)
    (mirror-pad "endframe_eye"          4m 0m 12m 4m "endframe_eye_side")
    (mirror-pad "endframe_eye"          4m 4m 12m 12m)))


;;;
;;;; Face
;;;


(class Lighted-Face extends Face
  
  
  (method protected virtual (iterate-lighting proc)
    ))


(class Triangle-Face extends Lighted-Face
  
  
  (slot l1 accessors generate)
  (slot l2 accessors generate)
  (slot l3 accessors generate)
  
  
  (method override (initialize material texture-coordinates <f32vector> texture-depth triangle <Triangle> l1 <f32vector> l2 <f32vector> l3 <f32vector>)
    (nextmethod material texture-coordinates texture-depth triangle)
    (set! l1~self l1)
    (set! l2~self l2)
    (set! l3~self l3))
  
  
  (method override (iterate-lighting proc)
    (proc l1 l2 l3)))


(class Quad-Face extends Lighted-Face
  
  
  (slot l1 accessors generate)
  (slot l2 accessors generate)
  (slot l3 accessors generate)
  (slot l4 accessors generate)
  
  
  (method override (initialize material texture-coordinates <f32vector> texture-depth quad <Quad> l1 <f32vector> l2 <f32vector> l3 <f32vector> l4 <f32vector>)
    (nextmethod material texture-coordinates texture-depth quad)
    (set! l1~self l1)
    (set! l2~self l2)
    (set! l3~self l3)
    (set! l4~self l4))
  
  
  (method override (iterate-lighting proc)
    (proc l1 l2 l3)
    (proc l3 l4 l1)))


;;;
;;;; Mesher
;;;


(class Lighted-Mesher extends Mesher
  
  
  (method (add-lighting template l1 l2 l3 l4 inverse?)
    (iterate-lighting~ template self l1 l2 l3 l4 inverse?
      ;; lambda-lift
      (lambda (mesher <Lighted-Mesher> l1 l2 l3)
        (let ((lightmap (get-lightmap~ mesher)))
          (define (blocklight! offset <fx> lighting <f32vector>) <void>
            (f32vector-set! lightmap offset (f32vector-ref lighting 0)))
          
          (define (skylight! offset <fx> lighting <f32vector>) <void>
            (f32vector-set! lightmap offset (f32vector-ref lighting 1)))
          
          (define (ambience! offset <fx> lighting <f32vector>) <void>
            (f32vector-set! lightmap offset (/ (f32vector-ref lighting 2) 4.)))
          
          (let ((li (get-li~ mesher)))
            (blocklight!    li    l1)
            (skylight!   (+ li 1) l1)
            (ambience!   (+ li 2) l1)
            (blocklight! (+ li 3) l2)
            (skylight!   (+ li 4) l2)
            (ambience!   (+ li 5) l2)
            (blocklight! (+ li 6) l3)
            (skylight!   (+ li 7) l3)
            (ambience!   (+ li 8) l3)
            (increase-li!~ mesher 9)))))))


;;;
;;;; Rendering
;;;


(class Rendering extends Object
  
  
  (slot material <Material> getter generate)
  (slot mesher   <Mesher>   getter generate)
  
  
  (method override (initialize initial-reserved material)
    (set! material~self material)
    (set! mesher~self (new Lighted-Mesher initial-reserved 0 material: material)))
  
  
  (method (reset-mesher)
    (reset~ mesher)))


(definition package opaque-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Rendering 8192 (new Material name: 'opaque atlas: atlas texture: texture renderer: (get-opaque-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package transparent-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Rendering 20480 (new Material name: 'transparent atlas: atlas texture: texture renderer: (get-transparent-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package coverage-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Rendering 2048 (new Material name: 'coverage atlas: atlas texture: texture renderer: (get-coverage-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package water-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture-repeat)))
            (let ((rend (new Rendering 2048 (new Material name: 'water atlas: atlas texture: texture renderer: (get-water-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package wet-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture)))
            (let ((rend (new Rendering 2048 (new Material name: 'wet atlas: atlas texture: texture renderer: (get-wet-renderer)))))
              (set! rendering rend)
              rend))))))


(definition package multitexture-rendering
  (let ((rendering #f))
    (lambda ()
      (or rendering
          (let ((atlas (cache-atlas))
                (texture (cache-texture-repeat)))
            (let ((rend (new Rendering 2048 (new Material name: 'multitexture atlas: atlas texture: texture renderer: (get-multitexture-renderer)))))
              (set! rendering rend)
              rend))))))


(class Block-Category extends Object
  
  
  (slot name    getter generate)
  (slot rank    getter generate)
  (slot texture getter generate)
  
  
  (method override (initialize name rank texture)
    (set! name~self name)
    (set! rank~self rank)
    (set! texture~self texture)))


(definition package block-categories
  (make-table test: eq?))

(definition (register-block-category name (rank: rank #f) (texture: texture #f))
  (let ((category (new Block-Category name rank texture)))
    (table-set! block-categories name category)
    category))


(definition public (name->block-category name)
  (table-ref block-categories name))


(define-block-category building       rank:  0 texture: 405)
(define-block-category decoration     rank:  1 texture: 338)
(define-block-category redstone       rank:  2 texture: 331)
(define-block-category invalid        rank:  2 texture: 377)
(define-block-category waiting        rank:  4 texture: 289)
(define-block-category sloped         rank:  9 texture: 265)


(class Block-Kind extends Object
  
  
  (slot name getter generate)
  (slot rank getter generate)
  
  
  (method override (initialize name rank)
    (set! name~self name)
    (set! rank~self rank)))


(definition package block-kinds
  (make-table test: eq?))

(definition (register-block-kind name (rank: rank #f))
  (let ((kind (new Block-Kind name rank)))
    (table-set! block-kinds name kind)
    kind))


(definition public (name->block-kind name)
  (table-ref block-kinds name))


;; building
(define-block-kind cube           rank: 0)
(define-block-kind slab           rank: 1)
(define-block-kind stairs         rank: 2)
(define-block-kind glass          rank: 3)
(define-block-kind snow           rank: 4)
(define-block-kind ice            rank: 5)
(define-block-kind ore            rank: 6)

;; decoration
(define-block-kind torch          rank: 0)
(define-block-kind fire           rank: 1)
(define-block-kind web            rank: 2)
(define-block-kind vegetation     rank: 3)
(define-block-kind leaves         rank: 4)
(define-block-kind veggieblock    rank: 5)
(define-block-kind liquid         rank: 6)
(define-block-kind signs          rank: 7)
(define-block-kind fence          rank: 8)
(define-block-kind bars           rank: 9)
(define-block-kind ladder         rank: 10)
(define-block-kind transportation rank: 11)
(define-block-kind portal         rank: 12)
(define-block-kind cake           rank: 13)

;; redstone
(define-block-kind power          rank: 0)
(define-block-kind redstonetorch  rank: 1)
(define-block-kind transmission   rank: 2)
(define-block-kind mechanism      rank: 3)


(definition package category-renderings
  (make-table test: eq?))

(definition (get-category-rendering category)
  (let ((name (get-name~ category)))
    (or (table-ref category-renderings name #f)
        (let ((atlas (cache-atlas))
              (texture (cache-texture)))
          (let ((rend (new Rendering 20480 (new Material name: name atlas: atlas texture: texture renderer: (get-transparent-renderer)))))
            (table-set! category-renderings name rend)
            rend)))))

(definition (reset-category-renderings)
  (iterate-table category-renderings
    (lambda (category rendering)
      (reset-mesher~ rendering))))


(definition package (dr)
  (define (d rendering <Rendering>)
    (let ((mesher (get-mesher~ rendering)))
      (list (get-growths~ mesher) (get-reserved~ mesher))))

  (debug (d (opaque-rendering))
         (d (transparent-rendering))
         (d (coverage-rendering))
         (d (water-rendering))
         (d (wet-rendering))
         (d (multitexture-rendering))))


;;;
;;;; Block
;;;


(class Block extends Object
  
  
  (slot name                                        getter generate)
  (slot id                  <fx>                    getter generate)
  (slot subid                                       getter generate)
  (slot category                                    getter generate)
  (slot kind                                        getter generate)
  (slot image                                       getter generate)
  (slot texture                                     getter generate)
  (slot texture-coordinates                         accessors generate)
  (slot rendering                                   getter generate)
  (slot rendering-cache                             getter generate)
  (slot opaque-cube?        <bool>                  getter generate)
  (slot water-cube?         <bool>                  getter generate)
  (slot physical?           <bool>                  getter generate)
  (slot cube?               <bool>                  accessors generate)
  (slot brightness                                  getter generate)
  (slot configurations                              getter generate)
  (slot generate                                    getter generate)
  (slot visual                                      getter generate)
  (slot physical                                    getter generate)
  (slot right-mouse                                 getter generate)
  (slot visuals             <vector+> initialize #f accessors generate)
  (slot physicals           <vector+> initialize #f accessors generate)
  
  
  (method override (initialize name id subid category kind image texture rendering opaque-cube? water-cube? physical? cube? brightness configurations generate visual physical right-mouse)
    (set! name~self name)
    (set! id~self id)
    (set! subid~self subid)
    (set! category~self category)
    (set! kind~self kind)
    (set! image~self image)
    (set! texture~self texture)
    (set! texture-coordinates~self #f)
    (set! rendering~self (or rendering opaque-rendering))
    (set! rendering-cache~self #f)
    (set! opaque-cube?~self opaque-cube?)
    (set! water-cube?~self water-cube?)
    (set! physical?~self physical?)
    (set! cube?~self cube?)
    (set! brightness~self brightness)
    (set! configurations~self configurations)
    (set! generate~self generate)
    (set! visual~self visual)
    (set! physical~self physical)
    (set! right-mouse~self right-mouse))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method (cache-rendering)
    (or rendering-cache
        (let ((rend (rendering)))
          (set! rendering-cache rend)
          rend))))


(definition protected blocks <table>
  (make-table test: eq?))

(definition protected blockids <vector>
  (make-vector 256 #f))


(definition (register-block name id (category: category #f) (kind: kind #f) (image: image #f) (texture: texture #f) (rendering: rendering #f) (opaque-cube?: opaque-cube? #t) (water-cube?: water-cube? #f) (physical?: physical? #t) (cube?: cube? #t) (brightness: brightness #f) (configurations: configurations 16) (generate: generate #f) (visual: visual #f) (physical: physical #f) (right-mouse: right-mouse #f))
  (let ((id <fx> (if (pair? id) (car id) id))
        (subid (if (pair? id) (cadr id) #f)))
    (when (not subid)
      (let ((block (new Block name id subid category kind image texture rendering opaque-cube? water-cube? physical? cube? brightness configurations generate visual physical right-mouse)))
        (table-set! blocks name block)
        (vector-set! blockids id block)
        (unspecified)))))


(definition public (name->block name) <Block>
  (table-ref blocks name))

(definition public inline (id->block id <fx>) <Block>
  (vector-ref blockids id))

(definition public inline (liquid-filter poly) <bool>
  (not (get-water-cube?~ (id->block (fxround (get-data1~ poly))))))

(definition protected tile-resolution <fx>
  (world-setting 'world.tile-resolution 128))

(definition protected tile-size <fl>
  (cast <fl> tile-resolution))

(definition protected tile-period <fx>
  16)

(definition protected texture-size <fl>
  (* tile-size (cast <fl> tile-period)))

(definition protected texture-dir
  (format "{a}x{a}" tile-resolution tile-resolution))

(definition protected texture-mipmap?
  #f)


(definition protected (block-texture-coordinates block <Block>)
  (or (get-texture-coordinates~ block)
      (let ((texture (get-texture~ block)))
        (let ((coords (and texture (image-rect~ (cache-atlas) texture))))
          (set-texture-coordinates~ block coords)
          coords))))


(definition coordinates-mutex
  (make-mutex 'coordinates))

(definition coordinates <table>
  (make-table test: equal?))

(definition (get-coordinates name <string>) <f32vector>
  (mutex-lock! coordinates-mutex)
  (prog1 (or (table-ref coordinates name #f)
             (let ((coords (image-rect~ (cache-atlas) name)))
               (table-set! coordinates name coords)
               coords))
    (mutex-unlock! coordinates-mutex)))


;;;
;;;; Blocks
;;;


(constant inline block-radius <fl>
  .5)


(constant inline air-id <fx>
  0)


(constant inline mixel
  .0625)

(constant inline  0m 0.)
(constant inline  1m .0625)
(constant inline  2m .125)
(constant inline  3m .1875)
(constant inline  4m .25)
(constant inline  5m .3125)
(constant inline  6m .375)
(constant inline  7m .4375)
(constant inline  8m .5)
(constant inline  9m .5625)
(constant inline 10m .625)
(constant inline 11m .6875)
(constant inline 12m .75)
(constant inline 13m .8125)
(constant inline 14m .875)
(constant inline 15m .9375)
(constant inline 16m 1.)


(define-block Air
  0
  opaque-cube?: #f
  cube?: #f)


(define-block Stone
  1
  category: building
  kind: cube
  texture: "stone")


(define-block Grass
  2
  category: building
  kind: cube
  texture: "grass_side"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              ;; this is so much nicer than the grass in the texture pack
              (let ((side (get-coordinates "grass_side"))
                    (top (get-coordinates "wool_colored_green"))
                    (bottom (get-coordinates "dirt")))
                (add-opaque-cube what i j k x y z side side bottom top side side lighting rendering category block-id add-face))))


(define-block Dirt
  3
  category: building
  kind: cube
  texture: "dirt")


(define-block Cobblestone
  4
  category: building
  kind: cube
  texture: "cobblestone")


(define-block WoodenPlank
  5
  category: building
  kind: cube
  texture: "planks_oak")


(definition Sapling-Textures <vector>
  #("sapling_oak"
    "sapling_spruce"
    "sapling_birch"
    "sapling_jungle"))


(define-block Sapling
  6
  category: decoration
  kind: vegetation
  texture: "sapling_jungle"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Sapling-Textures (bitwise-and data-id #b11)))))
                (add-cross-faces what i j k x y z uv lighting rendering category block-id add-face))))

(define-block RedwoodSapling
  (6 1))

(define-block BirchSapling
  (6 2))


(define-block Bedrock
  7
  category: building
  kind: cube
  texture: "bedrock")


(definition (liquid-side-heights i j k block-ref data-ref blocks)
  (define (side-data side-i side-k)
    (data-ref (+ i side-i) j (+ k side-k)))
  
  (define (data->height data)
    (if (< data 8)
        (- (* 2m (- 8 data)) 1m)
      16m))
  
  (define (corner-height side-i side-k data)
    (if (= data 0)
        7m
      (let ((block1 (block-ref (+ i side-i) j k))
            (block2 (block-ref i j (+ k side-k)))
            (block3 (block-ref (+ i side-i) j (+ k side-k)))
            (data1 (side-data side-i 0))
            (data2 (side-data 0 side-k))
            (data3 (side-data side-i side-k)))
        (let ((height1 (if (memq? block1 blocks)
                           (if (or (< data1 data) (> data1 7))
                               (data->height data1)
                             (data->height data))
                         1m))
              (height2 (if (memq? block2 blocks)
                           (if (or (< data2 data) (> data2 7))
                               (data->height data2)
                             (data->height data))
                         1m))
              (height3 (if (memq? block3 blocks)
                           (if (or (< data3 data) (> data3 7))
                               (data->height data3)
                             (data->height data))
                         1m)))
          (+ (- block-radius) (max height1 height2 height3))))))
  
  (f64vector 8m 8m 8m 8m)
  @cosmetic-hack-until-liquid-fixed
  (let ((data (data-ref i j k)))
    (if (> data 7)
        (f64vector 8m 8m 8m 8m)
      (let ((left-back   (corner-height -1 -1 data))
            (left-front  (corner-height -1  1 data))
            (right-front (corner-height  1  1 data))
            (right-back  (corner-height  1 -1 data)))
        (f64vector left-back left-front right-front right-back)))))


(definition (water-side-heights i j k block-ref data-ref)
  (liquid-side-heights i j k block-ref data-ref '(8 9)))


(definition (lava-side-heights i j k block-ref data-ref)
  (liquid-side-heights i j k block-ref data-ref '(10 11)))


(define-block Water
  8
  category: decoration
  kind: liquid
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  rendering: water-rendering
  texture: "water"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (water-side-heights i j k block-ref data-ref))
                    (left (- block-radius))
                    (right block-radius)
                    (bottom (if (memq? (block-ref i (- j 1) k) '(8 9)) (- (- block-radius) 1m) (- block-radius)))
                    (back (- block-radius))
                    (front block-radius))
                (when (not (or (and (get-cube?~ (id->block (block-ref (- i 1) j k))) (not (memq? (block-ref (- i 1) j k) '(20)))) (memq? (block-ref (- i 1) j k) '(8 9))))
                  (add-face (left-generic-quad what i j k x y z left right bottom (f64vector (first top) (second top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref (+ i 1) j k))) (not (memq? (block-ref (+ i 1) j k) '(20)))) (memq? (block-ref (+ i 1) j k) '(8 9))))
                  (add-face (right-generic-quad what i j k x y z left right bottom (f64vector (third top) (fourth top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref i (- j 1) k))) (not (memq? (block-ref i (- j 1) k) '(20)))) (memq? (block-ref i (- j 1) k) '(8 9))))
                  (add-face (bottom-generic what i j k x y z left right bottom (first top) back front uv generic-coordinates lighting rendering block-id (make-identity-matrix)) rendering category))
                (unless (memq? (block-ref i (+ j 1) k) '(8 9 20))
                  (let ((face (top-sloped what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))
                    (add-face (car face) rendering category)
                    (when (not (equal? (first face) (last face)))
                      (add-face (last face) rendering category))))
                (when (not (or (and (get-cube?~ (id->block (block-ref i j (- k 1)))) (not (memq? (block-ref i j (- k 1)) '(20)))) (memq? (block-ref i j (- k 1)) '(8 9))))
                  (add-face (back-generic-quad what i j k x y z left right bottom (f64vector (fourth top) (first top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref i j (+ k 1)))) (not (memq? (block-ref i j (+ k 1)) '(20)))) (memq? (block-ref i j (+ k 1)) '(8 9))))
                  (add-face (front-generic-quad what i j k x y z left right bottom (f64vector (second top) (third top)) back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-block StationaryWater
  9
  category: decoration
  kind: liquid
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  rendering: water-rendering
  texture: "water"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (water-side-heights i j k block-ref data-ref))
                    (left (- block-radius))
                    (right block-radius)
                    (bottom (if (memq? (block-ref i (- j 1) k) '(8 9)) (- (- block-radius) 1m) (- block-radius)))
                    (back (- block-radius))
                    (front block-radius))
                (when (not (or (and (get-cube?~ (id->block (block-ref (- i 1) j k))) (not (memq? (block-ref (- i 1) j k) '(20)))) (memq? (block-ref (- i 1) j k) '(8 9))))
                  (add-face (left-generic-quad what i j k x y z left right bottom (f64vector (first top) (second top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref (+ i 1) j k))) (not (memq? (block-ref (+ i 1) j k) '(20)))) (memq? (block-ref (+ i 1) j k) '(8 9))))
                  (add-face (right-generic-quad what i j k x y z left right bottom (f64vector (third top) (fourth top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref i (- j 1) k))) (not (memq? (block-ref i (- j 1) k) '(20)))) (memq? (block-ref i (- j 1) k) '(8 9))))
                  (add-face (bottom-generic what i j k x y z left right bottom (first top) back front uv generic-coordinates lighting rendering block-id (make-identity-matrix)) rendering category))
                (unless (memq? (block-ref i (+ j 1) k) '(8 9 20))
                  (let ((face (top-sloped what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))
                    (add-face (car face) rendering category)
                    (when (not (equal? (first face) (last face)))
                      (add-face (last face) rendering category))))
                (when (not (or (and (get-cube?~ (id->block (block-ref i j (- k 1)))) (not (memq? (block-ref i j (- k 1)) '(20)))) (memq? (block-ref i j (- k 1)) '(8 9))))
                  (add-face (back-generic-quad what i j k x y z left right bottom (f64vector (fourth top) (first top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref i j (+ k 1)))) (not (memq? (block-ref i j (+ k 1)) '(20)))) (memq? (block-ref i j (+ k 1)) '(8 9))))
                  (add-face (front-generic-quad what i j k x y z left right bottom (f64vector (second top) (third top)) back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-block Lava
  10
  category: decoration
  kind: liquid
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  rendering: multitexture-rendering
  texture: "lava"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (lava-side-heights i j k block-ref data-ref))
                    (left (- block-radius))
                    (right block-radius)
                    (bottom (if (memq? (block-ref i (- j 1) k) '(10 11)) (- (- block-radius) 1m) (- block-radius)))
                    (back (- block-radius))
                    (front block-radius))
                (when (not (or (and (get-cube?~ (id->block (block-ref (- i 1) j k))) (not (memq? (block-ref (- i 1) j k) '(20)))) (memq? (block-ref (- i 1) j k) '(10 11))))
                  (add-face (left-generic-quad what i j k x y z left right bottom (f64vector (first top) (second top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref (+ i 1) j k))) (not (memq? (block-ref (+ i 1) j k) '(20)))) (memq? (block-ref (+ i 1) j k) '(10 11))))
                  (add-face (right-generic-quad what i j k x y z left right bottom (f64vector (third top) (fourth top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref i (- j 1) k))) (not (memq? (block-ref i (- j 1) k) '(20)))) (memq? (block-ref i (- j 1) k) '(10 11))))
                  (add-face (bottom-generic what i j k x y z left right bottom (first top) back front uv generic-coordinates lighting rendering block-id (make-identity-matrix)) rendering category))
                (unless (memq? (block-ref i (+ j 1) k) '(10 11 20))
                  (let ((face (top-sloped what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))
                    (add-face (car face) rendering category)
                    (when (not (equal? (first face) (last face)))
                      (add-face (last face) rendering category))))
                (when (not (or (and (get-cube?~ (id->block (block-ref i j (- k 1)))) (not (memq? (block-ref i j (- k 1)) '(20)))) (memq? (block-ref i j (- k 1)) '(10 11))))
                  (add-face (back-generic-quad what i j k x y z left right bottom (f64vector (fourth top) (first top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref i j (+ k 1)))) (not (memq? (block-ref i j (+ k 1)) '(20)))) (memq? (block-ref i j (+ k 1)) '(10 11))))
                  (add-face (front-generic-quad what i j k x y z left right bottom (f64vector (second top) (third top)) back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-block StationaryLava
  11
  category: decoration
  kind: liquid
  opaque-cube?: #f
  cube?: #f
  water-cube?: #t
  rendering: multitexture-rendering
  texture: "lava"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (lava-side-heights i j k block-ref data-ref))
                    (left (- block-radius))
                    (right block-radius)
                    (bottom (if (memq? (block-ref i (- j 1) k) '(10 11)) (- (- block-radius) 1m) (- block-radius)))
                    (back (- block-radius))
                    (front block-radius))
                (when (not (or (and (get-cube?~ (id->block (block-ref (- i 1) j k))) (not (memq? (block-ref (- i 1) j k) '(20)))) (memq? (block-ref (- i 1) j k) '(10 11))))
                  (add-face (left-generic-quad what i j k x y z left right bottom (f64vector (first top) (second top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref (+ i 1) j k))) (not (memq? (block-ref (+ i 1) j k) '(20)))) (memq? (block-ref (+ i 1) j k) '(10 11))))
                  (add-face (right-generic-quad what i j k x y z left right bottom (f64vector (third top) (fourth top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref i (- j 1) k))) (not (memq? (block-ref i (- j 1) k) '(20)))) (memq? (block-ref i (- j 1) k) '(10 11))))
                  (add-face (bottom-generic what i j k x y z left right bottom (first top) back front uv generic-coordinates lighting rendering block-id (make-identity-matrix)) rendering category))
                (unless (memq? (block-ref i (+ j 1) k) '(10 11 20))
                  (let ((face (top-sloped what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))
                    (add-face (car face) rendering category)
                    (when (not (equal? (first face) (last face)))
                      (add-face (last face) rendering category))))
                (when (not (or (and (get-cube?~ (id->block (block-ref i j (- k 1)))) (not (memq? (block-ref i j (- k 1)) '(20)))) (memq? (block-ref i j (- k 1)) '(10 11))))
                  (add-face (back-generic-quad what i j k x y z left right bottom (f64vector (fourth top) (first top)) back front uv generic-coordinates lighting rendering block-id) rendering category))
                (when (not (or (and (get-cube?~ (id->block (block-ref i j (+ k 1)))) (not (memq? (block-ref i j (+ k 1)) '(20)))) (memq? (block-ref i j (+ k 1)) '(10 11))))
                  (add-face (front-generic-quad what i j k x y z left right bottom (f64vector (second top) (third top)) back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-block Sand
  12
  category: building
  kind: cube
  texture: "sand")


(define-block Gravel
  13
  category: building
  kind: cube
  texture: "gravel")


(define-block GoldOre
  14
  category: building
  kind: ore
  texture: "gold_ore")


(define-block IronOre
  15
  category: building
  kind: ore
  texture: "iron_ore")


(define-block CoalOre
  16
  category: building
  kind: ore
  texture: "coal_ore")


(definition Wood-Textures <vector>
  #("log_oak"
    "log_spruce"
    "log_birch"
    "log_jungle"))

(definition WoodTop-Textures <vector>
  #("log_oak_top"
    "log_spruce"
    "log_birch"
    "log_jungle"))
  
(define-block Wood
  17
  category: building
  kind: cube
  texture: "log_oak"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              @w(let ((uv (get-coordinates (vector-ref Wood-Textures (bitwise-and data-id #b11))))
                      (uv-top (get-coordinates (vector-ref WoodTop-Textures (bitwise-and data-id #b11)))))
                  (add-opaque-cube what i j k x y z uv uv uv-top uv-top uv uv lighting rendering category block-id add-face))
              
              (let ((filename (string-append
                                (case (bitwise-and data-id #b11)
                                  ((0) "oak")
                                  ((1) "spruce")
                                  ((2) "birch")
                                  ((3) "jungle"))
                                "_log.json"))
                    (key (string-append
                           "axis="
                           (case (arithmetic-shift-right (bitwise-and data-id #b1100) 2)
                             ((0) "y")
                             ((1) "x")
                             ((2) "z")
                             ((3) "none")))))
                (with-block-state filename key
                  (lambda (model rotation-y rotation-x)
                    (add-json-model what model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref rotation-y rotation-x))))))

(define-block Redwood
  (17 1))

(define-block Birchwood
  (17 2))


(define-block Leaves
  18
  category: decoration
  kind: leaves
  image: "leaves_birch"
  texture: "leaves_birch_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-cube-faces what i j k x y z uv lighting rendering category block-id add-face)))

(define-block RedwoodLeaves
  (18 1))

(define-block BirchwoodLeaves
  (18 2))


(define-block Sponge
  19
  category: building
  kind: cube
  texture: "sponge")


(define-block Glass
  20
  category: building
  kind: glass
  texture: "glass"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-cube-faces what i j k x y z uv lighting rendering category block-id add-face)))


(define-block LapisOre
  21
  category: building
  kind: ore
  texture: "lapis_ore")


(define-block LapisBlock
  22
  category: building
  kind: cube
  texture: "lapis_block")


(define-block Dispenser
  23
  category: waiting ;; redstone
  texture: "dispenser_front_vertical"
  opaque-cube?: #f)


(define-block Sandstone
  24
  category: building
  kind: cube
  texture: "sandstone_top")


(define-block NoteBlock
  25
  category: waiting ;; redstone
  kind: mechanism
  texture: "noteblock"
  opaque-cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-cube-faces what i j k x y z uv lighting rendering category block-id add-face)))


(define-block BedBlock
  26
  category: decoration
  texture: "bed_feet_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case (bitwise-and data-id #b11)
                                                                     ((0) (vertex&  0. 0.  1.))
                                                                     ((1) (vertex& -1. 0.  0.))
                                                                     ((2) (vertex&  0. 0. -1.))
                                                                     ((3) (vertex&  1. 0.  0.))))))
                    (head? (bit-set? 3 data-id))
                    (left (- block-radius))
                    (right (+ block-radius))
                    (bottom (- block-radius))
                    (top 1m)
                    (back (- block-radius))
                    (front (+ block-radius))
                    (bedbottom (+ (- block-radius) 3m))
                    (bedtop (- 9m block-radius)))
                (if head?
                    (let ((uv-top (get-coordinates "bed_head_top"))
                          (uv-side (get-coordinates "bed_head_side"))
                          (uv-end (get-coordinates "bed_head_end"))
                          (uv-bottom (get-coordinates "planks_oak")))
                      (add-face (left-generic   what i j k x y z left right bottom top back front uv-side generic-coordinates lighting rendering block-id matrix) rendering category)
                      (add-face (right-generic  what i j k x y z left right bottom top back front uv-side transpose-coordinates lighting rendering block-id matrix) rendering category)
                      (add-face (bottom-generic what i j k x y z left right bedbottom top back front uv-bottom generic-coordinates lighting rendering block-id matrix) rendering category)
                      (add-face (top-generic    what i j k x y z left right bottom bedtop back front uv-top rotate-coordinates lighting rendering block-id matrix) rendering category)
                      (add-face (front-generic  what i j k x y z left right bottom top back front uv-end generic-coordinates lighting rendering block-id matrix) rendering category))
                  (let ((uv-top (get-coordinates "bed_feet_top"))
                        (uv-side (get-coordinates "bed_feet_side"))
                        (uv-end (get-coordinates "bed_feet_end"))
                        (uv-bottom (get-coordinates "planks_oak")))
                    (add-face (left-generic   what i j k x y z left right bottom top back front uv-side generic-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (right-generic  what i j k x y z left right bottom top back front uv-side transpose-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (bottom-generic what i j k x y z left right bedbottom top back front uv-bottom generic-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (top-generic    what i j k x y z left right bottom bedtop back front uv-top rotate-coordinates lighting rendering block-id matrix) rendering category)
                    (add-face (back-generic   what i j k x y z left right bottom top back front uv-end generic-coordinates lighting rendering block-id matrix) rendering category)))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (let ((world (current-world))
                       (zone (current-zone))
                       (me (current-me)))
                   ;; we cannot spawn on top of the bed because some beds have too low a ceiling over them
                   (let ((spawnpoint (copy-vertex (get-position~ me))))
                     (set-player-spawnpoint~ zone spawnpoint)
                     (save-level-nbt~ zone))
                   (when (or (> (get-daytime~ zone) 18500.) (< (get-daytime~ zone) 6000.))
                     (goto-daytime~ zone 6000.))
                   (display-message~ world "Bedpoint set!"))))


(define-block PoweredRail
  27
  category: waiting ;; decoration
  texture: "rail_activator"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-rail-gadget what data-id i j k x y z uv (get-coordinates "rail_activator_powered") lighting rendering category block-id add-face)))


(define-block DetectorRail
  28
  category: waiting ;; decoration
  texture: "rail_detector"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-rail-gadget what data-id i j k x y z uv (get-coordinates "rail_detector_powered") lighting rendering category block-id add-face)))


(define-block StickyPiston
  29
  category: redstone
  kind: mechanism
  texture: "piston_side"
  opaque-cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((matrix (case (bit-set data-id 3 #f)
                              ((0) (make-x-rotation-matrix PI))
                              ((1) (make-identity-matrix))
                              ((2) (make-x-rotation-matrix PI/2))
                              ((3) (make-x-rotation-matrix (- PI/2)))
                              ((4) (make-z-rotation-matrix (- PI/2)))
                              ((5) (make-z-rotation-matrix PI/2)))))
                (let ((left (- block-radius))
                      (right block-radius)
                      (bottom (- block-radius))
                      (top (if (bit-set? 3 data-id)
                               4m
                             block-radius))
                      (back (- block-radius))
                      (front block-radius)
                      (side-uv (if (bit-set? 3 data-id)
                                   (uv-rect uv 0. 4m 1. 1.)
                                 uv))
                      (top-uv (if (bit-set? 3 data-id)
                                  (get-coordinates "piston_inner")
                                (get-coordinates "piston_top_sticky")))
                      (bottom-uv (get-coordinates "piston_bottom")))
                  (add-face (left-generic   what i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (right-generic  what i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (bottom-generic what i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (top-generic    what i j k x y z left right bottom top back front top-uv    generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (back-generic   what i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (front-generic  what i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)))))


(define-block Web
  30
  category: decoration
  kind: web
  texture: "web"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-block TallGrass
  31
  category: decoration
  kind: vegetation
  image: "tallgrass"
  texture: "tallgrass_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-block DeadBush
  32
  category: decoration
  kind: vegetation
  texture: "deadbush"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-block Piston
  33
  category: redstone
  kind: mechanism
  texture: "piston_side"
  opaque-cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((matrix (case (bit-set data-id 3 #f)
                              ((0) (make-x-rotation-matrix PI))
                              ((1) (make-identity-matrix))
                              ((2) (make-x-rotation-matrix PI/2))
                              ((3) (make-x-rotation-matrix (- PI/2)))
                              ((4) (make-z-rotation-matrix (- PI/2)))
                              ((5) (make-z-rotation-matrix PI/2)))))
                (let ((left (- block-radius))
                      (right block-radius)
                      (bottom (- block-radius))
                      (top (if (bit-set? 3 data-id)
                               4m
                             block-radius))
                      (back (- block-radius))
                      (front block-radius)
                      (side-uv (if (bit-set? 3 data-id)
                                   (uv-rect uv 0. 4m 1. 1.)
                                 uv))
                      (top-uv (if (bit-set? 3 data-id)
                                  (get-coordinates "piston_inner")
                                (get-coordinates "piston_top_normal")))
                      (bottom-uv (get-coordinates "piston_bottom")))
                  (add-face (left-generic   what i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (right-generic  what i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (bottom-generic what i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (top-generic    what i j k x y z left right bottom top back front top-uv    generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (back-generic   what i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (front-generic  what i j k x y z left right bottom top back front side-uv   generic-coordinates lighting rendering block-id matrix) rendering category)))))


(define-block PistonHead
  34
  category: invalid
  texture: "piston_inner"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((matrix (case (bit-set data-id 3 #f)
                              ((0) (make-x-rotation-matrix PI))
                              ((1) (make-identity-matrix))
                              ((2) (make-x-rotation-matrix PI/2))
                              ((3) (make-x-rotation-matrix (- PI/2)))
                              ((4) (make-z-rotation-matrix (- PI/2)))
                              ((5) (make-z-rotation-matrix PI/2)))))
                (let ((left (- block-radius))
                      (right block-radius)
                      (bottom 4m)
                      (top block-radius)
                      (back (- block-radius))
                      (front block-radius)
                      (side-uv (uv-rect (get-coordinates "piston_side") 0. 0. 1. 4m))
                      (top-uv (if (bit-set? 3 data-id)
                                  (get-coordinates "piston_top_sticky")
                                (get-coordinates "piston_top_normal")))
                      (stick-top 4m)
                      (stick-bottom (- 12m))
                      (margin 2m))
                  (add-face (left-generic   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (right-generic  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (bottom-generic what i j k x y z left right bottom top back front uv      generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (top-generic    what i j k x y z left right bottom top back front top-uv  generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (back-generic   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (front-generic  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (left-generic   what i j k x y z (- margin) margin stick-bottom stick-top (- margin) margin side-uv rotate-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (right-generic  what i j k x y z (- margin) margin stick-bottom stick-top (- margin) margin side-uv rotate-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (back-generic   what i j k x y z (- margin) margin stick-bottom stick-top (- margin) margin side-uv rotate-coordinates lighting rendering block-id matrix) rendering category)
                  (add-face (front-generic  what i j k x y z (- margin) margin stick-bottom stick-top (- margin) margin side-uv rotate-coordinates lighting rendering block-id matrix) rendering category)))))


(definition Wool-Textures <vector>
  #("wool_colored_white"
    "wool_colored_orange"
    "wool_colored_magenta"
    "wool_colored_light_blue"
    "wool_colored_yellow"
    "wool_colored_lime"
    "wool_colored_pink"
    "wool_colored_gray"
    "wool_colored_silver"
    "wool_colored_cyan"
    "wool_colored_purple"
    "wool_colored_blue"
    "wool_colored_brown"
    "wool_colored_green"
    "wool_colored_red"
    "wool_colored_black"))

(define-block Wool
  35
  category: building
  kind: cube
  texture: "wool_colored_white"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wool-Textures data-id))))
                (add-opaque-cube what i j k x y z uv uv uv uv uv uv lighting rendering category block-id add-face))))


(define-block Dandelion
  37
  category: decoration
  kind: vegetation
  texture: "flower_dandelion"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-block Rose
  38
  category: decoration
  kind: vegetation
  texture: "flower_rose"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-block BrownMushroom
  39
  category: decoration
  kind: vegetation
  texture: "mushroom_brown"
  rendering: transparent-rendering
  physical?: #f
  cube?: #f
  opaque-cube?: #f)


(define-block RedMushroom
  40
  category: decoration
  kind: vegetation
  texture: "mushroom_red"
  rendering: transparent-rendering
  physical?: #f
  cube?: #f
  opaque-cube?: #f)


(define-block GoldBlock
  41
  category: building
  kind: cube
  texture: "gold_block")


(define-block IronBlock
  42
  category: building
  kind: cube
  texture: "iron_block")


(define-block DoubleStoneSlab
  43
  category: building
  kind: slab
  texture: "stone_slab_top")

(define-block DoubleSandstoneSlab
  (43 1))

(define-block DoubleWoodenSlab
  (43 2))

(define-block DoubleCobblestoneSlab
  (43 3))

(define-block DoubleBrickSlab
  (43 4))

(define-block DoubleStoneBrickSlab
  (43 5))


(definition Slab-Textures <vector>
  #("stone_slab_top"
    "sandstone_top"
    "planks_oak"
    "cobblestone"
    "brick"
    "stonebrick"))

(define-block StoneSlab
  44
  category: building
  kind: slab
  texture: "stone_slab_top"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Slab-Textures (modulo (modulo data-id 8) 6)))))
                (if (< data-id 8)
                    (add-slab what i j k x y z uv (uv-rect uv 0. .5 1. 1.) lighting rendering category block-id add-face)
                  (add-slab what i j k x (+ y block-radius) z uv (uv-rect uv 0. 0. 1. .5) lighting rendering category block-id add-face)))))

(define-block SandstoneSlab
  (44 1))

(define-block WoodenSlab
  (44 2))

(define-block CobblestoneSlab
  (44 3))

(define-block BrickSlab
  (44 4))

(define-block StoneBrickSlab
  (44 5))


(define-block Brick
  45
  category: building
  kind: cube
  texture: "brick")


(define-block TNT
  46
  category: redstone
  kind: mechanism
  texture: "tnt_side"
  opaque-cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (get-coordinates "tnt_top")))
                (add-opaque-cube what i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-block Bookshelf
  47
  category: building
  kind: cube
  texture: "bookshelf"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (get-coordinates "planks_jungle")))
                (add-opaque-cube what i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-block MossyCobblestone
  48
  category: building
  kind: cube
  texture: "cobblestone_mossy")


(define-block Obsidian
  49
  category: building
  kind: cube
  texture: "obsidian")


(define-block Torch
  50
  category: decoration
  kind: torch
  texture: "torch_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  brightness: 14
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (if (or (= data-id 0) ;; why is this still necessary???
                      (= data-id 5))
                  (add-json-model what "torch.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref 0. 0.)
                (let ((rot (case data-id
                             ((1) 0.)
                             ((2) 180.)
                             ((3) 90.)
                             ((4) 270.))))
                  (add-json-model what "torch_wall.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref rot 0.)))))


(define-block Fire
  51
  category: decoration
  kind: fire
  texture: "fire"
  rendering: transparent-rendering
  brightness: 15
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-cross-faces what i j k x y z uv lighting rendering category block-id add-face)
              @w(let ((r (random-integer-between 0 15)))
                (let ((uv (uv-rect (get-coordinates "fire_layer_0") 0. (* r 128.) 128. (* (+ r 1.) 128.))))
                  (add-cross-faces what i j k x y z uv lighting rendering category block-id add-face)))))


(define-block MonsterSpawner
  52
  category: decoration
  texture: "mob_spawner"
  rendering: transparent-rendering
  opaque-cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-cube-faces what i j k x y z uv lighting rendering category block-id add-face)))


(define-block WoodenStairs
  53
  category: building
  kind: stairs
  texture: "planks_oak"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-stairs what data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-block Chest
  54
  category: decoration
  texture: "chest_top"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((left (- x 7m))
                    (right (+ x 7m))
                    (bottom (- y block-radius))
                    (top (+ y 7m))
                    (back (- z 7m))
                    (front (+ z 7m)))
                (let ((side-uv (get-coordinates "chest_side"))
                      (front-uv (get-coordinates "chest_front"))
                      (back-uv (get-coordinates "chest_back"))
                      (bottom-uv (get-coordinates "chest_bottom"))
                      (top-uv uv))
                  (add-face (left-face   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (bottom-face what i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (top-face    what i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   what i j k x y z left right bottom top back front back-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  what i j k x y z left right bottom top back front front-uv generic-coordinates lighting rendering block-id) rendering category))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (with-field i j k
                   (lambda (section index)
                     (updating-sectors~ (current-zone)
                       (lambda (add-sector)
                         (add-sector (get-sector~ section))
                         (let ((world (current-world))
                               (zone (current-zone))
                               (index (get-index~ sector)))
                           (let ((chest (list index i j k))
                                 (data (block-entity-data region sector i j k)))
                             (cond ((not (get-opened-chest~ zone))
                                    (play-sound-file "sound/random/chestopen" volume: .5)
                                    (show-chest~ world section data)
                                    (show-character~ world)
                                    (show-bag~ world blocks?: #f)
                                    (set-opened-chest~ zone chest))
                                   ((equal? chest (get-opened-chest~ zone))
                                    (play-sound-file "sound/random/chestclosed" volume: .5)
                                    (hide-chest~ world)
                                    (hide-character~ world)
                                    (hide-bag~ world)
                                    (set-opened-chest~ zone #f))
                                   (else
                                    (play-sound-file "sound/random/chestopen" volume: .5)
                                    (hide-chest~ world)
                                    (show-chest~ world section data)
                                    (hide-character~ world)
                                    (hide-bag~ world)
                                    (show-character~ world)
                                    (show-bag~ world blocks?: #f)
                                    (set-opened-chest~ zone chest)))))))))))


(definition RedstoneDustLine-Textures <vector>
  #("redstone_dust_line_0"
    "redstone_dust_line_1"
    "redstone_dust_line_2"
    "redstone_dust_line_3"
    "redstone_dust_line_4"
    "redstone_dust_line_5"
    "redstone_dust_line_6"
    "redstone_dust_line_7"
    "redstone_dust_line_8"
    "redstone_dust_line_9"
    "redstone_dust_line_10"
    "redstone_dust_line_11"
    "redstone_dust_line_12"
    "redstone_dust_line_13"
    "redstone_dust_line_14"
    "redstone_dust_line_15"))

(define-block RedstoneWire
  55
  category: redstone
  kind: transmission
  texture: "redstone_dust_line"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  configurations: 256
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (define (data->key data)
                (case data
                  ((0) "none")
                  ((1) "side")
                  ((2) "up")))
              
              (let ((key (string-append
                           "east="   (data->key (bitwise-and data-id #b11))
                           ",north=" (data->key (arithmetic-shift-right (bitwise-and data-id #b1100) 2))
                           ",south=" (data->key (arithmetic-shift-right (bitwise-and data-id #b110000) 4))
                           ",west="  (data->key (arithmetic-shift-right (bitwise-and data-id #b11000000) 6)))))
                (with-block-state "redstone_wire.json" key
                  (lambda (model rotation-y rotation-x)
                    (add-json-model what model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref rotation-y rotation-x)))))
  visual: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube add-texture-element block-ref data-ref)
            (let ((data (redstone-configuration i j k block-ref data-ref data-id)))
              (add-visual-template block-id data i j k x y z uv rendering category add-template add-opaque-cube block-ref data-ref)))
  physical: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
              (let ((data (redstone-configuration i j k block-ref data-ref data-id)))
                (add-physical-template block-id data i j k x y z add-template block-ref data-ref))))

(definition (redstone-configuration i <fx> j <fx> k <fx> block-ref data-ref data-id <fx>) <fx>
  (let ((allow-top? (not (get-cube?~ (id->block (block-ref i (+ j 1) k))))) ;; + Glass Beacon Slab
        (block #f))
    (define (side-connection side-i side-k)
      (set! block (block-ref side-i j side-k))
      (cond ((or (id? block RedstoneWire RedstoneTorchOn RedstoneTorchOff Lever WoodenButton StoneButton WoodenPressurePlate StonePressurePlate)
                 (and (id? (block-ref side-i (- j 1) side-k) RedstoneWire) (not (get-cube?~ (id->block (block-ref side-i j side-k)))))
                 (and (id? block RedstoneRepeaterBlockOn RedstoneRepeaterBlockOff) (memq? (bitwise-and (data-ref side-i j side-k) #b11) (if (= side-i i) '(0 2) '(1 3)))))
             1)
            ((and allow-top? (id? (block-ref side-i (+ j 1) side-k) RedstoneWire))
             2)
            (else
             0)))
    
    (bitwise-ior
      (side-connection (+ i 1) k)
      (arithmetic-shift-left (side-connection i (- k 1)) 2)
      (arithmetic-shift-left (side-connection i (+ k 1)) 4)
      (arithmetic-shift-left (side-connection (- i 1) k) 6)
      @w(arithmetic-shift-left data-id 8))))
      

(define-block DiamondOre
  56
  category: building
  kind: ore
  texture: "diamond_ore")


(define-block DiamondBlock
  57
  category: building
  kind: cube
  texture: "diamond_block")


(define-block WorkbenchBlock
  58
  category: building
  kind: cube
  texture: "log_oak")


(define-block WheatCrops
  59
  category: decoration
  kind: vegetation
  texture: "wheat_stage_7"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-block Soil
  60
  category: building
  kind: cube
  texture: "dirt"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-opaque-cube what i j k x y z uv uv uv (get-coordinates "farmland_dry") uv uv lighting rendering category block-id add-face)))


(define-block Furnace
  61
  category: decoration
  texture: "furnace_side")


(define-block BurningFurnace
  62
  category: decoration
  texture: "furnace_front_on"
  brightness: 13)


(class Sign-Element extends Element
  
  (property quad <Quad> initialize #f accessors generate)
  (property data        initialize #f accessors generate)
  
  (slot quad-texture <Quad-Texture+> initialize #f)
  
  (method override (destroy)
    (nextmethod)
    (when quad-texture
      (close~ quad-texture)))
  
  (method override (element-radiuses)
    (vertex 1. 1. 1.))
  
  (method override (lens-center)
    (matrix-transform matrix (quad-center (get-v1~ quad)
                                          (get-v2~ quad)
                                          (get-v3~ quad)
                                          (get-v4~ quad))))
  
  (method (sign-quad-texture)
    (let ((quad-texture <Quad-Texture> (make-quad-texture 100 50 (get-v1~ quad) (get-v2~ quad) (get-v3~ quad) (get-v4~ quad))))
      (let ((texture (get-texture~ quad-texture)))
        (let ((surface (get-surface~ texture))
              (font {Font font-name: tahoma point-size: 11 antialias: none})
              (color {Color Black})
              (width (get-width~ texture)))
          (define (draw-line v text)
            (let ((text (effective-sign-text text)))
              (let ((w (get-text-width~ surface text)))
                (let ((h (fxceiling (/ (cast <fl> (- width w)) 2.))))
                  (draw-text~ surface h v text color)))))
          
          (clear~ surface)
          (set-font~ surface font)
          (draw-line 0 (tag-assoc "Text1" data))
          (draw-line 12 (tag-assoc "Text2" data))
          (draw-line 24 (tag-assoc "Text3" data))
          (draw-line 36 (tag-assoc "Text4" data))
          (map-texture~ texture)))
      quad-texture))
  
  (method override (draw)
    (when (not quad-texture)
      (set! quad-texture (sign-quad-texture)))
    (allege quad-texture
      (render-texture~ quad-texture))))


(definition (contains-text? data)
  (and data
       (or (not (equal? (tag-assoc "Text1" data) ""))
           (not (equal? (tag-assoc "Text2" data) ""))
           (not (equal? (tag-assoc "Text3" data) ""))
           (not (equal? (tag-assoc "Text4" data) "")))))


(definition (make-sign-element position v1 v2 v3 v4 matrix data)
  (let ((quad (make-quad #f v1 v2 v3 v4)))
    (let ((elem (new Sign-Element position: position quad: quad data: data))
          (matrix (matrix-multiply& (make-translation-matrix& position) matrix)))
      (set-matrix~ elem matrix)
      elem)))


;; hacks for minecraft 1.8 format
(definition public (effective-sign-text text)
  (cond ((equal? text "null")
         "")
        ((starts-with? text "\"")
         (substring text 1 (- (string-length text) 1)))
        (else
         text)))


(definition public (find-sign text)
  (let ((context (->search-context text)))
    (continuation-capture
      (lambda (return)
        (iterate-signs
          (lambda (sign)
            (let ((data (get-data~ sign)))
              (when (or (search (tag-assoc "Text1" data) context)
                        (search (tag-assoc "Text2" data) context)
                        (search (tag-assoc "Text3" data) context)
                        (search (tag-assoc "Text4" data) context))
                (continuation-return return sign)))))
        #f))))

(definition public (iterate-signs proc)
  (let ((zone (current-zone)))
    (iterate-table (get-sectors~ zone)
      (lambda (index sector)
        (for-each (lambda (element)
                    (when (is? element Sign-Element)
                      (proc element)))
                  (get-texture-elements~ sector))))))


(define-block SignPost
  63
  category: decoration
  kind: signs
  texture: "planks_birch"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (rotate-upon& (- (* (cast <fl> data-id) PI/8)) (vertex& 0. 1. 0.) (vertex& 0. 0. 1.))))))
                ;; sign
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom 0.)
                      (top (+ block-radius))
                      (back (- .05))
                      (front (+ .05)))
                  (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)
                ;; post
                (let ((left (- .05))
                      (right (+ .05))
                      (bottom (- block-radius))
                      (top 0.)
                      (back (- .05))
                      (front (+ .05)))
                  (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))))
  visual: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube add-texture-element block-ref data-ref)
            (add-visual-template block-id data-id i j k x y z uv rendering category add-template add-opaque-cube block-ref data-ref)
            ;; text
            (add-texture-element
              (lambda (region sector adder)
                (let ((data (block-entity-data region sector i j k)))
                  (when (contains-text? data)
                    (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (rotate-upon& (- (* (cast <fl> data-id) PI/8)) (vertex& 0. 1. 0.) (vertex& 0. 0. 1.))))))
                      (let ((left (- block-radius))
                            (right (+ block-radius))
                            (bottom 0.)
                            (top (+ block-radius))
                            (back (- .05))
                            (front (+ .05)))
                        (let ((front (+ front add-epsilon)))
                          (let ((v1 (vertex left top front))
                                (v2 (vertex left bottom front))
                                (v3 (vertex right bottom front))
                                (v4 (vertex right top front)))
                            (adder
                              (make-sign-element (vertex& x y z) v1 v2 v3 v4 matrix data)))))))))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (invoke-block-hook (vertex x y z))))


(define-block WoodenDoorBlock
  64
  category: redstone
  kind: mechanism
  texture: "door_wood_lower"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  configurations: 32
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (choose-door-model what "wooden_door.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
  visual: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube add-texture-element block-ref data-ref)
            (let ((data (door-configuration i j k data-id data-ref)))
              (add-visual-template block-id data i j k x y z uv rendering category add-template add-opaque-cube block-ref data-ref)))
  physical: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
              (let ((data (door-configuration i j k data-id data-ref)))
                (add-physical-template block-id data i j k x y z add-template block-ref data-ref)))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (let ((zone (current-zone)))
                   (updating-sectors~ zone
                     (lambda (add-sector)
                       (define (door-sound open?)
                         (play-sound-file
                           (if open?
                               "sound/random/door_close"
                             "sound/random/door_open")
                           volume: .5))
                       
                       (cond ((bit-set? 3 data-id)
                              (with-field i (- j 1) k
                                (lambda (section index)
                                  (let ((data (data-ref section index)))
                                    (data-set! section index (bit-set data 2 (not (bit-set? 2 data))))
                                    (add-sector sector)
                                    (add-sector (get-sector~ section))))))
                             (else
                              (with-field i j k
                                (lambda (section index)
                                  (door-sound (bit-set? 2 data-id))
                                  (data-set! section index (bit-set data-id 2 (not (bit-set? 2 data-id))))
                                  (add-sector sector)
                                  (add-sector (get-sector~ section)))))))))))


(definition block-states
  (make-table))

(definition (cache-block-states filename)
  (or (table-ref block-states filename #f)
      (begin
        (set-current-directory (new-directory~ {Directory Yownu-World "assets" "minecraft" "block_states"} resolution-string))
        (if (file-exists? filename)
            (let ((variants (table-ref (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "block_states"} (list resolution-string filename))) "variants")))
              (table-set! block-states filename variants)
              variants)
          (let ((variants (table-ref (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "block_states" "minecraft"} filename)) "variants")))
            (table-set! block-states filename variants)
            variants)))))

(definition (with-block-state filename key proc)
  (let ((variants (cache-block-states filename)))
    (let ((variant (table-ref variants key)))
      (let ((model (string-append (table-ref variant "model") ".json"))
            (rotation-y (table-ref variant "y" 0))
            (rotation-x (table-ref variant "x" 0)))
        (proc model rotation-y rotation-x)))))


(definition (door-configuration i j k data-id data-ref)
  (let ((top? (bit-set? 3 data-id)))
    (let ((top-data (if top? data-id (data-ref i (+ j 1) k)))
          (bottom-data (if top? (data-ref i (- j 1) k) data-id)))
      (bitwise-ior
        (bitwise-and bottom-data #b11)
        (if (bit-set? 0 top-data) 4 0)
        (if (bit-set? 2 bottom-data) 8 0)
        (if (bit-set? 3 data-id) 16 0)))))


(definition (choose-door-model what filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref)
  (let ((key (string-append
               "facing="
               (case (bitwise-and data-id #b11)
                 ((0) "east,half=")
                 ((1) "south,half=")
                 ((2) "west,half=")
                 ((3) "north,half="))
               (if (bit-set? 4 data-id)
                   "upper,hinge="
                 "lower,hinge=")
               (if (bit-set? 2 data-id)
                   "right,open="
                 "left,open=")
               (if (bit-set? 3 data-id)
                   "true"
                 "false"))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model what model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref rotation-y rotation-x)))))


(define-block Ladder
  65
  category: decoration
  kind: ladder
  texture: "ladder"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-transparent what (bitwise-and data-id #b111) 5 4 3 2 i j k x y z uv lighting rendering category block-id add-face)))


(define-block Rail
  66
  category: decoration
  kind: transportation
  texture: "rail_normal"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-rail what data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-block CobblestoneStairs
  67
  category: building
  kind: stairs
  texture: "cobblestone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-stairs what data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-block WallSign
  68
  category: decoration
  kind: signs
  texture: "planks_birch"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((left (- block-radius))
                    (right (+ block-radius))
                    (bottom (- (/ block-radius 2.)))
                    (top (+ (/ block-radius 2.)))
                    (back (+ (- block-radius) .025))
                    (front (+ (- block-radius) .125)))
                (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case data-id
                                                                       ((2) (vertex&  0. 0. -1.))
                                                                       ((3) (vertex&  0. 0.  1.))
                                                                       ((4) (vertex& -1. 0.  0.))
                                                                       ((5) (vertex&  1. 0.  0.)))))))
                  ;; sign
                  (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face))))
  visual: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube add-texture-element block-ref data-ref)
            (add-visual-template block-id data-id i j k x y z uv rendering category add-template add-opaque-cube block-ref data-ref)
            ;; text
            (add-texture-element
              (lambda (region sector adder)
                (let ((data (block-entity-data region sector i j k)))
                  (when (contains-text? data)
                    (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case data-id
                                                                           ((2) (vertex&  0. 0. -1.))
                                                                           ((3) (vertex&  0. 0.  1.))
                                                                           ((4) (vertex& -1. 0.  0.))
                                                                           ((5) (vertex&  1. 0.  0.)))))))
                      (let ((left (- block-radius))
                            (right (+ block-radius))
                            (bottom (- (/ block-radius 2.)))
                            (top (+ (/ block-radius 2.)))
                            (back (+ (- block-radius) .025))
                            (front (+ (- block-radius) .125)))
                        (let ((front (+ front add-epsilon)))
                          (let ((v1 (vertex left top front))
                                (v2 (vertex left bottom front))
                                (v3 (vertex right bottom front))
                                (v4 (vertex right top front)))
                            (adder
                              (make-sign-element (vertex& x y z) v1 v2 v3 v4 matrix data)))))))))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (invoke-block-hook (vertex x y z))))


(define-block Lever
  69
  category: redstone
  kind: power
  texture: "lever"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (lever-model what "lever.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (with-field i j k
                   (lambda (section index)
                     (updating-sectors~ (current-zone)
                       (lambda (add-sector)
                         (add-sector (get-sector~ section))
                         (data-set! section index (bit-set data-id 3 (not (bit-set? 3 data-id))))
                         (world.redstone:redstone-update sector (list i j k block-id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!)))))))


(definition (lever-model what filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref)
  (let ((key
          (string-append
            "facing="
            (case (bitwise-and data-id #b111)
              ((0) "down_z")
              ((1) "east")
              ((2) "west")
              ((3) "south")
              ((4) "north")
              ((5) "up_x")
              ((6) "up_z")
              ((7) "down_x"))
            ",powered="
            (if (bit-set? 3 data-id)
                "false"
              "true"))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model what model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref rotation-y rotation-x)))))

        
(define-block StonePressurePlate
  70
  category: redstone
  kind: power
  texture: "stone_slab_top"
  opaque-cube?: #f
  cube?: #f
  physical?: #t
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((left (+ (- x block-radius) 1m))
                    (right (- (+ x block-radius) 1m))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) (/ 1m (if (bit-set? 0 data-id) 2 1))))
                    (back (+ (- z block-radius) 1m))
                    (front (- (+ z block-radius) 1m)))
                (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category))))


(define-block IronDoorBlock
  71
  category: redstone
  kind: mechanism
  texture: "door_iron_lower"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  configurations: 32
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (choose-door-model what "iron_door.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
  visual: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube add-texture-element block-ref data-ref)
            (let ((data (door-configuration i j k data-id data-ref)))
              (add-visual-template block-id data i j k x y z uv rendering category add-template add-opaque-cube block-ref data-ref)))
  physical: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
              (let ((data (door-configuration i j k data-id data-ref)))
                (add-physical-template block-id data i j k x y z add-template block-ref data-ref))))


(define-block WoodenPressurePlate
  72
  category: redstone
  kind: power
  texture: "planks_oak"
  opaque-cube?: #f
  cube?: #f
  physical?: #t
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((left (+ (- x block-radius) 1m))
                    (right (- (+ x block-radius) 1m))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) (/ 1m (if (bit-set? 0 data-id) 2 1))))
                    (back (+ (- z block-radius) 1m))
                    (front (- (+ z block-radius) 1m)))
                (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category))))


(define-block RedstoneOre
  73
  category: building
  kind: ore
  texture: "redstone_ore")


(define-block GlowingRedstoneOre
  74
  category: building
  kind: ore
  texture: "repeater_on"
  brightness: 9)


(define-block RedstoneTorchOff
  75
  category: invalid
  texture: "redstone_torch_off"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-torch what block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref "melon_top" "planks_spruce")))


(define-block RedstoneTorchOn
  76
  category: redstone
  kind: redstonetorch
  texture: "redstone_torch_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  brightness: 7
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (redstone-torch-model what "redstone_torch.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref)))

(definition (redstone-torch-model what filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref)
  (let ((key (string-append
                 "facing="
                 (case data-id
                   ((1) "west")
                   ((2) "east")
                   ((3) "north")
                   ((4) "south")
                   (else "up")))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model what model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref (+ rotation-y 180) rotation-x)))))


(define-block StoneButton
  77
  category: redstone
  kind: power
  texture: "cobblestone"
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-button what block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (with-field i j k
                   (lambda (section index)
                     (updating-sectors~ (current-zone)
                       (lambda (add-sector)
                         (add-sector (get-sector~ section))
                         (unless (bit-set? 3 data-id)
                           (data-set! section index (bit-set data-id 3 #t))
                           (world.redstone:redstone-update sector (list i j k block-id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! #t))))))))


(define-block Snow
  78
  category: building
  kind: snow
  texture: "snow"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((left (- x block-radius))
                    (right (+ x block-radius))
                    (bottom (- y block-radius))
                    (top (+ (- y block-radius) (* (+ data-id 1) (/ 1. 8.))))
                    (back (- z block-radius))
                    (front (+ z block-radius)))
                (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category))))


(define-block Ice
  79
  category: building
  kind: ice
  texture: "ice")


(define-block SnowBlock
  80
  category: building
  kind: snow
  texture: "snow")


;; todo other faces
(define-block Cactus
  81
  category: decoration
  kind: veggieblock
  texture: "cactus_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((left (- x 7m))
                    (right (+ x 7m))
                    (bottom (- y block-radius))
                    (top (+ y block-radius))
                    (back (- z 7m))
                    (front (+ z 7m))
                    (top-uv (get-coordinates "cactus_top"))
                    (bottom-uv (get-coordinates "cactus_bottom")))
                (add-face (left-face   what i j k x y z left right bottom top (- z block-radius) (+ z block-radius) uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (right-face  what i j k x y z left right bottom top (- z block-radius) (+ z block-radius) uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (back-face   what i j k x y z (- x block-radius) (+ x block-radius) bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (add-face (front-face  what i j k x y z (- x block-radius) (+ x block-radius) bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                (unless (bit-set? 1 data-id)
                  (add-face (top-face what i j k x y z (- x block-radius) (+ x block-radius) bottom top (- z block-radius) (+ z block-radius) top-uv generic-coordinates lighting rendering block-id) rendering category))
                (unless (bit-set? 0 data-id)
                  (add-face (bottom-face what i j k x y z (- x block-radius) (+ x block-radius) bottom top (- z block-radius) (+ z block-radius) bottom-uv generic-coordinates lighting rendering block-id) rendering category))))
  visual: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube add-texture-element block-ref data-ref)
            (let ((data-id (cactus-configuration i j k block-ref)))
              (add-visual-template block-id data-id i j k x y z uv rendering category add-template add-opaque-cube block-ref data-ref)))
  physical: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
              (let ((data-id (cactus-configuration i j k block-ref)))
                (add-physical-template block-id data-id i j k x y z add-template block-ref data-ref))))

(definition (cactus-configuration i j k block-ref)
  (define (connects? dj <fx>)
    (id? (block-ref i (+ j dj) k) Cactus))
  
  (bitwise-ior
    (if (connects? -1) 1 0)
    (if (connects?  1) 2 0)))

(define-block Clay
  82
  category: building
  kind: cube
  texture: "clay")


(define-block SugarCane
  83
  category: decoration
  kind: vegetation
  texture: "reeds"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f)


(define-block Jukebox
  84
  category: decoration
  texture: "jukebox_side"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (get-coordinates "jukebox_top")))
                (add-opaque-cube what i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-block Fence
  85
  category: decoration
  kind: fence
  texture: "planks_oak"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-fence what data-id i j k x y z uv lighting rendering category block-id add-face block-ref))
  visual: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube add-texture-element block-ref data-ref)
            (let ((data-id (fence-configuration i j k block-ref '(85 @quick-hack-to-remove-all-doors 107))))
              (add-visual-template block-id data-id i j k x y z uv rendering category add-template add-opaque-cube block-ref data-ref)))
  physical: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
              (let ((data-id (fence-configuration i j k block-ref '(85 @quick-hack-to-remove-all-doors 107))))
                (add-physical-template block-id data-id i j k x y z add-template block-ref data-ref))))


(define-block Pumpkin
  86
  category: decoration
  kind: veggieblock
  texture: "pumpkin_side"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (get-coordinates "pumpkin_top")))
                (add-opaque-cube what i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-block Netherrack
  87
  category: building
  kind: cube
  rendering: water-rendering
  texture: "netherrack")


(define-block SoulSand
  88
  category: building
  kind: cube
  rendering: water-rendering
  texture: "soul_sand")


(define-block Glowstone
  89
  category: building
  kind: cube
  rendering: multitexture-rendering
  texture: "glowstone"
  brightness: 15)


;; improve
(define-block Portal
  90
  category: decoration
  kind: portal
  rendering: multitexture-rendering
  texture: "portal"
  opaque-cube?: #f
  cube?: #f)


(define-block Jack-O-Lantern
  91
  category: decoration
  kind: veggieblock
  texture: "pumpkin_top"
  brightness: 15)


(define-block CakeBlock
  92
  category: decoration
  kind: cake
  texture: "cake_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((margin 1m)
                    (half (/ 1. 32.)))
                (let ((left (+ (- x block-radius) margin))
                      (right (- (+ x block-radius) margin))
                      (bottom (- y block-radius))
                      (top y)
                      (back (+ (- z block-radius) margin))
                      (front (- (+ z block-radius) margin))
                      (side-uv uv)
                      (bottom-uv (get-coordinates "cake_bottom"))
                      (top-uv (get-coordinates "cake_top")))
                  (add-face (left-face   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (bottom-face what i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (top-face    what i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)))))


;; improve
(define-block RedstoneRepeaterBlockOff
  93
  category: redstone
  kind: transmission
  texture: "repeater_off"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((margin 2m)
                    (small 1m)
                    (matrix (make-y-rotation-matrix (* PI/2 (cast <fl> (bitwise-and data-id #b11))))))
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom (- block-radius))
                      (top (+ margin (- block-radius)))
                      (back (- block-radius))
                      (front (+ block-radius))
                      (torch-back (+ (- 2m) (* (arithmetic-shift-right (bitwise-and data-id #b1100) 2) 2m))))
                  (let ((side-uv (uv-rect (get-coordinates "stone")  0. .875 0. 1.))
                        (torch-uv (uv-rect (get-coordinates "redstone_torch_off") 6m 5m 10m 11m))
                        (torch-top-uv (uv-rect (get-coordinates "redstone_torch_off") 7m 6m 9m 8m)))
                    (add-face (left-generic   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (right-generic  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (bottom-generic what i j k x y z left right bottom top back front (get-coordinates "stone") generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (top-generic    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (back-generic   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (front-generic  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (left-generic   what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (right-generic  what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (back-generic   what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (front-generic  what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (top-generic    what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-top-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (left-generic   what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (right-generic  what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (back-generic   what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (front-generic  what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (top-generic    what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-top-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (updating-sectors~ (current-zone)
                   (lambda (add-sector)
                     (with-field i j k
                       (lambda (section index)
                         (let ((delay (arithmetic-shift-right (bitwise-and data-id #b1100) 2)))
                           (let ((ajust (if (= delay 3) -12 4)))
                             (add-sector (get-sector~ section))
                             (data-set! section index (+ data-id ajust))))))))))


;; improve
(define-block RedstoneRepeaterBlockOn
  94
  category: invalid
  texture: "repeater_on"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((margin 2m)
                    (small 1m)
                    (matrix (make-y-rotation-matrix (* PI/2 (cast <fl> (bitwise-and data-id #b11))))))
                (let ((left (- block-radius))
                      (right (+ block-radius))
                      (bottom (- block-radius))
                      (top (+ margin (- block-radius)))
                      (back (- block-radius))
                      (front (+ block-radius))
                      (torch-back (+ (- 2m) (* (arithmetic-shift-right (bitwise-and data-id #b1100) 2) 2m))))
                  (let ((side-uv (uv-rect (get-coordinates "stone")  0. .875 0. 1.))
                        (torch-uv (uv-rect (get-coordinates "redstone_torch_on") 6m 5m 10m 11m))
                        (torch-top-uv (uv-rect (get-coordinates "redstone_torch_on") 7m 6m 9m 8m)))
                    (add-face (left-generic   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (right-generic  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (bottom-generic what i j k x y z left right bottom top back front (get-coordinates "stone") generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (top-generic    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (back-generic   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (front-generic  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (left-generic   what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (right-generic  what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (back-generic   what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (front-generic  what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (top-generic    what i j k x y z (- small) small top (+ top (* 3 margin)) (+ (- block-radius) margin) (- (* 2 margin)) torch-top-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (left-generic   what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (right-generic  what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (back-generic   what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (front-generic  what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)
                    (add-face (top-generic    what i j k x y z (- small) small top (+ top (* 3 margin)) torch-back (+ torch-back 2m) torch-top-uv generic-coordinates lighting rendering block-id matrix) rendering redstone)))))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (updating-sectors~ (current-zone)
                   (lambda (add-sector)
                     (with-field i j k
                       (lambda (section index)
                         (let ((delay (arithmetic-shift-right (bitwise-and data-id #b1100) 2)))
                           (let ((ajust (if (= delay 3) -12 4)))
                             (add-sector (get-sector~ section))
                             (data-set! section index (+ data-id ajust))))))))))


;; improve
(define-block LockedChest
  95
  category: decoration
  texture: "piston_top_normal"
  cube?: #f)


(define-block Trapdoor
  96
  category: redstone
  kind: mechanism
  texture: "trapdoor"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (choose-trapdoor-model what "trapdoor.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (let ((zone (current-zone)))
                   (updating-sectors~ zone
                     (lambda (add-sector)
                       (with-field i j k
                         (lambda (section index)
                           (data-set! section index (bit-set data-id 2 (not (bit-set? 2 data-id))))
                           (add-sector sector))))))))

(definition (choose-trapdoor-model what filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref)
  (let ((key
          (string-append
            "facing="
            (case (bitwise-and data-id #b11)
              ((0) "south,half=")
              ((1) "north,half=")
              ((2) "east,half=")
              ((3) "west,half="))
            (if (bit-set? 3 data-id)
                "top,open="
              "bottom,open=")
            (if (bit-set? 2 data-id)
                "true"
              "false"))))
    (with-block-state filename key
      (lambda (model rotation-y rotation-x)
        (add-json-model what model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref (+ rotation-y 180.) rotation-x)))))


;; improve with data
(define-block StoneSilverfish
  97
  category: building
  kind: cube
  texture: "stone")

(define-block CobblestoneSilverfish
  (97 1))

(define-block StoneBrickSilverfish
  (97 2))

(definition StoneBrick-Textures <vector>
  #("stonebrick"
    "stonebrick_mossy"
    "stonebrick_cracked"
    "stonebrick_carved"))

(define-block StoneBrick
  98
  category: building
  kind: cube
  texture: "stonebrick_cracked"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref StoneBrick-Textures data-id))))
                (add-opaque-cube what i j k x y z uv uv uv uv uv uv lighting rendering category block-id add-face))))
                

(define-block MossyStoneBrick
  (98 1))

(define-block CrackedStoneBrick
  (98 2))


(define-block BrownMushroomCap
  99
  category: decoration
  kind: veggieblock
  texture: "mushroom_block_skin_brown")


(define-block RedMushroomCap
  100
  category: decoration
  kind: veggieblock
  texture: "mushroom_block_skin_red")


(define-block IronBars
  101
  category: decoration
  kind: bars
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (choose-fence-model what "iron_bars.json" block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
  visual: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube add-texture-element block-ref data-ref)
            (let ((data-id (fence-configuration i j k block-ref '(101))))
              (add-visual-template block-id data-id i j k x y z uv rendering category add-template add-opaque-cube block-ref data-ref)))
  physical: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
              (let ((data-id (fence-configuration i j k block-ref '(101))))
                (add-physical-template block-id data-id i j k x y z add-template block-ref data-ref))))


(definition (choose-fence-model what filename block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref)  
  (let ((east (bit-set? 0 data-id))
        (west (bit-set? 1 data-id))
        (north (bit-set? 3 data-id))
        (south (bit-set? 2 data-id)))
    (when (and (or east west) (not (or north south)))
      (set! east #t)
      (set! west #t))
    (when (and (or north south) (not (or east west)))
      (set! north #t)
      (set! south #t))
    (let ((key (string-append
                 "east="
                 (if east
                     "true"
                   "false")
                 ",north="
                 (if north
                     "true"
                   "false")
                 ",south="
                 (if south
                     "true"
                   "false")
                 ",west="
                 (if west
                     "true"
                   "false"))))
      (with-block-state filename key
        (lambda (model rotation-y rotation-x)
          (add-json-model what model block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref (+ rotation-y 180) rotation-x))))))


(define-block GlassPane
  102
  category: building
  kind: glass
  texture: "glass"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-cube-faces what i j k x y z uv lighting rendering category block-id add-face)))


(define-block MelonBlock
  103
  category: decoration
  kind: veggieblock
  texture: "melon_side"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (get-coordinates "melon_top")))
                (add-opaque-cube what i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-block PumpkinStem
  104
  category: decoration
  kind: vegetation
  image: "pumpkin_stem_disconnected"
  texture: "pumpkin_stem_disconnected_ochre"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-cross-faces what i j k x y z uv lighting rendering category block-id add-face)))


(define-block MelonStem
  105
  category: waiting ;; decoration ;; no need for two stems
  kind: vegetation
  image: "melon_stem_disconnected"
  texture: "melon_stem_disconnected_ochre"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-cross-faces what i j k x y z uv lighting rendering category block-id add-face)))


(define-block Vines
  106
  category: decoration
  kind: vegetation
  image: "vine"
  texture: "vine_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-transparent what data-id 2 8 4 1 i j k x y z uv lighting rendering category block-id add-face)))


(define-block FenceGate
  107
  ;; no category until we display fences
  ;; category: redstone
  ;; kind: mechanism
  texture: "planks_oak"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              ;; quick hack to remove all fences
              #f
              @w
              (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case (bitwise-and data-id #b11)
                                                                     ((0 2) (vertex&  0. 0.  1.))
                                                                     ((1 3) (vertex& -1. 0.  0.))))))
                    (opened? (bit-set? 2 data-id)))
                (define (add-trunk left <fl> right <fl>)
                  (let ((bottom (+ (- block-radius) .35))
                        (top (+ block-radius))
                        (back (- .075))
                        (front (+ .075)))
                    (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
                
                (define (add-branches left <fl> right <fl> back <fl> front <fl>)
                  ;; upper
                  (let ((bottom (- .35 .075))
                        (top (+ .35 .075)))
                    (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face))
                  ;; lower
                  (let ((bottom (- .075))
                        (top (+ .075)))
                    (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
                
                (define (add-middle left <fl> right <fl> back <fl> front <fl>)
                  (let ((bottom -.075)
                        (top (+ .35 .075)))
                    (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
                
                ;; trunk
                (add-trunk (- block-radius) (+ (- block-radius) .2))
                (add-trunk (- (+ block-radius) .2) (+ block-radius))
                ;; branches
                (cond (opened?
                       (add-branches (- block-radius) (+ (- block-radius) .2) .075 (- (+ block-radius) .2))
                       (add-branches (- (+ block-radius) .2) (+ block-radius) .075 (- (+ block-radius) .2)))
                      (else
                       (add-branches (+ (- block-radius) .2) -.1 (- .075) (+ .075))
                       (add-branches .1 (- (+ block-radius) .2) (- .075) (+ .075))))
                ;; middle
                (cond (opened?
                       (add-middle (- block-radius) (+ (- block-radius) .2) (- (+ block-radius) .2) (+ block-radius))
                       (add-middle (- (+ block-radius) .2) (+ block-radius) (- (+ block-radius) .2) (+ block-radius)))
                      (else
                       (add-middle -.1 0. (- .075) (+ .075))
                       (add-middle 0. .1 (- .075) (+ .075)))))))


(define-block BrickStairs
  108
  category: building
  kind: stairs
  texture: "brick"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-stairs what data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-block StoneBrickStairs
  109
  category: building
  kind: stairs
  texture: "stonebrick"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-stairs what data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-block Mycelium
  110
  category: building
  kind: cube
  texture: "mycelium_side"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (get-coordinates "mycelium_top")))
                (add-opaque-cube what i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-block LilyPad
  111
  category: decoration
  kind: vegetation
  image: "waterlily"
  texture: "waterlily_green"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-bottom what i j k x y z uv generic-coordinates lighting rendering category block-id add-face)))


(define-block NetherBrick
  112
  category: building
  kind: cube
  texture: "nether_brick")


(define-block NetherBrickFence
  113
  category: decoration
  kind: fence
  texture: "iron_bars"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates "nether_brick")))
                (add-fence what data-id i j k x y z uv lighting rendering category block-id add-face block-ref)))
  visual: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube add-texture-element block-ref data-ref)
            (let ((data-id (fence-configuration i j k block-ref '(113))))
              (add-visual-template block-id data-id i j k x y z uv rendering category add-template add-opaque-cube block-ref data-ref)))
  physical: (lambda (block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
              (let ((data-id (fence-configuration i j k block-ref '(85 @quick-hack-to-remove-all-doors 107))))
                (add-physical-template block-id data-id i j k x y z add-template block-ref data-ref))))


(define-block NetherBrickStairs
  114
  category: building
  kind: stairs
  texture: "nether_brick"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-stairs what data-id i j k x y z uv lighting rendering category block-id add-face)))


;; improve
(define-block NetherWart
  115
  category: decoration
  kind: vegetation
  texture: "nether_wart_stage_1"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)


(define-block EnchantmentTable
  116
  category: decoration
  texture: "enchanting_table_side"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((margin 4m))
                (let ((left (- x block-radius))
                      (right (+ x block-radius))
                      (bottom (- y block-radius))
                      (top (+ y margin))
                      (back (- z block-radius))
                      (front (+ z block-radius))
                      (top-uv (get-coordinates "enchanting_table_top"))
                      (bottom-uv (get-coordinates "enchanting_table_bottom")))
                  (add-face (top-face    what i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (bottom-face what i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)))))


(define-block BrewingStand
  117
  category: decoration
  texture: "brewing_stand"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)


(define-block Cauldron
  118
  category: decoration
  texture: "cauldron_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((margin 4m)
                    (half 2m))
                (let ((left (- x block-radius))
                      (right (+ x block-radius))
                      (bottom (- y block-radius))
                      (top (+ y block-radius))
                      (back (- z block-radius))
                      (front (+ z block-radius))
                      (top-uv (get-coordinates "cauldron_top"))
                      (bottom-uv (get-coordinates "cauldron_bottom"))
                      (inner-uv (get-coordinates "cauldron_inner")))
                  (add-face (top-face    what i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (bottom-face what i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (left-face   what i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  what i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   what i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  what i j k x y z (+ left half) (- right half) bottom top (+ back half) (- front half) uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (top-face    what i j k x y z left right bottom (+ bottom margin) back front inner-uv generic-coordinates lighting rendering block-id) rendering category)
                  (if (> data-id 0)
                      (let ((water-uv (get-coordinates "water"))
                            (wtop (/ (+ 6. (* 3. data-id)) 16.)))
                        (add-face (top-face what i j k x y z left right bottom wtop back front water-uv generic-coordinates lighting rendering block-id) rendering category)))))))


;; improve
(define-block EndPortal
  119
  category: waiting ;; decoration
  texture: "stone_slab_top"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-slab what i j k x y z uv uv lighting rendering category block-id add-face)))


(define-block EndPortalFrame
  120
  category: waiting ;; decoration
  texture: "endframe_side"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((margin 5m))
                (let ((left (- x block-radius))
                      (right (+ x block-radius))
                      (bottom (- y block-radius))
                      (top (+ y margin))
                      (back (- z block-radius))
                      (front (+ z block-radius))
                      (top-uv (get-coordinates "endframe_top"))
                      (bottom-uv (get-coordinates "end_stone")))
                  (add-face (top-face    what i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (bottom-face what i j k x y z left right bottom top back front bottom-uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
                  (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)))
              (when (= data-id 4)
                (let ((margin 4m))
                  (let ((top (+ y block-radius))
                        (bottom (+ y 5m))
                        (left (- x margin))
                        (right (+ x margin))
                        (back (- z margin))
                        (front (+ z margin))
                        (side-uv (get-coordinates "endframe_eye_side"))
                        (top-uv (get-coordinates "endframe_eye")))
                    (add-face (left-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                    (add-face (right-face what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                    (add-face (front-face what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                    (add-face (back-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
                    (add-face (top-face   what i j k x y z left right bottom top back front top-uv generic-coordinates lighting rendering block-id) rendering category))))))


(define-block EndStone
  121
  category: building
  kind: cube
  texture: "end_stone")


;; improve
(define-block DragonEgg
  122
  category: waiting
  texture: "dragon_egg"
  opaque-cube?: #f
  cube?: #f)


(define-block RedstoneLampOff
  123
  category: redstone
  kind: mechanism
  texture: "redstone_lamp_off"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (get-coordinates "redstone_lamp_top_off")))
                (add-opaque-cube what i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(define-block RedstoneLampOn
  124
  category: invalid
  texture: "redstone_lamp_on"
  brightness: 15
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((top (get-coordinates "redstone_lamp_top_on")))
                (add-opaque-cube what i j k x y z uv uv uv top uv uv lighting rendering category block-id add-face))))


(definition Wood-Slab-Textures <vector>
  #("planks_oak"
    "planks_spruce"
    "planks_birch"
    "planks_jungle"))

;; improve
(define-block DoubleWoodenSlab
  125
  category: building
  kind: slab
  texture: "planks_oak"
  opaque-cube?: #t
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wood-Slab-Textures (modulo data-id 4)))))
                (add-slab what i j k x y z uv (uv-rect uv 0. .5 1. 1.) lighting rendering category block-id add-face)
                (add-slab what i j k x (+ y block-radius) z uv (uv-rect uv 0. 0. 1. .5) lighting rendering category block-id add-face))))


(define-block WoodenSlab
  126
  category: building
  kind: slab
  texture: "planks_oak"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates (vector-ref Wood-Slab-Textures (modulo data-id 4)))))
                (if (< data-id 3)
                    (add-slab what i j k x y z uv (uv-rect uv 0. .5 1. 1.) lighting rendering category block-id add-face)
                  (add-slab what i j k x (+ y block-radius) z uv (uv-rect uv 0. 0. 1. .5) lighting rendering category block-id add-face)))))


(define-block CocoaPlant
  127
  category: waiting ;; decoration
  texture: "cocoa_stage_2"
  opaque-cube?: #f
  cube?: #f)


(define-block SandstoneStairs
  128
  category: building
  kind: stairs
  texture: "sandstone_normal"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-stairs what data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-block EmeraldOre
  129
  category: building
  kind: ore
  texture: "emerald_ore")


;; improve
(define-block EnderChest
  130
  category: waiting ;; decoration
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-block TripwireHook
  131
  category: waiting ;; redstone
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-block Tripwire
  132
  category: waiting ;; redstone
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)


(define-block EmeraldBlock
  133
  category: building
  kind: cube
  texture: "emerald_block")


(define-block SpruceWoodStairs
  134
  category: building
  kind: stairs
  texture: "planks_spruce"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-stairs what data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-block BirchWoodStairs
  135
  category: building
  kind: stairs
  texture: "planks_birch"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-stairs what data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-block JungleWoodStairs
  136
  category: building
  kind: stairs
  texture: "planks_jungle"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-stairs what data-id i j k x y z uv lighting rendering category block-id add-face)))


(define-block CommandBlock
  137
  category: redstone
  kind: mechanism
  texture: "command_block"
  opaque-cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-opaque-cube what i j k x y z uv uv uv uv uv uv lighting rendering category block-id add-face)))


;; improve
(define-block BeaconBlock
  138
  category: decoration
  texture: "beacon"
  brightness: 15)


;; improve
(define-block CobblestoneWall
  139
  category: waiting
  texture: "cobblestone"
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-block FlowerPot
  140
  category: waiting ;; decoration
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-block Carrots
  141
  category: waiting ;; decoration
  texture: "farmland_wet"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-block Potatoes
  142
  category: waiting ;; decoration
  texture: "farmland_wet"
  rendering: transparent-rendering
  opaque-cube?: #f
  cube?: #f)


;; improve
(define-block WoodenButton
  143
  category: redstone
  kind: power
  texture: "farmland_wet"
  opaque-cube?: #f
  cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (add-button what block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
  right-mouse: (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                 (with-field i j k
                   (lambda (section index)
                     (updating-sectors~ (current-zone)
                       (lambda (add-sector)
                         (add-sector (get-sector~ section))
                         (unless (bit-set? 3 data-id)
                           (data-set! section index (bit-set data-id 3 #t))
                           (world.redstone:redstone-update sector (list i j k block-id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! #t))))))))


(define-block Leaves2
  161
  category: decoration
  kind: leaves
  image: "leaves_big_oak"
  texture: "leaves_big_oak_green"
  rendering: transparent-rendering
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates (case (bitwise-and data-id #b11)
                                           ((0) "leaves_acacia_green")
                                           ((1) "leaves_big_oak_green")))))
                    (add-cube-faces what i j k x y z uv lighting rendering category block-id add-face))))


(define-block Wood2
  162
  category: building
  kind: cube
  texture: "log_big_oak"
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates (case (bitwise-and data-id #b11)
                                           ((0) "log_acacia")
                                           ((1) "log_big_oak")))))
                    (add-cube-faces what i j k x y z uv lighting rendering category block-id add-face))))


(define-block DoublePlant
  175
  category: decoration
  kind: vegetation
  image: "double_plant_rose_bottom"
  texture: "double_plant_paeonia_bottom"
  rendering: transparent-rendering
  cube?: #f
  opaque-cube?: #f
  physical?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (let ((uv (get-coordinates (if (bit-set? 3 data-id)
                                             (case (bitwise-and data-id #b111)
                                               ((0) "double_plant_sunflower_top")
                                               ((1) "double_plant_syringa_top")
                                               ((2) "double_plant_grass_top_green")
                                               ((3) "double_plant_fern_top")
                                               ((4) "double_plant_rose_top")
                                               ((5) "double_plant_paeonia_top"))
                                           (case (bitwise-and data-id #b111)
                                             ((0) "double_plant_sunflower_bottom")
                                             ((1) "double_plant_syringa_bottom")
                                             ((2) "double_plant_grass_bottom_green")
                                             ((3) "double_plant_fern_bottom")
                                             ((4) "double_plant_rose_bottom")
                                             ((5) "double_plant_paeonia_bottom"))))))
                (add-cross-faces what i j k x y z uv lighting rendering category block-id add-face))))


;;;
;;;; Custom
;;;


;; quick test to use ids


(define-block Cube
  200
  category: sloped
  texture: "stone"
  ;; much slower version because it uses generic lighting
  ;; this can be a great test when optimizing generic lighting
  ;; generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
  ;;             (generate-model what 'Cube block-id i j k x y z uv generic-coordinates lighting rendering category add-face))
  )


(define-block Step-Big
  201
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Step-Big block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


(define-block Step-Small
  202
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Step-Small block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


(define-block Step
  203
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Step block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


(define-block Slope
  204
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Slope block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


(define-block Corner-Left
  205
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Corner-Left block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


(define-block Corner-Right
  206
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Corner-Right block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


(define-block Corner-Pyramid
  207
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Corner-Pyramid block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


(define-block Corner-Slope
  208
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Corner-Slope block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


(define-block Pyramid
  209
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Pyramid block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


@wait
(define-block Floor
  210
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Floor block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


@wait
(define-block Wall
  211
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Wall block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


@wait
(define-block Ceiling
  212
  category: sloped
  texture: "stone"
  opaque-cube?: #f
  cube?: #f
  generate: (lambda (what block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category add-face add-opaque-cube block-ref data-ref)
              (generate-model what 'Ceiling block-id i j k x y z uv generic-coordinates lighting rendering category add-face)))


;;;
;;;; Unknown
;;;


(let ((unknown-texture "gold_ore"))
  (loop (for id from 0 below 256)
        (unless (vector-ref blockids id)
          (register-block 'Unknown id
            texture: unknown-texture))))


;;;
;;;; Model
;;;


(definition (register-block-models)
  (loop (for n from 0 below (vector-length blockids))
        (let ((block <Block> (vector-ref blockids n)))
          (let ((name (get-name~ block))
                (id (get-id~ block)))
            (unless (or (= id 0)
                        (eq? name 'Unknown))
              (register-model name
                (lambda ()
                  (create-block-model block))
                #t
                'block))))))


(definition (create-block-model block <Block>)
  (let ((faces '())
        (block-id (get-id~ block))
        (category (get-category~ block))
        (uv (block-texture-coordinates block))
        (generate (get-generate~ block))
        (rendering (cache-rendering~ block))
        (transparent-rendering (transparent-rendering)))
    (define (block-ref i <fx> j <fx> k <fx>) <fx>
      air-id)
    
    (define (data-ref i <fx> j <fx> k <fx>) <fx>
      0)
    
    (define (block-data-id) <fx>
      (ccase block-id
        ((WoodenButton StoneButton Vines) 2)
        ((WoodenStairs CobblestoneStairs BrickStairs StoneBrickStairs NetherBrickStairs SandstoneStairs SpruceWoodStairs BirchWoodStairs JungleWoodStairs WallSign) 3)
        ((Ladder) 4)
        ((Torch Piston StickyPiston Lever) 5)
        (else 0)))
    
    (define (add-face face <Face> rendering <Rendering> category)
      (set! faces (cons face faces)))
    
    (define (add-opaque-cube what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id add-face)
      (add-face (left-side   what i j k x y z left-uv lighting rendering block-id) rendering category)
      (add-face (right-side  what i j k x y z right-uv lighting rendering block-id) rendering category)
      (add-face (bottom-side what i j k x y z bottom-uv lighting rendering block-id) rendering category)
      (add-face (top-side    what i j k x y z top-uv lighting rendering block-id) rendering category)
      (add-face (back-side   what i j k x y z back-uv lighting rendering block-id) rendering category)
      (add-face (front-side  what i j k x y z front-uv lighting rendering block-id) rendering category))
    
    (define default-lighting
      (f32vector 0. 60. 4.))
    
    (define (no-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      default-lighting)
    
    (let ((lighting no-lighting))
      (cond (generate
             (generate 'model block-id (block-data-id) 0 0 0 0. 0. 0. uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
            ((get-opaque-cube?~ block)
             (add-opaque-cube 'model 0 0 0 0. 0. 0. uv uv uv uv uv uv lighting rendering category block-id add-face))
            (else
             (add-cross-faces 'model 0 0 0 0. 0. 0. uv lighting transparent-rendering category block-id add-face))))
    (make-model faces class: Block-Model)))


(register-block-models)


;;;
;;;; Generate
;;;


(definition protected generate-mutex
  (make-mutex 'generate))


(definition protected (with-generate-mutex thunk)
  (unwind-protect
      (begin
        (mutex-lock! generate-mutex)
        (thunk))
    (mutex-unlock! generate-mutex)))


;; we need to go two in every direction instead of just one
;; because of door tops that are rendered by door bottom blocks
(definition block-cache-size <fx>
  (* 20 20 20 4))

(definition block-cache <u16vector>
  (make-u16vector block-cache-size))

(definition protected (initialize-block-cache cache-uninitialized <fx>) <u16vector>
  (loop (for i from 0 below block-cache-size)
        (u16vector-set! block-cache i cache-uninitialized))
  block-cache)


;;;
;;;; Visual
;;;


(definition protected (instantiate-visual sector <Sector>)
  (let ((zone (current-zone)))
    (define (conclude-rendering rendering <Rendering>)
      (let ((content (get-mesh-content~ (get-mesher~ rendering))))
        (when content
          (cons (get-material~ rendering) content))))
    
    (define (conclude-category-renderings)
      (let ((all '()))
        (iterate-table category-renderings
          (lambda (category rendering)
            (let ((content (get-mesh-content~ (get-mesher~ rendering))))
              (when content
                (let ((info (cons (get-material~ rendering) content)))
                  (set! all (cons (cons category info) all)))))))
        all))
    
    (define (generate-done)
      (set-visual-uptodate?~ sector #t)
      (set-generating?~ sector #f)
      (decrease-sectors-generating~ zone 1))
    
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region~ zone sector-x sector-y sector-z)))
          (if (not region)
              (generate-done)
            (let ((region-x (get-x~ region))
                  (region-z (get-z~ region))
                  (section (get-section~ region 'visual sector-x sector-y sector-z))
                  (chunk-index (chunk-index& sector-x sector-z))
                  (truncate-y (get-truncate-y~ zone))
                  (cache-uninitialized 65535))
              (if (not section)
                  (generate-done)
                (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y 0))))
                      (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                      (section-y (* sector-y 16))
                      (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                      (sections <vector> (make-vector 27 #t))
                      (cache <u16vector> (initialize-block-cache cache-uninitialized))
                      (blocks <u8vector> (get-blocks~ section))
                      (data <u8vector> (get-data~ section))
                      (blocklight <u8vector> (get-blocklight~ section))
                      (skylight <u8vector> (get-skylight~ section))
                      (opaque-rendering <Rendering> (opaque-rendering))
                      (transparent-rendering <Rendering> (transparent-rendering))
                      (coverage-rendering <Rendering> (coverage-rendering))
                      (water-rendering <Rendering> (water-rendering))
                      (wet-rendering <Rendering> (wet-rendering))
                      (multitexture-rendering <Rendering> (multitexture-rendering))
                      (texture-elements '()))
                  (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                    (if (and (= a 0)
                             (= b 0)
                             (= c 0))
                        section
                      (let ((index (section-index a b c)))
                        (let ((section (vector-ref sections index)))
                          (if (neq? section #t)
                              section
                            (let ((x (+ sector-x a))
                                  (y (+ sector-y b))
                                  (z (+ sector-z c)))
                              (let ((region (sector-region~ zone x y z)))
                                (let ((section (and region (get-section~ (cast <World-Region> region) 'visual x y z))))
                                  (vector-set! sections index section)
                                  section))))))))
                  
                  (define (section-index a <fx> b <fx> c <fx>) <fx>
                    (+ (* b 9) (* c 3) a 13))
                  
                  (define (local-index i <fx> j <fx> k <fx>) <fx>
                    (+ (* j 256) (* k 16) i))
                  
                  (define (effective-index i <fx> j <fx> k <fx>) <fx>
                    (* (+ (* j 400) (* k 20) i 842) 4))
                  
                  (define (blocks-get section <World-Section>) <u8vector>
                    (get-blocks~ section))
                  
                  (define (data-get section <World-Section>) <u8vector>
                    (get-data~ section))
                  
                  (define (blocklight-get section <World-Section>) <u8vector>
                    (get-blocklight~ section))
                  
                  (define (skylight-get section <World-Section>) <u8vector>
                    (get-skylight~ section))
                  
                  (define (local-block-ref i <fx> j <fx> k <fx>) <fx>
                    (u8vector-ref blocks (local-index i j k)))
                  
                  (define (local-data-ref i <fx> j <fx> k <fx>) <fx>
                    (u4vector-ref data (local-index i j k)))
                  
                  (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                    (let ((index (effective-index i j k)))
                      (let ((value (u16vector-ref cache index)))
                        (if (/= value cache-uninitialized)
                            value
                          (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                            (u16vector-set! cache index value)
                            value)))))
                  
                  (define (effective-data-ref i <fx> j <fx> k <fx>) <fx>
                    (field-ref i j k data-get u4vector-ref 0 0))
                  
                  (define (effective-light-ref! i <fx> j <fx> k <fx> lighting <f32vector>) <void>
                    (unless (get-opaque-cube?~ (id->block (effective-block-ref i j k)))
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache (+ index 1))))
                          (if (/= value cache-uninitialized)
                              (begin
                                (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> value)))
                                (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> (u16vector-ref cache (+ index 2)))))
                                (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> (u16vector-ref cache (+ index 3)))))
                                (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))
                            (let ((blocklight (field-ref i j k blocklight-get u4vector-ref 0 0))
                                  (skylight (field-ref i j k skylight-get u4vector-ref 15 15))
                                  (ambience (if (= (effective-block-ref i j k) air-id) 1 0)))
                              (u16vector-set! cache (+ index 1) blocklight)
                              (u16vector-set! cache (+ index 2) skylight)
                              (u16vector-set! cache (+ index 3) ambience)
                              (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> blocklight)))
                              (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> skylight)))
                              (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> ambience)))
                              (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.))))))))
                  
                  (define (inner-light-ref! i <fx> j <fx> k <fx> lighting <f32vector>) <void>
                    (unless (get-opaque-cube?~ (id->block (effective-block-ref i j k)))
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache (+ index 1))))
                          (if (/= value cache-uninitialized)
                              (begin
                                (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> value)))
                                (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> (u16vector-ref cache (+ index 2)))))
                                (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> (u16vector-ref cache (+ index 3)))))
                                (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))
                            (let ((local-index (local-index i j k)))
                              (let ((blocklight (u4vector-ref blocklight local-index))
                                    (skylight (u4vector-ref skylight local-index))
                                    (ambience (if (= (u8vector-ref blocks local-index) air-id) 1 0)))
                                (u16vector-set! cache (+ index 1) blocklight)
                                (u16vector-set! cache (+ index 2) skylight)
                                (u16vector-set! cache (+ index 3) ambience)
                                (f32vector-set! lighting 0 (+ (f32vector-ref lighting 0) (cast <fl> blocklight)))
                                (f32vector-set! lighting 1 (+ (f32vector-ref lighting 1) (cast <fl> skylight)))
                                (f32vector-set! lighting 2 (+ (f32vector-ref lighting 2) (cast <fl> ambience)))
                                (f32vector-set! lighting 3 (+ (f32vector-ref lighting 3) 1.)))))))))
                  
                  (define (u4vector-ref field <u8vector> index <fx>) <fx>
                    (let ((byte (u8vector-ref field (quotient index 2))))
                      (if (even? index)
                          (bitwise-and byte #x0F)
                        (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                  
                  (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                    (define (bind-i a <fx> i <fx>)
                      (define (bind-j b <fx> j <fx>)
                        (define (bind-k c <fx> k <fx>)
                          (let ((section (section-ref a b c)))
                            (if (not section)
                                (if (and bottom-section? (= b -1)) bottom empty)
                              (let ((field (get-field section)))
                                (if (not field)
                                    (if (and bottom-section? (= b -1)) bottom empty)
                                  (ref field (local-index i j k)))))))
                        
                        (cond ((< k 0) (bind-k -1 (+ 16 k)))
                              ((> k 15) (bind-k 1 (- k 16)))
                              (else (bind-k 0 k))))
                      
                      (cond ((< j 0) (bind-j -1 (+ 16 j)))
                            ((> j 15) (bind-j 1 (- j 16)))
                            (else (bind-j 0 j))))
                    
                    (cond ((< i 0) (bind-i -1 (+ 16 i)))
                          ((> i 15) (bind-i 1 (- i 16)))
                          (else (bind-i 0 i))))
                  
                  (define (add-template i j k x y z template <Face-Template> rendering <Rendering> category)
                    (let ((mesher <Lighted-Mesher> (get-mesher~ rendering))
                          (l1 (static (f32vector 0. 0. 0. 0.)))
                          (l2 (static (f32vector 0. 0. 0. 0.)))
                          (l3 (static (f32vector 0. 0. 0. 0.)))
                          (l4 (static (f32vector 0. 0. 0. 0.))))
                      (let ((inverse? (setup-lighting~ template i j k compute-lighting l1 l2 l3 l4)))
                        (add-template~ mesher x y z template inverse?)
                        (add-lighting~ mesher template l1 l2 l3 l4 inverse?))
                      (when (and mesh-categories? (eq? category redstone))
                        (let ((rendering (get-category-rendering category)))
                          (let ((mesher <Lighted-Mesher> (get-mesher~ rendering)))
                            (let ((inverse? (setup-lighting~ template i j k full-lighting l1 l2 l3 l4)))
                              (add-template~ mesher x y z template inverse?)
                              (add-lighting~ mesher template l1 l2 l3 l4 inverse?)))))))
                  
                  (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> rendering category block-id add-template)
                    (let ((data-id (local-data-ref i j k)))
                      (let ((template (find-visual-template block-id data-id)))
                        (let ((rendering (effective-rendering (effective-block-ref (- i 1) j k) rendering))) (when rendering (add-template i j k x y z (vector-ref template 0) rendering category)))
                        (let ((rendering (effective-rendering (effective-block-ref (+ i 1) j k) rendering))) (when rendering (add-template i j k x y z (vector-ref template 1) rendering category)))
                        (let ((rendering (effective-rendering (effective-block-ref i (- j 1) k) rendering))) (when rendering (add-template i j k x y z (vector-ref template 2) rendering category)))
                        (let ((rendering (effective-rendering (effective-block-ref i (+ j 1) k) rendering))) (when rendering (add-template i j k x y z (vector-ref template 3) rendering category)))
                        (let ((rendering (effective-rendering (effective-block-ref i j (- k 1)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 4) rendering category)))
                        (let ((rendering (effective-rendering (effective-block-ref i j (+ k 1)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 5) rendering category))))))
                  
                  (define (add-inner-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> rendering category block-id add-template)
                    (let ((index (local-index i j k)))
                      (let ((data-id (u4vector-ref data index)))
                        (let ((template (find-visual-template block-id data-id)))
                          (let ((rendering (effective-rendering (u8vector-ref blocks (- index   1)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 0) rendering category)))
                          (let ((rendering (effective-rendering (u8vector-ref blocks (+ index   1)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 1) rendering category)))
                          (let ((rendering (effective-rendering (u8vector-ref blocks (- index 256)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 2) rendering category)))
                          (let ((rendering (effective-rendering (u8vector-ref blocks (+ index 256)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 3) rendering category)))
                          (let ((rendering (effective-rendering (u8vector-ref blocks (- index  16)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 4) rendering category)))
                          (let ((rendering (effective-rendering (u8vector-ref blocks (+ index  16)) rendering))) (when rendering (add-template i j k x y z (vector-ref template 5) rendering category)))))))
                  
                  (define (effective-rendering neighboor-id <fx> rendering <Rendering>)
                    (let ((neighboor (id->block neighboor-id)))
                      (cond ((get-opaque-cube?~ neighboor)
                             #f)
                            ((get-water-cube?~ neighboor)
                             wet-rendering)
                            (else
                             rendering))))
                  
                  (define (add-water-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> rendering category block-id add-template)
                    (let ((data-id (local-data-ref i j k)))
                      (let ((template (find-visual-template block-id data-id)))
                        (unless (water-opaque? (effective-block-ref (- i 1) j k)) (add-template i j k x y z (vector-ref template 0) rendering category))
                        (unless (water-opaque? (effective-block-ref (+ i 1) j k)) (add-template i j k x y z (vector-ref template 1) rendering category))
                        (unless (water-opaque? (effective-block-ref i (- j 1) k)) (add-template i j k x y z (vector-ref template 2) rendering category))
                        (unless (water-opaque? (effective-block-ref i (+ j 1) k)) (add-template i j k x y z (vector-ref template 3) rendering category))
                        (unless (water-opaque? (effective-block-ref i j (- k 1))) (add-template i j k x y z (vector-ref template 4) rendering category))
                        (unless (water-opaque? (effective-block-ref i j (+ k 1))) (add-template i j k x y z (vector-ref template 5) rendering category)))))
                  
                  (define (add-inner-water-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> rendering category block-id add-template)
                    (let ((index (local-index i j k)))
                      (let ((data-id (u4vector-ref data index)))
                        (let ((template (find-visual-template block-id data-id)))
                          (unless (water-opaque? (u8vector-ref blocks (- index   1))) (add-template i j k x y z (vector-ref template 0) rendering category))
                          (unless (water-opaque? (u8vector-ref blocks (+ index   1))) (add-template i j k x y z (vector-ref template 1) rendering category))
                          (unless (water-opaque? (u8vector-ref blocks (- index 256))) (add-template i j k x y z (vector-ref template 2) rendering category))
                          (unless (water-opaque? (u8vector-ref blocks (+ index 256))) (add-template i j k x y z (vector-ref template 3) rendering category))
                          (unless (water-opaque? (u8vector-ref blocks (- index  16))) (add-template i j k x y z (vector-ref template 4) rendering category))
                          (unless (water-opaque? (u8vector-ref blocks (+ index  16))) (add-template i j k x y z (vector-ref template 5) rendering category))))))
                  
                  (define (water-opaque? block-id <fx>)
                    (let ((block (id->block block-id)))
                      (or (get-water-cube?~ block)
                          (get-opaque-cube?~ block))))
                  
                  (define (compute-lighting lighting <f32vector> i <fx> j <fx> k <fx> t <Light-Template>)
                    (let ((shade (get-shade~ t))
                          (s1 (get-s1~ t))
                          (s2 (get-s2~ t))
                          (s3 (get-s3~ t))
                          (s4 (get-s4~ t)))
                      (f32vector-set! lighting 0 0.)
                      (f32vector-set! lighting 1 0.)
                      (f32vector-set! lighting 2 0.)
                      (f32vector-set! lighting 3 0.)
                      (effective-light-ref! (+ i (s8vector-ref s1 0)) (+ j (s8vector-ref s1 1)) (+ k (s8vector-ref s1 2)) lighting)
                      (effective-light-ref! (+ i (s8vector-ref s2 0)) (+ j (s8vector-ref s2 1)) (+ k (s8vector-ref s2 2)) lighting)
                      (effective-light-ref! (+ i (s8vector-ref s3 0)) (+ j (s8vector-ref s3 1)) (+ k (s8vector-ref s3 2)) lighting)
                      (effective-light-ref! (+ i (s8vector-ref s4 0)) (+ j (s8vector-ref s4 1)) (+ k (s8vector-ref s4 2)) lighting)
                      (adjust-lighting lighting 0 shade)
                      (adjust-lighting lighting 1 shade)
                      lighting))
                  
                  (define (full-lighting lighting <f32vector> i <fx> j <fx> k <fx> t <Light-Template>)
                    (f32vector-set! lighting 0 60.)
                    (f32vector-set! lighting 1 60.)
                    (f32vector-set! lighting 2 15.)
                    (f32vector-set! lighting 3 1.))
                  
                  (define (add-texture-element proc)
                    (proc region sector texture-element-adder))
                  
                  (define (texture-element-adder element)
                    (set! texture-elements (cons element texture-elements)))
                  
                  (reset-mesher~ opaque-rendering)
                  (reset-mesher~ transparent-rendering)
                  (reset-mesher~ coverage-rendering)
                  (reset-mesher~ water-rendering)
                  (reset-mesher~ wet-rendering)
                  (reset-mesher~ multitexture-rendering)
                  (when mesh-categories?
                    (reset-category-renderings))
                  
                  ;; inner
                  (loop (for j from 1 below 15)
                        (loop (for k from 1 below 15)
                              (loop (for i from 1 below 15)
                                    (let ((block-id (local-block-ref i j k)))
                                      (when (/= block-id air-id)
                                        (let ((x (+ section-x i))
                                              (y (+ section-y j))
                                              (z (+ section-z k))
                                              (block (id->block block-id)))
                                          (let ((x (fl& (+ block-radius (cast <fl> x))))
                                                (y (fl& (+ block-radius (cast <fl> y))))
                                                (z (fl& (+ block-radius (cast <fl> z))))
                                                (uv (block-texture-coordinates block))
                                                (rendering (cache-rendering~ block))
                                                (category (get-category~ block)))
                                            (let ((visual (get-visual~ block)))
                                              (cond (visual
                                                     (visual block-id (local-data-ref i j k) i j k x y z uv rendering category add-template add-opaque-cube add-texture-element effective-block-ref effective-data-ref))
                                                    ((get-opaque-cube?~ block)
                                                     (add-inner-opaque-cube i j k x y z uv uv uv uv uv uv rendering category block-id add-template))
                                                    ((get-water-cube?~ block)
                                                     (add-inner-water-cube i j k x y z uv uv uv uv uv uv rendering category block-id add-template))
                                                    (else
                                                     (add-visual-template block-id (local-data-ref i j k) i j k x y z uv rendering category add-template add-opaque-cube effective-block-ref effective-data-ref)))))))))))
                  
                  ;; outer
                  (let ()
                    (define (add i <fx> j <fx> k <fx>)
                      (let ((block-id (local-block-ref i j k)))
                        (when (/= block-id air-id)
                          (let ((x (+ section-x i))
                                (y (+ section-y j))
                                (z (+ section-z k))
                                (block (id->block block-id)))
                            (let ((x (fl& (+ block-radius (cast <fl> x))))
                                  (y (fl& (+ block-radius (cast <fl> y))))
                                  (z (fl& (+ block-radius (cast <fl> z))))
                                  (uv (block-texture-coordinates block))
                                  (rendering (cache-rendering~ block))
                                  (category (get-category~ block)))
                              (let ((visual (get-visual~ block)))
                                (cond (visual
                                       (visual block-id (local-data-ref i j k) i j k x y z uv rendering category add-template add-opaque-cube add-texture-element effective-block-ref effective-data-ref))
                                      ((get-opaque-cube?~ block)
                                       (add-opaque-cube i j k x y z uv uv uv uv uv uv rendering category block-id add-template))
                                      ((get-water-cube?~ block)
                                       (add-water-cube i j k x y z uv uv uv uv uv uv rendering category block-id add-template))
                                      (else
                                       (add-visual-template block-id (local-data-ref i j k) i j k x y z uv rendering category add-template add-opaque-cube effective-block-ref effective-data-ref)))))))))
                    
                    ;; left
                    (let ((i 0))
                      (loop (for j from 0 to 15)
                            (loop (for k from 0 to 15)
                                  (add i j k))))
                    ;; right
                    (let ((i 15))
                      (loop (for j from 0 to 15)
                            (loop (for k from 0 to 15)
                                  (add i j k))))
                    ;; bottom
                    (let ((j 0))
                      (loop (for i from 1 to 14)
                            (loop (for k from 0 to 15)
                                  (add i j k))))
                    ;; top
                    (let ((j 15))
                      (loop (for i from 1 to 14)
                            (loop (for k from 0 to 15)
                                  (add i j k))))
                    ;; back
                    (let ((k 0))
                      (loop (for i from 1 to 14)
                            (loop (for j from 1 to 14)
                                  (add i j k))))
                    ;; front
                    (let ((k 15))
                      (loop (for i from 1 to 14)
                            (loop (for j from 1 to 14)
                                  (add i j k)))))
                  (let ((opaque (conclude-rendering opaque-rendering))
                        (transparent (conclude-rendering transparent-rendering))
                        (coverage (conclude-rendering coverage-rendering))
                        (water (conclude-rendering water-rendering))
                        (wet (conclude-rendering wet-rendering))
                        (multitexture (conclude-rendering multitexture-rendering))
                        (categorized (and mesh-categories? (conclude-category-renderings))))
                    (with-render-mutex
                      (lambda ()
                        (define (prepare-mesh info)
                          (when info
                            (bind (material triangles vertices neighbors lightmap) info
                              (setup-mesh~ sector)
                              (let ((mesh (get-mesh~ sector)))
                                (allege mesh
                                  (fill-vertices/neighbors~ sector mesh triangles vertices neighbors)
                                  (fill-lightmap~ sector mesh triangles lightmap)
                                  (setup-array~ mesh))))))
                        
                        (define (prepare-other-mesh info)
                          (when info
                            (bind (material triangles vertices neighbors lightmap) info
                              (setup-other-meshes~ sector)
                              (let ((mesh (new Mesh material: material)))
                                (let ((material (get-material~ mesh)))
                                  (table-set! (allege (get-other-meshes~ sector)) material mesh)
                                  (fill-vertices/neighbors~ sector mesh triangles vertices neighbors)
                                  (fill-lightmap~ sector mesh triangles lightmap)
                                  (setup-array~ mesh))))))
                        
                        (define (prepare-categorized-meshes)
                          (when (not-null? categorized)
                            (for-each (lambda (info)
                                        (bind (category material triangles vertices neighbors lightmap) info
                                          (setup-categorized-meshes~ sector)
                                          (let ((mesh (new Mesh material: material)))
                                            (let ((material (get-material~ mesh)))
                                              (table-set! (allege (get-categorized-meshes~ sector)) material mesh)
                                              (fill-vertices/neighbors~ sector mesh triangles vertices neighbors)
                                              (fill-lightmap~ sector mesh triangles lightmap)
                                              (setup-array~ mesh)))))
                                      categorized)))
                        
                        (when (eq? zone (current-zone))
                          (free-mesh~ sector)
                          (prepare-mesh opaque)
                          (prepare-other-mesh transparent)
                          (prepare-other-mesh coverage)
                          (prepare-other-mesh water)
                          (prepare-other-mesh wet)
                          (prepare-other-mesh multitexture)
                          (when mesh-categories?
                            (prepare-categorized-meshes))
                          (refcount-increase~ section)
                          (set-section~ sector section)
                          (when (not-null? texture-elements)
                            (set-texture-elements~ sector texture-elements))
                          (generate-done))))))))))))))


(class Light-Template extends Object
  
  
  (slot shade getter generate)
  (slot s1    getter generate)
  (slot s2    getter generate)
  (slot s3    getter generate)
  (slot s4    getter generate)
  
  
  (method override (initialize shade s1 s2 s3 s4)
    (set! shade~self shade)
    (set! s1~self s1)
    (set! s2~self s2)
    (set! s3~self s3)
    (set! s4~self s4)))


(definition (allocate-light-template shade s1 s2 s3 s4)
  (allocate Light-Template shade s1 s2 s3 s4))


(class Lighted-Template extends Face-Template
  
  
  (method protected virtual (setup-lighting l1 l2 l3 l4)
    )
  
  
  (method protected virtual (iterate-lighting mesher l1 l2 l3 l4 inverse? proc)
    ))


(class Triangle-Template extends Lighted-Template
  
  
  (slot t1 getter generate)
  (slot t2 getter generate)
  (slot t3 getter generate)
  
  
  (method override (initialize texture-coordinates <f32vector> texture-depth triangle <Triangle> t1 t2 t3)
    (nextmethod texture-coordinates texture-depth triangle)
    (set! t1~self t1)
    (set! t2~self t2)
    (set! t3~self t3))
  
  
  (method override (setup-lighting i j k compute-lighting l1 <f32vector> l2 <f32vector> l3 <f32vector> l4 <f32vector>)
    (compute-lighting l1 i j k t1)
    (compute-lighting l2 i j k t2)
    (compute-lighting l3 i j k t3)
    #f)
  
  
  (method override (iterate-lighting mesher l1 l2 l3 l4 inverse? proc)
    (proc mesher l1 l2 l3)))


(class Quad-Template extends Lighted-Template
  
  
  (slot t1 getter generate)
  (slot t2 getter generate)
  (slot t3 getter generate)
  (slot t4 getter generate)
  
  
  (method override (initialize texture-coordinates <f32vector> texture-depth quad <Quad> t1 t2 t3 t4)
    (nextmethod texture-coordinates texture-depth quad)
    (set! t1~self t1)
    (set! t2~self t2)
    (set! t3~self t3)
    (set! t4~self t4))
  
  
  (method override (setup-lighting i j k compute-lighting l1 <f32vector> l2 <f32vector> l3 <f32vector> l4 <f32vector>)
    (compute-lighting l1 i j k t1)
    (compute-lighting l2 i j k t2)
    (compute-lighting l3 i j k t3)
    (compute-lighting l4 i j k t4)
    ;; inversing the quad solves lighting anisotropy
    (let ((a00 (max (f32vector-ref l1 0) (f32vector-ref l1 1)))
          (a01 (max (f32vector-ref l2 0) (f32vector-ref l2 1)))
          (a11 (max (f32vector-ref l3 0) (f32vector-ref l3 1)))
          (a10 (max (f32vector-ref l4 0) (f32vector-ref l4 1))))
      (< (+ a00 a11) (+ a01 a10))))
  
  
  (method override (iterate-lighting mesher l1 l2 l3 l4 inverse? proc)
    (cond ((not inverse?)
           (proc mesher l1 l2 l3)
           (proc mesher l3 l4 l1))
          (else
           (proc mesher l4 l1 l2)
           (proc mesher l2 l3 l4)))))


(definition protected (create-visual-template block <Block> data-id <fx>)
  (let ((templates (new-queue))
        (block-id (get-id~ block))
        (category (get-category~ block))
        (uv (block-texture-coordinates block))
        (generate (get-generate~ block))
        (rendering (cache-rendering~ block))
        (transparent-rendering (transparent-rendering)))
    (define (block-ref i <fx> j <fx> k <fx>) <fx>
      air-id)
    
    (define (data-ref i <fx> j <fx> k <fx>) <fx>
      0)
    
    (define (add-face template <Face-Template> rendering <Rendering> category)
      (enqueue templates template))
    
    (define (add-opaque-cube what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id add-face)
      (add-face (left-side   what i j k x y z left-uv lighting rendering block-id) rendering category)
      (add-face (right-side  what i j k x y z right-uv lighting rendering block-id) rendering category)
      (add-face (bottom-side what i j k x y z bottom-uv lighting rendering block-id) rendering category)
      (add-face (top-side    what i j k x y z top-uv lighting rendering block-id) rendering category)
      (add-face (back-side   what i j k x y z back-uv lighting rendering block-id) rendering category)
      (add-face (front-side  what i j k x y z front-uv lighting rendering block-id) rendering category))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      (allocate-light-template shade
                               (s8vector ax ay az)
                               (s8vector bx by bz)
                               (s8vector cx cy cz)
                               (s8vector dx dy dz)))
    
    (cond (generate
           (generate 'visual block-id data-id 0 0 0 0. 0. 0. uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
          ((get-opaque-cube?~ block)
           (add-opaque-cube 'visual 0 0 0 0. 0. 0. uv uv uv uv uv uv lighting rendering category block-id add-face))
          (else
           (add-cross-faces 'visual 0 0 0 0. 0. 0. uv lighting transparent-rendering category block-id add-face)))
    (list->vector (queue-list templates))))


(definition protected (find-visual-template block-id <fx> data-id <fx>) <vector>
  (let ((block (id->block block-id)))
    (let ((templates (get-visuals~ block)))
      (if (not templates)
          (let ((template (create-visual-template block data-id))
                (templates (make-vector (get-configurations~ block) #f)))
            (vector-set! templates data-id template)
            (set-visuals~ block templates)
            template)
        (or (vector-ref templates data-id)
            (let ((template (create-visual-template block data-id)))
              (vector-set! templates data-id template)
              template))))))


(definition protected (add-visual-template block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> rendering category add-template add-opaque-cube block-ref data-ref)
  (let ((template (find-visual-template block-id data-id)))
    (loop (for template in-vector template)
          (add-template i j k x y z template rendering category))))


;;;
;;;; Physical
;;;


(definition protected (instantiate-physical sector <Sector>)
  (let ((zone (current-zone)))
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region~ zone sector-x sector-y sector-z)))
          (when region
            (let ((region-x (get-x~ region))
                  (region-z (get-z~ region))
                  (section (get-section~ region 'physical sector-x sector-y sector-z))
                  (chunk-index (chunk-index& sector-x sector-z))
                  (truncate-y (get-truncate-y~ zone))
                  (cache-uninitialized 65535))
              (when section
                (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y 0))))
                      (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                      (section-y (* sector-y 16))
                      (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                      (sections <vector> (make-vector 27 #t))
                      (cache <u16vector> (initialize-block-cache cache-uninitialized))
                      (blocks <u8vector> (get-blocks~ section))
                      (data <u8vector> (get-data~ section))
                      (areas (make-table test: eq?))
                      (areas-bounds (sector-areas-bounds~ zone sector)))
                  (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                    (if (and (= a 0)
                             (= b 0)
                             (= c 0))
                        section
                      (let ((index (section-index a b c)))
                        (let ((section (vector-ref sections index)))
                          (if (neq? section #t)
                              section
                            (let ((x (+ sector-x a))
                                  (y (+ sector-y b))
                                  (z (+ sector-z c)))
                              (let ((region (sector-region~ zone x y z)))
                                (let ((section (and region (get-section~ (cast <World-Region> region) 'physical x y z))))
                                  (vector-set! sections index section)
                                  section))))))))
                  
                  (define (section-index a <fx> b <fx> c <fx>) <fx>
                    (+ (* b 9) (* c 3) a 13))
                  
                  (define (local-index i <fx> j <fx> k <fx>) <fx>
                    (+ (* j 256) (* k 16) i))
                  
                  (define (effective-index i <fx> j <fx> k <fx>) <fx>
                    (* (+ (* j 400) (* k 20) i 842) 4))
                  
                  (define (blocks-get section <World-Section>) <u8vector>
                    (get-blocks~ section))
                  
                  (define (data-get section <World-Section>) <u8vector>
                    (get-data~ section))
                  
                  (define (local-block-ref i <fx> j <fx> k <fx>) <fx>
                    (u8vector-ref blocks (local-index i j k)))
                  
                  (define (local-data-ref i <fx> j <fx> k <fx>) <fx>
                    (u4vector-ref data (local-index i j k)))
                  
                  (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                    (let ((index (effective-index i j k)))
                      (let ((value (u16vector-ref cache index)))
                        (if (/= value cache-uninitialized)
                            value
                          (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                            (u16vector-set! cache index value)
                            value)))))
                  
                  (define (effective-data-ref i <fx> j <fx> k <fx>) <fx>
                    (field-ref i j k data-get u4vector-ref 0 0))
                  
                  (define (u4vector-ref field <u8vector> index <fx>) <fx>
                    (let ((byte (u8vector-ref field (quotient index 2))))
                      (if (even? index)
                          (bitwise-and byte #x0F)
                        (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                  
                  (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                    (define (bind-i a <fx> i <fx>)
                      (define (bind-j b <fx> j <fx>)
                        (define (bind-k c <fx> k <fx>)
                          (let ((section (section-ref a b c)))
                            (if (not section)
                                (if (and bottom-section? (= b -1)) bottom empty)
                              (let ((field (get-field section)))
                                (if (not field)
                                    (if (and bottom-section? (= b -1)) bottom empty)
                                  (ref field (local-index i j k)))))))
                        
                        (cond ((< k 0) (bind-k -1 (+ 16 k)))
                              ((> k 15) (bind-k 1 (- k 16)))
                              (else (bind-k 0 k))))
                      
                      (cond ((< j 0) (bind-j -1 (+ 16 j)))
                            ((> j 15) (bind-j 1 (- j 16)))
                            (else (bind-j 0 j))))
                    
                    (cond ((< i 0) (bind-i -1 (+ 16 i)))
                          ((> i 15) (bind-i 1 (- i 16)))
                          (else (bind-i 0 i))))
                  
                  (define (add-template x <fl> y <fl> z <fl> poly <Polygon>)
                    (let ((center (vertex+xyz& (get-center~ poly) x y z)))
                      (let ((index (position-area-index~ zone center)))
                        ;; it is critical for clearing polygons that every
                        ;; areas polygons are registered to belong to the zone
                        (let ((in-sector-index (vector (between (vector-ref areas-bounds 0) (vector-ref index 0) (vector-ref areas-bounds 3))
                                                       (between (vector-ref areas-bounds 1) (vector-ref index 1) (vector-ref areas-bounds 4))
                                                       (between (vector-ref areas-bounds 2) (vector-ref index 2) (vector-ref areas-bounds 5)))))
                          (let ((area (index-area~ zone in-sector-index #f)))
                            ;; quicky for tests
                            (let ((poly (copy-polygon~ poly)))
                              (vertex+xyz! (get-origin~ poly) (get-origin~ poly) x y z)
                              (loop (for vert in-vector (get-vertices~ poly))
                                    (vertex+xyz! vert vert x y z))
                              (set-data2~ poly (+ (get-data2~ poly) x))
                              (set-data3~ poly (+ (get-data3~ poly) y))
                              (set-data4~ poly (+ (get-data4~ poly) z))
                              (table-add areas area poly)))))))
                  
                  (define (add-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-id add-template)
                    (let ((data-id (local-data-ref i j k)))
                      (let ((template (find-physical-template block-id data-id)))
                        (unless (opaque? (effective-block-ref (- i 1) j k)) (add-template x y z (vector-ref template 0)))
                        (unless (opaque? (effective-block-ref (+ i 1) j k)) (add-template x y z (vector-ref template 1)))
                        (unless (opaque? (effective-block-ref i (- j 1) k)) (add-template x y z (vector-ref template 2)))
                        (unless (opaque? (effective-block-ref i (+ j 1) k)) (add-template x y z (vector-ref template 3)))
                        (unless (opaque? (effective-block-ref i j (- k 1))) (add-template x y z (vector-ref template 4)))
                        (unless (opaque? (effective-block-ref i j (+ k 1))) (add-template x y z (vector-ref template 5))))))
                  
                  (define (add-inner-opaque-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-id add-template)
                    (let ((data-id (local-data-ref i j k)))
                      (let ((template (find-physical-template block-id data-id)))
                        (unless (opaque? (local-block-ref (- i 1) j k)) (add-template x y z (vector-ref template 0)))
                        (unless (opaque? (local-block-ref (+ i 1) j k)) (add-template x y z (vector-ref template 1)))
                        (unless (opaque? (local-block-ref i (- j 1) k)) (add-template x y z (vector-ref template 2)))
                        (unless (opaque? (local-block-ref i (+ j 1) k)) (add-template x y z (vector-ref template 3)))
                        (unless (opaque? (local-block-ref i j (- k 1))) (add-template x y z (vector-ref template 4)))
                        (unless (opaque? (local-block-ref i j (+ k 1))) (add-template x y z (vector-ref template 5))))))
                  
                  (define (opaque? block-id <fx>)
                    (let ((block (id->block block-id)))
                      (get-opaque-cube?~ block)))
                  
                  (define (add-water-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-id add-template)
                    (let ((data-id (local-data-ref i j k)))
                      (let ((template (find-physical-template block-id data-id)))
                        (unless (water-opaque? (effective-block-ref (- i 1) j k)) (add-template x y z (vector-ref template 0)))
                        (unless (water-opaque? (effective-block-ref (+ i 1) j k)) (add-template x y z (vector-ref template 1)))
                        (unless (water-opaque? (effective-block-ref i (- j 1) k)) (add-template x y z (vector-ref template 2)))
                        (unless (water-opaque? (effective-block-ref i (+ j 1) k)) (add-template x y z (vector-ref template 3)))
                        (unless (water-opaque? (effective-block-ref i j (- k 1))) (add-template x y z (vector-ref template 4)))
                        (unless (water-opaque? (effective-block-ref i j (+ k 1))) (add-template x y z (vector-ref template 5))))))
                  
                  (define (add-inner-water-cube i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> block-id add-template)
                    (let ((data-id (local-data-ref i j k)))
                      (let ((template (find-physical-template block-id data-id)))
                        (unless (water-opaque? (local-block-ref (- i 1) j k)) (add-template x y z (vector-ref template 0)))
                        (unless (water-opaque? (local-block-ref (+ i 1) j k)) (add-template x y z (vector-ref template 1)))
                        (unless (water-opaque? (local-block-ref i (- j 1) k)) (add-template x y z (vector-ref template 2)))
                        (unless (water-opaque? (local-block-ref i (+ j 1) k)) (add-template x y z (vector-ref template 3)))
                        (unless (water-opaque? (local-block-ref i j (- k 1))) (add-template x y z (vector-ref template 4)))
                        (unless (water-opaque? (local-block-ref i j (+ k 1))) (add-template x y z (vector-ref template 5))))))
                  
                  (define (water-opaque? block-id <fx>)
                    (let ((block (id->block block-id)))
                      (or (get-water-cube?~ block)
                          (get-opaque-cube?~ block))))
                  
                  ;; inner
                  (loop (for j from 1 below 15)
                        (loop (for k from 1 below 15)
                              (loop (for i from 1 below 15)
                                    (let ((block-id (local-block-ref i j k)))
                                      (when (/= block-id air-id)
                                        (let ((x (+ section-x i))
                                              (y (+ section-y j))
                                              (z (+ section-z k))
                                              (block (id->block block-id)))
                                          (let ((x (fl& (+ block-radius (cast <fl> x))))
                                                (y (fl& (+ block-radius (cast <fl> y))))
                                                (z (fl& (+ block-radius (cast <fl> z)))))
                                            (let ((physical (get-physical~ block)))
                                              (cond (physical
                                                     (physical block-id (local-data-ref i j k) i j k x y z add-template effective-block-ref effective-data-ref))
                                                    ((get-opaque-cube?~ block)
                                                     (add-inner-opaque-cube i j k x y z block-id add-template))
                                                    ((get-water-cube?~ block)
                                                     (add-inner-water-cube i j k x y z block-id add-template))
                                                    (else
                                                     (add-physical-template block-id (local-data-ref i j k) i j k x y z add-template effective-block-ref effective-data-ref)))))))))))
                  
                  ;; outer
                  (let ()
                    (define (add i <fx> j <fx> k <fx>)
                      (let ((block-id (local-block-ref i j k)))
                        (when (/= block-id air-id)
                          (let ((x (+ section-x i))
                                (y (+ section-y j))
                                (z (+ section-z k))
                                (block (id->block block-id)))
                            (let ((x (fl& (+ block-radius (cast <fl> x))))
                                  (y (fl& (+ block-radius (cast <fl> y))))
                                  (z (fl& (+ block-radius (cast <fl> z)))))
                              (let ((physical (get-physical~ block)))
                                (cond (physical
                                       (physical block-id (local-data-ref i j k) i j k x y z add-template effective-block-ref effective-data-ref))
                                      ((get-opaque-cube?~ block)
                                       (add-opaque-cube i j k x y z block-id add-template))
                                      ((get-water-cube?~ block)
                                       (add-water-cube i j k x y z block-id add-template))
                                      (else
                                       (add-physical-template block-id (local-data-ref i j k) i j k x y z add-template effective-block-ref effective-data-ref)))))))))
                    
                    ;; left
                    (let ((i 0))
                      (loop (for j from 0 to 15)
                            (loop (for k from 0 to 15)
                                  (add i j k))))
                    ;; right
                    (let ((i 15))
                      (loop (for j from 0 to 15)
                            (loop (for k from 0 to 15)
                                  (add i j k))))
                    ;; bottom
                    (let ((j 0))
                      (loop (for i from 1 to 14)
                            (loop (for k from 0 to 15)
                                  (add i j k))))
                    ;; top
                    (let ((j 15))
                      (loop (for i from 1 to 14)
                            (loop (for k from 0 to 15)
                                  (add i j k))))
                    ;; back
                    (let ((k 0))
                      (loop (for i from 1 to 14)
                            (loop (for j from 1 to 14)
                                  (add i j k))))
                    ;; front
                    (let ((k 15))
                      (loop (for i from 1 to 14)
                            (loop (for j from 1 to 14)
                                  (add i j k)))))
                  (when (eq? zone (current-zone))
                    (iterate-table areas
                      (lambda (area <Area> polygons)
                        (add-polygons~ area #f polygons #f)))))))))))))


(definition protected (create-physical-template block <Block> data-id <fx>)
  (let ((polygons (new-queue))
        (block-id (get-id~ block))
        (category (get-category~ block))
        (uv (block-texture-coordinates block))
        (generate (get-generate~ block))
        (rendering (cache-rendering~ block))
        (transparent-rendering (transparent-rendering)))
    (define (block-ref i <fx> j <fx> k <fx>) <fx>
      air-id)
    
    (define (data-ref i <fx> j <fx> k <fx>) <fx>
      0)
    
    (define (add-face polygon <Polygon> rendering <Rendering> category)
      (enqueue polygons polygon))
    
    (define (add-opaque-cube what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left-uv <f32vector> right-uv <f32vector> bottom-uv <f32vector> top-uv <f32vector> back-uv <f32vector> front-uv <f32vector> lighting rendering category block-id add-face)
      (add-face (left-side   what i j k x y z left-uv lighting rendering block-id) rendering category)
      (add-face (right-side  what i j k x y z right-uv lighting rendering block-id) rendering category)
      (add-face (bottom-side what i j k x y z bottom-uv lighting rendering block-id) rendering category)
      (add-face (top-side    what i j k x y z top-uv lighting rendering block-id) rendering category)
      (add-face (back-side   what i j k x y z back-uv lighting rendering block-id) rendering category)
      (add-face (front-side  what i j k x y z front-uv lighting rendering block-id) rendering category))
    
    (define (lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
      #f)
    
    (cond (generate
           (generate 'physical block-id data-id 0 0 0 0. 0. 0. uv lighting rendering category add-face add-opaque-cube block-ref data-ref))
          ((get-opaque-cube?~ block)
           (add-opaque-cube 'physical 0 0 0 0. 0. 0. uv uv uv uv uv uv lighting rendering category block-id add-face))
          (else
           (add-cross-faces 'physical 0 0 0 0. 0. 0. uv lighting transparent-rendering category block-id add-face)))
    (list->vector (queue-list polygons))))


(definition protected (find-physical-template block-id <fx> data-id <fx>) <vector>
  (let ((block (id->block block-id)))
    (let ((templates (get-physicals~ block)))
      (if (not templates)
          (let ((template (create-physical-template block data-id))
                (templates (make-vector (get-configurations~ block) #f)))
            (vector-set! templates data-id template)
            (set-physicals~ block templates)
            template)
        (or (vector-ref templates data-id)
            (let ((template (create-physical-template block data-id)))
              (vector-set! templates data-id template)
              template))))))


(definition protected (add-physical-template block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> add-template block-ref data-ref)
  (let ((polygons (find-physical-template block-id data-id)))
    (loop (for poly in-vector polygons)
          (add-template x y z poly))))


;;;
;;;; Coordinates
;;;


(definition protected (index->coordinates index)
  (let ((i (modulo index 16))
        (k (modulo (quotient index 16) 16))
        (j (modulo (quotient (quotient index 16) 16) 16)))
    (list i j k)))


(definition protected (normalize-sector/coordinates sector i <fx> j <fx> k <fx> with-field proc)
  (if (and (between? i 0 15)
           (between? j 0 15)
           (between? k 0 15))
      (proc sector i j k)
    (with-field i j k
      (lambda (section index)
        (let ((sector (get-sector~ section)))
          (bind (i j k) (index->coordinates index)
            (proc sector i j k)))))))


(definition protected (enqueue-sector/coordinates queue sector coordinates with-field)
  (bind (i j k) coordinates
    (normalize-sector/coordinates sector i j k with-field
      (lambda (sector i j k)
        (enqueue queue (list sector i j k))))))


(definition protected (sector/coordinates->location sector <Sector> i <fx> j <fx> k <fx>)
  (let ((index (get-index~ sector)))
    (let ((sector-x (vector-ref index 0))
          (sector-y (vector-ref index 1))
          (sector-z (vector-ref index 2)))
      (vector (+ i (* sector-x 16))
              (+ j (* sector-y 16))
              (+ k (* sector-z 16))))))


(definition protected (section/index->position section index)
  (sector/index->position (get-sector~ section) index))


(definition protected (sector/index->position sector index)
  (bind (i j k) (index->coordinates index)
    (let ((location (sector/coordinates->location sector i j k)))
      (let ((x (vector-ref location 0))
            (y (vector-ref location 1))
            (z (vector-ref location 2)))
        (vertex (+ (cast <fl> x) .5)
                (+ (cast <fl> y) .5)
                (+ (cast <fl> z) .5))))))


(definition protected (position->location pos)
  (let ((x (vertex-x pos))
        (y (vertex-y pos))
        (z (vertex-z pos)))
    (vector (fxround (- x .5))
            (fxround (- y .5))
            (fxround (- z .5)))))


(definition protected (location->position loc)
  (vertex (+ (cast <fl> (vector-ref loc 0)) .5)
          (+ (cast <fl> (vector-ref loc 1)) .5)
          (+ (cast <fl> (vector-ref loc 2)) .5)))


(definition protected (taxicab-distance sector1 <Sector> sector2 <Sector>)
  (let ((index1 (get-index~ sector1))
        (index2 (get-index~ sector2)))
    (+ (abs (- (vector-ref index1 0) (vector-ref index2 0)))
       (abs (- (vector-ref index1 1) (vector-ref index2 1)))
       (abs (- (vector-ref index1 2) (vector-ref index2 2))))))


(definition protected (block-entity-data region <World-Region> sector <Sector> i <fx> j <fx> k <fx>)
  (let ((index (get-index~ sector)))
    (let ((sector-x (vector-ref index 0))
          (sector-z (vector-ref index 2)))
      (let ((chunk <World-Chunk> (get-chunk~ region sector-x sector-z))
            (index (sector/coordinates->location sector i j k)))
        (find-block-entity~ chunk index)))))


(definition protected (block-entity-add region <World-Region> sector <Sector> i <fx> j <fx> k <fx>)
  (let ((index (get-index~ sector)))
    (let ((sector-x (vector-ref index 0))
          (sector-z (vector-ref index 2)))
      (let ((chunk <World-Chunk> (get-chunk~ region sector-x sector-z))
            (index (sector/coordinates->location sector i j k)))
        (add-block-entity~ chunk index)))))


;;;
;;;; Components
;;;


(definition protected (new-repeater sector i j k delay power? with-field)
  (normalize-sector/coordinates sector i j k with-field
    (lambda (sector i j k)
      (new Repeater sector i j k delay power?))))


(definition protected (new-pressure-plate sector i j k delay actor with-field)
  (normalize-sector/coordinates sector i j k with-field
    (lambda (sector i j k)
      (new Pressure-Plate sector i j k delay actor))))


(class Redstone-Component extends Object
  
  
  (slot sector getter generate)
  (slot i      getter generate)
  (slot j      getter generate)
  (slot k      getter generate)
  (slot delay  accessors generate)
  
  
  (method override (initialize sector i j k delay)
    (set! sector~self sector)
    (set! i~self i)
    (set! j~self j)
    (set! k~self k)
    (set! delay~self delay))
  
  (method (location)
    (list sector i j k)))


(class Pressure-Plate extends Redstone-Component
  
  
  (slot colliders accessors generate)
  
  
  (method override (initialize sector i j k delay actor)
    (nextmethod sector i j k delay)
    (set! colliders~self (cons actor '()))))


(class Repeater extends Redstone-Component
  
  
  (slot power? accessors generate)
  
  
  (method override (initialize sector i j k delay power?)
    (nextmethod sector i j k delay)
    (set! power?~self power?)))


;;;
;;;; Spawner
;;;


(class Spawner extends Object
  
  
  (slot sector          getter generate)
  (slot coordinates     getter generate)
  (slot time-since-last accessors generate)
  (slot time-for-spawn  accessors generate)
  (slot creature-count  accessors generate)
  (slot position        getter generate)
  
  
  (method override (initialize sector coordinates time-since-last time-for-spawn creature-count position)
    (set! sector~self sector)
    (set! coordinates~self coordinates)
    (set! time-since-last~self time-since-last)
    (set! time-for-spawn~self time-for-spawn)
    (set! creature-count~self creature-count)
    (set! position~self position)))


;;;
;;;; Burnout
;;;


@code-to-implement-redstone-torch-burnout (
(class Powerer extends Object
  
  
  (slot i    getter generate)
  (slot j    getter generate)
  (slot time getter generate)
  
  
  (method override (initialize i j time)
    (set! i~self i)
    (set! j~self j)
    (set! time~self time)))


(define burnout-delay
  3)


(define last-torches
  (list #f))


(define (add-torch powerer)
  (set-cdr! last-torches (cons powerer (cdr last-torches))))


(define (count-powerings i j time)
  (define (powering? powerer)
    (and (= (get-i~ powerer) i)
         (= (get-j~ powerer) j)))
  
  (define (past-delay? powerer)
    (> (- time (get-time~ powerer)) burnout-delay))
  
  (let (iter (scan last-torches) (count 0))
    (let ((torches (cdr scan)))
      (if (null? torches)
          count
        (let ((torch (car torches)))
          (if (past-delay? torch)
              (begin
                (set-cdr! scan '())
                count)
            (iter (cdr scan) (if (powering? torch) (+ count 1) count))))))))


(add-torch (new Powerer 1 2 10)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 10)         (debug 'count (length (cdr last-torches)))
(add-torch (new Powerer 1 2 11)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 11)         (debug 'count (length (cdr last-torches)))
(add-torch (new Powerer 1 2 14)) (debug 'add (length (cdr last-torches)))
(count-powerings 1 2 14)         (debug 'count (length (cdr last-torches)))
(count-powerings 1 2 20)         (debug 'count (length (cdr last-torches))))


;;;
;;;; Actions
;;;


(definition protected block-hook
  #f)


(definition public (register-block-hook hook)
  (set! block-hook hook))


(definition public (invoke-block-hook pos)
  (when block-hook
    (block-hook pos)))


(definition protected block-actions
  (make-table test: equal?))


(definition public (registered-block-action pos)
  (table-ref block-actions pos #f))


(definition public (register-block-action pos action)
  (if (pair? pos)
      (for-each (lambda (pos)
                  (table-set! block-actions pos action))
                pos)
    (table-set! block-actions pos action)))


(definition public (invoke-block-action pos)
  (let ((action (registered-block-action pos)))
    (when action
      (action)
      #t)))


;;;
;;;; Add
;;;


(definition (make-quad-face what rendering <Rendering> texture-coordinates texture-depth quad l1 l2 l3 l4)
  (case what
    ((physical)
     quad)
    ((visual)
     (new Quad-Template texture-coordinates texture-depth quad l1 l2 l3 l4))
    (else
     (new Quad-Face (get-material~ rendering) texture-coordinates texture-depth quad l1 l2 l3 l4))))


(definition (make-triangle-face what rendering <Rendering> texture-coordinates texture-depth triangle l1 l2 l3)
  (case what
    ((physical)
     triangle)
    ((visual)
     (new Triangle-Template texture-coordinates texture-depth triangle l1 l2 l3))
    (else
     (new Triangle-Face (get-material~ rendering) texture-coordinates texture-depth triangle l1 l2 l3))))


(definition (make-block-quad v1 v2 v3 v4 block-id <fx> x <fl> y <fl> z <fl>) <Quad>
  (let ((quad <Quad> (make-quad #f v1 v2 v3 v4)))
    (set-data1~ quad (cast <fl> block-id))
    (set-data2~ quad x)
    (set-data3~ quad y)
    (set-data4~ quad z)
    quad))


(definition (make-block-triangle v1 v2 v3 block-id <fx> x <fl> y <fl> z <fl>) <Triangle>
  (let ((triangle <Triangle> (make-triangle #f v1 v2 v3)))
    (set-data1~ triangle (cast <fl> block-id))
    (set-data2~ triangle x)
    (set-data3~ triangle y)
    (set-data4~ triangle z)
    triangle))


(definition (generic-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tt tl tb tr tb tr tt)))


;; 90 degrees to the left
(definition (rotate-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tl tb tr tb tr tt tl tt)))


;; 90 degrees to the right
(definition (rotate-inverse-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tl tt tl tb tr tb)))


(definition (rotate-other-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tb tr tt tl tt tl tb)))


(definition (transpose-coordinates uv <f32vector>) <f32vector>
  (let ((tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv)))
    (f32vector tr tt tr tb tl tb tl tt)))


(definition (generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <f64vector> v2 <f64vector> v3 <f64vector> v4 <f64vector> uv <f32vector> uv-coordinates lighting shade rendering block-id matrix)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3))
        (v4 (matrix-transform-3x4 matrix v4)))
    (let ((quad (make-block-quad (vertex+xyz v1 x y z)
                                 (vertex+xyz v2 x y z)
                                 (vertex+xyz v3 x y z)
                                 (vertex+xyz v4 x y z)
                                 block-id
                                 x
                                 y
                                 z)))
      (let ((normal (get-normal~ quad)))
        (make-quad-face what
                        rendering
                        (uv-coordinates uv)
                        (uv-depth uv)
                        quad
                        (generic-lighting i j k v1 normal lighting shade)
                        (generic-lighting i j k v2 normal lighting shade)
                        (generic-lighting i j k v3 normal lighting shade)
                        (generic-lighting i j k v4 normal lighting shade))))))


(definition (generic-triangle what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> v1 <f64vector> v2 <f64vector> v3 <f64vector> uv <f32vector> uv-coordinates lighting shade rendering block-id matrix)
  (let ((v1 (matrix-transform-3x4 matrix v1))
        (v2 (matrix-transform-3x4 matrix v2))
        (v3 (matrix-transform-3x4 matrix v3)))
    (let ((triangle (make-block-triangle (vertex+xyz v1 x y z)
                                         (vertex+xyz v2 x y z)
                                         (vertex+xyz v3 x y z)
                                         block-id
                                         x
                                         y
                                         z)))
      (let ((normal (get-normal~ triangle)))
        (make-triangle-face what
                            rendering
                            (uv-coordinates uv)
                            (uv-depth uv)
                            triangle
                            (generic-lighting i j k v1 normal lighting shade)
                            (generic-lighting i j k v2 normal lighting shade)
                            (generic-lighting i j k v3 normal lighting shade))))))


(constant inline 1/SQRT2 <fl>
  (/ 1. (sqrt 2.)))

;; minimal value for door to clear itself
(constant inline ambient-forward <fl>
  .3)

;; minimal value for stair top to clear itself and fence to be uniform
(constant inline ambient-angled <fl>
  .9)


@debugging
(definition protected (get-ambient-forward/angled)
  (values ambient-forward ambient-angled))

@debugging
(definition protected (set-ambient-forward/angled forward angled)
  (set! ambient-forward forward)
  (set! ambient-angled angled))


(definition protected (generic-lighting i <fx> j <fx> k <fx> vert <f64vector> normal <f64vector> lighting shade)
  (if (u8vector? lighting)
      lighting
    ;; the .5 is because the shape is centered at 0 0 0
    (let ((adjusted (vertex+& (vertex+& vert (vertex& .5 .5 .5)) (vertex-scalar*& normal ambient-forward)))
          (r1 (make-vertex&))
          (r2 (make-vertex&))
          (r3 (make-vertex&))
          (r4 (make-vertex&)))
      (define (ambient-rays!)
        (let ((up (roll-free-up& normal)))
          (let ((right (cross-product& normal up)))
            (let ((advance (vertex-scalar*& normal 1/SQRT2)))
              (let ((up/+2 (vertex-scalar/& up  2.))
                    (up/-2 (vertex-scalar/& up -2.))
                    (right/+2 (vertex-scalar/& right  2.))
                    (right/-2 (vertex-scalar/& right -2.)))
                (vertex+! r1 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/+2)) ambient-angled))
                (vertex+! r2 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/+2 right/-2)) ambient-angled))
                (vertex+! r3 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/-2)) ambient-angled))
                (vertex+! r4 adjusted (vertex-scalar*& (vertex+& advance (vertex+& up/-2 right/+2)) ambient-angled)))))))
      
      (ambient-rays!)
      (lighting shade i j k
        (fxfloor (vertex-x r1)) (fxfloor (vertex-y r1)) (fxfloor (vertex-z r1))
        (fxfloor (vertex-x r2)) (fxfloor (vertex-y r2)) (fxfloor (vertex-z r2))
        (fxfloor (vertex-x r3)) (fxfloor (vertex-y r3)) (fxfloor (vertex-z r3))
        (fxfloor (vertex-x r4)) (fxfloor (vertex-y r4)) (fxfloor (vertex-z r4))))))


(constant inline no-shade     <fl> 1.)
(constant inline top-shade    <fl> 1.)
(constant inline bottom-shade <fl> .5)
(constant inline left-shade   <fl> .6)
(constant inline right-shade  <fl> .6)
(constant inline back-shade   <fl> .8)
(constant inline front-shade  <fl> .8)


(definition public (left-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (left-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (left-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front) block-id x y z)
                  (lighting left-shade i j k -1  0 -1 -1  0  0 -1  1 -1 -1  1  0)
                  (lighting left-shade i j k -1 -1 -1 -1 -1  0 -1  0 -1 -1  0  0)
                  (lighting left-shade i j k -1 -1  0 -1 -1  1 -1  0  0 -1  0  1)
                  (lighting left-shade i j k -1  0  0 -1  0  1 -1  1  0 -1  1  1)))


;; simple solution for shapes that don't work well with ambient vectors
(definition (uniform-lighting i <fx> j <fx> k <fx> lighting)
  (lighting no-shade i j k 0 0 1 0 0 -1 1 0 0 -1 0 0))


(definition public (left-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left top front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting left-shade rendering block-id matrix)))


(definition public (left-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex left (first top) back))
        (v2 (vertex left bottom back))
        (v3 (vertex left bottom front))
        (v4 (vertex left (second top) front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting left-shade rendering block-id (make-identity-matrix))))


(definition public (right-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (right-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (right-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back) block-id x y z)
                  (lighting right-shade i j k  1  0  0  1  0  1  1  1  0  1  1  1)
                  (lighting right-shade i j k  1 -1  0  1 -1  1  1  0  0  1  0  1)
                  (lighting right-shade i j k  1 -1 -1  1 -1  0  1  0 -1  1  0  0)
                  (lighting right-shade i j k  1  0 -1  1  0  0  1  1 -1  1  1  0)))


(definition public (right-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex right top front))
        (v2 (vertex right bottom front))
        (v3 (vertex right bottom back))
        (v4 (vertex right top back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting right-shade rendering block-id matrix)))


(definition public (right-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex right (first top) front))
        (v2 (vertex right bottom front))
        (v3 (vertex right bottom back))
        (v4 (vertex right (second top) back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting right-shade rendering block-id (make-identity-matrix))))


(definition public (bottom-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (bottom-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front) block-id x y z)
                  (lighting bottom-shade i j k -1 -1  0 -1 -1  1  0 -1  0  0 -1  1)
                  (lighting bottom-shade i j k -1 -1 -1 -1 -1  0  0 -1 -1  0 -1  0)
                  (lighting bottom-shade i j k  0 -1 -1  0 -1  0  1 -1 -1  1 -1  0)
                  (lighting bottom-shade i j k  0 -1  0  0 -1  1  1 -1  0  1 -1  1)))


(definition public (bottom-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left bottom front))
        (v2 (vertex left bottom back))
        (v3 (vertex right bottom back))
        (v4 (vertex right bottom front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting bottom-shade rendering block-id matrix)))


(definition public (top-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (top-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (top-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back) block-id x y z)
                  (lighting top-shade i j k -1  1 -1 -1  1  0  0  1 -1  0  1  0)
                  (lighting top-shade i j k -1  1  0 -1  1  1  0  1  0  0  1  1)
                  (lighting top-shade i j k  0  1  0  0  1  1  1  1  0  1  1  1)
                  (lighting top-shade i j k  0  1 -1  0  1  0  1  1 -1  1  1  0)))

(definition public (top-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top back))
        (v2 (vertex left top front))
        (v3 (vertex right top front))
        (v4 (vertex right top back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting top-shade rendering block-id matrix)))


(definition public (top-sloped what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex left (first top) back))
        (v2 (vertex left (second top) front))
        (v3 (vertex right (third top) front))
        (v4 (vertex right (fourth top) back))
        (matrix (make-identity-matrix)))
    (define (needs-triangles?)
      (/= (/ (+ (vertex-y v1) (vertex-y v3)) 2.) (/ (+ (vertex-y v2) (vertex-y v4)) 2.)))
    
    (if (needs-triangles?)
        (list
          (generic-triangle what i j k x y z v1 v2 v4 uv uv-coordinates lighting top-shade rendering block-id matrix)
          (generic-triangle what i j k x y z v3 v4 v2 uv uv-coordinates lighting top-shade rendering block-id matrix))
      (list
        (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting top-shade rendering block-id matrix)))))


(definition public (back-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (back-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (back-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back) block-id x y z)
                  (lighting back-shade i j k  0  0 -1  0  1 -1  1  0 -1  1  1 -1)
                  (lighting back-shade i j k  0 -1 -1  0  0 -1  1 -1 -1  1  0 -1)
                  (lighting back-shade i j k -1 -1 -1 -1  0 -1  0 -1 -1  0  0 -1)
                  (lighting back-shade i j k -1  0 -1 -1  1 -1  0  0 -1  0  1 -1)))


(definition public (back-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex right top back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left top back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting back-shade rendering block-id matrix)))


(definition public (back-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex right (first top) back))
        (v2 (vertex right bottom back))
        (v3 (vertex left bottom back))
        (v4 (vertex left (second top) back)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting back-shade rendering block-id (make-identity-matrix))))


(definition public (front-side what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering block-id)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (front-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id)))


(definition public (front-face what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (make-quad-face what
                  rendering
                  (uv-coordinates uv)
                  (uv-depth uv)
                  (make-block-quad (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front) block-id x y z)
                  (lighting front-shade i j k -1  0  1 -1  1  1  0  0  1  0  1  1)
                  (lighting front-shade i j k -1 -1  1 -1  0  1  0 -1  1  0  0  1)
                  (lighting front-shade i j k  0 -1  1  0  0  1  1 -1  1  1  0  1)
                  (lighting front-shade i j k  0  0  1  0  1  1  1  0  1  1  1  1)))


(definition public (front-generic what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <fl> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id matrix)
  (let ((v1 (vertex left top front))
        (v2 (vertex left bottom front))
        (v3 (vertex right bottom front))
        (v4 (vertex right top front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting front-shade rendering block-id matrix)))


(definition public (front-generic-quad what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> left <fl> right <fl> bottom <fl> top <f64vector> back <fl> front <fl> uv <f32vector> uv-coordinates lighting rendering block-id)
  (let ((v1 (vertex left (first top) front))
        (v2 (vertex left bottom front))
        (v3 (vertex right bottom front))
        (v4 (vertex right (second top) front)))
    (generic-quad what i j k x y z v1 v2 v3 v4 uv uv-coordinates lighting front-shade rendering block-id (make-identity-matrix))))


(definition (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)
  (add-face (left-generic   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (right-generic  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (bottom-generic what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (top-generic    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (back-generic   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category)
  (add-face (front-generic  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id matrix) rendering category))


(definition public (add-cube-faces what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)))


(definition public (add-cross-faces what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector> lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius)))
        (tl (uv-left uv))
        (tt (uv-top uv))
        (tr (uv-right uv))
        (tb (uv-bottom uv))
        (texture-depth (uv-depth uv))
        (lighting (uniform-lighting i j k lighting)))
    (add-face (make-quad-face what
                              rendering
                              (f32vector tl tt tl tb tr tb tr tt)
                              texture-depth
                              (make-block-quad (vertex right top back) (vertex right bottom back) (vertex left bottom front) (vertex left top front) block-id x y z)
                              lighting lighting lighting lighting)
              rendering
              category)
    (add-face (make-quad-face what
                              rendering
                              (f32vector tl tt tl tb tr tb tr tt)
                              texture-depth
                              (make-block-quad (vertex right top front) (vertex right bottom front) (vertex left bottom back) (vertex left top back) block-id x y z)
                              lighting lighting lighting lighting)
              rendering
              category)))


(definition (add-torch what block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref top-texture bottom-texture)
  (define (position-torch proc)
    (let ((margin .32))
      (ecase data-id
        ((1) (proc (- margin) 0.))
        ((2) (proc margin 0.))
        ((3) (proc 0. (- margin)))
        ((4) (proc 0. margin))
        (else (proc 0. 0.)))))
  
  (position-torch
    (lambda (dx dz)
      (let ((margin 1m)
            (left (- x block-radius))
            (right (+ x block-radius))
            (bottom (- y block-radius))
            (top (+ y block-radius))
            (back (- z block-radius))
            (front (+ z block-radius))
            (top-uv (get-coordinates top-texture))
            (bottom-uv (get-coordinates bottom-texture)))
        (add-face (top-face    what i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) top-uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (bottom-face what i j k x y z (+ dx (- x margin)) (+ dx (+ x margin)) bottom (+ y (* 2 margin)) (+ dz (- z margin)) (+ dz (+ z margin)) bottom-uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (left-face   what i j k x y z (+ dx (- x margin)) (+ dx right) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (right-face  what i j k x y z (+ dx left) (+ dx (+ x margin)) bottom top (+ dz back) (+ dz front) uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (back-face   what i j k x y z (+ dx left) (+ dx right) bottom top (+ dz (- z margin)) (+ dz front) uv generic-coordinates lighting rendering block-id) rendering category)
        (add-face (front-face  what i j k x y z (+ dx left) (+ dx right) bottom top (+ dz back) (+ dz (+ z margin)) uv generic-coordinates lighting rendering block-id) rendering category)))))


(definition (add-button what block-id data-id i j k x y z uv lighting rendering category add-face add-opaque-cube block-ref data-ref)
  (define (position-button proc)
    (let ((orientation (bitwise-and data-id #b111))
          (depth (if (bit-set? 3 data-id) 1m 2m))
          (margin 3m)
          (thick 2m)
          (thin 1m))
      (ecase orientation
        ((0) (proc (- x margin) (+ x margin) (- (+ y block-radius) depth) (+ y block-radius) (- z thick) (+ z thick)))
        ((1) (proc (- x block-radius) (+ (- x block-radius) depth) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((2) (proc (- (+ x block-radius) depth) (+ x block-radius) (- y thick) (+ y thick) (- z margin) (+ z margin)))
        ((3) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- z block-radius) (+ (- z block-radius) depth)))
        ((4) (proc (- x margin) (+ x margin) (- y thick) (+ y thick) (- (+ z block-radius) depth) (+ z block-radius)))
        ((5) (proc (- x margin) (+ x margin) (- y block-radius) (+ (- y block-radius) depth) (- z thick) (+ z thick))))))
  
  (position-button
    (lambda (left right bottom top back front)
      (add-face (left-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (right-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (back-face   what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
      (add-face (front-face  what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category))))


(definition block-models
  (make-table))

(definition (cache-block-models filename)
  (or (table-ref block-models filename #f)
      (begin
        (set-current-directory (new-directory~ {Directory Yownu-World "assets" "minecraft" "models"} resolution-string))
        (if (file-exists? filename)
            (let ((models (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "models"} (list resolution-string filename)))))
              (unless (table-ref models "parent" #f)
                (table-set! block-models filename models))
              models)
          (let ((models (load-json (new-file~ {Directory Yownu-World "assets" "minecraft" "models" "minecraft"} filename))))
            (unless (table-ref models "parent" #f)
              (table-set! block-models filename models))
            models)))))

(definition resolution-string
  (case (world-setting 'world.tile-resolution 128)
    ((16) "16x16")
    ((32) "32x32")
    ((64) "64x64")
    (else "128x128")))


(definition (add-json-model what filename block-id data-id i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category add-face add-opaque-cube block-ref data-ref y-rotation x-rotation)
  (define (read-json-model proc (file #f) (previous-textures #f))
    (let ((models (cache-block-models (or file filename))))
      (let ((has-parent? (table-ref models "parent" #f))
            (textures (or (table-ref models "textures" #f) previous-textures)))
        (when (and previous-textures (table-ref models "textures" #f))
          (iterate-table-safe textures
            (lambda (key value)
              (table-set! textures key (or (table-ref previous-textures (string-trailer value #\#) #f) value))))
          (iterate-table previous-textures
            (lambda (key value)
              (unless (table-ref textures key #f)
                (table-set! textures key value)))))
        (if has-parent?
            (read-json-model proc (string-append (string-trailer has-parent? #\/) ".json") textures)
          (iterate-table-safe textures
            (lambda (key value)
              (table-set! textures key (string-trailer value #\/))))
          (proc (table-ref models "elements") textures)))))
                          
  
  (read-json-model
    (lambda (elements textures) (let ((matrix (matrix-multiply (make-y-rotation-matrix (degree->radian (cast <fl> y-rotation)))
                                                               (make-x-rotation-matrix (degree->radian (cast <fl> x-rotation))))))
        (for-each
          (lambda (element)
            (define (get-file-texture face-name)
              (let ((face (table-ref (table-ref element "faces") face-name #f)))
                (when face
                  (if (/= block-id 55)
                      (let ((texture (get-coordinates (table-ref textures (string-trailer (table-ref face "texture") #\#)))))
                        (bind (l t r b) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref face "uv" '(0 0 16 16)))
                          (uv-rect texture l t r b)))
                    (let ((texture-name (string-trailer (table-ref face "texture") #\#)))
                      (unless (ends-with? texture-name "overlay")
                        (let ((texture (get-coordinates (string-append (table-ref textures texture-name) "_0" @redstone-color(->string data-id)))))
                          (bind (l t r b) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref face "uv"))
                            (uv-rect texture l t r b)))))))))
            
            (define (get-texture-rotation face-name)
              (let ((face (table-ref (table-ref element "faces") face-name #f)))
                (when face
                  (let ((rot (or (table-ref face "rotation" #f) 0)))
                    (case rot
                      ((0)   generic-coordinates)
                      ((90)  rotate-inverse-coordinates)
                      ((180) rotate-other-coordinates)
                      ((270) rotate-coordinates))))))
            
            (define (get-element-matrix)
              (let ((rotation (table-ref element "rotation" #f)))
                (if rotation
                    (bind (x y z) (map (lambda (r) (/ (cast <fl> r) 16.)) (table-ref rotation "origin"))
                      (let ((origin (vertex (- .5 x) (- .5 y) (- .5 z)))
                            (rotation-matrix (case (string->symbol (table-ref rotation "axis"))
                                               ((x) (make-x-rotation-matrix (degree->radian (cast <fl> (table-ref rotation "angle")))))
                                               ((y) (make-y-rotation-matrix (- (degree->radian (cast <fl> (table-ref rotation "angle"))))))
                                               ((z) (make-z-rotation-matrix (- (degree->radian (cast <fl> (table-ref rotation "angle")))))))))
                        (matrix-multiply (make-translation-matrix (vertex-negate origin))
                                         (matrix-multiply rotation-matrix (make-translation-matrix origin)))))
                  (make-identity-matrix))))
            
            (bind (a b c) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref element "from"))
              (bind (d e f) (map (lambda (x) (/ (cast <fl> x) 16.)) (table-ref element "to"))
                (unless (and (= a d) (= b e) (= c f))
                  (let ((left (- a .5))
                        (right (- d .5))
                        (bottom (- b .5))
                        (top (- e .5))
                        (back (- c .5))
                        (front (- f .5))
                        (left-uv (get-file-texture "west"))
                        (right-uv (get-file-texture "east"))
                        (bottom-uv (get-file-texture "down"))
                        (top-uv (get-file-texture "up"))
                        (back-uv (get-file-texture "north"))
                        (front-uv (get-file-texture "south"))
                        (left-rotation (get-texture-rotation "west"))
                        (right-rotation (get-texture-rotation "east"))
                        (bottom-rotation (get-texture-rotation "down"))
                        (top-rotation (get-texture-rotation "up"))
                        (back-rotation (get-texture-rotation "north"))
                        (front-rotation (get-texture-rotation "south"))
                        (matrix (matrix-multiply matrix (get-element-matrix))))
                    (when left-uv   (add-face (left-generic   what i j k x y z left right bottom top back front left-uv left-rotation lighting rendering block-id matrix) rendering category))
                    (when right-uv  (add-face (right-generic  what i j k x y z left right bottom top back front right-uv right-rotation lighting rendering block-id matrix) rendering category))
                    (when bottom-uv (add-face (bottom-generic what i j k x y z left right bottom top back front bottom-uv bottom-rotation lighting rendering block-id matrix) rendering category))
                    (when top-uv    (add-face (top-generic    what i j k x y z left right bottom top back front top-uv top-rotation lighting rendering block-id matrix) rendering category))
                    (when back-uv   (add-face (back-generic   what i j k x y z left right bottom top back front back-uv back-rotation lighting rendering block-id matrix) rendering category))
                    (when front-uv  (add-face (front-generic  what i j k x y z left right bottom top back front front-uv front-rotation lighting rendering block-id matrix) rendering category)))))))
          elements)))))


(definition (add-stairs what data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category block-id add-face)
  (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (case (bitwise-and data-id #b11)
                                                         ((3) (vertex&  0. 0. -1.))
                                                         ((2) (vertex&  0. 0.  1.))
                                                         ((1) (vertex& -1. 0.  0.))
                                                         ((0) (vertex&  1. 0.  0.)))))))
    ;; bottom
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom (fl& (- block-radius)))
          (top 0.)
          (back (fl& (- block-radius)))
          (front (fl& (+ block-radius))))
      (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face))
    ;; top
    (let ((left (fl& (- block-radius)))
          (right (fl& (+ block-radius)))
          (bottom 0.)
          (top (fl& (+ block-radius)))
          (back 0.)
          (front (fl& (+ block-radius))))
      (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face))))


(definition (fence-configuration i <fx> j <fx> k <fx> block-ref connects)
  (define (connect? block-id <fx>)
    (memv? block-id connects))
  
  (bitwise-ior
    ;; left
    (if (connect? (block-ref (- i 1) j k)) 1 0)
    ;; right
    (if (connect? (block-ref (+ i 1) j k)) 2 0)
    ;; back
    (if (connect? (block-ref i j (- k 1))) 4 0)
    ;; front
    (if (connect? (block-ref i j (+ k 1))) 8 0)))


(definition (add-fence what data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv <f32vector+> lighting rendering category block-id add-face block-ref)
  (let ((matrix (make-lookat-matrix& (horizon-lookat&^ (vertex&  0. 0.  1.)))))
    (define (add-trunk)
      (let ((left (- .1))
            (right (+ .1))
            (bottom (- block-radius))
            (top (+ block-radius))
            (back (- .1))
            (front (+ .1)))
        (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
    
    (define (add-branches left <fl> right <fl> back <fl> front <fl>)
      ;; upper
      (let ((bottom (- .35 .075))
            (top (+ .35 .075)))
        (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face))
      ;; lower
      (let ((bottom (- .075))
            (top (+ .075)))
        (add-cuboid-generic what i j k x y z left right bottom top back front uv lighting rendering category block-id matrix add-face)))
    
    ;; trunk
    (add-trunk)
    ;; left
    (when (bit-set? 0 data-id)
      (add-branches (- block-radius) -.1 (- .075) (+ .075)))
    ;; right
    (when (bit-set? 1 data-id)
      (add-branches .1 (+ block-radius) (- .075) (+ .075)))
    ;; back
    (when (bit-set? 2 data-id)
      (add-branches (- .075) (+ .075) (- block-radius) -.1))
    ;; front
    (when (bit-set? 3 data-id)
      (add-branches (- .075) (+ .075) .1 (+ block-radius)))))


(definition (add-slab what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv side-uv lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top y)
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (right-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (bottom-face what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (top-face    what i j k x y z left right bottom top back front uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (back-face   what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)
    (add-face (front-face  what i j k x y z left right bottom top back front side-uv generic-coordinates lighting rendering block-id) rendering category)))


(definition (add-sloped what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category block-id add-face horizon)
  (let ((left (fl& (- block-radius)))
        (right (fl& (+ block-radius)))
        (bottom (fl& (- block-radius)))
        (top (fl& (+ block-radius)))
        (back (fl& (- block-radius)))
        (front (fl& (+ block-radius))))
    (let ((v1 (vertex left top back))
          (v2 (vertex left bottom front))
          (v3 (vertex right bottom front))
          (v4 (vertex right top back))
          (matrix (make-lookat-matrix& (horizon-lookat&^ horizon))))
      (add-face (generic-quad what i j k x y z v1 v2 v3 v4 uv generic-coordinates lighting no-shade rendering block-id matrix) rendering category))))


(definition (add-rail what data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv lighting rendering category block-id add-face)
  (case data-id
    ((0) (add-bottom what i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
    ((1) (add-bottom what i j k x y z uv rotate-coordinates lighting rendering category block-id add-face))
    ((2) (add-sloped what i j k x y z uv lighting rendering category block-id add-face (vertex& -1. 0.  0.)))
    ((3) (add-sloped what i j k x y z uv lighting rendering category block-id add-face (vertex&  1. 0.  0.)))
    ((4) (add-sloped what i j k x y z uv lighting rendering category block-id add-face (vertex&  0. 0.  1.)))
    ((5) (add-sloped what i j k x y z uv lighting rendering category block-id add-face (vertex&  0. 0. -1.)))
    ((6) (add-bottom what i j k x y z (get-coordinates "rail_normal_turned") generic-coordinates lighting rendering category block-id add-face))
    ((7) (add-bottom what i j k x y z (get-coordinates "rail_normal_turned") rotate-coordinates lighting rendering category block-id add-face))
    ((8) (add-bottom what i j k x y z (get-coordinates "rail_normal_turned") rotate-other-coordinates lighting rendering category block-id add-face))
    ((9) (add-bottom what i j k x y z (get-coordinates "rail_normal_turned") rotate-inverse-coordinates lighting rendering category block-id add-face))))


(definition (add-rail-gadget what data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-powered lighting rendering category block-id add-face)
  (let ((powered? (bit-set? 3 data-id)))
    (let ((uv (if powered? uv-powered uv)))
      (case (bitwise-and data-id #b111)
        ((0) (add-bottom what i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
        ((1) (add-bottom what i j k x y z uv rotate-coordinates lighting rendering category block-id add-face))
        ((2) (add-sloped what i j k x y z uv lighting rendering category block-id add-face (vertex& -1. 0.  0.)))
        ((3) (add-sloped what i j k x y z uv lighting rendering category block-id add-face (vertex&  1. 0.  0.)))
        ((4) (add-sloped what i j k x y z uv lighting rendering category block-id add-face (vertex&  0. 0.  1.)))
        ((5) (add-sloped what i j k x y z uv lighting rendering category block-id add-face (vertex&  0. 0. -1.)))))))


(definition add-epsilon <fl>
  .01)


(definition (add-left what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (right-face what i j k x y z left (+ left add-epsilon) bottom top back front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-right what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (left-face what i j k x y z (- right add-epsilon) right bottom top back front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-bottom what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (top-face what i j k x y z left right bottom (+ bottom add-epsilon) back front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-top what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (bottom-face what i j k x y z left right (- top add-epsilon) top back front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-back what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (front-face what i j k x y z left right bottom top back (+ back add-epsilon) uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-front what i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category block-id add-face)
  (let ((left (fl& (- x block-radius)))
        (right (fl& (+ x block-radius)))
        (bottom (fl& (- y block-radius)))
        (top (fl& (+ y block-radius)))
        (back (fl& (- z block-radius)))
        (front (fl& (+ z block-radius))))
    (add-face (back-face what i j k x y z left right bottom top (- front add-epsilon) front uv uv-coordinates lighting rendering block-id) rendering category)))


(definition (add-transparent what data-id left right back front i j k x <fl> y <fl> z <fl> uv lighting rendering category block-id add-face)
  (ecase data-id
    ((left)  (add-left  what i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
    ((right) (add-right what i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
    ((back)  (add-back  what i j k x y z uv generic-coordinates lighting rendering category block-id add-face))
    (else    (add-front what i j k x y z uv generic-coordinates lighting rendering category block-id add-face))))


;;;
;;;; Models
;;;


;; hacks to try out blocks rendered with ambient lighting


(definition (generate-model what name block-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv uv-coordinates lighting rendering category add-face)
  (let ((world (current-world)))
    (let ((model (find-model~ world name))
          (center (vertex& x y z)))
      (let ((matrix (make-translation-matrix& center)))
        (let ((polygons (block-polygons-extract #f (get-polygons~ model) matrix block-id x y z)))
          (for-each (lambda (poly)
                      (let ((normal (get-normal~ poly)))
                        (let ((shade (determine-shade normal)))
                          (define (triangle)
                            (make-triangle-face what rendering (uv-coordinates uv) (uv-depth uv) poly
                              (generic-lighting i j k (vertex-& (get-v1~ poly) center) normal lighting shade)
                              (generic-lighting i j k (vertex-& (get-v2~ poly) center) normal lighting shade)
                              (generic-lighting i j k (vertex-& (get-v3~ poly) center) normal lighting shade)))
                          
                          (define (quad)
                            (make-quad-face what rendering (uv-coordinates uv) (uv-depth uv) poly
                              (generic-lighting i j k (vertex-& (get-v1~ poly) center) normal lighting shade)
                              (generic-lighting i j k (vertex-& (get-v2~ poly) center) normal lighting shade)
                              (generic-lighting i j k (vertex-& (get-v3~ poly) center) normal lighting shade)
                              (generic-lighting i j k (vertex-& (get-v4~ poly) center) normal lighting shade)))
                          
                          (add-face (if (is? poly Triangle)
                                        (triangle)
                                      (quad))
                                    rendering
                                    category))))
                    polygons))))))


(definition (determine-shade normal)
  (cond ((vertex=? normal (vertex&  0.  1.  0.)) top-shade)
        ((vertex=? normal (vertex&  0. -1.  0.)) bottom-shade)
        ((vertex=? normal (vertex&  1.  0.  0.)) left-shade)
        ((vertex=? normal (vertex& -1.  0.  0.)) right-shade)
        ((vertex=? normal (vertex&  0.  0.  1.)) back-shade)
        ((vertex=? normal (vertex&  0.  0. -1.)) front-shade)
        (else no-shade))))
