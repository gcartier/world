;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Binary Read
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.binary jazz


(import (jazz.foreign)
        (jazz.io)
        (jazz.platform.types)
        (jazz.zlib)
        (world.foreign))


(c-include "<string.h>")


(c-external (scan-s8 scheme-object int) int8
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    ___return(* (___S8*) (ptr + index));
//#)


(c-external (put-s8 scheme-object int int8) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    * (___S8*) (ptr + index) = ___arg3;
//#)


(c-external (scan-u8 scheme-object int) unsigned-int8
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    ___return(* (___U8*) (ptr + index));
//#)


(c-external (put-u8 scheme-object int unsigned-int8) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    * (___U8*) (ptr + index) = ___arg3;
//#)


(c-external (scan-s16 scheme-object int) int16
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    ___return(* (___S16*) (ptr + index));
//#)


(c-external (put-s16 scheme-object int int16) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    * (___S16*) (ptr + index) = ___arg3;
//#)


;; quick hack hardcoded for little endian machines
(c-external (scan-s16-big-endian scheme-object int) int16
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[2];
    data[1] = *scan++;
    data[0] = *scan++;
    ___return(* (___S16*) data);
//#)


;; quick hack hardcoded for little endian machines
(c-external (put-s16-big-endian scheme-object int int16) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[2];
    * (___S16*) data = ___arg3;
    *scan++ = data[1];
    *scan++ = data[0];
//#)


(c-external (scan-u16 scheme-object int) unsigned-int16
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    ___return(* (___U16*) (ptr + index));
//#)


(c-external (put-u16 scheme-object int unsigned-int16) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    * (___U16*) (ptr + index) = ___arg3;
//#)


(c-external (scan-s32 scheme-object int) int32
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    ___return(* (___S32*) (ptr + index));
//#)


(c-external (put-s32 scheme-object int int32) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    * (___S32*) (ptr + index) = ___arg3;
//#)


;; quick hack hardcoded for little endian machines
(c-external (scan-s32-big-endian scheme-object int) int32
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[4];
    data[3] = *scan++;
    data[2] = *scan++;
    data[1] = *scan++;
    data[0] = *scan++;
    ___return(* (___S32*) data);
//#)


;; quick hack hardcoded for little endian machines
(c-external (put-s32-big-endian scheme-object int int32) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[4];
    * (___S32*) data = ___arg3;
    *scan++ = data[3];
    *scan++ = data[2];
    *scan++ = data[1];
    *scan++ = data[0];
//#)


;; quick hack hardcoded for little endian machines
(c-external (scan-u32-big-endian scheme-object int) unsigned-int32
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[4];
    data[3] = *scan++;
    data[2] = *scan++;
    data[1] = *scan++;
    data[0] = *scan++;
    ___return(* (___U32*) data);
//#)


;; quick hack hardcoded for little endian machines
(c-external (put-u32-big-endian scheme-object int unsigned-int32) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[4];
    * (___U32*) data = ___arg3;
    *scan++ = data[3];
    *scan++ = data[2];
    *scan++ = data[1];
    *scan++ = data[0];
//#)


(c-external (scan-s64 scheme-object int) int64
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    ___return(* (___S64*) (ptr + index));
//#)


(c-external (put-s64 scheme-object int int64) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    * (___S64*) (ptr + index) = ___arg3;
//#)


;; quick hack hardcoded for little endian machines
(c-external (scan-s64-big-endian scheme-object int) int64
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[8];
    data[7] = *scan++;
    data[6] = *scan++;
    data[5] = *scan++;
    data[4] = *scan++;
    data[3] = *scan++;
    data[2] = *scan++;
    data[1] = *scan++;
    data[0] = *scan++;
    ___return(* (___S64*) data);
//#)


;; quick hack hardcoded for little endian machines
(c-external (put-s64-big-endian scheme-object int int64) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[8];
    * (___S64*) data = ___arg3;
    *scan++ = data[7];
    *scan++ = data[6];
    *scan++ = data[5];
    *scan++ = data[4];
    *scan++ = data[3];
    *scan++ = data[2];
    *scan++ = data[1];
    *scan++ = data[0];
//#)


(c-external (scan-float scheme-object int) float
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    ___return(* (float*) (ptr + index));
//#)


(c-external (put-float scheme-object int float) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    * (float*) (ptr + index) = ___arg3;
//#)


(c-external (scan-floats32! scheme-object int scheme-object int) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    float *scan = (float*) (ptr + index);
    float *dest = ___CAST(float*,___BODY(___arg3));
    int count = ___arg4;
    int i;
    for (i = 0; i < count; i++)
        *dest++ = *scan++;
//#)


(c-external (scan-floats64! scheme-object int scheme-object int) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    float *scan = (float*) (ptr + index);
    double *dest = ___CAST(double*,___BODY(___arg3));
    int count = ___arg4;
    int i;
    for (i = 0; i < count; i++)
        *dest++ = *scan++;
//#)


;; quick hack hardcoded for little endian machines
(c-external (scan-float-big-endian scheme-object int) float
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[4];
    data[3] = *scan++;
    data[2] = *scan++;
    data[1] = *scan++;
    data[0] = *scan++;
    ___return(* (float*) data);
//#)


;; quick hack hardcoded for little endian machines
(c-external (put-float-big-endian scheme-object int float) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[4];
    * (float*) data = ___arg3;
    *scan++ = data[3];
    *scan++ = data[2];
    *scan++ = data[1];
    *scan++ = data[0];
//#)


(c-external (scan-double scheme-object int) double
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    ___return(* (double*) (ptr + index));
//#)


(c-external (put-double scheme-object int double) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    * (double*) (ptr + index) = ___arg3;
//#)


;; quick hack hardcoded for little endian machines
(c-external (scan-double-big-endian scheme-object int) double
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[8];
    data[7] = *scan++;
    data[6] = *scan++;
    data[5] = *scan++;
    data[4] = *scan++;
    data[3] = *scan++;
    data[2] = *scan++;
    data[1] = *scan++;
    data[0] = *scan++;
    ___return(* (double*) data);
//#)


;; quick hack hardcoded for little endian machines
(c-external (put-double-big-endian scheme-object int double) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *scan = ptr + index;
    char data[8];
    * (double*) data = ___arg3;
    *scan++ = data[7];
    *scan++ = data[6];
    *scan++ = data[5];
    *scan++ = data[4];
    *scan++ = data[3];
    *scan++ = data[2];
    *scan++ = data[1];
    *scan++ = data[0];
//#)


(c-external (scan-c-string scheme-object int int) char-string
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    int size = ___arg3;
    char str[size];
    memcpy(str, ptr + index, size);
    ___return(str);
//#)


(c-external (put-c-string scheme-object int char-string int int) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *str = ___arg3;
    int strlen = ___arg4;
    int size = ___arg5;
    memcpy(ptr + index, str, strlen + 1);
//#)


(c-external (scan-size-string scheme-object int int) char-string
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    int size = ___arg3;
    char str[size + 1];
    memcpy(str, ptr + index, size);
    str[size] = 0;
    ___return(str);
//#)


(c-external (put-size-string scheme-object int char-string int) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    char *str = ___arg3;
    int size = ___arg4;
    memcpy(ptr + index, str, size);
//#)


(c-external (scan-utf-8-string scheme-object int) UTF-8-string
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    ___return(ptr + index);
//#)


(c-external (put-utf-8-string scheme-object int UTF-8-string int) void
  #/C/
    char *ptr = ___CAST(char*,___BODY(___arg1));
    int index = ___arg2;
    memcpy(ptr + index, ___arg3, ___arg4);
//#)


;;;
;;;; Binary-Reader
;;;


(proclaim (warn optimizations))


(class Binary-Reader extends Object
  
  
  (slot content  <u8vector> getter generate)
  (slot size     <fx>       getter generate)
  (slot position <fx>       getter generate)
  
  
  (method override (initialize self source (compressed?: compressed? #f) (gzip?: gzip? #f))
    (cond ((u8vector? source)
           (set! content source))
          (else
           (let ((u8vec (load-binary source)))
             (set! content (if compressed? (zlib-inflate u8vec gzip?: gzip?) u8vec)))))
    (set! size (u8vector-length content))
    (set! position 0))
  
  
  (method public (more? self bytes <fx>)
    (<= (+ position bytes) size))
  
  
  (method public (<-s8 self) <fx>
    (prog1 (scan-s8 content position)
      (increase! position 1)))
  
  
  (method public (<-u8 self) <fx>
    (prog1 (scan-u8 content position)
      (increase! position 1)))
  
  
  (method public (<-u8vector self size <fx>)
    (prog1 (subu8vector content position (+ position size))
      (increase! position size)))
  
  
  (method public (<-s16 self) <fx>
    (prog1 (scan-s16 content position)
      (increase! position 2)))
  
  
  (method public (<-s16-big-endian self) <fx>
    (prog1 (scan-s16-big-endian content position)
      (increase! position 2)))
  
  
  (method public (<-u16 self) <fx>
    (prog1 (scan-u16 content position)
      (increase! position 2)))
  
  
  (method public (<-s32 self) <int>
    (prog1 (scan-s32 content position)
      (increase! position 4)))
  
  
  (method public (<-s32-big-endian self) <int>
    (prog1 (scan-s32-big-endian content position)
      (increase! position 4)))
  
  
  (method public (<-s64 self) <int>
    (prog1 (scan-s64 content position)
      (increase! position 8)))
  
  
  (method public (<-s64-big-endian self) <int>
    (prog1 (scan-s64-big-endian content position)
      (increase! position 8)))
  
  
  (method public (<-float self) <fl>
    (prog1 (scan-float content position)
      (increase! position float-size)))
  
  
  (method public (<-float-big-endian self) <fl>
    (prog1 (scan-float-big-endian content position)
      (increase! position float-size)))
  
  
  (method public (<-floats32! self vec <f32vector>) <f32vector>
    (let ((len (f32vector-length vec)))
      (scan-floats32! content position vec len)
      (increase! position (* len float-size))
      vec))
  
  
  (method public (<-floats64! self vec <f64vector>) <f64vector>
    (let ((len (f64vector-length vec)))
      (scan-floats64! content position vec len)
      (increase! position (* len float-size))
      vec))
  
  
  (method public (<-double self) <fl>
    (prog1 (scan-double content position)
      (increase! position double-size)))
  
  
  (method public (<-double-big-endian self) <fl>
    (prog1 (scan-double-big-endian content position)
      (increase! position double-size)))
  
  
  (method public (<-c-string self size <fx>)
    (prog1 (scan-c-string content position size)
      (increase! position size)))
  
  
  (method public (<-size-string self size <fx>)
    (prog1 (scan-size-string content position size)
      (increase! position size)))
  
  
  (method public (<-utf-8-string self size <fx>)
    (prog1 (let ((end (+ position size)))
             (if (>= end (u8vector-length content))
                 (scan-utf-8-string content position)
               ;; quick hack add a terminating 0
               (let ((byte (u8vector-ref content end)))
                 (u8vector-set! content end 0)
                 (prog1 (scan-utf-8-string content position)
                   (u8vector-set! content end byte)))))
      (increase! position size))))


;;;
;;;; Binary-Writer
;;;


(class Binary-Writer extends Object
  
  
  (slot file        <File>     getter generate)
  (slot compressed? <bool>     getter generate)
  (slot gzip?       <bool>     getter generate)
  (slot port        <port>     getter generate)
  (slot buffer      <u8vector> getter generate)
  
  
  (method override (initialize self file (maximum: maximum #f) (compressed?: compressed? #f) (gzip?: gzip? #f))
    (set! self.file file)
    (set! self.compressed? compressed?)
    (set! self.gzip? gzip?)
    (set! port (open-u8vector))
    (set! buffer (make-u8vector (or maximum 8))))
  
  
  (method override (destroy self)
    (when file
      (let ((content (get-content self)))
        (call-with-output-file (path-settings file)
          (lambda (port)
            (write-subu8vector content 0 (u8vector-length content) port)))))
    (nextmethod self))
  
  
  (method public (get-content self) <u8vector>
    (let ((content (get-output-u8vector port)))
      (close-port port)
      (if compressed?
          (zlib-deflate content level: 4 gzip?: gzip?)
        content)))
  
  
  (method public (->s8 self val)
    (put-s8 buffer 0 val)
    (write-subu8vector buffer 0 1 port))
  
  
  (method public (->u8 self val)
    (put-u8 buffer 0 val)
    (write-subu8vector buffer 0 1 port))
  
  
  (method public (->s16 self val)
    (put-s16 buffer 0 val)
    (write-subu8vector buffer 0 2 port))
  
  
  (method public (->s16-big-endian self val)
    (put-s16-big-endian buffer 0 val)
    (write-subu8vector buffer 0 2 port))
  
  
  (method public (->u16 self val)
    (put-u16 buffer 0 val)
    (write-subu8vector buffer 0 2 port))
  
  
  (method public (->s32 self val)
    (put-s32 buffer 0 val)
    (write-subu8vector buffer 0 4 port))
  
  
  (method public (->s32-big-endian self val)
    (put-s32-big-endian buffer 0 val)
    (write-subu8vector buffer 0 4 port))
  
  
  (method public (->s64 self val)
    (put-s64 buffer 0 val)
    (write-subu8vector buffer 0 8 port))
  
  
  (method public (->s64-big-endian self val)
    (put-s64-big-endian buffer 0 val)
    (write-subu8vector buffer 0 8 port))
  
  
  (method public (->float self val)
    (put-float buffer 0 val)
    (write-subu8vector buffer 0 4 port))
  
  
  (method public (->floats32 self vec <f32vector>)
    (let ((len (f32vector-length vec)))
      (loop (for i from 0 below len)
            (->float self (f32vector-ref vec i)))))
  
  
  (method public (->floats64 self vec <f64vector>)
    (let ((len (f64vector-length vec)))
      (loop (for i from 0 below len)
            (->float self (f64vector-ref vec i)))))
  
  
  (method public (->float-big-endian self val)
    (put-float-big-endian buffer 0 val)
    (write-subu8vector buffer 0 4 port))
  
  
  (method public (->double self val)
    (put-double buffer 0 val)
    (write-subu8vector buffer 0 8 port))
  
  
  (method public (->double-big-endian self val)
    (put-double-big-endian buffer 0 val)
    (write-subu8vector buffer 0 8 port))
  
  
  (method public (->c-string self str size <fx>)
    (put-c-string buffer 0 str (string-length str) size)
    (write-subu8vector buffer 0 size port))
  
  
  (method public (->size-string self str size <fx>)
    (put-size-string buffer 0 str size)
    (write-subu8vector buffer 0 size port))
  
  
  (method public (->utf-8-string self val)
    (write-string val port))
  
  
  (method public (->u8vector self val <u8vector>)
    (write-subu8vector val 0 (u8vector-length val) port))))
