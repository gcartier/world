;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Enemy
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.enemy jazz


(import (jazz.geometry)
        (jazz.syntax (phase syntax))
        (world)
        (world.actor)
        (world.audio)
        (world.autoload)
        (world.block)
        (world.commands)
        (world.configure)
        (world.dye)
        (world.dyes)
        (world.geometry)
        (world.history)
        (world.homogeneous)
        (world.scripting)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Enemy
;;;


(definition public default-run?
  #t)

(definition public (set-default-run? flag)
  (set! default-run? flag))


(definition move-commands
  (let ((commands (new Commands)))
    (move-forward~ commands)
    commands))


(definition move/jump-commands
  (let ((commands (new Commands)))
    (move-forward~ commands)
    (jump~ commands)
    commands))


(class Enemy extends Actor
  
  
  (properties (;; component
               name visible?
               ;; element
               position lookat scale radiuses radius color user-data
               ;; entity
               model animate? animation
               ;; actor
               velocity fall-velocity life alive? global-cooldown spell adjustments rapid-fire-acceleration rapid-fire-duration rapid-fire-cooldown last-missile max-missiles missiles-count history-color jumping? jump-ready? jump-grace? jump-time ground? rotation orientation dash dash-duration animation-active)
    
    (slot tick? <bool> initialize #t accessors generate))
  
  
  (method protected virtual (move-enemy time elapse exit (gravity?: gravity? #t) (response: response 'slide) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f) (ignore-me?: ignore-me? #f))
    (tick-actor move-commands time elapse exit gravity? response ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me?))
  
  
  (method protected virtual (rebound-x)
    (vertex-x-set! velocity (- (vertex-x velocity)))
    (update-lookat velocity))
  
  
  (method protected virtual (rebound-z)
    (vertex-z-set! velocity (- (vertex-z velocity)))
    (update-lookat velocity))
  
  
  (method override (move-animation)
    (let ((effective-speed (* (ground-speed) dash)))
      (cond ((= effective-speed 0.) "Idle")
            ((<= effective-speed (walk-speed)) "Walk")
            (else "Run"))))
  
  
  (method (update-lookat dir)
    (let ((world (current-world)))
      (init-lookat (vertex-normalize& dir)
                   (get-world-up~ world)))))


;;;
;;;; Creature
;;;


(definition attack-distance <fl>
  .1)


(definition protected creature-ticks <fx>
  (fxround enemy-rate))

;; aggro 5 times per second
(definition protected aggro-ticks <fx>
  (fxround (/ enemy-rate 5.)))


(definition public creature-models? <bool>
  (world-setting 'world.creature-models? #f))

(definition public (set-creature-models? flag <bool>)
  (set! creature-models? flag))


(class Creature extends Enemy
  
  
  (properties (;; component
               name visible?
               ;; element
               position lookat scale radiuses radius color user-data
               ;; entity
               model animate? animation
               ;; actor
               velocity fall-velocity life alive? global-cooldown spell adjustments rapid-fire-acceleration rapid-fire-duration rapid-fire-cooldown last-missile max-missiles missiles-count history-color jumping? jump-ready? jump-grace? jump-time ground? rotation orientation dash dash-duration animation-active
               ;; enemy
               tick?)
    
    (slot tick-count       <fx>         initialize -1 accessors generate)
    (slot path-duration    <fl+>        initialize #f accessors generate)
    (slot attack?          <bool>       initialize #f accessors generate)
    (slot attack-delay     <fl+>        initialize #f accessors generate)
    (slot aggro-radius     <fl+>        initialize #f accessors generate)
    (slot aggro-target     <Player+>    initialize #f accessors generate)
    (slot spawner-position <f64vector+> initialize #f accessors generate)
    (slot jump?            <bool>       initialize #f accessors generate))
  
  
  (slot task <object> initialize #f accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (prepare-pathing))
  
  
  (method override (call-model-update model)
    (nextmethod model)
    (set! aggro-radius 25.)
    (set! orientation (or (get-orientation~ model) 'horizontal)))
  
  
  (method protected virtual (update-model (anchor?: anchor? #f))
    )
  
  
  (method (enemy-task task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (with-task-mutex
              (lambda ()
                (unless (stopping?~ task)
                  (let ((elapse (- time previous))
                        (max-elapse 10.))
                    ;; ignore ridiculous elapses like
                    ;; coming back from computer sleep
                    (unless (> elapse max-elapse)
                      (let ((history (current-history)))
                        (unless (get-paused?~ history)
                          (tick-enemy time elapse))))))))
            (let ((period (determine-period))
                  (duration (- (current-seconds) time)))
              (task-sleep task period duration exit))
            (iter time))))))
  
  
  ;; this should be replaced by not viewing entities outside a certain radius
  (method (determine-period)
    (let ((distance (f64-ref (vertex-distance& position (get-position~ (current-camera))))))
      (let ((period (/ 1. (cond-expand
                            (release
                             (cond ((<= distance 5.) 60.)
                                   ((<= distance 15.) 30.)
                                   (else 20.)))
                            (else
                             (cond ((<= distance 5.) 30.)
                                   ((<= distance 15.) 20.)
                                   ((<= distance 30.) 10.)
                                   ((<= distance 50.) 5.)
                                   ((<= distance 100.) 1.)))))))
        (if active? period (* period 4.)))))
  
  
  (method (tick-enemy time elapse)
    (let ((world (current-world)))
      (site (enemy on?: #t)
        (tick-sliced~ world self #f time elapse)
        (animate elapse))))
  
  
  (method override (tick commands time elapse exit)
    (set! tick-count (modulo (+ tick-count 1) creature-ticks))
    (if script-tick
        (with-exception-catcher
          (lambda (exc)
            (set-script-state 'error)
            (set-script-reason (exception-reason exc)))
          (lambda ()
            (parameterize ((current-event (list self time elapse exit)))
              (script-tick))))
      (let ((me (current-me)))
        (when (and tick? (neq? self (get-controlled~ me)))
          (when (and (not aggro-target) path-duration (> path-duration 0.))
            (decrease! path-duration elapse))
          (when aggro-target
            (when (and attack-delay (> attack-delay 0.))
              (decrease! attack-delay elapse))
            (let ((pos (get-position~ aggro-target)))
              (let ((dir (vertex-& (vertex& (vertex-x pos) (vertex-y position) (vertex-z pos)) position)))
                (unless (vertex-near-zero? dir)
                  (update-lookat (vertex-normalize& dir))))))
          (set! attack? (and aggro-target (< (vertex-distance position (get-position~ aggro-target)) (+ (get-radius) (get-radius~ aggro-target) attack-distance))))
          (if attack?
              (attack-player aggro-target)
            (move-enemy time elapse exit))
          (when (and (not aggro-target) (= (modulo tick-count aggro-ticks) 0))
            (or (players-aggro)
                (when (<= path-duration 0.)
                  (path-creature))))))))
  
  
  (method override (move-enemy time elapse exit (gravity?: gravity? #t) (response: response 'slide) (ignore-entities?: ignore-entities? #t) (ignore-players?: ignore-players? #f) (ignore-me?: ignore-me? #f))
    (if jump?
        (begin
          (set! jump? #f)
          (tick-actor move/jump-commands time elapse exit gravity? response ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: #f))
      (let ((info (tick-actor move-commands time elapse exit gravity? response ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: #f)))
        (when (and info (or (not jump-time) (> time (+ jump-time (if aggro-target 1. 2.)))))
          (receive (center slide-collisions fall-collisions) info
            (when (or (not-null? slide-collisions) (random-jump?))
              (set! jump? #t)))))))
  
  
  (method (random-jump?)
    (let ((number (random-jump)))
      (and number (< (random-real) number))))
  
  
  (method protected virtual (random-jump)
    #f)
  
  
  (method override (hit collisions exit)
    (for-each (lambda (collision)
                (let ((element (get-element~ collision)))
                  (cond ((is? element Block-Entity)
                         (case axis
                           ((x) (rebound-x))
                           ((z) (rebound-z)))))))
              collisions))
  
  
  (method override (adjust-fast-slide! center new-center)
    (when aggro-target
      (let ((target (get-position~ aggro-target)))
        (let ((direct (vertex-& target center))
              (actual (vertex-& new-center center)))
          (let ((dist (f64-ref (vertex-norm& actual))))
            (when (and (not (vertex-zero? direct)) (> dist 0.))
              ;; only consider reasonable angles with the aggro target
              (when (< (abs (f64-ref (dot-product& (vertex-normalize& direct) (vertex-normalize& actual)))) .1)
                (let ((proj (/ (f64-ref (dot-product& direct actual)) dist)))
                  (when (< proj dist)
                    (vertex+! new-center center (vertex-scalar*& (vertex-normalize& actual) proj)))))))))))
  
  
  (method public virtual (aggro-sound)
    #f)
  
  
  (method public virtual (attack-sound)
    #f)
  
  
  (method (players-aggro)
    (when (and aggro-radius (not aggro-target))
      (let ((zone (current-zone)))
        (let (iter (scan (get-players~ zone)))
          (if (null? scan)
              (begin
                (set! aggro-target #f)
                #f)
            (let ((player (car scan)))
              (if (and (user-role?) (can-aggro? player))
                  (begin
                    (aggro-player player)
                    #t)
                (let (iter1 (creatures (get-aggroed-creatures~ player)))
                  (if (null? creatures)
                      (iter (cdr scan))
                    (let ((creature (car creatures)))
                      (if (can-aggro? creature)
                          (begin
                            (aggro-player (get-aggro-target~ creature))
                            #t)
                        (iter1 (cdr creatures)))))))))))))
  
  
  (method (can-aggro? obj)
    (define (polygon-filter poly)
      (let ((element (get-element~ poly)))
        (and (not (eq? element self))
             (or (eq? element obj) (is-not? element Enemy))
             (not (get-water-cube?~ (world.generation:id->block (fxround (get-data1~ poly))))))))
    
    (let ((world (current-world)))
      (let ((position (lens-center))
            (pos (lens-center~ obj)))
        (let ((dist (vertex-distance position pos)))
          (and (<= dist aggro-radius)
               (< (vector-angle (get-sight~ lookat) (vertex-& pos position)) PI/2)
               (let ((dir (vertex-& pos position)))
                 (unless (vertex-zero? dir)
                   (let ((closest (ray-closest-polygon~ world position (vertex-normalize dir) (+ aggro-radius (get-radius) (get-radius~ obj)) filter: polygon-filter ignore-entities?: #f)))
                     @debug
                     (when closest
                       (let ((poly (first closest)))
                         (debug (or (get-element~ poly) (list (fxround (get-data1~ poly))
                                                              (fxround (get-data2~ poly))
                                                              (fxround (get-data3~ poly))
                                                              (fxround (get-data4~ poly)))))))
                     (and closest (equal? (get-element~ (first closest)) obj))))))))))
  
  
  (method (aggro-player player)
    (when (neq? player aggro-target)
      ;; pathing uses dash to stop enemies
      (set! dash 1.)
      (set! aggro-target player)
      (set-aggroed-creatures~ player (cons self (get-aggroed-creatures~ player)))
      (play-3d-sound-if (aggro-sound) position))
    (let ((pos (get-position~ player)))
      @enables-enemies-to-fly
      (update-lookat (vertex-normalize& (vertex-& pos position)))
      (update-lookat (vertex-normalize& (vertex-& (vertex& (vertex-x pos) (vertex-y position) (vertex-z pos)) position)))))
  
  
  (method override (attacking?)
    attack?)
  
  
  (method (attack-player player)
    (when (or (not attack-delay) (<= attack-delay 0))
      (play-3d-sound-if (attack-sound) position)
      (when (find-animation~ (cache-model) "AttackUnarmed")
        (transition-morphing "AttackUnarmed")
        (set! animation-active "AttackUnarmed"))
      (wound~ player self 1.)
      (set! attack-delay 1.5)))
  
  
  (method (prepare-pathing)
    (set! path-duration (random-between 1. 3.)))
  
  
  (method protected virtual (path-creature)
    (cond ((< (random-real) .333)
           (set! dash 0.))
          (else
           (set! dash 1.)
           (update-lookat (vertex (random-in 1.) 0. (random-in 1.)))))
    (prepare-pathing))
  
  
  (method override (wound inflictor (amount #f))
    (nextmethod inflictor amount)
    (when (and alive? (eq? inflictor (current-me)))
      (aggro-player inflictor)))
  
  
  (method override (die)
    (remove-element~ (current-zone) self)
    (when aggro-target
      (set-aggroed-creatures~ aggro-target (remove self (get-aggroed-creatures~ aggro-target) test: equal?)))
    (nextmethod)))


;;;
;;;; Wolf
;;;


(class Wolf extends Creature
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! aggro-radius 40.)
    (update-model))
  
  
  (method override (element-radiuses)
    (vertex .4 .4 .4))
  
  
  (method override (element-radius)
    .4)
  
  
  (method override (target-radius)
    (* (average-scaling) 1.8))
  
  
  (method override (update-model (anchor?: anchor? #f))
    (cond ((not creature-models?)
           (set-scaling .4)
           (set-color (dye .157 .157 .157 1.))
           (change-model 'Wolf anchor?)
           (free-morphing))
          (else
           (set-scaling .5)
           (change-model "creature/direwolf" anchor?)
           (set-pumps~ (cache-model) (vertex 0. .12 0.)))))
  
  
  (method override (aggro-sound)
    "sound/creature/wolf/aggro")
  
  (method override (attack-sound)
    "sound/creature/wolf/attack")
  
  (method override (wound-sound)
    "sound/creature/wolf/wound")
  
  (method override (wound-critical-sound)
    "sound/creature/wolf/woundCritical")
  
  (method override (death-sound)
    "sound/creature/wolf/death"))


;;;
;;;; Spider
;;;


(class Spider extends Creature
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! aggro-radius 25.)
    (update-model))
  
  
  (method override (element-radiuses)
    (vertex .4 .4 .4))
  
  
  (method override (element-radius)
    .4)
  
  
  (method override (target-radius)
    (* (average-scaling) 1.8))
  
  
  (method override (update-model (anchor?: anchor? #f))
    (cond ((not creature-models?)
           (set-scaling .4)
           (set-color (dye 0. .235 0. 1.))
           (change-model 'Spider anchor?)
           (free-morphing))
          (else
           (set-scaling .5)
           (change-model "creature/scorpion" anchor?)
           (set-pumps~ (cache-model) (vertex 0. .12 0.)))))
  
  
  (method override (aggro-sound)
    "sound/creature/spider/aggro")
  
  (method override (attack-sound)
    "sound/creature/spider/attack")
  
  (method override (wound-sound)
    "sound/creature/spider/wound")
  
  (method override (wound-critical-sound)
    "sound/creature/spider/woundCritical")
  
  (method override (death-sound)
    "sound/creature/spider/death"))


;;;
;;;; Jumper
;;;


(class Jumper extends Creature
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! aggro-radius 40.)
    (update-model))
  
  
  (method override (element-radiuses)
    (vertex .4 .4 .4))
  
  
  (method override (element-radius)
    .4)
  
  
  (method override (target-radius)
    (* (average-scaling) 1.8))
  
  
  (method override (update-model (anchor?: anchor? #f))
    (cond ((not creature-models?)
           (set-scaling .4)
           (set-color (dye .4 0. .5 .3))
           (change-model 'Jumper anchor?)
           (free-morphing))
          (else
           (set-scaling .5)
           (change-model "creature/sporebat" anchor?)
           (set-pumps~ (cache-model) (vertex 0. .12 0.)))))
  
  
  (method override (aggro-sound)
    "sound/creature/jumper/aggro")
  
  (method override (attack-sound)
    "sound/creature/jumper/attack")
  
  (method override (wound-sound)
    "sound/creature/jumper/wound")
  
  (method override (wound-critical-sound)
    "sound/creature/jumper/woundCritical")
  
  (method override (death-sound)
    "sound/creature/jumper/death")
  
  
  (method override (random-jump)
    .005))


;;;
;;;; Turtle
;;;


@wait-missing-turf-tile
(class Turtle extends Creature
  
  
  (slot stomp-time <fl> initialize 0. accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-color green-dye)
    (set-model 'Turtle))
  
  
  (method override (element-radiuses)
    (vertex .2 .2 .2))
  
  
  (method override (element-radius)
    .2)
  
  
  (method override (target-radius)
    .3)
  
  
  (method override (path-creature)
    (let ((zone (current-zone)))
      (if (getf (get-properties~ zone) victor?:)
          (vertex-x-set! velocity turtle-speed)
        (nextmethod))))
  
  
  (method override (tick commands time elapse exit)
    (let ((zone (current-zone)))
      (when tick?
        (if stomp-time
            (when (>= time stomp-time)
              (set! stomp-time #f))
          (move-enemy time elapse exit)
          (when (and (getf (get-properties~ zone) victor?:)
                     (or (< (get-x) -35.)
                         (> (get-x) -27.)))
            (rebound-x))))))
  
  
  (method override (stomp)
    (set! stomp-time (+ (current-seconds) 3.))
    #t))


;;;
;;;; Missile
;;;


(class Missile extends Enemy
  
  
  (properties (;; component
               name visible?
               ;; element
               position lookat scale radiuses radius color user-data
               ;; entity
               model animate? animation
               ;; actor
               velocity fall-velocity life alive? global-cooldown spell adjustments rapid-fire-acceleration rapid-fire-duration rapid-fire-cooldown last-missile max-missiles missiles-count history-color jumping? jump-ready? jump-grace? jump-time ground? rotation orientation dash dash-duration animation-active
               ;; enemy
               tick?)
    
    (property actor <object> initialize #f accessors generate)
    (property kind  <object> initialize #f getter generate setter explicit)
    
    
    (slot alive     <fl>     initialize 0.    accessors generate)
    (slot rendered? <bool>   initialize #f    accessors generate)
    (slot response  <object> initialize 'stop accessors generate))
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-color red-dye))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (setup-model))
  
  
  (method public (set-kind k)
    (set! kind k)
    (setup-model))
  
  
  (method (setup-model)
    (when kind
      (set-model (case kind
                   ((bullet) 'Bullet)
                   ((arrow) 'Arrow)))))
  
  
  (method override (element-radiuses)
    (vertex .05 .05 .05))
  
  
  (method override (element-radius)
    .05)
  
  
  (method override (get-friction)
    #f)
  
  
  (method override (is-missile?)
    #t)
  
  
  (method (missile-speed) <fl>
    100.)
  
  (method (missile-life) <fl>
    2.5)
  
  
  (method (self-wound-grace)
    .1)
  
  
  (method override (tick commands time elapse exit)
    (let ((ignore-me? (< alive (self-wound-grace))))
      (move-enemy time elapse exit gravity?: #f response: response ignore-entities?: #f ignore-players?: #f ignore-me?: ignore-me?)
      (set! alive (+ alive elapse))
      (when (> alive (missile-life))
        (remove-missile))))
  
  
  (method override (hit collisions exit)
    (nextmethod collisions exit)
    (let ((world (current-world)))
      (let (iter (scan collisions))
        (when (not-null? scan)
          (let ((collision (car scan)))
            (case (missile-hit~ world self collision)
              ((stop))
              ((remove)
               (remove-missile)
               (continuation-return exit #f))
              ((slide)
               (set! response 'slide))
              (else
               (iter (cdr scan)))))))))
  
  
  (method override (hit-floor velocity exit)
    (remove-missile)
    (continuation-return exit #f))
  
  
  (method (remove-missile)
    (if (not rendered?)
        (set! alive +infinity)
      (let ((world (current-world)))
        (remove-element~ world self)
        ;; quick hack for serialization not preserving actor
        (when actor
          (decrease-missiles~ actor)))))
  
  
  (method override (explosion-damage?)
    #f)
  
  
  (method override (damage amount critical?)
    )
  
  
  (method override (rebound-x)
    )
  
  (method override (rebound-z)
    )))
