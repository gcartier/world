;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Enemy
;;;


(module world.enemy jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world)
        (world.actor)
        (world.autoload)
        (world.block)
        (world.collision)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.mark)
        (world.movement)
        (world.opengl)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile)
        (world.window)
        (world.client.window))


;;;
;;;; Enemy
;;;


(definition public missile-speed <fl>
  2.5)

(definition public missile-delay <fl>
  .1)


(class Enemy extends Actor
  
  
  (method (move-enemy elapse exit (gravity: gravity #t) (response: response 'slide))
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((old-position (copy-vertex position))
            (factor (* elapse 65)))
        (let ((target-position (vertex+ position (vertex-scalar* velocity factor))))
          (let ((mvt (new Movement position (vertex- target-position position)))
                (collide (case response ((stop) collide&stop) ((slide) collide&slide))))
            (receive (new-position last-direction collisions) (collide radius mvt #f)
              (hit collisions exit)
              (let ((target-fall (copy-vertex new-position)))
                (when (< (- (vertex-y target-position) (get-radius-y)) (get-floor-level~ zone))
                  (hit-floor
                    (lambda (y)
                      (vertex-y-set! target-position y))
                    exit))
                (when gravity
                  (let ((gravity (if (eq? gravity #t) (get-gravity~ world) gravity))
                        (adjusted (* elapse 50.)))
                    (vertex-y-set! velocity (- (vertex-y velocity) (* gravity adjusted)))
                    (vertex-y-set! target-fall (+ (vertex-y target-fall) (- (* (vertex-y velocity) adjusted) (* gravity .5 adjusted adjusted))))))
                (when (< (vertex-y velocity) -1.0)
                  (vertex-y-set! velocity -1.))
                (if (not gravity)
                    (begin
                      (set-position new-position)
                      (update-area~ zone self old-position)
                      (update-sector~ zone self old-position))
                  (let ((mvt (new Movement new-position (vertex- target-fall new-position))))
                    (receive (new-fall last-direction collisions) (collide&stop radius mvt #f)
                      (let ((floor-level (+ (get-floor-level~ zone) (get-radius-y))))
                        (when (< (vertex-y new-fall) floor-level)
                          (vertex-y-set! new-fall floor-level)
                          (vertex-y-set! velocity 0.)))
                      (set-position new-fall)
                      (update-area~ zone self old-position)
                      (update-sector~ zone self old-position)))))))))))
  
  
  (method protected virtual (hit-filter)
    #f)
  
  
  (method protected virtual (hit-floor reset exit)
    (reset (get-radius-y)))
  
  
  (method protected virtual (hit collisions exit)
    @unify-with-die
    (let ((world (current-world))
          (me (current-me)))
      (when (memq? me collisions key: get-element~)
        (lose~ world me)
        (continuation-return exit))))
  
  
  (method protected virtual (rebound-x)
    (vertex-x-set! velocity (- (vertex-x velocity)))
    (update-lookat))
  
  
  (method protected virtual (rebound-z)
    (vertex-z-set! velocity (- (vertex-z velocity)))
    (update-lookat))
  
  
  (method (update-lookat)
    (let ((world (current-world)))
      (set-sight~ lookat (vertex-normalize (vertex (vertex-x velocity) 0. (vertex-z velocity))))
      (set-up~ lookat (get-world-up~ world))
      (set-right~ lookat (cross-product& (get-sight~ lookat) (get-up~ lookat))))))


;;;
;;;; Creature
;;;


(definition attack-distance <fl>
  .5)


(class Creature extends Enemy
  
  
  (slot path-duration initialize #f getter generate)
  (slot anim-duration initialize #f getter generate)
  (slot aggro-radius  initialize #f getter generate)
  (slot aggro-sound   initialize #f getter generate)
  (slot aggro-target  initialize #f getter generate)
  (slot attack-sound  initialize #f getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (standardize-lookat! lookat)
    (path-creature))
  
  
  (method override (position-update)
    (nextmethod)
    (matrix-multiply! matrix (make-translation-matrix& (get-x) (- (get-y) 2.) (get-z)) (matrix-multiply& (make-scaling-matrix& scale scale scale) (make-lookat-matrix& lookat))))
  
  
  (method override (tick commands elapse exit)
    (or (players-aggro)
        (if (<= path-duration 0)
            (path-creature)
          (decrease! path-duration)))
    (unless (and aggro-target (< (vertex-distance position (get-position~ aggro-target)) (+ radius (get-radius~ aggro-target) attack-distance)))
      (move-enemy elapse exit)))
  
  
  (method override (hit collisions exit)
    (for-each (lambda (collision)
                (let ((element (get-element~ collision)))
                  (cond ((and (is? element Actor) (is-player?~ element))
                         (attack-player element))
                        ((is? element Tile)
                         (case axis
                           ((x) (rebound-x))
                           ((z) (rebound-z)))))))
              collisions))
  
  
  (method (players-aggro)
    (when aggro-radius
      (let ((zone (current-zone)))
        (let (iter (scan (get-players~ zone)))
          (if (null? scan)
              (begin
                (set! aggro-target #f)
                #f)
            (let ((player (car scan)))
              (let ((dist (vertex-distance position (get-position~ player))))
                (if (< dist aggro-radius)
                    (begin
                      (aggro-player player)
                      #t)
                  (iter (cdr scan))))))))))
  
  
  (method (aggro-player player)
    (let ((world (current-world)))
      (when (neq? player aggro-target)
        (set! aggro-target player)
        (when aggro-sound
          (play-sound-file~ world aggro-sound)))
      (let ((direction (vertex-normalize (vertex- (get-position~ player) position))))
        (vertex-x-set! velocity (* (vertex-x direction) (creature-speed)))
        (vertex-z-set! velocity (* (vertex-z direction) (creature-speed))))
      (update-lookat)))
  
  
  (method (attack-player player)
    (let ((world (current-world)))
      (if (or (not anim-duration) (<= anim-duration 0))
          (begin
            (when attack-sound
              (play-sound-file~ world attack-sound)
              (wound~ player))
            (set! anim-duration 100))
        (decrease! anim-duration))))
  
  
  (method protected virtual (path-creature)
    (cond ((< (random-real) .333)
           (vertex-x-set! velocity 0.)
           (vertex-z-set! velocity 0.))
          (else
           (vertex-x-set! velocity (* (random-in 1.) (creature-speed)))
           (vertex-z-set! velocity (* (random-in 1.) (creature-speed)))
           (update-lookat)))
    (set! path-duration (+ 100 (random 200))))
  
  
  (method protected virtual (creature-speed)
    ))


;;;
;;;; Wolf
;;;


(definition wolf-speed <fl>
  .1)


(class Wolf extends Creature
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-radiuses (vertex 2. 2. 2.))
    (set-color (dye .157 .157 .157 1.))
    (set! aggro-radius 40.)
    (set! aggro-sound "sound/wolf/aggro")
    (set! attack-sound "sound/wolf/attack")
    (set! wound-sound "sound/wolf/wound")
    (set! wound-critical-sound "sound/wolf/woundCritical")
    (set! death-sound "sound/wolf/death"))
  
  
  (method override (element-radius)
    2.)
  
  
  (method override (creature-speed)
    wolf-speed)
  
  
  (method override (draw-3d)
    (let ((world (current-world)))
      (cond ((in-history?)
             (when (get-draw-actors-history?~ world)
               (draw-3d-history)))
            (else
             (draw-as-sphere-actor #f #f 'none 'high GL_FILL color #f32(.392 .392 .392 1.)))))))


;;;
;;;; Spider
;;;


(definition spider-speed <fl>
  .05)


(class Spider extends Creature
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-radiuses (vertex 2. 2. 2.))
    (set-color (dye 0. .235 0. 1.))
    (set! aggro-radius 25.)
    (set! aggro-sound "sound/spider/aggro")
    (set! attack-sound "sound/spider/attack")
    (set! wound-sound "sound/spider/wound")
    (set! wound-critical-sound "sound/spider/woundCritical")
    (set! death-sound "sound/spider/death"))
  
  
  (method override (element-radius)
    2.)
  
  
  (method override (creature-speed)
    spider-speed)
  
  
  (method override (draw-3d)
    (let ((world (current-world)))
      (cond ((in-history?)
             (when (get-draw-actors-history?~ world)
               (draw-3d-history)))
            (else
             (draw-as-sphere-actor #f #f 'none 'high GL_FILL color #f32(.196 .196 .196 1.)))))))


;;;
;;;; Turtle
;;;


(definition turtle-speed <fl>
  .025)


(class Turtle extends Creature
  
  
  (slot stomp-time <fl> initialize 0. accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-radiuses (vertex 1. 1. 1.))
    (set-color green-dye))
  
  
  (method override (creature-speed)
    turtle-speed)
  
  
  (method override (path-creature)
    (let ((zone (current-zone)))
      (if (getf (get-properties~ zone) victor?:)
          (vertex-x-set! velocity turtle-speed)
        (nextmethod))))
  
  
  (method override (tick commands elapse exit)
    (let ((zone (current-zone)))
      (if stomp-time
          (when (>= (time->seconds (current-time)) stomp-time)
            (set! stomp-time #f))
        (move-enemy elapse exit)
        (when (and (getf (get-properties~ zone) victor?:)
                   (or (< (get-x) -35.)
                       (> (get-x) -27.)))
          (rebound-x)))))
  
  
  (method override (stomp)
    (set! stomp-time (+ (time->seconds (current-time)) 3.))
    #t)
  
  
  (method override (draw-3d)
    (let ((world (current-world)))
      (cond ((in-history?)
             (when (get-draw-actors-history?~ world)
               (draw-3d-history)))
            (else
             (glPushMatrix)
             (glTranslatef (get-x) (get-y) (get-z))
             (gl-colorize-dye color)
             (draw-as-cube)
             (glPopMatrix))))))


;;;
;;;; Missile
;;;


(class Missile extends Enemy
  
  
  (property actor <object> initialize #f accessors generate)
  
  
  (slot start <f32vector> initialize (make-vertex) getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-radiuses (vertex .25 .25 .25))
    (set-color red-dye))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (vertex-copy! start position))
  
  
  (method override (copy-from from)
    (nextmethod from)
    (set! start (clone-vertex (get-start~ from))))
  
  
  (method override (element-radius)
    .25)
  
  
  (method override (tick commands elapse exit)
    (move-enemy elapse exit gravity: #f response: 'stop)
    ;; initial poor man boundaries
    (when (> (vertex-distance start position) 250.0)
      (remove-self)))
  
  
  (method override (hit-filter)
    (lambda (obj)
      (is-not? obj Missile)))
  
  
  (method override (hit-floor reset exit)
    (remove-self)
    (continuation-return exit))
  
  
  (method override (hit collisions exit)
    (nextmethod collisions exit)
    (let ((world (current-world)))
      (let (iter (scan collisions))
        (when (not-null? scan)
          (let ((element (get-element~ (car scan))))
            (case (missile-hit~ world self element)
              ((stop))
              ((remove)
               (remove-self)
               (continuation-return exit))
              (else
               (iter (cdr scan)))))))))
  
  
  (method (remove-self)
    (let ((world (current-world)))
      (remove-element~ world self)
      (decrease-missiles~ actor)))
  
  
  (method override (rebound-x)
    )
  
  (method override (rebound-z)
    )
  
  
  (method override (draw-3d)
    (glPushMatrix)
    (glTranslatef (get-x) (get-y) (get-z))
    (gl-colorize-dye color)
    (draw-as-sphere #f)
    (glPopMatrix))))
