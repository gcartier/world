;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Remote Master Implementation
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.master jazz


(import (jazz.io)
        (jazz.jrm)
        (jazz.network)
        (world.stub))


;;;
;;;; Slave
;;;


(definition *slave-cookie*
  0)

(definition *slave-procedures*
  (make-table test: eqv?))


(definition public (register-slave-ready-cookie)
  (prog1 *slave-cookie*
    (increase! *slave-cookie*)))


(definition public (register-slave-procedures setup ready)
  (let ((cookie (register-slave-ready-cookie))
        (mutex (make-mutex 'ready)))
    (mutex-lock! mutex)
    (table-set! *slave-procedures* cookie (list mutex setup ready))
    cookie))


(definition public (registered-slave-ready cookie)
  (table-ref *slave-procedures* cookie))


(definition public (wait-slave-ready cookie)
  (bind (mutex) (registered-slave-ready cookie)
    (mutex-lock! mutex)
    (let ((result (table-ref *slave-procedures* cookie)))
      (table-clear *slave-procedures* cookie)
      (mutex-unlock! mutex)
      result)))


(definition public (invoke-slave-setup-procedure master slave cookie)
  (bind (mutex setup ready) (registered-slave-ready cookie)
    (setup master slave cookie)))


(definition public (invoke-slave-ready-procedure master slave cookie)
  (bind (mutex setup ready) (registered-slave-ready cookie)
    (thread-yield!) ; why is this necessary?
    (table-set! *slave-procedures* cookie (ready master slave cookie))
    (mutex-unlock! mutex)))


(definition public (spawn-slave-process name filename setup ready (arguments: arguments #f) (debug?: debug? #f) (wait?: wait? #f))
  (define (determine-slave-path)
    (let ((filename (add-extension filename (executable-extension kernel-platform))))
      (or (find-kernel-file filename)
          (error "Unable to find {a} executable" name))))
  
  (start-remote-listener)
  (let ((slave-path (determine-slave-path))
        (cookie (register-slave-procedures setup ready)))
    (open-process
      (list
        path: slave-path
        arguments: `("-:darR" @maybe-use-in-production!? "-:daqQ-"
                     ;; it is not completly correct at the moment to always debug
                     ;; the slave because of the evaluate always hack done in yownu
                     ,@(let ((arg (command-argument "debugger")))
                         (if (and debug? arg)
                             (list "-debugger" arg)
                           '()))
                     ,@(or arguments '())
                     "-master" ,(encode-host/port (or (listening-host~ (get-remote-listener)) "localhost") (listening-port~ (get-remote-listener)))
                     "-master-cookie" ,(->string cookie))
        stdin-redirection: #f
        stdout-redirection: #f
        stderr-redirection: #f
        show-console: #f))
    (and wait?
         (wait-slave-ready cookie))))


;;;
;;;; Master
;;;


(class World-Remote-Master extends Object
  
  
  (method public (slave-setup slave cookie)
    (invoke-slave-setup-procedure self slave cookie))
  
  
  (method public (slave-ready slave cookie)
    (invoke-slave-ready-procedure self slave cookie)))


(definition public (make-world-remote-master)
  (new World-Remote-Master-Local-Proxy (new World-Remote-Master)))


(register-object~ (get-local-register) 'world-remote-master (make-world-remote-master)))
