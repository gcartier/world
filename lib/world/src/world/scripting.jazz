;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Scripting
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.scripting jazz


(import (jazz.geometry)
        (jazz.io)
        (script)
        (world)
        (world.audio)
        (world.autoload)
        (world.commands)
        (world.configure)
        (world.draw)
        (world.dyes)
        (world.generation.base)
        (world.geometry)
        (world.homogeneous)
        (world.index)
        (world.syntax (phase syntax))
        (world.task)
        (world.work))


;;;
;;;; Internal
;;;


(definition public %%current-instance
  (make-parameter #f))


(definition public current-task
  (make-parameter #f))


(definition public current-exit
  (make-parameter #f))


(definition public current-event
  (make-parameter #f))


(set-poll-script
  (lambda ()
    (let ((task (current-task))
          (exit (current-exit))
          (entity (%%current-entity)))
      (when entity
        (handle-events~ entity))
      (when (and task exit)
        (task-sleep task .01 0. exit)))))


;;;
;;;; World
;;;


(definition public (%%message msg)
  (let ((world (current-world)))
    (display-message~ world (->string msg))))


(definition public (%%say msg (size: size #f))
  (let ((entity (%%current-entity)))
    (set-billboard-console~ entity msg size: size)))


(definition public (%%unsay)
  (let ((entity (%%current-entity)))
    (set-billboard-element~ entity #f)))


(definition public (%%name name)
  (let ((entity (%%current-entity)))
    (set-billboard-name~ entity name)))


(definition public (%%unname)
  (let ((entity (%%current-entity)))
    (set-billboard-element~ entity #f)))


;;;
;;;; Zone
;;;


(definition public (%%creatures)
  (let ((zone (current-zone)))
    (get-creatures~ zone)))


;;;
;;;; Script
;;;


(definition protected (with-lock thunk)
  ;; handle events will already own the task mutex
  (with-maybe-task-mutex
    thunk))


(definition (get/create-script entity (create?: create? #t))
  (let ((zone (current-zone)))
    (or (get-script~ entity)
        (and create?
             (new world.scripter:Script parent: entity)))))


(definition public (%%set-tick-handler entity invocation handler)
  (set-tick~ (get/create-script entity) (cons invocation handler)))

(definition public (%%set-interact-handler entity invocation handler)
  (set-interact~ (get/create-script entity) (cons invocation handler)))

(definition public (%%set-double-click-handler entity invocation handler)
  (set-double-click~ (get/create-script entity) (cons invocation handler)))

(definition public (%%set-power-handler entity invocation handler)
  (set-power~ (get/create-script entity) (cons invocation handler)))

(definition public (%%set-unpower-handler entity invocation handler)
  (set-unpower~ (get/create-script entity) (cons invocation handler)))

(definition public (%%set-teleport-handler entity invocation handler)
  (set-teleport~ (get/create-script entity) (cons invocation handler)))

(definition public (%%set-explode-handler entity invocation handler)
  (set-explode~ (get/create-script entity) (cons invocation handler)))

(definition public (%%set-hit-handler entity invocation handler)
  (set-hit~ (get/create-script entity) (cons invocation handler)))


(definition protected (load-script-text info)
  (bind (dir . path) info
    (let ((file (new-file~ dir path)))
      (call-with-input-file (path-settings file)
        (lambda (input)
          (read-content-string input))))))


;;;
;;;; Entity
;;;


(definition public (%%current-entity)
  (if (current-event)
      (get-me~ (current-event))
    (%%current-instance)))


(definition public (%%near-player? actor distance)
  (<= (vertex-distance (get-position~ actor) (get-position~ (current-me))) distance))


(definition public (%%get-position element)
  (get-position~ element))


(definition public (%%set-position element position)
  (set-position~ element position))


(definition public (%%set-lookat element lookat)
  (set-lookat~ element lookat))


(definition public (%%set-speed element speed)
  (set-speed~ element speed))


(definition public (%%set-motion actor motion)
  (set-motion~ actor motion))


(definition public (%%set-sprint? actor flag)
  (set-sprint?~ actor flag))


(definition public (%%set-hover? actor flag)
  (set-hover?~ actor flag))


(definition public (%%set-billboard actor name)
  (set-billboard-name~ actor name))


(definition public (%%full-life)
  (set-life~ (%%current-entity) 100.))


(definition public (%%animate actor animation (next: next #f))
  (assert (find-animation~ (cache-model~ actor) animation))
  (transition-morphing~ actor animation next: (or next "Idle"))
  (set-animation-active~ actor animation))


(definition public (%%teleport position)
  (let ((zone (current-zone)))
    (teleport~ zone position)))


;;;
;;;; Actor
;;;


(definition public (%%current-actor)
  (let ((entity (%%current-entity)))
    (assert (is? entity Actor)
      entity)))


(definition public (%%fire actor)
  (let ((dir (random-horizon)))
    (fire-missile~ actor dir 'bullet)))


(definition public (%%fire-at actor creature)
  (let ((dir (vertex-normalize (vertex- (get-position~ creature) (lens-center~ actor)))))
    (unless (vertex-xz-zero? dir)
      (%%set-lookat actor (%%lookat-horizon dir)))
    (fire-missile~ actor dir 'bullet)))


(definition public (%%fire-random actor)
  (let ((dir (vertex-normalize (random-direction))))
    (unless (vertex-xz-zero? dir)
      (%%set-lookat actor (%%lookat-horizon dir)))
    (fire-missile~ actor dir 'bullet)))


(definition public (%%nearest-spawned actor target)
  (let ((zone (current-zone)))
    (let ((position (get-position~ target))
          (nearest #f)
          (nearest-distance #f))
      (for-each (lambda (creature)
                  (when (get-spawner~ creature)
                    (unless (eq? creature actor)
                      (let ((dist (vertex-distance position (get-position~ creature))))
                        (when (or (not nearest)
                                  (< dist nearest-distance))
                          (set! nearest creature)
                          (set! nearest-distance dist))))))
                (get-creatures~ zone))
      nearest)))


;;;
;;;; Model
;;;


(definition public (%%get-model entity)
  (cache-model~ entity))


(definition public (%%set-run-speed model speed)
  (set-run-speed~ model speed))


;;;
;;;; Sound
;;;


(definition public (%%sound path (volume: volume #f))
  (when sounds?
    (let ((sound (cache-stream-sound path)))
      (unless (playing?~ sound)
        (when volume
          (set-volume~ sound volume))
        (play~ sound)))))


;;;
;;;; Event
;;;


(class Script-Event extends Object
  
  
  (slot me   initialize #f getter generate)
  (slot time initialize #f getter generate)
  
  
  (method override (initialize me time)
    (set! me~self me)
    (set! time~self time)))


(class Tick-Event extends Script-Event
  
  
  (slot elapse initialize #f getter generate)
  
  
  (method override (initialize me time elapse)
    (nextmethod me time)
    (set! elapse~self elapse)))


;;;
;;;; Tick
;;;


(definition script-period
  (/ 1. 30.))


(definition protected (with-tick proc)
  (let ((history (current-history))
        (task (current-task))
        (exit (current-exit))
        (entity (%%current-entity)))
    (let ((script (get-script~ entity)))
      (let (iter)
        (declare (proper-tail-calls))
        (if (or (stopping?~ task) (get-paused?~ history))
            (begin
              (task-sleep task script-period 0. exit)
              (iter))
          (handle-events~ entity)
          (let ((last-tick (get-last-tick~ script)))
            (if (not last-tick)
                (begin
                  (set-last-tick~ script (current-seconds))
                  (task-sleep task script-period 0. exit)
                  (iter))
              (let ((time (current-seconds)))
                (let ((elapse (- time last-tick)))
                  (if (>= elapse script-period)
                      (continuation-capture
                        (lambda (outside-parameterize)
                          (parameterize ((current-event (new Tick-Event entity time elapse)))
                            (set-last-tick~ script time)
                            (animate~ entity elapse)
                            (proc entity script time elapse (lambda () (continuation-graft outside-parameterize iter))))))
                    (task-sleep task (- script-period elapse) 0. exit)
                    (iter)))))))))))


;;;
;;;; Perform
;;;


(definition public stay-commands
  (new Commands))

(definition public move-commands
  (let ((commands (new Commands)))
    (move-forward~ commands)
    commands))

(definition public move/jump-commands
  (let ((commands (new Commands)))
    (move-forward~ commands)
    (jump~ commands)
    commands))

(definition public sprint-commands
  (let ((commands (new Commands)))
    (sprint-forward~ commands)
    commands))

(definition public rotate-left-commands
  (let ((commands (new Commands)))
    (rotate-left~ commands)
    commands))

(definition public rotate-right-commands
  (let ((commands (new Commands)))
    (rotate-right~ commands)
    commands))

(definition public jump-commands
  (let ((commands (new Commands)))
    (jump~ commands)
    commands))


(definition public (perform-stay)
  (perform stay-commands))

(definition public (perform-move)
  (perform (if (get-sprint?~ (%%current-actor)) sprint-commands move-commands)))

(definition public (perform-move/jump)
  (perform move/jump-commands))

(definition public (perform-rotate-left)
  (perform rotate-left-commands))

(definition public (perform-rotate-right)
  (perform rotate-right-commands))

(definition public (perform-hover)
  (perform move-commands gravity?: #f))

(definition public (perform-jump)
  (perform jump-commands))


(definition public (perform commands (gravity?: gravity? #t))
  (unless (get-paused?~ (current-history))
    (let ((event (current-event)))
      (let ((actor (get-me~ event))
            (time (get-time~ event))
            (elapse (get-elapse~ event)))
        (with-lock
          (lambda ()
            (tick-actor~ actor commands time elapse gravity? 'slide)))))))


(definition public (%%perform-stay)
  (%%perform stay-commands))

(definition public (%%perform-move (after #f))
  (%%perform (if (get-sprint?~ (%%current-actor)) sprint-commands move-commands) after: after))

(definition public (%%perform-move/jump)
  (%%perform move/jump-commands))

(definition public (%%perform-rotate-left)
  (%%perform rotate-left-commands))

(definition public (%%perform-rotate-right)
  (%%perform rotate-right-commands))

(definition public (%%perform-hover)
  (%%perform move-commands gravity?: #f))

(definition public (%%perform-jump)
  (%%perform jump-commands))


(definition public (%%perform commands (gravity?: gravity? #t) (after: after #f))
  (unless (get-paused?~ (current-history))
    (let ((event (current-event)))
      (let ((actor (get-me~ event))
            (time (get-time~ event))
            (elapse (get-elapse~ event)))
        (with-lock
          (lambda ()
            (tick-actor~ actor commands time elapse gravity? 'slide)
            (when after
              (after))))))))


;;;
;;;; Pause
;;;


(definition public (%%paused?)
  (boolean (find-restart 'unpause)))


(definition public (%%pause)
  (with-restart-catcher 'unpause "Unpause"
    (lambda ()
      (declare (proper-tail-calls))
      (with-tick
        (lambda (entity script time elapse iter)
          (when (is? entity Actor)
            (%%perform-stay))
          (iter))))))


(definition public (%%unpause)
  (let ((restart (find-restart 'unpause)))
    (when restart
      (invoke-restart restart))))


(definition public (%%toggle-paused)
  (if (%%paused?)
      (%%unpause)
    (%%pause)))


;;;
;;;; Move
;;;


(definition public (%%stay)
  (declare (proper-tail-calls))
  (with-tick
    (lambda (actor script time elapse iter)
      (%%perform-stay)
      (iter))))


(definition public (%%move distance)
  (declare (proper-tail-calls))
  (let ((actor (%%current-actor)))
    (let ((start (copy-vertex (get-position~ actor)))
          (target (vertex+ (get-position~ actor) (vertex-scalar*& (get-sight~ actor) distance)))
          (line #f))
      (with-tick
        (lambda (actor script time elapse iter)
          (%%perform-move)
          (let ((traveled (vertex-distance (get-position~ actor) start)))
            (when (get-trail?~ script)
              (let ((end (copy-vertex (get-position~ actor))))
                (if (not line)
                    (let ((l (list start end (get-trail-color~ script))))
                      (trail-line actor l)
                      (set! line l))
                  (set-second! line end))))
            (if (< traveled distance)
                (iter)
              (unless (get-paused?~ (current-history))
                (when line
                  (set-second! line target))))))))))


(definition public (%%move-to target)
  (declare (proper-tail-calls))
  (let ((actor (%%current-actor)))
    (let ((start (copy-vertex (get-position~ actor)))
          (distance (vertex-distance (get-position~ actor) target))
          (line #f))
      (let ((direction (vertex-& target (get-position~ actor))))
        (unless (vertex-zero? direction)
          (%%set-lookat actor (horizon-lookat (vertex-normalize& direction)))
          (with-tick
            (lambda (actor script time elapse iter)
              (%%perform-move
                (lambda ()
                  (let ((traveled (vertex-distance (get-position~ actor) start)))
                    (when (>= traveled distance)
                      (set-position~ actor target)))))
              (let ((traveled (vertex-distance (get-position~ actor) start)))
                (when (get-trail?~ script)
                  (let ((end (copy-vertex (get-position~ actor))))
                    (if (not line)
                        (let ((l (list start end (get-trail-color~ script))))
                          (trail-line actor l)
                          (set! line l))
                      (set-second! line end))))
                (if (< traveled distance)
                    (iter)
                  (unless (get-paused?~ (current-history))
                    (when line
                      (set-second! line target))))))))))))


(definition public (%%rotate angle)
  (declare (proper-tail-calls))
  (let ((actor (%%current-actor)))
    (unless (= angle 0.)
      (let ((start (copy-vertex (get-sight~ actor)))
            (target (rotate-upon angle (vertex& 0. 1. 0.) (get-sight~ actor)))
            (perform (if (> angle 0.) %%perform-rotate-left %%perform-rotate-right))
            (test (if (> angle 0.) > <)))
        (with-tick
          (lambda (actor script time elapse iter)
            (perform)
            (let ((traveled (vector-signed-angle start (get-sight~ actor) (vertex& 0. 1. 0.))))
              (if (not (test traveled angle))
                  (iter)
                (unless (get-paused?~ (current-history))
                  (%%set-lookat actor (horizon-lookat target)))))))))))


(definition public (%%jump actor (impulsion #f))
  (set-jump?~ actor #t)
  (set-jump-impulsion~ actor impulsion)
  (when (eq? actor (%%current-actor))
    ;; kinda quick hack
    (parameterize ((current-event (new Tick-Event actor (current-seconds) 0.)))
      (%%perform-jump))))


(definition public (%%path actor)
  (let ((world (current-world))
        (history (current-history)))
    (let ((tick-count -1)
          (path-duration #f))
      (define (prepare-pathing)
        (set! path-duration (random-between 1. 5.)))
      
      (define (path-actor)
        (cond ((< (random-real) .333)
               (set-motion~ actor 'idle))
              (else
               (set-motion~ actor 'walk)
               (horizon-sight!~ actor (random-horizon))))
        (prepare-pathing))
      
      (declare (proper-tail-calls))
      (prepare-pathing)
      (with-tick
        (lambda (ignore-actor script time elapse iter)
          (unless (get-paused?~ history)
            (set! tick-count (modulo (+ tick-count 1) creature-ticks))
            (when (and path-duration (> path-duration 0.))
              (decrease! path-duration elapse))
            (%%move-actor actor time elapse)
            (when (<= path-duration 0.)
              (path-actor)))
          (iter))))))


(definition (%%move-actor actor time elapse)
  (define (random-jump?)
    (let ((number .005 @w (random-jump)))
      (and number (< (random-real) number))))
  
  (let ((gravity? #t)
        (response 'slide)
        (ignore-entities? #t)
        (ignore-players? #f)
        (ignore-me? #f))
    (let ((idle? (eq? (get-motion~ actor) 'idle)))
      (if (and (get-jump?~ actor) (not idle?))
          (begin
            (set-jump?~ actor #f)
            (tick-actor~ actor move/jump-commands time elapse gravity? response ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: #f))
        (let ((commands (if idle? stay-commands move-commands)))
          (let ((info (tick-actor~ actor commands time elapse gravity? response ignore-entities?: ignore-entities? ignore-players?: ignore-players? ignore-me?: ignore-me? proportional-slide?: #f)))
            (when (and info (or (not (get-jump-time~ actor)) (> time (+ (get-jump-time~ actor) (if #f @w aggro-target 1. 2.)))))
              (bind-values (center slide-collisions fall-collisions) info
                (when (or (not-null? slide-collisions) (random-jump?))
                  (set-jump?~ actor #t))))))))))


;;;
;;;; LookAt
;;;


(definition public (%%lookat-horizon dir)
  (horizon-lookat (vertex-normalize& (vertex& (vertex-x dir) 0. (vertex-z dir)))))


(definition public (%%lookat-player actor)
  (let ((dir (vertex-& (get-position~ (current-me)) (get-position~ actor))))
    (unless (vertex-xz-zero? dir)
      (%%set-lookat actor (%%lookat-horizon dir)))))


(definition public (%%lookat-target target actor)
  (let ((dir (vertex- target (get-position~ actor))))
    (unless (vertex-xz-zero? dir)
      (%%set-lookat actor (%%lookat-horizon dir)))))


(definition public (%%lookat-rotate element angle)
  (%%set-lookat element (rotate-lookat (get-lookat~ element) (degree->radian angle) (vertex 0. 1. 0.))))


;;;
;;;; Aggro
;;;


;; not correct should get info dynamically
(definition protected creature-ticks <fx>
  (fxround creature-rate))

;; aggro 5 times per second
(definition protected aggro-ticks <fx>
  (fxround/ creature-ticks 5))


;;;
;;;; Block
;;;


@too-much-for-now-to-be-obstructed-by-blocks
(definition public (with-script-interaction position proc)
  (let ((world (current-world))
        (game (current-game))
        (actor (%%current-actor)))
    (let ((max-distance (get-view-radius~ world))
          (lens (lens-center~ actor)))
      (let ((direction (vertex-normalize (vertex- position lens))))
        (let ((closest (ray-closest-polygon lens direction max-distance ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
          (when closest
            (let ((poly (car closest)))
              (when poly
                (with-polygon-interaction~ game poly
                  (lambda (poly block fore)
                    (proc poly fore)))))))))))


(definition public (%%add-block location id)
  (let ((game (current-game)))
    (apply-add-block~ game (location->position location) id 0)))


(definition public (%%delete-block position)
  )


(definition public (%%change-block position id)
  )


(definition public (%%add-entity class id pos lookat model script)
  (let ((world (current-world))
        (game (current-game)))
    (let ((entity (apply-add-entity~ game class id pos lookat model)))
      (when script
        (let ((script (new world.scripter:Script parent: entity text: (load-script-text (find-script~ world script)))))
          (run-task~ entity script)))
      entity)))


(definition public (with-location location proc (create?: create? #t))
  (let ((game (current-game))
        (zone (current-zone)))
    (updating-sections~ zone
      (lambda (add-section)
        (call-with-position~ zone (location->position location)
          (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
            (with-field i j k
              (lambda (section index)
                (proc add-section section index block-ref block-set! data-ref data-set!))))
          create?: create?))
      script?: #t)))


(definition public (%%get-block location)
  (or (with-location location
        (lambda (add-section section index block-ref block-set! data-ref data-set!)
          (block-ref section index))
        create?: #f)
      0 @wait Air))


(definition public (%%set-block location id)
  (with-location location
    (lambda (add-section section index block-ref block-set! data-ref data-set!)
      (block-set! section index id)
      (add-section section))))


(definition public (%%set-block-data location data)
  (with-location location
    (lambda (add-section section index block-ref block-set! data-ref data-set!)
      (data-set! section index data)
      (add-section section))))


(definition public (%%interact-block location)
  (let ((game (current-game)))
    (interact-at~ game (location->position location))))


;;;
;;;; Trail
;;;


(definition public (%%trail (color #f))
  (let ((zone (current-zone)))
    (let ((actor (%%current-actor)))
      (let ((script (get-script~ actor)))
        (set-trail?~ script #t)
        (when (not (get-trail~ script))
          (set-trail~ script (new-queue)))
        (when color
          (set-trail-color~ script (case color
                                     ((red) red-dye)
                                     ((green) green-dye)
                                     (else blue-dye))))
        (register-draw~ zone actor
          (lambda ()
            (draw-trail actor)))))))


(definition public (%%untrail)
  (let ((zone (current-zone)))
    (let ((actor (%%current-actor)))
      (let ((script (get-script~ actor)))
        (set-trail?~ script #f)
        @w
        (unregister-draw~ zone actor)))))


(definition public (%%trail-color color)
  (let ((zone (current-zone)))
    (let ((actor (%%current-actor)))
      (let ((script (get-script~ actor)))
        (set-trail-color~ script (case color
                                   ((red) red-dye)
                                   ((green) green-dye)
                                   (else blue-dye)))))))


(definition public (%%clear-trail)
  (let ((actor (%%current-actor)))
    (let ((script (get-script~ actor)))
      (set-trail~ script (new-queue)))))


(definition (trail-line actor line)
  (let ((script (get-script~ actor)))
    (enqueue (get-trail~ script) line)))


(definition (draw-trail actor)
  (let ((script (get-script~ actor)))
    (for-each (lambda (line)
                (bind (start end color) line
                  (render-line start
                               end
                               .04
                               (or color blue-dye))))
              (queue-list (get-trail~ script))))))
