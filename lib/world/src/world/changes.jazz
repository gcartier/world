;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Changes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.changes jazz


(import (jazz.editor.jazz)
        (jazz.text)
        (world)
        (world.autoload)
        (world.change)
        (world.commands)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.id)
        (world.index)
        (world.log)
        (world.parts)
        (world.script.entity)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Move
;;;


(define-change move
  ;; action
  action-layout: '(entity commands double)
  action-store: (lambda (push entity commands elapse)
                  (push-entity push entity)
                  (push-commands push commands)
                  (push-double push elapse))
  action-apply: (lambda (client-id pop)
                  (let* ((entity (pop-entity pop))
                         (commands (pop-commands pop))
                         (elapse (pop-double pop)))
                    (tick~ entity commands (current-seconds) elapse)))
  ;; forward
  forward-layout: '(entity vertex vertex)
  forward-store: (lambda (push entity new-position new-velocity)
                   (push-entity push entity)
                   (push-vertex push new-position)
                   (push-vertex push new-velocity))
  forward-apply: (lambda (client-id pop)
                   (let* ((entity (pop-entity pop))
                          (position (pop-vertex& pop))
                          (velocity (pop-vertex& pop)))
                     (set-position~ entity position)
                     (set-effective-velocity~ entity velocity)
                     (adjust-motion-target~ entity)))
  ;; backward
  backward-layout: '(entity vertex vertex)
  backward-store: (lambda (push entity old-position old-velocity)
                    (push-entity push entity)
                    (push-vertex push old-position)
                    (push-vertex push old-velocity))
  backward-apply: (lambda (client-id pop)
                    (let* ((entity (pop-entity pop))
                           (old-position (pop-vertex& pop))
                           (old-velocity (pop-vertex& pop)))
                      (set-position~ entity old-position)
                      (set-effective-velocity~ entity old-velocity))))


(definition protected (move-change time entity commands elapse old-position new-position old-velocity new-velocity)
  (let ((world (current-world))
        (history (current-history)))
    (unless (or (not (get-id~ entity))
                (not (record-change? entity))
                (and (get-paused?~ history) (not (stepping-history?)))
                (and (vertex-near? new-position old-position)
                     (vertex-near? new-velocity old-velocity))
                (admin-me?~ entity))
      (bidirectional-change 'move time
        (lambda (store push)
          (store push entity commands elapse))
        (lambda (store push)
          (store push entity new-position new-velocity))
        (lambda (store push)
          (store push entity old-position old-velocity))
        metadata: (snapshot-metadata~ world entity)))))


;;;
;;;; Lookat
;;;


(define-change lookat
  ;; action
  action-layout: '(entity commands double)
  action-store: (lambda (push entity commands elapse)
                  (push-entity push entity)
                  (push-commands push commands)
                  (push-double push (or elapse -1.)))
  action-apply: (lambda (client-id pop)
                  (let* ((entity (pop-entity pop))
                         (commands (pop-commands pop))
                         (elapse (pop-double pop)))
                    ;; quick hack for track-ground
                    (when commands
                      (tick~ entity commands (current-seconds) elapse))))
  ;; forward
  forward-layout: '(entity lookat)
  forward-store: (lambda (push entity new-lookat)
                   (push-entity push entity)
                   (push-lookat push new-lookat))
  forward-apply: (lambda (client-id pop)
                   (let* ((entity (pop-entity pop))
                          (new-lookat (pop-lookat& pop)))
                     (set-lookat~ entity new-lookat)
                     (adjust-motion-target~ entity)))
  ;; backward
  backward-layout: '(entity lookat)
  backward-store: (lambda (push entity old-lookat)
                    (push-entity push entity)
                    (push-lookat push old-lookat))
  backward-apply: (lambda (client-id pop)
                    (let* ((entity (pop-entity pop))
                           (old-lookat (pop-lookat& pop)))
                      (set-lookat~ entity old-lookat))))


(definition protected (lookat-change time entity commands elapse old-lookat new-lookat)
  (let ((world (current-world))
        (history (current-history)))
    (unless (or (not (get-id~ entity))
                (not (record-change? entity))
                (and (get-paused?~ history) (not (stepping-history?)))
                (lookat-near? new-lookat old-lookat)
                (admin-me?~ entity))
      (bidirectional-change 'lookat time
        (lambda (store push)
          (store push entity commands elapse))
        (lambda (store push)
          (store push entity new-lookat))
        (lambda (store push)
          (store push entity old-lookat))
        metadata: (snapshot-metadata~ world entity)))))
  
  
(definition protected (lookat-horizon-change entity dir)
  (unless (vertex-near-zero? dir)
    (let ((old-lookat (lookat-copy& (get-lookat~ entity))))
      (horizon-sight!~ entity dir)
      (let ((new-lookat (get-lookat~ entity)))
        (lookat-change (current-seconds) entity #f #f old-lookat new-lookat)))))


;;;
;;;; Animate
;;;


(define-change animate
  ;; forward
  forward-layout: '(entity literal)
  forward-store: (lambda (push entity new-animation)
                   (push-entity push entity)
                   (push-literal push new-animation))
  forward-apply: (lambda (client-id pop)
                   (let* ((entity (pop-entity pop))
                          (new-animation (pop-literal pop)))
                     ;; aec robust
                     (if (not (find-animation~ (cache-model~ entity) new-animation))
                         (log-server (format "Unable to find animation {a}" new-animation))
                       (change-morphing~ entity new-animation))))
  ;; backward
  backward-layout: '(entity literal)
  backward-store: (lambda (push entity old-animation)
                    (push-entity push entity)
                    (push-literal push old-animation))
  backward-apply: (lambda (client-id pop)
                    (let* ((entity (pop-entity pop))
                           (old-animation (pop-literal pop)))
                      ;; limit-case for first animate
                      (when old-animation
                        (change-morphing~ entity old-animation)))))


(definition protected (animate-change time entity old-animation new-animation)
  (let ((world (current-world))
        (history (current-history)))
    (unless (or (not (get-id~ entity))
                (not (record-change? entity))
                (and (get-paused?~ history) (not (stepping-history?)))
                (equal? new-animation old-animation)
                (admin-me?~ entity))
      (bidirectional-change 'animate time
        (lambda (store push)
          (store push entity new-animation))
        (lambda (store push)
          (store push entity new-animation))
        (lambda (store push)
          (store push entity old-animation))))))


;;;
;;;; Block
;;;


(define-change add-block
  ;; forward
  forward-layout: '(vertex integer integer)
  forward-store: (lambda (push position block-id data-id)
                   (push-vertex push position)
                   (push-integer push block-id)
                   (push-integer push data-id))
  forward-apply: (lambda (client-id pop)
                   (let* ((position (pop-vertex pop))
                          (block-id (pop-integer pop))
                          (data-id (pop-integer pop)))
                     (apply-add-block~ (current-game) position block-id data-id)))
  ;; backward
  backward-layout: '(vertex integer integer)
  backward-store: (lambda (push position replaced-block-id replaced-data-id)
                    (push-vertex push position)
                    (push-integer push replaced-block-id)
                    (push-integer push replaced-data-id))
  backward-apply: (lambda (client-id pop)
                    (let* ((position (pop-vertex pop))
                           (replaced-block-id (pop-integer pop))
                           (replaced-data-id (pop-integer pop)))
                      (apply-restore-block~ (current-game) position replaced-block-id replaced-data-id))))


(define-change delete-block
  ;; forward
  forward-layout: '(vertex)
  forward-store: (lambda (push position)
                   (push-vertex push position))
  forward-apply: (lambda (client-id pop)
                   (let* ((position (pop-vertex pop)))
                     (apply-delete-block~ (current-game) position)))
  ;; backward
  backward-layout: '(vertex integer integer)
  backward-store: (lambda (push position block-id data-id)
                    (push-vertex push position)
                    (push-integer push block-id)
                    (push-integer push data-id))
  backward-apply: (lambda (client-id pop)
                    (let* ((position (pop-vertex pop))
                           (block-id (pop-integer pop))
                           (data-id (pop-integer pop)))
                      (apply-restore-block~ (current-game) position block-id data-id))))


;;;
;;;; Entity
;;;


(define-change add-entity
  ;; forward
  forward-layout: '(class id vertex lookat literal)
  forward-store: (lambda (push entity position lookat)
                   (push-class push (class-of entity))
                   (push-id push (get-id~ entity))
                   (push-vertex push position)
                   (push-lookat push lookat)
                   (push-literal push (get-model~ entity)))
  forward-apply: (lambda (client-id pop)
                   (let* ((class (pop-class pop))
                          (entity-id (pop-id pop))
                          (position (pop-vertex pop))
                          (lookat (pop-lookat pop))
                          (model (pop-literal pop)))
                     (apply-add-entity~ (current-game) class entity-id position lookat model)))
  ;; backward
  backward-layout: '(entity)
  backward-store: (lambda (push entity)
                    (push-entity push entity))
  backward-apply: (lambda (client-id pop)
                    (let* ((entity (pop-entity pop)))
                      (apply-remove-entity~ (current-game) entity))))


(define-change remove-entity
  ;; forward
  forward-layout: '(entity)
  forward-store: (lambda (push entity)
                   (push-entity push entity))
  forward-apply: (lambda (client-id pop)
                   (let* ((entity (pop-entity pop)))
                     (apply-remove-entity~ (current-game) entity)))
  ;; backward
  backward-layout: '(class id vertex lookat literal)
  backward-store: (lambda (push entity)
                    (push-class push (class-of entity))
                    (push-id push (get-id~ entity))
                    (push-vertex push (get-position~ entity))
                    (push-lookat push (get-lookat~ entity))
                    (push-literal push (get-model~ entity)))
  backward-apply: (lambda (client-id pop)
                    (let* ((class (pop-class pop))
                           (entity-id (pop-id pop))
                           (position (pop-vertex pop))
                           (lookat (pop-lookat pop))
                           (model (pop-literal pop)))
                      (apply-add-entity~ (current-game) class entity-id position lookat model))))


;;;
;;;; Action
;;;


(define-change action
  ;; forward
  forward-layout: '(vertex)
  forward-store: (lambda (push position)
                   (push-vertex push position))
  forward-apply: (lambda (client-id pop)
                   (let* ((position (pop-vertex pop)))
                     (apply-action~ (current-game) position)))
  ;; backward
  backward-layout: '()
  backward-store: (lambda (push)
                    )
  backward-apply: (lambda (client-id pop)
                    ))


;;;
;;;; Interact
;;;


(define-change interact
  ;; forward
  forward-layout: '(entity)
  forward-store: (lambda (push obj)
                   (push-entity push obj))
  forward-apply: (lambda (client-id pop)
                   (let* ((entity (pop-entity pop)))
                     (apply-interact~ (current-game) entity)))
  ;; backward
  backward-layout: '()
  backward-store: (lambda (push)
                    )
  backward-apply: (lambda (client-id pop)
                    ))


;;;
;;;; Script
;;;


(definition protected (edit-script-change time entity edit?)
  (unless (server?)
    (let ((history (current-history)))
      ;; quicky
      (unless (is? entity Script-Entity)
        (unless (get-paused?~ history)
          (bidirectional-change 'edit-script time
            (lambda (store push)
              (store push))
            (lambda (store push)
              (store push entity edit?))
            (lambda (store push)
              (store push entity edit?))))))))


(define-change edit-script
  ;; forward
  forward-layout: '(entity boolean)
  forward-store: (lambda (push entity edit?)
                   (push-entity push entity)
                   (push-boolean push edit?))
  forward-apply: (lambda (client-id pop)
                   (let* ((entity (pop-entity pop))
                          (edit? (pop-literal pop)))
                     (edit-script client-id entity edit?)))
  ;; backward
  backward-layout: '(entity boolean)
  backward-store: (lambda (push entity edit?)
                    (push-entity push entity)
                    (push-boolean push edit?))
  backward-apply: (lambda (client-id pop)
                    (let* ((entity (pop-entity pop))
                           (edit? (pop-literal pop)))
                      (edit-script client-id entity (not edit?)))))


(definition protected (update-script-change time entity range strings undo-range undo-strings)
  (unless (server?)
    (let ((history (current-history)))
      (unless (get-paused?~ history)
        (bidirectional-change 'update-script time
          (lambda (store push)
            (store push))
          (lambda (store push)
            (store push entity range strings))
          (lambda (store push)
            (store push entity undo-range undo-strings)))))))


(define-change update-script
  ;; forward
  forward-layout: '(entity literal literal)
  forward-store: (lambda (push entity range strings)
                   (push-entity push entity)
                   (push-literal push range)
                   (push-literal push strings))
  forward-apply: (lambda (client-id pop)
                   (let* ((entity (pop-entity pop))
                          (range (pop-literal pop))
                          (strings (pop-literal pop)))
                     (forward-script client-id entity range strings)))
  ;; backward
  backward-layout: '(entity literal literal)
  backward-store: (lambda (push entity range strings)
                    (push-entity push entity)
                    (push-literal push range)
                    (push-literal push strings))
  backward-apply: (lambda (client-id pop)
                    (let* ((entity (pop-entity pop))
                           (range (pop-literal pop))
                           (strings (pop-literal pop)))
                      (let ((interface (current-interface)))
                        (when interface
                          (let ((pane (child~ interface 'script)))
                            (when (and (get-visible?~ pane)
                                       (eq? (get-edited~ pane) entity))
                              (let ((text (locate~ pane '(script text))))
                                ;; collabo quick hack for tests
                                (when (nu=? (valid-range~ text range) range)
                                  (replace~ text range strings))))))))))


(definition protected edited-views
  (make-table test: eq?))


(class Server-Text-View extends Jazz-Text-View)


(definition (edit-script client-id entity edit?)
  (when (processing?)
    (let ((views (table-ref edited-views entity '())))
      (if edit?
          (let ((text (new Server-Text-View)))
            (if (null? views)
                (let ((script (get-script~ entity)))
                  (when script
                    (set-string-content~ text (get-text~ script))))
              (set-model~ text (get-model~ (cdar views))))
            (table-set! edited-views entity (cons (cons client-id text) views)))
        (let ((pair (assq client-id views)))
          (when pair
            (table-set! edited-views entity (remove! pair views))))))))


(definition protected inhibit-content-changes?
  (make-parameter #f))


(definition (forward-script client-id entity range strings)
  (let ((zone (current-zone)))
    (when (processing?)
      (let ((views (table-ref edited-views entity '())))
        (let ((pair (assq client-id views)))
          (when pair
            (let ((text (cdr pair)))
              ;; collabo quick hack for tests
              (when (nu=? (valid-range~ text range) range)
                (replace~ text range strings)
                (let ((script (need-script~ zone entity)))
                  (write-element~ zone script 'text (get-string-content~ text)))))))))
    (let ((interface (current-interface)))
      (let ((pane (child~ interface 'script)))
        (if (and (get-visible?~ pane)
                 (eq? (get-edited~ pane) entity))
            (let ((text (locate~ pane '(script text))))
              (parameterize ((inhibit-content-changes? #t))
                ;; collabo quick hack for tests
                (when (nu=? (valid-range~ text range) range)
                  (replace~ (get-model~ text) range strings)
                  (save-script~ pane)
                  (let ((script (need-script~ zone entity)))
                    (evaluate-script~ (get-edited~ pane) script)))))
          ;; collabo mega quick test
          (let ((text (new Server-Text-View))
                (script (need-script~ zone entity)))
            (when script
              (when (get-text~ script)
                (set-string-content~ text (get-text~ script)))
              (parameterize ((inhibit-content-changes? #t))
                ;; collabo quick hack for tests
                (when (nu=? (valid-range~ text range) range)
                  (replace~ text range strings)))
              (write-element~ zone script 'text (get-string-content~ text))
              (evaluate-script~ entity script))))))))


;;;
;;;; Chest
;;;


(definition protected (update-chest-change time position slot id undo-slot undo-id)
  (let ((history (current-history)))
    (unless (get-paused?~ history)
      (bidirectional-change 'update-chest time
        (lambda (store push)
          (store push))
        (lambda (store push)
          (store push position slot id))
        (lambda (store push)
          (store push position undo-slot undo-id))))))


(definition protected (apply-chest-update client-id position slot id)
  )


(define-change update-chest
  ;; forward
  forward-layout: '(vertex integer integer)
  forward-store: (lambda (push position slot id)
                   (push-vertex push position)
                   (push-integer push slot)
                   (push-integer push id))
  forward-apply: (lambda (client-id pop)
                   (let* ((position (pop-vertex pop))
                          (slot (pop-integer pop))
                          (id (pop-integer pop)))
                     (apply-chest-update client-id position slot id)))
  ;; backward
  backward-layout: '(entity literal literal)
  backward-store: (lambda (push entity range strings)
                    (push-entity push entity)
                    (push-literal push range)
                    (push-literal push strings))
  backward-apply: (lambda (client-id pop)
                    (let* ((position (pop-vertex pop))
                           (slot (pop-integer pop))
                           (id (pop-integer pop)))
                      (apply-chest-update client-id position slot id)))))
