;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Changes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.changes jazz


(import (world)
        (world.autoload)
        (world.change)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Move
;;;


(define-change move
  forward-count: 7
  forward-store: (lambda (push entity new-position new-velocity)
                   (push (cast <fl> (literal->id (get-id~ entity))))
                   (push (vertex-x new-position))
                   (push (vertex-y new-position))
                   (push (vertex-z new-position))
                   (push (vertex-x new-velocity))
                   (push (vertex-y new-velocity))
                   (push (vertex-z new-velocity)))
  forward-apply: (lambda (pop time)
                   (let* ((id (pop))
                          (x (pop))
                          (y (pop))
                          (z (pop))
                          (vx (pop))
                          (vy (pop))
                          (vz (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                       (when entity
                         @improve-simulation
                         (unless (local?)
                           (terminal (vertex-distance (vertex& x y z) (get-position~ entity))))
                         (set-position~ entity (vertex& x y z))
                         (set-effective-velocity~ entity (vertex& vx vy vz))))))
  backward-count: 7
  backward-store: (lambda (push entity old-position old-velocity)
                    (push (cast <fl> (literal->id (get-id~ entity))))
                    (push (vertex-x old-position))
                    (push (vertex-y old-position))
                    (push (vertex-z old-position))
                    (push (vertex-x old-velocity))
                    (push (vertex-y old-velocity))
                    (push (vertex-z old-velocity)))
  backward-apply: (lambda (pop time)
                    (let* ((id (pop))
                           (x (pop))
                           (y (pop))
                           (z (pop))
                           (vx (pop))
                           (vy (pop))
                           (vz (pop)))
                      (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                        (when entity
                          (set-position~ entity (vertex& x y z))
                          (set-effective-velocity~ entity (vertex& vx vy vz)))))))


(definition protected (move-change time entity old-position new-position old-velocity new-velocity)
  (let ((world (current-world))
        (history (current-history))
        (me (current-me)))
    (let ((id (get-id~ entity)))
      (unless (or (not id)
                  (neq? entity me)
                  (get-paused?~ history)
                  (and (vertex-near? new-position old-position)
                       (vertex-near? new-velocity old-velocity))
                  (admin?))
        (bidirectional-change 'move time
          (lambda (store push)
            (store push entity new-position new-velocity))
          (lambda (store push)
            (store push entity old-position old-velocity))
          metadata: (snapshot-metadata~ world))))))


;;;
;;;; Lookat
;;;


(define-change lookat
  forward-count: 10
  forward-store: (lambda (push entity new-lookat)
                   (let ((sight (get-sight~ new-lookat))
                         (up (get-up~ new-lookat))
                         (right (get-right~ new-lookat)))
                     (push (cast <fl> (literal->id (get-id~ entity))))
                     (push (vertex-x sight))
                     (push (vertex-y sight))
                     (push (vertex-z sight))
                     (push (vertex-x up))
                     (push (vertex-y up))
                     (push (vertex-z up))
                     (push (vertex-x right))
                     (push (vertex-y right))
                     (push (vertex-z right))))
  forward-apply: (lambda (pop time)
                   (let* ((id (pop))
                          (sx (pop))
                          (sy (pop))
                          (sz (pop))
                          (ux (pop))
                          (uy (pop))
                          (uz (pop))
                          (rx (pop))
                          (ry (pop))
                          (rz (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                       (when entity
                         (set-lookat~ entity (lookat& (vertex& sx sy sz) (vertex& ux uy uz) (vertex& rx ry rz)))))))
  backward-count: 10
  backward-store: (lambda (push entity old-lookat)
                    (let ((sight (get-sight~ old-lookat))
                          (up (get-up~ old-lookat))
                          (right (get-right~ old-lookat)))
                      (push (cast <fl> (literal->id (get-id~ entity))))
                      (push (vertex-x sight))
                      (push (vertex-y sight))
                      (push (vertex-z sight))
                      (push (vertex-x up))
                      (push (vertex-y up))
                      (push (vertex-z up))
                      (push (vertex-x right))
                      (push (vertex-y right))
                      (push (vertex-z right))))
  backward-apply: (lambda (pop time)
                    (let* ((id (pop))
                           (sx (pop))
                           (sy (pop))
                           (sz (pop))
                           (ux (pop))
                           (uy (pop))
                           (uz (pop))
                           (rx (pop))
                           (ry (pop))
                           (rz (pop)))
                      (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                        (when entity
                          (set-lookat~ entity (lookat& (vertex& sx sy sz) (vertex& ux uy uz) (vertex& rx ry rz))))))))


(definition protected (lookat-change time entity old-lookat new-lookat)
  (let ((world (current-world))
        (history (current-history))
        (me (current-me)))
    (let ((id (get-id~ entity)))
      (unless (or (not id)
                  (neq? entity me)
                  (get-paused?~ history)
                  (lookat-near? new-lookat old-lookat)
                  (admin?))
        (bidirectional-change 'lookat time
          (lambda (store push)
            (store push entity new-lookat))
          (lambda (store push)
            (store push entity old-lookat))
          metadata: (snapshot-metadata~ world))))))


;;;
;;;; Animate
;;;


(define-change animate
  forward-count: 2
  forward-store: (lambda (push entity new-animation)
                   (push (cast <fl> (literal->id (get-id~ entity))))
                   (push (cast <fl> (literal->id new-animation))))
  forward-apply: (lambda (pop time)
                   (let* ((id (pop))
                          (animation-id (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                       (when entity
                         (let ((animation (id->literal (flonum->fixnum animation-id))))
                           ;; aec robust
                           (when (find-animation~ (cache-model~ entity) animation)
                             (change-morphing~ entity animation)))))))
  backward-count: 2
  backward-store: (lambda (push entity old-animation)
                    (push (cast <fl> (literal->id (get-id~ entity))))
                    (push (cast <fl> (literal->id old-animation))))
  backward-apply: (lambda (pop time)
                    (let* ((id (pop))
                           (animation-id (pop)))
                      (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                        (when entity
                          (let ((animation (id->literal (flonum->fixnum animation-id))))
                            ;; limit-case for first animate
                            (when animation
                              (change-morphing~ entity animation))))))))


(definition protected (animate-change time entity old-animation new-animation)
  (let ((world (current-world))
        (history (current-history))
        (me (current-me)))
    (let ((id (get-id~ entity)))
      (unless (or (not id)
                  (neq? entity me)
                  (get-paused?~ history)
                  (equal? new-animation old-animation)
                  (admin?))
        (bidirectional-change 'animate time
          (lambda (store push)
            (store push entity new-animation))
          (lambda (store push)
            (store push entity old-animation)))))))


;;;
;;;; Add Block
;;;


(define-change add-block
  forward-count: 5
  forward-store: (lambda (push x y z id data-id)
                   (push x)
                   (push y)
                   (push z)
                   (push (cast <fl> id))
                   (push (cast <fl> data-id)))
  forward-apply: (lambda (pop time)
                   (let* ((x (pop))
                          (y (pop))
                          (z (pop))
                          (id (pop))
                          (data-id (pop)))
                     (let ((pos (vertex& x y z))
                           (id (flonum->fixnum id))
                           (data-id (flonum->fixnum data-id)))
                       (apply-add-block~ (current-game) pos id data-id))))
  backward-count: 5
  backward-store: (lambda (push x y z replaced replaced-data)
                    (push x)
                    (push y)
                    (push z)
                    (push (cast <fl> replaced))
                    (push (cast <fl> replaced-data)))
  backward-apply: (lambda (pop time)
                    (let* ((x (pop))
                           (y (pop))
                           (z (pop))
                           (replaced (pop))
                           (replaced-data (pop)))
                      (let ((pos (vertex& x y z))
                            (replaced (flonum->fixnum replaced))
                            (replaced-data (flonum->fixnum replaced-data)))
                        (apply-restore-block~ (current-game) pos replaced replaced-data)))))


;;;
;;;; Delete Block
;;;


(define-change delete-block
  forward-count: 3
  forward-store: (lambda (push x y z)
                   (push x)
                   (push y)
                   (push z))
  forward-apply: (lambda (pop time)
                   (let* ((x (pop))
                          (y (pop))
                          (z (pop)))
                     (let ((pos (vertex& x y z)))
                       (apply-delete-block~ (current-game) pos))))
  backward-count: 3
  backward-store: (lambda (push x y z block-id data-id)
                    (push x)
                    (push y)
                    (push z)
                    (push (cast <fl> block-id))
                    (push (cast <fl> data-id)))
  backward-apply: (lambda (pop time)
                    (let* ((x (pop))
                           (y (pop))
                           (z (pop))
                           (block-id (pop))
                           (data-id (pop)))
                      (let ((pos (vertex& x y z))
                            (block-id (flonum->fixnum block-id))
                            (data-id (flonum->fixnum data-id)))
                        (apply-restore-block~ (current-game) pos block-id data-id)))))


;;;
;;;; Add Entity
;;;


(define-change add-entity
  forward-count: 5
  forward-store: (lambda (push entity position)
                   (push (cast <fl> (literal->id (get-id~ entity))))
                   (push (vertex-x position))
                   (push (vertex-y position))
                   (push (vertex-z position))
                   (push (cast <fl> (literal->id (get-model~ entity)))))
  forward-apply: (lambda (pop time)
                   (let* ((id (pop))
                          (x (pop))
                          (y (pop))
                          (z (pop))
                          (model-id (pop)))
                     (let ((id (id->literal (flonum->fixnum id)))
                           (pos (vertex& x y z))
                           (model (id->literal (flonum->fixnum model-id))))
                       (apply-add-entity~ (current-game) id pos model))))
  backward-count: 1
  backward-store: (lambda (push entity)
                    (push (cast <fl> (literal->id (get-id~ entity)))))
  backward-apply: (lambda (pop time)
                    (let* ((id (pop)))
                      (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                        (if (not entity)
                            (debug 'unable 'to 'find id (id->literal (flonum->fixnum id)))
                          (apply-remove-entity~ (current-game) entity))))))


;;;
;;;; Remove Entity
;;;


(define-change remove-entity
  forward-count: 1
  forward-store: (lambda (push entity)
                   (push (cast <fl> (literal->id (get-id~ entity)))))
  forward-apply: (lambda (pop time)
                   (let* ((id (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                       (if (not entity)
                           (debug 'unable 'to 'find id (id->literal (flonum->fixnum id)))
                         (apply-remove-entity~ (current-game) entity)))))
  backward-count: 5
  backward-store: (lambda (push entity)
                    (let ((pos (get-position~ entity)))
                      (push (cast <fl> (literal->id (get-id~ entity))))
                      (push (vertex-x pos))
                      (push (vertex-y pos))
                      (push (vertex-z pos))
                      (push (cast <fl> (literal->id (get-model~ entity))))))
  backward-apply: (lambda (pop time)
                    (let* ((id (pop))
                          (x (pop))
                          (y (pop))
                          (z (pop))
                          (model-id (pop)))
                     (let ((id (id->literal (flonum->fixnum id)))
                           (pos (vertex& x y z))
                           (model (id->literal (flonum->fixnum model-id))))
                       (apply-add-entity~ (current-game) id pos model)))))


;;;
;;;; Action
;;;


(define-change action
  forward-count: 3
  forward-store: (lambda (push x y z)
                   (push x)
                   (push y)
                   (push z))
  forward-apply: (lambda (pop time)
                   (let* ((x (pop))
                          (y (pop))
                          (z (pop)))
                     (let ((pos (vertex& x y z)))
                       (apply-action~ (current-game) pos))))
  backward-count: 0
  backward-store: (lambda (push)
                    )
  backward-apply: (lambda (pop time)
                    ))


;;;
;;;; Interact
;;;


(define-change interact
  forward-count: 1
  forward-store: (lambda (push id)
                   (push (cast <fl> id)))
  forward-apply: (lambda (pop time)
                   (let* ((id (pop)))
                     (apply-interact~ (current-game) (flonum->fixnum id))))
  backward-count: 0
  backward-store: (lambda (push)
                    )
  backward-apply: (lambda (pop time)
                    )))
