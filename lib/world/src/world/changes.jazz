;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Changes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.changes jazz


(import (jazz.editor.jazz)
        (jazz.text)
        (world)
        (world.autoload)
        (world.change)
        (world.commands)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.index)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Move
;;;


(define-change move
  action-count: 3
  action-store: (lambda (push entity commands elapse)
                  (push (cast <fl> (literal->id (get-id~ entity))))
                  (push (cast <fl> (encode~ commands)))
                  (push elapse))
  action-apply: (lambda (client-id pop time)
                  (let ((id (pop))
                        (commands-encoded (pop))
                        (elapse (pop)))
                    (let ((entity (find-entity (id->literal (flonum->fixnum id))))
                          (commands (new Commands)))
                      (when entity
                        (decode~ commands (flonum->fixnum commands-encoded))
                        (tick~ entity commands (current-seconds) elapse)))))
  forward-count: 7
  forward-store: (lambda (push entity new-position new-velocity)
                   (push (cast <fl> (literal->id (get-id~ entity))))
                   (push (vertex-x new-position))
                   (push (vertex-y new-position))
                   (push (vertex-z new-position))
                   (push (vertex-x new-velocity))
                   (push (vertex-y new-velocity))
                   (push (vertex-z new-velocity)))
  forward-apply: (lambda (client-id pop time)
                   (let* ((id (pop))
                          (x (pop))
                          (y (pop))
                          (z (pop))
                          (vx (pop))
                          (vy (pop))
                          (vz (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                       (when entity
                         @improve-simulation
                         (unless (local?)
                           (terminal (vertex-distance (vertex& x y z) (get-position~ entity))))
                         (set-position~ entity (vertex& x y z))
                         (set-effective-velocity~ entity (vertex& vx vy vz))))))
  backward-count: 7
  backward-store: (lambda (push entity old-position old-velocity)
                    (push (cast <fl> (literal->id (get-id~ entity))))
                    (push (vertex-x old-position))
                    (push (vertex-y old-position))
                    (push (vertex-z old-position))
                    (push (vertex-x old-velocity))
                    (push (vertex-y old-velocity))
                    (push (vertex-z old-velocity)))
  backward-apply: (lambda (client-id pop time)
                    (let* ((id (pop))
                           (x (pop))
                           (y (pop))
                           (z (pop))
                           (vx (pop))
                           (vy (pop))
                           (vz (pop)))
                      (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                        (when entity
                          (set-position~ entity (vertex& x y z))
                          (set-effective-velocity~ entity (vertex& vx vy vz)))))))


(definition protected (move-change time entity commands elapse old-position new-position old-velocity new-velocity)
  (let ((world (current-world))
        (history (current-history))
        (me (current-me)))
    (let ((id (get-id~ entity)))
      (unless (or (not id)
                  (neq? entity me)
                  (and (get-paused?~ history) (not (stepping-history?)))
                  (and (vertex-near? new-position old-position)
                       (vertex-near? new-velocity old-velocity))
                  (admin?))
        (bidirectional-change 'move time
          (lambda (store push)
            (store push entity commands elapse))
          (lambda (store push)
            (store push entity new-position new-velocity))
          (lambda (store push)
            (store push entity old-position old-velocity))
          metadata: (snapshot-metadata~ world))))))


;;;
;;;; Lookat
;;;


(define-change lookat
  action-count: 3
  action-store: (lambda (push entity commands elapse)
                  (push (cast <fl> (literal->id (get-id~ entity))))
                  (push (if commands (cast <fl> (encode~ commands)) -1.))
                  (push (or elapse -1.)))
  action-apply: (lambda (client-id pop time)
                  (let ((id (pop))
                        (commands-encoded (pop))
                        (elapse (pop)))
                    ;; quick hack around track-ground
                    (unless (= commands-encoded -1.)
                      (let ((entity (find-entity (id->literal (flonum->fixnum id))))
                            (commands (new Commands)))
                        (when entity
                          (decode~ commands (flonum->fixnum commands-encoded))
                          (tick~ entity commands (current-seconds) elapse))))))
  forward-count: 10
  forward-store: (lambda (push entity new-lookat)
                   (let ((sight (get-sight~ new-lookat))
                         (up (get-up~ new-lookat))
                         (right (get-right~ new-lookat)))
                     (push (cast <fl> (literal->id (get-id~ entity))))
                     (push (vertex-x sight))
                     (push (vertex-y sight))
                     (push (vertex-z sight))
                     (push (vertex-x up))
                     (push (vertex-y up))
                     (push (vertex-z up))
                     (push (vertex-x right))
                     (push (vertex-y right))
                     (push (vertex-z right))))
  forward-apply: (lambda (client-id pop time)
                   (let* ((id (pop))
                          (sx (pop))
                          (sy (pop))
                          (sz (pop))
                          (ux (pop))
                          (uy (pop))
                          (uz (pop))
                          (rx (pop))
                          (ry (pop))
                          (rz (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                       (when entity
                         (set-lookat~ entity (lookat& (vertex& sx sy sz) (vertex& ux uy uz) (vertex& rx ry rz)))))))
  backward-count: 10
  backward-store: (lambda (push entity old-lookat)
                    (let ((sight (get-sight~ old-lookat))
                          (up (get-up~ old-lookat))
                          (right (get-right~ old-lookat)))
                      (push (cast <fl> (literal->id (get-id~ entity))))
                      (push (vertex-x sight))
                      (push (vertex-y sight))
                      (push (vertex-z sight))
                      (push (vertex-x up))
                      (push (vertex-y up))
                      (push (vertex-z up))
                      (push (vertex-x right))
                      (push (vertex-y right))
                      (push (vertex-z right))))
  backward-apply: (lambda (client-id pop time)
                    (let* ((id (pop))
                           (sx (pop))
                           (sy (pop))
                           (sz (pop))
                           (ux (pop))
                           (uy (pop))
                           (uz (pop))
                           (rx (pop))
                           (ry (pop))
                           (rz (pop)))
                      (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                        (when entity
                          (set-lookat~ entity (lookat& (vertex& sx sy sz) (vertex& ux uy uz) (vertex& rx ry rz))))))))


(definition protected (lookat-change time entity commands elapse old-lookat new-lookat)
  (let ((world (current-world))
        (history (current-history))
        (me (current-me)))
    (let ((id (get-id~ entity)))
      (unless (or (not id)
                  (neq? entity me)
                  (and (get-paused?~ history) (not (stepping-history?)))
                  (lookat-near? new-lookat old-lookat)
                  (admin?))
        (bidirectional-change 'lookat time
          (lambda (store push)
            (store push entity commands elapse))
          (lambda (store push)
            (store push entity new-lookat))
          (lambda (store push)
            (store push entity old-lookat))
          metadata: (snapshot-metadata~ world))))))


;;;
;;;; Animate
;;;


(define-change animate
  forward-count: 2
  forward-store: (lambda (push entity new-animation)
                   (push (cast <fl> (literal->id (get-id~ entity))))
                   (push (cast <fl> (literal->id new-animation))))
  forward-apply: (lambda (client-id pop time)
                   (let* ((id (pop))
                          (animation-id (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                       (when entity
                         (let ((animation (id->literal (flonum->fixnum animation-id))))
                           ;; aec robust
                           (when (find-animation~ (cache-model~ entity) animation)
                             (change-morphing~ entity animation)))))))
  backward-count: 2
  backward-store: (lambda (push entity old-animation)
                    (push (cast <fl> (literal->id (get-id~ entity))))
                    (push (cast <fl> (literal->id old-animation))))
  backward-apply: (lambda (client-id pop time)
                    (let* ((id (pop))
                           (animation-id (pop)))
                      (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                        (when entity
                          (let ((animation (id->literal (flonum->fixnum animation-id))))
                            ;; limit-case for first animate
                            (when animation
                              (change-morphing~ entity animation))))))))


(definition protected (animate-change time entity old-animation new-animation)
  (let ((world (current-world))
        (history (current-history))
        (me (current-me)))
    (let ((id (get-id~ entity)))
      (unless (or (not id)
                  (neq? entity me)
                  (and (get-paused?~ history) (not (stepping-history?)))
                  (equal? new-animation old-animation)
                  (admin?))
        (bidirectional-change 'animate time
          (lambda (store push)
            (store push entity new-animation))
          (lambda (store push)
            (store push entity new-animation))
          (lambda (store push)
            (store push entity old-animation)))))))


;;;
;;;; Block
;;;


(define-change add-block
  forward-count: 5
  forward-store: (lambda (push x y z id data-id)
                   (push x)
                   (push y)
                   (push z)
                   (push (cast <fl> id))
                   (push (cast <fl> data-id)))
  forward-apply: (lambda (client-id pop time)
                   (let* ((x (pop))
                          (y (pop))
                          (z (pop))
                          (id (pop))
                          (data-id (pop)))
                     (let ((pos (vertex& x y z))
                           (id (flonum->fixnum id))
                           (data-id (flonum->fixnum data-id)))
                       (apply-add-block~ (current-game) pos id data-id))))
  backward-count: 5
  backward-store: (lambda (push x y z replaced replaced-data)
                    (push x)
                    (push y)
                    (push z)
                    (push (cast <fl> replaced))
                    (push (cast <fl> replaced-data)))
  backward-apply: (lambda (client-id pop time)
                    (let* ((x (pop))
                           (y (pop))
                           (z (pop))
                           (replaced (pop))
                           (replaced-data (pop)))
                      (let ((pos (vertex& x y z))
                            (replaced (flonum->fixnum replaced))
                            (replaced-data (flonum->fixnum replaced-data)))
                        (apply-restore-block~ (current-game) pos replaced replaced-data)))))


(define-change delete-block
  forward-count: 3
  forward-store: (lambda (push x y z)
                   (push x)
                   (push y)
                   (push z))
  forward-apply: (lambda (client-id pop time)
                   (let* ((x (pop))
                          (y (pop))
                          (z (pop)))
                     (let ((pos (vertex& x y z)))
                       (apply-delete-block~ (current-game) pos))))
  backward-count: 5
  backward-store: (lambda (push x y z block-id data-id)
                    (push x)
                    (push y)
                    (push z)
                    (push (cast <fl> block-id))
                    (push (cast <fl> data-id)))
  backward-apply: (lambda (client-id pop time)
                    (let* ((x (pop))
                           (y (pop))
                           (z (pop))
                           (block-id (pop))
                           (data-id (pop)))
                      (let ((pos (vertex& x y z))
                            (block-id (flonum->fixnum block-id))
                            (data-id (flonum->fixnum data-id)))
                        (apply-restore-block~ (current-game) pos block-id data-id)))))


;;;
;;;; Entity
;;;


(define-change add-entity
  forward-count: 6
  forward-store: (lambda (push entity position)
                   (push (cast <fl> (literal->id (category-name (class-of entity)))))
                   (push (cast <fl> (literal->id (get-id~ entity))))
                   (push (vertex-x position))
                   (push (vertex-y position))
                   (push (vertex-z position))
                   (push (cast <fl> (literal->id (get-model~ entity)))))
  forward-apply: (lambda (client-id pop time)
                   (let* ((class-id (pop))
                          (id (pop))
                          (x (pop))
                          (y (pop))
                          (z (pop))
                          (model-id (pop)))
                     (let ((class-name (id->literal (flonum->fixnum class-id)))
                           (id (id->literal (flonum->fixnum id)))
                           (pos (vertex& x y z))
                           (model (id->literal (flonum->fixnum model-id))))
                       (apply-add-entity~ (current-game) class-name id pos model))))
  backward-count: 1
  backward-store: (lambda (push entity)
                    (push (cast <fl> (literal->id (get-id~ entity)))))
  backward-apply: (lambda (client-id pop time)
                    (let* ((id (pop)))
                      (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                        (if (not entity)
                            (debug 'unable 'to 'find id (id->literal (flonum->fixnum id)))
                          (apply-remove-entity~ (current-game) entity))))))


(define-change remove-entity
  forward-count: 1
  forward-store: (lambda (push entity)
                   (push (cast <fl> (literal->id (get-id~ entity)))))
  forward-apply: (lambda (client-id pop time)
                   (let* ((id (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id)))))
                       (if (not entity)
                           (debug 'unable 'to 'find id (id->literal (flonum->fixnum id)))
                         (apply-remove-entity~ (current-game) entity)))))
  backward-count: 6
  backward-store: (lambda (push entity)
                    (let ((pos (get-position~ entity)))
                      (push (cast <fl> (literal->id (category-name (class-of entity)))))
                      (push (cast <fl> (literal->id (get-id~ entity))))
                      (push (vertex-x pos))
                      (push (vertex-y pos))
                      (push (vertex-z pos))
                      (push (cast <fl> (literal->id (get-model~ entity))))))
  backward-apply: (lambda (client-id pop time)
                    (let* ((class-id (pop))
                           (id (pop))
                           (x (pop))
                           (y (pop))
                           (z (pop))
                           (model-id (pop)))
                      (let ((class-name (id->literal (flonum->fixnum class-id)))
                            (id (id->literal (flonum->fixnum id)))
                            (pos (vertex& x y z))
                            (model (id->literal (flonum->fixnum model-id))))
                        (apply-add-entity~ (current-game) class-name id pos model)))))


;;;
;;;; Action
;;;


(define-change action
  forward-count: 3
  forward-store: (lambda (push x y z)
                   (push x)
                   (push y)
                   (push z))
  forward-apply: (lambda (client-id pop time)
                   (let* ((x (pop))
                          (y (pop))
                          (z (pop)))
                     (let ((pos (vertex& x y z)))
                       (apply-action~ (current-game) pos))))
  backward-count: 0
  backward-store: (lambda (push)
                    )
  backward-apply: (lambda (client-id pop time)
                    ))


;;;
;;;; Interact
;;;


(define-change interact
  forward-count: 1
  forward-store: (lambda (push id)
                   (push (cast <fl> id)))
  forward-apply: (lambda (client-id pop time)
                   (let* ((id (pop)))
                     (apply-interact~ (current-game) (flonum->fixnum id))))
  backward-count: 0
  backward-store: (lambda (push)
                    )
  backward-apply: (lambda (client-id pop time)
                    ))


;;;
;;;; Script
;;;


(define-change edit-script
  forward-count: 3
  forward-store: (lambda (push locator entity edit?)
                   (push (cast <fl> (literal->id locator)))
                   (push (cast <fl> (literal->id (get-id~ entity))))
                   (push (cast <fl> (literal->id edit?))))
  forward-apply: (lambda (client-id pop time)
                   (let* ((locator-id (pop))
                          (id (pop))
                          (edit-id (pop)))
                     (let ((locator (id->literal (flonum->fixnum locator-id))))
                       (let ((entity (find-entity-in locator (id->literal (flonum->fixnum id))))
                             (edit? (id->literal (flonum->fixnum edit-id))))
                         (when entity
                           (edit-script client-id entity edit?))))))
  backward-count: 3
  backward-store: (lambda (push locator entity edit?)
                    (push (cast <fl> (literal->id locator)))
                    (push (cast <fl> (literal->id (get-id~ entity))))
                    (push (cast <fl> (literal->id edit?))))
  backward-apply: (lambda (client-id pop time)
                    (let* ((locator-id (pop))
                           (id (pop))
                           (edit-id (pop)))
                      (let ((locator (id->literal (flonum->fixnum locator-id))))
                        (let ((entity (find-entity-in locator (id->literal (flonum->fixnum id))))
                              (edit? (id->literal (flonum->fixnum edit-id))))
                          (when entity
                            (edit-script client-id entity edit?)))))))


(definition protected (find-entity-in locator id)
  (let ((zone (current-zone)))
    (bind (section-x . section-z) locator
      ;; collabo quick test
      (let ((section-y 0))
        (index-chunk~ zone (indexed section-x section-y section-z))
        (let ((entity (find-entity id)))
          entity)))))


(definition protected (edit-script-change time entity edit?)
  (let ((history (current-history)))
    (unless (get-paused?~ history)
      (let ((locator (chunk-locator~ (get-designer-chunk~ entity))))
        (bidirectional-change 'edit-script time
          (lambda (store push)
            (store push))
          (lambda (store push)
            (store push locator entity edit?))
          (lambda (store push)
            (store push locator entity edit?)))))))


(define-change update-script
  forward-count: 3
  forward-store: (lambda (push entity range strings)
                   (push (cast <fl> (literal->id (get-id~ entity))))
                   (push (cast <fl> (literal->id range)))
                   (push (cast <fl> (literal->id strings))))
  forward-apply: (lambda (client-id pop time)
                   (let* ((id (pop))
                          (range-id (pop))
                          (strings-id (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id))))
                           (range (id->literal (flonum->fixnum range-id)))
                           (strings (id->literal (flonum->fixnum strings-id))))
                       (forward-script client-id entity range strings))))
  backward-count: 3
  backward-store: (lambda (push entity range strings)
                    (push (cast <fl> (literal->id (get-id~ entity))))
                    (push (cast <fl> (literal->id range)))
                    (push (cast <fl> (literal->id strings))))
  backward-apply: (lambda (client-id pop time)
                    (let* ((id (pop))
                          (range-id (pop))
                          (strings-id (pop)))
                     (let ((entity (find-entity (id->literal (flonum->fixnum id))))
                           (range (id->literal (flonum->fixnum range-id)))
                           (strings (id->literal (flonum->fixnum strings-id))))
                       (let ((interface (current-interface)))
                         (when interface
                           (let ((pane (child~ interface 'script)))
                             (when (and (get-visible?~ pane)
                                        (eq? (get-edited~ pane) entity))
                               (let ((text (locate~ pane '(script text))))
                                 ;; collabo quick hack for tests
                                 (when (nu=? (valid-range~ text range) range)
                                   (replace~ text range strings)))))))))))


(definition protected (update-script-change time entity range strings undo-range undo-strings)
  (let ((history (current-history)))
    (unless (get-paused?~ history)
      (bidirectional-change 'update-script time
        (lambda (store push)
          (store push))
        (lambda (store push)
          (store push entity range strings))
        (lambda (store push)
          (store push entity undo-range undo-strings))))))


(definition protected edited-views
  (make-table test: eq?))


(class Server-Text-View extends Jazz-Text-View)


(definition (edit-script client-id entity edit?)
  (when (server?)
    (let ((views (table-ref edited-views entity '())))
      (if edit?
          (let ((text (new Server-Text-View)))
            (when (not-null? views)
              (set-model~ text (get-model~ (cdar views))))
            (table-set! edited-views entity (cons (cons client-id text) views)))
        (let ((pair (assq client-id views)))
          (when pair
            (table-set! edited-views entity (remove! pair views))))))))


(definition protected inhibit-content-changes?
  (make-parameter #f))


(definition (forward-script client-id entity range strings)
  (let ((zone (current-zone)))
    (if (server?)
        (let ((views (table-ref edited-views entity '())))
          (let ((pair (assq client-id views)))
            (when pair
              (let ((text (cdr pair)))
                ;; collabo quick hack for tests
                (when (nu=? (valid-range~ text range) range)
                  (replace~ text range strings)
                  (let ((script (need-script~ zone entity)))
                    (write-element~ zone script 'text (get-string-content~ text))))))))
      (let ((interface (current-interface)))
        (let ((pane (child~ interface 'script)))
          (if (and (get-visible?~ pane)
                   (eq? (get-edited~ pane) entity))
              (let ((text (locate~ pane '(script text))))
                (parameterize ((inhibit-content-changes? #t))
                  ;; collabo quick hack for tests
                  (when (nu=? (valid-range~ text range) range)
                    (replace~ (get-model~ text) range strings)
                    (save-script~ pane)
                    (let ((script (need-script~ zone entity)))
                      (evaluate-script~ (get-edited~ pane) script)))))
            ;; collabo mega quick test
            (let ((text (new Server-Text-View))
                  (script (need-script~ zone entity)))
              (when script
                (when (get-text~ script)
                  (set-string-content~ text (get-text~ script)))
                (parameterize ((inhibit-content-changes? #t))
                  ;; collabo quick hack for tests
                  (when (nu=? (valid-range~ text range) range)
                    (replace~ text range strings)))
                (write-element~ zone script 'text (get-string-content~ text))
                (evaluate-script~ entity script))))))))))
