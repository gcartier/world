;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Changes
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.changes jazz


(import (world)
        (world.autoload)
        (world.change)
        (world.entity)
        (world.geometry)
        (world.history)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Move
;;;


(define-change move
  forward-count: 7
  forward-store: (lambda (push entity new-position new-velocity)
                   (push (cast <fl> (get-id~ entity)))
                   (push (vertex-x new-position))
                   (push (vertex-y new-position))
                   (push (vertex-z new-position))
                   (push (vertex-x new-velocity))
                   (push (vertex-y new-velocity))
                   (push (vertex-z new-velocity)))
  forward-apply: (lambda (pop time)
                   (let* ((id (pop))
                          (x (pop))
                          (y (pop))
                          (z (pop))
                          (vx (pop))
                          (vy (pop))
                          (vz (pop)))
                     (let ((entity (id->entity (flonum->fixnum id))))
                       @improve-simulation
                       (unless (local?)
                         (terminal (vertex-distance (vertex& x y z) (get-position~ entity))))
                       (set-position~ entity (vertex& x y z))
                       (set-effective-velocity~ entity (vertex& vx vy vz)))))
  backward-store: (lambda (push entity old-position old-velocity)
                    (push (cast <fl> (get-id~ entity)))
                    (push (vertex-x old-position))
                    (push (vertex-y old-position))
                    (push (vertex-z old-position))
                    (push (vertex-x old-velocity))
                    (push (vertex-y old-velocity))
                    (push (vertex-z old-velocity)))
  backward-apply: (lambda (pop time)
                    (let* ((id (pop))
                           (x (pop))
                           (y (pop))
                           (z (pop))
                           (vx (pop))
                           (vy (pop))
                           (vz (pop)))
                      (let ((entity (id->entity (flonum->fixnum id))))
                        (set-position~ entity (vertex& x y z))
                        (set-effective-velocity~ entity (vertex& vx vy vz))))))


(definition protected (move-change time entity old-position new-position old-velocity new-velocity)
  (let ((world (current-world))
        (history (current-history)))
    (let ((id (get-id~ entity)))
      (unless (or (not id)
                  (get-paused?~ history)
                  (and (vertex-near? new-position old-position)
                       (vertex-near? new-velocity old-velocity))
                  (admin?))
        (bidirectional-change 'move time
          (lambda (store push)
            (store push entity new-position new-velocity))
          (lambda (store push)
            (store push entity old-position old-velocity))
          metadata: (snapshot-metadata~ world))))))


;;;
;;;; Lookat
;;;


(define-change lookat
  forward-count: 10
  forward-store: (lambda (push entity new-lookat)
                   (let ((sight (get-sight~ new-lookat))
                         (up (get-up~ new-lookat))
                         (right (get-right~ new-lookat)))
                     (push (cast <fl> (get-id~ entity)))
                     (push (vertex-x sight))
                     (push (vertex-y sight))
                     (push (vertex-z sight))
                     (push (vertex-x up))
                     (push (vertex-y up))
                     (push (vertex-z up))
                     (push (vertex-x right))
                     (push (vertex-y right))
                     (push (vertex-z right))))
  forward-apply: (lambda (pop time)
                   (let* ((id (pop))
                          (sx (pop))
                          (sy (pop))
                          (sz (pop))
                          (ux (pop))
                          (uy (pop))
                          (uz (pop))
                          (rx (pop))
                          (ry (pop))
                          (rz (pop)))
                     (let ((entity (id->entity (flonum->fixnum id))))
                       (set-lookat~ entity (lookat& (vertex& sx sy sz) (vertex& ux uy uz) (vertex& rx ry rz))))))
  backward-store: (lambda (push entity old-lookat)
                    (let ((sight (get-sight~ old-lookat))
                          (up (get-up~ old-lookat))
                          (right (get-right~ old-lookat)))
                      (push (cast <fl> (get-id~ entity)))
                      (push (vertex-x sight))
                      (push (vertex-y sight))
                      (push (vertex-z sight))
                      (push (vertex-x up))
                      (push (vertex-y up))
                      (push (vertex-z up))
                      (push (vertex-x right))
                      (push (vertex-y right))
                      (push (vertex-z right))))
  backward-apply: (lambda (pop time)
                    (let* ((id (pop))
                           (sx (pop))
                           (sy (pop))
                           (sz (pop))
                           (ux (pop))
                           (uy (pop))
                           (uz (pop))
                           (rx (pop))
                           (ry (pop))
                           (rz (pop)))
                      (let ((entity (id->entity (flonum->fixnum id))))
                        (set-lookat~ entity (lookat& (vertex& sx sy sz) (vertex& ux uy uz) (vertex& rx ry rz)))))))


(definition protected (lookat-change time entity old-lookat new-lookat)
  (let ((world (current-world))
        (history (current-history)))
    (let ((id (get-id~ entity)))
      (unless (or (not id)
                  (get-paused?~ history)
                  (lookat-near? new-lookat old-lookat)
                  (admin?))
        (bidirectional-change 'lookat time
          (lambda (store push)
            (store push entity new-lookat))
          (lambda (store push)
            (store push entity old-lookat))
          metadata: (snapshot-metadata~ world))))))


;;;
;;;; Animate
;;;


(define-change animate
  forward-count: 2
  forward-store: (lambda (push entity new-animation)
                   (push (cast <fl> (get-id~ entity)))
                   (push (cast <fl> (literal->id new-animation))))
  forward-apply: (lambda (pop time)
                   (let* ((id (pop))
                          (animation-id (pop)))
                     (let ((entity (id->entity (flonum->fixnum id)))
                           (animation (id->literal (flonum->fixnum animation-id))))
                       (change-morphing~ entity animation))))
  backward-store: (lambda (push entity old-animation)
                    (push (cast <fl> (get-id~ entity)))
                    (push (cast <fl> (literal->id old-animation))))
  backward-apply: (lambda (pop time)
                    (let* ((id (pop))
                           (animation-id (pop)))
                      (let ((entity (id->entity (flonum->fixnum id)))
                            (animation (id->literal (flonum->fixnum animation-id))))
                        ;; limit-case for first animate
                        (when animation
                          (change-morphing~ entity animation))))))


(definition protected (animate-change time entity old-animation new-animation)
  (let ((world (current-world))
        (history (current-history)))
    (let ((id (get-id~ entity)))
      (unless (or (not id)
                  (get-paused?~ history)
                  (equal? new-animation old-animation)
                  (admin?))
        (bidirectional-change 'animate time
          (lambda (store push)
            (store push entity new-animation))
          (lambda (store push)
            (store push entity old-animation)))))))


;;;
;;;; Add
;;;


(define-change add
  forward-count: 5
  forward-store: (lambda (push x y z id data-id)
                   (push x)
                   (push y)
                   (push z)
                   (push (cast <fl> id))
                   (push (cast <fl> data-id)))
  forward-apply: (lambda (pop time)
                   (let* ((x (pop))
                          (y (pop))
                          (z (pop))
                          (id (pop))
                          (data-id (pop)))
                     (let ((pos (vertex& x y z))
                           (id (flonum->fixnum id))
                           (data-id (flonum->fixnum data-id)))
                       (apply-add-block~ (current-game) pos id data-id))))
  backward-store: (lambda (push x y z replaced replaced-data)
                    (push x)
                    (push y)
                    (push z)
                    (push (cast <fl> replaced))
                    (push (cast <fl> replaced-data)))
  backward-apply: (lambda (pop time)
                    (let* ((x (pop))
                           (y (pop))
                           (z (pop))
                           (replaced (pop))
                           (replaced-data (pop)))
                      (let ((pos (vertex& x y z))
                            (replaced (flonum->fixnum replaced))
                            (replaced-data (flonum->fixnum replaced-data)))
                        (apply-restore-block~ (current-game) pos replaced replaced-data)))))


;;;
;;;; Delete
;;;


(define-change delete
  forward-count: 3
  forward-store: (lambda (push x y z)
                   (push x)
                   (push y)
                   (push z))
  forward-apply: (lambda (pop time)
                   (let* ((x (pop))
                          (y (pop))
                          (z (pop)))
                     (let ((pos (vertex& x y z)))
                       (apply-delete-block~ (current-game) pos))))
  backward-store: (lambda (push x y z block-id data-id)
                    (push x)
                    (push y)
                    (push z)
                    (push (cast <fl> block-id))
                    (push (cast <fl> data-id)))
  backward-apply: (lambda (pop time)
                    (let* ((x (pop))
                           (y (pop))
                           (z (pop))
                           (block-id (pop))
                           (data-id (pop)))
                      (let ((pos (vertex& x y z))
                            (block-id (flonum->fixnum block-id))
                            (data-id (flonum->fixnum data-id)))
                        (apply-restore-block~ (current-game) pos block-id data-id))))))
