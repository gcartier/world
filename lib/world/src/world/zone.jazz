;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Zones
;;;


(module world.zone jazz


(import (jazz.designer)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (jazz.version)
        (time)
        (world)
        (world.area)
        (world.autoload)
        (world.actor)
        (world.block)
        (world.counter)
        (world.enemy)
        (world.folio)
        (world.foreign)
        (world.gadget)
        (world.geometry)
        (world.gravity)
        (world.history)
        (world.light)
        (world.mark)
        (world.object)
        (world.player)
        (world.render)
        (world.sector)
        (world.shader)
        (world.sprite)
        (world.texture)
        (world.window)
        (world.client.window))


;;;
;;;; Zone
;;;


(class Zone extends Component
  
  
  (property title              <string+>    initialize #f           accessors generate)
  (property ambient-color      <Color+>     initialize #f           accessors generate)
  (property material-specular  <Color+>     initialize #f           accessors generate)
  (property material-shininess <fl+>        initialize #f           accessors generate)
  (property block-color        <object>     initialize #f           accessors generate)
  (property block-stiches?     <bool>       initialize #f           accessors generate)
  (property textures?          <bool>       initialize #f           accessors generate)
  (property start-position     <f32vector+> initialize #f           accessors generate)
  (property start-sight        <f32vector+> initialize #f           accessors generate)
  (property start-up           <f32vector+> initialize #f           accessors generate)
  (property properties         <object>     initialize '()          accessors generate)
  
  
  (slot radius                <fl>     initialize #f            getter generate)
  (slot sectors               <object> initialize #f            getter generate)
  (slot sector-period         <fx>     initialize #f            getter generate)
  (slot sector-size           <fx>     initialize #f            getter generate)
  (slot sector-radius         <fl>     initialize #f            getter generate)
  (slot areas                 <object> initialize #f            getter generate)
  (slot area-size             <fx>     initialize #f            getter generate)
  (slot debug-areas?          <bool>   initialize #f            getter generate)
  (slot actors                <list>   initialize '()           getter generate)
  (slot blocks                <list>   initialize '()           getter generate)
  (slot gadgets               <list>   initialize '()           getter generate)
  (slot sprites               <list>   initialize '()           getter generate)
  (slot marks                 <list>   initialize '()           getter generate)
  (slot debug-sectors?        <bool>   initialize #f            getter generate)
  (slot designer              <object> initialize #f            accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! radius 500.)
    (set-zone self))
  
  
  (method (initialize-zone)
    (setup-areas)
    (setup-sectors)
    (setup-lights)
    (setup-boundaries))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))


  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (free-sectors))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (reset-zone)
    (set! actors '())
    (set! blocks '())
    (set! sprites '()))
  
  
  (method (update-children)
    (set-me #f)
    (for-each (lambda (obj)
                (when (is? obj Sprite)
                  (add-sprite obj)))
              children))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (get-moniker)
    (get-origin~ (get-form~ designer)))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (set-modified?~ designer flag))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method (draw-zone)
    (when textures?
      (draw-sectors~ world))
    (when debug-areas?
      (draw-debug-areas))
    (when debug-sectors?
      (draw-debug-sectors))
    (when (get-draw-gadgets?~ world)
      (draw-gadgets))
    (when (get-draw-sprites?~ world)
      (draw-sprites))
    (when (get-draw-marks?~ world)
      (draw-marks)))
  
  
  ;;;
  ;;;; Boundaries
  ;;;
  
  
  (method (setup-boundaries)
    @w
    (set! boundaries (new Cuboid left bottom back right top front)))
  
  
  ;;;
  ;;;; Snapshots
  ;;;
  
  
  (method (snapshot-zone)
    (let ((actors (map object-copy actors))
          (marks (map object-copy marks)))
      (new Snapshot
        actors
        (find-player~ world actors)
        marks)))
  
  
  (method (load-zone snapshot)
    (set! actors (map object-copy (get-actors~ snapshot)))
    (set! marks (map object-copy (get-marks~ snapshot)))
    (set! sprites (append blocks actors))
    (setup-areas)
    (setup-sectors)
    (setup-lights)
    (for-each (lambda (sprite)
                (area-add-sprite (sprite-area sprite) sprite)
                (sector-add-sprite (sprite-sector sprite) sprite))
              sprites))
  
  
  ;;;
  ;;;; Sprites
  ;;;
  
  
  (method (add-sprite obj)
    (define (add-actor)
      (set! actors (cons obj actors))
      (set! sprites (cons obj sprites)))
    
    (define (add-block)
      (set! blocks (cons obj blocks))
      (set! sprites (cons obj sprites)))
    
    (define (add-gadget)
      (set! gadgets (cons obj gadgets)))
    
    (typecase obj
      ((Actor) (add-actor))
      ((Block) (add-block))
      (else (add-gadget)))
    (area-add-sprite (sprite-area obj) obj)
    (sector-add-sprite (sprite-sector obj) obj)
    obj)
  
  
  (method (remove-sprite obj)
    (define (remove-actor)
      (set! actors (remove! obj actors))
      (set! sprites (remove! obj sprites)))
    
    (define (remove-block)
      (set! blocks (remove! obj blocks))
      (set! sprites (remove! obj sprites)))
    
    (define (remove-gadget)
      (set! gadgets (remove! obj gadgets)))
    
    (typecase obj
      ((Actor) (remove-actor))
      ((Block) (remove-block))
      (else (remove-gadget)))
    (area-remove-sprite (sprite-area obj) obj)
    (sector-remove-sprite (sprite-sector obj) obj))
  
  
  (method (find-sprite predicate)
    (find-if predicate sprites))
  
  
  (method (iterate-actors proc)
    (for-each proc actors))
  
  
  (method (iterate-gadgets proc)
    (for-each proc gadgets))
  
  
  (method (iterate-sprites proc)
    (for-each proc sprites))
  
  
  (method (iterate-all proc)
    (for-each proc sprites)
    (for-each proc gadgets))
  
  
  (method (collect-players)
    (collect-type Player actors))
  
  
  (method (draw-sprites)
    ;; draw actors
    ((if textures?
         iterate-actors
       iterate-sprites)
     (lambda (sprite)
       (unless (eq? sprite me)
         (draw~ sprite))))
    
    ;; draw potentially translucent objects last
    (when me
      (draw~ me)))
  
  
  (method (vertex->sprite vert)
    (continuation-capture
      (lambda (return)
        (let ((area (index-area (position-area-index vert)))
              (x (vertex-x vert))
              (y (vertex-y vert))
              (z (vertex-z vert)))
          (iterate-area-sprites area
            (lambda (obj)
              (when (and (get-visible?~ obj)
                         (>= x (get-left~ obj))
                         (>= y (get-bottom~ obj))
                         (>= z (get-back~ obj))
                         (<  x (get-right~ obj))
                         (<  y (get-top~ obj))
                         (<  z (get-front~ obj)))
                (continuation-return return obj)))))
        #f)))
  
  
  ;;;
  ;;;; Sector
  ;;;
  
  
  (method (setup-sectors)
    (set! sectors (make-table test: equal?))
    (set! sector-period 10)
    (set! sector-size (* area-size sector-period))
    (set! sector-radius (let ((half (/ sector-size 2.)))
                          (vertex-norm (vertex half half half)))))
  
  
  (method (sprite-sector-index sprite)
    (position-sector-index (get-position~ sprite)))
  
  
  (method (position-sector-index pos)
    (define (offset r)
      (let ((i (fxfloor r)))
        (/ (- i (modulo i sector-size))
           sector-size)))
    
    (list (offset (vertex-x pos))
          (offset (vertex-y pos))
          (offset (vertex-z pos))))
  
  
  (method (sprite-sector sprite)
    (index-sector (sprite-sector-index sprite)))
  
  
  (method (index-sector index)
    (define (center i)
      (* (+ i .5) sector-size))
    
    (or (table-ref sectors index #f)
        (bind (x y z) index
          (let ((sector (new Sector index (vertex (center x) (center y) (center z)))))
            (table-set! sectors index sector)
            sector))))
  
  
  (method (unlink-sector sector)
    ;; doesnt-work-as-is-see-unlink-area-comment
    )
  
  
  (method (free-sectors)
    (iterate-table sectors
      (lambda (index sector)
        (free-vao~ sector))))
  
  
  (method (sector-add-sprite sector sprite)
    (define (add-block)
      (set-blocks~ sector (cons sprite (get-blocks~ sector)))
      (set-vao-uptodate?~ sector #f))
    
    (when (is? sprite Block)
      (add-block)))
  
  
  (method (sector-remove-sprite sector sprite)
    (define (remove-block)
      (let ((blocks (remove! sprite (get-blocks~ sector))))
        (set-blocks~ sector blocks)
        (set-vao-uptodate?~ sector #f)
        (when (null? blocks)
          (unlink-sector sector))))
    
    (when (is? sprite Block)
      (remove-block)))
  
  
  (method (iterate-position-neighbor-sectors pos proc)
    (bind (a b c) (position-sector-index pos)
      (loop (for i from -3 to 3)
            (loop (for j from -3 to 3)
                  (loop (for k from -3 to 3)
                        (proc (index-sector (list (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-sprite-neighbor-sectors sprite proc)
    (iterate-position-neighbor-sectors (get-position~ sprite) proc))
  
  
  (method (sprite-neighbor-sectors sprite)
    (let ((queue (new-queue)))
      (iterate-sprite-neighbor-sectors sprite (lambda (sector) (enqueue queue sector)))
      (queue-list queue)))
  
  
  (method (validate-sectors)
    )
  
  
  (method (toggle-debug-sectors)
    (set! debug-sectors? (not debug-sectors?)))
  
  
  (method (draw-debug-sectors)
    (let ((size (cast <fl> sector-size))
          (depth 5))
      (let ((min (- (* size depth)))
            (max (* size depth)))
        (glDisable GL_LIGHTING)
        (gl-colorize {Color Red})
        (glBegin GL_LINES)
        (loop (for x <fl> from min to max by size)
              (loop (for y <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for y <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for z <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z))
              (loop (for y <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glEnable GL_LIGHTING))))
  
  
  ;;;
  ;;;; Area
  ;;;
  
  
  (method (setup-areas)
    (set! areas (make-table test: equal?))
    (set! area-size 10))
  
  
  (method (sprite-area-index sprite)
    (position-area-index (get-position~ sprite)))
  
  
  (method (position-area-index pos)
    (define (offset r)
      (let ((i (fxfloor r)))
        (/ (- i (modulo i area-size))
           area-size)))
    
    (list (offset (vertex-x pos))
          (offset (vertex-y pos))
          (offset (vertex-z pos))))
  
  
  (method (sprite-area sprite)
    (index-area (sprite-area-index sprite)))
  
  
  (method (index-area index)
    (or (table-ref areas index #f)
        (let ((area (new Area index)))
          (table-set! areas index area)
          area)))
  
  
  (method (unlink-area area)
    @doesnt-work-as-is-because-hit-test-will-consult/create-the-27-adjacent-areas-even-if-they-are-empty
    (table-clear areas (get-index~ area)))
  
  
  (method (area-add-sprite area sprite)
    (define (add-actor)
      (set-actors~ area (cons sprite (get-actors~ area))))
    
    (define (add-block)
      (set-blocks~ area (cons sprite (get-blocks~ area))))
    
    (define (add-gadget)
      (set-gadgets~ area (cons sprite (get-gadgets~ area))))
    
    (cond ((is? sprite Actor)
           (add-actor))
          ((is? sprite Block)
           (add-block))
          (else
           (add-gadget))))
  
  
  (method (area-remove-sprite area sprite)
    (define (remove-actor)
      (let ((actors (remove! sprite (get-actors~ area))))
        (set-actors~ area actors)
        (when (and (null? actors) (null? (get-blocks~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-block)
      (let ((blocks (remove! sprite (get-blocks~ area))))
        (set-blocks~ area blocks)
        (when (and (null? blocks) (null? (get-actors~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-gadget)
      (let ((gadgets (remove! sprite (get-gadgets~ area))))
        (set-gadgets~ area gadgets)
        (when (and (null? gadgets) (null? (get-actors~ area)) (null? (get-blocks~ area)))
          (unlink-area area))))
    
    (cond ((is? sprite Actor)
           (remove-actor))
          ((is? sprite Block)
           (remove-block))
          (else
           (remove-gadget))))
  
  
  (method (update-area sprite old-position)
    (let ((old-index (position-area-index old-position))
          (new-index (sprite-area-index sprite)))
      (when (not (equal? old-index new-index))
        (let ((old-area (index-area old-index))
              (new-area (index-area new-index)))
          (area-remove-sprite old-area sprite)
          (area-add-sprite new-area sprite)))))
  
  
  (method (iterate-position-neighbor-areas pos proc)
    (bind (a b c) (position-area-index pos)
      (loop (for i from -1 to 1)
            (loop (for j from -1 to 1)
                  (loop (for k from -1 to 1)
                        (proc (index-area (list (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-sprite-neighbor-areas sprite proc)
    (iterate-position-neighbor-areas (get-position~ sprite) proc))
  
  
  (method (sprite-neighbor-areas sprite)
    (let ((queue (new-queue)))
      (iterate-sprite-neighbor-areas sprite (lambda (area) (enqueue queue area)))
      (queue-list queue)))
  
  
  (method (iterate-areas-sprites areas proc)
    (for-each (lambda (area)
                (for-each proc (get-actors~ area))
                (for-each proc (get-blocks~ area))
                (for-each proc (get-gadgets~ area)))
              areas))
  
  
  (method (iterate-area-sprites area proc)
    (for-each proc (get-actors~ area))
    (for-each proc (get-blocks~ area))
    (for-each proc (get-gadgets~ area)))
  
  
  (method (collect-area-sprites)
    (let ((queue (new-queue)))
      (iterate-table areas
        (lambda (index area)
          (enqueue-list queue (get-actors~ area))
          (enqueue-list queue (get-blocks~ area))
          (enqueue-list queue (get-gadgets~ area))))
      (queue-list queue)))
  
  
  (method (areas-count filter)
    (count-if filter (collect-area-sprites)))
  
  
  (method (validate-areas)
    (let ((actors-count 0)
          (blocks-count 0)
          (gadgets-count 0)
          (sprites-count 0))
      (iterate-table areas
        (lambda (index area)
          (let ((area-actors (length (get-actors~ area)))
                (area-blocks (length (get-blocks~ area)))
                (area-gadgets (length (get-gadgets~ area))))
            (increase! actors-count area-actors)
            (increase! blocks-count area-blocks)
            (increase! gadgets-count area-gadgets)
            (increase! sprites-count (+ area-actors area-blocks)))))
      (if (and (= actors-count (length actors))
               (= blocks-count (length blocks))
               (= gadgets-count (length gadgets))
               (= sprites-count (length sprites)))
          (begin
            (reset-information~ world)
            #t)
        (set-information~ world
          `("Area corruption detected"
            ,(format "  Actors: {s} {s}" actors-count (length actors))
            ,(format "  Blocks: {s} {s}" blocks-count (length blocks))
            ,(format "  Gadgets: {s} {s}" gadgets-count (length gadgets))
            ,(format "  Sprites: {s} {s}" sprites-count (length sprites))))
        #f)))
  
  
  (method (toggle-debug-areas)
    (set! debug-areas? (not debug-areas?)))
  
  
  (method (draw-debug-areas)
    (let ((size (cast <fl> area-size))
          (depth 5))
      (let ((min (- (* size depth)))
            (max (* size depth)))
        (glDisable GL_LIGHTING)
        (gl-colorize {Color Red})
        (glBegin GL_LINES)
        (loop (for x <fl> from min to max by size)
              (loop (for y <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for y <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for z <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z))
              (loop (for y <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glEnable GL_LIGHTING))))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method (hit-test object from-x <fl> from-y <fl> from-z <fl> to-x <fl> to-y <fl> to-z <fl> width <fl> height <fl> depth <fl> radius-x <fl> radius-y <fl> radius-z <fl>)
    (let ((from-right (+ from-x width))
          (from-top (+ from-y height))
          (from-front (+ from-z depth))
          (to-right #f)
          (to-top #f)
          (to-front #f)
          (areas (sprite-neighbor-areas object)))
      (define (hit-x)
        (cond ;; going right
              ((> to-x from-x)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (when (get-visible?~ obj)
                       (let ((bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (back (get-back~ obj))
                             (front (get-front~ obj))
                             (border (get-left~ obj)))
                         (when (and (neq? obj object)
                                    (<= from-right border)
                                    (> to-right border)
                                    (not (or (<= to-top bottom)
                                             (>= to-y top)
                                             (<= to-front back)
                                             (>= to-z front))))
                           (cond ((or (not found)
                                      (< border found))
                                  (set! found border)
                                  (set! found-objects (list obj))
                                  (set! to-right border)
                                  (set! to-x (- to-right width)))
                                 ((= border found)
                                  (set! found-objects (cons obj found-objects)))))))))
                 (when found
                   (list found-objects 1 found (- found radius-x)))))
              ;; going left
              ((< to-x from-x)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (when (get-visible?~ obj)
                       (let ((bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (back (get-back~ obj))
                             (front (get-front~ obj))
                             (border (get-right~ obj)))
                         (when (and (neq? obj object)
                                    (>= from-x border)
                                    (< to-x border)
                                    (not (or (<= to-top bottom)
                                             (>= to-y top)
                                             (<= to-front back)
                                             (>= to-z front))))
                           (cond ((or (not found)
                                      (> border found))
                                  (set! found border)
                                  (set! found-objects (list obj))
                                  (set! to-x border)
                                  (set! to-right (+ to-x width)))
                                 ((= border found)
                                  (set! found-objects (cons obj found-objects)))))))))
                 (when found
                   (list found-objects -1 found (+ found radius-x)))))
              ;; not moving
              (else
               #f)))
      
      (define (hit-y)
        (cond ;; going up
              ((> to-y from-y)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (when (get-visible?~ obj)
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (back (get-back~ obj))
                             (front (get-front~ obj))
                             (border (get-bottom~ obj)))
                         (when (and (neq? obj object)
                                    (<= from-top border)
                                    (> to-top border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-front back)
                                             (>= to-z front))))
                           (cond ((or (not found)
                                      (< border found))
                                  (set! found border)
                                  (set! found-objects (list obj))
                                  (set! to-top border)
                                  (set! to-y (- to-top height)))
                                 ((= border found)
                                  (set! found-objects (cons obj found-objects)))))))))
                 (when found
                   (list found-objects 1 found (- found radius-y)))))
              ;; going down
              ((< to-y from-y)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (when (get-visible?~ obj)
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (back (get-back~ obj))
                             (front (get-front~ obj))
                             (border (get-top~ obj)))
                         (when (and (neq? obj object)
                                    (>= from-y border)
                                    (< to-y border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-front back)
                                             (>= to-z front))))
                           (cond ((or (not found)
                                      (> border found))
                                  (set! found border)
                                  (set! found-objects (list obj))
                                  (set! to-y border)
                                  (set! to-top (+ to-y height)))
                                 ((= border found)
                                  (set! found-objects (cons obj found-objects)))))))))
                 (when found
                   (list found-objects -1 found (+ found radius-y)))))
              ;; not moving
              (else
               #f)))
      
      (define (hit-z)
        (cond ;; going front
              ((> to-z from-z)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (when (get-visible?~ obj)
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (border (get-back~ obj)))
                         (when (and (neq? obj object)
                                    (<= from-front border)
                                    (> to-front border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-top bottom)
                                             (>= to-y top))))
                           (cond ((or (not found)
                                      (< border found))
                                  (set! found border)
                                  (set! found-objects (list obj))
                                  (set! to-front border)
                                  (set! to-z (- to-front depth)))
                                 ((= border found)
                                  (set! found-objects (cons obj found-objects)))))))))
                 (when found
                   (list found-objects 1 found (- found radius-z)))))
              ;; going back
              ((< to-z from-z)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (when (get-visible?~ obj)
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (border (get-front~ obj)))
                         (when (and (neq? obj object)
                                    (>= from-z border)
                                    (< to-z border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-top bottom)
                                             (>= to-y top))))
                           (cond ((or (not found)
                                      (> border found))
                                  (set! found border)
                                  (set! found-objects (list obj))
                                  (set! to-z border)
                                  (set! to-front (+ to-z depth)))
                                 ((= border found)
                                  (set! found-objects (cons obj found-objects)))))))))
                 (when found
                   (list found-objects -1 found (+ found radius-z)))))
              ;; not moving
              (else
               #f)))
      
      (let ((preserved-x to-x)
            (preserved-y to-y)
            (preserved-z to-z))
        (define (restore)
          (set! to-x preserved-x)
          (set! to-y preserved-y)
          (set! to-z preserved-z)
          (set! to-right (+ to-x width))
          (set! to-top (+ to-y height))
          (set! to-front (+ to-z depth)))
        
        (define (hit h1 h2 h3 order)
          (restore)
          (let ((count 0))
            (let ((h1 (h1)))
              (when h1
                (increase! count))
              (let ((h2 (h2)))
                (when h2
                  (increase! count))
                (let ((h3 (h3)))
                  (when h3
                    (increase! count))
                  (cons count (order h1 h2 h3)))))))
        
        (let ((r1 (hit hit-y hit-x hit-z (lambda (hit-y hit-x hit-z) (values hit-x hit-y hit-z)))))
          (if (<= (car r1) 1)
              (cdr r1)
            (let ((r2 (hit hit-x hit-y hit-z (lambda (hit-x hit-y hit-z) (values hit-x hit-y hit-z))))
                  (r3 (hit hit-z hit-y hit-x (lambda (hit-z hit-y hit-x) (values hit-x hit-y hit-z))))
                  (r4 (hit hit-y hit-z hit-x (lambda (hit-y hit-z hit-x) (values hit-x hit-y hit-z))))
                  (r5 (hit hit-x hit-z hit-y (lambda (hit-x hit-z hit-y) (values hit-x hit-y hit-z))))
                  (r6 (hit hit-z hit-x hit-y (lambda (hit-z hit-x hit-y) (values hit-x hit-y hit-z)))))
              (let ((lst (list r1 r2 r3 r4 r5 r6)))
                (cdr (minimum lst key: car)))))))))
  
  
  ;;;
  ;;;; Gadget
  ;;;
  
  
  (method (draw-gadgets)
    (for-each draw~ gadgets))
  
  
  ;;;
  ;;;; Light
  ;;;
    
  
  (method (setup-lights)
    )

  
  (method (setup-lighting)
    (define (closest-lights)
      (let ((lights (collect-lights))
            (eye (get-eye~ world)))
        (sort < lights key: (lambda (light) (vertex-distance eye (get-position~ light))))))
    
    (when (get-light?~ world)
      (glEnable GL_LIGHTING)
      (glDisable GL_LIGHT0)
      (glDisable GL_LIGHT1)
      (glDisable GL_LIGHT2)
      (glDisable GL_LIGHT3)
      (glDisable GL_LIGHT4)
      (glDisable GL_LIGHT5)
      (glDisable GL_LIGHT6)
      (glDisable GL_LIGHT7)
      (let ((color (or ambient-color {Color red: .1 green: .1 blue: .1 alpha: 1.0})))
        (gl-light-model GL_LIGHT_MODEL_AMBIENT (get-red~ color) (get-green~ color) (get-blue~ color) (get-alpha~ color)))
      (let ((color (or material-specular {Color red: .01 green: .01 blue: .01 alpha: 1.0})))
        (gl-material-specular GL_FRONT (get-red~ color) (get-green~ color) (get-blue~ color) (get-alpha~ color)))
      (let ((value (or material-shininess 50.)))
        (gl-material-shininess GL_FRONT value))
      (let ((lights (closest-lights))
            (no GL_LIGHT0))
        (loop (for light in lights)
              (repeat 8)
              (glEnable no)
              (glLightf no
                        GL_CONSTANT_ATTENUATION
                        (get-constant-attenuation~ light))
              (glLightf no
                        GL_LINEAR_ATTENUATION
                        (get-linear-attenuation~ light))
              (glLightf no
                        GL_QUADRATIC_ATTENUATION
                        (get-quadratic-attenuation~ light))
              (gl-light no
                        GL_AMBIENT
                        (get-ambient-red~ light)
                        (get-ambient-green~ light)
                        (get-ambient-blue~ light)
                        (get-ambient-alpha~ light))
              (gl-light no
                        GL_DIFFUSE
                        (get-red~ light)
                        (get-green~ light)
                        (get-blue~ light)
                        (get-alpha~ light))
              (gl-light no
                        GL_POSITION
                        (get-x~ light)
                        (get-y~ light)
                        (get-z~ light)
                        1.)
              (increase! no)))))
  
  
  (method (iterate-lights proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Light)
          (proc gadget)))))
  
  
  (method (collect-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (enqueue queue light)))
      (queue-list queue)))
  
  
  (method (count-lights)
    (let ((count 0))
      (iterate-lights
        (lambda (light)
          (increase! count)))
      count))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method (iterate-gravities proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Gravity)
          (proc gadget)))))
  
  
  (method (compute-gravity position)
    (let ((gravity (vertex 0. (- (get-gravity~ world)) 0.)))
      (iterate-gravities
        (lambda (well)
          (let ((direction (vertex-normalize (vertex- (get-position~ well) position))))
            (vertex+! gravity gravity (vertex-scalar* direction (get-pull~ well))))))
      gravity))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method (reset-marks)
    (set! marks '()))
  
  
  (method (set-marks lst)
    (set! marks lst))
  
  
  (method (set-mark mark)
    (set! marks (list mark)))
  
  
  (method (add-mark mark)
    (set! marks (cons mark marks)))
  
  
  (method (remove-mark mark)
    (set! marks (remove! mark marks)))

  
  (method (draw-marks)
    (for-each draw-mark~ marks))
  
  
  (method (reset-all-marks)
    (reset-marks)
    (display-message~ world "Marks reset"))))
