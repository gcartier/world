;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Zones
;;;


(module world.zone jazz


(import (jazz.designer)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.literals)
        (jazz.math)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.version)
        (time)
        (world)
        (world.actor)
        (world.area)
        (world.autoload)
        (world.block)
        (world.counter)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.enemy)
        (world.entity)
        (world.folio)
        (world.foreign)
        (world.foreign.triangulate)
        (world.gadget)
        (world.geometry)
        (world.gravity)
        (world.history)
        (world.light)
        (world.mark)
        (world.opengl)
        (world.player)
        (world.procedural)
        (world.render)
        (world.sector)
        (world.settings)
        (world.shader)
        (world.sun)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile)
        (world.window)
        (world.client.window))


;;;
;;;; Zone
;;;


(class Zone extends Component
  
  
  (property title                <string+>    initialize #f           accessors generate)
  (property ambient-color        <Color+>     initialize #f           accessors generate)
  (property material-specular    <Color+>     initialize #f           accessors generate)
  (property material-shininess   <fl+>        initialize #f           accessors generate)
  (property start-position       <f32vector+> initialize #f           accessors generate)
  (property start-sight          <f32vector+> initialize #f           accessors generate)
  (property start-up             <f32vector+> initialize #f           accessors generate)
  (property floor-level          <fl>         initialize 0.0          accessors generate)
  (property missile-behavior     <symbol>     initialize 'destroy     accessors generate)
  (property sun-cycle?           <bool>       initialize #t           accessors generate)
  (property properties           <object>     initialize '()          accessors generate)
  
  
  (slot radius                   <fl>         initialize #f           getter generate)
  (slot sectors                  <object>     initialize #f           getter generate)
  (slot sector-size              <fx>         initialize #f           getter generate)
  (slot sector-radius            <fl>         initialize #f           getter generate)
  (slot debug-sectors?           <bool>       initialize #f           accessors generate)
  (slot areas                    <object>     initialize #f           getter generate)
  (slot area-size                <fx>         initialize #f           getter generate)
  (slot debug-areas?             <bool>       initialize #f           accessors generate)
  (slot tiles                    <list>       initialize '()          getter generate)
  (slot players                  <list>       initialize '()          getter generate)
  (slot actors                   <list>       initialize '()          getter generate)
  (slot entities                 <list>       initialize '()          getter generate)
  (slot gadgets                  <list>       initialize '()          getter generate)
  (slot marks                    <list>       initialize '()          getter generate)
  (slot update-lightmaps?        <bool>       initialize #t           getter generate)
  (slot lights-count             <fx>         initialize 0            accessors generate)
  (slot sun                      <Sun+>       initialize #f           accessors generate)
  (slot sun-ambient              <Color+>     initialize #f           accessors generate)
  (slot sun-color                <Color+>     initialize #f           accessors generate)
  (slot sun-coordinates          <f32vector>  initialize #f           accessors generate)
  (slot sun-angle                <fl>         initialize 0.           accessors generate)
  (slot designer                 <object>     initialize #f           accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! radius 500.)
    (set! update-lightmaps? (get-lightmaps?~ (current-world)))
    (set! sun-ambient (dye 0.1 0.1 0.1 1.0))
    (set! sun-color (dye 1.0 1.0 1.0 1.0))
    (set! sun-coordinates (vertex 10000.0 10000.0 10000.0))
    (set-current-zone self))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set! sun-cycle? (and sun-cycle? (find-setting 'world.sun-cycle? #t))))
  
  
  (method (initialize-zone)
    (setup-areas)
    (setup-sectors)
    (setup-boundaries)
    (setup-content))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method protected virtual (generate-sector sector)
    (when (generate-content?)
      (bind (x y z) (get-index~ sector)
        (when (and (= y 0)
                   (let ((max-size (find-setting 'world.procedural-size #f)))
                     (or (not max-size)
                         (let ((from (- max-size))
                               (to (- max-size 1)))
                           (and (between? x from to)
                                (between? z from to))))))
          (let ((size (/ sector-size 5)))
            (let ((from-x (* x size))
                  (width size)
                  (from-z (* z size))
                  (depth size))
              (generate-content from-x width from-z depth)))))))
    
  
  (method protected virtual (generate-content?)
    #f)
  
  
  (method protected virtual (generate-content from-x <fx> width <fx> from-z <fx> depth <fx>)
    )

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))
  
  
  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (free-sectors))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (reset-zone)
    (set! tiles '())
    (set! players '())
    (set! actors '())
    (set! entities '()))
  
  
  (method virtual (setup-content)
    )
  
  
  (method (update-children)
    (set-current-me #f)
    (for-each (lambda (obj)
                (when (is? obj Element)
                  (add-element obj)))
              children))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (get-moniker)
    (get-origin~ (get-form~ designer)))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (set-modified?~ designer flag))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method (draw-zone)
    (let ((world (current-world)))
      (when (get-draw-elements?~ world)
        (if (get-3d?~ world)
            (draw-sectors~ world)
          (draw-immediate)))
      (when debug-areas?
        (draw-debug-areas))
      (when debug-sectors?
        (draw-debug-sectors))
      (when (get-draw-gadgets?~ world)
        (draw-gadgets))
      (when (get-draw-marks?~ world)
        (draw-marks))
      (when (and sun (get-visible?~ sun))
        (draw-sun))
      (draw-translucent)))
  
  
  ;;;
  ;;;; Boundaries
  ;;;
  
  
  (method (setup-boundaries)
    @w
    (set! boundaries (cuboid left bottom back right top front)))
  
  
  ;;;
  ;;;; Snapshots
  ;;;
  
  
  (method (snapshot-object obj)
    (let ((copy (object-copy obj)))
      (copy-from~ copy obj)
      copy))
  
  
  (method (snapshot-zone)
    (let ((actors (map snapshot-object actors))
          (gadgets (map snapshot-object gadgets))
          (marks (map object-copy marks)))
      (new Snapshot
        actors
        (collect-type Player actors)
        gadgets
        marks
        sun-angle)))
  
  
  (method (load-zone snapshot)
    (define (add elem)
      (add-element elem)
      (position-update~ elem))
    
    (for-each remove-element actors)
    (for-each add (map snapshot-object (get-actors~ snapshot)))
    (for-each remove-element gadgets)
    (for-each add (map snapshot-object (get-gadgets~ snapshot)))
    (set! marks (map object-copy (get-marks~ snapshot)))
    (when sun-cycle?
      (position-sun (get-sun-angle~ snapshot))))
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method (add-element obj)
    (define (add-player)
      (set! players (cons obj players))
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-actor)
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-entity)
      (set! entities (cons obj entities)))
    
    (define (add-tile)
      (set! tiles (cons obj tiles)))
    
    (define (add-gadget)
      (set! gadgets (cons obj gadgets)))
    
    (typecase obj
      ((Player) (add-player))
      ((Actor) (add-actor))
      ((Entity) (add-entity))
      (else (add-tile)))
    (when (gadget?~ obj)
      (add-gadget))
    (area-add-element (element-area obj) obj)
    (sector-add-element (element-sector obj) obj)
    obj)
  
  
  (method (remove-element obj)
    (define (remove-player)
      (set! players (remove! obj players))
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-actor)
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-entity)
      (set! entities (remove! obj entities)))
    
    (define (remove-tile)
      (set! tiles (remove! obj tiles)))
    
    (define (remove-gadget)
      (set! gadgets (remove! obj gadgets)))
    
    (typecase obj
      ((Player) (remove-player))
      ((Actor) (remove-actor))
      ((Entity) (remove-entity))
      (else (remove-tile)))
    (when (gadget?~ obj)
      (remove-gadget))
    (area-remove-element (element-area obj) obj)
    (sector-remove-element (element-sector obj) obj))
  
  
  (method (find-element predicate)
    (continuation-capture
      (lambda (return)
        (iterate-elements
          (lambda (element)
            (when (predicate element)
              (continuation-return return element))))
        #f)))
  
  
  (method (find-named-element name)
    (find-element
      (lambda (element)
        (eq? (get-name~ element) name))))
  
  
  (method (find-gadget predicate)
    (find-if predicate gadgets))
  
  
  (method (iterate-players proc)
    (for-each proc players))
  
  
  (method (iterate-actors proc)
    (for-each proc actors))
  
  
  (method (iterate-entities proc)
    (for-each proc entities))
  
  
  (method (iterate-gadgets proc)
    (for-each proc gadgets))
  
  
  (method (iterate-elements proc)
    (for-each proc tiles)
    (for-each proc entities))
  
  
  ;; draw potentially translucent last
  (method (draw-translucent)
    (let ((me (current-me)))
      (when me
        (draw~ me))))
  
  
  (method (draw-immediate)
    (iterate-elements
      (lambda (element)
        (unless (is? element Actor)
          (draw~ element)))))
  
  
  (method (vertex->element vert)
    (let ((l (* (floor (/ (vertex-x vert) 5.)) 5.))
          (b (* (floor (/ (vertex-y vert) 5.)) 5.))
          (f (* (floor (/ (vertex-z vert) 5.)) 5.)))
      (let ((r (+ l 5.))
            (t (+ b 5.))
            (n (+ f 5.)))
        (continuation-capture
          (lambda (return)
            (let ((area (index-area (position-area-index vert)))
                  (x (vertex-x vert))
                  (y (vertex-y vert))
                  (z (vertex-z vert)))
              (iterate-area-elements area
                (lambda (obj)
                  (when (and (get-visible?~ obj)
                             (let ((x (get-x~ obj))
                                   (y (get-y~ obj))
                                   (z (get-z~ obj)))
                               (and (>= x l)
                                    (>= y b)
                                    (>= z f)
                                    (<  x r)
                                    (<  y t)
                                    (<  z n))))
                    (continuation-return return obj)))))
            #f)))))
  
  
  (method (element-at vert)
    (continuation-capture
      (lambda (return)
        (let ((area (index-area (position-area-index vert))))
          (iterate-area-elements area
            (lambda (obj)
              (when (and (get-visible?~ obj)
                         (vertex=? (get-position~ obj) vert))
                (continuation-return return obj)))))
        #f)))
  
  
  (method (validate-elements)
    (iterate-elements
      (lambda (element)
        (assert (real? (get-x~ element)))
        (assert (real? (get-y~ element)))
        (assert (real? (get-z~ element)))
        (assert (real? (get-red~ element)))
        (assert (real? (get-green~ element)))
        (assert (real? (get-blue~ element)))
        (assert (real? (get-alpha~ element))))))
  
  
  ;;;
  ;;;; Sectors
  ;;;
  
  
  (method (setup-sectors)
    (set! sectors (make-table test: equal?))
    (set! sector-size (or (find-setting 'world.sector-size #f) 80))
    (set! sector-radius (let ((half (/ sector-size 2.)))
                          (vertex-norm (vertex half half half)))))
  
  
  (method (element-sector-index element)
    (position-sector-index (get-position~ element)))
  
  
  (method (position-sector-index pos)
    (define (offset r)
      (let ((i (fxfloor r)))
        (/ (- i (modulo i sector-size))
           sector-size)))
    
    (list (offset (vertex-x pos))
          (offset (vertex-y pos))
          (offset (vertex-z pos))))
  
  
  (method (position-sector pos)
    (index-sector (position-sector-index pos)))
  
  
  (method (element-sector element)
    (index-sector (element-sector-index element)))
  
  
  (method (index-sector index)
    (define (center i)
      (* (+ i .5) sector-size))
    
    (or (table-ref sectors index #f)
        (bind (x y z) index
          (let ((sector (new Sector index (vertex (center x) (center y) (center z)))))
            (table-set! sectors index sector)
            sector))))
  
  
  (method (unlink-sector sector)
    ;; doesnt-work-as-is-see-unlink-area-comment
    )
  
  
  (method (free-sectors)
    (iterate-table sectors
                   (lambda (index sector)
                     (free-mesh~ sector))))
  
  
  (method (sector-add-element sector element)
    (define (add-entity)
      (set-entities~ sector (cons element (get-entities~ sector))))
    
    (define (add-tile)
      (set-tiles~ sector (cons element (get-tiles~ sector)))
      (set-vertices-uptodate?~ sector #f)
      ;; temporary
      (set-lightmap-uptodate?~ sector #f))
    
    (typecase element
      ((Entity)
       (add-entity))
      ((Tile)
       (add-tile)))
    (invalidate-lightmaps element))
  
  
  (method (sector-remove-element sector element)
    (define (remove-entity)
      (set-entities~ sector (remove! element (get-entities~ sector))))
    
    (define (remove-tile)
      (let ((tiles (remove! element (get-tiles~ sector))))
        (set-tiles~ sector tiles)
        (set-vertices-uptodate?~ sector #f)
        ;; temporary
        (set-lightmap-uptodate?~ sector #f)
        (when (null? tiles)
          (unlink-sector sector))))
    
    (typecase element
      ((Entity)
       (remove-entity))
      ((Tile)
       (remove-tile)))
    (invalidate-lightmaps element))
  
  
  (method (iterate-sectors-with-tiles proc)
    (iterate-table sectors
                   (lambda (index sector)
                     (when (not-null? (get-tiles~ sector))
                       (proc index sector)))))
  
  
  (method (iterate-position-neighbor-sectors pos distance <fx> proc)
    (bind (a <fx> b <fx> c <fx>) (position-sector-index pos)
      (loop (for i from (- distance) to distance)
            (loop (for j from (- distance) to distance)
                  (loop (for k from (- distance) to distance)
                        (proc (index-sector (list (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-element-neighbor-sectors element distance proc)
    (iterate-position-neighbor-sectors (get-position~ element) distance proc))
  
  
  (method (element-neighbor-sectors element distance)
    (let ((queue (new-queue)))
      (iterate-element-neighbor-sectors element distance (lambda (sector) (enqueue queue sector)))
      (queue-list queue)))
  
  
  (method (compute-floats)
    (let ((total 0))
      (iterate-table sectors
                     (lambda (index sector)
                       (let ((mesh (get-mesh~ sector)))
                         (when (and mesh (get-vertices-uptodate?~ sector))
                           (let ((floats (count-floats~ mesh)))
                             (when floats
                               (increase! total floats)))))))
      total))
  
  
  (method (count-sectors-with-tiles)
    (let ((total 0))
      (iterate-sectors-with-tiles
        (lambda (index sector)
          (increase! total)))
      total))
  
  
  (method (validate-sectors)
    )
  
  
  (method (toggle-debug-sectors)
    (set! debug-sectors? (not debug-sectors?)))
  
  
  (method (draw-debug-sectors)
    (let ((size (cast <fl> sector-size))
          (depth 5))
      (let ((min (- (* size depth)))
            (max (* size depth)))
        (glDisable GL_LIGHTING)
        (gl-colorize-dye red-dye)
        (glBegin GL_LINES)
        (loop (for x <fl> from min to max by size)
              (loop (for y <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for y <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for z <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z))
              (loop (for y <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glEnable GL_LIGHTING))))
  
  
  ;;;
  ;;;; Areas
  ;;;
  
  
  (method (setup-areas)
    (set! areas (make-table test: equal?))
    (set! area-size 10))
  
  
  (method (element-area-index element)
    (position-area-index (get-position~ element)))
  
  
  (method (position-area-index pos)
    (define (offset r)
      (let ((i (fxfloor r)))
        (/ (- i (modulo i area-size))
           area-size)))
    
    (list (offset (vertex-x pos))
          (offset (vertex-y pos))
          (offset (vertex-z pos))))
  
  
  (method (element-area element)
    (index-area (element-area-index element)))
  
  
  (method (index-area index)
    (or (table-ref areas index #f)
        (let ((area (new Area index)))
          (table-set! areas index area)
          area)))
  
  
  (method (unlink-area area)
    @doesnt-work-as-is-because-hit-test-will-consult/create-the-27-adjacent-areas-even-if-they-are-empty
    (table-clear areas (get-index~ area)))
  
  
  (method (area-add-element area element)
    (define (add-actor)
      (set-actors~ area (cons element (get-actors~ area))))
    
    (define (add-tile)
      (set-tiles~ area (cons element (get-tiles~ area))))
    
    (define (add-gadget)
      (set-gadgets~ area (cons element (get-gadgets~ area))))
    
    (cond ((is? element Actor)
           (add-actor))
          ((is? element Tile)
           (add-tile))
          (else
           (add-gadget))))
  
  
  (method (area-remove-element area element)
    (define (remove-actor)
      (let ((actors (remove! element (get-actors~ area))))
        (set-actors~ area actors)
        (when (and (null? actors) (null? (get-tiles~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-tile)
      (let ((tiles (remove! element (get-tiles~ area))))
        (set-tiles~ area tiles)
        (when (and (null? tiles) (null? (get-actors~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-gadget)
      (let ((gadgets (remove! element (get-gadgets~ area))))
        (set-gadgets~ area gadgets)
        (when (and (null? gadgets) (null? (get-actors~ area)) (null? (get-tiles~ area)))
          (unlink-area area))))
    
    (cond ((is? element Actor)
           (remove-actor))
          ((is? element Tile)
           (remove-tile))
          (else
           (remove-gadget))))
  
  
  (method (update-area element old-position)
    (let ((old-index (position-area-index old-position))
          (new-index (element-area-index element)))
      (when (not (equal? old-index new-index))
        (let ((old-area (index-area old-index))
              (new-area (index-area new-index)))
          (area-remove-element old-area element)
          (area-add-element new-area element)))))
  
  
  (method (iterate-position-neighbor-areas pos distance <fx> proc)
    (bind (a <fx> b <fx> c <fx>) (position-area-index pos)
      (loop (for i from (- distance) to distance)
            (loop (for j from (- distance) to distance)
                  (loop (for k from (- distance) to distance)
                        (proc (index-area (list (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-element-neighbor-areas element distance proc)
    (iterate-position-neighbor-areas (get-position~ element) distance proc))
  
  
  (method (iterate-area-elements area proc)
    (for-each proc (get-tiles~ area))
    (for-each proc (get-actors~ area))
    (for-each proc (get-gadgets~ area)))
  
  
  (method (collect-area-elements)
    (let ((queue (new-queue)))
      (iterate-table areas
                     (lambda (index area)
                       (enqueue-list queue (get-tiles~ area))
                       (enqueue-list queue (get-actors~ area))
                       (enqueue-list queue (get-gadgets~ area))))
      (queue-list queue)))
  
  
  (method (areas-count filter)
    (count-if filter (collect-area-elements)))
  
  
  (method (validate-areas)
    (let ((world (current-world)))
      (let ((tiles-count 0)
            (actors-count 0)
            (gadgets-count 0)
            (elements-count 0))
        (iterate-table areas
          (lambda (index area)
            (let ((area-tiles (length (get-tiles~ area)))
                  (area-actors (length (get-actors~ area)))
                  (area-gadgets (length (get-gadgets~ area))))
              (increase! tiles-count area-tiles)
              (increase! actors-count area-actors)
              (increase! gadgets-count area-gadgets)
              (increase! elements-count (+ area-actors area-tiles)))))
        (if (and (= tiles-count (length tiles))
                 (= actors-count (length actors))
                 (= gadgets-count (length gadgets))
                 @convert
                 (= elements-count (length elements)))
            (begin
              (reset-information~ world)
              #t)
          (set-information~ world
            `("Area corruption detected"
              ,(format "  Tiles: {s} {s}" tiles-count (length tiles))
              ,(format "  Actors: {s} {s}" actors-count (length actors))
              ,(format "  Gadgets: {s} {s}" gadgets-count (length gadgets))
              @convert
              ,(format "  Elements: {s} {s}" elements-count (length elements))))
          #f))))
  
  
  (method (toggle-debug-areas)
    (set! debug-areas? (not debug-areas?)))
  
  
  (method (draw-debug-areas)
    (let ((size (cast <fl> area-size))
          (depth 5))
      (let ((min (- (* size depth)))
            (max (* size depth)))
        (glDisable GL_LIGHTING)
        (gl-colorize-dye red-dye)
        (glBegin GL_LINES)
        (loop (for x <fl> from min to max by size)
              (loop (for y <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for y <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for z <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z))
              (loop (for y <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glEnable GL_LIGHTING))))
  
  
  ;;;
  ;;;; Gadget
  ;;;
  
  
  (method (draw-gadgets)
    (for-each (lambda (gadget)
                (when (get-visible?~ gadget)
                  (draw~ gadget)))
              gadgets))
  
  
  ;;;
  ;;;; Blocks
  ;;;
  
  
  (method (remove-duplicate-blocks)
    (let ((world (current-world)))
      (let ((table (make-table test: vertex=? hash: vertex-hash))
            (count 0))
        (for-each (lambda (tile)
                    (when (is? tile Blockable)
                      (let ((pos (get-position~ tile)))
                        (if (table-ref table pos #f)
                            (begin
                              (editor-remove-element~ world tile)
                              (increase! count))
                          (table-set! table pos tile)))))
                  tiles)
        (display-message~ world
          (format "Removed {a} block{a}"
                  (format-cardinality count)
                  (format-plural count))))))
  
  
  ;;;
  ;;;; Sun
  ;;;
  
  
  (definition sun-speed <fl>
    .025)
  
  
  (method (set-sun-speed speed)
    (set! sun-speed speed))
  
  
  (method (tick-sun elapse (reverse? #f))
    (position-sun ((if reverse? - +) sun-angle (* sun-speed elapse))))
  
  
  (method (position-sun angle)
    (let ((zone (current-zone)))
      (set! sun-angle (flmodulo angle PI*2))
      (let ((under-limit 0.1)
            (direction (rotate-upon PI/4 (vertex 0.0 1.0 0.0) (rotate-upon sun-angle (vertex 0.0 0.0 -1.0) (vertex -1. 0. 0.)))))
        (let ((pos (vertex-scalar* direction 1000.)))
          (when (not sun)
            (set! sun (new Sun parent: zone position: pos))
            (add-element sun))
          (cond ((or (< sun-angle (+ PI under-limit))
                     (> sun-angle (- PI*2 under-limit)))
                 (let ((coord (vertex-scalar* direction 1000.))
                       (under (cond ((> sun-angle (- PI*2 under-limit)) (- PI*2 sun-angle))
                                    ((and (> sun-angle PI) (< sun-angle (+ PI under-limit))) (- sun-angle PI))
                                    (else 0.))))
                   (let ((intensity (- 1.0 (/ under under-limit))))
                     (set-sun-color (dye intensity intensity intensity 1.0)))
                   (set-sun-coordinates coord)
                   (set-position~ sun pos)
                   (set-visible?~ sun #t)))
                (else
                 (set-sun-color black-dye)
                 (set-visible?~ sun #f)))))))
  
  
  (method (draw-sun)
    (draw~ sun))
  
  
  ;;;
  ;;;; Lighting
  ;;;
  
  
  (method (setup-lighting)
    (let ((world (current-world)))
      (define (closest-lights)
        (let ((lights (if update-lightmaps? (collect-dynamic-lights) (collect-lights)))
              (eye (get-eye~ world)))
          (sort < lights key: (lambda (light) (vertex-distance eye (get-position~ light))))))
      
      (when (get-light?~ world)
        (glEnable GL_LIGHTING)
        (glDisable GL_LIGHT0)
        (glDisable GL_LIGHT1)
        (glDisable GL_LIGHT2)
        (glDisable GL_LIGHT3)
        (glDisable GL_LIGHT4)
        (glDisable GL_LIGHT5)
        (glDisable GL_LIGHT6)
        (glDisable GL_LIGHT7)
        (let ((color (or ambient-color (dye .1 .1 .1 1.0))))
          (gl-light-model GL_LIGHT_MODEL_AMBIENT (dye-red color) (dye-green color) (dye-blue color) (dye-alpha color)))
        (let ((color (or material-specular (dye .01 .01 .01 1.0))))
          (gl-material-specular GL_FRONT (dye-red color) (dye-green color) (dye-blue color) (dye-alpha color)))
        (let ((value (or material-shininess 50.)))
          (gl-material-shininess GL_FRONT value))
        (let ((lights (closest-lights))
              (no GL_LIGHT0))
          (set! lights-count (min (get-dynamic-lights~ world) (length lights)))
          (loop (for light in lights)
                (repeat lights-count)
                (glEnable no)
                (glLightf no
                          GL_CONSTANT_ATTENUATION
                          (get-constant-attenuation~ light))
                (glLightf no
                          GL_LINEAR_ATTENUATION
                          (get-linear-attenuation~ light))
                (glLightf no
                          GL_QUADRATIC_ATTENUATION
                          (get-quadratic-attenuation~ light))
                (let ((ambient (get-ambient-color~ light)))
                  (gl-light no
                            GL_AMBIENT
                            (dye-red ambient)
                            (dye-green ambient)
                            (dye-blue ambient)
                            (dye-alpha ambient)))
                (gl-light no
                          GL_DIFFUSE
                          (get-red~ light)
                          (get-green~ light)
                          (get-blue~ light)
                          (get-alpha~ light))
                (gl-light no
                          GL_POSITION
                          (get-x~ light)
                          (get-y~ light)
                          (get-z~ light)
                          1.)
                (increase! no))))))
  
  
  (method (iterate-lights proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Light)
          (proc gadget)))))
  
  
  (method (collect-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (enqueue queue light)))
      (queue-list queue)))
  
  
  (method (collect-static-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (unless (get-dynamic?~ light)
            (enqueue queue light))))
      (queue-list queue)))
  
  
  (method (collect-dynamic-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (when (get-dynamic?~ light)
            (enqueue queue light))))
      (queue-list queue)))
  
  
  (method (count-lights)
    (let ((count 0))
      (iterate-lights
        (lambda (light)
          (increase! count)))
      count))
  
  
  (method (invalidate-lightmaps element)
    @temporary
    (let ((world (current-world)))
      (when (get-lightmaps?~ world)
        (iterate-sectors-with-tiles
          (lambda (index sector)
            (set-lightmap-baked?~ sector #f)))
        (set! update-lightmaps? #f))))
  
  
  (method (update-lightmaps)
    (let ((world (current-world)))
      (when (get-lightmaps?~ world)
        (set! update-lightmaps? #t))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method (iterate-gravities proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Gravity)
          (proc gadget)))))
  
  
  (method (compute-gravity position)
    (let ((world (current-world)))
      (let ((gravity (vertex 0. (- (get-gravity~ world)) 0.)))
        (iterate-gravities
          (lambda (well)
            (let ((direction (vertex-normalize (vertex- (get-position~ well) position)))
                  (distance (min 1. (vertex-distance (get-position~ well) position))))
              (vertex+! gravity gravity (vertex-scalar* direction (/ (* (get-pull~ well) 1.) (* distance distance)))))))
        gravity)))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method (reset-marks)
    (set! marks '()))
  
  
  (method (set-marks lst)
    (set! marks lst))
  
  
  (method (set-mark mark)
    (set! marks (list mark)))
  
  
  (method (add-mark mark)
    (set! marks (cons mark marks)))
  
  
  (method (remove-mark mark)
    (set! marks (remove! mark marks)))
  
  
  (method (draw-marks)
    (for-each draw-mark~ marks))
  
  
  (method (reset-all-marks)
    (let ((world (current-world)))
      (reset-marks)
      (display-message~ world "Marks reset"))))


;;;
;;;; Procedural Zones
;;;


(proclaim (warn optimizations))


;; Ideally, this would use a PRNG which we can seed with a given value.
;; That way the map can be persisted using just the seed, and a list of changes.
;; Also I have no clue how this will react in multiplayer.
(class Procedural-Zone extends Zone
  
  
  (property detail-level <fl>               initialize 15. accessors generate)
  (property clamp-height <fl>               initialize 65. accessors generate)
  (property seed         <object>           initialize #f  accessors generate)
  (property generator    <Perlin-Generator> initialize #f  accessors generate)
  
  
  (method override (setup-component)
    (nextmethod)
    (random-seed seed)
    (set! generator (new Perlin-Generator detail-level clamp-height)))
  
  
  (method override (generate-content?)
    #t)
  
  
  (method override (generate-content from-x <fx> width <fx> from-z <fx> depth <fx>)
    (let ((x-count (+ width 1))
          (z-count (+ depth 1)))
      (define (generate-heightmap)
        (let ((heightmap <f32vector> (make-f32vector (* x-count z-count))))
          (loop (for x from 0 below x-count)
                (loop (for z from 0 below z-count)
                      (f32vector-set! heightmap (+ (* x z-count) z)
                        ;; max and min are quick hack until perlin generator is fixed
                        (max 0. (min 50. (get-value~ generator (cast <fl> (+ from-x x)) (cast <fl> (+ from-z z))))))))
          heightmap))
      
      (let ((heightmap <f32vector> (generate-heightmap)))
        (let ((count (f32vector-length heightmap)))
          (let ((vertices (make-vector count))
                (normals (make-vector count)))
            (define (get-vertex x <fx> z <fx>)
              (vector-ref vertices (+ (* x z-count) z)))
            (define (get-normal x <fx> z <fx>)
              (vector-ref normals (+ (* x z-count) z)))
            ;; fill vertices
            (loop (for x from 0 below x-count)
                  (loop (for z from 0 below z-count)
                        (let ((index (+ (* x z-count) z)))
                          (let ((height (f32vector-ref heightmap index)))
                            (let ((x (cast <fl> (+ (* 5. (+ from-x x)) .5)))
                                  (y (cast <fl> height))
                                  (z (cast <fl> (+ (* 5. (+ from-z z)) .5))))
                              (vector-set! vertices index (vertex x y z))
                              (vector-set! normals index (vertex 0. 0. 0.)))))))
            ;; add triangles
            (let ((squares (make-vector (* width depth))))
              (define (safe-square x <fx> z <fx>)
                (and
                  (>= x 0) (< x width)
                  (>= z 0) (< z depth)
                  (get-square x z)))
              (define (get-square x <fx> z <fx>)
                (vector-ref squares (+ (* x depth) z)))
              (define (set-square x <fx> z <fx> square)
                (vector-set! squares (+ (* x depth) z) square))
              (define (make-square t1 t2)
                (cons t1 t2))
              (define (square-t1 square)
                (car square))
              (define (square-t2 square)
                (cdr square))
              (loop (for x from 0 below width)
                    (loop (for z from 0 below depth)
                          (let ((v1 (get-vertex x (+ z 1)))
                                (v2 (get-vertex (+ x 1) (+ z 1)))
                                (v3 (get-vertex (+ x 1) z))
                                (v4 (get-vertex x z)))
                            (let ((triangle1
                                    (add-element
                                      (new Triangle-Tile
                                        v1: v1
                                        v2: v2
                                        v3: v3
                                        parent: self)))
                                  (triangle2
                                    (add-element
                                      (new Triangle-Tile
                                        v1: v3
                                        v2: v4
                                        v3: v1
                                        parent: self))))
                              (set-square x z (make-square triangle1 triangle2))))))
              (loop (for x from 0 below x-count)
                    (loop (for z from 0 below z-count)
                          (let ((normal (get-normal x z))
                                (tl (safe-square (- x 1) (- z 1)))
                                (tr (safe-square x (- z 1)))
                                (bl (safe-square (- x 1) z))
                                (br (safe-square x z)))
                            (when tl
                              (vertex-increase! normal (get-normal~ (square-t1 tl))))
                            (when tr
                              (vertex-increase! normal (get-normal~ (square-t1 tr)))
                              (vertex-increase! normal (get-normal~ (square-t2 tr))))
                            (when bl
                              (vertex-increase! normal (get-normal~ (square-t1 bl)))
                              (vertex-increase! normal (get-normal~ (square-t2 bl))))
                            (when br
                              (vertex-increase! normal (get-normal~ (square-t2 br))))
                            (vertex-normalize! normal normal))))
              (loop (for x from 0 below width)
                    (loop (for z from 0 below depth)
                          (let ((square (get-square x z)))
                            (set-n1~ (square-t1 square) (get-normal x (+ z 1)))
                            (set-n2~ (square-t1 square) (get-normal (+ x 1) (+ z 1)))
                            (set-n3~ (square-t1 square) (get-normal (+ x 1) z))
                            (set-n1~ (square-t2 square) (get-normal (+ x 1) z))
                            (set-n2~ (square-t2 square) (get-normal x z))
                            (set-n3~ (square-t2 square) (get-normal x (+ z 1))))))))))))))
