;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Zones
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.zone jazz


(import (jazz.action)
        (jazz.application)
        (jazz.io)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.jml)
        (jazz.opengl.glew)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (world)
        (world.actor)
        (world.album)
        (world.area)
        (world.atlas)
        (world.audio)
        (world.autoload)
        (world.block)
        (world.camera)
        (world.chunk)
        (world.configure)
        (world.draw)
        (world.dye)
        (world.element)
        (world.enemy)
        (world.entity)
        (world.entities)
        (world.face)
        (world.foreign)
        (world.gadget)
        (world.generation)
        (world.geometry)
        (world.gravity)
        (world.grid)
        (world.history)
        (world.homogeneous)
        (world.info)
        (world.interface.documents)
        (world.interface.inventory)
        (world.lava)
        (world.light)
        (world.lighting)
        (world.material)
        (world.motion)
        (world.music)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.profiling)
        (world.redstone)
        (world.region)
        (world.render)
        (world.renderer)
        (world.renderers)
        (world.scene)
        (world.section)
        (world.sector)
        (world.settings)
        (world.skybox)
        (world.spawn)
        (world.sun)
        (world.support)
        (world.syntax (phase syntax))
        (world.tag)
        (world.task)
        (world.texture)
        (world.triangle)
        (world.water))


;;;
;;;; Zone
;;;


(definition protected day-duration <fl>
  24000.)

(definition protected dawn-daytime <fl>
  6000.)

(definition protected day-daytime <fl>
  12000.)

(definition protected dusk-daytime <fl>
  18000.)

(definition protected night-daytime <fl>
  0.)


(definition delay-updating? <bool>
  (world-setting 'world.delay-updating? #t))

(definition report-updating? <bool>
  (world-setting 'world.report-updating? #f))


(class Zone extends Scene
  
  
  (property title                   <string+>    initialize #f              accessors generate)
  (property start-mode              <symbol>     initialize #f              accessors generate)
  (property start-eye               <f64vector+> initialize #f              accessors generate)
  (property start-eye-sight         <f64vector+> initialize #f              accessors generate)
  (property start-eye-up            <f64vector+> initialize #f              accessors generate)
  (property start-position          <f64vector+> initialize #f              accessors explicit)
  (property start-sight             <f64vector+> initialize #f              accessors generate)
  (property start-up                <f64vector+> initialize #f              accessors generate)
  (property start-distance          <fl+>        initialize #f              accessors generate)
  (property truncate-y              <fx+>        initialize #f              accessors generate)
  (property missile-behavior        <symbol>     initialize 'destroy        accessors generate)
  (property ambient-color           <f32vector+> initialize #f              accessors generate)
  (property sun-color               <f32vector+> initialize #f              accessors generate)
  (property sun-cycle?              <bool>       initialize #t              accessors generate)
  (property start-time              <object>     initialize 'day            accessors generate)
  (property start-skybox            <object>     initialize #f              accessors generate)
  (property atlas-name              <object>     initialize #f              accessors generate)
  (property prepare-script          <object>     initialize #f              accessors generate)
  (property start-script            <object>     initialize #f              accessors generate)
  (property avatar                  <object>     initialize #f              accessors generate)
  (property draw-me?                <bool>       initialize #t              accessors generate)
  (property first-time?             <bool>       initialize #t              accessors generate)
  (property level-dir               <Directory>  initialize #f              accessors generate)
  (property dimension               <symbol>     initialize 'over           accessors generate)
  (property player-glow             <fl>         initialize -1.             accessors generate)
  (property properties              <object>     initialize '()             accessors generate)
  
  ;; world override properties
  (property ambient-gravity         <object>     initialize default-gravity accessors generate)
  (property jump-impulsion          <object>     initialize default-jump    accessors generate)
  (property start-grid?             <object>     initialize (unspecified)   accessors generate)
  (property start-axes?             <object>     initialize (unspecified)   accessors generate)


  (slot regions-dir                 <Directory>  initialize #f                        getter explicit)
  (slot regions-mutex               <object>     initialize (make-mutex 'regions)     getter generate)
  (slot regions                     <table>      initialize (make-table test: equal?) getter generate)
  (slot sectors                     <table>      initialize #f                        getter generate)
  (slot sector-size                 <fx>         initialize #f                        getter generate)
  (slot sector-radius               <fl>         initialize #f                        getter generate)
  (slot sector-diameter             <fl>         initialize #f                        getter generate)
  (slot sectors-generating          <fx>         initialize 0                         getter generate)
  (slot sectors-mutex               <object>     initialize #f                        getter generate)
  (slot debug-sectors?              <bool>       initialize #f                        accessors generate)
  (slot areas                       <table>      initialize #f                        getter generate)
  (slot area-size                   <fx>         initialize #f                        getter generate)
  (slot debug-areas?                <bool>       initialize #f                        accessors generate)
  (slot blocks                      <list>       initialize '()                       getter generate)
  (slot players                     <list>       initialize '()                       getter generate)
  (slot actors                      <list>       initialize '()                       getter generate)
  (slot entities                    <list>       initialize '()                       getter generate)
  (slot gravities                   <list>       initialize '()                       getter generate)
  (slot gadgets                     <list>       initialize '()                       getter generate)
  (slot marks                       <list>       initialize '()                       getter generate)
  (slot destroy-hooks               <list>       initialize '()                       getter generate)
  (slot editable-warned?            <bool>       initialize #f                        accessors generate)
  (slot generate-thread             <object>     initialize #f                        accessors generate)
  (slot lighting                    <Lighting>   initialize (new Lighting)            accessors generate)
  (slot block-lighting              <Lighting>   initialize (new Lighting)            accessors generate)
  (slot daytime                     <fl>         initialize 0.                        getter generate)
  (slot daylight                    <fl>         initialize 0.                        accessors generate)
  (slot sun                         <Sun+>       initialize #f                        accessors generate)
  (slot sun-angle                   <fl>         initialize -.20                      accessors generate)
  (slot skybox                      <Skybox+>    initialize #f                        accessors generate)
  (slot designer                    <object>     initialize #f                        accessors generate)
  (slot level-file                               initialize #f)
  (slot level-nbt                                initialize #f)
  (slot opened-chest                             initialize #f accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition default-ambient-color
    (dye .1 .05 0. 1.))
  
  
  ;; quicky for tests
  (method protected virtual (planets?)
    #f)
  
  
  (method protected virtual (needs-pumps?)
    #t)
  
  
  (method override (finish rest)
    (define (effective-ambient-color)
      (let ((ambient-color (world-setting 'world.ambient-color 'default)))
        (cond ((not ambient-color)
               (dye 0. 0. 0. 1.0))
              ((eq? ambient-color 'default)
               default-ambient-color)
              (else
               ambient-color))))
    
    (nextmethod rest)
    (load-point 'zone-prepare)
    (prepare-blocks)
    (load-point 'zone-blocks)
    (prepare-draw)
    (load-point 'zone-draw)
    (set-current-zone self)
    (set! draw-me? (world-setting 'world.draw-me? #t))
    (set! ambient-color (or ambient-color (effective-ambient-color)))
    (set! sun-color (or sun-color (world-setting 'world.sun-color #f) (dye 1.0 1.0 1.0 1.0)))
    (set! sun-cycle? (and sun-cycle? (world-setting 'world.sun-cycle? #t)))
    (set! start-time (world-setting 'world.start-time 'dawn))
    (set! avatar (or avatar (world-setting 'world.avatar "character/bloodelffemale")))
    (register-task 'generate generate-task)
    (register-task 'render render-task)
    (register-task 'player player-task)
    (register-task 'tick tick-task)
    (register-task 'sun sun-task)
    (register-task 'spawn spawn-task)
    (register-task 'redstone redstone-task)
    (register-task 'gravity gravity-task)
    (register-task 'lava lava-task)
    (register-task 'water water-task)
    (register-task 'distance distance-task)
    (register-task 'eat eat-task)
    (register-task 'audio audio-task)
    (register-task 'music music-task)
    (load-point 'zone-tasks)
    (register-entity-classes)
    (prepare-skybox-program)
    (prepare-skybox)
    (load-point 'zone-skybox)
    (initialize-spawned)
    (load-point 'zone-spawned)
    (set-daytime (effective-daytime start-time))
    (set! sun-angle (daytime->sun-angle daytime))
    (load-point 'zone-sun))
  
  
  (method (initialize-zone)
    (let ((world (current-world)))
      (setup-persistence)
      (setup-areas)
      (setup-sectors)
      (setup-boundaries)
      (setup-overrides)
      (setup-programs)
      (setup-game)
      (start-ambience)
      (start-music)
      (setup-history~ world)
      (install-interface)))
  
  
  (method (setup-persistence)
    (let ((moniker (get-moniker)))
      (when (and moniker (not level-dir))
        (set! level-dir (new-directory~ (get-parent~ moniker) "level")))))
  
  
  (method (setup-overrides)
    (let ((world (current-world)))
      (when (specified? ambient-gravity)
        (set-ambient-gravity~ world ambient-gravity))
      (when (specified? jump-impulsion)
        (set-jump-impulsion~ world jump-impulsion))
      (when (specified? start-grid?)
        (set-grid?~ world start-grid?))
      (when (specified? start-axes?)
        (set-axes?~ world start-axes?))))
  
  
  (method (setup-programs)
    (let ((world (current-world)))
      (let ((block-program (find-mesh-program~ (current-world) (default-block-program))))
        (set-block-program~ world block-program)
        (set-program~ (get-opaque-renderer) block-program)
        (set-program~ (get-transparent-renderer) block-program)
        (set-program~ (get-culled-transparent-renderer) block-program)
        (set-program~ (get-coverage-renderer) block-program))))
  
  
  (method protected virtual (setup-game)
    (set-current-game (new World-Game)))
  
  
  (method protected virtual (start-ambience)
    (let ((ambience (current-ambience)))
      (initial-ambience~ ambience)))
  
  
  (method protected virtual (start-music)
    (let ((music (current-music)))
      (initial-music~ music)))
  
  
  (method protected virtual (stop-ambience)
    (let ((ambience (current-ambience)))
      (close-ambience~ ambience)))
  
  
  (method protected virtual (stop-music)
    (let ((music (current-music)))
      (close-music~ music)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method protected virtual (get-start-position)
    start-position)
  
  
  (method protected virtual (set-start-position pos)
    (set! start-position pos))
  
  
  (method protected virtual (sector-class)
    Sector)
  
  
  (method protected virtual (default-block-program)
    'phong)
  
  
  (method protected virtual (populate-zone)
    )
  
  
  (method protected virtual (generate-visual sector)
    (with-generate-mutex
      (lambda ()
        ;; is this still necessary?
        (when (eq? self (current-zone))
          (generate-sector sector 'visual)))))
  
  
  (method protected virtual (generate-physical sector)
    (with-generate-mutex
      (lambda ()
        ;; is this still necessary?
        (when (eq? self (current-zone))
          (generate-sector sector 'physical)))))
  
  
  (method protected virtual (zone-ready)
    )
  
  
  (method (get-zone-directory)
    (let ((moniker (get-moniker)))
      (when moniker
        (get-parent~ moniker))))
  
  
  (method (determine-path)
    (let ((world (current-world)))
      (let ((moniker (get-moniker)))
        (let ((directories (get-zones-directories~ world)))
          (let (iter (moniker (get-parent~ moniker)) (path '()))
            (if (some? (lambda (dir)
                         (pathname=? moniker dir))
                       directories)
                path
              (let ((parent (get-parent~ moniker)))
                (if (not parent)
                    #f
                  (iter parent (cons (get-base~ moniker) path))))))))))
  
  
  (method (zone-brother path)
    (new-file~ (get-zone-directory) path))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (register-destroy-hook proc)
    (set! destroy-hooks (cons proc destroy-hooks)))
  
  
  (method (unregister-destroy-hook proc)
    (set! destroy-hooks (remove! proc destroy-hooks)))
  
  
  (method override (add-child child)
    (set! children (cons child children)))
  
  
  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (let ((world (current-world)))
      (shutdown-tasks self)
      (save-zone)
      (save-designer)
      (for-each (lambda (proc)
                  (proc))
                destroy-hooks)
      (free-sectors)
      (free-regions)
      (uninstall-interface)
      (stop-ambience)
      (stop-music)))
  
  
  (method protected virtual (save-zone)
    (let ((world (current-world)))
      (define (save)
        (set-property~ designer self 'first-time? #f))
      
      (define (save-mode)
        (set-property~ designer self 'start-mode (if (person-motion?) 'first-person 'free-camera)))
      
      (define (save-camera)
        (let ((eye (get-eye~ world)))
          (set-property~ designer self 'start-eye (get-position~ eye))
          (set-property~ designer self 'start-eye-sight (get-sight~ eye))
          (set-property~ designer self 'start-eye-up (get-up~ eye))))
      
      (define (save-player)
        (let ((me (current-me))
              (motion (current-motion)))
          (set-property~ designer self 'start-position (get-position~ me))
          (let ((lookat (get-lookat~ me)))
            (set-property~ designer self 'start-sight (get-sight~ lookat))
            (set-property~ designer self 'start-up (get-up~ lookat)))
          (when (is? motion Target-Motion)
            (set-property~ designer self 'start-distance (get-desired-distance~ motion)))))
      
      (save)
      (save-mode)
      (save-camera)
      (save-player)
      (save-chest save-region?: #t)
      (save-inventory)
      (save-level-nbt)))
  
  
  (method protected (save-designer)
    (save~ designer))
  
  
  (method (install-interface)
    (let ((world (current-world)))
      (let ((interface (get-interface~ world)))
        (set-visible?~ (child~ interface 'bag) #f)
        (view-inventory~ (child~ interface 'belt))
        (set-visible?~ (child~ interface 'belt) (get-show-belt?~ world))
        (set-visible?~ (child~ interface 'chest) #f))))
  
  
  (method (uninstall-interface)
    (let ((world (current-world)))
      (let ((interface (get-interface~ world)))
        (set-show-belt?~ world (get-visible?~ (child~ interface 'belt)))
        (set-visible?~ (child~ interface 'bag) #f)
        (set-visible?~ (child~ interface 'belt) #f)
        (set-visible?~ (child~ interface 'chest) #f))))
  
  
  ;;;
  ;;;; Tasks
  ;;;
  
  
  (method (start-tasks)
    (start-task 'generate)
    (start-task 'render)
    (start-task 'player)
    (start-task 'tick)
    (start-task 'sun)
    (start-task 'spawn)
    (start-task 'redstone)
    (start-task 'gravity)
    (start-task 'lava)
    (start-task 'water)
    (start-task 'distance)
    (start-task 'eat)
    (start-task 'audio)
    (start-task 'music)
    (thread-base-priority-set! (task-thread 'player) player-priority)
    (thread-base-priority-set! (task-thread 'render) render-priority)
    (thread-base-priority-set! (task-thread 'tick) tick-priority)
    (thread-base-priority-set! (task-thread 'sun) sun-priority)
    (thread-base-priority-set! (task-thread 'spawn) spawn-priority)
    (thread-base-priority-set! (task-thread 'redstone) redstone-priority)
    (thread-base-priority-set! (task-thread 'gravity) gravity-priority)
    (thread-base-priority-set! (task-thread 'lava) lava-priority)
    (thread-base-priority-set! (task-thread 'water) water-priority)
    (thread-base-priority-set! (task-thread 'distance) distance-priority)
    (thread-base-priority-set! (task-thread 'eat) eat-priority)
    (thread-base-priority-set! (task-thread 'audio) audio-priority)
    (thread-base-priority-set! (task-thread 'music) music-priority)
    (thread-base-priority-set! (task-thread 'generate) generate-priority))
  
  
  (method (stop-tasks)
    (define (stop-enemies)
      (for-each (lambda (enemy)
                  (stop-task (get-task~ enemy)))
                spawned-enemies))
    
    (let ((world (current-world)))
      (set-render-boost? #f)
      (set-player-boost? #f)
      (stop-enemies)
      (stop-task 'sun)
      (stop-task 'spawn)
      (stop-task 'redstone)
      (stop-task 'gravity)
      (stop-task 'lava)
      (stop-task 'water)
      (stop-task 'distance)
      (stop-task 'eat)
      (stop-task 'music)
      (stop-task 'audio)
      (stop-task 'player)
      (stop-task 'tick)
      (set-player-thread~ world #f)
      (stop-task 'render)
      (set-render-thread~ world #f)
      (reset-content)
      (stop-task 'generate stop-generate)))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (reset-zone)
    (set! blocks '())
    (set! players '())
    (set! actors '())
    (set! entities '())
    (set! gravities '()))
  
  
  (method (update-children)
    (set-current-me #f)
    (for-each (lambda (obj)
                (when (is? obj Element)
                  (add-element obj)))
              children))
  
  
  (method (player-update)
    (let ((world (current-world)))
      (let ((interface (get-interface~ world)))
        (let ((character-pane (child~ interface 'character)))
          (view-inventory~ character-pane)
          (update~ character-pane)))))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (proclaim (not warn optimizations))
  
  
  (method (target-update target face face-rank poly vert)
    (define (center-info title center (poly #f))
      (let ((sector (position-sector center))
            (x (fxfloor (vertex-x center)))
            (y (fxfloor (vertex-y center)))
            (z (fxfloor (vertex-z center))))
        (let ((block (vector x y z))
              (sector-index (get-index~ sector)))
          (let ((sector-x (vector-ref sector-index 0))
                (sector-y (vector-ref sector-index 1))
                (sector-z (vector-ref sector-index 2)))
            (let ((region (sector-region sector-x sector-y sector-z)))
              (when region
                (let ((section (get-section~ region 'physical sector-x sector-y sector-z))
                      (cache-uninitialized 65535))
                  (when section
                    (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                          (sections <vector> (make-vector 27 #t))
                          (cache <u16vector> (initialize-block-cache cache-uninitialized))
                          (blocks (get-blocks~ section))
                          (data (get-data~ section))
                          (blocklight (get-blocklight~ section))
                          (skylight (get-skylight~ section)))
                      (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                        (if (and (= a 0)
                                 (= b 0)
                                 (= c 0))
                            section
                          (let ((index (section-index a b c)))
                            (let ((section (vector-ref sections index)))
                              (if (neq? section #t)
                                  section
                                (let ((x (+ sector-x a))
                                      (y (+ sector-y b))
                                      (z (+ sector-z c)))
                                  (let ((region (sector-region x y z)))
                                    (let ((section (and region (get-section~ (cast <World-Region> region) 'physical x y z))))
                                      (vector-set! sections index section)
                                      section))))))))
                      
                      (define (section-index a <fx> b <fx> c <fx>) <fx>
                        (+ (* b 9) (* c 3) a 13))
                      
                      (define (local-index i <fx> j <fx> k <fx>) <fx>
                        (+ (* j 256) (* k 16) i))
                      
                      (define (effective-index i <fx> j <fx> k <fx>) <fx>
                        (* (+ (* j 324) (* k 18) i 343) 4))
                      
                      (define (blocks-get section <World-Section>) <u8vector>
                        (get-blocks~ section))
                      
                      (define (blocklight-get section <World-Section>) <u8vector>
                        (get-blocklight~ section))
                      
                      (define (blocklight-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref blocklight (local-index i j k)))
                      
                      (define (skylight-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref skylight (local-index i j k)))
                      
                      (define (local-block-ref i <fx> j <fx> k <fx>)
                        (u8vector-ref blocks (local-index i j k)))
                      
                      (define (local-data-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref data (local-index i j k)))
                      
                      (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                        (let ((index (effective-index i j k)))
                          (let ((value (u16vector-ref cache index)))
                            (if (/= value cache-uninitialized)
                                value
                              (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                                (u16vector-set! cache index value)
                                value)))))
                      
                      (define (effective-light-ref shade <fl> i <fx> j <fx> k <fx>) <fx>
                        (field-ref i j k blocklight-get u4vector-ref 0 0))
                      
                      (define (u4vector-ref field <u8vector> index <fx>) <fx>
                        (let ((byte (u8vector-ref field (quotient index 2))))
                          (if (even? index)
                              (bitwise-and byte #x0F)
                            (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                      
                      (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                        (define (bind-i a <fx> i <fx>)
                          (define (bind-j b <fx> j <fx>)
                            (define (bind-k c <fx> k <fx>)
                              (let ((section (section-ref a b c)))
                                (if (not section)
                                    (if (and bottom-section? (= b -1)) bottom empty)
                                  (let ((field (get-field section)))
                                    (if (not field)
                                        (if (and bottom-section? (= b -1)) bottom empty)
                                      (ref field (local-index i j k)))))))
                            
                            (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                  ((> k 15) (bind-k 1 (- k 16)))
                                  (else (bind-k 0 k))))
                          
                          (cond ((< j 0) (bind-j -1 (+ 16 j)))
                                ((> j 15) (bind-j 1 (- j 16)))
                                (else (bind-j 0 j))))
                        
                        (cond ((< i 0) (bind-i -1 (+ 16 i)))
                              ((> i 15) (bind-i 1 (- i 16)))
                              (else (bind-i 0 i))))
                      
                      (define (compute-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                        (format "{a} {a} {a} {a}"
                                (effective-light-ref shade (+ i ax) (+ j ay) (+ k az))
                                (effective-light-ref shade (+ i bx) (+ j by) (+ k bz))
                                (effective-light-ref shade (+ i cx) (+ j cy) (+ k cz))
                                (effective-light-ref shade (+ i dx) (+ j dy) (+ k dz))))
                      
                      (define (ambient-light i <fx> j <fx> k <fx> vert)
                        (let ((origin (vertex- (vertex-& vert (vertex& (cast <fl> x) (cast <fl> y) (cast <fl> z))) (vertex& .5 .5 .5)))
                              (normal (get-normal~ poly)))
                          (generic-lighting i j k origin normal compute-lighting no-shade)))
                      
                      (define (block-info i <fx> j <fx> k <fx>)
                        (let ((id (local-block-ref i j k))
                              (data (local-data-ref i j k))
                              (blocklight (blocklight-ref i j k))
                              (skylight (skylight-ref i j k)))
                          (let ((block (blockid->block id)))
                            (append (list (cons title (get-name~ block))
                                          (cons "id" id)
                                          (cons "data" data)
                                          (cons "block light" blocklight)
                                          (cons "sky light" skylight))
                                    (if (and poly (programmer-role?))
                                        (list (cons "sector" (format "{a} {a} {a}" sector-x sector-y sector-z))
                                              (cons "coordinates" (format "{a} {a} {a}" i j k))
                                              (cons "global" (present-vertex (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly))))
                                              (cons "ambient" (ambient-light i j k vert)))
                                      '())))))
                      
                      (define (present-vertex vert)
                        (format "{r precision: 1}, {r precision: 1}, {r precision: 1}"
                                (vertex-x vert)
                                (vertex-y vert)
                                (vertex-z vert)))
                      
                      (let ((i (- x (* sector-x 16)))
                            (j (- y (* sector-y 16)))
                            (k (- z (* sector-z 16))))
                        (block-info i j k)))))))))))
    
    (define (update-info)
      (if (not poly)
          (begin
            (unregister-info 'block)
            (unregister-info 'fore)
            (let ((eye (get-position~ (current-camera))))
              (let ((info (center-info "Eye" eye)))
                (if (not info)
                    (unregister-info 'eye)
                  (register-info 'eye
                    (lambda (add-section add-info)
                      (let ((section (add-section "Eye")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info))))))))
        (let ((game (current-game)))
          (with-polygon-interaction~ game poly
            (lambda (poly block fore)
              (let ((info (center-info "Block" block poly)))
                (register-info 'block
                  (lambda (add-section add-info)
                    (let ((section (add-section "Block")))
                      (for-each (lambda (info)
                                  (add-info section (car info) (cdr info)))
                                info)))))
              (let ((info (center-info "Fore" fore)))
                (if (not info)
                    (unregister-info 'fore)
                  (register-info 'fore
                    (lambda (add-section add-info)
                      (let ((section (add-section "Fore")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info)))))))))
        (unregister-info 'eye)))
    
    (with-generate-mutex
      (lambda ()
        (update-info))))
  
  
  (proclaim (warn optimizations))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (get-moniker)
    (get-origin~ form))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (let ((world (current-world)))
      (when #t @buggy (neq? flag (get-modified?~ designer))
        (set-modified?~ designer flag)
        (update-title~ world))))
  
  
  (method (read-element element property)
    (read-property element property))
  
  
  (method (write-element element property value)
    (set-property~ designer element property value))
  
  
  ;;;
  ;;;; Prologue
  ;;;
  
  
  (method (check-prologue (size: size #f))
    (when (and first-time? (world-setting 'world.show-prologue? #t))
      (show-prologue size: size)
      (save-designer)))
  
  
  (method (show-prologue (size: size #f))
    (open-world-document (prologue-file) class: World-Formatted-Text-View size: (or size {Dimension 800 600})))
  
  
  (method (prologue-file)
    (zone-brother "Prologue.ftx"))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method (draw-zone)
    (let ((world (current-world))
          (me (current-me)))
      (draw-sectors~ world)
      (if (effective-draw-gadgets?~ world)
          (draw-gadgets)
        (draw-drawable-gadgets))
      (when (get-draw-marks?~ world)
        (draw-marks))
      (when (get-draw-atlas?~ world)
        (draw-atlas))
      (when (and sun (get-visible?~ sun))
        (register-sun))
      (gl-check-error)))
  
  
  ;;;
  ;;;; Blocks
  ;;;
  
  
  (method protected virtual (album-name)
    'block)
  
  
  (method protected virtual (create-album)
    (let ((name (or atlas-name (album-name))))
      (or (registered-album name)
          (let ((atlas (create-atlas)))
            (let ((textures (create-textures atlas)))
              (when (complete-album?)
                (complete~ atlas))
              (update-textures-subuvs atlas)
              (let ((album (new Album atlas textures)))
                (register-album name album)
                album))))))
  
  
  (method protected virtual (complete-album?)
    #t)
  
  
  (method protected virtual (create-atlas)
    (create-minecraft-atlas))
  
  
  (method protected virtual (create-textures atlas)
    (list->table
      (list
        ;; clamp to edge is necessary for joins like between the rails
        (cons 'clamp (create-minecraft-texture atlas wrap: GL_CLAMP_TO_EDGE))
        (cons 'repeat (create-minecraft-texture atlas min-filter: 'nearest)))))
  
  
  (method (create-opaque-material atlas texture)
    (get-material~ (cast <Rendering> (opaque-rendering))))
  
  
  (method (create-transparent-material atlas texture)
    (get-material~ (cast <Rendering> (transparent-rendering))))
  
  
  (method (prepare-blocks)
    (let ((world (current-world)))
      (let ((album (create-album)))
        (let ((atlas (get-atlas~ album)))
          (let ((texture (get-texture~ album 'clamp))
                (texture-repeat (get-texture~ album 'repeat)))
            (prepare-block~ world atlas texture texture-repeat)
            (let ((opaque-material (create-opaque-material atlas texture))
                  (transparent-material (create-transparent-material atlas texture)))
              (prepare-materials~ world opaque-material transparent-material)))))))

  
  (method (make-block-atlas (adder: adder #f))
    (let ((world (current-world)))
      (let ((atlas (new Atlas)))
        (iterate-assets~ world
          (lambda (assets)
            (add-assets-directory-if-exists~ atlas assets '("tile"))))
        (when adder
          (adder atlas))
        atlas)))
  
  
  (method protected virtual (sample-program-image program)
    (case program
      ((opaque) "stone")
      ((transparent) "flower_rose")
      (else "wool_colored_light_blue")))
  
  
  (method protected virtual (default-block-class)
    'block)
  
  
  @minecraft-convert
  (method override (default-block-class)
    (new Minecraft-Block model: 'Stone))
  
  
  ;;;
  ;;;; Skybox
  ;;;
  
  
  (method protected virtual (prepare-skybox)
    (set! skybox (let ((name (or start-skybox (world-setting 'world.skybox #f))))
                   (and name (let ((skybox (find-skybox name)))
                               (when skybox
                                 (prepare~ skybox))
                               skybox)))))
  
  
  (method (install-skybox sky)
    (prepare~ sky)
    (set! skybox sky))
  
  
  (method (remove-skybox)
    (set! skybox #f))
  
  
  ;;;
  ;;;; Boundaries
  ;;;
  
  
  (method (setup-boundaries)
    @w
    (set! boundaries (cuboid left bottom back right top front)))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method protected virtual (mouse-track elapse dx dy)
    #f)
  
  
  ;;;
  ;;;; Snapshots
  ;;;
  
  
  (method (snapshot-zone)
    (let ((world (current-world)))
      (new Snapshot
        ;; pragmatic hack until incremental history
        (let ((effective-actors (if (> (length actors) 50)
                                    (list (current-me))
                                  actors)))
          (object->u8vector effective-actors serialize))
        (object->u8vector gadgets serialize)
        (object->u8vector marks serialize)
        (object->u8vector (get-eye~ world) serialize)
        (object->u8vector sun-angle serialize))))
  
  
  (method (load-zone snapshot)
    (define (remove elem)
      ;; quick hack
      (when (is? elem Creature)
        (remove-enemy elem))
      (remove-element elem))
    
    (define (add elem)
      (set-parent~ elem self)
      (add-element elem)
      (update-matrix~ elem)
      ;; quick hack
      (when (is? elem Creature)
        (add-enemy elem)))
    
    (let ((world (current-world)))
      (for-each remove actors)
      (for-each add (u8vector->object (get-actors~ snapshot) deserialize))
      (for-each remove gadgets)
      (for-each add (u8vector->object (get-gadgets~ snapshot) deserialize))
      (reset-marks)
      (set! marks (u8vector->object (get-marks~ snapshot) deserialize))
      (set-eye~ world (u8vector->object (get-camera~ snapshot) deserialize))
      (when sun-cycle?
        (position-sun (u8vector->object (get-sun-angle~ snapshot) deserialize)))))
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method (add-element obj)
    (define (add-player)
      (set! players (cons obj players))
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-actor)
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-block)
      (set! blocks (cons obj blocks)))
    
    (define (add-gravity)
      (set! gravities (cons obj gravities))
      (set! gadgets (cons obj gadgets)))
    
    (define (add-gravity-well)
      (set! gravities (cons obj gravities)))
    
    (define (add-gadget)
      (set! gadgets (cons obj gadgets)))
    
    (define (add-entity)
      (set! entities (cons obj entities)))
    
    (typecase obj
      ((Player) (add-player))
      ((Actor) (add-actor))
      ((Block) (add-block))
      ((Gravity) (add-gravity))
      ((Gravity-Well) (add-gravity-well))
      ((Gadget) (add-gadget))
      ((Entity) (add-entity)))
    (area-add-element (element-area obj) obj)
    (sector-add-element (element-sector obj) obj)
    obj)
  
  
  (method (remove-element obj)
    (define (remove-player)
      (set! players (remove! obj players))
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-actor)
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-block)
      (set! blocks (remove! obj blocks)))
    
    (define (remove-gravity)
      (set! gravities (remove! obj gravities))
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-gravity-well)
      (set! gravities (remove! obj gravities)))
    
    (define (remove-gadget)
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-entity)
      (set! entities (remove! obj entities)))
    
    (typecase obj
      ((Player) (remove-player))
      ((Actor) (remove-actor))
      ((Block) (remove-block))
      ((Gravity) (remove-gravity))
      ((Gravity-Well) (remove-gravity-well))
      ((Gadget) (remove-gadget))
      ((Entity) (remove-entity)))
    (area-remove-element (element-area obj) obj)
    (sector-remove-element (element-sector obj) obj)
    (close~ obj))
  
  
  (method (update-element element old-position)
    (update-area element old-position)
    (let ((old-index (position-sector-index old-position))
          (new-index (element-sector-index element)))
      (unless (equal? old-index new-index)
        (let ((old-sector (index-sector old-index))
              (new-sector (index-sector new-index)))
          (sector-remove-element old-sector element)
          (sector-add-element new-sector element)))))
  
  
  (method (find-element predicate)
    (continuation-capture
      (lambda (return)
        (iterate-elements
          (lambda (element)
            (when (predicate element)
              (continuation-return return element))))
        #f)))
  
  
  (method (find-named-element name)
    (find-element
      (lambda (element)
        (eq? (get-name~ element) name))))
  
  
  (method (find-gadget predicate)
    (find-if predicate gadgets))
  
  
  (method (iterate-players proc)
    (for-each proc players))
  
  
  (method (iterate-actors proc)
    (for-each proc actors))
  
  
  (method (iterate-entities proc)
    (for-each proc entities))
  
  
  (method (iterate-gadgets proc)
    (for-each proc gadgets))
  
  
  (method (iterate-elements proc)
    (for-each proc blocks)
    (for-each proc entities))
  
  
  (method (draw-me)
    (let ((me (current-me)))
      (draw~ me)))
  
  
  (method (element-at vert)
    (continuation-capture
      (lambda (return)
        (let ((area (index-area (position-area-index vert))))
          (iterate-area-elements area
            (lambda (obj)
              (when (and (get-visible?~ obj)
                         (vertex=? (get-position~ obj) vert))
                (continuation-return return obj)))))
        #f)))
  
  
  (method (element-near vert)
    (let ((x (vertex-x vert))
          (y (vertex-y vert))
          (z (vertex-z vert))
          (radius .45))
      (let ((left (- x radius))
            (bottom (- y radius))
            (back (- z radius))
            (right (+ x radius))
            (top (+ y radius))
            (front (+ z radius)))
        (continuation-capture
          (lambda (return)
            (iterate-position-neighbor-areas vert 1
              (lambda (area)
                (iterate-area-elements area
                  (lambda (obj)
                    (when (and (get-visible?~ obj)
                               (let ((x (get-x~ obj))
                                     (y (get-y~ obj))
                                     (z (get-z~ obj)))
                                 (and (>= x left)
                                      (>= y bottom)
                                      (>= z back)
                                      (<  x right)
                                      (<  y top)
                                      (<  z front))))
                      (continuation-return return obj))))))
            #f)))))
  
  
  (method (validate-elements)
    (iterate-elements
      (lambda (element)
        (assert (real? (get-x~ element)))
        (assert (real? (get-y~ element)))
        (assert (real? (get-z~ element)))
        (assert (real? (get-red~ element)))
        (assert (real? (get-green~ element)))
        (assert (real? (get-blue~ element)))
        (assert (real? (get-alpha~ element))))))
  
  
  ;;;
  ;;;; Enemies
  ;;;
  
  
  (method (add-enemy enemy)
    (set-spawned-count (+ spawned-count 1))
    (set-spawned-enemies (cons enemy spawned-enemies))
    (let ((procedure
            (lambda (task)
              (enemy-task~ enemy task))))
      (let ((task (new Task 'enemy procedure)))
        (start-task task)
        (set-task~ enemy task)
        (thread-base-priority-set! (get-thread~ task) enemy-priority))))
  
  
  (method (remove-enemy enemy)
    (let ((pos (get-spawner-position~ enemy)))
      (let ((spawner (find-object (lambda (spawner)
                                    (when (equal? (get-position~ spawner) pos)
                                      spawner))
                                  spawner-list)))
        (when spawner
          (set-enemy-count~ spawner (- (get-enemy-count~ spawner) 1))))
      (set-spawned-count (- spawned-count 1))
      (set-spawned-enemies (remove enemy spawned-enemies)))
    (let ((task (get-task~ enemy)))
      (stop-task task)))
  
  
  (method (change-enemy-models? value)
    (set-enemy-models? value)
    (for-each (lambda (enemy)
                (update-model~ enemy anchor?: #t))
              spawned-enemies))
  
  
  ;;;
  ;;;; Regions
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (with-regions-mutex thunk)
    (mutex-lock! regions-mutex)
    (prog1 (thunk)
      (mutex-unlock! regions-mutex)))
  
  
  (method (free-regions)
    (with-regions-mutex
      (lambda ()
        (iterate-table regions
          (lambda (index region <World-Region+>)
            (when region
              (close~ region))))
        (empty-table regions))))
  
  
  (method (get-regions-dir) <Directory>
    (or regions-dir (let ((dir (new-directory~ level-dir (case dimension
                                                           ((over) "region")
                                                           ((nether) '("DIM-1" "region"))
                                                           ((end) '("DIM1" "region"))))))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method (iterate-regions-dir proc)
    (iterate-directory~ (get-regions-dir)
      (lambda (file <File>)
        (when (extension=? (get-extension~ file) "mca")
          (let ((base <string> (get-base~ file)))
            (bind (x z) (split (substring base 2 (string-length base)) ".")
              (let ((x (string->number x))
                    (z (string->number z)))
                (proc file x z))))))))
  
  
  (method (compute-boundaries)
    (let ((inf 1000000))
      (let ((left inf)
            (right (- inf))
            (back inf)
            (front (- inf)))
        (iterate-regions-dir
          (lambda (file x <fx> z <fx>)
            (when (< x left)
              (set! left x))
            (when (> x right)
              (set! right x))
            (when (< z back)
              (set! back z))
            (when (> z front)
              (set! front z))))
        (values left right back front))))
  
  
  (method public (change-dimension)
    (with-generate-mutex
      (lambda ()
        (set! dimension (case dimension
                          ((over) 'nether)
                          ((nether) 'end)
                          ((end) 'over)))
        (set! regions-dir #f)
        (set! regions (make-table test: equal?))
        (set! sectors (make-table test: equal?))
        (set! areas (make-table test: equal?)))))
  
  
  ;; for exploration
  (method (preload-regions)
    (iterate-regions-dir
      (lambda (file x z)
        (let ((region (get-region x z)))
          (loop (for sector-x from 0 below 32)
                (loop (for sector-z from 0 below 32)
                      (loop (for sector-y from 0 below 16)
                            (get-section~ region 'physical sector-x sector-y sector-z))))))))


  ;; for exploration
  (method (explore-regions from to (more? #f))
    (define (explore region)
      (let ((region-x (get-x~ region))
            (region-z (get-z~ region))
            (count 0)
            (missing (new-queue)))
        (iterate-chunks~ region
          (lambda (x z)
            (when (not (get-chunk~ region x z))
              (increase! count)
              (enqueue missing (list (+ (* region-x region-size) x)
                                     (+ (* region-z region-size) z))))))
        (if (not more?)
            (debug region count)
          (debug region count (queue-list missing)))))
      
      (loop (for x from from to to)
            (loop (for z from from to to)
                  (explore (get-region x z)))))
  
  
  ;; exploration
  (method (explore-chests)
    (preload-regions)
    (let ((items '()))
      (for-each (lambda (info)
                  (bind (sector i j k) info
                    (call-with-sector sector i j k
                      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                        (let ((data (block-entity-data region sector i j k)))
                          (let ((inventory (list-payload-content (tag-assoc "Items" data))))
                            (for-each (lambda (item)
                                        (let ((id (tag-assoc "id" item)))
                                          (let ((name (or (let ((item (id->item id)))
                                                            (and item (get-name~ item)))
                                                          id)))
                                          (unless (memv? name items)
                                            (set! items (cons name items))))))
                                      inventory)))))))
                (find-visual-blocks '(54)))
      (sort nu<? items key: ->string)))
  
  
  (method (get-region region-x <fx> region-z <fx> (create?: create? #f)) <World-Region+>
    (let ((region-index (cons region-x region-z)))
      (define (region-name)
        (format "r.{a}.{a}.mca" region-x region-z))
      
      (define (create-region file)
        (create-directories~ file)
        (call-with-output-file (path-settings file)
          (lambda (port)
            (let ((locations/timestamps (make-u8vector 4096 0)))
              (write-subu8vector locations/timestamps 0 4096 port)
              (write-subu8vector locations/timestamps 0 4096 port)))))
      
      (with-regions-mutex
        (lambda ()
          (let ((not-found (if create? #f #t)))
            (let ((value (table-ref regions region-index not-found)))
              (if (neq? value not-found)
                  value
                (let ((dir (get-regions-dir))
                      (name (region-name)))
                  (let ((file (new-file~ dir name)))
                    (let ((region (cond ((exists?~ file)
                                         (new World-Region region-x region-z file))
                                        (create?
                                          (create-region file)
                                          (new World-Region region-x region-z file))
                                        (else
                                         #f))))
                      (table-set! regions region-index region)
                      region))))))))))
  
  
  (method (sector-region sector-x <fx> sector-y <fx> sector-z <fx> (create?: create? #f)) <World-Region+>
    (get-region (fxfloor/ sector-x region-size)
                (fxfloor/ sector-z region-size)
                create?: create?))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (count-regions)
    (let ((count 0))
      (iterate-table regions
        (lambda (index region)
          (when region
            (increase! count))))
      count))
  
  
  (method (count-chunks)
    (let ((count 0))
      (iterate-table regions
        (lambda (index region)
          (when region
            (increase! count (table-length (get-chunks~ region))))))
      count))
  
  
  (method (count-sections)
    (let ((count 0))
      (iterate-table regions
        (lambda (index region)
          (when region
            (iterate-table (get-chunks~ region)
              (lambda (index chunk)
                (when chunk
                  (let ((sections-table (get-sections-table~ chunk)))
                    (when sections-table
                      (increase! count (table-length sections-table))))))))))
      count))
  
  
  (method (get-enemies)
    (collect-type Enemy actors))
    
  
  ;;;
  ;;;; Sectors
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-sectors)
    (let ((world (current-world)))
      (set! sectors (make-table test: equal?))
      (set! sector-size (or (world-setting 'world.sector-size #f) 16))
      (set! sector-radius (let ((half (/ sector-size 2.)))
                            (vertex-norm (vertex half half half))))
      (set! sector-diameter (* sector-radius 2))
      (set! sectors-mutex (make-mutex 'sectors))
      (let ((distance (get-view-distance~ world)))
        (let ((diameter (+ distance 1 distance)))
          (set! eye-radius distance)
          (set! eye-diameter diameter)
          (set! eye-diameter^2 (expt diameter 2))
          (set! eye-diameter^3 (expt diameter 3))
          (set! eye-sectors (make-eye-sectors))
          (set! eye-neighbors (make-eye-neighbors))))))
  
  
  (method (update-view-distance old-distance distance)
    (unless (= distance old-distance)
      (let ((diameter (+ distance 1 distance)))
        (let ((radius distance)
              (diameter^2 (expt diameter 2))
              (diameter^3 (expt diameter 3)))
          (define (index i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j radius) diameter^2)
               (* (+ k radius) diameter)
               (+ i radius)))
          
          (define (index-eye i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j eye-radius) eye-diameter^2)
               (* (+ k eye-radius) eye-diameter)
               (+ i eye-radius)))
          
          (let ((sectors (make-vector diameter^3 #f)))
            (cond ;; smaller
                  ((< distance old-distance)
                   (loop (for i from (- distance) to distance)
                         (loop (for j from (- distance) to distance)
                               (loop (for k from (- distance) to distance)
                                     (vector-set! sectors (index i j k) (vector-ref eye-sectors (index-eye i j k)))))))
                  ;; greater
                  (else
                   (loop (for i from (- old-distance) to old-distance)
                         (loop (for j from (- old-distance) to old-distance)
                               (loop (for k from (- old-distance) to old-distance)
                                     (vector-set! sectors (index i j k) (vector-ref eye-sectors (index-eye i j k))))))))
            (set! eye-radius radius)
            (set! eye-diameter diameter)
            (set! eye-diameter^2 diameter^2)
            (set! eye-diameter^3 diameter^3)
            (set! eye-sectors sectors)
            ;; greater so add new sectors
            (when (> distance old-distance)
              (let ((a <fx> (vector-ref eye-index 0))
                    (b <fx> (vector-ref eye-index 1))
                    (c <fx> (vector-ref eye-index 2)))
                (loop (for i from (- distance) to distance)
                      (loop (for j from (- distance) to distance)
                            (loop (for k from (- distance) to distance)
                                  (let ((index (index-eye i j k)))
                                    (unless (vector-ref eye-sectors index)
                                      (vector-set! sectors index (coordinates-sector (+ a i) (+ b j) (+ c k))))))))))
            (set! eye-neighbors (make-vector diameter^3 #f))
            (update-eye-neighbors distance))))))
  
  
  (method (element-sector-index element <Element>) <vector>
    (position-sector-index (get-position~ element)))
  
  
  (method (position-sector-index pos <f64vector>) <vector>
    (let ((size (cast <fl> sector-size)))
      (vector (fxfloor (/ (vertex-x pos) size))
              (fxfloor (/ (vertex-y pos) size))
              (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method (position-sector pos) <Sector>
    (index-sector (position-sector-index pos)))
  
  
  (method (element-sector element) <Sector>
    (index-sector (element-sector-index element)))
  
  
  (method (index-sector index <vector>) <Sector>
    (or (table-ref sectors index #f)
        (let ((sector (new-sector index)))
          (table-set! sectors index sector)
          sector)))
  
  
  (method (coordinates-sector x y z) <Sector>
    (let ((index (static (make-vector 3))))
      (vector-set! index 0 x)
      (vector-set! index 1 y)
      (vector-set! index 2 z)
      (or (table-ref sectors index #f)
          (let ((index (vector x y z)))
            (let ((sector (new-sector index)))
              (table-set! sectors index sector)
              sector)))))
  
  
  (method (new-sector index <vector>) <Sector>
    (define (center i <fx>)
      (* (+ (cast <fl> i) .5) sector-size))
    
    (let ((x (vector-ref index 0))
          (y (vector-ref index 1))
          (z (vector-ref index 2)))
      (new (sector-class) index (vertex (center x) (center y) (center z)))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (unlink-sector sector)
    ;; doesnt-work-as-is-see-unlink-area-comment
    )
  
  
  (method (free-sectors)
    (iterate-table sectors
      (lambda (index sector)
        (close~ sector))))
  
  
  (method (sector-add-element sector element)
    (define (add-block)
      (set-blocks~ sector (cons element (get-blocks~ sector)))
      (set-vertices-uptodate?~ sector #f)
      (set-lightmap-uptodate?~ sector #f))
    
    (define (add-entity)
      (set-entities~ sector (cons element (get-entities~ sector))))
    
    (typecase element
      ((Block)
       (add-block))
      ((Gadget))
      ((Entity)
       (add-entity)))
    (invalidate-lightmaps element))
  
  
  (method (sector-remove-element sector element)
    (define (remove-block)
      (let ((blocks (remove! element (get-blocks~ sector))))
        (set-blocks~ sector blocks)
        (set-vertices-uptodate?~ sector #f)
        (set-lightmap-uptodate?~ sector #f)
        (when (null? blocks)
          (unlink-sector sector))))
    
    (define (remove-entity)
      (set-entities~ sector (remove! element (get-entities~ sector))))
    
    (typecase element
      ((Block)
       (remove-block))
      ((Gadget))
      ((Entity)
       (remove-entity)))
    (invalidate-lightmaps element))
  
  
  (method (iterate-sectors proc)
    (iterate-table sectors
      proc))
  
  
  (method (iterate-sectors-with-blocks proc)
    (iterate-table sectors
      (lambda (index sector)
        (when (not-null? (get-blocks~ sector))
          (proc index sector)))))
  
  
  (method (iterate-sector-areas sector <Sector> proc)
    (let ((ratio (/ sector-size area-size))
          (index (get-index~ sector)))
      (let ((a (* (vector-ref index 0) ratio))
            (b (* (vector-ref index 1) ratio))
            (c (* (vector-ref index 2) ratio)))
        (loop (for i from 0 below ratio)
              (loop (for j from 0 below ratio)
                    (loop (for k from 0 below ratio)
                          (let ((area (existing-area (vector (+ a i)
                                                             (+ b j)
                                                             (+ c k)))))
                            (when area
                              (proc area)))))))))
  
  
  (method (sector-areas-bounds sector <Sector>) <vector>
    (let ((ratio (/ sector-size area-size))
          (index (get-index~ sector)))
      (let ((a (* (vector-ref index 0) ratio))
            (b (* (vector-ref index 1) ratio))
            (c (* (vector-ref index 2) ratio))
            (limit (- ratio 1)))
        (vector a b c (+ a limit) (+ b limit) (+ c limit)))))
  
  
  (proclaim (warn optimizations))
  
  
  (method (iterate-sector-neighbors sector distance <fx> proc)
    (let ((index (get-index~ sector)))
      (let ((a <fx> (vector-ref index 0))
            (b <fx> (vector-ref index 1))
            (c <fx> (vector-ref index 2)))
        (loop (for i from (- distance) to distance)
              (loop (for j from (- distance) to distance)
                    (loop (for k from (- distance) to distance)
                          (proc (coordinates-sector (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-position-neighbor-sectors pos distance <fx> proc)
    (iterate-sector-neighbors (position-sector pos) distance proc))
  
  
  (method (iterate-position-outward-neighbor-sectors pos distance <fx> proc)
    (let ((index (position-sector-index pos)))
      (proc (index-sector index))
      (let ((a <fx> (vector-ref index 0))
            (b <fx> (vector-ref index 1))
            (c <fx> (vector-ref index 2)))
        (loop (for radius from 1 to distance)
              (let ((radius-1 (- radius 1)))
                ;; left
                (let ((i (- a radius)))
                  (loop (for j from (- radius) to radius)
                        (loop (for k from (- radius) to radius)
                              (proc (coordinates-sector i (+ b j) (+ c k))))))
                ;; right
                (let ((i (+ a radius)))
                  (loop (for j from (- radius) to radius)
                        (loop (for k from (- radius) to radius)
                              (proc (coordinates-sector i (+ b j) (+ c k))))))
                ;; bottom
                (let ((j (- b radius)))
                  (loop (for i from (- radius-1) to radius-1)
                        (loop (for k from (- radius) to radius)
                              (proc (coordinates-sector (+ a i) j (+ c k))))))
                ;; top
                (let ((j (+ b radius)))
                  (loop (for i from (- radius-1) to radius-1)
                        (loop (for k from (- radius) to radius)
                              (proc (coordinates-sector (+ a i) j (+ c k))))))
                ;; back
                (let ((k (- c radius)))
                  (loop (for i from (- radius-1) to radius-1)
                        (loop (for j from (- radius-1) to radius-1)
                              (proc (coordinates-sector (+ a i) (+ b j) k)))))
                ;; front
                (let ((k (+ c radius)))
                  (loop (for i from (- radius-1) to radius-1)
                        (loop (for j from (- radius-1) to radius-1)
                              (proc (coordinates-sector (+ a i) (+ b j) k))))))))))
    
  
  ;; index of the eye sector
  (definition eye-index <vector+>
    #f)
  
  ;; cube of all eye sectors
  (definition eye-sectors
    #f)
  
  ;; eye sectors ordered by distance
  (definition eye-neighbors
    #f)
  
  (definition eye-radius <fx>
    0)
  
  (definition eye-diameter <fx>
    0)
  
  (definition eye-diameter^2 <fx>
    0)
  
  (definition eye-diameter^3 <fx>
    0)
  
  
  (method package (get-eye-index)
    eye-index)
  
  (method package (get-eye-sectors) <vector>
    eye-sectors)
  
  (method package (get-eye-neighbors) <vector>
    eye-neighbors)
    
  
  (method (sectors-index i <fx> j <fx> k <fx>) <fx>
    (+ (* j eye-diameter^2) (* k eye-diameter) i))

  
  (method (make-eye-sectors)
    (make-vector eye-diameter^3 #f))
  
  
  (method (make-eye-neighbors)
    (make-vector eye-diameter^3 #f))
  
  
  (method (find-eye-sector index)
    (when eye-index
      (let ((a <fx> (- (vector-ref eye-index 0) eye-radius))
            (b <fx> (- (vector-ref eye-index 1) eye-radius))
            (c <fx> (- (vector-ref eye-index 2) eye-radius)))
        (let ((i (- (vector-ref index 0) a))
              (j (- (vector-ref index 1) b))
              (k (- (vector-ref index 2) c))
              (last (- eye-diameter 1)))
          (when (and (between? i 0 last)
                     (between? j 0 last)
                     (between? k 0 last))
            (vector-ref eye-sectors (sectors-index i j k)))))))
  
  
  (method (eye-sector)
    (vector-ref eye-sectors (sectors-index eye-radius eye-radius eye-radius)))
  
  
  (method (free-eye-sectors)
    (set! eye-index #f)
    (loop (for n from 0 below eye-diameter^3)
          (let ((sector (vector-ref eye-sectors n)))
            (when sector
              (close~ sector)))
          (vector-set! eye-sectors n #f)
          (vector-set! eye-neighbors n #f)))
  
  
  (method (eye-neighbor-sectors pos distance <fx>) <vector>
    (define (sector-new i j k)
      ;; commented until cleanup finished
      ;; (new-sector (vector i j k))
      (coordinates-sector i j k))
    
    (define (sector-free sector)
      ;; commented until cleanup finished
      ;; (close~ sector)
      )
    
    (let ((index (position-sector-index pos)))
      (if (equal? index eye-index)
          eye-neighbors
        ;; update sectors
        (let ((sectors (get-eye-sectors))
              (a <fx> (- (vector-ref index 0) eye-radius))
              (b <fx> (- (vector-ref index 1) eye-radius))
              (c <fx> (- (vector-ref index 2) eye-radius)))
          (if (not eye-index)
              (loop (for i from 0 below eye-diameter)
                    (loop (for j from 0 below eye-diameter)
                          (loop (for k from 0 below eye-diameter)
                                (vector-set! sectors (sectors-index i j k)
                                  (sector-new (+ a i)
                                              (+ b j)
                                              (+ c k))))))
            (let ((last (- eye-diameter 1))
                  (dx (- (vector-ref index 0) (vector-ref eye-index 0)))
                  (dy (- (vector-ref index 1) (vector-ref eye-index 1)))
                  (dz (- (vector-ref index 2) (vector-ref eye-index 2))))
              (define (looping delta proc)
                (if (>= delta 0)
                    (loop (for n from 0 to last)
                          (proc n))
                  (loop (for n from last downto 0)
                        (proc n))))
              
              (looping dx
                (lambda (x)
                  (let ((fx (+ x dx))
                        (tx x))
                    (looping dy
                      (lambda (y)
                        (let ((fy (+ y dy))
                              (ty y))
                          (looping dz
                            (lambda (z)
                              (let ((fz (+ z dz))
                                    (tz z))
                                (let ((fi (and (between? fx 0 last)
                                               (between? fy 0 last)
                                               (between? fz 0 last)
                                               (sectors-index fx fy fz)))
                                      (ti (sectors-index tx ty tz)))
                                  (let ((sector (vector-ref sectors ti)))
                                    (when sector
                                      ;; free
                                      (sector-free sector)))
                                  (if fi
                                      (begin
                                        ;; move
                                        (vector-set! sectors ti (vector-ref sectors fi))
                                        (vector-set! sectors fi #f))
                                    ;; new
                                    (vector-set! sectors ti (sector-new (+ a tx) (+ b ty) (+ c tz)))))))))))))))))
        ;; update neighbors
        (update-eye-neighbors distance)
        (set! eye-index index)
        eye-neighbors)))
  
  
  (method (update-eye-neighbors distance <fx>)
    (let ((sectors eye-sectors)
          (neighbors eye-neighbors)
          (n 0))
      (define (set i j k)
        (vector-set! neighbors n (vector-ref sectors (sectors-index (+ i distance) (+ j distance) (+ k distance))))
        (increase! n))
      
      ;; set neighbors in expanding distance from eye
      (set 0 0 0)
      (loop (for radius from 1 to distance)
            (let ((radius-1 (- radius 1)))
              ;; left
              (let ((i (- radius)))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; right
              (let ((i radius))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; bottom
              (let ((j (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; top
              (let ((j radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; back
              (let ((k (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))
              ;; front
              (let ((k radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))))))
  
  
  (method (draw-eye-neighbors camera <Camera> view-distance <fx> @radius <fl> proc)
    (let ((world (current-world))
          (camera-position (get-position~ camera)))
      (let ((sectors (eye-neighbor-sectors camera-position view-distance)))
        (loop (for i from 0 below (vector-length sectors))
              (let ((sector <Sector> (vector-ref sectors i)))
                (let ((center (get-center~ sector)))
                  ;; this hack for big entities like trees slows
                  ;; down render and is not 100% correct anyways
                  ;; (< (f64-ref (vertex-distance& camera-position center)) radius)
                  (when (in-frustum?~ camera center)
                    (update~ sector)
                    (proc sector))))))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (iterate-element-neighbor-sectors element distance proc)
    (iterate-position-neighbor-sectors (get-position~ element) distance proc))
  
  
  (method (element-neighbor-sectors element distance)
    (let ((queue (new-queue)))
      (iterate-element-neighbor-sectors element distance (lambda (sector) (enqueue queue sector)))
      (queue-list queue)))
  
  
  (method (increase-sectors-generating count <fx>)
    (mutex-lock! sectors-mutex)
    (when (= sectors-generating 0)
      (active-site 'generate)
      (active-site 'content)
      (active-site 'read-chunk))
    (set! sectors-generating (+ sectors-generating count))
    (mutex-unlock! sectors-mutex))
  
  
  (method (decrease-sectors-generating count <fx>)
    (mutex-lock! sectors-mutex)
    (set! sectors-generating (- sectors-generating count))
    (when (= sectors-generating 0)
      (inactive-site 'generate)
      (inactive-site 'content)
      (inactive-site 'read-chunk))
    (mutex-unlock! sectors-mutex))
  
  
  (method (compute-floats)
    (let ((total 0))
      (iterate-table sectors
        (lambda (index sector)
          (let ((mesh (get-mesh~ sector)))
            (when (and mesh (get-vertices-uptodate?~ sector))
              (let ((floats (count-floats~ mesh)))
                (when floats
                  (increase! total floats)))))))
      total))
  
  
  (method (count-non-empty-sectors)
    (let ((total 0))
      (iterate-table sectors
        (lambda (index sector)
          (let ((mesh (get-mesh~ sector)))
            (when mesh
              (increase! total)))))
      total))
  
  
  (method (validate-sectors)
    )
  
  
  (method (toggle-debug-sectors)
    (let ((world (current-world)))
      (set! debug-sectors? (not debug-sectors?))
      (update-parameter~ world 'debug-sectors)))
  
  
  (method (draw-debug-sectors)
    (draw-3d-grid (element-sector-index (current-me)) sector-size))
  
  
  ;;;
  ;;;; Areas
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-areas)
    (set! areas (make-table test: equal?))
    (set! area-size 2))
  
  
  (method (element-area-index element <Element>) <vector>
    (position-area-index (get-position~ element)))
  
  
  (method (position-area-index pos <f64vector>) <vector>
    (let ((size (cast <fl> area-size)))
      (vector (fxfloor (/ (vertex-x pos) size))
              (fxfloor (/ (vertex-y pos) size))
              (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method (position-area-index& pos <f64vector>) <vector>
    (let ((size (cast <fl> area-size))
          (index (static (make-vector 3))))
      (vector-set! index 0 (fxfloor (fl& (/ (vertex-x pos) size))))
      (vector-set! index 1 (fxfloor (fl& (/ (vertex-y pos) size))))
      (vector-set! index 2 (fxfloor (fl& (/ (vertex-z pos) size))))
      index))
  
  
  (method (position-area pos) <Area>
    (index-area (position-area-index pos)))
  
  
  (method (element-area element) <Area>
    (index-area (element-area-index element)))
  
  
  (method (index-area index <vector> (update? #t)) <Area>
    (when update?
      (update-physical~ (area-index-sector index)))
    (or (table-ref areas index #f)
        (let ((area (new Area index)))
          (table-set! areas index area)
          area)))
  
  
  (method (area-sector area <Area>) <Sector>
    (area-index-sector (get-index~ area)))
  
  
  (method (area-index-sector index <vector>) <Sector>
    (area-coordinates-sector (vector-ref index 0) (vector-ref index 1) (vector-ref index 2)))
  
  
  (method (existing-area index <vector>) <Area+>
    (table-ref areas index #f))
  
  
  (method (coordinates-area x y z) <Area>
    (update-physical~ (area-coordinates-sector x y z))
    (let ((index (static (make-vector 3))))
      (vector-set! index 0 x)
      (vector-set! index 1 y)
      (vector-set! index 2 z)
      (or (table-ref areas index #f)
          (let ((index (vector x y z)))
            (let ((area (new Area index)))
              (table-set! areas index area)
              area)))))
  
  
  (method (area-coordinates-sector x <fx> y <fx> z <fx>) <Sector>
    (coordinates-sector (arithmetic-shift-right x 3)
                        (arithmetic-shift-right y 3)
                        (arithmetic-shift-right z 3)))
  
  
  (method (area-index-sector-coordinates! index <vector> coord <vector>)
    (vector-set! coord 0 (arithmetic-shift-right (vector-ref index 0) 3))
    (vector-set! coord 1 (arithmetic-shift-right (vector-ref index 1) 3))
    (vector-set! coord 2 (arithmetic-shift-right (vector-ref index 2) 3)))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (unlink-area area)
    @doesnt-work-as-is-because-hit-test-will-consult/create-the-27-adjacent-areas-even-if-they-are-empty
    (table-clear areas (get-index~ area)))
  
  
  (method (area-add-element area element)
    (define (add-actor)
      (set-actors~ area (cons element (get-actors~ area))))
    
    (define (add-block)
      (set-blocks~ area (cons element (get-blocks~ area)))
      (add-polygons~ (element-area element) element (element-polygons~ element) #f))
    
    (define (add-gadget)
      (set-gadgets~ area (cons element (get-gadgets~ area))))
    
    (define (add-entity)
      (set-entities~ area (cons element (get-entities~ area)))
      ;; need to optimize
      (when (get-physical?~ element)
        (let ((polygons (element-polygons~ element))
              (table (make-table test: eq?)))
          (for-each (lambda (polygon)
                      (let ((area (position-area (get-origin~ polygon))))
                        (table-add table area polygon)))
                    polygons)
          (iterate-table table
            (lambda (area polygons)
              (add-polygons~ area element polygons #f))))))
    
    (cond ((and (is? element Actor) (is-not? element Missile))
           (add-actor))
          ((is? element Block)
           (add-block))
          ((is? element Gadget)
           (add-gadget))
          ((is? element Entity)
           (add-entity))))
  
  
  (method (area-remove-element area element)
    (define (remove-actor)
      (let ((actors (remove! element (get-actors~ area))))
        (set-actors~ area actors)
        (when (and (null? actors) (null? (get-blocks~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-block)
      (let ((blocks (remove! element (get-blocks~ area))))
        (set-blocks~ area blocks)
        (remove-polygons~ area element)
        (when (and (null? blocks) (null? (get-actors~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-gadget)
      (let ((gadgets (remove! element (get-gadgets~ area))))
        (set-gadgets~ area gadgets)
        (when (and (null? gadgets) (null? (get-actors~ area)) (null? (get-blocks~ area)))
          (unlink-area area))))
    
    (define (remove-entity)
      (let ((entities (remove! element (get-entities~ area))))
        (set-entities~ area entities)
        ;; need to optimize
        (when (get-physical?~ element)
          (let ((polygons (element-polygons~ element))
                (table (make-table test: eq?)))
            (for-each (lambda (polygon)
                        (let ((area (position-area (get-origin~ polygon))))
                          (table-set! table area #t)))
                      polygons)
            (iterate-table table
              (lambda (area ignore)
                (remove-polygons~ area element)))))
        (when (and (null? gadgets) (null? (get-actors~ area)) (null? (get-blocks~ area)))
          (unlink-area area))))
    
    (cond ((is? element Actor)
           (remove-actor))
          ((is? element Block)
           (remove-block))
          ((is? element Gadget)
           (remove-gadget))
          ((is? element Entity)
           (remove-entity))))
  
  
  (method (update-area element old-position)
    (let ((old-index (position-area-index old-position))
          (new-index (element-area-index element)))
      (unless (equal? old-index new-index)
        (let ((old-area (index-area old-index))
              (new-area (index-area new-index)))
          (area-remove-element old-area element)
          (area-add-element new-area element)))))
  
  
  (method (iterate-areas proc)
    (iterate-table areas
      proc))
  
  
  (method (iterate-position-neighbor-areas pos distance <fx> proc)
    (let ((index (position-area-index& pos)))
      (let ((a <fx> (vector-ref index 0))
            (b <fx> (vector-ref index 1))
            (c <fx> (vector-ref index 2)))
        (loop (for i from (- distance) to distance)
              (loop (for j from (- distance) to distance)
                    (loop (for k from (- distance) to distance)
                          (proc (coordinates-area (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-area-elements area proc)
    (for-each proc (get-blocks~ area))
    (for-each proc (get-actors~ area))
    (for-each proc (get-entities~ area))
    (for-each proc (get-gadgets~ area)))
  
  
  (method (collect-area-elements)
    (let ((queue (new-queue)))
      (iterate-table areas
        (lambda (index area)
          (enqueue-list queue (get-blocks~ area))
          (enqueue-list queue (get-actors~ area))
          (enqueue-list queue (get-entities~ area))
          (enqueue-list queue (get-gadgets~ area))))
      (queue-list queue)))
  
  
  (method (areas-count filter)
    (count-if filter (collect-area-elements)))
  
  
  (method (count-polygons)
    (let ((count 0))
      (iterate-table areas
        (lambda (index area)
          (let ((polygons (get-polygons~ area)))
            (when polygons
              (increase! count (/ (f64vector-length polygons) polygon-float-size))))))
      count))
  
  
  (method (validate-areas)
    (let ((world (current-world)))
      (let ((blocks-count 0)
            (actors-count 0)
            (gadgets-count 0))
        (iterate-table areas
          (lambda (index area)
            (let ((area-blocks (length (get-blocks~ area)))
                  (area-actors (length (get-actors~ area)))
                  (area-gadgets (length (get-gadgets~ area))))
              (increase! blocks-count area-blocks)
              (increase! actors-count area-actors)
              (increase! gadgets-count area-gadgets))))
        (if (and (= blocks-count (length blocks))
                 (= actors-count (length actors))
                 (= gadgets-count (length gadgets)))
            (begin
              (unregister-info 'corrupted-areas)
              #t)
          (register-info 'corrupted-areas
            (lambda (add-section add-info)
              (let ((section (add-section "Corrupted areas")))
                (add-info section "blocks" (format "{s} {s}" blocks-count (length blocks)))
                (add-info section "actors" (format "{s} {s}" actors-count (length actors)))
                (add-info section "gadgets" (format "{s} {s}" gadgets-count (length gadgets))))))
          #f))))
  
  
  (method (toggle-debug-areas)
    (let ((world (current-world)))
      (set! debug-areas? (not debug-areas?))
      (update-parameter~ world 'debug-areas)))
  
  
  (method (draw-debug-areas)
    (draw-3d-grid (element-area-index (current-me)) area-size))
  
  
  ;;;
  ;;;; Gadget
  ;;;
  
  
  (method (draw-gadgets)
    (for-each (lambda (gadget)
                (register-entity gadget #t))
              gadgets))
  
  
  (method (draw-drawable-gadgets)
    (for-each (lambda (gadget)
                (when (and (drawable?~ gadget)
                           (get-visible?~ gadget))
                  (register-entity gadget)))
              gadgets))
  
  
  ;;;
  ;;;; Blocks
  ;;;
  
  
  (method (remove-duplicate-blocks)
    (let ((world (current-world)))
      (let ((table (make-table test: vertex=? hash: vertex-hash))
            (count 0))
        (for-each (lambda (block)
                    (let ((pos (get-position~ block)))
                      (if (table-ref table pos #f)
                          (begin
                            (editor-remove-element~ world block)
                            (increase! count))
                        (table-set! table pos block))))
                  blocks)
        (display-message~ world
          (format "Removed {a} block{a}"
                  (format-cardinality count)
                  (format-plural count))))))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (method (render-task task <Task>)
    (render-task~ (current-world) task))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (resurrect-player player)
    (let ((old-position (copy-vertex (get-position~ player)))
          (new-position (find-spawnpoint~ (current-zone))))
      (set-position~ player new-position)
      (set-velocity~ player (vertex 0. 0. 0.))
      (set-fall-velocity~ player (vertex 0. 0. 0.))
      (update-element player old-position)))
  
  
  (method protected virtual (player-task task <Task>)
    (player-task~ (current-world) task))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (tick-task task <Task>)
    (tick-task~ (current-world) task))
  
  
  ;;;
  ;;;; Actors
  ;;;
  
  
  (method (actors-task task <Task>)
    (actors-task~ (current-world) task))
  
  
  ;;;
  ;;;; Sun
  ;;;
  
  
  (definition sun-speed <fl>
    .025)
  
  
  (method (set-sun-speed speed)
    (set! sun-speed speed))
  
  
  (method (sun-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (if (not sun-cycle?)
              (task-sleep task +infinity 0. exit)
            (let (iter (previous (current-seconds)))
              (let ((time (current-seconds)))
                (let ((elapse (- time previous)))
                  (unless (get-paused?~ history)
                    (with-task-mutex
                      (lambda ()
                        (unless (stopping?~ task)
                          (trace-task sun "S")
                          (tick-sun elapse)))))
                  (let ((duration (- (current-seconds) time)))
                    (task-sleep task sun-period duration exit))
                  (iter time)))))))))
  
  
  (method (tick-sun elapse (reverse? #f))
    (site (sun on?: #t)
      (position-sun ((if reverse? - +) sun-angle (* sun-speed elapse)))))
  
  
  (method (position-sun angle)
    (set! sun-angle (flmodulo angle PI*2))
    (let ((under-limit 0.1)
          (direction (rotate-upon& PI/4 (vertex 0.0 1.0 0.0) (rotate-upon& sun-angle (vertex 0.0 0.0 -1.0) (vertex -1. 0. 0.)))))
      (let ((pos (vertex-scalar* direction 1000.)))
        (when (not sun)
          (set! sun (new Sun parent: self position: pos))
          (add-element sun))
        (cond ((or (< sun-angle (+ PI under-limit))
                   (> sun-angle (- PI*2 under-limit)))
               (let ((under (cond ((> sun-angle (- PI*2 under-limit)) (- PI*2 sun-angle))
                                  ((and (> sun-angle PI) (< sun-angle (+ PI under-limit))) (- sun-angle PI))
                                  (else 0.))))
                 (let ((intensity (- 1.0 (/ under under-limit))))
                   (let ((effective (dye (* (dye-red sun-color) intensity)
                                         (* (dye-green sun-color) intensity)
                                         (* (dye-blue sun-color) intensity)
                                         1.0)))
                     (set-position~ sun pos)
                     (set-color~ sun effective)
                     (set-visible?~ sun #t)))))
              (else
               (set-sun-effective~ lighting (dye 0. 0. 0. 0.))
               (set-visible?~ sun #f)))
        (sun-update))))
  
  
  (method (sun-update)
    (set-daytime (sun-angle->daytime sun-angle)))
  
  
  (method (register-sun)
    (register-entity sun))
  
  
  ;;;
  ;;;; Daytime
  ;;;
  
  
  (method (goto-daytime daytime)
    (if sun-cycle?
        (position-sun (daytime->sun-angle daytime))
      (set-daytime daytime)))
  
  
  (method (sun-angle->daytime sun-angle)
    (let ((angle (flmodulo sun-angle PI*2)))
      (flmodulo (+ (/ (* angle day-duration) PI*2) dawn-daytime) day-duration)))
  
  
  (method (daytime->sun-angle daytime)
    (/ (* (- daytime dawn-daytime) PI*2) day-duration))
  
  
  (method (effective-daytime daytime)
    (cond ((flonum? daytime) daytime)
          ((or (eq? daytime 'default) (ci=? daytime "default")) dawn-daytime)
          ((or (eq? daytime 'dawn) (ci=? daytime "dawn")) dawn-daytime)
          ((or (eq? daytime 'day) (ci=? daytime "day")) day-daytime)
          ((or (eq? daytime 'dusk) (ci=? daytime "dusk")) dusk-daytime)
          ((or (eq? daytime 'night) (ci=? daytime "night")) night-daytime)
          ((string? daytime) (cast <fl> (string->number daytime)))
          (else "Invalid daytime: {s}" daytime)))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method (gravity-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history))
          (game (current-game)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds)))
              (let ((elapse (- time previous)))
                (unless (get-paused?~ history)
                  (with-task-mutex
                    (lambda ()
                      (unless (stopping?~ task)
                        (trace-task gravity "G")
                        (let ((blocks (get-fall-blocks~ game)))
                          (unless (queue-empty? blocks)
                            (set-fall-blocks~ game (new-queue))
                            (tick-gravity elapse blocks)))))))
                (task-sleep task gravity-period (- (current-seconds) time) exit)
                (iter time))))))))
  
  
  (method (tick-gravity elapse blocks)
    (site (gravity on?: #t)
      (blocks-fall elapse blocks)))
  
  
  (method (blocks-fall elapse blocks)
    (let ((game (current-game)))
      (updating-sectors~ (current-zone)
        (lambda (add-sector)
          (let (iter)
            (unless (queue-empty? blocks)
              (bind (sector i j k) (dequeue blocks)
                (call-with-sector sector i j k
                  (lambda (region sector block <fx> data <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                    (define (effective-block-ref i j k)
                      (with-field i j k
                        (lambda (section index)
                          (if section
                            (block-ref section index)
                            0))))
                    
                    (define (add-neighbors i j k)
                      (define (add-neighbor i j k)
                        (with-field i j k
                          (lambda (section index)
                            @w(when (id? (block-ref section index) Sand Gravel)
                              (normalize-sector/coordinates sector i j k with-field
                                (lambda (sector i j k)
                                  (add-fall-block~ game sector i j k))))
                            (add-sector (get-sector~ section)))))
                      
                      (add-neighbor (+ i 1) j k)
                      (add-neighbor (- i 1) j k)
                      (add-neighbor i (+ j 1) k)
                      (add-neighbor i (- j 1) k)
                      (add-neighbor i j (+ k 1))
                      (add-neighbor i j (- k 1)))
                    
                    (when (and (id? block Sand Gravel) (id? (effective-block-ref i (- j 1) k) Air Water StationaryWater Lava StationaryLava))
                      (with-field i j k
                        (lambda (section index)
                          (block-set! section index 0)
                          (add-neighbors i j k)
                          (inverse-propagate-light~ game i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                          (redstone-update sector (list i j k block) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!)))))))
              (iter))))
        delay-update?: #t)))
  
  
  ;;;
  ;;;; Distance
  ;;;
  
  
  (method (distance-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds)))
              (let ((elapse (- time previous)))
                (unless (get-paused?~ history)
                  (with-task-mutex
                    (lambda ()
                      (unless (stopping?~ task)
                        (trace-task distance "D")
                        (tick-distance elapse)))))
                (let ((duration (- (current-seconds) time)))
                  (task-sleep task distance-period duration exit))
                (iter time))))))))
  
  
  (method (tick-distance elapse)
    (site (distance on?: #t)
      (check-distance elapse (current-me))))
  
  
  (method (check-distance elapse me)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((chest (get-opened-chest~ zone))
            (enemies (get-aggroed-enemies~ me))
            (pos (get-position~ me)))
        (when chest
          (bind (index i j k) chest
            (let ((sector (table-ref (get-sectors~ zone) index)))
              (let ((location (sector/coordinates->location sector i j k)))
                (let ((dist (vertex-distance (vertex (+ (vector-ref location 0) .5)
                                                     (- (vector-ref location 1) 63.5)
                                                     (+ (vector-ref location 2) .5))
                                             pos)))
                  (when (> dist (if (user-role?)
                                    (world-setting 'world.interaction-distance 8.)
                                  20.))
                    (play-sound-file "sound/random/chestclosed" volume: .5)
                    (hide-chest~ world)
                    (hide-bag~ world)
                    (set-opened-chest~ zone #f)))))))
        (when enemies
          (for-each (lambda (enemy)
                      (when (> (vertex-distance pos (get-position~ enemy)) (get-aggro-radius~ enemy))
                        (set-aggro-target~ enemy #f)
                        (set! enemies (remove enemy enemies test: equal?))))
                    enemies))
        (set-aggroed-enemies~ me enemies))))
  
  
  ;;;
  ;;;; Eat
  ;;;
  
  
  (method (eat-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (unless (get-paused?~ history)
              (with-task-mutex
                (lambda ()
                  (unless (stopping?~ task)
                    (tick-eat task exit)))))
            (task-sleep task eat-period 0. exit)
            (iter))))))
  
  
  (method (tick-eat task exit)
    (site (eat on?: #t)
      (let ((world (current-world))
            (me (current-me)))
        (let ((eating (get-eating~ me)))
          (when eating
            (let ((eating-ticks (get-eating-ticks~ me)))
              (set-life~ me (min (+ (get-life~ me) eating) 100.))
              (invalidate-view~ (child~ (get-interface~ world) 'combat))
              (let ((eating-ticks (- (get-eating-ticks~ me) 1)))
                (if (> eating-ticks 0)
                    (set-eating-ticks~ me eating-ticks)
                  (set-eating~ me #f)
                  (set-eating-ticks~ me #f)))))))))
  
  
  ;;;
  ;;;; Day
  ;;;
  
  
  (method (set-daytime time)
    (set! daytime time)
    (set! daylight (daytime->daylight time)))
  
  
  (method (daytime->daylight daytime)
    ;; night
    (cond ((< daytime 6000.)
           0.)
          ;; dawn
          ((< daytime 9000.)
           (/ (- daytime 6000.) 3000.))
          ;; day
          ((< daytime 18000.)
           1.)
          ;; dusk
          ((< daytime 21000.)
           (/ (- 21000. daytime) 3000.))
          ;; night
          (else
           0.)))
  
  
  ;;;
  ;;;; Lighting
  ;;;
  
  
  (method (effective-lights) <list>
    (let ((world (current-world)))
      (define (closest-lights)
        (let ((lights (collect-lights))
              (eye-position (get-position~ (get-eye~ world))))
          (sort < lights key: (lambda (light) (vertex-distance eye-position (get-position~ light))))))
      
      (if (get-lighting?~ world)
          (let ((lights (closest-lights)))
            (if (not-null? lights)
                lights
              '()))
        '())))
  
  
  (method (effective-player-glow)
    player-glow)
  
  
  (method (setup-lighting)
    (lighting-setup)
    (block-lighting-setup))
  
  
  (method (lighting-setup)
    (let ((world (current-world)))
      (let ((lights (effective-lights)))
        (let ((light (/ daylight 5.)))
          (set-ambient-color~ lighting (dye (+ (dye-red ambient-color) light)
                                            (+ (dye-green ambient-color) light)
                                            (+ (dye-blue ambient-color) light)
                                            1.0)))
        (set-lights~ lighting lights)
        (set-lights-count~ lighting (min (get-dynamic-lights~ world) (length lights)))
        (set-current-lighting lighting))))
  
  
  (method (block-lighting-setup)
    (let ((world (current-world)))
      (let ((lights '()))
        (set-ambient-color~ block-lighting ambient-color)
        (set-lights~ block-lighting lights)
        (set-lights-count~ block-lighting 0)
        (set-current-block-lighting block-lighting))))
  
  
  (method (iterate-lights proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Light)
          (proc gadget)))))
  
  
  (method (collect-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (enqueue queue light)))
      (queue-list queue)))
  
  
  (method (count-lights)
    (let ((count 0))
      (iterate-lights
        (lambda (light)
          (increase! count)))
      count))
  
  
  (method (invalidate-lightmaps element)
    )
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method public (iterate-gravities proc)
    (for-each proc gravities))
  
  
  (method public (iterate-planets proc)
    (iterate-gravities
      (lambda (well)
        (when (is? well Planet)
          (proc well)))))
  
  
  (method public (collect-planets)
    (let ((queue (new-queue)))
      (iterate-planets
        (lambda (planet)
          (enqueue queue planet)))
      (queue-list queue)))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method (reset-marks)
    (set! marks '()))
  
  
  (method (set-marks lst)
    (set! marks lst))
  
  
  (method (set-mark mark)
    (set! marks (list mark)))
  
  
  (method (add-mark mark)
    (set! marks (cons mark marks)))
  
  
  (method (remove-mark mark)
    (set! marks (remove! mark marks)))
  
  
  (method (draw-marks)
    (for-each (lambda (mark)
                (when (is-not? mark world.mark:Polygon-Mark)
                  (draw~ mark)))
              marks)
    (for-each (lambda (mark)
                (when (is? mark world.mark:Polygon-Mark)
                  (draw~ mark)))
              marks))
  
  
  (method (reset-all-marks)
    (let ((world (current-world)))
      (reset-marks)
      (display-message~ world "Marks reset")))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method virtual (zone-editable?)
    #t)
  
  
  (method virtual (zone-destructible?)
    #f)
  
  
  ;;;
  ;;;; Atlas
  ;;;
  
  
  (method (draw-atlas)
    @convert-effective-material
    (let ((world (current-world)))
      (unless texture-arrays?
        (let ((texture (get-texture~ (let ((elem (first-target~ world)))
                                       (if (is? elem Entity)
                                           (effective-material~ elem)
                                         (get-block-atlas~ world)))))
              (width 100.)
              (height 100.))
          (map-texture~ texture)
          (textured-quad~ texture
            (lambda () (glVertex3f 0.0 0.0 0.0))
            (lambda () (glVertex3f width 0.0 0.0))
            (lambda () (glVertex3f width height 0.0))
            (lambda () (glVertex3f 0.0 height 0.0)))))))
  
  
  ;;;
  ;;;; Heightmap
  ;;;
  
  
  (method (generate-heightmap-content sector <Sector> heightmap <f32vector> from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (decrease-sectors-generating 1))
    
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1)))
      (let ((count (f32vector-length heightmap)))
        (let ((vertices (make-vector count))
              (normals (make-vector count)))
          (define (get-vertex x <fx> z <fx>)
            (vector-ref vertices (+ (* x z-count) z)))
          (define (get-normal x <fx> z <fx>)
            (vector-ref normals (+ (* x z-count) z)))
          ;; fill vertices
          (loop (for x from 0 below x-count)
                (loop (for z from 0 below z-count)
                      (let ((index (+ (* x z-count) z)))
                        (let ((height (f32vector-ref heightmap index)))
                          (let ((x (cast <fl> (+ from-x x)))
                                (y (cast <fl> height))
                                (z (cast <fl> (+ from-z z))))
                            (vector-set! vertices index (vertex x y z))
                            (vector-set! normals index (vertex 0. 0. 0.)))))))
          ;; add triangles
          (let ((squares (make-vector (* width depth)))
                (sectors (make-table test: eq?))
                (areas (make-table test: eq?))
                (default-image (get-default-image~ world)))
            (let ((material (get-block-opaque~ world))
                  (uv (image-rect~ (get-block-atlas~ world) default-image)))
              (let ((tl (uv-left uv))
                    (tt (uv-top uv))
                    (tr (uv-right uv))
                    (tb (uv-bottom uv))
                    (texture-depth (uv-depth uv)))
                (define (safe-square x <fx> z <fx>)
                  (and
                    (>= x 0) (< x width)
                    (>= z 0) (< z depth)
                    (get-square x z)))
                (define (get-square x <fx> z <fx>)
                  (vector-ref squares (+ (* x depth) z)))
                (define (set-square x <fx> z <fx> square)
                  (vector-set! squares (+ (* x depth) z) square))
                (define (make-square t1 t2)
                  (cons t1 t2))
                (define (square-t1 square) <Smooth-Triangle>
                  (get-polygon~ (cast <Face> (car square))))
                (define (square-t2 square) <Smooth-Triangle>
                  (get-polygon~ (cast <Face> (cdr square))))
                (define (add-face face <Face>)
                  (let ((center (get-center~ (get-polygon~ face))))
                    (let ((sector (index-sector (position-sector-index center))))
                      (table-add sectors sector face))
                    (when (eq? what 'physical)
                      (let ((area (index-area (position-area-index center) #f)))
                        (table-add areas area (get-polygon~ face))))))
                (define (add-triangle v1 v2 v3)
                  (let ((normal (plane-normal v1 v2 v3)))
                    (let ((face
                            (if (> (vertex-x v1) (vertex-x v2))
                                (make-face material
                                           (f32vector tl tb tr tb tr tt)
                                           texture-depth
                                           (make-smooth-triangle self
                                                                 v1 v2 v3
                                                                 normal normal normal))
                              (make-face material
                                         (f32vector tr tt tl tt tl tb)
                                         texture-depth
                                         (make-smooth-triangle self
                                                               v1 v2 v3
                                                               normal normal normal)))))
                      (add-face face)
                      face)))
                ;; add triangles
                (loop (for x from 0 below width)
                      (loop (for z from 0 below depth)
                            (let ((v1 (get-vertex x (+ z 1)))
                                  (v2 (get-vertex (+ x 1) (+ z 1)))
                                  (v3 (get-vertex (+ x 1) z))
                                  (v4 (get-vertex x z)))
                              (let ((triangle1 (add-triangle v1 v2 v3))
                                    (triangle2 (add-triangle v3 v4 v1)))
                                (set-square x z (make-square triangle1 triangle2))))))
                ;; smooth normals
                (loop (for x from 0 below x-count)
                      (loop (for z from 0 below z-count)
                            (let ((normal (get-normal x z))
                                  (tl (safe-square (- x 1) (- z 1)))
                                  (tr (safe-square x (- z 1)))
                                  (bl (safe-square (- x 1) z))
                                  (br (safe-square x z)))
                              (when tl
                                (vertex-increase! normal (get-normal~ (square-t1 tl))))
                              (when tr
                                (vertex-increase! normal (get-normal~ (square-t1 tr)))
                                (vertex-increase! normal (get-normal~ (square-t2 tr))))
                              (when bl
                                (vertex-increase! normal (get-normal~ (square-t1 bl)))
                                (vertex-increase! normal (get-normal~ (square-t2 bl))))
                              (when br
                                (vertex-increase! normal (get-normal~ (square-t2 br))))
                              (vertex-normalize! normal normal))))
                ;; update normals
                (loop (for x from 0 below width)
                      (loop (for z from 0 below depth)
                            (let ((square (get-square x z)))
                              (set-n1~ (square-t1 square) (get-normal x (+ z 1)))
                              (set-n2~ (square-t1 square) (get-normal (+ x 1) (+ z 1)))
                              (set-n3~ (square-t1 square) (get-normal (+ x 1) z))
                              (set-n1~ (square-t2 square) (get-normal (+ x 1) z))
                              (set-n2~ (square-t2 square) (get-normal x z))
                              (set-n3~ (square-t2 square) (get-normal x (+ z 1))))))
                (case what
                  ((physical)
                   (when (eq? self (current-zone))
                     (iterate-table areas
                       (lambda (area <Area> polygons)
                         (add-polygons~ area #f polygons #f)))))
                  ((render)
                   (iterate-table sectors
                     (lambda (sector faces)
                       (receive (vertices neighbors) (prepare-vertices/neighbors~ sector faces)
                         (let ((lightmap (prepare-lightmap~ sector faces)))
                           (write-render-event
                             (lambda ()
                               (when (eq? self (current-zone))
                                 (free-mesh~ sector)
                                 (setup-mesh~ sector)
                                 (fill-vertices/neighbors~ sector (get-mesh~ sector) #f vertices neighbors)
                                 (set-vertices-uptodate?~ sector #t)
                                 (fill-lightmap~ sector (get-mesh~ sector) #f lightmap)
                                 (set-lightmap-uptodate?~ sector #t)
                                 (generate-done)))))))))))))))))
    
  
  ;;;
  ;;;; Level
  ;;;

  
  (method protected (get-level-file)
    (or level-file
        (let ((file (new-file~ level-dir "level.dat")))
          (set! level-file file)
          file)))
  
  
  (method public (get-level-nbt)
    (or level-nbt
        (let ((nbt (read/create-level)))
          (set! level-nbt nbt)
          nbt)))
  
  
  (method (read/create-level)
    (let ((file (get-level-file)))
      (if (exists?~ file)
          (read-level file)
        (create-level))))
  
  
  (method (read-level file)
    (with ((reader <NBT-Reader> (new NBT-Reader file compressed?: #t gzip?: #t)))
      (read-tag~ reader)))
  
  
  (method (create-level)
    (make-tag "" TAG_Compound
      (list
        (make-tag "Data" TAG_Compound
          (list
            (make-tag "Player" TAG_Compound
              (list
                (make-tag "Inventory" TAG_List (make-list-payload TAG_Compound '()))))
            (make-tag "SpawnX" TAG_Int 0)
            (make-tag "SpawnY" TAG_Int 0)
            (make-tag "SpawnZ" TAG_Int 0)
            (make-tag "LevelName" TAG_String "New")
            (make-tag "version" TAG_Int 19133))))))
  
  
  (method public (save-level-nbt)
    (save-level (get-level-nbt) (get-level-file)))
  
  
  (method (save-level level file)
    (create-directories~ file)
    (with ((writer (new NBT-Writer file compressed?: #t gzip?: #t)))
      (write-tag~ writer level)))
  
  
  (method (find-spawnpoint)
    (or (get-player-spawnpoint)
        (get-spawnpoint)))
  
  
  (method (get-spawnpoint)
    (let ((tag (get-level-nbt)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-assoc "SpawnX" compound))
              (y (tag-assoc "SpawnY" compound))
              (z (tag-assoc "SpawnZ" compound)))
          (vertex (cast <fl> x) (cast <fl> (- y 63)) (cast <fl> z))))))
  
  
  (method (set-spawnpoint pos)
    (let ((tag (get-level-nbt)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-find "SpawnX" compound))
              (y (tag-find "SpawnY" compound))
              (z (tag-find "SpawnZ" compound)))
          (tag-set x (fxround (vertex-x pos)))
          (tag-set y (+ (fxround (vertex-y pos)) 63))
          (tag-set z (fxround (vertex-z pos)))))))
  
  
  (method (get-player-spawnpoint)
    (let ((tag (get-level-nbt)))
      (let ((player (tag-assoc "Player" (tag-assoc "Data" (tag-value tag)))))
        (let ((x (tag-assoc "SpawnX" player))
              (y (tag-assoc "SpawnY" player))
              (z (tag-assoc "SpawnZ" player)))
          (and x y z (vertex (cast <fl> x) (cast <fl> (- y 63)) (cast <fl> z)))))))
  
  
  (method (set-player-spawnpoint pos)
    (let ((tag (get-level-nbt)))
      (let ((player (tag-find "Player" (tag-assoc "Data" (tag-value tag)))))
        (tag-add player "SpawnX" TAG_Int (fxround (vertex-x pos)))
        (tag-add player "SpawnY" TAG_Int (+ (fxround (vertex-y pos)) 63))
        (tag-add player "SpawnZ" TAG_Int (fxround (vertex-z pos))))))
  
  
  (method (teleport pos (sight #f))
    (let ((world (current-world))
          (me (current-me)))
      (let ((eye (get-eye~ world)))
        (person-motion~ world feedback?: #f)
        (set-position~ me pos)
        (cond ((not sight)
               (derive-target~ eye)
               (camera-update~ eye))
              (else
               (set-lookat~ me (horizon-lookat sight))
               (eye-behind-player~ world)
               (follow-player~ world))))))
  
  
  (method (explode-blocks tnts blocks)
    (play-sound-file "sound/random/explode" volume: .25)
    (updating-sectors
      (lambda (add-sector)
        (for-each (lambda (tnt)
                    (remove-block! tnt add-sector))
                  tnts)
        (for-each (lambda (block)
                    (remove-block! block add-sector)) blocks))
      delay-update?: #t))
  
  
  (method (reveal-chests command-block blocks)
    (updating-sectors
      (lambda (add-sector)
        (loop (for x from 0 below (fxceiling (/ (length blocks) 6.)))
              (let ((pos (random-element blocks)))
                (set! blocks (remove pos blocks test: equal?))
                (place-block! pos RedstoneTorchOn add-sector)))
        (remove-block (car command-block) add-sector))))
  
  
  (method (testfor-action command-block test action)
    (call-with-position (car test)
      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (when (= block-id (cdr test))
          (updating-sectors
            (lambda (add-sector)
              (case (cdr action)
                ((remove) (remove-block (car action) add-sector))
                ((delete) (remove-block! (car action) add-sector))
                ((add)    (place-block! (caar action) (cdar action) add-sector)))
              (remove-block (car command-block) add-sector)))))))
  
  
  (method (remove-block pos add-sector)
    (call-with-position pos
      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (with-field i j k
          (lambda (section index)
            (add-sector (get-sector~ section))
            (block-set! section index 0)
            (data-set! section index 0))))))
  
  
  (method (remove-block! pos add-sector)
    (call-with-position pos
      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (delete-block~ (current-game) region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (place-block! pos block add-sector)
    (call-with-position pos
      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (add-block~ (current-game) #f block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (on-toggle-glow evt)
    (if (= player-glow -1.)
        (set! player-glow 300.)
      (set! player-glow -1.)))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (call-with-position pos <f64vector> proc)
    (let ((sector (position-sector pos))
          (x (fxfloor (vertex-x pos)))
          (y (fxfloor (vertex-y pos)))
          (z (fxfloor (vertex-z pos))))
      (let ((sector-index (get-index~ sector)))
        (let ((sector-x <fx> (vector-ref sector-index 0))
              (sector-y <fx> (vector-ref sector-index 1))
              (sector-z <fx> (vector-ref sector-index 2)))
          (let ((i (- x (* sector-x 16)))
                (j (- y (* sector-y 16)))
                (k (- z (* sector-z 16))))
            (call-with-sector sector i j k proc))))))
  
  
  (method (call-with-sector sector i j k proc)
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region sector-x sector-y sector-z create?: #t)))
          (let ((region-x (get-x~ region))
                (region-z (get-z~ region))
                (section (get-section~ region 'physical sector-x sector-y sector-z create?: #t))
                (chunk-index (chunk-index~ region sector-x sector-z)))
            (when section
              (let ((bottom-section? (= sector-y (cast <fx> (or truncate-y -4))))
                    (section-x (+ (* region-x 32 16) (* (cast <fx> (car chunk-index)) 16)))
                    (section-y (* sector-y 16))
                    (section-z (+ (* region-z 32 16) (* (cast <fx> (cdr chunk-index)) 16)))
                    (sections <vector> (make-vector 27 #t))
                    (blocks (get-blocks~ section))
                    (data (get-data~ section))
                    (blocklight (get-blocklight~ section))
                    (skylight (get-skylight~ section)))
                (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                  (if (and (= a 0)
                           (= b 0)
                           (= c 0))
                      section
                    ;; quick hack for test
                    (if (or (< a -1)
                            (< b -1)
                            (< c -1)
                            (> a 1)
                            (> b 1)
                            (> c 1))
                        (let ((x (+ sector-x a))
                              (y (+ sector-y b))
                              (z (+ sector-z c)))
                          (let ((region (sector-region x y z)))
                            (get-section~ (cast <World-Region> region) 'physical x y z)))
                      (let ((index (section-index a b c)))
                        (let ((section (vector-ref sections index)))
                          (if (neq? section #t)
                              section
                            (let ((x (+ sector-x a))
                                  (y (+ sector-y b))
                                  (z (+ sector-z c)))
                              (let ((region (sector-region x y z)))
                                (let ((section (and region (get-section~ (cast <World-Region> region) 'physical x y z))))
                                  (vector-set! sections index section)
                                  section)))))))))
                
                (define (section-index a <fx> b <fx> c <fx>) <fx>
                  (+ (* b 9) (* c 3) a 13))
                
                (define (local-index i <fx> j <fx> k <fx>) <fx>
                  (+ (* j 256) (* k 16) i))
                
                (define (block-ref section local-index <fx>) <fx>
                  (u8vector-ref (get-blocks~ section) local-index))
                
                (define (block-set! section local-index <fx> block-id <fx>)
                  (u8vector-set! (get-blocks~ section) local-index block-id))
                
                (define (data-ref section local-index <fx>) <fx>
                  (u4vector-ref (get-data~ section) local-index))
                
                (define (data-set! section local-index <fx> data-id <fx>)
                  (u4vector-set! (get-data~ section) local-index data-id))
                
                (define (blocklight-ref section local-index <fx>) <fx>
                  (u4vector-ref (get-blocklight~ section) local-index))
                
                (define (blocklight-set! section local-index <fx> blocklight <fx>)
                  (u4vector-set! (get-blocklight~ section) local-index blocklight))
                
                (define (skylight-ref section local-index <fx>) <fx>
                  (u4vector-ref (get-skylight~ section) local-index))
                
                (define (skylight-set! section local-index <fx> skylight <fx>)
                  (u4vector-set! (get-skylight~ section) local-index skylight))
                
                (define (u4vector-ref field <u8vector> index <fx>) <fx>
                  (let ((byte (u8vector-ref field (quotient index 2))))
                    (if (even? index)
                        (bitwise-and byte #x0F)
                      (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                
                (define (u4vector-set! field <u8vector> index <fx> value <fx>)
                  (let ((offset (quotient index 2)))
                    (let ((byte (u8vector-ref field offset)))
                      (u8vector-set! field offset
                        (if (even? index)
                            (bitwise-ior value (bitwise-and byte #xF0))
                          (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4)))))))
                
                (define (with-field i <fx> j <fx> k <fx> proc)
                  (define (bind-i a <fx> i <fx>)
                    (define (bind-j b <fx> j <fx>)
                      (define (bind-k c <fx> k <fx>)
                        (let ((section (section-ref a b c)))
                          (proc section (local-index i j k))))
                      
                      (cond ((< k 0) (bind-k (- (quotient k 16) 1) (modulo k 16)))
                            ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                            (else (bind-k 0 k))))
                    
                    (cond ((< j 0) (bind-j (- (quotient j 16) 1) (modulo j 16)))
                          ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                          (else (bind-j 0 j))))
                  
                  @debug-infinite-loop
                  (continuation-capture
                    (lambda (cont)
                      (let ((max 1000))
                        (when (>= (length (get-continuation-stack cont (+ max 10))) max)
                          (break)))))
                  (cond ((< i 0) (bind-i (- (quotient i 16) 1) (modulo i 16)))
                        ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                        (else (bind-i 0 i))))
                
                ;; debugging
                (assert (and (between? i 0 15)
                             (between? j 0 15)
                             (between? k 0 15)))
                (let ((index (local-index i j k)))
                  (let ((block-id (block-ref section index))
                        (data-id (data-ref section index)))
                    (let ((x (+ section-x i))
                          (y (+ section-y j))
                          (z (+ section-z k))
                          (block (blockid->block block-id)))
                      (let ((x (fl& (+ block-radius (cast <fl> x))))
                            (y (fl& (+ block-radius (cast <fl> y))))
                            (z (fl& (+ block-radius (cast <fl> z))))
                            (uv (block-texture-coordinates block))
                            (rendering (cache-rendering~ block))
                            (generate (get-generate~ block)))
                        (proc region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))))))))))
  
  
  (method (updating-sectors proc (delay-update?: delay-update? #f))
    (define (update-sectors sectors)
      (for-each (lambda (sector)
                  (iterate-sector-areas sector
                    (lambda (area)
                      (remove-polygons~ area #f)
                      @replaced-by-above-for-now-to-not-clear-elements-polygons
                      (clear-polygons~ area)))
                  (set-physical-uptodate?~ sector #f)
                  ;; no need to generate the physical explicitly
                  ;; (generate-sector sector 'physical)
                  (let ((eye-sector (find-eye-sector (get-index~ sector))))
                    (when eye-sector
                      (set-content-uptodate?~ eye-sector #f)
                      (unless (and delay-update? delay-updating?)
                        (set-generating?~ sector #t)
                        (increase-sectors-generating 1)
                        (generate-sector eye-sector 'visual))))
                  ;; this test should not be necessary
                  (let ((section (get-section~ sector)))
                    (when section
                      (modified~ (get-chunk~ section)))))
                sectors))
    
    (define (save-regions)
      (with-regions-mutex
        (lambda ()
          (iterate-table regions
            (lambda (index region)
              (when region
                (save-region~ region)))))))
    
    (let ((sectors '()))
      (define (add-sector sector)
        (unless (memq? sector sectors)
          (set! sectors (cons sector sectors))))
      
      (let ((timer (new Timer)))
        (with-generate-mutex
          (lambda ()
            (proc add-sector)
            (update-sectors sectors)
            (save-regions)))
        (when report-updating?
          (let ((world (current-world)))
            (let ((count (length sectors))
                  (duration (real-duration-in-milliseconds~ timer)))
              (display-message~ world (format "Updated {a} sector{a} ({a}ms)" count (format-plural count) duration))))))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method (evaluate-hook forms syntax str container line col)
    (let ((ids (collect (lambda (form)
                          (when (and (pair? form) (eq? (car form) 'define-block))
                            (third form)))
                        forms)))
      (cond ((not-null? ids)
             (updating-sectors
               (lambda (add-sector)
                 (finding-visual-blocks ids
                   add-sector)
                 (finding-physical-blocks ids
                   (lambda (area)
                     (add-sector (area-sector area)))))))
            ((search container "world/external/minecraft")
             (updating-sectors
               (lambda (add-sector)
                 (add-sector (element-sector (current-me)))))))))
  
  
  ;;;
  ;;;; Model
  ;;;
  
  
  (method (minecraft-blocks)
    blocks)
  
  
  (method (minecraft-blockids)
    blockids)
  
  
  (method (minecraft-block-class)
    Minecraft-Block)
  
  
  (method (minecraft-find-model name)
    (find-minecraft-model name))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  (method (find-visual-blocks ids)
    (let ((zone (current-zone))
          (queue (new-queue)))
      (iterate-sectors~ zone
        (lambda (index sector)
          (sector-iterate-blocks sector ids
            (lambda (found)
              (enqueue queue (cons sector (index->coordinates found)))))))
      (queue-list queue)))
  
  
  (method (finding-visual-blocks ids proc)
    (let ((zone (current-zone)))
      (iterate-sectors~ zone
        (lambda (index sector)
          (when (sector-contains-blocks? sector ids)
            (proc sector))))))
  
  
  (method (sector-contains-blocks? sector ids)
    (continuation-capture
      (lambda (found)
        (sector-iterate-blocks sector ids
          (lambda (ignore)
            (continuation-return found #t)))
        #f)))
  
  
  (method (sector-iterate-blocks sector ids proc)
    (let ((sector-index (get-index~ sector)))
      (let ((sector-x <fx> (vector-ref sector-index 0))
            (sector-y <fx> (vector-ref sector-index 1))
            (sector-z <fx> (vector-ref sector-index 2)))
        (let ((region (sector-region sector-x sector-y sector-z)))
          (when region
            (let ((section (get-section~ region 'physical sector-x sector-y sector-z)))
              (when section
                (let ((blocks (get-blocks~ section)))
                  (for-each (lambda (id)
                              (let (iter (pos 0))
                                (let ((found (u8vector-find id blocks (u8vector-length blocks) pos)))
                                  (when found
                                    (proc found)
                                    (iter (+ found 1))))))
                            ids)))))))))
  
  
  (method (finding-physical-blocks ids proc)
    (let ((zone (current-zone)))
      (iterate-areas~ zone
        (lambda (index area)
          (iterate-polygons~ area
            (lambda (elem polygons offset)
              (let ((data1 (f64vector-ref polygons (+ offset 16))))
                (when (and (/= data1 0.) (memq? (fxround data1) ids))
                  (proc area))))))))))


;;;
;;;; Procedural Zones
;;;


(proclaim (warn optimizations))


;; Ideally, this would use a PRNG which we can seed with a given value.
;; That way the map can be persisted using just the seed and a list of changes.
;; Also I have no clue how this will react in multiplayer.
(class Procedural-Zone extends Zone
  
  
  (property detail-level <fl>               initialize 15. accessors generate)
  (property clamp-height <fl>               initialize 65. accessors generate)
  (property seed         <object>           initialize #f  accessors generate)
  (property generator    <Perlin-Generator> initialize #f  accessors generate)
  
  
  (method override (setup-component)
    (nextmethod)
    (random-seed seed)
    (set! generator (new Perlin-Generator detail-level clamp-height)))
  
  
  (method override (zone-editable?)
    (world-setting 'world.procedural-editable? #f))
  
  
  (method override (zone-destructible?)
    (zone-editable?))
  
  
  (method override (generate-visual sector <Sector>)
    (let ((index (get-index~ sector)))
      (let ((x <fx> (vector-ref index 0))
            (y <fx> (vector-ref index 1))
            (z <fx> (vector-ref index 2)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural sector from-x width from-z depth 'visual)))))
    (set-content-revision~ sector (get-current-content-revision))
    (set-content-uptodate?~ sector #t)
    (decrease-sectors-generating 1))
  
  
  (method override (generate-physical sector <Sector>)
    (let ((index (get-index~ sector)))
      (let ((x <fx> (vector-ref index 0))
            (y <fx> (vector-ref index 1))
            (z <fx> (vector-ref index 2)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural sector from-x width from-z depth 'physical))))))
  
  
  (method (generate-procedural sector <Sector> from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1)))
      (define (generate-heightmap)
        (let ((heightmap <f32vector> (make-f32vector (* x-count z-count))))
          (loop (for x from 0 below x-count)
                (loop (for z from 0 below z-count)
                      (f32vector-set! heightmap (+ (* x z-count) z)
                        ;; max and min are quick hacks until perlin generator is fixed
                        (max 0. (min 10. (/ (get-value~ generator (cast <fl> (+ from-x x)) (cast <fl> (+ from-z z))) 5.))))))
          heightmap))
      
      (generate-heightmap-content sector (generate-heightmap) from-x width from-z depth what)))))
