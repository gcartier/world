;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Zones
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.zone jazz


(import (jazz.associative)
        (jazz.component)
        (jazz.io)
        (jazz.geometry)
        (jazz.markup)
        (jazz.opengl.glew)
        (jazz.snapshot)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.actor)
        (world.album)
        (world.area)
        (world.assets)
        (world.atlas)
        (world.autoload)
        (world.block)
        (world.buffer)
        (world.camera)
        (world.chunk)
        (world.client.tier)
        (world.configure)
        (world.context)
        (world.coverage)
        (world.creature)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.entity)
        (world.entities)
        (world.expanse)
        (world.face)
        (world.foreign)
        (world.gadget)
        (world.generation)
        (world.generation.base)
        (world.generation.block)
        (world.generation.building)
        (world.generation.redstone)
        (world.generation.rendering)
        (world.geometry)
        (world.gravity)
        (world.grid)
        (world.history)
        (world.homogeneous)
        (world.index)
        (world.info)
        (world.instantiate)
        (world.interface.bars)
        (world.interface.documents)
        (world.interface.inventory)
        (world.io)
        (world.lava)
        (world.light)
        (world.lighting)
        (world.mesh)
        (world.motion)
        (world.music)
        (world.network)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.profiling)
        (world.random)
        (world.redstone)
        (world.region)
        (world.render)
        (world.renderer)
        (world.scene)
        (world.scripter)
        (world.section)
        (world.sector)
        (world.settings)
        (world.skybox)
        (world.sound)
        (world.space)
        (world.spawn)
        (world.sun)
        (world.support)
        (world.syntax (phase syntax))
        (world.tag)
        (world.task)
        (world.texture)
        (world.tier)
        (world.triangle)
        (world.water)
        (world.work))


(proclaim (not check bounds))


;;;
;;;; Zone
;;;


(definition protected day-span <fl>
  24000.)

(definition protected dawn-daytime <fl>
  6000.)

(definition protected day-daytime <fl>
  12000.)

(definition protected dusk-daytime <fl>
  18000.)

(definition protected night-daytime <fl>
  0.)


(definition protected default-day-duration <fl>
  1200.)


(definition delay-updating? <bool>
  (world-setting 'world.delay-updating? #t))

(definition report-updating? <bool>
  (world-setting 'world.report-updating? #f))


(definition show-sections? <bool>
  (world-setting 'world.show-sections? #f))

(definition show-chunks? <bool>
  (world-setting 'world.show-chunks? #f))


(class Zone extends Scene
  
  
  (property title                   <string+>    initialize #f              accessors generate)
  (property start-mode              <symbol>     initialize #f              accessors generate)
  (property start-distance          <fl+>        initialize #f              accessors generate)
  (property start-spawnpoint        <vertex+>    initialize #f              accessors generate)
  ;; change default from #f to 0 for now and when we start using full 3d regions
  ;; put it back to #f and make it so minecraft zones have truncate-y = 0 by default
  (property truncate-y              <fx+>        initialize 0               accessors generate)
  (property missile-behavior        <symbol>     initialize 'destroy        accessors generate)
  (property ambient-color           <f32vector+> initialize #f              accessors generate)
  (property sun-color               <f32vector+> initialize #f              accessors generate)
  (property sun?                    <bool>       initialize #t              accessors generate)
  (property day-duration            <object>     initialize default-day-duration accessors generate)
  (property start-time              <object>     initialize #f              accessors generate)
  (property start-skybox            <object>     initialize #f              accessors generate)
  (property atlas-name              <object>     initialize #f              accessors generate)
  (property prepare-script          <object>     initialize "zone/prepare"  accessors generate)
  (property enter-script            <object>     initialize "zone/enter"    accessors generate)
  (property exit-script             <object>     initialize "zone/exit"     accessors generate)
  (property draw-grid?              <bool>       initialize #t              accessors generate)
  (property first-time?             <bool>       initialize #t              accessors generate)
  (property level-dir               <Directory>  initialize #f              accessors generate)
  (property level-dimension         <symbol>     initialize 'over           accessors generate)
  (property player-glow             <fl>         initialize -1.             accessors generate)
  (property vista-target            <object>     initialize #f              accessors generate)
  (property vista-radius            <object>     initialize #f              accessors generate)
  (property vista-elevation         <object>     initialize #f              accessors generate)
  (property seed                    <object>     initialize #f              accessors generate)
  (property properties              <object>     initialize '()             accessors generate)
  
  ;; world override properties
  (property ambient-gravity         <object>     initialize default-gravity accessors generate)
  (property jump-impulsion          <object>     initialize default-jump    accessors generate)
  (property start-grid?             <object>     initialize #f              accessors generate)
  (property start-grid-position     <object>     initialize 0.              accessors generate)
  (property start-axes?             <object>     initialize #f              accessors generate)


  (slot path                        <object>     initialize #f                        accessors generate)
  (slot dimension                   <object>     initialize #f                        getter generate)
  (slot debug-sections?             <bool>       initialize #f                        accessors generate)
  (slot sector-size                 <fx>         initialize 16                        getter generate)
  (slot sector-radius               <fl>         initialize #f                        getter generate)
  (slot sector-diameter             <fl>         initialize #f                        getter generate)
  (slot sector/area-ratio           <fx>         initialize #f                        getter generate)
  (slot sectors-generating          <fx>         initialize 0                         getter generate)
  (slot sectors-generated           <fx>         initialize 0                         getter generate)
  (slot sectors-mutex               <object>     initialize #f                        getter generate)
  (slot debug-sectors?              <bool>       initialize #f                        accessors generate)
  (slot areas                       <table>      initialize #f                        getter generate)
  (slot area-size                   <fx>         initialize 2                         getter generate)
  (slot debug-areas?                <bool>       initialize #f                        accessors generate)
  (slot expanses                    <table>      initialize #f                        getter generate)
  (slot assets                      <object>     initialize '()                       getter generate)
  (slot players                     <list>       initialize '()                       getter generate)
  (slot actors                      <list>       initialize '()                       getter generate)
  (slot entities                    <list>       initialize '()                       getter generate)
  (slot gravities                   <list>       initialize '()                       getter generate)
  (slot gadgets                     <list>       initialize '()                       getter generate)
  (slot marks                       <list>       initialize '()                       getter generate)
  (slot simulations                 <table>      initialize (make-table test: eq?)    getter generate)
  (slot game                        <object>     initialize #f                        getter generate)
  (slot generator                   <Generator+> initialize #f                        accessors generate)
  (slot draw-procedures             <object>     initialize '()                       getter generate)
  (slot draw-procedure-names        <object>     initialize #f                        getter generate)
  (slot destroy-hooks               <list>       initialize '()                       getter generate)
  (slot ready?                      <bool>       initialize #f                        accessors generate)
  (slot editable?                   <bool>       initialize #t                        accessors generate)
  (slot editable-warned?            <bool>       initialize #f                        accessors generate)
  (slot generate-thread             <object>     initialize #f                        accessors generate)
  (slot lighting                    <Lighting>   initialize (new Lighting)            accessors generate)
  (slot daytime                     <fl>         initialize 0.                        getter generate)
  (slot daylight                    <fl>         initialize 0.                        accessors generate)
  (slot sun                         <Sun+>       initialize #f                        accessors generate)
  (slot sun-angle                   <fl>         initialize -.20                      accessors generate)
  (slot skybox                      <Skybox+>    initialize #f                        accessors generate)
  (slot designer                    <object>     initialize #f                        accessors generate)
  (slot level-file                               initialize #f)
  (slot level-state                              initialize #f)
  (slot opened-chest                             initialize #f                        accessors generate)
  (slot inventory-blocks                         initialize (make-vector 63 #f)       getter generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition default-ambient-color
    (dye .1 .05 0. 1.))
  
  
  (method package virtual (login? self)
    #f)
  
  
  (method package virtual (void? self)
    #f)
  
  
  ;; quicky for tests
  (method package virtual (planets? self)
    #f)
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set-current-zone self))
  
  
  (method override (finish self rest)
    (define (effective-ambient-color)
      (let ((ambient-color (world-setting 'world.ambient-color 'default)))
        (cond ((not ambient-color)
               (dye 0. 0. 0. 1.0))
              ((eq? ambient-color 'default)
               default-ambient-color)
              (else
               ambient-color))))
    
    (nextmethod self rest)
    (load-point 'zone-prepare)
    (when (window?)
      (prepare-blocks self)
      (load-point 'zone-blocks))
    (when (window?)
      (prepare-draw)
      (load-point 'zone-draw))
    (setup-me (current-tier))
    (set! ambient-color (or ambient-color (effective-ambient-color)))
    (set! sun-color (or sun-color (world-setting 'world.sun-color #f) (dye 1.0 1.0 1.0 1.0)))
    (set! sun? (and sun? (world-setting 'world.sun? #t)))
    (set! start-time (or start-time (world-setting 'world.start-time 'dawn)))
    (set! day-duration (world-setting 'world.day-duration default-day-duration))
    (set! draw-procedure-names (make-table test: eq?))
    (set! debug-sections? (or show-sections? show-chunks? (world-setting 'world.debug-sections? #f)))
    (when (window?)
      (registered-task 'generate generate-task)
      @generate-tasks
      (begin
        (registered-task 'generate2 generate-task2)
        (registered-task 'generate3 generate-task3)
        (registered-task 'generate4 generate-task4)
        (registered-task 'generate5 generate-task5))
      (registered-task 'free free-task)
      (registered-task 'instantiate instantiate-task)
      (registered-task 'render (~ render-task self)))
    (when (client?)
      (registered-task 'player (~ player-task self)))
    (registered-task 'tick (~ tick-task self))
    (registered-task 'redstone redstone-task)
    (registered-task 'gravity (~ gravity-task self))
    (registered-task 'lava lava-task)
    (registered-task 'water water-task)
    (when (client?)
      (registered-task 'distance (~ distance-task self))
      (registered-task 'eat (~ eat-task self)))
    (registered-task 'sun (~ sun-task self))
    @YOWNU
    (begin
    (registered-task 'spawn spawn-task)
    (registered-task 'missile (~ missile-task self))
    (when (window?)
      (registered-task 'sound sound-task)
      (registered-task 'music music-task)))
    (when (processor?)
      (registered-task 'processor processor-task))
    (when (client?)
      (registered-task 'client client-task)
      (registered-task 'alive alive-task))
    (load-point 'zone-tasks)
    (when (window?)
      (register-entity-classes)
      (prepare-skybox-program)
      (prepare-skybox self)
      (load-point 'zone-skybox))
    (initialize-spawned)
    (load-point 'zone-created)
    (set-daytime self (effective-daytime self start-time))
    (set! sun-angle (daytime->sun-angle self daytime))
    (load-point 'zone-sun))
  
  
  (method package (initialize-zone self)
    (setup-persistence self)
    (setup-seed self)
    (setup-generator self)
    (setup-dimension self)
    (setup-sectors self)
    (setup-areas self)
    (setup-expanses self)
    (setup-overrides self)
    (setup-universe self)
    (setup-space self)
    (setup-player self)
    (setup-children self)
    (setup-game self)
    (enter-tier self)
    (zone-change (current-space) self)
    (when (window?)
      (start-music self)
      (start-ambience self)
      (install-interface self)
      (display-welcome self)))
  
  
  (method (setup-persistence self)
    (when (not level-dir)
      (set! level-dir (new-directory (get-directory self) "level"))))
  
  
  (method (setup-seed self)
    (if seed
        (init-seed seed)
      (let ((seed (world-setting 'world.seed (random-monotonic))))
        (set-property designer self 'seed seed)
        (init-seed seed))))
  
  
  (method protected virtual (setup-generator self)
    (let ((file (new-file (get-directory self) ".generator")))
      (set! generator (if (exists? file)
                          (instantiate (read-form file))
                        (new Empty-Generator)))))
  
  
  (method (setup-overrides self)
    (let ((world (current-world)))
      (when (specified? ambient-gravity)
        (set-ambient-gravity world ambient-gravity))
      (when (specified? jump-impulsion)
        (set-jump-impulsion world jump-impulsion))
      (set-grid? world start-grid?)
      (set-grid-position world start-grid-position)
      (set-axes? world start-axes?)))
  
  
  (method protected virtual (setup-universe self)
    (set-current-universe (new Universe)))
  
  
  (method protected virtual (setup-space self)
    (unless (current-space+)
      (set-current-space (new Space))
      (clear-snapshot-property 'live.space)))
  
  
  (method protected virtual (setup-player self)
    (let ((me (current-me+)))
      (when me
        (add-element self me))))
  
  
  ;; backward compatibility
  (method protected virtual (setup-children self)
    (let ((touched? #f))
      (for-each (lambda (obj)
                  (when (is? obj Element)
                    (add-element self obj)
                    (when (component-in-descendants? designer obj)
                      (with-designer self obj
                        (lambda (des container)
                          (remove-child designer obj)
                          (set-parent obj container)
                          (add-child des obj container form: (get-form obj))
                          (set! touched? #t))))))
                children)
      (when touched?
        (save designer))))
  
  
  (method (setup-game self)
    (when (client?)
      (let ((file (new-file (get-directory self) ".game")))
        (set! game (if (exists? file)
                       (instantiate (read-form file))
                     (let ((units '(world.game)))
                       (let ((tag '(<World-Game>))
                             (data (new Data zone-version 'jazz units #f)))
                         (let ((form (construct-form tag (imports-locator units) data)))
                           (set-origin form file)
                           (instantiate form)))))))))
  
  
  (method protected virtual (camera-update self)
    )
  
  
  (method protected virtual (title-update self)
    @YOWNU
    (when (window?)
      (let ((window (current-window)))
        (set-caption window title))))
  
  
  (method protected virtual (enter-tier self)
    (enter (current-tier)))
  
  
  (method protected virtual (start-music self)
    (let ((music (current-music)))
      (initial-music music)))
  
  
  (method protected virtual (start-ambience self)
    (let ((ambience (current-ambience)))
      (initial-ambience ambience)))
  
  
  (method protected virtual (stop-music self)
    (let ((music (current-music)))
      (close-music music)))
  
  
  (method protected virtual (stop-ambience self)
    (let ((ambience (current-ambience)))
      (close-ambience ambience)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method package virtual (populate-zone self)
    )
  
  
  (method package virtual (generate-visual self sector)
    (site (visual)
      (if show-blocking?
          (parameterize ((non-blocking? #t))
            (instantiate-visual sector))
        (instantiate-visual sector))))
  
  
  @generate-tasks
  (method (generate-visual2 sector)
    (site (visual2)
      (instantiate-visual sector)))
  
  
  @generate-tasks
  (method (generate-visual3 sector)
    (site (visual3)
      (instantiate-visual sector)))
  
  
  @generate-tasks
  (method (generate-visual4 sector)
    (site (visual4)
      (instantiate-visual sector)))
  
  
  @generate-tasks
  (method (generate-visual5 sector)
    (site (visual5)
      (instantiate-visual sector)))
  
  
  (method package virtual (generate-physical self area revision-update?)
    (site (physical)
      (instantiate-physical area revision-update?)))
  
  
  (method package virtual (zone-ready self)
    )
  
  
  (method (get-zone-directory self)
    (let ((moniker (get-moniker self)))
      (and moniker
           (get-parent moniker))))
  
  
  (method package (zone-path self kind)
    (let ((directory (get-tiers-directory kind))
          (moniker (get-moniker self)))
      (subpath directory (get-parent moniker))))
  
  
  (method (zone-brother self path)
    (new-file (get-zone-directory self) path))
  
  
  (method protected virtual (about-size self)
    {Dimension 715 487})

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (register-destroy-hook self proc)
    (set! destroy-hooks (cons proc destroy-hooks)))
  
  
  (method (unregister-destroy-hook self proc)
    (set! destroy-hooks (remove! proc destroy-hooks)))
  
  
  (method override (add-child self child)
    (set! children (cons child children)))
  
  
  (method override (destroy-component self)
    (destroy self))
  
  
  (method override (destroy self)
    (let ((world (current-world)))
      (shutting-down
        (lambda ()
          (launch-event world exit-script)
          @too-brittle ;; for example putting a crash-process in server retrieve chunk
          (when (window?)
            (unpause-world world))
          (shutdown-selection world)
          (when (window?)
            (uninstall-interface self))
          (stop-tasks self)
          (save-zone self)
          (save-designer self)
          (save-game self)
          (for-each (lambda (proc)
                      (proc))
                    destroy-hooks)
          (free-generator self)
          (free-eye-sectors self)
          (free-dimension self)
          (when (window?)
            (stop-music self)
            (stop-ambience self))))))
  
  
  (method package virtual (save-zone self)
    (let ((tier (current-tier))
          (world (current-world))
          (motion (current-motion)))
      (define (save)
        (set-property designer self 'first-time? #f))
      
      (define (save-mode)
        (set-property designer self 'start-mode (if (person-motion?) 'first-person 'free-camera)))
      
      (define (save-distance)
        (when (is? motion Target-Motion)
          (set-property designer self 'start-distance (get-desired-distance motion))))
      
      (save)
      ;; until these properties are in the player at
      ;; least don't save them when no actual player
      (when (current-me+)
        (save-mode)
        (save-distance))
      (save-me tier)
      (when (window?)
        (save-chest save-region?: #t)
        (save-inventory))
      (save-level-state self)))
  
  
  (method package (save-designer self)
    (save designer))
  
  
  (method (save-game self)
    (when (client?)
      (let ((form (get-form game)))
        (let ((file (get-origin form)))
          (create-directories file)
          (let ((designer (new Former form: form reference: game)))
            (set-property designer game 'first-time? #f)
            (save designer))))))
  
  
  (method package (install-interface self)
    (let ((world (current-world))
          (interface (current-interface)))
      (view-inventory (child interface 'belt))
      (reset-cache (child interface 'map))))
  
  
  (method package (uninstall-interface self)
    )
  
  
  (method (display-welcome self)
    @YOWNU
    (when (and (client?) (show-chat? self))
      (let ((tier (current-client))
            (interface (current-interface)))
        (unless (get-welcomed? tier)
          (let ((welcome (get-welcome tier)))
            (when welcome
              (let ((chat (child interface 'chat)))
                (show-welcome chat welcome))))
          (set-welcomed? tier #t)))))
  
  
  (method protected virtual (show-belt? self)
    #f
    @YOWNU
    (let ((world (current-world)))
      (get-show-belt? world)))
  
  
  (method protected virtual (show-compass? self)
    #t)
  
  
  (method protected virtual (show-combat? self)
    #t)
  
  
  (method protected virtual (show-chat? self)
    #t)
  
  
  ;;;
  ;;;; Tasks
  ;;;
  
  
  (method package (start-tasks self)
    (when (window?)
      (start-task 'generate)
      @generate-tasks
      (begin
        (start-task 'generate2)
        (start-task 'generate3)
        (start-task 'generate4)
        (start-task 'generate5))
      (start-task 'free)
      (start-task 'instantiate)
      (start-task 'render))
    (when (client?)
      (start-task 'player))
    (start-task 'tick)
    (start-task 'redstone)
    (start-task 'gravity)
    (start-task 'lava)
    (start-task 'water)
    (when (client?)
      (start-task 'distance)
      (start-task 'eat))
    (start-task 'sun)
    @YOWNU
    (begin
    (start-task 'spawn)
    (start-task 'missile)
    (when (window?)
      (start-task 'sound)
      (start-task 'music)))
    (when (processor?)
      (start-task 'processor))
    (when (client?)
      (start-task 'client)
      (start-task 'alive))
    (when (window?)
      (thread-base-priority-set! (task-thread 'generate) generate-priority)
      @generate-tasks
      (begin
        (thread-base-priority-set! (task-thread 'generate2) generate-priority)
        (thread-base-priority-set! (task-thread 'generate3) generate-priority)
        (thread-base-priority-set! (task-thread 'generate4) generate-priority)
        (thread-base-priority-set! (task-thread 'generate5) generate-priority))
      (thread-base-priority-set! (task-thread 'free) free-priority)
      (thread-base-priority-set! (task-thread 'instantiate) instantiate-priority)
      (thread-base-priority-set! (task-thread 'render) render-priority))
    (when (client?)
      (thread-base-priority-set! (task-thread 'player) player-priority))
    (thread-base-priority-set! (task-thread 'tick) tick-priority)
    (thread-base-priority-set! (task-thread 'redstone) redstone-priority)
    (thread-base-priority-set! (task-thread 'gravity) gravity-priority)
    (thread-base-priority-set! (task-thread 'lava) lava-priority)
    (thread-base-priority-set! (task-thread 'water) water-priority)
    (when (client?)
      (thread-base-priority-set! (task-thread 'distance) distance-priority)
      (thread-base-priority-set! (task-thread 'eat) eat-priority))
    (thread-base-priority-set! (task-thread 'sun) sun-priority)
    @YOWNU
    (begin
    (thread-base-priority-set! (task-thread 'spawn) spawn-priority)
    (thread-base-priority-set! (task-thread 'missile) missile-priority)
    (when (window?)
      (thread-base-priority-set! (task-thread 'sound) sound-priority)
      (thread-base-priority-set! (task-thread 'music) music-priority)))
    (when (processor?)
      (thread-base-priority-set! (task-thread 'processor) processor-priority))
    (when (client?)
      (thread-base-priority-set! (task-thread 'client) client-priority)
      (thread-base-priority-set! (task-thread 'alive) alive-priority)))
  
  
  (method (stop-tasks self)
    (define (stop-simulations)
      (iterate-table-safe simulations
        (lambda (entity task)
          (halt-simulation self entity))))
    
    (define (stop-entities)
      (for-each stop-entity entities))
  
    (define (stop-entity entity)
      (let ((task (get-task entity)))
        (when task
          (stop-task task))))
    
    (let ((world (current-world)))
      (set-render-boost? #f)
      (set-player-boost? #f)
      ;; stop generate before instantiate
      (reset-generate)
      (stop-generate)
      @generate-tasks
      (begin
        (stop-generate)
        (stop-generate)
        (stop-generate)
        (stop-generate))
      (stop-task 'generate #f)
      @generate-tasks
      (begin
        (stop-task 'generate2 #f)
        (stop-task 'generate3 #f)
        (stop-task 'generate4 #f)
        (stop-task 'generate5 #f))
      ;; stop free before instantiate
      (reset-free)
      (stop-free)
      (stop-task 'free #f)
      ;; stop instantiate before entities
      (reset-instantiate)
      (stop-task 'instantiate)
      (stop-simulations)
      (stop-entities)
      (when (client?)
        (stop-task 'player))
      (stop-task 'tick)
      (stop-task 'redstone)
      (stop-task 'gravity)
      (stop-task 'lava)
      (stop-task 'water)
      (when (client?)
        (stop-task 'distance)
        (stop-task 'eat))
      (stop-task 'sun)
      @YOWNU
      (begin
      (stop-task 'spawn)
      (stop-task 'missile)
      (when (window?)
        (stop-task 'sound)
        (stop-task 'music)))
      (when (processor?)
        (stop-task 'processor))
      (when (client?)
        (stop-task 'client)
        (stop-task 'alive))
      (when (client?)
        (set-player-thread world #f))
      (when (window?)
        (stop-task 'render)
        (set-render-thread world #f))))
  
  
  ;;;
  ;;;; Generator
  ;;;
  
  
  (method (free-generator self)
    (when generator
      (free generator)
      (set! generator #f)))
  
  
  ;;;
  ;;;; Scripts
  ;;;
  
  
  (definition scripting-prepared?
    #f)
  
  
  (method package (prepare-scripting self)
    (define (script-code)
      "(module prepare-scripting script (import (world.script)))")
    
    (when (scripting-available?)
      (when (not scripting-prepared?)
        (when (world-setting 'world.worker? #t)
          (let ((code (script-code)))
            (worker-run #f code
              ;; read
              (lambda (data)
                )
              ;; walk
              (lambda (data)
                )
              ;; error
              (lambda (data)
                )
              ;; run
              (lambda ()
                )
              ;; result
              (lambda (result)
                ))))
        (set! scripting-prepared? #t))))
  
  
  (method package (run-script self element)
    (unless (inhibit-scripts?)
      (when (is? element Entity)
        (let ((script (get-script element)))
          (when script
            (let ((kind (get-kind script)))
              (when (or (and (processor?) (eq? kind 'server))
                        (and (client?) (eq? kind 'client)))
                (let ((script (get-script element)))
                  (run-task element script evaluate-run?: #t)))))))))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method package (player-update self)
    (when (current-me+)
      (let ((interface (current-interface+)))
        (when interface
          (let ((character-panel (child interface 'character)))
            (view-inventory character-panel)
            (update character-panel))))))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (proclaim (not warn optimizations))

  
  (method package (target-update self target poly vert (only-feet? #f))
    (define (center-info title center (poly #f))
      (let ((section (position-section self center))
            (x (fxfloor (vertex-x center)))
            (y (fxfloor (vertex-y center)))
            (z (fxfloor (vertex-z center))))
        (if (not section)
            #f
          (let ((section-index (get-index section)))
            (let ((section-x (index-x section-index))
                  (section-y (index-y section-index))
                  (section-z (index-z section-index)))
              (let ((cache-uninitialized <fx> 65535)
                    (sections (neighbor-sections section section-x section-y section-z)))
                (define (gather-info)
                  (let ((bottom-section? (= section-y (cast <fx> (or truncate-y 0))))
                        (cache <u16vector> (initialize-block-cache block-cache cache-uninitialized))
                        (blocks (get-blocks section))
                        (data (get-data section))
                        (blocklight (get-blocklight section))
                        (skylight (get-skylight section)))
                    (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                      (vector-ref sections (section-index a b c)))
                    
                    (define (section-index a <fx> b <fx> c <fx>) <fx>
                      (+ (* b 9) (* c 3) a 13))
                    
                    (define (local-index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (effective-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* j 324) (* k 18) i 343) 4))
                    
                    (define (blocks-get section <World-Section>) <u8vector>
                      (get-blocks section))
                    
                    (define (blocklight-get section <World-Section>) <u8vector>
                      (get-blocklight section))
                    
                    (define (blocklight-ref i <fx> j <fx> k <fx>)
                      (u4vector-ref blocklight (local-index i j k)))
                    
                    (define (skylight-ref i <fx> j <fx> k <fx>)
                      (u4vector-ref skylight (local-index i j k)))
                    
                    (define (local-block-ref i <fx> j <fx> k <fx>)
                      (u8vector-ref blocks (local-index i j k)))
                    
                    (define (local-data-ref i <fx> j <fx> k <fx>)
                      (u4vector-ref data (local-index i j k)))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (effective-light-ref shade <fl> i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k blocklight-get u4vector-ref 0 0))
                    
                    (define (u4vector-ref field <u8vector> index <fx>) <fx>
                      (let ((byte (u8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (local-index i j k)))))))
                          
                          (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                ((> k 15) (bind-k 1 (- k 16)))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j -1 (+ 16 j)))
                              ((> j 15) (bind-j 1 (- j 16)))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i -1 (+ 16 i)))
                            ((> i 15) (bind-i 1 (- i 16)))
                            (else (bind-i 0 i))))
                    
                    (define (compute-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                      (format "{a} {a} {a} {a}"
                              (effective-light-ref shade (+ i ax) (+ j ay) (+ k az))
                              (effective-light-ref shade (+ i bx) (+ j by) (+ k bz))
                              (effective-light-ref shade (+ i cx) (+ j cy) (+ k cz))
                              (effective-light-ref shade (+ i dx) (+ j dy) (+ k dz))))
                    
                    (define (ambient-light i <fx> j <fx> k <fx> vert)
                      (let ((origin (vertex-& (vertex-& vert (vertex& (cast <fl> x) (cast <fl> y) (cast <fl> z))) (vertex& .5 .5 .5)))
                            (normal (get-normal poly)))
                        (generic-lighting i j k origin normal compute-lighting no-shade)))
                    
                    (define (block-info i <fx> j <fx> k <fx>)
                      (let ((block-id (local-block-ref i j k))
                            (data-id (local-data-ref i j k))
                            (blocklight (blocklight-ref i j k))
                            (skylight (skylight-ref i j k)))
                        (let ((block (id/variant-id->block block-id data-id)))
                          (append (list (cons title (get-name block)))
                                  (if (not (equal? title "Feet"))
                                      (list (cons "id" block-id)
                                            (cons "data" data-id))
                                    '())
                                  (list (cons "block light" blocklight)
                                        (cons "sky light" skylight))
                                  (if (equal? title "Feet")
                                      (list (cons "section" (format "{a} {a} {a}" section-x section-y section-z))
                                            (cons "coordinates" (format "{a} {a} {a}" i j k)))
                                    '())
                                  (if (and poly (developer?))
                                      (list (cons "section" (format "{a} {a} {a}" section-x section-y section-z))
                                            (cons "coordinates" (format "{a} {a} {a}" i j k))
                                            (cons "location" (present-location (position->location (polygon-position poly))))
                                            (cons "ambient" (ambient-light i j k vert)))
                                    '())))))
                    
                    (define (present-location loc)
                      (format "{a} {a} {a}"
                              (index-x loc)
                              (index-y loc)
                              (index-z loc)))
                    
                    (let ((i (- x (* section-x 16)))
                          (j (- y (* section-y 16)))
                          (k (- z (* section-z 16))))
                      (block-info i j k))))
                
                ;; quick hack
                (if only-feet?
                    (gather-info)
                  (with-generate-mutex
                    (lambda ()
                      (gather-info))))))))))
    
    (define (update-feet)
      (let ((pos (get-position (current-me))))
        (let ((feet (vertex+ pos (vertex 0. .5 0.))))
          (let ((info (center-info "Feet" feet)))
            (if (not info)
                (unregister-info 'feet)
              (register-info 'feet
                (lambda (add-section add-info)
                  (let ((section (add-section "Feet")))
                    (for-each (lambda (info)
                                (add-info section (car info) (cdr info)))
                              info)))))))))
    
    (define (update-info)
      (if (not poly)
          (begin
            (unregister-info 'block)
            (unregister-info 'fore))
        (let ((universe (current-universe)))
          (with-polygon-interaction universe poly
            (lambda (poly block fore)
              (let ((info (center-info "Block" block poly)))
                (register-info 'block
                  (lambda (add-section add-info)
                    (let ((section (add-section "Block")))
                      (for-each (lambda (info)
                                  (add-info section (car info) (cdr info)))
                                info)))))
              @wait
              (let ((info (center-info "Fore" fore)))
                (if (not info)
                    (unregister-info 'fore)
                  (register-info 'fore
                    (lambda (add-section add-info)
                      (let ((section (add-section "Fore")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info)))))))))
        (unregister-info 'feet)))
    
    (define (update-vertex)
      (define (determine-mesh)
        (if (and target
                 (= (length target) 1)
                 (is? (car target) Entity)
                 (is-not? (car target) Block-Entity)
                 (get-model (car target)))
            (let ((meshes (get-meshes (cache-model (car target)))))
              (and meshes
                   (> (vector-length meshes) 0)
                   (let ((position (get-position (car target))))
                     (values (vertex- vert position) (vector-ref meshes 0)))))
          (let ((universe (current-universe)))
            (with-polygon-interaction universe poly
              (lambda (poly block fore)
                (let ((section (position-section self block)))
                  (let ((sector (find-eye-sector (current-zone) (get-index section))))
                    (and sector
                         (let ((position (get-position& sector)))
                           (values (vertex- vert position) (get-mesh sector)))))))))))
      
      (define (vertex-info)
        (and vert
             (let ((info (determine-mesh)))
               (and info
                    (receive (vert mesh) info
                      (with-render-mutex
                        (lambda ()
                          (let ((world (current-world)))
                            (parameterize ((transform-feedback? #t))
                              (glEnable GL_RASTERIZER_DISCARD)
                              (render-world world)
                              (glDisable GL_RASTERIZER_DISCARD)))))
                      (let ((feedback (get-feedback-buffer mesh)))
                        (and (get-buffer feedback)
                             (let ((floats (get-floats feedback)))
                               (let ((data (make-f32vector floats)))
                                 (define (find-vertex-offset)
                                   (continuation-capture
                                     (lambda (return)
                                       (loop (for n from 0 below (get-indices feedback))
                                             (let ((offset (* n feedback-floats)))
                                               (when (and (= (f32vector-ref data offset) (vertex-x vert))
                                                          (= (f32vector-ref data (+ offset 1)) (vertex-y vert))
                                                          (= (f32vector-ref data (+ offset 2)) (vertex-z vert)))
                                                 (continuation-return return offset))))
                                       #f)))
                                 
                                 (bind-feedback-buffer feedback)
                                 (glGetTransformFeedbackFloat* 0 floats data)
                                 (let ((offset (find-vertex-offset)))
                                   (if (not offset)
                                       (list (cons "feedback" "<not found>")
                                             (cons "out1" (present-vec4 (subf32vector data 0 4)))
                                             (cons "out2" (present-vec4 (subf32vector data 4 8)))
                                             (cons "out3" (present-vec4 (subf32vector data 8 12)))
                                             (cons "out4" (present-vec4 (subf32vector data 12 16))))
                                     (list (cons "out1" (present-vec4 (subf32vector data (+ offset 0) (+ offset 4))))
                                           (cons "out2" (present-vec4 (subf32vector data (+ offset 4) (+ offset 8))))
                                           (cons "out3" (present-vec4 (subf32vector data (+ offset 8) (+ offset 12))))
                                           (cons "out4" (present-vec4 (subf32vector data (+ offset 12) (+ offset 16))))))))))))))))
      
      (define (present-vec4 vec)
        (format "{r precision: 3} {r precision: 3} {r precision: 3} {r precision: 3}"
                (f32vector-ref vec 0)
                (f32vector-ref vec 1)
                (f32vector-ref vec 2)
                (f32vector-ref vec 3)))
      
      (let ((info (and debug-transform? (vertex-info))))
        (if (not info)
            (unregister-info 'vertex)
          (register-info 'vertex
            (lambda (add-section add-info)
              (let ((section (add-section "Vertex")))
                (for-each (lambda (info)
                            (add-info section (car info) (cdr info)))
                          info)))))))
             
    
    @wait
    (update-feet)
    (unless only-feet?
      (update-info)
      (update-vertex)))
  
  
  (proclaim (warn optimizations))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method package (get-directory self)
    (get-parent (get-moniker self)))
  
  
  (method package (get-moniker self)
    (get-origin form))
  
  
  (method package (get-modified? self)
    (get-modified? designer))
  
  
  (method package (set-modified? self flag)
    (when #t @buggy (neq? flag (get-modified? designer))
      (set-modified? designer flag)
      (title-update self)))
  
  
  (method package (save-property self property value)
    (set-property designer self property value)
    (save-designer self))
  
  
  (method (read-element self element property)
    (read-property element property))
  
  
  (method package (write-element self element property value)
    (with-designer self element
      (lambda (designer container)
        (set-property designer element property value))))
  
  
  (method package (with-designer self element proc)
    (define (toplevel elem)
      (let ((parent (get-parent elem)))
        (if (or (not parent) (eq? parent self) (is? parent Chunk-Container))
            elem
          (toplevel parent))))
    
    (let ((top (toplevel element)))
      (with-chunk-designer self (get-designer-chunk top)
        proc)))
  
  
  (method package (with-chunk-designer self chunk proc)
    (assert chunk)
    (let ((designer (cache-designer chunk)))
      (prog1 (proc designer (get-reference designer))
        (save-designer chunk)
        (modified chunk)
        (save-region (get-region chunk)))))
  
  
  (method package (create-block-entity self model position)
    (let ((chunk (position-chunk self position)))
      (with-chunk-designer self chunk
        (lambda (designer container)
          (let ((entity (new Block-Entity model: model position: position)))
            (set-designer-chunk entity chunk)
            entity)))))
  
  
  ;; quicky for sejour to think through
  (method package (designable? self obj)
    (and (is? obj Entity)
         (get-designer-chunk obj)
         (component-in-descendants? (cache-designer (get-designer-chunk obj)) obj)))


  (method package (need-script self obj (create?: create? #t))
    (or (get-script obj)
        (and create?
             ;; sejour quicky
             (or (is? obj Block-Entity)
                 (designable? (current-zone) obj))
             (let ((script (new Script parent: obj)))
               (if (is? obj Block-Entity)
                   (let ((pos (get-position obj))
                         (model (get-model obj)))
                     (let ((chunk (position-chunk self pos)))
                       (with-chunk-designer self chunk
                         (lambda (designer container)
                           (add-child designer obj container properties: (list 'position pos 'model model proxy?: #t))
                           (add-child designer script obj)
                           (add-element self obj chunk)
                           (setup-actions obj)
                           script))))
                 (with-designer self obj
                   (lambda (designer container)
                     (add-child designer script obj)))
                 script)))))
  
  
  ;;;
  ;;;; Prologue
  ;;;
  
  
  (method (check-prologue self (size: size #f))
    (when (and (client?) (get-first-time? game) (world-setting 'world.show-prologue? #t) (window?))
      (show-prologue self size: size)
      (save-designer self)))
  
  
  (method (show-prologue self (size: size #f))
    (let ((file (prologue-file self)))
      (when (exists? file)
        (open-world-document file class: World-Formatted-Text-View size: (or size {Dimension 800 600})))))
  
  
  (method (prologue-file self)
    (zone-brother self "Prologue.ftx"))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method package (draw-zone self)
    (let ((world (current-world)))
      (draw-sectors)
      (when (not-null? draw-procedures)
        (for-each (lambda (proc)
                    (proc))
                  draw-procedures))
      (if (effective-draw-gadgets? world)
          (draw-gadgets self)
        (draw-drawable-gadgets self))
      (when (get-draw-marks? world)
        (draw-marks self))
      (when (get-draw-atlas? world)
        (draw-atlas self))
      (when (and sun (get-visible? sun))
        (register-sun self))
      (gl-check-error)))
  
  
  (method (registered-draw self name)
    (table-ref draw-procedure-names name #f))
  
  
  (method package (register-draw self name proc)
    (when (registered-draw self name)
      (unregister-draw self name))
    (set! draw-procedures (cons proc draw-procedures))
    (table-set! draw-procedure-names name proc))
  
  
  (method (unregister-draw self name)
    (let ((proc (table-ref draw-procedure-names name)))
      (set! draw-procedures (remove! proc draw-procedures))
      (table-clear draw-procedure-names name)))
  
  
  ;;;
  ;;;; Blocks
  ;;;
  
  
  (method protected virtual (album-name self)
    'block)
  
  
  (method protected virtual (create-album self)
    (let ((name (or atlas-name (album-name self))))
      (or (registered-album name)
          (let ((atlas (create-atlas self)))
            (let ((textures (create-textures self atlas)))
              (when (complete-album? self)
                (complete atlas))
              (update-textures-subuvs atlas)
              (let ((album (new Album atlas textures)))
                (register-album name album)
                album))))))
  
  
  (method protected virtual (complete-album? self)
    #t)
  
  
  (method protected virtual (create-atlas self)
    (create-block-atlas))
  
  
  (method protected virtual (create-textures self atlas)
    (list->table
      (list
        ;; clamp to edge is necessary for joins like between the rails
        (cons 'clamp (create-texture atlas wrap: GL_CLAMP_TO_EDGE))
        (cons 'repeat (create-texture atlas min-filter: 'nearest)))))
  
  
  (method (prepare-blocks self)
    (let ((world (current-world)))
      (prepare-pack self)
      (let ((album (create-album self)))
        (let ((atlas (get-atlas album)))
          (let ((texture (get-texture album 'clamp))
                (texture-repeat (get-texture album 'repeat)))
            (prepare-block world atlas texture texture-repeat)
            (let ((opaque-material (get-material (cast <Rendering> (opaque-rendering))))
                  (transparent-material (get-material (cast <Rendering> (transparent-rendering))))
                  (coverage-material (get-material (cast <Rendering> (coverage-rendering))))
                  (water-material (get-material (cast <Rendering> (water-rendering))))
                  (wet-material (get-material (cast <Rendering> (wet-rendering))))
                  (multitexture-material (get-material (cast <Rendering> (multitexture-rendering)))))
              (prepare-materials world opaque-material transparent-material coverage-material water-material wet-material multitexture-material))
            (prepare-lightmaps world))))))
  
  
  (method protected virtual (prepare-pack self)
    (prepare-pack/tile self
                       (world-setting 'world.tile-resolution #f)
                       (world-setting 'world.tile-pack #f)))
  
  
  (method protected (require-pack self dirname)
    (let ((world (current-world)))
      (continuation-capture
        (lambda (return)
          (iterate-assets world
            (lambda (assets)
              (when (contains-directory? assets dirname)
                (let ((dir (make-directory assets dirname)))
                  (when (not (exists? dir))
                    (retrieve-directory assets dirname progress: "Downloading texture pack")))
                (continuation-return return assets))))
          (error "Unable to find asset: {a}" dirname)))))
  
  
  (method (prepare-pack/tile self resolution tile-pack)
    ;; pack
    (let ((resolution (or resolution 128)))
      (let ((name (format "{a}x{a}" resolution resolution)))
        (let ((assets (require-pack self (string-append "block/" name)))
              (path (list "block" name)))
          (setup-pack resolution assets path))))
    ;; tile
    (when tile-pack
      (if (not resolution)
          (error "Need to specify resolution for tile pack")
        (let ((assets (require-pack self (string-append "block/" tile-pack)))
              (path (list "block" tile-pack)))
          (setup-tile assets path)))))
  
  
  (method package virtual (sample-program-image self program)
    (case program
      ((opaque) "stone")
      ((transparent) "flower_rose")
      (else "wool_colored_light_blue")))
  
  
  ;;;
  ;;;; Skybox
  ;;;
  
  
  (method protected virtual (prepare-skybox self)
    (set! skybox (and start-skybox (let ((skybox (find-skybox start-skybox)))
                                     (when skybox
                                       (prepare skybox))
                                     skybox))))
  
  
  (method package (install-skybox self sky)
    (prepare sky)
    (set! skybox sky))
  
  
  (method package (remove-skybox self)
    (set! skybox #f))
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method package (add-element self obj (chunk #f))
    (define (add-player)
      (set! players (cons obj players))
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-actor)
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-gravity)
      (set! gravities (cons obj gravities))
      (set! gadgets (cons obj gadgets)))
    
    (define (add-gravity-well)
      (set! gravities (cons obj gravities)))
    
    (define (add-light)
      (set! gadgets (cons obj gadgets))
      (setup-lighting self))
    
    (define (add-gadget)
      (set! gadgets (cons obj gadgets)))
    
    (define (add-entity)
      (set! entities (cons obj entities)))
    
    (if (and (client?) (simulated? obj))
        (begin
          (when (is? obj Player)
            (set! players (cons obj players)))
          (link-entity self obj (transformed-coverage self obj))
          (start-simulation self obj))
      (typecase obj
        ((Player) (add-player))
        ((Actor) (add-actor))
        ((Gravity) (add-gravity))
        ((Gravity-Well) (add-gravity-well))
        ((Light) (add-light))
        ((Gadget) (add-gadget))
        ((Entity) (add-entity)))
      (when (is? obj Entity)
        (let ((index (element-section-index self obj)))
          (link-entity self obj (transformed-coverage self obj))
          (set-designer-chunk obj (or chunk (index-chunk self index)))))
      (when (or (and (server?) (window?) (is? obj Player) (not (get-me? obj)))
                (and (client?) (is? obj Creature)))
        (start-simulation self obj))
      (when (is? obj Creature)
        (add-spawned obj))
      (when (is? obj Entity)
        (run-script self obj)))
    obj)
  
  
  (method package (remove-element self obj)
    (define (remove-player)
      (set! players (remove! obj players))
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-actor)
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-gravity)
      (set! gravities (remove! obj gravities))
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-gravity-well)
      (set! gravities (remove! obj gravities)))
    
    (define (remove-light)
      (set! gadgets (remove! obj gadgets))
      (setup-lighting self))
    
    (define (remove-gadget)
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-entity)
      (set! entities (remove! obj entities)))
    
    (if (and (client?) (simulated? obj))
        (begin
          (halt-simulation self obj)
          (when (is? obj Player)
            (set! players (remove! obj players)))
          (unlink-entity self obj (get-coverage obj)))
      (unless (client?)
        (when (is? obj Entity)
          (halt-entity obj)))
      (when (or (and (server?) (window?) (is? obj Player) (not (get-me? obj)))
                (and (client?) (is? obj Creature)))
        (halt-simulation self obj))
      (when (is? obj Creature)
        (remove-spawned obj))
      (typecase obj
        ((Player) (remove-player))
        ((Actor) (remove-actor))
        ((Gravity) (remove-gravity))
        ((Gravity-Well) (remove-gravity-well))
        ((Light) (remove-light))
        ((Gadget) (remove-gadget))
        ((Entity) (remove-entity)))
      (when (is? obj Entity)
        (unlink-entity self obj (get-coverage obj))
        (set-designer-chunk obj #f)))
    (close obj))
  
  
  (method (add-simulated self obj)
    (link-entity self obj (transformed-coverage self obj)))
  
  
  (method (remove-simulated self obj)
    (unlink-entity self obj (get-coverage obj)))
  
  
  (method (link-entity self entity coverage)
    (when (get-model-cache entity)
      (loop (for i from (coverage-left coverage) to (coverage-right coverage))
            (loop (for j from (coverage-bottom coverage) to (coverage-top coverage))
                  (loop (for k from (coverage-back coverage) to (coverage-front coverage))
                        (let ((expanse (index-expanse self (indexed i j k))))
                          (add-entity expanse entity)))))
      (set-coverage entity coverage))
    (when (is? entity Point-Light)
      (let ((index (position-section-index self (get-position entity))))
        (loop (for i from (- (index-x index) 1) to (+ (index-x index) 1))
              (loop (for j from (- (index-y index) 1) to (+ (index-y index) 1))
                    (loop (for k from (- (index-z index) 1) to (+ (index-z index) 1))
                          (let ((expanse (index-expanse self (indexed i j k))))
                            (add-point-light expanse entity))))))
      (set-light-position entity (copy-vertex (get-position entity)))))
  
  
  (method (unlink-entity self entity coverage)
    (when (get-model-cache entity)
      (loop (for i from (coverage-left coverage) to (coverage-right coverage))
            (loop (for j from (coverage-bottom coverage) to (coverage-top coverage))
                  (loop (for k from (coverage-back coverage) to (coverage-front coverage))
                        (let ((expanse (index-expanse self (indexed i j k))))
                          (remove-entity expanse entity)))))
      (set-coverage entity #f))
    (when (is? entity Point-Light)
      (let ((index (position-section-index self (get-light-position entity))))
        (loop (for i from (- (index-x index) 1) to (+ (index-x index) 1))
              (loop (for j from (- (index-y index) 1) to (+ (index-y index) 1))
                    (loop (for k from (- (index-z index) 1) to (+ (index-z index) 1))
                          (let ((expanse (index-expanse self (indexed i j k))))
                            (remove-point-light expanse entity))))))
      (set-light-position entity #f)))
  
  
  (method package (transformed-coverage self entity)
    (let ((bounds (transformed-bounds entity)))
      (coverage (fxfloor (/ (cuboid-left bounds) 16.))
                (fxfloor (/ (cuboid-bottom bounds) 16.))
                (fxfloor (/ (cuboid-back bounds) 16.))
                (fxfloor (/ (cuboid-right bounds) 16.))
                (fxfloor (/ (cuboid-top bounds) 16.))
                (fxfloor (/ (cuboid-front bounds) 16.)))))
  
  
  (method package (update-entity self entity)
    ;; for setup-children backward compatibility
    (when level-dir
      (when (get-model-cache entity)
        (let ((old (get-coverage entity))
              (new (transformed-coverage self entity)))
          (when (and old (not (coverage=? old new)))
            ;; if we ever have big entities moving
            ;; it will become essential to not unlink
            ;; and link sectors that remain linked for
            ;; example bounds going from 0 10 to 1 11
            ;; we would only unlink 0 and link 11
            (unlink-entity self entity old)
            (link-entity self entity new))))
      @old
      (let ((old-index (position-section-index self old-position))
            (new-index (element-section-index self entity)))
        (unless (equal? old-index new-index)
          (unlink-entity self old-index entity)
          @should-only-be-done-by-set-property-as-it-can-put-an-entity-in-an-incorrect-section-designer
          (when (and (is? (get-parent entity) Chunk-Container)
                     (get-chunk (get-parent entity)))
            (with-section-designer (index-section old-index)
              (lambda (designer container)
                (remove-child designer entity)))
            (with-section-designer (index-section new-index)
              (lambda (designer container)
                (set-parent entity container)
                (add-child designer entity container form: (get-form entity)))))
          (link-entity self new-index entity)))))
  
  
  (method (find-element self predicate)
    (continuation-capture
      (lambda (return)
        (iterate-elements self
          (lambda (element)
            (when (predicate element)
              (continuation-return return element))))
        #f)))
  
  
  (method (find-named-element self name)
    (find-element self
      (lambda (element)
        (eq? (get-name element) name))))
  
  
  (method (find-gadget self predicate)
    (find-if predicate gadgets))
  
  
  (method (collect-observers self)
    (collect-if (lambda (player)
                  (eq? (get-mode player) 'observer))
                players))
  
  
  (method (collect-players self)
    (collect-if (lambda (player)
                  (eq? (get-mode player) 'player))
                players))
  
  
  (method (iterate-players self proc)
    (for-each proc players))
  
  
  (method (iterate-actors self proc)
    (for-each proc actors))
  
  
  (method package (iterate-entities self proc)
    (for-each proc entities))
  
  
  (method (iterate-gadgets self proc)
    (for-each proc gadgets))
  
  
  (method (iterate-elements self proc)
    (for-each proc entities))
  
  
  (method (draw-me self)
    (let ((me (current-me)))
      (draw me)))
  
  
  (method (element-at self vert)
    #f
    @convert^^^
    (continuation-capture
      (lambda (return)
        (let ((area (index-area (position-area-index vert))))
          (iterate-area-elements area
            (lambda (obj)
              (when (and (get-visible? obj)
                         (vertex=? (get-position obj) vert))
                (continuation-return return obj)))))
        #f)))
  
  
  (method package (element-near self vert)
    #f
    @convert^^^
    (let ((x (vertex-x vert))
          (y (vertex-y vert))
          (z (vertex-z vert))
          ;; open test quicky to improve
          (radius .7))
      (let ((left (- x radius))
            (bottom (- y radius))
            (back (- z radius))
            (right (+ x radius))
            (top (+ y radius))
            (front (+ z radius)))
        (continuation-capture
          (lambda (return)
            (with-area-retainer 'element-near
              (lambda (retain)
                (iterate-position-neighbor-areas vert 1 #f
                  (lambda (area index retain?)
                    (when retain?
                      (retain area))
                    (iterate-area-elements area
                      (lambda (obj)
                        (when (and (get-visible? obj)
                                   (let ((x (get-x obj))
                                         (y (get-y obj))
                                         (z (get-z obj)))
                                     (and (>= x left)
                                          (>= y bottom)
                                          (>= z back)
                                          (<  x right)
                                          (<  y top)
                                          (<  z front))))
                          (continuation-return return obj))))))))
            #f)))))
  
  
  (method (validate-elements self)
    (iterate-elements self
      (lambda (element)
        (assert (real? (get-x element)))
        (assert (real? (get-y element)))
        (assert (real? (get-z element)))
        (assert (real? (get-red element)))
        (assert (real? (get-green element)))
        (assert (real? (get-blue element)))
        (assert (real? (get-alpha element))))))
  
  
  ;;;
  ;;;; Creature
  ;;;
  
  
  (method package (get-creatures self)
    (collect-type Creature actors))
  
  
  (method package (change-creature-models? self value)
    (set-creature-models? value)
    (for-each (lambda (creature)
                (update-model creature anchor?: #t))
              spawned-creatures))
  
  
  ;;;
  ;;;; Simulation
  ;;;
  
  
  (method (start-simulation self actor)
    (unless (table-ref simulations actor #f)
      (let ((procedure
              (lambda (task)
                (simulation-task actor task))))
        (let ((task (new Task 'simulation procedure priority: simulation-priority)))
          (start-task task)
          (set-task actor task)
          (table-set! simulations actor task)))))
  
  
  (method (halt-simulation self actor)
    (let ((task (get-task actor)))
      (table-clear simulations actor)
      (halt-task task)))

  
  ;;;
  ;;;; Dimension
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-dimension self)
    (let ((dir (new-directory level-dir (case level-dimension
                                          ((over) "region")
                                          ((nether) '("DIM-1" "region"))
                                          ((end) '("DIM1" "region"))))))
      (set! dimension (new World-Dimension dir generator truncate-y self))))
  
  
  (method (free-dimension self)
    (free-regions dimension))
  
  
  (method public (cycle-level-dimension self)
    (with-generate-mutex
      (lambda ()
        (set! level-dimension (case level-dimension
                                ((over) 'nether)
                                ((nether) 'end)
                                ((end) 'over)))
        (setup-dimension self)
        (setup-areas self))))
  
  
  (method public (load-region self index <index>) <World-Region>
    (load-region dimension index))
  
  
  ;; exploration
  (method (preload-regions self)
    (iterate-regions-dir dimension
      (lambda (file index)
        (let ((region (load-region dimension index)))
          (loop (for section-x from 0 below 32)
                (loop (for section-z from 0 below 32)
                      (loop (for section-y from 0 below 16)
                            (load-section region section-x section-y section-z))))))))


  ;; exploration
  (method (explore-regions self from to (more? #f))
    (define (explore region)
      (let ((region-x (get-x region))
            (region-z (get-z region))
            (count 0)
            (missing (new-queue)))
        (iterate-chunks region
          (lambda (x z)
            (when (not (load-chunk region (planar-index x z)))
              (increase! count)
              (enqueue missing (list (+ (* region-x region-size) x)
                                     (+ (* region-z region-size) z))))))
        (if (not more?)
            (debug region count)
          (debug region count (queue-list missing)))))
    
    (loop (for x from from to to)
          (loop (for z from from to to)
                (let ((region (load-region dimension (indexed x 0 z))))
                  (explore region)))))
  
  
  ;; exploration
  (method (explore-chests self)
    (preload-regions self)
    (let ((items '()))
      (for-each (lambda (info)
                  (bind (section . coordinates) info
                    (bind-index (i j k) coordinates
                      (call-with-section self section i j k
                        (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                          (let ((data (block-entity-data section (indexed i j k))))
                            (let ((inventory (list-payload-content (tag-assoc "Items" data))))
                              (for-each (lambda (item)
                                          (let ((id (tag-assoc "id" item)))
                                            (let ((name (or (let ((item (id->item id)))
                                                              (and item (get-name item)))
                                                            id)))
                                              (unless (memv? name items)
                                                (set! items (cons name items))))))
                                        inventory))))))))
                (find-visual-blocks self '(54)))
      (sort nu<? items key: ->string)))
  
  
  (method package (count-regions self)
    (let ((count 0))
      (iterate-regions dimension
        (lambda (region)
          (increase! count)))
      count))
  
  
  ;;;
  ;;;; Chunks
  ;;;
  
  
  (method (position-chunk self pos <vertex>) <World-Chunk>
    (index-chunk self (position-section-index self pos)))
  
  
  (method (element-chunk self element) <World-Chunk+>
    (let ((index (element-section-index self element)))
      (index-chunk self index)))
  
  
  (method (index-chunk self index <index>) <World-Chunk>
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (let ((region (load-region dimension (indexed (fxfloor/ section-x region-size)
                                                    (fxfloor/ section-y region-size)
                                                    (fxfloor/ section-z region-size)))))
        (load-section-chunk region (planar-index section-x section-z)))))
  
  
  (method (index-chunk-if self index (create?: create? #f)) <World-Chunk+>
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (let ((region (let ((index (indexed (fxfloor/ section-x region-size)
                                          (fxfloor/ section-y region-size)
                                          (fxfloor/ section-z region-size))))
                      (if create?
                          (load-region dimension index)
                        (load-region-if dimension index)))))
        (and region
             (load-section-chunk region (planar-index section-x section-z))))))
  
  
  (method package (find-chunk self section-x section-y section-z) <World-Chunk+>
    (let ((region (find-region dimension (indexed (fxfloor/ section-x region-size)
                                                  (fxfloor/ section-y region-size)
                                                  (fxfloor/ section-z region-size)))))
      (and region
           (find-chunk region (planar-index section-x section-z)))))
  
  
  (method package (count-chunks self)
    (let ((count 0))
      (iterate-regions dimension
        (lambda (region)
          (increase! count (count-chunks region))))
      count))
  
  
  ;;;
  ;;;; Sections
  ;;;
  
  
  (method package (element-section-index self element <Element>) <index>
    (position-section-index self (get-position element)))
  
  
  (method (position-section-index self pos <vertex>) <index>
    (let ((size (cast <fl> sector-size)))
      (indexed (fxfloor (/ (vertex-x pos) size))
               (fxfloor (/ (vertex-y pos) size))
               (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method package (position-section self pos (create?: create? #f)) <World-Section+>
    (let ((index (position-section-index self pos)))
      (index-section self index create?: create?)))
  
  
  (method (element-section self element) <World-Section+>
    (let ((index (element-section-index self element)))
      (index-section self index)))
  
  
  (method package (index-section self index (create?: create? #f)) <World-Section+>
    (let ((section-y (index-y index)))
      (let ((chunk (index-chunk-if self index create?: create?)))
        (and chunk
             (load-section chunk section-y create?: create?)))))
  
  
  (method package (find-section self section-x section-y section-z) <World-Section+>
    (let ((chunk (find-chunk self section-x section-y section-z)))
      (and chunk
           (find-section chunk section-y))))
  
  
  (method package (count-sections self)
    (let ((count 0))
      (iterate-regions dimension
        (lambda (region)
          (iterate-chunks region
            (lambda (chunk)
              (increase! count (count-sections chunk))))))
      count))
  
  
  (method package (toggle-debug-sections self)
    (set! debug-sections? (not debug-sections?)))
  
  
  (method package (draw-debug-sections self)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((world (current-world))
          (camera (current-camera)))
      (let ((view-distance (get-view-distance world)))
        (let ((eye-x (index-x eye-index))
              (eye-y (index-y eye-index))
              (eye-z (index-z eye-index))
              (distance (+ view-distance 2)))
          (if show-chunks?
              (let ((j 0))
                (define (show state color)
                  (render-cubes
                    (lambda (render)
                      (loop (for i from (- eye-x distance) to (+ eye-x distance))
                            (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                  (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                         (+ (* (cast <fl> j) 16.) 8.)
                                                         (+ (* (cast <fl> k) 16.) 8.))))
                                    (when (in-frustum? camera center)
                                      (let ((chunk (find-chunk self i j k)))
                                        (when (and chunk (= (get-state chunk) state))
                                          (render center))))))))
                    wire-color: color
                    cull?: #t))
                
                (show Shaped red-dye)
                (show Populated blue-dye)
                (show Generated green-dye))
            (if (not instanced-rendering?)
                (render-cubes
                  (lambda (render)
                    (loop (for i from (- eye-x distance) to (+ eye-x distance))
                          (loop (for j from (- eye-y distance) to (+ eye-y distance))
                                (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                      (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                             (+ (* (cast <fl> j) 16.) 8.)
                                                             (+ (* (cast <fl> k) 16.) 8.))))
                                        (when (in-frustum? camera center)
                                          (when (or show-sections? (find-section self i j k))
                                            (render center))))))))
                  wire-color: red-dye
                  cull?: #t)
              (render-cubes-instanced
                (lambda (mesh render)
                  (let ((distance (get-view-distance world))
                        (camera-pos (get-position (current-camera))))
                    (let ((max (expt (+ distance 1 distance) 3)))
                      (let ((buffer (get-instance-buffer mesh))
                            (data (make-f32vector (* max 3)))
                            (offset 0)
                            (count 0))
                        (loop (for i from (- eye-x distance) to (+ eye-x distance))
                              (loop (for j from (- eye-y distance) to (+ eye-y distance))
                                    (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                          (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                                 (+ (* (cast <fl> j) 16.) 8.)
                                                                 (+ (* (cast <fl> k) 16.) 8.))))
                                            (when (in-frustum? camera center)
                                              (when (or show-sections? (find-section self i j k))
                                                (f32vector-set! data offset (+ (vertex-x center) (vertex-x camera-pos)))
                                                (f32vector-set! data (+ offset 1) (+ (vertex-y center) (vertex-y camera-pos)))
                                                (f32vector-set! data (+ offset 2) (+ (vertex-z center) (vertex-z camera-pos)))
                                                (increase! offset 3)
                                                (increase! count)))))))
                        (update-stream-data buffer 0 data (* count 3))
                        (render (vertex 0. 0. 0.) count)))))
                wire-color: red-dye
                cull?: #t)))))))
  
  
  ;;;
  ;;;; Sectors
  ;;;
  
  
  (method (setup-sectors self)
    (let ((world (current-world)))
      (set! sector-radius (let ((half (/ sector-size 2.)))
                            (vertex-norm (vertex half half half))))
      (set! sector-diameter (* sector-radius 2))
      (set! sectors-mutex (make-mutex 'sectors))
      (let ((distance (get-view-distance world)))
        (let ((diameter (+ distance 1 distance)))
          (set! eye-radius distance)
          (set! eye-diameter diameter)
          (set! eye-diameter^2 (expt diameter 2))
          (set! eye-diameter^3 (expt diameter 3))
          (set! eye-sectors (make-eye-sectors self))
          (set! eye-neighbors (make-eye-neighbors self))))
      (set! sector/area-ratio (fxround/ sector-size area-size))))
  
  
  (method package (update-view-distance self old-distance distance)
    @convert-indexed-sector^^^
    (unless (= distance old-distance)
      (let ((diameter (+ distance 1 distance)))
        (let ((radius distance)
              (diameter^2 (expt diameter 2))
              (diameter^3 (expt diameter 3)))
          (define (index i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j radius) diameter^2)
               (* (+ k radius) diameter)
               (+ i radius)))
          
          (define (index-eye i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j eye-radius) eye-diameter^2)
               (* (+ k eye-radius) eye-diameter)
               (+ i eye-radius)))
          
          (let ((sectors (make-vector diameter^3 #f)))
            (cond ;; smaller
                  ((< distance old-distance)
                   (loop (for i from (- distance) to distance)
                         (loop (for j from (- distance) to distance)
                               (loop (for k from (- distance) to distance)
                                     (vector-set! sectors (index i j k) (vector-ref eye-sectors (index-eye i j k)))))))
                  ;; greater
                  (else
                   (loop (for i from (- old-distance) to old-distance)
                         (loop (for j from (- old-distance) to old-distance)
                               (loop (for k from (- old-distance) to old-distance)
                                     (vector-set! sectors (index i j k) (vector-ref eye-sectors (index-eye i j k))))))))
            (set! eye-radius radius)
            (set! eye-diameter diameter)
            (set! eye-diameter^2 diameter^2)
            (set! eye-diameter^3 diameter^3)
            (set! eye-sectors sectors)
            ;; greater so add new sectors
            (when (> distance old-distance)
              (let ((a (index-x eye-index))
                    (b (index-y eye-index))
                    (c (index-z eye-index)))
                (loop (for i from (- distance) to distance)
                      (loop (for j from (- distance) to distance)
                            (loop (for k from (- distance) to distance)
                                  (let ((index (index-eye i j k)))
                                    (unless (vector-ref eye-sectors index)
                                      (vector-set! sectors index (indexed-sector (+ a i) (+ b j) (+ c k))))))))))
            (set! eye-neighbors (make-vector diameter^3 #f))
            (update-eye-neighbors distance))))))
  
  
  (method package (position-sector-index self pos <vertex>) <index>
    (let ((size (cast <fl> sector-size)))
      (indexed (fxfloor (fl& (/ (vertex-x pos) size)))
               (fxfloor (fl& (/ (vertex-y pos) size)))
               (fxfloor (fl& (/ (vertex-z pos) size))))))
  
  
  (method (new-sector self index <index>) <Sector>
    (define (center i <fx>)
      (* (+ (cast <fl> i) .5) sector-size))
    
    (let ((x (index-x index))
          (y (index-y index))
          (z (index-z index)))
      (new Sector index (vertex (center x) (center y) (center z)) (index-expanse self index))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (iterate-sectors self proc)
    (when eye-neighbors
      (loop (for sector in-vector eye-neighbors)
            (when sector
              (proc sector)))))
  
  
  (proclaim (warn optimizations))
  
  
  (method package (iterate-section-neighbors self section-index <index> distance <fx> proc)
    (let ((a (index-x section-index))
          (b (index-y section-index))
          (c (index-z section-index)))
      (loop (for i from (- distance) to distance)
            (loop (for j from (- distance) to distance)
                  ;; $$$ try
                  (do (when (between? j 0 15)
                        (loop (for k from (- distance) to distance)
                              (let ((section (index-section self (indexed (+ a i) (+ b j) (+ c k)))))
                                (when section
                                  (proc section))))))))))
    
  
  ;; index of the eye sector
  (definition eye-index <index+>
    #f)
  
  ;; cube of all eye sectors
  (definition eye-sectors
    #f)
  
  ;; eye sectors ordered by distance
  (definition eye-neighbors
    #f)
  
  (definition eye-radius <fx>
    0)
  
  (definition eye-diameter <fx>
    0)
  
  (definition eye-diameter^2 <fx>
    0)
  
  (definition eye-diameter^3 <fx>
    0)
  
  
  (method package (get-eye-index self)
    eye-index)
  
  (method package (get-eye-sectors self) <vector>
    eye-sectors)
  
  (method package (get-eye-neighbors self) <vector>
    eye-neighbors)
    
  
  (method (sectors-index self i <fx> j <fx> k <fx>) <fx>
    (+ (* j eye-diameter^2) (* k eye-diameter) i))

  
  (method (make-eye-sectors self)
    (make-vector eye-diameter^3 #f))
  
  
  (method (make-eye-neighbors self)
    (make-vector eye-diameter^3 #f))
  
  
  ;; PLANETS
  @w
  (method (position-sector pos) <Sector>
    (index-sector (position-sector-index pos)))
  
  
  (method (element-sector self element) <Sector+>
    ;; should iterate over every camera
    (find-eye-sector self (element-section-index self element)))
  
  
  ;; PLANETS
  @w
  (method (index-sector index <vector>) <Sector>
    (or (table-ref sectors index #f)
        (let ((sector (new-sector index)))
          (table-set! sectors index sector)
          sector)))
  
  
  (method (find-sector self index) <Sector+>
    ;; should iterate over every camera
    (find-eye-sector self index))
  
  
  (method (find-eye-sector self index)
    (and eye-index
         (let ((a (- (index-x eye-index) eye-radius))
               (b (- (index-y eye-index) eye-radius))
               (c (- (index-z eye-index) eye-radius)))
           (let ((i (- (index-x index) a))
                 (j (- (index-y index) b))
                 (k (- (index-z index) c))
                 (last (- eye-diameter 1)))
             (and (between? i 0 last)
                  (between? j 0 last)
                  (between? k 0 last)
                  (vector-ref eye-sectors (sectors-index self i j k)))))))
  
  
  (method (eye-sector self)
    (vector-ref eye-sectors (sectors-index self eye-radius eye-radius eye-radius)))
  
  
  (method (free-eye-sectors self)
    (set! eye-index #f)
    (loop (for n from 0 below eye-diameter^3)
          (let ((sector (vector-ref eye-sectors n)))
            (when sector
              (close sector)))
          (vector-set! eye-sectors n #f)
          (vector-set! eye-neighbors n #f)))
  
  
  (method package (eye-neighbor-sectors self index <index> distance <fx>) <vector>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (define (sector-new i j k)
      (new-sector self (indexed i j k)))
    
    (define (sector-free sector)
      (push-free sector))
    
    (if (and eye-index (index=? index eye-index))
        eye-neighbors
      ;; update sectors
      (let ((sectors (get-eye-sectors self))
            (a <fx> (- (index-x index) eye-radius))
            (b <fx> (- (index-y index) eye-radius))
            (c <fx> (- (index-z index) eye-radius)))
        (if (not eye-index)
            (loop (for i from 0 below eye-diameter)
                  (loop (for j from 0 below eye-diameter)
                        (loop (for k from 0 below eye-diameter)
                              (vector-set! sectors (sectors-index self i j k)
                                (sector-new (+ a i)
                                            (+ b j)
                                            (+ c k))))))
          (let ((last (- eye-diameter 1))
                (dx (- (index-x index) (index-x eye-index)))
                (dy (- (index-y index) (index-y eye-index)))
                (dz (- (index-z index) (index-z eye-index))))
            (define (by delta <fx>)
              (if (>= delta 0)
                  1
                -1))
            
            (loop (for x start 0 end last by (by dx))
                  (let ((fx (+ x dx))
                        (tx x))
                    (loop (for y start 0 end last by (by dy))
                          (let ((fy (+ y dy))
                                (ty y))
                            (loop (for z start 0 end last by (by dz))
                                  (let ((fz (+ z dz))
                                        (tz z))
                                    (let ((fi (and (between? fx 0 last)
                                                   (between? fy 0 last)
                                                   (between? fz 0 last)
                                                   (sectors-index self fx fy fz)))
                                          (ti (sectors-index self tx ty tz)))
                                      (let ((sector (vector-ref sectors ti)))
                                        (when sector
                                          ;; free
                                          (sector-free sector)))
                                      (if fi
                                          (begin
                                            ;; move
                                            (vector-set! sectors ti (vector-ref sectors fi))
                                            (vector-set! sectors fi #f))
                                        ;; new
                                        (vector-set! sectors ti (sector-new (+ a tx) (+ b ty) (+ c tz))))))))))))))
      ;; update neighbors
      (update-eye-neighbors self distance)
      (set! eye-index (copy-index index))
      eye-neighbors))
  
  
  (method (update-eye-neighbors self distance <fx>)
    (let ((sectors eye-sectors)
          (neighbors eye-neighbors)
          (n 0))
      (define (set i j k)
        (vector-set! neighbors n (vector-ref sectors (sectors-index self (+ i distance) (+ j distance) (+ k distance))))
        (increase! n))
      
      ;; set neighbors in expanding distance from eye
      (set 0 0 0)
      (loop (for radius from 1 to distance)
            (let ((radius-1 (- radius 1)))
              ;; left
              (let ((i (- radius)))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; right
              (let ((i radius))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; bottom
              (let ((j (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; top
              (let ((j radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; back
              (let ((k (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))
              ;; front
              (let ((k radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (increase-sectors-generating self count <fx>)
    (mutex-lock! sectors-mutex)
    (set! sectors-generating (+ sectors-generating count))
    (mutex-unlock! sectors-mutex))
  
  
  (method package (decrease-sectors-generating self count <fx>)
    (mutex-lock! sectors-mutex)
    (set! sectors-generating (- sectors-generating count))
    (mutex-unlock! sectors-mutex))
  
  
  (method package (increase-sectors-generated self)
    (mutex-lock! sectors-mutex)
    (set! sectors-generated (+ sectors-generated 1))
    (mutex-unlock! sectors-mutex))
  
  
  (method (compute-floats self)
    (let ((total 0))
      (iterate-sectors self
        (lambda (sector)
          (let ((mesh (get-mesh sector)))
            (when mesh
              (let ((floats (count-floats mesh)))
                (when floats
                  (increase! total floats)))))))
      total))
  
  
  (method package (count-laden-sectors self)
    (let ((total 0))
      (iterate-sectors self
        (lambda (sector)
          (let ((mesh (get-mesh sector)))
            (when mesh
              (increase! total)))))
      total))
  
  
  (method package (toggle-debug-sectors self)
    (let ((world (current-world)))
      (set! debug-sectors? (not debug-sectors?))
      (update-parameter world 'debug-sectors)))
  
  
  (method package (draw-debug-sectors self)
    (draw-3d-grid (element-section-index self (current-me)) sector-size))
  
  
  ;;;
  ;;;; Areas
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-areas self)
    ;; temporary simplification by having processor retain everything
    (set! areas (make-table test: equal? weak-values: #f @wait-client-caching-chunks (not (serving?)))))
  
  
  (method (element-area-index self element <Element>) <index>
    (position-area-index self (get-position element)))
  
  
  (method package (position-area-index self pos <vertex>) <index>
    (let ((size (cast <fl> area-size)))
      (indexed (fxfloor (/ (vertex-x pos) size))
               (fxfloor (/ (vertex-y pos) size))
               (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method (element-area self element) <Area>
    (let ((index (element-area-index self element)))
      (indexed-area self (index-x index)
                    (index-y index)
                    (index-z index))))
  
  
  (method package (indexed-area self x <fx> y <fx> z <fx>) <Area>
    (let ((index (make-index&)))
      (index-x-set! index (fxfloor/ (* x area-size) section-size))
      (index-y-set! index (fxfloor/ (* y area-size) section-size))
      (index-z-set! index (fxfloor/ (* z area-size) section-size))
      (let ((area
              (or (table-ref areas index #f)
                  (let ((index (copy-index index)))
                    (let ((area (new Area index (index-expanse self index))))
                      (table-set! areas index area)
                      area)))))
        (update-physical area)
        area)))
  
  
  ;; PLANETS
  (method package (index-area self index <index> (update? #t)) <Area>
    (let ((area
            (or (table-ref areas index #f)
                (let ((index (copy-index index)))
                  (let ((area (new Area index (index-expanse self index))))
                    (table-set! areas index area)
                    area)))))
    (when update?
      (update-physical area))
    area))
  
  
  (method (find-area self index) <Area+>
    (table-ref areas index #f))
  
  
  (method (unlink-area self index)
    (table-clear areas index))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (iterate-areas self proc)
    @convert^^^
    (iterate-table areas
      proc))
  
  
  ;; putting area-cube here is a quicky to test travel-ray-polygons&
  (method package (iterate-position-neighbor-areas self pos distance <fx> area-cube proc)
    (if (and area-cube (<= distance (get-cube-radius area-cube)))
        (iterate-neighbor-areas area-cube pos distance proc)
      (let ((index (position-area-index self pos)))
        (let ((a (index-x index))
              (b (index-y index))
              (c (index-z index)))
          (loop (for i from (- distance) to distance)
                (loop (for j from (- distance) to distance)
                      (loop (for k from (- distance) to distance)
                            (let ((a (+ a i))
                                  (b (+ b j))
                                  (c (+ c k)))
                              (let ((area (indexed-area self a b c)))
                                (proc area
                                      (subarea-index area a b c)
                                      #t))))))))))
  
  
  (method (iterate-area-elements self area proc)
    (for-each proc (get-actors area))
    (for-each proc (get-entities area))
    (for-each proc (get-gadgets area)))
  
  
  (method (count-polygons self)
    0
    @convert^^^
    (let ((count 0))
      (iterate-table areas
        (lambda (index area)
          (let ((polygons (get-polygons area)))
            (when polygons
              (increase! count (fxround/ (f64vector-length polygons) polygon-float-size))))))
      count))
  
  
  (method package (toggle-debug-areas self)
    (let ((world (current-world)))
      (set! debug-areas? (not debug-areas?))
      (update-parameter world 'debug-areas)))
  
  
  (method package (draw-debug-areas self)
    (draw-3d-grid (element-area-index self (current-me)) area-size))
  
  
  ;;;
  ;;;; Expanses
  ;;;
  
  
  (method (setup-expanses self)
    ;; temporary simplification by having processor retain everything
    (set! expanses (make-table test: equal? weak-values: #f @wait-client-caching-chunks (not (serving?)))))
  
  
  (method (index-expanse self index <index>) <Expanse>
    (or (table-ref expanses index #f)
        (let ((index (copy-index index)))
          (let ((expanse (new Expanse)))
            (table-set! expanses index expanse)
            expanse))))
  
  
  (method (element-expanse self element)
    (index-expanse self (element-section-index self element)))
  
  
  ;;;
  ;;;; Gadget
  ;;;
  
  
  (method (draw-gadgets self)
    (for-each (lambda (gadget)
                (register-entity gadget #t))
              gadgets))
  
  
  (method (draw-drawable-gadgets self)
    (for-each (lambda (gadget)
                (when (and (renderable? gadget)
                           (get-visible? gadget))
                  (register-entity gadget)))
              gadgets))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (method package (render-task self task <Task>)
    (render-task (current-world) task))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method package (find-player self name)
    (find-if (lambda (player)
               (equal? (get-name player) name))
             players))
  
  
  (method package (resurrect-player self player)
    (let ((new-position (find-spawnpoint self)))
      (set-position player new-position)
      (set-velocity player (vertex 0. 0. 0.))
      (set-fall-velocity player (vertex 0. 0. 0.))
      (verify-water player)))
  
  
  (method package virtual (player-task self task <Task>)
    (player-task (current-world) task))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method package virtual (missile-task self task <Task>)
    (missile-task (current-world) task))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method package (tick-task self task <Task>)
    (tick-task (current-world) task))
  
  
  ;;;
  ;;;; Actors
  ;;;
  
  
  (method package (actors-task self task <Task>)
    (actors-task (current-world) task))
  
  
  ;;;
  ;;;; Sun
  ;;;
  
  
  (method (sun-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (if (not sun?)
              (task-wait task +infinity 0. exit)
            (let (iter (previous (current-monotonic)))
              (let ((time (current-monotonic)))
                (let ((elapse (- time previous)))
                  (with-task-mutex
                    (lambda ()
                      (unless (get-paused? history)
                        (unless (stopping? task)
                          (tick-sun self elapse)))))
                  (let ((duration (- (current-monotonic) time)))
                    (task-wait task sun-period duration exit))
                  (iter time)))))))))
  
  
  (method (tick-sun self elapse)
    (site (sun)
      (position-sun self elapse)))
  
  
  (method package (position-sun self elapse (angle: angle #f))
    (define (calculate-angle)
      (flmodulo (+ sun-angle (* (sun-speed) elapse)) PI*2))
    
    (define (sun-speed)
      (if (not day-duration)
          0.
        (/ PI*2 day-duration)))
    
    (set! sun-angle (or angle (calculate-angle)))
    (when (window?)
      (let ((under-limit 0.1)
            (direction (rotate-vertex-upon& PI/4 (vertex 0.0 1.0 0.0) (rotate-vertex-upon& sun-angle (vertex 0.0 0.0 -1.0) (vertex -1. 0. 0.)))))
        (let ((pos (vertex-scalar*& direction 1000.)))
          (when (not sun)
            (set! sun (new Sun parent: self position: pos))
            (add-element self sun))
          (cond ((or (< sun-angle (+ PI under-limit))
                     (> sun-angle (- PI*2 under-limit)))
                 (let ((coord (vertex-scalar* direction 1000.))
                       (under (cond ((> sun-angle (- PI*2 under-limit)) (- PI*2 sun-angle))
                                    ((and (> sun-angle PI) (< sun-angle (+ PI under-limit))) (- sun-angle PI))
                                    (else 0.))))
                   (let ((intensity (- 1.0 (/ under under-limit))))
                     (let ((effective (dye (* (dye-red sun-color) intensity)
                                           (* (dye-green sun-color) intensity)
                                           (* (dye-blue sun-color) intensity)
                                           1.0)))
                       (set-sun-effective lighting effective)
                       (set-sun-coordinates lighting coord)
                       (set-position-noupdate sun pos)
                       (set-color sun effective)
                       (set-visible? sun #t)))))
                (else
                 (set-sun-effective lighting (dye 0. 0. 0. 0.))
                 (set-visible? sun #f))))))
    (sun-update self))
  
  
  (method (sun-update self)
    (set-daytime self (sun-angle->daytime self sun-angle)))
  
  
  (method (register-sun self)
    (register-entity sun))
  
  
  ;;;
  ;;;; Daytime
  ;;;
  
  
  (method package (goto-daytime self daytime)
    (if sun?
        (position-sun self #f angle: (daytime->sun-angle self daytime))
      (set-daytime self daytime)))
  
  
  (method package (sun-angle->daytime self sun-angle)
    (let ((angle (flmodulo sun-angle PI*2)))
      (flmodulo (+ (/ (* angle day-span) PI*2) dawn-daytime) day-span)))
  
  
  (method package (daytime->sun-angle self daytime)
    (/ (* (- daytime dawn-daytime) PI*2) day-span))
  
  
  (method package (effective-daytime self daytime)
    (cond ((flonum? daytime) daytime)
          ((integer? daytime) (cast <fl> daytime))
          ((or (eq? daytime 'default) (ci=? daytime "default")) dawn-daytime)
          ((or (eq? daytime 'dawn) (ci=? daytime "dawn")) dawn-daytime)
          ((or (eq? daytime 'day) (ci=? daytime "day")) day-daytime)
          ((or (eq? daytime 'dusk) (ci=? daytime "dusk")) dusk-daytime)
          ((or (eq? daytime 'night) (ci=? daytime "night")) night-daytime)
          ((string? daytime) (cast <fl> (string->number daytime)))
          (else (error "Invalid daytime: {s}" daytime))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method (gravity-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history))
          (universe (current-universe)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-monotonic)))
            (let ((time (current-monotonic)))
              (let ((elapse (- time previous)))
                (with-task-mutex
                  (lambda ()
                    (unless (get-paused? history)
                      (unless (stopping? task)
                        (let ((blocks (get-fall-blocks universe)))
                          (unless (queue-empty? blocks)
                            (set-fall-blocks universe (new-queue))
                            (tick-gravity self elapse blocks)))))))
                (task-wait task gravity-period (- (current-monotonic) time) exit)
                (iter time))))))))
  
  
  (method (tick-gravity self elapse blocks)
    (site (gravity)
      (blocks-fall self elapse blocks)))
  
  
  (method (blocks-fall self elapse blocks)
    (let ((universe (current-universe)))
      (updating-sections self
        (lambda (add-section)
          (let (iter)
            (unless (queue-empty? blocks)
              (bind (section . index) (dequeue blocks)
                (bind-index (i j k) index
                  (call-with-section self section i j k
                    (lambda (section block <fx> data <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                      (define (effective-block-ref i j k)
                        (with-field i j k
                          (lambda (section index)
                            (if section
                                (block-ref section index)
                              0))))
                      
                      (define (add-neighbors i j k)
                        (define (add-neighbor i j k)
                          (with-field i j k
                            (lambda (section index)
                              @w(when (id? (block-ref section index) SandBlock Gravel)
                                  (normalize-section/coordinates section i j k with-field
                                    (lambda (section i j k)
                                      (add-fall-block universe section i j k))))
                              ;; EH validate
                              (when section
                                (add-section section)))))
                        
                        (add-neighbor (+ i 1) j k)
                        (add-neighbor (- i 1) j k)
                        (add-neighbor i (+ j 1) k)
                        (add-neighbor i (- j 1) k)
                        (add-neighbor i j (+ k 1))
                        (add-neighbor i j (- k 1)))
                      
                      (when (and (id? block SandBlock Gravel) (id? (effective-block-ref i (- j 1) k) Air Water StationaryWater Lava StationaryLava))
                        (with-field i j k
                          (lambda (section index)
                            (block-set! section index 0)
                            (add-neighbors i j k)
                            (inverse-propagate-light universe i j k add-section with-field block-ref blocklight-ref blocklight-set!)
                            (redstone-update section (list i j k block) add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!))))))))
              (iter))))
        delay-update?: #t)))
  
  
  ;;;
  ;;;; Distance
  ;;;
  
  
  (method (distance-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-monotonic)))
            (let ((time (current-monotonic)))
              (let ((elapse (- time previous)))
                (with-task-mutex
                  (lambda ()
                    (unless (get-paused? history)
                      (unless (stopping? task)
                        (tick-distance self elapse)))))
                (let ((duration (- (current-monotonic) time)))
                  (task-wait task distance-period duration exit))
                (iter time))))))))
  
  
  (method (tick-distance self elapse)
    (site (distance)
      (let ((me (current-me)))
        (check-distance self elapse me))))
  
  
  (method (check-distance self elapse me)
    (let ((world (current-world)))
      (let ((chest (get-opened-chest self))
            (creatures (get-aggroed-creatures me))
            (pos (get-position me)))
        ;; water
        (verify-water me)
        ;; chest
        (when chest
          (bind (section index coordinates) chest
            (let ((location (section/coordinates->location section coordinates)))
              (let ((dist (vertex-distance (vertex (+ (index-x location) .5)
                                                   (+ (index-y location) .5)
                                                   (+ (index-z location) .5))
                                           pos)))
                (when (> dist interaction-distance)
                  (play-ambient-sound "minecraft/random/chestclosed" volume: .5)
                  (hide-chest world)
                  (hide-bag world)
                  (set-opened-chest self #f))))))
        ;; aggro
        (when creatures
          (for-each (lambda (creature)
                      (when (> (vertex-distance pos (get-position creature)) (get-aggro-radius creature))
                        (set-aggro-target creature #f)
                        (set! creatures (remove! creature creatures test: equal?))))
                    creatures))
        (set-aggroed-creatures me creatures))))
  
  
  ;;;
  ;;;; Eat
  ;;;
  
  
  (method (eat-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (with-task-mutex
              (lambda ()
                (unless (get-paused? history)
                  (unless (stopping? task)
                    (tick-eat self task exit)))))
            (task-wait task eat-period 0. exit)
            (iter))))))
  
  
  (method (tick-eat self task exit)
    (site (eat)
      (let ((interface (current-interface+))
            (me (current-me)))
        (let ((eating (get-eating me)))
          (when eating
            (let ((eating-ticks (get-eating-ticks me)))
              (set-life me (min (+ (get-life me) eating) 100.))
              (when interface
                (invalidate-view (child interface 'combat)))
              (let ((eating-ticks (- (get-eating-ticks me) 1)))
                (if (> eating-ticks 0)
                    (set-eating-ticks me eating-ticks)
                  (set-eating me #f)
                  (set-eating-ticks me #f)))))))))
  
  
  ;;;
  ;;;; Day
  ;;;
  
  
  (method (set-daytime self time)
    (set! daytime time)
    (set! daylight (daytime->daylight self time))
    ;; not sure
    (setup-lighting self))
  
  
  (method (daytime->daylight self daytime)
    (cond ;; night
          ((< daytime 6000.)
           0.)
          ;; dawn
          ((< daytime 9000.)
           (/ (- daytime 6000.) 3000.))
          ;; day
          ((< daytime 18000.)
           1.)
          ;; dusk
          ((< daytime 21000.)
           (/ (- 21000. daytime) 3000.))
          ;; night
          (else
           0.)))
  
  
  ;;;
  ;;;; Lighting
  ;;;
  
  
  (method package (setup-lighting self)
    (let ((world (current-world)))
      (let ((light (max .1 (/ daylight 5.))))
        (set-ambient-color lighting (dye (+ (dye-red ambient-color) light)
                                         (+ (dye-green ambient-color) light)
                                         (+ (dye-blue ambient-color) light)
                                         1.0)))
      @old!?
      (cond (sun?
             (set-sun-effective lighting sun-color)
             (set-sun-coordinates lighting (vertex 10000.0 10000.0 10000.0)))
            (else
             (set-sun-effective lighting (dye 0. 0. 0. 0.))
             (set-sun-coordinates lighting (vertex 0. 0. 0.))))
      (set-current-lighting lighting)))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method public (iterate-gravities self proc)
    (for-each proc gravities))
  
  
  (method public (iterate-planets self proc)
    (iterate-gravities self
      (lambda (well)
        (when (is? well Planet)
          (proc well)))))
  
  
  (method public (collect-planets self)
    (let ((queue (new-queue)))
      (iterate-planets self
        (lambda (planet)
          (enqueue queue planet)))
      (queue-list queue)))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method package (reset-marks self)
    (set! marks '()))
  
  
  (method (set-marks self lst)
    (set! marks lst))
  
  
  (method (set-mark self mark)
    (set! marks (list mark)))
  
  
  (method package (add-mark self mark)
    (set! marks (cons mark marks)))
  
  
  (method package (remove-mark self mark)
    (set! marks (remove! mark marks)))
  
  
  (method (draw-marks self)
    (for-each (lambda (mark)
                (when (is-not? mark world.mark:Polygon-Mark)
                  (draw mark)))
              marks)
    (for-each (lambda (mark)
                (when (is? mark world.mark:Polygon-Mark)
                  (draw mark)))
              marks))
  
  
  (method package (reset-all-marks self)
    (let ((world (current-world)))
      (reset-marks self)
      (display-message world "Marks reset")))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method package virtual (zone-editable? self)
    editable?)
  
  
  (method package virtual (zone-destructible? self)
    #f)
  
  
  ;;;
  ;;;; Atlas
  ;;;
  
  
  (method (draw-atlas self)
    @convert-effective-material
    (let ((world (current-world)))
      (unless texture-arrays?
        (let ((texture (get-texture (let ((elem (first-target world)))
                                      (if (is? elem Entity)
                                          (effective-material elem)
                                        (get-block-atlas world)))))
              (width 100.)
              (height 100.))
          (map-texture texture)
          (textured-quad texture
            (lambda () (glVertex3f 0.0 0.0 0.0))
            (lambda () (glVertex3f width 0.0 0.0))
            (lambda () (glVertex3f width height 0.0))
            (lambda () (glVertex3f 0.0 height 0.0)))))))
  
  
  ;;;
  ;;;; Heightmap
  ;;;
  
  
  ;; gambit30 quicky to pass sector and area
  (method (generate-heightmap-old self sector/area heightmap <f32vector> from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (define (generate-done sector)
      (set-visual-uptodate? sector #t)
      (set-visual-revision sector (get-revision generator))
      (set-visual-generating? sector #f)
      (decrease-sectors-generating self 1))
    
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1))
          (x-base (cast <fl> from-x))
          (z-base (cast <fl> from-z)))
      (let ((count (f32vector-length heightmap)))
        (let ((vertices (make-vector count))
              (normals (make-vector count)))
          (define (get-vertex x <fx> z <fx>)
            (vector-ref vertices (+ (* x z-count) z)))
          
          (define (normal-ref x <fx> z <fx>)
            (vector-ref normals (+ (* x z-count) z)))
          
          ;; fill vertices
          (loop (for x from 0 below x-count)
                (loop (for z from 0 below z-count)
                      (let ((index (+ (* x z-count) z)))
                        (let ((height (f32vector-ref heightmap index)))
                          (let ((x (cast <fl> (+ from-x x)))
                                (y (cast <fl> height))
                                (z (cast <fl> (+ from-z z))))
                            (vector-set! vertices index (vertex (- x x-base) y (- z z-base)))
                            (vector-set! normals index (vertex 0. 0. 0.)))))))
          ;; add triangles
          (let ((squares (make-vector (* width depth)))
                (faces '())
                (areas (make-table test: equal?))
                (default-image (get-default-image world)))
            (let ((material (get-material-opaque world))
                  (uv (image-rect (get-block-atlas world) default-image)))
              (let ((tl (uv-left uv))
                    (tt (uv-top uv))
                    (tr (uv-right uv))
                    (tb (uv-bottom uv))
                    (texture-depth (uv-depth uv)))
                (define (safe-square x <fx> z <fx>)
                  (and
                    (>= x 0) (< x width)
                    (>= z 0) (< z depth)
                    (get-square x z)))
                
                (define (get-square x <fx> z <fx>)
                  (vector-ref squares (+ (* x depth) z)))
                
                (define (set-square x <fx> z <fx> square)
                  (vector-set! squares (+ (* x depth) z) square))
                
                (define (make-square t1 t2)
                  (cons t1 t2))
                
                (define (square-t1 square) <Smooth-Triangle>
                  (get-polygon (cast <Face> (car square))))
                
                (define (square-t2 square) <Smooth-Triangle>
                  (get-polygon (cast <Face> (cdr square))))
                
                (define (add-face face)
                  (set! faces (cons face faces))
                  (when (eq? what 'physical)
                    (let ((poly (get-polygon face)))
                      (let ((center (get-center poly)))
                        (let ((index (position-index sector/area center)))
                          (table-add areas index poly))))))
                
                (define (add-triangle v1 v2 v3)
                  (let ((normal (plane-normal v1 v2 v3)))
                    (let ((face
                            (if (> (vertex-x v1) (vertex-x v2))
                                (make-face material
                                           (f32vector tl tb tr tb tr tt)
                                           texture-depth
                                           (make-smooth-triangle self
                                                                 v1 v2 v3
                                                                 normal normal normal))
                              (make-face material
                                         (f32vector tr tt tl tt tl tb)
                                         texture-depth
                                         (make-smooth-triangle self
                                                               v1 v2 v3
                                                               normal normal normal)))))
                      (add-face face)
                      face)))
                
                ;; add triangles
                (loop (for x from 0 below width)
                      (loop (for z from 0 below depth)
                            (let ((v1 (get-vertex x (+ z 1)))
                                  (v2 (get-vertex (+ x 1) (+ z 1)))
                                  (v3 (get-vertex (+ x 1) z))
                                  (v4 (get-vertex x z)))
                              (let ((triangle1 (add-triangle v1 v2 v3))
                                    (triangle2 (add-triangle v3 v4 v1)))
                                (set-square x z (make-square triangle1 triangle2))))))
                ;; smooth normals
                (loop (for x from 0 below x-count)
                      (loop (for z from 0 below z-count)
                            (let ((normal (normal-ref x z))
                                  (tl (safe-square (- x 1) (- z 1)))
                                  (tr (safe-square x (- z 1)))
                                  (bl (safe-square (- x 1) z))
                                  (br (safe-square x z)))
                              (when tl
                                (vertex-increase! normal (get-normal (square-t1 tl))))
                              (when tr
                                (vertex-increase! normal (get-normal (square-t1 tr)))
                                (vertex-increase! normal (get-normal (square-t2 tr))))
                              (when bl
                                (vertex-increase! normal (get-normal (square-t1 bl)))
                                (vertex-increase! normal (get-normal (square-t2 bl))))
                              (when br
                                (vertex-increase! normal (get-normal (square-t2 br))))
                              (vertex-normalize! normal normal))))
                ;; update normals
                (loop (for x from 0 below width)
                      (loop (for z from 0 below depth)
                            (let ((square (get-square x z)))
                              (set-n1 (square-t1 square) (normal-ref x (+ z 1)))
                              (set-n2 (square-t1 square) (normal-ref (+ x 1) (+ z 1)))
                              (set-n3 (square-t1 square) (normal-ref (+ x 1) z))
                              (set-n1 (square-t2 square) (normal-ref (+ x 1) z))
                              (set-n2 (square-t2 square) (normal-ref x z))
                              (set-n3 (square-t2 square) (normal-ref x (+ z 1))))))
                (case what
                  ((physical)
                   (let ((area sector/area))
                     ;; PLANETS quick inefficient try
                     (let ((matrix (make-translation-matrix (vertex x-base 0. z-base))))
                       (iterate-table areas
                         (lambda (index polygons)
                           (add-polygons area #f index polygons matrix))))))
                  ((visual)
                   (let ((sector sector/area))
                     (bind-values (vertices neighbors) (prepare-vertices/neighbors sector faces)
                       (let ((lightmap (prepare-lightmap sector faces)))
                         (with-render-mutex
                           (lambda ()
                             (free-material-mesh sector)
                             (setup-material-mesh sector)
                             (let ((mesh (get-material-mesh sector)))
                               (fill-vertices/neighbors sector mesh #f vertices neighbors)
                               (fill-lightmap sector mesh #f lightmap)
                               (setup-array mesh))
                             (generate-done sector/area)))))))))))))))
    
  
  ;;;
  ;;;; Level
  ;;;

  
  (method protected (get-level-file self)
    (or level-file
        (let ((file (new-file level-dir "level.dat")))
          (set! level-file file)
          file)))
  
  
  (method public (get-level-state self)
    (or level-state
        (let ((state (read/create-level self)))
          (set! level-state state)
          state)))
  
  
  (method (read/create-level self)
    (let ((file (get-level-file self)))
      (if (exists? file)
          (read-level self file)
        (create-level self))))
  
  
  (method (read-level self file)
    (with ((reader <NBT-Reader> (new NBT-Reader file compressed?: #t gzip?: #t)))
      (read-tag reader)))
  
  
  (method (create-level self)
    (let ((spawnpoint (or start-spawnpoint (vertex 0. 50. 0.))))
      (make-tag "" TAG_Compound
        (list
          (make-tag "Data" TAG_Compound
            (list
              (make-tag "Player" TAG_Compound
                (list
                  (make-tag "Inventory" TAG_List (make-list-payload TAG_Compound '()))))
              (make-tag "SpawnX" TAG_Int (fxround (vertex-x spawnpoint)))
              (make-tag "SpawnY" TAG_Int (fxround (vertex-y spawnpoint)))
              (make-tag "SpawnZ" TAG_Int (fxround (vertex-z spawnpoint)))
              (make-tag "LevelName" TAG_String "New")
              (make-tag "version" TAG_Int 19133)))))))
  
  
  (method public (save-level-state self)
    (save-level self (get-level-state self) (get-level-file self)))
  
  
  (method (save-level self level file)
    (create-directories file)
    (with ((writer (new NBT-Writer file compressed?: #t gzip?: #t)))
      (write-tag writer level)))
  
  
  (method package (find-spawnpoint self)
    (or (get-player-spawnpoint self)
        (get-spawnpoint self)))
  
  
  (method package (find-spawnlookat self)
    (make-standard-lookat))
  
  
  (method package (get-spawnpoint self)
    (let ((tag (get-level-state self)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-assoc "SpawnX" compound))
              (y (tag-assoc "SpawnY" compound))
              (z (tag-assoc "SpawnZ" compound)))
          (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z))))))
  
  
  (method package (set-spawnpoint self pos)
    (let ((tag (get-level-state self)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-find "SpawnX" compound))
              (y (tag-find "SpawnY" compound))
              (z (tag-find "SpawnZ" compound)))
          (tag-set x (fxround (vertex-x pos)))
          (tag-set y (fxround (vertex-y pos)))
          (tag-set z (fxround (vertex-z pos)))))))
  
  
  (method package (get-player-spawnpoint self)
    (let ((tag (get-level-state self)))
      (let ((player (tag-assoc "Player" (tag-assoc "Data" (tag-value tag)))))
        (let ((x (tag-assoc "SpawnX" player))
              (y (tag-assoc "SpawnY" player))
              (z (tag-assoc "SpawnZ" player)))
          (and x y z (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z)))))))
  
  
  (method package (set-player-spawnpoint self pos)
    (let ((tag (get-level-state self)))
      (let ((player (tag-find "Player" (tag-assoc "Data" (tag-value tag)))))
        (tag-add player "SpawnX" TAG_Int (fxround (vertex-x pos)))
        (tag-add player "SpawnY" TAG_Int (fxround (vertex-y pos)))
        (tag-add player "SpawnZ" TAG_Int (fxround (vertex-z pos))))))
  
  
  (method package (teleport self pos (sight #f))
    (let ((world (current-world))
          (me (current-me)))
      (let ((eye (get-eye world)))
        (person-motion world feedback?: #f)
        (set-position me pos)
        (cond ((not sight)
               (derive-target eye)
               (camera-update eye))
              (else
               (set-lookat me (horizon-lookat sight))
               (eye-behind-player world)
               (follow-player world))))))
  
  
  (method (explode-blocks self tnts blocks)
    (play-ambient-sound "minecraft/random/explode" volume: .25)
    (updating-sections self
      (lambda (add-section)
        (for-each (lambda (tnt)
                    (remove-block! self tnt add-section))
                  tnts)
        (for-each (lambda (block)
                    (remove-block! self block add-section)) blocks))
      delay-update?: #t))
  
  
  (method (reveal-chests self command-block blocks)
    (updating-sections self
      (lambda (add-section)
        (loop (for x from 0 below (fxceiling (/ (length blocks) 6.)))
              (let ((pos (random-element blocks)))
                (set! blocks (remove pos blocks test: equal?))
                (place-block! self pos RedstoneTorchOn add-section)))
        (remove-block self (car command-block) add-section))))
  
  
  (method (testfor-action self command-block test action)
    (call-with-position self (car test)
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (when (= block-id (cdr test))
          (updating-sections self
            (lambda (add-section)
              (case (cdr action)
                ((remove) (remove-block self (car action) add-section))
                ((delete) (remove-block! self (car action) add-section))
                ((add)    (place-block! self (caar action) (cdar action) add-section)))
              (remove-block self (car command-block) add-section)))))))
  
  
  (method (remove-block self pos add-section)
    (call-with-position self pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (with-field i j k
          (lambda (section index)
            (add-section section)
            (block-set! section index 0)
            (data-set! section index 0))))))
  
  
  (method (remove-block! self pos add-section)
    (call-with-position self pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (delete-block (current-universe) #f section block-id data-id i j k x y z add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (place-block! self pos block add-section)
    (call-with-position self pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (add-block (current-universe) #f #f #f block #f section block-id data-id i j k x y z add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (on-toggle-glow self evt)
    (let ((world (current-world)))
      (if (= player-glow -1.)
          (set! player-glow 5.)
        (set! player-glow -1.))
      (update-parameter world 'glow)))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method package (call-with-position self pos <vertex> proc (create?: create? #t))
    (let ((section (position-section self pos create?: create?)))
      (and section
           (let ((x (fxfloor (vertex-x pos)))
                 (y (fxfloor (vertex-y pos)))
                 (z (fxfloor (vertex-z pos))))
             (let ((section-index (get-index section)))
               (let ((section-x (index-x section-index))
                     (section-y (index-y section-index))
                     (section-z (index-z section-index)))
                 (let ((i (- x (* section-x 16)))
                       (j (- y (* section-y 16)))
                       (k (- z (* section-z 16))))
                   (call-with-section self section i j k proc))))))))
  
  
  (method package (call-with-section self section i <fx> j <fx> k <fx> proc)
    (with-index section
      (lambda (section-x section-y section-z)
        (let ((region (get-region (get-chunk section))))
          (let ((region-x (get-x region))
                (region-z (get-z region))
                (chunk-x (section->chunk section-x))
                (chunk-z (section->chunk section-z))
                (sections (neighbor-sections section section-x section-y section-z)))
            (let ((bottom-section? (= section-y (cast <fx> (or truncate-y 0))))
                  (position-x (+ (* region-x 32 16) (* chunk-x 16) i))
                  (position-y (+ (* section-y 16) j))
                  (position-z (+ (* region-z 32 16) (* chunk-z 16) k))
                  (blocks (get-blocks section))
                  (data (get-data section))
                  (blocklight (get-blocklight section))
                  (skylight (get-skylight section)))
              (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                (vector-ref sections (section-index a b c)))
              
              (define (section-index a <fx> b <fx> c <fx>) <fx>
                (+ (* b 9) (* c 3) a 13))
              
              (define (local-index i <fx> j <fx> k <fx>) <fx>
                (+ (* j 256) (* k 16) i))
              
              (define (block-ref section local-index <fx>) <fx>
                (u8vector-ref (cast <u8vector> (get-blocks section)) local-index))
              
              (define (block-set! section local-index <fx> block-id <fx>)
                (u8vector-set! (cast <u8vector> (get-blocks section)) local-index block-id))
              
              (define (data-ref section local-index <fx>) <fx>
                (u4vector-ref (cast <u8vector> (get-data section)) local-index))
              
              (define (data-set! section local-index <fx> data-id <fx>)
                (u4vector-set! (cast <u8vector> (get-data section)) local-index data-id))
              
              (define (blocklight-ref section local-index <fx>) <fx>
                (u4vector-ref (cast <u8vector> (get-blocklight section)) local-index))
              
              (define (blocklight-set! section local-index <fx> blocklight <fx>)
                (u4vector-set! (cast <u8vector> (get-blocklight section)) local-index blocklight))
              
              (define (skylight-ref section local-index <fx>) <fx>
                (u4vector-ref (cast <u8vector> (get-skylight section)) local-index))
              
              (define (skylight-set! section local-index <fx> skylight <fx>)
                (u4vector-set! (cast <u8vector> (get-skylight section)) local-index skylight))
              
              (define (u4vector-ref field <u8vector> index <fx>) <fx>
                (let ((byte (u8vector-ref field (quotient index 2))))
                  (if (even? index)
                      (bitwise-and byte #x0F)
                    (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
              
              (define (u4vector-set! field <u8vector> index <fx> value <fx>)
                (let ((offset (quotient index 2)))
                  (let ((byte (u8vector-ref field offset)))
                    (u8vector-set! field offset
                      (if (even? index)
                          (bitwise-ior value (bitwise-and byte #xF0))
                        (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4)))))))
              
              (define (with-field i <fx> j <fx> k <fx> proc)
                (define (bind-i a <fx> i <fx>)
                  (define (bind-j b <fx> j <fx>)
                    (define (bind-k c <fx> k <fx>)
                      (let ((section (section-ref a b c)))
                        (proc section (local-index i j k))))
                    
                    (cond ((< k 0) (bind-k (- (quotient k 16) 1) (modulo k 16)))
                          ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                          (else (bind-k 0 k))))
                  
                  (cond ((< j 0) (bind-j (- (quotient j 16) 1) (modulo j 16)))
                        ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                        (else (bind-j 0 j))))
                
                (cond ((< i 0) (bind-i (- (quotient i 16) 1) (modulo i 16)))
                      ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                      (else (bind-i 0 i))))
              
              (let ((index (local-index i j k)))
                (let ((block-id (block-ref section index))
                      (data-id (data-ref section index)))
                  (let ((x (fl& (+ block-radius (cast <fl> position-x))))
                        (y (fl& (+ block-radius (cast <fl> position-y))))
                        (z (fl& (+ block-radius (cast <fl> position-z)))))
                    (proc section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))))))))
  
  
  (method package (updating-sections self proc (delay-update?: delay-update? #f))
    (define (update-sections sections)
      (for-each (lambda (section)
                  (let ((area (find-area self (get-index section))))
                    (when area
                      (clear-polygons area)
                      (set-physical-uptodate? area #f)))
                  ;; should iterate over every camera
                  (let ((eye-sector (find-eye-sector self (get-index section))))
                    (when eye-sector
                      (set-visual-uptodate? eye-sector #f)
                      (unless (and delay-update? delay-updating?)
                        (set-visual-generating? eye-sector #t) ;; $$$ was sector. is this correct?
                        (increase-sectors-generating self 1)
                        (instantiate-visual eye-sector))))
                  (modified (get-chunk section)))
                sections))
    
    (define (save-regions)
      (iterate-regions dimension
        (lambda (region)
          (save-region region))))
    
    (let ((sections '()))
      (define (add-section section)
        (unless (memq? section sections)
          (set! sections (cons section sections))))
      
      (let ((timer (new Timer)))
        (define (updating)
          (prog1 (proc add-section)
            (update-sections sections)
            (save-regions)))
        
        (prog1 (updating)
          (when report-updating?
            (let ((world (current-world)))
              (let ((count (length sections))
                    (duration (real-duration-in-milliseconds timer)))
                (display-message world (format "Updated {a} section{a} ({a}ms)" count (format-plural count) duration)))))))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method package (evaluate-zone-hook self forms syntax str container line col)
    (let ((ids (collect (lambda (form)
                          (and (pair? form) (eq? (car form) 'define-block)
                            (third form)))
                        forms)))
      (cond ((not-null? ids)
             (reset-inventory-blocks)
             @$$$
             (updating-sections
               (lambda (add-section)
                 (finding-visual-blocks ids
                   add-section)
                 (finding-physical-blocks ids
                   (lambda (area)
                     (add-section (get-section area)))))))
            @$$$
            ((search container "world/external/minecraft")
             (updating-sectors
               (lambda (add-sector)
                 (add-sector (element-sector (current-me)))))))))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  (method package (block-at self pos)
    (or (call-with-position self pos
          (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
            block-id)
          create?: #f)
        Air))
  
  
  (method package (block/data-at self pos)
    (call-with-position self pos
      (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (cons block-id data-id))
      create?: #f))
  
  
  (method (find-visual-blocks self ids)
    (let ((queue (new-queue)))
      (iterate-sectors self
        (lambda (sector)
          (sector-iterate-blocks self sector ids
            (lambda (found)
              (enqueue queue (cons sector (index->coordinates found)))))))
      (queue-list queue)))
  
  
  (method (finding-visual-blocks self ids proc)
    (iterate-sectors self
      (lambda (sector)
        (when (sector-contains-blocks? self sector ids)
          (proc sector)))))
  
  
  (method (sector-contains-blocks? self sector ids)
    (continuation-capture
      (lambda (found)
        (sector-iterate-blocks self sector ids
          (lambda (ignore)
            (continuation-return found #t)))
        #f)))
  
  
  (method (sector-iterate-blocks self sector ids proc)
    (let ((section (index-section self (get-index sector))))
      (when section
        (section-iterate-blocks self section ids proc))))
  
  
  (method package (section-iterate-blocks self section ids proc)
    (let ((blocks (get-blocks section)))
      (for-each (lambda (id)
                  (let (iter (pos 0))
                    (let ((found (u8vector-find id blocks (u8vector-length blocks) pos)))
                      (when found
                        (proc found)
                        (iter (+ found 1))))))
                ids)))
  
  
  (method (section-count-blocks self section)
    (let ((blocks (get-blocks section))
          (count 0))
      (loop (for n from 0 below 4096)
            (let ((block (u8vector-ref blocks n)))
              (when (/= block Air)
                (increase! count))))
      count))
  
  
  (method (finding-physical-blocks self ids proc)
    @convert^^^
    (iterate-areas
      (lambda (index area)
        (iterate-polygons area #f
          (lambda (env elem polygons offset)
            (let ((data1 (f64vector-ref polygons (+ offset 16))))
              (when (and (/= data1 0.) (memq? (flonum->fixnum data1) ids))
                (proc area)))))))))


;;;
;;;; Procedural Zones
;;;


(proclaim (warn optimizations))


;; Ideally, this would use a PRNG which we can seed with a given value.
;; That way the map can be persisted using just the seed and a list of changes.
(class Procedural-Zone extends Zone
  
  
  (property detail-level <fl> initialize 15. accessors generate)
  (property clamp-height <fl> initialize 65. accessors generate)
  
  
  (method override (setup-generator self)
    (set! generator (new Perlin-Generator detail-level: detail-level clamp-height: clamp-height)))
  
  
  (method override (zone-editable? self)
    (world-setting 'world.procedural-editable? #f))
  
  
  (method override (zone-destructible? self)
    (zone-editable? self))
  
  
  (method override (generate-visual self sector <Sector>)
    (let ((index (get-index sector)))
      (let ((x (index-x index))
            (y (index-y index))
            (z (index-z index)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural self sector from-x width from-z depth 'visual)))))
    (set-visual-uptodate? sector #t)
    (decrease-sectors-generating self 1))
  
  
  (method override (generate-physical self area revision-update?)
    (let ((index (get-index area)))
      (let ((x (index-x index))
            (y (index-y index))
            (z (index-z index)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural self area from-x width from-z depth 'physical))))))
  
  
  ;; gambit30 quicky to pass sector and area
  (method (generate-procedural self sector/area from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1)))
      (define (generator-heightmap)
        (let ((heightmap <f32vector> (make-f32vector (* x-count z-count))))
          (loop (for x from 0 below x-count)
                (loop (for z from 0 below z-count)
                      (f32vector-set! heightmap (+ (* x z-count) z)
                        ;; max and min are quick hacks until perlin generator is fixed
                        (max 0. (min 10. (/ (noise2 generator (cast <fl> (+ from-x x)) (cast <fl> (+ from-z z))) 5.))))))
          heightmap))
      
      (generate-heightmap-old self sector/area (generator-heightmap) from-x width from-z depth what)))))
