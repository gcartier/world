;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Zones
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.zone jazz


(import (jazz.component)
        (jazz.io)
        (jazz.geometry)
        (jazz.opengl.glew)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.view)
        (world)
        (world.actor)
        (world.album)
        (world.area)
        (world.atlas)
        (world.autoload)
        (world.block)
        (world.camera)
        (world.chunk)
        (world.client.tier)
        (world.configure)
        (world.context)
        (world.creature)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.entity)
        (world.entities)
        (world.expanse)
        (world.face)
        (world.foreign)
        (world.gadget)
        (world.generation)
        (world.generation.base)
        (world.generation.block)
        (world.generation.building)
        (world.generation.rendering)
        (world.geometry)
        (world.gravity)
        (world.grid)
        (world.history)
        (world.homogeneous)
        (world.id)
        (world.index)
        (world.info)
        (world.instantiate)
        (world.interface.bars)
        (world.interface.documents)
        (world.interface.inventory)
        (world.lava)
        (world.light)
        (world.lighting)
        (world.motion)
        (world.music)
        (world.network)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.profiling)
        (world.random)
        (world.redstone)
        (world.region)
        (world.render)
        (world.renderer)
        (world.scene)
        (world.scripter)
        (world.section)
        (world.sector)
        (world.settings)
        (world.skybox)
        (world.sound)
        (world.spawn)
        (world.sun)
        (world.support)
        (world.syntax (phase syntax))
        (world.tag)
        (world.task)
        (world.texture)
        (world.tier)
        (world.triangle)
        (world.water)
        (world.work))


;;;
;;;; Zone
;;;


(definition protected day-span <fl>
  24000.)

(definition protected dawn-daytime <fl>
  6000.)

(definition protected day-daytime <fl>
  12000.)

(definition protected dusk-daytime <fl>
  18000.)

(definition protected night-daytime <fl>
  0.)


(definition delay-updating? <bool>
  (world-setting 'world.delay-updating? #t))

(definition report-updating? <bool>
  (world-setting 'world.report-updating? #f))


(definition show-sections? <bool>
  (world-setting 'world.show-sections? #f))

(definition show-chunks? <bool>
  (world-setting 'world.show-chunks? #f))


(class Zone extends Scene
  
  
  (property title                   <string+>    initialize #f              accessors generate)
  (property start-mode              <symbol>     initialize #f              accessors generate)
  (property start-distance          <fl+>        initialize #f              accessors generate)
  (property start-spawnpoint        <vertex+>    initialize #f              accessors generate)
  ;; change default from #f to 0 for now and when we start using full 3d regions
  ;; put it back to #f and make it so minecraft zones have truncate-y = 0 by default
  (property truncate-y              <fx+>        initialize 0               accessors generate)
  (property missile-behavior        <symbol>     initialize 'destroy        accessors generate)
  (property ambient-color           <f32vector+> initialize #f              accessors generate)
  (property sun-color               <f32vector+> initialize #f              accessors generate)
  (property sun-cycle?              <bool>       initialize #t              accessors generate)
  (property day-duration            <object>     initialize 1200.           accessors generate)
  (property start-time              <object>     initialize 'day            accessors generate)
  (property start-skybox            <object>     initialize #f              accessors generate)
  (property atlas-name              <object>     initialize #f              accessors generate)
  (property prepare-script          <object>     initialize "zone/prepare"  accessors generate)
  (property enter-script            <object>     initialize "zone/enter"    accessors generate)
  (property exit-script             <object>     initialize "zone/exit"     accessors generate)
  (property draw-me?                <bool>       initialize #t              accessors generate)
  (property first-time?             <bool>       initialize #t              accessors generate)
  (property level-dir               <Directory>  initialize #f              accessors generate)
  (property dimension               <symbol>     initialize 'over           accessors generate)
  (property player-glow             <fl>         initialize -1.             accessors generate)
  (property seed                    <object>     initialize #f              accessors generate)
  (property properties              <object>     initialize '()             accessors generate)
  
  ;; world override properties
  (property ambient-gravity         <object>     initialize default-gravity accessors generate)
  (property jump-impulsion          <object>     initialize default-jump    accessors generate)
  (property start-grid?             <object>     initialize #f              accessors generate)
  (property start-axes?             <object>     initialize #f              accessors generate)


  (slot settings                    <object>     initialize #f                        getter generate)
  (slot regions-dir                 <Directory>  initialize #f                        getter explicit)
  (slot regions-mutex               <object>     initialize (make-mutex 'regions)     getter generate)
  (slot region-access-mutexes       <table>      initialize #f                        getter generate)
  (slot regions                     <table>      initialize #f                        getter generate)
  (slot debug-sections?             <bool>       initialize #f                        accessors generate)
  (slot sector-size                 <fx>         initialize 16                        getter generate)
  (slot sector-radius               <fl>         initialize #f                        getter generate)
  (slot sector-diameter             <fl>         initialize #f                        getter generate)
  (slot sector/area-ratio           <fx>         initialize #f                        getter generate)
  (slot sectors-generating          <fx>         initialize 0                         getter generate)
  (slot sectors-generated           <fx>         initialize 0                         getter generate)
  (slot sectors-mutex               <object>     initialize #f                        getter generate)
  (slot debug-sectors?              <bool>       initialize #f                        accessors generate)
  (slot areas                       <table>      initialize #f                        getter generate)
  (slot area-size                   <fx>         initialize 2                         getter generate)
  (slot debug-areas?                <bool>       initialize #f                        accessors generate)
  (slot expanses                    <table>      initialize #f                        getter generate)
  (slot assets                      <object>     initialize '()                       getter generate)
  (slot players                     <list>       initialize '()                       getter generate)
  (slot actors                      <list>       initialize '()                       getter generate)
  (slot entities                    <list>       initialize '()                       getter generate)
  (slot gravities                   <list>       initialize '()                       getter generate)
  (slot gadgets                     <list>       initialize '()                       getter generate)
  (slot panes                       <list>       initialize '()                       getter generate)
  (slot marks                       <list>       initialize '()                       getter generate)
  (slot simulations                 <table>      initialize (make-table test: eq?)    getter generate)
  (slot generator                   <Generator>  initialize #f                        accessors generate)
  (slot draw-procedures             <object>     initialize '()                       getter generate)
  (slot draw-procedure-names        <object>     initialize #f                        getter generate)
  (slot destroy-hooks               <list>       initialize '()                       getter generate)
  (slot ready?                      <bool>       initialize #f                        accessors generate)
  (slot editable?                   <bool>       initialize #t                        accessors generate)
  (slot editable-warned?            <bool>       initialize #f                        accessors generate)
  (slot generate-thread             <object>     initialize #f                        accessors generate)
  (slot lighting                    <Lighting>   initialize (new Lighting)            accessors generate)
  (slot block-lighting              <Lighting>   initialize (new Lighting)            accessors generate)
  (slot daytime                     <fl>         initialize 0.                        getter generate)
  (slot daylight                    <fl>         initialize 0.                        accessors generate)
  (slot sun                         <Sun+>       initialize #f                        accessors generate)
  (slot sun-angle                   <fl>         initialize -.20                      accessors generate)
  (slot skybox                      <Skybox+>    initialize #f                        accessors generate)
  (slot designer                    <object>     initialize #f                        accessors generate)
  (slot level-file                               initialize #f)
  (slot level-state                              initialize #f)
  (slot opened-chest                             initialize #f                        accessors generate)
  (slot inventory-blocks                         initialize (make-vector 63 #f)       getter generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition default-ambient-color
    (dye .1 .05 0. 1.))
  
  
  (method package virtual (welcome? self)
    #f)
  
  
  ;; quicky for tests
  (method package virtual (planets? self)
    #f)
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set-current-zone self))
  
  
  (method override (finish self rest)
    (define (effective-ambient-color)
      (let ((ambient-color (world-setting 'world.ambient-color 'default)))
        (cond ((not ambient-color)
               (dye 0. 0. 0. 1.0))
              ((eq? ambient-color 'default)
               default-ambient-color)
              (else
               ambient-color))))
    
    (nextmethod self rest)
    (load-point 'zone-prepare)
    (when (window?)
      (prepare-blocks self)
      (load-point 'zone-blocks))
    (when (window?)
      (prepare-draw)
      (load-point 'zone-draw))
    (setup-me (current-tier))
    (set! draw-me? (world-setting 'world.draw-me? #t))
    (set! ambient-color (or ambient-color (effective-ambient-color)))
    (set! sun-color (or sun-color (world-setting 'world.sun-color #f) (dye 1.0 1.0 1.0 1.0)))
    (set! sun-cycle? (and sun-cycle? (world-setting 'world.sun-cycle? #t)))
    (set! start-time (world-setting 'world.start-time 'dawn))
    (set! day-duration (world-setting 'world.day-duration 1200.))
    (set! draw-procedure-names (make-table test: eq?))
    (set! debug-sections? (or show-sections? show-chunks? (world-setting 'world.debug-sections? #f)))
    (when (window?)
      (register-task 'generate generate-task)
      @generate-tasks
      (begin
        (register-task 'generate2 generate-task2)
        (register-task 'generate3 generate-task3)
        (register-task 'generate4 generate-task4)
        (register-task 'generate5 generate-task5))
      (register-task 'instantiate instantiate-task)
      (register-task 'render (~ render-task self)))
    (when (current-me+)
      (register-task 'player (~ player-task self)))
    (register-task 'missile (~ missile-task self))
    (register-task 'tick (~ tick-task self))
    (register-task 'sun (~ sun-task self))
    (register-task 'spawn spawn-task)
    (register-task 'redstone redstone-task)
    (register-task 'gravity (~ gravity-task self))
    (register-task 'lava lava-task)
    (register-task 'water water-task)
    (register-task 'distance (~ distance-task self))
    (register-task 'eat (~ eat-task self))
    (when (window?)
      (register-task 'sound sound-task)
      (register-task 'music music-task))
    (unless (standalone?)
      (register-task 'network network-task)
      (register-task 'alive alive-task))
    (load-point 'zone-tasks)
    (when (window?)
      (register-entity-classes)
      (prepare-skybox-program)
      (prepare-skybox self)
      (load-point 'zone-skybox))
    (initialize-spawned)
    (load-point 'zone-spawned)
    (set-daytime self (effective-daytime self start-time))
    (set! sun-angle (daytime->sun-angle self daytime))
    (load-point 'zone-sun))
  
  
  (method package (initialize-zone self)
    (let ((world (current-world)))
      (setup-persistence self)
      (setup-seed self)
      (setup-generator self)
      (setup-regions self)
      (setup-sectors self)
      (setup-areas self)
      (setup-expanses self)
      (setup-overrides self)
      (setup-universe self)
      (setup-camera self)
      (setup-player self)
      (setup-children self)
      (setup-history world)
      (enter-tier self)
      (when (window?)
        (start-music self)
        (start-ambience self)
        (install-interface self)
        (display-welcome self))))
  
  
  (method (setup-persistence self)
    (when (not level-dir)
      (set! level-dir (new-directory (get-directory self) "level"))))
  
  
  (method (setup-seed self)
    (if seed
        (init-seed seed)
      (let ((seed (world-setting 'world.seed (random-monotonic))))
        (set-property designer self 'seed seed)
        (init-seed seed))))
  
  
  (method (setup-generator self)
    (let ((file (new-file (get-directory self) ".generator")))
      (set! generator (if (exists? file)
                          (instantiate (read-form file))
                        (new Empty-Generator)))))
  
  
  (method (setup-overrides self)
    (let ((world (current-world)))
      (when (specified? ambient-gravity)
        (set-ambient-gravity world ambient-gravity))
      (when (specified? jump-impulsion)
        (set-jump-impulsion world jump-impulsion))
      (set-grid? world start-grid?)
      (set-axes? world start-axes?)))
  
  
  (method protected virtual (setup-universe self)
    (set-current-universe (new Universe)))
  
  
  (method protected virtual (setup-camera self)
    )
  
  
  (method protected virtual (setup-player self)
    (let ((me (current-me+)))
      (when me
        (add-element self me))))
  
  
  ;; backward compatibility
  (method protected virtual (setup-children self)
    (let ((touched? #f))
      (for-each (lambda (obj)
                  (when (is? obj Element)
                    (add-element self obj)
                    (when (component-in-descendants? designer obj)
                      (with-designer self obj
                        (lambda (des container)
                          (remove-child designer obj)
                          (set-parent obj container)
                          (add-child des obj container form: (get-form obj))
                          (set! touched? #t))))))
                children)
      (when touched?
        (save designer))))
  
  
  (method protected virtual (enter-tier self)
    (enter (current-tier)))
  
  
  (method protected virtual (start-music self)
    (let ((music (current-music)))
      (initial-music music)))
  
  
  (method protected virtual (start-ambience self)
    (let ((ambience (current-ambience)))
      (initial-ambience ambience)))
  
  
  (method protected virtual (stop-music self)
    (let ((music (current-music)))
      (close-music music)))
  
  
  (method protected virtual (stop-ambience self)
    (let ((ambience (current-ambience)))
      (close-ambience ambience)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method package virtual (populate-zone self)
    )
  
  
  (method package virtual (generate-visual self sector)
    (site (visual on?: #t)
      (if show-blocking?
          (parameterize ((non-blocking? #t))
            (instantiate-visual sector))
        (instantiate-visual sector))))
  
  
  @generate-tasks
  (method (generate-visual2 sector)
    (site (visual2 on?: #t)
      (instantiate-visual sector)))
  
  
  @generate-tasks
  (method (generate-visual3 sector)
    (site (visual3 on?: #t)
      (instantiate-visual sector)))
  
  
  @generate-tasks
  (method (generate-visual4 sector)
    (site (visual4 on?: #t)
      (instantiate-visual sector)))
  
  
  @generate-tasks
  (method (generate-visual5 sector)
    (site (visual5 on?: #t)
      (instantiate-visual sector)))
  
  
  (method package virtual (generate-physical self area revision-update?)
    (site (physical on?: #t)
      (instantiate-physical area revision-update?)))
  
  
  (method package virtual (zone-ready self)
    )
  
  
  (method (get-zone-directory self)
    (let ((moniker (get-moniker self)))
      (and moniker
           (get-parent moniker))))
  
  
  (method package (zone-path self kind)
    (let ((world (current-world)))
      (let ((moniker (get-moniker self)))
        (let ((directory (get-tiers-directory world kind)))
          (let (iter (moniker (get-parent moniker)) (path '()))
            (if (pathname=? moniker directory)
                (join path "/")
              (let ((parent (get-parent moniker)))
                (if (not parent)
                    #f
                  (iter parent (cons (get-base moniker) path))))))))))
  
  
  (method (zone-brother self path)
    (new-file (get-zone-directory self) path))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (register-destroy-hook self proc)
    (set! destroy-hooks (cons proc destroy-hooks)))
  
  
  (method (unregister-destroy-hook self proc)
    (set! destroy-hooks (remove! proc destroy-hooks)))
  
  
  (method override (add-child self child)
    (set! children (cons child children)))
  
  
  (method override (destroy-component self)
    (destroy self))
  
  
  (method override (destroy self)
    (let ((world (current-world)))
      (shutting-down
        (lambda ()
          (launch-event world exit-script)
          @too-brittle ;; for example putting a crash-process in server retrieve chunk
          (when (window?)
            (unpause-world world))
          (shutdown-selection world)
          (when (window?)
            (uninstall-interface self))
          (stop-tasks self)
          (save-zone self)
          (save-designer self)
          (for-each (lambda (proc)
                      (proc))
                    destroy-hooks)
          (free-generator self)
          (free-eye-sectors self)
          (free-regions self)
          (when (window?)
            (stop-music self)
            (stop-ambience self))))))
  
  
  (method package virtual (save-zone self)
    (let ((tier (current-tier))
          (world (current-world))
          (motion (current-motion)))
      (define (save)
        (set-property designer self 'first-time? #f))
      
      (define (save-mode)
        (set-property designer self 'start-mode (if (person-motion?) 'first-person 'free-camera)))
      
      (define (save-distance)
        (when (is? motion Target-Motion)
          (set-property designer self 'start-distance (get-desired-distance motion))))
      
      (save)
      ;; until these properties are in the player at
      ;; least don't save them when no actual player
      (when (current-me+)
        (save-mode)
        (save-distance))
      (save-me tier)
      (when (window?)
        (save-chest save-region?: #t)
        (save-inventory))
      (save-level-state self)))
  
  
  (method package (save-designer self)
    (save designer))
  
  
  (method package (install-interface self)
    (let ((world (current-world))
          (interface (current-interface)))
      (set-visible? (child interface 'bag) #f)
      (view-inventory (child interface 'belt))
      (set-visible? (child interface 'belt) (show-belt? self))
      (set-visible? (child interface 'chest) #f)
      (set-visible? (child interface 'command) #f)
      (set-visible? (child interface 'compass) (show-compass? self))
      (set-visible? (child interface 'combat) (show-combat? self))
      (set-compass-visible? world (show-compass? self))
      (reset-cache (child interface 'map))
      ;; aec quicky
      (when (creator?)
        (let ((bar (child interface 'edition)))
          (set-location bar '(-332 -10))))
      ;; quick solution
      (let ((bar (child interface 'main)))
        (layout-bar bar 'horizontal)
        (layout-view interface))))
  
  
  (method package (uninstall-interface self)
    (let ((world (current-world))
          (interface (current-interface)))
      (set-visible? (child interface 'bag) #f)
      (set-visible? (child interface 'belt) #f)
      (set-visible? (child interface 'chest) #f)
      (set-visible? (child interface 'chat) #f)
      (set-visible? (child interface 'command) #f)))
  
  
  (method (display-welcome self)
    (when (and (client?) (not local?))
      (let ((tier (client-tier))
            (interface (current-interface)))
        (unless (get-welcomed? tier)
          (let ((welcome (get-welcome tier)))
            (when welcome
              (let ((chat (child interface 'chat)))
                (show-welcome chat welcome))))
          (set-welcomed? tier #t)))))
  
  
  (method protected virtual (show-belt? self)
    (let ((world (current-world)))
      (get-show-belt? world)))
  
  
  (method protected virtual (show-compass? self)
    #t)
  
  
  (method protected virtual (show-combat? self)
    #t)
  
  
  ;;;
  ;;;; Tasks
  ;;;
  
  
  (method package (start-tasks self)
    (when (window?)
      (start-task 'generate)
      @generate-tasks
      (begin
        (start-task 'generate2)
        (start-task 'generate3)
        (start-task 'generate4)
        (start-task 'generate5))
      (start-task 'instantiate)
      (start-task 'render))
    (when (current-me+)
      (start-task 'player))
    (start-task 'missile)
    (start-task 'tick)
    (start-task 'sun)
    (start-task 'spawn)
    (start-task 'redstone)
    (start-task 'gravity)
    (start-task 'lava)
    (start-task 'water)
    (start-task 'distance)
    (start-task 'eat)
    (when (window?)
      (start-task 'sound)
      (start-task 'music))
    (unless (standalone?)
      (start-task 'network)
      (start-task 'alive))
    (when (window?)
      (thread-base-priority-set! (task-thread 'generate) generate-priority)
      @generate-tasks
      (begin
        (thread-base-priority-set! (task-thread 'generate2) generate-priority)
        (thread-base-priority-set! (task-thread 'generate3) generate-priority)
        (thread-base-priority-set! (task-thread 'generate4) generate-priority)
        (thread-base-priority-set! (task-thread 'generate5) generate-priority))
      (thread-base-priority-set! (task-thread 'instantiate) instantiate-priority)
      (thread-base-priority-set! (task-thread 'render) render-priority))
    (when (current-me+)
      (thread-base-priority-set! (task-thread 'player) player-priority))
    (thread-base-priority-set! (task-thread 'missile) missile-priority)
    (thread-base-priority-set! (task-thread 'tick) tick-priority)
    (thread-base-priority-set! (task-thread 'sun) sun-priority)
    (thread-base-priority-set! (task-thread 'spawn) spawn-priority)
    (thread-base-priority-set! (task-thread 'redstone) redstone-priority)
    (thread-base-priority-set! (task-thread 'gravity) gravity-priority)
    (thread-base-priority-set! (task-thread 'lava) lava-priority)
    (thread-base-priority-set! (task-thread 'water) water-priority)
    (thread-base-priority-set! (task-thread 'distance) distance-priority)
    (thread-base-priority-set! (task-thread 'eat) eat-priority)
    (when (window?)
      (thread-base-priority-set! (task-thread 'sound) sound-priority)
      (thread-base-priority-set! (task-thread 'music) music-priority))
    (unless (standalone?)
      (thread-base-priority-set! (task-thread 'network) network-priority)
      (thread-base-priority-set! (task-thread 'alive) alive-priority)))
  
  
  (method (stop-tasks self)
    (define (stop-simulations)
      (iterate-table simulations
        (lambda (entity task)
          (stop-entity entity))))
    
    (define (stop-entities)
      (for-each stop-entity entities))
  
    (define (stop-entity entity)
      (let ((task (get-task entity)))
        (when task
          (stop-task task))))
    
    (let ((world (current-world)))
      (set-render-boost? #f)
      (set-player-boost? #f)
      ;; stop generate before instantiate
      (reset-content)
      (stop-generate)
      @generate-tasks
      (begin
        (stop-generate)
        (stop-generate)
        (stop-generate)
        (stop-generate))
      (stop-task 'generate #f)
      @generate-tasks
      (begin
        (stop-task 'generate2 #f)
        (stop-task 'generate3 #f)
        (stop-task 'generate4 #f)
        (stop-task 'generate5 #f))
      ;; stop instantiate before entities
      (reset-instantiate)
      (stop-task 'instantiate)
      (stop-simulations)
      (stop-entities)
      (stop-task 'sun)
      (stop-task 'spawn)
      (stop-task 'redstone)
      (stop-task 'gravity)
      (stop-task 'lava)
      (stop-task 'water)
      (stop-task 'distance)
      (stop-task 'eat)
      (when (window?)
        (stop-task 'sound)
        (stop-task 'music))
      (when (current-me+)
        (stop-task 'player))
      (stop-task 'missile)
      (stop-task 'tick)
      (unless (standalone?)
        (stop-task 'network)
        (stop-task 'alive))
      (when (current-me+)
        (set-player-thread world #f))
      (when (window?)
        (stop-task 'render)
        (set-render-thread world #f))))
  
  
  ;;;
  ;;;; Generator
  ;;;
  
  
  (method (free-generator self)
    (when generator
      (free generator)
      (set! generator #f)))
  
  
  ;;;
  ;;;; Scripts
  ;;;
  
  
  (definition scripting-prepared?
    #f)
  
  
  (method package (prepare-scripting self)
    (define (script-code)
      "(module prepare-scripting script (import (world.script)))")
    
    (when (not scripting-prepared?)
      (when (world-setting 'world.worker? #t)
        (let ((code (script-code)))
          (worker-run #f code
            ;; read
            (lambda (data)
              )
            ;; walk
            (lambda (data)
              )
            ;; error
            (lambda (data)
              )
            ;; run
            (lambda ()
              )
            ;; result
            (lambda (result)
              ))))
      (set! scripting-prepared? #t)))
  
  
  (method package (run-script self element)
    (unless (world-setting 'world.inhibit-scripts? #f)
      (when (is? element Entity)
        (let ((script (get-script element)))
          (run-task element script)))))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method package (player-update self)
    (when (current-me+)
      (let ((interface (current-interface+)))
        (when interface
          (let ((character-panel (child interface 'character)))
            (view-inventory character-panel)
            (update character-panel))))))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (proclaim (not warn optimizations))

  
  (method package (target-update self target poly vert)
    (define (center-info title center (poly #f))
      (let ((section (position-section self center))
            (x (fxfloor (vertex-x center)))
            (y (fxfloor (vertex-y center)))
            (z (fxfloor (vertex-z center))))
        (if (not section)
            #f
          (let ((section-index (get-index section)))
            (let ((section-x (index-x section-index))
                  (section-y (index-y section-index))
                  (section-z (index-z section-index)))
              (let ((cache-uninitialized 65535)
                    (sections (neighbor-sections section section-x section-y section-z)))
                (with-generate-mutex
                  (lambda ()
                    (let ((bottom-section? (= section-y (cast <fx> (or truncate-y 0))))
                          (cache <u16vector> (initialize-block-cache block-cache cache-uninitialized))
                          (blocks (get-blocks section))
                          (data (get-data section))
                          (blocklight (get-blocklight section))
                          (skylight (get-skylight section)))
                      (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                        (vector-ref sections (section-index a b c)))
                      
                      (define (section-index a <fx> b <fx> c <fx>) <fx>
                        (+ (* b 9) (* c 3) a 13))
                      
                      (define (local-index i <fx> j <fx> k <fx>) <fx>
                        (+ (* j 256) (* k 16) i))
                      
                      (define (effective-index i <fx> j <fx> k <fx>) <fx>
                        (* (+ (* j 324) (* k 18) i 343) 4))
                      
                      (define (blocks-get section <World-Section>) <u8vector>
                        (get-blocks section))
                      
                      (define (blocklight-get section <World-Section>) <u8vector>
                        (get-blocklight section))
                      
                      (define (blocklight-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref blocklight (local-index i j k)))
                      
                      (define (skylight-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref skylight (local-index i j k)))
                      
                      (define (local-block-ref i <fx> j <fx> k <fx>)
                        (u8vector-ref blocks (local-index i j k)))
                      
                      (define (local-data-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref data (local-index i j k)))
                      
                      (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                        (let ((index (effective-index i j k)))
                          (let ((value (u16vector-ref cache index)))
                            (if (/= value cache-uninitialized)
                                value
                              (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                                (u16vector-set! cache index value)
                                value)))))
                      
                      (define (effective-light-ref shade <fl> i <fx> j <fx> k <fx>) <fx>
                        (field-ref i j k blocklight-get u4vector-ref 0 0))
                      
                      (define (u4vector-ref field <u8vector> index <fx>) <fx>
                        (let ((byte (u8vector-ref field (quotient index 2))))
                          (if (even? index)
                              (bitwise-and byte #x0F)
                            (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                      
                      (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                        (define (bind-i a <fx> i <fx>)
                          (define (bind-j b <fx> j <fx>)
                            (define (bind-k c <fx> k <fx>)
                              (let ((section (section-ref a b c)))
                                (if (not section)
                                    (if (and bottom-section? (= b -1)) bottom empty)
                                  (let ((field (get-field section)))
                                    (if (not field)
                                        (if (and bottom-section? (= b -1)) bottom empty)
                                      (ref field (local-index i j k)))))))
                            
                            (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                  ((> k 15) (bind-k 1 (- k 16)))
                                  (else (bind-k 0 k))))
                          
                          (cond ((< j 0) (bind-j -1 (+ 16 j)))
                                ((> j 15) (bind-j 1 (- j 16)))
                                (else (bind-j 0 j))))
                        
                        (cond ((< i 0) (bind-i -1 (+ 16 i)))
                              ((> i 15) (bind-i 1 (- i 16)))
                              (else (bind-i 0 i))))
                      
                      (define (compute-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                        (format "{a} {a} {a} {a}"
                                (effective-light-ref shade (+ i ax) (+ j ay) (+ k az))
                                (effective-light-ref shade (+ i bx) (+ j by) (+ k bz))
                                (effective-light-ref shade (+ i cx) (+ j cy) (+ k cz))
                                (effective-light-ref shade (+ i dx) (+ j dy) (+ k dz))))
                      
                      (define (ambient-light i <fx> j <fx> k <fx> vert)
                        (let ((origin (vertex-& (vertex-& vert (vertex& (cast <fl> x) (cast <fl> y) (cast <fl> z))) (vertex& .5 .5 .5)))
                              (normal (get-normal poly)))
                          (generic-lighting i j k origin normal compute-lighting no-shade)))
                      
                      (define (block-info i <fx> j <fx> k <fx>)
                        (let ((id (local-block-ref i j k))
                              (data (local-data-ref i j k))
                              (blocklight (blocklight-ref i j k))
                              (skylight (skylight-ref i j k)))
                          (let ((block (id/variant-id->block id data)))
                            (append (list (cons title (get-name block))
                                          (cons "id" id)
                                          (cons "data" data)
                                          (cons "block light" blocklight)
                                          (cons "sky light" skylight))
                                    (if (and poly (programmer?))
                                        (list (cons "section" (format "{a} {a} {a}" section-x section-y section-z))
                                              (cons "coordinates" (format "{a} {a} {a}" i j k))
                                              (cons "location" (present-location (position->location (polygon-position poly))))
                                              (cons "ambient" (ambient-light i j k vert)))
                                      '())))))
                      
                      (define (present-location loc)
                        (format "{a} {a} {a}"
                                (index-x loc)
                                (index-y loc)
                                (index-z loc)))
                      
                      (let ((i (- x (* section-x 16)))
                            (j (- y (* section-y 16)))
                            (k (- z (* section-z 16))))
                        (block-info i j k)))))))))))
    
    (define (update-info)
      (if (not poly)
          (begin
            (unregister-info 'block)
            (unregister-info 'fore)
            (let ((eye (get-position (current-camera))))
              (let ((info (center-info "Eye" eye)))
                (if (not info)
                    (unregister-info 'eye)
                  (register-info 'eye
                    (lambda (add-section add-info)
                      (let ((section (add-section "Eye")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info))))))))
        (let ((universe (current-universe)))
          (with-polygon-interaction universe poly
            (lambda (poly block fore)
              (let ((info (center-info "Block" block poly)))
                (register-info 'block
                  (lambda (add-section add-info)
                    (let ((section (add-section "Block")))
                      (for-each (lambda (info)
                                  (add-info section (car info) (cdr info)))
                                info)))))
              (let ((info (center-info "Fore" fore)))
                (if (not info)
                    (unregister-info 'fore)
                  (register-info 'fore
                    (lambda (add-section add-info)
                      (let ((section (add-section "Fore")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info)))))))))
        (unregister-info 'eye)))
    
    (update-info))
  
  
  (proclaim (warn optimizations))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method package (get-directory self)
    (get-parent (get-moniker self)))
  
  
  (method package (get-moniker self)
    (get-origin form))
  
  
  (method package (get-modified? self)
    (get-modified? designer))
  
  
  (method package (set-modified? self flag)
    (let ((world (current-world)))
      (when #t @buggy (neq? flag (get-modified? designer))
        (set-modified? designer flag)
        (update-title world))))
  
  
  (method (read-element self element property)
    (read-property element property))
  
  
  (method package (write-element self element property value)
    (with-designer self element
      (lambda (designer container)
        (set-property designer element property value))))
  
  
  (method package (with-designer self element proc)
    (define (toplevel elem)
      (let ((parent (get-parent elem)))
        (if (or (not parent) (eq? parent self) (is? parent Chunk-Container))
            elem
          (toplevel parent))))
    
    (let ((top (toplevel element)))
      (with-chunk-designer self (get-designer-chunk top)
        proc)))
  
  
  (method package (with-chunk-designer self chunk proc)
    (assert chunk)
    (let ((designer (cache-designer chunk)))
      (prog1 (proc designer (get-reference designer))
        (save-designer chunk)
        (modified chunk)
        (save-region (get-region chunk)))))
  
  
  (method package (create-block-entity self model position)
    (let ((chunk (position-chunk self position)))
      (with-chunk-designer self chunk
        (lambda (designer container)
          (let ((entity (new Block-Entity model: model position: position)))
            (set-designer-chunk entity chunk)
            entity)))))
  
  
  ;; quicky for sejour to think through
  (method package (designable? self obj)
    (and (is? obj Entity)
         (get-designer-chunk obj)
         (component-in-descendants? (cache-designer (get-designer-chunk obj)) obj)))


  (method package (need-script self obj (create?: create? #t))
    (or (get-script obj)
        (and create?
             ;; sejour quicky
             (or (is? obj Block-Entity)
                 (designable? (current-zone) obj))
             (let ((script (new Script parent: obj)))
               (if (is? obj Block-Entity)
                   (let ((pos (get-position obj))
                         (model (get-model obj)))
                     (let ((chunk (position-chunk self pos)))
                       (with-chunk-designer self chunk
                         (lambda (designer container)
                           (add-child designer obj container properties: (list 'position pos 'model model proxy?: #t))
                           (add-child designer script obj)
                           (add-element self obj chunk)
                           (setup-actions obj)
                           script))))
                 (with-designer self obj
                   (lambda (designer container)
                     (add-child designer script obj)))
                 script)))))
  
  
  ;;;
  ;;;; Prologue
  ;;;
  
  
  (method (check-prologue self (size: size #f))
    (when (and first-time? (world-setting 'world.show-prologue? #t) (window?))
      (show-prologue self size: size)
      (save-designer self)))
  
  
  (method (show-prologue self (size: size #f))
    (open-world-document (prologue-file self) class: World-Formatted-Text-View size: (or size {Dimension 800 600})))
  
  
  (method (prologue-file self)
    (zone-brother self "Prologue.ftx"))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method package (draw-zone self)
    (let ((world (current-world)))
      (draw-sectors)
      (site (draw-procedures on?: #f parent: draw-world)
        (when (not-null? draw-procedures)
          (for-each (lambda (proc)
                      (proc))
                    draw-procedures)))
      (if (effective-draw-gadgets? world)
          (draw-gadgets self)
        (draw-drawable-gadgets self))
      (when (get-draw-marks? world)
        (draw-marks self))
      (when (get-draw-atlas? world)
        (draw-atlas self))
      (when (and sun (get-visible? sun))
        (register-sun self))
      (gl-check-error)))
  
  
  (method (registered-draw self name)
    (table-ref draw-procedure-names name #f))
  
  
  (method package (register-draw self name proc)
    (when (registered-draw self name)
      (unregister-draw self name))
    (set! draw-procedures (cons proc draw-procedures))
    (table-set! draw-procedure-names name proc))
  
  
  (method (unregister-draw self name)
    (let ((proc (table-ref draw-procedure-names name)))
      (set! draw-procedures (remove! proc draw-procedures))
      (table-clear draw-procedure-names name)))
  
  
  ;;;
  ;;;; Blocks
  ;;;
  
  
  (method protected virtual (album-name self)
    'block)
  
  
  (method protected virtual (create-album self)
    (let ((name (or atlas-name (album-name self))))
      (or (registered-album name)
          (let ((atlas (create-atlas self)))
            (let ((textures (create-textures self atlas)))
              (when (complete-album? self)
                (complete atlas))
              (update-textures-subuvs atlas)
              (let ((album (new Album atlas textures)))
                (register-album name album)
                album))))))
  
  
  (method protected virtual (complete-album? self)
    #t)
  
  
  (method protected virtual (create-atlas self)
    (create-block-atlas))
  
  
  (method protected virtual (create-textures self atlas)
    (list->table
      (list
        ;; clamp to edge is necessary for joins like between the rails
        (cons 'clamp (create-texture atlas wrap: GL_CLAMP_TO_EDGE))
        (cons 'repeat (create-texture atlas min-filter: 'nearest)))))
  
  
  (method (prepare-blocks self)
    (let ((world (current-world)))
      (let ((album (create-album self)))
        (let ((atlas (get-atlas album)))
          (let ((texture (get-texture album 'clamp))
                (texture-repeat (get-texture album 'repeat)))
            (prepare-block world atlas texture texture-repeat)
            (let ((opaque-material (get-material (cast <Rendering> (opaque-rendering))))
                  (transparent-material (get-material (cast <Rendering> (transparent-rendering))))
                  (coverage-material (get-material (cast <Rendering> (coverage-rendering))))
                  (water-material (get-material (cast <Rendering> (water-rendering))))
                  (wet-material (get-material (cast <Rendering> (wet-rendering))))
                  (multitexture-material (get-material (cast <Rendering> (multitexture-rendering)))))
              (prepare-materials world opaque-material transparent-material coverage-material water-material wet-material multitexture-material)))))))

  
  (method (make-block-atlas self (adder: adder #f))
    (let ((world (current-world)))
      (let ((atlas (new Atlas)))
        (when (window?)
          (iterate-assets world
            (lambda (assets)
              (add-assets-directory-if-exists atlas assets '("tile"))))
          (when adder
            (adder atlas)))
        atlas)))
  
  
  (method package virtual (sample-program-image self program)
    (case program
      ((opaque) "stone")
      ((transparent) "flower_rose")
      (else "wool_colored_light_blue")))
  
  
  ;;;
  ;;;; Skybox
  ;;;
  
  
  (method protected virtual (prepare-skybox self)
    (set! skybox (and start-skybox (let ((skybox (find-skybox start-skybox)))
                                     (when skybox
                                       (prepare skybox))
                                     skybox))))
  
  
  (method package (install-skybox self sky)
    (prepare sky)
    (set! skybox sky))
  
  
  (method package (remove-skybox self)
    (set! skybox #f))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method package virtual (mouse-track self elapse dx dy)
    #f)
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method package (add-element self obj (chunk #f))
    (define (add-player)
      (set! players (cons obj players))
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-actor)
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-gravity)
      (set! gravities (cons obj gravities))
      (set! gadgets (cons obj gadgets)))
    
    (define (add-gravity-well)
      (set! gravities (cons obj gravities)))
    
    (define (add-light)
      (set! gadgets (cons obj gadgets))
      (setup-lighting self))
    
    (define (add-gadget)
      (set! gadgets (cons obj gadgets)))
    
    (define (add-entity)
      (set! entities (cons obj entities)))
    
    (if (and (client?) (simulated? obj))
        (begin
          (when (is? obj Player)
            (set! players (cons obj players)))
          (link-entity self (element-section-index self obj) obj)
          (start-simulation self obj))
      (typecase obj
        ((Player) (add-player))
        ((Actor) (add-actor))
        ((Gravity) (add-gravity))
        ((Gravity-Well) (add-gravity-well))
        ((Light) (add-light))
        ((Gadget) (add-gadget))
        ((Entity) (add-entity)))
      (when (is? obj Entity)
        (let ((index (element-section-index self obj)))
          (link-entity self index obj)
          (set-designer-chunk obj (or chunk (index-chunk self index)))))
      (when (or (and (server?) (window?) (is? obj Player) (not (get-me? obj)))
                (and (client?) (is? obj Creature)))
        (start-simulation self obj))
      (when (is? obj Creature)
        (add-spawned obj))
      (unless (client?)
        (when (is? obj Entity)
          (run-script self obj))))
    obj)
  
  
  (method package (remove-element self obj)
    (define (remove-player)
      (set! players (remove! obj players))
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-actor)
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-gravity)
      (set! gravities (remove! obj gravities))
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-gravity-well)
      (set! gravities (remove! obj gravities)))
    
    (define (remove-light)
      (set! gadgets (remove! obj gadgets))
      (setup-lighting self))
    
    (define (remove-gadget)
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-entity)
      (set! entities (remove! obj entities)))
    
    (if (and (client?) (simulated? obj))
        (begin
          (cease-simulation self obj)
          (when (is? obj Player)
            (set! players (remove! obj players)))
          (unlink-entity self obj))
      (unless (client?)
        (when (is? obj Entity)
          (cease-entity obj)))
      (when (or (and (server?) (window?) (is? obj Player) (not (get-me? obj)))
                (and (client?) (is? obj Creature)))
        (cease-simulation self obj))
      (when (is? obj Creature)
        (remove-spawned obj))
      (typecase obj
        ((Player) (remove-player))
        ((Actor) (remove-actor))
        ((Gravity) (remove-gravity))
        ((Gravity-Well) (remove-gravity-well))
        ((Light) (remove-light))
        ((Gadget) (remove-gadget))
        ((Entity) (remove-entity)))
      (when (is? obj Entity)
        (unlink-entity self obj)
        (set-designer-chunk obj #f)))
    (close obj))
  
  
  (method (add-simulated self obj)
    (let ((index (element-section-index self obj)))
      (link-entity self index obj)))
  
  
  (method (remove-simulated self obj)
    (unlink-entity self obj))
  
  
  (method (link-entity self index entity)
    (let ((expanse (index-expanse self index)))
      (add-entity expanse entity)
      (set-expanse entity expanse)))
  
  
  (method (unlink-entity self entity)
    ;; sejour horrible quicky
    (when (get-expanse entity)
      (remove-entity (get-expanse entity) entity))
    (set-expanse entity #f))
  
  
  (method package (update-entity self entity old-position)
    ;; for setup-children backward compatibility
    (when level-dir
      (let ((old-index (position-section-index self old-position))
            (new-index (element-section-index self entity)))
        (unless (equal? old-index new-index)
          (unlink-entity self entity)
          @should-only-be-done-by-set-property-as-it-can-put-an-entity-in-an-incorrect-section-designer
          (when (and (is? (get-parent entity) Chunk-Container)
                     (get-chunk (get-parent entity)))
            (with-section-designer (index-section old-index)
              (lambda (designer container)
                (remove-child designer entity)))
            (with-section-designer (index-section new-index)
              (lambda (designer container)
                (set-parent entity container)
                (add-child designer entity container form: (get-form entity)))))
          (link-entity self new-index entity)))))
  
  
  (method (find-element self predicate)
    (continuation-capture
      (lambda (return)
        (iterate-elements self
          (lambda (element)
            (when (predicate element)
              (continuation-return return element))))
        #f)))
  
  
  (method (find-named-element self name)
    (find-element self
      (lambda (element)
        (eq? (get-name element) name))))
  
  
  (method (find-gadget self predicate)
    (find-if predicate gadgets))
  
  
  (method (iterate-players self proc)
    (for-each proc players))
  
  
  (method (iterate-actors self proc)
    (for-each proc actors))
  
  
  (method package (iterate-entities self proc)
    (for-each proc entities))
  
  
  (method (iterate-gadgets self proc)
    (for-each proc gadgets))
  
  
  (method (iterate-elements self proc)
    (for-each proc entities))
  
  
  (method (draw-me self)
    (let ((me (current-me)))
      (draw me)))
  
  
  (method (element-at self vert)
    #f
    @convert^^^
    (continuation-capture
      (lambda (return)
        (let ((area (index-area (position-area-index vert))))
          (iterate-area-elements area
            (lambda (obj)
              (when (and (get-visible? obj)
                         (vertex=? (get-position obj) vert))
                (continuation-return return obj)))))
        #f)))
  
  
  (method package (element-near self vert)
    #f
    @convert^^^
    (let ((x (vertex-x vert))
          (y (vertex-y vert))
          (z (vertex-z vert))
          ;; open test quicky to improve
          (radius .7))
      (let ((left (- x radius))
            (bottom (- y radius))
            (back (- z radius))
            (right (+ x radius))
            (top (+ y radius))
            (front (+ z radius)))
        (continuation-capture
          (lambda (return)
            (with-area-retainer 'element-near
              (lambda (retain)
                (iterate-position-neighbor-areas vert 1 #f
                  (lambda (area index retain?)
                    (when retain?
                      (retain area))
                    (iterate-area-elements area
                      (lambda (obj)
                        (when (and (get-visible? obj)
                                   (let ((x (get-x obj))
                                         (y (get-y obj))
                                         (z (get-z obj)))
                                     (and (>= x left)
                                          (>= y bottom)
                                          (>= z back)
                                          (<  x right)
                                          (<  y top)
                                          (<  z front))))
                          (continuation-return return obj))))))))
            #f)))))
  
  
  (method (validate-elements self)
    (iterate-elements self
      (lambda (element)
        (assert (real? (get-x element)))
        (assert (real? (get-y element)))
        (assert (real? (get-z element)))
        (assert (real? (get-red element)))
        (assert (real? (get-green element)))
        (assert (real? (get-blue element)))
        (assert (real? (get-alpha element))))))
  
  
  ;;;
  ;;;; Creature
  ;;;
  
  
  (method package (get-creatures self)
    (collect-type Creature actors))
  
  
  (method package (change-creature-models? self value)
    (set-creature-models? value)
    (for-each (lambda (creature)
                (update-model creature anchor?: #t))
              spawned-creatures))
  
  
  ;;;
  ;;;; Simulation
  ;;;
  
  
  (method (start-simulation self actor)
    (unless (table-ref simulations actor #f)
      (let ((procedure
              (lambda (task)
                (simulation-task actor task))))
        (let ((task (new Task 'simulation procedure priority: simulation-priority)))
          (start-task task)
          (set-task actor task)
          (table-set! simulations actor task)))))
  
  
  (method (cease-simulation self actor)
    (let ((task (get-task actor)))
      (table-clear simulations actor)
      (cease-task task)))
    
  
  ;;;
  ;;;; Panes
  ;;;
  
  
  (method (register-pane self pane)
    (set! panes (cons pane panes)))
  
  
  (method (unregister-pane self pane)
    (set! panes (remove! pane panes)))

  
  ;;;
  ;;;; Regions
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-regions self)
    (with-regions-mutex self
      (lambda ()
        (set! region-access-mutexes (make-table test: equal?))
        ;; temporary simplification by having processor retain everything
        (set! regions (make-table test: equal? weak-values: (standalone?) @wait-client-caching-chunks (not (processing?)))))))
  
  
  (method (with-regions-mutex self thunk)
    (mutex-lock! regions-mutex)
    (prog1 (thunk)
      (mutex-unlock! regions-mutex)))
  
  
  (method (with-region-access-mutex self index thunk)
    (define (region-access-mutex index)
      (with-regions-mutex self
        (lambda ()
          (or (table-ref region-access-mutexes index #f)
              (let ((mutex (make-mutex 'region-access)))
                (table-set! region-access-mutexes index mutex)
                mutex)))))
    
    (let ((mutex (region-access-mutex index)))
      (mutex-lock! mutex)
      (prog1 (thunk)
        (mutex-unlock! mutex))))
  
  
  (method (iterate-regions self proc)
    (with-regions-mutex self
      (lambda ()
        (iterate-table regions
          (lambda (index region)
            (proc region))))))
  
  
  (method package (find-region self index <index>) <World-Region+>
    (with-regions-mutex self
      (lambda ()
        (table-ref regions index #f))))
  
  
  (method package (load-region self index <index>) <World-Region>
    (or (find-region self index)
        (let ((region-x (index-x index))
              (region-y (index-y index))
              (region-z (index-z index)))
          (define (region-name)
            (if (= region-y 0)
                (format "r.{a}.{a}.mca" region-x region-z)
              (format "r.{a}.{a}.{a}.mca" region-x region-z region-y)))
          
          (define (create-file file)
            (create-directories file)
            (call-with-output-file (path-settings file)
              (lambda (port)
                (let ((locations/timestamps (make-u8vector 4096 0)))
                  (write-subu8vector locations/timestamps 0 4096 port)
                  (write-subu8vector locations/timestamps 0 4096 port)))))
          
          (define (create-region index)
            (let ((dir (get-regions-dir self))
                  (name (region-name)))
              (let ((file (new-file dir name)))
                (if (exists? file)
                    (new World-Region index file self)
                  (create-file file)
                  (new World-Region index file self)))))
          
          (with-region-access-mutex self index
            (lambda ()
              (let ((index (copy-index index)))
                (let ((region (create-region index)))
                  (with-regions-mutex self
                    (lambda ()
                      (table-set! regions index region)))
                  region)))))))
  
  
  (method (load-region-if self index <index>) <World-Region+>
    (and (or (not truncate-y)
             (>= (index-y index) (fxfloor/ truncate-y region-size)))
         (load-region self index)))
  
  
  (method package (unlink-region self region)
    (with-regions-mutex self
      (lambda ()
        (let ((index (get-index region)))
          (table-clear region-access-mutexes index)
          (table-clear regions index)))))
  
  
  (method (free-regions self)
    (iterate-regions self
      (lambda (region)
        (with-mutex region
          (lambda ()
            (set-zone region #f)
            (close region))))))
  
  
  (method package (get-regions-dir self) <Directory>
    (or regions-dir (let ((dir (new-directory level-dir (case dimension
                                                           ((over) "region")
                                                           ((nether) '("DIM-1" "region"))
                                                           ((end) '("DIM1" "region"))))))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method (iterate-regions-dir self proc)
    (iterate-directory (get-regions-dir self)
      (lambda (file <File>)
        (when (extension=? (get-extension file) "mca")
          (let ((base <string> (get-base file)))
            (bind (x z y . rest) (split (substring base 2 (string-length base)) ".")
              (let ((x (string->number x))
                    (z (string->number z))
                    (y (if (null? rest) 0 (string->number y))))
                (proc file (indexed x y z)))))))))
  
  
  (method public (change-dimension self)
    (with-generate-mutex
      (lambda ()
        (set! dimension (case dimension
                          ((over) 'nether)
                          ((nether) 'end)
                          ((end) 'over)))
        (set! regions-dir #f)
        (setup-regions self)
        (setup-areas self))))
  
  
  ;; for exploration
  (method (preload-regions self)
    (iterate-regions-dir self
      (lambda (file index)
        (let ((region (load-region self index)))
          (loop (for section-x from 0 below 32)
                (loop (for section-z from 0 below 32)
                      (loop (for section-y from 0 below 16)
                            (load-section region section-x section-y section-z))))))))


  ;; for exploration
  (method (explore-regions self from to (more? #f))
    (define (explore region)
      (let ((region-x (get-x region))
            (region-z (get-z region))
            (count 0)
            (missing (new-queue)))
        (iterate-chunks region
          (lambda (x z)
            (when (not (load-chunk region (planar-index x z)))
              (increase! count)
              (enqueue missing (list (+ (* region-x region-size) x)
                                     (+ (* region-z region-size) z))))))
        (if (not more?)
            (debug region count)
          (debug region count (queue-list missing)))))
    
    (loop (for x from from to to)
          (loop (for z from from to to)
                (let ((region (load-region self (indexed x 0 z))))
                  (explore region)))))
  
  
  ;; exploration
  (method (explore-chests self)
    (preload-regions self)
    (let ((items '()))
      (for-each (lambda (info)
                  (bind (section . coordinates) info
                    (bind-index (i j k) coordinates
                      (call-with-section self section i j k
                        (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                          (let ((data (block-entity-data section (indexed i j k))))
                            (let ((inventory (list-payload-content (tag-assoc "Items" data))))
                              (for-each (lambda (item)
                                          (let ((id (tag-assoc "id" item)))
                                            (let ((name (or (let ((item (id->item id)))
                                                              (and item (get-name item)))
                                                            id)))
                                              (unless (memv? name items)
                                                (set! items (cons name items))))))
                                        inventory))))))))
                (find-visual-blocks self '(54)))
      (sort nu<? items key: ->string)))
  
  
  (method package (count-regions self)
    (let ((count 0))
      (iterate-regions self
        (lambda (region)
          (increase! count)))
      count))
  
  
  ;;;
  ;;;; Chunks
  ;;;
  
  
  (method (position-chunk self pos <vertex>) <World-Chunk>
    (index-chunk self (position-section-index self pos)))
  
  
  (method (element-chunk self element) <World-Chunk+>
    (let ((index (element-section-index self element)))
      (index-chunk self index)))
  
  
  (method (index-chunk self index <index>) <World-Chunk>
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (let ((region (load-region self (indexed (fxfloor/ section-x region-size)
                                          (fxfloor/ section-y region-size)
                                          (fxfloor/ section-z region-size)))))
        (load-section-chunk region (planar-index section-x section-z)))))
  
  
  (method (index-chunk-if self index (create?: create? #f)) <World-Chunk+>
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (let ((region (let ((index (indexed (fxfloor/ section-x region-size)
                                          (fxfloor/ section-y region-size)
                                          (fxfloor/ section-z region-size))))
                      (if create?
                          (load-region self index)
                        (load-region-if self index)))))
        (and region
             (load-section-chunk region (planar-index section-x section-z))))))
  
  
  (method package (find-chunk self section-x section-y section-z) <World-Chunk+>
    (let ((region (find-region self (indexed (fxfloor/ section-x region-size)
                                        (fxfloor/ section-y region-size)
                                        (fxfloor/ section-z region-size)))))
      (and region
           (find-chunk region (planar-index section-x section-z)))))
  
  
  (method package (count-chunks self)
    (let ((count 0))
      (iterate-regions self
        (lambda (region)
          (increase! count (count-chunks region))))
      count))
  
  
  ;;;
  ;;;; Sections
  ;;;
  
  
  (method package (element-section-index self element <Element>) <index>
    (position-section-index self (get-position element)))
  
  
  (method (position-section-index self pos <vertex>) <index>
    (let ((size (cast <fl> sector-size)))
      (indexed (fxfloor (/ (vertex-x pos) size))
               (fxfloor (/ (vertex-y pos) size))
               (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method package (position-section self pos (create?: create? #f)) <World-Section+>
    (let ((index (position-section-index self pos)))
      (index-section self index create?: create?)))
  
  
  (method (element-section self element) <World-Section+>
    (let ((index (element-section-index self element)))
      (index-section self index)))
  
  
  (method package (index-section self index (create?: create? #f)) <World-Section+>
    (let ((section-y (index-y index)))
      (let ((chunk (index-chunk-if self index create?: create?)))
        (and chunk
             (load-section chunk section-y create?: create?)))))
  
  
  (method package (find-section self section-x section-y section-z) <World-Section+>
    (let ((chunk (find-chunk self section-x section-y section-z)))
      (and chunk
           (find-section chunk section-y))))
  
  
  (method package (count-sections self)
    (let ((count 0))
      (iterate-regions self
        (lambda (region)
          (iterate-chunks region
            (lambda (chunk)
              (increase! count (count-sections chunk))))))
      count))
  
  
  (method package (toggle-debug-sections self)
    (set! debug-sections? (not debug-sections?)))
  
  
  (method package (draw-debug-sections self)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((world (current-world))
          (camera (current-camera)))
      (let ((view-distance (get-view-distance world)))
        (let ((eye-x (index-x eye-index))
              (eye-y (index-y eye-index))
              (eye-z (index-z eye-index))
              (distance (+ view-distance 2)))
          (if show-chunks?
              (let ((j 0))
                (define (show state color)
                  (render-cubes
                    (lambda (render)
                      (loop (for i from (- eye-x distance) to (+ eye-x distance))
                            (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                  (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                         (+ (* (cast <fl> j) 16.) 8.)
                                                         (+ (* (cast <fl> k) 16.) 8.))))
                                    (when (in-frustum? camera center)
                                      (let ((chunk (find-chunk self i j k)))
                                        (when (and chunk (= (get-state chunk) state))
                                          (render center))))))))
                    wire-color: color
                    cull?: #t))
                
                (show Shaped red-dye)
                (show Populated blue-dye)
                (show Generated green-dye))
            (render-cubes
              (lambda (render)
                (loop (for i from (- eye-x distance) to (+ eye-x distance))
                      (loop (for j from (- eye-y distance) to (+ eye-y distance))
                            (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                  (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                         (+ (* (cast <fl> j) 16.) 8.)
                                                         (+ (* (cast <fl> k) 16.) 8.))))
                                    (when (in-frustum? camera center)
                                      (when (or show-sections? (find-section self i j k))
                                        (render center))))))))
              wire-color: red-dye
              cull?: #t))))))
  
  
  ;;;
  ;;;; Sectors
  ;;;
  
  
  (method (setup-sectors self)
    (let ((world (current-world)))
      (set! sector-radius (let ((half (/ sector-size 2.)))
                            (vertex-norm (vertex half half half))))
      (set! sector-diameter (* sector-radius 2))
      (set! sectors-mutex (make-mutex 'sectors))
      (let ((distance (get-view-distance world)))
        (let ((diameter (+ distance 1 distance)))
          (set! eye-radius distance)
          (set! eye-diameter diameter)
          (set! eye-diameter^2 (expt diameter 2))
          (set! eye-diameter^3 (expt diameter 3))
          (set! eye-sectors (make-eye-sectors self))
          (set! eye-neighbors (make-eye-neighbors self))))
      (set! sector/area-ratio (fxround/ sector-size area-size))))
  
  
  (method package (update-view-distance self old-distance distance)
    @convert-indexed-sector^^^
    (unless (= distance old-distance)
      (let ((diameter (+ distance 1 distance)))
        (let ((radius distance)
              (diameter^2 (expt diameter 2))
              (diameter^3 (expt diameter 3)))
          (define (index i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j radius) diameter^2)
               (* (+ k radius) diameter)
               (+ i radius)))
          
          (define (index-eye i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j eye-radius) eye-diameter^2)
               (* (+ k eye-radius) eye-diameter)
               (+ i eye-radius)))
          
          (let ((sectors (make-vector diameter^3 #f)))
            (cond ;; smaller
                  ((< distance old-distance)
                   (loop (for i from (- distance) to distance)
                         (loop (for j from (- distance) to distance)
                               (loop (for k from (- distance) to distance)
                                     (vector-set! sectors (index i j k) (vector-ref eye-sectors (index-eye i j k)))))))
                  ;; greater
                  (else
                   (loop (for i from (- old-distance) to old-distance)
                         (loop (for j from (- old-distance) to old-distance)
                               (loop (for k from (- old-distance) to old-distance)
                                     (vector-set! sectors (index i j k) (vector-ref eye-sectors (index-eye i j k))))))))
            (set! eye-radius radius)
            (set! eye-diameter diameter)
            (set! eye-diameter^2 diameter^2)
            (set! eye-diameter^3 diameter^3)
            (set! eye-sectors sectors)
            ;; greater so add new sectors
            (when (> distance old-distance)
              (let ((a (index-x eye-index))
                    (b (index-y eye-index))
                    (c (index-z eye-index)))
                (loop (for i from (- distance) to distance)
                      (loop (for j from (- distance) to distance)
                            (loop (for k from (- distance) to distance)
                                  (let ((index (index-eye i j k)))
                                    (unless (vector-ref eye-sectors index)
                                      (vector-set! sectors index (indexed-sector (+ a i) (+ b j) (+ c k))))))))))
            (set! eye-neighbors (make-vector diameter^3 #f))
            (update-eye-neighbors distance))))))
  
  
  (method package (position-sector-index self pos <vertex>) <index>
    (let ((size (cast <fl> sector-size)))
      (indexed (fxfloor (fl& (/ (vertex-x pos) size)))
               (fxfloor (fl& (/ (vertex-y pos) size)))
               (fxfloor (fl& (/ (vertex-z pos) size))))))
  
  
  (method (new-sector self index <index>) <Sector>
    (define (center i <fx>)
      (* (+ (cast <fl> i) .5) sector-size))
    
    (let ((x (index-x index))
          (y (index-y index))
          (z (index-z index)))
      (new Sector index (vertex (center x) (center y) (center z)) (index-expanse self index))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (iterate-sectors self proc)
    (when eye-neighbors
      (loop (for sector in-vector eye-neighbors)
            (when sector
              (proc sector)))))
  
  
  (proclaim (warn optimizations))
  
  
  (method package (iterate-section-neighbors self section-index <index> distance <fx> proc)
    (let ((a (index-x section-index))
          (b (index-y section-index))
          (c (index-z section-index)))
      (loop (for i from (- distance) to distance)
            (loop (for j from (- distance) to distance)
                  ;; $$$ try
                  (do (when (between? j 0 15)
                        (loop (for k from (- distance) to distance)
                              (let ((section (index-section self (indexed (+ a i) (+ b j) (+ c k)))))
                                (when section
                                  (proc section))))))))))
    
  
  ;; index of the eye sector
  (definition eye-index <index+>
    #f)
  
  ;; cube of all eye sectors
  (definition eye-sectors
    #f)
  
  ;; eye sectors ordered by distance
  (definition eye-neighbors
    #f)
  
  (definition eye-radius <fx>
    0)
  
  (definition eye-diameter <fx>
    0)
  
  (definition eye-diameter^2 <fx>
    0)
  
  (definition eye-diameter^3 <fx>
    0)
  
  
  (method package (get-eye-index self)
    eye-index)
  
  (method package (get-eye-sectors self) <vector>
    eye-sectors)
  
  (method package (get-eye-neighbors self) <vector>
    eye-neighbors)
    
  
  (method (sectors-index self i <fx> j <fx> k <fx>) <fx>
    (+ (* j eye-diameter^2) (* k eye-diameter) i))

  
  (method (make-eye-sectors self)
    (make-vector eye-diameter^3 #f))
  
  
  (method (make-eye-neighbors self)
    (make-vector eye-diameter^3 #f))
  
  
  (method (element-sector self element) <Sector+>
    ;; should iterate over every camera
    (find-eye-sector self (element-section-index self element)))
  
  
  (method (find-sector self index) <Sector+>
    ;; should iterate over every camera
    (find-eye-sector self index))
  
  
  (method (find-eye-sector self index)
    (and eye-index
         (let ((a (- (index-x eye-index) eye-radius))
               (b (- (index-y eye-index) eye-radius))
               (c (- (index-z eye-index) eye-radius)))
           (let ((i (- (index-x index) a))
                 (j (- (index-y index) b))
                 (k (- (index-z index) c))
                 (last (- eye-diameter 1)))
             (and (between? i 0 last)
                  (between? j 0 last)
                  (between? k 0 last)
                  (vector-ref eye-sectors (sectors-index self i j k)))))))
  
  
  (method (eye-sector self)
    (vector-ref eye-sectors (sectors-index self eye-radius eye-radius eye-radius)))
  
  
  (method (free-eye-sectors self)
    (set! eye-index #f)
    (loop (for n from 0 below eye-diameter^3)
          (let ((sector (vector-ref eye-sectors n)))
            (when sector
              (close sector)))
          (vector-set! eye-sectors n #f)
          (vector-set! eye-neighbors n #f)))
  
  
  (method package (eye-neighbor-sectors self index <index> distance <fx>) <vector>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ()
      (define (sector-new i j k)
        (new-sector self (indexed i j k)))
      
      (define (sector-free sector)
        (close sector))
      
      (if (and eye-index (index=? index eye-index))
          eye-neighbors
        ;; update sectors
        (let ((sectors (get-eye-sectors self))
              (a <fx> (- (index-x index) eye-radius))
              (b <fx> (- (index-y index) eye-radius))
              (c <fx> (- (index-z index) eye-radius)))
          (if (not eye-index)
              (loop (for i from 0 below eye-diameter)
                    (loop (for j from 0 below eye-diameter)
                          (loop (for k from 0 below eye-diameter)
                                (vector-set! sectors (sectors-index self i j k)
                                  (sector-new (+ a i)
                                              (+ b j)
                                              (+ c k))))))
            (let ((last (- eye-diameter 1))
                  (dx (- (index-x index) (index-x eye-index)))
                  (dy (- (index-y index) (index-y eye-index)))
                  (dz (- (index-z index) (index-z eye-index))))
              (define (by delta <fx>)
                (if (>= delta 0)
                    1
                  -1))
              
              (loop (for x start 0 end last by (by dx))
                    (let ((fx (+ x dx))
                          (tx x))
                      (loop (for y start 0 end last by (by dy))
                            (let ((fy (+ y dy))
                                  (ty y))
                              (loop (for z start 0 end last by (by dz))
                                    (let ((fz (+ z dz))
                                          (tz z))
                                      (let ((fi (and (between? fx 0 last)
                                                     (between? fy 0 last)
                                                     (between? fz 0 last)
                                                     (sectors-index self fx fy fz)))
                                            (ti (sectors-index self tx ty tz)))
                                        (let ((sector (vector-ref sectors ti)))
                                          (when sector
                                            ;; free
                                            (sector-free sector)))
                                        (if fi
                                            (begin
                                              ;; move
                                              (vector-set! sectors ti (vector-ref sectors fi))
                                              (vector-set! sectors fi #f))
                                          ;; new
                                          (vector-set! sectors ti (sector-new (+ a tx) (+ b ty) (+ c tz))))))))))))))
        ;; update neighbors
        (update-eye-neighbors self distance)
        (set! eye-index (copy-index index))
        eye-neighbors)))
  
  
  (method (update-eye-neighbors self distance <fx>)
    (let ((sectors eye-sectors)
          (neighbors eye-neighbors)
          (n 0))
      (define (set i j k)
        (vector-set! neighbors n (vector-ref sectors (sectors-index self (+ i distance) (+ j distance) (+ k distance))))
        (increase! n))
      
      ;; set neighbors in expanding distance from eye
      (set 0 0 0)
      (loop (for radius from 1 to distance)
            (let ((radius-1 (- radius 1)))
              ;; left
              (let ((i (- radius)))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; right
              (let ((i radius))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; bottom
              (let ((j (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; top
              (let ((j radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; back
              (let ((k (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))
              ;; front
              (let ((k radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (increase-sectors-generating self count <fx>)
    (mutex-lock! sectors-mutex)
    (when (= sectors-generating 0)
      (active-site 'visual))
    (set! sectors-generating (+ sectors-generating count))
    (mutex-unlock! sectors-mutex))
  
  
  (method package (decrease-sectors-generating self count <fx>)
    (mutex-lock! sectors-mutex)
    (set! sectors-generating (- sectors-generating count))
    (when (= sectors-generating 0)
      (inactive-site 'visual))
    (mutex-unlock! sectors-mutex))
  
  
  (method package (increase-sectors-generated self)
    (mutex-lock! sectors-mutex)
    (set! sectors-generated (+ sectors-generated 1))
    (mutex-unlock! sectors-mutex))
  
  
  (method (compute-floats self)
    (let ((total 0))
      (iterate-sectors self
        (lambda (sector)
          (let ((mesh (get-mesh sector)))
            (when mesh
              (let ((floats (count-floats mesh)))
                (when floats
                  (increase! total floats)))))))
      total))
  
  
  (method package (count-laden-sectors self)
    (let ((total 0))
      (iterate-sectors self
        (lambda (sector)
          (let ((mesh (get-mesh sector)))
            (when mesh
              (increase! total)))))
      total))
  
  
  (method package (toggle-debug-sectors self)
    (let ((world (current-world)))
      (set! debug-sectors? (not debug-sectors?))
      (update-parameter world 'debug-sectors)))
  
  
  (method package (draw-debug-sectors self)
    (draw-3d-grid (element-section-index self (current-me)) sector-size))
  
  
  ;;;
  ;;;; Areas
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-areas self)
    ;; temporary simplification by having processor retain everything
    (set! areas (make-table test: equal? weak-values: (standalone?) @wait-client-caching-chunks (not (processing?)))))
  
  
  (method (element-area-index self element <Element>) <index>
    (position-area-index self (get-position element)))
  
  
  (method package (position-area-index self pos <vertex>) <index>
    (let ((size (cast <fl> area-size)))
      (indexed (fxfloor (/ (vertex-x pos) size))
               (fxfloor (/ (vertex-y pos) size))
               (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method (element-area self element) <Area>
    (let ((index (element-area-index self element)))
      (indexed-area self (index-x index)
                    (index-y index)
                    (index-z index))))
  
  
  (method package (indexed-area self x <fx> y <fx> z <fx>) <Area>
    (let ((index (make-index&)))
      (index-x-set! index (fxfloor/ (* x area-size) section-size))
      (index-y-set! index (fxfloor/ (* y area-size) section-size))
      (index-z-set! index (fxfloor/ (* z area-size) section-size))
      (let ((area
              (or (table-ref areas index #f)
                  (let ((index (copy-index index)))
                    (let ((area (new Area index (index-expanse self index))))
                      (table-set! areas index area)
                      area)))))
        (update-physical area)
        area)))
  
  
  (method (find-area self index) <Area+>
    (table-ref areas index #f))
  
  
  (method (unlink-area self index)
    (table-clear areas index))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (iterate-areas self proc)
    @convert^^^
    (iterate-table areas
      proc))
  
  
  ;; putting area-cube here is a quicky to test travel-ray-polygons&
  (method package (iterate-position-neighbor-areas self pos distance <fx> area-cube proc)
    (if (and area-cube (<= distance (get-cube-radius area-cube)))
        (iterate-neighbor-areas area-cube pos distance proc)
      (let ((index (position-area-index self pos)))
        (let ((a (index-x index))
              (b (index-y index))
              (c (index-z index)))
          (loop (for i from (- distance) to distance)
                (loop (for j from (- distance) to distance)
                      (loop (for k from (- distance) to distance)
                            (let ((a (+ a i))
                                  (b (+ b j))
                                  (c (+ c k)))
                              (let ((area (indexed-area self a b c)))
                                (proc area
                                      (subarea-index area a b c)
                                      #t))))))))))
  
  
  (method (iterate-area-elements self area proc)
    (for-each proc (get-actors area))
    (for-each proc (get-entities area))
    (for-each proc (get-gadgets area)))
  
  
  (method (count-polygons self)
    0
    @convert^^^
    (let ((count 0))
      (iterate-table areas
        (lambda (index area)
          (let ((polygons (get-polygons area)))
            (when polygons
              (increase! count (fxround/ (f64vector-length polygons) polygon-float-size))))))
      count))
  
  
  (method package (toggle-debug-areas self)
    (let ((world (current-world)))
      (set! debug-areas? (not debug-areas?))
      (update-parameter world 'debug-areas)))
  
  
  (method package (draw-debug-areas self)
    (draw-3d-grid (element-area-index self (current-me)) area-size))
  
  
  ;;;
  ;;;; Expanses
  ;;;
  
  
  (method (setup-expanses self)
    ;; temporary simplification by having processor retain everything
    (set! expanses (make-table test: equal? weak-values: (standalone?) @wait-client-caching-chunks (not (processing?)))))
  
  
  (method (index-expanse self index <index>) <Expanse>
    (or (table-ref expanses index #f)
        (let ((index (copy-index index)))
          (let ((expanse (new Expanse)))
            (table-set! expanses index expanse)
            expanse))))
  
  
  (method (element-expanse self element)
    (index-expanse self (element-section-index self element)))
  
  
  ;;;
  ;;;; Gadget
  ;;;
  
  
  (method (draw-gadgets self)
    (for-each (lambda (gadget)
                (register-entity gadget #t))
              gadgets))
  
  
  (method (draw-drawable-gadgets self)
    (for-each (lambda (gadget)
                (when (and (renderable? gadget)
                           (get-visible? gadget))
                  (register-entity gadget)))
              gadgets))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (method package (render-task self task <Task>)
    (render-task (current-world) task))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method package (find-player self name)
    (find-if (lambda (player)
               (equal? (get-name player) name))
             players))
  
  
  (method package (resurrect-player self player)
    (let ((new-position (find-spawnpoint self)))
      (set-position player new-position)
      (set-velocity player (vertex 0. 0. 0.))
      (set-fall-velocity player (vertex 0. 0. 0.))
      (verify-water player)))
  
  
  (method package virtual (player-task self task <Task>)
    (player-task (current-world) task))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method package virtual (missile-task self task <Task>)
    (missile-task (current-world) task))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method package (tick-task self task <Task>)
    (tick-task (current-world) task))
  
  
  ;;;
  ;;;; Actors
  ;;;
  
  
  (method package (actors-task self task <Task>)
    (actors-task (current-world) task))
  
  
  ;;;
  ;;;; Sun
  ;;;
  
  
  (method (sun-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (if (not sun-cycle?)
              (task-sleep task +infinity 0. exit)
            (let (iter (previous (current-seconds)))
              (let ((time (current-seconds)))
                (let ((elapse (- time previous)))
                  (with-task-mutex
                    (lambda ()
                      (unless (get-paused? history)
                        (unless (stopping? task)
                          (tick-sun self elapse)))))
                  (let ((duration (- (current-seconds) time)))
                    (task-sleep task sun-period duration exit))
                  (iter time)))))))))
  
  
  (method (tick-sun self elapse)
    (site (sun on?: #t)
      (position-sun self elapse)))
  
  
  (method package (position-sun self elapse (angle: angle #f))
    (define (calculate-angle)
      (flmodulo (+ sun-angle (* (sun-speed) elapse)) PI*2))
    
    (define (sun-speed)
      (/ PI*2 day-duration))
    
    (set! sun-angle (or angle (calculate-angle)))
    (when (window?)
      (let ((under-limit 0.1)
            (direction (rotate-vertex-upon& PI/4 (vertex 0.0 1.0 0.0) (rotate-vertex-upon& sun-angle (vertex 0.0 0.0 -1.0) (vertex -1. 0. 0.)))))
        (let ((pos (vertex-scalar*& direction 1000.)))
          (when (not sun)
            (set! sun (new Sun parent: self position: pos))
            (add-element self sun))
          (cond ((or (< sun-angle (+ PI under-limit))
                     (> sun-angle (- PI*2 under-limit)))
                 (let (@wait-sun-on-player/material (coord (vertex-scalar* direction 1000.))
                       (under (cond ((> sun-angle (- PI*2 under-limit)) (- PI*2 sun-angle))
                                    ((and (> sun-angle PI) (< sun-angle (+ PI under-limit))) (- sun-angle PI))
                                    (else 0.))))
                   (let ((intensity (- 1.0 (/ under under-limit))))
                     (let ((effective (dye (* (dye-red sun-color) intensity)
                                           (* (dye-green sun-color) intensity)
                                           (* (dye-blue sun-color) intensity)
                                           1.0)))
                       @wait-sun-on-player/material (set-sun-effective lighting effective)
                       @wait-sun-on-player/material (set-sun-coordinates lighting coord)
                       (set-position-noupdate sun pos)
                       (set-color sun effective)
                       (set-visible? sun #t)))))
                (else
                 (set-sun-effective lighting (dye 0. 0. 0. 0.))
                 (set-visible? sun #f))))))
    (sun-update self))
  
  
  (method (sun-update self)
    (set-daytime self (sun-angle->daytime self sun-angle)))
  
  
  (method (register-sun self)
    (register-entity sun))
  
  
  ;;;
  ;;;; Daytime
  ;;;
  
  
  (method package (goto-daytime self daytime)
    (if sun-cycle?
        (position-sun self #f angle: (daytime->sun-angle self daytime))
      (set-daytime self daytime)))
  
  
  (method (sun-angle->daytime self sun-angle)
    (let ((angle (flmodulo sun-angle PI*2)))
      (flmodulo (+ (/ (* angle day-span) PI*2) dawn-daytime) day-span)))
  
  
  (method (daytime->sun-angle self daytime)
    (/ (* (- daytime dawn-daytime) PI*2) day-span))
  
  
  (method package (effective-daytime self daytime)
    (cond ((flonum? daytime) daytime)
          ((or (eq? daytime 'default) (ci=? daytime "default")) dawn-daytime)
          ((or (eq? daytime 'dawn) (ci=? daytime "dawn")) dawn-daytime)
          ((or (eq? daytime 'day) (ci=? daytime "day")) day-daytime)
          ((or (eq? daytime 'dusk) (ci=? daytime "dusk")) dusk-daytime)
          ((or (eq? daytime 'night) (ci=? daytime "night")) night-daytime)
          ((string? daytime) (cast <fl> (string->number daytime)))
          (else (error "Invalid daytime: {s}" daytime))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method (gravity-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history))
          (universe (current-universe)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds)))
              (let ((elapse (- time previous)))
                (with-task-mutex
                  (lambda ()
                    (unless (get-paused? history)
                      (unless (stopping? task)
                        (let ((blocks (get-fall-blocks universe)))
                          (unless (queue-empty? blocks)
                            (set-fall-blocks universe (new-queue))
                            (tick-gravity self elapse blocks)))))))
                (task-sleep task gravity-period (- (current-seconds) time) exit)
                (iter time))))))))
  
  
  (method (tick-gravity self elapse blocks)
    (site (gravity on?: #t)
      (blocks-fall self elapse blocks)))
  
  
  (method (blocks-fall self elapse blocks)
    (let ((universe (current-universe)))
      (updating-sections self
        (lambda (add-section)
          (let (iter)
            (unless (queue-empty? blocks)
              (bind (section . index) (dequeue blocks)
                (bind-index (i j k) index
                  (call-with-section self section i j k
                    (lambda (section block <fx> data <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                      (define (effective-block-ref i j k)
                        (with-field i j k
                          (lambda (section index)
                            (if section
                                (block-ref section index)
                              0))))
                      
                      (define (add-neighbors i j k)
                        (define (add-neighbor i j k)
                          (with-field i j k
                            (lambda (section index)
                              @w(when (id? (block-ref section index) SandBlock Gravel)
                                  (normalize-section/coordinates section i j k with-field
                                    (lambda (section i j k)
                                      (add-fall-block universe section i j k))))
                              ;; EH validate
                              (when section
                                (add-section section)))))
                        
                        (add-neighbor (+ i 1) j k)
                        (add-neighbor (- i 1) j k)
                        (add-neighbor i (+ j 1) k)
                        (add-neighbor i (- j 1) k)
                        (add-neighbor i j (+ k 1))
                        (add-neighbor i j (- k 1)))
                      
                      (when (and (id? block SandBlock Gravel) (id? (effective-block-ref i (- j 1) k) Air Water StationaryWater Lava StationaryLava))
                        (with-field i j k
                          (lambda (section index)
                            (block-set! section index 0)
                            (add-neighbors i j k)
                            (inverse-propagate-light universe i j k add-section with-field block-ref blocklight-ref blocklight-set!)
                            (redstone-update section (list i j k block) add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!))))))))
              (iter))))
        delay-update?: #t)))
  
  
  ;;;
  ;;;; Distance
  ;;;
  
  
  (method (distance-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds)))
              (let ((elapse (- time previous)))
                (with-task-mutex
                  (lambda ()
                    (unless (get-paused? history)
                      (unless (stopping? task)
                        (tick-distance self elapse)))))
                (let ((duration (- (current-seconds) time)))
                  (task-sleep task distance-period duration exit))
                (iter time))))))))
  
  
  (method (tick-distance self elapse)
    (site (distance on?: #t)
      (let ((me (current-me+)))
        ;; quick solution that should be generalized for server-side
        (when me
          (check-distance self elapse me)))))
  
  
  (method (check-distance self elapse me)
    (let ((world (current-world)))
      (let ((chest (get-opened-chest self))
            (creatures (get-aggroed-creatures me))
            (pos (get-position me)))
        ;; water
        (verify-water me)
        ;; chest
        (when chest
          (bind (section index coordinates) chest
            (let ((location (section/coordinates->location section coordinates)))
              (let ((dist (vertex-distance (vertex (+ (index-x location) .5)
                                                   (+ (index-y location) .5)
                                                   (+ (index-z location) .5))
                                           pos)))
                (when (> dist (if (user?)
                                  (world-setting 'world.interaction-distance 8.)
                                20.))
                  (play-ambient-sound "sound/random/chestclosed" volume: .5)
                  (hide-chest world)
                  (hide-bag world)
                  (set-opened-chest self #f))))))
        ;; aggro
        (when creatures
          (for-each (lambda (creature)
                      (when (> (vertex-distance pos (get-position creature)) (get-aggro-radius creature))
                        (set-aggro-target creature #f)
                        (set! creatures (remove! creature creatures test: equal?))))
                    creatures))
        (set-aggroed-creatures me creatures))))
  
  
  ;;;
  ;;;; Eat
  ;;;
  
  
  (method (eat-task self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (with-task-mutex
              (lambda ()
                (unless (get-paused? history)
                  (unless (stopping? task)
                    (tick-eat self task exit)))))
            (task-sleep task eat-period 0. exit)
            (iter))))))
  
  
  (method (tick-eat self task exit)
    (site (eat on?: #t)
      (let ((interface (current-interface+))
            (me (current-me+)))
        ;; quick solution that should be generalized for server-side
        (when me
          (let ((eating (get-eating me)))
            (when eating
              (let ((eating-ticks (get-eating-ticks me)))
                (set-life me (min (+ (get-life me) eating) 100.))
                (when interface
                  (invalidate-view (child interface 'combat)))
                (let ((eating-ticks (- (get-eating-ticks me) 1)))
                  (if (> eating-ticks 0)
                      (set-eating-ticks me eating-ticks)
                    (set-eating me #f)
                    (set-eating-ticks me #f))))))))))
  
  
  ;;;
  ;;;; Day
  ;;;
  
  
  (method (set-daytime self time)
    (set! daytime time)
    (set! daylight (daytime->daylight self time)))
  
  
  (method (daytime->daylight self daytime)
    ;; night
    (cond ((< daytime 6000.)
           0.)
          ;; dawn
          ((< daytime 9000.)
           (/ (- daytime 6000.) 3000.))
          ;; day
          ((< daytime 18000.)
           1.)
          ;; dusk
          ((< daytime 21000.)
           (/ (- 21000. daytime) 3000.))
          ;; night
          (else
           0.)))
  
  
  ;;;
  ;;;; Lighting
  ;;;
  
  
  (definition default-lights-cache
    #f)
  
  
  (method (effective-lights self) <list>
    (define (default-lights)
      (or default-lights-cache
          (let ((lights (list (new Light-Ambient position: (vertex 10000. 10. 10000.)))))
            (set! default-lights-cache lights)
            lights)))
    
    (let ((world (current-world)))
      (if (get-lighting? world)
          (let ((lights (collect-lights self)))
            (if (null? lights)
                (default-lights)
              lights))
        '())))
  
  
  (method package (effective-player-glow self)
    player-glow)
  
  
  (method package (setup-lighting self)
    (lighting-setup self)
    (block-lighting-setup self))
  
  
  (method (lighting-setup self)
    (let ((world (current-world)))
      (let ((lights (effective-lights self)))
        (let ((light (max .1 (/ daylight 5.))))
          (set-ambient-color lighting (dye (+ (dye-red ambient-color) light)
                                            (+ (dye-green ambient-color) light)
                                            (+ (dye-blue ambient-color) light)
                                            1.0)))
        (set-lights lighting lights)
        (set-lights-count lighting (min (get-dynamic-lights world) (length lights)))
        @wait-sun-on-player/material 
        (cond (sun-cycle?
               (set-sun-effective lighting sun-color)
               (set-sun-coordinates lighting (vertex 10000.0 10000.0 10000.0)))
              (else
               (set-sun-effective lighting (dye 0. 0. 0. 0.))
               (set-sun-coordinates lighting (vertex 0. 0. 0.))))
        (set-current-lighting lighting))))
  
  
  (method (block-lighting-setup self)
    (let ((world (current-world)))
      (let ((lights '()))
        (set-ambient-color block-lighting ambient-color)
        (set-lights block-lighting lights)
        (set-lights-count block-lighting 0)
        (set-current-block-lighting block-lighting))))
  
  
  (method (iterate-lights self proc)
    (iterate-gadgets self
      (lambda (gadget)
        (when (is? gadget Light)
          (proc gadget)))))
  
  
  (method (collect-lights self)
    (let ((queue (new-queue)))
      (iterate-lights self
        (lambda (light)
          (enqueue queue light)))
      (queue-list queue)))
  
  
  (method (count-lights self)
    (let ((count 0))
      (iterate-lights self
        (lambda (light)
          (increase! count)))
      count))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method public (iterate-gravities self proc)
    (for-each proc gravities))
  
  
  (method public (iterate-planets self proc)
    (iterate-gravities self
      (lambda (well)
        (when (is? well Planet)
          (proc well)))))
  
  
  (method public (collect-planets self)
    (let ((queue (new-queue)))
      (iterate-planets self
        (lambda (planet)
          (enqueue queue planet)))
      (queue-list queue)))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method package (reset-marks self)
    (set! marks '()))
  
  
  (method (set-marks self lst)
    (set! marks lst))
  
  
  (method (set-mark self mark)
    (set! marks (list mark)))
  
  
  (method package (add-mark self mark)
    (set! marks (cons mark marks)))
  
  
  (method (remove-mark self mark)
    (set! marks (remove! mark marks)))
  
  
  (method (draw-marks self)
    (for-each (lambda (mark)
                (when (is-not? mark world.mark:Polygon-Mark)
                  (draw mark)))
              marks)
    (for-each (lambda (mark)
                (when (is? mark world.mark:Polygon-Mark)
                  (draw mark)))
              marks))
  
  
  (method package (reset-all-marks self)
    (let ((world (current-world)))
      (reset-marks self)
      (display-message world "Marks reset")))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method package virtual (zone-editable? self)
    (and editable? (not (admin?))))
  
  
  (method package virtual (zone-destructible? self)
    #f)
  
  
  ;;;
  ;;;; Atlas
  ;;;
  
  
  (method (draw-atlas self)
    @convert-effective-material
    (let ((world (current-world)))
      (unless texture-arrays?
        (let ((texture (get-texture (let ((elem (first-target world)))
                                      (if (is? elem Entity)
                                          (effective-material elem)
                                        (get-block-atlas world)))))
              (width 100.)
              (height 100.))
          (map-texture texture)
          (textured-quad texture
            (lambda () (glVertex3f 0.0 0.0 0.0))
            (lambda () (glVertex3f width 0.0 0.0))
            (lambda () (glVertex3f width height 0.0))
            (lambda () (glVertex3f 0.0 height 0.0)))))))
  
  
  ;;;
  ;;;; Heightmap
  ;;;
  
  
  @convert^^^
  (method (generate-heightmap-old sector <Sector> heightmap <f32vector> from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (define (generate-done)
      (set-visual-uptodate? sector #t)
      (set-visual-revision sector (get-revision generator))
      (set-visual-generating? sector #f)
      (decrease-sectors-generating 1))
    
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1)))
      (let ((count (f32vector-length heightmap)))
        (let ((vertices (make-vector count))
              (normals (make-vector count)))
          (define (get-vertex x <fx> z <fx>)
            (vector-ref vertices (+ (* x z-count) z)))
          
          (define (get-normal x <fx> z <fx>)
            (vector-ref normals (+ (* x z-count) z)))
          
          ;; fill vertices
          (loop (for x from 0 below x-count)
                (loop (for z from 0 below z-count)
                      (let ((index (+ (* x z-count) z)))
                        (let ((height (f32vector-ref heightmap index)))
                          (let ((x (cast <fl> (+ from-x x)))
                                (y (cast <fl> height))
                                (z (cast <fl> (+ from-z z))))
                            (vector-set! vertices index (vertex x y z))
                            (vector-set! normals index (vertex 0. 0. 0.)))))))
          ;; add triangles
          (let ((squares (make-vector (* width depth)))
                (sectors (make-table test: eq?))
                (areas (make-table test: eq?))
                (default-image (get-default-image world)))
            (let ((material (get-material-opaque world))
                  (uv (image-rect (get-block-atlas world) default-image)))
              (let ((tl (uv-left uv))
                    (tt (uv-top uv))
                    (tr (uv-right uv))
                    (tb (uv-bottom uv))
                    (texture-depth (uv-depth uv)))
                (define (safe-square x <fx> z <fx>)
                  (and
                    (>= x 0) (< x width)
                    (>= z 0) (< z depth)
                    (get-square x z)))
                
                (define (get-square x <fx> z <fx>)
                  (vector-ref squares (+ (* x depth) z)))
                
                (define (set-square x <fx> z <fx> square)
                  (vector-set! squares (+ (* x depth) z) square))
                
                (define (make-square t1 t2)
                  (cons t1 t2))
                
                (define (square-t1 square) <Smooth-Triangle>
                  (get-polygon (cast <Face> (car square))))
                
                (define (square-t2 square) <Smooth-Triangle>
                  (get-polygon (cast <Face> (cdr square))))
                
                (define (add-face face <Face>)
                  (let ((center (get-center (get-polygon face))))
                    (let ((sector #f @$$$ (index-sector (position-sector-index center))))
                      (table-add sectors sector face))
                    (when (eq? what 'physical)
                      (let ((area (index-area (position-area-index center) #f)))
                        (table-add areas area (get-polygon face))))))
                
                (define (add-triangle v1 v2 v3)
                  (let ((normal (plane-normal v1 v2 v3)))
                    (let ((face
                            (if (> (vertex-x v1) (vertex-x v2))
                                (make-face material
                                           (f32vector tl tb tr tb tr tt)
                                           texture-depth
                                           (make-smooth-triangle self
                                                                 v1 v2 v3
                                                                 normal normal normal))
                              (make-face material
                                         (f32vector tr tt tl tt tl tb)
                                         texture-depth
                                         (make-smooth-triangle self
                                                               v1 v2 v3
                                                               normal normal normal)))))
                      (add-face face)
                      face)))
                
                ;; add triangles
                (loop (for x from 0 below width)
                      (loop (for z from 0 below depth)
                            (let ((v1 (get-vertex x (+ z 1)))
                                  (v2 (get-vertex (+ x 1) (+ z 1)))
                                  (v3 (get-vertex (+ x 1) z))
                                  (v4 (get-vertex x z)))
                              (let ((triangle1 (add-triangle v1 v2 v3))
                                    (triangle2 (add-triangle v3 v4 v1)))
                                (set-square x z (make-square triangle1 triangle2))))))
                ;; smooth normals
                (loop (for x from 0 below x-count)
                      (loop (for z from 0 below z-count)
                            (let ((normal (get-normal x z))
                                  (tl (safe-square (- x 1) (- z 1)))
                                  (tr (safe-square x (- z 1)))
                                  (bl (safe-square (- x 1) z))
                                  (br (safe-square x z)))
                              (when tl
                                (vertex-increase! normal (get-normal (square-t1 tl))))
                              (when tr
                                (vertex-increase! normal (get-normal (square-t1 tr)))
                                (vertex-increase! normal (get-normal (square-t2 tr))))
                              (when bl
                                (vertex-increase! normal (get-normal (square-t1 bl)))
                                (vertex-increase! normal (get-normal (square-t2 bl))))
                              (when br
                                (vertex-increase! normal (get-normal (square-t2 br))))
                              (vertex-normalize! normal normal))))
                ;; update normals
                (loop (for x from 0 below width)
                      (loop (for z from 0 below depth)
                            (let ((square (get-square x z)))
                              (set-n1 (square-t1 square) (get-normal x (+ z 1)))
                              (set-n2 (square-t1 square) (get-normal (+ x 1) (+ z 1)))
                              (set-n3 (square-t1 square) (get-normal (+ x 1) z))
                              (set-n1 (square-t2 square) (get-normal (+ x 1) z))
                              (set-n2 (square-t2 square) (get-normal x z))
                              (set-n3 (square-t2 square) (get-normal x (+ z 1))))))
                (case what
                  ((physical)
                   (iterate-table areas
                     (lambda (area <Area> polygons)
                       (add-polygons area #f polygons #f))))
                  ((visual)
                   (iterate-table sectors
                     (lambda (sector faces)
                       (bind-values (vertices neighbors) (prepare-vertices/neighbors sector faces)
                         (let ((lightmap (prepare-lightmap sector faces)))
                           (with-render-mutex
                             (lambda ()
                               (free-material-mesh sector)
                               (setup-material-mesh sector)
                               (let ((mesh (get-material-mesh sector)))
                                 (fill-vertices/neighbors sector mesh #f vertices neighbors)
                                 (fill-lightmap sector mesh #f lightmap)
                                 (setup-array mesh))
                               (generate-done))))))))))))))))
    
  
  ;;;
  ;;;; Level
  ;;;

  
  (method protected (get-level-file self)
    (or level-file
        (let ((file (new-file level-dir "level.dat")))
          (set! level-file file)
          file)))
  
  
  (method public (get-level-state self)
    (or level-state
        (let ((state (read/create-level self)))
          (set! level-state state)
          state)))
  
  
  (method (read/create-level self)
    (let ((file (get-level-file self)))
      (if (exists? file)
          (read-level self file)
        (create-level self))))
  
  
  (method (read-level self file)
    (with ((reader <NBT-Reader> (new NBT-Reader file compressed?: #t gzip?: #t)))
      (read-tag reader)))
  
  
  (method (create-level self)
    (let ((spawnpoint (or start-spawnpoint (vertex 0. 50. 0.))))
      (make-tag "" TAG_Compound
        (list
          (make-tag "Data" TAG_Compound
            (list
              (make-tag "Player" TAG_Compound
                (list
                  (make-tag "Inventory" TAG_List (make-list-payload TAG_Compound '()))))
              (make-tag "SpawnX" TAG_Int (fxround (vertex-x spawnpoint)))
              (make-tag "SpawnY" TAG_Int (fxround (vertex-y spawnpoint)))
              (make-tag "SpawnZ" TAG_Int (fxround (vertex-z spawnpoint)))
              (make-tag "LevelName" TAG_String "New")
              (make-tag "version" TAG_Int 19133)))))))
  
  
  (method public (save-level-state self)
    (save-level self (get-level-state self) (get-level-file self)))
  
  
  (method (save-level self level file)
    (create-directories file)
    (with ((writer (new NBT-Writer file compressed?: #t gzip?: #t)))
      (write-tag writer level)))
  
  
  (method package (find-spawnpoint self)
    (or (get-player-spawnpoint self)
        (get-spawnpoint self)))
  
  
  (method package (find-spawnlookat self)
    (make-standard-lookat))
  
  
  (method package (get-spawnpoint self)
    (let ((tag (get-level-state self)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-assoc "SpawnX" compound))
              (y (tag-assoc "SpawnY" compound))
              (z (tag-assoc "SpawnZ" compound)))
          (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z))))))
  
  
  (method package (set-spawnpoint self pos)
    (let ((tag (get-level-state self)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-find "SpawnX" compound))
              (y (tag-find "SpawnY" compound))
              (z (tag-find "SpawnZ" compound)))
          (tag-set x (fxround (vertex-x pos)))
          (tag-set y (fxround (vertex-y pos)))
          (tag-set z (fxround (vertex-z pos)))))))
  
  
  (method package (get-player-spawnpoint self)
    (let ((tag (get-level-state self)))
      (let ((player (tag-assoc "Player" (tag-assoc "Data" (tag-value tag)))))
        (let ((x (tag-assoc "SpawnX" player))
              (y (tag-assoc "SpawnY" player))
              (z (tag-assoc "SpawnZ" player)))
          (and x y z (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z)))))))
  
  
  (method package (set-player-spawnpoint self pos)
    (let ((tag (get-level-state self)))
      (let ((player (tag-find "Player" (tag-assoc "Data" (tag-value tag)))))
        (tag-add player "SpawnX" TAG_Int (fxround (vertex-x pos)))
        (tag-add player "SpawnY" TAG_Int (fxround (vertex-y pos)))
        (tag-add player "SpawnZ" TAG_Int (fxround (vertex-z pos))))))
  
  
  (method package (teleport self pos (sight #f))
    (let ((world (current-world))
          (me (current-me)))
      (let ((eye (get-eye world)))
        (person-motion world feedback?: #f)
        (set-position me pos)
        (cond ((not sight)
               (derive-target eye)
               (camera-update eye))
              (else
               (set-lookat me (horizon-lookat sight))
               (eye-behind-player world)
               (follow-player world))))))
  
  
  (method (explode-blocks self tnts blocks)
    (play-ambient-sound "sound/random/explode" volume: .25)
    (updating-sections self
      (lambda (add-section)
        (for-each (lambda (tnt)
                    (remove-block! self tnt add-section))
                  tnts)
        (for-each (lambda (block)
                    (remove-block! self block add-section)) blocks))
      delay-update?: #t))
  
  
  (method (reveal-chests self command-block blocks)
    (updating-sections self
      (lambda (add-section)
        (loop (for x from 0 below (fxceiling (/ (length blocks) 6.)))
              (let ((pos (random-element blocks)))
                (set! blocks (remove pos blocks test: equal?))
                (place-block! self pos RedstoneTorchOn add-section)))
        (remove-block self (car command-block) add-section))))
  
  
  (method (testfor-action self command-block test action)
    (call-with-position self (car test)
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (when (= block-id (cdr test))
          (updating-sections self
            (lambda (add-section)
              (case (cdr action)
                ((remove) (remove-block self (car action) add-section))
                ((delete) (remove-block! self (car action) add-section))
                ((add)    (place-block! self (caar action) (cdar action) add-section)))
              (remove-block self (car command-block) add-section)))))))
  
  
  (method (remove-block self pos add-section)
    (call-with-position self pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (with-field i j k
          (lambda (section index)
            (add-section section)
            (block-set! section index 0)
            (data-set! section index 0))))))
  
  
  (method (remove-block! self pos add-section)
    (call-with-position self pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (delete-block (current-universe) #f section block-id data-id i j k x y z add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (place-block! self pos block add-section)
    (call-with-position self pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (add-block (current-universe) #f #f block section block-id data-id i j k x y z add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (on-toggle-glow self evt)
    (let ((world (current-world)))
      (if (= player-glow -1.)
          (set! player-glow 300.)
        (set! player-glow -1.))
      (update-parameter world 'glow)))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method package (call-with-position self pos <vertex> proc (create?: create? #t))
    (let ((section (position-section self pos create?: create?)))
      (and section
           (let ((x (fxfloor (vertex-x pos)))
                 (y (fxfloor (vertex-y pos)))
                 (z (fxfloor (vertex-z pos))))
             (let ((section-index (get-index section)))
               (let ((section-x (index-x section-index))
                     (section-y (index-y section-index))
                     (section-z (index-z section-index)))
                 (let ((i (- x (* section-x 16)))
                       (j (- y (* section-y 16)))
                       (k (- z (* section-z 16))))
                   (call-with-section self section i j k proc))))))))
  
  
  (method package (call-with-section self section i <fx> j <fx> k <fx> proc)
    (with-index section
      (lambda (section-x section-y section-z)
        (let ((region (get-region (get-chunk section))))
          (let ((region-x (get-x region))
                (region-z (get-z region))
                (chunk-x (section->chunk section-x))
                (chunk-z (section->chunk section-z))
                (sections (neighbor-sections section section-x section-y section-z)))
            (let ((bottom-section? (= section-y (cast <fx> (or truncate-y 0))))
                  (position-x (+ (* region-x 32 16) (* chunk-x 16) i))
                  (position-y (+ (* section-y 16) j))
                  (position-z (+ (* region-z 32 16) (* chunk-z 16) k))
                  (blocks (get-blocks section))
                  (data (get-data section))
                  (blocklight (get-blocklight section))
                  (skylight (get-skylight section)))
              (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                (vector-ref sections (section-index a b c)))
              
              (define (section-index a <fx> b <fx> c <fx>) <fx>
                (+ (* b 9) (* c 3) a 13))
              
              (define (local-index i <fx> j <fx> k <fx>) <fx>
                (+ (* j 256) (* k 16) i))
              
              (define (block-ref section local-index <fx>) <fx>
                (u8vector-ref (cast <u8vector> (get-blocks section)) local-index))
              
              (define (block-set! section local-index <fx> block-id <fx>)
                (u8vector-set! (cast <u8vector> (get-blocks section)) local-index block-id))
              
              (define (data-ref section local-index <fx>) <fx>
                (u4vector-ref (cast <u8vector> (get-data section)) local-index))
              
              (define (data-set! section local-index <fx> data-id <fx>)
                (u4vector-set! (cast <u8vector> (get-data section)) local-index data-id))
              
              (define (blocklight-ref section local-index <fx>) <fx>
                (u4vector-ref (cast <u8vector> (get-blocklight section)) local-index))
              
              (define (blocklight-set! section local-index <fx> blocklight <fx>)
                (u4vector-set! (cast <u8vector> (get-blocklight section)) local-index blocklight))
              
              (define (skylight-ref section local-index <fx>) <fx>
                (u4vector-ref (cast <u8vector> (get-skylight section)) local-index))
              
              (define (skylight-set! section local-index <fx> skylight <fx>)
                (u4vector-set! (cast <u8vector> (get-skylight section)) local-index skylight))
              
              (define (u4vector-ref field <u8vector> index <fx>) <fx>
                (let ((byte (u8vector-ref field (quotient index 2))))
                  (if (even? index)
                      (bitwise-and byte #x0F)
                    (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
              
              (define (u4vector-set! field <u8vector> index <fx> value <fx>)
                (let ((offset (quotient index 2)))
                  (let ((byte (u8vector-ref field offset)))
                    (u8vector-set! field offset
                      (if (even? index)
                          (bitwise-ior value (bitwise-and byte #xF0))
                        (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4)))))))
              
              (define (with-field i <fx> j <fx> k <fx> proc)
                (define (bind-i a <fx> i <fx>)
                  (define (bind-j b <fx> j <fx>)
                    (define (bind-k c <fx> k <fx>)
                      (let ((section (section-ref a b c)))
                        (proc section (local-index i j k))))
                    
                    (cond ((< k 0) (bind-k (- (quotient k 16) 1) (modulo k 16)))
                          ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                          (else (bind-k 0 k))))
                  
                  (cond ((< j 0) (bind-j (- (quotient j 16) 1) (modulo j 16)))
                        ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                        (else (bind-j 0 j))))
                
                (cond ((< i 0) (bind-i (- (quotient i 16) 1) (modulo i 16)))
                      ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                      (else (bind-i 0 i))))
              
              (let ((index (local-index i j k)))
                (let ((block-id (block-ref section index))
                      (data-id (data-ref section index)))
                  (let ((x (fl& (+ block-radius (cast <fl> position-x))))
                        (y (fl& (+ block-radius (cast <fl> position-y))))
                        (z (fl& (+ block-radius (cast <fl> position-z)))))
                    (proc section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))))))))
  
  
  (method package (updating-sections self proc (delay-update?: delay-update? #f))
    (define (update-sections sections)
      (for-each (lambda (section)
                  (let ((area (find-area self (get-index section))))
                    (when area
                      (clear-polygons area)
                      (set-physical-uptodate? area #f)))
                  ;; should iterate over every camera
                  (let ((eye-sector (find-eye-sector self (get-index section))))
                    (when eye-sector
                      (set-visual-uptodate? eye-sector #f)
                      (unless (and delay-update? delay-updating?)
                        (set-visual-generating? eye-sector #t) ;; $$$ was sector. is this correct?
                        (increase-sectors-generating self 1)
                        (instantiate-visual eye-sector))))
                  (modified (get-chunk section)))
                sections))
    
    (define (save-regions)
      (iterate-regions self
        (lambda (region)
          (save-region region))))
    
    (let ((sections '()))
      (define (add-section section)
        (unless (memq? section sections)
          (set! sections (cons section sections))))
      
      (let ((timer (new Timer)))
        (define (updating)
          (prog1 (proc add-section)
            (update-sections sections)
            (save-regions)))
        
        (prog1 (updating)
          (when report-updating?
            (let ((world (current-world)))
              (let ((count (length sections))
                    (duration (real-duration-in-milliseconds timer)))
                (display-message world (format "Updated {a} section{a} ({a}ms)" count (format-plural count) duration)))))))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method package (evaluate-zone-hook self forms syntax str container line col)
    (let ((ids (collect (lambda (form)
                          (and (pair? form) (eq? (car form) 'define-block)
                            (third form)))
                        forms)))
      (cond ((not-null? ids)
             (reset-inventory-blocks)
             @$$$
             (updating-sections
               (lambda (add-section)
                 (finding-visual-blocks ids
                   add-section)
                 (finding-physical-blocks ids
                   (lambda (area)
                     (add-section (get-section area)))))))
            @$$$
            ((search container "world/external/minecraft")
             (updating-sectors
               (lambda (add-sector)
                 (add-sector (element-sector (current-me)))))))))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  (method package (block-at self pos)
    (or (call-with-position self pos
          (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
            block-id)
          create?: #f)
        Air))
  
  
  (method package (block/data-at self pos)
    (call-with-position self pos
      (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (cons block-id data-id))
      create?: #f))
  
  
  (method (find-visual-blocks self ids)
    (let ((queue (new-queue)))
      (iterate-sectors self
        (lambda (sector)
          (sector-iterate-blocks self sector ids
            (lambda (found)
              (enqueue queue (cons sector (index->coordinates found)))))))
      (queue-list queue)))
  
  
  (method (finding-visual-blocks self ids proc)
    (iterate-sectors self
      (lambda (sector)
        (when (sector-contains-blocks? self sector ids)
          (proc sector)))))
  
  
  (method (sector-contains-blocks? self sector ids)
    (continuation-capture
      (lambda (found)
        (sector-iterate-blocks self sector ids
          (lambda (ignore)
            (continuation-return found #t)))
        #f)))
  
  
  (method (sector-iterate-blocks self sector ids proc)
    (let ((section (index-section self (get-index sector))))
      (when section
        (section-iterate-blocks self section ids proc))))
  
  
  (method package (section-iterate-blocks self section ids proc)
    (let ((blocks (get-blocks section)))
      (for-each (lambda (id)
                  (let (iter (pos 0))
                    (let ((found (u8vector-find id blocks (u8vector-length blocks) pos)))
                      (when found
                        (proc found)
                        (iter (+ found 1))))))
                ids)))
  
  
  (method (section-count-blocks self section)
    (let ((blocks (get-blocks section))
          (count 0))
      (loop (for n from 0 below 4096)
            (let ((block (u8vector-ref blocks n)))
              (when (/= block Air)
                (increase! count))))
      count))
  
  
  (method (finding-physical-blocks self ids proc)
    @convert^^^
    (iterate-areas
      (lambda (index area)
        (iterate-polygons area #f
          (lambda (env elem polygons offset)
            (let ((data1 (f64vector-ref polygons (+ offset 16))))
              (when (and (/= data1 0.) (memq? (flonum->fixnum data1) ids))
                (proc area)))))))))


;;;
;;;; Procedural Zones
;;;


(proclaim (warn optimizations))


;; Ideally, this would use a PRNG which we can seed with a given value.
;; That way the map can be persisted using just the seed and a list of changes.
@convert^^^
(class Procedural-Zone extends Zone
  
  
  (property detail-level <fl> initialize 15. accessors generate)
  (property clamp-height <fl> initialize 65. accessors generate)
  
  
  (method override (setup-component)
    (nextmethod)
    @old
    (set! generator (new Perlin-Generator detail-level clamp-height)))
  
  
  (method override (zone-editable?)
    (world-setting 'world.procedural-editable? #f))
  
  
  (method override (zone-destructible?)
    (zone-editable?))
  
  
  (method override (generate-visual sector <Sector>)
    (let ((index (get-index sector)))
      (let ((x (index-x index))
            (y (index-y index))
            (z (index-z index)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural sector from-x width from-z depth 'visual)))))
    (set-visual-uptodate? sector #t)
    (decrease-sectors-generating 1))
  
  
  (method override (generate-physical sector <Sector> revision-update?)
    (let ((index (get-index sector)))
      (let ((x (index-x index))
            (y (index-y index))
            (z (index-z index)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural sector from-x width from-z depth 'physical))))))
  
  
  (method (generate-procedural sector <Sector> from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1)))
      (define (generator-heightmap)
        (let ((heightmap <f32vector> (make-f32vector (* x-count z-count))))
          (loop (for x from 0 below x-count)
                (loop (for z from 0 below z-count)
                      (f32vector-set! heightmap (+ (* x z-count) z)
                        ;; max and min are quick hacks until perlin generator is fixed
                        (max 0. (min 10. (/ (get-value generator (cast <fl> (+ from-x x)) (cast <fl> (+ from-z z))) 5.))))))
          heightmap))
      
      (generate-heightmap-old sector (generator-heightmap) from-x width from-z depth what)))))
