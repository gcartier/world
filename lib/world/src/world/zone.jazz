;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Zones
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.zone jazz


(import (jazz.designer)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.literals)
        (jazz.math)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.version)
        (time)
        (world)
        (world.actor)
        (world.area)
        (world.autoload)
        (world.block)
        (world.counter)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.enemy)
        (world.entity)
        (world.face)
        (world.folio)
        (world.foreign)
        (world.foreign.triangulate)
        (world.gadget)
        (world.geometry)
        (world.gravity)
        (world.history)
        (world.light)
        (world.mark)
        (world.opengl)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.render)
        (world.sector)
        (world.serialization)
        (world.settings)
        (world.shader)
        (world.skybox)
        (world.sun)
        (world.support)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile)
        (world.triangle)
        (world.window)
        (world.client.window))


;;;
;;;; Zone
;;;


(class Zone extends Component
  
  
  (property title                   <string+>    initialize #f              accessors generate)
  (property ambient-color           <Color+>     initialize #f              accessors generate)
  (property material-specular       <Color+>     initialize #f              accessors generate)
  (property material-shininess      <fl+>        initialize #f              accessors generate)
  (property start-mode              <symbol>     initialize 'free-camera    accessors generate)
  (property start-eye               <f64vector+> initialize #f              accessors generate)
  (property start-eye-sight         <f64vector+> initialize #f              accessors generate)
  (property start-eye-up            <f64vector+> initialize #f              accessors generate)
  (property start-position          <f64vector+> initialize #f              accessors generate)
  (property start-sight             <f64vector+> initialize #f              accessors generate)
  (property start-up                <f64vector+> initialize #f              accessors generate)
  (property floor-level             <fl+>        initialize 0.              accessors generate)
  (property missile-behavior        <symbol>     initialize 'destroy        accessors generate)
  (property sun-cycle?              <bool>       initialize #t              accessors generate)
  (property start-skybox            <object>     initialize #f              accessors generate)
  (property draw-me?                <bool>       initialize #t              accessors generate)
  (property properties              <object>     initialize '()             accessors generate)
  
  ;; world override properties
  (property ambient-gravity         <object>     initialize (unspecified)   accessors generate)
  (property jump-impulsion          <object>     initialize (unspecified)   accessors generate)
  (property start-3d?               <object>     initialize (unspecified)   accessors generate)
  (property start-grid?             <object>     initialize (unspecified)   accessors generate)
  (property start-axes?             <object>     initialize (unspecified)   accessors generate)
  
  
  (slot sectors                     <object>     initialize #f              getter generate)
  (slot sector-size                 <fx>         initialize #f              getter generate)
  (slot sector-radius               <fl>         initialize #f              getter generate)
  (slot sector-diameter             <fl>         initialize #f              getter generate)
  (slot sectors-generating          <fx>         initialize 0               getter generate)
  (slot sectors-waiting             <fx>         initialize 0               getter generate)
  (slot sectors-mutex               <object>     initialize #f              getter generate)
  (slot debug-sectors?              <bool>       initialize #f              accessors generate)
  (slot areas                       <object>     initialize #f              getter generate)
  (slot area-size                   <fx>         initialize #f              getter generate)
  (slot debug-areas?                <bool>       initialize #f              accessors generate)
  (slot tiles                       <list>       initialize '()             getter generate)
  (slot players                     <list>       initialize '()             getter generate)
  (slot actors                      <list>       initialize '()             getter generate)
  (slot entities                    <list>       initialize '()             getter generate)
  (slot gravities                   <list>       initialize '()             getter generate)
  (slot gadgets                     <list>       initialize '()             getter generate)
  (slot marks                       <list>       initialize '()             getter generate)
  (slot update-lightmaps?           <bool>       initialize #t              getter generate)
  (slot lights-count                <fx>         initialize 0               accessors generate)
  (slot sun                         <Sun+>       initialize #f              accessors generate)
  (slot sun-ambient                 <Color+>     initialize #f              accessors generate)
  (slot sun-color                   <Color+>     initialize #f              accessors generate)
  (slot sun-coordinates             <f64vector>  initialize #f              accessors generate)
  (slot sun-angle                   <fl>         initialize 0.              accessors generate)
  (slot skybox                      <Skybox+>    initialize #f              accessors generate)
  (slot skyboxes                    <list>       initialize '()             accessors generate)
  (slot designer                    <object>     initialize #f              accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (load-point 'zone-prepare)
    (set! update-lightmaps? (get-lightmaps?~ (current-world)))
    (set! sun-ambient (dye 0.1 0.1 0.1 1.0))
    (set! sun-color (dye 1.0 1.0 1.0 1.0))
    (set! sun-coordinates (vertex 10000.0 10000.0 10000.0))
    (prepare-tiles)
    (load-point 'zone-tiles)
    (prepare-skyboxes)
    (load-point 'zone-skyboxes)
    (set-current-zone self))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set! draw-me? (find-setting 'world.draw-me? #t))
    (set! sun-cycle? (and sun-cycle? (find-setting 'world.sun-cycle? #t)))
    (prepare-skybox))
  
  
  (method (initialize-zone)
    (setup-areas)
    (setup-sectors)
    (setup-boundaries)
    (setup-content)
    (setup-overrides))
  
  
  (method (setup-overrides)
    (let ((world (current-world)))
      (when (specified? ambient-gravity)
        (set-ambient-gravity~ world ambient-gravity))
      (when (specified? jump-impulsion)
        (set-jump-impulsion~ world jump-impulsion))
      (when (specified? start-3d?)
        (if start-3d?
            (activate-3d~ world)
          (deactivate-3d~ world)))
      (when (specified? start-grid?)
        (set-grid?~ world start-grid?))
      (when (specified? start-axes?)
        (set-axes?~ world start-axes?))))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method protected virtual (sector-class)
    Sector)
  
  
  (method protected virtual (populate-zone)
    )
  
  
  (method protected virtual (generate-physical sector)
    )
    
  
  (method protected virtual (generate-content?)
    #f)
  
  
  (method protected virtual (generate-content sector)
    (set-content-revision~ sector (get-current-content-revision))
    (set-content-uptodate?~ sector #t))
  
  
  (method protected virtual (nmc?)
    #f)

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))
  
  
  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (free-sectors))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (reset-zone)
    (set! tiles '())
    (set! players '())
    (set! actors '())
    (set! entities '())
    (set! gravities '()))
  
  
  (method virtual (setup-content)
    )
  
  
  (method (update-children)
    (set-current-me #f)
    (for-each (lambda (obj)
                (when (is? obj Element)
                  (add-element obj)))
              children))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (method public virtual (target-update target face poly)
    )
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (get-moniker)
    (get-origin~ (get-form~ designer)))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (set-modified?~ designer flag))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method (draw-zone)
    (let ((world (current-world)))
      (when (and skybox (get-3d?~ world))
        (draw~ skybox))
      (when (get-draw-elements?~ world)
        (if (get-3d?~ world)
            (draw-sectors~ world)
          (draw-immediate)))
      (when debug-areas?
        (draw-debug-areas))
      (when debug-sectors?
        (draw-debug-sectors))
      (when (get-draw-gadgets?~ world)
        (draw-gadgets))
      (when (get-draw-marks?~ world)
        (draw-marks))
      (when (get-draw-atlas?~ world)
        (draw-atlas))
      (when (and sun (get-visible?~ sun))
        (draw-sun))
      (draw-translucent)))
  
  
  ;;;
  ;;;; Tiles
  ;;;
  
  
  (method protected virtual (prepare-tiles)
    (let ((world (current-world)))
      (prepare-tile~ world)))
  
  
  ;;;
  ;;;; Skybox
  ;;;
  
  
  (method (prepare-skyboxes)
    (let ((world (current-world)))
      (define (collect-skyboxes)
        (define (add-skyboxes dir queue)
          (when (exists?~ dir)
            (iterate-directory~ dir
              (lambda (dir)
                (when (skybox-kind dir)
                  (enqueue queue (new Skybox dir))))
              files?: #f
              directories?: #t)))
        
        (let ((queue (new-queue)))
          (for-each (lambda (assets)
                      (add-skyboxes (new-directory~ assets "skybox") queue))
                    (get-all-assets~ world))
          (sort di<? (queue-list queue) key: get-name~)))
      
      (set! skyboxes (collect-skyboxes))))
  
  
  (method protected virtual (prepare-skybox)
    (set! skybox (let ((name (or start-skybox (find-setting 'world.skybox #f))))
                   (and name (let ((skybox (find-skybox name)))
                               (when skybox
                                 (prepare~ skybox))
                               skybox)))))
  
  
  (method (find-skybox name)
    (find-if (lambda (skybox)
               (di=? (get-name~ skybox) name))
             skyboxes))
  
  
  (method (install-skybox sky)
    (prepare~ sky)
    (set! skybox sky))
  
  
  (method (change-skybox (reversed?: reversed? #f))
    (if (null? skyboxes)
        (bell)
      (let ((world (current-world))
            (next (if reversed? previous-element next-element)))
        (let ((sky (next skyboxes skybox)))
          (install-skybox sky)
          (display-message~ world (format "{a}" (get-name~ skybox)))))))
  
  
  ;;;
  ;;;; Boundaries
  ;;;
  
  
  (method (setup-boundaries)
    @w
    (set! boundaries (cuboid left bottom back right top front)))
  
  
  ;;;
  ;;;; Snapshots
  ;;;
  
  
  (method (snapshot-zone)
    (new Snapshot
      (object->u8vector actors serialize)
      (object->u8vector gadgets serialize)
      (object->u8vector marks serialize)
      (object->u8vector sun-angle serialize)))
  
  
  (method (load-zone snapshot)
    (define (add elem)
      (add-element elem)
      (position-update~ elem))
    
    (for-each remove-element actors)
    (for-each add (u8vector->object (get-actors~ snapshot) deserialize))
    (for-each remove-element gadgets)
    (for-each add (u8vector->object (get-gadgets~ snapshot) deserialize))
    (set! marks (u8vector->object (get-marks~ snapshot) deserialize))
    (when sun-cycle?
      (position-sun (u8vector->object (get-sun-angle~ snapshot) deserialize))))
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method (add-element obj)
    (define (add-player)
      (set! players (cons obj players))
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-actor)
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-entity)
      (set! entities (cons obj entities)))
    
    (define (add-tile)
      (set! tiles (cons obj tiles)))
    
    (define (add-gravity)
      (set! gravities (cons obj gravities)))
    
    (define (add-gadget)
      (set! gadgets (cons obj gadgets)))
    
    (typecase obj
      ((Player) (add-player))
      ((Actor) (add-actor))
      ((Entity) (add-entity))
      (else (add-tile)))
    (when (is? obj Gravity-Well)
      (add-gravity))
    (when (gadget?~ obj)
      (add-gadget))
    (area-add-element (element-area obj) obj)
    (sector-add-element (element-sector obj) obj)
    obj)
  
  
  (method (remove-element obj)
    (define (remove-player)
      (set! players (remove! obj players))
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-actor)
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-entity)
      (set! entities (remove! obj entities)))
    
    (define (remove-tile)
      (set! tiles (remove! obj tiles)))
    
    (define (remove-gravity)
      (set! gravities (remove! obj gravities)))
    
    (define (remove-gadget)
      (set! gadgets (remove! obj gadgets)))
    
    (typecase obj
      ((Player) (remove-player))
      ((Actor) (remove-actor))
      ((Entity) (remove-entity))
      (else (remove-tile)))
    (when (is? obj Gravity-Well)
      (remove-gravity))
    (when (gadget?~ obj)
      (remove-gadget))
    (area-remove-element (element-area obj) obj)
    (sector-remove-element (element-sector obj) obj))
  
  
  (method (find-element predicate)
    (continuation-capture
      (lambda (return)
        (iterate-elements
          (lambda (element)
            (when (predicate element)
              (continuation-return return element))))
        #f)))
  
  
  (method (find-named-element name)
    (find-element
      (lambda (element)
        (eq? (get-name~ element) name))))
  
  
  (method (find-gadget predicate)
    (find-if predicate gadgets))
  
  
  (method (iterate-players proc)
    (for-each proc players))
  
  
  (method (iterate-actors proc)
    (for-each proc actors))
  
  
  (method (iterate-entities proc)
    (for-each proc entities))
  
  
  (method (iterate-gadgets proc)
    (for-each proc gadgets))
  
  
  (method (iterate-elements proc)
    (for-each proc tiles)
    (for-each proc entities))
  
  
  ;; draw potentially translucent last
  (method (draw-translucent)
    (let ((me (current-me)))
      (when (and me draw-me?)
        (draw~ me))))
  
  
  (method (draw-immediate)
    (iterate-elements
      (lambda (element)
        (unless (is? element Actor)
          (unless (and (is? element Gadget) (not (get-draw-gadgets?~ (current-world))))
            (draw~ element))))))
  
  
  (method (vertex->element vert)
    (let ((left (floor (vertex-x vert)))
          (bottom (floor (vertex-y vert)))
          (back (floor (vertex-z vert))))
      (let ((right (+ left 1.))
            (top (+ bottom 1.))
            (front (+ back 1.)))
        (continuation-capture
          (lambda (return)
            (let ((area (index-area (position-area-index vert)))
                  (x (vertex-x vert))
                  (y (vertex-y vert))
                  (z (vertex-z vert)))
              (iterate-area-elements area
                (lambda (obj)
                  (when (and (get-visible?~ obj)
                             (let ((x (get-x~ obj))
                                   (y (get-y~ obj))
                                   (z (get-z~ obj)))
                               (and (>= x left)
                                    (>= y bottom)
                                    (>= z back)
                                    (<  x right)
                                    (<  y top)
                                    (<  z front))))
                    (continuation-return return obj)))))
            #f)))))
  
  
  (method (element-at vert)
    (continuation-capture
      (lambda (return)
        (let ((area (index-area (position-area-index vert))))
          (iterate-area-elements area
            (lambda (obj)
              (when (and (get-visible?~ obj)
                         (vertex=? (get-position~ obj) vert))
                (continuation-return return obj)))))
        #f)))
  
  
  (method (validate-elements)
    (iterate-elements
      (lambda (element)
        (assert (real? (get-x~ element)))
        (assert (real? (get-y~ element)))
        (assert (real? (get-z~ element)))
        (assert (real? (get-red~ element)))
        (assert (real? (get-green~ element)))
        (assert (real? (get-blue~ element)))
        (assert (real? (get-alpha~ element))))))
  
  
  ;;;
  ;;;; Sectors
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-sectors)
    (set! sectors (make-table test: equal?))
    (set! sector-size (or (find-setting 'world.sector-size #f) 16))
    (set! sector-radius (let ((half (/ sector-size 2.)))
                          (vertex-norm (vertex half half half))))
    (set! sector-diameter (* sector-radius 2))
    (set! sectors-mutex (make-mutex 'sectors)))
  
  
  (method (element-sector-index element <Element>)
    (position-sector-index (get-center~ element)))
  
  
  (method (position-sector-index pos <f64vector>) <vector>
    (let ((size (cast <fl> sector-size)))
      (vector (fxfloor (/ (vertex-x pos) size))
              (fxfloor (/ (vertex-y pos) size))
              (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method (position-sector pos)
    (index-sector (position-sector-index pos)))
  
  
  (method (element-sector element)
    (index-sector (element-sector-index element)))
  
  
  (method (index-sector index <vector>)
    (or (table-ref sectors index #f)
        (let ((sector (new-sector index)))
          (table-set! sectors index sector)
          sector)))
  
  
  (method (coordinates-sector x y z)
    (let ((index (static (make-vector 3))))
      (vector-set! index 0 x)
      (vector-set! index 1 y)
      (vector-set! index 2 z)
      (or (table-ref sectors index #f)
          (let ((index (vector x y z)))
            (let ((sector (new-sector index)))
              (table-set! sectors index sector)
              sector)))))
  
  
  (method (new-sector index <vector>)
    (define (center i)
      (* (+ i .5) sector-size))
    
    (let ((x (vector-ref index 0))
          (y (vector-ref index 1))
          (z (vector-ref index 2)))
      (new (sector-class) index (vertex (center x) (center y) (center z)))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (unlink-sector sector)
    ;; doesnt-work-as-is-see-unlink-area-comment
    )
  
  
  (method (free-sectors)
    (iterate-table sectors
      (lambda (index sector)
        (free-mesh~ sector))))
  
  
  (method (sector-add-element sector element)
    (define (add-entity)
      (set-entities~ sector (cons element (get-entities~ sector))))
    
    (define (add-tile)
      (set-tiles~ sector (cons element (get-tiles~ sector)))
      (set-vertices-uptodate?~ sector #f)
      ;; temporary
      (set-lightmap-uptodate?~ sector #f))
    
    (typecase element
      ((Entity)
       (add-entity))
      ((Tile)
       (add-tile)))
    (invalidate-lightmaps element))
  
  
  (method (sector-remove-element sector element)
    (define (remove-entity)
      (set-entities~ sector (remove! element (get-entities~ sector))))
    
    (define (remove-tile)
      (let ((tiles (remove! element (get-tiles~ sector))))
        (set-tiles~ sector tiles)
        (set-vertices-uptodate?~ sector #f)
        ;; temporary
        (set-lightmap-uptodate?~ sector #f)
        (when (null? tiles)
          (unlink-sector sector))))
    
    (typecase element
      ((Entity)
       (remove-entity))
      ((Tile)
       (remove-tile)))
    (invalidate-lightmaps element))
  
  
  (method (update-sector element old-center)
    (let ((old-index (position-sector-index old-center))
          (new-index (element-sector-index element)))
      (when (not (equal? old-index new-index))
        (let ((old-sector (index-sector old-index))
              (new-sector (index-sector new-index)))
          (sector-remove-element old-sector element)
          (sector-add-element new-sector element)))))
  
  
  (method (iterate-sectors-with-tiles proc)
    (iterate-table sectors
      (lambda (index sector)
        (when (not-null? (get-tiles~ sector))
          (proc index sector)))))
  
  
  (proclaim (warn optimizations))
  
  
  (method (iterate-position-neighbor-sectors pos distance <fx> proc)
    (let ((index (position-sector-index pos)))
      (let ((a <fx> (vector-ref index 0))
            (b <fx> (vector-ref index 1))
            (c <fx> (vector-ref index 2)))
        (for-to (i (- distance) distance)
             (for-to (j (- distance) distance)
                  (for-to (k (- distance) distance)
                          (proc (coordinates-sector (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-position-outward-neighbor-sectors pos distance <fx> proc)
    (let ((index (position-sector-index pos)))
      (proc (index-sector index))
      (let ((a <fx> (vector-ref index 0))
            (b <fx> (vector-ref index 1))
            (c <fx> (vector-ref index 2)))
        (for-to (radius 1 distance)
                (let ((radius-1 (- radius 1)))
                  ;; left
                  (let ((i (- a radius)))
                    (for-to (j (- radius) radius)
                            (for-to (k (- radius) radius)
                                    (proc (coordinates-sector i (+ b j) (+ c k))))))
                  ;; right
                  (let ((i (+ a radius)))
                    (for-to (j (- radius) radius)
                            (for-to (k (- radius) radius)
                                    (proc (coordinates-sector i (+ b j) (+ c k))))))
                  ;; bottom
                  (let ((j (- b radius)))
                    (for-to (i (- radius-1) radius-1)
                            (for-to (k (- radius) radius)
                                    (proc (coordinates-sector (+ a i) j (+ c k))))))
                  ;;p
                  (let ((j (+ b radius)))
                    (for-to (i (- radius-1) radius-1)
                            (for-to (k (- radius) radius)
                                    (proc (coordinates-sector (+ a i) j (+ c k))))))
                  ;; back
                  (let ((k (- c radius)))
                    (for-to (i (- radius-1) radius-1)
                            (for-to (j (- radius-1) radius-1)
                                    (proc (coordinates-sector (+ a i) (+ b j) k)))))
                  ;; front
                  (let ((k (+ c radius)))
                    (for-to (i (- radius-1) radius-1)
                            (for-to (j (- radius-1) radius-1)
                                    (proc (coordinates-sector (+ a i) (+ b j) k))))))))))
    
  
  (definition eye-index
    #f)
  
  (definition eye-sectors
    #f)
  
  (method (reset-eye-sectors)
    (set! eye-index #f)
    (set! eye-sectors #f))
  
  
  (method (eye-neighbor-sectors pos distance <fx>)
    (let ((index (position-sector-index pos)))
      (if (equal? index eye-index)
          eye-sectors
        (let ((a <fx> (vector-ref index 0))
              (b <fx> (vector-ref index 1))
              (c <fx> (vector-ref index 2))
              (sectors (make-vector (expt (+ distance 1 distance) 3)))
              (n 0))
          (define (add sector)
            (vector-set! sectors n sector)
            (increase! n))
          
          (add (index-sector index))
          (for-to (radius 1 distance)
                  (let ((radius-1 (- radius 1)))
                    ;; left
                    (let ((i (- a radius)))
                      (for-to (j (- radius) radius)
                              (for-to (k (- radius) radius)
                                      (add (coordinates-sector i (+ b j) (+ c k))))))
                    ;; right
                    (let ((i (+ a radius)))
                      (for-to (j (- radius) radius)
                              (for-to (k (- radius) radius)
                                      (add (coordinates-sector i (+ b j) (+ c k))))))
                    ;; bottom
                    (let ((j (- b radius)))
                      (for-to (i (- radius-1) radius-1)
                              (for-to (k (- radius) radius)
                                      (add (coordinates-sector (+ a i) j (+ c k))))))
                    ;;p
                    (let ((j (+ b radius)))
                      (for-to (i (- radius-1) radius-1)
                              (for-to (k (- radius) radius)
                                      (add (coordinates-sector (+ a i) j (+ c k))))))
                    ;; back
                    (let ((k (- c radius)))
                      (for-to (i (- radius-1) radius-1)
                              (for-to (j (- radius-1) radius-1)
                                      (add (coordinates-sector (+ a i) (+ b j) k)))))
                    ;; front
                    (let ((k (+ c radius)))
                      (for-to (i (- radius-1) radius-1)
                              (for-to (j (- radius-1) radius-1)
                                      (add (coordinates-sector (+ a i) (+ b j) k)))))))
          (set! eye-index index)
          (set! eye-sectors sectors)
          eye-sectors))))
  
  
  ;; virtual to test new-minecraft
  (method virtual (draw-eye-neighbors eye view-distance proc)
    (let ((world (current-world)))
      (reset-sectors-waiting)
      (let ((sectors (eye-neighbor-sectors eye view-distance)))
        (for (i 0 (vector-length sectors))
             (let ((sector <Sector> (vector-ref sectors i)))
               (when (in-frustum?~ world (get-center~ sector))
                 (update~ sector)
                 (proc sector)))))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (iterate-element-neighbor-sectors element distance proc)
    (iterate-position-neighbor-sectors (get-center~ element) distance proc))
  
  
  (method (element-neighbor-sectors element distance)
    (let ((queue (new-queue)))
      (iterate-element-neighbor-sectors element distance (lambda (sector) (enqueue queue sector)))
      (queue-list queue)))
  
  
  (method (increase-sectors-generating sector)
    (mutex-lock! sectors-mutex)
    (set! sectors-generating (+ sectors-generating 1))
    (mutex-unlock! sectors-mutex))
  
  
  (method (decrease-sectors-generating sector)
    (mutex-lock! sectors-mutex)
    (set! sectors-generating (- sectors-generating 1))
    (mutex-unlock! sectors-mutex))
  
  
  (method (reset-sectors-waiting)
    (mutex-lock! sectors-mutex)
    (set! sectors-waiting 0)
    (mutex-unlock! sectors-mutex))
  
  
  (method (increase-sectors-waiting sector)
    (mutex-lock! sectors-mutex)
    (set! sectors-waiting (+ sectors-waiting 1))
    (mutex-unlock! sectors-mutex))
  
  
  (method (compute-floats)
    (let ((total 0))
      (iterate-table sectors
                     (lambda (index sector)
                       (let ((mesh (get-mesh~ sector)))
                         (when (and mesh (get-vertices-uptodate?~ sector))
                           (let ((floats (count-floats~ mesh)))
                             (when floats
                               (increase! total floats)))))))
      total))
  
  
  (method (count-non-empty-sectors)
    (let ((total 0))
      (iterate-table sectors
        (lambda (index sector)
          (unless (empty?~ (get-mesh~ sector))
            (increase! total))))
      total))
  
  
  (method (validate-sectors)
    )
  
  
  (method (toggle-debug-sectors)
    (set! debug-sectors? (not debug-sectors?)))
  
  
  (method (draw-debug-sectors)
    (when (current-me)
      (let ((index (element-sector-index (current-me)))
            (size (cast <fl> sector-size))
            (depth 5))
        (let ((bx (* (vector-ref index 0) size))
              (by (* (vector-ref index 1) size))
              (bz (* (vector-ref index 2) size))
              (hx (- (* size depth)))
              (tx (* size depth))
              (hy 0.)
              (ty size)
              (hz (- (* size depth)))
              (tz (* size depth)))
          (define (vert x y z)
            (glVertex3f (+ bx x)
                        (+ by y)
                        (+ bz z)))
          
          (glDisable GL_LIGHTING)
          (gl-colorize-dye red-dye)
          (glBegin GL_LINES)
          (loop (for x <fl> from hx to tx by size)
                (loop (for y <fl> from hy to ty by size)
                      (vert x y hz)
                      (vert x y tz))
                (loop (for z <fl> from hz to tz by size)
                      (vert x hy z)
                      (vert x ty z)))
          (glEnd)
          (glBegin GL_LINES)
          (loop (for y <fl> from hy to ty by size)
                (loop (for x <fl> from hx to tx by size)
                      (vert x y hz)
                      (vert x y tz))
                (loop (for z <fl> from hz to tz by size)
                      (vert hx y z)
                      (vert tx y z)))
          (glEnd)
          (glBegin GL_LINES)
          (loop (for z <fl> from hz to tz by size)
                (loop (for x <fl> from hx to tx by size)
                      (vert x hy z)
                      (vert x ty z))
                (loop (for y <fl> from hy to ty by size)
                      (vert hx y z)
                      (vert tx y z)))
          (glEnd)
          (glEnable GL_LIGHTING)))))
  
  
  ;;;
  ;;;; Areas
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-areas)
    (set! areas (make-table test: equal?))
    (set! area-size 2))
  
  
  (method (element-area-index element <Element>)
    (position-area-index (get-center~ element)))
  
  
  (method (position-area-index pos <f64vector>) <vector>
    (let ((size (cast <fl> area-size)))
      (vector (fxfloor (/ (vertex-x pos) size))
              (fxfloor (/ (vertex-y pos) size))
              (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method (position-area pos)
    (index-area (position-area-index pos)))
  
  
  (method (element-area element)
    (index-area (element-area-index element)))
  
  
  (method (index-area index <vector> (update? #t))
    (when update?
      (update-physical~ (area-coordinates-sector (vector-ref index 0) (vector-ref index 1) (vector-ref index 2))))
    (or (table-ref areas index #f)
        (let ((area (new Area index)))
          (table-set! areas index area)
          area)))
  
  
  (method (coordinates-area x y z)
    (update-physical~ (area-coordinates-sector x y z))
    (let ((index (static (make-vector 3))))
      (vector-set! index 0 x)
      (vector-set! index 1 y)
      (vector-set! index 2 z)
      (or (table-ref areas index #f)
          (let ((index (vector x y z)))
            (let ((area (new Area index)))
              (table-set! areas index area)
              area)))))
  
  
  (method (area-coordinates-sector x <fx> y <fx> z <fx>) <Sector>
    (coordinates-sector (arithmetic-shift-right x 3)
                        (arithmetic-shift-right y 3)
                        (arithmetic-shift-right z 3)))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (unlink-area area)
    @doesnt-work-as-is-because-hit-test-will-consult/create-the-27-adjacent-areas-even-if-they-are-empty
    (table-clear areas (get-index~ area)))
  
  
  (method (area-add-element area element)
    (define (add-actor)
      (set-actors~ area (cons element (get-actors~ area)))
      (set-entities~ area (cons element (get-entities~ area))))
    
    (define (add-tile)
      (set-tiles~ area (cons element (get-tiles~ area)))
      ;; need to make sure we're not calling element-faces twice
      (add-polygons~ (element-area element) element (map get-polygon~ (element-faces~ element))))
    
    (define (add-entity)
      (set-entities~ area (cons element (get-entities~ area))))
    
    (define (add-gadget)
      (set-gadgets~ area (cons element (get-gadgets~ area))))
    
    (cond ((and (is? element Actor) (is-not? element Missile))
           (add-actor))
          ((is? element Tile)
           (add-tile))
          ((is? element Entity)
           (add-entity))
          ((is? element Gadget)
           (add-gadget))))
  
  
  (method (area-remove-element area element)
    (define (remove-actor)
      (let ((actors (remove! element (get-actors~ area))))
        (set-actors~ area actors)
        (set-entities~ area (remove! element (get-entities~ area)))
        (when (and (null? actors) (null? (get-tiles~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-tile)
      (let ((tiles (remove! element (get-tiles~ area))))
        (set-tiles~ area tiles)
        (remove-polygons~ area element)
        (when (and (null? tiles) (null? (get-actors~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-entity)
      (let ((entities (remove! element (get-entities~ area))))
        (set-entities~ area entities)
        (when (and (null? gadgets) (null? (get-actors~ area)) (null? (get-tiles~ area)))
          (unlink-area area))))
    
    (define (remove-gadget)
      (let ((gadgets (remove! element (get-gadgets~ area))))
        (set-gadgets~ area gadgets)
        (when (and (null? gadgets) (null? (get-actors~ area)) (null? (get-tiles~ area)))
          (unlink-area area))))
    
    (cond ((is? element Actor)
           (remove-actor))
          ((is? element Tile)
           (remove-tile))
          ((is? element Entity)
           (remove-entity))
          ((is? element Gadget)
           (remove-gadget))))
  
  
  (method (update-area element old-center (force? #f))
    (let ((old-index (position-area-index old-center))
          (new-index (element-area-index element)))
      (when (or force? (not (equal? old-index new-index)))
        (let ((old-area (index-area old-index))
              (new-area (index-area new-index)))
          (area-remove-element old-area element)
          (area-add-element new-area element)))))
  
  
  (method (iterate-position-neighbor-areas pos distance <fx> proc)
    (let ((index (position-area-index pos)))
      (let ((a <fx> (vector-ref index 0))
            (b <fx> (vector-ref index 1))
            (c <fx> (vector-ref index 2)))
        (for-to (i (- distance) distance)
             (for-to (j (- distance) distance)
                  (for-to (k (- distance) distance)
                          (proc (coordinates-area (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-area-elements area proc)
    (for-each proc (get-tiles~ area))
    (for-each proc (get-actors~ area))
    (for-each proc (get-gadgets~ area)))
  
  
  (method (collect-area-elements)
    (let ((queue (new-queue)))
      (iterate-table areas
        (lambda (index area)
          (enqueue-list queue (get-tiles~ area))
          (enqueue-list queue (get-actors~ area))
          (enqueue-list queue (get-gadgets~ area))))
      (queue-list queue)))
  
  
  (method (areas-count filter)
    (count-if filter (collect-area-elements)))
  
  
  (method (count-polygons)
    (let ((count 0))
      (iterate-table areas
        (lambda (index area)
          (let ((polygons (get-polygons~ area)))
            (when polygons
              (increase! count (/ (f64vector-length polygons) polygon-float-size))))))
      count))
  
  
  (method (validate-areas)
    (let ((world (current-world)))
      (let ((tiles-count 0)
            (actors-count 0)
            (gadgets-count 0)
            (elements-count 0))
        (iterate-table areas
          (lambda (index area)
            (let ((area-tiles (length (get-tiles~ area)))
                  (area-actors (length (get-actors~ area)))
                  (area-gadgets (length (get-gadgets~ area))))
              (increase! tiles-count area-tiles)
              (increase! actors-count area-actors)
              (increase! gadgets-count area-gadgets)
              (increase! elements-count (+ area-actors area-tiles)))))
        (if (and (= tiles-count (length tiles))
                 (= actors-count (length actors))
                 (= gadgets-count (length gadgets))
                 @convert
                 (= elements-count (length elements)))
            (begin
              (reset-information~ world)
              #t)
          (set-information~ world
            `("Area corruption detected"
              ,(format "  Tiles: {s} {s}" tiles-count (length tiles))
              ,(format "  Actors: {s} {s}" actors-count (length actors))
              ,(format "  Gadgets: {s} {s}" gadgets-count (length gadgets))
              @convert
              ,(format "  Elements: {s} {s}" elements-count (length elements))))
          #f))))
  
  
  (method (toggle-debug-areas)
    (set! debug-areas? (not debug-areas?)))
  
  
  (method (draw-debug-areas)
    (when (current-me)
      (let ((index (element-area-index (current-me)))
            (size (cast <fl> area-size))
            (depth 5))
        (let ((bx (* (vector-ref index 0) size))
              (by (* (vector-ref index 1) size))
              (bz (* (vector-ref index 2) size))
              (hx (- (* size depth)))
              (tx (* size depth))
              (hy 0.)
              (ty size)
              (hz (- (* size depth)))
              (tz (* size depth)))
          (define (vert x y z)
            (glVertex3f (+ bx x)
                        (+ by y)
                        (+ bz z)))
          
          (glDisable GL_LIGHTING)
          (gl-colorize-dye red-dye)
          (glBegin GL_LINES)
          (loop (for x <fl> from hx to tx by size)
                (loop (for y <fl> from hy to ty by size)
                      (vert x y hz)
                      (vert x y tz))
                (loop (for z <fl> from hz to tz by size)
                      (vert x hy z)
                      (vert x ty z)))
          (glEnd)
          (glBegin GL_LINES)
          (loop (for y <fl> from hy to ty by size)
                (loop (for x <fl> from hx to tx by size)
                      (vert x y hz)
                      (vert x y tz))
                (loop (for z <fl> from hz to tz by size)
                      (vert hx y z)
                      (vert tx y z)))
          (glEnd)
          (glBegin GL_LINES)
          (loop (for z <fl> from hz to tz by size)
                (loop (for x <fl> from hx to tx by size)
                      (vert x hy z)
                      (vert x ty z))
                (loop (for y <fl> from hy to ty by size)
                      (vert hx y z)
                      (vert tx y z)))
          (glEnd)
          (glEnable GL_LIGHTING)))))
  
  
  ;;;
  ;;;; Gadget
  ;;;
  
  
  (method (draw-gadgets)
    (for-each (lambda (gadget)
                (when (get-visible?~ gadget)
                  (draw~ gadget)))
              gadgets))
  
  
  ;;;
  ;;;; Blocks
  ;;;
  
  
  (method (remove-duplicate-blocks)
    (let ((world (current-world)))
      (let ((table (make-table test: vertex=? hash: vertex-hash))
            (count 0))
        (for-each (lambda (tile)
                    (when (is? tile Block)
                      (let ((pos (get-position~ tile)))
                        (if (table-ref table pos #f)
                            (begin
                              (editor-remove-element~ world tile)
                              (increase! count))
                          (table-set! table pos tile)))))
                  tiles)
        (display-message~ world
          (format "Removed {a} block{a}"
                  (format-cardinality count)
                  (format-plural count))))))
  
  
  ;;;
  ;;;; Sun
  ;;;
  
  
  (definition sun-speed <fl>
    .025)
  
  
  (method (set-sun-speed speed)
    (set! sun-speed speed))
  
  
  (method (tick-sun elapse (reverse? #f))
    (position-sun ((if reverse? - +) sun-angle (* sun-speed elapse))))
  
  
  (method (position-sun angle)
    (let ((zone (current-zone)))
      (set! sun-angle (flmodulo angle PI*2))
      (let ((under-limit 0.1)
            (direction (rotate-upon& PI/4 (vertex 0.0 1.0 0.0) (rotate-upon& sun-angle (vertex 0.0 0.0 -1.0) (vertex -1. 0. 0.)))))
        (let ((pos (vertex-scalar* direction 1000.)))
          (when (not sun)
            (set! sun (new Sun parent: zone position: pos))
            (add-element sun))
          (cond ((or (< sun-angle (+ PI under-limit))
                     (> sun-angle (- PI*2 under-limit)))
                 (let ((coord (vertex-scalar* direction 1000.))
                       (under (cond ((> sun-angle (- PI*2 under-limit)) (- PI*2 sun-angle))
                                    ((and (> sun-angle PI) (< sun-angle (+ PI under-limit))) (- sun-angle PI))
                                    (else 0.))))
                   (let ((intensity (- 1.0 (/ under under-limit))))
                     (set-sun-color (dye intensity intensity intensity 1.0)))
                   (set-sun-coordinates coord)
                   (set-position~ sun pos)
                   (set-visible?~ sun #t)))
                (else
                 (set-sun-color black-dye)
                 (set-visible?~ sun #f)))))))
  
  
  (method (draw-sun)
    (draw~ sun))
  
  
  ;;;
  ;;;; Lighting
  ;;;
  
  
  (method (setup-lighting)
    (let ((world (current-world)))
      (define (closest-lights)
        (let ((lights (if update-lightmaps? (collect-dynamic-lights) (collect-lights)))
              (eye (get-eye~ world)))
          (sort < lights key: (lambda (light) (vertex-distance eye (get-center~ light))))))
      
      (when (get-light?~ world)
        (glEnable GL_LIGHTING)
        (glDisable GL_LIGHT0)
        (glDisable GL_LIGHT1)
        (glDisable GL_LIGHT2)
        (glDisable GL_LIGHT3)
        (glDisable GL_LIGHT4)
        (glDisable GL_LIGHT5)
        (glDisable GL_LIGHT6)
        (glDisable GL_LIGHT7)
        (let ((color (or ambient-color (dye .1 .1 .1 1.0))))
          (gl-light-model GL_LIGHT_MODEL_AMBIENT (dye-red color) (dye-green color) (dye-blue color) (dye-alpha color)))
        (let ((color (or material-specular (dye .01 .01 .01 1.0))))
          (gl-material-specular GL_FRONT (dye-red color) (dye-green color) (dye-blue color) (dye-alpha color)))
        (let ((value (or material-shininess 50.)))
          (gl-material-shininess GL_FRONT value))
        (let ((lights (closest-lights))
              (no GL_LIGHT0))
          (set! lights-count (min (get-dynamic-lights~ world) (length lights)))
          (loop (for light in lights)
                (repeat lights-count)
                (glEnable no)
                (glLightf no
                          GL_CONSTANT_ATTENUATION
                          (get-constant-attenuation~ light))
                (glLightf no
                          GL_LINEAR_ATTENUATION
                          (get-linear-attenuation~ light))
                (glLightf no
                          GL_QUADRATIC_ATTENUATION
                          (get-quadratic-attenuation~ light))
                (let ((ambient (get-ambient-color~ light)))
                  (gl-light no
                            GL_AMBIENT
                            (dye-red ambient)
                            (dye-green ambient)
                            (dye-blue ambient)
                            (dye-alpha ambient)))
                (gl-light no
                          GL_DIFFUSE
                          (get-red~ light)
                          (get-green~ light)
                          (get-blue~ light)
                          (get-alpha~ light))
                (gl-light no
                          GL_POSITION
                          (get-x~ light)
                          (get-y~ light)
                          (get-z~ light)
                          1.)
                (increase! no))))))
  
  
  (method (iterate-lights proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Light)
          (proc gadget)))))
  
  
  (method (collect-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (enqueue queue light)))
      (queue-list queue)))
  
  
  (method (collect-static-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (unless (get-dynamic?~ light)
            (enqueue queue light))))
      (queue-list queue)))
  
  
  (method (collect-dynamic-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (when (get-dynamic?~ light)
            (enqueue queue light))))
      (queue-list queue)))
  
  
  (method (count-lights)
    (let ((count 0))
      (iterate-lights
        (lambda (light)
          (increase! count)))
      count))
  
  
  (method (invalidate-lightmaps element)
    @temporary
    (let ((world (current-world)))
      (when (get-lightmaps?~ world)
        (iterate-sectors-with-tiles
          (lambda (index sector)
            (set-lightmap-baked?~ sector #f)))
        (set! update-lightmaps? #f))))
  
  
  (method (update-lightmaps)
    (let ((world (current-world)))
      (when (get-lightmaps?~ world)
        (set! update-lightmaps? #t))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method public (iterate-gravities proc)
    (for-each proc gravities))
  
  
  (method public (iterate-planets proc)
    (iterate-gravities
      (lambda (well)
        (when (is? well Planet)
          (proc well)))))
  
  
  (method public (collect-planets)
    (let ((queue (new-queue)))
      (iterate-planets
        (lambda (planet)
          (enqueue queue planet)))
      (queue-list queue)))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method (reset-marks)
    (set! marks '()))
  
  
  (method (set-marks lst)
    (set! marks lst))
  
  
  (method (set-mark mark)
    (set! marks (list mark)))
  
  
  (method (add-mark mark)
    (set! marks (cons mark marks)))
  
  
  (method (remove-mark mark)
    (set! marks (remove! mark marks)))
  
  
  (method (draw-marks)
    (for-each draw~ marks))
  
  
  (method (reset-all-marks)
    (let ((world (current-world)))
      (reset-marks)
      (display-message~ world "Marks reset")))
  
  
  ;;;
  ;;;; Atlas
  ;;;
  
  
  (method protected virtual (draw-atlas)
    (let ((world (current-world)))
      (unless (get-texture-arrays?)
        (let ((texture (get-texture~ (if (is? % Entity)
                                         (get-material~ (get-mesh~ (get-model~ %)))
                                       (get-tile-atlas~ world))))
              (width 100.)
              (height 100.))
          (map-texture~ texture)
          (textured-quad~ texture
            (lambda () (glVertex3f 0.0 0.0 0.0))
            (lambda () (glVertex3f width 0.0 0.0))
            (lambda () (glVertex3f width height 0.0))
            (lambda () (glVertex3f 0.0 height 0.0)))))))
  
  
  ;;;
  ;;;; Heightmap
  ;;;
  
  
  (method (generate-heightmap-content sector <Sector> heightmap <f32vector> from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (define (generate-done)
      (set-content-revision~ sector (get-current-content-revision))
      (set-content-uptodate?~ sector #t)
      (decrease-sectors-generating sector))
    
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1)))
      (let ((count (f32vector-length heightmap)))
        (let ((vertices (make-vector count))
              (normals (make-vector count)))
          (define (get-vertex x <fx> z <fx>)
            (vector-ref vertices (+ (* x z-count) z)))
          (define (get-normal x <fx> z <fx>)
            (vector-ref normals (+ (* x z-count) z)))
          ;; fill vertices
          (for (x 0 x-count)
               (for (z 0 z-count)
                    (let ((index (+ (* x z-count) z)))
                      (let ((height (f32vector-ref heightmap index)))
                        (let ((x (cast <fl> (+ from-x x)))
                              (y (cast <fl> height))
                              (z (cast <fl> (+ from-z z))))
                          (vector-set! vertices index (vertex x y z))
                          (vector-set! normals index (vertex 0. 0. 0.)))))))
          ;; add triangles
          (let ((squares (make-vector (* width depth)))
                (sectors (make-table test: eq?))
                (areas (make-table test: eq?))
                (default-image (get-default-image~ world)))
            (let ((uv (image-rect~ (get-tile-atlas~ world) default-image)))
              (let ((tl (uv-left uv))
                    (tt (uv-top uv))
                    (tr (uv-right uv))
                    (tb (uv-bottom uv))
                    (texture-depth (uv-depth uv)))
                (define (safe-square x <fx> z <fx>)
                  (and
                    (>= x 0) (< x width)
                    (>= z 0) (< z depth)
                    (get-square x z)))
                (define (get-square x <fx> z <fx>)
                  (vector-ref squares (+ (* x depth) z)))
                (define (set-square x <fx> z <fx> square)
                  (vector-set! squares (+ (* x depth) z) square))
                (define (make-square t1 t2)
                  (cons t1 t2))
                (define (square-t1 square) <Smooth-Triangle>
                  (get-polygon~ (cast <Face> (car square))))
                (define (square-t2 square) <Smooth-Triangle>
                  (get-polygon~ (cast <Face> (cdr square))))
                (define (add-face face <Face>)
                  (let ((center (get-center~ (get-polygon~ face))))
                    (let ((sector (index-sector (position-sector-index center))))
                      (table-add sectors sector face))
                    (when (eq? what 'physical)
                      (let ((area (index-area (position-area-index center) #f)))
                        (table-add areas area (get-polygon~ face))))))
                (define (add-triangle v1 v2 v3)
                  (let ((normal (plane-normal v1 v2 v3)))
                    (let ((face
                            (if (> (vertex-x v1) (vertex-x v2))
                                (make-face #f
                                           (f32vector tl tb tr tb tr tt)
                                           texture-depth
                                           (make-smooth-triangle self
                                                                 v1 v2 v3
                                                                 normal normal normal))
                              (make-face #f
                                         (f32vector tr tt tl tt tl tb)
                                         texture-depth
                                         (make-smooth-triangle self
                                                               v1 v2 v3
                                                               normal normal normal)))))
                      (add-face face)
                      face)))
                ;; add triangles
                (for (x 0 width)
                     (for (z 0 depth)
                          (let ((v1 (get-vertex x (+ z 1)))
                                (v2 (get-vertex (+ x 1) (+ z 1)))
                                (v3 (get-vertex (+ x 1) z))
                                (v4 (get-vertex x z)))
                            (let ((triangle1 (add-triangle v1 v2 v3))
                                  (triangle2 (add-triangle v3 v4 v1)))
                              (set-square x z (make-square triangle1 triangle2))))))
                ;; smooth normals
                (for (x 0 x-count)
                     (for (z 0 z-count)
                          (let ((normal (get-normal x z))
                                (tl (safe-square (- x 1) (- z 1)))
                                (tr (safe-square x (- z 1)))
                                (bl (safe-square (- x 1) z))
                                (br (safe-square x z)))
                            (when tl
                              (vertex-increase! normal (get-normal~ (square-t1 tl))))
                            (when tr
                              (vertex-increase! normal (get-normal~ (square-t1 tr)))
                              (vertex-increase! normal (get-normal~ (square-t2 tr))))
                            (when bl
                              (vertex-increase! normal (get-normal~ (square-t1 bl)))
                              (vertex-increase! normal (get-normal~ (square-t2 bl))))
                            (when br
                              (vertex-increase! normal (get-normal~ (square-t2 br))))
                            (vertex-normalize! normal normal))))
                ;; update normals
                (for (x 0 width)
                     (for (z 0 depth)
                          (let ((square (get-square x z)))
                            (set-n1~ (square-t1 square) (get-normal x (+ z 1)))
                            (set-n2~ (square-t1 square) (get-normal (+ x 1) (+ z 1)))
                            (set-n3~ (square-t1 square) (get-normal (+ x 1) z))
                            (set-n1~ (square-t2 square) (get-normal (+ x 1) z))
                            (set-n2~ (square-t2 square) (get-normal x z))
                            (set-n3~ (square-t2 square) (get-normal x (+ z 1))))))
                (case what
                  ((physical)
                   (when (eq? self (current-zone))
                     (iterate-table areas
                       (lambda (area <Area> polygons)
                         (add-polygons~ area #f polygons)))))
                  ((render)
                   (iterate-table sectors
                     (lambda (sector faces)
                       (let ((faces (list->vector faces)))
                         (receive (vertices neighbors) (prepare-vertices/neighbors~ sector faces)
                           (let ((lightmap (prepare-lightmap~ sector faces)))
                             (post-event
                               (lambda ()
                                 (when (eq? self (current-zone))
                                   (free-mesh~ sector)
                                   (fill-vertices/neighbors~ sector vertices neighbors)
                                   (set-vertices-uptodate?~ sector #t)
                                   (fill-lightmap~ sector lightmap)
                                   (set-lightmap-uptodate?~ sector #t)
                                   (generate-done)))))))))))))))))))


;;;
;;;; Procedural Zones
;;;


(proclaim (warn optimizations))


;; Ideally, this would use a PRNG which we can seed with a given value.
;; That way the map can be persisted using just the seed, and a list of changes.
;; Also I have no clue how this will react in multiplayer.
(class Procedural-Zone extends Zone
  
  
  (property detail-level <fl>               initialize 15. accessors generate)
  (property clamp-height <fl>               initialize 65. accessors generate)
  (property seed         <object>           initialize #f  accessors generate)
  (property generator    <Perlin-Generator> initialize #f  accessors generate)
  
  
  (method override (setup-component)
    (nextmethod)
    (random-seed seed)
    (set! generator (new Perlin-Generator detail-level clamp-height)))
  
  
  (method override (generate-content?)
    #t)
  
  
  (method override (generate-content sector <Sector>)
    (let ((index (get-index~ sector)))
      (let ((x <fx> (vector-ref index 0))
            (y <fx> (vector-ref index 1))
            (z <fx> (vector-ref index 2)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural sector from-x width from-z depth 'render)))))
    (set-content-revision~ sector (get-current-content-revision))
    (set-content-uptodate?~ sector #t)
    (decrease-sectors-generating sector))
  
  
  (method override (generate-physical sector <Sector>)
    (let ((index (get-index~ sector)))
      (let ((x <fx> (vector-ref index 0))
            (y <fx> (vector-ref index 1))
            (z <fx> (vector-ref index 2)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural sector from-x width from-z depth 'physical))))))
  
  
  (method (generate-procedural sector <Sector> from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1)))
      (define (generate-heightmap)
        (let ((heightmap <f32vector> (make-f32vector (* x-count z-count))))
          (for (x 0 x-count)
               (for (z 0 z-count)
                    (f32vector-set! heightmap (+ (* x z-count) z)
                      ;; max and min are quick hacks until perlin generator is fixed
                      (max 0. (min 10. (/ (get-value~ generator (cast <fl> (+ from-x x)) (cast <fl> (+ from-z z))) 5.))))))
          heightmap))
      
      (generate-heightmap-content sector (generate-heightmap) from-x width from-z depth what)))))
