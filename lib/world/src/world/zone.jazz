;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Zones
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.zone jazz


(import (jazz.associative)
        (jazz.component)
        (jazz.io)
        (jazz.geometry)
        (jazz.markup)
        (jazz.platform.types)
        (jazz.snapshot)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (gaea.dye)
        (gaea.geometry)
        (gaea.homogeneous)
        (gaea.opengl.glew)
        (gaea.opengl.render)
        (world)
        (world.actor)
        (world.album)
        (world.area)
        (world.assets)
        (world.atlas)
        (world.autoload)
        (world.block)
        (world.buffer)
        (world.camera)
        (world.chunk)
        (world.client.network)
        (world.client.tier)
        (world.configure)
        (world.context)
        @coverage
        (world.coverage)
        (world.creature)
        (world.distance)
        (world.draw)
        (world.dyes)
        (world.element)
        (world.entity)
        (world.entities)
        (world.expanse)
        (world.face)
        (world.fog)
        (world.foreign)
        (world.gadget)
        (world.generation)
        (world.generation.base)
        (world.generation.block)
        (world.generation.building)
        (world.generation.redstone)
        (world.generation.rendering)
        (world.gravity)
        (world.grid)
        (world.history)
        (world.index)
        (world.info)
        (world.interface.bars)
        (world.interface.documents)
        (world.interface.inventory)
        (world.io)
        (world.lava)
        (world.light)
        (world.lighting)
        (world.mesh)
        (world.moment)
        (world.moment.syntax (phase syntax))
        (world.motion)
        (world.music)
        (world.network)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.processor.network)
        (world.profiling)
        (world.random)
        (world.redstone)
        (world.region)
        (world.render)
        (world.renderer)
        (world.scene)
        (world.scripter)
        (world.section)
        (world.sector)
        (world.settings)
        (world.skybox)
        (world.sound)
        (world.space)
        (world.spawn)
        (world.stress)
        (world.sun)
        (world.support)
        (world.syntax (phase syntax))
        (world.tag)
        (world.task)
        (world.texture)
        (world.tier)
        (world.triangle)
        (world.water)
        (world.work))


(proclaim (not check bounds))


;;;
;;;; Zone
;;;


(definition protected day-span <fl>
  24000.)

(definition protected dawn-daytime <fl>
  6000.)

(definition protected day-daytime <fl>
  12000.)

(definition protected dusk-daytime <fl>
  18000.)

(definition protected night-daytime <fl>
  0.)


(definition protected default-day-duration <fl>
  1200.)


(definition delay-updating? <bool>
  (world-setting 'world.delay-updating? #t))

(definition report-updating? <bool>
  (world-setting 'world.report-updating? #f))


(definition show-generated? <bool>
  (world-setting 'world.show-generated? #f))

(definition show-loaded? <bool>
  (world-setting 'world.show-loaded? #f))

(definition show-sections? <bool>
  (world-setting 'world.show-sections? #f))


(definition debug-retrieves?
  (world-setting 'world.debug-retrieves? #f))


;; index of the eye sector
(definition protected eye-index <index+>
  #f)

;; cube of all eye sectors
(definition protected eye-sectors
  #f)

;; eye sectors ordered by distance
(definition protected eye-neighbors
  #f)

;; eye sectors within camera frustum
(definition protected eye-frustum
  #f)

(definition protected eye-frustum-count
  0)

(definition protected eye-frustum-uptodate?
  #f)

(definition protected eye-radius <fx>
  0)

(definition protected eye-diameter <fx>
  0)

(definition protected eye-diameter^2 <fx>
  0)

(definition protected eye-diameter^3 <fx>
  0)

(definition protected eye-preload <fx>
  3)

(definition protected eye-instantiate <fx>
  5)


(definition protected (eye-update)
  (set! eye-frustum-uptodate? #f))


(class Zone extends Scene
  
  
  (property title                   <string+>    initialize #f              accessors generate)
  (property start-mode              <symbol>     initialize #f              accessors generate)
  (property start-distance          <fl+>        initialize #f              accessors generate)
  (property start-spawnpoint        <vertex+>    initialize #f              accessors generate)
  ;; change default from #f to 0 for now and when we start using full 3d regions
  ;; put it back to #f and make it so minecraft zones have truncate-y = 0 by default
  (property truncate-y              <fx+>        initialize 0               accessors generate)
  (property missile-behavior        <symbol>     initialize 'destroy        accessors generate)
  (property sun?                    <bool>       initialize #t              accessors generate)
  (property day-duration            <object>     initialize default-day-duration accessors generate)
  (property start-time              <object>     initialize #f              accessors generate)
  (property start-skybox            <object>     initialize #f              accessors generate)
  (property atlas-name              <object>     initialize #f              accessors generate)
  (property prepare-script          <object>     initialize "zone/prepare"  accessors generate)
  (property enter-script            <object>     initialize "zone/enter"    accessors generate)
  (property exit-script             <object>     initialize "zone/exit"     accessors generate)
  (property draw-grid?              <bool>       initialize #t              accessors generate)
  (property first-time?             <bool>       initialize #t              accessors generate)
  (property level-dir               <Directory>  initialize #f              accessors generate)
  (property level-dimension         <symbol>     initialize 'over           accessors generate)
  (property player-glow             <fl>         initialize -1.             accessors generate)
  (property vista-target            <object>     initialize #f              accessors generate)
  (property vista-radius            <object>     initialize #f              accessors generate)
  (property vista-elevation         <object>     initialize #f              accessors generate)
  (property seed                    <object>     initialize #f              accessors generate)
  (property properties              <object>     initialize '()             accessors generate)
  
  ;; world override properties
  (property ambient-gravity         <object>     initialize default-gravity accessors generate)
  (property jump-impulsion          <object>     initialize default-jump    accessors generate)
  (property start-grid?             <object>     initialize #f              accessors generate)
  (property start-grid-position     <object>     initialize 0.              accessors generate)
  (property start-axes?             <object>     initialize #f              accessors generate)


  (slot path                        <object>     initialize #f                        accessors generate)
  (slot dimension                   <object>     initialize #f                        getter generate)
  (slot debug-sections?             <bool>       initialize #f                        accessors generate)
  (slot sector-size                 <fx>         initialize 16                        getter generate)
  (slot sector-radius               <fl>         initialize #f                        getter generate)
  (slot sector-diameter             <fl>         initialize #f                        getter generate)
  (slot sector/subarea-ratio        <fx>         initialize #f                        getter generate)
  (slot sectors-generating          <fx>         initialize 0                         getter generate)
  (slot sectors-generated           <fx>         initialize 0                         getter generate)
  (slot sectors-mutex               <object>     initialize #f                        getter generate)
  (slot debug-sectors?              <bool>       initialize #f                        accessors generate)
  (slot areas                       <table>      initialize #f                        getter generate)
  (slot subarea-size                <fx>         initialize 2                         getter generate)
  (slot debug-areas?                <bool>       initialize #f                        accessors generate)
  (slot chunk-requests              <table>      initialize (make-table test: equal?) getter generate)
  (slot chunk-requests-mutex        <object>     initialize (make-mutex 'chunk-requests) getter generate)
  (slot chunk-requests-shutdown?    <bool>       initialize #f                        getter generate)
  (slot expanses                    <table>      initialize #f                        getter generate)
  (slot assets                      <object>     initialize '()                       getter generate)
  (slot players                     <list>       initialize '()                       getter generate)
  (slot actors                      <list>       initialize '()                       getter generate)
  (slot entities                    <list>       initialize '()                       getter generate)
  (slot gravities                   <list>       initialize '()                       getter generate)
  (slot gadgets                     <list>       initialize '()                       getter generate)
  (slot marks                       <list>       initialize '()                       getter generate)
  (slot simulations                 <table>      initialize (make-table test: eq?)    getter generate)
  (slot game                        <object>     initialize #f                        getter generate)
  (slot generator                   <Generator+> initialize #f                        accessors generate)
  (slot draw-procedures             <object>     initialize '()                       getter generate)
  (slot draw-procedure-names        <object>     initialize #f                        getter generate)
  (slot destroy-hooks               <list>       initialize '()                       getter generate)
  (slot ready?                      <bool>       initialize #f                        accessors generate)
  (slot editable?                   <bool>       initialize #t                        accessors generate)
  (slot editable-warned?            <bool>       initialize #f                        accessors generate)
  (slot daytime                     <fl>         initialize 0.                        getter generate)
  (slot daylight                    <fl>         initialize 0.                        accessors generate)
  (slot sun                         <Sun+>       initialize #f                        accessors generate)
  (slot sun-angle                   <fl>         initialize -.20                      accessors generate)
  (slot skybox                      <Skybox+>    initialize #f                        accessors generate)
  (slot designer                    <object>     initialize #f                        accessors generate)
  (slot level-file                               initialize #f)
  (slot level-state                              initialize #f)
  (slot opened-chest                             initialize #f                        accessors generate)
  (slot inventory-blocks                         initialize (make-vector 63 #f)       getter generate)
  (slot request-task                <object>     initialize #f                        getter generate)
  (slot preload-task                <object>     initialize #f                        getter generate)
  (slot generate-task               <object>     initialize #f                        getter generate)
  (slot instantiate-task            <object>     initialize #f                        getter generate)
  (slot interface-task              <object>     initialize #f                        getter generate)
  (slot render-task                 <object>     initialize #f                        getter generate)
  (slot free-task                   <object>     initialize #f                        getter generate)
  (slot tick-task                   <object>     initialize #f                        getter generate)
  (slot player-task                 <object>     initialize #f                        getter generate)
  (slot action-task                 <object>     initialize #f                        getter generate)
  (slot redstone-task               <object>     initialize #f                        getter generate)
  (slot gravity-task                <object>     initialize #f                        getter generate)
  (slot lava-task                   <object>     initialize #f                        getter generate)
  (slot water-task                  <object>     initialize #f                        getter generate)
  (slot distance-task               <object>     initialize #f                        getter generate)
  (slot eat-task                    <object>     initialize #f                        getter generate)
  (slot sun-task                    <object>     initialize #f                        getter generate)
  (slot spawn-task                  <object>     initialize #f                        getter generate)
  (slot missile-task                <object>     initialize #f                        getter generate)
  (slot song-task                   <object>     initialize #f                        getter generate)
  (slot music-task                  <object>     initialize #f                        getter generate)
  (slot processor-update-task       <object>     initialize #f                        getter generate)
  (slot processor-droppable-task    <object>     initialize #f                        getter generate)
  (slot client-update-task          <object>     initialize #f                        getter generate)
  (slot client-droppable-task       <object>     initialize #f                        getter generate)
  (slot client-alive-task           <object>     initialize #f                        getter generate)
  (slot stress-task                 <object>     initialize #f                        getter generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method package virtual (login? self)
    #f)
  
  
  (method package virtual (void? self)
    #f)
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set-current-zone self))
  
  
  (method override (finish self rest)
    (nextmethod self rest)
    (load-point 'zone-prepare)
    (when (window?)
      (prepare-blocks self)
      (load-point 'zone-blocks))
    (when (window?)
      (prepare-draw)
      (load-point 'zone-draw))
    (setup-me (current-tier))
    (set! sun? (and sun? (world-setting 'world.sun? #t)))
    (set! start-time (or start-time (world-setting 'world.start-time 'dawn)))
    (set! day-duration (world-setting 'world.day-duration default-day-duration))
    (set! draw-procedure-names (make-table test: eq?))
    (set! debug-sections? (world-setting 'world.debug-sections? #f))
    (when (window?)
      (unless (void? self)
        (set! request-task (new Task 'request run-request exit: exit-request priority: request-priority))
        (set! preload-task (new Task 'preload run-preload exit: exit-preload priority: preload-priority))
        (set! generate-task (new Task 'generate run-generate exit: exit-generate priority: generate-priority))
        (set! instantiate-task (new Task 'instantiate run-instantiate exit: exit-instantiate priority: instantiate-priority)))
      (set! interface-task (new Task 'interface (~ run-interface self) priority: interface-priority))
      (set! render-task (new Task 'render (~ run-render self) priority: render-priority))
      (set! free-task (new Task 'free run-free exit: exit-free priority: free-priority)))
    (set! tick-task (new Task 'tick (~ run-tick self) priority: tick-priority))
    (unless (void? self)
      (when (client?)
        (set! player-task (new Task 'player (~ run-player self) priority: player-priority))
        (set! action-task (new Task 'action (~ run-action self) priority: action-priority)))
      @redstonewait
      (set! redstone-task (new Task 'redstone run-redstone priority: redstone-priority))
      @gravitywait
      (set! gravity-task (new Task 'gravity (~ run-gravity self) priority: gravity-priority))
      @lavawait
      (set! lava-task (new Task 'lava run-lava priority: lava-priority))
      @waterwait
      (set! water-task (new Task 'water run-water priority: water-priority))
      (when (client?)
        (set! distance-task (new Task 'distance run-distance priority: distance-priority))
        @eatwait
        (set! eat-task (new Task 'eat (~ run-eat self) priority: eat-priority)))
      (set! sun-task (new Task 'sun (~ run-sun self) priority: sun-priority))
      @YOWNU
      (begin
        (set! spawn-task (new Task 'spawn run-spawn priority: spawn-priority))
        (set! missile-task (new Task 'missile (~ run-missile self) priority: missile-priority))
        (when (window?)
          (set! song-task (new Task 'song run-song priority: song-priority))
          (set! music-task (new Task 'music run-music priority: music-priority)))))
    (when (processor?)
      (set! processor-update-task (new Task 'update run-processor-update priority: processor-update-priority))
      (set! processor-droppable-task (new Task 'droppable run-processor-droppable priority: processor-droppable-priority)))
    (when (client?)
      (unless (void? self)
        (set! client-update-task (new Task 'update run-update priority: client-update-priority))
        (set! client-droppable-task (new Task 'send-droppable run-send-droppable priority: send-droppable-priority)))
      (set! client-alive-task (new Task 'alive run-alive priority: alive-priority))
      (when stressable?
        (set! stress-task (new Task 'stress run-stress priority: stress-priority))))
    (load-point 'zone-tasks)
    (when (window?)
      (register-entity-classes)
      (prepare-skybox-program)
      (prepare-skybox self)
      (load-point 'zone-skybox))
    (initialize-spawned)
    (load-point 'zone-created)
    (set-daytime self (effective-daytime self start-time))
    (set! sun-angle (daytime->sun-angle self daytime))
    (load-point 'zone-sun))
  
  
  (method package (initialize-zone self)
    (setup-persistence self)
    (setup-seed self)
    (setup-generator self)
    (setup-dimension self)
    (setup-sectors self)
    (setup-areas self)
    (setup-expanses self)
    (setup-overrides self)
    (setup-universe self)
    (setup-space self)
    (setup-player self)
    (setup-children self)
    (setup-game self)
    (enter-tier self)
    (zone-change (current-space) self)
    (when (window?)
      (start-music self)
      (start-ambience self)
      (install-interface self)
      (display-welcome self)))
  
  
  (method (setup-persistence self)
    (when (not level-dir)
      (set! level-dir (new-directory (get-directory self) "level"))))
  
  
  (method (setup-seed self)
    (if seed
        (init-seed seed)
      (let ((seed (world-setting 'world.seed (random-monotonic))))
        (set-property designer self 'seed seed)
        (init-seed seed))))
  
  
  (method protected virtual (setup-generator self)
    (let ((file (new-file (get-directory self) ".generator")))
      (set! generator (if (exists? file)
                          (instantiate (read-form file))
                        (new Empty-Generator)))))
  
  
  (method (setup-overrides self)
    (let ((world (current-world)))
      (when (specified? ambient-gravity)
        (set-ambient-gravity world ambient-gravity))
      (when (specified? jump-impulsion)
        (set-jump-impulsion world jump-impulsion))
      (set-grid? world start-grid?)
      (set-grid-position world start-grid-position)
      (set-axes? world start-axes?)))
  
  
  (method protected virtual (setup-universe self)
    (set-current-universe (new Universe)))
  
  
  (method protected virtual (setup-space self)
    (unless (current-space+)
      (set-current-space (new Space))
      (clear-snapshot-property 'live.space)))
  
  
  (method protected virtual (setup-player self)
    (let ((me (current-me+)))
      (when me
        (add-element self me))))
  
  
  ;; backward compatibility
  (method protected virtual (setup-children self)
    (let ((touched? #f))
      (for-each (lambda (obj)
                  (when (is? obj Element)
                    (add-element self obj)
                    (when (component-in-descendants? designer obj)
                      (with-designer self obj
                        (lambda (des container)
                          (remove-child designer obj)
                          (set-parent obj container)
                          (add-child des obj container form: (get-form obj))
                          (set! touched? #t))))))
                children)
      (when touched?
        (save designer))))
  
  
  (method (setup-game self)
    (when (client?)
      (let ((file (new-file (get-directory self) ".game")))
        (set! game (if (exists? file)
                       (instantiate (read-form file))
                     (let ((units '(world.game)))
                       (let ((tag '(<World-Game>))
                             (data (new Data zone-version 'jazz units #f)))
                         (let ((form (construct-form tag (imports-locator units) data)))
                           (set-origin form file)
                           (instantiate form)))))))))
  
  
  (method protected virtual (camera-update self)
    )
  
  
  (method protected virtual (title-update self)
    @YOWNU
    (when (window?)
      (let ((window (current-window)))
        (set-caption window title))))
  
  
  (method protected virtual (enter-tier self)
    (enter (current-tier)))
  
  
  (method protected virtual (start-music self)
    (let ((music (current-music)))
      (initial-music music)))
  
  
  (method protected virtual (start-ambience self)
    (let ((ambience (current-ambience)))
      (initial-ambience ambience)))
  
  
  (method protected virtual (stop-music self)
    (let ((music (current-music)))
      (close-music music)))
  
  
  (method protected virtual (stop-ambience self)
    (let ((ambience (current-ambience)))
      (close-ambience ambience)))
  
  
  (method protected (effective-player-position self)
    (if vista-target
        (vertex+ vista-target (vertex 0. 50. 0.))
      (vertex 0. 50. 0.)))
  
  
  (method protected (effective-vista-target self)
    (or vista-target (vertex 0. 4. 0.)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method package virtual (populate-zone self)
    )
  
  
  (method package virtual (generate-visual self sector)
    (site visual
      (instantiate-visual sector)))
  
  
  (method package virtual (generate-physical self area revision-update?)
    (site physical
      (instantiate-physical area revision-update?)))
  
  
  (method package virtual (zone-ready self)
    )
  
  
  (method (get-zone-directory self)
    (let ((moniker (get-moniker self)))
      (and moniker
           (get-parent moniker))))
  
  
  (method package (zone-path self kind)
    (let ((directory (get-tiers-directory kind))
          (moniker (get-moniker self)))
      (subpath directory (get-parent moniker))))
  
  
  (method (zone-brother self path)
    (new-file (get-zone-directory self) path))
  
  
  (method protected virtual (about-size self)
    {Dimension 715 388})

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (register-destroy-hook self proc)
    (set! destroy-hooks (cons proc destroy-hooks)))
  
  
  (method (unregister-destroy-hook self proc)
    (set! destroy-hooks (remove! proc destroy-hooks)))
  
  
  (method override (add-child self child)
    (set! children (cons child children)))
  
  
  (method override (destroy-component self)
    (destroy self))
  
  
  (method override (destroy self)
    (let ((world (current-world)))
      (shutting-down
        (lambda ()
          (launch-event world exit-script)
          @too-brittle ;; for example putting a crash-process in server retrieve chunk
          (when (window?)
            (unpause-world world))
          (shutdown-selection world)
          (when (window?)
            (uninstall-interface self))
          (shutdown-chunk-requests self)
          (stop-tasks self)
          (save-zone self)
          (save-designer self)
          (save-game self)
          (for-each (lambda (proc)
                      (proc))
                    destroy-hooks)
          (free-generator self)
          (free-eye-sectors self)
          (free-dimension self)
          (when (window?)
            (stop-music self)
            (stop-ambience self)
            (clear-action world))))))
  
  
  (method package virtual (save-zone self)
    (let ((tier (current-tier))
          (world (current-world))
          (motion (current-motion)))
      (define (save)
        (set-property designer self 'first-time? #f))
      
      (define (save-mode)
        (set-property designer self 'start-mode (if (person-motion?) 'first-person 'free-camera)))
      
      (define (save-distance)
        (when (is? motion Target-Motion)
          (set-property designer self 'start-distance (get-desired-distance motion))))
      
      (save)
      ;; until these properties are in the player at
      ;; least don't save them when no actual player
      (when (current-me+)
        (save-mode)
        (save-distance))
      (save-me tier)
      (when (window?)
        (save-chest save-region?: #t)
        (save-inventory))
      (save-level-state self)))
  
  
  (method package (save-designer self)
    (save designer))
  
  
  (method (save-game self)
    (when (client?)
      (let ((form (get-form game)))
        (let ((file (get-origin form)))
          (create-directories file)
          (let ((designer (new Former form: form reference: game)))
            (set-property designer game 'first-time? #f)
            (save designer))))))
  
  
  (method package (install-interface self)
    (let ((world (current-world))
          (interface (current-interface)))
      (view-inventory (child interface 'belt))
      (reset-cache (child interface 'map))))
  
  
  (method package (uninstall-interface self)
    )
  
  
  (method (display-welcome self)
    @YOWNU
    (when (and (client?) (show-chat? self))
      (let ((tier (current-client))
            (interface (current-interface)))
        (unless (get-welcomed? tier)
          (let ((welcome (get-welcome tier)))
            (when welcome
              (let ((chat (child interface 'chat)))
                (show-welcome chat welcome))))
          (set-welcomed? tier #t)))))
  
  
  (method protected virtual (show-belt? self)
    #f
    @YOWNU
    (let ((world (current-world)))
      (get-show-belt? world)))
  
  
  (method protected virtual (show-compass? self)
    #t)
  
  
  (method protected virtual (show-combat? self)
    #t)
  
  
  (method protected virtual (show-chat? self)
    #t)
  
  
  ;;;
  ;;;; Tasks
  ;;;
  
  
  (method package (start-tasks self)
    (when (window?)
      (unless (void? self)
        (start-task request-task)
        (start-task preload-task)
        (start-task generate-task)
        (start-task instantiate-task))
      (start-task interface-task)
      (start-task render-task)
      (start-task free-task))
    (start-task tick-task)
    (unless (void? self)
      (when (client?)
        (start-task player-task)
        (start-task action-task))
      @redstonewait
      (start-task redstone-task)
      @gravitywait
      (start-task gravity-task)
      @lavawait
      (start-task lava-task)
      @waterwait
      (start-task water-task)
      (when (client?)
        (start-task distance-task)
        @eatwait
        (start-task eat-task))
      (start-task sun-task)
      @YOWNU
      (begin
        (start-task spawn-task)
        (start-task missile-task)
        (when (window?)
          (start-task song-task)
          (start-task music-task))))
    (when (processor?)
      (start-task processor-update-task)
      (start-task processor-droppable-task))
    (when (client?)
      (unless (void? self)
        (start-task client-update-task)
        (start-task client-droppable-task))
      (start-task client-alive-task)
      (when stressable?
        (start-task stress-task))))
  
  
  (method (stop-tasks self)
    (define (stop-simulations)
      (iterate-table simulations
        (lambda (entity task)
          (halt-simulation self entity))))
    
    (define (stop-entities)
      (for-each stop-entity entities))
  
    (define (stop-entity entity)
      (let ((task (get-task entity)))
        (when task
          (stop-task task))))
    
    (let ((world (current-world)))
      (set-render-boost? #f)
      (set-player-boost? #f)
      (unless (void? self)
        (stop-task request-task)
        (stop-task preload-task)
        ;; stop generate before instantiate
        (stop-task generate-task)
        ;; stop instantiate before entities
        (stop-task instantiate-task)
        (stop-simulations)
        (stop-entities))
      (stop-task tick-task)
      (unless (void? self)
        (when (client?)
          (stop-task player-task)
          (stop-task action-task))
        @redstonewait
        (stop-task redstone-task)
        @gravitywait
        (stop-task gravity-task)
        @lavawait
        (stop-task lava-task)
        @waterwait
        (stop-task water-task)
        (when (client?)
          (stop-task distance-task)
          @eatwait
          (stop-task eat-task))
        (stop-task sun-task)
        @YOWNU
        (begin
          (stop-task spawn-task)
          (stop-task missile-task)
          (when (window?)
            (stop-task song-task)
            (stop-task music-task))))
      (when (processor?)
        (stop-task processor-update-task)
        (stop-task processor-droppable-task))
      (when (client?)
        (unless (void? self)
          (stop-task client-update-task)
          (stop-task client-droppable-task))
        (stop-task client-alive-task)
        (when stressable?
          (stop-task stress-task)))
      (when (client?)
        (set-player-thread world #f))
      (when (window?)
        (stop-task interface-task)
        (stop-task render-task)
        (set-render-thread world #f)
        (stop-task free-task))))
  
  
  ;;;
  ;;;; Generator
  ;;;
  
  
  (method (free-generator self)
    (when generator
      (free generator)
      (set! generator #f)))
  
  
  ;;;
  ;;;; Scripts
  ;;;
  
  
  (definition scripting-prepared?
    #f)
  
  
  (method package (prepare-scripting self)
    (define (script-code)
      "(module prepare-scripting script (import (world.script)))")
    
    (when (scripting-available?)
      (when (not scripting-prepared?)
        (when (world-setting 'world.worker? #t)
          (let ((code (script-code)))
            (worker-run #f code
              ;; read
              (lambda (data)
                )
              ;; walk
              (lambda (data)
                )
              ;; error
              (lambda (data)
                )
              ;; run
              (lambda ()
                )
              ;; result
              (lambda (result)
                ))))
        (set! scripting-prepared? #t))))
  
  
  (method package (run-script self element)
    (unless (inhibit-scripts?)
      (when (is? element Entity)
        (let ((script (get-script element)))
          (when script
            (let ((kind (get-kind script)))
              (when (or (and (processor?) (eq? kind 'server))
                        (and (client?) (eq? kind 'client)))
                (let ((script (get-script element)))
                  (run-task element script evaluate-run?: #t)))))))))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method package (player-update self)
    (when (current-me+)
      (let ((interface (current-interface+)))
        (when interface
          (let ((character-panel (child interface 'character)))
            (view-inventory character-panel)
            (update character-panel))))))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (proclaim (not warn optimizations))

  
  (method package (target-update self target poly vert (only-feet? #f))
    (define (center-info title center (poly #f))
      (let ((section (position-section self center))
            (x (fxfloor (vertex-x center)))
            (y (fxfloor (vertex-y center)))
            (z (fxfloor (vertex-z center))))
        (if (not section)
            #f
          (let ((section-index (get-index section)))
            (let ((section-x (index-x section-index))
                  (section-y (index-y section-index))
                  (section-z (index-z section-index)))
              (let ((cache-uninitialized <fx> 65535)
                    (sections (neighbor-sections section section-x section-y section-z)))
                (define (gather-info)
                  (let ((bottom-section? (= section-y (cast <fx> (or truncate-y 0))))
                        (cache <u16vector> (initialize-block-cache block-cache cache-uninitialized))
                        (blocks (get-blocks section))
                        (data (get-data section))
                        (blocklight (get-blocklight section))
                        (skylight (get-skylight section)))
                    (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                      (let ((index (neighbor-section-index a b c)))
                        (and index (vector-ref sections index))))
                    
                    (define (local-index i <fx> j <fx> k <fx>) <fx>
                      (+ (* j 256) (* k 16) i))
                    
                    (define (effective-index i <fx> j <fx> k <fx>) <fx>
                      (* (+ (* j 324) (* k 18) i 343) 4))
                    
                    (define (blocks-get section <World-Section>) <u8vector>
                      (get-blocks section))
                    
                    (define (blocklight-get section <World-Section>) <u8vector>
                      (get-blocklight section))
                    
                    (define (blocklight-ref i <fx> j <fx> k <fx>)
                      (u4vector-ref blocklight (local-index i j k)))
                    
                    (define (skylight-ref i <fx> j <fx> k <fx>)
                      (u4vector-ref skylight (local-index i j k)))
                    
                    (define (local-block-ref i <fx> j <fx> k <fx>)
                      (u8vector-ref blocks (local-index i j k)))
                    
                    (define (local-data-ref i <fx> j <fx> k <fx>)
                      (u4vector-ref data (local-index i j k)))
                    
                    (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                      (let ((index (effective-index i j k)))
                        (let ((value (u16vector-ref cache index)))
                          (if (/= value cache-uninitialized)
                              value
                            (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                              (u16vector-set! cache index value)
                              value)))))
                    
                    (define (effective-light-ref shade <fl> i <fx> j <fx> k <fx>) <fx>
                      (field-ref i j k blocklight-get u4vector-ref 0 0))
                    
                    (define (u4vector-ref field <u8vector> index <fx>) <fx>
                      (let ((byte (u8vector-ref field (quotient index 2))))
                        (if (even? index)
                            (bitwise-and byte #x0F)
                          (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                    
                    (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                      (define (bind-i a <fx> i <fx>)
                        (define (bind-j b <fx> j <fx>)
                          (define (bind-k c <fx> k <fx>)
                            (let ((section (section-ref a b c)))
                              (if (not section)
                                  (if (and bottom-section? (= b -1)) bottom empty)
                                (let ((field (get-field section)))
                                  (if (not field)
                                      (if (and bottom-section? (= b -1)) bottom empty)
                                    (ref field (local-index i j k)))))))
                          
                          (cond ((< k 0) (bind-k (quotient/ k 16) (modulo k 16)))
                                ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                                (else (bind-k 0 k))))
                        
                        (cond ((< j 0) (bind-j (quotient/ j 16) (modulo j 16)))
                              ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                              (else (bind-j 0 j))))
                      
                      (cond ((< i 0) (bind-i (quotient/ i 16) (modulo i 16)))
                            ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                            (else (bind-i 0 i))))
                    
                    (define (compute-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                      (format "{a} {a} {a} {a}"
                              (effective-light-ref shade (+ i ax) (+ j ay) (+ k az))
                              (effective-light-ref shade (+ i bx) (+ j by) (+ k bz))
                              (effective-light-ref shade (+ i cx) (+ j cy) (+ k cz))
                              (effective-light-ref shade (+ i dx) (+ j dy) (+ k dz))))
                    
                    (define (ambient-light i <fx> j <fx> k <fx> vert)
                      (let ((origin (vertex-& (vertex-& vert (vertex& (cast <fl> x) (cast <fl> y) (cast <fl> z))) (vertex& .5 .5 .5)))
                            (normal (get-normal poly)))
                        (generic-lighting i j k origin normal compute-lighting no-shade)))
                    
                    (define (block-info i <fx> j <fx> k <fx>)
                      (let ((block-id (local-block-ref i j k))
                            (data-id (local-data-ref i j k))
                            (blocklight (blocklight-ref i j k))
                            (skylight (skylight-ref i j k)))
                        (let ((block (id/variant-id->block block-id data-id)))
                          (append (list (cons title (get-name block)))
                                  (if (not (equal? title "Feet"))
                                      (list (cons "id" block-id)
                                            (cons "data" data-id))
                                    '())
                                  (list (cons "block light" blocklight)
                                        (cons "sky light" skylight))
                                  (if (equal? title "Feet")
                                      (list (cons "section" (format "{a} {a} {a}" section-x section-y section-z))
                                            (cons "coordinates" (format "{a} {a} {a}" i j k)))
                                    '())
                                  (if (and poly (developer?))
                                      (list (cons "section" (format "{a} {a} {a}" section-x section-y section-z))
                                            (cons "coordinates" (format "{a} {a} {a}" i j k))
                                            (cons "location" (present-location (position->location (polygon-position poly))))
                                            (cons "ambient" (ambient-light i j k vert)))
                                    '())))))
                    
                    (define (present-location loc)
                      (format "{a} {a} {a}"
                              (index-x loc)
                              (index-y loc)
                              (index-z loc)))
                    
                    (let ((i (- x (* section-x 16)))
                          (j (- y (* section-y 16)))
                          (k (- z (* section-z 16))))
                      (block-info i j k))))
                
                ;; quick hack
                (if only-feet?
                    (gather-info)
                  (with-generate-mutex
                    (lambda ()
                      (gather-info))))))))))
    
    (define (update-feet)
      (let ((pos (get-position (current-me))))
        (let ((feet (vertex+ pos (vertex 0. .5 0.))))
          (let ((info (center-info "Feet" feet)))
            (if (not info)
                (unregister-info 'feet)
              (register-info 'feet
                (lambda (add-section add-info)
                  (let ((section (add-section "Feet")))
                    (for-each (lambda (info)
                                (add-info section (car info) (cdr info)))
                              info)))))))))
    
    (define (update-info)
      (if (or (not poly) (get-element poly))
          (begin
            (unregister-info 'block)
            (unregister-info 'fore))
        (let ((universe (current-universe)))
          (with-polygon-interaction universe poly
            (lambda (poly block fore)
              (let ((info (center-info "Block" block poly)))
                (register-info 'block
                  (lambda (add-section add-info)
                    (let ((section (add-section "Block")))
                      (for-each (lambda (info)
                                  (add-info section (car info) (cdr info)))
                                info)))))
              @wait
              (let ((info (center-info "Fore" fore)))
                (if (not info)
                    (unregister-info 'fore)
                  (register-info 'fore
                    (lambda (add-section add-info)
                      (let ((section (add-section "Fore")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info)))))))))
        (unregister-info 'feet)))
    
    (define (update-vertex)
      (define (determine-mesh)
        (if (and target
                 (= (length target) 1)
                 (is? (car target) Entity)
                 (is-not? (car target) Block-Entity)
                 (get-model (car target)))
            (let ((meshes (get-meshes (cache-model (car target)))))
              (and meshes
                   (> (vector-length meshes) 0)
                   (let ((position (get-position (car target))))
                     (values (vertex- vert position) (vector-ref meshes 0)))))
          (let ((universe (current-universe)))
            (with-polygon-interaction universe poly
              (lambda (poly block fore)
                (let ((section (position-section self block)))
                  (let ((sector (find-sector (current-zone) (get-index section))))
                    (and sector
                         (let ((position (get-position& sector)))
                           (values (vertex- vert position) (get-mesh sector)))))))))))
      
      (define (vertex-info)
        (and vert
             (let ((info (determine-mesh)))
               (and info
                    (receive (vert mesh) info
                      (with-render-mutex
                        (lambda ()
                          (let ((world (current-world)))
                            (parameterize ((transform-feedback? #t))
                              (glEnable GL_RASTERIZER_DISCARD)
                              (render-world world)
                              (glDisable GL_RASTERIZER_DISCARD)))))
                      (let ((feedback (get-feedback-buffer mesh)))
                        (and (get-buffer feedback)
                             (let ((size (get-size feedback)))
                               (let ((data (make-f32vector size)))
                                 (define (find-vertex-offset)
                                   (continuation-capture
                                     (lambda (return)
                                       (loop (for n from 0 below (get-indices feedback))
                                             (let ((offset (* n feedback-floats)))
                                               (when (and (= (f32vector-ref data offset) (vertex-x vert))
                                                          (= (f32vector-ref data (+ offset 1)) (vertex-y vert))
                                                          (= (f32vector-ref data (+ offset 2)) (vertex-z vert)))
                                                 (continuation-return return offset))))
                                       #f)))
                                 
                                 (bind-feedback-buffer feedback)
                                 (glGetTransformFeedbackFloat* 0 size data)
                                 (let ((offset (find-vertex-offset)))
                                   (if (not offset)
                                       (list (cons "feedback" "<not found>")
                                             (cons "out1" (present-vec4 (subf32vector data 0 4)))
                                             (cons "out2" (present-vec4 (subf32vector data 4 8)))
                                             (cons "out3" (present-vec4 (subf32vector data 8 12)))
                                             (cons "out4" (present-vec4 (subf32vector data 12 16))))
                                     (list (cons "out1" (present-vec4 (subf32vector data (+ offset 0) (+ offset 4))))
                                           (cons "out2" (present-vec4 (subf32vector data (+ offset 4) (+ offset 8))))
                                           (cons "out3" (present-vec4 (subf32vector data (+ offset 8) (+ offset 12))))
                                           (cons "out4" (present-vec4 (subf32vector data (+ offset 12) (+ offset 16))))))))))))))))
      
      (define (present-vec4 vec)
        (format "{r precision: 3} {r precision: 3} {r precision: 3} {r precision: 3}"
                (f32vector-ref vec 0)
                (f32vector-ref vec 1)
                (f32vector-ref vec 2)
                (f32vector-ref vec 3)))
      
      (let ((info (and debug-transform? (vertex-info))))
        (if (not info)
            (unregister-info 'vertex)
          (register-info 'vertex
            (lambda (add-section add-info)
              (let ((section (add-section "Vertex")))
                (for-each (lambda (info)
                            (add-info section (car info) (cdr info)))
                          info)))))))
    
    @wait
    (update-feet)
    (unless only-feet?
      (update-info)
      (update-vertex)))
  
  
  (proclaim (warn optimizations))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method package (get-directory self)
    (get-parent (get-moniker self)))
  
  
  (method package (get-moniker self)
    (get-origin form))
  
  
  (method package (get-modified? self)
    (get-modified? designer))
  
  
  (method package (set-modified? self flag)
    (when #t @buggy (neq? flag (get-modified? designer))
      (set-modified? designer flag)
      (title-update self)))
  
  
  (method package (save-property self property value)
    (set-property designer self property value)
    (save-designer self))
  
  
  (method (read-element self element property)
    (read-property element property))
  
  
  (method package (write-element self element property value)
    (with-designer self element
      (lambda (designer container)
        (set-property designer element property value))))
  
  
  (method package (with-designer self element proc)
    (define (toplevel elem)
      (let ((parent (get-parent elem)))
        (if (or (not parent) (eq? parent self) (is? parent Section-Container))
            elem
          (toplevel parent))))
    
    (let ((top (toplevel element)))
      (let ((section (element-section self top)))
        (assert section)
        (with-designer section
          proc))))
  
  
  (method package (create-block-entity self model position)
    (new Block-Entity model: model position: position))
  
  
  ;; quicky for sejour to think through
  (method package (designable? self obj)
    (and (is? obj Entity)
         ;; if it was removed but still got accessed somehow
         (get-parent obj)))


  (method package (need-script self obj (create?: create? #t))
    (or (get-script obj)
        (and create?
             ;; sejour quicky
             (or (is? obj Block-Entity)
                 (designable? (current-zone) obj))
             (let ((script (new Script parent: obj)))
               (if (is? obj Block-Entity)
                   (let ((pos (get-position obj))
                         (model (get-model obj)))
                     (let ((section (position-section self pos)))
                       (with-designer section
                         (lambda (designer container)
                           (add-child designer obj container properties: (list 'position pos 'model model proxy?: #t))
                           (add-child designer script obj)
                           (add-element self obj)
                           (setup-actions obj)
                           script))))
                 (with-designer self obj
                   (lambda (designer container)
                     (add-child designer script obj)))
                 script)))))
  
  
  ;;;
  ;;;; Prologue
  ;;;
  
  
  (method (check-prologue self (size: size #f))
    (when (and (client?) (get-first-time? game) (world-setting 'world.show-prologue? #t) (window?))
      (show-prologue self size: size)
      (save-designer self)))
  
  
  (method (show-prologue self (size: size #f))
    (let ((file (prologue-file self)))
      (when (exists? file)
        (open-world-document file class: World-Formatted-Text-View size: (or size {Dimension 800 600})))))
  
  
  (method (prologue-file self)
    (zone-brother self "Prologue.ftx"))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method package (draw-zone self)
    (let ((world (current-world)))
      (draw-sectors)
      (when (not-null? draw-procedures)
        (for-each (lambda (proc)
                    (proc))
                  draw-procedures))
      (when (get-draw-marks? world)
        (draw-marks self))
      (when (and sun (get-visible? sun))
        (register-sun self))
      (gl-check-error)))
  
  
  (method (registered-draw self name)
    (table-ref draw-procedure-names name #f))
  
  
  (method package (register-draw self name proc)
    (when (registered-draw self name)
      (unregister-draw self name))
    (set! draw-procedures (cons proc draw-procedures))
    (table-set! draw-procedure-names name proc))
  
  
  (method (unregister-draw self name)
    (let ((proc (table-ref draw-procedure-names name)))
      (set! draw-procedures (remove! proc draw-procedures))
      (table-clear draw-procedure-names name)))
  
  
  ;;;
  ;;;; Blocks
  ;;;
  
  
  (method protected virtual (album-name self)
    'block)
  
  
  (method protected virtual (create-album self)
    (let ((name (or atlas-name (album-name self))))
      (or (registered-album name)
          (let ((atlas (create-atlas self)))
            (let ((textures (create-textures self atlas)))
              (when (complete-album? self)
                (complete atlas))
              (update-textures-subuvs atlas)
              (let ((album (new Album atlas textures)))
                (register-album name album)
                album))))))
  
  
  (method protected virtual (complete-album? self)
    #t)
  
  
  (method protected virtual (create-atlas self)
    (create-block-atlas))
  
  
  (method protected virtual (create-textures self atlas)
    (list->table
      (list
        ;; clamp to edge is necessary for joins like between the rails
        (cons 'clamp (create-texture atlas wrap: GL_CLAMP_TO_EDGE))
        (cons 'repeat (create-texture atlas min-filter: 'nearest)))))
  
  
  (method (prepare-blocks self)
    (let ((world (current-world)))
      (prepare-pack self)
      (let ((album (create-album self)))
        (let ((atlas (get-atlas album)))
          (let ((texture (get-texture album 'clamp))
                (texture-repeat (get-texture album 'repeat)))
            (prepare-block world atlas texture texture-repeat)
            (let ((opaque-material (get-material (cast <Rendering> (opaque-rendering))))
                  (transparent-material (get-material (cast <Rendering> (transparent-rendering))))
                  (coverage-material (get-material (cast <Rendering> (coverage-rendering))))
                  (water-material (get-material (cast <Rendering> (water-rendering))))
                  (wet-material (get-material (cast <Rendering> (wet-rendering))))
                  (multitexture-material (get-material (cast <Rendering> (multitexture-rendering)))))
              (prepare-materials world opaque-material transparent-material coverage-material water-material wet-material multitexture-material))
            (prepare-lightmaps world))))))
  
  
  (method protected virtual (prepare-pack self)
    (prepare-pack/tile self
                       (world-setting 'world.tile-resolution #f)
                       (world-setting 'world.tile-pack #f)))
  
  
  (method protected (require-pack self dirname)
    (let ((world (current-world)))
      (continuation-capture
        (lambda (return)
          (iterate-assets world
            (lambda (assets)
              (when (contains-directory? assets dirname)
                (let ((dir (make-directory assets dirname)))
                  (when (not (exists? dir))
                    (retrieve-directory assets dirname progress: "Downloading texture pack")))
                (continuation-return return assets))))
          (error "Unable to find asset: {a}" dirname)))))
  
  
  (method (prepare-pack/tile self resolution tile-pack)
    ;; pack
    (let ((resolution (or resolution 128)))
      (let ((name (format "{a}x{a}" resolution resolution)))
        (let ((assets (require-pack self (string-append "block/" name)))
              (path (list "block" name)))
          (setup-pack resolution assets path))))
    ;; tile
    (when tile-pack
      (if (not resolution)
          (error "Need to specify resolution for tile pack")
        (let ((assets (require-pack self (string-append "block/" tile-pack)))
              (path (list "block" tile-pack)))
          (setup-tile assets path)))))
  
  
  (method package virtual (sample-program-image self program)
    (case program
      ((opaque) "stone")
      ((transparent) "flower_rose")
      (else "wool_colored_light_blue")))
  
  
  ;;;
  ;;;; Skybox
  ;;;
  
  
  (method protected virtual (prepare-skybox self)
    (set! skybox (and start-skybox (let ((skybox (find-skybox start-skybox)))
                                     (when skybox
                                       (prepare skybox))
                                     skybox)))
    (when skybox
      (set-fog-color (get-fog skybox))))
  
  
  (method package (install-skybox self sky)
    (prepare sky)
    (set! skybox sky)
    (set-fog-color (get-fog skybox)))
  
  
  (method package (remove-skybox self)
    (set! skybox #f))
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method package (add-element self obj)
    (define (add-player)
      (set! players (cons obj players))
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-actor)
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-gravity)
      (set! gravities (cons obj gravities))
      (set! gadgets (cons obj gadgets)))
    
    (define (add-gravity-well)
      (set! gravities (cons obj gravities)))
    
    (define (add-gadget)
      (set! gadgets (cons obj gadgets)))
    
    (define (add-entity)
      (set! entities (cons obj entities)))
    
    (if (and (client?) (simulated? obj))
        (begin
          (when (is? obj Player)
            (set! players (cons obj players)))
          (let ((index (element-section-index self obj)))
            (link-entity self obj index @coverage (transformed-coverage self obj)))
          (unless (void? self)
            (start-simulation self obj)))
      (typecase obj
        ((Player) (add-player))
        ((Actor) (add-actor))
        ((Gravity) (add-gravity))
        ((Gravity-Well) (add-gravity-well))
        ((Gadget) (add-gadget))
        ((Entity) (add-entity)))
      (when (is? obj Entity)
        (let ((index (element-section-index self obj)))
          (link-entity self obj index @coverage (transformed-coverage self obj))))
      (unless (void? self)
        (when (and (client?) (is? obj Creature))
          (start-simulation self obj)))
      (when (is? obj Creature)
        (add-spawned obj))
      (when (is? obj Entity)
        (run-script self obj)))
    obj)
  
  
  (method package (remove-element self obj (close?: close? #t))
    (define (remove-player)
      (set! players (remove! obj players))
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-actor)
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-gravity)
      (set! gravities (remove! obj gravities))
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-gravity-well)
      (set! gravities (remove! obj gravities)))
    
    (define (remove-gadget)
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-entity)
      (set! entities (remove! obj entities)))
    
    (if (and (client?) (simulated? obj))
        (begin
          (unless (void? self)
            (halt-simulation self obj))
          (when (is? obj Player)
            (set! players (remove! obj players)))
          (unlink-entity self obj (get-expanse-index obj) @coverage (get-coverage obj)))
      (unless (client?)
        (when (is? obj Entity)
          (halt-entity obj)))
      (unless (void? self)
        (when (and (client?) (is? obj Creature))
          (halt-simulation self obj)))
      (when (is? obj Creature)
        (remove-spawned obj))
      (typecase obj
        ((Player) (remove-player))
        ((Actor) (remove-actor))
        ((Gravity) (remove-gravity))
        ((Gravity-Well) (remove-gravity-well))
        ((Gadget) (remove-gadget))
        ((Entity) (remove-entity)))
      (when (is? obj Entity)
        (unlink-entity self obj (get-expanse-index obj) @coverage (get-coverage obj))))
    (when close?
      (close obj)))
  
  
  #; ;; coverage
  (method (link-entity self entity coverage)
    (loop (for i from (coverage-left coverage) to (coverage-right coverage))
          (loop (for j from (coverage-bottom coverage) to (coverage-top coverage))
                (loop (for k from (coverage-back coverage) to (coverage-front coverage))
                      (let ((expanse (index-expanse self (indexed i j k))))
                        (add-entity expanse entity)))))
    (set-coverage entity coverage))
  
  
  (method (link-entity self entity index)
    (let ((expanse (index-expanse self index)))
      (add-entity expanse entity)
      (when (player? entity)
        (set-expanse entity expanse)))
    (set-expanse-index entity index))
  
  
  #; ;; coverage
  (method (unlink-entity self entity coverage)
    ;; scriptoo
    (when coverage
    (loop (for i from (coverage-left coverage) to (coverage-right coverage))
          (loop (for j from (coverage-bottom coverage) to (coverage-top coverage))
                (loop (for k from (coverage-back coverage) to (coverage-front coverage))
                      (let ((expanse (index-expanse self (indexed i j k))))
                        (remove-entity expanse entity)))))
    (set-coverage entity #f)))
  
  
  (method (unlink-entity self entity index)
    ;; scriptoo
    (when index
      (let ((expanse (index-expanse self index)))
        (remove-entity expanse entity)
        (when (player? entity)
          (set-expanse entity #f)))
      (set-expanse-index entity #f)))
  
  
  #; ;; coverage
  (method package (transformed-coverage self entity)
    (let ((bounds (transformed-bounds entity)))
      (coverage (fxfloor (/ (cuboid-left bounds) 16.))
                (fxfloor (/ (cuboid-bottom bounds) 16.))
                (fxfloor (/ (cuboid-back bounds) 16.))
                (fxfloor (/ (cuboid-right bounds) 16.))
                (fxfloor (/ (cuboid-top bounds) 16.))
                (fxfloor (/ (cuboid-front bounds) 16.)))))
  
  
  #; ;; coverage
  (method package (update-entity self entity)
    ;; for setup-children backward compatibility
    (when level-dir
      (let ((old (get-coverage entity))
            (new (transformed-coverage self entity)))
        (when (and old (not (coverage=? old new)))
          ;; if we ever have big entities moving
          ;; it will become essential to not unlink
          ;; and link sectors that remain linked for
          ;; example bounds going from 0 10 to 1 11
          ;; we would only unlink 0 and link 11
          (unlink-entity self entity old)
          (link-entity self entity new)))))
  
  
  (method package (update-entity self entity)
    ;; for setup-children backward compatibility
    (when level-dir
      (let ((old (get-expanse-index entity))
            (new (element-section-index self entity)))
        (when (and old (not (index=? old new)))
          (unlink-entity self entity old)
          (link-entity self entity new)))))
  
  
  (method (find-element self predicate)
    (continuation-capture
      (lambda (return)
        (iterate-elements self
          (lambda (element)
            (when (predicate element)
              (continuation-return return element))))
        #f)))
  
  
  (method (find-named-element self name)
    (find-element self
      (lambda (element)
        (eq? (get-name element) name))))
  
  
  (method (find-gadget self predicate)
    (find-if predicate gadgets))
  
  
  (method (collect-observers self)
    (collect-if (lambda (player)
                  (eq? (get-mode player) 'observer))
                players))
  
  
  (method (collect-players self)
    (collect-if (lambda (player)
                  (eq? (get-mode player) 'player))
                players))
  
  
  (method (iterate-players self proc)
    (for-each proc players))
  
  
  (method (iterate-actors self proc)
    (for-each proc actors))
  
  
  (method package (iterate-entities self proc)
    (for-each proc entities))
  
  
  (method (iterate-gadgets self proc)
    (for-each proc gadgets))
  
  
  (method (iterate-elements self proc)
    (for-each proc entities))
  
  
  (method (draw-me self)
    (let ((me (current-me)))
      (draw me)))
  
  
  (method package (element-at self vert)
    (continuation-capture
      (lambda (return)
        (let ((index (position-area-index self vert)))
          (let ((area (indexed-area self (index-x index) (index-y index) (index-z index))))
            (iterate-area-elements self area
              (lambda (obj)
                (when (and (get-visible? obj)
                           (vertex=? (get-position obj) vert))
                  (continuation-return return obj))))))
        #f)))
  
  
  (method package (element-near self vert)
    (let ((x (vertex-x vert))
          (y (vertex-y vert))
          (z (vertex-z vert))
          ;; open test quicky to improve
          (radius .7))
      (let ((left (- x radius))
            (bottom (- y radius))
            (back (- z radius))
            (right (+ x radius))
            (top (+ y radius))
            (front (+ z radius)))
        (continuation-capture
          (lambda (return)
            (with-area-retainer 'element-near
              (lambda (retain)
                (iterate-position-neighbor-areas self vert 1 #f
                  (lambda (area index retain?)
                    (when retain?
                      (retain area))
                    (iterate-area-elements self area
                      (lambda (obj)
                        (when (and (get-visible? obj)
                                   (let ((x (get-x obj))
                                         (y (get-y obj))
                                         (z (get-z obj)))
                                     (and (>= x left)
                                          (>= y bottom)
                                          (>= z back)
                                          (<  x right)
                                          (<  y top)
                                          (<  z front))))
                          (continuation-return return obj))))))))
            #f)))))
  
  
  (method (validate-elements self)
    (iterate-elements self
      (lambda (element)
        (assert (real? (get-x element)))
        (assert (real? (get-y element)))
        (assert (real? (get-z element)))
        (assert (real? (get-red element)))
        (assert (real? (get-green element)))
        (assert (real? (get-blue element)))
        (assert (real? (get-alpha element))))))
  
  
  ;;;
  ;;;; Creature
  ;;;
  
  
  (method package (get-creatures self)
    (collect-type Creature actors))
  
  
  (method package (change-creature-models? self value)
    (set-creature-models? value)
    (for-each (lambda (creature)
                (update-model creature anchor?: #t))
              spawned-creatures))
  
  
  ;;;
  ;;;; Simulation
  ;;;
  
  
  (method (start-simulation self actor)
    (unless (table-ref simulations actor #f)
      (let ((procedure
              (lambda (task)
                (run-simulation actor task))))
        (let ((name (task-name actor))
              (priority (if (player? actor) simulate-player-priority simulate-actor-priority)))
          (let ((task (new Task (list 'simulate name) procedure priority: priority)))
            (start-task task)
            (set-task actor task)
            (table-set! simulations actor task))))))
  
  
  (method (halt-simulation self actor)
    (when (table-ref simulations actor #f)
      (let ((task (get-task actor)))
        (table-clear simulations actor)
        (halt-task task))))

  
  ;;;
  ;;;; Dimension
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-dimension self)
    (let ((dir (new-directory level-dir (case level-dimension
                                          ((over) "region")
                                          ((nether) '("DIM-1" "region"))
                                          ((end) '("DIM1" "region"))))))
      (set! dimension (new World-Dimension dir generator truncate-y self))))
  
  
  (method (free-dimension self)
    (free-regions dimension))
  
  
  (method public (cycle-level-dimension self)
    (with-generate-mutex
      (lambda ()
        (set! level-dimension (case level-dimension
                                ((over) 'nether)
                                ((nether) 'end)
                                ((end) 'over)))
        (setup-dimension self)
        (setup-areas self))))

  
  ;;;
  ;;;; Regions
  ;;;
  
  
  (method public (load-region self index <index>) <World-Region>
    (load-region dimension index))

  
  ;;;
  ;;;; Explore
  ;;;


  (method package (explore-regions self proc)
    (iterate-regions-dir dimension
      (lambda (file index)
        (let ((region (load-region dimension index)))
          (loop (for section-x from 0 below 32)
                (loop (for section-z from 0 below 32)
                      (loop (for section-y from 0 below 16)
                            (let ((section (load-section region section-x section-y section-z)))
                              (when section
                                (proc section))))))))))
  
  
  (method package (explore-chests self)
    (let ((items '()))
      (for-each (lambda (info)
                  (bind (section . coordinates) info
                    (bind-index (i j k) coordinates
                      (call-with-section self section i j k
                        (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                          (let ((data (block-entity-data section (indexed i j k))))
                            (let ((inventory (list-payload-content (tag-assoc "Items" data))))
                              (for-each (lambda (item)
                                          (let ((id (tag-assoc "id" item)))
                                            (let ((name (or (let ((item (id->item id)))
                                                              (and item (get-name item)))
                                                            id)))
                                              (unless (memv? name items)
                                                (set! items (cons name items))))))
                                        inventory))))))))
                (find-visual-blocks self '(54)))
      (sort nu<? items key: ->string)))
  
  
  (method package (count-regions self)
    (let ((count 0))
      (iterate-regions dimension
        (lambda (region)
          (increase! count)))
      count))
  
  
  ;;;
  ;;;; Chunks
  ;;;
  
  
  (method (position-chunk self pos <vertex>) <World-Chunk>
    (index-chunk self (position->section-index pos)))
  
  
  (method (element-chunk self element) <World-Chunk+>
    (let ((index (element-section-index self element)))
      (index-chunk self index)))
  
  
  (method (index-chunk self index <index>) <World-Chunk>
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (let ((region-index (section->region-index section-x section-y section-z)))
        (let ((region (load-region dimension region-index)))
          (load-section-chunk region (planar-index section-x section-z))))))
  
  
  (method (index-chunk-if self index (create?: create? #f)) <World-Chunk+>
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (let ((region-index (section->region-index section-x section-y section-z)))
        (let ((region (if create?
                          (load-region dimension region-index)
                        (load-region-if dimension region-index))))
          (and region
               (load-section-chunk region (planar-index section-x section-z)))))))
    
  
  (method package (store-chunk self region-index chunk-index chunk-raw)
    (let ((region (load-region dimension region-index)))
      (store-chunk region chunk-index chunk-raw)))

  
  (method package (find-chunk self section-x section-y section-z) <World-Chunk+>
    (let ((region-index (section->region-index section-x section-y section-z)))
      (let ((region (find-region dimension region-index)))
        (and region
             (find-chunk region (planar-index section-x section-z))))))
  
  
  (method package (find-chunk-by-locator self chunk-locator <index>) <World-Chunk+>
    (let ((section-x (index-x chunk-locator))
          (section-y (* (index-y chunk-locator) region-size))
          (section-z (index-z chunk-locator)))
      (find-chunk self section-x section-y section-z)))
  
  
  (method package (count-chunks self)
    (let ((count 0))
      (iterate-regions dimension
        (lambda (region)
          (increase! count (count-chunks region))))
      count))
  
  
  ;;;
  ;;;; Requests
  ;;;
  
  
  (proclaim (not check types))
  
  
  (method package (request-chunk self chunk-locator <index>)
    (mutex-lock! chunk-requests-mutex)
    (prog1 (cond (chunk-requests-shutdown?
                  #f)
                 ((table-ref chunk-requests chunk-locator #f)
                  #f)
                 ((find-chunk-by-locator self chunk-locator)
                  #f)
                 (else
                  (let ((chunk-mutex (make-mutex 'chunk))
                        (chunk-locator (copy-index chunk-locator)))
                    (mutex-lock! chunk-mutex)
                    (table-set! chunk-requests chunk-locator chunk-mutex)
                    (request-chunk (current-tier) chunk-locator))
                  #t))
        (mutex-unlock! chunk-requests-mutex)))
  
  
  (method package (receive-chunk self chunk-locator chunk-raw)
    (mutex-lock! chunk-requests-mutex)
    (unless chunk-requests-shutdown?
      (let ((chunk-mutex (table-ref chunk-requests chunk-locator)))
        (let ((chunk-x (index-x chunk-locator))
              (chunk-y (index-y chunk-locator))
              (chunk-z (index-z chunk-locator)))
          (let ((region-index (section->region-index chunk-x chunk-y chunk-z))
                (chunk-index (section->chunk-index (planar-index chunk-x chunk-z))))
            (let ((chunk (store-chunk self region-index chunk-index chunk-raw)))
              (mutex-specific-set! chunk-mutex chunk))))
        (table-clear chunk-requests chunk-locator)
        (mutex-unlock! chunk-mutex)))
    (mutex-unlock! chunk-requests-mutex))
  
  
  (method package (retrieve-chunk self chunk-locator)
    (mutex-lock! chunk-requests-mutex)
    (if chunk-requests-shutdown?
        (prog1 (store-empty-chunk self chunk-locator)
          (mutex-unlock! chunk-requests-mutex))
      (let ((chunk-mutex (table-ref chunk-requests chunk-locator #f)))
        (if chunk-mutex
            (begin
              (mutex-unlock! chunk-requests-mutex)
              (mutex-lock! chunk-mutex)
              (mutex-unlock! chunk-mutex)
              (mutex-specific chunk-mutex))
          (let ((chunk-mutex (make-mutex 'chunk)))
            (when debug-retrieves?
              (let ((name (thread-name (current-thread))))
                (terminal 'retrieve name chunk-locator)))
            (mutex-lock! chunk-mutex)
            (table-set! chunk-requests chunk-locator chunk-mutex)
            (request-chunk (current-tier) chunk-locator)
            (mutex-unlock! chunk-requests-mutex)
            (mutex-lock! chunk-mutex)
            (mutex-unlock! chunk-mutex)
            (mutex-specific chunk-mutex))))))
  
  
  (method package (shutdown-chunk-requests self)
    (mutex-lock! chunk-requests-mutex)
    (set! chunk-requests-shutdown? #t)
    (iterate-table chunk-requests
      (lambda (chunk-locator chunk-mutex)
        (let ((chunk (store-empty-chunk self chunk-locator)))
          (mutex-specific-set! chunk-mutex chunk))
        (table-clear chunk-requests chunk-locator)
        (mutex-unlock! chunk-mutex)))
    (mutex-unlock! chunk-requests-mutex))
  
  
  ;; store an empty chunk as a simple way to
  ;; unblock any task waiting on a retrieve chunk
  (method (store-empty-chunk self chunk-locator)
    (let ((chunk-x (index-x chunk-locator))
          (chunk-y (index-y chunk-locator))
          (chunk-z (index-z chunk-locator)))
      (let ((region-index (section->region-index chunk-x chunk-y chunk-z))
            (chunk-index (section->chunk-index (planar-index chunk-x chunk-z))))
        (store-chunk self region-index chunk-index #f))))
  
  
  (proclaim (check types))
  
  
  ;;;
  ;;;; Sections
  ;;;
  
  
  (method package (element-section-index self element <Element>) <index>
    (position->section-index (get-position element)))
  
  
  (method package (position-section self pos (create?: create? #f)) <World-Section+>
    (let ((index (position->section-index pos)))
      (index-section self index create?: create?)))
  
  
  (method package (element-section self element) <World-Section+>
    (let ((index (element-section-index self element)))
      (index-section self index)))
  
  
  (method package (index-section self index (create?: create? #f)) <World-Section+>
    (let ((section-y (index-y index)))
      (let ((chunk (index-chunk-if self index create?: create?)))
        (and chunk
             (load-section chunk section-y create?: create?)))))
  
  
  (method package (find-section self section-x section-y section-z) <World-Section+>
    (let ((chunk (find-chunk self section-x section-y section-z)))
      (and chunk
           (find-section chunk section-y))))
  
  
  (method package (count-sections self)
    (let ((count 0))
      (iterate-regions dimension
        (lambda (region)
          (iterate-chunks region
            (lambda (chunk)
              (increase! count (count-sections chunk))))))
      count))
  
  
  (method package (toggle-debug-sections self)
    (set! debug-sections? (not debug-sections?)))
  
  
  (method package (draw-debug-sections self)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((world (current-world))
          (camera (current-camera)))
      (let ((view-distance (get-view-distance world)))
        (when eye-index
          (let ((eye-x (index-x eye-index))
                (eye-y (index-y eye-index))
                (eye-z (index-z eye-index))
                (distance (+ view-distance (if show-generated? 2 1))))
            (define (show-generated)
              (let ((j 0))
                (define (show state color)
                  (render-cubes
                    (lambda (render)
                      (loop (for i from (- eye-x distance) to (+ eye-x distance))
                            (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                  (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                         (+ (* (cast <fl> j) 16.) 5.)
                                                         (+ (* (cast <fl> k) 16.) 8.))))
                                    (when (in-frustum? camera center)
                                      (let ((chunk (find-chunk self i j k)))
                                        (when (and chunk (= (get-state chunk) state))
                                          (render center))))))))
                    wire-color: color
                    cull?: #t))
                
                (show Shaped red-dye)
                (show Populated blue-dye)
                (show Generated green-dye)))
            
            (define (show-loaded)
              (let ((j 0))
                (define (show section? color)
                  (render-cubes
                    (lambda (render)
                      (loop (for i from (- eye-x distance) to (+ eye-x distance))
                            (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                  (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                         (+ (* (cast <fl> j) 16.) 5.)
                                                         (+ (* (cast <fl> k) 16.) 8.))))
                                    (when (in-frustum? camera center)
                                      (when (xor section? (not (find-section self i j k)))
                                        (render center)))))))
                    wire-color: color
                    cull?: #t))
                
                (show #t green-dye)
                (show #f red-dye)))
            
            (define (show-not-instanced)
              (render-cubes
                (lambda (render)
                  (loop (for i from (- eye-x distance) to (+ eye-x distance))
                        (loop (for j from (- eye-y distance) to (+ eye-y distance))
                              (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                    (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                           (+ (* (cast <fl> j) 16.) 8.)
                                                           (+ (* (cast <fl> k) 16.) 8.))))
                                      (when (in-frustum? camera center)
                                        (render center)))))))
                wire-color: red-dye
                cull?: #t))
            
            (define (show-instanced)
              (render-cubes-instanced
                (lambda (mesh render)
                  (let ((distance (get-view-distance world))
                        (camera-pos (get-position (current-camera))))
                    (let ((max (expt (+ distance 1 distance) 3)))
                      (let ((buffer (get-instance-buffer mesh))
                            (data (make-f32vector (* max 3)))
                            (offset 0)
                            (count 0))
                        (loop (for i from (- eye-x distance) to (+ eye-x distance))
                              (loop (for j from (- eye-y distance) to (+ eye-y distance))
                                    (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                          (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                                 (+ (* (cast <fl> j) 16.) 8.)
                                                                 (+ (* (cast <fl> k) 16.) 8.))))
                                            (when (in-frustum? camera center)
                                              (f32vector-set! data offset (+ (vertex-x center) (vertex-x camera-pos)))
                                              (f32vector-set! data (+ offset 1) (+ (vertex-y center) (vertex-y camera-pos)))
                                              (f32vector-set! data (+ offset 2) (+ (vertex-z center) (vertex-z camera-pos)))
                                              (increase! offset 3)
                                              (increase! count))))))
                        (upload-stream-data buffer 0 data (* count 3))
                        (render (vertex 0. 0. 0.) count)))))
                wire-color: red-dye
                cull?: #t))
            
            (cond (show-generated?
                   (show-generated))
                  (show-loaded?
                   (show-loaded))
                  (show-sections?
                   (if instanced-rendering?
                       (show-instanced)
                     (show-not-instanced)))))))))
  
  
  ;;;
  ;;;; Sectors
  ;;;
  
  
  (method (setup-sectors self)
    (let ((world (current-world)))
      (set! sector-radius (let ((half (/ sector-size 2.)))
                            (vertex-norm (vertex half half half))))
      (set! sector-diameter (* sector-radius 2))
      (set! sectors-mutex (make-mutex 'sectors))
      (let ((distance (get-view-distance world)))
        (let ((diameter (+ distance 1 distance)))
          (set! eye-radius distance)
          (set! eye-diameter diameter)
          (set! eye-diameter^2 (expt diameter 2))
          (set! eye-diameter^3 (expt diameter 3))
          (set! eye-sectors (make-eye-sectors self))
          (set! eye-neighbors (make-eye-neighbors self))
          (set! eye-frustum (make-eye-frustum self))))
      (set! sector/subarea-ratio (fxround/ sector-size subarea-size))))
  
  
  (method package (update-view-distance self old-distance distance)
    (unless (= distance old-distance)
      (let ((diameter (+ distance 1 distance)))
        (let ((radius distance)
              (diameter^2 (expt diameter 2))
              (diameter^3 (expt diameter 3))
              (a (index-x eye-index))
              (b (index-y eye-index))
              (c (index-z eye-index)))
          (define (sector-new i j k)
            (new-sector self (indexed i j k)))
          
          (define (sector-free sector)
            (push-free sector))
          
          (define (index i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j radius) diameter^2)
               (* (+ k radius) diameter)
               (+ i radius)))
          
          (define (index-eye i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j eye-radius) eye-diameter^2)
               (* (+ k eye-radius) eye-diameter)
               (+ i eye-radius)))
          
          (let ((sectors (make-vector diameter^3 #f)))
            (cond ;; smaller
                  ((< distance old-distance)
                   (loop (for i from (- old-distance) to old-distance)
                         (loop (for j from (- old-distance) to old-distance)
                               (loop (for k from (- old-distance) to old-distance)
                                     (let ((old-sector (vector-ref eye-sectors (index-eye i j k))))
                                       (if (and (between? i (- distance) distance)
                                                (between? j (- distance) distance)
                                                (between? k (- distance) distance))
                                           (vector-set! sectors (index i j k) old-sector)
                                         (sector-free old-sector)))))))
                  ;; greater
                  (else
                   (loop (for i from (- distance) to distance)
                         (loop (for j from (- distance) to distance)
                               (loop (for k from (- distance) to distance)
                                     (if (and (between? i (- old-distance) old-distance)
                                              (between? j (- old-distance) old-distance)
                                              (between? k (- old-distance) old-distance))
                                         (vector-set! sectors (index i j k) (vector-ref eye-sectors (index-eye i j k)))
                                       (vector-set! sectors (index i j k) (sector-new (+ a i) (+ b j) (+ c k)))))))))
            (set! eye-radius radius)
            (set! eye-diameter diameter)
            (set! eye-diameter^2 diameter^2)
            (set! eye-diameter^3 diameter^3)
            (set! eye-sectors sectors)
            (set! eye-neighbors (make-vector diameter^3 #f))
            (set! eye-frustum (make-eye-frustum self))
            (set! eye-frustum-count 0)
            (set! eye-frustum-uptodate? #f)
            (update-eye-neighbors self distance))))))
  
  
  (method (new-sector self index <index>) <Sector>
    (define (center i <fx>)
      (* (+ (cast <fl> i) .5) sector-size))
    
    (let ((x (index-x index))
          (y (index-y index))
          (z (index-z index)))
      (new Sector index (vertex (center x) (center y) (center z)) (index-expanse self index))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (iterate-sectors self proc)
    (when eye-neighbors
      (loop (for sector in-vector eye-neighbors)
            (when sector
              (proc sector)))))
  
  
  (proclaim (warn optimizations))
  
  
  (method package (iterate-section-neighbors self section-index <index> distance <fx> proc)
    (let ((a (index-x section-index))
          (b (index-y section-index))
          (c (index-z section-index)))
      (loop (for i from (- distance) to distance)
            (loop (for j from (- distance) to distance)
                  ;; $$$ try
                  (do (when (between? j 0 15)
                        (loop (for k from (- distance) to distance)
                              (let ((section (index-section self (indexed (+ a i) (+ b j) (+ c k)))))
                                (when section
                                  (proc section))))))))))
  
  
  (method package (get-eye-index self)
    eye-index)
  
  (method package (get-eye-sectors self) <vector>
    eye-sectors)
  
  (method package (get-eye-neighbors self) <vector>
    eye-neighbors)
    
  
  (method (sectors-index self i <fx> j <fx> k <fx>) <fx>
    (+ (* j eye-diameter^2) (* k eye-diameter) i))

  
  (method (make-eye-sectors self)
    (make-vector eye-diameter^3 #f))
  
  
  (method (make-eye-neighbors self)
    (make-vector eye-diameter^3 #f))
  
  
  (method (make-eye-frustum self)
    (make-vector eye-diameter^3 #f))
  
  
  (method package (element-sector self element) <Sector+>
    (find-sector self (element-section-index self element)))
  
  
  (method package (find-sector self index) <Sector+>
    (and eye-index
         (let ((a (- (index-x eye-index) eye-radius))
               (b (- (index-y eye-index) eye-radius))
               (c (- (index-z eye-index) eye-radius)))
           (let ((i (- (index-x index) a))
                 (j (- (index-y index) b))
                 (k (- (index-z index) c))
                 (last (- eye-diameter 1)))
             (and (between? i 0 last)
                  (between? j 0 last)
                  (between? k 0 last)
                  (vector-ref eye-sectors (sectors-index self i j k)))))))
  
  
  (method (eye-sector self)
    (vector-ref eye-sectors (sectors-index self eye-radius eye-radius eye-radius)))
  
  
  (method (free-eye-sectors self)
    (set! eye-index #f)
    (loop (for n from 0 below eye-diameter^3)
          (let ((sector (vector-ref eye-sectors n)))
            (when sector
              (close sector)))
          (vector-set! eye-sectors n #f)
          (vector-set! eye-neighbors n #f)))
  
  
  (method package (initial-preload self index)
    @wait-until-done-right
    (when (client?)
      ;; to maximize the time that received chunks
      ;; will be alive before being garbage collected
      (gc)
      (let ((x (index-x index))
            (y (index-y index))
            (z (index-z index)))
        (loop (for i from (- eye-preload) to eye-preload)
              (loop (for j from (- eye-preload) below eye-preload)
                    (loop (for k from (- eye-preload) below eye-preload)
                          (let ((chunk-locator (static (make-index))))
                            (section->chunk-locator! chunk-locator (+ x i) (+ y j) (+ z k))
                            (request-chunk self chunk-locator))))))))
  
  
  (method package (eye-frustum-sectors self motion camera view-distance)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (proclaim (not check bounds types zero))
    (when (not eye-frustum-uptodate?)
      (let ((motion-index (motion-sector-index motion)))
        (let ((sectors (eye-neighbor-sectors self motion-index view-distance))
              (count 0))
          (loop (for i from 0 below (vector-length sectors))
                (let ((sector <Sector> (vector-ref sectors i)))
                  (let ((center (get-center sector)))
                    (when (in-frustum? camera center)
                      (update-visual sector self camera)
                      (vector-set! eye-frustum count sector)
                      (increase! count)))))
          (loop (for i from count below eye-frustum-count)
                (vector-set! eye-frustum i #f))
          (set! eye-frustum-count count)
          (set! eye-frustum-uptodate? #t))))
    (values eye-frustum eye-frustum-count))
  
  
  (method package (eye-neighbor-sectors self index <index> distance <fx>) <vector>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (proclaim (not check bounds types zero))
    (define (sector-new i j k)
      (new-sector self (indexed i j k)))
    
    (define (sector-free sector)
      (push-free sector))
    
    (if (and eye-index (index=? index eye-index))
        eye-neighbors
      (trim-preload)
      (trim-instantiate)
      ;; update sectors
      (let ((sectors (get-eye-sectors self))
            (a <fx> (- (index-x index) eye-radius))
            (b <fx> (- (index-y index) eye-radius))
            (c <fx> (- (index-z index) eye-radius))
            (pl (- eye-radius eye-preload))
            (pu (+ eye-radius eye-preload))
            (il (- eye-radius eye-instantiate))
            (iu (+ eye-radius eye-instantiate)))
        (if (not eye-index)
            (loop (for i from 0 below eye-diameter)
                  (loop (for j from 0 below eye-diameter)
                        (loop (for k from 0 below eye-diameter)
                              (vector-set! sectors (sectors-index self i j k)
                                (let ((sector (sector-new (+ a i)
                                                          (+ b j)
                                                          (+ c k)))
                                      (preload? (and (>= i pl) (<= i pu)
                                                     (>= j pl) (<= j pu)
                                                     (>= k pl) (<= k pu)))
                                      (instantiate? (and (>= i il) (<= i iu)
                                                         (>= j il) (<= j iu)
                                                         (>= k il) (<= k iu))))
                                  (when preload?
                                    (set-preload? sector #t)
                                    (update-preload sector))
                                  (when instantiate?
                                    (set-instantiate? sector #t)
                                    (update-instantiate sector))
                                  sector)))))
          (let ((last (- eye-diameter 1))
                (dx (- (index-x index) (index-x eye-index)))
                (dy (- (index-y index) (index-y eye-index)))
                (dz (- (index-z index) (index-z eye-index))))
            (define (by delta <fx>)
              (if (>= delta 0)
                  1
                -1))
            
            (loop (for x start 0 end last by (by dx))
                  (let ((fx (+ x dx))
                        (tx x))
                    (loop (for y start 0 end last by (by dy))
                          (let ((fy (+ y dy))
                                (ty y))
                            (loop (for z start 0 end last by (by dz))
                                  (let ((fz (+ z dz))
                                        (tz z))
                                    (let ((fi (and (between? fx 0 last)
                                                   (between? fy 0 last)
                                                   (between? fz 0 last)
                                                   (sectors-index self fx fy fz)))
                                          (ti (sectors-index self tx ty tz)))
                                      (let ((sector (vector-ref sectors ti)))
                                        (when sector
                                          ;; free
                                          (sector-free sector)))
                                      (if fi
                                          ;; move
                                          (let ((sector (vector-ref sectors fi))
                                                (preload? (and (>= tx pl) (<= tx pu)
                                                               (>= ty pl) (<= ty pu)
                                                               (>= tz pl) (<= tz pu)))
                                                (instantiate? (and (>= tx il) (<= tx iu)
                                                                   (>= ty il) (<= ty iu)
                                                                   (>= tz il) (<= tz iu))))
                                            (vector-set! sectors ti sector)
                                            (vector-set! sectors fi #f)
                                            (unless (eqv? (get-preload? sector) preload?)
                                              (set-preload? sector preload?)
                                              (if (not preload?)
                                                  (set-section sector #f)
                                                (update-preload sector)))
                                            (unless (eqv? (get-instantiate? sector) instantiate?)
                                              (set-instantiate? sector instantiate?)
                                              (if (not instantiate?)
                                                  (free-instantiate sector self)
                                                (update-instantiate sector))))
                                        ;; new
                                        (vector-set! sectors ti (sector-new (+ a tx) (+ b ty) (+ c tz))))))))))))))
      ;; update neighbors
      (update-eye-neighbors self distance)
      (set! eye-index (copy-index index))
      eye-neighbors))
  
  
  (method (update-eye-neighbors self distance <fx>)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (proclaim (not check bounds types zero))
    (let ((sectors eye-sectors)
          (neighbors eye-neighbors)
          (n 0))
      (define (set i j k)
        (vector-set! neighbors n (vector-ref sectors (sectors-index self (+ i distance) (+ j distance) (+ k distance))))
        (increase! n))
      
      ;; set neighbors in expanding distance from eye
      (set 0 0 0)
      (loop (for radius from 1 to distance)
            (let ((radius-1 (- radius 1)))
              ;; left
              (let ((i (- radius)))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; right
              (let ((i radius))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; bottom
              (let ((j (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; top
              (let ((j radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; back
              (let ((k (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))
              ;; front
              (let ((k radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (increase-sectors-generating self count <fx>)
    (mutex-lock! sectors-mutex)
    (set! sectors-generating (+ sectors-generating count))
    (mutex-unlock! sectors-mutex))
  
  
  (method package (decrease-sectors-generating self count <fx>)
    (mutex-lock! sectors-mutex)
    (set! sectors-generating (- sectors-generating count))
    (mutex-unlock! sectors-mutex))
  
  
  (method package (increase-sectors-generated self)
    (mutex-lock! sectors-mutex)
    (set! sectors-generated (+ sectors-generated 1))
    (mutex-unlock! sectors-mutex))
  
  
  (method (compute-floats self)
    (let ((total 0))
      (iterate-sectors self
        (lambda (sector)
          (let ((mesh (get-mesh sector)))
            (when mesh
              (let ((floats (count-floats mesh)))
                (when floats
                  (increase! total floats)))))))
      total))
  
  
  (method package (count-laden-sectors self)
    (let ((total 0))
      (iterate-sectors self
        (lambda (sector)
          (let ((mesh (get-mesh sector)))
            (when mesh
              (increase! total)))))
      total))
  
  
  (method package (toggle-debug-sectors self)
    (let ((world (current-world)))
      (set! debug-sectors? (not debug-sectors?))
      (update-parameter world 'debug-sectors)))
  
  
  (method package (draw-debug-sectors self)
    (draw-3d-grid (element-section-index self (current-me)) sector-size))
  
  
  ;;;
  ;;;; Areas
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-areas self)
    (set! areas (make-table test: equal? weak-values: #t)))
  
  
  (method (element-area-index self element <Element>) <index>
    (position-area-index self (get-position element)))
  
  
  (method package (position-area-index self pos <vertex>) <index>
    (let ((size (cast <fl> subarea-size)))
      (indexed (fxfloor (/ (vertex-x pos) size))
               (fxfloor (/ (vertex-y pos) size))
               (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method (element-area self element) <Area>
    (let ((index (element-area-index self element)))
      (indexed-area self
                    (index-x index)
                    (index-y index)
                    (index-z index))))
  
  
  (method package (indexed-area self x <fx> y <fx> z <fx>) <Area>
    (let ((index (make-index&)))
      (index-x-set! index (quotient/ (* x subarea-size) section-size))
      (index-y-set! index (quotient/ (* y subarea-size) section-size))
      (index-z-set! index (quotient/ (* z subarea-size) section-size))
      (let ((area
              (or (table-ref areas index #f)
                  (let ((index (copy-index index)))
                    (let ((area (new Area index (index-expanse self index))))
                      (table-set! areas index area)
                      area)))))
        (update-physical area)
        area)))
  
  
  (method (find-area self index) <Area+>
    (table-ref areas index #f))
  
  
  (method (unlink-area self index)
    (table-clear areas index))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (iterate-areas self proc)
    (iterate-table areas
      proc))
  
  
  ;; putting area-cube here is a quicky to test travel-ray-polygons&
  (method package (iterate-position-neighbor-areas self pos distance <fx> area-cube proc)
    (if (and area-cube (<= distance (get-cube-radius area-cube)))
        (iterate-neighbor-areas area-cube pos distance proc)
      (let ((index (position-area-index self pos)))
        (let ((a (index-x index))
              (b (index-y index))
              (c (index-z index)))
          (loop (for i from (- distance) to distance)
                (loop (for j from (- distance) to distance)
                      (loop (for k from (- distance) to distance)
                            (let ((a (+ a i))
                                  (b (+ b j))
                                  (c (+ c k)))
                              (let ((area (indexed-area self a b c)))
                                (proc area
                                      (subarea-index area a b c)
                                      #t))))))))))
  
  
  (method (iterate-area-elements self area proc)
    (for-each proc (get-entities (get-expanse area))))
  
  
  (method (count-polygons self)
    (let ((count 0))
      (iterate-table areas
        (lambda (index area)
          (let ((polygons (get-polygons area)))
            (when polygons
              (increase! count (fxround/ (f64vector-length polygons) polygon-float-size))))))
      count))
  
  
  (method package (toggle-debug-areas self)
    (let ((world (current-world)))
      (set! debug-areas? (not debug-areas?))
      (update-parameter world 'debug-areas)))
  
  
  (method package (draw-debug-areas self)
    (draw-3d-grid (element-area-index self (current-me)) subarea-size))
  
  
  ;;;
  ;;;; Expanses
  ;;;
  
  
  (method (setup-expanses self)
    (set! expanses (make-table test: equal? weak-values: #t)))
  
  
  (method (index-expanse self index <index>) <Expanse>
    (or (table-ref expanses index #f)
        (let ((index (copy-index index)))
          (let ((expanse (new Expanse)))
            (table-set! expanses index expanse)
            expanse))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method package (run-interface self task <Task>)
    (run-interface (current-world) task))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (method package (run-render self task <Task>)
    (run-render (current-world) task))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method package (find-player self name)
    (find-if (lambda (player)
               (equal? (get-name player) name))
             players))
  
  
  (method package (resurrect-player self player)
    (let ((new-position (find-spawnpoint self)))
      (set-position player new-position)
      (set-velocity player (vertex 0. 0. 0.))
      (set-fall-velocity player (vertex 0. 0. 0.))
      (verify-water player)))
  
  
  (method package virtual (run-player self task <Task>)
    (run-player (current-world) task))
  
  
  ;;;
  ;;;; Action
  ;;;
  
  
  (method package virtual (run-action self task <Task>)
    (run-action (current-world) task))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method package virtual (run-missile self task <Task>)
    (run-missile (current-world) task))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method package (run-tick self task <Task>)
    (run-tick (current-world) task))
  
  
  ;;;
  ;;;; Sun
  ;;;
  
  
  (method (run-sun self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (if (not sun?)
              (task-wait task +infinity 0. exit)
            (let (iter (previous (current-monotonic)))
              (let ((time (current-monotonic)))
                (let ((elapse (- time previous)))
                  (with-task-mutex
                    (lambda ()
                      (unless (get-paused? history)
                        (unless (stopping? task)
                          (tick-sun self elapse)))))
                  (let ((duration (- (current-monotonic) time)))
                    (task-wait task sun-period duration exit))
                  (iter time)))))))))
  
  
  (method (tick-sun self elapse)
    (site sun
      (position-sun self elapse)))
  
  
  (method package (position-sun self elapse (angle: angle #f))
    (define (calculate-angle)
      (flmodulo (+ sun-angle (* (sun-speed) elapse)) PI*2))
    
    (define (sun-speed)
      (if (not day-duration)
          0.
        (/ PI*2 day-duration)))
    
    (set! sun-angle (or angle (calculate-angle)))
    @sunwait
    (when (window?)
      (let ((under-limit 0.1)
            (direction (rotate-vertex-upon& PI/4 (vertex 0.0 1.0 0.0) (rotate-vertex-upon& sun-angle (vertex 0.0 0.0 -1.0) (vertex -1. 0. 0.)))))
        (let ((pos (vertex-scalar*& direction 1000.)))
          (when (not sun)
            (set! sun (new Sun parent: self position: pos))
            (add-element self sun))
          (cond ((or (< sun-angle (+ PI under-limit))
                     (> sun-angle (- PI*2 under-limit)))
                 (set-position-noupdate sun pos)
                 (set-visible? sun #t))
                (else
                 (set-visible? sun #f))))))
    (sun-update self))
  
  
  (method (sun-update self)
    (set-daytime self (sun-angle->daytime self sun-angle)))
  
  
  (method (register-sun self)
    (register-entity sun))
  
  
  ;;;
  ;;;; Daytime
  ;;;
  
  
  (method package (goto-daytime self daytime)
    (if sun?
        (position-sun self #f angle: (daytime->sun-angle self daytime))
      (set-daytime self daytime)))
  
  
  (method package (sun-angle->daytime self sun-angle)
    (let ((angle (flmodulo sun-angle PI*2)))
      (flmodulo (+ (/ (* angle day-span) PI*2) dawn-daytime) day-span)))
  
  
  (method package (daytime->sun-angle self daytime)
    (/ (* (- daytime dawn-daytime) PI*2) day-span))
  
  
  (method package (effective-daytime self daytime)
    (cond ((flonum? daytime) daytime)
          ((integer? daytime) (cast <fl> daytime))
          ((or (eq? daytime 'default) (ci=? daytime "default")) dawn-daytime)
          ((or (eq? daytime 'dawn) (ci=? daytime "dawn")) dawn-daytime)
          ((or (eq? daytime 'day) (ci=? daytime "day")) day-daytime)
          ((or (eq? daytime 'dusk) (ci=? daytime "dusk")) dusk-daytime)
          ((or (eq? daytime 'night) (ci=? daytime "night")) night-daytime)
          ((string? daytime) (cast <fl> (string->number daytime)))
          (else (error "Invalid daytime: {s}" daytime))))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  @gravitywait
  (method (run-gravity self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history))
          (universe (current-universe)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-monotonic)))
            (let ((time (current-monotonic)))
              (let ((elapse (- time previous)))
                (with-task-mutex
                  (lambda ()
                    (unless (get-paused? history)
                      (unless (stopping? task)
                        (let ((blocks (get-fall-blocks universe)))
                          (unless (queue-empty? blocks)
                            (set-fall-blocks universe (new-queue))
                            (tick-gravity self elapse blocks)))))))
                (task-wait task gravity-period (- (current-monotonic) time) exit)
                (iter time))))))))
  
  
  @gravitywait
  (method (tick-gravity self elapse blocks)
    (site gravity
      (blocks-fall self elapse blocks)))
  
  
  @gravitywait
  (method (blocks-fall self elapse blocks)
    (let ((universe (current-universe)))
      (updating-sections self
        (lambda (add-section)
          (let (iter)
            (unless (queue-empty? blocks)
              (bind (section . index) (dequeue blocks)
                (bind-index (i j k) index
                  (call-with-section self section i j k
                    (lambda (section block <fx> data <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                      (define (effective-block-ref i j k)
                        (with-field i j k
                          (lambda (section index)
                            (if section
                                (block-ref section index)
                              0))))
                      
                      (define (add-neighbors i j k)
                        (define (add-neighbor i j k)
                          (with-field i j k
                            (lambda (section index)
                              @w(when (id? (block-ref section index) SandBlock Gravel)
                                  (normalize-section/coordinates section i j k with-field
                                    (lambda (section i j k)
                                      (add-fall-block universe section i j k))))
                              ;; EH validate
                              (when section
                                (add-section section)))))
                        
                        (add-neighbor (+ i 1) j k)
                        (add-neighbor (- i 1) j k)
                        (add-neighbor i (+ j 1) k)
                        (add-neighbor i (- j 1) k)
                        (add-neighbor i j (+ k 1))
                        (add-neighbor i j (- k 1)))
                      
                      (when (and (id? block SandBlock Gravel) (id? (effective-block-ref i (- j 1) k) Air Water StationaryWater Lava StationaryLava))
                        (with-field i j k
                          (lambda (section index)
                            (block-set! section index 0)
                            (add-neighbors i j k)
                            (inverse-propagate-light universe i j k add-section with-field block-ref blocklight-ref blocklight-set!)
                            @redstonewait
                            (redstone-update section (list i j k block) add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!))))))))
              (iter))))
        delay-update?: #t)))
  
  
  ;;;
  ;;;; Eat
  ;;;
  
  
  @eatwait
  (method (run-eat self task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (with-task-mutex
              (lambda ()
                (unless (get-paused? history)
                  (unless (stopping? task)
                    (tick-eat self task exit)))))
            (task-wait task eat-period 0. exit)
            (iter))))))
  
  
  @eatwait
  (method (tick-eat self task exit)
    (site eat
      (let ((interface (current-interface+))
            (me (current-me)))
        (let ((eating (get-eating me)))
          (when eating
            (let ((eating-ticks (get-eating-ticks me)))
              (set-life me (min (+ (get-life me) eating) 100.))
              (when interface
                (invalidate-view (child interface 'combat)))
              (let ((eating-ticks (- (get-eating-ticks me) 1)))
                (if (> eating-ticks 0)
                    (set-eating-ticks me eating-ticks)
                  (set-eating me #f)
                  (set-eating-ticks me #f)))))))))
  
  
  ;;;
  ;;;; Day
  ;;;
  
  
  (method (set-daytime self time)
    (set! daytime time)
    (set! daylight (daytime->daylight self time)))
  
  
  (method (daytime->daylight self daytime)
    (cond ;; night
          ((< daytime 6000.)
           0.)
          ;; dawn
          ((< daytime 9000.)
           (/ (- daytime 6000.) 3000.))
          ;; day
          ((< daytime 18000.)
           1.)
          ;; dusk
          ((< daytime 21000.)
           (/ (- 21000. daytime) 3000.))
          ;; night
          (else
           0.)))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method public (iterate-gravities self proc)
    (for-each proc gravities))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method package (reset-marks self)
    (set! marks '()))
  
  
  (method (set-marks self lst)
    (set! marks lst))
  
  
  (method (set-mark self mark)
    (set! marks (list mark)))
  
  
  (method package (add-mark self mark)
    (set! marks (cons mark marks)))
  
  
  (method package (remove-mark self mark)
    (set! marks (remove! mark marks)))
  
  
  (method (draw-marks self)
    (for-each (lambda (mark)
                (when (is-not? mark world.mark:Polygon-Mark)
                  (draw mark)))
              marks)
    (for-each (lambda (mark)
                (when (is? mark world.mark:Polygon-Mark)
                  (draw mark)))
              marks))
  
  
  (method package (reset-all-marks self)
    (let ((world (current-world)))
      (reset-marks self)
      (display-message world "Marks reset")))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method package virtual (zone-editable? self)
    editable?)
  
  
  (method package virtual (zone-destructible? self)
    #f)
    
  
  ;;;
  ;;;; Level
  ;;;

  
  (method protected (get-level-file self)
    (or level-file
        (let ((file (new-file level-dir "level.dat")))
          (set! level-file file)
          file)))
  
  
  (method public (get-level-state self)
    (or level-state
        (let ((state (read/create-level self)))
          (set! level-state state)
          state)))
  
  
  (method (read/create-level self)
    (let ((file (get-level-file self)))
      (if (exists? file)
          (read-level self file)
        (create-level self))))
  
  
  (method (read-level self file)
    (with ((reader <NBT-Reader> (new NBT-Reader file compressed?: #t gzip?: #t)))
      (read-tag reader)))
  
  
  (method (create-level self)
    (let ((spawnpoint (or start-spawnpoint (vertex 0. 50. 0.))))
      (make-tag "" TAG_Compound
        (list
          (make-tag "Data" TAG_Compound
            (list
              (make-tag "Player" TAG_Compound
                (list
                  (make-tag "Inventory" TAG_List (make-list-payload TAG_Compound '()))))
              (make-tag "SpawnX" TAG_Int (fxround (vertex-x spawnpoint)))
              (make-tag "SpawnY" TAG_Int (fxround (vertex-y spawnpoint)))
              (make-tag "SpawnZ" TAG_Int (fxround (vertex-z spawnpoint)))
              (make-tag "LevelName" TAG_String "New")
              (make-tag "version" TAG_Int 19133)))))))
  
  
  (method public (save-level-state self)
    (save-level self (get-level-state self) (get-level-file self)))
  
  
  (method (save-level self level file)
    (create-directories file)
    (with ((writer (new NBT-Writer file compressed?: #t gzip?: #t)))
      (write-tag writer level)))
  
  
  (method package (find-spawnpoint self)
    (or (get-player-spawnpoint self)
        (get-spawnpoint self)))
  
  
  (method package (find-spawnlookat self)
    (make-standard-lookat))
  
  
  (method package (get-spawnpoint self)
    (let ((tag (get-level-state self)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-assoc "SpawnX" compound))
              (y (tag-assoc "SpawnY" compound))
              (z (tag-assoc "SpawnZ" compound)))
          (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z))))))
  
  
  (method package (set-spawnpoint self pos)
    (let ((tag (get-level-state self)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-find "SpawnX" compound))
              (y (tag-find "SpawnY" compound))
              (z (tag-find "SpawnZ" compound)))
          (tag-set x (fxround (vertex-x pos)))
          (tag-set y (fxround (vertex-y pos)))
          (tag-set z (fxround (vertex-z pos)))))))
  
  
  (method package (get-player-spawnpoint self)
    (let ((tag (get-level-state self)))
      (let ((player (tag-assoc "Player" (tag-assoc "Data" (tag-value tag)))))
        (let ((x (tag-assoc "SpawnX" player))
              (y (tag-assoc "SpawnY" player))
              (z (tag-assoc "SpawnZ" player)))
          (and x y z (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z)))))))
  
  
  (method package (set-player-spawnpoint self pos)
    (let ((tag (get-level-state self)))
      (let ((player (tag-find "Player" (tag-assoc "Data" (tag-value tag)))))
        (tag-add player "SpawnX" TAG_Int (fxround (vertex-x pos)))
        (tag-add player "SpawnY" TAG_Int (fxround (vertex-y pos)))
        (tag-add player "SpawnZ" TAG_Int (fxround (vertex-z pos))))))
  
  
  (method package (teleport self pos (sight #f))
    (let ((world (current-world))
          (me (current-me)))
      (let ((eye (get-eye world)))
        (person-motion world feedback?: #f)
        (set-position me pos)
        (cond ((not sight)
               (derive-target eye)
               (camera-update eye))
              (else
               (set-lookat me (horizon-lookat sight))
               (eye-behind-player world)
               (follow-player world))))))
  
  
  (method (explode-blocks self tnts blocks)
    (play-ambient-sound "minecraft/random/explode" volume: .25)
    (updating-sections self
      (lambda (add-section)
        (for-each (lambda (tnt)
                    (remove-block! self tnt add-section))
                  tnts)
        (for-each (lambda (block)
                    (remove-block! self block add-section)) blocks))
      delay-update?: #t))
  
  
  (method (reveal-chests self command-block blocks)
    (updating-sections self
      (lambda (add-section)
        (loop (for x from 0 below (fxceiling (/ (length blocks) 6.)))
              (let ((pos (random-element blocks)))
                (set! blocks (remove pos blocks test: equal?))
                (place-block! self pos RedstoneTorchOn add-section)))
        (remove-block self (car command-block) add-section))))
  
  
  (method (testfor-action self command-block test action)
    (call-with-position self (car test)
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (when (= block-id (cdr test))
          (updating-sections self
            (lambda (add-section)
              (case (cdr action)
                ((remove) (remove-block self (car action) add-section))
                ((delete) (remove-block! self (car action) add-section))
                ((add)    (place-block! self (caar action) (cdar action) add-section)))
              (remove-block self (car command-block) add-section)))))))
  
  
  (method (remove-block self pos add-section)
    (call-with-position self pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (with-field i j k
          (lambda (section index)
            (add-section section)
            (block-set! section index 0)
            (data-set! section index 0))))))
  
  
  (method (remove-block! self pos add-section)
    (call-with-position self pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (delete-block (current-universe) #f section block-id data-id i j k x y z add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (place-block! self pos block add-section)
    (call-with-position self pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (add-block (current-universe) #f #f #f block #f section block-id data-id i j k x y z add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (on-toggle-glow self evt)
    (let ((world (current-world)))
      (if (= player-glow -1.)
          (set! player-glow 5.)
        (set! player-glow -1.))
      (update-parameter world 'glow)))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method package (call-with-position self pos <vertex> proc (create?: create? #t))
    (let ((section (position-section self pos create?: create?)))
      (and section
           (let ((x (fxfloor (vertex-x pos)))
                 (y (fxfloor (vertex-y pos)))
                 (z (fxfloor (vertex-z pos))))
             (let ((section-index (get-index section)))
               (let ((section-x (index-x section-index))
                     (section-y (index-y section-index))
                     (section-z (index-z section-index)))
                 (let ((i (- x (* section-x 16)))
                       (j (- y (* section-y 16)))
                       (k (- z (* section-z 16))))
                   (call-with-section self section i j k proc))))))))
  
  
  (method package (call-with-section self section i <fx> j <fx> k <fx> proc)
    (with-index section
      (lambda (section-x section-y section-z)
        (let ((region (get-region (get-chunk section))))
          (let ((region-x (get-x region))
                (region-z (get-z region))
                (chunk-x (section->chunk section-x))
                (chunk-z (section->chunk section-z))
                (sections (neighbor-sections section section-x section-y section-z)))
            (let ((bottom-section? (= section-y (cast <fx> (or truncate-y 0))))
                  (position-x (+ (* region-x 32 16) (* chunk-x 16) i))
                  (position-y (+ (* section-y 16) j))
                  (position-z (+ (* region-z 32 16) (* chunk-z 16) k))
                  (blocks (get-blocks section))
                  (data (get-data section))
                  (blocklight (get-blocklight section))
                  (skylight (get-skylight section)))
              (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                (let ((index (neighbor-section-index a b c)))
                  (and index (vector-ref sections index))))
              
              (define (local-index i <fx> j <fx> k <fx>) <fx>
                (+ (* j 256) (* k 16) i))
              
              (define (block-ref section local-index <fx>) <fx>
                (u8vector-ref (cast <u8vector> (get-blocks section)) local-index))
              
              (define (block-set! section local-index <fx> block-id <fx>)
                (u8vector-set! (cast <u8vector> (get-blocks section)) local-index block-id))
              
              (define (data-ref section local-index <fx>) <fx>
                (u4vector-ref (cast <u8vector> (get-data section)) local-index))
              
              (define (data-set! section local-index <fx> data-id <fx>)
                (u4vector-set! (cast <u8vector> (get-data section)) local-index data-id))
              
              (define (blocklight-ref section local-index <fx>) <fx>
                (u4vector-ref (cast <u8vector> (get-blocklight section)) local-index))
              
              (define (blocklight-set! section local-index <fx> blocklight <fx>)
                (u4vector-set! (cast <u8vector> (get-blocklight section)) local-index blocklight))
              
              (define (skylight-ref section local-index <fx>) <fx>
                (u4vector-ref (cast <u8vector> (get-skylight section)) local-index))
              
              (define (skylight-set! section local-index <fx> skylight <fx>)
                (u4vector-set! (cast <u8vector> (get-skylight section)) local-index skylight))
              
              (define (u4vector-ref field <u8vector> index <fx>) <fx>
                (let ((byte (u8vector-ref field (quotient index 2))))
                  (if (even? index)
                      (bitwise-and byte #x0F)
                    (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
              
              (define (u4vector-set! field <u8vector> index <fx> value <fx>)
                (let ((offset (quotient index 2)))
                  (let ((byte (u8vector-ref field offset)))
                    (u8vector-set! field offset
                      (if (even? index)
                          (bitwise-ior value (bitwise-and byte #xF0))
                        (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4)))))))
              
              (define (with-field i <fx> j <fx> k <fx> proc)
                (define (bind-i a <fx> i <fx>)
                  (define (bind-j b <fx> j <fx>)
                    (define (bind-k c <fx> k <fx>)
                      (let ((section (section-ref a b c)))
                        ;; callers of with-field need to be able
                        ;; to handle section being #f for the moment
                        (proc section (local-index i j k))))
                    
                    (cond ((< k 0) (bind-k (quotient/ k 16) (modulo k 16)))
                          ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                          (else (bind-k 0 k))))
                  
                  (cond ((< j 0) (bind-j (quotient/ j 16) (modulo j 16)))
                        ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                        (else (bind-j 0 j))))
                
                (cond ((< i 0) (bind-i (quotient/ i 16) (modulo i 16)))
                      ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                      (else (bind-i 0 i))))
              
              (let ((index (local-index i j k)))
                (let ((block-id (block-ref section index))
                      (data-id (data-ref section index)))
                  (let ((x (fl& (+ block-radius (cast <fl> position-x))))
                        (y (fl& (+ block-radius (cast <fl> position-y))))
                        (z (fl& (+ block-radius (cast <fl> position-z)))))
                    (proc section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))))))))
  
  
  (method package (updating-sections self proc (delay-update?: delay-update? #f))
    (define (update-sections sections)
      (let ((entities '())
            (bake-lighting? (window?)))
        (for-each (lambda (section)
                    (let ((area (find-area self (get-index section))))
                      (when area
                        (clear-polygons area)
                        (set-physical-uptodate? area #f)))
                    (when (window?)
                      (let ((eye-sector (find-sector self (get-index section))))
                        (when eye-sector
                          (set-visual-uptodate? eye-sector #f)
                          (if (and delay-update? delay-updating?)
                              (update-visual eye-sector self (current-camera))
                            (set-visual-generating? eye-sector #t)
                            (increase-sectors-generating self 1)
                            (instantiate-visual eye-sector))
                          (when bake-lighting?
                            (for-each (lambda (entity)
                                        (unless (memq? entity entities)
                                          (set! entities (cons entity entities))))
                                      (get-entities (get-expanse eye-sector)))))))
                    (modified (get-chunk section)))
                  sections)
        (when bake-lighting?
          (for-each (lambda (entity)
                      (unless (player? entity)
                        (bake-entity-lighting self entity)))
                    entities))))
    
    (define (save-regions)
      (iterate-regions dimension
        (lambda (region)
          (save-region region))))
    
    (let ((sections '()))
      (define (add-section section)
        (unless (memq? section sections)
          (set! sections (cons section sections))))
      
      (let ((timer (new Timer)))
        (define (updating)
          (prog1 (proc add-section)
            (update-sections sections)
            (save-regions)))
        
        (prog1 (updating)
          (when report-updating?
            (let ((world (current-world)))
              (let ((count (length sections))
                    (duration (real-duration-in-milliseconds timer)))
                (display-message world (format "Updated {a} section{a} ({a}ms)" count (format-plural count) duration)))))))))
  
  
  (method package (bake-entity-lighting self entity <Entity>)
    (cache-model entity)
    (call-with-position self (get-position entity)
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (let ((section-index (get-index section)))
          (let ((section-pos (vertex (cast <fl> (* (index-x section-index) 16))
                                     (cast <fl> (* (index-y section-index) 16))
                                     (cast <fl> (* (index-z section-index) 16)))))
            (let ((meshes (get-meshes entity)))
              (loop (for mesh in-vector meshes)
                    (bake-mesh-lighting self entity mesh section-pos with-field blocklight-ref skylight-ref))))))))
  
  
  (method (bake-mesh-lighting self entity <Entity> mesh <Mesh> section-pos <vertex> with-field blocklight-ref skylight-ref)
    (with-reentrant-render-mutex
      (lambda ()
        (let ((vertices-buffer (get-vertices-buffer mesh))
              (lightmap-buffer (get-lightmap-buffer mesh)))
          (let ((vertices-size (get-size vertices-buffer))
                (vertices-indices (get-indices vertices-buffer))
                (lightmap-size (get-size lightmap-buffer))
                (lightmap-indices (get-indices lightmap-buffer)))
            (let ((vertices (make-f32vector vertices-size))
                  (lightmap (make-f32vector lightmap-size))
                  (indices (assert (= vertices-indices lightmap-indices) vertices-indices))
                  (matrix (matrix-multiply& (get-matrix entity) (get-global-matrix (cache-model entity))))
                  (sun-position (vertex 50. 400. 200.)))
              (download-stream-data vertices-buffer 0 vertices vertices-size)
              (loop (for n from 0 below indices)
                    (let ((vertex-offset (* n vertex-floats))
                          (lightmap-offset (* n lightmap-floats)))
                      (let ((vert (vertex (f32vector-ref vertices vertex-offset)
                                          (f32vector-ref vertices (+ vertex-offset 1))
                                          (f32vector-ref vertices (+ vertex-offset 2))))
                            (normal (vertex (f32vector-ref vertices (+ vertex-offset 3))
                                            (f32vector-ref vertices (+ vertex-offset 4))
                                            (f32vector-ref vertices (+ vertex-offset 5)))))
                        (let ((pos (matrix-transform& matrix vert)))
                          (let ((sun-direction (vertex-normalize& (vertex-& sun-position pos))))
                            (let ((sun-diffuse (dot-product& normal sun-direction)))
                              (let ((shade (+ .5 (/ (abs sun-diffuse) 2.))))
                                (let ((relative-pos (vertex-& pos section-pos)))
                                  (with-field (fxround (vertex-x relative-pos)) (fxround (vertex-y relative-pos)) (fxround (vertex-z relative-pos))
                                    (lambda (section index)
                                      (if (not section)
                                          (begin
                                            (f32vector-set! lightmap lightmap-offset 0.)
                                            (f32vector-set! lightmap (+ lightmap-offset 1) 0.)
                                            (f32vector-set! lightmap (+ lightmap-offset 2) shade))
                                        (let ((blocklight (blocklight-ref section index))
                                              (skylight (skylight-ref section index)))
                                          (f32vector-set! lightmap lightmap-offset (* (cast <fl> blocklight) 4.))
                                          (f32vector-set! lightmap (+ lightmap-offset 1) (* (cast <fl> skylight) 4.))
                                          (f32vector-set! lightmap (+ lightmap-offset 2) shade)))))))))))))
              (upload-stream-data lightmap-buffer 0 lightmap lightmap-size)))))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method package (evaluate-zone-hook self forms syntax str container line col)
    (let ((ids (collect (lambda (form)
                          (and (pair? form) (eq? (car form) 'define-block)
                            (third form)))
                        forms)))
      (cond ((not-null? ids)
             (reset-inventory-blocks)
             @$$$
             (updating-sections
               (lambda (add-section)
                 (finding-visual-blocks ids
                   add-section)
                 (finding-physical-blocks self ids
                   (lambda (area)
                     (add-section (get-section area)))))))
            @$$$
            ((search container "world/external/minecraft")
             (updating-sectors
               (lambda (add-sector)
                 (add-sector (element-sector (current-me)))))))))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  (method package (block-at self pos)
    (or (call-with-position self pos
          (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
            block-id)
          create?: #f)
        Air))
  
  
  (method package (block/data-at self pos)
    (call-with-position self pos
      (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (cons block-id data-id))
      create?: #f))
  
  
  (method (find-visual-blocks self ids)
    (let ((queue (new-queue)))
      (iterate-sectors self
        (lambda (sector)
          (sector-iterate-blocks self sector ids
            (lambda (found)
              (enqueue queue (cons sector (index->coordinates found)))))))
      (queue-list queue)))
  
  
  (method (finding-visual-blocks self ids proc)
    (iterate-sectors self
      (lambda (sector)
        (when (sector-contains-blocks? self sector ids)
          (proc sector)))))
  
  
  (method (sector-contains-blocks? self sector ids)
    (continuation-capture
      (lambda (found)
        (sector-iterate-blocks self sector ids
          (lambda (ignore)
            (continuation-return found #t)))
        #f)))
  
  
  (method (sector-iterate-blocks self sector ids proc)
    (let ((section (index-section self (get-index sector))))
      (when section
        (section-iterate-blocks self section ids proc))))
  
  
  (method package (section-iterate-blocks self section ids proc)
    (let ((blocks (get-blocks section)))
      (for-each (lambda (id)
                  (let (iter (pos 0))
                    (let ((found (u8vector-find id blocks (u8vector-length blocks) pos)))
                      (when found
                        (proc found)
                        (iter (+ found 1))))))
                ids)))
  
  
  (method (section-count-blocks self section)
    (let ((blocks (get-blocks section))
          (count 0))
      (loop (for n from 0 below 4096)
            (let ((block (u8vector-ref blocks n)))
              (when (/= block Air)
                (increase! count))))
      count))
  
  
  (method (finding-physical-blocks self ids proc)
    (iterate-areas self
      (lambda (index area)
        (iterate-area-polygons area #f
          (lambda (env elem polygons offset)
            (let ((data1 (f64vector-ref polygons (+ offset 16))))
              (when (and (/= data1 0.) (memq? (flonum->fixnum data1) ids))
                (proc area))))))))))
