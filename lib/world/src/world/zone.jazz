;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Zones
;;;


(module world.zone jazz


(import (jazz.designer)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.literals)
        (jazz.math)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.version)
        (time)
        (world)
        (world.actor)
        (world.area)
        (world.autoload)
        (world.block)
        (world.counter)
        (world.dye)
        (world.element)
        (world.enemy)
        (world.entity)
        (world.folio)
        (world.foreign)
        (world.foreign.triangulate)
        (world.gadget)
        (world.geometry)
        (world.gravity)
        (world.history)
        (world.light)
        (world.mark)
        (world.player)
        (world.procedural)
        (world.render)
        (world.sector)
        (world.settings)
        (world.shader)
        (world.sun)
        (world.texture)
        (world.tile)
        (world.window)
        (world.client.window))


;;;
;;;; Zone
;;;


(class Zone extends Component
  
  
  (property title                <string+>    initialize #f           accessors generate)
  (property ambient-color        <Color+>     initialize #f           accessors generate)
  (property material-specular    <Color+>     initialize #f           accessors generate)
  (property material-shininess   <fl+>        initialize #f           accessors generate)
  (property start-position       <f32vector+> initialize #f           accessors generate)
  (property start-sight          <f32vector+> initialize #f           accessors generate)
  (property start-up             <f32vector+> initialize #f           accessors generate)
  (property floor-level          <fl>         initialize 0.0          accessors generate)
  (property missile-behavior     <symbol>     initialize 'destroy     accessors generate)
  (property sun-cycle?           <bool>       initialize #t           accessors generate)
  (property properties           <object>     initialize '()          accessors generate)
  
  
  (slot radius                   <fl>         initialize #f           getter generate)
  (slot sectors                  <object>     initialize #f           getter generate)
  (slot sector-size              <fx>         initialize #f           getter generate)
  (slot sector-radius            <fl>         initialize #f           getter generate)
  (slot areas                    <object>     initialize #f           getter generate)
  (slot area-size                <fx>         initialize #f           getter generate)
  (slot debug-areas?             <bool>       initialize #f           getter generate)
  (slot tiles                    <list>       initialize '()          getter generate)
  (slot players                  <list>       initialize '()          getter generate)
  (slot actors                   <list>       initialize '()          getter generate)
  (slot entities                 <list>       initialize '()          getter generate)
  (slot gadgets                  <list>       initialize '()          getter generate)
  (slot elements                 <list>       initialize '()          getter generate)
  (slot marks                    <list>       initialize '()          getter generate)
  (slot update-lightmaps?        <bool>       initialize #t           getter generate)
  (slot lights-count             <fx>         initialize 0            accessors generate)
  (slot sun-ambient              <Color+>     initialize #f           accessors generate)
  (slot sun-color                <Color+>     initialize #f           accessors generate)
  (slot sun-coordinates          <f32vector>  initialize #f           accessors generate)
  (slot sun-angle                <fl>         initialize 0.           accessors generate)
  (slot debug-sectors?           <bool>       initialize #f           accessors generate)
  (slot designer                 <object>     initialize #f           accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! radius 500.)
    (set! update-lightmaps? (get-lightmaps?~ world))
    (set! sun-ambient {Color red: 0.4 green: 0.4 blue: 0.4 alpha: 1.0})
    (set! sun-color {Color red: 1.0 green: 1.0 blue: 1.0 alpha: 1.0})
    (set! sun-coordinates (vertex 10000.0 10000.0 10000.0))
    (set-zone self))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set! sun-cycle? (and sun-cycle? (find-setting 'world.sun-cycle? #t))))
  
  
  (method (initialize-zone)
    (setup-areas)
    (setup-sectors)
    (setup-lights)
    (setup-boundaries)
    (setup-content))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))


  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (free-sectors))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (reset-zone)
    (set! tiles '())
    (set! players '())
    (set! actors '())
    (set! entities '())
    (set! elements '()))
  
  
  (method virtual (setup-content)
    )
	
  
  (method (update-children)
    (set-me #f)
    (for-each (lambda (obj)
                (when (is? obj Element)
                  (add-element obj)))
              children))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (get-moniker)
    (get-origin~ (get-form~ designer)))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (set-modified?~ designer flag))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method (draw-zone)
    (when (get-draw-elements?~ world)
      (if (get-3d?~ world)
          (draw-sectors~ world)
        (draw-immediate)))
    (when debug-areas?
      (draw-debug-areas))
    (when debug-sectors?
      (draw-debug-sectors))
    (when (get-draw-gadgets?~ world)
      (draw-gadgets))
    (when (get-draw-marks?~ world)
      (draw-marks))
    (draw-entities))
  
  
  ;;;
  ;;;; Boundaries
  ;;;
  
  
  (method (setup-boundaries)
    @w
    (set! boundaries (new Cuboid left bottom back right top front)))
  
  
  ;;;
  ;;;; Snapshots
  ;;;
  
  
  (method (snapshot-zone)
    (let ((actors (map object-copy actors))
          (marks (map object-copy marks)))
      (new Snapshot
        actors
        (collect-type Player actors)
        marks)))
  
  
  (method (load-zone snapshot)
    (set! actors (map object-copy (get-actors~ snapshot)))
    (set! marks (map object-copy (get-marks~ snapshot)))
    (set! elements (append tiles actors))
    ;; quick solution to player being left in entities when unpausing
    (set! entities (collect-if (lambda (entity) (memq? entity elements)) entities))
    (setup-areas)
    (setup-sectors)
    (setup-lights)
    (setup-content)
    (for-each (lambda (element)
                (area-add-element (element-area element) element)
                (sector-add-element (element-sector element) element))
              elements))
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method (add-element obj)
    (define (add-player)
      (set! players (cons obj players))
      (set! actors (cons obj actors))
      (set! entities (cons obj entities))
      (set! elements (cons obj elements)))
    
    (define (add-actor)
      (set! actors (cons obj actors))
      (set! entities (cons obj entities))
      (set! elements (cons obj elements)))
    
    (define (add-entity)
      (set! entities (cons obj entities))
      (set! elements (cons obj elements)))
    
    (define (add-tile)
      (set! tiles (cons obj tiles))
      (set! elements (cons obj elements)))
    
    (define (add-gadget)
      (set! gadgets (cons obj gadgets)))
    
    (if (gadget?~ obj)
        (add-gadget)
      (typecase obj
        ((Player) (add-player))
        ((Actor) (add-actor))
        ((Entity) (add-entity))
        (else (add-tile))))
    (area-add-element (element-area obj) obj)
    (sector-add-element (element-sector obj) obj)
    obj)
  
  
  (method (remove-element obj)
    (define (remove-player)
      (set! players (remove! obj players))
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities))
      (set! elements (remove! obj elements)))
    
    (define (remove-actor)
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities))
      (set! elements (remove! obj elements)))
    
    (define (remove-entity)
      (set! entities (remove! obj entities))
      (set! elements (remove! obj elements)))
    
    (define (remove-tile)
      (set! tiles (remove! obj tiles))
      (set! elements (remove! obj elements)))
    
    (define (remove-gadget)
      (set! gadgets (remove! obj gadgets)))
    
    (if (gadget?~ obj)
        (remove-gadget)
      (typecase obj
        ((Player) (remove-player))
        ((Actor) (remove-actor))
        ((Entity) (remove-entity))
        (else (remove-tile))))
    (area-remove-element (element-area obj) obj)
    (sector-remove-element (element-sector obj) obj))
  
  
  (method (find-element predicate)
    (find-if predicate elements))
  
  
  (method (find-named-element name)
    (find-if (lambda (element)
               (eq? (get-name~ element) name))
             elements))
  
  
  (method (find-gadget predicate)
    (find-if predicate gadgets))
  
  
  (method (iterate-players proc)
    (for-each proc players))
  
  
  (method (iterate-actors proc)
    (for-each proc actors))
  
  
  (method (iterate-entities proc)
    (for-each proc entities))
  
  
  (method (iterate-gadgets proc)
    (for-each proc gadgets))
  
  
  (method (iterate-elements proc)
    (for-each proc elements))
  
  
  (method (iterate-all proc)
    (for-each proc elements)
    (for-each proc gadgets))
  
  
  (method (draw-entities)
    (iterate-entities
      (lambda (element)
        (unless (or (eq? element me) (not (get-visible?~ element)))
          (draw~ element))))
    
    ;; draw potentially translucent elements last
    (when me
      (draw~ me)))
  
  
  (method (draw-immediate)
    (iterate-elements
      (lambda (element)
        (unless (is? element Actor)
          (draw~ element)))))
  
  
  (method (vertex->element vert)
    (let ((l (* (floor (/ (vertex-x vert) 5.)) 5.))
          (b (* (floor (/ (vertex-y vert) 5.)) 5.))
          (f (* (floor (/ (vertex-z vert) 5.)) 5.)))
      (let ((r (+ l 5.))
            (t (+ b 5.))
            (n (+ f 5.)))
        (continuation-capture
          (lambda (return)
            (let ((area (index-area (position-area-index vert)))
                  (x (vertex-x vert))
                  (y (vertex-y vert))
                  (z (vertex-z vert)))
              (iterate-area-elements area
                (lambda (obj)
                  (when (and (get-visible?~ obj)
                             (let ((x (get-x~ obj))
                                   (y (get-y~ obj))
                                   (z (get-z~ obj)))
                               (and (>= x l)
                                    (>= y b)
                                    (>= z f)
                                    (<  x r)
                                    (<  y t)
                                    (<  z n))))
                    (continuation-return return obj)))))
            #f)))))
  
  
  (method (element-at vert)
    (continuation-capture
      (lambda (return)
        (let ((area (index-area (position-area-index vert))))
          (iterate-area-elements area
            (lambda (obj)
              (when (and (get-visible?~ obj)
                         (vertex=? (get-position~ obj) vert))
                (continuation-return return obj)))))
        #f)))
  
  
  (method (validate-elements)
    (iterate-elements
      (lambda (element)
        (assert (real? (get-x~ element)))
        (assert (real? (get-y~ element)))
        (assert (real? (get-z~ element)))
        (assert (real? (get-red~ element)))
        (assert (real? (get-green~ element)))
        (assert (real? (get-blue~ element)))
        (assert (real? (get-alpha~ element))))))
  
  
  ;;;
  ;;;; Sectors
  ;;;
  
  
  (method (setup-sectors)
    (set! sectors (make-table test: equal?))
    (set! sector-size (or (find-setting 'world.sector-size #f) 100))
    (set! sector-radius (let ((half (/ sector-size 2.)))
                          (vertex-norm (vertex half half half)))))
  
  
  (method (element-sector-index element)
    (position-sector-index (get-position~ element)))
  
  
  (method (position-sector-index pos)
    (define (offset r)
      (let ((i (fxfloor r)))
        (/ (- i (modulo i sector-size))
           sector-size)))
    
    (list (offset (vertex-x pos))
          (offset (vertex-y pos))
          (offset (vertex-z pos))))
  
  
  (method (position-sector pos)
    (index-sector (position-sector-index pos)))
  
  
  (method (element-sector element)
    (index-sector (element-sector-index element)))
  
  
  (method (index-sector index)
    (define (center i)
      (* (+ i .5) sector-size))
    
    (or (table-ref sectors index #f)
        (bind (x y z) index
          (let ((sector (new Sector index (vertex (center x) (center y) (center z)))))
            (table-set! sectors index sector)
            sector))))
  
  
  (method (unlink-sector sector)
    ;; doesnt-work-as-is-see-unlink-area-comment
    )
  
  
  (method (free-sectors)
    (iterate-table sectors
      (lambda (index sector)
        (free-mesh~ sector))))
  
  
  (method (sector-add-element sector element)
    (define (add-tile)
      (set-tiles~ sector (cons element (get-tiles~ sector)))
      (set-vertices-uptodate?~ sector #f))
    
    (typecase element
      ((Tile)
       (add-tile)))
    (invalidate-lightmaps element))
  
  
  (method (sector-remove-element sector element)
    (define (remove-tile)
      (let ((tiles (remove! element (get-tiles~ sector))))
        (set-tiles~ sector tiles)
        (set-vertices-uptodate?~ sector #f)
        (when (null? tiles)
          (unlink-sector sector))))
    
    (typecase element
      ((Tile)
       (remove-tile)))
    (invalidate-lightmaps element))
  
  
  (method (iterate-sectors-with-tiles proc)
    (iterate-table sectors
      (lambda (index sector)
        (when (not-null? (get-tiles~ sector))
          (proc index sector)))))
  
  
  (method (iterate-position-neighbor-sectors pos distance proc)
    (bind (a b c) (position-sector-index pos)
      (loop (for i from (- distance) to distance)
            (loop (for j from (- distance) to distance)
                  (loop (for k from (- distance) to distance)
                        (proc (index-sector (list (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-element-neighbor-sectors element distance proc)
    (iterate-position-neighbor-sectors (get-position~ element) distance proc))
  
  
  (method (element-neighbor-sectors element distance)
    (let ((queue (new-queue)))
      (iterate-element-neighbor-sectors element distance (lambda (sector) (enqueue queue sector)))
      (queue-list queue)))
  
  
  (method (compute-floats)
    (let ((total 0))
      (iterate-table sectors
        (lambda (index sector)
          (let ((mesh (get-mesh~ sector)))
            (when (and mesh (get-vertices-uptodate?~ sector))
              (let ((floats (count-floats~ mesh)))
                (when floats
                  (increase! total floats)))))))
      total))
  
  
  (method (count-sectors-with-tiles)
    (let ((total 0))
      (iterate-sectors-with-tiles
        (lambda (index sector)
          (increase! total)))
      total))
  
  
  (method (validate-sectors)
    )
  
  
  (method (toggle-debug-sectors)
    (set! debug-sectors? (not debug-sectors?)))
  
  
  (method (draw-debug-sectors)
    (let ((size (cast <fl> sector-size))
          (depth 5))
      (let ((min (- (* size depth)))
            (max (* size depth)))
        (glDisable GL_LIGHTING)
        (gl-colorize {Color Red})
        (glBegin GL_LINES)
        (loop (for x <fl> from min to max by size)
              (loop (for y <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for y <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for z <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z))
              (loop (for y <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glEnable GL_LIGHTING))))
  
  
  ;;;
  ;;;; Areas
  ;;;
  
  
  (method (setup-areas)
    (set! areas (make-table test: equal?))
    (set! area-size 10))
  
  
  (method (element-area-index element)
    (position-area-index (get-position~ element)))
  
  
  (method (position-area-index pos)
    (define (offset r)
      (let ((i (fxfloor r)))
        (/ (- i (modulo i area-size))
           area-size)))
    
    (list (offset (vertex-x pos))
          (offset (vertex-y pos))
          (offset (vertex-z pos))))
  
  
  (method (element-area element)
    (index-area (element-area-index element)))
  
  
  (method (index-area index)
    (or (table-ref areas index #f)
        (let ((area (new Area index)))
          (table-set! areas index area)
          area)))
  
  
  (method (unlink-area area)
    @doesnt-work-as-is-because-hit-test-will-consult/create-the-27-adjacent-areas-even-if-they-are-empty
    (table-clear areas (get-index~ area)))
  
  
  (method (area-add-element area element)
    (define (add-actor)
      (set-actors~ area (cons element (get-actors~ area))))
    
    (define (add-tile)
      (set-tiles~ area (cons element (get-tiles~ area))))
    
    (define (add-gadget)
      (set-gadgets~ area (cons element (get-gadgets~ area))))
    
    (cond ((is? element Actor)
           (add-actor))
          ((is? element Tile)
           (add-tile))
          (else
           (add-gadget))))
  
  
  (method (area-remove-element area element)
    (define (remove-actor)
      (let ((actors (remove! element (get-actors~ area))))
        (set-actors~ area actors)
        (when (and (null? actors) (null? (get-tiles~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-tile)
      (let ((tiles (remove! element (get-tiles~ area))))
        (set-tiles~ area tiles)
        (when (and (null? tiles) (null? (get-actors~ area)) (null? (get-gadgets~ area)))
          (unlink-area area))))
    
    (define (remove-gadget)
      (let ((gadgets (remove! element (get-gadgets~ area))))
        (set-gadgets~ area gadgets)
        (when (and (null? gadgets) (null? (get-actors~ area)) (null? (get-tiles~ area)))
          (unlink-area area))))
    
    (cond ((is? element Actor)
           (remove-actor))
          ((is? element Tile)
           (remove-tile))
          (else
           (remove-gadget))))
  
  
  (method (update-area element old-position)
    (let ((old-index (position-area-index old-position))
          (new-index (element-area-index element)))
      (when (not (equal? old-index new-index))
        (let ((old-area (index-area old-index))
              (new-area (index-area new-index)))
          (area-remove-element old-area element)
          (area-add-element new-area element)))))
  
  
  (method (iterate-position-neighbor-areas pos proc)
    (bind (a b c) (position-area-index pos)
      (loop (for i from -1 to 1)
            (loop (for j from -1 to 1)
                  (loop (for k from -1 to 1)
                        (proc (index-area (list (+ a i) (+ b j) (+ c k)))))))))
  
  
  (method (iterate-element-neighbor-areas element proc)
    (iterate-position-neighbor-areas (get-position~ element) proc))
  
  
  (method (element-neighbor-areas element)
    (let ((queue (new-queue)))
      (iterate-element-neighbor-areas element (lambda (area) (enqueue queue area)))
      (queue-list queue)))
  
  
  (method (iterate-areas-elements areas proc)
    (for-each (lambda (area)
                (for-each proc (get-tiles~ area))
                (for-each proc (get-actors~ area))
                (for-each proc (get-gadgets~ area)))
              areas))
  
  
  (method (iterate-area-elements area proc)
    (for-each proc (get-tiles~ area))
    (for-each proc (get-actors~ area))
    (for-each proc (get-gadgets~ area)))
  
  
  (method (collect-area-elements)
    (let ((queue (new-queue)))
      (iterate-table areas
        (lambda (index area)
          (enqueue-list queue (get-tiles~ area))
          (enqueue-list queue (get-actors~ area))
          (enqueue-list queue (get-gadgets~ area))))
      (queue-list queue)))
  
  
  (method (areas-count filter)
    (count-if filter (collect-area-elements)))
  
  
  (method (validate-areas)
    (let ((tiles-count 0)
          (actors-count 0)
          (gadgets-count 0)
          (elements-count 0))
      (iterate-table areas
        (lambda (index area)
          (let ((area-tiles (length (get-tiles~ area)))
                (area-actors (length (get-actors~ area)))
                (area-gadgets (length (get-gadgets~ area))))
            (increase! tiles-count area-tiles)
            (increase! actors-count area-actors)
            (increase! gadgets-count area-gadgets)
            (increase! elements-count (+ area-actors area-tiles)))))
      (if (and (= tiles-count (length tiles))
               (= actors-count (length actors))
               (= gadgets-count (length gadgets))
               (= elements-count (length elements)))
          (begin
            (reset-information~ world)
            #t)
        (set-information~ world
          `("Area corruption detected"
            ,(format "  Tiles: {s} {s}" tiles-count (length tiles))
            ,(format "  Actors: {s} {s}" actors-count (length actors))
            ,(format "  Gadgets: {s} {s}" gadgets-count (length gadgets))
            ,(format "  Elements: {s} {s}" elements-count (length elements))))
        #f)))
  
  
  (method (toggle-debug-areas)
    (set! debug-areas? (not debug-areas?)))
  
  
  (method (draw-debug-areas)
    (let ((size (cast <fl> area-size))
          (depth 5))
      (let ((min (- (* size depth)))
            (max (* size depth)))
        (glDisable GL_LIGHTING)
        (gl-colorize {Color Red})
        (glBegin GL_LINES)
        (loop (for x <fl> from min to max by size)
              (loop (for y <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for y <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for z <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z))
              (loop (for y <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glEnable GL_LIGHTING))))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method (hit-test object from-x <fl> from-y <fl> from-z <fl> to-x <fl> to-y <fl> to-z <fl> width <fl> height <fl> depth <fl> radius-x <fl> radius-y <fl> radius-z <fl> filter <procedure+>)
    (let ((from-right (+ from-x width))
          (from-top (+ from-y height))
          (from-front (+ from-z depth))
          (to-right #f)
          (to-top #f)
          (to-front #f)
          (areas (element-neighbor-areas object)))
      (define (hit-x)
        (cond ;; going right
              ((> to-x from-x)
               (let ((found #f)
                     (found-elements #f))
                 (iterate-areas-elements areas
                   (lambda (obj)
                     (when (and (get-visible?~ obj)
                                (or (not filter)
                                    (filter obj)))
                       (let ((bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (back (get-back~ obj))
                             (front (get-front~ obj))
                             (border (get-left~ obj)))
                         (when (and (neq? obj object)
                                    (<= from-right border)
                                    (> to-right border)
                                    (not (or (<= to-top bottom)
                                             (>= to-y top)
                                             (<= to-front back)
                                             (>= to-z front))))
                           (cond ((or (not found)
                                      (< border found))
                                  (set! found border)
                                  (set! found-elements (list obj))
                                  (set! to-right border)
                                  (set! to-x (- to-right width)))
                                 ((= border found)
                                  (set! found-elements (cons obj found-elements)))))))))
                 (when found
                   (list found-elements 1 found (- found radius-x)))))
              ;; going left
              ((< to-x from-x)
               (let ((found #f)
                     (found-elements #f))
                 (iterate-areas-elements areas
                   (lambda (obj)
                     (when (and (get-visible?~ obj)
                                (or (not filter)
                                    (filter obj)))
                       (let ((bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (back (get-back~ obj))
                             (front (get-front~ obj))
                             (border (get-right~ obj)))
                         (when (and (neq? obj object)
                                    (>= from-x border)
                                    (< to-x border)
                                    (not (or (<= to-top bottom)
                                             (>= to-y top)
                                             (<= to-front back)
                                             (>= to-z front))))
                           (cond ((or (not found)
                                      (> border found))
                                  (set! found border)
                                  (set! found-elements (list obj))
                                  (set! to-x border)
                                  (set! to-right (+ to-x width)))
                                 ((= border found)
                                  (set! found-elements (cons obj found-elements)))))))))
                 (when found
                   (list found-elements -1 found (+ found radius-x)))))
              ;; not moving
              (else
               #f)))
      
      (define (hit-y)
        (cond ;; going up
              ((> to-y from-y)
               (let ((found #f)
                     (found-elements #f))
                 (iterate-areas-elements areas
                   (lambda (obj)
                     (when (and (get-visible?~ obj)
                                (or (not filter)
                                    (filter obj)))
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (back (get-back~ obj))
                             (front (get-front~ obj))
                             (border (get-bottom~ obj)))
                         (when (and (neq? obj object)
                                    (<= from-top border)
                                    (> to-top border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-front back)
                                             (>= to-z front))))
                           (cond ((or (not found)
                                      (< border found))
                                  (set! found border)
                                  (set! found-elements (list obj))
                                  (set! to-top border)
                                  (set! to-y (- to-top height)))
                                 ((= border found)
                                  (set! found-elements (cons obj found-elements)))))))))
                 (when found
                   (list found-elements 1 found (- found radius-y)))))
              ;; going down
              ((< to-y from-y)
               (let ((found #f)
                     (found-elements #f))
                 (iterate-areas-elements areas
                   (lambda (obj)
                     (when (and (get-visible?~ obj)
                                (or (not filter)
                                    (filter obj)))
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (back (get-back~ obj))
                             (front (get-front~ obj))
                             (border (get-top~ obj)))
                         (when (and (neq? obj object)
                                    (>= from-y border)
                                    (< to-y border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-front back)
                                             (>= to-z front))))
                           (cond ((or (not found)
                                      (> border found))
                                  (set! found border)
                                  (set! found-elements (list obj))
                                  (set! to-y border)
                                  (set! to-top (+ to-y height)))
                                 ((= border found)
                                  (set! found-elements (cons obj found-elements)))))))))
                 (when found
                   (list found-elements -1 found (+ found radius-y)))))
              ;; not moving
              (else
               #f)))
      
      (define (hit-z)
        (cond ;; going front
              ((> to-z from-z)
               (let ((found #f)
                     (found-elements #f))
                 (iterate-areas-elements areas
                   (lambda (obj)
                     (when (and (get-visible?~ obj)
                                (or (not filter)
                                    (filter obj)))
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (border (get-back~ obj)))
                         (when (and (neq? obj object)
                                    (<= from-front border)
                                    (> to-front border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-top bottom)
                                             (>= to-y top))))
                           (cond ((or (not found)
                                      (< border found))
                                  (set! found border)
                                  (set! found-elements (list obj))
                                  (set! to-front border)
                                  (set! to-z (- to-front depth)))
                                 ((= border found)
                                  (set! found-elements (cons obj found-elements)))))))))
                 (when found
                   (list found-elements 1 found (- found radius-z)))))
              ;; going back
              ((< to-z from-z)
               (let ((found #f)
                     (found-elements #f))
                 (iterate-areas-elements areas
                   (lambda (obj)
                     (when (and (get-visible?~ obj)
                                (or (not filter)
                                    (filter obj)))
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (border (get-front~ obj)))
                         (when (and (neq? obj object)
                                    (>= from-z border)
                                    (< to-z border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-top bottom)
                                             (>= to-y top))))
                           (cond ((or (not found)
                                      (> border found))
                                  (set! found border)
                                  (set! found-elements (list obj))
                                  (set! to-z border)
                                  (set! to-front (+ to-z depth)))
                                 ((= border found)
                                  (set! found-elements (cons obj found-elements)))))))))
                 (when found
                   (list found-elements -1 found (+ found radius-z)))))
              ;; not moving
              (else
               #f)))
      
      (let ((preserved-x to-x)
            (preserved-y to-y)
            (preserved-z to-z))
        (define (restore)
          (set! to-x preserved-x)
          (set! to-y preserved-y)
          (set! to-z preserved-z)
          (set! to-right (+ to-x width))
          (set! to-top (+ to-y height))
          (set! to-front (+ to-z depth)))
        
        (define (hit h1 h2 h3 order)
          (restore)
          (let ((count 0))
            (let ((h1 (h1)))
              (when h1
                (increase! count))
              (let ((h2 (h2)))
                (when h2
                  (increase! count))
                (let ((h3 (h3)))
                  (when h3
                    (increase! count))
                  (cons count (order h1 h2 h3)))))))
        
        (let ((r1 (hit hit-y hit-x hit-z (lambda (hit-y hit-x hit-z) (values hit-x hit-y hit-z)))))
          (if (<= (car r1) 1)
              (cdr r1)
            (let ((r2 (hit hit-x hit-y hit-z (lambda (hit-x hit-y hit-z) (values hit-x hit-y hit-z))))
                  (r3 (hit hit-z hit-y hit-x (lambda (hit-z hit-y hit-x) (values hit-x hit-y hit-z))))
                  (r4 (hit hit-y hit-z hit-x (lambda (hit-y hit-z hit-x) (values hit-x hit-y hit-z))))
                  (r5 (hit hit-x hit-z hit-y (lambda (hit-x hit-z hit-y) (values hit-x hit-y hit-z))))
                  (r6 (hit hit-z hit-x hit-y (lambda (hit-z hit-x hit-y) (values hit-x hit-y hit-z)))))
              (let ((lst (list r1 r2 r3 r4 r5 r6)))
                (cdr (minimum lst key: car)))))))))
  
  
  ;;;
  ;;;; Gadget
  ;;;
  
  
  (method (draw-gadgets)
    (for-each (lambda (gadget)
                (when (get-visible?~ gadget)
                  (draw~ gadget)))
              gadgets))
  
  
  ;;;
  ;;;; Blocks
  ;;;
  
  
  (method (remove-duplicate-blocks)
    (let ((table (make-table test: vertex=? hash: vertex-hash))
          (count 0))
      (for-each (lambda (tile)
                  (when (is? tile Block)
                    (let ((pos (get-position~ tile)))
                      (if (table-ref table pos #f)
                          (begin
                            (editor-remove-element~ world tile)
                            (increase! count))
                        (table-set! table pos tile)))))
                tiles)
      (display-message~ world
        (format "Removed {a} block{a}"
                (format-cardinality count)
                (format-plural count)))))
  
  
  ;;;
  ;;;; Sun
  ;;;
  
  
  (definition sun-speed
    .025)
  
  
  (method (set-sun-speed speed)
    (set! sun-speed speed))
  
  
  (method (find-sun)
    (find-element (lambda (sun) (is? sun Sun))))
  
  
  (method (tick-sun elapse (reverse? #f))
    (set! sun-angle (flmodulo ((if reverse? - +) sun-angle (* sun-speed elapse)) PI*2))
    (let ((under-limit 0.1)
          (direction (rotate-upon PI/4 (vertex 0.0 1.0 0.0) (rotate-upon sun-angle (vertex 0.0 0.0 -1.0) (vertex -1. 0. 0.))))
          (sun (find-sun)))
      (let ((pos (vertex-scalar* direction 1000.)))
        (when (not sun)
          (set! sun (new Sun parent: zone x: (vertex-x pos) y: (vertex-y pos) z: (vertex-z pos)))
          (add-element sun))
        (cond ((or (< sun-angle (+ PI under-limit))
                   (> sun-angle (- PI*2 under-limit)))
               (let ((coord (vertex-scalar* direction 1000.))
                     (under (cond ((> sun-angle (- PI*2 under-limit)) (- PI*2 sun-angle))
                                  ((and (> sun-angle PI) (< sun-angle (+ PI under-limit))) (- sun-angle PI))
                                  (else 0.))))
                 (let ((intensity (- 1.0 (/ under under-limit))))
                   (set-sun-color (new Color red: intensity green: intensity blue: intensity alpha: 1.0)))
                 (set-sun-coordinates coord)
                 (set-position~ sun pos)
                 (set-visible?~ sun #t)))
              (else
               (set-sun-color {Color red: 0.0 green: 0.0 blue: 0.0 alpha: 1.0})
               (set-visible?~ sun #f))))))
  
  
  ;;;
  ;;;; Light
  ;;;
    
  
  (method (setup-lights)
    )

  
  (method (setup-lighting)
    (define (closest-lights)
      (let ((lights (if update-lightmaps? (collect-dynamic-lights) (collect-lights)))
            (eye (get-eye~ world)))
        (sort < lights key: (lambda (light) (vertex-distance eye (get-position~ light))))))
    
    (when (get-light?~ world)
      (glEnable GL_LIGHTING)
      (glDisable GL_LIGHT0)
      (glDisable GL_LIGHT1)
      (glDisable GL_LIGHT2)
      (glDisable GL_LIGHT3)
      (glDisable GL_LIGHT4)
      (glDisable GL_LIGHT5)
      (glDisable GL_LIGHT6)
      (glDisable GL_LIGHT7)
      (let ((color (or ambient-color {Color red: .1 green: .1 blue: .1 alpha: 1.0})))
        (gl-light-model GL_LIGHT_MODEL_AMBIENT (get-red~ color) (get-green~ color) (get-blue~ color) (get-alpha~ color)))
      (let ((color (or material-specular {Color red: .01 green: .01 blue: .01 alpha: 1.0})))
        (gl-material-specular GL_FRONT (get-red~ color) (get-green~ color) (get-blue~ color) (get-alpha~ color)))
      (let ((value (or material-shininess 50.)))
        (gl-material-shininess GL_FRONT value))
      (let ((lights (closest-lights))
            (no GL_LIGHT0))
        (set! lights-count (min (get-dynamic-lights~ world) (length lights)))
        (loop (for light in lights)
              (repeat lights-count)
              (glEnable no)
              (glLightf no
                        GL_CONSTANT_ATTENUATION
                        (get-constant-attenuation~ light))
              (glLightf no
                        GL_LINEAR_ATTENUATION
                        (get-linear-attenuation~ light))
              (glLightf no
                        GL_QUADRATIC_ATTENUATION
                        (get-quadratic-attenuation~ light))
              (let ((ambient (get-ambient-color~ light)))
                (gl-light no
                          GL_AMBIENT
                          (dye-red ambient)
                          (dye-green ambient)
                          (dye-blue ambient)
                          (dye-alpha ambient)))
              (gl-light no
                        GL_DIFFUSE
                        (get-red~ light)
                        (get-green~ light)
                        (get-blue~ light)
                        (get-alpha~ light))
              (gl-light no
                        GL_POSITION
                        (get-x~ light)
                        (get-y~ light)
                        (get-z~ light)
                        1.)
              (increase! no)))))
  
  
  (method (iterate-lights proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Light)
          (proc gadget)))))
  
  
  (method (collect-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (enqueue queue light)))
      (queue-list queue)))
  
  
  (method (collect-static-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (unless (get-dynamic?~ light)
            (enqueue queue light))))
      (queue-list queue)))
  
  
  (method (collect-dynamic-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (when (get-dynamic?~ light)
            (enqueue queue light))))
      (queue-list queue)))
  
  
  (method (count-lights)
    (let ((count 0))
      (iterate-lights
        (lambda (light)
          (increase! count)))
      count))
  
  
  (method (invalidate-lightmaps element)
    (when (get-lightmaps?~ world)
      (iterate-sectors-with-tiles
        (lambda (index sector)
          (set-lightmap-uptodate?~ sector #f)))
      (set! update-lightmaps? #f)))
  
  
  (method (update-lightmaps)
    (when (get-lightmaps?~ world)
      (set! update-lightmaps? #t)))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method (iterate-gravities proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Gravity)
          (proc gadget)))))
  
  
  (method (compute-gravity position)
    (let ((gravity (vertex 0. (- (get-gravity~ world)) 0.)))
      (iterate-gravities
        (lambda (well)
          (let ((direction (vertex-normalize (vertex- (get-position~ well) position)))
                (distance (min 1. (vertex-distance (get-position~ well) position))))
            (vertex+! gravity gravity (vertex-scalar* direction (/ (* (get-pull~ well) 1.) (* distance distance)))))))
      gravity))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method (reset-marks)
    (set! marks '()))
  
  
  (method (set-marks lst)
    (set! marks lst))
  
  
  (method (set-mark mark)
    (set! marks (list mark)))
  
  
  (method (add-mark mark)
    (set! marks (cons mark marks)))
  
  
  (method (remove-mark mark)
    (set! marks (remove! mark marks)))

  
  (method (draw-marks)
    (for-each draw-mark~ marks))
  
  
  (method (reset-all-marks)
    (reset-marks)
    (display-message~ world "Marks reset")))
	

;;;
;;;; Procedural Zones
;;;


;; Ideally, this would use a PRNG which we can seed with a given value. That way
;; the map can be persisted using just the seed, and a list of changes.
;; Also I have no clue how this will react in multiplayer.
(class Procedural-Zone extends Zone
  
  
  (property size         initialize 8       accessors generate)
  (property roughness    initialize 2       accessors generate)
  (property clamp-height initialize 50      accessors generate)
  (property algorithm    initialize 'perlin accessors generate)
  
  
  (method (get-heightmap)
    (case algorithm
      ((perlin) (perlin-noise size roughness: roughness clamp-height: clamp-height))
      ((diamond) (diamond-square size roughness: roughness clamp-height: clamp-height))
      (else (error "Invalid algorithm"))))
  
  
  (method override (setup-content)
    (let ((heightmap (get-heightmap)))
      (let ((dimension (+ (expt 2 size) 1))
            (count (vector-length heightmap)))
        (let ((half-dimension (fxround (/ (cast <fl> dimension) 2.)))
              (vertices (make-vector count))
              (normals (make-vector count)))
          (define (get-vertex x z)
            (vector-ref vertices (+ (* x dimension) z)))
          (define (get-normal x z)
            (vector-ref normals (+ (* x dimension) z)))
          ;; fill vertices
          (let (x-loop (x 0))
            (when (< x dimension)
              (let (z-loop (z 0)
                           (index (* x dimension)))
                (when (< z dimension)
                  (let ((i (* index 3)))
                    (let ((height (vector-ref heightmap index)))
                      (let ((x (cast <fl> (+ (* 5. (- x half-dimension)) .5)))
                            (y (cast <fl> height))
                            (z (cast <fl> (+ (* 5. (- z half-dimension)) .5))))
                        (vector-set! vertices index (vertex x y z))
                        (vector-set! normals index (vertex 0. 0. 0.)))))
                  (z-loop (+ z 1)
                          (+ index 1))))
              (x-loop (+ x 1))))
          ;; add triangles
          (let ((squares-dim (- dimension 1)))
            (let ((squares (make-vector (* squares-dim squares-dim))))
              (define (safe-square x z)
                (and (>= x 0) (< x squares-dim)
                     (>= z 0) (< z squares-dim)
                     (get-square x z)))
              (define (get-square x z)
                (vector-ref squares (+ (* x squares-dim) z)))
              (define (set-square x z square)
                (vector-set! squares (+ (* x squares-dim) z) square))
              (define (make-square t1 t2)
                (cons t1 t2))
              (define (square-t1 square)
                (car square))
              (define (square-t2 square)
                (cdr square))
              (loop (for x from 0 below squares-dim)
                    (loop (for z from 0 below squares-dim)
                          (let ((v1 (get-vertex x (+ z 1)))
                                (v2 (get-vertex (+ x 1) (+ z 1)))
                                (v3 (get-vertex (+ x 1) z))
                                (v4 (get-vertex x z)))
                            (let ((triangle1
                                    (new Triangle-Tile
                                      v1: v1
                                      v2: v2
                                      v3: v3
                                      parent: self))
                                  (triangle2
                                    (new Triangle-Tile
                                      v1: v3
                                      v2: v4
                                      v3: v1
                                      parent: self)))
                              (set-square x z (make-square triangle1 triangle2))))))
              (loop (for x from 0 below dimension)
                    (loop (for z from 0 below dimension)
                          (let ((normal (get-normal x z))
                                (tl (safe-square (- x 1) (- z 1)))
                                (tr (safe-square x (- z 1)))
                                (bl (safe-square (- x 1) z))
                                (br (safe-square x z)))
                            (when tl
                              (vertex-increase! normal (get-normal~ (square-t1 tl))))
                            (when tr
                              (vertex-increase! normal (get-normal~ (square-t1 tr)))
                              (vertex-increase! normal (get-normal~ (square-t2 tr))))
                            (when bl
                              (vertex-increase! normal (get-normal~ (square-t1 bl)))
                              (vertex-increase! normal (get-normal~ (square-t2 bl))))
                            (when br
                              (vertex-increase! normal (get-normal~ (square-t2 br))))
                            (vertex-normalize! normal))))
              (loop (for x from 0 below squares-dim)
                    (loop (for z from 0 below squares-dim)
                          (let ((square (get-square x z)))
                            (set-n1~ (square-t1 square) (get-normal x (+ z 1)))
                            (set-n2~ (square-t1 square) (get-normal (+ x 1) (+ z 1)))
                            (set-n3~ (square-t1 square) (get-normal (+ x 1) z))
                            (set-n1~ (square-t2 square) (get-normal (+ x 1) z))
                            (set-n2~ (square-t2 square) (get-normal x z))
                            (set-n3~ (square-t2 square) (get-normal x (+ z 1))))))))
                            
          ;; add light
          (new Light-Ambient
            x: 100.
            y: 0.
            z: 100.
            parent: self)))))))
