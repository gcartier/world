;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Zones
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.zone jazz


(import (jazz.component)
        (jazz.io)
        (jazz.geometry)
        (jazz.opengl.glew)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (world)
        (world.actor)
        (world.album)
        (world.area)
        (world.atlas)
        (world.audio)
        (world.autoload)
        (world.block)
        (world.camera)
        (world.chunk)
        (world.client.tier)
        (world.configure)
        (world.creature)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.entity)
        (world.entities)
        (world.expanse)
        (world.face)
        (world.foreign)
        (world.gadget)
        (world.generation)
        (world.generation.base)
        (world.generation.block)
        (world.generation.building)
        (world.generation.rendering)
        (world.geometry)
        (world.gravity)
        (world.grid)
        (world.history)
        (world.homogeneous)
        (world.id)
        (world.index)
        (world.info)
        (world.instantiate)
        (world.interface.bars)
        (world.interface.documents)
        (world.interface.inventory)
        (world.lava)
        (world.light)
        (world.lighting)
        (world.motion)
        (world.music)
        (world.network)
        (world.planet)
        (world.player)
        (world.polygon)
        (world.procedural)
        (world.profiling)
        (world.random)
        (world.redstone)
        (world.region)
        (world.render)
        (world.renderer)
        (world.scene)
        (world.scripter)
        (world.section)
        (world.sector)
        (world.settings)
        (world.skybox)
        (world.spawn)
        (world.sun)
        (world.support)
        (world.syntax (phase syntax))
        (world.tag)
        (world.task)
        (world.texture)
        (world.tier)
        (world.triangle)
        (world.water)
        (world.work))


;;;
;;;; Zone
;;;


(definition protected day-span <fl>
  24000.)

(definition protected dawn-daytime <fl>
  6000.)

(definition protected day-daytime <fl>
  12000.)

(definition protected dusk-daytime <fl>
  18000.)

(definition protected night-daytime <fl>
  0.)


(definition delay-updating? <bool>
  (world-setting 'world.delay-updating? #t))

(definition report-updating? <bool>
  (world-setting 'world.report-updating? #f))


(definition show-sections? <bool>
  (world-setting 'world.show-sections? #f))

(definition show-chunks? <bool>
  (world-setting 'world.show-chunks? #f))


(class Zone extends Scene
  
  
  (property title                   <string+>    initialize #f              accessors generate)
  (property start-mode              <symbol>     initialize #f              accessors generate)
  (property start-distance          <fl+>        initialize #f              accessors generate)
  (property start-spawnpoint        <vertex+>    initialize #f              accessors generate)
  ;; change default from #f to 0 for now and when we start using full 3d regions
  ;; put it back to #f and make it so minecraft zones have truncate-y = 0 by default
  (property truncate-y              <fx+>        initialize 0               accessors generate)
  (property missile-behavior        <symbol>     initialize 'absorb         accessors generate)
  (property ambient-color           <f32vector+> initialize #f              accessors generate)
  (property sun-color               <f32vector+> initialize #f              accessors generate)
  (property sun-cycle?              <bool>       initialize #t              accessors generate)
  (property day-duration            <object>     initialize 1200.           accessors generate)
  (property start-time              <object>     initialize 'day            accessors generate)
  (property start-skybox            <object>     initialize #f              accessors generate)
  (property atlas-name              <object>     initialize #f              accessors generate)
  (property prepare-script          <object>     initialize #f              accessors generate)
  (property start-script            <object>     initialize #f              accessors generate)
  (property draw-me?                <bool>       initialize #t              accessors generate)
  (property first-time?             <bool>       initialize #t              accessors generate)
  (property level-dir               <Directory>  initialize #f              accessors generate)
  (property dimension               <symbol>     initialize 'over           accessors generate)
  (property player-glow             <fl>         initialize -1.             accessors generate)
  (property seed                    <object>     initialize #f              accessors generate)
  (property properties              <object>     initialize '()             accessors generate)
  
  ;; world override properties
  (property ambient-gravity         <object>     initialize default-gravity accessors generate)
  (property jump-impulsion          <object>     initialize default-jump    accessors generate)
  (property start-grid?             <object>     initialize #f              accessors generate)
  (property start-axes?             <object>     initialize #f              accessors generate)


  (slot settings                    <object>     initialize #f                        getter generate)
  (slot regions-dir                 <Directory>  initialize #f                        getter explicit)
  (slot regions-mutex               <object>     initialize (make-mutex 'regions)     getter generate)
  (slot region-access-mutexes       <table>      initialize #f                        getter generate)
  (slot regions                     <table>      initialize #f                        getter generate)
  (slot debug-sections?             <bool>       initialize #f                        accessors generate)
  (slot sector-size                 <fx>         initialize 16                        getter generate)
  (slot sector-radius               <fl>         initialize #f                        getter generate)
  (slot sector-diameter             <fl>         initialize #f                        getter generate)
  (slot sector/area-ratio           <fx>         initialize #f                        getter generate)
  (slot sectors-generating          <fx>         initialize 0                         getter generate)
  (slot sectors-generated           <fx>         initialize 0                         getter generate)
  (slot sectors-mutex               <object>     initialize #f                        getter generate)
  (slot debug-sectors?              <bool>       initialize #f                        accessors generate)
  (slot areas                       <table>      initialize #f                        getter generate)
  (slot area-size                   <fx>         initialize 2                         getter generate)
  (slot debug-areas?                <bool>       initialize #f                        accessors generate)
  (slot expanses                    <table>      initialize #f                        getter generate)
  (slot assets                      <object>     initialize '()                       getter generate)
  (slot players                     <list>       initialize '()                       getter generate)
  (slot actors                      <list>       initialize '()                       getter generate)
  (slot entities                    <list>       initialize '()                       getter generate)
  (slot gravities                   <list>       initialize '()                       getter generate)
  (slot gadgets                     <list>       initialize '()                       getter generate)
  (slot marks                       <list>       initialize '()                       getter generate)
  (slot simulations                 <table>      initialize (make-table test: eq?)    getter generate)
  (slot generator                   <Generator>  initialize #f                        accessors generate)
  (slot draw-procedures             <object>     initialize '()                       getter generate)
  (slot draw-procedure-names        <object>     initialize #f                        getter generate)
  (slot destroy-hooks               <list>       initialize '()                       getter generate)
  (slot ready?                      <bool>       initialize #f                        accessors generate)
  (slot shutdown?                   <bool>       initialize #f                        getter generate)
  (slot shutdown-complete?          <bool>       initialize #f                        getter generate)
  (slot shutdown-mutex              <bool>       initialize (make-mutex 'shutdown)    getter generate)
  (slot editable?                   <bool>       initialize #t                        accessors generate)
  (slot editable-warned?            <bool>       initialize #f                        accessors generate)
  (slot generate-thread             <object>     initialize #f                        accessors generate)
  (slot lighting                    <Lighting>   initialize (new Lighting)            accessors generate)
  (slot block-lighting              <Lighting>   initialize (new Lighting)            accessors generate)
  (slot daytime                     <fl>         initialize 0.                        getter generate)
  (slot daylight                    <fl>         initialize 0.                        accessors generate)
  (slot sun                         <Sun+>       initialize #f                        accessors generate)
  (slot sun-angle                   <fl>         initialize -.20                      accessors generate)
  (slot skybox                      <Skybox+>    initialize #f                        accessors generate)
  (slot designer                    <object>     initialize #f                        accessors generate)
  (slot level-file                               initialize #f)
  (slot level-state                              initialize #f)
  (slot opened-chest                             initialize #f                        accessors generate)
  (slot inventory-blocks                         initialize (make-vector 63 #f)       getter generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (definition default-ambient-color
    (dye .1 .05 0. 1.))
  
  
  (method protected virtual (welcome?)
    #f)
  
  
  ;; quicky for tests
  (method protected virtual (planets?)
    #f)
  
  
  (method override (install rest)
    (nextmethod rest)
    (set-current-zone self))
  
  
  (method override (finish rest)
    (define (effective-ambient-color)
      (let ((ambient-color (world-setting 'world.ambient-color 'default)))
        (cond ((not ambient-color)
               (dye 0. 0. 0. 1.0))
              ((eq? ambient-color 'default)
               default-ambient-color)
              (else
               ambient-color))))
    
    (nextmethod rest)
    (load-point 'zone-prepare)
    (when (window?)
      (prepare-blocks)
      (load-point 'zone-blocks))
    (when (window?)
      (prepare-draw)
      (load-point 'zone-draw))
    (setup-me~ (current-tier))
    (set! draw-me? (world-setting 'world.draw-me? #t))
    (set! ambient-color (or ambient-color (effective-ambient-color)))
    (set! sun-color (or sun-color (world-setting 'world.sun-color #f) (dye 1.0 1.0 1.0 1.0)))
    (set! sun-cycle? (and sun-cycle? (world-setting 'world.sun-cycle? #t)))
    (set! start-time (world-setting 'world.start-time 'dawn))
    (set! day-duration (world-setting 'world.day-duration 1200.))
    (set! draw-procedure-names (make-table test: eq?))
    (set! debug-sections? (or show-sections? show-chunks? (world-setting 'world.debug-sections? #f)))
    (when (window?)
      (register-task 'generate generate-task)
      @generate-tasks
      (begin
        (register-task 'generate2 generate-task2)
        (register-task 'generate3 generate-task3)
        (register-task 'generate4 generate-task4)
        (register-task 'generate5 generate-task5))
      (register-task 'instantiate instantiate-task)
      (register-task 'render render-task))
    (when (current-me+)
      (register-task 'player player-task))
    (register-task 'missile missile-task)
    (register-task 'tick tick-task)
    (register-task 'sun sun-task)
    (register-task 'spawn spawn-task)
    (register-task 'redstone redstone-task)
    (register-task 'gravity gravity-task)
    (register-task 'lava lava-task)
    (register-task 'water water-task)
    (register-task 'distance distance-task)
    (register-task 'eat eat-task)
    (when (window?)
      (register-task 'audio audio-task)
      (register-task 'music music-task))
    (unless (eq? tier-kind 'local)
      (register-task 'network network-task)
      (register-task 'alive alive-task))
    (load-point 'zone-tasks)
    (when (window?)
      (register-entity-classes)
      (prepare-skybox-program)
      (prepare-skybox)
      (load-point 'zone-skybox))
    (initialize-spawned)
    (load-point 'zone-spawned)
    (set-daytime (effective-daytime start-time))
    (set! sun-angle (daytime->sun-angle daytime))
    (load-point 'zone-sun))
  
  
  (method (initialize-zone)
    (let ((world (current-world)))
      (setup-persistence)
      (setup-seed)
      (setup-generator)
      (setup-regions)
      (setup-sectors)
      (setup-areas)
      (setup-expanses)
      (setup-overrides)
      (setup-game)
      (setup-camera)
      (setup-player)
      (setup-children)
      (setup-history~ world)
      (enter-tier)
      (when (window?)
        (start-ambience)
        (start-music)
        (install-interface)
        (display-welcome))))
  
  
  (method (setup-persistence)
    (when (not level-dir)
      (set! level-dir (new-directory~ (get-directory) "level"))))
  
  
  (method (setup-seed)
    (if seed
        (init-seed seed)
      (let ((seed (world-setting 'world.seed (random-monotonic))))
        (set-property~ designer self 'seed seed)
        (init-seed seed))))
  
  
  (method (setup-generator)
    (let ((file (new-file~ (get-directory) ".generator")))
      (set! generator (if (exists?~ file)
                          (instantiate~ (read-form file))
                        (new Empty-Generator)))))
  
  
  (method (setup-overrides)
    (let ((world (current-world)))
      (when (specified? ambient-gravity)
        (set-ambient-gravity~ world ambient-gravity))
      (when (specified? jump-impulsion)
        (set-jump-impulsion~ world jump-impulsion))
      (set-grid?~ world start-grid?)
      (set-axes?~ world start-axes?)))
  
  
  (method protected virtual (setup-game)
    (set-current-game (new World-Game)))
  
  
  (method protected virtual (setup-camera)
    )
  
  
  (method protected virtual (setup-player)
    (let ((me (current-me+)))
      (when me
        (add-element me))))
  
  
  ;; backward compatibility
  (method protected virtual (setup-children)
    (let ((touched? #f))
      (for-each (lambda (obj)
                  (when (is? obj Element)
                    (add-element obj)
                    (when (component-in-descendants?~ designer obj)
                      (with-designer obj
                        (lambda (des container)
                          (remove-child~ designer obj)
                          (set-parent~ obj container)
                          (add-child~ des obj container form: (get-form~ obj))
                          (set! touched? #t))))))
                children)
      (when touched?
        (save~ designer))))
  
  
  (method protected virtual (enter-tier)
    (enter~ (current-tier)))
  
  
  (method protected virtual (start-ambience)
    (let ((ambience (current-ambience)))
      (initial-ambience~ ambience)))
  
  
  (method protected virtual (start-music)
    (let ((music (current-music)))
      (initial-music~ music)))
  
  
  (method protected virtual (stop-ambience)
    (let ((ambience (current-ambience)))
      (close-ambience~ ambience)))
  
  
  (method protected virtual (stop-music)
    (let ((music (current-music)))
      (close-music~ music)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (or title "New")))))
  
  
  (method protected virtual (populate-zone)
    )
  
  
  (method protected virtual (generate-visual sector)
    (site (visual on?: #t)
      (if show-blocking?
          (parameterize ((non-blocking? #t))
            (instantiate-visual sector))
        (instantiate-visual sector))))
  
  
  @generate-tasks
  (method (generate-visual2 sector)
    (site (visual2 on?: #t)
      (instantiate-visual sector)))
  
  
  @generate-tasks
  (method (generate-visual3 sector)
    (site (visual3 on?: #t)
      (instantiate-visual sector)))
  
  
  @generate-tasks
  (method (generate-visual4 sector)
    (site (visual4 on?: #t)
      (instantiate-visual sector)))
  
  
  @generate-tasks
  (method (generate-visual5 sector)
    (site (visual5 on?: #t)
      (instantiate-visual sector)))
  
  
  (method protected virtual (generate-physical area revision-update?)
    (site (physical on?: #t)
      (instantiate-physical area revision-update?)))
  
  
  (method protected virtual (zone-ready)
    )
  
  
  (method (get-zone-directory)
    (let ((moniker (get-moniker)))
      (and moniker
           (get-parent~ moniker))))
  
  
  (method (zone-path kind)
    (let ((world (current-world)))
      (let ((moniker (get-moniker)))
        (let ((directory (get-tiers-directory~ world kind)))
          (let (iter (moniker (get-parent~ moniker)) (path '()))
            (if (pathname=? moniker directory)
                (join path "/")
              (let ((parent (get-parent~ moniker)))
                (if (not parent)
                    #f
                  (iter parent (cons (get-base~ moniker) path))))))))))
  
  
  (method (zone-brother path)
    (new-file~ (get-zone-directory) path))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (register-destroy-hook proc)
    (set! destroy-hooks (cons proc destroy-hooks)))
  
  
  (method (unregister-destroy-hook proc)
    (set! destroy-hooks (remove! proc destroy-hooks)))
  
  
  (method override (add-child child)
    (set! children (cons child children)))
  
  
  (method override (destroy-component)
    (destroy))
  
  
  (method override (destroy)
    (let ((world (current-world)))
      (shutting-down
        (lambda ()
          (when (window?)
            (unpause-world~ world))
          (shutdown-selection~ world)
          (when (window?)
            (uninstall-interface))
          (stop-tasks)
          (save-zone)
          (save-designer)
          (for-each (lambda (proc)
                      (proc))
                    destroy-hooks)
          (free-generator)
          (free-eye-sectors)
          (free-regions)
          (when (window?)
            (stop-ambience)
            (stop-music))))))
  
  
  (method (shutting-down thunk)
    (dynamic-wind
      (lambda ()
        (mutex-lock! shutdown-mutex)
        (set! shutdown? #t))
      (lambda ()
        (unless shutdown-complete?
          (thunk)))
      (lambda ()
        (set! shutdown? #f)
        (set! shutdown-complete? #t)
        (mutex-unlock! shutdown-mutex))))
  
  
  (method protected virtual (save-zone)
    (let ((tier (current-tier))
          (world (current-world))
          (motion (current-motion)))
      (define (save)
        (set-property~ designer self 'first-time? #f))
      
      (define (save-mode)
        (set-property~ designer self 'start-mode (if (person-motion?) 'first-person 'free-camera)))
      
      (define (save-distance)
        (when (is? motion Target-Motion)
          (set-property~ designer self 'start-distance (get-desired-distance~ motion))))
      
      (save)
      ;; until these properties are in the player at
      ;; least don't save them when no actual player
      (when (current-me+)
        (save-mode)
        (save-distance))
      (save-me~ tier)
      (when (window?)
        (save-chest save-region?: #t)
        (save-inventory))
      (save-level-state)))
  
  
  (method protected (save-designer)
    (save~ designer))
  
  
  (method (install-interface)
    (let ((world (current-world))
          (interface (current-interface)))
      (set-visible?~ (child~ interface 'bag) #f)
      (view-inventory~ (child~ interface 'belt))
      (set-visible?~ (child~ interface 'belt) (show-belt?))
      (set-visible?~ (child~ interface 'chest) #f)
      (set-visible?~ (child~ interface 'chat) (not (local?)))
      (set-visible?~ (child~ interface 'command) #f)
      (set-visible?~ (child~ interface 'compass) (show-compass?))
      (set-visible?~ (child~ interface 'combat) (show-combat?))
      (set-compass-visible?~ world (show-compass?))
      (reset-cache~ (child~ interface 'map))
      ;; aec quicky
      (when (creator?)
        (let ((bar (child~ interface 'edition)))
          (set-location~ bar (if (local?) '(-266 -10) '(-332 -10)))))
      ;; quick solution
      (let ((connected? (not (local?)))
            (bar (child~ interface 'main)))
        (set-visible?~ (child~ bar 'who-pane) connected?)
        (set-visible?~ (child~ bar 'chat-pane) connected?)
        (set-visible?~ (child~ bar 'command-message) connected?)
        (layout-bar bar 'horizontal)
        (layout-view~ interface))))
  
  
  (method (uninstall-interface)
    (let ((world (current-world))
          (interface (current-interface)))
      (set-visible?~ (child~ interface 'bag) #f)
      (set-visible?~ (child~ interface 'belt) #f)
      (set-visible?~ (child~ interface 'chest) #f)
      (set-visible?~ (child~ interface 'chat) #f)
      (set-visible?~ (child~ interface 'command) #f)))
  
  
  (method (display-welcome)
    (when (eq? tier-kind 'client)
      (let ((tier (client-tier))
            (interface (current-interface)))
        (unless (get-welcomed?~ tier)
          (let ((welcome (get-welcome~ tier)))
            (when welcome
              (let ((chat (child~ interface 'chat)))
                (show-welcome~ chat welcome))))
          (set-welcomed?~ tier #t)))))
  
  
  (method protected virtual (show-belt?)
    (let ((world (current-world)))
      (get-show-belt?~ world)))
  
  
  (method protected virtual (show-compass?)
    #t)
  
  
  (method protected virtual (show-combat?)
    #t)
  
  
  ;;;
  ;;;; Tasks
  ;;;
  
  
  (method (start-tasks)
    (when (window?)
      (start-task 'generate)
      @generate-tasks
      (begin
        (start-task 'generate2)
        (start-task 'generate3)
        (start-task 'generate4)
        (start-task 'generate5))
      (start-task 'instantiate)
      (start-task 'render))
    (when (current-me+)
      (start-task 'player))
    (start-task 'missile)
    (start-task 'tick)
    (start-task 'sun)
    (start-task 'spawn)
    (start-task 'redstone)
    (start-task 'gravity)
    (start-task 'lava)
    (start-task 'water)
    (start-task 'distance)
    (start-task 'eat)
    (when (window?)
      (start-task 'audio)
      (start-task 'music))
    (unless (eq? tier-kind 'local)
      (start-task 'network)
      (start-task 'alive))
    (when (window?)
      (thread-base-priority-set! (task-thread 'generate) generate-priority)
      @generate-tasks
      (begin
        (thread-base-priority-set! (task-thread 'generate2) generate-priority)
        (thread-base-priority-set! (task-thread 'generate3) generate-priority)
        (thread-base-priority-set! (task-thread 'generate4) generate-priority)
        (thread-base-priority-set! (task-thread 'generate5) generate-priority))
      (thread-base-priority-set! (task-thread 'instantiate) instantiate-priority)
      (thread-base-priority-set! (task-thread 'render) render-priority))
    (when (current-me+)
      (thread-base-priority-set! (task-thread 'player) player-priority))
    (thread-base-priority-set! (task-thread 'missile) missile-priority)
    (thread-base-priority-set! (task-thread 'tick) tick-priority)
    (thread-base-priority-set! (task-thread 'sun) sun-priority)
    (thread-base-priority-set! (task-thread 'spawn) spawn-priority)
    (thread-base-priority-set! (task-thread 'redstone) redstone-priority)
    (thread-base-priority-set! (task-thread 'gravity) gravity-priority)
    (thread-base-priority-set! (task-thread 'lava) lava-priority)
    (thread-base-priority-set! (task-thread 'water) water-priority)
    (thread-base-priority-set! (task-thread 'distance) distance-priority)
    (thread-base-priority-set! (task-thread 'eat) eat-priority)
    (when (window?)
      (thread-base-priority-set! (task-thread 'audio) audio-priority)
      (thread-base-priority-set! (task-thread 'music) music-priority))
    (unless (eq? tier-kind 'local)
      (thread-base-priority-set! (task-thread 'network) network-priority)
      (thread-base-priority-set! (task-thread 'alive) alive-priority)))
  
  
  (method (stop-tasks)
    (define (stop-simulations)
      (iterate-table simulations
        (lambda (entity task)
          (stop-entity entity))))
    
    (define (stop-entities)
      (for-each stop-entity entities))
  
    (define (stop-entity entity)
      (let ((task (get-task~ entity)))
        (when task
          (stop-task task))))
    
    (let ((world (current-world)))
      (set-render-boost? #f)
      (set-player-boost? #f)
      ;; stop generate before instantiate
      (reset-content)
      (stop-generate)
      @generate-tasks
      (begin
        (stop-generate)
        (stop-generate)
        (stop-generate)
        (stop-generate))
      (stop-task 'generate #f)
      @generate-tasks
      (begin
        (stop-task 'generate2 #f)
        (stop-task 'generate3 #f)
        (stop-task 'generate4 #f)
        (stop-task 'generate5 #f))
      ;; stop instantiate before entities
      (reset-instantiate)
      (stop-task 'instantiate)
      (stop-simulations)
      (stop-entities)
      (stop-task 'sun)
      (stop-task 'spawn)
      (stop-task 'redstone)
      (stop-task 'gravity)
      (stop-task 'lava)
      (stop-task 'water)
      (stop-task 'distance)
      (stop-task 'eat)
      (when (window?)
        (stop-task 'music)
        (stop-task 'audio))
      (when (current-me+)
        (stop-task 'player))
      (stop-task 'missile)
      (stop-task 'tick)
      (unless (eq? tier-kind 'local)
        (stop-task 'network)
        (stop-task 'alive))
      (when (current-me+)
        (set-player-thread~ world #f))
      (when (window?)
        (stop-task 'render)
        (set-render-thread~ world #f))))
  
  
  ;;;
  ;;;; Generator
  ;;;
  
  
  (method (free-generator)
    (when generator
      (free~ generator)
      (set! generator #f)))
  
  
  ;;;
  ;;;; Scripts
  ;;;
  
  
  (definition scripting-prepared?
    #f)
  
  
  (method (prepare-scripting)
    (define (script-code)
      "(module prepare-scripting script (import (world.script)))")
    
    (when (not scripting-prepared?)
      (when (world-setting 'world.worker? (not sejour?))
        (let ((code (script-code)))
          (worker-run #f code
            ;; read
            (lambda (reason)
              )
            ;; walk
            (lambda (reason detail)
              )
            ;; error
            (lambda (reason location stack)
              )
            ;; result
            (lambda (result)
              ))))
      (set! scripting-prepared? #t)))
  
  
  (method (run-script element)
    (unless (world-setting 'world.inhibit-scripts? #f)
      (when (is? element Entity)
        (let ((script (get-script~ element)))
          (run-task~ element script)))))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (player-update)
    (when (current-me+)
      (let ((interface (current-interface+)))
        (when interface
          (let ((character-pane (child~ interface 'character)))
            (view-inventory~ character-pane)
            (update~ character-pane))))))
  
  
  ;;;
  ;;;; Target
  ;;;
  
  
  (proclaim (not warn optimizations))

  
  (method (target-update target poly vert)
    (define (center-info title center (poly #f))
      (let ((section (position-section center))
            (x (fxfloor (vertex-x center)))
            (y (fxfloor (vertex-y center)))
            (z (fxfloor (vertex-z center))))
        (if (not section)
            #f
          (let ((section-index (get-index~ section)))
            (let ((section-x (index-x section-index))
                  (section-y (index-y section-index))
                  (section-z (index-z section-index)))
              (let ((cache-uninitialized 65535)
                    (sections (neighbor-sections section section-x section-y section-z)))
                (with-generate-mutex
                  (lambda ()
                    (let ((bottom-section? (= section-y (cast <fx> (or truncate-y 0))))
                          (cache <u16vector> (initialize-block-cache block-cache cache-uninitialized))
                          (blocks (get-blocks~ section))
                          (data (get-data~ section))
                          (blocklight (get-blocklight~ section))
                          (skylight (get-skylight~ section)))
                      (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                        (vector-ref sections (section-index a b c)))
                      
                      (define (section-index a <fx> b <fx> c <fx>) <fx>
                        (+ (* b 9) (* c 3) a 13))
                      
                      (define (local-index i <fx> j <fx> k <fx>) <fx>
                        (+ (* j 256) (* k 16) i))
                      
                      (define (effective-index i <fx> j <fx> k <fx>) <fx>
                        (* (+ (* j 324) (* k 18) i 343) 4))
                      
                      (define (blocks-get section <World-Section>) <u8vector>
                        (get-blocks~ section))
                      
                      (define (blocklight-get section <World-Section>) <u8vector>
                        (get-blocklight~ section))
                      
                      (define (blocklight-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref blocklight (local-index i j k)))
                      
                      (define (skylight-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref skylight (local-index i j k)))
                      
                      (define (local-block-ref i <fx> j <fx> k <fx>)
                        (u8vector-ref blocks (local-index i j k)))
                      
                      (define (local-data-ref i <fx> j <fx> k <fx>)
                        (u4vector-ref data (local-index i j k)))
                      
                      (define (effective-block-ref i <fx> j <fx> k <fx>) <fx>
                        (let ((index (effective-index i j k)))
                          (let ((value (u16vector-ref cache index)))
                            (if (/= value cache-uninitialized)
                                value
                              (let ((value (field-ref i j k blocks-get u8vector-ref 0 1)))
                                (u16vector-set! cache index value)
                                value)))))
                      
                      (define (effective-light-ref shade <fl> i <fx> j <fx> k <fx>) <fx>
                        (field-ref i j k blocklight-get u4vector-ref 0 0))
                      
                      (define (u4vector-ref field <u8vector> index <fx>) <fx>
                        (let ((byte (u8vector-ref field (quotient index 2))))
                          (if (even? index)
                              (bitwise-and byte #x0F)
                            (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
                      
                      (define (field-ref i <fx> j <fx> k <fx> get-field ref empty bottom) <fx>
                        (define (bind-i a <fx> i <fx>)
                          (define (bind-j b <fx> j <fx>)
                            (define (bind-k c <fx> k <fx>)
                              (let ((section (section-ref a b c)))
                                (if (not section)
                                    (if (and bottom-section? (= b -1)) bottom empty)
                                  (let ((field (get-field section)))
                                    (if (not field)
                                        (if (and bottom-section? (= b -1)) bottom empty)
                                      (ref field (local-index i j k)))))))
                            
                            (cond ((< k 0) (bind-k -1 (+ 16 k)))
                                  ((> k 15) (bind-k 1 (- k 16)))
                                  (else (bind-k 0 k))))
                          
                          (cond ((< j 0) (bind-j -1 (+ 16 j)))
                                ((> j 15) (bind-j 1 (- j 16)))
                                (else (bind-j 0 j))))
                        
                        (cond ((< i 0) (bind-i -1 (+ 16 i)))
                              ((> i 15) (bind-i 1 (- i 16)))
                              (else (bind-i 0 i))))
                      
                      (define (compute-lighting shade <fl> i <fx> j <fx> k <fx> ax <fx> ay <fx> az <fx> bx <fx> by <fx> bz <fx> cx <fx> cy <fx> cz <fx> dx <fx> dy <fx> dz <fx>)
                        (format "{a} {a} {a} {a}"
                                (effective-light-ref shade (+ i ax) (+ j ay) (+ k az))
                                (effective-light-ref shade (+ i bx) (+ j by) (+ k bz))
                                (effective-light-ref shade (+ i cx) (+ j cy) (+ k cz))
                                (effective-light-ref shade (+ i dx) (+ j dy) (+ k dz))))
                      
                      (define (ambient-light i <fx> j <fx> k <fx> vert)
                        (let ((origin (vertex-& (vertex-& vert (vertex& (cast <fl> x) (cast <fl> y) (cast <fl> z))) (vertex& .5 .5 .5)))
                              (normal (get-normal~ poly)))
                          (generic-lighting i j k origin normal compute-lighting no-shade)))
                      
                      (define (block-info i <fx> j <fx> k <fx>)
                        (let ((id (local-block-ref i j k))
                              (data (local-data-ref i j k))
                              (blocklight (blocklight-ref i j k))
                              (skylight (skylight-ref i j k)))
                          (let ((block (id/variant-id->block id data)))
                            (append (list (cons title (get-name~ block))
                                          (cons "id" id)
                                          (cons "data" data)
                                          (cons "block light" blocklight)
                                          (cons "sky light" skylight))
                                    (if (and poly (programmer?))
                                        (list (cons "section" (format "{a} {a} {a}" section-x section-y section-z))
                                              (cons "coordinates" (format "{a} {a} {a}" i j k))
                                              (cons "location" (present-location (position->location (polygon-position poly))))
                                              (cons "ambient" (ambient-light i j k vert)))
                                      '())))))
                      
                      (define (present-location loc)
                        (format "{a} {a} {a}"
                                (index-x loc)
                                (index-y loc)
                                (index-z loc)))
                      
                      (let ((i (- x (* section-x 16)))
                            (j (- y (* section-y 16)))
                            (k (- z (* section-z 16))))
                        (block-info i j k)))))))))))
    
    (define (update-info)
      (if (not poly)
          (begin
            (unregister-info 'block)
            (unregister-info 'fore)
            (let ((eye (get-position~ (current-camera))))
              (let ((info (center-info "Eye" eye)))
                (if (not info)
                    (unregister-info 'eye)
                  (register-info 'eye
                    (lambda (add-section add-info)
                      (let ((section (add-section "Eye")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info))))))))
        (let ((game (current-game)))
          (with-polygon-interaction~ game poly
            (lambda (poly block fore)
              (let ((info (center-info "Block" block poly)))
                (register-info 'block
                  (lambda (add-section add-info)
                    (let ((section (add-section "Block")))
                      (for-each (lambda (info)
                                  (add-info section (car info) (cdr info)))
                                info)))))
              (let ((info (center-info "Fore" fore)))
                (if (not info)
                    (unregister-info 'fore)
                  (register-info 'fore
                    (lambda (add-section add-info)
                      (let ((section (add-section "Fore")))
                        (for-each (lambda (info)
                                    (add-info section (car info) (cdr info)))
                                  info)))))))))
        (unregister-info 'eye)))
    
    (update-info))
  
  
  (proclaim (warn optimizations))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (get-directory)
    (get-parent~ (get-moniker)))
  
  
  (method (get-moniker)
    (get-origin~ form))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (let ((world (current-world)))
      (when #t @buggy (neq? flag (get-modified?~ designer))
        (set-modified?~ designer flag)
        (update-title~ world))))
  
  
  (method (read-element element property)
    (read-property element property))
  
  
  (method (write-element element property value)
    (with-designer element
      (lambda (designer container)
        (set-property~ designer element property value))))
  
  
  (method (with-designer element proc)
    (define (toplevel elem)
      (let ((parent (get-parent~ elem)))
        (if (or (not parent) (eq? parent self) (is? parent Chunk-Container))
            elem
          (toplevel parent))))
    
    (let ((top (toplevel element)))
      (with-chunk-designer (get-designer-chunk~ top)
        proc)))
  
  
  (method (with-chunk-designer chunk proc)
    (assert chunk)
    (let ((designer (cache-designer~ chunk)))
      (prog1 (proc designer (get-reference~ designer))
        (save-designer~ chunk)
        (modified~ chunk)
        (save-region~ (get-region~ chunk)))))
  
  
  (method (create-block-entity model position)
    (let ((chunk (position-chunk position)))
      (with-chunk-designer chunk
        (lambda (designer container)
          (let ((entity (new Block-Entity model: model position: position)))
            (set-designer-chunk~ entity chunk)
            entity)))))


  (method (need-script obj (create?: create? #t))
    (or (get-script~ obj)
        (and create?
             (let ((script (new Script parent: obj)))
               (if (is? obj Block-Entity)
                   (let ((pos (get-position~ obj))
                         (model (get-model~ obj)))
                     (let ((chunk (position-chunk pos)))
                       (with-chunk-designer chunk
                         (lambda (designer container)
                           (add-child~ designer obj container properties: (list 'position pos 'model model proxy?: #t))
                           (add-child~ designer script obj)
                           (add-element obj chunk)
                           (setup-actions~ obj)
                           script))))
                 (with-designer obj
                   (lambda (designer container)
                     (add-child~ designer script obj)))
                 script)))))
  
  
  ;;;
  ;;;; Prologue
  ;;;
  
  
  (method (check-prologue (size: size #f))
    (when (and first-time? (world-setting 'world.show-prologue? #t) (window?))
      (show-prologue size: size)
      (save-designer)))
  
  
  (method (show-prologue (size: size #f))
    (open-world-document (prologue-file) class: World-Formatted-Text-View size: (or size {Dimension 800 600})))
  
  
  (method (prologue-file)
    (zone-brother "Prologue.ftx"))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method (draw-zone)
    (let ((world (current-world)))
      (draw-sectors)
      (site (draw-procedures on?: #f parent: draw-world)
        (when (not-null? draw-procedures)
          (for-each (lambda (proc)
                      (proc))
                    draw-procedures)))
      (if (effective-draw-gadgets?~ world)
          (draw-gadgets)
        (draw-drawable-gadgets))
      (when (get-draw-marks?~ world)
        (draw-marks))
      (when (get-draw-atlas?~ world)
        (draw-atlas))
      (when (and sun (get-visible?~ sun))
        (register-sun))
      (gl-check-error)))
  
  
  (method (registered-draw name)
    (table-ref draw-procedure-names name #f))
  
  
  (method (register-draw name proc)
    (when (registered-draw name)
      (unregister-draw name))
    (set! draw-procedures (cons proc draw-procedures))
    (table-set! draw-procedure-names name proc))
  
  
  (method (unregister-draw name)
    (let ((proc (table-ref draw-procedure-names name)))
      (set! draw-procedures (remove! proc draw-procedures))
      (table-clear draw-procedure-names name)))
  
  
  ;;;
  ;;;; Blocks
  ;;;
  
  
  (method protected virtual (album-name)
    'block)
  
  
  (method protected virtual (create-album)
    (let ((name (or atlas-name (album-name))))
      (or (registered-album name)
          (let ((atlas (create-atlas)))
            (let ((textures (create-textures atlas)))
              (when (complete-album?)
                (complete~ atlas))
              (update-textures-subuvs atlas)
              (let ((album (new Album atlas textures)))
                (register-album name album)
                album))))))
  
  
  (method protected virtual (complete-album?)
    #t)
  
  
  (method protected virtual (create-atlas)
    (create-block-atlas))
  
  
  (method protected virtual (create-textures atlas)
    (list->table
      (list
        ;; clamp to edge is necessary for joins like between the rails
        (cons 'clamp (create-texture atlas wrap: GL_CLAMP_TO_EDGE))
        (cons 'repeat (create-texture atlas min-filter: 'nearest)))))
  
  
  (method (prepare-blocks)
    (let ((world (current-world)))
      (let ((album (create-album)))
        (let ((atlas (get-atlas~ album)))
          (let ((texture (get-texture~ album 'clamp))
                (texture-repeat (get-texture~ album 'repeat)))
            (prepare-block~ world atlas texture texture-repeat)
            (let ((opaque-material (get-material~ (cast <Rendering> (opaque-rendering))))
                  (transparent-material (get-material~ (cast <Rendering> (transparent-rendering))))
                  (coverage-material (get-material~ (cast <Rendering> (coverage-rendering))))
                  (water-material (get-material~ (cast <Rendering> (water-rendering))))
                  (wet-material (get-material~ (cast <Rendering> (wet-rendering))))
                  (multitexture-material (get-material~ (cast <Rendering> (multitexture-rendering)))))
              (prepare-materials~ world opaque-material transparent-material coverage-material water-material wet-material multitexture-material)))))))

  
  (method (make-block-atlas (adder: adder #f))
    (let ((world (current-world)))
      (let ((atlas (new Atlas)))
        (when (window?)
          (iterate-assets~ world
            (lambda (assets)
              (add-assets-directory-if-exists~ atlas assets '("tile"))))
          (when adder
            (adder atlas)))
        atlas)))
  
  
  (method protected virtual (sample-program-image program)
    (case program
      ((opaque) "stone")
      ((transparent) "flower_rose")
      (else "wool_colored_light_blue")))
  
  
  ;;;
  ;;;; Skybox
  ;;;
  
  
  (method protected virtual (prepare-skybox)
    (set! skybox (and start-skybox (let ((skybox (find-skybox start-skybox)))
                                     (when skybox
                                       (prepare~ skybox))
                                     skybox))))
  
  
  (method (install-skybox sky)
    (prepare~ sky)
    (set! skybox sky))
  
  
  (method (remove-skybox)
    (set! skybox #f))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method protected virtual (mouse-track elapse dx dy)
    #f)
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method (add-element obj (chunk #f))
    (define (add-player)
      (set! players (cons obj players))
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-actor)
      (set! actors (cons obj actors))
      (set! entities (cons obj entities)))
    
    (define (add-gravity)
      (set! gravities (cons obj gravities))
      (set! gadgets (cons obj gadgets)))
    
    (define (add-gravity-well)
      (set! gravities (cons obj gravities)))
    
    (define (add-light)
      (set! gadgets (cons obj gadgets))
      (setup-lighting))
    
    (define (add-gadget)
      (set! gadgets (cons obj gadgets)))
    
    (define (add-entity)
      (set! entities (cons obj entities)))
    
    (if (and (client?) (simulated?~ obj))
        (begin
          (when (is? obj Player)
            (set! players (cons obj players)))
          (link-entity (element-section-index obj) obj)
          (start-simulation obj))
      (typecase obj
        ((Player) (add-player))
        ((Actor) (add-actor))
        ((Gravity) (add-gravity))
        ((Gravity-Well) (add-gravity-well))
        ((Light) (add-light))
        ((Gadget) (add-gadget))
        ((Entity) (add-entity)))
      (when (is? obj Entity)
        (let ((index (element-section-index obj)))
          (link-entity index obj)
          (set-designer-chunk~ obj (or chunk (index-chunk index)))))
      (when (and (server?) (window?) (is? obj Player) (not (get-me?~ obj)))
        (start-simulation obj))
      (when (is? obj Creature)
        (add-spawned obj))
      (unless (client?)
        (when (is? obj Entity)
          (run-script obj))))
    obj)
  
  
  (method (remove-element obj)
    (define (remove-player)
      (set! players (remove! obj players))
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-actor)
      (set! actors (remove! obj actors))
      (set! entities (remove! obj entities)))
    
    (define (remove-gravity)
      (set! gravities (remove! obj gravities))
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-gravity-well)
      (set! gravities (remove! obj gravities)))
    
    (define (remove-light)
      (set! gadgets (remove! obj gadgets))
      (setup-lighting))
    
    (define (remove-gadget)
      (set! gadgets (remove! obj gadgets)))
    
    (define (remove-entity)
      (set! entities (remove! obj entities)))
    
    (if (and (client?) (simulated?~ obj))
        (begin
          (cease-simulation obj)
          (when (is? obj Player)
            (set! players (remove! obj players)))
          (unlink-entity obj))
      (unless (client?)
        (when (is? obj Entity)
          (cease-entity~ obj)))
      (when (and (server?) (window?) (is? obj Player) (not (get-me?~ obj)))
        (cease-simulation obj))
      (when (is? obj Creature)
        (remove-spawned obj))
      (typecase obj
        ((Player) (remove-player))
        ((Actor) (remove-actor))
        ((Gravity) (remove-gravity))
        ((Gravity-Well) (remove-gravity-well))
        ((Light) (remove-light))
        ((Gadget) (remove-gadget))
        ((Entity) (remove-entity)))
      (when (is? obj Entity)
        (unlink-entity obj)
        (set-designer-chunk~ obj #f)))
    (close~ obj))
  
  
  (method (add-simulated obj)
    (let ((index (element-section-index obj)))
      (link-entity index obj)))
  
  
  (method (remove-simulated obj)
    (unlink-entity obj))
  
  
  (method (link-entity index entity)
    (let ((expanse (index-expanse index)))
      (add-entity~ expanse entity)
      (set-expanse~ entity expanse)))
  
  
  (method (unlink-entity entity)
    (remove-entity~ (get-expanse~ entity) entity)
    (set-expanse~ entity #f))
  
  
  (method (update-entity entity old-position)
    ;; for setup-children backward compatibility
    (when level-dir
      (let ((old-index (position-section-index old-position))
            (new-index (element-section-index entity)))
        (unless (equal? old-index new-index)
          (unlink-entity entity)
          @should-only-be-done-by-set-property-as-it-can-put-an-entity-in-an-incorrect-section-designer
          (when (and (is? (get-parent~ entity) Chunk-Container)
                     (get-chunk~ (get-parent~ entity)))
            (with-section-designer (index-section old-index)
              (lambda (designer container)
                (remove-child~ designer entity)))
            (with-section-designer (index-section new-index)
              (lambda (designer container)
                (set-parent~ entity container)
                (add-child~ designer entity container form: (get-form~ entity)))))
          (link-entity new-index entity)))))
  
  
  (method (find-element predicate)
    (continuation-capture
      (lambda (return)
        (iterate-elements
          (lambda (element)
            (when (predicate element)
              (continuation-return return element))))
        #f)))
  
  
  (method (find-named-element name)
    (find-element
      (lambda (element)
        (eq? (get-name~ element) name))))
  
  
  (method (find-gadget predicate)
    (find-if predicate gadgets))
  
  
  (method (iterate-players proc)
    (for-each proc players))
  
  
  (method (iterate-actors proc)
    (for-each proc actors))
  
  
  (method (iterate-entities proc)
    (for-each proc entities))
  
  
  (method (iterate-gadgets proc)
    (for-each proc gadgets))
  
  
  (method (iterate-elements proc)
    (for-each proc entities))
  
  
  (method (draw-me)
    (let ((me (current-me)))
      (draw~ me)))
  
  
  (method (element-at vert)
    #f
    @convert^^^
    (continuation-capture
      (lambda (return)
        (let ((area (index-area (position-area-index vert))))
          (iterate-area-elements area
            (lambda (obj)
              (when (and (get-visible?~ obj)
                         (vertex=? (get-position~ obj) vert))
                (continuation-return return obj)))))
        #f)))
  
  
  (method (element-near vert)
    #f
    @convert^^^
    (let ((x (vertex-x vert))
          (y (vertex-y vert))
          (z (vertex-z vert))
          ;; open test quicky to improve
          (radius .7))
      (let ((left (- x radius))
            (bottom (- y radius))
            (back (- z radius))
            (right (+ x radius))
            (top (+ y radius))
            (front (+ z radius)))
        (continuation-capture
          (lambda (return)
            (with-area-retainer 'element-near
              (lambda (retain)
                (iterate-position-neighbor-areas vert 1 #f
                  (lambda (area index retain?)
                    (when retain?
                      (retain area))
                    (iterate-area-elements area
                      (lambda (obj)
                        (when (and (get-visible?~ obj)
                                   (let ((x (get-x~ obj))
                                         (y (get-y~ obj))
                                         (z (get-z~ obj)))
                                     (and (>= x left)
                                          (>= y bottom)
                                          (>= z back)
                                          (<  x right)
                                          (<  y top)
                                          (<  z front))))
                          (continuation-return return obj))))))))
            #f)))))
  
  
  (method (validate-elements)
    (iterate-elements
      (lambda (element)
        (assert (real? (get-x~ element)))
        (assert (real? (get-y~ element)))
        (assert (real? (get-z~ element)))
        (assert (real? (get-red~ element)))
        (assert (real? (get-green~ element)))
        (assert (real? (get-blue~ element)))
        (assert (real? (get-alpha~ element))))))
  
  
  ;;;
  ;;;; Creature
  ;;;
  
  
  (method (get-creatures)
    (collect-type Creature actors))
  
  
  (method (change-creature-models? value)
    (set-creature-models? value)
    (for-each (lambda (creature)
                (update-model~ creature anchor?: #t))
              spawned-creatures))
  
  
  ;;;
  ;;;; Simulation
  ;;;
  
  
  (method (start-simulation actor)
    (unless (table-ref simulations actor #f)
    (let ((procedure
            (lambda (task)
              (simulation-task~ actor task))))
      (let ((task (new Task 'simulation procedure)))
        (start-task task)
        (set-task~ actor task)
        (table-set! simulations actor task)
        (thread-base-priority-set! (get-thread~ task) simulation-priority)))))
  
  
  (method (cease-simulation actor)
    (let ((task (get-task~ actor)))
      (table-clear simulations actor)
      (cease-task task)))
  
  
  ;;;
  ;;;; Regions
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-regions)
    (with-regions-mutex
      (lambda ()
        (set! region-access-mutexes (make-table test: equal?))
        ;; temporary simplification by having processor retain everything
        (set! regions (make-table test: equal? weak-values: (not (processing?)))))))
  
  
  (method (with-regions-mutex thunk)
    (mutex-lock! regions-mutex)
    (prog1 (thunk)
      (mutex-unlock! regions-mutex)))
  
  
  (method (with-region-access-mutex index thunk)
    (define (region-access-mutex index)
      (with-regions-mutex
        (lambda ()
          (or (table-ref region-access-mutexes index #f)
              (let ((mutex (make-mutex 'region-access)))
                (table-set! region-access-mutexes index mutex)
                mutex)))))
    
    (let ((mutex (region-access-mutex index)))
      (mutex-lock! mutex)
      (prog1 (thunk)
        (mutex-unlock! mutex))))
  
  
  (method (iterate-regions proc)
    (with-regions-mutex
      (lambda ()
        (iterate-table regions
          (lambda (index region)
            (proc region))))))
  
  
  (method (find-region index <index>) <World-Region+>
    (with-regions-mutex
      (lambda ()
        (table-ref regions index #f))))
  
  
  (method (load-region index <index>) <World-Region>
    (or (find-region index)
        (let ((region-x (index-x index))
              (region-y (index-y index))
              (region-z (index-z index)))
          (define (region-name)
            (if (= region-y 0)
                (format "r.{a}.{a}.mca" region-x region-z)
              (format "r.{a}.{a}.{a}.mca" region-x region-z region-y)))
          
          (define (create-file file)
            (create-directories~ file)
            (call-with-output-file (path-settings file)
              (lambda (port)
                (let ((locations/timestamps (make-u8vector 4096 0)))
                  (write-subu8vector locations/timestamps 0 4096 port)
                  (write-subu8vector locations/timestamps 0 4096 port)))))
          
          (define (create-region index)
            (let ((dir (get-regions-dir))
                  (name (region-name)))
              (let ((file (new-file~ dir name)))
                (if (exists?~ file)
                    (new World-Region index file self)
                  (create-file file)
                  (new World-Region index file self)))))
          
          (with-region-access-mutex index
            (lambda ()
              (let ((index (copy-index index)))
                (let ((region (create-region index)))
                  (with-regions-mutex
                    (lambda ()
                      (table-set! regions index region)))
                  region)))))))
  
  
  (method (load-region-if index <index>) <World-Region+>
    (and (or (not truncate-y)
             (>= (index-y index) (fxfloor/ truncate-y region-size)))
         (load-region index)))
  
  
  (method (unlink-region region)
    (with-regions-mutex
      (lambda ()
        (let ((index (get-index~ region)))
          (table-clear region-access-mutexes index)
          (table-clear regions index)))))
  
  
  (method (free-regions)
    (iterate-regions
      (lambda (region)
        (with-mutex~ region
          (lambda ()
            (set-zone~ region #f)
            (close~ region))))))
  
  
  (method (get-regions-dir) <Directory>
    (or regions-dir (let ((dir (new-directory~ level-dir (case dimension
                                                           ((over) "region")
                                                           ((nether) '("DIM-1" "region"))
                                                           ((end) '("DIM1" "region"))))))
                      (set! regions-dir dir)
                      dir)))
  
  
  (method (iterate-regions-dir proc)
    (iterate-directory~ (get-regions-dir)
      (lambda (file <File>)
        (when (extension=? (get-extension~ file) "mca")
          (let ((base <string> (get-base~ file)))
            (bind (x z y . rest) (split (substring base 2 (string-length base)) ".")
              (let ((x (string->number x))
                    (z (string->number z))
                    (y (if (null? rest) 0 (string->number y))))
                (proc file (indexed x y z)))))))))
  
  
  (method public (change-dimension)
    (with-generate-mutex
      (lambda ()
        (set! dimension (case dimension
                          ((over) 'nether)
                          ((nether) 'end)
                          ((end) 'over)))
        (set! regions-dir #f)
        (setup-regions)
        (setup-areas))))
  
  
  ;; for exploration
  (method (preload-regions)
    (iterate-regions-dir
      (lambda (file index)
        (let ((region (load-region index)))
          (loop (for section-x from 0 below 32)
                (loop (for section-z from 0 below 32)
                      (loop (for section-y from 0 below 16)
                            (load-section~ region section-x section-y section-z))))))))


  ;; for exploration
  (method (explore-regions from to (more? #f))
    (define (explore region)
      (let ((region-x (get-x~ region))
            (region-z (get-z~ region))
            (count 0)
            (missing (new-queue)))
        (iterate-chunks~ region
          (lambda (x z)
            (when (not (load-chunk~ region (planar-index x z)))
              (increase! count)
              (enqueue missing (list (+ (* region-x region-size) x)
                                     (+ (* region-z region-size) z))))))
        (if (not more?)
            (debug region count)
          (debug region count (queue-list missing)))))
    
    (loop (for x from from to to)
          (loop (for z from from to to)
                (let ((region (load-region (indexed x 0 z))))
                  (explore region)))))
  
  
  ;; exploration
  (method (explore-chests)
    (preload-regions)
    (let ((items '()))
      (for-each (lambda (info)
                  (bind (section . coordinates) info
                    (bind-index (i j k) coordinates
                      (call-with-section section i j k
                        (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                          (let ((data (block-entity-data section (indexed i j k))))
                            (let ((inventory (list-payload-content (tag-assoc "Items" data))))
                              (for-each (lambda (item)
                                          (let ((id (tag-assoc "id" item)))
                                            (let ((name (or (let ((item (id->item id)))
                                                              (and item (get-name~ item)))
                                                            id)))
                                              (unless (memv? name items)
                                                (set! items (cons name items))))))
                                        inventory))))))))
                (find-visual-blocks '(54)))
      (sort nu<? items key: ->string)))
  
  
  (method (count-regions)
    (let ((count 0))
      (iterate-regions
        (lambda (region)
          (increase! count)))
      count))
  
  
  ;;;
  ;;;; Chunks
  ;;;
  
  
  (method (position-chunk pos <vertex>) <World-Chunk>
    (index-chunk (position-section-index pos)))
  
  
  (method (element-chunk element) <World-Chunk+>
    (let ((index (element-section-index element)))
      (index-chunk index)))
  
  
  (method (index-chunk index <index>) <World-Chunk>
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (let ((region (load-region (indexed (fxfloor/ section-x region-size)
                                          (fxfloor/ section-y region-size)
                                          (fxfloor/ section-z region-size)))))
        (load-section-chunk~ region (planar-index section-x section-z)))))
  
  
  (method (index-chunk-if index (create?: create? #f)) <World-Chunk+>
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (let ((region (let ((index (indexed (fxfloor/ section-x region-size)
                                          (fxfloor/ section-y region-size)
                                          (fxfloor/ section-z region-size))))
                      (if create?
                          (load-region index)
                        (load-region-if index)))))
        (and region
             (load-section-chunk~ region (planar-index section-x section-z))))))
  
  
  (method (find-chunk section-x section-y section-z) <World-Chunk+>
    (let ((region (find-region (indexed (fxfloor/ section-x region-size)
                                        (fxfloor/ section-y region-size)
                                        (fxfloor/ section-z region-size)))))
      (and region
           (find-chunk~ region (planar-index section-x section-z)))))
  
  
  (method (count-chunks)
    (let ((count 0))
      (iterate-regions
        (lambda (region)
          (increase! count (count-chunks~ region))))
      count))
  
  
  ;;;
  ;;;; Sections
  ;;;
  
  
  (method (element-section-index element <Element>) <index>
    (position-section-index (get-position~ element)))
  
  
  (method (position-section-index pos <vertex>) <index>
    (let ((size (cast <fl> sector-size)))
      (indexed (fxfloor (/ (vertex-x pos) size))
               (fxfloor (/ (vertex-y pos) size))
               (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method (position-section pos (create?: create? #f)) <World-Section+>
    (let ((index (position-section-index pos)))
      (index-section index create?: create?)))
  
  
  (method (element-section element) <World-Section+>
    (let ((index (element-section-index element)))
      (index-section index)))
  
  
  (method (index-section index (create?: create? #f)) <World-Section+>
    (let ((section-x (index-x index))
          (section-y (index-y index))
          (section-z (index-z index)))
      (let ((chunk (index-chunk-if index create?: create?)))
        (and chunk
             (load-section~ chunk section-y create?: create?)))))
  
  
  (method (find-section section-x section-y section-z) <World-Section+>
    (let ((chunk (find-chunk section-x section-y section-z)))
      (and chunk
           (find-section~ chunk section-y))))
  
  
  (method (count-sections)
    (let ((count 0))
      (iterate-regions
        (lambda (region)
          (iterate-chunks~ region
            (lambda (chunk)
              (increase! count (count-sections~ chunk))))))
      count))
  
  
  (method (toggle-debug-sections)
    (set! debug-sections? (not debug-sections?)))
  
  
  (method (draw-debug-sections)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((world (current-world))
          (camera (current-camera)))
      (let ((view-distance (get-view-distance~ world)))
        (let ((eye-x (index-x eye-index))
              (eye-y (index-y eye-index))
              (eye-z (index-z eye-index))
              (distance (+ view-distance 2)))
          (if show-chunks?
              (let ((j 0))
                (define (show state color)
                  (render-cubes
                    (lambda (render)
                      (loop (for i from (- eye-x distance) to (+ eye-x distance))
                            (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                  (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                         (+ (* (cast <fl> j) 16.) 8.)
                                                         (+ (* (cast <fl> k) 16.) 8.))))
                                    (when (in-frustum?~ camera center)
                                      (let ((chunk (find-chunk i j k)))
                                        (when (and chunk (= (get-state~ chunk) state))
                                          (render center))))))))
                    wire-color: color
                    cull?: #t))
                
                (show Shaped red-dye)
                (show Populated blue-dye)
                (show Generated green-dye))
            (render-cubes
              (lambda (render)
                (loop (for i from (- eye-x distance) to (+ eye-x distance))
                      (loop (for j from (- eye-y distance) to (+ eye-y distance))
                            (loop (for k from (- eye-z distance) to (+ eye-z distance))
                                  (let ((center (vertex& (+ (* (cast <fl> i) 16.) 8.)
                                                         (+ (* (cast <fl> j) 16.) 8.)
                                                         (+ (* (cast <fl> k) 16.) 8.))))
                                    (when (in-frustum?~ camera center)
                                      (when (or show-sections? (find-section i j k))
                                        (render center))))))))
              wire-color: red-dye
              cull?: #t))))))
  
  
  ;;;
  ;;;; Sectors
  ;;;
  
  
  (method (setup-sectors)
    (let ((world (current-world)))
      (set! sector-radius (let ((half (/ sector-size 2.)))
                            (vertex-norm (vertex half half half))))
      (set! sector-diameter (* sector-radius 2))
      (set! sectors-mutex (make-mutex 'sectors))
      (let ((distance (get-view-distance~ world)))
        (let ((diameter (+ distance 1 distance)))
          (set! eye-radius distance)
          (set! eye-diameter diameter)
          (set! eye-diameter^2 (expt diameter 2))
          (set! eye-diameter^3 (expt diameter 3))
          (set! eye-sectors (make-eye-sectors))
          (set! eye-neighbors (make-eye-neighbors))))
      (set! sector/area-ratio (fxround/ sector-size area-size))))
  
  
  (method (update-view-distance old-distance distance)
    @convert-indexed-sector^^^
    (unless (= distance old-distance)
      (let ((diameter (+ distance 1 distance)))
        (let ((radius distance)
              (diameter^2 (expt diameter 2))
              (diameter^3 (expt diameter 3)))
          (define (index i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j radius) diameter^2)
               (* (+ k radius) diameter)
               (+ i radius)))
          
          (define (index-eye i <fx> j <fx> k <fx>) <fx>
            (+ (* (+ j eye-radius) eye-diameter^2)
               (* (+ k eye-radius) eye-diameter)
               (+ i eye-radius)))
          
          (let ((sectors (make-vector diameter^3 #f)))
            (cond ;; smaller
                  ((< distance old-distance)
                   (loop (for i from (- distance) to distance)
                         (loop (for j from (- distance) to distance)
                               (loop (for k from (- distance) to distance)
                                     (vector-set! sectors (index i j k) (vector-ref eye-sectors (index-eye i j k)))))))
                  ;; greater
                  (else
                   (loop (for i from (- old-distance) to old-distance)
                         (loop (for j from (- old-distance) to old-distance)
                               (loop (for k from (- old-distance) to old-distance)
                                     (vector-set! sectors (index i j k) (vector-ref eye-sectors (index-eye i j k))))))))
            (set! eye-radius radius)
            (set! eye-diameter diameter)
            (set! eye-diameter^2 diameter^2)
            (set! eye-diameter^3 diameter^3)
            (set! eye-sectors sectors)
            ;; greater so add new sectors
            (when (> distance old-distance)
              (let ((a (index-x eye-index))
                    (b (index-y eye-index))
                    (c (index-z eye-index)))
                (loop (for i from (- distance) to distance)
                      (loop (for j from (- distance) to distance)
                            (loop (for k from (- distance) to distance)
                                  (let ((index (index-eye i j k)))
                                    (unless (vector-ref eye-sectors index)
                                      (vector-set! sectors index (indexed-sector (+ a i) (+ b j) (+ c k))))))))))
            (set! eye-neighbors (make-vector diameter^3 #f))
            (update-eye-neighbors distance))))))
  
  
  (method (position-sector-index pos <vertex>) <index>
    (let ((size (cast <fl> sector-size)))
      (indexed (fxfloor (fl& (/ (vertex-x pos) size)))
               (fxfloor (fl& (/ (vertex-y pos) size)))
               (fxfloor (fl& (/ (vertex-z pos) size))))))
  
  
  (method (new-sector index <index>) <Sector>
    (define (center i <fx>)
      (* (+ (cast <fl> i) .5) sector-size))
    
    (let ((x (index-x index))
          (y (index-y index))
          (z (index-z index)))
      (new Sector index (vertex (center x) (center y) (center z)) (index-expanse index))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (iterate-sectors proc)
    (when eye-neighbors
      (loop (for sector in-vector eye-neighbors)
            (when sector
              (proc sector)))))
  
  
  (proclaim (warn optimizations))
  
  
  (method (iterate-section-neighbors section-index <index> distance <fx> proc)
    (let ((a (index-x section-index))
          (b (index-y section-index))
          (c (index-z section-index)))
      (loop (for i from (- distance) to distance)
            (loop (for j from (- distance) to distance)
                  ;; $$$ try
                  (do (when (between? j 0 15)
                        (loop (for k from (- distance) to distance)
                              (let ((section (index-section (indexed (+ a i) (+ b j) (+ c k)))))
                                (when section
                                  (proc section))))))))))
    
  
  ;; index of the eye sector
  (definition eye-index <index+>
    #f)
  
  ;; cube of all eye sectors
  (definition eye-sectors
    #f)
  
  ;; eye sectors ordered by distance
  (definition eye-neighbors
    #f)
  
  (definition eye-radius <fx>
    0)
  
  (definition eye-diameter <fx>
    0)
  
  (definition eye-diameter^2 <fx>
    0)
  
  (definition eye-diameter^3 <fx>
    0)
  
  
  (method package (get-eye-index)
    eye-index)
  
  (method package (get-eye-sectors) <vector>
    eye-sectors)
  
  (method package (get-eye-neighbors) <vector>
    eye-neighbors)
    
  
  (method (sectors-index i <fx> j <fx> k <fx>) <fx>
    (+ (* j eye-diameter^2) (* k eye-diameter) i))

  
  (method (make-eye-sectors)
    (make-vector eye-diameter^3 #f))
  
  
  (method (make-eye-neighbors)
    (make-vector eye-diameter^3 #f))
  
  
  (method (element-sector element) <Sector+>
    ;; should iterate over every camera
    (find-eye-sector (element-section-index element)))
  
  
  (method (find-sector index) <Sector+>
    ;; should iterate over every camera
    (find-eye-sector index))
  
  
  (method (find-eye-sector index)
    (and eye-index
         (let ((a (- (index-x eye-index) eye-radius))
               (b (- (index-y eye-index) eye-radius))
               (c (- (index-z eye-index) eye-radius)))
           (let ((i (- (index-x index) a))
                 (j (- (index-y index) b))
                 (k (- (index-z index) c))
                 (last (- eye-diameter 1)))
             (and (between? i 0 last)
                  (between? j 0 last)
                  (between? k 0 last)
                  (vector-ref eye-sectors (sectors-index i j k)))))))
  
  
  (method (eye-sector)
    (vector-ref eye-sectors (sectors-index eye-radius eye-radius eye-radius)))
  
  
  (method (free-eye-sectors)
    (set! eye-index #f)
    (loop (for n from 0 below eye-diameter^3)
          (let ((sector (vector-ref eye-sectors n)))
            (when sector
              (close~ sector)))
          (vector-set! eye-sectors n #f)
          (vector-set! eye-neighbors n #f)))
  
  
  (method (eye-neighbor-sectors index <index> distance <fx>) <vector>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ()
      (define (sector-new i j k)
        (new-sector (indexed i j k)))
      
      (define (sector-free sector)
        (close~ sector))
      
      (if (and eye-index (index=? index eye-index))
          eye-neighbors
        ;; update sectors
        (let ((sectors (get-eye-sectors))
              (a <fx> (- (index-x index) eye-radius))
              (b <fx> (- (index-y index) eye-radius))
              (c <fx> (- (index-z index) eye-radius)))
          (if (not eye-index)
              (loop (for i from 0 below eye-diameter)
                    (loop (for j from 0 below eye-diameter)
                          (loop (for k from 0 below eye-diameter)
                                (vector-set! sectors (sectors-index i j k)
                                  (sector-new (+ a i)
                                              (+ b j)
                                              (+ c k))))))
            (let ((last (- eye-diameter 1))
                  (dx (- (index-x index) (index-x eye-index)))
                  (dy (- (index-y index) (index-y eye-index)))
                  (dz (- (index-z index) (index-z eye-index))))
              (define (by delta <fx>)
                (if (>= delta 0)
                    1
                  -1))
              
              (loop (for x start 0 end last by (by dx))
                    (let ((fx (+ x dx))
                          (tx x))
                      (loop (for y start 0 end last by (by dy))
                            (let ((fy (+ y dy))
                                  (ty y))
                              (loop (for z start 0 end last by (by dz))
                                    (let ((fz (+ z dz))
                                          (tz z))
                                      (let ((fi (and (between? fx 0 last)
                                                     (between? fy 0 last)
                                                     (between? fz 0 last)
                                                     (sectors-index fx fy fz)))
                                            (ti (sectors-index tx ty tz)))
                                        (let ((sector (vector-ref sectors ti)))
                                          (when sector
                                            ;; free
                                            (sector-free sector)))
                                        (if fi
                                            (begin
                                              ;; move
                                              (vector-set! sectors ti (vector-ref sectors fi))
                                              (vector-set! sectors fi #f))
                                          ;; new
                                          (vector-set! sectors ti (sector-new (+ a tx) (+ b ty) (+ c tz))))))))))))))
        ;; update neighbors
        (update-eye-neighbors distance)
        (set! eye-index (copy-index index))
        eye-neighbors)))
  
  
  (method (update-eye-neighbors distance <fx>)
    (let ((sectors eye-sectors)
          (neighbors eye-neighbors)
          (n 0))
      (define (set i j k)
        (vector-set! neighbors n (vector-ref sectors (sectors-index (+ i distance) (+ j distance) (+ k distance))))
        (increase! n))
      
      ;; set neighbors in expanding distance from eye
      (set 0 0 0)
      (loop (for radius from 1 to distance)
            (let ((radius-1 (- radius 1)))
              ;; left
              (let ((i (- radius)))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; right
              (let ((i radius))
                (loop (for j from (- radius) to radius)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; bottom
              (let ((j (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; top
              (let ((j radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for k from (- radius) to radius)
                            (set i j k))))
              ;; back
              (let ((k (- radius)))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))
              ;; front
              (let ((k radius))
                (loop (for i from (- radius-1) to radius-1)
                      (loop (for j from (- radius-1) to radius-1)
                            (set i j k))))))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (increase-sectors-generating count <fx>)
    (mutex-lock! sectors-mutex)
    (when (= sectors-generating 0)
      (active-site 'visual))
    (set! sectors-generating (+ sectors-generating count))
    (mutex-unlock! sectors-mutex))
  
  
  (method (decrease-sectors-generating count <fx>)
    (mutex-lock! sectors-mutex)
    (set! sectors-generating (- sectors-generating count))
    (when (= sectors-generating 0)
      (inactive-site 'visual))
    (mutex-unlock! sectors-mutex))
  
  
  (method (increase-sectors-generated)
    (mutex-lock! sectors-mutex)
    (set! sectors-generated (+ sectors-generated 1))
    (mutex-unlock! sectors-mutex))
  
  
  (method (compute-floats)
    (let ((total 0))
      (iterate-sectors
        (lambda (sector)
          (let ((mesh (get-mesh~ sector)))
            (when mesh
              (let ((floats (count-floats~ mesh)))
                (when floats
                  (increase! total floats)))))))
      total))
  
  
  (method (count-laden-sectors)
    (let ((total 0))
      (iterate-sectors
        (lambda (sector)
          (let ((mesh (get-mesh~ sector)))
            (when mesh
              (increase! total)))))
      total))
  
  
  (method (toggle-debug-sectors)
    (let ((world (current-world)))
      (set! debug-sectors? (not debug-sectors?))
      (update-parameter~ world 'debug-sectors)))
  
  
  (method (draw-debug-sectors)
    (draw-3d-grid (element-section-index (current-me)) sector-size))
  
  
  ;;;
  ;;;; Areas
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (setup-areas)
    ;; temporary simplification by having processor retain everything
    (set! areas (make-table test: equal? weak-values: (not (processing?)))))
  
  
  (method (element-area-index element <Element>) <index>
    (position-area-index (get-position~ element)))
  
  
  (method (position-area-index pos <vertex>) <index>
    (let ((size (cast <fl> area-size)))
      (indexed (fxfloor (/ (vertex-x pos) size))
               (fxfloor (/ (vertex-y pos) size))
               (fxfloor (/ (vertex-z pos) size)))))
  
  
  (method (element-area element) <Area>
    (let ((index (element-area-index element)))
      (indexed-area (index-x index)
                    (index-y index)
                    (index-z index))))
  
  
  (method (indexed-area x <fx> y <fx> z <fx>) <Area>
    (let ((index (make-index&)))
      (index-x-set! index (fxfloor/ (* x area-size) section-size))
      (index-y-set! index (fxfloor/ (* y area-size) section-size))
      (index-z-set! index (fxfloor/ (* z area-size) section-size))
      (let ((area
              (or (table-ref areas index #f)
                  (let ((index (copy-index index)))
                    (let ((area (new Area index (index-expanse index))))
                      (table-set! areas index area)
                      area)))))
        (update-physical~ area)
        area)))
  
  
  (method (find-area index) <Area+>
    (table-ref areas index #f))
  
  
  (method (unlink-area index)
    (table-clear areas index))
  
  
  (proclaim (not warn optimizations))
  
  
  (method (iterate-areas proc)
    @convert^^^
    (iterate-table areas
      proc))
  
  
  ;; putting area-cube here is a quicky to test travel-ray-polygons&
  (method (iterate-position-neighbor-areas pos distance <fx> area-cube proc)
    (if (and area-cube (<= distance (get-cube-radius~ area-cube)))
        (iterate-neighbor-areas~ area-cube pos distance proc)
      (let ((index (position-area-index pos)))
        (let ((a (index-x index))
              (b (index-y index))
              (c (index-z index)))
          (loop (for i from (- distance) to distance)
                (loop (for j from (- distance) to distance)
                      (loop (for k from (- distance) to distance)
                            (let ((a (+ a i))
                                  (b (+ b j))
                                  (c (+ c k)))
                              (let ((area (indexed-area a b c)))
                                (proc area
                                      (subarea-index~ area a b c)
                                      #t))))))))))
  
  
  (method (iterate-area-elements area proc)
    (for-each proc (get-actors~ area))
    (for-each proc (get-entities~ area))
    (for-each proc (get-gadgets~ area)))
  
  
  (method (count-polygons)
    0
    @convert^^^
    (let ((count 0))
      (iterate-table areas
        (lambda (index area)
          (let ((polygons (get-polygons~ area)))
            (when polygons
              (increase! count (fxround/ (f64vector-length polygons) polygon-float-size))))))
      count))
  
  
  (method (toggle-debug-areas)
    (let ((world (current-world)))
      (set! debug-areas? (not debug-areas?))
      (update-parameter~ world 'debug-areas)))
  
  
  (method (draw-debug-areas)
    (draw-3d-grid (element-area-index (current-me)) area-size))
  
  
  ;;;
  ;;;; Expanses
  ;;;
  
  
  (method (setup-expanses)
    ;; temporary simplification by having processor retain everything
    (set! expanses (make-table test: equal? weak-values: (not (processing?)))))
  
  
  (method (index-expanse index <index>) <Expanse>
    (or (table-ref expanses index #f)
        (let ((index (copy-index index)))
          (let ((expanse (new Expanse)))
            (table-set! expanses index expanse)
            expanse))))
  
  
  (method (element-expanse element)
    (index-expanse (element-section-index element)))
  
  
  ;;;
  ;;;; Gadget
  ;;;
  
  
  (method (draw-gadgets)
    (for-each (lambda (gadget)
                (register-entity gadget #t))
              gadgets))
  
  
  (method (draw-drawable-gadgets)
    (for-each (lambda (gadget)
                (when (and (drawable?~ gadget)
                           (get-visible?~ gadget))
                  (register-entity gadget)))
              gadgets))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (method (render-task task <Task>)
    (render-task~ (current-world) task))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (find-player name)
    (find-if (lambda (player)
               (equal? (get-name~ player) name))
             players))
  
  
  (method (resurrect-player player)
    (let ((new-position (find-spawnpoint)))
      (set-position~ player new-position)
      (set-velocity~ player (vertex 0. 0. 0.))
      (set-fall-velocity~ player (vertex 0. 0. 0.))
      (verify-water~ player)))
  
  
  (method protected virtual (player-task task <Task>)
    (player-task~ (current-world) task))
  
  
  ;;;
  ;;;; Missile
  ;;;
  
  
  (method protected virtual (missile-task task <Task>)
    (missile-task~ (current-world) task))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (tick-task task <Task>)
    (tick-task~ (current-world) task))
  
  
  ;;;
  ;;;; Actors
  ;;;
  
  
  (method (actors-task task <Task>)
    (actors-task~ (current-world) task))
  
  
  ;;;
  ;;;; Sun
  ;;;
  
  
  (method (sun-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (if (not sun-cycle?)
              (task-sleep task +infinity 0. exit)
            (let (iter (previous (current-seconds)))
              (let ((time (current-seconds)))
                (let ((elapse (- time previous)))
                  (with-task-mutex
                    (lambda ()
                      (unless (get-paused?~ history)
                        (unless (stopping?~ task)
                          (tick-sun elapse)))))
                  (let ((duration (- (current-seconds) time)))
                    (task-sleep task sun-period duration exit))
                  (iter time)))))))))
  
  
  (method (tick-sun elapse)
    (site (sun on?: #t)
      (position-sun elapse)))
  
  
  (method (position-sun elapse (angle: angle #f))
    (define (calculate-angle)
      (flmodulo (+ sun-angle (* (sun-speed) elapse)) PI*2))
    
    (define (sun-speed)
      (/ PI*2 day-duration))
    
    (set! sun-angle (or angle (calculate-angle)))
    (when (window?)
      (let ((under-limit 0.1)
            (direction (rotate-upon& PI/4 (vertex 0.0 1.0 0.0) (rotate-upon& sun-angle (vertex 0.0 0.0 -1.0) (vertex -1. 0. 0.)))))
        (let ((pos (vertex-scalar*& direction 1000.)))
          (when (not sun)
            (set! sun (new Sun parent: self position: pos))
            (add-element sun))
          (cond ((or (< sun-angle (+ PI under-limit))
                     (> sun-angle (- PI*2 under-limit)))
                 (let (@wait-sun-on-player/material (coord (vertex-scalar* direction 1000.))
                       (under (cond ((> sun-angle (- PI*2 under-limit)) (- PI*2 sun-angle))
                                    ((and (> sun-angle PI) (< sun-angle (+ PI under-limit))) (- sun-angle PI))
                                    (else 0.))))
                   (let ((intensity (- 1.0 (/ under under-limit))))
                     (let ((effective (dye (* (dye-red sun-color) intensity)
                                           (* (dye-green sun-color) intensity)
                                           (* (dye-blue sun-color) intensity)
                                           1.0)))
                       @wait-sun-on-player/material (set-sun-effective~ lighting effective)
                       @wait-sun-on-player/material (set-sun-coordinates~ lighting coord)
                       (set-position-noupdate~ sun pos)
                       (set-color~ sun effective)
                       (set-visible?~ sun #t)))))
                (else
                 (set-sun-effective~ lighting (dye 0. 0. 0. 0.))
                 (set-visible?~ sun #f))))))
    (sun-update))
  
  
  (method (sun-update)
    (set-daytime (sun-angle->daytime sun-angle)))
  
  
  (method (register-sun)
    (register-entity sun))
  
  
  ;;;
  ;;;; Daytime
  ;;;
  
  
  (method (goto-daytime daytime)
    (if sun-cycle?
        (position-sun #f angle: (daytime->sun-angle daytime))
      (set-daytime daytime)))
  
  
  (method (sun-angle->daytime sun-angle)
    (let ((angle (flmodulo sun-angle PI*2)))
      (flmodulo (+ (/ (* angle day-span) PI*2) dawn-daytime) day-span)))
  
  
  (method (daytime->sun-angle daytime)
    (/ (* (- daytime dawn-daytime) PI*2) day-span))
  
  
  (method (effective-daytime daytime)
    (cond ((flonum? daytime) daytime)
          ((or (eq? daytime 'default) (ci=? daytime "default")) dawn-daytime)
          ((or (eq? daytime 'dawn) (ci=? daytime "dawn")) dawn-daytime)
          ((or (eq? daytime 'day) (ci=? daytime "day")) day-daytime)
          ((or (eq? daytime 'dusk) (ci=? daytime "dusk")) dusk-daytime)
          ((or (eq? daytime 'night) (ci=? daytime "night")) night-daytime)
          ((string? daytime) (cast <fl> (string->number daytime)))
          (else "Invalid daytime: {s}" daytime)))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method (gravity-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history))
          (game (current-game)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds)))
              (let ((elapse (- time previous)))
                (with-task-mutex
                  (lambda ()
                    (unless (get-paused?~ history)
                      (unless (stopping?~ task)
                        (let ((blocks (get-fall-blocks~ game)))
                          (unless (queue-empty? blocks)
                            (set-fall-blocks~ game (new-queue))
                            (tick-gravity elapse blocks)))))))
                (task-sleep task gravity-period (- (current-seconds) time) exit)
                (iter time))))))))
  
  
  (method (tick-gravity elapse blocks)
    (site (gravity on?: #t)
      (blocks-fall elapse blocks)))
  
  
  (method (blocks-fall elapse blocks)
    (let ((game (current-game)))
      (updating-sections
        (lambda (add-section)
          (let (iter)
            (unless (queue-empty? blocks)
              (bind (section . index) (dequeue blocks)
                (bind-index (i j k) index
                  (call-with-section section i j k
                    (lambda (section block <fx> data <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                      (define (effective-block-ref i j k)
                        (with-field i j k
                          (lambda (section index)
                            (if section
                                (block-ref section index)
                              0))))
                      
                      (define (add-neighbors i j k)
                        (define (add-neighbor i j k)
                          (with-field i j k
                            (lambda (section index)
                              @w(when (id? (block-ref section index) SandBlock Gravel)
                                  (normalize-section/coordinates section i j k with-field
                                    (lambda (section i j k)
                                      (add-fall-block~ game section i j k))))
                              ;; EH validate
                              (when section
                                (add-section section)))))
                        
                        (add-neighbor (+ i 1) j k)
                        (add-neighbor (- i 1) j k)
                        (add-neighbor i (+ j 1) k)
                        (add-neighbor i (- j 1) k)
                        (add-neighbor i j (+ k 1))
                        (add-neighbor i j (- k 1)))
                      
                      (when (and (id? block SandBlock Gravel) (id? (effective-block-ref i (- j 1) k) Air Water StationaryWater Lava StationaryLava))
                        (with-field i j k
                          (lambda (section index)
                            (block-set! section index 0)
                            (add-neighbors i j k)
                            (inverse-propagate-light~ game i j k add-section with-field block-ref blocklight-ref blocklight-set!)
                            (redstone-update section (list i j k block) add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!))))))))
              (iter))))
        delay-update?: #t)))
  
  
  ;;;
  ;;;; Distance
  ;;;
  
  
  (method (distance-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter (previous (current-seconds)))
            (let ((time (current-seconds)))
              (let ((elapse (- time previous)))
                (with-task-mutex
                  (lambda ()
                    (unless (get-paused?~ history)
                      (unless (stopping?~ task)
                        (tick-distance elapse)))))
                (let ((duration (- (current-seconds) time)))
                  (task-sleep task distance-period duration exit))
                (iter time))))))))
  
  
  (method (tick-distance elapse)
    (site (distance on?: #t)
      (let ((me (current-me+)))
        ;; quick solution that should be generalized for server-side
        (when me
          (check-distance elapse me)))))
  
  
  (method (check-distance elapse me)
    (let ((world (current-world)))
      (let ((chest (get-opened-chest))
            (creatures (get-aggroed-creatures~ me))
            (pos (get-position~ me)))
        (when chest
          (bind (section index coordinates) chest
            (let ((location (section/coordinates->location section coordinates)))
              (let ((dist (vertex-distance (vertex (+ (index-x location) .5)
                                                   (+ (index-y location) .5)
                                                   (+ (index-z location) .5))
                                           pos)))
                (when (> dist (if (user?)
                                  (world-setting 'world.interaction-distance 8.)
                                20.))
                  (play-sound-file "sound/random/chestclosed" volume: .5)
                  (hide-chest~ world)
                  (hide-bag~ world)
                  (set-opened-chest #f))))))
        (when creatures
          (for-each (lambda (creature)
                      (when (> (vertex-distance pos (get-position~ creature)) (get-aggro-radius~ creature))
                        (set-aggro-target~ creature #f)
                        (set! creatures (remove! creature creatures test: equal?))))
                    creatures))
        (set-aggroed-creatures~ me creatures))))
  
  
  ;;;
  ;;;; Eat
  ;;;
  
  
  (method (eat-task task <Task>)
    (declare (proper-tail-calls))
    (let ((history (current-history)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (with-task-mutex
              (lambda ()
                (unless (get-paused?~ history)
                  (unless (stopping?~ task)
                    (tick-eat task exit)))))
            (task-sleep task eat-period 0. exit)
            (iter))))))
  
  
  (method (tick-eat task exit)
    (site (eat on?: #t)
      (let ((interface (current-interface+))
            (me (current-me+)))
        ;; quick solution that should be generalized for server-side
        (when me
          (let ((eating (get-eating~ me)))
            (when eating
              (let ((eating-ticks (get-eating-ticks~ me)))
                (set-life~ me (min (+ (get-life~ me) eating) 100.))
                (when interface
                  (invalidate-view~ (child~ interface 'combat)))
                (let ((eating-ticks (- (get-eating-ticks~ me) 1)))
                  (if (> eating-ticks 0)
                      (set-eating-ticks~ me eating-ticks)
                    (set-eating~ me #f)
                    (set-eating-ticks~ me #f))))))))))
  
  
  ;;;
  ;;;; Day
  ;;;
  
  
  (method (set-daytime time)
    (set! daytime time)
    (set! daylight (daytime->daylight time)))
  
  
  (method (daytime->daylight daytime)
    ;; night
    (cond ((< daytime 6000.)
           0.)
          ;; dawn
          ((< daytime 9000.)
           (/ (- daytime 6000.) 3000.))
          ;; day
          ((< daytime 18000.)
           1.)
          ;; dusk
          ((< daytime 21000.)
           (/ (- 21000. daytime) 3000.))
          ;; night
          (else
           0.)))
  
  
  ;;;
  ;;;; Lighting
  ;;;
  
  
  (definition default-lights-cache
    #f)
  
  
  (method (effective-lights) <list>
    (define (default-lights)
      (or default-lights-cache
          (let ((lights (list (new Light-Ambient position: (vertex 10000. 10. 10000.)))))
            (set! default-lights-cache lights)
            lights)))
    
    (let ((world (current-world)))
      (if (get-lighting?~ world)
          (let ((lights (collect-lights)))
            (if (null? lights)
                (default-lights)
              lights))
        '())))
  
  
  (method (effective-player-glow)
    player-glow)
  
  
  (method (setup-lighting)
    (lighting-setup)
    (block-lighting-setup))
  
  
  (method (lighting-setup)
    (let ((world (current-world)))
      (let ((lights (effective-lights)))
        (let ((light (max .1 (/ daylight 5.))))
          (set-ambient-color~ lighting (dye (+ (dye-red ambient-color) light)
                                            (+ (dye-green ambient-color) light)
                                            (+ (dye-blue ambient-color) light)
                                            1.0)))
        (set-lights~ lighting lights)
        (set-lights-count~ lighting (min (get-dynamic-lights~ world) (length lights)))
        @wait-sun-on-player/material 
        (cond (sun-cycle?
               (set-sun-effective~ lighting sun-color)
               (set-sun-coordinates~ lighting (vertex 10000.0 10000.0 10000.0)))
              (else
               (set-sun-effective~ lighting (dye 0. 0. 0. 0.))
               (set-sun-coordinates~ lighting (vertex 0. 0. 0.))))
        (set-current-lighting lighting))))
  
  
  (method (block-lighting-setup)
    (let ((world (current-world)))
      (let ((lights '()))
        (set-ambient-color~ block-lighting ambient-color)
        (set-lights~ block-lighting lights)
        (set-lights-count~ block-lighting 0)
        (set-current-block-lighting block-lighting))))
  
  
  (method (iterate-lights proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Light)
          (proc gadget)))))
  
  
  (method (collect-lights)
    (let ((queue (new-queue)))
      (iterate-lights
        (lambda (light)
          (enqueue queue light)))
      (queue-list queue)))
  
  
  (method (count-lights)
    (let ((count 0))
      (iterate-lights
        (lambda (light)
          (increase! count)))
      count))
  
  
  ;;;
  ;;;; Gravity
  ;;;
  
  
  (method public (iterate-gravities proc)
    (for-each proc gravities))
  
  
  (method public (iterate-planets proc)
    (iterate-gravities
      (lambda (well)
        (when (is? well Planet)
          (proc well)))))
  
  
  (method public (collect-planets)
    (let ((queue (new-queue)))
      (iterate-planets
        (lambda (planet)
          (enqueue queue planet)))
      (queue-list queue)))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method (reset-marks)
    (set! marks '()))
  
  
  (method (set-marks lst)
    (set! marks lst))
  
  
  (method (set-mark mark)
    (set! marks (list mark)))
  
  
  (method (add-mark mark)
    (set! marks (cons mark marks)))
  
  
  (method (remove-mark mark)
    (set! marks (remove! mark marks)))
  
  
  (method (draw-marks)
    (for-each (lambda (mark)
                (when (is-not? mark world.mark:Polygon-Mark)
                  (draw~ mark)))
              marks)
    (for-each (lambda (mark)
                (when (is? mark world.mark:Polygon-Mark)
                  (draw~ mark)))
              marks))
  
  
  (method (reset-all-marks)
    (let ((world (current-world)))
      (reset-marks)
      (display-message~ world "Marks reset")))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method virtual (zone-editable?)
    (and editable? (not (admin?))))
  
  
  (method virtual (zone-destructible?)
    #f)
  
  
  ;;;
  ;;;; Atlas
  ;;;
  
  
  (method (draw-atlas)
    @convert-effective-material
    (let ((world (current-world)))
      (unless texture-arrays?
        (let ((texture (get-texture~ (let ((elem (first-target~ world)))
                                       (if (is? elem Entity)
                                           (effective-material~ elem)
                                         (get-block-atlas~ world)))))
              (width 100.)
              (height 100.))
          (map-texture~ texture)
          (textured-quad~ texture
            (lambda () (glVertex3f 0.0 0.0 0.0))
            (lambda () (glVertex3f width 0.0 0.0))
            (lambda () (glVertex3f width height 0.0))
            (lambda () (glVertex3f 0.0 height 0.0)))))))
  
  
  ;;;
  ;;;; Heightmap
  ;;;
  
  
  @convert^^^
  (method (generate-heightmap-old sector <Sector> heightmap <f32vector> from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (define (generate-done)
      (set-visual-uptodate?~ sector #t)
      (set-visual-revision~ sector (get-revision~ generator))
      (set-visual-generating?~ sector #f)
      (decrease-sectors-generating 1))
    
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1)))
      (let ((count (f32vector-length heightmap)))
        (let ((vertices (make-vector count))
              (normals (make-vector count)))
          (define (get-vertex x <fx> z <fx>)
            (vector-ref vertices (+ (* x z-count) z)))
          
          (define (get-normal x <fx> z <fx>)
            (vector-ref normals (+ (* x z-count) z)))
          
          ;; fill vertices
          (loop (for x from 0 below x-count)
                (loop (for z from 0 below z-count)
                      (let ((index (+ (* x z-count) z)))
                        (let ((height (f32vector-ref heightmap index)))
                          (let ((x (cast <fl> (+ from-x x)))
                                (y (cast <fl> height))
                                (z (cast <fl> (+ from-z z))))
                            (vector-set! vertices index (vertex x y z))
                            (vector-set! normals index (vertex 0. 0. 0.)))))))
          ;; add triangles
          (let ((squares (make-vector (* width depth)))
                (sectors (make-table test: eq?))
                (areas (make-table test: eq?))
                (default-image (get-default-image~ world)))
            (let ((material (get-material-opaque~ world))
                  (uv (image-rect~ (get-block-atlas~ world) default-image)))
              (let ((tl (uv-left uv))
                    (tt (uv-top uv))
                    (tr (uv-right uv))
                    (tb (uv-bottom uv))
                    (texture-depth (uv-depth uv)))
                (define (safe-square x <fx> z <fx>)
                  (and
                    (>= x 0) (< x width)
                    (>= z 0) (< z depth)
                    (get-square x z)))
                
                (define (get-square x <fx> z <fx>)
                  (vector-ref squares (+ (* x depth) z)))
                
                (define (set-square x <fx> z <fx> square)
                  (vector-set! squares (+ (* x depth) z) square))
                
                (define (make-square t1 t2)
                  (cons t1 t2))
                
                (define (square-t1 square) <Smooth-Triangle>
                  (get-polygon~ (cast <Face> (car square))))
                
                (define (square-t2 square) <Smooth-Triangle>
                  (get-polygon~ (cast <Face> (cdr square))))
                
                (define (add-face face <Face>)
                  (let ((center (get-center~ (get-polygon~ face))))
                    (let ((sector #f @$$$ (index-sector (position-sector-index center))))
                      (table-add sectors sector face))
                    (when (eq? what 'physical)
                      (let ((area (index-area (position-area-index center) #f)))
                        (table-add areas area (get-polygon~ face))))))
                
                (define (add-triangle v1 v2 v3)
                  (let ((normal (plane-normal v1 v2 v3)))
                    (let ((face
                            (if (> (vertex-x v1) (vertex-x v2))
                                (make-face material
                                           (f32vector tl tb tr tb tr tt)
                                           texture-depth
                                           (make-smooth-triangle self
                                                                 v1 v2 v3
                                                                 normal normal normal))
                              (make-face material
                                         (f32vector tr tt tl tt tl tb)
                                         texture-depth
                                         (make-smooth-triangle self
                                                               v1 v2 v3
                                                               normal normal normal)))))
                      (add-face face)
                      face)))
                
                ;; add triangles
                (loop (for x from 0 below width)
                      (loop (for z from 0 below depth)
                            (let ((v1 (get-vertex x (+ z 1)))
                                  (v2 (get-vertex (+ x 1) (+ z 1)))
                                  (v3 (get-vertex (+ x 1) z))
                                  (v4 (get-vertex x z)))
                              (let ((triangle1 (add-triangle v1 v2 v3))
                                    (triangle2 (add-triangle v3 v4 v1)))
                                (set-square x z (make-square triangle1 triangle2))))))
                ;; smooth normals
                (loop (for x from 0 below x-count)
                      (loop (for z from 0 below z-count)
                            (let ((normal (get-normal x z))
                                  (tl (safe-square (- x 1) (- z 1)))
                                  (tr (safe-square x (- z 1)))
                                  (bl (safe-square (- x 1) z))
                                  (br (safe-square x z)))
                              (when tl
                                (vertex-increase! normal (get-normal~ (square-t1 tl))))
                              (when tr
                                (vertex-increase! normal (get-normal~ (square-t1 tr)))
                                (vertex-increase! normal (get-normal~ (square-t2 tr))))
                              (when bl
                                (vertex-increase! normal (get-normal~ (square-t1 bl)))
                                (vertex-increase! normal (get-normal~ (square-t2 bl))))
                              (when br
                                (vertex-increase! normal (get-normal~ (square-t2 br))))
                              (vertex-normalize! normal normal))))
                ;; update normals
                (loop (for x from 0 below width)
                      (loop (for z from 0 below depth)
                            (let ((square (get-square x z)))
                              (set-n1~ (square-t1 square) (get-normal x (+ z 1)))
                              (set-n2~ (square-t1 square) (get-normal (+ x 1) (+ z 1)))
                              (set-n3~ (square-t1 square) (get-normal (+ x 1) z))
                              (set-n1~ (square-t2 square) (get-normal (+ x 1) z))
                              (set-n2~ (square-t2 square) (get-normal x z))
                              (set-n3~ (square-t2 square) (get-normal x (+ z 1))))))
                (case what
                  ((physical)
                   (iterate-table areas
                     (lambda (area <Area> polygons)
                       (add-polygons~ area #f polygons #f))))
                  ((visual)
                   (iterate-table sectors
                     (lambda (sector faces)
                       (bind-values (vertices neighbors) (prepare-vertices/neighbors~ sector faces)
                         (let ((lightmap (prepare-lightmap~ sector faces)))
                           (with-render-mutex
                             (lambda ()
                               (free-material-mesh~ sector)
                               (setup-material-mesh~ sector)
                               (let ((mesh (get-material-mesh~ sector)))
                                 (fill-vertices/neighbors~ sector mesh #f vertices neighbors)
                                 (fill-lightmap~ sector mesh #f lightmap)
                                 (setup-array~ mesh))
                               (generate-done))))))))))))))))
    
  
  ;;;
  ;;;; Level
  ;;;

  
  (method protected (get-level-file)
    (or level-file
        (let ((file (new-file~ level-dir "level.dat")))
          (set! level-file file)
          file)))
  
  
  (method public (get-level-state)
    (or level-state
        (let ((state (read/create-level)))
          (set! level-state state)
          state)))
  
  
  (method (read/create-level)
    (let ((file (get-level-file)))
      (if (exists?~ file)
          (read-level file)
        (create-level))))
  
  
  (method (read-level file)
    (with ((reader <NBT-Reader> (new NBT-Reader file compressed?: #t gzip?: #t)))
      (read-tag~ reader)))
  
  
  (method (create-level)
    (let ((spawnpoint (or start-spawnpoint (vertex 0. 50. 0.))))
      (make-tag "" TAG_Compound
        (list
          (make-tag "Data" TAG_Compound
            (list
              (make-tag "Player" TAG_Compound
                (list
                  (make-tag "Inventory" TAG_List (make-list-payload TAG_Compound '()))))
              (make-tag "SpawnX" TAG_Int (fxround (vertex-x spawnpoint)))
              (make-tag "SpawnY" TAG_Int (fxround (vertex-y spawnpoint)))
              (make-tag "SpawnZ" TAG_Int (fxround (vertex-z spawnpoint)))
              (make-tag "LevelName" TAG_String "New")
              (make-tag "version" TAG_Int 19133)))))))
  
  
  (method public (save-level-state)
    (save-level (get-level-state) (get-level-file)))
  
  
  (method (save-level level file)
    (create-directories~ file)
    (with ((writer (new NBT-Writer file compressed?: #t gzip?: #t)))
      (write-tag~ writer level)))
  
  
  (method (find-spawnpoint)
    (or (get-player-spawnpoint)
        (get-spawnpoint)))
  
  
  (method (find-spawnlookat)
    (make-standard-lookat))
  
  
  (method (get-spawnpoint)
    (let ((tag (get-level-state)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-assoc "SpawnX" compound))
              (y (tag-assoc "SpawnY" compound))
              (z (tag-assoc "SpawnZ" compound)))
          (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z))))))
  
  
  (method (set-spawnpoint pos)
    (let ((tag (get-level-state)))
      (let ((compound (tag-assoc "Data" (tag-value tag))))
        (let ((x (tag-find "SpawnX" compound))
              (y (tag-find "SpawnY" compound))
              (z (tag-find "SpawnZ" compound)))
          (tag-set x (fxround (vertex-x pos)))
          (tag-set y (fxround (vertex-y pos)))
          (tag-set z (fxround (vertex-z pos)))))))
  
  
  (method (get-player-spawnpoint)
    (let ((tag (get-level-state)))
      (let ((player (tag-assoc "Player" (tag-assoc "Data" (tag-value tag)))))
        (let ((x (tag-assoc "SpawnX" player))
              (y (tag-assoc "SpawnY" player))
              (z (tag-assoc "SpawnZ" player)))
          (and x y z (vertex (cast <fl> x) (cast <fl> y) (cast <fl> z)))))))
  
  
  (method (set-player-spawnpoint pos)
    (let ((tag (get-level-state)))
      (let ((player (tag-find "Player" (tag-assoc "Data" (tag-value tag)))))
        (tag-add player "SpawnX" TAG_Int (fxround (vertex-x pos)))
        (tag-add player "SpawnY" TAG_Int (fxround (vertex-y pos)))
        (tag-add player "SpawnZ" TAG_Int (fxround (vertex-z pos))))))
  
  
  (method (teleport pos (sight #f))
    (let ((world (current-world))
          (me (current-me)))
      (let ((eye (get-eye~ world)))
        (person-motion~ world feedback?: #f)
        (set-position~ me pos)
        (cond ((not sight)
               (derive-target~ eye)
               (camera-update~ eye))
              (else
               (set-lookat~ me (horizon-lookat sight))
               (eye-behind-player~ world)
               (follow-player~ world))))))
  
  
  (method (explode-blocks tnts blocks)
    (play-sound-file "sound/random/explode" volume: .25)
    (updating-sections
      (lambda (add-section)
        (for-each (lambda (tnt)
                    (remove-block! tnt add-section))
                  tnts)
        (for-each (lambda (block)
                    (remove-block! block add-section)) blocks))
      delay-update?: #t))
  
  
  (method (reveal-chests command-block blocks)
    (updating-sections
      (lambda (add-section)
        (loop (for x from 0 below (fxceiling (/ (length blocks) 6.)))
              (let ((pos (random-element blocks)))
                (set! blocks (remove pos blocks test: equal?))
                (place-block! pos RedstoneTorchOn add-section)))
        (remove-block (car command-block) add-section))))
  
  
  (method (testfor-action command-block test action)
    (call-with-position (car test)
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (when (= block-id (cdr test))
          (updating-sections
            (lambda (add-section)
              (case (cdr action)
                ((remove) (remove-block (car action) add-section))
                ((delete) (remove-block! (car action) add-section))
                ((add)    (place-block! (caar action) (cdar action) add-section)))
              (remove-block (car command-block) add-section)))))))
  
  
  (method (remove-block pos add-section)
    (call-with-position pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (with-field i j k
          (lambda (section index)
            (add-section section)
            (block-set! section index 0)
            (data-set! section index 0))))))
  
  
  (method (remove-block! pos add-section)
    (call-with-position pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (delete-block~ (current-game) #f section block-id data-id i j k x y z add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (place-block! pos block add-section)
    (call-with-position pos
      (lambda (section block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (add-block~ (current-game) #f #f block section block-id data-id i j k x y z add-section with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
  
  
  (method (on-toggle-glow evt)
    (let ((world (current-world)))
      (if (= player-glow -1.)
          (set! player-glow 300.)
        (set! player-glow -1.))
      (update-parameter~ world 'glow)))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method (call-with-position pos <vertex> proc (create?: create? #t))
    (let ((section (position-section pos create?: create?)))
      (and section
           (let ((x (fxfloor (vertex-x pos)))
                 (y (fxfloor (vertex-y pos)))
                 (z (fxfloor (vertex-z pos))))
             (let ((section-index (get-index~ section)))
               (let ((section-x (index-x section-index))
                     (section-y (index-y section-index))
                     (section-z (index-z section-index)))
                 (let ((i (- x (* section-x 16)))
                       (j (- y (* section-y 16)))
                       (k (- z (* section-z 16))))
                   (call-with-section section i j k proc))))))))
  
  
  (method (call-with-section section i <fx> j <fx> k <fx> proc)
    (with-index~ section
      (lambda (section-x section-y section-z)
        (let ((region (get-region~ (get-chunk~ section))))
          (let ((region-x (get-x~ region))
                (region-z (get-z~ region))
                (chunk-x (section->chunk section-x))
                (chunk-z (section->chunk section-z))
                (sections (neighbor-sections section section-x section-y section-z)))
            (let ((bottom-section? (= section-y (cast <fx> (or truncate-y 0))))
                  (position-x (+ (* region-x 32 16) (* chunk-x 16) i))
                  (position-y (+ (* section-y 16) j))
                  (position-z (+ (* region-z 32 16) (* chunk-z 16) k))
                  (blocks (get-blocks~ section))
                  (data (get-data~ section))
                  (blocklight (get-blocklight~ section))
                  (skylight (get-skylight~ section)))
              (define (section-ref a <fx> b <fx> c <fx>) <World-Section+>
                (vector-ref sections (section-index a b c)))
              
              (define (section-index a <fx> b <fx> c <fx>) <fx>
                (+ (* b 9) (* c 3) a 13))
              
              (define (local-index i <fx> j <fx> k <fx>) <fx>
                (+ (* j 256) (* k 16) i))
              
              (define (block-ref section local-index <fx>) <fx>
                (u8vector-ref (get-blocks~ section) local-index))
              
              (define (block-set! section local-index <fx> block-id <fx>)
                (u8vector-set! (get-blocks~ section) local-index block-id))
              
              (define (data-ref section local-index <fx>) <fx>
                (u4vector-ref (get-data~ section) local-index))
              
              (define (data-set! section local-index <fx> data-id <fx>)
                (u4vector-set! (get-data~ section) local-index data-id))
              
              (define (blocklight-ref section local-index <fx>) <fx>
                (u4vector-ref (get-blocklight~ section) local-index))
              
              (define (blocklight-set! section local-index <fx> blocklight <fx>)
                (u4vector-set! (get-blocklight~ section) local-index blocklight))
              
              (define (skylight-ref section local-index <fx>) <fx>
                (u4vector-ref (get-skylight~ section) local-index))
              
              (define (skylight-set! section local-index <fx> skylight <fx>)
                (u4vector-set! (get-skylight~ section) local-index skylight))
              
              (define (u4vector-ref field <u8vector> index <fx>) <fx>
                (let ((byte (u8vector-ref field (quotient index 2))))
                  (if (even? index)
                      (bitwise-and byte #x0F)
                    (bitwise-and (arithmetic-shift-right byte 4) #x0F))))
              
              (define (u4vector-set! field <u8vector> index <fx> value <fx>)
                (let ((offset (quotient index 2)))
                  (let ((byte (u8vector-ref field offset)))
                    (u8vector-set! field offset
                      (if (even? index)
                          (bitwise-ior value (bitwise-and byte #xF0))
                        (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4)))))))
              
              (define (with-field i <fx> j <fx> k <fx> proc)
                (define (bind-i a <fx> i <fx>)
                  (define (bind-j b <fx> j <fx>)
                    (define (bind-k c <fx> k <fx>)
                      (let ((section (section-ref a b c)))
                        (proc section (local-index i j k))))
                    
                    (cond ((< k 0) (bind-k (- (quotient k 16) 1) (modulo k 16)))
                          ((> k 15) (bind-k (quotient k 16) (modulo k 16)))
                          (else (bind-k 0 k))))
                  
                  (cond ((< j 0) (bind-j (- (quotient j 16) 1) (modulo j 16)))
                        ((> j 15) (bind-j (quotient j 16) (modulo j 16)))
                        (else (bind-j 0 j))))
                
                (cond ((< i 0) (bind-i (- (quotient i 16) 1) (modulo i 16)))
                      ((> i 15) (bind-i (quotient i 16) (modulo i 16)))
                      (else (bind-i 0 i))))
              
              (let ((index (local-index i j k)))
                (let ((block-id (block-ref section index))
                      (data-id (data-ref section index)))
                  (let ((x (fl& (+ block-radius (cast <fl> position-x))))
                        (y (fl& (+ block-radius (cast <fl> position-y))))
                        (z (fl& (+ block-radius (cast <fl> position-z)))))
                    (proc section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))))))))
  
  
  (method (updating-sections proc (delay-update?: delay-update? #f) (script?: script? #f))
    (define (update-sections sections)
      (for-each (lambda (section)
                  (let ((area (find-area (get-index~ section))))
                    (when area
                      (clear-polygons~ area)
                      (set-physical-uptodate?~ area #f)))
                  ;; should iterate over every camera
                  (let ((eye-sector (find-eye-sector (get-index~ section))))
                    (when eye-sector
                      (set-visual-uptodate?~ eye-sector #f)
                      (unless (and delay-update? delay-updating?)
                        (set-visual-generating?~ eye-sector #t) ;; $$$ was sector. is this correct?
                        (increase-sectors-generating 1)
                        (instantiate-visual eye-sector))))
                  (modified~ (get-chunk~ section)))
                sections))
    
    (define (save-regions)
      (iterate-regions
        (lambda (region)
          (save-region~ region))))
    
    (let ((sections '()))
      (define (add-section section)
        (unless (memq? section sections)
          (set! sections (cons section sections))))
      
      (let ((timer (new Timer)))
        (define (updating)
          (prog1 (proc add-section)
            (update-sections sections)
            (save-regions)))
        
        (prog1 (updating)
          (when report-updating?
            (let ((world (current-world)))
              (let ((count (length sections))
                    (duration (real-duration-in-milliseconds~ timer)))
                (display-message~ world (format "Updated {a} section{a} ({a}ms)" count (format-plural count) duration)))))))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method (evaluate-hook forms syntax str container line col)
    (let ((ids (collect (lambda (form)
                          (and (pair? form) (eq? (car form) 'define-block)
                            (third form)))
                        forms)))
      (cond ((not-null? ids)
             (reset-inventory-blocks)
             @$$$
             (updating-sections
               (lambda (add-section)
                 (finding-visual-blocks ids
                   add-section)
                 (finding-physical-blocks ids
                   (lambda (area)
                     (add-section (get-section~ area)))))))
            @$$$
            ((search container "world/external/minecraft")
             (updating-sectors
               (lambda (add-sector)
                 (add-sector (element-sector (current-me)))))))))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  (method (block-at pos)
    (call-with-position pos
      (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        block-id)))
  
  
  (method (block/data-at pos)
    (call-with-position pos
      (lambda (section block-id data-id i j k x y z with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
        (cons block-id data-id))))
  
  
  (method (find-visual-blocks ids)
    (let ((queue (new-queue)))
      (iterate-sectors
        (lambda (sector)
          (sector-iterate-blocks sector ids
            (lambda (found)
              (enqueue queue (cons sector (index->coordinates found)))))))
      (queue-list queue)))
  
  
  (method (finding-visual-blocks ids proc)
    (iterate-sectors
      (lambda (sector)
        (when (sector-contains-blocks? sector ids)
          (proc sector)))))
  
  
  (method (sector-contains-blocks? sector ids)
    (continuation-capture
      (lambda (found)
        (sector-iterate-blocks sector ids
          (lambda (ignore)
            (continuation-return found #t)))
        #f)))
  
  
  (method (sector-iterate-blocks sector ids proc)
    (let ((section (index-section (get-index~ sector))))
      (when section
        (section-iterate-blocks section ids proc))))
  
  
  (method (section-iterate-blocks section ids proc)
    (let ((blocks (get-blocks~ section)))
      (for-each (lambda (id)
                  (let (iter (pos 0))
                    (let ((found (u8vector-find id blocks (u8vector-length blocks) pos)))
                      (when found
                        (proc found)
                        (iter (+ found 1))))))
                ids)))
  
  
  (method (section-count-blocks section)
    (let ((blocks (get-blocks~ section))
          (count 0))
      (loop (for n from 0 below 4096)
            (let ((block (u8vector-ref blocks n)))
              (when (/= block Air)
                (increase! count))))
      count))
  
  
  (method (finding-physical-blocks ids proc)
    @convert^^^
    (iterate-areas
      (lambda (index area)
        (iterate-polygons~ area #f
          (lambda (env elem polygons offset)
            (let ((data1 (f64vector-ref polygons (+ offset 16))))
              (when (and (/= data1 0.) (memq? (flonum->fixnum data1) ids))
                (proc area)))))))))


;;;
;;;; Procedural Zones
;;;


(proclaim (warn optimizations))


;; Ideally, this would use a PRNG which we can seed with a given value.
;; That way the map can be persisted using just the seed and a list of changes.
@convert^^^
(class Procedural-Zone extends Zone
  
  
  (property detail-level <fl> initialize 15. accessors generate)
  (property clamp-height <fl> initialize 65. accessors generate)
  
  
  (method override (setup-component)
    (nextmethod)
    @old
    (set! generator (new Perlin-Generator detail-level clamp-height)))
  
  
  (method override (zone-editable?)
    (world-setting 'world.procedural-editable? #f))
  
  
  (method override (zone-destructible?)
    (zone-editable?))
  
  
  (method override (generate-visual sector <Sector>)
    (let ((index (get-index~ sector)))
      (let ((x (index-x index))
            (y (index-y index))
            (z (index-z index)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural sector from-x width from-z depth 'visual)))))
    (set-visual-uptodate?~ sector #t)
    (decrease-sectors-generating 1))
  
  
  (method override (generate-physical sector <Sector> revision-update?)
    (let ((index (get-index~ sector)))
      (let ((x (index-x index))
            (y (index-y index))
            (z (index-z index)))
        (when (= y 0)
          (let ((from-x (* x sector-size))
                (width sector-size)
                (from-z (* z sector-size))
                (depth sector-size))
            (generate-procedural sector from-x width from-z depth 'physical))))))
  
  
  (method (generate-procedural sector <Sector> from-x <fx> width <fx> from-z <fx> depth <fx> what)
    (let ((world (current-world))
          (x-count (+ width 1))
          (z-count (+ depth 1)))
      (define (generator-heightmap)
        (let ((heightmap <f32vector> (make-f32vector (* x-count z-count))))
          (loop (for x from 0 below x-count)
                (loop (for z from 0 below z-count)
                      (f32vector-set! heightmap (+ (* x z-count) z)
                        ;; max and min are quick hacks until perlin generator is fixed
                        (max 0. (min 10. (/ (get-value~ generator (cast <fl> (+ from-x x)) (cast <fl> (+ from-z z))) 5.))))))
          heightmap))
      
      (generate-heightmap-old sector (generator-heightmap) from-x width from-z depth what)))))
