;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Games
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.game jazz


(import (jazz.application)
        (jazz.geometry)
        (jazz.platform)
        (world)
        (world.actor)
        (world.audio)
        (world.autoload)
        (world.block)
        (world.element)
        (world.generation)
        (world.geometry)
        (world.interface.documents)
        (world.interface.inventory)
        (world.mark)
        (world.polygon)
        (world.redstone)
        (world.scripting)
        (world.settings)
        (world.spawn)
        (world.syntax (phase syntax))
        (world.travel))


;;;
;;;; Game
;;;


(class World-Game extends Object
  
  
  (slot repeaters       initialize '()          accessors generate)
  (slot pressure-plates initialize (make-table) accessors generate)
  (slot lava-blocks     initialize (new-queue)  accessors generate)
  (slot water-blocks    initialize (new-queue)  accessors generate)
  (slot fall-blocks     initialize (new-queue)  accessors generate)
  
  
  (method (add-fall-block sector i j k)
    (let ((item (list sector i j k)))
      (unless (member? item (queue-list fall-blocks))
        (enqueue fall-blocks item))))
  
  
  (method (with-interaction proc (filter: filter #f))
    (let ((world (current-world))
          (camera (current-camera)))
      (let ((pos (get-down-point~ world)))
        (when pos
          (receive (position direction) (screen->world~ camera (get-h~ pos) (get-v~ pos))
            (let ((max-distance (get-view-radius~ world)))
              (let ((closest (ray-closest-polygon (get-position~ camera) direction max-distance filter: filter ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
                (when closest
                  (let ((poly (car closest)))
                    (proc (or (get-element~ poly)
                              poly)))))))))))
  
  
  (method (with-polygon-interaction poly proc)
    (let ((center (get-center~ poly))
          (normal (get-normal~ poly)))
      (let ((block (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly)))
            (fore (vertex+ center (vertex-scalar*& normal .5))))
        (proc poly block fore))))
  
  
  (method (add-block-at poly fore id)
    (let ((zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (add-block-at-updating poly fore id add-sector)))))
  
  
  (method (add-block-at-updating poly fore id add-sector)
    (let ((zone (current-zone)))
      (call-with-position~ zone fore
        (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
          (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)))))
  

  (method (delete-block-at block)
    (let ((world (current-world))
          (zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (delete-block-at-updating block add-sector)))
      (reset-selection~ world)))
  

  (method (delete-block-at-updating block add-sector)
    (let ((zone (current-zone)))
      (call-with-position~ zone block
        (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
          (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)))))
  
  
  @wait
  (method (explose-blocks-at block)
    (let ((world (current-world))
          (zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (call-with-position~ zone block
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
              (let ((radius 2.)
                    (center (vertex x y z)))
                (loop (for a from -2 to 2)
                      (loop (for b from -2 to 2)
                            (loop (for c from -2 to 2)
                                  (let ((pos (vertex (+ x (cast <fl> a)) (+ y (cast <fl> b)) (+ z (cast <fl> c)))))
                                    (when (<= (vertex-distance center pos) radius)
                                      (delete-block region sector block-id data-id (+ i a) (+ j b) (+ k c) (vertex-x pos) (vertex-y pos) (vertex-z pos) uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)))))))))))))

  
  (method (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
    (with-field i j k
      (lambda (section index)
        (let ((can-add? #t))
          (define (set-blockid id)
            (define (determine-torch-rotation)
              (case (polygon-orientation)
                ((up down) 5)
                ((east) 1)
                ((west) 2)
                ((south) 3)
                ((north) 4)))
            
            (define (determine-lever-rotation)
              (case (polygon-orientation)
                ((up) 5)
                ((down) 7)
                ((east) 1)
                ((west) 2)
                ((south) 3)
                ((north) 4)))
            
            (define (determine-button-rotation)
              (case (polygon-orientation)
                ((up) 5)
                ((down) 0)
                ((east) 1)
                ((west) 2)
                ((south) 3)
                ((north) 4)))
            
            (define (determine-ladder-rotation)
              (case (polygon-orientation)
                ((up down) 2)
                ((north) 2)
                ((south) 3)
                ((west) 4)
                ((east) 5)))
            
            (define (polygon-orientation)
              (let ((normal (get-normal~ poly)))
                (if (> (vertex-y normal) 0.)
                    'up
                  (if (< (vertex-y normal) 0.)
                      'down
                    (let ((angle (plane-angle 1. 0. (vertex-x normal) (vertex-z normal))))
                      (cond ((or (between? angle 0. PI/4) (between? angle (- PI*2 PI/4) PI*2)) 'east)
                            ((between? angle PI/4 (* 3. PI/4)) 'north)
                            ((between? angle (* 3. PI/4) (* 5. PI/4)) 'west)
                            (else 'south)))))))
            
            (define (determine-piston-rotation)
              (let ((normal (get-normal~ poly)))
                (cond ((> (vertex-y normal) 0.) 1)
                      ((< (vertex-y normal) 0.) 0)
                      ((> (vertex-x normal) 0.) 5)
                      ((< (vertex-x normal) 0.) 4)
                      ((> (vertex-z normal) 0.) 3)
                      ((< (vertex-z normal) 0.) 2))))
            
            (define (camera-orientation (dir #f))
              (define (get-direction)
                (let ((camera (current-camera)))
                  (let ((sight (get-sight~ (get-lookat~ camera))))
                    (vertex-normalize (vertex (vertex-x sight) 0. (vertex-z sight))))))
              
              (let ((direction (or dir (get-direction))))
                (let ((angle (plane-angle 1. 0. (vertex-x direction) (vertex-z direction))))
                  (cond ((or (between? angle 0. PI/4) (between? angle (* 7 PI/4) (* 2 PI)))
                         'east)
                        ((between? angle PI/4 (* 3 PI/4))
                         'north)
                        ((between? angle (* 3 PI/4) (* 5 PI/4))
                         'west)
                        (else
                         'south)))))
            
            (define (determine-repeater-rotation)
              (case (camera-orientation)
                ((north) 0)
                ((south) 2)
                ((west) 3)
                ((east) 1)))
            
            (define (add-bed)
              (let ((orientation (camera-orientation)))
                (define (bed-data)
                  (case orientation
                    ((north) 2)
                    ((south) 0)
                    ((east) 3)
                    ((west) 1)))
                
                (define (add-top a b c data)
                  (with-field (+ i a) (+ j b) (+ k c)
                    (lambda (section index)
                      (if (id? (block-ref section index) Air TallGrass DeadBush Vines Snow)
                          (begin
                            (block-set! section index BedBlock)
                            (data-set! section index (bit-set data 3 #t))) ;; redstone update
                        (set! can-add? #f)))))
                
                (apply add-top (case (bed-data)
                                 ((0) (list  0 0  1 0))
                                 ((1) (list -1 0  0 1))
                                 ((2) (list  0 0 -1 2))
                                 ((3) (list  1 0  0 3))))
                (when can-add?
                  (data-set! section index (bed-data)))))
            
            (define (add-door)
              (with-field i (- j 1) k
                (lambda (section index)
                  (let ((block (world.generation:id->block (block-ref section index))))
                    (set! can-add? (and (get-cube?~ block) (get-opaque-cube?~ block))))))
              (with-field i (+ j 1) k
                (lambda (section index)
                  (set! can-add? (and can-add? (id? (block-ref section index) Air Vines)))
                  (when can-add?
                    (block-set! section index block-id)
                    (data-set! section index 8)))) ;; left or right hinge
              (when can-add?
                (data-set! section index (case (camera-orientation)
                                           ((north) 3)
                                           ((south) 1)
                                           ((east) 0)
                                           ((west) 2)))))
            
            (if poly
                (ccase id ;; polygon orientation
                  ((RedstoneTorchOn Torch)
                   (data-set! section index (determine-torch-rotation)))
                  ((Lever)
                   (data-set! section index (determine-lever-rotation)))
                  ((WoodenButton StoneButton)
                   (data-set! section index (determine-button-rotation)))
                  ((Ladder)
                   (data-set! section index (determine-ladder-rotation)))
                  ((Piston StickyPiston)
                   (data-set! section index (determine-piston-rotation))))
              (data-set! section index 0))
            
            (ccase id ;; camera orientation or special blocks
              ((RedstoneRepeaterBlockOff)
               (data-set! section index (determine-repeater-rotation)))
              ((BedBlock)
               (add-bed))
              ((WoodenDoorBlock IronDoorBlock)
               (add-door))
              ((Sand Gravel)
               (add-fall-block sector i j k)))
            
            (when can-add?
              (block-set! section index id)
              (when (get-water-cube?~ (id->block id))
                (if (id? id Lava)
                    (enqueue lava-blocks (cons (get-sector~ section) (index->coordinates index)))
                  (enqueue water-blocks (cons (get-sector~ section) (index->coordinates index)))))
              (redstone-update sector (list i j k id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!)))
          
          (if (and poly (id? (fxround (get-data1~ poly)) Vines DeadBush RedMushroom BrownMushroom TallGrass DoublePlant))
              (call-with-position~ (current-zone) (vertex (get-data2~ poly)
                                                          (get-data3~ poly)
                                                          (get-data4~ poly))
                (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                  (let ((new-poly (new world.polygon:Polygon (get-element~ poly) (vector (vertex& (- x .5) (- y 1.) (- z .5)) (vertex& (- x .5) (- y 1.) (+ z .5)) (vertex& (+ x .5) (- y 1.) (- z .5)) (vertex& (+ x .5) (- y 1.) (+ z .5))))))
                    (with-field i j k
                      (lambda (section index)
                        (add-sector (get-sector~ section))
                        (block-set! section index Air)))
                    (set-data1~ new-poly 1.)
                    (add-block #f id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
            (begin
              (case id
                ((52)
                 (set-spawner-added? #t))
                ((54)
                 (block-entity-add region sector i j k)))
              
              (let ((brightness (get-brightness~ (id->block id))))
                (when (id? (block-ref section index) Air Water Lava StationaryWater StationaryLava)
                  (cond (brightness
                          (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                          (propagate-light i j k brightness add-sector with-field block-ref blocklight-ref blocklight-set!)
                          (set-blockid id)
                          (inverse-propagate-skylight i j k (skylight-ref section index) add-sector with-field block-ref skylight-ref skylight-set!))
                        (else
                         (set-blockid id)
                         (inverse-propagate-skylight i j k (skylight-ref section index) add-sector with-field block-ref skylight-ref skylight-set!)
                         (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                         (when (get-opaque-cube?~ (id->block id))
                           (blocklight-set! section index 0))))))
              (add-sector sector)))))))
  
  
  (method (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
    ;; can be improved by testing for opaque blocks in all directions
    ;; and then testing that every block in all directions is opaque
    (define (add-neighbors add-sector)
      (define (add i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              @w(when (memq? (block-ref section index) '(8 9))
                (enqueue water-blocks (cons (get-sector~ section) (index->coordinates index))))
              @w(when (memq? (block-ref section index) '(10 11))
                (enqueue lava-blocks (cons (get-sector~ section) (index->coordinates index))))))))
      
      (add (- i 1) j k)
      (add (+ i 1) j k)
      (add i (- j 1) k)
      (add i (+ j 1) k)
      (add i j (- k 1))
      (add i j (+ k 1)))
    
    (add-neighbors add-sector)
    (with-field i j k
      (lambda (section index)
        (define (find-max-light-around i j k)
          (define (find-light i j k)
            (with-field i j k
              (lambda (section index)
                (if (not section)
                    0
                  (blocklight-ref section index)))))
          
          (let ((left (find-light (- i 1) j k))
                (right (find-light (+ i 1) j k))
                (down (find-light i (- j 1) k))
                (up (find-light i (+ j 1) k))
                (back (find-light i j (- k 1)))
                (front (find-light i j (+ k 1))))
            (max left right down up back front)))
        
        (define (get-skylight i j k)
          (define (top-skylight)
            (with-field i (+ j 1) k
              (lambda (section index)
                (or (when section
                      (let ((light (skylight-ref section index)))
                        (if (= light 15) 15 (- light 1))))
                    0))))
          
          (define (side-skylight i j k)
            (with-field i j k
              (lambda (section index)
                (or (when section
                      (- (skylight-ref section index) 1))
                    0))))
          
          (max (top-skylight)
               (side-skylight (- i 1) j k)
               (side-skylight (+ i 1) j k)
               (side-skylight i j (- k 1))
               (side-skylight i j (+ k 1))
               (side-skylight i (- j 1) k)
               0))
        
        (define (delete-bed)
          (let ((top? (bit-set? 3 data-id)))
            (define (other-part)
              (case (bit-set data-id 3 #f)
                ((0) (list  0  1))
                ((1) (list -1  0))
                ((2) (list  0 -1))
                ((3) (list  1  0))
                (else (list 0 0))))
            
            (bind (a c) (other-part)
              (with-field (+ i (* a (if top? -1 1))) j (+ k (* c (if top? -1 1)))
                (lambda (section index)
                  (block-set! section index 0)
                  (data-set! section index 0))))))
        
        (define (delete-piston)
          (let ((top? (id? block-id PistonHead)))
            (define (other-part)
              (case (bit-set data-id 3 #f)
                ((0) (list  0 -1  0))
                ((1) (list  0  1  0))
                ((2) (list  0  0 -1))
                ((3) (list  0  0  1))
                ((4) (list -1  0  0))
                ((5) (list  1  0  0))
                (else (list 0 0 0))))
            
            (bind (a b c) (other-part)
              (with-field (+ i (* a (if top? -1 1))) (+ j (* b (if top? -1 1))) (+ k (* c (if top? -1 1)))
                (lambda (section index)
                  (block-set! section index 0)
                  (data-set! section index 0))))))
        
        (let ((brightness (get-brightness~ (id->block block-id))))
          (block-set! section index 0)
          (when (id? block-id IronDoorBlock WoodenDoorBlock DoublePlant)
            (with-field i ((if (bit-set? 3 data-id) - +) j 1) k
              (lambda (section index)
                (block-set! section index 0)
                (data-set! section index 0))))
          (when (id? block-id BedBlock)
            (delete-bed))
          (when (or (and (id? block-id Piston StickyPiston) (bit-set? 3 data-id)) (id? block-id PistonHead))
            (delete-piston))
          (if brightness
              (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
            (begin
              (blocklight-set! section index 0)
              (propagate-light i j k (- (find-max-light-around i j k) 1) add-sector with-field block-ref blocklight-ref blocklight-set!)))
          (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
          (skylight-set! section index (get-skylight i j k))
          (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
          (redstone-update sector (list i j k block-id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!)
          (data-set! section index 0)))))
  
  
  (method (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (propagate i j k light)
        (with-field i j k
          (lambda (section index)
            (when section
              ;; always adding the sector covers the case where the light changes
              ;; and we need to update all neighboring sectors even if no light changes for
              ;; them like when putting a torch next to a wall that is in the next sector
              (add-sector (get-sector~ section))
              (when (and (> light 0)
                         (< (blocklight-ref section index) light)
                         (not (get-opaque-cube?~ (id->block (block-ref section index)))))
                (blocklight-set! section index light)
                (let ((light (- light 1)))
                  (define (add-queue i j k)
                    (enqueue queue (list i j k light)))
                  
                  (add-queue (- i 1) j k)
                  (add-queue (+ i 1) j k)
                  (add-queue i (- j 1) k)
                  (add-queue i (+ j 1) k)
                  (add-queue i j (- k 1))
                  (add-queue i j (+ k 1))))
              (let (iter)
                (unless (queue-empty? queue)
                  (apply propagate (dequeue queue))
                  (iter)))))))
      
      (propagate i j k light)))
  
  
  (method (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (inverse-propagate i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (let ((light (blocklight-ref section index)))
                (define (look-around i j k light)
                  (with-field i j k
                    (lambda (section index)
                      (when section
                        (add-sector (get-sector~ section))
                        (let ((new-light (blocklight-ref section index)))
                          (unless (= new-light 0)
                            (if (< new-light light)
                                (inverse-propagate i j k)
                              (enqueue queue (list i j k)))))))))
                
                (unless (= light 0)
                  (blocklight-set! section index 0)
                  (look-around (- i 1) j k light)
                  (look-around (+ i 1) j k light)
                  (look-around i (- j 1) k light)
                  (look-around i (+ j 1) k light)
                  (look-around i j (- k 1) light)
                  (look-around i j (+ k 1) light)))))))
      
      (inverse-propagate i j k)
      (let (iter)
        (unless (queue-empty? queue)
          (bind (i j k) (dequeue queue)
            (with-field i j k
              (lambda (section index)
                (let ((light (blocklight-ref section index)))
                  (unless (= light 0)
                    (blocklight-set! section index 0)
                    (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!))))))
          (iter)))))
  
  
  (method (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((queue (new-queue)))
      (define (propagate i j k light (first #f))
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (when (and (> light 0)
                         (or first (> light (skylight-ref section index)))
                         (not (get-opaque-cube?~ (id->block (block-ref section index)))))
                (skylight-set! section index light)
                (let ((light2 (- light 1)))
                  (define (add-queue i j k (amount light2))
                    (enqueue queue (list i j k amount)))
                  
                  (add-queue (- i 1) j k)
                  (add-queue (+ i 1) j k)
                  (add-queue i (- j 1) k (if (= light 15) 15 light2))
                  (unless (= light 15)
                    (add-queue i (+ j 1) k))
                  (add-queue i j (- k 1))
                  (add-queue i j (+ k 1))))
              (let (iter)
                (unless (queue-empty? queue)
                  (apply propagate (dequeue queue))
                  (iter)))))))
      
      (with-field i j k
        (lambda (section index)
          (propagate i j k (skylight-ref section index) #t)))))
  
  
  (method (inverse-propagate-skylight i j k first-light add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((inverse-spots (new-queue))
          (propagate-spots (new-queue)))
      (define (add-queue item queue)
        (unless (member? item (queue-list queue))
          (enqueue queue item)))
      
      (define (inverse-propagate i j k previous (first #f))
        (with-field i j k
          (lambda (section index)
            (when section
              (let ((current-light (if first first-light (skylight-ref section index))))
                (define (add-around)
                  (add-queue (list (- i 1) j k current-light) inverse-spots)
                  (add-queue (list (+ i 1) j k current-light) inverse-spots)
                  (add-queue (list i j (- k 1) current-light) inverse-spots)
                  (add-queue (list i j (+ k 1) current-light) inverse-spots)
                  (add-queue (list i (+ j 1) k current-light) inverse-spots)
                  (add-queue (list i (- j 1) k (if (= current-light 15) 16 current-light)) inverse-spots))
                
                (unless (and (not first)
                             (or (= current-light 0)
                                 (get-opaque-cube?~ (id->block (block-ref section index)))))
                  (if (or first (< current-light previous))
                      (begin
                        (skylight-set! section index 0)
                        (add-sector (get-sector~ section))
                        (add-around))
                    (begin
                      (add-queue (list i j k) propagate-spots)))))))))
      
      (inverse-propagate i j k 0 #t)
      (let (iter-inverse)
        (unless (queue-empty? inverse-spots)
          (apply inverse-propagate (dequeue inverse-spots))
          (iter-inverse)))
      (let (iter-propagate)
        (unless (queue-empty? propagate-spots)
          (bind (i j k) (dequeue propagate-spots)
            (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
            (iter-propagate))))))
  
  
  (method (pressure-plates-update add-to remove-from actor) ;; bug: getting off and on quickly
    (define (table-remove table key)
      (list->table (map (lambda (x) (cons x (table-ref table x))) (remove key (table-keys table) test: equal?))))
    
    (define (pp-test pp1 pp2)
      (when (and (is? pp1 Pressure-Plate) (is? pp2 Pressure-Plate))
        (equal? (location~ pp1) (location~ pp2))))
    
    (let ((zone (current-zone)))
      (for-each (lambda (pos)
                  (let ((pp (table-ref pressure-plates pos #f)))
                    (if pp
                        (begin
                          (set-colliders~ pp (cons actor (get-colliders~ pp)))
                          (table-set! pressure-plates pos pp))
                      (call-with-position~ zone pos ;; add new pressure plate
                        (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                          (table-set! pressure-plates pos (new-pressure-plate sector i j k 5 actor with-field))
                          (set-repeaters~ self (remove pp repeaters test: pp-test))
                          ;; play sound
                          (updating-sectors~ zone
                            (lambda (add-sector)
                              (redstone-update sector (list i j k block-id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! #t))))))))
                add-to)
      (for-each (lambda (pos) ;; remove actor from pressure plates
                  (let ((pp (table-ref pressure-plates pos #f)))
                    (let ((colliders (get-colliders~ pp)))
                      (set! colliders (remove actor colliders))
                      (if (null? colliders)
                          (begin
                            (set! pressure-plates (table-remove pressure-plates pos)) ;; test weak-values
                            (set! repeaters (cons pp repeaters))) ;; unpower
                        (begin
                          (set-colliders~ pp colliders)
                          (table-set! pressure-plates pos pp))))))
                remove-from)))
  
  
  (definition interaction-distance <fl>
    (world-setting 'world.interaction-distance 8.))
  
  
  (definition public (liquid-filter poly)
    (not (get-water-cube?~ (world.generation:id->block (fxround (get-data1~ poly))))))
  
  
  (method (max-interaction-distance)
    (let ((world (current-world)))
      (if (user-role?)
          interaction-distance
        (get-view-radius~ world))))
  
  
  (method (deposit-block h v)
    (let ((zone (current-zone)))
      (with-interaction
        (lambda (obj)
          (when (polygon? obj)
            (with-polygon-interaction obj
              (lambda (poly block fore)
                (call-with-position~ zone block
                  (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                    (let ((count (if (shift-down?) 10 1)))
                      (deposit-inventory block-id count: count)))))))))))
  
  
  (method protected virtual (mouse-up h v)
    (let ((me (current-me)))
      (with-interaction
        (lambda (obj)
          (when (polygon? obj)
            (with-polygon-interaction obj
              (lambda (poly block fore)
                (let ((distance (vertex-distance block (get-position~ me)))
                      (max-distance (max-interaction-distance)))
                  (when (<= distance max-distance)
                    (delete-block-at block)))))))
        filter: liquid-filter)))
  
  
  (method protected virtual (right-mouse-up h v)
    (let ((interface (current-interface))
          (world (current-world))
          (zone (current-zone))
          (me (current-me)))
      (with-interaction
        (lambda (obj)
          (if (element? obj)
              (when (is? obj Actor)
                (let ((interact (get-script-interact~ obj)))
                  (when interact
                    (running-handler~ obj
                      (lambda ()
                        (parameterize ((current-event (new Interact-Event obj (current-seconds))))
                          (interact obj)))))))
            (with-polygon-interaction obj
              (lambda (poly clicked fore)
                (let ((distance (vertex-distance clicked (get-position~ me)))
                      (max-distance (max-interaction-distance)))
                  (when (<= distance max-distance)
                    (call-with-position~ zone clicked
                      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                        (let ((block (id->block block-id)))
                          (let ((right-mouse (get-right-mouse~ block)))
                            (if right-mouse
                                (right-mouse region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                              (let ((slot (selected-slot~ (child~ interface 'belt))))
                                (let ((id (get-id~ slot)))
                                  (when id
                                    (place-slot slot poly clicked fore)))))))))))))))
        filter: liquid-filter)))
  
  
  (method (interaction-element h v)
    (let ((zone (current-zone))
          (me (current-me)))
      (with-interaction
        (lambda (obj)
          (if (element? obj)
              obj
            (with-polygon-interaction obj
              (lambda (poly clicked fore)
                (let ((distance (vertex-distance clicked (get-position~ me)))
                      (max-distance (max-interaction-distance)))
                  (when (<= distance max-distance)
                    (call-with-position~ zone clicked
                      (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                        (let ((block (id->block block-id)))
                          (new Block-Entity model: (get-name~ block) position: (polygon-position poly)))))))))))
        filter: liquid-filter)))
  
  
  ;; need a section that gets called from scripts and tests that distance, ... are all valid
  (method (interact-at pos)
    (let ((zone (current-zone)))
      (call-with-position~ zone pos
        (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
          (let ((block (id->block block-id)))
            (let ((right-mouse (get-right-mouse~ block)))
              (when right-mouse
                (right-mouse region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))))))
  
  
  (method protected virtual (place-slot slot poly clicked fore)
    (let ((id (get-id~ slot)))
      (if (>= id 256)
          (bell)
        (add-block-at poly fore id)
        (decrease-count~ slot))))))
