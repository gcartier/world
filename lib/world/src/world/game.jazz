;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Games
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.game jazz


(import (jazz.application)
        (jazz.geometry)
        (jazz.platform)
        (world)
        (world.audio)
        (world.autoload)
        (world.generation)
        (world.geometry)
        (world.interface.documents)
        (world.interface.inventory)
        (world.redstone)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Game
;;;


(class World-Game extends Object
  
  
  (slot repeaters       initialize '()                          accessors generate)
  (slot pressure-plates initialize (make-table)                 accessors generate)
  (slot lava-blocks     initialize (new-queue)                  accessors generate)
  (slot water-blocks    initialize (new-queue)                  accessors generate)
  (slot fall-blocks     initialize (new-queue)                  accessors generate)
  
  
  (method (add-fall-block sector i j k)
    (let ((item (list sector i j k)))
      (unless (member? item (queue-list fall-blocks))
        (enqueue fall-blocks item))))
  
  
  (method (with-interaction proc (filter: filter #f))
    (let ((world (current-world))
          (camera (current-camera)))
      (let ((pos (get-down-point~ world)))
        (when pos
          (receive (position direction) (screen->ray~ camera (get-h~ pos) (get-v~ pos))
            (let ((max-distance (get-view-radius~ world)))
              (let ((closest (ray-closest-polygon~ world (get-position~ camera) direction max-distance filter: filter ignore-non-physical?: #f ignore-entities?: #f ignore-players?: #t)))
                (when closest
                  (let ((poly (car closest)))
                    (with-polygon-interaction poly
                      proc))))))))))
  
  
  (method (with-polygon-interaction poly proc)
    (let ((center (get-center~ poly))
          (normal (get-normal~ poly)))
      (let ((block (vertex (get-data2~ poly) (get-data3~ poly) (get-data4~ poly)))
            (fore (vertex+ center (vertex-scalar*& normal .5))))
        (proc poly block fore))))
  
  
  (method (add-block-at poly fore id)
    (let ((zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (call-with-position~ zone fore
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
              (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)))))))
  

  (method (delete-block-at block)
    (let ((world (current-world))
          (zone (current-zone)))
      (updating-sectors~ zone
        (lambda (add-sector)
          (call-with-position~ zone block
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
              (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)))))
      (reset-selection~ world)))

  
  (method (add-block poly id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
    (with-field i j k
      (lambda (section index)
        (define (set-blockid id)
          (define (determine-torch-rotation)
            (case (polygon-orientation)
              ((up down) 5)
              ((east) 1)
              ((west) 2)
              ((south) 3)
              ((north) 4)))
          
          (define (determine-lever-rotation)
            (case (polygon-orientation)
              ((up) 5)
              ((down) 7)
              ((east) 1)
              ((west) 2)
              ((south) 3)
              ((north) 4)))
          
          (define (determine-button-rotation)
            (case (polygon-orientation)
              ((up) 5)
              ((down) 0)
              ((east) 1)
              ((west) 2)
              ((south) 3)
              ((north) 4)))
          
          (define (determine-ladder-rotation)
            (case (polygon-orientation)
              ((up down) 2)
              ((north) 2)
              ((south) 3)
              ((west) 4)
              ((east) 5)))
          
          (define (polygon-orientation)
            (let ((normal (get-normal~ poly)))
              (if (> (vertex-y normal) 0.)
                  'up
                (if (< (vertex-y normal) 0.)
                    'down
                  (let ((angle (plane-angle 1. 0. (vertex-x normal) (vertex-z normal))))
                    (cond ((or (between? angle 0. PI/4) (between? angle (- PI*2 PI/4) PI*2)) 'east)
                          ((between? angle PI/4 (* 3. PI/4)) 'north)
                          ((between? angle (* 3. PI/4) (* 5. PI/4)) 'west)
                          (else 'south)))))))
          
          (define (determine-piston-rotation)
            (let ((normal (get-normal~ poly)))
              (cond ((> (vertex-y normal) 0.) 1)
                    ((< (vertex-y normal) 0.) 0)
                    ((> (vertex-x normal) 0.) 5)
                    ((< (vertex-x normal) 0.) 4)
                    ((> (vertex-z normal) 0.) 2)
                    ((< (vertex-z normal) 0.) 3))))
          
          (define (determine-other-rotation)
            (let ((camera (current-camera)))
              (let ((sight (get-sight~ (get-lookat~ camera))))
                (let ((direction (vertex-normalize (vertex (vertex-x sight) 0. (vertex-z sight)))))
                  (let ((angle (plane-angle 1. 0. (vertex-x direction) (vertex-z direction))))
                    (cond ((or (between? angle 0. PI/4) (between? angle (* 7 PI/4) (* 2 PI)))
                           1)
                          ((between? angle PI/4 (* 3 PI/4))
                           0)
                          ((between? angle (* 3 PI/4) (* 5 PI/4))
                           3)
                          (else
                           2)))))))
          
          (if poly
              (ccase id
                ((RedstoneTorchOn Torch)
                 (data-set! section index (determine-torch-rotation)))
                ((Lever)
                 (data-set! section index (determine-lever-rotation)))
                ((WoodenButton StoneButton)
                 (data-set! section index (determine-button-rotation)))
                ((Ladder)
                 (data-set! section index (determine-ladder-rotation)))
                ((Piston StickyPiston)
                 (data-set! section index (determine-piston-rotation)))
                ((RedstoneRepeaterBlockOff)
                 (data-set! section index (determine-other-rotation)))
                ((Sand Gravel)
                 (add-fall-block sector i j k)))
            (data-set! section index 0))
          (block-set! section index id)
          (when (get-water-cube?~ (blockid->block id))
            (if (id? id Lava StationaryLava)
                (enqueue lava-blocks (cons (get-sector~ section) (index->coordinates index)))
              (enqueue water-blocks (cons (get-sector~ section) (index->coordinates index)))))
          (redstone-update sector (list i j k id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!))
        
        (if (and poly (id? (fxround (get-data1~ poly)) Vines DeadBush RedMushroom BrownMushroom  TallGrass DoublePlant))
            (call-with-position~ (current-zone) (vertex (get-data2~ poly)
                                                        (get-data3~ poly)
                                                        (get-data4~ poly))
              (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                (let ((new-poly (new world.polygon:Polygon (get-element~ poly) (vector (vertex& (- x .5) (- y 1.) (- z .5)) (vertex& (- x .5) (- y 1.) (+ z .5)) (vertex& (+ x .5) (- y 1.) (- z .5)) (vertex& (+ x .5) (- y 1.) (+ z .5))))))
                  (with-field i j k
                    (lambda (section index)
                      (add-sector (get-sector~ section))
                      (block-set! section index Air)))
                  (set-data1~ new-poly 1.)
                  (add-block #f id region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!))))
          (begin
            (case id
              ((54)
               (block-entity-add region sector i j k)))
            
            (let ((brightness (get-brightness~ (blockid->block id))))
              (when (id? (block-ref section index) Air Water Lava StationaryWater StationaryLava)
                (cond (brightness
                        (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                        (propagate-light i j k brightness add-sector with-field block-ref blocklight-ref blocklight-set!)
                        (set-blockid id)
                        (inverse-propagate-skylight i j k (skylight-ref section index) add-sector with-field block-ref skylight-ref skylight-set!))
                      (else
                       (set-blockid id)
                       (inverse-propagate-skylight i j k (skylight-ref section index) add-sector with-field block-ref skylight-ref skylight-set!)
                       (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
                       (when (get-opaque-cube?~ (blockid->block id))
                         (blocklight-set! section index 0))))))
            (add-sector sector))))))
  
  
  (method (delete-block region sector block-id data-id i j k x y z uv rendering add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
    ;; can be improved by testing for opaque blocks in all directions
    ;; and then testing that every block in all directions is opaque
    (define (add-neighbors add-sector)
      (define (add i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              @w(when (memq? (block-ref section index) '(8 9))
                (enqueue water-blocks (cons (get-sector~ section) (index->coordinates index))))
              @w(when (memq? (block-ref section index) '(10 11))
                (enqueue lava-blocks (cons (get-sector~ section) (index->coordinates index))))))))
      
      (add (- i 1) j k)
      (add (+ i 1) j k)
      (add i (- j 1) k)
      (add i (+ j 1) k)
      (add i j (- k 1))
      (add i j (+ k 1)))
    
    (add-neighbors add-sector)
    (with-field i j k
      (lambda (section index)
        (define (find-max-light-around i j k)
          (define (find-light i j k)
            (with-field i j k
              (lambda (section index)
                (if (not section)
                    0
                  (blocklight-ref section index)))))
          
          (let ((left (find-light (- i 1) j k))
                (right (find-light (+ i 1) j k))
                (down (find-light i (- j 1) k))
                (up (find-light i (+ j 1) k))
                (back (find-light i j (- k 1)))
                (front (find-light i j (+ k 1))))
            (max left right down up back front)))
        
        (define (get-skylight i j k)
          (define (top-skylight)
            (with-field i (+ j 1) k
              (lambda (section index)
                (or (when section
                      (let ((light (skylight-ref section index)))
                        (if (= light 15) 15 (- light 1))))
                    0))))
          
          (define (side-skylight i j k)
            (with-field i j k
              (lambda (section index)
                (or (when section
                      (- (skylight-ref section index) 1))
                    0))))
          
          (max (top-skylight)
               (side-skylight (- i 1) j k)
               (side-skylight (+ i 1) j k)
               (side-skylight i j (- k 1))
               (side-skylight i j (+ k 1))
               (side-skylight i (- j 1) k)
               0))
        
        (let ((brightness (get-brightness~ (blockid->block block-id))))
          (block-set! section index 0)
          (when (id? block-id IronDoorBlock WoodenDoorBlock DoublePlant)
            (with-field i ((if (bit-set? 3 data-id) - +) j 1) k
              (lambda (section index)
                (block-set! section index 0)
                (data-set! section index 0))))
          (if brightness
              (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
            (begin
              (blocklight-set! section index 0)
              (propagate-light i j k (- (find-max-light-around i j k) 1) add-sector with-field block-ref blocklight-ref blocklight-set!)))
          (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
          (skylight-set! section index (get-skylight i j k))
          (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
          (redstone-update sector (list i j k block-id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set!)
          (data-set! section index 0)))))
  
  
  (method (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (propagate i j k light)
        (with-field i j k
          (lambda (section index)
            (when section
              ;; always adding the sector covers the case where the light changes
              ;; and we need to update all neighboring sectors even if no light changes for
              ;; them like when putting a torch next to a wall that is in the next sector
              (add-sector (get-sector~ section))
              (when (and (> light 0)
                         (< (blocklight-ref section index) light)
                         (not (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                (blocklight-set! section index light)
                (let ((light (- light 1)))
                  (define (add-queue i j k)
                    (enqueue queue (list i j k light)))
                  
                  (add-queue (- i 1) j k)
                  (add-queue (+ i 1) j k)
                  (add-queue i (- j 1) k)
                  (add-queue i (+ j 1) k)
                  (add-queue i j (- k 1))
                  (add-queue i j (+ k 1))))
              (let (iter)
                (unless (queue-empty? queue)
                  (apply propagate (dequeue queue))
                  (iter)))))))
      
      (propagate i j k light)))
  
  
  (method (inverse-propagate-light i j k add-sector with-field block-ref blocklight-ref blocklight-set!)
    (let ((queue (new-queue)))
      (define (inverse-propagate i j k)
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (let ((light (blocklight-ref section index)))
                (define (look-around i j k light)
                  (with-field i j k
                    (lambda (section index)
                      (when section
                        (add-sector (get-sector~ section))
                        (let ((new-light (blocklight-ref section index)))
                          (unless (= new-light 0)
                            (if (< new-light light)
                                (inverse-propagate i j k)
                              (enqueue queue (list i j k)))))))))
                
                (unless (= light 0)
                  (blocklight-set! section index 0)
                  (look-around (- i 1) j k light)
                  (look-around (+ i 1) j k light)
                  (look-around i (- j 1) k light)
                  (look-around i (+ j 1) k light)
                  (look-around i j (- k 1) light)
                  (look-around i j (+ k 1) light)))))))
      
      (inverse-propagate i j k)
      (let (iter)
        (unless (queue-empty? queue)
          (bind (i j k) (dequeue queue)
            (with-field i j k
              (lambda (section index)
                (let ((light (blocklight-ref section index)))
                  (unless (= light 0)
                    (blocklight-set! section index 0)
                    (propagate-light i j k light add-sector with-field block-ref blocklight-ref blocklight-set!))))))
          (iter)))))
  
  
  (method (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((queue (new-queue)))
      (define (propagate i j k light (first #f))
        (with-field i j k
          (lambda (section index)
            (when section
              (add-sector (get-sector~ section))
              (when (and (> light 0)
                         (or first (> light (skylight-ref section index)))
                         (not (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                (skylight-set! section index light)
                (let ((light2 (- light 1)))
                  (define (add-queue i j k (amount light2))
                    (enqueue queue (list i j k amount)))
                  
                  (add-queue (- i 1) j k)
                  (add-queue (+ i 1) j k)
                  (add-queue i (- j 1) k (if (= light 15) 15 light2))
                  (unless (= light 15)
                    (add-queue i (+ j 1) k))
                  (add-queue i j (- k 1))
                  (add-queue i j (+ k 1))))
              (let (iter)
                (unless (queue-empty? queue)
                  (apply propagate (dequeue queue))
                  (iter)))))))
      
      (with-field i j k
        (lambda (section index)
          (propagate i j k (skylight-ref section index) #t)))))
  
  
  (method (inverse-propagate-skylight i j k first-light add-sector with-field block-ref skylight-ref skylight-set!)
    (let ((inverse-spots (new-queue))
          (propagate-spots (new-queue)))
      (define (add-queue item queue)
        (unless (member? item (queue-list queue))
          (enqueue queue item)))
      
      (define (inverse-propagate i j k previous (first #f))
        (with-field i j k
          (lambda (section index)
            (when section
              (let ((current-light (if first first-light (skylight-ref section index))))
                (define (add-around)
                  (add-queue (list (- i 1) j k current-light) inverse-spots)
                  (add-queue (list (+ i 1) j k current-light) inverse-spots)
                  (add-queue (list i j (- k 1) current-light) inverse-spots)
                  (add-queue (list i j (+ k 1) current-light) inverse-spots)
                  (add-queue (list i (+ j 1) k current-light) inverse-spots)
                  (add-queue (list i (- j 1) k (if (= current-light 15) 16 current-light)) inverse-spots))
                
                (unless (and (not first)
                             (or (= current-light 0)
                                 (get-opaque-cube?~ (blockid->block (block-ref section index)))))
                  (if (or first (< current-light previous))
                      (begin
                        (skylight-set! section index 0)
                        (add-sector (get-sector~ section))
                        (add-around))
                    (begin
                      (add-queue (list i j k) propagate-spots)))))))))
      
      (inverse-propagate i j k 0 #t)
      (let (iter-inverse)
        (unless (queue-empty? inverse-spots)
          (apply inverse-propagate (dequeue inverse-spots))
          (iter-inverse)))
      (let (iter-propagate)
        (unless (queue-empty? propagate-spots)
          (bind (i j k) (dequeue propagate-spots)
            (propagate-skylight i j k add-sector with-field block-ref skylight-ref skylight-set!)
            (iter-propagate))))))
  
  
  (method (pressure-plates-update add-to remove-from actor) ;; bug: getting off and on quickly
    (define (table-remove table key)
      (list->table (map (lambda (x) (cons x (table-ref table x))) (remove key (table-keys table) test: equal?))))
    
    (define (pp-test pp1 pp2)
      (when (and (is? pp1 Pressure-Plate) (is? pp2 Pressure-Plate))
        (equal? (location~ pp1) (location~ pp2))))
    
    (let ((zone (current-zone)))
      (for-each (lambda (pos)
                  (let ((pp (table-ref pressure-plates pos #f)))
                    (if pp
                        (begin
                          (set-colliders~ pp (cons actor (get-colliders~ pp)))
                          (table-set! pressure-plates pos pp))
                      (call-with-position~ zone pos ;; add new pressure plate
                        (lambda (region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                          (table-set! pressure-plates pos (new-pressure-plate sector i j k 5 actor with-field))
                          (set-repeaters~ self (remove pp repeaters test: pp-test))
                          ;; play sound
                          (updating-sectors~ zone
                            (lambda (add-sector)
                              (redstone-update sector (list i j k block-id) add-sector with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! #t))))))))
                add-to)
      (for-each (lambda (pos) ;; remove actor from pressure plates
                  (let ((pp (table-ref pressure-plates pos #f)))
                    (let ((colliders (get-colliders~ pp)))
                      (set! colliders (remove actor colliders))
                      (if (null? colliders)
                          (begin
                            (set! pressure-plates (table-remove pressure-plates pos)) ;; test weak-values
                            (set! repeaters (cons pp repeaters))) ;; unpower
                        (begin
                          (set-colliders~ pp colliders)
                          (table-set! pressure-plates pos pp))))))
                remove-from)))
  
  
  (definition interaction-distance <fl>
    (world-setting 'world.interaction-distance 8.))
  
  
  (definition public (liquid-filter poly)
    (not (get-water-cube?~ (world.generation:blockid->block (fxround (get-data1~ poly))))))
  
  
  (method (max-interaction-distance)
    (let ((world (current-world)))
      (if (user-role?)
          interaction-distance
        (get-view-radius~ world))))
  
  
  (method (deposit-block h v)
    (let ((zone (current-zone)))
      (with-interaction
        (lambda (poly block fore)
          (call-with-position~ zone block
            (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
              (let ((count (if (shift-down?) 10 1)))
                (deposit-inventory block-id count: count))))))))
  
  
  (method protected virtual (mouse-up h v)
    (let ((me (current-me)))
      (with-interaction
        (lambda (poly block fore)
          (let ((distance (vertex-distance block (get-position~ me)))
                (max-distance (max-interaction-distance)))
            (when (<= distance max-distance)
              (delete-block-at block))))
        filter: liquid-filter)))
  
  
  (method protected virtual (right-mouse-up h v)
    (let ((world (current-world))
          (zone (current-zone))
          (me (current-me)))
      (with-interaction
        (lambda (poly clicked fore)
          (let ((distance (vertex-distance clicked (get-position~ me)))
                (max-distance (max-interaction-distance)))
            (when (<= distance max-distance)
              (call-with-position~ zone clicked
                (lambda (region sector block-id <fx> data-id <fx> i <fx> j <fx> k <fx> x <fl> y <fl> z <fl> uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                  (let ((block (blockid->block block-id)))
                    (let ((right-mouse (get-right-mouse~ block)))
                      (if right-mouse
                          (right-mouse region sector block-id data-id i j k x y z uv rendering with-field block-ref block-set! data-ref data-set! blocklight-ref blocklight-set! skylight-ref skylight-set!)
                        (let ((slot (selected-slot~ (child~ (get-interface~ world) 'belt))))
                          (let ((id (get-id~ slot)))
                            (when id
                              (place-slot slot poly clicked fore))))))))))))
        filter: liquid-filter)))
  
  
  (method protected virtual (place-slot slot poly clicked fore)
    (let ((id (get-id~ slot)))
      (if (>= id 256)
          (bell)
        (add-block-at poly fore id)
        (decrease-count~ slot))))
  
  
  (method (mouse-wheel h v d)
    (let ((world (current-world)))
      (if (xor (shift-down?) (world-setting 'world.wheel-zoom? #f))
          (cond ((> d 0)
                 (zoom-in~ world))
                ((< d 0)
                 (zoom-out~ world)))
        (cycle-selection~ (child~ (get-interface~ world) 'belt) d))))))
