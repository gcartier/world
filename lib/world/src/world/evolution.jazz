;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Evolution
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.evolution jazz


(import (jazz.io))


(proclaim (not check bounds zero))


;;;
;;;; Evolution
;;;


(definition sample-size <fx>
  6)


(class Evolution-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-size object))
                              (serialize (get-content-size object))
                              (serialize (get-content object))
                              (serialize (get-now object))
                              (serialize (get-head object))
                              (serialize (get-count object)))))
  
  
  (method override (unmarshall-object self content)
    (bind-vector (size content-size content now head count) content
      (allocate self
                (deserialize size)
                (deserialize content-size)
                (deserialize content)
                (deserialize now)
                (deserialize head)
                (deserialize count)))))


(class Evolution metaclass Evolution-Class extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot content-size <fx>        getter generate)
  (slot content      <f64vector> getter generate)
  (slot now          <fx>        accessors generate)
  (slot head         <fx>        accessors generate)
  (slot count        <fx>        accessors generate)
  
  
  (method override (initialize self size <fx>)
    (nextmethod self)
    (set! self.size size)
    (set! content-size (* size sample-size))
    (set! content (make-f64vector content-size))
    (set! now 0)
    (set! head 0)
    (set! count 0))
  
  
  (method package (reset self)
    (set! content (make-f64vector content-size))
    (set! now 0)
    (set! head 0)
    (set! count 0))

  
  (method package (start-position self) <fx>
    0)
  
  
  (method package (end-position self) <fx>
    count)
  
  
  (method package (first-position self) <fx>
    0)
  
  
  (method package (last-position self) <fx>
    (- (end-position self) 1))
  
  
  (method package (index self n <fx>) <fx>
    (modulo (+ head (* n sample-size)) content-size))
  
  
  (method package (index-now self) <fx>
    (index self now))
  
  
  (method package (evolutionary-time self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 0)))
  
  (method package (evolutionary-id self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 1)))
  
  (method package (evolutionary-data1 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 2)))
  
  (method package (evolutionary-data2 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 3)))
  
  (method package (evolutionary-data3 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 4)))
  
  (method package (evolutionary-data4 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 5)))
  
  
  (method package (advance! self)
    (if (< count size)
        (begin
          (increase! count)
          (increase! now))
      (set! head (modulo (+ head sample-size) content-size)))))


(definition protected evolution <Evolution>
  (new Evolution 30000))


(definition public (current-evolution) <Evolution>
  evolution)


(definition protected (copy-evolution evolution <Evolution>) <Evolution>
  (let ((copy (new Evolution (get-size evolution))))
    (subf64vector-move! (get-content evolution) 0 (get-content-size evolution) (get-content copy) 0)
    (set-now copy (get-now evolution))
    (set-head copy (get-head evolution))
    (set-count copy (get-count evolution))
    copy))


;;;
;;;; Persistence
;;;


(definition protected (evolution-id->name id)
  (case (inexact->exact id)
    ((0) 'connect)
    ((1) 'connected)
    ((2) 'create-packet)
    ((3) 'receive-ack)
    ((4) 'receive-nack)
    ((5) 'timeless-packet)
    ((6) 'discard-packet)
    ((7) 'duplicate-packet)
    ((8) 'missing-packet)
    ((9) 'add-retain)
    ((10) 'remove-retain)
    ((11) 'add-nack)
    ((12) 'remove-nack)
    ((13) 'update-time)
    ((14) 'add-process)
    ((15) 'remove-process)
    ((16) 'process-ok)
    ((17) 'process-waiting)
    ((18) 'reset-media)
    ((19) 'throttle-on)
    ((20) 'throttle-off)
    ((50) 'ring-overflow)
    ((51) 'retrying-write)
    ((100) 'debug)
    ((101) 'debug1)
    ((102) 'debug2)
    (else id)))


(class Evolution-Entry extends Object
  
  
  (slot tier  getter generate)
  (slot time  getter generate)
  (slot id    getter generate)
  (slot data1 getter generate)
  (slot data2 getter generate)
  (slot data3 getter generate)
  (slot data4 getter generate)
  
  
  (method override (initialize self tier time id data1 data2 data3 data4)
    (nextmethod self)
    (set! self.tier tier)
    (set! self.time time)
    (set! self.id id)
    (set! self.data1 data1)
    (set! self.data2 data2)
    (set! self.data3 data3)
    (set! self.data4 data4))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" tier id)))))


(definition protected (read-evolution file)
  (call-with-input-file (path-settings file)
    (lambda (input)
      (define (read-metadata)
        (read input))
      
      (define (read-entries tier)
        (let (loop (entries '()))
          (let ((entry (read-entry tier)))
            (if (not entry)
                (reverse! entries)
              (loop (cons entry entries))))))
      
      (define (read-entry tier)
        (let ((time (read input)))
          (if (eof-object? time)
              #f
            (let ((id (read input))
                  (data1 (read input))
                  (data2 (read input))
                  (data3 (read input))
                  (data4 (read input)))
              (new Evolution-Entry tier time id data1 data2 data3 data4)))))
      
      (let ((metadata (read-metadata)))
        (let ((tier (and (not-null? metadata) (first metadata))))
          (let ((entries (read-entries tier)))
            (cons metadata entries)))))))


(definition protected (process-evolutions local?)
  (let ((dir {Directory Home ".together" "1.0.0" "work" "requests"}))
    (let ((files (collect-files dir (lambda (file)
                                      (extension=? (get-extension file) "evolution")))))
      (let ((names (make-table test: eqv?))
            (all (make-table test: eqv?)))
        (define (present-tier tier)
          (if (not tier)
              "<server>"
            (or (table-ref names tier #f)
                "<unknown>")))
        
        (define (present-data2 data2)
          (if (>= data2 100.)
              data2
            (if (= data2 -1.)
                -1.
              ;; client-no
              (or (table-ref names (flonum->fixnum data2) #f)
                  -1))))
        
        ;; extract
        (for-each (lambda (file)
                    (bind (metadata . entries) (read-evolution file)
                      (let ((id (and (not-null? metadata) (first metadata)))
                            (name (and (not-null? metadata) (second metadata))))
                        (table-set! names id name)
                        (table-set! all id entries))))
                  files)
        ;; generate
        (iterate-table all
          (lambda (id entries)
            (let ((name (or (table-ref names id #f) "<server>")))
              (let ((base (get-time (car entries))))
                (call-with-output-file (path-settings (new-file dir (add-extension name "txt")))
                  (lambda (output)
                    (let ((first? #t))
                      (for-each (lambda (entry)
                                  (if first?
                                      (set! first? #f)
                                    (format output "{%}"))
                                  (let ((time (get-time entry))
                                        (id (get-id entry))
                                        (data1 (get-data1 entry))
                                        (data2 (get-data2 entry))
                                        (data3 (get-data3 entry))
                                        (data4 (get-data4 entry)))
                                    (format output "{r precision: 6},{a},{a},{a},{a},{a}"
                                      time @wait (- time base)
                                      (evolution-id->name id)
                                      data1
                                      (present-data2 data2)
                                      data3
                                      data4)))
                                entries))))))))
        ;; unified
        (when local?
          (let ((all (apply append (table-values all))))
            (let ((sorted (sort < all key: get-time)))
              (let ((base (if local? (get-time (car sorted)) 0.)))
                (call-with-output-file (path-settings (new-file dir (add-extension "<unified>" "txt")))
                  (lambda (output)
                    (let ((first? #t))
                      (for-each (lambda (entry)
                                  (if first?
                                      (set! first? #f)
                                    (format output "{%}"))
                                  (let ((tier (get-tier entry))
                                        (time (get-time entry))
                                        (id (get-id entry))
                                        (data1 (get-data1 entry))
                                        (data2 (get-data2 entry))
                                        (data3 (get-data3 entry))
                                        (data4 (get-data4 entry)))
                                    (format output "{a},{r precision: 6},{a},{a},{a},{a},{a}"
                                      (present-tier tier)
                                      time @wait (- time base)
                                      (evolution-id->name id)
                                      data1
                                      (present-data2 data2)
                                      data3
                                      data4)))
                                sorted)))))))))))))
