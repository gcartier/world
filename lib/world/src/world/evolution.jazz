;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Evolution
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.evolution jazz


(import (jazz.io))


(proclaim (not check bounds zero))


;;;
;;;; Evolution
;;;


(definition sample-size <fx>
  8)


(class Evolution-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (serialize (get-size object))
                              (serialize (get-content-size object))
                              (serialize (get-content object))
                              (serialize (get-now object))
                              (serialize (get-head object))
                              (serialize (get-count object)))))
  
  
  (method override (unmarshall-object self content)
    (bind-vector (size content-size content now head count) content
      (allocate self
                (deserialize size)
                (deserialize content-size)
                (deserialize content)
                (deserialize now)
                (deserialize head)
                (deserialize count)))))


(class Evolution metaclass Evolution-Class extends Object
  
  
  (slot size         <fx>        getter generate)
  (slot content-size <fx>        getter generate)
  (slot content      <f64vector> getter generate)
  (slot now          <fx>        accessors generate)
  (slot head         <fx>        accessors generate)
  (slot count        <fx>        accessors generate)
  
  
  (method override (initialize self size <fx>)
    (nextmethod self)
    (set! self.size size)
    (set! content-size (* size sample-size))
    (set! content (make-f64vector content-size))
    (set! now 0)
    (set! head 0)
    (set! count 0))
  
  
  (method package (reset self)
    (set! content (make-f64vector content-size))
    (set! now 0)
    (set! head 0)
    (set! count 0))

  
  (method package (start-position self) <fx>
    0)
  
  
  (method package (end-position self) <fx>
    count)
  
  
  (method package (first-position self) <fx>
    0)
  
  
  (method package (last-position self) <fx>
    (- (end-position self) 1))
  
  
  (method package (index self n <fx>) <fx>
    (modulo (+ head (* n sample-size)) content-size))
  
  
  (method package (index-now self) <fx>
    (index self now))
  
  
  (method package (evolutionary-time self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 0)))
  
  (method package (evolutionary-id self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 1)))
  
  (method package (evolutionary-data1 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 2)))
  
  (method package (evolutionary-data2 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 3)))
  
  (method package (evolutionary-data3 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 4)))
  
  (method package (evolutionary-data4 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 5)))
  
  (method package (evolutionary-data5 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 6)))
  
  (method package (evolutionary-data6 self n <fx>) <fl>
    (f64vector-ref content (+ (index self n) 7)))
  
  
  (method package (advance! self)
    (if (< count size)
        (begin
          (increase! count)
          (increase! now))
      (set! head (modulo (+ head sample-size) content-size)))))


(definition protected evolution <Evolution>
  (new Evolution 30000))


(definition public (current-evolution) <Evolution>
  evolution)


(definition protected (copy-evolution evolution <Evolution>) <Evolution>
  (let ((copy (new Evolution (get-size evolution))))
    (subf64vector-move! (get-content evolution) 0 (get-content-size evolution) (get-content copy) 0)
    (set-now copy (get-now evolution))
    (set-head copy (get-head evolution))
    (set-count copy (get-count evolution))
    copy))


;;;
;;;; Persistence
;;;


(definition protected (evolution-id->name id)
  (case (inexact->exact id)
    ((udp-id-connect) 'connect)
    ((udp-id-connected) 'connected)
    ((udp-id-create-packet) 'create-packet)
    ((udp-id-receive-ack) 'receive-ack)
    ((udp-id-receive-nack) 'receive-nack)
    ((udp-id-timeless-packet) 'timeless-packet)
    ((udp-id-discard-packet) 'discard-packet)
    ((udp-id-duplicate-packet) 'duplicate-packet)
    ((udp-id-missing-packet) 'missing-packet)
    ((udp-id-add-retain) 'add-retain)
    ((udp-id-remove-retain) 'remove-retain)
    ((udp-id-add-nack) 'add-nack)
    ((udp-id-remove-nack) 'remove-nack)
    ((udp-id-update-time) 'update-time)
    ((udp-id-add-process) 'add-process)
    ((udp-id-remove-process) 'remove-process)
    ((udp-id-process-ok) 'process-ok)
    ((udp-id-process-waiting) 'process-waiting)
    ((udp-id-reset-media) 'reset-media)
    ((udp-id-throttle-on) 'throttle-on)
    ((udp-id-throttle-off) 'throttle-off)
    ((udp-id-ring-overflow) 'ring-overflow)
    ((udp-id-retrying-write) 'retrying-write)
    ((udp-id-debug) 'debug)
    ((udp-id-debug1) 'debug1)
    ((udp-id-debug2) 'debug2)
    (else id)))


(class Evolution-Entry extends Object
  
  
  (slot tier       getter generate)
  (slot time       getter generate)
  (slot id         getter generate)
  (slot origin     getter generate)
  (slot media-kind getter generate)
  (slot data1      getter generate)
  (slot data2      getter generate)
  (slot data3      getter generate)
  (slot data4      getter generate)
  
  
  (method override (initialize self tier time id origin media-kind data1 data2 data3 data4)
    (nextmethod self)
    (set! self.tier tier)
    (set! self.time time)
    (set! self.id id)
    (set! self.origin origin)
    (set! self.media-kind media-kind)
    (set! self.data1 data1)
    (set! self.data2 data2)
    (set! self.data3 data3)
    (set! self.data4 data4))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" tier id)))))


(definition protected (read-evolution file)
  (call-with-input-file (path-settings file)
    (lambda (input)
      (define (read-metadata)
        (read input))
      
      (define (read-entries tier)
        (let (loop (entries '()))
          (let ((entry (read-entry tier)))
            (if (not entry)
                (reverse! entries)
              (loop (cons entry entries))))))
      
      (define (read-entry tier)
        (let ((time (read input)))
          (if (eof-object? time)
              #f
            (let ((id (read input))
                  (origin (read input))
                  (media-kind (read input))
                  (data1 (read input))
                  (data2 (read input))
                  (data3 (read input))
                  (data4 (read input)))
              (new Evolution-Entry tier time id origin media-kind data1 data2 data3 data4)))))
      
      (let ((metadata (read-metadata)))
        (let ((tier (and (not-null? metadata) (first metadata))))
          (let ((entries (read-entries tier)))
            (cons metadata entries)))))))


(definition protected (process-evolutions local?)
  (let ((dir {Directory Home ".together" "1.0.0" "work" "requests"}))
    (let ((files (collect-files dir (lambda (file)
                                      (extension=? (get-extension file) "evolution")))))
      (let ((names (make-table test: eqv?))
            (all (make-table test: eqv?)))
        (define (present-tier tier)
          (if (not tier)
              "<server>"
            (or (table-ref names tier #f)
                "<unknown>")))
        
        (define (present-origin origin)
          (if (= origin -1.)
              origin
            ;; client-no
            (or (table-ref names (flonum->fixnum origin) #f)
                origin)))
        
        (define (present-kind media-kind)
          (cond ((= media-kind 5.)
                 "audio")
                ((= media-kind 6.)
                 "video")
                (else
                 media-kind)))
        
        ;; extract
        (for-each (lambda (file)
                    (bind (metadata . entries) (read-evolution file)
                      (let ((id (and (not-null? metadata) (first metadata)))
                            (name (and (not-null? metadata) (second metadata))))
                        (table-set! names id name)
                        (table-set! all id entries))))
                  files)
        ;; generate
        (iterate-table all
          (lambda (id entries)
            (let ((name (or (table-ref names id #f) "<server>")))
              (let ((base (get-time (car entries))))
                (call-with-output-file (path-settings (new-file dir (add-extension name "txt")))
                  (lambda (output)
                    (let ((first? #t))
                      (for-each (lambda (entry)
                                  (if first?
                                      (set! first? #f)
                                    (format output "{%}"))
                                  (let ((time (get-time entry))
                                        (id (get-id entry))
                                        (origin (get-origin entry))
                                        (media-kind (get-media-kind entry))
                                        (data1 (get-data1 entry))
                                        (data2 (get-data2 entry))
                                        (data3 (get-data3 entry))
                                        (data4 (get-data4 entry)))
                                    (format output "{r precision: 6},{a},{a},{a},{a},{a},{a},{a}"
                                      time @wait (- time base)
                                      (evolution-id->name id)
                                      (present-origin origin)
                                      (present-kind media-kind)
                                      data1
                                      data2
                                      data3
                                      data4)))
                                entries))))))))
        ;; unified
        (when local?
          (let ((all (apply append (table-values all))))
            (let ((sorted (sort < all key: get-time)))
              (let ((base (if local? (get-time (car sorted)) 0.)))
                (call-with-output-file (path-settings (new-file dir (add-extension "<unified>" "txt")))
                  (lambda (output)
                    (let ((first? #t))
                      (for-each (lambda (entry)
                                  (if first?
                                      (set! first? #f)
                                    (format output "{%}"))
                                  (let ((tier (get-tier entry))
                                        (time (get-time entry))
                                        (id (get-id entry))
                                        (origin (get-origin entry))
                                        (media-kind (get-media-kind entry))
                                        (data1 (get-data1 entry))
                                        (data2 (get-data2 entry))
                                        (data3 (get-data3 entry))
                                        (data4 (get-data4 entry)))
                                    (format output "{a},{r precision: 6},{a},{a},{a},{a},{a},{a},{a}"
                                      (present-tier tier)
                                      time @wait (- time base)
                                      (evolution-id->name id)
                                      (present-origin origin)
                                      (present-kind media-kind)
                                      data1
                                      data2
                                      data3
                                      data4)))
                                sorted)))))))))))))
