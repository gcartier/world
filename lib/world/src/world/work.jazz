;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Work
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.work jazz


(import (jazz.application)
        (jazz.debuggee)
        (jazz.evaluate)
        (jazz.io)
        (jazz.jrm)
        (world)
        (world.autoload)
        (world.master)
        (world.settings)
        (world.syntax (phase syntax)))


;; ensures we never load this file in the worker
(assert (get-worker-filename))


;;;
;;;; Process
;;;


(definition spawn-mutex
  (make-mutex 'spawn))

(definition (with-spawn-mutex thunk)
  (unwind-protect
      (begin
        (mutex-lock! spawn-mutex)
        (thunk))
    (mutex-unlock! spawn-mutex)))


(definition protected worker
  #f)

(definition public (require-worker)
  (with-spawn-mutex
    (lambda ()
      (or worker
          (let ((wrk (spawn-worker-process)))
            (set! worker wrk)
            wrk)))))

(definition public (set-worker wrk)
  (set! worker wrk))


(definition world-repositories
  '())

(definition protected (get-world-repositories)
  world-repositories)

(definition protected (set-world-repositories repositories)
  (set! world-repositories repositories)
  ;; spawning worker will setup repositories
  (and worker
       (bind (what expr detail) (process-repositories~ worker repositories)
         (worker-result what expr detail))))


(definition (worker-crashes)
  (parse~ {Directory Settings "work" "crashes"}))

(definition (worker-cache)
  (parse~ {Directory Settings "work" "caches" "code"}))

(definition (worker-optimize?)
  (world-setting 'world.worker-optimize? #f))

(definition (worker-debug?)
  (world-setting 'world.worker-debug? #f))


(definition protected (setup-worker-process)
  (load-unit 'jazz.jrm)
  (load-unit 'jazz.jrm.transmission)
  (load-unit 'jazz.jrm.remote.IOR))


;; for now we need to do this upfront as starting
;; jrm-based worker from a unit-hook doesn't work
(definition protected (spawn-worker-process)
  (let ((crashes (worker-crashes))
        (cache (worker-cache))
        (optimize? (worker-optimize?))
        (debug? (worker-debug?)))
    (spawn-slave-process "worker" (get-worker-filename)
      (lambda (master slave cookie)
        (process-setup~ slave crashes cache optimize? debug? world-repositories))
      (lambda (master slave cookie)
        (set! worker slave)
        slave)
      debug?: debug?
      wait?: #t)))


(definition protected (hide-worker-process)
  (and worker
       (bind (what expr detail) (process-hide~ worker)
         (worker-result what expr detail))))


(definition protected (kill-worker-process)
  (when worker
    (process-quit~ worker)
    (set! worker #f)))


(definition protected (calling-worker thunk)
  ;; compiling live can take a long time
  (parameterize ((receive-timeout 60))
    (thunk)))


(setup-worker-process)


;;;
;;;; Settings
;;;


(definition protected worker?
  (world-setting 'world.worker? (not sejour?)))

(definition protected (set-worker? flag)
  (set! worker? flag))


(definition (worker-mode)
  (world-setting 'world.worker-mode 'interpret))


;;;
;;;; Evaluate
;;;


(definition public (worker-evaluate syntax str container line col walk-handler error-handler)
  (if (not worker?)
      (let ((expansion (evaluate-forms syntax str container line col 'interpret evaluate?: #f)))
        (eval expansion))
    (bind (what expr detail) (calling-worker (lambda () (process-evaluate~ (require-worker) 'interpret #f syntax str container line col 'interpret)))
      (worker-result what expr detail walk-handler: walk-handler error-handler: error-handler))))


;;;
;;;; Run
;;;


(definition public (worker-run instance script-code walk-handler error-handler result-handler)
  (with-exception-catcher
    (lambda (exc)
      (error-handler (exception-reason exc)))
    (lambda ()
      (catch (Walk-Problems exc
               (walk-handler (exception-reason exc) (exception-detail exc)))
        (let ((syntax 'jazz)
              (str script-code)
              (container #f)
              (line 0)
              (col 0))
          (when instance
            (startup~ instance))
          (result-handler
            (if (not worker?)
                (eval (evaluate-forms syntax str container line col 'interpret readtable: 'scheme evaluate?: #f scripting?: #t))
              (bind (what expr detail) (calling-worker (lambda () (process-run~ (require-worker) 'interpret #f syntax str container line col 'interpret)))
                (worker-result what expr detail walk-handler: walk-handler error-handler: error-handler))))
          (when instance
            (fallthrough~ instance)))))))


;;;
;;;; Hooks
;;;


(definition (unit-hook unit-name)
  (and worker?
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'unit unit-name))
    (let ((mode (worker-mode)))
      (with-feedback mode unit-name
        (lambda (feedback? time?)
          (bind (what expr detail) (calling-worker (lambda () (process-unit~ (require-worker) mode feedback? time? unit-name)))
            (worker-result what expr detail)))))
    #t))


(definition (script-hook path)
  (and worker?
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'script path))
    (let ((mode 'interpret))
      (bind (what expr detail) (calling-worker (lambda () (process-script~ (require-worker) mode path)))
        (worker-result what expr detail)))
    #t))


(definition (evaluate-hook forms syntax str container line col evaluation-mode walk-debugger walk-cookie)
  (and worker?
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'evaluate))
    (let ((mode (worker-mode)))
      (with-feedback mode 'evaluation
        (lambda (feedback? time?)
          (bind (what expr detail) (calling-worker (lambda () (process-evaluate~ (require-worker) mode feedback? syntax str container line col evaluation-mode)))
            (when (worker-result what expr detail walk-debugger: walk-debugger walk-cookie: walk-cookie)
              (hook-evaluate forms syntax str container line col))))))
    #t))


(definition (console-hook unit-name expr evaluator)
  (if (not worker?)
      (values #f #f)
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'console))
    (let ((mode 'interpret))
      (bind (what expr detail) (calling-worker (lambda () (process-console~ (require-worker) unit-name expr)))
        (values (wrap-evaluate
                  (lambda ()
                    (worker-result what expr detail evaluator: evaluator)))
                #t)))))


(definition (with-feedback mode name proc)
  (let ((world (current-world+)))
    (let ((visible? (and (get-toplevel) (get-visible?~ (get-toplevel))))
          (feedback? (world-setting 'world.worker-feedback? #f))
          (time? (world-setting 'world.worker-time? #f)))
      (when (and feedback?
                 (eq? mode 'compile)
                 (neq? name 'evaluation)
                 name
                 world
                 visible?)
        (display-message~ world (format "Compiling {a}..." name)))
      (proc (not visible?) time?))))


(definition (worker-result what expr detail (evaluator: evaluator #f) (walk-handler: walk-handler #f) (walk-debugger: walk-debugger #f) (walk-cookie: walk-cookie #f) (error-handler: error-handler #f))
  (when (world-setting 'world.worker-verbose-result? #f)
    (debug 'result what))
  (case what
    ((eval evaload)
     (parameterize ((generate-symbol-for "%")
                    (generate-symbol-context (gensym))
                    (generate-symbol-counter 0))
       (let ((expansion (if (eq? what 'eval)
                            expr
                          (call-with-input-file expr
                            read-binary))))
         (if evaluator
             (evaluator expansion)
           (eval expansion)
           #t))))
    ((load)
     (load-file expr #t))
    ((walk)
     (if walk-handler
         (walk-handler expr detail)
       (let ((world (current-world+))
             (zone (current-zone+)))
         (cond (walk-debugger
                (report-walk-problems~ walk-debugger (get-local-process) detail walk-cookie))
               ((and world zone (get-ready?~ zone) (not (get-controller-debugger)))
                (display-walk-problems~ world detail))
               (else
                (error "{a}" expr))))
       (if evaluator
           (unspecified)
         #f)))
    ((error)
     (if error-handler
         (error-handler expr)
       (error "{a}" expr)))))


(add-exit-job! kill-worker-process)


(set-load-interpreted-hook
  unit-hook)

(set-load-script-hook
  script-hook)

(set-evaluate-forms-hook
  evaluate-hook)

(set-console-evaluate-hook
  console-hook))
