;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Work
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.work jazz


(import (jazz.debuggee)
        (jazz.evaluate)
        (jazz.io)
        (jazz.system)
        (world)
        (world.autoload)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Process
;;;


(definition world-repositories
  #f)

(definition protected (set-world-repositories repositories)
  (set! world-repositories repositories))


(definition (spawn-worker-process)
  (define (determine-worker-path)
    (let ((filename (add-extension (get-worker-filename) (executable-extension kernel-platform))))
      (let ((bundle-path (and kernel-bundle-install (string-append kernel-bundle-install filename))))
        (if (and bundle-path (file-exists? bundle-path))
            bundle-path
          (let ((install-path (string-append kernel-install filename)))
            (if (file-exists? install-path)
                install-path
              (error "Unable to find worker executable")))))))
  
  (let ((worker-path (determine-worker-path))
        (server-port (open-tcp-server 0)))
    (open-process
      (list
        path: worker-path
        arguments: `("-:daqQ-"
                     "-port" ,(number->string (socket-info-port-number (tcp-server-socket-info server-port)))
                     ,@(if world-repositories
                           (list "-repositories" (join world-repositories ";"))
                         '())
                     ;; use variable as this is not correct at the moment because of the evaluate always hack
                     ,@(let ((debug? (world-setting 'world.worker-debug? #f))
                             (arg (command-argument "debugger")))
                         (if (and debug? arg)
                             (list "-debugger" arg)
                           '())))
        stdin-redirection: #f
        stdout-redirection: #f
        stderr-redirection: #f
        show-console: #f))
    (read server-port)))


(definition (kill-worker-process port)
  (write '() port)
  (force-output port)
  ;; we should do this to wait for the worker to exit else
  ;; the worker can get a broken pipe if we exit too soon
  ;; (process-status port)
  (close-port port))


;;;
;;;; Port
;;;


(definition worker-port
  #f)


(definition protected (get-worker-port)
  (or worker-port
      (let ((port (spawn-worker-process)))
        (set! worker-port port)
        port)))


(definition protected (close-worker-port)
  (when worker-port
    (kill-worker-process worker-port)
    (set! worker-port #f)))


;;;
;;;; Hooks
;;;


(definition (worker-mode)
  (effective-evaluation-mode (world-setting 'world.worker-mode 'interpret)))


(definition (worker-cache)
  (parse~ {Directory Settings "work" "cache"}))


(definition (unit-hook unit-name)
  (when (world-setting 'world.worker? #t)
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'unit unit-name))
    (let ((mode (worker-mode)))
      (worker-work 'unit mode unit-name)
      (worker-result 'unit mode))
    #t))


(definition (script-hook path)
  (when (world-setting 'world.worker? #t)
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'script (extract-base (extract-name path))))
    (let ((mode (worker-mode)))
      (worker-work 'script mode path)
      (worker-result 'script mode))
    #t))


(definition (evaluate-hook forms syntax str container line col evaluation-mode)
  (when (world-setting 'world.worker? #t)
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'evaluate))
    (let ((mode (worker-mode)))
      (worker-work 'evaluate mode syntax str container line col evaluation-mode)
      (when (worker-result 'evaluate mode)
        (hook-evaluate forms syntax str container line col)))
    #t))


(definition (console-hook unit-name expr evaluator)
  (if (not (world-setting 'world.worker? #t))
      (values #f #f)
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'console))
    (let ((mode 'interpret))
      (worker-work 'console mode unit-name expr)
      (values (worker-result 'console mode evaluator: evaluator) #t))))


(definition (worker-work command mode . arguments)
  (let ((port (get-worker-port))
        (cache (parse~ {Directory Settings "work" "cache"}))
        (debug? (world-setting 'world.worker-debug? #f)))
    (write `(,command ,mode ,cache ,debug? ,@arguments) port)
    (force-output port)))


(definition (worker-result kind mode (evaluator: evaluator #f))
  (let ((info (read-binary-content (get-worker-port) unmarshall)))
    (unless (eof-object? info)
      (bind (what expr exception) info
        (when (world-setting 'world.worker-verbose-result? #f)
          (debug 'result what))
        (case what
          ((eval)
           (parameterize ((generate-symbol-for "%")
                          (generate-symbol-context (gensym))
                          (generate-symbol-counter 0))
             (if evaluator
                 (evaluator expr)
               (eval expr)
               #t)))
          ((load)
           (load-file expr))
          ((walk)
           ;quicky
           (error expr)
           ;(display-walk-problems~ (current-world) expr)
           (if evaluator
               (unspecified)
             #f))
          ((error)
           (error expr)))))))


(add-exit-job! close-worker-port)


(set-load-interpreted-hook
  unit-hook)

(set-load-script-hook
  script-hook)

(set-evaluate-forms-hook
  evaluate-hook)

(set-console-evaluate-hook
  console-hook))
