;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Work
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.work jazz


(import (jazz.application)
        (jazz.debuggee)
        (jazz.io)
        (world)
        (world.autoload)
        (world.settings)
        (world.syntax (phase syntax)))


;; ensures we never load this file in the worker
(assert (get-worker-filename))


;;;
;;;; Process
;;;


(definition world-repositories
  #f)

(definition protected (get-world-repositories)
  world-repositories)

(definition protected (set-world-repositories repositories)
  (set! world-repositories repositories)
  ;; worker is already running so update repositories
  (when worker-port
    (let ((port (get-worker-port)))
      (write-binary `(repositories ,repositories) port)
      (force-output port)
      (check-exception port))))


(definition (worker-crashes)
  (parse~ {Directory Settings "work" "crashes"}))

(definition (worker-cache)
  (parse~ {Directory Settings "work" "caches" "code"}))

(definition (worker-debug?)
  (world-setting 'world.worker-debug? #f))


(define (check-exception port)
  (let ((exception-reason (read-binary port)))
    (when exception-reason
      (error "Worker error: {a}" exception-reason))))


(definition (spawn-worker-process)
  (define (determine-worker-path)
    (let ((filename (add-extension (get-worker-filename) (executable-extension kernel-platform))))
      (or (find-kernel-file filename)
          (error "Unable to find worker executable"))))
  
  (let ((worker-path (determine-worker-path))
        (server-port (open-tcp-server 0))
        (crashes (worker-crashes))
        (cache (worker-cache))
        (debug? (worker-debug?)))
    (open-process
      (list
        path: worker-path
        arguments: `("-:daqQ-"
                     "-port" ,(number->string (socket-info-port-number (tcp-server-socket-info server-port)))
                     ;; it is not completly correct at the moment to always debug
                     ;; the worker because of the evaluate always hack done in yownu
                     ,@(let ((arg (command-argument "debugger")))
                         (if (and debug? arg)
                             (list "-debugger" arg)
                           '())))
        stdin-redirection: #f
        stdout-redirection: #f
        stderr-redirection: #f
        show-console: #f))
    (let ((port (read server-port)))
      (write-binary `(setup ,crashes ,cache ,debug?) port)
      (force-output port)
      (check-exception port)
      (write-binary `(repositories ,world-repositories) port)
      (force-output port)
      (check-exception port)
      port)))


(definition (kill-worker-process port)
  (write '() port)
  (force-output port)
  ;; we should do this to wait for the worker to exit else
  ;; the worker can get a broken pipe if we exit too soon
  ;; (process-status port)
  (close-port port))


;;;
;;;; Feedback
;;;


(definition protected (hide-worker)
  (when worker-port
    (worker-work 'hide #f #f #f #f)))


;;;
;;;; Port
;;;


(definition worker-port
  #f)


(definition protected (get-worker-port)
  (or worker-port
      (let ((port (spawn-worker-process)))
        (set! worker-port port)
        port)))


(definition protected (close-worker-port)
  (when worker-port
    (kill-worker-process worker-port)
    (set! worker-port #f)))


;;;
;;;; Evaluate
;;;


(definition public (worker-evaluate syntax str container line col walk-handler error-handler)
  (worker-work 'evaluate 'interpret #f #f syntax str container line col 'interpret)
  (worker-result walk-handler: walk-handler error-handler: error-handler))


;;;
;;;; Hooks
;;;


(definition worker?
  (world-setting 'world.worker? #t))


(definition (worker-mode)
  (world-setting 'world.worker-mode 'interpret))


(definition (unit-hook unit-name)
  (when worker?
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'unit unit-name))
    (let ((mode (worker-mode)))
      (with-feedback mode unit-name
        (lambda (feedback? time?)
          (worker-work 'unit mode feedback? time? unit-name)
          (worker-result))))
    #t))


(definition (script-hook path)
  (when worker?
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'script path))
    (let ((mode 'interpret))
      (worker-work 'script mode #f #f path)
      (worker-result))
    #t))


(definition (evaluate-hook forms syntax str container line col evaluation-mode walk-debugger walk-cookie)
  (when worker?
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'evaluate))
    (let ((mode (worker-mode)))
      (with-feedback mode 'evaluation
        (lambda (feedback? time?)
          (worker-work 'evaluate mode feedback? time? syntax str container line col evaluation-mode)
          (when (worker-result walk-debugger: walk-debugger walk-cookie: walk-cookie)
            (hook-evaluate forms syntax str container line col)))))
    #t))


(definition (console-hook unit-name expr evaluator)
  (if (not worker?)
      (values #f #f)
    (when (world-setting 'world.worker-verbose? #f)
      (debug 'console))
    (let ((mode 'interpret))
      (worker-work 'console mode #f #f unit-name expr)
      (values (wrap-evaluate
                (lambda ()
                  (worker-result evaluator: evaluator)))
              #t))))


(definition (with-feedback mode name proc)
  (let ((world (current-world+)))
    (let ((visible? (and (get-toplevel) (get-visible?~ (get-toplevel))))
          (feedback? (world-setting 'world.worker-feedback? #f))
          (time? (world-setting 'world.worker-time? #f)))
      (when (and feedback?
                 (eq? mode 'compile)
                 (neq? name 'evaluation)
                 name
                 world
                 visible?)
        (display-message~ world (format "Compiling {a}..." name)))
      (proc (not visible?) time?))))


(definition (worker-work command mode feedback? time? . arguments)
  (let ((port (get-worker-port)))
    (write-binary `(,command ,mode ,feedback? ,time? ,@arguments) port)
    (force-output port)))


(definition (worker-result (evaluator: evaluator #f) (walk-handler: walk-handler #f) (walk-debugger: walk-debugger #f) (walk-cookie: walk-cookie #f) (error-handler: error-handler #f))
  (let ((info (read-binary (get-worker-port))))
    (unless (eof-object? info)
      (bind (what expr detail) info
        (when (world-setting 'world.worker-verbose-result? #f)
          (debug 'result what))
        (case what
          ((eval evaload)
           (parameterize ((generate-symbol-for "%")
                          (generate-symbol-context (gensym))
                          (generate-symbol-counter 0))
             (let ((expansion (if (eq? what 'eval)
                                  expr
                                (call-with-input-file expr
                                  read-binary))))
               (if evaluator
                   (evaluator expansion)
                 (eval expansion)
                 #t))))
          ((load)
           (load-file expr #t))
          ((walk)
           (if walk-handler
               (walk-handler expr detail)
             (let ((world (current-world+))
                   (zone (current-zone+)))
               (cond (walk-debugger
                       (report-walk-problems~ walk-debugger (get-local-process) detail walk-cookie))
                     ((and world zone (get-ready?~ zone) (not (get-controller-debugger)))
                      (display-walk-problems~ world detail))
                     (else
                      (error "{a}" expr))))
             (if evaluator
                 (unspecified)
               #f)))
          ((error)
           (if error-handler
               (error-handler expr)
             (error "{a}" expr))))))))


(add-exit-job! close-worker-port)


(set-load-interpreted-hook
  unit-hook)

(set-load-script-hook
  script-hook)

(set-evaluate-forms-hook
  evaluate-hook)

(set-console-evaluate-hook
  console-hook))
