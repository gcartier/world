;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Chunks
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.chunk jazz


(import (world)
        (world.autoload)
        (world.geometry)
        (world.index)
        (world.section)
        (world.syntax (phase syntax))
        (world.tag))


(proclaim (warn optimizations))


;;;
;;;; Chunk
;;;


(class World-Chunk extends Object
  
  
  (slot refcount              <fx>      initialize 0  getter generate)
  (slot x                     <fx>                    getter generate)
  (slot z                     <fx>                    getter generate)
  (slot digest                                        accessors generate)
  (slot raw                                           accessors generate)
  (slot region                                        getter generate)
  (slot tag                                           getter generate)
  (slot heightmap             <vector+>               accessors generate)
  (slot entities                                      getter generate)
  (slot block-entities                                getter generate)
  (slot block-entities-index  <table+>                getter generate)
  (slot sections                                      getter generate)
  (slot sections-table        <table+>  initialize #f getter generate)
  (slot generator-revision    <fx>      initialize -1 getter generate)
  (slot generated?            <bool>    initialize #f accessors generate)
  (slot structures-generated? <bool>    initialize #f accessors generate)
  (slot modified?             <bool>    initialize #f accessors generate)
  
  
  (method override (initialize digest raw region tag heightmap entities block-entities sections chunk-index)
    (set! digest~self digest)
    (set! raw~self raw)
    (set! region~self region)
    (set! tag~self tag)
    (set! heightmap~self heightmap)
    (set! entities~self entities)
    (set! block-entities~self block-entities)
    (set! block-entities-index~self (index-block-entities (list-payload-content block-entities)))
    (set! sections~self sections)
    (set! x~self (car chunk-index))
    (set! z~self (cdr chunk-index)))
  
  
  (definition tree1
    '((((0 0 0) (0 -1 0) (0 -2 0) (0 -3 0) (0 -4 0) (0 -5 0) (0 -6 0)) . (17 . 0))
      (((0 1 0) (0 1 1) (1 1 0) (-1 1 0) (0 1 -1)
        (-1 0 0) (1 0 0) (0 0 1) (0 0 -1) (1 0 1) (-1 0 1)
        (-1 -1 0) (1 -1 0) (0 -1 1) (0 -1 -1) (1 -1 1) (-1 -1 1) (1 -1 -1) (-1 -1 -1) (-2 -1 0) (2 -1 0) (0 -1 2) (0 -1 -2) (1 -1 2) (1 -1 -2) (-1 -1 2) (-1 -1 -2) (2 -1 1) (2 -1 -1) (-2 -1 1) (-2 -1 -1) (2 -1 2) (2 -1 -2)
        (-1 -2 0) (1 -2 0) (0 -2 1) (0 -2 -1) (1 -2 1) (-1 -2 1) (1 -2 -1) (-1 -2 -1) (-2 -2 0) (2 -2 0) (0 -2 2) (0 -2 -2) (1 -2 2) (1 -2 -2) (-1 -2 2) (-1 -2 -2) (2 -2 1) (2 -2 -1) (-2 -2 1) (-2 -2 -1) (2 -2 2) (2 -2 -2) (-2 -2 2) (-2 -2 -2)) . (18 . 0))))
  
  
  (definition tree2
    '((((0 0 0) (0 -1 0) (0 -2 0) (0 -3 0) (0 -4 0) (0 -5 0) (0 -6 0)) . (17 . 2))
      (((0 1 0) (0 1 1) (1 1 0) (-1 1 0) (0 1 -1)
        (-1 0 0) (1 0 0) (0 0 1) (0 0 -1) (1 0 1) (-1 0 1)
        (-1 -1 0) (1 -1 0) (0 -1 1) (0 -1 -1) (1 -1 1) (-1 -1 1) (1 -1 -1) (-1 -1 -1) (-2 -1 0) (2 -1 0) (0 -1 2) (0 -1 -2) (1 -1 2) (1 -1 -2) (-1 -1 2) (-1 -1 -2) (2 -1 1) (2 -1 -1) (-2 -1 1) (-2 -1 -1) (2 -1 -2)
        (-1 -2 0) (1 -2 0) (0 -2 1) (0 -2 -1) (1 -2 1) (-1 -2 1) (1 -2 -1) (-1 -2 -1) (-2 -2 0) (2 -2 0) (0 -2 2) (0 -2 -2) (1 -2 2) (1 -2 -2) (-1 -2 2) (-1 -2 -2) (2 -2 1) (2 -2 -1) (-2 -2 1) (-2 -2 -1) (2 -2 2) (2 -2 -2) (-2 -2 2) (-2 -2 -2)) . (18 . 2))))
  
  
  (method (refcount-increase)
    (increase! refcount)
    ;(debug self 'refcount refcount)
    )
  
  
  (method (refcount-decrease)
    (decrease! refcount)
    ;(debug self 'refcount refcount)
    (when (<= refcount 0)
      (release)))
  
  
  (method (release)
    ;(debug 'release self)
    (refcount-decrease~ region))
  
  
  (method (register-section y section)
    (refcount-increase)
    (unless sections-table
      (set! sections-table (make-table test: eq?)))
    (table-set! sections-table y section))
  
  
  (method (index-block-entities block-entities)
    (if (null? block-entities)
        #f
      (let ((table (make-table test: equal?)))
        (for-each (lambda (block-entity)
                    (let ((x (tag-assoc "x" block-entity))
                          (y (tag-assoc "y" block-entity))
                          (z (tag-assoc "z" block-entity)))
                      (let ((index (vector x y z)))
                        (table-set! table index block-entity))))
                  block-entities)
        table)))
  
  
  (method (find-block-entity index)
    (and block-entities-index (table-ref block-entities-index index #f)))
  
  
  (method (add-block-entity index)
    (let ((x (vector-ref index 0))
          (y (vector-ref index 1))
          (z (vector-ref index 2)))
      (let ((block-entity (list (make-tag "Items" TAG_List (make-list-payload TAG_Compound '()))
                                (make-tag "id" TAG_String "Chest")
                                (make-tag "x" TAG_Int x)
                                (make-tag "y" TAG_Int y)
                                (make-tag "z" TAG_Int z))))
        (when (not block-entities-index)
          ;; when empty it contains ("TileEntities" 9 0)
          (set-list-payload-type block-entities TAG_Compound)
          (set! block-entities-index (make-table test: equal?)))
        (set-list-payload-content block-entities (cons block-entity (list-payload-content block-entities)))
        (table-set! block-entities-index index block-entity)
        block-entity)))
  
  
  (method (add-section sector-y)
    (let ((blocks (make-u8vector 4096))
          (data (make-u8vector 2048))
          (blocklight (make-u8vector 2048))
          (skylight (make-u8vector 2048 255))) ;; quicky
      (let ((section (new World-Section self blocks data blocklight skylight)))
        (register-section sector-y section)
        (modified)
        (let ((section-tag (list (make-tag "Blocks" TAG_Byte_Array blocks)
                                 (make-tag "Data" TAG_Byte_Array data)
                                 (make-tag "BlockLight" TAG_Byte_Array blocklight)
                                 (make-tag "SkyLight" TAG_Byte_Array skylight)
                                 (make-tag "Y" TAG_Byte sector-y))))
          (set-list-payload-content sections (cons section-tag (list-payload-content sections))))
        section)))
  
  
  (method (regenerate)
    (set! sections-table #f)
    (generate #t))
  
  
  (method (generate generate-structures?)
    (let ((zone (current-zone)))
      (define (local-index i <fx> j <fx> k <fx>) <fx>
        (+ (* j 256) (* k 16) i))
      
      (define (block-ref section i <fx> j <fx> k <fx>) <fx>
        (u8vector-ref (get-blocks~ section) (local-index i j k)))
      
      (define (block-set! section i <fx> j <fx> k <fx> block-id <fx> (replace? <bool> #t))
        (when (or replace? (= (block-ref section i j k) 0))
          (u8vector-set! (get-blocks~ section) (local-index i j k) block-id)))
      
      (define (data-set! section i <fx> j <fx> k <fx> data-id <fx> (check-id <bool> #f))
        (when (or (not check-id) (= (block-ref section i j k) check-id))
          (u4vector-set! (get-data~ section) (local-index i j k) data-id)))
      
      (define (u4vector-set! field <u8vector> index <fx> value <fx>)
        (let ((offset (quotient index 2)))
          (let ((byte (u8vector-ref field offset)))
            (u8vector-set! field offset
              (if (even? index)
                  (bitwise-ior value (bitwise-and byte #xF0))
                (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4)))))))
      
      (let ((generator (get-generator~ zone)))
        (generate-chunk~ generator self block-ref block-set! data-set! generate-structures?)
        (set! generator-revision (get-revision~ generator))
        (set! generated? #t))))
  
  
  (method (generate-blocks block-ref block-set! data-set! generate-structures?)
    (let ((sections (make-vector 16 #f))
          (other-sections (make-table test: equal?))
          (zone (current-zone)))
      (define (heightmap-index x <fx> z <fx>) <fx>
        (+ x (* z 16)))
      
      (define (get-section x y z)
        (let ((section-y (fxfloor/ y 16)))
          ;; for development
          (assert (and (>= section-y 0) (< section-y 16)))
          (if (and (= x 0) (= z 0))
              (or (vector-ref sections section-y)
                  (let ((section (add-section section-y)))
                    (vector-set! sections section-y section)
                    (let ((sector (index-sector~ zone (vector x~self section-y z~self))))
                      (set-sector~ section sector)
                      (set-section~ sector section)
                      (set-visual-uptodate?~ sector #f))
                    section))
            (or (table-ref other-sections (list x section-y z) #f)
                (let ((chunk-x (+ x x~self))
                      (chunk-z (+ z z~self)))
                  (if (or (< chunk-x 0) (> chunk-x 31) (< chunk-z 0) (> chunk-z 31))
                      (let ((region-a (fxfloor/ chunk-x 32))
                            (region-c (fxfloor/ chunk-z 32)))
                        (let ((section (get-section~ (get-region~ zone (+ region-a (get-x~ region)) (+ region-c (get-z~ region))) #f (modulo chunk-x 32) section-y (modulo chunk-z 32) create?: #t generate-structures?: #f)))
                          (table-set! other-sections (list x section-y z) section)
                          section))
                    (let ((section (get-section~ region #f (modulo chunk-x 32) section-y (modulo chunk-z 32) create?: #t generate-structures?: #f)))
                      (table-set! other-sections (list x section-y z) section)
                      section)))))))
      
      (define (update-visual)
        (loop (for y from 0 below 16)
              (let ((section (vector-ref sections y)))
                (when section
                  (update-visual~ (get-sector~ section))))))
      
      (loop (for x from 0 below 16)
            (loop (for z from 0 below 16)
                  (let ((height (vector-ref heightmap (heightmap-index x z))))
                    (loop (for y from 0 below height)
                          (block-set! (get-section 0 y 0) x (modulo y 16) z (if (= y (fxfloor height)) 2 3))))))
      (if generate-structures?
          (generate-structures get-section block-set! data-set! update-visual)
        (enqueue (get-tree-chunks~ (current-zone)) (list self get-section block-set! data-set! update-visual))))) ;; vector field with 3 trigo functions (2 for direction and 1 for amount of trees)
  
  
  (method (generate-structures get-section block-set! data-set! update-visual)
    (with-generation-mutex~ (current-zone)
      (lambda ()
        (define (plant-tree x z structure)
          (generate-structure structure x (+ (fxfloor (vector-ref heightmap (+ x (* z 16)))) 7) z get-section block-set! data-set!))
        
        (let ((dir-x (sin (/ (+ x z) 2.)))
              (dir-z (cos (/ (* x z) 3.))))
          (if (> (abs dir-x) (abs dir-z))
              (let ((x (fxround (+ 7.5 (* 7.5 (sign dir-x)))))
                    (z (+ 7 (fxround (+ (/ (* 7.5 dir-z) dir-x) .5)))))
                (plant-tree x z tree1))
            (when (not (and (= dir-x 0.) (= dir-z 0.)))
              (let ((x (+ 7 (fxround (+ (/ (* 7.5 dir-x) dir-z) .5))))
                    (z (fxround (+ 7.5 (* 7.5 (sign dir-x))))))
                (plant-tree x z tree1)))))
        (plant-tree 8 8 tree2)
        @w(update-visual)
        (set! structures-generated? #t))))
  
  
  (method (generate-structure structure i j k get-section block-set! data-set!)
    (define (with-field i j k proc)
      (proc (get-section (fxfloor/ i 16) j (fxfloor/ k 16)) (modulo i 16) (modulo j 16) (modulo k 16)))
    
    (for-each (lambda (element)
                (for-each (lambda (loc)
                            (bind (a b c) loc
                              (with-field (+ i a) (+ j b) (+ k c)
                                (lambda (section x y z)
                                  (block-set! section x y z (cadr element) #f)
                                  (data-set! section x y z (cddr element) (cadr element))))))
                          (car element)))
              structure))
  
  
  (method (get-corner index)
    (vector-ref heightmap (case index
                            ((1) 0)
                            ((2) 15)
                            ((3) 240)
                            ((4) 255))))
  
  
  (method (get-row index)
    (let ((row (make-vector 16 0)))
      (loop (for i from 0 below 16)
            (vector-set! row i (vector-ref heightmap (case index
                                                       ((1) (* 16 i))
                                                       ((2) i)
                                                       ((3) (+ i 240))
                                                       ((4) (+ 15 (* 16 i)))))))
      row))
  
  
  (method protected (reset-modified)
    (set! modified? #f))
  
  
  (method protected (modified)
    (set! modified? #t)
    (modified~ region)))


;;;
;;;; Data
;;;


(class World-Data extends Object
  
  
  (slot blocks      getter generate)
  (slot data        getter generate)
  (slot blocklight  getter generate)
  (slot skylight    getter generate)
  
  
  (method override (initialize blocks data blocklight skylight)
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)
    (set! skylight~self skylight))))
