;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Chunks
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.chunk jazz


(import (jazz.component)
        (jazz.foreign)
        (jazz.geometry)
        (jazz.jml)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.foreign)
        (world.generation.block)
        (world.geometry.syntax (phase syntax))
        (world.homogeneous)
        (world.index)
        (world.instantiate)
        (world.section)
        (world.syntax (phase syntax))
        (world.tag))


(proclaim (warn optimizations))


;;;
;;;; Chunk
;;;


(c-enumeration ChunkState
  (Shaped 0)
  (Populated 1)
  (Generated 2))


;;  +-------+-------+-------+-------+-------+-------+-------+
;;  |       |       |       |       |       |       |       |
;;  |   P   |   P   |   P   |   P   |   P   |   P   |   S   |
;;  |       |       |       |       |       |       |       |
;;  +-------+-------+-------+-------+-------+-------+-------+
;;  |       |       |       |       |       |       |       |
;;  |   P   |   G   |   G   |  <G>  |   G   |   G   |   S   |
;;  |       |       |       |       |       |       |       |
;;  +-------+-------+-------+-------+-------+-------+-------+
;;  |       |       |       |       |       |       |       |
;;  |   P   |   G   |   E   |  <E>  |   E   |   G   |   S   |
;;  |       |       |       |       |       |       |       |
;;  +-------+-------+-------+-------+-------+-------+-------+
;;  |       |       |       |       |       |       |       |
;;  |   P   |   G   |   E   |   E   |   E   |   G   |   S   |
;;  |       |       |       |       |       |       |       |
;;  +-------+-------+-------+-------+-------+-------+-------+
;;  |       |       |       |       |       |       |       |
;;  |   P   |   G   |   E   |   E   |   E   |   G   |   S   |
;;  |       |       |       |       |       |       |       |
;;  +-------+-------+-------+-------+-------+-------+-------+
;;  |       |       |       |       |       |       |       |
;;  |   P   |   G   |   G   |   G   |   G   |   G   |   S   |
;;  |       |       |       |       |       |       |       |
;;  +-------+-------+-------+-------+-------+-------+-------+
;;  |       |       |       |       |       |       |       |
;;  |   S   |   S   |   S   |   S   |   S   |   S   |   S   |
;;  |       |       |       |       |       |       |       |
;;  +-------+-------+-------+-------+-------+-------+-------+

;; when <G>'s visual is instantiated it will need its neighbor sectors
;; and so <E> will end up being regenerated if a garbage collect occured
;; iterating chunk neighbors up to 2 instead of 1 solves this I think


(definition protected debug-regenerated?
  #f)


(definition protected partial-times
  (make-table test: eq?))

(definition protected partial-chunks
  (make-table test: eq?))

(definition protected generated-chunks
  (make-table test: equal?))


;; for debugging retainment
(definition protected (reset-partials)
  (empty-table partial-times)
  (empty-table partial-chunks))


(definition protected (iterate-chunk-neighbors chunk proc)
  (let ((zone (current-zone)))
    (let ((region (get-region~ chunk))
          (region-size 32))
      (let ((x (+ (* (get-x~ region) 32) (get-x~ chunk)))
            (z (+ (* (get-z~ region) 32) (get-z~ chunk))))
        (loop (for section-x from (- x 2) to (+ x 2))
              (loop (for section-z from (- z 2) to (+ z 2))
                    (unless (and (= section-x x)
                                 (= section-z z))
                      (let ((region (find-region~ zone
                                      (fxfloor/ section-x region-size)
                                      0
                                      (fxfloor/ section-z region-size))))
                        (when region
                          (let ((neighbor (find-chunk~ region section-x section-z)))
                            (when neighbor
                              (proc neighbor))))))))))))


(definition protected (register-partial chunk)
  (let ((needed '()))
    (iterate-chunk-neighbors chunk
      (lambda (neighbor)
        (set! needed (cons neighbor needed))))
    (table-set! partial-times chunk (current-seconds))
    (table-set! partial-chunks chunk needed)
    (trim-partials)))


;; quick inefficient solution
(definition protected (trim-partials)
  (define (clear-oldest)
    (let ((oldest-time #f)
          (oldest-chunk #f))
      (iterate-table partial-times
        (lambda (chunk time)
          (when (or (not oldest-time)
                    (< time oldest-time))
            (set! oldest-time time)
            (set! oldest-chunk chunk))))
      (table-clear partial-times oldest-chunk)
      (table-clear partial-chunks oldest-chunk)))
  
  (let ((overflow (- (table-length partial-chunks) 128)))
    (when (> overflow 0)
      (loop (repeat overflow)
            (clear-oldest)))))


(definition protected (register-generated chunk)
  (define (generated-stack)
    (let ((stack (execution-stack)))
      (cond ((memq? 'world.spawn:find-spawners stack)
             'find-spawners)
            ((memq? 'world.lava:find-flowing-lava stack)
             'find-flowing-lava)
            ((memq? 'world.water:find-flowing-water stack)
             'find-flowing-water)
            ((memq? 'world.actor:Actor:update-area-cube stack)
             'update-area-cube)
            ((memq? 'world.generation:instantiate-visual stack)
             'instantiate-visual)
            ((memq? 'world.generation:instantiate-physical stack)
             'instantiate-physical)
            ((memq? 'world.zone:Zone:add-element stack)
             'add-element)
            ((memq? 'world.element:Element:set-position stack)
             'set-position)
            (else
             stack))))
  
  (table-clear partial-times chunk)
  (table-clear partial-chunks chunk)
  (when debug-regenerated?
    (let ((location (chunk-location chunk))
          (stack (generated-stack)))
      (table-add generated-chunks location stack)
      (unless (eq? stack 'instantiate-physical)
        (let ((all (table-ref generated-chunks location)))
          (when (> (length all) 1)
            (debug location (reverse all))))))))


(definition protected (register-new chunk)
  (iterate-chunk-neighbors chunk
    (lambda (neighbor)
      (unless (= (get-state~ neighbor) Generated)
        (table-set! partial-times neighbor (current-seconds))
        (table-add partial-chunks neighbor chunk))))
  (trim-partials))


(definition protected (chunk-location chunk)
  (let ((region (get-region~ chunk)))
    (let ((region-x (get-x~ region))
          (region-z (get-z~ region))
          (chunk-x (get-x~ chunk))
          (chunk-z (get-z~ chunk)))
      (list region-x region-z chunk-x chunk-z))))


(definition protected (monitor-generated-throughput)
  (thread-start!
    (new-thread
      (let ((zone (current-zone)))
        (let ((last-time (current-seconds))
              (last-generated (get-sectors-generated~ zone)))
          (lambda ()
            (let (iter)
              (thread-sleep! 1.)
              (let ((time (current-seconds))
                    (generated (get-sectors-generated~ zone)))
                (terminal (/ (cast <fl> (- generated last-generated)) (- time last-time)))
                (set! last-time time)
                (set! last-generated generated))
              (iter)))))
      'generated)))


(class World-Chunk extends Object
  
  
  (slot x                     <fx>                    getter generate)
  (slot z                     <fx>                    getter generate)
  (slot state                 <fx>                    getter generate)
  (slot digest                                        accessors generate)
  (slot raw                                           accessors generate)
  (slot region                <World-Region>          getter generate)
  (slot tag                                           getter generate)
  (slot biomes                <u8vector>              accessors generate)
  (slot heightmap             <vector>                accessors generate)
  (slot entities                                      getter generate)
  (slot block-entities                                getter generate)
  (slot block-entities-index  <table+>                getter generate)
  (slot sections                                      getter generate)
  (slot sections-table        <table+>  initialize #f getter generate)
  (slot elements                                      getter generate)
  (slot elements-designer               initialize #f accessors generate)
  (slot generator-revision    <fx>      initialize -1 accessors generate)
  (slot modified?             <bool>    initialize #f accessors generate)
  
  
  (method override (initialize state digest raw region tag biomes heightmap entities block-entities sections elements chunk-index)
    (set! state~self state)
    (set! digest~self digest)
    (set! raw~self raw)
    (set! region~self region)
    (set! tag~self tag)
    (set! biomes~self biomes)
    (set! heightmap~self heightmap)
    (set! entities~self entities)
    (set! block-entities~self block-entities)
    (set! block-entities-index~self (index-block-entities (list-payload-content block-entities)))
    (set! sections~self sections)
    (set! elements~self elements)
    (set! x~self (planar-index-x chunk-index))
    (set! z~self (planar-index-z chunk-index))
    (register-new self)
    (if (= state Generated)
        (register-generated self)
      (register-partial self)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" x z))))
  
  
  (method (change-state s)
    (unless (eq? s state)
      (set! state s)
      (let ((compound (tag-find "Level" (tag-value tag))))
        (tag-add compound "State" TAG_Byte state))
      (if (= s Generated)
          (register-generated self)
        (register-partial self))))
  
  
  (method (register-section y section)
    (assert (between? y 0 31))
    (unless sections-table
      (set! sections-table (make-table test: eq?)))
    (allege sections-table
      (table-set! sections-table y section)))
  
  
  (method (index-block-entities block-entities)
    (if (null? block-entities)
        #f
      (let ((table (make-table test: equal?)))
        (for-each (lambda (block-entity)
                    (let ((x (tag-assoc "x" block-entity))
                          (y (tag-assoc "y" block-entity))
                          (z (tag-assoc "z" block-entity)))
                      (let ((index (indexed x y z)))
                        (table-set! table index block-entity))))
                  block-entities)
        table)))
  
  
  (method (find-block-entity index <index>)
    (and block-entities-index (table-ref block-entities-index index #f)))
  
  
  (method (add-block-entity index <index>)
    (let ((x (index-x index))
          (y (index-y index))
          (z (index-z index)))
      (let ((block-entity (list (make-tag "Items" TAG_List (make-list-payload TAG_Compound '()))
                                (make-tag "id" TAG_String "Chest")
                                (make-tag "x" TAG_Int x)
                                (make-tag "y" TAG_Int y)
                                (make-tag "z" TAG_Int z))))
        (when (not block-entities-index)
          (set! block-entities-index (make-table test: equal?)))
        (allege block-entities-index
          (set-list-payload-content block-entities TAG_Compound (cons block-entity (list-payload-content block-entities)))
          (table-set! block-entities-index index block-entity)
          block-entity))))
  
  
  (method (add-sign index <index> data)
    (let ((block-entity (list (make-tag "id" TAG_String "Sign")
                              (make-tag "x" TAG_Int (index-x index))
                              (make-tag "y" TAG_Int (index-y index))
                              (make-tag "z" TAG_Int (index-z index))
                              (make-tag "Text1" TAG_String (list-ref data 0))
                              (make-tag "Text2" TAG_String (list-ref data 1))
                              (make-tag "Text3" TAG_String (list-ref data 2))
                              (make-tag "Text4" TAG_String (list-ref data 3)))))
      (when (not block-entities-index)
        (set! block-entities-index (make-table test: equal?)))
      (allege block-entities-index
        (let ((old-sign (table-ref block-entities-index index #f)))
          (when old-sign
            (set-list-payload-content block-entities TAG_Compound (remove! old-sign (list-payload-content block-entities) test: equal?))))
        (set-list-payload-content block-entities TAG_Compound (cons block-entity (list-payload-content block-entities)))
        (table-set! block-entities-index index block-entity)
        (modified)
        (save-region~ region)
        block-entity)))
  
  
  (method (setup-section section <World-Section>)
    (let ((section-y (get-y~ section))
          (blocks (get-blocks~ section))
          (data (get-data~ section))
          (blocklight (get-blocklight~ section))
          (skylight (get-skylight~ section)))
      (set-chunk~ section self)
      (register-section section-y section)
      (let ((section-tag (list (make-tag "Blocks" TAG_Byte_Array blocks)
                               (make-tag "Data" TAG_Byte_Array data)
                               (make-tag "BlockLight" TAG_Byte_Array blocklight)
                               (make-tag "SkyLight" TAG_Byte_Array skylight)
                               (make-tag "Y" TAG_Byte section-y))))
        (set-list-payload-content sections TAG_Compound (cons section-tag (list-payload-content sections))))
      (modified)))
  
  
  (method (create-section section-y) <World-Section>
    (let ((section (make-section section-y)))
      (setup-section section)
      section))
  
  
  (method (load-section section-x <fx> section-y <fx> section-z <fx> (create?: create? #f)) <World-Section+>
    (let ((y (modulo section-y 32)))
      (let ((existing-section (and sections-table (table-ref sections-table y #f))))
        (if (and (not existing-section) create?)
            (create-section y)
          existing-section))))
  
  
  (method (get-section section-y <fx>) <World-Section>
    (assert (between? section-y 0 31))
    (or (and sections-table (table-ref sections-table section-y #f))
        (create-section section-y)))
  
  
  (method (find-section section-y <fx>) <World-Section+>
    (and sections-table (table-ref sections-table section-y #f)))
  
  
  (method (get-chunk-height x <fx> z <fx>) <fx>
    (vector-ref heightmap (+ x (* z 16))))
  
  
  (method (chunk-locator)
    (let ((region-x (get-x~ region))
          (region-z (get-z~ region)))
      (cons (+ (* region-x 32) x)
            (+ (* region-z 32) z))))
  
  
  @convert
  (method (reshape)
    (set! sections-table #f)
    (shape))
  
  
  (method (generated)
    (let ((zone (current-zone)))
      (set! generator-revision (get-revision~ (get-generator~ zone)))))
  
  
  (method protected (reset-modified)
    (set! modified? #f))
  
  
  (method protected (modified)
    (set! modified? #t)
    (modified~ region))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (cache-designer)
    (or elements-designer
        (let ((units '(world.data)))
          (let ((tag '(<Chunk-Container>))
                (data (new Data zone-version 'jazz units #f)))
            (let ((form (construct-form tag (imports-locator units) data))
                  (container (new Chunk-Container)))
              (set-chunk~ container self)
              (let ((des (new Former form: form reference: container)))
                (set! elements-designer des)
                des))))))
  
  
  (method (save-designer)
    (when elements-designer
      (let ((compound (tag-find "Level" (tag-value tag))))
        (if (null? (get-children~ (get-form~ elements-designer)))
            (begin
              (tag-remove compound "Elements")
              (set! elements #f)
              (set! elements-designer #f))
          (let ((port (open-output-string)))
            ;; for now save as string
            (save-to-port~ elements-designer port)
            (let ((content (object->u8vector (get-output-string port))))
              (tag-add compound "Elements" TAG_Byte_Array content)))))))
  
  
  (method (instantiate-elements)
    (let ((zone (current-zone)))
      (when elements
        (let ((content (u8vector->object elements)))
          (call-with-input-string (list init: content readtable: jazz-readtable)
            (lambda (port)
              (let ((form (read-form-from port))
                    (backward-compatibility? #f))
                ;; backward compatibility
                (when (eq? (get-model~ form) 'Component)
                  (set! backward-compatibility? #t)
                  (set-model~ form 'Chunk-Container))
                (let ((container (instantiate~ form)))
                  (prepare-scripting~ zone)
                  (set-chunk~ container self)
                  (for-each (lambda (child)
                              (add-element~ zone child self))
                            (get-children~ container))
                  (set! elements-designer (new Former form: form reference: container))
                  (when backward-compatibility?
                    (with-chunk-designer~ zone self
                      (lambda (designer container)
                        ))))))))
        (set! elements #f)))))


;;;
;;;; Container
;;;


(class Chunk-Container extends Component
  
  
  (slot chunk initialize #f accessors generate)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" (get-x~ chunk) (get-z~ chunk)))))))
