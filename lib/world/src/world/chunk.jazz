;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Chunks
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.chunk jazz


(import (jazz.foreign)
        (jazz.geometry)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.biome)
        (world.foreign)
        (world.generation.block)
        (world.geometry.syntax (phase syntax))
        (world.homogeneous)
        (world.section)
        (world.syntax (phase syntax))
        (world.tag))


(proclaim (warn optimizations))


;;;
;;;; Chunk
;;;


(c-enumeration ChunkState
  (Generated 0)
  (Populated 1)
  (Loaded    2))


(class World-Chunk extends Object
  
  
  (slot refcount              <fx>      initialize 0  getter generate)
  (slot x                     <fx>                    getter generate)
  (slot z                     <fx>                    getter generate)
  (slot state                 <fx>                    getter generate)
  (slot digest                                        accessors generate)
  (slot raw                                           accessors generate)
  (slot region                <World-Region>          getter generate)
  (slot tag                                           getter generate)
  (slot biomes                <u8vector>              accessors generate)
  (slot heightmap             <vector>                accessors generate)
  (slot entities                                      getter generate)
  (slot block-entities                                getter generate)
  (slot block-entities-index  <table+>                getter generate)
  (slot sections                                      getter generate)
  (slot sections-table        <table+>  initialize #f getter generate)
  (slot generator-revision    <fx>      initialize -1 accessors generate)
  (slot modified?             <bool>    initialize #f accessors generate)
  
  
  (method override (initialize state digest raw region tag biomes heightmap entities block-entities sections chunk-index)
    (set! state~self state)
    (set! digest~self digest)
    (set! raw~self raw)
    (set! region~self region)
    (set! tag~self tag)
    (set! biomes~self biomes)
    (set! heightmap~self heightmap)
    (set! entities~self entities)
    (set! block-entities~self block-entities)
    (set! block-entities-index~self (index-block-entities (list-payload-content block-entities)))
    (set! sections~self sections)
    (set! x~self (car chunk-index))
    (set! z~self (cdr chunk-index)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" x z))))
  
  
  (method (refcount-increase)
    (increase! refcount)
    ;(debug self 'refcount refcount)
    )
  
  
  (method (refcount-decrease)
    (decrease! refcount)
    ;(debug self 'refcount refcount)
    (when (<= refcount 0)
      (release)))
  
  
  (method (release)
    ;(debug 'release self)
    (refcount-decrease~ region))
  
  
  (method (change-state s)
    (set! state s)
    (let ((compound (tag-find "Level" (tag-value tag))))
      (tag-add compound "State" TAG_Byte state)))
  
  
  (method (register-section y section)
    (refcount-increase)
    (unless sections-table
      (set! sections-table (make-table test: eq?)))
    (allege sections-table
      (table-set! sections-table y section)))
  
  
  (method (index-block-entities block-entities)
    (if (null? block-entities)
        #f
      (let ((table (make-table test: equal?)))
        (for-each (lambda (block-entity)
                    (let ((x (tag-assoc "x" block-entity))
                          (y (tag-assoc "y" block-entity))
                          (z (tag-assoc "z" block-entity)))
                      (let ((index (vector x y z)))
                        (table-set! table index block-entity))))
                  block-entities)
        table)))
  
  
  (method (find-block-entity index)
    (and block-entities-index (table-ref block-entities-index index #f)))
  
  
  (method (add-block-entity index <vector>)
    (let ((x (vector-ref index 0))
          (y (vector-ref index 1))
          (z (vector-ref index 2)))
      (let ((block-entity (list (make-tag "Items" TAG_List (make-list-payload TAG_Compound '()))
                                (make-tag "id" TAG_String "Chest")
                                (make-tag "x" TAG_Int x)
                                (make-tag "y" TAG_Int y)
                                (make-tag "z" TAG_Int z))))
        (when (not block-entities-index)
          ;; when empty it contains ("TileEntities" 9 0)
          (set-list-payload-type block-entities TAG_Compound)
          (set! block-entities-index (make-table test: equal?)))
        (allege block-entities-index
          (set-list-payload-content block-entities (cons block-entity (list-payload-content block-entities)))
          (table-set! block-entities-index index block-entity)
          block-entity))))
  
  
  (method (add-sign index <vector> data)
    (let ((block-entity (list (make-tag "id" TAG_String "Sign")
                              (make-tag "x" TAG_Int (vector-ref index 0))
                              (make-tag "y" TAG_Int (vector-ref index 1))
                              (make-tag "z" TAG_Int (vector-ref index 2))
                              (make-tag "Text1" TAG_String (list-ref data 0))
                              (make-tag "Text2" TAG_String (list-ref data 1))
                              (make-tag "Text3" TAG_String (list-ref data 2))
                              (make-tag "Text4" TAG_String (list-ref data 3)))))
      (when (not block-entities-index)
        (set-list-payload-type block-entities TAG_Compound)
        (set! block-entities-index (make-table test: equal?)))
      (allege block-entities-index
        (let ((old-sign (table-ref block-entities-index index #f)))
          (when old-sign
            (set-list-payload-content block-entities (remove! old-sign (list-payload-content block-entities) test: equal?))))
        (set-list-payload-content block-entities (cons block-entity (list-payload-content block-entities)))
        (table-set! block-entities-index index block-entity)
        (modified)
        (save-region~ region)
        block-entity)))
  
  
  (method (add-section sector-y) <World-Section>
    (let ((blocks (make-u8vector 4096))
          (data (make-u8vector 2048))
          (blocklight (make-u8vector 2048 0))
          (skylight (make-u8vector 2048 0))) ;; quicky
      (let ((section (new World-Section self sector-y blocks data blocklight skylight)))
        (register-section sector-y section)
        (modified)
        (let ((section-tag (list (make-tag "Blocks" TAG_Byte_Array blocks)
                                 (make-tag "Data" TAG_Byte_Array data)
                                 (make-tag "BlockLight" TAG_Byte_Array blocklight)
                                 (make-tag "SkyLight" TAG_Byte_Array skylight)
                                 (make-tag "Y" TAG_Byte sector-y))))
          (set-list-payload-content sections (cons section-tag (list-payload-content sections))))
        section)))
  
  
  (method (get-section section-y <fx>) <World-Section>
    (assert (< section-y 16))
    (or (and sections-table (table-ref sections-table section-y #f))
        (let ((section (add-section section-y)))
          (let ((sector (index-sector~ (current-zone) (vector (+ (* (get-x~ region) 32) x) section-y (+ (* (get-z~ region) 32) z)))))
            (set-sector~ section sector)
            (set-section~ sector section))
          section)))
  
  
  (method (get-biome x <fx> z <fx>) <Biome>
    (define (heightmap-index x <fx> z <fx>) <fx>
      (+ x (* z 16)))
    
    (id->biome (u8vector-ref biomes (+ x (* z 16)))))
  
  
  (method (get-chunk-height x <fx> z <fx>) <fx>
    (define (heightmap-index x <fx> z <fx>) <fx>
      (+ x (* z 16)))
    
    (vector-ref heightmap (heightmap-index x z)))
  
  
  (method private (set-height! x <fx> z <fx> value <fx>)
    (define (heightmap-index x <fx> z <fx>) <fx>
      (+ x (* z 16)))
    
    (vector-set! heightmap (heightmap-index x z) value))
  
  
  (method (regenerate)
    (set! sections-table #f)
    (generate))
  
  
  (method (generate)
    (let ((zone (current-zone)))
      (let ((sections (make-vector 16 #f)))
        (define (cache-section j <fx>) <World-Section>
          (let ((y (fxfloor/ j 16)))
            (or (vector-ref sections y)
                (let ((section (get-section y)))
                  (vector-set! sections y section)
                  section))))
        
        (define (local-index i <fx> j <fx> k <fx>) <fx>
          (+ (* j 256) (* k 16) i))
        
        (define (block-ref i <fx> j <fx> k <fx>) <fx>
          (u8vector-ref (get-blocks~ (cache-section j)) (local-index i (modulo j 16) k)))
        
        (define (block-set! i <fx> j <fx> k <fx> block-id <fx>)
          (u8vector-set! (get-blocks~ (cache-section j)) (local-index i (modulo j 16) k) block-id))
        
        (define (data-set! i <fx> j <fx> k <fx> data-id <fx>)
          (u4vector-set! (get-data~ (cache-section j)) (local-index i (modulo j 16) k) data-id))
        
        (define (u4vector-set! field <u8vector> index <fx> value <fx>)
          (let ((offset (quotient index 2)))
            (let ((byte (u8vector-ref field offset)))
              (u8vector-set! field offset
                (if (even? index)
                    (bitwise-ior value (bitwise-and byte #xF0))
                  (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4)))))))
        
        (define (blockstate-set! i <fx> j <fx> k <fx> id <fx>)
          (bind-values (block-id <fx> data-id <fx>) (decode-fxid/variant-id id)
            (block-set! i j k block-id)
            (when (> data-id 0)
              (data-set! i j k data-id))))
        
        (define (skylight-set! i <fx> j <fx> k <fx> value <fx>)
          (u4vector-set! (get-skylight~ (cache-section j)) (local-index i (modulo j 16) k) value))
        
        (let ((generator (get-generator~ zone)))
          (generate-chunk~ generator self block-ref block-set! data-set! blockstate-set! skylight-set!))
        (generated)
        (modified))))
  
  
  (method (generated)
    (let ((zone (current-zone)))
      (set! generator-revision (get-revision~ (get-generator~ zone)))))
  
  
(method protected (reset-modified)
    (set! modified? #f))
  
  
  (method protected (modified)
    (set! modified? #t)
    (modified~ region)))


;;;
;;;; Data
;;;


(class World-Data extends Object
  
  
  (slot blocks      getter generate)
  (slot data        getter generate)
  (slot blocklight  getter generate)
  (slot skylight    getter generate)
  
  
  (method override (initialize blocks data blocklight skylight)
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)
    (set! skylight~self skylight))))
