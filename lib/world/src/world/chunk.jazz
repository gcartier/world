;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Chunks
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.chunk jazz


(import (world)
        (world.autoload)
        (world.foreign.noise)
        (world.geometry)
        (world.index)
        (world.section)
        (world.syntax (phase syntax))
        (world.tag))


(proclaim (warn optimizations))


;;;
;;;; Chunk
;;;


(class World-Chunk extends Object
  
  
  (slot refcount             <fx>      initialize 0  getter generate)
  (slot x                    <fx>                    getter generate)
  (slot z                    <fx>                    getter generate)
  (slot digest                                       accessors generate)
  (slot raw                                          accessors generate)
  (slot region                                       getter generate)
  (slot tag                                          getter generate)
  (slot heightmap            <vector+>               getter generate)
  (slot entities                                     getter generate)
  (slot block-entities                               getter generate)
  (slot block-entities-index <table+>                getter generate)
  (slot sections                                     getter generate)
  (slot sections-table       <table+>  initialize #f getter generate)
  (slot modified?            <bool>    initialize #f accessors generate)
  
  
  (method override (initialize digest raw region tag heightmap entities block-entities sections chunk-index)
    (set! digest~self digest)
    (set! raw~self raw)
    (set! region~self region)
    (set! tag~self tag)
    (set! heightmap~self heightmap)
    (set! entities~self entities)
    (set! block-entities~self block-entities)
    (set! block-entities-index~self (index-block-entities (list-payload-content block-entities)))
    (set! sections~self sections)
    (set! x~self (car chunk-index))
    (set! z~self (cdr chunk-index)))
  
  
  (method (refcount-increase)
    (increase! refcount)
    ;(debug self 'refcount refcount)
    )
  
  
  (method (refcount-decrease)
    (decrease! refcount)
    ;(debug self 'refcount refcount)
    (when (<= refcount 0)
      (release)))
  
  
  (method (release)
    ;(debug 'release self)
    (refcount-decrease~ region))
  
  
  (method (register-section y section)
    (refcount-increase)
    (unless sections-table
      (set! sections-table (make-table test: eq?)))
    (table-set! sections-table y section))
  
  
  (method (index-block-entities block-entities)
    (if (null? block-entities)
        #f
      (let ((table (make-table test: equal?)))
        (for-each (lambda (block-entity)
                    (let ((x (tag-assoc "x" block-entity))
                          (y (tag-assoc "y" block-entity))
                          (z (tag-assoc "z" block-entity)))
                      (let ((index (vector x y z)))
                        (table-set! table index block-entity))))
                  block-entities)
        table)))
  
  
  (method (find-block-entity index)
    (and block-entities-index (table-ref block-entities-index index #f)))
  
  
  (method (add-block-entity index)
    (let ((x (vector-ref index 0))
          (y (vector-ref index 1))
          (z (vector-ref index 2)))
      (let ((block-entity (list (make-tag "Items" TAG_List (make-list-payload TAG_Compound '()))
                                (make-tag "id" TAG_String "Chest")
                                (make-tag "x" TAG_Int x)
                                (make-tag "y" TAG_Int y)
                                (make-tag "z" TAG_Int z))))
        (when (not block-entities-index)
          ;; when empty it contains ("TileEntities" 9 0)
          (set-list-payload-type block-entities TAG_Compound)
          (set! block-entities-index (make-table test: equal?)))
        (set-list-payload-content block-entities (cons block-entity (list-payload-content block-entities)))
        (table-set! block-entities-index index block-entity)
        block-entity)))
  
  
  (method (add-section sector-y)
    (let ((blocks (make-u8vector 4096))
          (data (make-u8vector 2048))
          (blocklight (make-u8vector 2048))
          (skylight (make-u8vector 2048 255))) ;; quicky
      (let ((section (new World-Section self blocks data blocklight skylight)))
        (register-section sector-y section)
        (modified)
        (let ((section-tag (list (make-tag "Blocks" TAG_Byte_Array blocks)
                                 (make-tag "Data" TAG_Byte_Array data)
                                 (make-tag "BlockLight" TAG_Byte_Array blocklight)
                                 (make-tag "SkyLight" TAG_Byte_Array skylight)
                                 (make-tag "Y" TAG_Byte sector-y))))
          (set-list-payload-content sections (cons section-tag (list-payload-content sections))))
        section)))
  
  
  (method (generate)
    (let ((zone (current-zone)))
      (define (local-index i <fx> j <fx> k <fx>) <fx>
        (+ (* j 256) (* k 16) i))
      
      (define (block-ref section i <fx> j <fx> k <fx>) <fx>
        (u8vector-ref (get-blocks~ section) (local-index i j k)))
      
      (define (block-set! section i <fx> j <fx> k <fx> block-id <fx>)
        (u8vector-set! (get-blocks~ section) (local-index i j k) block-id))
      
      (case (get-generator~ zone)
        ((flat)
         (generate-flat block-ref block-set!))
        ((simplex)
         (generate-simplex block-ref block-set!))
        ((diamond)
         (generate-diamond-square block-ref block-set!))
        ((poly)
         (set! heightmap~self (generate-polynomial-heightmap))
         (generate-blocks block-ref block-set!)
         (modified)))))
  
  
  (method (generate-flat block-ref block-set!)
    (let ((section (add-section 0)))
      (loop (for i from 0 below 16)
            (loop (for k from 0 below 16)
                  (block-set! section i 0 k world.generation:Bedrock)
                  (block-set! section i 1 k world.generation:Dirt)
                  (block-set! section i 2 k world.generation:Dirt)
                  (block-set! section i 3 k world.generation:Grass)))))
  
  
  (method (generate-simplex block-ref block-set!)
    (define (generate-heightmap)
      (let ((heights (make-vector 256 1.))
            (base-x (* x 16.))
            (base-z (* z 16.)))
        (define (vector-index x <fx> z <fx>) <fx>
          (+ x (* z 16)))
        
        (let ((context (simplex-noise 87))
              (frequency .02)
              (amplitude 20.)
              (octaves 3)
              (lacunarity 2.0)
              (gain .5))
          (loop (repeat octaves)
                (loop (for a from 0 below 16)
                      (loop (for c from 0 below 16)
                            (let ((index (vector-index a c))
                                  (x (* (+ base-x (cast <fl> a)) frequency))
                                  (z (* (+ base-z (cast <fl> c)) frequency)))
                              (vector-set! heights index (+ (vector-ref heights index) (* amplitude (+ .7071067811865476 (simplex-noise2 context x z))))))))
                (set! amplitude (* amplitude gain))
                (set! frequency (* frequency lacunarity)))
          (simplex-noise-free context)
          heights)))
  
    (set! heightmap~self (generate-heightmap))
    (generate-blocks block-ref block-set!)
    (modified))
  
  
  (method (generate-diamond-square block-ref block-set!)
    (set! heightmap~self (generate-diamond-square-heightmap))
    (generate-blocks block-ref block-set!)
    (modified))
  
  
  (method (generate-blocks block-ref block-set!)
    (let ((sections (make-vector 16 #f)))
      (define (heightmap-index x <fx> z <fx>) <fx>
        (+ x (* z 16)))
      
      (define (get-section y)
        (let ((section-y (fxfloor/ y 16)))
          (or (vector-ref sections section-y)
              (let ((section (add-section section-y)))
                (vector-set! sections section-y section)
                section))))
      
      (loop (for x from 0 below 16)
            (loop (for z from 0 below 16)
                  (let ((height (vector-ref heightmap (heightmap-index x z))))
                    (loop (for y from 0 below height)
                          (block-set! (get-section y) x (modulo y 16) z (if (= y (fxfloor height)) 2 3))))))))
  
  
  (method (generate-diamond-square-heightmap)
    (let ((height (make-vector 289 0)))
      (define (vector-index x <fx> z <fx>) <fx>
        (+ x (* z 17)))
      
      (define (diamond-step n)
        (let ((average-hop (/ 16 (expt 2 n))))
          (let ((move-hop (* average-hop 2)))
            (define (diamond-average x z)
              (fxfloor (/ (+ (vector-ref height (vector-index (- x average-hop) (- z average-hop)))
                             (vector-ref height (vector-index (+ x average-hop) (- z average-hop)))
                             (vector-ref height (vector-index (- x average-hop) (+ z average-hop)))
                             (vector-ref height (vector-index (+ x average-hop) (+ z average-hop))))
                          4.)))
            
            (loop (for a from 0 below (expt 2 (- n 1)))
                  (loop (for c from 0 below (expt 2 (- n 1)))
                        (let ((x (+ average-hop (* a move-hop)))
                              (z (+ average-hop (* c move-hop))))
                          (vector-set! height (vector-index x z) (+ (diamond-average x z) (if (> n 1) 0 (random-integer-between -1 1))))))))))
      
      (define (square-step n)
        (let ((average-hop (/ 16 (expt 2 n))))
          (let ((move-hop (* average-hop 2)))
            (define (square-average x z)
              (let ((edge? (or (= x 0) (= x 16) (= z 0) (= z 16))))
                (fxfloor (/ (+ (if (= x 0) 0 (vector-ref height (vector-index (- x average-hop) z)))
                               (if (= x 16) 0 (vector-ref height (vector-index (+ x average-hop) z)))
                               (if (= z 0) 0 (vector-ref height (vector-index x (- z average-hop))))
                               (if (= z 16) 0 (vector-ref height (vector-index x (+ z average-hop)))))
                            (if edge? 3. 4.)))))
            
            (loop (for c from 0 below (+ (expt 2 n) 1))
                  (if (even? c)
                      (loop (for a from 0 below (expt 2 (- n 1)))
                            (let ((x (+ average-hop (* a move-hop)))
                                  (z (* c average-hop)))
                              (vector-set! height (vector-index x z) (+ (square-average x z) (if (> n 1) 0 (random-integer-between -1 1))))))
                    (loop (for a from 0 below (+ (expt 2 (- n 1)) 1))
                          (let ((x (* a move-hop))
                                (z (* c average-hop)))
                            (vector-set! height (vector-index x z) (+ (square-average x z) (if (> n 1) 0 (random-integer-between -1 1)))))))))))
      
      (vector-set! height (vector-index 0  0 ) 64)
      (vector-set! height (vector-index 0  16) 64)
      (vector-set! height (vector-index 16 0 ) 64)
      (vector-set! height (vector-index 16 16) 64)
      (loop (for n from 1 to 4)
            (diamond-step n)
            (square-step n))
      (subvector height 0 256)))
  
  
  (method (generate-polynomial-heightmap)
    (let ((zone (current-zone))
          (heights (make-vector 256 0))
          (region #f)
          (chunk #f))
      (define (corner-height n x z)
        (set! region (cond ((< x 0) (increase! x 32) (table-ref (get-regions~ zone) (cons (- (get-x~ region~self) 1) (get-z~ region~self)) #f))
                           ((> x 31) (decrease! x 32) (table-ref (get-regions~ zone) (cons (+ (get-x~ region~self) 1) (get-z~ region~self)) #f))
                           ((< z 0) (increase! z 32) (table-ref (get-regions~ zone) (cons (get-x~ region~self) (- (get-z~ region~self) 1)) #f))
                           ((> z 31) (decrease! z 32) (table-ref (get-regions~ zone) (cons (get-x~ region~self) (+ (get-z~ region~self) 1)) #f))
                           (else region~self)))
        (when region
          (set! chunk (table-ref (get-chunks~ region) (cons x z) #f))
          (when chunk
            (get-corner~ chunk n))))
      
      (define (make-heightmap fx fz ax az mx mz ac)
        (loop (for x from 0 below 16)
              (loop (for z from 0 below 16)
                    (vector-set! heights (+ (ax x) (* (az z) 16)) (min 255 (max 1 (+ 16 (fxround (cast <fl> (+ (* (/ x (max 1 (+ x z))) (/ (fx x) mx)) (* (/ z (max 1 (+ x z))) (/ (fz z) mz)) (* (/ (+ x z) 30) (- 1 (/ (abs (- z x)) 15)) ac)))))))))))
      
      (define (approx row)
        #f)
      
      (let ((corner1 (corner-height 2 (- x 1) z))
            (corner2 (corner-height 4 x (- z 1)))
            (corner3 (corner-height 1 x (+ z 1)))
            (corner4 (corner-height 3 (+ x 1) z))
            (x-ajust (lambda (x) x))
            (z-ajust (lambda (z) z)))
        (let ((nb 0))
          (when corner1
            (increase! nb))
          (when corner2
            (increase! nb))
          (when corner3
            (increase! nb))
          (when corner4
            (increase! nb))
          (when (= nb 0)
            (set! corner1 64))
          (case nb
            ((1) (let ((corner (or corner1 (cond (corner2 (set! x-ajust (lambda (x) (- 15 x))) corner2)
                                                 (corner3 (set! z-ajust (lambda (z) (- 15 z))) corner3)
                                                 (corner4 (set! x-ajust (lambda (x) (- 15 x))) (set! z-ajust (lambda (z) (- 15 z))) corner4)))))
                   (let ((x-var (lambda (x) (+ (* x x x (- (random-real) .5) 3) (* x x (- (random-real) .5) 10) (* x (- (random-real) .5) 14) corner)))
                         (z-var (lambda (z) (+ (* z z (- (random-real) .5) 3) (* z (- (random-real) .5) 10) corner)))
                         (max-x (max 1 (fxround (* (random-real) (random-real) 3))))
                         (max-z (max 1 (fxround (* (random-real) (random-real) 3)))))
                     (let ((x-factor (abs (/ (- (x-var 16) (x-var 0)) max-x)))
                           (z-factor (abs (/ (- (z-var 16) (z-var 0)) max-z))))
                       (make-heightmap x-var z-var x-ajust z-ajust x-factor z-factor (random-integer-between -3 3))))))
            ((2) (if (or (and corner1 corner4) (and corner2 corner3))
                     (let ((c1 (or corner1 (begin (set! x-ajust (lambda (x) (- 15 x))) corner2)))
                           (c2 (or corner3 corner4)))
                       (let ((x-var (lambda (x) (+ (* x x x (- (random-real) .5) 6) (* x x (- (random-real) .5) 10) (* x (- (random-real) .5) 14) c1)))
                             (z-var (lambda (z) (+ (* z z z (- (random-real) .5) 4) (* z z (- (random-real) .5) 8) (* z (- (random-real) .5) 12) c1)))
                             (max-x (max 1 (fxround (* (random-real) (random-real) 3))))
                             (max-z (max 1 (fxround (* (random-real) (random-real) 3)))))
                         (let ((x-factor (abs (/ (- (x-var 16) (x-var 0)) max-x)))
                               (z-factor (abs (/ (- (z-var 16) (z-var 0)) max-z))))
                           (make-heightmap x-var z-var x-ajust z-ajust x-factor z-factor (- c2 (+ (* .5 (/ (x-var 15) x-factor)) (* .5 (/ (z-var 15) z-factor))))))))
                   (make-heightmap
                     (lambda (x) (+ (* x x x (- (random-real) .5) 6) (* x x (- (random-real) .5) 10) (* x (- (random-real) .5) 14) 64))
                     (lambda (z) (+ (* z z z (- (random-real) .5) 4) (* z z (- (random-real) .5) 8) (* z (- (random-real) .5) 12) 64))
                     (lambda (x) x)
                     (lambda (z) z)
                     (* (+ (random-real) 1) 800)
                     (* (+ (random-real) 1) 800)
                     3)))
            (else (make-heightmap
                    (lambda (x) (+ (* x x x (- (random-real) .5) 3) (* x x (- (random-real) .5) 4) (* x (- (random-real) .5) 5) 64))
                    (lambda (z) (+ (* z z z (- (random-real) .5) 2) (* z z (- (random-real) .5) 3) (* z (- (random-real) .5) 4) 64))
                    (lambda (x) x)
                    (lambda (z) z)
                    (* (+ (random-real) 1) 800)
                    (* (+ (random-real) 1) 800)
                    1)))))
      heights))
  
  
  (method (get-corner index)
    (vector-ref heightmap (case index
                            ((1) 0)
                            ((2) 15)
                            ((3) 240)
                            ((4) 255))))
  
  
  (method (get-row index)
    (let ((row (make-vector 16 0)))
      (loop (for i from 0 below 16)
            (vector-set! row i (vector-ref heightmap (case index
                                                       ((1) (* 16 i))
                                                       ((2) i)
                                                       ((3) (+ i 240))
                                                       ((4) (+ 15 (* 16 i)))))))
      row))
  
  
  (method protected (reset-modified)
    (set! modified? #f))
  
  
  (method protected (modified)
    (set! modified? #t)
    (modified~ region)))


;;;
;;;; Data
;;;


(class World-Data extends Object
  
  
  (slot blocks      getter generate)
  (slot data        getter generate)
  (slot blocklight  getter generate)
  (slot skylight    getter generate)
  
  
  (method override (initialize blocks data blocklight skylight)
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)
    (set! skylight~self skylight))))
