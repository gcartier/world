;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Chunks
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.chunk jazz


(import (jazz.foreign)
        (jazz.geometry)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.biome)
        (world.foreign)
        (world.generation.block)
        (world.geometry.syntax (phase syntax))
        (world.homogeneous)
        (world.section)
        (world.syntax (phase syntax))
        (world.tag))


(proclaim (warn optimizations))


;;;
;;;; Chunk
;;;


(c-enumeration ChunkState
  (Created   0)   ;; created by another's populate
  (Populated 1)   ;; populated by another's generate
  (Generated 2))  ;; fully generated


(class World-Chunk extends Object
  
  
  (slot refcount              <fx>      initialize 0  getter generate)
  (slot x                     <fx>                    getter generate)
  (slot z                     <fx>                    getter generate)
  (slot state                 <fx>                    getter generate)
  (slot digest                                        accessors generate)
  (slot raw                                           accessors generate)
  (slot region                <World-Region>          getter generate)
  (slot tag                                           getter generate)
  (slot biomes                <u8vector>              accessors generate)
  (slot heightmap             <vector>                accessors generate)
  (slot entities                                      getter generate)
  (slot block-entities                                getter generate)
  (slot block-entities-index  <table+>                getter generate)
  (slot sections                                      getter generate)
  (slot sections-table        <table+>  initialize #f getter generate)
  (slot generator-revision    <fx>      initialize -1 accessors generate)
  (slot generated?            <bool>    initialize #f accessors generate)
  (slot populated?            <bool>    initialize #f accessors generate)
  (slot modified?             <bool>    initialize #f accessors generate)
  
  
  (method override (initialize state digest raw region tag biomes heightmap entities block-entities sections chunk-index)
    (set! state~self state)
    (set! digest~self digest)
    (set! raw~self raw)
    (set! region~self region)
    (set! tag~self tag)
    (set! biomes~self biomes)
    (set! heightmap~self heightmap)
    (set! entities~self entities)
    (set! block-entities~self block-entities)
    (set! block-entities-index~self (index-block-entities (list-payload-content block-entities)))
    (set! sections~self sections)
    (set! x~self (car chunk-index))
    (set! z~self (cdr chunk-index)))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" x z))))
  
  
  (method (refcount-increase)
    (increase! refcount)
    ;(debug self 'refcount refcount)
    )
  
  
  (method (refcount-decrease)
    (decrease! refcount)
    ;(debug self 'refcount refcount)
    (when (<= refcount 0)
      (release)))
  
  
  (method (release)
    ;(debug 'release self)
    (refcount-decrease~ region))
  
  
  (method (change-state s)
    (set! state s)
    (let ((compound (tag-find "Level" (tag-value tag))))
      (tag-add compound "State" TAG_Byte state)))
  
  
  (method (register-section y section)
    (refcount-increase)
    (unless sections-table
      (set! sections-table (make-table test: eq?)))
    (allege sections-table
      (table-set! sections-table y section)))
  
  
  (method (index-block-entities block-entities)
    (if (null? block-entities)
        #f
      (let ((table (make-table test: equal?)))
        (for-each (lambda (block-entity)
                    (let ((x (tag-assoc "x" block-entity))
                          (y (tag-assoc "y" block-entity))
                          (z (tag-assoc "z" block-entity)))
                      (let ((index (vector x y z)))
                        (table-set! table index block-entity))))
                  block-entities)
        table)))
  
  
  (method (find-block-entity index)
    (and block-entities-index (table-ref block-entities-index index #f)))
  
  
  (method (add-block-entity index <vector>)
    (let ((x (vector-ref index 0))
          (y (vector-ref index 1))
          (z (vector-ref index 2)))
      (let ((block-entity (list (make-tag "Items" TAG_List (make-list-payload TAG_Compound '()))
                                (make-tag "id" TAG_String "Chest")
                                (make-tag "x" TAG_Int x)
                                (make-tag "y" TAG_Int y)
                                (make-tag "z" TAG_Int z))))
        (when (not block-entities-index)
          ;; when empty it contains ("TileEntities" 9 0)
          (set-list-payload-type block-entities TAG_Compound)
          (set! block-entities-index (make-table test: equal?)))
        (allege block-entities-index
          (set-list-payload-content block-entities (cons block-entity (list-payload-content block-entities)))
          (table-set! block-entities-index index block-entity)
          block-entity))))
  
  
  (method (add-sign index <vector> data)
    (let ((block-entity (list (make-tag "id" TAG_String "Sign")
                              (make-tag "x" TAG_Int (vector-ref index 0))
                              (make-tag "y" TAG_Int (vector-ref index 1))
                              (make-tag "z" TAG_Int (vector-ref index 2))
                              (make-tag "Text1" TAG_String (list-ref data 0))
                              (make-tag "Text2" TAG_String (list-ref data 1))
                              (make-tag "Text3" TAG_String (list-ref data 2))
                              (make-tag "Text4" TAG_String (list-ref data 3)))))
      (when (not block-entities-index)
        (set-list-payload-type block-entities TAG_Compound)
        (set! block-entities-index (make-table test: equal?)))
      (allege block-entities-index
        (let ((old-sign (table-ref block-entities-index index #f)))
          (when old-sign
            (set-list-payload-content block-entities (remove! old-sign (list-payload-content block-entities) test: equal?))))
        (set-list-payload-content block-entities (cons block-entity (list-payload-content block-entities)))
        (table-set! block-entities-index index block-entity)
        (modified)
        (save-region~ region)
        block-entity)))
  
  
  (method (add-section sector-y) <World-Section>
    (let ((blocks (make-u8vector 4096))
          (data (make-u8vector 2048))
          (blocklight (make-u8vector 2048))
          (skylight (make-u8vector 2048 255))) ;; quicky
      (let ((section (new World-Section self blocks data blocklight skylight)))
        (register-section sector-y section)
        (modified)
        (let ((section-tag (list (make-tag "Blocks" TAG_Byte_Array blocks)
                                 (make-tag "Data" TAG_Byte_Array data)
                                 (make-tag "BlockLight" TAG_Byte_Array blocklight)
                                 (make-tag "SkyLight" TAG_Byte_Array skylight)
                                 (make-tag "Y" TAG_Byte sector-y))))
          (set-list-payload-content sections (cons section-tag (list-payload-content sections))))
        section)))
  
  
  (method (get-section section-y <fx>) <World-Section>
    (assert (< section-y 16))
    (or (and sections-table (table-ref sections-table section-y #f))
        (let ((section (add-section section-y)))
          (let ((sector (index-sector~ (current-zone) (vector x section-y z))))
            (set-sector~ section sector)
            (set-section~ sector section))
          section)))
  
  
  (method (get-biome x <fx> z <fx>) <Biome>
    (define (heightmap-index x <fx> z <fx>) <fx>
      (+ x (* z 16)))
    
    (id->biome (u8vector-ref biomes (+ x (* z 16)))))
  
  
  (method (regenerate)
    (set! sections-table #f)
    (generate (lambda ()
                )))
  
  
  (method (generate register-chunk)
    (cond-expand
      (release
       (declare (proper-tail-calls))
       (declare (optimize-dead-local-variables))
       (declare (inline))
       (declare (inlining-limit 1000)))
      (else))
    (let ((zone (current-zone)))
      (let ((sections (make-vector 16 #f)))
        (define (cache-section j <fx>) <World-Section>
          (let ((y (fxfloor/ j 16)))
            (or (vector-ref sections y)
                (let ((section (get-section y)))
                  (vector-set! sections y section)
                  section))))
        
        (define (local-index i <fx> j <fx> k <fx>) <fx>
          (+ (* j 256) (* k 16) i))
        
        (define (block-ref i <fx> j <fx> k <fx>) <fx>
          (u8vector-ref (get-blocks~ (cache-section j)) (local-index i (modulo j 16) k)))
        
        (define (block-set! i <fx> j <fx> k <fx> block-id <fx>)
          (u8vector-set! (get-blocks~ (cache-section j)) (local-index i (modulo j 16) k) block-id))
        
        (define (data-set! i <fx> j <fx> k <fx> data-id <fx>)
          (u4vector-set! (get-data~ (cache-section j)) (local-index i (modulo j 16) k) data-id))
        
        (define (u4vector-set! field <u8vector> index <fx> value <fx>)
          (let ((offset (quotient index 2)))
            (let ((byte (u8vector-ref field offset)))
              (u8vector-set! field offset
                (if (even? index)
                    (bitwise-ior value (bitwise-and byte #xF0))
                  (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4)))))))
        
        (define (blockstate-set! i <fx> j <fx> k <fx> id <fx>)
          (bind-values (block-id <fx> data-id <fx>) (decode-fxid/variant-id id)
            (block-set! i j k block-id)
            (when (> data-id 0)
              (data-set! i j k data-id))))
        
        (if (welcome?~ zone)
            (register-chunk)
          (let ((generator (get-generator~ zone)))
            (generate-chunk~ generator self block-ref block-set! data-set! blockstate-set! register-chunk)))
        (generate-complete)
        (modified))))
  
  
  (definition rand-seed
    23)
  
  (definition rand
    (newRandom rand-seed))
  
  
  (method (generate-complete)
    (let ((zone (current-zone)))
      (set! generator-revision (get-revision~ (get-generator~ zone)))
      (set! generated? #t)))
  
  
  (definition sea-level <fx>
    63)
  
  
  (method (generate-blocks block-ref block-set! data-set! heightmap <f64vector>)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (site (blocks on?: #t parent: generate)
    (let ((heightmap-check (make-vector 256 #t))
          (zone (current-zone)))
      (define (heightmap-index x <fx> z <fx>) <fx>
        (+ x (* z 16)))
      
      (loop (for i from 0 below 4)
            (let ((j (* i 5))
                  (k (* (+ i 1) 5)))
              (loop (for l from 0 below 4)
                    (let ((i1 (* (+ j l) 33))
                          (j1 (* (+ j l 1) 33))
                          (k1 (* (+ k l) 33))
                          (l1 (* (+ k l 1) 33)))
                      (loop (for i2 from 0 below 32)
                            (let ((d1 (f64& (f64vector-ref heightmap (+ i1 i2))))
                                  (d2 (f64& (f64vector-ref heightmap (+ j1 i2))))
                                  (d3 (f64& (f64vector-ref heightmap (+ k1 i2))))
                                  (d4 (f64& (f64vector-ref heightmap (+ l1 i2)))))
                              (let ((d5 (f64& (/ (- (f64vector-ref heightmap (+ i1 i2 1)) (f64-ref d1)) 8.)))
                                    (d6 (f64& (/ (- (f64vector-ref heightmap (+ j1 i2 1)) (f64-ref d2)) 8.)))
                                    (d7 (f64& (/ (- (f64vector-ref heightmap (+ k1 i2 1)) (f64-ref d3)) 8.)))
                                    (d8 (f64& (/ (- (f64vector-ref heightmap (+ l1 i2 1)) (f64-ref d4)) 8.))))
                                (loop (for j2 from 0 below 8)
                                      (let ((d9 (f64& (f64-ref d1)))
                                            (d10 (f64& (f64-ref d2)))
                                            (y (+ j2 (* i2 8))))
                                        (let ((d11 (f64& (/ (- (f64-ref d3) (f64-ref d1)) 4.)))
                                              (d12 (f64& (/ (- (f64-ref d4) (f64-ref d2)) 4.))))
                                          (loop (for k2 from 0 below 4)
                                                (let ((d13 (f64& (/ (- (f64-ref d10) (f64-ref d9)) 4.)))
                                                      (x (+ k2 (* i 4))))
                                                  (let ((lvt-45-1 (f64& (f64-ref d9))))
                                                    (loop (for l2 from 0 below 4)
                                                          (let ((z (+ l2 (* l 4))))
                                                            (let ((index (heightmap-index x z)))
                                                              (if (> (f64-ref lvt-45-1) 0.)
                                                                  (begin
                                                                    (block-set! x y z 1)
                                                                    (unless (vector-ref heightmap-check index)
                                                                      (vector-set! heightmap-check index #t)))
                                                                (when (vector-ref heightmap-check index)
                                                                  (vector-set! heightmap-check index #f)
                                                                  (vector-set! heightmap~self index y))
                                                                (when (< y sea-level)
                                                                  (block-set! x y z 9)))))
                                                          (f64-set! lvt-45-1 (+ (f64-ref lvt-45-1) (f64-ref d13))))
                                                    (f64-set! d9 (+ (f64-ref d9) (f64-ref d11)))
                                                    (f64-set! d10 (+ (f64-ref d10) (f64-ref d12))))))
                                          (f64-set! d1 (+ (f64-ref d1) (f64-ref d5)))
                                          (f64-set! d2 (+ (f64-ref d2) (f64-ref d6)))
                                          (f64-set! d3 (+ (f64-ref d3) (f64-ref d7)))
                                          (f64-set! d4 (+ (f64-ref d4) (f64-ref d8))))))))))))))))


  (method (replace-biome-blocks block-ref block-set! blockstate-set!)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (site (replace on?: #t parent: generate)
      (loop (for x from 0 below 16)
            (loop (for z from 0 below 16)
                  (let ((biome <Biome> (id->biome (u8vector-ref biomes (+ x (* z 16))))))
                    (replace-blocks~ biome x z rand block-ref block-set! blockstate-set!))))))
  
  
  (method (generate-caves block-ref block-set! data-set!)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (site (caves on?: #t parent: generate)
    (let ((range 8)
          (br block-ref)
          (bs block-set!)
          (ds data-set!)
          (Air 0)
          (Water 8)
          (StationaryWater 9))
      (define (add-room seed chunkX chunkZ rx ry rz)
        (add-tunnel seed chunkX chunkZ rx ry rz (+ 1.0 (* (randomFloat rand) 6.0)) 0.0 0.0 -1 -1 0.5))
      
      (define (add-tunnel seed chunkX <fx> chunkZ <fx> rx <fl> ry <fl> rz <fl> p_180702_12_ <fl> p_180702_13_ <fl> p_180702_14_ <fl> p_180702_15_ <fx> p_180702_16_ <fx> p_180702_17_ <fl>)
        (continuation-capture
          (lambda (return)
            (let ((rx (f64& rx))
                  (ry (f64& ry))
                  (rz (f64& rz))
                  (d0 (+ (* (cast <fl> chunkX) 16.) 8.))
                  (d1 (+ (* (cast <fl> chunkZ) 16.) 8.))
                  (f0 (f64& 0.))
                  (f1 (f64& 0.)))
              (let ((random (newRandom seed)))
                (when (<= p_180702_16_ 0)
                  (let ((i (- (* range 16) 16)))
                    (set! p_180702_16_ (- i (randomInt random (/ i 4))))))
                (let ((flag2 #f))
                  (when (= p_180702_15_ -1)
                    (set! p_180702_15_ (fxfloor/ p_180702_16_ 2))
                    (set! flag2 #t))
                  (let ((j (+ (randomInt random (fxfloor/ p_180702_16_ 2)) (fxfloor/ p_180702_16_ 4)))
                        (flag (= (randomInt random 6) 0)))
                    (continuation-capture
                      (lambda (continue)
                        (loop (for p_180702_15_ from p_180702_15_ below p_180702_16_)
                              (let ((d2 (f64& (+ 1.5 (* (sin
                                                          (/ (* (cast <fl> p_180702_15_) PI)
                                                             (cast <fl> p_180702_16_)))
                                                        p_180702_12_)))))
                                (let ((d3 (f64& (* (f64-ref d2) p_180702_17_)))
                                      (f2 (f64& (cos p_180702_14_)))
                                      (f3 (f64& (sin p_180702_14_))))
                                  (f64-set! rx (+ (f64-ref rx) (* (cos p_180702_13_) (f64-ref f2))))
                                  (f64-set! ry (+ (f64-ref ry) (f64-ref f3)))
                                  (f64-set! rz (+ (f64-ref rz) (* (sin p_180702_13_) (f64-ref f2))))
                                  (if flag
                                      (set! p_180702_14_ (* p_180702_14_ .92))
                                    (set! p_180702_14_ (* p_180702_14_ .7)))
                                  (set! p_180702_14_ (+ p_180702_14_ (* (f64-ref f1) .1)))
                                  (increase! p_180702_13_ (* (f64-ref f0) .1))
                                  (f64-set! f1 (* (f64-ref f1) .9))
                                  (f64-set! f0 (* (f64-ref f0) .75))
                                  (f64-set! f1 (+ (f64-ref f1) (* (- (randomFloat random) (randomFloat random)) (randomFloat random) 2.)))
                                  (f64-set! f0 (+ (f64-ref f0) (* (- (randomFloat random) (randomFloat random)) (randomFloat random) 4.)))
                                  (when (and (not flag2)
                                             (= p_180702_15_ j)
                                             (> p_180702_12_ 1.)
                                             (> p_180702_16_ 0))
                                    (add-tunnel (randomLong random) chunkX chunkZ (f64-ref rx) (f64-ref ry) (f64-ref rz) (+ (* (randomFloat random) .5) .5) (- p_180702_13_ (/ PI 2.)) (/ p_180702_14_ 3.) p_180702_15_ p_180702_16_ 1.)
                                    (add-tunnel (randomLong random) chunkX chunkZ (f64-ref rx) (f64-ref ry) (f64-ref rz) (+ (* (randomFloat random) .5) .5) (+ p_180702_13_ (/ PI 2.)) (/ p_180702_14_ 3.) p_180702_15_ p_180702_16_ 1.)
                                    (continuation-return return #f))
                                  (when (or flag2 (/= (randomInt random 4) 0))
                                    (let ((d4 (- (f64-ref rx) d0))
                                          (d5 (- (f64-ref rz) d1))
                                          (d6 (- (cast <fl> p_180702_16_) (cast <fl> p_180702_15_)))
                                          (d7 (+ p_180702_12_ 2. 16.)))
                                      (when (> (- (+ (* d4 d4) (* d5 d5))
                                                  (* d6 d6))
                                               (* d7 d7))
                                        (continuation-return return #f))
                                      (when (and (>= (f64-ref rx) (- (- d0 16.) (* (f64-ref d2) 2.)))
                                                 (>= (f64-ref rz) (- (- d1 16.) (* (f64-ref d2) 2.)))
                                                 (<= (f64-ref rx) (+ d0 16. (* (f64-ref d2) 2.)))
                                                 (<= (f64-ref rz) (+ d1 16. (* (f64-ref d2) 2.))))
                                        (let ((k2 (- (- (fxfloor (- (f64-ref rx) (f64-ref d2))) (* chunkX 16)) 1))
                                              (k (+ (- (fxfloor (+ (f64-ref rx) (f64-ref d2))) (* chunkX 16)) 1))
                                              (l2 (- (fxfloor (- (f64-ref ry) (f64-ref d3))) 1))
                                              (l (+ (fxfloor (+ (f64-ref ry) (f64-ref d3))) 1))
                                              (i3 (- (- (fxfloor (- (f64-ref rz) (f64-ref d2))) (* chunkZ 16)) 1))
                                              (i1 (+ (- (fxfloor (+ (f64-ref rz) (f64-ref d2))) (* chunkZ 16)) 1)))
                                          (let ((k2 (if (< k2 0) 0 k2))
                                                (k (if (> k 16) 16 k))
                                                (l2 (if (< l2 1) 1 l2))
                                                (l (if (> l 248) 248 l))
                                                (i3 (if (< i3 0) 0 i3))
                                                (i1 (if (> i1 16) 16 i1))
                                                (flag3 #f))
                                            (loop (for j1 <fx> init k2 test (and (not flag3) (< j1 k)) iter (+ j1 1))
                                                  (loop (for k1 <fx> init i3 test (and (not flag3) (< k1 i1)) iter (+ k1 1))
                                                        (let (iter (l1 <fx> (+ l 1)))
                                                          (when (and (not flag3) (>= l1 (- l2 1)))
                                                            (if (and (>= l1 0) (< l1 256))
                                                                (let ((block <fx> (block-ref j1 l1 k1)))
                                                                  (when (or (= block Water)
                                                                            (= block StationaryWater))
                                                                    (set! flag3 #t))
                                                                  (if (and (/= l1 (- l2 1))
                                                                           (/= j1 k2)
                                                                           (/= j1 (- k 1))
                                                                           (/= k1 i3)
                                                                           (/= k1 (- i1 1)))
                                                                      (iter (- l2 1))
                                                                    (iter (- l1 1))))
                                                              (iter (- l1 1)))))))
                                            (unless flag3
                                              (loop (for j3 <fx> init k2 test (< j3 k) iter (+ j3 1))
                                                    (let ((d10 (/ (- (+ (cast <fl> j3) (* (cast <fl> chunkX) 16.) .5) (f64-ref rx)) (f64-ref d2))))
                                                      (loop (for i2 <fx> init i3 test (< i2 i1) iter (+ i2 1))
                                                            (let ((d8 (/ (- (+ (cast <fl> i2) (* (cast <fl> chunkZ) 16.) .5) (f64-ref rz)) (f64-ref d2))))
                                                              (when (< (+ (* d10 d10) (* d8 d8)) 1.)
                                                                (loop (for j2 <fx> init l test (> j2 l2) iter (- j2 1))
                                                                      (let ((d9 (f64& (/ (- (+ (- (cast <fl> j2) 1.) .5) (f64-ref ry)) (f64-ref d3)))))
                                                                        (when (and (> (f64-ref d9) -.7)
                                                                                   (< (+ (* d10 d10) (* (f64-ref d9) (f64-ref d9)) (* d8 d8)) 1.))
                                                                          (block-set! j3 j2 i2 Air)))))))))
                                              (when flag2
                                                (continuation-return continue #f))))))))))))))))))))
      
      (define (recursive-generate p <fx> q <fx> chunkX <fx> chunkZ <fx>)
        (let ((i (randomInt rand (+ (randomInt rand (+ (randomInt rand 15) 1)) 1))))
          (when (/= (randomInt rand 7) 0)
            (set! i 0))
          (loop (for j from 0 below i)
                (let ((rx (cast <fl> (+ (* p 16) (randomInt rand 16))))
                      (ry (cast <fl> (randomInt rand (+ (randomInt rand 120) 8))))
                      (rz (cast <fl> (+ (* q 16) (randomInt rand 16))))
                      (k 1))
                  (when (= (randomInt rand 4) 0)
                    (add-room (randomLong rand) chunkX chunkZ rx ry rz)
                    (increase! k (randomInt rand 4)))
                  (loop (for l from 0 below k)
                        (let ((f0 (* (randomFloat rand) (* PI 2.)))
                              (f1 (/ (* (- (randomFloat rand) .5) 2.) 8.))
                              (f2 (+ (* (randomFloat rand) 2.) (randomFloat rand))))
                          (when (= (randomInt rand 10) 0)
                            (multiply! f2 (+ (* (randomFloat rand) (randomFloat rand) 3.) 1.)))
                          (add-tunnel (randomLong rand) chunkX chunkZ rx ry rz f2 f0 f1 0 0 1.)))))))
      
      (let ((i range)
            (worldSeed (worldSeed)))
        (setSeed rand worldSeed)
        (let ((j (randomLong rand))
              (k (randomLong rand)))
          (loop (for p <fx> init (- x i) test (<= p (+ x i)) iter (+ p 1))
                (loop (for q <fx> init (- z i) test (<= q (+ z i)) iter (+ q 1))
                      (setSeedAux rand p q j k worldSeed)
                      (recursive-generate p q x z))))))))
  
  
  (method (populate-chunks)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (site (populate on?: #t parent: generate)
    (let ((zone (current-zone)))
      (let ((region-x (get-x~ region))
            (region-z (get-z~ region)))
        (define (loaded-chunk chunk-x <fx> chunk-z <fx>) <World-Chunk+>
          (let ((region (get-loaded-region~ zone (+ region-x (fxfloor/ chunk-x 32)) (+ region-z (fxfloor/ chunk-z 32)))))
            (and region (get-loaded-chunk~ region (modulo chunk-x 32) (modulo chunk-z 32)))))
        
        (define (local-index i <fx> j <fx> k <fx>) <fx>
          (+ (* j 256) (* k 16) i))
        
        (define (block-ref section <World-Section> i <fx> j <fx> k <fx>) <fx>
          (u8vector-ref (get-blocks~ section) (local-index i (modulo j 16) k)))
        
        (define (block-set! section <World-Section> i <fx> j <fx> k <fx> block-id <fx>)
          (u8vector-set! (get-blocks~ section) (local-index i (modulo j 16) k) block-id))
        
        (define (data-set! section <World-Section> i <fx> j <fx> k <fx> data-id <fx>)
          (u4vector-set! (get-data~ section) (local-index i (modulo j 16) k) data-id))
        
        (define (u4vector-set! field <u8vector> index <fx> value <fx>)
          (let ((offset (quotient index 2)))
            (let ((byte (u8vector-ref field offset)))
              (u8vector-set! field offset
                (if (even? index)
                    (bitwise-ior value (bitwise-and byte #xF0))
                  (bitwise-ior (bitwise-and byte #x0F) (arithmetic-shift value 4)))))))
        
        (define (blockstate-set! section <World-Section> i <fx> j <fx> k <fx> id <fx>)
          (bind-values (block-id <fx> data-id <fx>) (decode-fxid/variant-id id)
            (block-set! section i j k block-id)
            (when (>= data-id 0)
              (data-set! section i j k data-id))))
        
        (let ((back (loaded-chunk x (- z 1)))
              (right (loaded-chunk (+ x 1) z))
              (front (loaded-chunk x (+ z 1)))
              (left (loaded-chunk (- x 1) z)))
          (when (and right front)
            (let ((corner (loaded-chunk (+ x 1) (+ z 1))))
              (when corner
                (populate-chunk block-ref block-set! blockstate-set! front corner right))))
          (when (and left front)
            (let ((corner (loaded-chunk (- x 1) (+ z 1))))
              (when corner
                (populate-chunk~ left block-ref block-set! blockstate-set! corner front self))))
          (when (and back right)
            (let ((corner (loaded-chunk (+ x 1) (- z 1))))
              (when corner
                (populate-chunk~ back block-ref block-set! blockstate-set! self right corner))))
          (when (and back left)
            (let ((corner (loaded-chunk (- x 1) (- z 1))))
              (when corner
                (populate-chunk~ corner block-ref block-set! blockstate-set! left self back)))))))))
  
  
  (method (populate-chunk block-ref block-set! blockstate-set! front corner right)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (unless populated?
      (let ()
        (define (neighbor-chunk x <fx> z <fx>) <World-Chunk>
          (if (< x 16)
              (if (< z 16)
                  self
                front)
            (if (< z 16)
                right
              corner)))
        
        (define (get-height x <fx> z <fx>) <fx>
          (vector-ref (get-heightmap~ (neighbor-chunk x z)) (heightmap-index (modulo x 16) (modulo z 16))))
        
        (define (get-biome x <fx> z <fx>) <Biome>
          (id->biome (u8vector-ref (get-biomes~ (neighbor-chunk x z)) (heightmap-index (modulo x 16) (modulo z 16)))))
        
        (define (with-position x <fx> z <fx> proc)
          (let ((chunk (neighbor-chunk x z))
                (index (heightmap-index (modulo x 16) (modulo z 16))))
            (proc (vector-ref (get-heightmap~ chunk) index) (id->biome (u8vector-ref (get-biomes~ chunk) index)))))
        
        (define (heightmap-index x <fx> z <fx>) <fx>
          (+ x (* z 16)))
        
        (define (chunk-block-ref x <fx> y <fx> z <fx>) <fx>
          (block-ref (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16)))
        
        (define (chunk-block-set! x <fx> y <fx> z <fx> block-id <fx>)
          (block-set! (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16) block-id))
        
        (define (chunk-blockstate-set! x <fx> y <fx> z <fx> id <fx>)
          (blockstate-set! (get-section~ (neighbor-chunk x z) (fxfloor/ y 16)) (modulo x 16) (modulo y 16) (modulo z 16) id))
        
        (let ((biome (get-biome 16 16)))
          (decorate-biome~ biome rand chunk-block-ref chunk-block-set! chunk-blockstate-set! get-height)
          (set! populated? #t)))))
  
  
  (method protected (reset-modified)
    (set! modified? #f))
  
  
  (method protected (modified)
    (set! modified? #t)
    (modified~ region)))


;;;
;;;; Data
;;;


(class World-Data extends Object
  
  
  (slot blocks      getter generate)
  (slot data        getter generate)
  (slot blocklight  getter generate)
  (slot skylight    getter generate)
  
  
  (method override (initialize blocks data blocklight skylight)
    (set! blocks~self blocks)
    (set! data~self data)
    (set! blocklight~self blocklight)
    (set! skylight~self skylight))))
