;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.math)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.audio)
        (world.configure)
        (world.context)
        (world.event)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.udp)
        (world.video))


(definition record-output?
  (world-setting 'world.record-output? #f))

(definition recordings
  (make-table))


(definition udp-video-action
  (world-setting 'world.udp-video-action #f))

(definition udp-video-file
  {File Settings "captures" "video.mpj"})

(definition udp-video-port
  #f)


(definition (find-id-quick-hack no)
  (let ((member (find-group-member-by-no (current-client) no)))
    ;; quick solution for when logging in and starting receiving
    ;; someone's media before the client is actually registered
    ;; need to revisit this code for a cleaner solution
    (and member
         (second member))))


(definition (state-callback origin media-kind)
  (lambda (state)
    (when (= media-kind udp-video)
      (unless (or (simulation?) (visualization?))
        (let ((id (find-id-quick-hack origin)))
          (when id
            (let ((output (find-output (current-video) id)))
              (when output
                (let ((mode (case state
                              ((ok) 'draw)
                              ((late) 'freeze)
                              ((waiting) 'wait))))
                  (change-draw-mode output mode))))))))))


(class UDP-Client extends Object
  
  
  (slot client-no             initialize #f getter generate)
  (slot udp-port              initialize #f getter generate)
  (slot udp-stopping?         initialize #f getter generate)
  (slot local-host            initialize #f getter generate)
  (slot local-port            initialize #f getter generate)
  (slot server-host           initialize #f getter generate)
  (slot server-port           initialize #f getter generate)
  (slot write-mutex           initialize #f getter generate)
  (slot send-channels         initialize #f getter generate)
  (slot receive-channels      initialize #f getter generate)
  (slot receive-task          initialize #f getter generate)
  (slot state-task            initialize #f getter generate)
  (slot started?              initialize #f getter generate)
  (slot packets-sent          initialize 0  getter generate)
  (slot packets-received      initialize 0  getter generate)
  (slot last-packets-sent     initialize 0  getter generate)
  (slot last-packets-received initialize 0  getter generate)
  (slot last-server-sent      initialize 0  getter generate)
  (slot last-server-received  initialize 0  getter generate)
  (slot last-traffic-count    initialize 0  getter generate)
  (slot last-traffic-time     initialize #f getter generate)
  (slot outgoing-drop         initialize 0  getter generate)
  (slot incoming-drop         initialize 0  getter generate)
  (slot last-received-ack     initialize #f getter generate)
  (slot throttle-media?       initialize #f getter generate)
  (slot camera-resetting      initialize #f getter generate)
  (slot topology              initialize #f getter generate)
  (slot peers                 initialize #f getter generate)
  (slot peers-mutex           initialize #f getter generate)
  (slot simulator             initialize #f getter generate)
  
  
  (method override (initialize self client-no)
    (nextmethod self)
    (set! self.client-no client-no))
  
  
  (method package (connect self local-host host service)
    ;; quick heuristic
    (define (determine-local-address)
      (if local?
          #u8(127 0 0 1)
        (let ((info (host-info (host-name))))
          (let ((addresses (host-info-addresses info)))
            (if (= 1 (length addresses))
                (car addresses)
              #u8(0 0 0 0))))))
    
    (if (simulation?)
        (begin
          (set! write-mutex (make-mutex 'write))
          (set! send-channels (make-table))
          (set! receive-channels (make-table)))
    (set! udp-port (open-udp (list
                               local-address: local-host
                               address: host
                               port-number: service)))
    (set! udp-stopping? #f)
    (let ((local-host (determine-local-address))
          (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (mutex-lock! write-mutex)
        (let ((data (make-u8vector (+ 8 4 4 4 4 4 4 4))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-connect)
          (write-udp-origin data client-no)
          (write-udp-connect-local-host data local-host)
          (write-udp-connect-local-port data local-port)
          (write-udp-connect-latency data (or udp-latency -1.))
          (write-udp-connect-lag data (or udp-lag -1.))
          (write-udp-connect-drop data (or udp-drop -1.))
          (retrying-write data udp-port))
        (mutex-unlock! write-mutex))
      
      (set! self.local-host local-host)
      (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! write-mutex (make-mutex 'write))
      (set! send-channels (make-table))
      (set! receive-channels (make-table))
      (set! packets-sent 0)
      (set! packets-received 0)
      (set! outgoing-drop 0)
      (set! incoming-drop 0)
      (set! camera-resetting #f)
      (set! topology (world-setting 'world.udp-topology 'server))
      (set! peers (make-table))
      (set! peers-mutex (make-mutex 'peers))
      (set! simulator (if (or udp-latency udp-lag udp-drop udp-congestion)
                          (new UDP-Simulator udp-latency udp-lag udp-drop
                               (lambda (data drop?)
                                 (if drop?
                                     (increase! packets-sent)
                                   @fix-me-can-deadlock-the-threads
                                   (mutex-lock! write-mutex)
                                   (send-topology self data)
                                   @fix-me-can-deadlock-the-threads
                                   (mutex-unlock! write-mutex))))
                        #f))
      (record-event udp-id-connect
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.)
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (if (or (eof-object? reply) (not (= (read-udp-kind reply) udp-connected)))
                (if (>= n 100)
                    (begin
                      (terminal 'BAILOUT 'did 'not 'receive 'udp-connected)
                      (exit 1))
                  (loop (+ n 1)))
              (let ((source-info (udp-source-socket-info udp-port)))
                (set! server-host (socket-info-address source-info))
                (set! server-port (socket-info-port-number source-info)))
              (let ((round-trip (- (current-seconds) (read-udp-sent reply))))
                (record-event udp-id-connected
                              -1.
                              -1.
                              -1.
                              -1.
                              round-trip
                              -1.)
                (when udp-show-roundtrip?
                  (format :terminal "{s} {s} {s}{%}" remote-name '***roundtrip*** round-trip))))))))))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (unless (simulation?)
        (set! receive-task (new Task 'udp-receive (lambda (task)
                                                    (receive-loop self task))
                                priority: udp-priority))
        (start-task receive-task)
        (set! state-task (new Task 'udp-state (lambda (task)
                                                (state-loop self task))
                              priority: udp-priority))
        (start-task state-task))
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (exit-thread (get-thread receive-task))
      (thread-join! (get-thread receive-task))
      (set! receive-task #f)
      (thread-send (get-thread state-task) #t)
      (thread-join! (get-thread state-task))
      (set! state-task #f)
      (set! started? #f)))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (/= origin client-no)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method public (find-send-channel self media-kind)
    (let ((key media-kind))
      (table-ref send-channels key #f)))
  
  
  (method package (require-send-channel self media-kind)
    (let ((key media-kind))
      (or (table-ref send-channels key #f)
          (let ((channel (new UDP-Send-Channel client-no media-kind)))
            (table-set! send-channels key channel)
            channel))))
  
  
  (method package (close-send-channel self media-kind)
    (let ((key media-kind))
      (let ((channel (table-ref send-channels key #f)))
        (close channel)
        (table-clear send-channels key))))
  
  
  (method package (close-send-channels self)
    (iterate-table-safe send-channels
      (lambda (media-kind channel)
        (close-send-channel self media-kind))))
  
  
  (method public (find-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (table-ref receive-channels key #f)))
  
  
  (method package (require-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref receive-channels key #f)
          (let ((channel (new UDP-Receive-Channel origin media-kind)))
            (table-set! receive-channels key channel)
            channel))))
  
  
  (method package (close-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (let ((channel (table-ref receive-channels key #f)))
        (close channel)
        (table-clear receive-channels key))))
  
  
  (method package (close-receive-channels self)
    (iterate-table-safe receive-channels
      (lambda (key channel)
        (bind (origin . media-kind) key
          (close-receive-channel self origin media-kind)))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method (send-audio self buffer header? timestamp duration)
    (send-media self udp-audio buffer header? timestamp duration))
  
  
  (method (send-video self buffer header? timestamp duration)
    (send-media self udp-video buffer header? timestamp duration))
  
  
  (method package (send-media self kind buffer header? timestamp duration)
    (mutex-lock! write-mutex)
    (let ((channel (find-send-channel self kind)))
      (when channel
        (let ()
          (define (send)
            (when udp-video-action
              (let ((key kind))
                (cond ((and buffer (not (table-ref send-channels key #f)))
                       (set! udp-video-port (case udp-video-action
                                              ((record)
                                               (create-directories udp-video-file)
                                               (open-output-file (path-settings udp-video-file)))
                                              ((play)
                                               (open-input-file (path-settings udp-video-file))))))
                      ((and (not buffer) (table-ref send-channels key #f))
                       (when udp-video-port
                         (close-port udp-video-port)
                         (set! udp-video-port #f))))))
            (let ((off? (not buffer))
                  (frame (next-frame-sequence! channel))
                  ;; give media off and resent header a sequential timestamp so it gets inserted correctly
                  (timestamp (or timestamp (+ (or (get-last-timestamp channel) 0) 1)))
                  (duration (or duration 1))
                  ;; udp-media-off is not really used for its content anymore
                  ;; but it is still useful as an empty buffer ends the logic
                  (buffer (or buffer udp-media-off)))
              ;; -1 means no timestamp used by vorbis header
              (unless (= timestamp -1)
                (set-last-timestamp channel timestamp))
              (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4))
                    (payload-size (u8vector-length buffer)))
                (let ((max-content-size (- udp-datagram-max header-size)))
                  (let ((total (fxceiling/ payload-size max-content-size)))
                    (let (loop-part (part 0) (pos 0))
                      (let ((remain (- payload-size pos)))
                        (when (> remain 0)
                          (let ((sequence (next-data-sequence! channel))
                                (content-size (min remain max-content-size)))
                            (let ((size (+ header-size content-size)))
                              (let ((data (make-u8vector size)))
                                (write-udp-sent data (current-seconds))
                                (write-udp-kind data kind)
                                (write-udp-origin data client-no)
                                (write-udp-sequence data sequence)
                                (write-udp-frame data frame)
                                (write-udp-part data part)
                                (write-udp-total data total)
                                (write-udp-media-timestamp data timestamp)
                                (write-udp-media-duration data duration)
                                (write-udp-media-subpayload data buffer pos content-size)
                                (write-udp-media-header? data header?)
                                (write-udp-media-off? data off?)
                                (when udp-video-port
                                  (case udp-video-action
                                    ((record)
                                     (write data udp-video-port)
                                     (newline udp-video-port)
                                     (force-output udp-video-port))
                                    ((play)
                                     (let ((obj (read udp-video-port)))
                                       (unless (eof-object? obj)
                                         (set! data obj))))))
                                ;; quick hack to make media off more robust
                                (if off?
                                    (loop (repeat 3)
                                          (send-data self data))
                                  (send-data self data))
                                (record-event udp-id-create-packet
                                              (fixnum->flonum client-no)
                                              (fixnum->flonum kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              (barbara-header-hack header?)
                                              (if (= timestamp -1)
                                                  -1.
                                                (timestamp->flonum timestamp)))
                                (record-event udp-id-create-info
                                              (fixnum->flonum client-no)
                                              (fixnum->flonum kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              (fixnum->flonum part)
                                              (fixnum->flonum total))
                                @wait
                                (let ((ring (if (= kind udp-audio) audio-ring video-ring)))
                                  (give ring data))
                                (retain-media channel data)
                                (loop-part (+ part 1) (+ pos content-size)))))))))))))
          
          (when last-received-ack
            (if throttle-media?
                ;; advance frame
                (let ((frame (next-frame-sequence! channel)))
                  (record-event udp-id-throttle-frame
                                (fixnum->flonum client-no)
                                (fixnum->flonum kind)
                                -1.
                                (fixnum->flonum frame)
                                -1.
                                -1.))
              (let ((now (current-seconds)))
                (if (and udp-throttle (> (- now last-received-ack) udp-throttle))
                    (begin
                      (set! throttle-media? #t)
                      (record-event udp-id-throttle-on
                                    (fixnum->flonum server-no)
                                    -1.
                                    -1.
                                    -1.
                                    -1.
                                    -1.)
                      (when udp-show-throttle?
                        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind kind) 'THROTTLE 'ON)))
                  (send))))))))
    (mutex-unlock! write-mutex))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       (udp-destination-set! server-host server-port udp-port)
       (retrying-write data udp-port)
       (increase! packets-sent))
      ((peer)
       (iterate-table peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (retrying-write data udp-port)))))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (state-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((end? (thread-receive udp-state-period #f)))
            (if end?
                (continuation-return exit #f)
              (site (udp-state on?: #t)
                (send-state self))
              (loop)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (when udp-record-read/write?
                  (let ((origin (read-udp-origin data))
                        (media-kind (read-udp-kind data))
                        (sequence (read-udp-sequence data))
                        (frame (read-udp-frame data)))
                    (record-event udp-id-read-data
                                  (fixnum->flonum origin)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum frame)
                                  -1.
                                  (fixnum->flonum (u8vector-length data)))))
                (receive-data self data))
              (loop)))))))
  
  
  (method (receive-data self data)
    (increase! packets-received)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-connected))
        ((udp-state)
         (receive-state self data))
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-state self data)
    (let ((states (u8vector->object (read-udp-state-channels data))))
      (for-each (lambda (info)
                  (bind (channel-origin media-kind client-state client-last-header) info
                    (when (= channel-origin client-no)
                      (when (eq? client-state 'waiting)
                        (maybe-reset-media self channel-origin media-kind (or client-last-header -1))))))
                states)))
  
  
  (method (maybe-reset-media self reset-origin media-kind last-header)
    (let ((channel (find-send-channel self media-kind)))
      (define (locate-later-header header)
        (locate-latest (get-retain-ring channel)
          (lambda (packet)
            (let ((data (get-data packet)))
              (and data
                   (media-packet-header? data)
                   (> (read-udp-frame data) header))))))
      
      (when channel
        (ecase media-kind
          ((udp-audio)
           ;; resend headers
           (let ((audio (current-audio)))
             (when (audio-playing? audio)
               (when (eq? audio-codec 'vorbis)
                 (let ((header (and last-header (locate-later-header last-header))))
                   (if header
                       (when udp-show-resetting?
                         (format :terminal "{s} {s} {s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESEND 'AVOIDED last-header (get-frame header)))
                     (resend-mic-header audio)
                     (record-event udp-id-reset-media
                                   (fixnum->flonum reset-origin)
                                   (fixnum->flonum media-kind)
                                   -1.
                                   -1.
                                   -1.
                                   -1.)
                     (when udp-show-resets?
                       (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESEND 'HEADERS))))))))
          ((udp-video)
           ;; camera reset
           (let ((video (current-video)))
             (when (video-playing? video)
               (if (and camera-resetting
                        (= camera-resetting (get-data-sequence channel)))
                   (when udp-show-resetting?
                     (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESET 'IN-PROGRESS last-header))
                 (let ((header (and last-header (locate-later-header last-header))))
                   (if header
                       (when udp-show-resetting?
                         (format :terminal "{s} {s} {s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESET 'AVOIDED last-header (get-frame header)))
                     (reset-camera video)
                     (let ((sequence (get-data-sequence channel)))
                       (set! camera-resetting sequence)
                       (record-event udp-id-reset-media
                                     (fixnum->flonum reset-origin)
                                     (fixnum->flonum media-kind)
                                     -1.
                                     -1.
                                     -1.
                                     -1.)
                       (when udp-show-resets?
                         (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESET last-header sequence)))))))))))))
  
  
  (method (receive-ack self data)
    (let ((now (current-seconds)))
      ;; throttling
      (set! last-received-ack now)
      (when throttle-media?
        (set! throttle-media? #f)
        ;; force camera reset
        (maybe-reset-media self server-no udp-video #f)
        (record-event udp-id-throttle-off
                      (fixnum->flonum server-no)
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.)
        (when udp-show-throttle?
          (format :terminal "{s} {s} {s}{%}" remote-name 'THROTTLE 'OFF)))
      ;; statistics
      (let ((round-trip (- now (read-udp-sent data)))
            (server-sent (read-udp-ack-packets-sent data))
            (server-received (read-udp-ack-packets-received data)))
        (let ((fresh-packets-sent (- packets-sent last-packets-sent))
              (fresh-packets-received (- packets-received last-packets-received))
              (fresh-server-sent (- server-sent last-server-sent))
              (fresh-server-received (- server-received last-server-received)))
          (define (fresh-traffic-rate)
            (if (not last-traffic-time)
                (begin
                  (set! last-traffic-time now)
                  -1.)
              (increase! last-traffic-count (+ fresh-packets-sent fresh-packets-received))
              (let ((elapse (- now last-traffic-time)))
                (if (>= elapse .05)
                    (let ((rate (/ (cast <fl> last-traffic-count) elapse)))
                      (set! last-traffic-count 0)
                      (set! last-traffic-time now)
                      rate)
                  -1.))))
          
          (set! last-packets-sent packets-sent)
          (set! last-packets-received packets-received)
          (set! last-server-sent server-sent)
          (set! last-server-received server-received)
          (record-event udp-id-receive-ack
                        -1.
                        -1.
                        (fixnum->flonum (- fresh-packets-sent fresh-server-received))
                        (fixnum->flonum (- fresh-server-sent fresh-packets-received))
                        round-trip
                        (fresh-traffic-rate)))
        (let ((outgoing-dropped (- packets-sent server-received))
              (incoming-dropped (- server-sent packets-received)))
          (set! outgoing-drop (and (> packets-sent 0) (percentage outgoing-dropped packets-sent)))
          (set! incoming-drop (and (> server-sent 0) (percentage incoming-dropped server-sent)))))))
  
  
  (method (receive-nack self data)
    (let ((origin (read-udp-origin data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-latest-missing data))))
      (send-missing self origin media-kind missing)))
  
  
  (method protected (receive-media self kind data)
    (let ((origin (read-udp-origin data)))
      (let ((channel (find-receive-channel self origin kind)))
        (when channel
          (insert-media channel data)
          (let ((frame (read-udp-frame data))
                (last-nacked-frame (get-last-nacked-frame channel)))
            (when (or (not last-nacked-frame)
                      (> frame last-nacked-frame))
              (send-nacks self origin kind channel)
              (set-last-nacked-frame channel frame)))))))
  
  
  (method protected (send-nacks self origin kind channel)
    (unless (simulation?)
      (let ((latest-missing (collect-latest-missing channel)))
        (unless (null? latest-missing)
          (send-nack self origin kind latest-missing)))))
  
  
  (method (send-missing self origin media-kind missing)
    (let ((channel (find-send-channel self media-kind)))
      (when channel
        (let ((ring (get-retain-ring channel)))
          (for-each (lambda (sequence)
                      (let ((data (locate-data ring sequence)))
                        (if data
                            (begin
                              (send-data self data)
                              (let ((frame (read-udp-frame data)))
                                (record-event udp-id-resend-packet
                                              (fixnum->flonum origin)
                                              (fixnum->flonum media-kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              -1.
                                              -1.)))
                          (record-event udp-id-absent-packet
                                        (fixnum->flonum origin)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        -1.
                                        -1.
                                        -1.)
                          (when udp-show-nacks?
                            (terminal remote-name (present-media-kind media-kind) '***nack-missing*** sequence)))))
                    missing)))))
  
  
  (method (send-state self)
    (define (collect-states)
      (let ((queue (new-queue)))
        (iterate-table receive-channels
          (lambda (key channel)
            (let ((state (get-state (get-process-ring channel)))
                  (header (get-last-processed-header channel)))
              (enqueue queue
                       (list (get-origin channel)
                             (get-media-kind channel)
                             state
                             header)))))
        (queue-list queue)))
    
    (let ((states (collect-states)))
      (mutex-lock! write-mutex)
      (let ((states (object->u8vector states)))
        (let ((size (+ 8 4 4 4 (u8vector-length states))))
          (let ((data (make-u8vector size)))
            (write-udp-sent data (current-seconds))
            (write-udp-kind data udp-state)
            (write-udp-origin data client-no)
            (write-udp-state-channels data states)
            (send-data self data))))
      (mutex-unlock! write-mutex)))
  
  
  (method (send-nack self origin media-kind latest-missing)
    (when udp-show-nacks?
      (terminal remote-name (present-media-kind media-kind) '***send-nack*** latest-missing))
    (mutex-lock! write-mutex)
    (let ((missing (object->u8vector latest-missing)))
      (let ((size (+ 8 4 4 4 4 (u8vector-length missing))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-origin data origin)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-latest-missing data missing)
          (send-data self data))))
    (mutex-unlock! write-mutex)))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Channel
  
  
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-timestamp accessors generate)
  (slot retain-ring    getter generate)
  (slot release-task   getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self origin media-kind)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f)
    (set! self.retain-ring (new UDP-Ring origin media-kind udp-retain-size max-size: udp-retain-max-size overflow-proc: (udp-ring-overflow 'retain udp-ring-kind-retain)))
    (unless (simulation?)
      (set! self.release-task (new Task 'udp-release (lambda (task)
                                                       (release-loop self task))
                                   priority: udp-priority))
      (start-task release-task)))
  
  
  (method override (destroy self)
    (terminate retain-ring)
    (thread-join! (get-thread release-task))
    (nextmethod self))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (retain-media self data)
    (insert retain-ring data udp-id-retain-packet))
  
  
  (method protected (release-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((packet (retain-wait retain-ring)))
            (if (eq? packet 'terminate)
                (continuation-return exit #f)
              (site (udp-release on?: #t)
                (release-media self packet))
              (loop)))))))
  
  
  (method protected (release-media self packet)
    (let ((data (get-data packet)))
      (if (not data)
          (let ((removed-sequence data))
            (record-event udp-id-giveup-packet
                          (fixnum->flonum origin)
                          (fixnum->flonum media-kind)
                          (fixnum->flonum removed-sequence)
                          -1.
                          -1.
                          -1.))
        (let ((origin (read-udp-origin data))
              (sequence (read-udp-sequence data))
              (frame (read-udp-frame data))
              (ring-size (get-count retain-ring))
              (timestamp (read-udp-media-timestamp data)))
          (record-event udp-id-release-packet
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        (fixnum->flonum sequence)
                        (fixnum->flonum frame)
                        (fixnum->flonum ring-size)
                        (timestamp->flonum timestamp)))))))


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot process-ring          getter generate)
  (slot process-task          getter generate)
  (slot process-average       getter generate)
  (slot last-nacked-frame     accessors generate)
  (slot last-processed-header getter generate)
  (slot processed             getter generate)
  (slot missing               getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self origin media-kind)
    (set! self.last-nacked-frame #f)
    (set! self.last-processed-header #f)
    (set! self.process-ring (new UDP-Ring origin media-kind udp-process-size max-size: udp-process-max-size state-proc: (state-callback origin media-kind) invalid-proc: (udp-ring-invalid origin media-kind) overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
    (unless (simulation?)
      (set! self.process-task (new Task 'udp-process (lambda (task)
                                                       (process-loop self task))
                                   priority: udp-priority)))
    (set! self.process-average (new Average .05 1.))
    (set! self.processed 0)
    (set! self.missing 0)
    (unless (simulation?)
      (start-task process-task)))
  
  
  (method override (destroy self)
    (terminate process-ring)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (collect-latest-missing self)
    (let ((missing (new-queue))
          (count 0))
      (continuation-capture
        (lambda (done)
          (iterate-latest process-ring
            (lambda (packet)
              (when (not (get-data packet))
                (enqueue missing (get-sequence packet))
                (increase! count)
                (when (>= count udp-latest-nacks)
                  (continuation-return done #f)))))))
      (queue-list missing)))
  
  
  (method protected (count-missing self)
    (let ((count 0))
      (iterate-latest process-ring
        (lambda (packet)
          (when (not (get-data packet))
            (increase! count))))
      count))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected (insert-nack self data)
    )
  
  
  (method protected (insert-media self data)
    (insert process-ring data))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-wait process-ring udp-ready-window process-average)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site (udp-process on?: #t)
                (present-frame self info))
              (looping)))))))
  
  
  (method protected (present-frame self datas)
    (define (record-play-frame origin frame header? timestamp)
      (record-event udp-id-play-frame
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (barbara-header-hack header?)
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (define (record-freeze-frame origin frame header? timestamp)
      (record-event udp-id-freeze-frame
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (barbara-header-hack header?)
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (let ((id (find-id-quick-hack origin)))
      (when (or id (simulation?))
        (let ((count (length datas))
              (first (car datas)))
          (increase! processed count)
          (let ((kind (read-udp-kind first))
                (origin (read-udp-origin first))
                (frame (read-udp-frame first))
                (total (read-udp-total first))
                (timestamp (read-udp-media-timestamp first))
                (duration (read-udp-media-duration first))
                (header? (read-udp-media-header? first))
                (off? (read-udp-media-off? first)))
            (define (process-audio)
              (let ((buffer (assemble-chunks)))
                (if off?
                    (receive-server-audio (current-audio) id #f #f #f)
                  (if (and header? (eq? audio-codec 'vorbis))
                      (let ((headers (u8vector->object buffer)))
                        (for-each (lambda (header)
                                    (bind (buffer timestamp duration) header
                                      ;; be very careful as timestamp is incorrect as it
                                      ;; is the timestamp at time the header was captured
                                      ;; this only works because gst_app_src_write3
                                      ;; doesn't actually use the timestamp
                                      (receive-server-audio (current-audio) id buffer timestamp duration)))
                                  headers))
                    (receive-server-audio (current-audio) id buffer timestamp duration))
                  (record-play-frame origin frame header? timestamp))))
            
            (define (process-video)
              (let ((buffer (assemble-chunks)))
                (if off?
                    (receive-server-video (current-video) id #f #f #f)
                  (unless (simulation?)
                    (receive-server-video (current-video) id buffer timestamp duration))
                  (if (eq? (get-state process-ring) 'late)
                      (record-freeze-frame origin frame header? timestamp)
                    (record-play-frame origin frame header? timestamp)))))
            
            (define (assemble-chunks)
              (if (= total 1)
                  (read-udp-media-payload first)
                (let ((chunks (map read-udp-media-payload datas)))
                  (apply u8vector-append chunks))))
            
            (ecase kind
              ((udp-audio)
               (process-audio))
              ((udp-video)
               (process-video)))
            (when header?
              (set! last-processed-header frame)))))))))
