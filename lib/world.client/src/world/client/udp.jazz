;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.application)
        (jazz.event)
        (jazz.io)
        (jazz.math)
        (jazz.platform)
        (jazz.presence)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.audio)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.player)
        (world.profiling)
        (world.record (phase syntax))
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.throttle)
        (world.time)
        (world.udp)
        (world.video))


(definition protected round-trip-tolerance
  .01)


(class UDP-Client extends UDP-Tier
  
  
  (slot client-no              initialize #f getter generate)
  (slot character-name         initialize #f getter generate)
  (slot udp-port               initialize #f getter generate)
  (slot udp-stopping?          initialize #f getter generate)
  (slot server-host            initialize #f getter generate)
  (slot server-port            initialize #f getter generate)
  (slot write-mutex            initialize #f getter generate)
  (slot receive-streams        initialize #f getter generate)
  (slot receive-channels       initialize #f getter generate)
  (slot alive-task             initialize #f getter generate)
  (slot awake-task             initialize #f getter generate)
  (slot receive-task           initialize #f getter generate)
  (slot state-task             initialize #f getter generate)
  (slot heartbeat-task         initialize #f getter generate)
  (slot heartbeat-sequence     initialize 0  getter generate)
  (slot noack-ring             initialize #f getter generate)
  (slot noack-thread           initialize #f getter generate)
  (slot noack-time             initialize #f getter generate)
  (slot started?               initialize #f getter generate)
  (slot monitor                initialize #f getter generate)
  (slot statistics             initialize #f getter generate)
  (slot invalid-packets        initialize 0  getter generate)
  (slot last-send-state        initialize #f getter generate)
  (slot last-received-ack      initialize #f getter generate)
  (slot stable-received-acks   initialize 0  getter generate)
  (slot stable-round-trip      initialize #f getter generate)
  (slot moving-round-trip      initialize #f getter generate)
  (slot throttle               initialize #f getter generate)
  (slot throttle-media?        initialize #f getter generate)
  (slot profile-ack-callback   initialize #f accessors generate)
  (slot profile-pulse-sequence initialize #f getter generate)
  (slot profile-media-sequence initialize #f getter generate)
  (slot profile-last-sequence  initialize #f getter generate)
  (slot profile-monitor        initialize #f getter generate)
  (slot profile-statistics     initialize #f getter generate)
  (slot profile-chronology     initialize #f getter generate)
  (slot profile-evolution      initialize #f getter generate)
  (slot simulator              initialize #f accessors generate)
  
  
  (method override (initialize self client-no character-name)
    (nextmethod self)
    (set! self.client-no client-no)
    (set! self.character-name character-name)
    (set! write-mutex (make-mutex 'write))
    (set! receive-streams (make-table))
    (set! receive-channels (make-table))
    (set! throttle (new UDP-Throttle))
    (register-snapshot-callback (~ snapshot-receive-streams self)))
  
  
  (method package (connect self local-address host service)
    (unless (simulation?)
    (set! udp-port (open-udp (list
                               local-address: local-address
                               address: host
                               port-number: service)))
    (setup-udp-port-buffers udp-port)
    (set! udp-stopping? #f)
    (let ()
      (define (send-connect)
        (with-write-mutex self
          (lambda ()
            (with-record connect
              (let ((data (make-u8vector (+ (calculate-connect-size) udp-code-size))))
                (write-header-kind data udp-connect)
                (write-header-sender data client-no)
                (write-connect-sent data (current-seconds))
                (write-connect-video-level data (or (video-profile-level) -1))
                (write-udp-code data)
                (write-data data udp-port))))))
      
      (set! server-host #f)
      (set! server-port #f)
      (set! monitor (new UDP-Monitor))
      (set! statistics (new UDP-Statistics))
      (set! simulator #f)
      (record-event udp-id-connecting
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.)
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (with-record connected
              (if (or (eof-object? reply) (/= (read-header-kind reply) udp-connected))
                  (if (>= n 100)
                      (begin
                        (terminal 'BAILOUT 'did 'not 'receive 'udp-connected)
                        (exit 1))
                    (loop (+ n 1)))
                (let ((source-info (udp-source-socket-info udp-port)))
                  (set! server-host (socket-info-address source-info))
                  (set! server-port (socket-info-port-number source-info)))
                (record-event udp-id-connected
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.)
                (set! alive-task (new Task 'udp-alive (~ run-alive self) priority: alive-priority))
                (set! awake-task (new Task 'udp-awake (~ run-awake self) priority: awake-priority))
                (set! receive-task (new Task 'udp-receive (~ run-receive self) priority: udp-priority))
                (start-task alive-task)
                (start-task awake-task)
                (start-task receive-task)))))))))

  
  (method (deconnect self)
    (set! udp-stopping? #t)
    (stop-task alive-task)
    (set! alive-task #f)
    (stop-task awake-task)
    (set! awake-task #f)
    (close-port udp-port)
    (thread-join! (get-thread receive-task))
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (unless (simulation?)
        (set! state-task (new Task 'udp-state (~ run-state self) priority: udp-priority))
        (start-task state-task)
        (set! heartbeat-task (new Task 'udp-heartbeat (~ run-heartbeat self) priority: udp-priority))
        (start-task heartbeat-task)
        (let ((thread (new-thread
                        (lambda ()
                          (declare (proper-tail-calls))
                          (let (loop)
                            (let ((proc (wait noack-ring)))
                              (when proc
                                (proc)
                                (loop)))))
                        'udp-noack)))
          (set! noack-ring (new Time-Ring 1))
          (set! noack-thread thread)
          (thread-base-priority-set! thread udp-priority)
          (thread-start! thread)
          (schedule-noack self 1.)))
      (set! last-received-ack (current-seconds))
      (set! throttle-media? #f)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (stop-task state-task)
      (set! state-task #f)
      (stop-task heartbeat-task)
      (set! heartbeat-task #f)
      (terminate noack-ring)
      (thread-join! noack-thread)
      (set! noack-ring #f)
      (set! noack-thread #f)
      (set! started? #f)))
  
  
  (method (with-write-mutex self thunk)
    (unwind-protect
        (begin
          (mutex-lock! write-mutex)
          (thunk))
      (mutex-unlock! write-mutex)))
  
  
  (method (snapshot-receive-streams self)
    (let ((info (map (lambda (stream)
                       (list (get-sender stream)
                             (get-name stream)
                             (get-source-kind stream)))
                     (table-values receive-streams))))
      (add-snapshot-property 'live.udp-receive info)))
  
  
  (method protected (new-simulator self)
    (new UDP-Simulator
         (lambda (data info drop?)
           (if drop?
               (increase-sent self data)
             (send-server self data)))))
  
  
  (method package (require-simulator self)
    (or simulator
        (let ((sim (new-simulator self)))
          (set! simulator sim)
          sim)))
  
  
  (method protected (increase-sent self data)
    (increase-sent monitor data))
  
  
  (method protected (increase-received self data)
    (increase-received monitor data))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (set! profile-pulse-sequence 0)
    (set! profile-media-sequence 0)
    (set! profile-last-sequence 0)
    (set! profile-monitor (new UDP-Monitor))
    (set! profile-statistics (new UDP-Statistics))
    (set! profile-chronology (new Chronology 0))
    (set! profile-evolution (new Evolution 5000)))
  
  
  (method package (retrieve-profile self)
    (let ((metadata (list client-no character-name '() '() (sites-metadata)))
          (chronology (copy-chronology profile-chronology))
          (evolution (copy-evolution profile-evolution)))
      (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
  
  
  (method package (stop-profile self)
    (set! profile-chronology #f)
    (set! profile-evolution #f))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (close-send-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-send-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (unregister-stream (current-client) stream-no)
      (table-clear send-streams stream-no)))
  
  
  (method package (close-send-streams self)
    (iterate-table-safe send-streams
      (lambda (no stream)
        (close-send-stream self stream))))
  
  
  (method package (register-receive-stream self sender name stream-no origin source-kind video-level channels)
    (let ((stream (new UDP-Receive-Stream sender name stream-no origin source-kind video-level)))
      (for-each (lambda (info)
                  (bind (channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata) info
                    (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                channels)
      (table-set! receive-streams stream-no stream)
      stream))
  
  
  (method public (find-receive-stream self stream-no)
    (table-ref receive-streams stream-no #f))
  
  
  (method package (close-receive-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-receive-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (table-clear receive-streams stream-no)))
  
  
  (method package (close-receive-streams self)
    (iterate-table-safe receive-streams
      (lambda (no stream)
        (close-receive-stream self stream))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (register-send-channel self stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (let ((stream (find-send-stream self stream-no)))
      (let ((channel (new UDP-Send-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
        (table-set! send-channels channel-no channel)
        channel)))
  
  
  (method package (close-send-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear send-channels channel-no)))
  
  
  (method public (find-receive-channel self channel-no)
    (table-ref receive-channels channel-no #f))
  
  
  (method package (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (let ((channel (new UDP-Receive-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
      (table-set! receive-channels channel-no channel)
      channel))
  
  
  (method package (close-receive-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear receive-channels channel-no)))
  
  
  (method package (close-channel-output self channel)
    (let ((id (get-no channel))
          (kind (get-media-kind channel)))
      (ecase kind
        ((udp-audio)
         (let ((audio (current-audio)))
           (let ((output (find-output audio id)))
             (when output
               (close-output audio id output)
               (close-empty-audio audio)))))
        ((udp-video)
         (let ((video (current-video)))
           (let ((output (find-output video id)))
             (when output
               (close-output video id output))))))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method package (send-media self channel-no buffer dts pts duration keyframe?)
    (with-write-mutex self
      (lambda ()
        (let ((channel (find-send-channel self channel-no)))
          (when channel
            (let ((kind (get-media-kind channel)))
              (define (send)
                (send-media channel buffer dts pts duration keyframe?
                  (lambda (data)
                    (send-data self data))))
              
              (define (advance-frame!)
                (let ((frame (next-frame-sequence! channel)))
                  (record-event udp-id-throttle-frame
                                (fixnum->flonum channel-no)
                                (fixnum->flonum client-no)
                                (fixnum->flonum kind)
                                -1.
                                (fixnum->flonum frame)
                                -1.
                                -1.)))
              
              (if (simulation?)
                  (send)
                (if throttle-media?
                    (advance-frame!)
                  (if (waiting-keyframe? channel)
                      (if (not keyframe?)
                          (advance-frame!)
                        (got-keyframe channel)
                        (send))
                    (let ((now (current-seconds)))
                      (if (and udp-throttle (> (- now last-received-ack) udp-throttle))
                          (begin
                            (set! throttle-media? #t)
                            (iterate-table send-channels
                              (lambda (no channel)
                                (wait-keyframe channel)))
                            (record-event udp-id-throttle-on
                                          -1.
                                          (fixnum->flonum server-no)
                                          -1.
                                          -1.
                                          -1.
                                          -1.
                                          -1.))
                        (send))))))))))))
  
  
  (method (send-state self)
    (define (collect-waiting)
      (let ((waiting '()))
        (iterate-table receive-channels
          (lambda (key channel)
            (when (eq? (get-source-kind channel) 'image)
              (let ((state (get-state (get-process-ring channel))))
                (when (eq? state 'waiting)
                  (set! waiting (cons (get-no channel) waiting)))))))
        waiting))
    
    (let ((waiting (collect-waiting)))
      (when (not-null? waiting)
        (let ((now (current-seconds)))
          (when (or (not last-send-state)
                    (> now (+ last-send-state 1.)))
            (with-write-mutex self
              (lambda ()
                (with-record state
                  (let ((waiting (object->u8vector waiting)))
                    (let ((size (calculate-state-size waiting)))
                      (let ((data (make-u8vector (+ size udp-code-size))))
                        (write-header-kind data udp-state)
                        (write-header-sender data client-no)
                        (write-state-waiting data waiting)
                        (write-udp-code data)
                        (send-data self data)))))))
            (set! last-send-state now))))))
  
  
  (method protected (next-profile-pulse-sequence! self)
    (prog1 profile-pulse-sequence
      (increase! profile-pulse-sequence)))
  
  
  (method protected (next-profile-media-sequence! self)
    (prog1 profile-media-sequence
      (increase! profile-media-sequence)))
  
  
  (method package (send-profile-pulse self)
    (with-write-mutex self
      (lambda ()
        (with-record profile-pulse
          (let ((size (calculate-profile-pulse-size)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-profile-pulse)
              (write-header-sender data client-no)
              (write-profile-pulse-sent data (current-seconds))
              (write-profile-pulse-sequence data (next-profile-pulse-sequence! self))
              (write-udp-code data)
              (send-data self data)
              data))))))
  
  
  (method package (send-profile-media self payload)
    (with-write-mutex self
      (lambda ()
        (with-record profile-media
          (let ((size (calculate-profile-media-size payload)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-profile-media)
              (write-header-sender data client-no)
              (write-profile-media-sequence data (next-profile-media-sequence! self))
              (write-profile-media-payload data payload)
              (write-udp-code data)
              (send-data self data)
              (increase-sent profile-monitor data)))))))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data #f)
      (send-server self data)))
  
  
  (method (send-server self data)
    ;; quick temporary hack to get back the safe behavior
    ;; of retrying-write until port being false is fixed
    (when udp-port
      (udp-destination-set! server-host server-port udp-port)
      (send-udp data udp-port)
      (increase-sent self data)))
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (method (run-alive self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site alive
                  (send-alive self)))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task alive-period duration exit))
              (iter time)))))))
  
  
  ;;;
  ;;;; Awake
  ;;;
  
  
  (method (run-awake self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site awake
                  (adjust-computer-sleep self)))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task awake-period duration exit))
              (iter time)))))))
  
  
  (method (adjust-computer-sleep self)
    (if (not application-active?)
        ;; when in the background we let the os manage sleep and we
        ;; disconnect from group or circle when actually going to sleep
        (allow-computer-sleep)
      (let ((keep-awake? #f))
        ;; send
        (iterate-table send-channels
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio udp-video)
               (when (or (neq? (get-source-kind channel) 'live)
                         (on? channel))
                 (set! keep-awake? #t))))))
        ;; receive
        (iterate-table receive-channels
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio udp-video)
               (set! keep-awake? #t)))))
        ;; policy
        (if keep-awake?
            (prevent-computer-sleep)
          (allow-computer-sleep)))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (run-state self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (site udp-state
            (send-state self))
          (task-sleep task udp-state-period exit)
          (loop)))))
  
  
  ;;;
  ;;;; Heartbeat
  ;;;
  
  
  (method (run-heartbeat self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (site udp-heartbeat
            (send-heartbeat self))
          (task-sleep task udp-heartbeat-period exit)
          (loop)))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (run-receive self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (catch-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read-data udp-port)))))
            (when data
              (site udp-receive
                (receive-data self data))
              (loop)))))))
  
  
  (method protected (receive-data self data)
    (if (or (< (u8vector-length data) 4)
            (/= (read-udp-code data) udp-code))
        (increase! invalid-packets)
      (increase-received self data)
      (let ((kind (with-record header
                    (read-header-kind data))))
        (if (not started?)
            (ecase kind
              ((udp-connected))
              ((udp-ack))
              ((udp-nack))
              ((udp-audio udp-video))
              ((udp-alive-ack)
               (receive-alive-ack self data))
              ((udp-profile-ack)
               (receive-profile-ack self data))
              ((udp-profile-media)
               (receive-profile-media self data))
              (else
               (error "Unknown UDP kind: {s}" kind)))
          (ecase kind
            ((udp-connected))
            ((udp-ack)
             (receive-ack self data))
            ((udp-nack)
             (receive-nack self data))
            ((udp-audio udp-video)
             (receive-medias self kind data))
            ((udp-state)
             (receive-state self data))
            ((udp-alive-ack)
             (receive-alive-ack self data))
            ((udp-profile-pulse))
            ((udp-profile-media))
            (else
             (error "Unknown UDP kind: {s}" kind)))))))
  
  
  (method (receive-ack self data)
    (with-record ack
      (let ((now (current-seconds))
            (sender (read-header-sender data))
            (heartbeat-sent (read-ack-heartbeat-sent data))
            (heartbeat-sequence (read-ack-heartbeat-sequence data)))
        ;; statistics
        (let ((ack-sent (read-ack-sent data))
              (server-packets-sent (read-ack-packets-sent data))
              (server-bytes-sent (read-ack-bytes-sent data))
              (server-packets-received (read-ack-packets-received data))
              (server-bytes-received (read-ack-bytes-received data))
              (server-missed-media-packets (read-ack-missed-media-packets data)))
          (let ((round-trip (- now heartbeat-sent)))
            (let ((variance (abs (- (- now last-received-ack) .1))))
              (if (>= variance .01)
                  (set! stable-received-acks 0)
                (increase! stable-received-acks)
                (when (>= stable-received-acks 3)
                  (cond ((not moving-round-trip)
                         (set! moving-round-trip round-trip)
                         (set! stable-round-trip round-trip))
                        (else
                         (set! moving-round-trip (/ (+ (* moving-round-trip 7.) round-trip) 8.))
                         (when (> (abs (- moving-round-trip stable-round-trip)) round-trip-tolerance)
                           (set! stable-round-trip moving-round-trip)))))))
            (update statistics now monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received server-missed-media-packets)
            (record-event udp-id-receive-ack
                          -1.
                          (fixnum->flonum sender)
                          -1.
                          (fixnum->flonum heartbeat-sequence)
                          round-trip
                          heartbeat-sent
                          ack-sent
                          -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                          -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received))))
          (let ((last-send-rate (get-last-send-rate statistics))
                (last-receive-rate (get-last-receive-rate statistics)))
            (unless (= last-send-rate -1.)
              (record-event udp-id-traffic-rate
                            -1.
                            (fixnum->flonum sender)
                            -1.
                            (fixnum->flonum heartbeat-sequence)
                            -1.
                            last-send-rate
                            last-receive-rate))))
        ;; throttle
        (received-ack throttle heartbeat-sent heartbeat-sequence statistics
          (lambda (adjustment reason)
            (delay-throttle-upload self adjustment reason)))
        (schedule-noack self)
        ;; throttling
        (set! last-received-ack now)
        (when throttle-media?
          (set! throttle-media? #f)
          ;; force camera reset
          ;; (maybe-reset-media self server-no udp-video #f)
          (record-event udp-id-throttle-off
                        -1.
                        (fixnum->flonum server-no)
                        -1.
                        (fixnum->flonum heartbeat-sequence)
                        -1.
                        -1.
                        -1.)))))
  
  
  (method (noack-receive self)
    (noack-received throttle statistics
      (lambda (adjustment reason)
        (delay-throttle-upload self adjustment reason)))
    (schedule-noack self))
  
  
  (method (delay-throttle-upload self adjustment reason)
    (delay-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (throttle-upload (current-client))
            (record-event udp-id-throttle-upload
                          -1.
                          -1.
                          -1.
                          adjustment
                          reason
                          -1.
                          -1.
                          -1.))))))
  
  
  (method (schedule-noack self (delay #f))
    (let ((time (+ (current-seconds) (or delay (* udp-heartbeat-period noack-heartbeats)))))
      ;; mostly so we don't overwrite the initial longer 1s delay
      (when (or (not noack-time)
                (> time noack-time))
        (set! noack-time time)
        (empty noack-ring)
        (insert noack-ring noack-time (lambda ()
                                        (noack-receive self))))))
  
  
  (method (receive-nack self data)
    (with-record nack
      (let ((sender (read-header-sender data))
            (channel-no (read-nack-channel data))
            (start (read-nack-start data))
            (gap (read-nack-gap data)))
        (send-missing self sender channel-no start gap))))
  
  
  (method protected (receive-medias self kind data)
    (declare (proper-tail-calls))
    (with-record media
      (let ((no (read-media-channel data)))
        ;; so a sequence of one doesn't allocate a pair
        (let (loop (ordered #f))
          (define (receive)
            (if (not ordered)
                (receive-media self kind data)
              (for-each (lambda (data)
                          (receive-media self kind data))
                        ordered)))
          
          (input-port-timeout-set! udp-port 0)
          (let ((next (read udp-port)))
            (input-port-timeout-set! udp-port +inf.0)
            (cond ((eof-object? next)
                   (receive))
                  ((and (= (read-header-kind next) kind)
                        (= (read-media-channel next) no))
                   (loop (add-ordered! next (or ordered (list data)) key: (lambda (data)
                                                                            (read-media-sequence data)))))
                  (else
                   (receive)
                   (receive-data self next))))))))
  
  
  (method protected (receive-media self kind data)
    (with-record media
      (let ((channel-no (read-media-channel data)))
        (let ((channel (find-receive-channel self channel-no)))
          (when channel
            (remember-media channel data)
            (insert-media channel data))))))
  
  
  (method (send-missing self sender channel-no start gap)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((media-kind (get-media-kind channel))
              (ring (get-retain-ring channel)))
          (loop (for sequence from start below (+ start gap))
                (let ((data (locate-data ring sequence)))
                  (if data
                      (with-record media
                        (increase-media-resent data)
                        (send-data self data)
                        (let ((frame (read-media-frame data)))
                          (record-event udp-id-resend-packet
                                        (fixnum->flonum channel-no)
                                        (fixnum->flonum sender)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        (fixnum->flonum frame)
                                        -1.
                                        -1.)))
                    (record-event udp-id-absent-packet
                                  (fixnum->flonum channel-no)
                                  (fixnum->flonum sender)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  -1.
                                  -1.
                                  -1.))))))))
  
  
  (method (receive-state self data)
    (with-record state
      (let ((waiting (u8vector->object (read-state-waiting data))))
        (for-each (lambda (channel-no)
                    (let ((channel (find-send-channel self channel-no)))
                      (when channel
                        (reset-media channel))))
                  waiting))))
  
  
  (method (receive-alive-ack self data)
    )
  
  
  (method (receive-profile-ack self data)
    (let ((include-receive-rate?
            (if profile-ack-callback
                (profile-ack-callback data)
              #t)))
      (with-record profile-ack
        (let ((now (current-seconds)))
          (let ((ack-sent (read-profile-ack-sent data))
                (pulse-sent (read-profile-ack-pulse-sent data))
                (pulse-sequence (read-profile-ack-pulse-sequence data))
                (latency (read-profile-ack-latency data))
                (server-packets-sent (read-profile-ack-packets-sent data))
                (server-bytes-sent (read-profile-ack-bytes-sent data))
                (server-packets-received (read-profile-ack-packets-received data))
                (server-bytes-received (read-profile-ack-bytes-received data))
                (server-missed-media-packets 0)) ;; todo
            (let ((round-trip (- now pulse-sent)))
              (update profile-statistics now profile-monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received server-missed-media-packets)
              (parameterize ((simulation-evolution profile-evolution))
                ;; hack to plot latency
                (record-event udp-id-insert-packet
                              (fixnum->flonum pulse-sequence)
                              (fixnum->flonum client-no)
                              (fixnum->flonum udp-audio)
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              latency)
                ;; hack to plot round trip
                (record-event udp-id-receive-ack
                              -1.
                              (fixnum->flonum client-no)
                              -1.
                              (fixnum->flonum pulse-sequence)
                              round-trip
                              pulse-sent
                              ack-sent
                              -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                              -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received)))
                (let ((last-send-rate (get-last-send-rate profile-statistics))
                      (last-receive-rate (get-last-receive-rate profile-statistics)))
                  (unless (= last-send-rate -1.)
                    ;; hack to plot upload
                    (record-event udp-id-traffic-rate
                                  -1.
                                  (fixnum->flonum client-no)
                                  -1.
                                  (fixnum->flonum pulse-sequence)
                                  -1.
                                  last-send-rate
                                  (if include-receive-rate?
                                      last-receive-rate
                                    -1.)))))))))))
  
  
  (method (receive-profile-media self data)
    (with-record profile-media
      (let ((sender (read-header-sender data))
            (sequence (read-profile-media-sequence data)))
        (when profile-last-sequence
          (let ((expected-sequence (+ profile-last-sequence 1)))
            (when (/= sequence expected-sequence)
              (parameterize ((simulation-evolution profile-evolution))
                (loop (for seq from expected-sequence below sequence)
                      (record-event udp-id-lost-packet
                                    -1.
                                    (fixnum->flonum sender)
                                    (fixnum->flonum udp-profile-media)
                                    (fixnum->flonum seq)
                                    -1.
                                    -1.
                                    -1.))))))
        (set! profile-last-sequence sequence)
        (increase-received profile-monitor data))))
  
  
  (method protected (next-heartbeat-sequence! self)
    (prog1 heartbeat-sequence
      ;; wrap around acceptable
      (if (= heartbeat-sequence max-heartbeat-sequence)
          (set! heartbeat-sequence 0)
        (increase! heartbeat-sequence))))
  
  
  (method (send-heartbeat self)
    (let ((heartbeat-sequence (next-heartbeat-sequence! self)))
      (with-write-mutex self
        (lambda ()
          (with-record heartbeat
            (let ((size (calculate-heartbeat-size)))
              (let ((data (make-u8vector (+ size udp-code-size))))
                (write-header-kind data udp-heartbeat)
                (write-header-sender data client-no)
                (write-heartbeat-sent data (current-seconds))
                (write-heartbeat-sequence data heartbeat-sequence)
                (write-udp-code data)
                (send-data self data))))
          (record-event udp-id-send-heartbeat
                        -1.
                        (fixnum->flonum client-no)
                        -1.
                        (fixnum->flonum heartbeat-sequence)
                        -1.
                        -1.
                        -1.)))))
  
  
  (method override (add-missed-media-packets self sender gap)
    (increase-missed-media-packets monitor gap))
  
  
  (method override (send-nack self sender channel-no start gap)
    (with-write-mutex self
      (lambda ()
        (with-record nack
          (let ((size (calculate-nack-size)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-nack)
              (write-header-sender data client-no)
              (write-nack-channel data channel-no)
              (write-nack-start data start)
              (write-nack-gap data gap)
              (write-udp-code data)
              (send-data self data)))))))
  
  
  (method (send-alive self)
    ;; keep clean during profile
    (unless profile-ack-callback
      (with-write-mutex self
        (lambda ()
          (with-record header
            (let ((size (calculate-alive-size)))
              (let ((data (make-u8vector (+ size udp-code-size))))
                (write-header-kind data udp-alive)
                (write-header-sender data client-no)
                (write-udp-code data)
                (send-data self data)))))))))


;;;
;;;; Receive Base
;;;


(definition cutoff-latency
  1.5)

(definition cutoff-last-past-time
  0.5)


(class UDP-Receive-Base extends Time-Base
  
  
  (slot stream                    getter generate)
  (slot media-kind                getter generate)
  (slot source-kind               getter generate)
  (slot short-moving        <fl>  getter generate)
  (slot long-moving         <fl>  getter generate)
  (slot past-moving         <fl>  getter generate)
  (slot last-past-time      <fl+> getter generate)
  (slot time-of-last-change <fl+> getter generate)
  
  
  (method override (initialize self stream media-kind source-kind)
    (nextmethod self)
    (set! self.stream stream)
    (set! self.media-kind media-kind)
    (set! self.source-kind source-kind))
  
  
  (method override (reset-base self)
    (nextmethod self)
    (set! self.short-moving 0.)
    (set! self.long-moving 0.)
    (set! self.past-moving 0.)
    (set! self.last-past-time #f)
    (set! self.time-of-last-change #f))
  
  
  (method protected (update-moving-averages self raw new-local)
    (let ((old-short-moving short-moving)
          (old-long-moving long-moving))
      (let ((new-short-moving (/ (+ (* short-moving 15.) raw) 16.))
            (new-long-moving (/ (+ (* long-moving 1001.) raw) 1002.)))
        (set! short-moving new-short-moving)
        (set! long-moving new-long-moving)
        (cond ((and (> short-moving old-short-moving) (> short-moving long-moving))
               (set! self.long-moving short-moving)
               (set! time-of-last-change new-local)
               short-moving)
              ((and (< short-moving old-short-moving) (< short-moving long-moving))
               (set! self.short-moving long-moving)
               long-moving)))))
  
  
  (method override (update-time self new-local new-remote update-proc)
    (let ((new-base (- new-local new-remote)))
      (if (not base)
          (begin
            (set! base new-base)
            (set! raw-latency 0.)
            (set! latency 0.))
        (let ((raw (- new-base base))
              (last-latency latency))
          (case source-kind
            ((live)
             (let ((min-latency (update-moving-averages self raw new-local)))
               (set! raw-latency raw)
               (cond ;; latency going up because of nacks
                     ((and last-past-time
                           (< (- new-local last-past-time) cutoff-last-past-time)
                           (> past-moving latency))
                      (set! latency past-moving)
                      (update-latency stream media-kind latency)
                      @w
                      (terminal '*** latency))
                     ;; latency going up
                     ((> min-latency last-latency)
                      (set! time-of-last-change new-local)
                      (set! latency min-latency)
                      (update-latency stream media-kind latency)
                      @w
                      (terminal '>>> latency))
                     ;; latency going down
                     ((and (< min-latency last-latency)
                           time-of-last-change
                           (> (- new-local time-of-last-change) 10.))
                      (set! time-of-last-change new-local)
                      (set! latency min-latency)
                      (update-latency stream media-kind latency)
                      @w
                      (terminal '<<< latency))))
             (update-proc raw-latency latency))
            (else
             (set! latency (max raw latency))
             (update-latency stream media-kind latency)
             (update-proc raw-latency latency)))))))
  
  
  (method override (update-past self new-local new-remote update-proc)
    (let ((new-base (- new-local new-remote)))
      (let ((raw (- new-base base)))
        (case source-kind
          ((live)
           (cond ((> raw cutoff-latency)
                  @w (terminal '$$$))
                 (else
                  (let ((new-past-moving (/ (+ (* past-moving 31.) raw) 32.)))
                    (set! past-moving new-past-moving)
                    (set! last-past-time new-local)))))
          (else
           (when (> raw latency)
             (set! latency raw)
             (update-latency stream media-kind latency)))))))
  
  
  (method override (remote->local self remote) <fl>
    (+ base (effective-latency stream) remote)))


;;;
;;;; Receive Stream
;;;


(class UDP-Receive-Stream extends UDP-Stream
  
  
  (slot latency-mutex      initialize (make-mutex 'latency) getter generate)
  (slot audio-latency <fl> initialize 0. getter generate)
  (slot video-latency <fl> initialize 0. getter generate)
  (slot latency       <fl> initialize 0. getter generate)
  
  
  (method protected (effective-latency self)
    (mutex-lock! latency-mutex)
    (prog1 latency
      (mutex-unlock! latency-mutex)))
  
  
  (method protected (update-latency self media-kind lat)
    (mutex-lock! latency-mutex)
    (ecase media-kind
      ((udp-audio) (set! audio-latency lat))
      (else (set! video-latency lat)))
    (set! latency (max audio-latency video-latency))
    (mutex-unlock! latency-mutex)))


;;;
;;;; Receive Channel
;;;


(definition protected max-audio-gap
  5)


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot process-ring      getter generate)
  (slot process-task      getter generate)
  (slot replay-ring       getter generate)
  (slot insert-rate-frame getter generate)
  (slot insert-rate       getter generate)
  (slot process-rate      getter generate)
  (slot last-audio-frame    initialize #f getter generate)
  (slot last-audio-buffer   initialize #f getter generate)
  (slot last-audio-pts      initialize #f getter generate)
  (slot last-audio-dts      initialize #f getter generate)
  (slot last-audio-duration initialize #f getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (nextmethod self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (set! self.replay-ring (and (developer?) (remember-ring media-kind source-kind level framerate)))
    (set! self.process-ring (new UDP-Ring self no (get-origin stream) media-kind source-kind udp-process-size max-size: udp-process-max-size time-base: (new UDP-Receive-Base stream media-kind source-kind) overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
    (unless (simulation?)
      (set! self.process-task (new Task 'udp-process (~ run-process self) priority: udp-process-priority)))
    (set! self.insert-rate-frame 0)
    (set! self.insert-rate (new Rate))
    (set! self.process-rate (new Rate))
    (unless (simulation?)
      (start-task process-task)))
  
  
  (method override (destroy self)
    (terminate process-ring)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (remember-media self data)
    (when replay-ring
      (remember replay-ring data)))
  
  
  (method protected (insert-media self data)
    (when framerate
      (with-record media
        (let ((frame (read-media-frame data)))
          (when (or (not insert-rate-frame)
                    (> frame insert-rate-frame))
            (update insert-rate framerate)
            (set! insert-rate-frame frame)))))
    (insert process-ring data))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (run-process self task)
    (ecase media-kind
      ((udp-audio) (run-process-audio self task))
      ((udp-video) (run-process-video self task))))
  
  
  (method (run-process-audio self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-audio process-ring)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site present-audio
                (present-audio self info))
              (looping)))))))
  
  
  (method (run-process-video self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-video process-ring)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site present-video
                (present-video self info))
              (looping)))))))
  
  
  (method (record-play-frame self sender frame keyframe? dts pts)
    (record-event udp-id-play-frame
                  (fixnum->flonum no)
                  (fixnum->flonum sender)
                  (fixnum->flonum media-kind)
                  -1.
                  (fixnum->flonum frame)
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method (record-freeze-frame self sender frame keyframe? dts pts)
    (record-event udp-id-freeze-frame
                  (fixnum->flonum no)
                  (fixnum->flonum sender)
                  (fixnum->flonum media-kind)
                  -1.
                  (fixnum->flonum frame)
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method (assemble-chunks self datas first total)
    (with-record media
      (if (= total 1)
          (read-media-payload first)
        (let ((chunks (map (lambda (data)
                             (read-media-payload data))
                           datas)))
          (apply u8vector-append chunks)))))
  
  
  (method (chop-audio self buffer buffer-duration duration)
    (let ((size (fxround (exact->inexact (* (u8vector-length buffer) (/ duration buffer-duration))))))
      (subu8vector buffer 0 size)))
  

  (method protected (present-audio self datas)
    (let ((first (car datas)))
      (with-record media
        (let ((sender (read-header-sender first))
              (channel-no (read-media-channel first))
              (frame (read-media-frame first))
              (total (read-media-total first))
              (dts (read-media-dts first))
              (pts (read-media-pts first))
              (duration (read-media-duration first))
              (keyframe? (read-media-keyframe? first))
              (off? (read-media-off? first)))
          (let ((id/output (or (simulation-audio) channel-no)))
            ;; duplicate last buffer to fill missing audio which sounds a lot better
            ;; than doing nothing and have gstreamer use silence which sounds gritchy
            (when (and last-audio-frame (> last-audio-duration 0))
              (let ((audio-gap (- frame last-audio-frame)))
                (when (and (> audio-gap 1) (< audio-gap max-audio-gap))
                  (let ((missing-dts (+ last-audio-dts last-audio-duration))
                        (missing-pts (+ last-audio-pts last-audio-duration)))
                    (let (loop (missing-dts missing-dts) (missing-pts missing-pts) (missing-duration (- pts missing-pts)))
                      (when (> missing-duration 0)
                        (if (< missing-duration last-audio-duration)
                            (let ((buffer (chop-audio self last-audio-buffer last-audio-duration missing-duration)))
                              (receive-audio (current-audio) id/output buffer missing-dts missing-pts missing-duration))
                          (receive-audio (current-audio) id/output last-audio-buffer missing-dts missing-pts last-audio-duration)
                          (loop (+ missing-dts last-audio-duration) (+ missing-pts last-audio-duration) (- missing-duration last-audio-duration)))))))))
            (let ((buffer (assemble-chunks self datas first total)))
              (if off?
                  (begin
                    (set! last-audio-frame #f)
                    (set! last-audio-buffer #f)
                    (set! last-audio-dts #f)
                    (set! last-audio-pts #f)
                    (set! last-audio-duration #f)
                    (receive-audio (current-audio) id/output #f #f #f #f))
                (set! last-audio-frame frame)
                (set! last-audio-buffer buffer)
                (set! last-audio-dts dts)
                (set! last-audio-pts pts)
                (set! last-audio-duration duration)
                (receive-audio (current-audio) id/output buffer dts pts duration)
                (record-play-frame self sender frame keyframe? dts pts))))))))
  
  
  (method protected (present-video self datas)
    (let ((first (car datas)))
      (with-record media
        (let ((sender (read-header-sender first))
              (channel-no (read-media-channel first))
              (frame (read-media-frame first))
              (total (read-media-total first))
              (dts (read-media-dts first))
              (pts (read-media-pts first))
              (duration (read-media-duration first))
              (keyframe? (read-media-keyframe? first))
              (off? (read-media-off? first)))
          (let ((id/output (or (simulation-video) channel-no)))
            (let ((buffer (assemble-chunks self datas first total)))
              (if off?
                  (receive-video (current-video) id/output #f #f #f #f #f)
                (receive-video (current-video) id/output buffer dts pts duration keyframe?)
                (when framerate
                  (update process-rate framerate))
                (if (eq? (get-state process-ring) 'late)
                    (record-freeze-frame self sender frame keyframe? dts pts)
                  (record-play-frame self sender frame keyframe? dts pts)))))))))))
