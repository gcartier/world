;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.math)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.audio)
        (world.configure)
        (world.context)
        (world.event)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.udp)
        (world.video))


(definition (state-callback channel-no media-kind)
  (lambda (state)
    (when (= media-kind udp-video)
      (unless (or (simulation?) (emulation?))
        (let ((output (find-output (current-video) channel-no)))
          (when output
            (let ((mode (case state
                          ((ok) 'draw)
                          ((late) 'freeze)
                          ((waiting) 'wait))))
              (change-draw-mode output mode))))))))


(class UDP-Client extends UDP-Tier
  
  
  (slot client-no             initialize #f getter generate)
  (slot udp-port              initialize #f getter generate)
  (slot udp-stopping?         initialize #f getter generate)
  (slot local-host            initialize #f getter generate)
  (slot local-port            initialize #f getter generate)
  (slot server-host           initialize #f getter generate)
  (slot server-port           initialize #f getter generate)
  (slot write-mutex           initialize #f getter generate)
  (slot receive-channels      initialize #f getter generate)
  (slot receive-task          initialize #f getter generate)
  (slot state-task            initialize #f getter generate)
  (slot started?              initialize #f getter generate)
  (slot packets-sent          initialize 0  getter generate)
  (slot packets-received      initialize 0  getter generate)
  (slot last-packets-sent     initialize 0  getter generate)
  (slot last-packets-received initialize 0  getter generate)
  (slot last-server-sent      initialize 0  getter generate)
  (slot last-server-received  initialize 0  getter generate)
  (slot last-traffic-count    initialize 0  getter generate)
  (slot last-traffic-time     initialize #f getter generate)
  (slot outgoing-drop         initialize 0  getter generate)
  (slot incoming-drop         initialize 0  getter generate)
  (slot last-received-ack     initialize #f getter generate)
  (slot throttle-media?       initialize #f getter generate)
  (slot topology              initialize #f getter generate)
  (slot peers                 initialize #f getter generate)
  (slot peers-mutex           initialize #f getter generate)
  (slot simulator             initialize #f accessors generate)
  
  
  (method override (initialize self client-no)
    (nextmethod self)
    (set! self.client-no client-no)
    (set! write-mutex (make-mutex 'write))
    (set! receive-channels (make-table)))
  
  
  (method package (connect self local-host host service)
    ;; quick heuristic
    (define (determine-local-address)
      (if local?
          #u8(127 0 0 1)
        (let ((info (host-info (host-name))))
          (let ((addresses (host-info-addresses info)))
            (if (= 1 (length addresses))
                (car addresses)
              #u8(0 0 0 0))))))
    
    (unless (simulation?)
    (set! udp-port (open-udp (list
                               local-address: local-host
                               address: host
                               port-number: service)))
    (set! udp-stopping? #f)
    (let ((local-host (determine-local-address))
          (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (mutex-lock! write-mutex)
        (let ((data (make-u8vector (+ 8 4 4 4 4 4 4 4))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-connect)
          (write-udp-origin data client-no)
          (write-udp-connect-local-host data local-host)
          (write-udp-connect-local-port data local-port)
          (write-udp-connect-latency data (or udp-latency -1.))
          (write-udp-connect-lag data (or udp-lag -1.))
          (write-udp-connect-drop data (or udp-drop -1.))
          (retrying-write data udp-port))
        (mutex-unlock! write-mutex))
      
      (set! self.local-host local-host)
      (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! packets-sent 0)
      (set! packets-received 0)
      (set! outgoing-drop 0)
      (set! incoming-drop 0)
      (set! topology (world-setting 'world.udp-topology 'server))
      (set! peers (make-table))
      (set! peers-mutex (make-mutex 'peers))
      (set! simulator (if (or udp-latency udp-lag udp-drop udp-congestion)
                          (new UDP-Simulator udp-latency udp-lag udp-drop
                               (lambda (data drop?)
                                 (if drop?
                                     (increase! packets-sent)
                                   @fix-me-can-deadlock-the-threads
                                   (mutex-lock! write-mutex)
                                   (send-topology self data)
                                   @fix-me-can-deadlock-the-threads
                                   (mutex-unlock! write-mutex))))
                        #f))
      (record-event udp-id-connect
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.)
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (if (or (eof-object? reply) (not (= (read-udp-kind reply) udp-connected)))
                (if (>= n 100)
                    (begin
                      (terminal 'BAILOUT 'did 'not 'receive 'udp-connected)
                      (exit 1))
                  (loop (+ n 1)))
              (let ((source-info (udp-source-socket-info udp-port)))
                (set! server-host (socket-info-address source-info))
                (set! server-port (socket-info-port-number source-info)))
              (let ((round-trip (- (current-seconds) (read-udp-sent reply))))
                (record-event udp-id-connected
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              round-trip
                              -1.)
                (when udp-show-roundtrip?
                  (format :terminal "{s} {s} {s}{%}" remote-name '***roundtrip*** round-trip))))))))))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (unless (simulation?)
        (set! receive-task (new Task 'udp-receive (lambda (task)
                                                    (receive-loop self task))
                                priority: udp-priority))
        (start-task receive-task)
        (set! state-task (new Task 'udp-state (lambda (task)
                                                (state-loop self task))
                              priority: udp-priority))
        (start-task state-task))
      (set! last-received-ack (current-seconds))
      (set! throttle-media? #f)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (exit-thread (get-thread receive-task))
      (thread-join! (get-thread receive-task))
      (set! receive-task #f)
      (thread-send (get-thread state-task) #t)
      (thread-join! (get-thread state-task))
      (set! state-task #f)
      (set! started? #f)))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (/= origin client-no)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (register-send-channel self sender name channel-no media-kind source-kind resolution framerate bitrate codec)
    (let ((channel (new UDP-Send-Channel sender name channel-no client-no media-kind source-kind resolution framerate bitrate codec)))
      (table-set! send-channels channel-no channel)
      channel))
  
  
  (method package (close-send-channel self channel-no)
    (let ((channel (table-ref send-channels channel-no #f)))
      (close channel)
      (unregister-channel (current-client) channel-no)
      (table-clear send-channels channel-no)))
  
  
  (method package (close-send-channels self)
    (iterate-table-safe send-channels
      (lambda (channel-no channel)
        (close-send-channel self channel-no))))
  
  
  (method public (find-receive-channel self channel-no)
    (table-ref receive-channels channel-no #f))
  
  
  (method public (find-receive-channels self name)
    (let ((audio #f)
          (video #f))
      (iterate-table receive-channels
        (lambda (channel-no channel)
          (when (equal? (get-name channel) name)
            (ecase (get-media-kind channel)
              ((udp-audio) (set! audio channel))
              ((udp-video) (set! video channel))))))
      (values audio video)))
  
  
  (method protected (find-receive-audio-channel self origin name)
    (continuation-capture
      (lambda (return)
        (iterate-table receive-channels
          (lambda (no channel)
            (when (and (= (get-origin channel) origin)
                       (equal? (get-name channel) name)
                       (= (get-media-kind channel) udp-audio))
              (continuation-return return channel))))
        #f)))
  
  
  (method protected (find-receive-video-channel self origin name)
    (continuation-capture
      (lambda (return)
        (iterate-table receive-channels
          (lambda (no channel)
            (when (and (= (get-origin channel) origin)
                       (equal? (get-name channel) name)
                       (= (get-media-kind channel) udp-video))
              (continuation-return return channel))))
        #f)))
  
  
  (method package (register-receive-channel self sender name channel-no origin media-kind source-kind resolution framerate bitrate codec)
    (let ((channel (new UDP-Receive-Channel sender name channel-no origin media-kind source-kind resolution framerate bitrate codec)))
      (table-set! receive-channels channel-no channel)
      channel))
  
  
  (method package (close-receive-channel self channel-no)
    (let ((channel (table-ref receive-channels channel-no #f)))
      (close channel)
      (let ((kind (get-media-kind channel)))
        (ecase kind
          ((udp-audio)
           (let ((audio (current-audio))
                 (id channel-no))
             (let ((output (find-output audio id)))
               (when output
                 (close-output audio id output)))))
          ((udp-video)
           (let ((video (current-video))
                 (id channel-no))
             (let ((output (find-output video id)))
               (when output
                 (close-output video id output)))))))
      (table-clear receive-channels channel-no)))
  
  
  (method package (close-receive-channels self)
    (iterate-table-safe receive-channels
      (lambda (channel-no channel)
        (close-receive-channel self channel-no))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method package (send-media self channel-no buffer header? timestamp duration)
    (mutex-lock! write-mutex)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((kind (get-media-kind channel)))
          (define (send)
            (send-media channel buffer header? timestamp duration
              (lambda (data)
                (send-data self data))))
          
          (if (simulation?)
              (send)
            (if throttle-media?
                ;; advance frame
                (let ((frame (next-frame-sequence! channel)))
                  (record-event udp-id-throttle-frame
                                (fixnum->flonum channel-no)
                                (fixnum->flonum client-no)
                                (fixnum->flonum kind)
                                -1.
                                (fixnum->flonum frame)
                                -1.
                                -1.))
              (let ((now (current-seconds)))
                (if (and udp-throttle (> (- now last-received-ack) udp-throttle))
                    (begin
                      (set! throttle-media? #t)
                      (record-event udp-id-throttle-on
                                    (fixnum->flonum channel-no)
                                    (fixnum->flonum server-no)
                                    -1.
                                    -1.
                                    -1.
                                    -1.
                                    -1.)
                      (when udp-show-throttle?
                        (format :terminal "{s} {s} {s}{%}" remote-name 'THROTTLE 'ON)))
                  (send))))))))
    (mutex-unlock! write-mutex))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       (udp-destination-set! server-host server-port udp-port)
       (retrying-write data udp-port)
       (increase! packets-sent))
      ((peer)
       (iterate-table peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (retrying-write data udp-port)))))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (state-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((end? (thread-receive udp-state-period #f)))
            (if end?
                (continuation-return exit #f)
              (site (udp-state on?: #t)
                (send-state self))
              (loop)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (when udp-record-read/write?
                  (let ((channel (read-udp-channel data))
                        (origin (read-udp-origin data))
                        (media-kind (read-udp-kind data))
                        (sequence (read-udp-sequence data))
                        (frame (read-udp-frame data)))
                    (record-event udp-id-read-data
                                  (fixnum->flonum channel)
                                  (fixnum->flonum origin)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum frame)
                                  -1.
                                  (fixnum->flonum (u8vector-length data)))))
                (receive-data self data))
              (loop)))))))
  
  
  (method (receive-data self data)
    (increase! packets-received)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-connected))
        ((udp-state)
         (receive-state self data))
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-state self data)
    (let ((states (u8vector->object (read-udp-state-channels data))))
      (for-each (lambda (info)
                  (bind (channel-no client-state) info
                    (let ((channel (find-send-channel self channel-no)))
                      (when (and channel (eq? client-state 'waiting))
                        (reset-media channel)))))
                states)))
  
  
  (method (receive-ack self data)
    (let ((now (current-seconds)))
      ;; throttling
      (set! last-received-ack now)
      (when throttle-media?
        (set! throttle-media? #f)
        ;; force camera reset
        ;; (maybe-reset-media self server-no udp-video #f)
        (record-event udp-id-throttle-off
                      -1.
                      (fixnum->flonum server-no)
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.)
        (when udp-show-throttle?
          (format :terminal "{s} {s} {s}{%}" remote-name 'THROTTLE 'OFF)))
      ;; statistics
      (let ((round-trip (- now (read-udp-sent data)))
            (server-sent (read-udp-ack-packets-sent data))
            (server-received (read-udp-ack-packets-received data)))
        (let ((fresh-packets-sent (- packets-sent last-packets-sent))
              (fresh-packets-received (- packets-received last-packets-received))
              (fresh-server-sent (- server-sent last-server-sent))
              (fresh-server-received (- server-received last-server-received)))
          (define (fresh-traffic-rate)
            (if (not last-traffic-time)
                (begin
                  (set! last-traffic-time now)
                  -1.)
              (increase! last-traffic-count (+ fresh-packets-sent fresh-packets-received))
              (let ((elapse (- now last-traffic-time)))
                ;; best try to smooth the jaggies that I think arise
                ;; from the audio / video frequency, the right solution
                ;; probably being to smooth all this in the graph
                (if (>= elapse .2)
                    (let ((rate (/ (cast <fl> last-traffic-count) elapse)))
                      (set! last-traffic-count 0)
                      (set! last-traffic-time now)
                      rate)
                  -1.))))
          
          (set! last-packets-sent packets-sent)
          (set! last-packets-received packets-received)
          (set! last-server-sent server-sent)
          (set! last-server-received server-received)
          (record-event udp-id-receive-ack
                        -1.
                        -1.
                        -1.
                        (fixnum->flonum (- fresh-packets-sent fresh-server-received))
                        (fixnum->flonum (- fresh-server-sent fresh-packets-received))
                        round-trip
                        -1.)
          (let ((traffic (fresh-traffic-rate)))
            (unless (= traffic -1.)
              (record-event udp-id-traffic-rate
                            -1.
                            -1.
                            -1.
                            -1.
                            -1.
                            -1.
                            traffic))))
        (let ((outgoing-dropped (- packets-sent server-received))
              (incoming-dropped (- server-sent packets-received)))
          (set! outgoing-drop (and (> packets-sent 0) (percentage outgoing-dropped packets-sent)))
          (set! incoming-drop (and (> server-sent 0) (percentage incoming-dropped server-sent)))))))
  
  
  (method (receive-nack self data)
    (let ((channel-no (read-udp-channel data))
          (origin (read-udp-origin data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-missing data))))
      (send-missing self channel-no origin media-kind missing)))
  
  
  (method protected (receive-media self kind data)
    (let ((channel-no (read-udp-channel data))
          (origin (read-udp-origin data)))
      (let ((channel (find-receive-channel self channel-no)))
        (when channel
          (remember-media channel data)
          (insert-media channel data)
          (let ((frame (read-udp-frame data))
                (last-nacked-frame (get-last-nacked-frame channel)))
            (when (or (not last-nacked-frame)
                      (> frame last-nacked-frame))
              (send-nacks self channel-no origin kind channel)
              (set-last-nacked-frame channel frame)))))))
  
  
  (method protected (send-nacks self channel-no origin kind channel)
    (unless (simulation?)
      (let ((missing (collect-missing channel)))
        (unless (null? missing)
          (send-nack self channel-no origin kind missing)))))
  
  
  (method (send-missing self channel-no origin media-kind missing)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((ring (get-retain-ring channel)))
          (for-each (lambda (sequence)
                      (let ((data (locate-data ring sequence)))
                        (if data
                            (begin
                              (increase-udp-resent data)
                              (send-data self data)
                              (let ((frame (read-udp-frame data)))
                                (record-event udp-id-resend-packet
                                              (fixnum->flonum channel-no)
                                              (fixnum->flonum origin)
                                              (fixnum->flonum media-kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              -1.
                                              -1.)))
                          (record-event udp-id-absent-packet
                                        (fixnum->flonum channel-no)
                                        (fixnum->flonum origin)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        -1.
                                        -1.
                                        -1.)
                          (when udp-show-nacks?
                            (terminal remote-name (present-media-kind media-kind) '***nack-missing*** sequence)))))
                    missing)))))
  
  
  (method (send-state self)
    (let ((self? #f))
      (define (collect-states)
        (let ((queue (new-queue)))
          (iterate-table receive-channels
            (lambda (key channel)
              (when (= (get-origin channel) client-no)
                (set! self? #t))
              (let ((state (get-state (get-process-ring channel))))
                (enqueue queue
                         (list (get-no channel)
                               state)))))
          (queue-list queue)))
      
      (let ((states (collect-states)))
        (mutex-lock! write-mutex)
        (let ((states (object->u8vector states)))
          (let ((size (+ 8 4 4 4 4 (u8vector-length states))))
            (let ((data (make-u8vector size)))
              (write-udp-sent data (current-seconds))
              (write-udp-kind data udp-state)
              (write-udp-origin data client-no)
              (write-udp-state-self? data self?)
              (write-udp-state-channels data states)
              (send-data self data))))
        (mutex-unlock! write-mutex))))
  
  
  (method (send-nack self channel-no origin media-kind missing)
    (when udp-show-nacks?
      (terminal remote-name (present-media-kind media-kind) '***send-nack*** missing))
    (mutex-lock! write-mutex)
    (let ((missing-vector (object->u8vector missing)))
      (let ((size (+ 8 4 4 4 4 (u8vector-length missing-vector))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-origin data origin)
          (write-udp-channel data channel-no)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-missing data missing-vector)
          (send-data self data))))
    (mutex-unlock! write-mutex))
  
  
  ;;;
  ;;;; Replay
  ;;;
  
  
  (method protected (gather-replay-missing self missing)
    '()
    @CONVERT
    (let ((queue (new-queue)))
      (for-each (lambda (info)
                  (bind (origin media-kind missing) info
                    (when (= origin client-no)
                      (let ((channel (find-send-channel self -1 media-kind)))
                        (when channel
                          (let ((ring (get-replay-ring channel)))
                            (for-each (lambda (sequence)
                                        (let ((packet (locate-packet ring sequence)))
                                          (when packet
                                            (enqueue queue (get-data packet)))))
                                      missing)))))))
                missing)
      (queue-list queue))))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot process-ring      getter generate)
  (slot process-task      getter generate)
  (slot process-average   getter generate)
  (slot last-nacked-frame accessors generate)
  (slot replay-ring       getter generate)
  (slot replay-header     getter generate)
  (slot processed         getter generate)
  (slot missing           getter generate)
  
  
  (method override (initialize self sender name no origin media-kind source-kind resolution framerate bitrate codec)
    (nextmethod self sender name no origin media-kind source-kind resolution framerate bitrate codec)
    (set! self.last-nacked-frame #f)
    (set! self.replay-ring (new Remember-Ring 6000))
    (set! self.replay-header #f)
    (set! self.process-ring (new UDP-Ring self no origin media-kind udp-process-size max-size: udp-process-max-size state-proc: (state-callback no media-kind) overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
    (unless (simulation?)
      (set! self.process-task (new Task 'udp-process (lambda (task)
                                                       (process-loop self task))
                                   priority: udp-priority)))
    (set! self.process-average (new Average .05 1.))
    (set! self.processed 0)
    (set! self.missing 0)
    (unless (simulation?)
      (start-task process-task)))
  
  
  (method override (destroy self)
    (terminate process-ring)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (collect-missing self)
    (let ((missing (new-queue)))
      (iterate-latest process-ring
        (lambda (packet)
          (when (not (get-data packet))
            (enqueue missing (get-sequence packet)))))
      (queue-list missing)))
  
  
  (method protected (count-missing self)
    (let ((count 0))
      (iterate-latest process-ring
        (lambda (packet)
          (when (not (get-data packet))
            (increase! count))))
      count))
  
  
  (method protected (remember-media self data)
    (remember replay-ring data))
  
  
  (method protected (insert-media self data)
    (insert process-ring data))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-wait process-ring process-average)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site (udp-process on?: #t)
                (present-frame self info))
              (looping)))))))
  
  
  (method protected (present-frame self datas)
    (define (record-play-frame origin frame header? timestamp)
      (record-event udp-id-play-frame
                    (fixnum->flonum no)
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (barbara-header-hack header?)
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (define (record-freeze-frame origin frame header? timestamp)
      (record-event udp-id-freeze-frame
                    (fixnum->flonum no)
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (barbara-header-hack header?)
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (let ((count (length datas))
          (first (car datas)))
      (increase! processed count)
      (let ((kind (read-udp-kind first))
            (origin (read-udp-origin first))
            (channel-no (read-udp-channel first))
            (frame (read-udp-frame first))
            (total (read-udp-total first))
            (timestamp (read-udp-media-timestamp first))
            (duration (read-udp-media-duration first))
            (header? (read-udp-media-header? first))
            (off? (read-udp-media-off? first)))
        (define (process-audio)
          (let ((buffer (assemble-chunks)))
            (if off?
                (receive-audio (current-audio) channel-no #f #f #f)
              (if (and header? (eq? audio-codec 'vorbis))
                  (let ((headers (u8vector->object buffer)))
                    (set! replay-header buffer)
                    (for-each (lambda (header)
                                (bind (buffer timestamp duration) header
                                  ;; be very careful as timestamp is incorrect as it
                                  ;; is the timestamp at time the header was captured
                                  ;; this only works because gst_app_src_write_u8vector
                                  ;; doesn't actually use the timestamp
                                  (receive-audio (current-audio) channel-no buffer timestamp duration)))
                              headers))
                (receive-audio (current-audio) channel-no buffer timestamp duration))
              (record-play-frame origin frame header? timestamp))))
        
        (define (process-video)
          (let ((buffer (assemble-chunks)))
            (if off?
                (receive-video (current-video) channel-no #f #f #f)
              (receive-video (current-video) channel-no buffer timestamp duration)
              (if (eq? (get-state process-ring) 'late)
                  (record-freeze-frame origin frame header? timestamp)
                (record-play-frame origin frame header? timestamp)))))
        
        (define (assemble-chunks)
          (if (= total 1)
              (read-udp-media-payload first)
            (let ((chunks (map read-udp-media-payload datas)))
              (apply u8vector-append chunks))))
        
        (ecase kind
          ((udp-audio)
           (process-audio))
          ((udp-video)
           (process-video))))))))
