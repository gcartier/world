;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.network)
        (jazz.presence)
        (jazz.syntax (phase syntax))
        (world)
        (world.configure)
        (world.context)
        (world.evolution)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.udp))


(definition udp-video-action
  (world-setting 'world.udp-video-action #f))

(definition udp-video-file
  {File Home "video.mpj"})

(definition udp-video-port
  #f)


(class UDP-Client extends Object
  
  
  (slot udp-port         initialize #f getter generate)
  (slot udp-task         initialize #f getter generate)
  (slot udp-stopping?    initialize #f getter generate)
  (slot write-mutex      initialize #f getter generate)
  (slot send-channels    initialize #f getter generate)
  (slot receive-channels initialize #f getter generate)
  
  
  (method (connect self client-no local-host host service)
    (define (send-connect)
      (mutex-lock! write-mutex)
      (let ((data (make-u8vector 8)))
        (write-udp-kind data udp-connect)
        (write-udp-origin data client-no)
        (write data udp-port))
      (mutex-unlock! write-mutex))
    
    (set! udp-port (open-udp (list
                               local-address: local-host
                               address: host
                               port-number: service)))
    (set! udp-task (new Task 'udp-receive (lambda (task)
                                            (receive-loop self task))
                        priority: udp-priority))
    (set! udp-stopping? #f)
    (set! write-mutex (make-mutex 'write))
    (set! send-channels (make-table))
    (set! receive-channels (make-table))
    (record-event udp-id-connect
                  0.
                  0.
                  0.)
    (send-connect)
    (let ((data (read udp-port)))
      (assert (equal? data udp-connected)
        (record-event udp-id-connected
                      0.
                      0.
                      0.)))
    (start-task udp-task))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (thread-join! (get-thread udp-task))
    (set! udp-port #f)
    (set! udp-task #f))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method (require-send-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref send-channels key #f)
          (let ((channel (new UDP-Client-Send-Channel origin media-kind)))
            (table-set! send-channels key channel)
            channel))))
  
  
  (method (require-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref receive-channels key #f)
          (let ((channel (new UDP-Client-Receive-Channel origin media-kind self)))
            (table-set! receive-channels key channel)
            channel))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method (send-audio self buffer timestamp duration)
    (send-media self udp-audio buffer timestamp duration))
  
  
  (method (send-video self buffer timestamp duration)
    (send-media self udp-video buffer timestamp duration))
  
  
  (method (send-media self kind buffer timestamp duration)
    (mutex-lock! write-mutex)
    (let ((origin (get-client-no (current-tier))))
      (when udp-video-action
        (let ((key (cons origin kind)))
          (cond ((and buffer (not (table-ref send-channels key #f)))
                 (set! udp-video-port (case udp-video-action
                                        ((record)
                                         (open-output-file (path-settings udp-video-file)))
                                        ((play)
                                         (open-input-file (path-settings udp-video-file))))))
                ((and (not buffer) (table-ref send-channels key #f))
                 (when udp-video-port
                   (close-port udp-video-port)
                   (set! udp-video-port #f))))))
      (let ((channel (require-send-channel self origin kind)))
        ;; quick hack to give media off a timestamp
        (let ((last-timestamp (or (get-last-timestamp channel) 0)))
          (let ((off? (not buffer))
                (frame (next-frame-sequence! channel))
                (timestamp (or timestamp (+ last-timestamp 1)))
                (duration (or duration 1))
                (buffer (or buffer udp-media-off)))
            (set-last-timestamp channel timestamp)
            (let ((header-size (+ 4 4 4 4 4 4 8 8 4))
                  (payload-size (u8vector-length buffer)))
              (let ((max-content-size (- udp-datagram-max header-size)))
                (let ((total (fxceiling/ payload-size max-content-size)))
                  (let (loop (part 0) (pos 0))
                    (let ((remain (- payload-size pos)))
                      (when (> remain 0)
                        (let ((sequence (next-data-sequence! channel))
                              (content-size (min remain max-content-size)))
                          (let ((size (+ header-size content-size)))
                            (let ((data (make-u8vector size)))
                              (write-udp-kind data kind)
                              (write-udp-origin data origin)
                              (write-udp-sequence data sequence)
                              (write-udp-frame data frame)
                              (write-udp-part data part)
                              (write-udp-total data total)
                              (write-udp-timestamp data timestamp)
                              (write-udp-duration data duration)
                              (write-udp-subpayload data buffer pos content-size)
                              (when udp-video-port
                                (case udp-video-action
                                  ((record)
                                   (write data udp-video-port)
                                   (newline udp-video-port)
                                   (force-output udp-video-port))
                                  ((play)
                                   (let ((obj (read udp-video-port)))
                                     (unless (eof-object? obj)
                                       (set! data obj))))))
                              (when (or (not udp-drop-percentage)
                                        (> (random-real) (/ udp-drop-percentage 100.)))
                                (write data udp-port))
                              (retain channel data)
                              (record-event udp-id-send-media
                                            (fixnum->flonum kind)
                                            (fixnum->flonum sequence)
                                            (if off? 0. 1.))
                              (loop (+ part 1) (+ pos content-size)))))))))))))))
    (mutex-unlock! write-mutex))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (receive-data self data))
              (loop)))))))
  
  
  (method (receive-data self data)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-ack self data)
    (let ((media-kind (read-udp-media-kind data))
          (sequence (read-udp-sequence data)))
      (record-event udp-id-receive-ack
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    0.)))
  
  
  (method (receive-nack self data)
    (let ((origin (read-udp-origin data))
          (media-kind (read-udp-media-kind data))
          (sequence (read-udp-sequence data)))
      (let ((channel (require-send-channel self origin media-kind)))
        (let ((ring (get-retain-ring channel)))
          (let ((found (locate ring (lambda (data)
                                      (= (read-udp-sequence data) sequence)))))
            (record-event udp-id-receive-nack
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (if found 1. 0.))
            (if found
                (write found udp-port)
              (when udp-debug-nack?
                (terminal remote-name (udp-name media-kind) '***nack-missing*** sequence))))))))
  
  
  (method (receive-media self kind data)
    (let ((origin (read-udp-origin data))
          (sequence (read-udp-sequence data)))
      (let ((channel (require-receive-channel self origin kind)))
        (unless (member? sequence (get-nack-sequences channel))
          (let ((last-sequence (get-receive-last-sequence channel)))
            (when last-sequence
              (let ((expected (+ last-sequence 1)))
                (when (> sequence expected)
                  (loop (for seq from expected below sequence)
                        (send-nack self origin seq kind)
                        (set-nack-sequences channel (cons seq (get-nack-sequences channel))))))))
          (set-receive-last-sequence channel sequence))
        (insert-media channel data))))
  
  
  (method protected (send-ack self origin sequence media-kind)
    (mutex-lock! write-mutex)
    (let ((size (+ 4 4 4 4)))
      (let ((data (make-u8vector size)))
        (write-udp-kind data udp-ack)
        (write-udp-origin data origin)
        (write-udp-sequence data sequence)
        (write-udp-media-kind data media-kind)
        (write data udp-port)))
    (mutex-unlock! write-mutex))
  
  
  (method (send-nack self origin sequence media-kind)
    (when udp-debug-nack?
      (terminal remote-name (udp-name media-kind) 'send-nack sequence))
    (mutex-lock! write-mutex)
    (let ((size (+ 4 4 4 4)))
      (let ((data (make-u8vector size)))
        (write-udp-kind data udp-nack)
        (write-udp-origin data origin)
        (write-udp-sequence data sequence)
        (write-udp-media-kind data media-kind)
        (write data udp-port)))
    (mutex-unlock! write-mutex)))


;;;
;;;; Send Channel
;;;


(class UDP-Client-Send-Channel extends UDP-Send-Channel
  
  
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-timestamp accessors generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self origin media-kind)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence))))


;;;
;;;; Receive Channel
;;;


(class UDP-Client-Receive-Channel extends UDP-Receive-Channel
  
  
  (slot client                getter generate)
  (slot process-last-sequence getter generate)
  (slot process-ring          getter generate)
  (slot process-task          getter generate)
  
  
  (method override (initialize self origin media-kind client)
    (nextmethod self origin media-kind)
    (set! self.client client)
    (set! self.process-last-sequence #f)
    ;; make it really big until time ring is a real ring
    (set! self.process-ring (new Time-Ring 40096 @w 512 @max-size: +inf.0 timestamp-proc: read-udp-timestamp now-proc: (~ now-timestamp self)))
    ;; development
    (set-$c self)
    (set-$r process-ring)
    (set! self.process-task (new Task 'udp-process (lambda (task)
                                                     (process-loop self task))
                                 priority: udp-priority))
    (start-task process-task))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected (insert-nack self data)
    )
  
  
  (method protected (insert-media self data)
    (insert-data self data))
  
  
  (method protected (insert-data self data)
    (let ((sequence (read-udp-sequence data)))
      (let ((nack? (member? sequence nack-sequences)))
        (when (and udp-debug-nack? nack?)
          (terminal remote-name (udp-name media-kind) 'insert-resent sequence))
        (unless nack?
          (update-time self data))
        (let ((inserted? (insert process-ring data)))
          (when (and udp-show-discard? (not inserted?))
            (let ((kind (read-udp-kind data))
                  (sequence (read-udp-sequence data)))
              (when (and nack? video-self?)
                (record-event udp-id-discard-resent
                              (fixnum->flonum media-kind)
                              (fixnum->flonum sequence)
                              0.))
              (let ((label (if nack? '***discard-resent*** '***discard***)))
                (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name kind) label sequence))))))))
  
  
  (method protected (wait-data self)
    (wait process-ring))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((lst (wait-data self)))
            (site (udp-process on?: #t)
              (process-missing self lst)
              (for-each (lambda (partition)
                          (bind (frame . datas) partition
                            (let ((unique-datas (remove-duplicates datas key: read-udp-sequence)))
                              (when (and udp-show-duplicates? (> (length datas) (length unique-datas)))
                                (let ((duplicates (difference datas unique-datas)))
                                  (format :terminal "{s} {s} {s} {l}{%}" remote-name (udp-name media-kind) '***received-duplicates*** (map read-udp-sequence duplicates))))
                              (process-frame self (sort < unique-datas key: read-udp-sequence)))))
                        (sort < (partition lst key: read-udp-frame) key: car))))
          (loop)))))
  
  
  (method (process-missing self lst)
    (let ((sorted (sort < lst key: read-udp-sequence)))
      (for-each (lambda (data)
                  (let ((sequence (read-udp-sequence data)))
                    (when (and udp-show-missing? process-last-sequence)
                      (let ((expected (+ process-last-sequence 1)))
                        (when (/= sequence expected)
                          (loop (for seq from expected below sequence)
                                (let ((nack? (member? seq nack-sequences)))
                                  (when (and nack? video-self?)
                                    (record-event udp-id-missing-resent
                                                  (fixnum->flonum media-kind)
                                                  (fixnum->flonum seq)
                                                  0.))
                                  (let ((label (if nack? '***missing-resent*** '***missing***)))
                                    (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name media-kind) label seq)))))))
                    (set! process-last-sequence sequence)))
                sorted)))
  
  
  (method (process-frame self datas)
    (let ((received (length datas))
          (first (car datas)))
      (let ((kind (read-udp-kind first))
            (origin (read-udp-origin first))
            (sequence (read-udp-sequence first))
            (frame (read-udp-frame first))
            (part (read-udp-part first))
            (total (read-udp-total first))
            (timestamp (read-udp-timestamp first))
            (duration (read-udp-duration first)))
        (if (= total received)
            (if (= total 1)
                (process-data self kind origin sequence frame timestamp duration (read-udp-payload first))
              (let ((chunks (map read-udp-payload datas)))
                (let ((data (apply u8vector-append chunks)))
                  (process-data self kind origin sequence frame timestamp duration data))))
          @reported-by-process-missing
          (let ((missing (difference (naturals sequence (+ sequence total)) (map read-udp-sequence datas))))
            (format :terminal "{s} {s} {s} {s} {l}{%}" remote-name (udp-name kind) '***partial-frame*** 'missing missing))))))
  
  
  (method (process-data self kind origin sequence frame timestamp duration buffer)
    (define (player-no->id no)
      (get-id (find-player-by-no no)))
    
    (define (process-audio)
      (if (equal? buffer udp-media-off)
          (receive-server-audio (current-audio) (player-no->id origin) #f #f #f)
        (receive-server-audio (current-audio) (player-no->id origin) buffer timestamp duration)))
    
    (define (process-video)
      (if (equal? buffer udp-media-off)
          (receive-server-video (current-video) (player-no->id origin) #f #f #f)
        (receive-server-video (current-video) (player-no->id origin) buffer timestamp duration)))
    
    ;; sending ack by frame seems a reasonable approach to
    ;; complement nacks that get sent when parts are missing
    (send-ack client origin sequence kind)
    (ecase kind
      ((udp-audio)
       (process-audio))
      ((udp-video)
       (process-video))))))
