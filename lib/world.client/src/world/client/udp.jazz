;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.math)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.audio)
        (world.configure)
        (world.context)
        (world.event)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.udp)
        (world.video))


(definition record-output?
  (world-setting 'world.record-output? #f))

(definition recordings
  (make-table))


(definition udp-video-action
  (world-setting 'world.udp-video-action #f))

(definition udp-video-file
  {File Settings "captures" "video.mpj"})

(definition udp-video-port
  #f)


(class UDP-Client extends Object
  
  
  (slot client-no           initialize #f getter generate)
  (slot udp-port            initialize #f getter generate)
  (slot udp-stopping?       initialize #f getter generate)
  (slot local-host          initialize #f getter generate)
  (slot local-port          initialize #f getter generate)
  (slot server-host         initialize #f getter generate)
  (slot server-port         initialize #f getter generate)
  (slot write-mutex         initialize #f getter generate)
  (slot send-channels       initialize #f getter generate)
  (slot receive-channels    initialize #f getter generate)
  (slot receive-task        initialize #f getter generate)
  (slot state-task          initialize #f getter generate)
  (slot started?            initialize #f getter generate)
  (slot packets-sent        initialize 0  getter generate)
  (slot packets-received    initialize 0  getter generate)
  (slot client-drop         initialize 0  getter generate)
  (slot server-drop         initialize 0  getter generate)
  (slot ack-count           initialize 0  getter generate)
  (slot last-received-state initialize #f getter generate)
  (slot throttle-media?     initialize #f getter generate)
  (slot camera-resetting    initialize #f getter generate)
  (slot topology            initialize #f getter generate)
  (slot peers               initialize #f getter generate)
  (slot peers-mutex         initialize #f getter generate)
  (slot simulator           initialize #f getter generate)
  
  
  (method override (initialize self client-no)
    (nextmethod self)
    (set! self.client-no client-no))
  
  
  (method (connect self local-host host service)
    ;; quick heuristic
    (define (determine-local-address)
      (if local?
          #u8(127 0 0 1)
        (let ((info (host-info (host-name))))
          (let ((addresses (host-info-addresses info)))
            (if (= 1 (length addresses))
                (car addresses)
              #u8(0 0 0 0))))))
    
    (set! udp-port (open-udp (list
                               local-address: local-host
                               address: host
                               port-number: service)))
    (set! udp-stopping? #f)
    (let ((local-host (determine-local-address))
          (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (mutex-lock! write-mutex)
        (let ((data (make-u8vector (+ 8 4 4 4 4 4 4 4))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-connect)
          (write-udp-origin data client-no)
          (write-udp-connect-local-host data local-host)
          (write-udp-connect-local-port data local-port)
          (write-udp-connect-latency data (or udp-latency -1.))
          (write-udp-connect-lag data (or udp-lag -1.))
          (write-udp-connect-drop data (or udp-drop -1.))
          (retrying-write data udp-port))
        (mutex-unlock! write-mutex))
      
      (set! self.local-host local-host)
      (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! write-mutex (make-mutex 'write))
      (set! send-channels (make-table))
      (set! receive-channels (make-table))
      (set! packets-sent 0)
      (set! packets-received 0)
      (set! client-drop 0)
      (set! server-drop 0)
      (set! camera-resetting #f)
      (set! topology (world-setting 'world.udp-topology 'server))
      (set! peers (make-table))
      (set! peers-mutex (make-mutex 'peers))
      (set! simulator (if (or udp-latency udp-lag udp-drop udp-congestion)
                          (new UDP-Simulator udp-latency udp-lag udp-drop
                               (lambda (data drop?)
                                 (if drop?
                                     (increase! packets-sent)
                                   @fix-me-can-deadlock-the-threads
                                   (mutex-lock! write-mutex)
                                   (send-topology self data)
                                   @fix-me-can-deadlock-the-threads
                                   (mutex-unlock! write-mutex))))
                        #f))
      (record-event udp-id-connect
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.)
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (if (or (eof-object? reply) (not (= (read-udp-kind reply) udp-connected)))
                (if (>= n 100)
                    (begin
                      (terminal 'BAILOUT 'did 'not 'receive 'udp-connected)
                      (exit 1))
                  (loop (+ n 1)))
              (let ((source-info (udp-source-socket-info udp-port)))
                (set! server-host (socket-info-address source-info))
                (set! server-port (socket-info-port-number source-info)))
              (let ((round-trip (- (current-seconds) (read-udp-sent reply))))
                (record-event udp-id-connected
                              -1.
                              -1.
                              -1.
                              -1.
                              round-trip
                              -1.)
                (when udp-show-roundtrip?
                  (format :terminal "{s} {s} {s}{%}" remote-name '***roundtrip*** round-trip)))))))))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (set! receive-task (new Task 'udp-receive (lambda (task)
                                                  (receive-loop self task))
                              priority: udp-priority))
      (start-task receive-task)
      (set! state-task (new Task 'udp-state (lambda (task)
                                              (state-loop self task))
                            priority: udp-priority))
      (start-task state-task)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (exit-thread (get-thread receive-task))
      (thread-join! (get-thread receive-task))
      (set! receive-task #f)
      (thread-send (get-thread state-task) #t)
      (thread-join! (get-thread state-task))
      (set! state-task #f)
      (set! started? #f)))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (or (/= origin client-no)
                                  audio-self?
                                  video-self?)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method public (find-send-channel self media-kind)
    (let ((key media-kind))
      (table-ref send-channels key #f)))
  
  
  (method package (require-send-channel self media-kind)
    (let ((key media-kind))
      (or (table-ref send-channels key #f)
          (let ((channel (new UDP-Send-Channel media-kind)))
            (table-set! send-channels key channel)
            channel))))
  
  
  (method package (close-send-channel self media-kind)
    (let ((key media-kind))
      (let ((channel (table-ref send-channels key #f)))
        (close channel)
        (table-clear send-channels key))))
  
  
  (method package (close-send-channels self)
    (iterate-table-safe send-channels
      (lambda (media-kind channel)
        (close-send-channel self media-kind))))
  
  
  (method public (find-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (table-ref receive-channels key #f)))
  
  
  (method package (require-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref receive-channels key #f)
          (let ((channel (new UDP-Receive-Channel origin media-kind)))
            (table-set! receive-channels key channel)
            channel))))
  
  
  (method package (close-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (let ((channel (table-ref receive-channels key #f)))
        (close channel)
        (table-clear receive-channels key))))
  
  
  (method package (close-receive-channels self)
    (iterate-table-safe receive-channels
      (lambda (key channel)
        (bind (origin . media-kind) key
          (close-receive-channel self origin media-kind)))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method (send-audio self buffer header? timestamp duration)
    (send-media self udp-audio buffer header? timestamp duration))
  
  
  (method (send-video self buffer header? timestamp duration)
    (send-media self udp-video buffer header? timestamp duration))
  
  
  (method (send-media self kind buffer header? timestamp duration)
    (mutex-lock! write-mutex)
    (let ((channel (find-send-channel self kind)))
      (when channel
        (let ()
          (define (send)
            (when udp-video-action
              (let ((key kind))
                (cond ((and buffer (not (table-ref send-channels key #f)))
                       (set! udp-video-port (case udp-video-action
                                              ((record)
                                               (create-directories udp-video-file)
                                               (open-output-file (path-settings udp-video-file)))
                                              ((play)
                                               (open-input-file (path-settings udp-video-file))))))
                      ((and (not buffer) (table-ref send-channels key #f))
                       (when udp-video-port
                         (close-port udp-video-port)
                         (set! udp-video-port #f))))))
            (let ((off? (not buffer))
                  (frame (next-frame-sequence! channel))
                  ;; give media off and resent header a sequential timestamp so it gets inserted correctly
                  (timestamp (or timestamp (+ (or (get-last-timestamp channel) 0) 1)))
                  (duration (or duration 1))
                  ;; udp-media-off is not really used for its content anymore
                  ;; but it is still useful as an empty buffer ends the logic
                  (buffer (or buffer udp-media-off)))
              ;; -1 means no timestamp used by vorbis header
              (unless (= timestamp -1)
                (set-last-timestamp channel timestamp))
              (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4))
                    (payload-size (u8vector-length buffer)))
                (let ((max-content-size (- udp-datagram-max header-size)))
                  (let ((total (fxceiling/ payload-size max-content-size)))
                    (let (loop-part (part 0) (pos 0))
                      (let ((remain (- payload-size pos)))
                        (when (> remain 0)
                          (let ((sequence (next-data-sequence! channel))
                                (content-size (min remain max-content-size)))
                            (let ((size (+ header-size content-size)))
                              (let ((data (make-u8vector size)))
                                (write-udp-sent data (current-seconds))
                                (write-udp-kind data kind)
                                (write-udp-origin data client-no)
                                (write-udp-sequence data sequence)
                                (write-udp-frame data frame)
                                (write-udp-part data part)
                                (write-udp-total data total)
                                (write-udp-media-timestamp data timestamp)
                                (write-udp-media-duration data duration)
                                (write-udp-media-subpayload data buffer pos content-size)
                                (write-udp-media-header? data header?)
                                (write-udp-media-off? data off?)
                                (when udp-video-port
                                  (case udp-video-action
                                    ((record)
                                     (write data udp-video-port)
                                     (newline udp-video-port)
                                     (force-output udp-video-port))
                                    ((play)
                                     (let ((obj (read udp-video-port)))
                                       (unless (eof-object? obj)
                                         (set! data obj))))))
                                ;; quick hack to make media off more robust
                                (if off?
                                    (loop (repeat 3)
                                          (send-data self data))
                                  (send-data self data))
                                (record-event udp-id-create-packet
                                              (fixnum->flonum client-no)
                                              (fixnum->flonum kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              -1.
                                              (if (= timestamp -1)
                                                  -1.
                                                (timestamp->flonum timestamp)))
                                (retain channel data)
                                (loop-part (+ part 1) (+ pos content-size)))))))))))))
          
          (when last-received-state
            (if throttle-media?
                ;; advance frame
                (let ((frame (next-frame-sequence! channel)))
                  (record-event udp-id-throttle-frame
                                (fixnum->flonum client-no)
                                (fixnum->flonum kind)
                                -1.
                                (fixnum->flonum frame)
                                -1.
                                -1.))
              (let ((now (current-seconds))
                    (throttle (if (= kind udp-audio) udp-audio-throttle udp-video-throttle)))
                (if (> (- now last-received-state) throttle)
                    (begin
                      (set! throttle-media? #t)
                      (record-event udp-id-throttle-on
                                    (fixnum->flonum client-no)
                                    (fixnum->flonum kind)
                                    -1.
                                    -1.
                                    -1.
                                    -1.)
                      (when udp-show-throttle?
                        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind kind) 'THROTTLE 'ON)))
                  (send))))))))
    (mutex-unlock! write-mutex))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       (udp-destination-set! server-host server-port udp-port)
       (retrying-write data udp-port)
       (increase! packets-sent))
      ((peer)
       (iterate-table peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (retrying-write data udp-port)))))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (state-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((end? (thread-receive udp-state-period #f)))
            (if end?
                (continuation-return exit #f)
              (site (udp-state on?: #t)
                (send-state self))
              (loop)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (when udp-record-read/write?
                  (let ((origin (read-udp-origin data))
                        (media-kind (read-udp-kind data))
                        (sequence (read-udp-sequence data))
                        (frame (read-udp-frame data)))
                    (record-event udp-id-read-data
                                  (fixnum->flonum origin)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum frame)
                                  -1.
                                  (fixnum->flonum (u8vector-length data)))))
                (receive-data self data))
              (loop)))))))
  
  
  (method (receive-data self data)
    (increase! packets-received)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-connected))
        ((udp-state)
         (receive-state self data))
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-state self data)
    (let ((states (u8vector->object (read-udp-state-channels data))))
      (for-each (lambda (info)
                  (bind (channel-origin media-kind client-state) info
                    (when (= channel-origin client-no)
                      ;; throttling
                      (set! last-received-state (current-seconds))
                      (when throttle-media?
                        (set! throttle-media? #f)
                        ;; force camera reset in the code below
                        (set! client-state 'waiting)
                        (record-event udp-id-throttle-off
                                      (fixnum->flonum channel-origin)
                                      (fixnum->flonum media-kind)
                                      -1.
                                      -1.
                                      -1.
                                      -1.)
                        (when udp-show-throttle?
                          (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'THROTTLE 'OFF)))
                      ;; waiting
                      (when (eq? client-state 'waiting)
                        (let ((channel (find-send-channel self media-kind)))
                          (when channel
                            (ecase media-kind
                              ((udp-audio)
                               ;; resend headers
                               (let ((audio (current-audio)))
                                 (when (audio-playing? audio)
                                   (when (eq? audio-codec 'vorbis)
                                     (let ((header (locate (get-retain-ring channel) media-packet-header?)))
                                       (if header
                                           (when udp-show-resetting?
                                             (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESEND 'AVOIDED (read-udp-sequence header)))
                                         (resend-mic-header audio)
                                         (record-event udp-id-reset-media
                                                       (fixnum->flonum channel-origin)
                                                       (fixnum->flonum media-kind)
                                                       -1.
                                                       -1.
                                                       -1.
                                                       -1.)
                                         (when udp-show-resets?
                                           (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESEND 'HEADERS))))))))
                              ((udp-video)
                               ;; camera reset
                               (let ((video (current-video)))
                                 (when (video-playing? video)
                                   (if (and camera-resetting
                                            (= camera-resetting (get-data-sequence channel)))
                                       (when udp-show-resetting?
                                         (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESET 'IN-PROGRESS))
                                     (let ((header (locate (get-retain-ring channel) media-packet-header?)))
                                       (if header
                                           (when udp-show-resetting?
                                             (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESET 'AVOIDED (read-udp-sequence header)))
                                         (reset-camera video)
                                         (let ((sequence (get-data-sequence channel)))
                                           (set! camera-resetting sequence)
                                           (record-event udp-id-reset-media
                                                         (fixnum->flonum channel-origin)
                                                         (fixnum->flonum media-kind)
                                                         -1.
                                                         -1.
                                                         -1.
                                                         -1.)
                                           (when udp-show-resets?
                                             (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESET sequence))))))))))))))))
                states)))
  
  
  (method (receive-ack self data)
    (let ((round-trip (- (current-seconds) (read-udp-sent data))))
      (when (and udp-show-roundtrip? (= (modulo ack-count 100) 0))
        (format :terminal "{s} {s} {s}{%}" remote-name '***roundtrip*** round-trip))
      (increase! ack-count)
      (record-event udp-id-receive-ack
                    -1.
                    -1.
                    -1.
                    -1.
                    round-trip
                    -1.))
    ;; adjust for server sending ack before increasing sent
    (let ((server-sent (+ (read-udp-ack-packets-sent data) 1))
          (server-received (read-udp-ack-packets-received data)))
      (let ((client-dropped (- packets-sent server-received))
            (server-dropped (- server-sent packets-received)))
        (set! client-drop (and (> packets-sent 0) (percentage client-dropped packets-sent)))
        (set! server-drop (and (> server-sent 0) (percentage server-dropped server-sent)))
        ;(set! packets-sent 0)
        ;(set! packets-received 0)
        )))
  
  
  (method (receive-nack self data)
    (let ((origin (read-udp-origin data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-latest-missing data))))
      (send-missing self origin media-kind missing)))
  
  
  (method (receive-media self kind data)
    (let ((origin (read-udp-origin data))
          (sequence (read-udp-sequence data)))
      (let ((channel (find-receive-channel self origin kind)))
        (when channel
          (let ((last-sequence (get-last-sequence channel)))
            (let ((in-order? (or (not last-sequence)
                                 (> sequence last-sequence)))
                  (now (current-seconds)))
              (if (not in-order?)
                  (begin
                    (remove-nack channel sequence)
                    (insert-media channel data now))
                ;; remember last sequence
                (set-last-sequence channel sequence)
                ;; insert media
                (when (insert-media channel data now)
                  ;; remember time information
                  (update-time channel sequence data now (get-process-ring channel))
                  ;; add nacks to list
                  (when last-sequence
                    (let ((expected (+ last-sequence 1)))
                      (when (> sequence expected)
                        (let ((seconds (current-seconds)))
                          (loop (for seq from expected below sequence)
                                (add-nack channel seconds seq sequence))))))
                  ;; send the lastest nacks
                  (let ((latest-missing (filter-latest-missing channel)))
                    (unless (null? latest-missing)
                      (send-nack self origin kind latest-missing)))))))))))
  
  
  (method (send-missing self origin media-kind missing)
    (let ((channel (find-send-channel self media-kind)))
      (when channel
        (let ((ring (get-retain-ring channel))
              (entries (get-retain-entries channel)))
          (for-each (lambda (sequence)
                      (let ((found (table-ref entries sequence #f) @old (locate ring (lambda (data)
                                                  (= (read-udp-sequence data) sequence)))))
                        (if found
                            (begin
                              (send-data self found)
                              (let ((frame (read-udp-frame found)))
                                (record-event udp-id-resend-packet
                                              (fixnum->flonum origin)
                                              (fixnum->flonum media-kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              -1.
                                              -1.)))
                          (record-event udp-id-absent-packet
                                        (fixnum->flonum origin)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        -1.
                                        -1.
                                        -1.)
                          (when udp-show-nacks?
                            (terminal remote-name (present-media-kind media-kind) '***nack-missing*** sequence)))))
                    missing)))))
  
  
  (method (send-state self)
    (define (collect-states)
      (let ((queue (new-queue)))
        (iterate-table receive-channels
          (lambda (key channel)
            (let ((state (get-process-state channel)))
              (enqueue queue
                       (list (get-origin channel)
                             (get-media-kind channel)
                             state)))))
        (queue-list queue)))
    
    (let ((states (collect-states)))
      (mutex-lock! write-mutex)
      (let ((states (object->u8vector states)))
        (let ((size (+ 8 4 4 4 (u8vector-length states))))
          (let ((data (make-u8vector size)))
            (write-udp-sent data (current-seconds))
            (write-udp-kind data udp-state)
            (write-udp-origin data client-no)
            (write-udp-state-channels data states)
            (send-data self data))))
      (mutex-unlock! write-mutex)))
  
  
  (method (send-nack self origin media-kind latest-missing)
    (when udp-show-nacks?
      (terminal remote-name (present-media-kind media-kind) '***send-nack*** latest-missing))
    (mutex-lock! write-mutex)
    (let ((missing (object->u8vector latest-missing)))
      (let ((size (+ 8 4 4 4 4 (u8vector-length missing))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-origin data origin)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-latest-missing data missing)
          (send-data self data))))
    (mutex-unlock! write-mutex)))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Channel
  
  
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-timestamp accessors generate)
  (slot retain-ring    getter generate)
  (slot retain-entries getter generate)
  (slot release-task   getter generate)
  
  
  (method override (initialize self media-kind)
    (nextmethod self media-kind)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f)
    (set! self.retain-ring (new Time-Ring udp-retain-size max-size: udp-retain-max-size overflow-proc: (udp-ring-overflow 'retain udp-ring-kind-retain)))
    (set! self.retain-entries (make-table test: eqv?))
    (set! self.release-task (new Task 'udp-release (lambda (task)
                                                     (release-loop self task))
                                 priority: udp-priority))
    (start-task release-task))
  
  
  (method override (destroy self)
    (insert-earliest retain-ring #f)
    (thread-join! (get-thread release-task))
    (nextmethod self))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (retain self data)
    (insert retain-ring (+ (current-seconds) udp-retain-window) data)
    (table-set! retain-entries (read-udp-sequence data) data)
    (let ((kind (read-udp-kind data)))
      (let ((origin (read-udp-origin data))
            (sequence (read-udp-sequence data))
            (frame (read-udp-frame data))
            (ring-size (get-count retain-ring))
            (timestamp (read-udp-media-timestamp data)))
        (record-event udp-id-retain-packet
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      (fixnum->flonum sequence)
                      (fixnum->flonum frame)
                      (fixnum->flonum ring-size)
                      (timestamp->flonum timestamp)))))
  
  
  (method protected (release-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (wait retain-ring)))
            (if (not data)
                (continuation-return exit #f)
              (site (udp-release on?: #t)
                (table-clear retain-entries (read-udp-sequence data))
                (let ((kind (read-udp-kind data)))
                  (let ((origin (read-udp-origin data))
                        (sequence (read-udp-sequence data))
                        (frame (read-udp-frame data))
                        (ring-size (get-count retain-ring))
                        (timestamp (read-udp-media-timestamp data)))
                    (record-event udp-id-release-packet
                                  (fixnum->flonum origin)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum frame)
                                  (fixnum->flonum ring-size)
                                  (timestamp->flonum timestamp)))))
              (loop))))))))


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot origin          getter generate)
  (slot latest-nacks    accessors generate)
  (slot process-state   getter generate)
  (slot process-ring    getter generate)
  (slot process-task    getter generate)
  (slot process-average getter generate)
  (slot ready-frames    getter generate)
  (slot ready-count     getter generate)
  (slot last-processed  getter generate)
  (slot processed       getter generate)
  (slot missing         getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self media-kind)
    (set! self.origin origin)
    (set! self.latest-nacks '())
    (set! self.process-state 'waiting)
    (set! self.ready-frames (make-table test: eqv?))
    (set! self.ready-count 0)
    (set! self.last-processed #f)
    (set! self.process-ring (new Time-Ring udp-process-size max-size: udp-process-max-size key-proc: udp-ring-key invalid-proc: (udp-ring-invalid origin media-kind) overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
    (set! self.process-task (new Task 'udp-process (lambda (task)
                                                     (process-loop self task))
                                 priority: udp-priority))
    (set! self.process-average (new Average .05 1.))
    (set! self.processed 0)
    (set! self.missing 0)
    (start-task process-task))
  
  
  (method override (destroy self)
    (insert-earliest process-ring #f)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (add-nack self seconds seq sequence)
    (set! latest-nacks (cons (cons seconds seq) latest-nacks))
    (let ((ring-size (length latest-nacks)))
      (record-event udp-id-nack-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum seq)
                    (fixnum->flonum sequence)
                    (fixnum->flonum ring-size)
                    -1.))
    ;; trim when more than udp-latest-nacks
    (when (> (length latest-nacks) udp-latest-nacks)
      (let ((removed-sequence (cdr (last latest-nacks))))
        (set-cdr! (tail latest-nacks (- udp-latest-nacks 1)) '())
        (let ((ring-size (length latest-nacks)))
          (record-event udp-id-giveup-packet
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        (fixnum->flonum removed-sequence)
                        -1.
                        (fixnum->flonum ring-size)
                        -1.))))
    latest-nacks)
  
  
  (method protected (remove-nack self sequence)
    (set! latest-nacks (remove! sequence latest-nacks key: cdr)))
  
  
  (method protected (filter-latest-missing self)
    ;; discard any nack older than udp-process-window
    (let ((now (current-seconds))
          (ring-size (length latest-nacks))
          (gaveup? #f))
      (set! latest-nacks (collect-if (lambda (nack)
                                       (let ((seconds (car nack)))
                                         (let ((keep? (< (- now seconds) udp-nack-window)))
                                           (when (not keep?)
                                             (set! gaveup? #t)
                                             (decrease! ring-size)
                                             (let ((removed-sequence (cdr nack)))
                                               (record-event udp-id-giveup-packet
                                                             (fixnum->flonum origin)
                                                             (fixnum->flonum media-kind)
                                                             (fixnum->flonum removed-sequence)
                                                             -1.
                                                             (fixnum->flonum ring-size)
                                                             -1.)))
                                           keep?)))
                                     latest-nacks))
      (when (and gaveup? (= media-kind udp-video))
        (process-state-waiting self)
        (let ((udp-client (get-udp-client (current-client))))
          ;; should not be necessary but lets
          ;; do the necessary changes later...
          (when udp-client
            (send-state udp-client)))))
    (map cdr latest-nacks))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method private (process-state-ok self)
    (unless (eq? process-state 'ok)
      (set! process-state 'ok)
      (record-event udp-id-process-ok
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    -1.
                    -1.
                    -1.)
      (when udp-show-states?
        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'STATE 'OK))))
  
  
  (method private (process-state-waiting self)
    (unless (eq? process-state 'waiting)
      (set! process-state 'waiting)
      (record-event udp-id-process-waiting
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    -1.
                    -1.
                    -1.)
      (when udp-show-states?
        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'STATE 'WAITING))))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected (insert-nack self data)
    )
  
  
  (method protected (insert-media self data now)
    (let ((sequence (read-udp-sequence data)))
      (let ((timeless? (= (read-udp-media-timestamp data) -1)))
        (let ((timestamp (read-udp-media-seconds data)))
          (let ((process-time (cond (timeless?
                                     #f)
                                    ((not time-base)
                                     (+ now udp-process-window))
                                    (else
                                     (+ timestamp time-base udp-process-window)
                                     ;; (+ timestamp (- base-time base-timestamp) udp-process-window)
                                     ;; (+ base-time (- timestamp base-timestamp) udp-process-window)
                                     ))))
            (let ((problem (insert process-ring process-time data)))
              (if (not problem)
                  (let ((origin (read-udp-origin data))
                        (ring-size (get-count process-ring)))
                    (record-event udp-id-insert-packet
                                  (fixnum->flonum origin)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum ring-size)
                                  (if timeless? -1. process-time)
                                  (if timeless? -1. timestamp))
                    #t)
                (case problem
                  ((duplicate)
                   (let ((origin (read-udp-origin data))
                         (ring-size (get-count process-ring)))
                     (record-event udp-id-duplicate-packet
                                   (fixnum->flonum origin)
                                   (fixnum->flonum media-kind)
                                   (fixnum->flonum sequence)
                                   (fixnum->flonum ring-size)
                                   (if timeless? -1. process-time)
                                   (if timeless? -1. timestamp)))
                   (when udp-show-duplicates?
                     (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) '***duplicate*** sequence))))
                #f)))))))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (define (record-reject-packet origin sequence frame timestamp)
      (record-event udp-id-process-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    -1.
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (define (record-process-packet origin sequence frame timestamp)
      (record-event udp-id-process-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    -1.
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (define (record-discard-packet origin sequence frame timestamp)
      (record-event udp-id-discard-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    -1.
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (define (record-missing-packet origin sequence frame timestamp)
      (record-event udp-id-missing-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    -1.
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((data (wait process-ring)))
            (if (not data)
                (continuation-return exit #f)
              (site (udp-process on?: #t)
                (let ((origin (read-udp-origin data))
                      (sequence (read-udp-sequence data))
                      (frame (read-udp-frame data))
                      (part (read-udp-part data))
                      (timestamp (read-udp-media-timestamp data)))
                  (if (and last-processed (<= frame last-processed))
                      ;; reject
                      (record-reject-packet origin sequence frame timestamp)
                    ;; process
                    (record-process-packet origin sequence frame timestamp)
                    ;; add
                    (let ((chunks (table-ref ready-frames frame #f)))
                      (when (not chunks)
                        (let ((total (read-udp-total data)))
                          (let ((vec (make-vector total #f)))
                            (table-set! ready-frames frame vec)
                            (set! chunks vec))))
                      (vector-set! chunks part data)
                      (increase! ready-count))
                    ;; scan
                    (let ((keys (table-keys ready-frames)))
                      (let ((lowest (minimum keys))
                            (highest (maximum keys)))
                        (define (complete? chunks)
                          (and chunks
                               (= (loop (for data in-vector chunks)
                                        (when data
                                          (sum 1)))
                                  (vector-length chunks))))
                        
                        (define (complete-header? chunks)
                          (and (complete? chunks)
                               (read-udp-media-header? (vector-ref chunks 0))))
                        
                        (let (loop-frame (frame lowest))
                          (when (<= frame highest)
                            (let ((chunks (table-ref ready-frames frame #f)))
                              (if (and (complete? chunks)
                                       (or (read-udp-media-header? (vector-ref chunks 0))
                                           (not last-processed)
                                           (= frame (+ last-processed 1))))
                                  ;; complete
                                  (begin
                                    (table-clear ready-frames frame)
                                    (decrease! ready-count (vector-length chunks))
                                    (set! last-processed frame)
                                    (process-frame self chunks)
                                    (loop-frame (+ frame 1)))
                                ;; incomplete
                                (let ((header (loop (for f from (+ frame 1) to highest)
                                                    (when (complete-header? (table-ref ready-frames f #f))
                                                      (return f))
                                                    (finally #f))))
                                  (when header
                                    ;; flush frames before header
                                    (loop (for f from frame below header)
                                          (let ((chunks (table-ref ready-frames f #f))
                                                (chunks-origin #f)
                                                (chunks-base #f)
                                                (chunks-frame #f)
                                                (chunks-timestamp #f))
                                            ;; TODO deduce sequences in the missing chunks
                                            (when chunks
                                              (let ((len (vector-length chunks)))
                                                (loop (for n from 0 below len)
                                                      (let ((data (vector-ref chunks n)))
                                                        (when data
                                                          (let ((origin (read-udp-origin data))
                                                                (sequence (read-udp-sequence data))
                                                                (frame (read-udp-frame data))
                                                                (timestamp (read-udp-media-timestamp data)))
                                                            (record-discard-packet origin sequence frame timestamp)
                                                            (when (not chunks-origin)
                                                              (set! chunks-origin origin)
                                                              (set! chunks-base (- sequence n))
                                                              (set! chunks-frame frame)
                                                              (set! chunks-timestamp timestamp))))))
                                                (loop (for n from 0 below len)
                                                      (let ((data (vector-ref chunks n)))
                                                        (when (not data)
                                                          (let ((missing-sequence (+ chunks-base n)))
                                                            (record-missing-packet chunks-origin missing-sequence chunks-frame chunks-timestamp)))))
                                                (decrease! ready-count len))))
                                          (table-clear ready-frames f))
                                    ;; continue with header
                                    (loop-frame header)))))))))
                    @redo
                    (let ((gap (if (not last-processed) 0 (- frame (+ last-processed 1)))))
                      (loop (repeat gap)
                            (add process-average 0.))
                      (add process-average 1.)))))))
          (looping)))))
  
  
  (method (process-frame self datas)
    (define (record-present-frame origin frame timestamp header?)
      (record-event udp-id-present-frame
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (if header? 1. -1.)
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (let ((member (find-group-member-by-no (current-client) origin)))
      ;; quick solution for when logging in and starting receiving
      ;; someone's media before the client is actually registered
      ;; need to revisit this code for a cleaner solution
      (when member
        (let ((id (second member)))
          (let ((count (vector-length datas))
                (first (vector-ref datas 0)))
            (increase! processed count)
            (let ((kind (read-udp-kind first))
                  (origin (read-udp-origin first))
                  (frame (read-udp-frame first))
                  (total (read-udp-total first))
                  (timestamp (read-udp-media-timestamp first))
                  (duration (read-udp-media-duration first))
                  (header? (read-udp-media-header? first))
                  (off? (read-udp-media-off? first)))
              (define (process-audio)
                (let ((buffer (assemble-chunks)))
                  (if off?
                      (receive-server-audio (current-audio) id #f #f #f)
                    (when header?
                      (process-state-ok self))
                    (if (and header? (eq? audio-codec 'vorbis))
                        (let ((headers (u8vector->object buffer)))
                          (for-each (lambda (header)
                                      (bind (buffer timestamp duration) header
                                        ;; be very careful as timestamp is incorrect as it
                                        ;; is the timestamp at time the header was captured
                                        ;; this only works because gst_app_src_write3
                                        ;; doesn't actually use the timestamp
                                        (receive-server-audio (current-audio) id buffer timestamp duration)))
                                    headers))
                      (receive-server-audio (current-audio) id buffer timestamp duration))
                    (record-present-frame origin frame timestamp header?))))
              
              (define (process-video)
                (let ((buffer (assemble-chunks)))
                  (if off?
                      (receive-server-video (current-video) id #f #f #f)
                    (when header?
                      (process-state-ok self))
                    (receive-server-video (current-video) id buffer timestamp duration)
                    (record-present-frame origin frame timestamp header?))))
              
              (define (assemble-chunks)
                (if (= total 1)
                    (read-udp-media-payload first)
                  (let ((chunks (loop (for data in-vector datas)
                                      (collect (read-udp-media-payload data)))))
                    (apply u8vector-append chunks))))
              
              (ecase kind
                ((udp-audio)
                 (process-audio))
                ((udp-video)
                 (process-video)))))))))))
