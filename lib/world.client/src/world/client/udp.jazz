;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; UDP Client
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.application)
        (jazz.event)
        (jazz.flow)
        (jazz.io)
        (jazz.math)
        (jazz.network)
        (jazz.platform)
        (jazz.presence)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.audio)
        (world.bbr)
        (world.bbr.state)
        (world.chronology)
        (world.client.autoload)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.format)
        (world.player)
        (world.profile)
        (world.profiling)
        (world.queue)
        (world.record-syntax (phase syntax))
        (world.ring)
        (world.settings)
        (world.stream)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.time)
        (world.udp)
        (world.video))


(definition protected round-trip-tolerance
  .01)


(definition protected ack-drop-percentage
  #f)

(definition protected snd_cwnd-override
  #f)

(definition protected pacing_rate-override
  #f)

(definition protected (set-ack-drop-percentage value)
  (set! ack-drop-percentage value))

(definition protected (set-snd_cwnd-override value)
  (set! snd_cwnd-override value))

(definition protected (set-pacing_rate-override value)
  (set! pacing_rate-override value))


(definition protected media-trial-size
  udp-datagram-max)


(class Local-Rate extends Object
  
  
  (slot previous getter generate)
  (slot rate     getter generate)
  (slot average  getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! previous #f)
    (set! rate 0.)
    (set! average -1.))
  
  
  (method protected (reset self)
    (set! previous #f)
    (set! rate 0.)
    (set! average -1.))
  
  
  (method protected (update self size)
    (let ((now (current-monotonic)))
      (if (not previous)
          (set! previous now)
        (let ((elapsed (- now previous)))
          (when (> elapsed 0.)
            (set! rate (/ (cast <fl> size) elapsed))
            (set! average (if (= average -1.) rate (/ (+ (* 7. average) rate) 8.)))
            (set! previous now))))))
  
  
  (method public (average-mbps self)
    (if (= average -1.)
        -1.
      (bytes->mbps average))))


(class Moving-Rate extends Object
  
  
  (slot start   getter generate)
  (slot total   getter generate)
  (slot rate    getter generate)
  (slot average getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! start #f)
    (set! total #f)
    (set! rate 0.)
    (set! average -1.))
  
  
  (method protected (reset self)
    (set! start #f)
    (set! total #f)
    (set! rate 0.)
    (set! average -1.))
  
  
  (method protected (update self size)
    (let ((now (current-monotonic)))
      (when (not start)
        (set! start now)
        (set! total 0))
      (increase! total size)
      (let ((elapsed (- now start)))
        (when (>= elapsed .25)
          (set! rate (/ (cast <fl> total) elapsed))
          (set! average (if (= average -1.) rate (/ (+ (* 7. average) rate) 8.)))
          (set! start now)
          (set! total 0)))))
  
  
  (method public (average-mbps self)
    (if (= average -1.)
        -1.
      (bytes->mbps average))))


(class UDP-Client extends UDP-Tier
  
  
  (slot tier-no                    initialize #f  getter generate)
  (slot character-name             initialize #f  getter generate)
  (slot udp-port                   initialize #f  getter generate)
  (slot udp-stopping?              initialize #f  getter generate)
  (slot server-host                initialize #f  getter generate)
  (slot server-port                initialize #f  getter generate)
  (slot write-mutex                initialize #f  getter generate)
  (slot receive-streams            initialize #f  getter generate)
  (slot receive-channels           initialize #f  getter generate)
  (slot live-task                  initialize #f  getter generate)
  (slot last-live-ack              initialize #f  getter generate)
  (slot awake-task                 initialize #f  getter generate)
  (slot receive-task               initialize #f  getter generate)
  (slot state-task                 initialize #f  getter generate)
  (slot heartbeat-task             initialize #f  getter generate)
  (slot heartbeat-sequence         initialize 0   getter generate)
  (slot started?                   initialize #f  getter generate)
  (slot monitor                    initialize #f  getter generate)
  (slot statistics                 initialize #f  getter generate)
  (slot bbr-state                  initialize #f  getter generate)
  (slot upload-mutex               initialize #f  getter generate)
  (slot upload-socket              initialize #f  getter generate)
  (slot upload-queue               initialize #f  getter generate)
  (slot upload-queue-rate          initialize #f  getter generate)
  (slot upload-send-rate           initialize #f  getter generate)
  (slot upload-pace-lag            initialize -1. getter generate)
  (slot upload-ack-mutex           initialize #f  getter generate)
  (slot upload-ack-condvar         initialize #f  getter generate)
  (slot upload-task                initialize #f  getter generate)
  (slot upload-done?               initialize #f  getter generate)
  (slot upload-info?               initialize #f  accessors generate)
  (slot upload-limited?            initialize #f  getter generate)
  (slot upload-skbuff-info         initialize #f  getter generate)
  (slot upload-skbcb-info          initialize #f  getter generate)
  (slot upload-rate-info           initialize #f  getter generate)
  (slot upload-bbr-info            initialize #f  getter generate)
  (slot upload-bbrinfo-info        initialize #f  getter generate)
  (slot upload-bbr-update          initialize 0   getter generate)
  (slot upload-user-rate           initialize #f  accessors generate)
  (slot throttle-task              initialize #f  getter generate)
  (slot invalid-packets            initialize 0   getter generate)
  (slot resending-nacks            initialize '() getter generate)
  (slot last-send-state            initialize #f  getter generate)
  (slot profile-ack-callback       initialize #f  accessors generate)
  (slot profile-media-ack-callback initialize #f  accessors generate)
  (slot profile-pulse-sequence     initialize #f  getter generate)
  (slot profile-media-order        initialize #f  getter generate)
  (slot profile-last-order         initialize #f  getter generate)
  (slot profile-monitor            initialize #f  getter generate)
  (slot profile-statistics         initialize #f  getter generate)
  (slot profile-chronology         initialize #f  getter generate)
  (slot profile-evolution          initialize #f  getter generate)
  (slot simulator                  initialize #f  accessors generate)
  (slot profile-changed-hook       initialize #f  accessors generate)
  
  
  (method override (initialize self tier-no character-name)
    (nextmethod self)
    (set! self.tier-no tier-no)
    (set! self.character-name character-name)
    (set! write-mutex (make-mutex 'write))
    (set! receive-streams (make-table))
    (set! receive-channels (make-table))
    (register-snapshot-callback (~ snapshot-receive-streams self)))
  
  
  (method package (connect self local-address host service)
    (unless (simulation?)
    (set! udp-port (open-udp (list
                               local-address: local-address
                               address: host
                               port-number: service)))
    (setup-udp-port-buffers udp-port)
    (set! udp-stopping? #f)
    (let ()
      (define (send-connect)
        (with-write-mutex self
          (lambda ()
            (with-record connect
              (let ((data (make-u8vector (calculate-connect-size))))
                (write-header-code data udp-code)
                (write-header-kind data udp-connect)
                (write-header-sender data tier-no)
                (write-connect-sent data (current-seconds))
                (write-connect-graphic-level data (or (active-graphic-level) -1))
                (write-data data udp-port))))))
      
      (set! server-host #f)
      (set! server-port #f)
      (set! monitor (new UDP-Monitor))
      (set! statistics (new UDP-Statistics))
      (set! bbr-state (new BBR-State))
      (set! upload-mutex (make-mutex 'upload))
      (set! upload-socket (new_tcpsock))
      (set! upload-queue (new Upload-Queue))
      (set! upload-queue-rate (new Moving-Rate))
      (set! upload-send-rate (new Moving-Rate))
      (set! upload-ack-mutex (make-mutex 'ack))
      (set! upload-ack-condvar (make-condition-variable 'ack))
      (set! upload-done? #f)
      (set! upload-skbuff-info (new_skbuff 0))
      (set! upload-skbcb-info (new_skbcb))
      (set! upload-rate-info (new_ratesample))
      (set! upload-bbr-info (socket->bbr upload-socket))
      (set! upload-bbrinfo-info (new_bbrinfo))
      (set-?q upload-queue)
      (set! simulator #f)
      (when record-events?
        (record-event udp-id-connecting
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.))
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (with-record connected
              (if (or (eof-object? reply) (/= (read-header-kind reply) udp-connected))
                  (if (>= n 500)
                      (throw-connection-broke "Unable to connect to udp server")
                    (loop (+ n 1)))
                (let ((source-info (udp-source-socket-info udp-port)))
                  (set! server-host (socket-info-address source-info))
                  (set! server-port (socket-info-port-number source-info)))
                (when record-events?
                  (record-event udp-id-connected
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.))
                (set! last-live-ack (current-seconds))
                (set! live-task (new Task 'live-server (~ run-live self) priority: live-priority))
                (set! awake-task (new Task 'awake (~ run-awake self) priority: awake-priority))
                (set! receive-task (new Task 'receive (~ run-receive self) priority: receive-priority))
                (start-task live-task)
                (start-task awake-task)
                (start-task receive-task)))))))))

  
  (method package (deconnect self)
    (set! udp-stopping? #t)
    (stop-task live-task)
    (set! live-task #f)
    (stop-task awake-task)
    (set! awake-task #f)
    (close-port udp-port)
    (thread-join! (get-thread receive-task))
    (set! udp-port #f)
    (set! receive-task #f)
    (free_tcpsock upload-socket)
    (set! upload-socket #f)
    (free_skbuff upload-skbuff-info)
    (set! upload-skbuff-info #f)
    (free_skbcb upload-skbcb-info)
    (set! upload-skbcb-info #f)
    (free_ratesample upload-rate-info)
    (set! upload-rate-info #f)
    (set! upload-bbr-info #f)
    (free_bbrinfo upload-bbrinfo-info)
    (set! upload-bbrinfo-info #f))
  
  
  (method (start self)
    (unless started?
      (unless (simulation?)
        (reset bbr-state)
        (reset upload-queue)
        (reset upload-queue-rate)
        (reset upload-send-rate)
        (let ((base (current-monotonic-jiffies))
              (frequency (current-monotonic-frequency)))
          (tcp_init upload-socket udp-mss base frequency)
          (bbr_init upload-socket)
          (when record-events?
            (record-event udp-id-bbr-init
                          -1.
                          -1.
                          -1.
                          -1.
                          (fixnum->flonum udp-mss)
                          (timestamp->flonum base)
                          (timestamp->flonum frequency))))
        (cond-expand
          ((or devel stable)
           (together.bbr:set-upload-info bbr-state upload-socket upload-queue upload-queue-rate upload-send-rate upload-skbuff-info upload-skbcb-info upload-rate-info upload-bbr-info upload-bbrinfo-info (lambda () upload-bbr-update) statistics)
           (together.bbr:draw-bbr #f 0 0)
           (together.bbr:set-upload-info #f #f #f #f #f #f #f #f #f #f #f #f))
          (else))
        (bbr-updated self)
        (set! upload-done? #f)
        (set! upload-task (new Task 'upload (~ run-upload self) priority: upload-priority))
        (start-task upload-task)
        (set! throttle-task (new Task 'throttle (~ run-throttle self) priority: throttle-priority))
        (start-task throttle-task)
        (set! state-task (new Task 'state (~ run-state self) priority: state-priority))
        (start-task state-task)
        (set! heartbeat-task (new Task 'heartbeat (~ run-heartbeat self) priority: heartbeat-priority))
        (start-task heartbeat-task))
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (set! upload-done? #t)
      (push-done upload-queue)
      (condition-variable-signal! upload-ack-condvar)
      (thread-join! (get-thread upload-task))
      (set! upload-task #f)
      (thread-send (get-thread throttle-task) #t)
      (thread-join! (get-thread throttle-task))
      (set! throttle-task #f)
      (reset bbr-state)
      (reset upload-queue)
      (stop-task state-task)
      (set! state-task #f)
      (stop-task heartbeat-task)
      (set! heartbeat-task #f)
      (set! started? #f)))
  
  
  (method (with-write-mutex self thunk)
    (prog1 (begin
             (mutex-lock! write-mutex)
             (thunk))
      (mutex-unlock! write-mutex)))
  
  
  (method (snapshot-receive-streams self)
    (let ((info (map (lambda (stream)
                       (list (get-sender stream)
                             (get-name stream)
                             (get-source-kind stream)))
                     (table-values receive-streams))))
      (add-snapshot-property 'live.udp-receive info)))
  
  
  (method protected (new-simulator self)
    (new UDP-Simulator
         (lambda (data info drop?)
           (unless drop?
             (send-server self data)))))
  
  
  (method package (require-simulator self)
    (or simulator
        (let ((sim (new-simulator self)))
          (set! simulator sim)
          sim)))
  
  
  (method protected (increase-sent self data)
    (increase-sent monitor data))
  
  
  (method protected (increase-received self data)
    (increase-received monitor data))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (set! profile-pulse-sequence 0)
    (set! profile-media-order 0)
    (set! profile-last-order 0)
    (set! profile-monitor (new UDP-Monitor))
    (set! profile-statistics (new UDP-Statistics))
    (set! profile-chronology (new Chronology 0))
    (set! profile-evolution (new Evolution 250000)))
  
  
  (method package (retrieve-profile self)
    (let ((metadata (list tier-no character-name '() '() (sites-metadata)))
          (chronology (copy-chronology profile-chronology))
          (evolution (copy-evolution profile-evolution)))
      (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
  
  
  (method package (stop-profile self)
    (set! profile-chronology #f)
    (set! profile-evolution #f))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (close-send-stream self stream)
    (table-iterate-safe (get-channels stream)
      (lambda (no channel)
        (close-send-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (unregister-stream (current-client) stream-no)
      (table-clear send-streams stream-no)))
  
  
  (method package (close-send-streams self)
    (table-iterate-safe send-streams
      (lambda (no stream)
        (close-send-stream self stream))))
  
  
  (method package (register-receive-stream self sender name stream-no origin source-kind video-levels channels)
    (let ((stream (new UDP-Receive-Stream sender name stream-no origin source-kind video-levels)))
      (for-each (lambda (info)
                  (bind (channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state) info
                    (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                channels)
      (table-set! receive-streams stream-no stream)
      stream))
  
  
  (method public (find-receive-stream self stream-no)
    (table-ref receive-streams stream-no #f))
  
  
  (method package (close-receive-stream self stream)
    (close-waiting-video stream)
    (table-iterate-safe (get-channels stream)
      (lambda (no channel)
        (close-receive-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (table-clear receive-streams stream-no)))
  
  
  (method package (close-receive-streams self)
    (table-iterate-safe receive-streams
      (lambda (no stream)
        (with-locked-channels stream
          (lambda ()
            (close-receive-stream self stream))))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (register-send-channel self priority stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (let ((stream (find-send-stream self stream-no)))
      (let ((channel (new UDP-Send-Channel priority stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
        (unless (simulation?)
          (register-channel upload-queue channel (if (= media-kind udp-audio) 1. #f)))
        (table-set! send-channels channel-no channel)
        channel)))
  
  
  (method package (close-send-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear send-channels channel-no))
    (unless (simulation?)
      (unregister-channel upload-queue channel)))
  
  
  (method public (find-receive-channel self channel-no)
    (table-ref receive-channels channel-no #f))
  
  
  (method package (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (let ((channel (new UDP-Receive-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
      (table-set! receive-channels channel-no channel)
      channel))
  
  
  (method package (close-receive-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear receive-channels channel-no)))
  
  
  (method package (close-channel-output self channel)
    (let ((id (get-no channel))
          (kind (get-media-kind channel)))
      (when (= kind udp-audio)
        (let ((audio (current-audio)))
          (let ((output (get-output channel)))
            (when output
              (close-output audio id output)
              (close-empty-audio audio)))))
      ;; use video-output as the output of the channel
      ;; can be a waiting not yet installed video sink
      (let ((stream (get-stream channel)))
        (let ((output (get-video-output stream)))
          (when (and output (eq? (get-channel output) channel))
            (close-output (current-video) id output)
            (set-video-output stream #f))))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method package (send-media self channel-no buffer dts pts duration flags)
    (with-write-mutex self
      (lambda ()
        (let ((channel (find-send-channel self channel-no)))
          (when channel
            (let ((kind (get-media-kind channel)))
              (define (send)
                (when (and (= kind udp-video) (frame-keyframe? flags))
                  (trim-upload self channel))
                (sending-media channel tier-no buffer dts pts duration flags
                  (lambda (data)
                    (if (= kind udp-audio)
                        (push-time-upload self channel data)
                      (push-upload self channel data)))))
              
              (define (advance-frame!)
                (next-frame-sequence! channel))
              
              (if (simulation?)
                  (send)
                (if (waiting-keyframe? channel)
                    (if (not (frame-keyframe? flags))
                        (advance-frame!)
                      (got-keyframe channel)
                      (send))
                  (send)))))))))
  
  
  (method (send-state self)
    (define (collect-waiting)
      (let ((waiting '()))
        (table-iterate receive-channels
          (lambda (key channel)
            (when (eq? (get-source-kind channel) 'image)
              (let ((state (get-state (get-process-ring channel))))
                (when (eq? state 'wait)
                  (set! waiting (cons (get-no channel) waiting)))))))
        waiting))
    
    (let ((waiting (collect-waiting)))
      (when (not-null? waiting)
        (let ((now (current-seconds)))
          (when (or (not last-send-state)
                    (> now (+ last-send-state 1.)))
            (with-write-mutex self
              (lambda ()
                (with-record state
                  (let ((waiting (object->u8vector waiting)))
                    (let ((size (calculate-state-size waiting)))
                      (let ((data (make-u8vector size)))
                        (write-header-code data udp-code)
                        (write-header-kind data udp-state)
                        (write-header-sender data tier-no)
                        (write-state-waiting data waiting)
                        (send-data self data)))))))
            (set! last-send-state now))))))
  
  
  (method protected (next-profile-pulse-sequence! self)
    (prog1 profile-pulse-sequence
      (increase! profile-pulse-sequence)))
  
  
  (method protected (next-profile-media-order! self)
    (prog1 profile-media-order
      (increase! profile-media-order)))
  
  
  (method package (send-profile-pulse self)
    (with-write-mutex self
      (lambda ()
        (with-record profile-pulse
          (let ((size (calculate-profile-pulse-size)))
            (let ((data (make-u8vector size)))
              (write-header-code data udp-code)
              (write-header-kind data udp-profile-pulse)
              (write-header-sender data tier-no)
              (write-profile-pulse-sent data (current-seconds))
              (write-profile-pulse-sequence data (next-profile-pulse-sequence! self))
              (write-profile-pulse-bytes-sent data (get-bytes-sent profile-monitor))
              (send-data self data)
              (increase-sent profile-monitor data)
              data))))))
  
  
  (method package (send-profile-media self payload)
    (with-write-mutex self
      (lambda ()
        (with-record profile-media
          (let ((size (calculate-profile-media-size payload)))
            (let ((data (make-u8vector size)))
              (write-header-code data udp-code)
              (write-header-kind data udp-profile-media)
              (write-header-sender data tier-no)
              (write-profile-media-order data (next-profile-media-order! self))
              (write-profile-media-payload data payload)
              (send-data self data)
              (increase-sent profile-monitor data)
              data))))))
  
  
  (method package (send-profile-media-pulse self)
    (with-write-mutex self
      (lambda ()
        (with-record profile-media-pulse
          (let ((size (calculate-profile-media-pulse-size)))
            (let ((data (make-u8vector size)))
              (write-header-code data udp-code)
              (write-header-kind data udp-profile-media)
              (write-header-sender data tier-no)
              (write-profile-media-pulse-order data (next-profile-media-order! self))
              (send-data self data)
              (increase-sent profile-monitor data)
              data))))))
  
  
  (method package (send-profile-dummy self payload)
    (with-write-mutex self
      (lambda ()
        (with-record profile-dummy
          (let ((size (calculate-profile-dummy-size payload)))
            (let ((data (make-u8vector size)))
              (write-header-code data udp-code)
              (write-header-kind data udp-profile-dummy)
              (write-header-sender data tier-no)
              (write-profile-dummy-order data (next-profile-media-order! self))
              (write-profile-dummy-payload data payload)
              (send-data self data)
              (increase-sent profile-monitor data)
              data))))))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data #f)
      (send-server self data))
    (increase-sent self data))
  
  
  (method (send-server self data)
    ;; quick temporary hack to get back the safe behavior
    ;; of retrying-write until port being false is fixed
    (when udp-port
      (udp-destination-set! server-host server-port udp-port)
      (send-udp data udp-port)))
  
  
  ;;;
  ;;;; Upload
  ;;;
  
  
  (method (push-upload self channel data)
    (unless upload-done?
      (push upload-queue channel data)
      (update upload-queue-rate (u8vector-length data))
      (when record-events?
        (record-event udp-id-queue-rate
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.
                      (average-mbps upload-queue-rate)
                      -1.))))
  
  
  (method (push-time-upload self channel data)
    (unless upload-done?
      (push-time upload-queue channel data)
      (update upload-queue-rate (u8vector-length data))))
  
  
  (method (push-missing-upload self data)
    (unless upload-done?
      (push-missing upload-queue data)
      (update upload-queue-rate (u8vector-length data))))
  
  
  (method (pop-upload self timeout)
    (pop upload-queue timeout))
  
  
  (method (trim-upload self channel)
    (trim upload-queue channel))

  
  (method (bbr-updated self)
    (increase! upload-bbr-update))
  
  
  (method (send-upload-media self data was-empty?)
    (with-record media-ackable
      (let ((sent (current-monotonic))
            (order (next-media-order!)))
        (write-media-ackable-order data order)
        (with-write-mutex self
          (lambda ()
            (send-data self data)
            (update upload-send-rate (u8vector-length data))))
        (bind-values (skb segs) (packet-sent bbr-state sent order data)
          (let ((timer (current-monotonic-jiffies)))
            (tcp_skb_sent upload-socket skb was-empty? order timer)
            (when record-bbr?
              (record-event udp-id-bbr-sent
                            -1.
                            -1.
                            -1.
                            (fixnum->flonum segs)
                            (fixnum->flonum order)
                            (if was-empty? 1. 0.)
                            (timestamp->flonum timer)))))
        (when record-events?
          (with-record media
            (record-event udp-id-bbr-media
                          (fixnum->flonum (read-media-channel data))
                          (fixnum->flonum (read-header-sender data))
                          (fixnum->flonum (read-header-kind data))
                          (fixnum->flonum (read-media-sequence data))
                          (fixnum->flonum order)
                          -1.
                          -1.))
          (record-event udp-id-send-rate
                        -1.
                        -1.
                        -1.
                        -1.
                        (fixnum->flonum order)
                        (average-mbps upload-send-rate)
                        -1.))
        (bbr-updated self))))
  
  
  (method (send-upload-pulse self sent was-empty?)
    (let ((order (next-media-order!)))
      (let ((data (with-write-mutex self
                    (lambda ()
                      (with-record media-pulse
                        (let ((size (calculate-media-pulse-size)))
                          (let ((data (make-u8vector size)))
                            (write-header-code data udp-code)
                            (write-header-kind data udp-media-pulse)
                            (write-header-sender data tier-no)
                            (write-media-ackable-order data order)
                            (send-data self data)
                            (update upload-send-rate (u8vector-length data))
                            data)))))))
        (bind-values (skb segs) (packet-sent bbr-state sent order data)
          (let ((timer (current-monotonic-jiffies)))
            (tcp_skb_sent upload-socket skb was-empty? order timer)
            (when record-bbr?
              (record-event udp-id-bbr-pulsed
                            -1.
                            -1.
                            -1.
                            (fixnum->flonum segs)
                            (fixnum->flonum order)
                            (if was-empty? 1. 0.)
                            (timestamp->flonum timer)))))
        (when record-events?
          (record-event udp-id-bbr-pulse
                        -1.
                        -1.
                        -1.
                        -1.
                        (fixnum->flonum order)
                        -1.
                        -1.))
        (pulse-sent bbr-state sent)
        (bbr-updated self))))
  
  
  (method (receive-upload-ack self data)
    (mutex-lock! upload-mutex)
    (unless (and ack-drop-percentage (< (random-real) ack-drop-percentage))
    (with-record media-ack
      (let ((order (read-media-ack-order data))
            (empty? (empty? upload-queue))
            (timer (current-monotonic-jiffies)))
        (let ((info (ack-received bbr-state upload-socket order)))
          (when record-bbr?
            (record-event udp-id-bbr-acked
                          -1.
                          -1.
                          -1.
                          (if empty? 1. 0.)
                          (fixnum->flonum order)
                          (timestamp->flonum timer)
                          -1.))
          (when info
            (bind-values (skb lost) info
              (when upload-info?
                (skbuff_get_info skb upload-skbuff-info)
                (skbcb_get_info skb upload-skbcb-info))
              (let ((app-limited? (tcp_ack upload-socket skb lost empty? timer (and upload-info? upload-rate-info))))
                (set! upload-limited? app-limited?)
                (condition-variable-signal! upload-ack-condvar)
                (free_skbuff skb)
                (when record-events?
                  (record-state bbr-state upload-socket order)
                  (record-event udp-id-bbr-ack
                                -1.
                                -1.
                                -1.
                                -1.
                                (fixnum->flonum order)
                                -1.
                                -1.)
                  (record-pacing bbr-state upload-socket order)
                  (record-window bbr-state upload-socket order)
                  (record-limited bbr-state app-limited? order))))))))
    (bbr-updated self))
    (mutex-unlock! upload-mutex))
  
  
  (proclaim (warn optimizations))
  
  
  (method (run-upload self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let ((now (current-monotonic)))
          (let (loop (data (pop-upload self 0)) (was-empty? #f) (local-delivery-time now) (next-delivery-time now))
            (if upload-done?
                (continuation-return exit #f)
              (wake-upload self data was-empty? local-delivery-time next-delivery-time loop)))))))
  
  
  (method (wake-upload self data was-empty? local-delivery-time next-delivery-time loop)
    (declare (proper-tail-calls))
    (define (wait local-delivery-time)
      (sleep (- local-delivery-time (current-monotonic))))
    
    (define (pace size)
      (/ (cast <fl> size) (or upload-user-rate (tcp_pacing_rate upload-socket))))
    
    (define (show str)
      @w (terminal-string str))
    
    (mutex-lock! upload-mutex)
    (cond ;; no data
          ((eof-object? data)
           (show ".")
           (mutex-unlock! upload-mutex)
           (let ((data (pop-upload self +inf.0))
                 (now (current-monotonic)))
             (loop data #t now now)))
          ;; data
          (else
           (cond ;; exceeding congestion window
                 ((> (+ (tcp_packets_in_flight upload-socket) 1) (tcp_snd_cwnd upload-socket))
                  (tcp_set_is_cwnd_limited upload-socket #t)
                  (record-congested bbr-state #t)
                  (let ((now (current-monotonic)))
                    (cond ;; send pulse
                          ((>= now (+ (get-last-sent-time bbr-state) .1))
                           (show "@")
                           (wait local-delivery-time)
                           (send-upload-pulse self now was-empty?)
                           (mutex-unlock! upload-mutex)
                           (mutex-lock! upload-ack-mutex)
                           (mutex-unlock! upload-ack-mutex upload-ack-condvar .1)
                           (loop data was-empty? local-delivery-time next-delivery-time))
                          ;; do nothing
                          (else
                           (show "$")
                           (wait local-delivery-time)
                           (mutex-unlock! upload-mutex)
                           (mutex-lock! upload-ack-mutex)
                           (mutex-unlock! upload-ack-mutex upload-ack-condvar .1)
                           (loop data was-empty? local-delivery-time next-delivery-time)))))
                 ;; send media
                 (else
                  (tcp_set_is_cwnd_limited upload-socket #f)
                  (record-congested bbr-state #f)
                  (set! upload-pace-lag (- local-delivery-time next-delivery-time))
                  (let ((size (u8vector-length data)))
                    (show "^")
                    (wait local-delivery-time)
                    (send-upload-media self data was-empty?)
                    (let ((pace (pace size)))
                      (let ((next (+ next-delivery-time pace))
                            ;; never send faster locally than pace / 2
                            (smallest-local (+ (current-monotonic) (/ pace 2.))))
                        (let ((local-delivery-time (max next smallest-local)))
                          (mutex-unlock! upload-mutex)
                          (loop (pop-upload self 0) #f local-delivery-time next))))))))))
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (run-throttle self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (throttle upload-queue task)
          (let ((done? (thread-receive 1 #f)))
            (if done?
                (continuation-return exit #f)
              (loop)))))))
  
  
  (method package (upload-info self)
    (let ((min-rtt (/ (tcp_min_rtt upload-socket) 1000000.))
          (smoothed-rtt (get-round-trip-rate statistics))
          (cwnd (or snd_cwnd-override (tcp_snd_cwnd upload-socket)))
          (pacing-rate (or pacing_rate-override (tcp_pacing_rate upload-socket)))
          (queue-rate (average-mbps upload-queue-rate))
          (send-rate (average-mbps upload-send-rate))
          (upload-drop (get-upload-drop statistics))
          (congested (if upload-limited? "true" "false"))
          (limited (if upload-limited? "true" "false")))
      (and upload-drop
           (format "MinRTT: {r precision: 3}s, RTT: {r precision: 3}s, CWnd {a}, Pacing: {r precision: 1}Mbps, Rate: {r precision: 1}Mbps, Lag: {r precision: 3}s, Drop: {r precision: 1}%, Congested: {a}, Limited: {a}" min-rtt smoothed-rtt cwnd (bytes->mbps pacing-rate) send-rate upload-pace-lag upload-drop congested limited))))
  
  
  ;;;
  ;;;; Live
  ;;;
  
  
  (method (run-live self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site live
                  (send-live self)))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task live-period duration exit))
              (iter time)))))))
  
  
  ;;;
  ;;;; Awake
  ;;;
  
  
  (method (run-awake self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site awake
                  (adjust-computer-sleep self)))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task awake-period duration exit))
              (iter time)))))))
  
  
  (method (adjust-computer-sleep self)
    (if (not application-active?)
        ;; when in the background we let the os manage sleep and we
        ;; disconnect from group or circle when actually going to sleep
        (allow-computer-sleep)
      (let ((keep-awake? #f))
        ;; send
        (table-iterate send-channels
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio udp-video)
               (when (or (neq? (get-source-kind channel) 'live)
                         (on? channel))
                 (set! keep-awake? #t))))))
        ;; receive
        (table-iterate receive-channels
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio udp-video)
               (set! keep-awake? #t)))))
        ;; policy
        (if keep-awake?
            (prevent-computer-sleep)
          (allow-computer-sleep)))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (run-state self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (site state
            (send-state self))
          (task-sleep task udp-state-period exit)
          (loop)))))
  
  
  ;;;
  ;;;; Heartbeat
  ;;;
  
  
  (method (run-heartbeat self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (site heartbeat
            (send-heartbeat self))
          (task-sleep task udp-heartbeat-period exit)
          (loop)))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (run-receive self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (catch-exception-filter
          (lambda (exc)
            udp-stopping?)
          (lambda (exc)
            (continuation-return exit #f))
          (lambda ()
            (let (loop)
              (let ((data (read-parcel udp-port)))
                (site receive
                  (receive-data self data))
                (loop))))))))
  
  
  (method protected (receive-data self data)
    (if (or (< (u8vector-length data) 4)
            (/= (with-record header (read-header-code data)) udp-code))
        (increase! invalid-packets)
      (increase-received self data)
      (let ((kind (with-record header
                    (read-header-kind data))))
        (if (not started?)
            (ecase kind
              ((udp-connected))
              ((udp-ack))
              ((udp-nack))
              ((udp-audio udp-video))
              ((udp-media-ack))
              ((udp-state))
              ((udp-reset))
              ((udp-live-ack)
               (receive-live-ack self data))
              ((udp-profile-ack)
               (receive-profile-ack self data))
              ((udp-profile-pulse))
              ((udp-profile-media)
               (receive-profile-media self data))
              ((udp-profile-media-ack)
               (receive-profile-media-ack self data))
              (else
               (error "Unknown UDP kind: {s}" kind)))
          (ecase kind
            ((udp-connected))
            ((udp-ack)
             (receive-ack self data))
            ((udp-nack)
             (receive-nack self data))
            ((udp-audio udp-video)
             (receive-medias self kind data))
            ((udp-media-ack)
             (receive-upload-ack self data))
            ((udp-state)
             (receive-state self data))
            ((udp-reset)
             (receive-reset self data))
            ((udp-live-ack)
             (receive-live-ack self data))
            ((udp-profile-ack))
            ((udp-profile-pulse))
            ((udp-profile-media))
            (else
             (error "Unknown UDP kind: {s}" kind))))
        (when (and (/= kind udp-audio)
                   (/= kind udp-video))
          (return-parcel data)))))
  
  
  (method (receive-ack self data)
    (with-record ack
      (let ((now (current-seconds))
            (sender (read-header-sender data))
            (heartbeat-sent (read-ack-heartbeat-sent data))
            (heartbeat-sequence (read-ack-heartbeat-sequence data))
            (heartbeat-bytes-sent (read-ack-heartbeat-bytes-sent data)))
        ;; statistics
        (let ((ack-sent (read-ack-sent data))
              (server-bytes-sent (read-ack-bytes-sent data))
              (server-bytes-received (read-ack-bytes-received data))
              (round-trip (- now heartbeat-sent)))
          (update statistics now monitor round-trip heartbeat-sequence heartbeat-bytes-sent server-bytes-sent server-bytes-received)
          (when record-events?
            (record-event udp-id-receive-ack
                          -1.
                          (fixnum->flonum sender)
                          -1.
                          (fixnum->flonum heartbeat-sequence)
                          round-trip
                          heartbeat-sent
                          ack-sent))
          (when record-events?
            (let ((upload-drop (get-upload-drop statistics))
                  (download-drop (get-download-drop statistics))
                  (last-upload-rate (get-last-upload-rate statistics))
                  (last-download-rate (get-last-download-rate statistics)))
              (unless (= last-upload-rate -1.)
                (record-event udp-id-traffic-rate
                              -1.
                              (fixnum->flonum sender)
                              -1.
                              upload-drop
                              download-drop
                              last-upload-rate
                              last-download-rate))))))))
  
  
  (method (receive-nack self data)
    (with-record nack
      (let ((sender (read-header-sender data))
            (channel-no (read-nack-channel data))
            (start (read-nack-start data))
            (gap (read-nack-gap data)))
        (send-missing self sender channel-no start gap))))
  
  
  ;; receive and reorder all available packets
  (method protected (receive-medias self kind data)
    (declare (proper-tail-calls))
    (with-record media
      (let ((no (read-media-channel data)))
        ;; so a sequence of one doesn't allocate a pair
        (let (loop (ordered #f))
          (define (receive)
            (resend-nacks self)
            (if (not ordered)
                (receive-media self kind data)
              (for-each (lambda (data)
                          (receive-media self kind data))
                        ordered)))
          
          (input-port-timeout-set! udp-port 0)
          (let ((next (need-parcel)))
            (let ((parcel-read (udp-read-subu8vector next 0 parcel-size udp-port)))
              (input-port-timeout-set! udp-port +inf.0)
              (cond ((not parcel-read)
                     (return-parcel next)
                     (receive))
                    ((and (= (read-header-kind next) kind)
                          (= (read-media-channel next) no))
                     (increase-received self next)
                     (loop (add-ordered! next (or ordered (list data)) key: (lambda (data)
                                                                              (read-media-sequence data)))))
                    (else
                     (receive)
                     (receive-data self next)))))))))
  
  
  (method package (receive-media self kind data)
    (with-record media
      (let ((channel-no (read-media-channel data)))
        (let ((channel (find-receive-channel self channel-no)))
          (when channel
            (let ((ring (get-process-ring channel)))
              (with-mutex ring
                (lambda ()
                  (when (eq? (get-send-state channel) 'on)
                    (when (get-flow ring)
                      (remember-media channel data)
                      (insert-media channel data)))))))))))
  
  
  (method (send-missing self sender channel-no start gap)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((media-kind (get-media-kind channel))
              (ring (get-retain-ring channel)))
          (loop (for sequence from start below (+ start gap))
                (let ((data (locate-data ring sequence)))
                  (if data
                      (with-record media
                        (increase-media-resent data)
                        (push-missing-upload self data)
                        (when record-events?
                          (let ((frame (read-media-frame data)))
                            (record-event udp-id-resend-packet
                                          (fixnum->flonum channel-no)
                                          (fixnum->flonum sender)
                                          (fixnum->flonum media-kind)
                                          (fixnum->flonum sequence)
                                          (fixnum->flonum frame)
                                          -1.
                                          -1.))))
                    (when record-events?
                      (record-event udp-id-absent-packet
                                    (fixnum->flonum channel-no)
                                    (fixnum->flonum sender)
                                    (fixnum->flonum media-kind)
                                    (fixnum->flonum sequence)
                                    -1.
                                    -1.
                                    -1.)))))))))
  
  
  (method (receive-state self data)
    (with-record state
      (let ((waiting (u8vector->object (read-state-waiting data))))
        (for-each (lambda (channel-no)
                    (let ((channel (find-send-channel self channel-no)))
                      (when channel
                        (reset-media channel))))
                  waiting))))
  
  
  (method (receive-reset self data)
    (with-record reset
      (let ((channel-no (read-reset-channel data)))
        (let ((channel (find-send-channel self channel-no)))
          (when channel
            (reset-media channel))))))
  
  
  (method (receive-live-ack self data)
    (set! last-live-ack (current-seconds)))
  
  
  (method (receive-profile-ack self data)
    (let ((include-download-rate?
            (if profile-ack-callback
                (profile-ack-callback data)
              #t)))
      (with-record profile-ack
        (let ((now (current-seconds)))
          (let ((ack-sent (read-profile-ack-sent data))
                (pulse-sent (read-profile-ack-pulse-sent data))
                (pulse-sequence (read-profile-ack-pulse-sequence data))
                (pulse-bytes-sent (read-profile-ack-pulse-bytes-sent data))
                (latency (read-profile-ack-latency data))
                (server-bytes-sent (read-profile-ack-bytes-sent data))
                (server-bytes-received (read-profile-ack-bytes-received data)))
            (let ((round-trip (- now pulse-sent)))
              (update profile-statistics now profile-monitor round-trip pulse-sequence pulse-bytes-sent server-bytes-sent server-bytes-received)
              (parameterize ((simulation-evolution profile-evolution))
                ;; hack to plot latency
                @wait
                (when record-events?
                  (record-event udp-id-insert-packet
                                (fixnum->flonum pulse-sequence)
                                (fixnum->flonum tier-no)
                                (fixnum->flonum udp-audio)
                                -1.
                                -1.
                                -1.
                                latency))
                ;; hack to plot round trip
                (when record-events?
                  (record-event udp-id-receive-ack
                                -1.
                                (fixnum->flonum tier-no)
                                -1.
                                (fixnum->flonum pulse-sequence)
                                round-trip
                                pulse-sent
                                ack-sent))
                (when record-events?
                  (let ((upload-drop (get-upload-drop profile-statistics))
                        (download-drop (get-download-drop profile-statistics))
                        (last-upload-rate (get-last-upload-rate profile-statistics))
                        (last-download-rate (get-last-download-rate profile-statistics)))
                    (unless (= last-upload-rate -1.)
                      ;; hack to plot upload
                      (record-event udp-id-traffic-rate
                                    -1.
                                    (fixnum->flonum tier-no)
                                    -1.
                                    upload-drop
                                    download-drop
                                    last-upload-rate
                                    (if include-download-rate?
                                        last-download-rate
                                      -1.))))))))))
      (increase-received profile-monitor data)))
  
  
  (method (receive-profile-media self data)
    (with-record profile-media
      (let ((sender (read-header-sender data))
            (order (read-profile-media-order data)))
        (when record-events?
          (when profile-last-order
            (let ((expected-order (+ profile-last-order 1)))
              (when (/= order expected-order)
                (parameterize ((simulation-evolution profile-evolution))
                  (loop (for ord from expected-order below order)
                        (record-event udp-id-lost-packet
                                      -1.
                                      (fixnum->flonum sender)
                                      (fixnum->flonum udp-profile-media)
                                      (fixnum->flonum ord)
                                      -1.
                                      -1.
                                      -1.)))))))
        (set! profile-last-order order)
        (increase-received profile-monitor data))))
  
  
  (method (receive-profile-media-ack self data)
    (when profile-media-ack-callback
      (profile-media-ack-callback data)))
  
  
  (method protected (next-heartbeat-sequence! self)
    (prog1 heartbeat-sequence
      ;; wrap around acceptable
      (if (= heartbeat-sequence max-heartbeat-sequence)
          (set! heartbeat-sequence 0)
        (increase! heartbeat-sequence))))
  
  
  (method (send-heartbeat self)
    (let ((heartbeat-sequence (next-heartbeat-sequence! self)))
      (with-write-mutex self
        (lambda ()
          (with-record heartbeat
            (let ((size (calculate-heartbeat-size)))
              (let ((data (make-u8vector size)))
                (write-header-code data udp-code)
                (write-header-kind data udp-heartbeat)
                (write-header-sender data tier-no)
                (write-heartbeat-sent data (current-seconds))
                (write-heartbeat-sequence data heartbeat-sequence)
                (write-heartbeat-bytes-sent data (get-bytes-sent monitor))
                (send-data self data))))
          (when record-events?
            (record-event udp-id-send-heartbeat
                          -1.
                          (fixnum->flonum tier-no)
                          -1.
                          (fixnum->flonum heartbeat-sequence)
                          -1.
                          -1.
                          -1.))))))
  
  
  (method override (send-nack self sender channel-no start gap ring)
    (with-write-mutex self
      (lambda ()
        (with-record nack
          (let ((size (calculate-nack-size)))
            (let ((data (make-u8vector size)))
              (write-header-code data udp-code)
              (write-header-kind data udp-nack)
              (write-header-sender data tier-no)
              (write-nack-channel data channel-no)
              (write-nack-start data start)
              (write-nack-gap data gap)
              (send-data self data)
              (set! resending-nacks (cons data resending-nacks))))))))
  
  
  (method (resend-nacks self)
    (when (not-null? resending-nacks)
      (with-write-mutex self
        (lambda ()
          (for-each (lambda (data)
                      (send-data self data))
                    resending-nacks)
          (set! resending-nacks '())))))
  
  
  (method (send-live self)
    ;; keep clean during profile
    (unless profile-ack-callback
      (if (> (- (current-seconds) last-live-ack) live-disconnected)
          (bailout (current-tier) (new Error message: "Disconnected from server"))
        (with-write-mutex self
          (lambda ()
            (with-record header
              (let ((size (calculate-live-size)))
                (let ((data (make-u8vector size)))
                  (write-header-code data udp-code)
                  (write-header-kind data udp-live)
                  (write-header-sender data tier-no)
                  (send-data self data))))))))))


;;;
;;;; Upload Ring
;;;


(class Upload-Ring extends Object
  
  
  (slot count   <fx>)
  (slot expire)
  (slot times   <f64vector>)
  (slot content <vector>)
  (slot head    <fx>)
  (slot tail    <fx>)
  (slot size    <fx> getter generate)
  (slot pushed  <fx> getter generate)
  (slot popped  <fx> getter generate)
  
  
  (method override (initialize self cnt exp)
    (set! count cnt)
    (set! expire exp)
    (set! times (make-f64vector (if exp cnt 0) +nan.0))
    (set! content (make-vector cnt))
    (set! head 0)
    (set! tail 0)
    (set! size 0)
    (set! pushed 0)
    (set! popped 0))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" size))))
  
  
  (method public (empty? self)
    (= size 0))
  
  
  (method public (reset self)
    (prog1 size
      (f64vector-fill! times +nan.0)
      (vector-fill! content #f)
      (set! head 0)
      (set! tail 0)
      (set! size 0)
      (set! pushed 0)
      (set! popped 0)))
  
  
  (method public (reset-pushed/popped self)
    (set! pushed 0)
    (set! popped 0))
  
  
  (method public (push self obj)
    (let ((new-size (+ size 1)))
      (when (> new-size count)
        (let ((new-count (if (= count 0) 8 (fxround (* count GOLDEN-RATIO)))))
          (let ((new-content (make-vector new-count)))
            (loop (for n from 0 below size)
                  (vector-set! new-content n (vector-ref content (modulo (+ head n) count))))
            (set! count new-count)
            (set! content new-content)
            (set! head 0)
            (set! tail size))))
      (vector-set! content tail obj)
      (set! tail (modulo (+ tail 1) count))
      (set! size new-size)
      (increase! pushed)))
  
  
  (method public (push-time self obj)
    (declare (proper-tail-calls))
    (let ((time (current-seconds)))
      ;; trim
      (when (> size 0)
        (let ((cut (- time expire)))
          (let (loop)
            (let ((earliest-time (f64vector-ref times head)))
              (when (<= earliest-time cut)
                (f64vector-set! times head +nan.0)
                (vector-set! content head #f)
                (set! head (modulo (+ head 1) count))
                (decrease! size)
                (when (> size 0)
                  (loop)))))))
      ;; push
      (let ((new-size (+ size 1)))
        (when (> new-size count)
          (let ((new-count (if (= count 0) 8 (fxround (* count GOLDEN-RATIO)))))
            (let ((new-times (make-f64vector new-count +nan.0))
                  (new-content (make-vector new-count #f)))
              (loop (for n from 0 below size)
                    (let ((offset (modulo (+ head n) count)))
                      (f64vector-set! new-times n (f64vector-ref times offset))
                      (vector-set! new-content n (vector-ref content offset))))
              (set! count new-count)
              (set! times new-times)
              (set! content new-content)
              (set! head 0)
              (set! tail size))))
        (f64vector-set! times tail time)
        (vector-set! content tail obj)
        (set! tail (modulo (+ tail 1) count))
        (set! size new-size)
        (increase! pushed))))
  
  
  (method public (pop self)
    (if (<= size 0)
        (error "Ring is empty")
      (prog1 (vector-ref content head)
        (vector-set! content head #f)
        (set! head (modulo (+ head 1) count))
        (decrease! size)
        (increase! popped))))
  
  
  (method public (pop-time self)
    (if (<= size 0)
        (error "Ring is empty")
      (prog1 (vector-ref content head)
        (f64vector-set! times head +nan.0)
        (vector-set! content head #f)
        (set! head (modulo (+ head 1) count))
        (decrease! size)
        (increase! popped)))))


;;;
;;;; Upload Queue
;;;


;; TODO
;; - make it so only the highest channel throttles
;; - we need some test to determine if the
;;   trial was a success or not and disable
;;   for 10s or whatever
;; - there was a case for (eq? (get-source-kind stream) 'image)
;;   in startup-mode that probably needs to be redone
;; - maybe the silly steps like 1.05 -> .05 -> 0. could be
;;   improved by the logic acting on something like < .1 or > .9


;; channel state
;;   #f
;;   running
;;   waiting
;;   closing


;; on keyframe
;;   when waiting
;;     set state to running


;; every second
;;   throttle
;;     throttle-logic
;;       for every stream
;;         throttle-stream
;;           for every channel
;;             throttle-channel
;;           match-needs
;;             if available-bitrate = 0
;;               startup-mode
;;             else
;;               satisfy-needs
;;               apply-levels
;;               maybe-trial
;;               update-levels
;;                 cleanup-closing
;;     apply bitrates
;;     update specs
;;       send specs and closing to server


(definition debug-logic?
  (world-setting 'world.debug-logic? #f))


(definition protected (encode-levels levels)
  (let ((bits 0))
    (for-each (lambda (level)
                (set! bits (bit-set bits level 1)))
              levels)
    (fixnum->flonum bits)))

(definition protected (present-levels bits)
  (format "{b width: 4 justify: :right padding: #\\0}" (flonum->fixnum bits)))


(class Upload-Queue extends Object
  
  
  (slot count         <fx>)
  (slot channels      <list>   getter generate)
  (slot video-streams          getter generate)
  (slot rings         <vector>)
  (slot missing-ring)
  (slot trial-ring)
  (slot trial-size)
  (slot trial-amount           getter generate)
  (slot trial-bitrate)
  (slot mutex                  initialize (make-mutex 'upload))
  (slot condition-variable     initialize (make-condition-variable 'upload))
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! count 2)
    (set! channels '())
    (set! video-streams #f)
    (set! missing-ring (new Upload-Ring 0 1.))
    (set! trial-ring (new Upload-Ring 0 #f))
    (set! trial-size media-trial-size)
    (set! trial-amount 0)
    (set! trial-bitrate 0)
    (set! rings (vector missing-ring trial-ring)))
  
  
  (method protected (register-channel self channel expire)
    (mutex-lock! mutex)
    (let ((ring (new Upload-Ring 0 expire)))
      (increase! count)
      (set! channels (cons channel channels))
      (set! video-streams #f)
      (set-upload-state channel #f)
      (set-upload-ring channel ring)
      (sort-channels self)
      (update-rings self))
    (mutex-unlock! mutex))
  
  
  (method protected (unregister-channel self channel)
    (mutex-lock! mutex)
    (decrease! count)
    (set! channels (remove! channel channels))
    (set! video-streams #f)
    (set-upload-state channel #f)
    (set-upload-ring channel #f)
    (sort-channels self)
    (update-rings self)
    (mutex-unlock! mutex))
  
  
  (method (sort-channels self)
    (define (determine-level channel)
      (if (= (get-media-kind channel) udp-audio)
          -1
        (or (get-level channel) 0)))
    
    (set! channels (sort (lambda (x y)
                           (let ((px (get-priority x))
                                 (py (get-priority y))
                                 (lx (determine-level x))
                                 (ly (determine-level y)))
                             (or (< px py)
                                 (and (= px py)
                                      (< lx ly)))))
                         channels)))
  
  
  (method (cache-video-streams self)
    (or video-streams
        (let ((lst '()))
          (for-each (lambda (channel)
                      (when (= (get-media-kind channel) udp-video)
                        (let ((stream (get-stream channel)))
                          (unless (memq? stream lst)
                            (set! lst (append! lst (list stream)))))))
                    channels)
          (set! video-streams lst)
          lst)))
  
  
  (method (update-rings self)
    (set! rings (make-vector count))
    (let ((last (- count 1)))
      (loop (for n from 0 below last)
            (for channel in channels)
            (vector-set! rings n (get-upload-ring channel)))
      (vector-set! rings (- last 1) missing-ring)
      (vector-set! rings last trial-ring)))
  
  
  (method (top-ring self) <Upload-Ring+>
    (declare (proper-tail-calls))
    (let (iter (n 0))
      (if (< n count)
          (let ((ring (vector-ref rings n)))
            (if (not (empty? ring))
                ring
              (iter (+ n 1))))
        #f)))
  
  
  (method public (size self)
    (mutex-lock! mutex)
    (prog1 (let ((size 0))
             (loop (for ring <Upload-Ring> in-vector rings)
                   (increase! size (get-size ring)))
             size)
      (mutex-unlock! mutex)))
  
  
  (method public (sizes self)
    (loop (for n from 0 below count)
          (collect (get-size (vector-ref rings n)))))
  
  
  (method public (empty? self)
    (mutex-lock! mutex)
    (prog1 (not (top-ring self))
      (mutex-unlock! mutex)))
  
  
  (method public (reset self)
    (mutex-lock! mutex)
    (loop (for ring <Upload-Ring> in-vector rings)
          (reset ring))
    (mutex-unlock! mutex))
  
  
  (method public (trim self channel)
    (mutex-lock! mutex)
    (reset (get-upload-ring channel))
    (when (eq? (get-upload-state channel) 'waiting)
      (debug-section self 'trim)
      (change-state self channel 'running))
    (mutex-unlock! mutex))
  
  
  (method (debug-logic self color rest)
    (when debug-logic?
      (if (not color)
          (apply tell rest)
        (let ((first? #t))
          (for-each (lambda (obj)
                      (when (not first?)
                        (format :terminal " "))
                      (if first?
                          (format :terminal "\033[{a}m{a}\033[39;49m" color obj)
                        (if (symbol? obj)
                            (format :terminal "\033[{a}m{a}\033[39;49m" terminal-magenta obj)
                          (format :terminal "{a}" obj)))
                      (set! first? #f))
                    rest))
        (format :terminal "{%}"))))
    
  
  (method (debug-stream self stream)
    (when debug-logic?
      (let ((title (get-name stream)))
        (format :terminal "\033[{a}m{a}\033[39;49m{%}" terminal-yellow title))))
    
  
  (method (debug-section self . rest)
    (debug-logic self terminal-cyan rest))
  
  
  (method (debug-to-server self . rest)
    (debug-logic self terminal-red (cons '>>>>>>>>>> rest)))
  
  
  (method (debug-from-server self . rest)
    (debug-logic self terminal-green (cons '<<<<<<<<<< rest)))
  
  
  (method (debug-action self . rest)
    (when debug-logic?
      (format :terminal "  {l}{%}" rest)))
  
  
  (method (debug-separator self)
    (when debug-logic?
      (tell)))
  
  
  (method (waiting? self stream)
    (let ((waiting? #f))
      (iterate-video-channels stream
        (lambda (level channel)
          (when (eq? (get-upload-state channel) 'waiting)
            (set! waiting? #t))))
      waiting?))
  
  
  (method (change-state self channel state)
    (set-upload-state channel state)
    (debug-action self (get-level channel) '-> state))
  
  
  (method public (throttle self task)
    (let ((streams (cache-video-streams self)))
      (bind-values (bitrate-changes levels-changes) (throttle-logic self streams)
        (let ((client (current-client)))
          (let ((udp-client (get-udp-client client)))
            ;; apply bitrates
            (when (not-null? bitrate-changes)
              (for-each (lambda (change)
                          (bind (channel-no . modifier) change
                            (with-reentrant-task-mutex
                              (lambda ()
                                (unless (stopping? task)
                                  (let ((channel (find-send-channel udp-client channel-no)))
                                    (when channel
                                      (change-bitrate channel modifier))))))))
                        bitrate-changes))
            ;; update specs
            (when (not-null? levels-changes)
              (for-each (lambda (change)
                          (bind (stream-no spec-levels closing-levels) change
                            (with-reentrant-task-mutex
                              (lambda ()
                                (unless (stopping? task)
                                  (let ((stream (find-send-stream udp-client stream-no)))
                                    (when stream
                                      (let ((upload-specs (update-specs client stream spec-levels closing-levels)))
                                        ;; quick solution for mac screen permissions
                                        (when upload-specs
                                          (debug-to-server self (map car upload-specs) closing-levels)
                                          ;; send specs and closing to server
                                          (change-upload-specs client stream-no upload-specs closing-levels))))))))))
                        levels-changes)))))
      (when (and debug-logic? (not-null? streams))
        (tell)
        (tell)))
    (when debug-upload?
      (invalidate-outputs (current-video))))
  
  
  (method (throttle-logic self streams)
    (mutex-lock! mutex)
    (let ((bitrate-changes (new-queue))
          (levels-changes (new-queue)))
      (when (not-null? streams)
        (let ((trial-ended? (> trial-amount 0)))
          (when trial-ended?
            (determine-trial-bitrate self))
          (let ((first? #t))
            (for-each (lambda (stream)
                        (if first?
                            (set! first? #f)
                          (when debug-logic?
                            (tell)))
                        (debug-stream self stream)
                        (let ((levels-info (throttle-stream self stream bitrate-changes)))
                          (when levels-info
                            (bind-values (spec-levels closing-levels) levels-info
                              (enqueue levels-changes (list (get-no stream) spec-levels closing-levels)))))
                        (when trial-ended?
                          (set-upload-trial stream #f)))
                      streams)))
        (set! trial-bitrate 0)
        (when (> trial-amount 0)
          (push-trial-amount self)))
      (let ((bitrate-changes (queue-list bitrate-changes))
            (levels-changes (queue-list levels-changes)))
        (mutex-unlock! mutex)
        (values bitrate-changes levels-changes))))
  
  
  (method (throttle-stream self stream bitrate-changes)
    (let ((current-bitrate 0))
      (iterate-video-channels stream
        (lambda (level channel)
          (when (get-upload-state channel)
            (increase! current-bitrate (throttle-channel self channel bitrate-changes))
            (reset-pushed/popped (get-upload-ring channel)))))
      (match-needs self stream (+ current-bitrate trial-bitrate) bitrate-changes)))
  
  
  (method (throttle-channel self channel bitrate-changes)
    (define (last-second-bitrate-sent-ratio)
      (let ((ring (get-upload-ring channel)))
        (let ((pushed <fl> (get-pushed ring))
              (popped <fl> (get-popped ring)))
          (if (= pushed 0.)
              #f
            (let ((sent-ratio (if ;; this can happen in normal behavior
                                  (> popped pushed)
                                  1.
                                (/ popped pushed))))
              ;; assumes that min-bitrate is half of max-bitrate
              (if (<= sent-ratio .5)
                  0.
                (* (- sent-ratio .5) 2.)))))))
    
    (let ((stream (get-stream channel))
          (level (get-level channel))
          (sent (last-second-bitrate-sent-ratio)))
      (when sent
        (let ((trimmed (- 1. sent))
              (modifier (get-upload-modifier channel)))
          (cond ;; lower bitrate
                ((> trimmed .1)
                 (unless (<= modifier 0.)
                   (let ((excess (- trimmed .1)))
                     (let ((decrease (+ .1 (/ excess 3.))))
                       (let ((new-modifier (max 0. (- modifier decrease))))
                         (debug-section self 'throttle-bitrate level new-modifier)
                         (set-upload-modifier channel new-modifier)
                         (enqueue bitrate-changes (cons (get-no channel) new-modifier))
                         (record-upload-modifier self channel new-modifier))))))
                ;; raise bitrate
                ((= trimmed 0.)
                 (unless (>= modifier 1.)
                   (let ((new-modifier (min (+ modifier .1) 1.)))
                     (debug-section self 'throttle-bitrate level new-modifier)
                     (set-upload-modifier channel new-modifier)
                     (enqueue bitrate-changes (cons (get-no channel) new-modifier))
                     (record-upload-modifier self channel new-modifier)))))))
      (let ((modifier (get-upload-modifier channel)))
        (if (= modifier 0.)
            ;; channel will not be used by satisfy-needs so use min bitrate
            (get-min-bitrate channel)
          ;; else use full bitrate
          (get-bitrate channel)))))
  
  
  (method (match-needs self stream available-bitrate bitrate-changes)
    (let ((needs (get-upload-needs stream)))
      (debug-section self 'match-needs 'needs needs 'available-bitrate available-bitrate)
      (cond ((null? needs)
             (apply-levels self stream '())
             (update-levels self stream '() bitrate-changes))
            ((= available-bitrate 0)
             (startup-mode self stream needs bitrate-changes))
            (else
             (bind-values (satisfied-levels unsatisfied-bitrate) (satisfy-needs self stream needs available-bitrate)
               (apply-levels self stream satisfied-levels)
               (maybe-trial self stream unsatisfied-bitrate)
               (update-levels self stream satisfied-levels bitrate-changes))))))
  
  
  (method (startup-mode self stream needs bitrate-changes)
    (debug-section self 'startup-mode 'needs needs)
    (let ((startup-bitrate 0))
      (for-each (lambda (need)
                  (increase! startup-bitrate (get-bitrate (locate-video-level-channel stream need))))
                needs)
      (add-trial self stream startup-bitrate)
      (update-levels self stream '() bitrate-changes)))
  
  
  (method (satisfy-needs self stream needs available-bitrate)
    (debug-section self 'satisfy-needs 'needs needs)
    (let ((satisfied-levels '())
          (unsatisfied-bitrate 0))
      (define (satisfy-need need)
        (let (loop (level need) (smallest need))
          ;; if nothing fits use smallest
          (if (< level 0)
              smallest
            (let ((channel (locate-video-level-channel stream level)))
              (if (not channel)
                  (loop (- level 1) smallest)
                (if (memv? level satisfied-levels)
                    level
                  (let ((bitrate (get-bitrate channel)))
                    ;; if bitrate fits use this level
                    (if (and (<= bitrate available-bitrate)
                             (/= (get-upload-modifier channel) 0.))
                        level
                      (loop (- level 1) level)))))))))
      
      ;; satisfy needs
      (for-each (lambda (need)
                  (let ((level (satisfy-need need)))
                    (when (/= level need)
                      (increase! unsatisfied-bitrate (get-bitrate (locate-video-level-channel stream need))))
                    (unless (memv? level satisfied-levels)
                      (let ((bitrate (get-bitrate (locate-video-level-channel stream level))))
                        (decrease! available-bitrate bitrate)
                        (set! satisfied-levels (cons level satisfied-levels))))))
                needs)
      (values (sort < satisfied-levels) unsatisfied-bitrate)))
  

  (method (apply-levels self stream satisfied-levels)
    (debug-section self 'apply-levels 'satisfied-levels satisfied-levels)
    (iterate-video-channels stream
      (lambda (level channel)
        (cond ((memv? level satisfied-levels)
               (case (get-upload-state channel)
                 ((#f)
                  (change-state self channel 'waiting))
                 ((waiting))
                 ((running))
                 ((closing)
                  (change-state self channel 'running))))
              (else
               (when (get-upload-state channel)
                 (change-state self channel 'closing)))))))
  
  
  (method (maybe-trial self stream unsatisfied-bitrate)
    (debug-section self 'maybe-trial 'unsatisfied-bitrate unsatisfied-bitrate)
    (when (> unsatisfied-bitrate 0)
      (let ((highest-channel (locate-highest-upload-channel stream)))
        (when (or (not highest-channel)
                  (= (get-upload-modifier highest-channel) 1.))
          (add-trial self stream unsatisfied-bitrate)))))
  
  
  (method (add-trial self stream unsatisfied-bitrate)
    ;; push a bit more to have some resilience
    (let ((amount (* unsatisfied-bitrate 1.2)))
      (debug-section self 'add-trial 'amount amount)
      (increase! trial-amount amount)
      ;; for debugging only
      (set-upload-trial stream amount)))
  
  
  (method (push-trial-amount self)
    (debug-separator self)
    (debug-section self 'trial-amount trial-amount)
    (let ((count (fxceiling (/ (kbps->bytes trial-amount) (cast <fl> trial-size)))))
      (loop (repeat count)
            (let ((data (make-u8vector trial-size)))
              (with-record media-trial
                (write-header-code data udp-code)
                (write-header-kind data udp-media-trial)
                (write-header-sender data tier-no))
              (push trial-ring data))))
    (condition-variable-signal! condition-variable)
    (when record-events?
      (record-event udp-id-trial-start
                    -1.
                    -1.
                    -1.
                    (kbps->mbps trial-amount)
                    -1.
                    -1.
                    -1.)))
  
  
  (method (determine-trial-bitrate self)
    (set! trial-amount 0)
    (set! trial-bitrate (bytes->kbps (* (get-popped trial-ring) trial-size)))
    (debug-section self 'trial-bitrate trial-bitrate)
    (debug-separator self)
    (reset trial-ring)
    (when record-events?
      (record-event udp-id-trial-end
                    -1.
                    -1.
                    -1.
                    (kbps->mbps trial-bitrate)
                    -1.
                    -1.
                    -1.)))
  
  
  (method (update-levels self stream spec-levels bitrate-changes)
    (let ((closing-levels (cleanup-closing self stream bitrate-changes)))
      (if (and (equal? spec-levels (get-upload-levels stream))
               (equal? closing-levels (get-upload-closing stream)))
          #f
        (set-upload-levels stream spec-levels)
        (set-upload-closing stream closing-levels)
        (record-upload-levels self spec-levels closing-levels)
        (values spec-levels closing-levels))))
  
  
  (method (cleanup-closing self stream bitrate-changes)
    (let ((waiting? (waiting? self stream))
          (closing-levels (new-queue)))
      (debug-section self 'cleanup-closing)
      (iterate-video-channels stream
        (lambda (level channel)
          (when (eq? (get-upload-state channel) 'closing)
            (if waiting?
                (enqueue closing-levels (get-level channel))
              (set-upload-modifier channel 1.)
              (enqueue bitrate-changes (cons (get-no channel) 1.))
              (record-upload-modifier self channel 1.)
              (change-state self channel #f)))))
      (queue-list closing-levels)))
  
  
  (method public (update-needs self stream upload-needs)
    (mutex-lock! mutex)
    (debug-from-server self upload-needs)
    (set-upload-needs stream upload-needs)
    (mutex-unlock! mutex)
    (record-upload-needs self upload-needs))
  
  
  (method (record-upload-needs self upload-needs)
    (when record-events?
      (record-event udp-id-upload-needs
                    -1.
                    -1.
                    -1.
                    (encode-levels upload-needs)
                    -1.
                    -1.
                    -1.)))
  
  
  (method (record-upload-levels self spec-levels closing-levels)
    (when record-events?
      (record-event udp-id-upload-levels
                    -1.
                    -1.
                    -1.
                    (encode-levels spec-levels)
                    (encode-levels closing-levels)
                    -1.
                    -1.)))
  
  
  (method (record-upload-modifier self channel modifier)
    (when record-events?
      (record-event udp-id-upload-modifier
                    (fixnum->flonum (get-no channel))
                    (fixnum->flonum (get-origin (get-stream channel)))
                    (fixnum->flonum (get-media-kind channel))
                    modifier
                    -1.
                    -1.
                    -1.)))
  
  
  (method public (push self channel data)
    (mutex-lock! mutex)
    (push (get-upload-ring channel) data)
    (mutex-unlock! mutex)
    (condition-variable-signal! condition-variable))
  
  
  (method public (push-time self channel data)
    (mutex-lock! mutex)
    (push-time (get-upload-ring channel) data)
    (mutex-unlock! mutex)
    (condition-variable-signal! condition-variable))
  
  
  (method public (push-missing self data)
    (mutex-lock! mutex)
    (push-time missing-ring data)
    (mutex-unlock! mutex)
    (condition-variable-signal! condition-variable))
  
  
  (method public (push-done self)
    (mutex-lock! mutex)
    (push-time missing-ring (eof-object))
    (mutex-unlock! mutex)
    (condition-variable-signal! condition-variable))
  
  
  (method public (pop self timeout)
    (declare (proper-tail-calls))
    (let (iter)
      (mutex-lock! mutex)
      (let ((ring (top-ring self)))
        (cond (ring
               (prog1 (pop ring)
                 (mutex-unlock! mutex)))
              ((mutex-unlock! mutex condition-variable timeout)
               (iter))
              (else
               (eof-object)))))))


;;;
;;;; Receive Base
;;;


(definition stop-rising-grace <fx>
  (flonum->timestamp .1))

(definition plateau-grace <fx>
  (flonum->timestamp 1.))

(definition plateau-sampling <fx>
  (flonum->timestamp 2.))

(definition drop-minimum <fx>
  (flonum->timestamp 0.05))

(definition drop-into-bumps-minimum <fx>
  (flonum->timestamp 0.2))

(definition minimum-duration <fx>
  (flonum->timestamp .2))


(class UDP-Receive-Base extends UDP-Base
  
  
  (slot stream           getter generate)
  (slot media-kind       getter generate)
  (slot source-kind      getter generate)
  (slot rise-tolerance   getter generate)
  (slot last-raw-latency getter generate)
  (slot plateau-start    getter generate)
  (slot plateau-highest  getter generate)
  (slot state            getter generate)
  (slot ring             accessors generate)
  
  (slot contour-start                 getter generate)
  (slot contour-raw-latency      <fx> getter generate)
  (slot contour-latency          <fx> getter generate)
  (slot contour-last-raw-latency      getter generate)
  (slot contour-plateau-start         getter generate)
  (slot contour-plateau-highest       getter generate)
  (slot contour-state                 getter generate)
  (slot contour-history               getter generate)
  
  
  (method override (initialize self stream media-kind source-kind)
    (nextmethod self)
    (set! self.stream stream)
    (set! self.media-kind media-kind)
    (set! self.source-kind (if live-streaming? 'live source-kind))
    (set! self.rise-tolerance (if (= media-kind udp-audio) udp-audio-tolerance udp-video-tolerance))
    (set! self.last-raw-latency 0)
    (set! self.plateau-start 0)
    (set! self.plateau-highest #f)
    (set! self.state 'plateau)
    (reset-contour self))
  
  
  (method override (reset self)
    (nextmethod self)
    (set! self.last-raw-latency 0)
    (set! self.plateau-start 0)
    (set! self.plateau-highest #f)
    (set! self.state 'plateau)
    (reset-contour self))
  
  
  (method (reset-contour self)
    (set! self.contour-raw-latency 0)
    (set! self.contour-latency 0)
    (set! self.contour-last-raw-latency 0)
    (set! self.contour-plateau-start 0)
    (set! self.contour-plateau-highest #f)
    (set! self.contour-state 'plateau)
    (set! self.contour-history (new Windowed-History 30. 60)))
  
  
  (method protected virtual (voice-under-threshold? self)
    #t)
  
  
  (method (update-contour-base self local remote)
    (set! contour-start (current-seconds))
    (set! contour-raw-latency 0)
    (set! contour-latency 0)
    (set! contour-plateau-start local)
    (set! contour-plateau-highest #f))
  
  
  (method (update-contour self local remote raw)
    (define (reset-plateau)
      (set! contour-plateau-start local)
      (set! contour-plateau-highest #f))
    
    (define (record-plateau latency)
      (let ((latency (timestamp->flonum latency)))
        (record contour-history (current-seconds) latency)
        (when record-events?
          (record-event udp-id-contour-latency
                        -1.
                        -1.
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        latency
                        -1.))))
    
    (set! contour-raw-latency raw)
    (case contour-state
      ((plateau)
       (cond ;; up
             ((> raw (+ contour-latency rise-tolerance))
              (set! contour-state 'rise)
              (set! contour-latency +inf.ts)
              (set! contour-last-raw-latency raw)
              (record-plateau raw))
             ;; extend
             ((>= raw (- contour-latency drop-minimum))
              (reset-plateau))
             ;; down
             ((>= local (+ contour-plateau-start plateau-grace))
              (when (or (not contour-plateau-highest)
                        (> raw contour-plateau-highest))
                (set! contour-plateau-highest raw))
              (let ((plateau-time (- local contour-plateau-start)))
                ;; fall
                (when (>= plateau-time plateau-sampling)
                  (set! contour-latency contour-plateau-highest)
                  (reset-plateau)
                  (record-plateau contour-latency))))))
      ((rise)
       (if (> raw contour-last-raw-latency)
           (set! contour-last-raw-latency raw)
         ;; plateau
         (set! contour-state 'plateau)
         (set! contour-latency (+ contour-last-raw-latency stop-rising-grace))
         (reset-plateau)
         (record-plateau contour-latency)))))
  
  
  (method override (update-time self local remote update-proc)
    (let ((new-base (- local remote)))
      (define (reset-plateau)
        (set! plateau-start local)
        (set! plateau-highest #f))
      
      (define (analyse-bumps target)
        (let ((now (current-seconds))
              ;; include slightly lower bumps
              (target (- (timestamp->flonum target) .05))
              (rising? #t)
              (total 0.)
              (count 0)
              (bumps 0))
          (let ((starting? (< (- now contour-start) 20.))
                (previous target))
            (iterate-window contour-history now
              (lambda (time latency)
                (cond ((>= latency previous)
                       (set! rising? #t))
                      (else
                       (when rising?
                         (let ((top previous))
                           (when (>= top target)
                             ;; skip first bump and average next 3
                             (when (and (> bumps 0) (< count 3))
                               (increase! total top)
                               (increase! count))
                             (increase! bumps))))
                       (set! rising? #f)))
                (set! previous latency)))
            (and (>= bumps (if starting? 2 3))
                 (flonum->timestamp (/ total (cast <fl> count)))))))
      
      (if (not base)
          (begin
            (set! base new-base)
            (set! raw-latency 0)
            (set! latency 0)
            (reset-plateau)
            (update-contour-base self local remote)
            (update-latency stream media-kind raw-latency latency)
            (update-proc raw-latency latency))
        (unless (eq? source-kind 'image)
          (let ((raw (- new-base base)))
            (set! raw-latency raw)
            (update-contour self local remote raw)
            (case state
              ((plateau)
               (cond ;; up
                     ((> raw (+ latency rise-tolerance))
                      (set! state 'rise)
                      (set! latency +inf.ts)
                      (set! last-raw-latency raw))
                     ;; extend
                     ((>= raw (- latency drop-minimum))
                      (reset-plateau))
                     ;; down
                     ((and (eq? source-kind 'live)
                           (>= local (+ plateau-start plateau-grace)))
                      (when (or (not plateau-highest)
                                (> raw plateau-highest))
                        (set! plateau-highest raw))
                      (let ((plateau-time (- local plateau-start)))
                        ;; fall
                        (when (and (>= plateau-time plateau-sampling)
                                   (voice-under-threshold? self))
                          (let ((bumps-average (analyse-bumps plateau-highest)))
                            (if bumps-average
                                (let ((drop (- latency bumps-average)))
                                  (when (>= drop drop-into-bumps-minimum)
                                    (set! latency bumps-average)))
                              (set! latency plateau-highest)))
                          (reset-plateau))))))
              ((rise)
               (if (> raw last-raw-latency)
                   (set! last-raw-latency raw)
                 ;; plateau
                 (set! state 'plateau)
                 (set! latency (+ last-raw-latency stop-rising-grace))
                 (reset-plateau))))
            ;; update
            (update-latency stream media-kind raw-latency latency)
            (update-proc raw-latency latency))))))
  
  
  (method override (update-past self local remote)
    (when (neq? source-kind 'live)
      (unless (eq? state 'rise)
        (let ((running-latency (running-time-latency self local remote)))
          (when (> running-latency (+ latency rise-tolerance))
            (set! latency running-latency)
            (set! state 'plateau)
            (set! plateau-start local)
            (set! plateau-highest #f)
            (update-past-latency stream media-kind latency))))))
  
  
  (method (running-time-latency self local remote)
    (- local (+ base remote)))
  
  
  (method override (effective-latency self)
    (media-latency stream media-kind))
  
  
  (method protected (latency-remote->local self latency remote) <fx>
    (+ base remote latency)))


(definition voice-threshold <fl>
  10.)


(class UDP-Audio-Base extends UDP-Receive-Base
  
  
  (method override (voice-under-threshold? self)
    (<= (voice-percentage ring) voice-threshold)))


(class UDP-Video-Base extends UDP-Receive-Base)


;;;
;;;; Receive Ring
;;;


(class UDP-Receive-Ring extends UDP-Ring
  
  
  (slot flow initialize #f accessors generate)
  @assert-mutex
  (slot flow initialize #f getter generate)
  
  
  @assert-mutex
  (method public (set-flow self fl)
    (assert-mutex self 'set-flow)
    (set! flow fl))
  
  
  (method override (local-timestamp self)
    ;; quick hack todo
    (and flow
    (running-time flow)))
  
  
  (method protected (determine-write-time self packet <UDP-Packet> latency <fx> process-window <fx>) <fx>
    (let ((dts (get-dts packet)))
      (let ((time (latency-remote->local time-base latency dts)))
        (+ time process-window)))))


;;;
;;;; Audio Ring
;;;


(definition audio-clock-resolution <fl>
  .01)


(definition not-ready-max-sleep <fl>
  .1)


(definition (not-ready-sleep mutex timeout)
  (mutex-unlock! mutex)
  (sleep (min not-ready-max-sleep timeout)))


(definition voice-size
  100)

(definition (make-windowed-voice)
  (new Windowed-Count voice-size))


(class UDP-Audio-Ring extends UDP-Receive-Ring
  
  
  (slot windowed-voice initialize (make-windowed-voice) getter generate)
  
  
  (method override (empty self)
    (nextmethod self)
    (set! windowed-voice (make-windowed-voice)))
  
  
  (method override (audio-added self packet)
    (record windowed-voice (if (has-voice? packet) 1 0)))
  
  
  (method package (voice-percentage self)
    (percentage (get-count windowed-voice) voice-size))
  
  
  (method package (process-audio self channel exit)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (wake-audio self channel exit loop-wait)))
  
  
  (method (wake-audio self channel exit loop-wait)
    (declare (proper-tail-calls))
    (if terminate?
        (continuation-return exit #f)
      (mutex-lock! mutex)
      ;; empty
      (if (= count 0)
          (begin
            (mutex-unlock! mutex wait-condvar)
            (loop-wait))
        (let ((latency (effective-latency time-base)))
          ;; rising
          (if (or (= latency +inf.ts)
                  ;; quick hack todo
                  (not flow))
              (begin
                (mutex-unlock! mutex wait-condvar audio-clock-resolution)
                (loop-wait))
            (let ((running-time (running-time flow))
                  (earliest <UDP-Packet> (vector-ref packets head)))
              (let ((write-time (determine-write-time self earliest latency (process-window flow))))
                (let ((giveup-time (+ write-time udp-audio-giveup)))
                  (cond ;; giveup
                        ((>= running-time giveup-time)
                         (flush-earliest self)
                         (mutex-unlock! mutex)
                         (loop-wait))
                        ;; not ready
                        ((< running-time write-time)
                         (not-ready-sleep mutex (max audio-clock-resolution (timestamp->flonum (- write-time running-time))))
                         (loop-wait))
                        ;; frame
                        ((complete-frame? self)
                         (site process-audio
                           (bind-values (sender packet buffer) (extract-complete self)
                             (give-audio channel sender packet buffer (get-base time-base) latency)))
                         (mutex-unlock! mutex)
                         (loop-wait))
                        ;; not live wakeup on giveup
                        ((neq? source-kind 'live)
                         (mutex-unlock! mutex wait-condvar (timestamp->flonum (- giveup-time running-time)))
                         (loop-wait))
                        ;; live flush
                        (else
                         (flush-earliest self)
                         (mutex-unlock! mutex)
                         (loop-wait))))))))))))


;;;
;;;; Video Ring
;;;


(class UDP-Video-Ring extends UDP-Receive-Ring
  
  
  (method package (state-play self)
    (unless (eq? state 'play)
      (set! state 'play)
      (thaw flow)
      (unless (emulation?)
        (when record-events?
          (record-event udp-id-state-play
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        -1.)))))
  
  
  (method package (state-freeze self)
    (unless (eq? state 'freeze)
      (set! state 'freeze)
      (freeze flow)
      (unless (emulation?)
        (when record-events?
          (record-event udp-id-state-freeze
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        -1.)))))
  
  
  (method package (process-video self channel exit)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (wake-video self channel exit loop-wait)))
  
  
  (method (wake-video self channel exit loop-wait)
    (declare (proper-tail-calls))
    (if terminate?
        (continuation-return exit #f)
      (mutex-lock! mutex)
      ;; empty
      (if (= count 0)
          (begin
            (mutex-unlock! mutex wait-condvar)
            (loop-wait))
        (let ((latency (effective-latency time-base)))
          ;; rising
          (if (or (= latency +inf.ts)
                  ;; quick hack todo
                  (not flow))
              (begin
                (mutex-unlock! mutex wait-condvar .01)
                (loop-wait))
            @assert-mutex
            (assert-mutex self 'wake-video)
            (let ((running-time (running-time flow))
                  (earliest <UDP-Packet> (vector-ref packets head)))
              (let ((write-time (determine-write-time self earliest latency (process-window flow))))
                (let ((late-time (+ write-time udp-video-late))
                      (giveup-time (+ write-time udp-video-giveup)))
                  (cond ;; giveup
                        ((>= running-time giveup-time)
                         (flush-earliest self)
                         (state-wait self)
                         (mutex-unlock! mutex)
                         (loop-wait))
                        ;; wait
                        ((eq? state 'wait)
                         (let ((keyframe (complete-keyframe self)))
                           (cond ;; keyframe
                                 (keyframe
                                  (let ((packet (packet-ref self keyframe)))
                                    (let ((packet-write (determine-write-time self packet latency udp-video-process)))
                                      (cond ;; not ready
                                            ((< running-time packet-write)
                                             (not-ready-sleep mutex (timestamp->flonum (- packet-write running-time)))
                                             (loop-wait))
                                            ;; ready
                                            (else
                                             (flush-before self keyframe)
                                             (state-ok self)
                                             (mutex-unlock! mutex)
                                             (loop-wait))))))
                                 ;; no keyframe
                                 (else
                                  (mutex-unlock! mutex wait-condvar (timestamp->flonum (- giveup-time running-time)))
                                  (loop-wait)))))
                        ;; not ready
                        ((< running-time write-time)
                         (not-ready-sleep mutex (timestamp->flonum (- write-time running-time)))
                         (loop-wait))
                        ;; frame
                        ((complete-frame? self)
                         (cond ;; ontime
                               ((or (< running-time late-time)
                                    (eq? source-kind 'image))
                                (state-play self))
                               ;; late
                               (else
                                (state-freeze self)))
                         (site process-video
                           (bind-values (sender packet buffer) (extract-complete self)
                             (give-video channel sender packet buffer (get-base time-base) latency)))
                         (mutex-unlock! mutex)
                         (loop-wait))
                        ;; wakeup on late
                        ((< running-time late-time)
                         (mutex-unlock! mutex wait-condvar (timestamp->flonum (- late-time running-time)))
                         (loop-wait))
                        ;; wakeup on giveup
                        (else
                         (let ((keyframe (complete-keyframe self)))
                           ;; use keyframe if available
                           (cond (keyframe
                                  (flush-before self keyframe)
                                  (mutex-unlock! mutex)
                                  (loop-wait))
                                 (else
                                  (mutex-unlock! mutex wait-condvar (timestamp->flonum (- giveup-time running-time)))
                                  (loop-wait)))))))))))))))


;;;
;;;; Receive Stream
;;;


(class UDP-Receive-Stream extends UDP-Stream
  
  
  (slot waiting-video           initialize #f accessors generate)
  (slot audio-video-sync-mutex  initialize (make-mutex 'latency) getter generate)
  (slot audio-on?               initialize #t getter generate)
  (slot audio-time        <fl+> initialize #f getter generate)
  (slot audio-raw         <fx+> initialize #f getter generate)
  (slot audio-latency     <fx+> initialize #f getter generate)
  (slot video-time        <fl+> initialize #f getter generate)
  (slot video-raw         <fx+> initialize #f getter generate)
  (slot video-latency     <fx+> initialize #f getter generate)
  (slot moving-base       <fl+> initialize #f getter generate)
  (slot base              <fx+> initialize #f getter generate)
  
  
  (method override (initialize self sender name no origin source-kind video-levels)
    (nextmethod self sender name no origin source-kind video-levels)
    (when live-streaming?
      (set! self.source-kind 'live)))
  
  
  (method package (close-waiting-video self)
    (when waiting-video
      (let ((waiting-channel (get-channel waiting-video)))
        (set-flow (get-process-ring waiting-channel) #f)
        (set-output waiting-channel #f)
        (release waiting-video)
        (close waiting-video)
        (set! waiting-video #f))))

  
  (method package (with-locked-channels self thunk (media-kind #f))
    (table-iterate channels
      (lambda (no channel)
        (when (or (not media-kind)
                  (= media-kind (get-media-kind channel)))
          (mutex-lock! (get-mutex (get-process-ring channel))))))
    (prog1 (thunk)
      (table-iterate channels
        (lambda (no channel)
          (when (or (not media-kind)
                    (= media-kind (get-media-kind channel)))
            (mutex-unlock! (get-mutex (get-process-ring channel))))))))
  
  
  (method package (media-on self media-kind)
    (mutex-lock! audio-video-sync-mutex)
    (when (= media-kind udp-audio)
      (set! audio-on? #t))
    (mutex-unlock! audio-video-sync-mutex))
  
  
  (method package (media-off self media-kind)
    (mutex-lock! audio-video-sync-mutex)
    (when (= media-kind udp-audio)
      (set! audio-on?     #f)
      (set! audio-time    #f)
      (set! audio-raw     #f)
      (set! audio-latency #f)
      (set! moving-base   #f)
      (set! base          #f))
    (mutex-unlock! audio-video-sync-mutex))
  
  
  (method package (only-audio? self)
    (let ((only-audio? #t))
      (table-iterate channels
        (lambda (no channel)
          (when (and (= (get-media-kind channel) udp-video)
                     (eq? (get-send-state channel) 'on))
            (set! only-audio? #f))))
      only-audio?))
  
  
  (method package (reset-video-latency self)
    (mutex-lock! audio-video-sync-mutex)
    (set! video-time    #f)
    (set! video-raw     #f)
    (set! video-latency #f)
    (set! moving-base   #f)
    (set! base          #f)
    (mutex-unlock! audio-video-sync-mutex))
  
  
  (method package (update-latency self media-kind raw-latency latency)
    (mutex-lock! audio-video-sync-mutex)
    (let ((now (current-seconds)))
      (define (update-base)
        (when (< (abs (- audio-time video-time)) .01)
          (let ((fresh-base (- video-raw audio-raw)))
            (when (not base)
              (set! base fresh-base))
            (let ((fresh (timestamp->flonum fresh-base)))
              (if (not moving-base)
                  (set! moving-base fresh)
                (set! moving-base (/ (+ (* moving-base 63.) fresh) 64.)))))
          (when (> (abs (- moving-base (timestamp->flonum base))) .01)
            (set! base (flonum->timestamp moving-base)))))
      
      (ecase media-kind
        ((udp-audio)
         (set! audio-time now)
         (set! audio-raw raw-latency)
         (set! audio-latency latency)
         (when video-raw
           (update-base)))
        (else
         (set! video-time now)
         (set! video-raw raw-latency)
         (set! video-latency latency)
         (when audio-raw
           (update-base)))))
    (mutex-unlock! audio-video-sync-mutex))
  
  
  (method package (update-past-latency self media-kind latency)
    (mutex-lock! audio-video-sync-mutex)
    (ecase media-kind
      ((udp-audio)
       (set! audio-latency latency))
      (else
       (set! video-latency latency)))
    (mutex-unlock! audio-video-sync-mutex))
  
  
  (method package (media-latency self media-kind)
    (mutex-lock! audio-video-sync-mutex)
    (prog1 (if (neq? source-kind 'live)
               ;; non-live take max of audio and video
               (ecase media-kind
                 ((udp-audio)
                  (cond ((or (not video-latency)
                             (not base))
                         audio-latency)
                        ((= video-latency +inf.ts)
                         video-latency)
                        (else
                         (max (- video-latency base)
                              audio-latency))))
                 (else
                  (cond ((or (not audio-latency)
                             (not base))
                         video-latency)
                        ((= audio-latency +inf.ts)
                         audio-latency)
                        (else
                         (max (+ audio-latency base)
                              video-latency)))))
             ;; live slave video to audio
             (ecase media-kind
               ((udp-audio)
                audio-latency)
               (else
                (cond ((or (not audio-on?)
                           (not base))
                       video-latency)
                      ((= audio-latency +inf.ts)
                       audio-latency)
                      (else
                       (+ audio-latency base))))))
      (mutex-unlock! audio-video-sync-mutex))))


;;;
;;;; Receive Channel
;;;


(definition protected max-audio-gap
  5)


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot process-ring                    getter generate)
  (slot process-task                    getter generate)
  (slot replay-ring                     getter generate)
  (slot insert-rate-frame               getter generate)
  (slot insert-rate                     getter generate)
  (slot process-rate                    getter generate)
  (slot expected-pts      initialize #f getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (nextmethod self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (set! self.replay-ring (and (developer?) record-media? (remember-ring media-kind source-kind level framerate)))
    (let ((time-base (cond ((simulation?)
                            (new UDP-Visualizer-Base))
                           ((= media-kind udp-audio)
                            (new UDP-Audio-Base stream media-kind source-kind))
                           (else
                            (new UDP-Video-Base stream media-kind source-kind)))))
      (set! self.process-ring (ecase media-kind
                                ((udp-audio)
                                 (new UDP-Audio-Ring self no (get-origin stream) media-kind source-kind udp-process-size max-size: udp-process-max-size time-base: time-base overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
                                (else
                                 (new UDP-Video-Ring self no (get-origin stream) media-kind source-kind udp-process-size max-size: udp-process-max-size time-base: time-base overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))))
      (unless (simulation?)
        (set-ring time-base self.process-ring)))
    (unless (simulation?)
      (set! self.process-task (if (= media-kind udp-audio)
                                  (new Task (list 'process-audio (determine-channel-name self)) (~ run-process-audio self) priority: process-audio-priority)
                                (new Task (list 'process-video (determine-channel-name self) (level->graphic-profile-name level)) (~ run-process-video self) priority: process-video-priority))))
    (set! self.insert-rate-frame 0)
    (set! self.insert-rate (new Rate))
    (set! self.process-rate (new Rate))
    (unless (simulation?)
      (start-task process-task)))
  
  
  (method override (destroy self)
    @assert-mutex
    (assert-mutex self 'destroy)
    (terminate process-ring)
    (let ((mutex (get-mutex process-ring)))
      (mutex-unlock! mutex)
      (thread-join! (get-thread process-task))
      (mutex-lock! mutex))
    (nextmethod self))
  
  
  @assert-mutex
  (method protected (assert-mutex self tag)
    (assert process-ring
      (assert-mutex process-ring tag)))
  
  
  (method override (receiver? self)
    #t)
  
  
  (method package (remember-media self data)
    (when replay-ring
      (remember replay-ring data)))
  
  
  (method package (insert-media self data)
    (with-record media
      (let ((frame (read-media-frame data)))
        (when (or (not insert-rate-frame)
                  (> frame insert-rate-frame))
          (update insert-rate)
          (set! insert-rate-frame frame))))
    (insert-unlocked process-ring data #f))
  
  
  (method package (channel-on self)
    (set! send-state 'on))
  
  
  (method package (channel-off self)
    (set! send-state 'off)
    (reset self))
  
  
  (method override (reset self)
    (reset process-ring)
    (set! expected-pts #f)
    (when output
      (reset output)))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (run-process-audio self task)
    (with-task task
      (lambda (exit)
        (process-audio process-ring self exit))))
  
  
  (method (run-process-video self task)
    (with-task task
      (lambda (exit)
        (process-video process-ring self exit))))
  
  
  (method (record-play-frame self sender frame flags dts pts)
    (when record-play?
      (record-event udp-id-play-frame
                    (fixnum->flonum no)
                    (fixnum->flonum sender)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (fixnum->flonum flags)
                    (timestamp->flonum dts))))
  
  
  (method (record-freeze-frame self sender frame flags dts pts)
    (when record-play?
      (record-event udp-id-freeze-frame
                    (fixnum->flonum no)
                    (fixnum->flonum sender)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (fixnum->flonum flags)
                    (timestamp->flonum dts))))
  

  (method package (give-audio self sender packet buffer base latency)
    (let ((frame (get-frame packet))
          (dts (get-dts packet))
          (pts (get-pts packet))
          (duration (get-duration packet))
          (flags (get-flags packet)))
      (let ((dts (max 0 (+ dts latency)))
            (pts (max 0 (+ pts latency))))
        (define (receive)
          (receive-audio (current-audio) output buffer dts pts duration base)
          (set! expected-pts (+ pts duration)))
        
        (define (receive-gap pts duration)
          (receive-audio (current-audio) output #f pts pts duration base))
        
        (cond ;; perfect timestamp
              ((or (not expected-pts)
                   (= pts expected-pts))
               (receive))
              ;; generate gap for opus packet loss concealment
              ((> pts expected-pts)
               (let ((gap (- pts expected-pts)))
                 (when (< gap udp-audio-mixer)
                   (receive-gap expected-pts gap)))
               (receive))
              ;; do not send decreasing timestamps
              ))
      @convert-to-buffer
      (when recorder
        (world.recording:record-media recorder buffer dts pts duration flags))
      (record-play-frame self sender frame flags dts pts)))
  
  
  (method package (give-video self sender packet buffer base latency)
    (let ((frame (get-frame packet))
          (total (get-total packet))
          (dts (get-dts packet))
          (pts (get-pts packet))
          (duration (get-duration packet))
          (flags (get-flags packet)))
      (let ((dts (max 0 (+ dts latency)))
            (pts (max 0 (+ pts latency))))
        (receive-video (current-video) output buffer dts pts duration flags base))
      @convert-to-buffer
      (when recorder
        (world.recording:record-media recorder buffer dts pts duration flags))
      (update process-rate)
      (if (eq? (get-state process-ring) 'late)
          (record-freeze-frame self sender frame flags dts pts)
        (record-play-frame self sender frame flags dts pts))))))
