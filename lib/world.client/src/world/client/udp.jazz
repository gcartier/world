;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.math)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.audio)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.time)
        (world.udp)
        (world.video))


(class UDP-Client extends UDP-Tier
  
  
  (slot client-no                  initialize #f getter generate)
  (slot character-name             initialize #f getter generate)
  (slot udp-port                   initialize #f getter generate)
  (slot udp-stopping?              initialize #f getter generate)
  @peer2peer
  (slot local-host                 initialize #f getter generate)
  @peer2peer
  (slot local-port                 initialize #f getter generate)
  (slot server-host                initialize #f getter generate)
  (slot server-port                initialize #f getter generate)
  (slot write-mutex                initialize #f getter generate)
  (slot receive-streams            initialize #f getter generate)
  (slot receive-channels           initialize #f getter generate)
  (slot receive-task               initialize #f getter generate)
  (slot state-task                 initialize #f getter generate)
  (slot state-sequence             initialize 0  getter generate)
  (slot started?                   initialize #f getter generate)
  (slot monitor                    initialize #f getter generate)
  (slot statistics                 initialize #f getter generate)
  (slot last-received-ack          initialize #f getter generate)
  (slot throttle-media?            initialize #f getter generate)
  (slot topology                   initialize #f getter generate)
  @peer2peer
  (slot peers                      initialize #f getter generate)
  @peer2peer
  (slot peers-mutex                initialize #f getter generate)
  (slot profile-heartbeat-sequence initialize #f getter generate)
  (slot profile-media-sequence     initialize #f getter generate)
  (slot profile-last-sequence      initialize #f getter generate)
  (slot profile-monitor            initialize #f getter generate)
  (slot profile-statistics         initialize #f getter generate)
  (slot profile-chronology         initialize #f getter generate)
  (slot profile-evolution          initialize #f getter generate)
  (slot simulator                  initialize #f accessors generate)
  
  
  (method override (initialize self client-no character-name)
    (nextmethod self)
    (set! self.client-no client-no)
    (set! self.character-name character-name)
    (set! write-mutex (make-mutex 'write))
    (set! receive-streams (make-table))
    (set! receive-channels (make-table)))
  
  
  (method package (connect self local-address host service)
    ;; quick heuristic
    @peer2peer
    (define (determine-local-host)
      (if local?
          #u8(127 0 0 1)
        (let ((info (host-info (host-name))))
          (let ((addresses (host-info-addresses info)))
            (if (= 1 (length addresses))
                (car addresses)
              #u8(0 0 0 0))))))
    
    (unless (simulation?)
    (set! udp-port (open-udp (list
                               local-address: local-address
                               address: host
                               port-number: service)))
    (set! udp-stopping? #f)
    (let (@peer2peer (local-host (determine-local-host))
          @peer2peer (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (mutex-lock! write-mutex)
        (let ((data (make-u8vector (+ 8 4 4 @peer2peer 4 @peer2peer 4 4 4 4 4))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-connect)
          (write-udp-sender data client-no)
          @peer2peer
          (write-udp-connect-local-host data local-host)
          @peer2peer
          (write-udp-connect-local-port data local-port)
          (write-udp-connect-latency data (or udp-latency -1.))
          (write-udp-connect-lag data (or udp-lag -1.))
          (write-udp-connect-drop data (or udp-drop -1.))
          (write-udp-connect-video-level data (or (video-profile-level) -1))
          (write-data data udp-port))
        (mutex-unlock! write-mutex))
      
      @peer2peer (set! self.local-host local-host)
      @peer2peer (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! monitor (new UDP-Monitor))
      (set! statistics (new UDP-Statistics))
      (set! topology (world-setting 'world.udp-topology 'server))
      @peer2peer (set! peers (make-table))
      @peer2peer (set! peers-mutex (make-mutex 'peers))
      (set! simulator (if (or udp-latency udp-lag udp-drop udp-congestion udp-simulation)
                          (cond-expand
                            (devel (new UDP-Simulator udp-latency udp-lag udp-drop
                                        (lambda (data drop?)
                                          (if drop?
                                              (increase-sent self data)
                                            @fix-me-can-deadlock-the-threads
                                            (mutex-lock! write-mutex)
                                            (send-topology self data)
                                            @fix-me-can-deadlock-the-threads
                                            (mutex-unlock! write-mutex)))))
                            (else #f))
                        #f))
      (record-event udp-id-connecting
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.)
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (if (or (eof-object? reply) (not (= (read-udp-kind reply) udp-connected)))
                (if (>= n 100)
                    (begin
                      (terminal 'BAILOUT 'did 'not 'receive 'udp-connected)
                      (exit 1))
                  (loop (+ n 1)))
              (let ((source-info (udp-source-socket-info udp-port)))
                (set! server-host (socket-info-address source-info))
                (set! server-port (socket-info-port-number source-info)))
              (let ((round-trip (- (current-seconds) (read-udp-sent reply))))
                (record-event udp-id-connected
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              round-trip
                              -1.)
                (when udp-show-roundtrip?
                  (format :terminal "{s} {s} {s}{%}" remote-name '***roundtrip*** round-trip))))))))))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (unless (simulation?)
        (set! receive-task (new Task 'udp-receive (lambda (task)
                                                    (receive-loop self task))
                                priority: udp-priority))
        (start-task receive-task)
        (set! state-task (new Task 'udp-state (lambda (task)
                                                (state-loop self task))
                              priority: udp-priority))
        (start-task state-task))
      (set! last-received-ack (current-seconds))
      (set! throttle-media? #f)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (exit-thread (get-thread receive-task))
      (thread-join! (get-thread receive-task))
      (set! receive-task #f)
      (thread-send (get-thread state-task) #t)
      (thread-join! (get-thread state-task))
      (set! state-task #f)
      (set! started? #f)))
  
  
  (method protected (increase-sent self data)
    (increase-sent monitor data))
  
  
  (method protected (increase-received self data)
    (increase-received monitor data))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (set! profile-heartbeat-sequence 0)
    (set! profile-media-sequence 0)
    (set! profile-last-sequence 0)
    (set! profile-monitor (new UDP-Monitor))
    (set! profile-statistics (new UDP-Statistics))
    (set! profile-chronology (new Chronology 0))
    (set! profile-evolution (new Evolution 5000)))
  
  
  (method package (retrieve-profile self)
    (let ((metadata (list client-no character-name '() '()))
          (chronology (copy-chronology profile-chronology))
          (evolution (copy-evolution profile-evolution)))
      (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
  
  
  (method package (stop-profile self)
    (set! profile-chronology #f)
    (set! profile-evolution #f))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  @peer2peer
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (/= origin client-no)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  @peer2peer
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (close-send-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-send-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (unregister-stream (current-client) stream-no)
      (table-clear send-streams stream-no)))
  
  
  (method package (close-send-streams self)
    (iterate-table-safe send-streams
      (lambda (no stream)
        (close-send-stream self stream))))
  
  
  (method package (register-receive-stream self sender name stream-no origin source-kind video-level)
    (let ((stream (new UDP-Receive-Stream sender name stream-no origin source-kind video-level)))
      (table-set! receive-streams stream-no stream)
      stream))
  
  
  (method public (find-receive-stream self stream-no)
    (table-ref receive-streams stream-no #f))
  
  
  (method package (close-receive-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-receive-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (table-clear receive-streams stream-no)))
  
  
  (method package (close-receive-streams self)
    (iterate-table-safe receive-streams
      (lambda (no stream)
        (close-receive-stream self stream))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (register-send-channel self stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps)
    (let ((stream (find-send-stream self stream-no)))
      (let ((channel (new UDP-Send-Channel stream channel-no client-no media-kind source-kind level resolution framerate bitrate codec caps)))
        (table-set! send-channels channel-no channel)
        channel)))
  
  
  (method package (close-send-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear send-channels channel-no)))
  
  
  (method public (find-receive-channel self channel-no)
    (table-ref receive-channels channel-no #f))
  
  
  (method package (register-receive-channel self stream-no channel-no origin media-kind source-kind level resolution framerate bitrate codec caps)
    (let ((stream (find-receive-stream self stream-no)))
      (let ((channel (new UDP-Receive-Channel stream channel-no origin media-kind source-kind level resolution framerate bitrate codec caps)))
        (table-set! receive-channels channel-no channel)
        channel)))
  
  
  (method package (close-receive-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear receive-channels channel-no)))
  
  
  (method package (close-channel-output self channel)
    (let ((id (get-no channel))
          (kind (get-media-kind channel)))
      (ecase kind
        ((udp-audio)
         (let ((audio (current-audio)))
           (let ((output (find-output audio id)))
             (when output
               (close-output audio id output)))))
        ((udp-video)
         (let ((video (current-video)))
           (let ((output (find-output video id)))
             (when output
               (close-output video id output))))))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method package (send-media self channel-no buffer header? timestamp duration)
    (mutex-lock! write-mutex)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((kind (get-media-kind channel)))
          (define (send)
            (send-media channel buffer header? timestamp duration
              (lambda (data)
                (send-data self data))))
          
          (define (advance-frame!)
            (let ((frame (next-frame-sequence! channel)))
              (record-event udp-id-throttle-frame
                            (fixnum->flonum channel-no)
                            (fixnum->flonum client-no)
                            (fixnum->flonum kind)
                            -1.
                            (fixnum->flonum frame)
                            -1.
                            -1.)))
          
          (if (simulation?)
              (send)
            (if throttle-media?
                (advance-frame!)
              (if (waiting-header? channel)
                  (if (not header?)
                      (begin
                        (advance-frame!)
                        (when udp-show-skipping?
                          (format :terminal "{s} {s} {s}{%}" remote-name 'SKIPPING (get-frame-sequence channel))))
                    (got-header channel)
                    (send))
                (let ((now (current-seconds)))
                  (if (and udp-throttle (> (- now last-received-ack) udp-throttle))
                      (begin
                        (set! throttle-media? #t)
                        (iterate-table send-channels
                          (lambda (no channel)
                            (wait-header channel)))
                        (record-event udp-id-throttle-on
                                      -1.
                                      (fixnum->flonum server-no)
                                      -1.
                                      -1.
                                      -1.
                                      -1.
                                      -1.)
                        (when udp-show-throttle?
                          (format :terminal "{s} {s} {s}{%}" remote-name 'THROTTLE 'ON)))
                    (send)))))))))
    (mutex-unlock! write-mutex))
  
  
  (method protected (next-profile-heartbeat-sequence! self)
    (prog1 profile-heartbeat-sequence
      (increase! profile-heartbeat-sequence)))
  
  
  (method protected (next-profile-media-sequence! self)
    (prog1 profile-media-sequence
      (increase! profile-media-sequence)))
  
  
  (method package (send-profile-heartbeat self)
    (mutex-lock! write-mutex)
    (let ((size (+ 8 4 4 4 4 4 4 4)))
      (let ((data (make-u8vector size)))
        (write-udp-sent data (current-seconds))
        (write-udp-kind data udp-profile-heartbeat)
        (write-udp-sender data client-no)
        (write-udp-sequence data (next-profile-heartbeat-sequence! self))
        (write-udp-profile-heartbeat-packets-sent data 0)
        (write-udp-profile-heartbeat-bytes-sent data 0)
        (write-udp-profile-heartbeat-packets-received data 0)
        (write-udp-profile-heartbeat-bytes-received data 0)
        (send-data self data)))
    (mutex-unlock! write-mutex))
  
  
  (method package (send-profile-media self payload)
    (mutex-lock! write-mutex)
    (let ((size (+ 8 4 4 4 4 (u8vector-length payload))))
      (let ((data (make-u8vector size)))
        (write-udp-sent data (current-seconds))
        (write-udp-kind data udp-profile-media)
        (write-udp-sender data client-no)
        (write-udp-sequence data (next-profile-media-sequence! self))
        (write-udp-profile-media-payload data payload)
        (send-data self data)
        (increase-sent profile-monitor data)))
    (mutex-unlock! write-mutex))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       (udp-destination-set! server-host server-port udp-port)
       (safe-write data udp-port)
       (increase-sent self data))
      @peer2peer
      ((peer)
       (iterate-table peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (safe-write data udp-port)))))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (state-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((end? (thread-receive udp-state-period #f)))
            (if end?
                (continuation-return exit #f)
              (site (udp-state on?: #t)
                (send-state self))
              (loop)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read-data udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (receive-data self data))
              (loop)))))))
  
  
  (method protected (receive-data self data)
    (increase-received self data)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-connected))
        ((udp-state)
         (receive-state self data))
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        ((udp-profile-heartbeat)
         (receive-profile-heartbeat self data))
        ((udp-profile-media)
         (receive-profile-media self data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-state self data)
    (let ((states (u8vector->object (read-udp-state-channels data))))
      (for-each (lambda (info)
                  (bind (channel-no client-state) info
                    (let ((channel (find-send-channel self channel-no)))
                      (when (and channel (eq? client-state 'waiting))
                        (reset-media channel)))))
                states)))
  
  
  (method (receive-ack self data)
    (let ((now (current-seconds))
          (sender (read-udp-sender data))
          (state-sequence (read-udp-ack-state-sequence data)))
      ;; throttling
      (set! last-received-ack now)
      (when throttle-media?
        (set! throttle-media? #f)
        ;; force camera reset
        ;; (maybe-reset-media self server-no udp-video #f)
        (record-event udp-id-throttle-off
                      -1.
                      (fixnum->flonum server-no)
                      -1.
                      (fixnum->flonum state-sequence)
                      -1.
                      -1.
                      -1.)
        (when udp-show-throttle?
          (format :terminal "{s} {s} {s}{%}" remote-name 'THROTTLE 'OFF)))
      ;; statistics
      (let ((state-sent (read-udp-ack-state-sent data))
            (ack-sent (read-udp-sent data))
            (server-packets-sent (read-udp-ack-packets-sent data))
            (server-bytes-sent (read-udp-ack-bytes-sent data))
            (server-packets-received (read-udp-ack-packets-received data))
            (server-bytes-received (read-udp-ack-bytes-received data)))
        (let ((round-trip (- now state-sent)))
          (update statistics now monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received)
          (record-event udp-id-receive-ack
                        -1.
                        (fixnum->flonum sender)
                        -1.
                        (fixnum->flonum state-sequence)
                        round-trip
                        state-sent
                        ack-sent
                        -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                        -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received))))
        (let ((last-send-rate (get-last-send-rate statistics))
              (last-receive-rate (get-last-receive-rate statistics)))
          (unless (= last-send-rate -1.)
            (record-event udp-id-traffic-rate
                          -1.
                          (fixnum->flonum sender)
                          -1.
                          (fixnum->flonum state-sequence)
                          -1.
                          last-send-rate
                          last-receive-rate))))))
  
  
  (method (receive-nack self data)
    (let ((channel-no (read-udp-channel data))
          (sender (read-udp-sender data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-missing data))))
      (send-missing self sender channel-no media-kind missing)))
  
  
  (method protected (receive-media self kind data)
    (let ((channel-no (read-udp-channel data)))
      (let ((channel (find-receive-channel self channel-no)))
        (when channel
          (remember-media channel data)
          (insert-media channel data)
          (let ((frame (read-udp-frame data))
                (last-nacked-frame (get-last-nacked-frame channel)))
            (when (or (not last-nacked-frame)
                      (> frame last-nacked-frame))
              (send-nacks self channel-no kind channel)
              (set-last-nacked-frame channel frame)))))))
  
  
  (method protected (send-nacks self channel-no kind channel)
    (unless (simulation?)
      (let ((missing (collect-missing channel)))
        (unless (null? missing)
          (send-nack self channel-no kind missing)))))
  
  
  (method (send-missing self sender channel-no media-kind missing)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((ring (get-retain-ring channel)))
          (for-each (lambda (sequence)
                      (let ((data (locate-data ring sequence)))
                        (if data
                            (begin
                              (when udp-show-resend?
                                (let ((packet (locate-packet ring sequence)))
                                  (when packet
                                    (let ((timestamp (get-timestamp packet)))
                                      (let ((time (remote->local (get-time-base ring) timestamp)))
                                        (terminal (- (current-seconds) time)))))))
                              (increase-udp-resent data)
                              (send-data self data)
                              (let ((frame (read-udp-frame data)))
                                (record-event udp-id-resend-packet
                                              (fixnum->flonum channel-no)
                                              (fixnum->flonum sender)
                                              (fixnum->flonum media-kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              -1.
                                              -1.)))
                          (record-event udp-id-absent-packet
                                        (fixnum->flonum channel-no)
                                        (fixnum->flonum sender)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        -1.
                                        -1.
                                        -1.)
                          (when udp-show-nacks?
                            (terminal remote-name (present-media-kind media-kind) '***nack-missing*** sequence)))))
                    missing)))))
  
  
  (method (receive-profile-heartbeat self data)
    (let ((now (current-seconds)))
      (let ((sequence (read-udp-sequence data))
            (state-sent (read-udp-ack-state-sent data))
            (ack-sent (read-udp-sent data))
            (server-packets-sent (read-udp-profile-heartbeat-packets-sent data))
            (server-bytes-sent (read-udp-profile-heartbeat-bytes-sent data))
            (server-packets-received (read-udp-profile-heartbeat-packets-received data))
            (server-bytes-received (read-udp-profile-heartbeat-bytes-received data)))
        (let ((round-trip (- now state-sent)))
          (update profile-statistics now profile-monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received)
          (parameterize ((simulation-evolution profile-evolution))
            (record-event udp-id-receive-ack
                          -1.
                          (fixnum->flonum client-no)
                          -1.
                          (fixnum->flonum sequence)
                          round-trip
                          state-sent
                          ack-sent
                          -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                          -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received)))
            (let ((last-send-rate (get-last-send-rate profile-statistics))
                  (last-receive-rate (get-last-receive-rate profile-statistics)))
              (unless (= last-send-rate -1.)
                (record-event udp-id-traffic-rate
                              -1.
                              (fixnum->flonum client-no)
                              -1.
                              (fixnum->flonum sequence)
                              -1.
                              last-send-rate
                              last-receive-rate)))))))
    (when udp-show-profile?
      (format :terminal "{s} {s} {s}{%}" remote-name 'PROFILE 'HEARTBEAT)))
  
  
  (method (receive-profile-media self data)
    (let ((sender (read-udp-sender data))
          (sequence (read-udp-sequence data)))
      (when profile-last-sequence
        (let ((expected-sequence (+ profile-last-sequence 1)))
          (when (/= sequence expected-sequence)
            (parameterize ((simulation-evolution profile-evolution))
              (loop (for seq from expected-sequence below sequence)
                    (record-event udp-id-lost-packet
                                  -1.
                                  (fixnum->flonum sender)
                                  (fixnum->flonum udp-audio)
                                  (fixnum->flonum seq)
                                  -1.
                                  -1.
                                  -1.))))))
      (set! profile-last-sequence sequence)
      (increase-received profile-monitor data))
    (when udp-show-profile?
      (format :terminal "{s} {s} {s}{%}" remote-name 'PROFILE 'MEDIA)))
  
  
  (method protected (next-state-sequence! self)
    (prog1 state-sequence
      (increase! state-sequence)))
  
  
  (method (send-state self)
    (define (collect-states)
      (let ((queue (new-queue)))
        (iterate-table receive-channels
          (lambda (key channel)
            (let ((state (get-state (get-process-ring channel))))
              (enqueue queue
                       (list (get-no channel)
                             state)))))
        (queue-list queue)))
    
    (let ((state-sequence (next-state-sequence! self))
          (states (collect-states)))
      (mutex-lock! write-mutex)
      (let ((states (object->u8vector states)))
        (let ((size (+ 8 4 4 4 4 (u8vector-length states))))
          (let ((data (make-u8vector size)))
            (write-udp-sent data (current-seconds))
            (write-udp-kind data udp-state)
            (write-udp-sender data client-no)
            (write-udp-state-sequence data state-sequence)
            (write-udp-state-channels data states)
            (send-data self data))))
      (record-event udp-id-send-state
                    -1.
                    (fixnum->flonum client-no)
                    -1.
                    (fixnum->flonum state-sequence)
                    -1.
                    -1.
                    -1.)
      (mutex-unlock! write-mutex)))
  
  
  (method (send-nack self channel-no media-kind missing)
    (when udp-show-nacks?
      (terminal remote-name (present-media-kind media-kind) '***send-nack*** missing))
    (mutex-lock! write-mutex)
    (let ((missing-vector (object->u8vector missing)))
      (let ((size (+ 8 4 2 2 4 4 (u8vector-length missing-vector))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-sender data client-no)
          (write-udp-channel data channel-no)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-missing data missing-vector)
          (send-data self data))))
    (mutex-unlock! write-mutex)))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Receive Stream
;;;


(class UDP-Receive-Stream extends UDP-Stream)


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot process-ring      getter generate)
  (slot process-task      getter generate)
  (slot process-average   getter generate)
  (slot last-nacked-frame accessors generate)
  (slot last-playtime     accessors generate)
  (slot last-timestamp    accessors generate)
  (slot replay-ring       getter generate)
  (slot replay-header     getter generate)
  (slot processed         getter generate)
  (slot missing           getter generate)
  
  
  (method override (initialize self stream no origin media-kind source-kind level resolution framerate bitrate codec caps)
    (nextmethod self stream no origin media-kind source-kind level resolution framerate bitrate codec caps)
    (set! self.last-nacked-frame #f)
    (set! self.last-playtime #f)
    (set! self.last-timestamp #f)
    (set! self.replay-ring (new Remember-Ring 6000))
    (set! self.replay-header #f)
    (set! self.process-ring (new UDP-Ring self no origin media-kind udp-process-size max-size: udp-process-max-size overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
    (unless (simulation?)
      (set! self.process-task (new Task 'udp-process (lambda (task)
                                                       (process-loop self task))
                                   priority: udp-priority)))
    (set! self.process-average (new Average .05 1.))
    (set! self.processed 0)
    (set! self.missing 0)
    (unless (simulation?)
      (start-task process-task)))
  
  
  (method override (destroy self)
    (terminate process-ring)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (collect-missing self)
    (let ((missing (new-queue)))
      (iterate-earliest process-ring
        (lambda (packet)
          (when (not (get-data packet))
            (enqueue missing (get-sequence packet)))))
      (queue-list missing)))
  
  
  (method protected (count-missing self)
    (let ((count 0))
      (iterate-earliest process-ring
        (lambda (packet)
          (when (not (get-data packet))
            (increase! count))))
      count))
  
  
  (method protected (remember-media self data)
    (remember replay-ring data))
  
  
  (method protected (insert-media self data)
    (insert process-ring data))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (ecase media-kind
      ((udp-audio) (process-audio-loop self task))
      ((udp-video) (process-video-loop self task))))
  
  
  (method (process-audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-audio process-ring process-average #f)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site (udp-process on?: #t)
                (bind (presentation-time . datas) info
                  (present-audio self presentation-time datas)))
              (looping)))))))
  
  
  (method (process-video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-video process-ring process-average #f)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site (udp-process on?: #t)
                (present-video self info))
              (looping)))))))
  
  
  (method (record-play-frame self sender frame header? timestamp adjustment)
    (record-event udp-id-play-frame
                  (fixnum->flonum no)
                  (fixnum->flonum sender)
                  (fixnum->flonum media-kind)
                  -1.
                  (fixnum->flonum frame)
                  (barbara-header-hack header?)
                  (if (= timestamp -1)
                      -1.
                    (timestamp->flonum timestamp))
                  adjustment))
  
  
  (method (record-freeze-frame self sender frame header? timestamp)
    (record-event udp-id-freeze-frame
                  (fixnum->flonum no)
                  (fixnum->flonum sender)
                  (fixnum->flonum media-kind)
                  -1.
                  (fixnum->flonum frame)
                  (barbara-header-hack header?)
                  (if (= timestamp -1)
                      -1.
                    (timestamp->flonum timestamp))))
  
  
  (method (assemble-chunks self datas first total)
    (if (= total 1)
        (read-udp-media-payload first)
      (let ((chunks (map read-udp-media-payload datas)))
        (apply u8vector-append chunks))))
  

  ;;
  ;; Two sanity checks are still needed:
  ;; 1) ensure that adjustment does not send timestamps to gstreamer outside the range of its buffer
  ;; 2) ensure that adjustment does not send timestamps to gstreamer that puts packets out of order
  ;;
  (method protected (present-audio self presentation-time datas)
    (let ((first (car datas)))
      (let ((kind (read-udp-kind first))
            (sender (read-udp-sender first))
            (channel-no (read-udp-channel first))
            (frame (read-udp-frame first))
            (total (read-udp-total first))
            (timestamp (read-udp-media-timestamp first))
            (duration (read-udp-media-duration first))
            (header? (read-udp-media-header? first))
            (off? (read-udp-media-off? first)))
        (define (determine-effective-timestamp!)
          (let ((now (current-seconds))
                (timestamp (timestamp->flonum timestamp)))
            (let ((perfect-playtime (if (not last-playtime)
                                        now
                                      (+ last-playtime (- timestamp (or last-timestamp timestamp))))))
              (let ((perfect (- perfect-playtime now)))
                (let ((adjustment (if (< (abs (- perfect-playtime presentation-time)) 0.2)
                                      perfect
                                    (let ((latency-adjust (+ perfect (- presentation-time perfect-playtime))))
                                      @w (terminal 'LATENCY 'ADJUSTMENT latency-adjust)
                                      latency-adjust))))
                  (set! last-timestamp timestamp)
                  (set! last-playtime (+ now adjustment))
                  @w (when (> adjustment .2)
                    (terminal 'adjustment 'makes 'frame 'too 'late adjustment))
                  @w (when (< adjustment -.2)
                    (terminal 'adjustment 'makes 'frame 'too 'early adjustment))
                  adjustment)))))
        
        (increase! processed total)
        (let ((id/output (or (simulation-audio) channel-no)))
          (let ((buffer (assemble-chunks self datas first total)))
            (if off?
                (receive-audio (current-audio) id/output #f #f #f)
              (if (and header? (eq? audio-codec 'vorbis))
                  (let ((headers (u8vector->object buffer)))
                    (set! replay-header buffer)
                    (for-each (lambda (header)
                                (bind (buffer timestamp duration) header
                                  ;; be very careful as timestamp is incorrect as it
                                  ;; is the timestamp at time the header was captured
                                  ;; this only works because gst_app_src_write
                                  ;; doesn't actually use the timestamp
                                  (receive-audio (current-audio) id/output buffer 0 duration)))
                              headers)
                    (record-play-frame self sender frame header? timestamp 0.))
                (let ((adjustment (determine-effective-timestamp!)))
                  (receive-audio (current-audio) id/output buffer (flonum->timestamp adjustment) duration)
                  (record-play-frame self sender frame header? timestamp adjustment)))))))))
  
  
  (method protected (present-video self datas)
    (let ((first (car datas)))
      (let ((kind (read-udp-kind first))
            (sender (read-udp-sender first))
            (channel-no (read-udp-channel first))
            (frame (read-udp-frame first))
            (total (read-udp-total first))
            (timestamp (read-udp-media-timestamp first))
            (duration (read-udp-media-duration first))
            (header? (read-udp-media-header? first))
            (off? (read-udp-media-off? first)))
        (increase! processed total)
        (let ((id/output (or (simulation-video) channel-no)))
          (let ((buffer (assemble-chunks self datas first total)))
            (if off?
                (receive-video (current-video) id/output #f #f #f)
              (receive-video (current-video) id/output buffer timestamp duration)
              (if (eq? (get-state process-ring) 'late)
                  (record-freeze-frame self sender frame header? timestamp)
                (record-play-frame self sender frame header? timestamp 0.))))))))))
