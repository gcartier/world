;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.presence)
        (jazz.syntax (phase syntax))
        (world)
        (world.audio)
        (world.configure)
        (world.context)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.udp)
        (world.video))


(definition record-output?
  (world-setting 'world.record-output? #f))

(definition recordings
  (make-table))


(definition udp-video-action
  (world-setting 'world.udp-video-action #f))

(definition udp-video-file
  {File Settings "captures" "video.mpj"})

(definition udp-video-port
  #f)


(class UDP-Client extends Object
  
  
  (slot udp-port         initialize #f getter generate)
  (slot udp-stopping?    initialize #f getter generate)
  (slot local-host       initialize #f getter generate)
  (slot local-port       initialize #f getter generate)
  (slot server-host      initialize #f getter generate)
  (slot server-port      initialize #f getter generate)
  (slot write-mutex      initialize #f getter generate)
  (slot send-channels    initialize #f getter generate)
  (slot receive-channels initialize #f getter generate)
  (slot receive-task     initialize #f getter generate)
  (slot ack-task         initialize #f getter generate)
  (slot camera-reset     initialize #f getter generate)
  (slot topology         initialize #f getter generate)
  (slot peers            initialize #f getter generate)
  (slot peers-mutex      initialize #f getter generate)
  (slot simulator        initialize #f getter generate)
  
  
  (method (connect self client-no local-host host service)
    ;; quick heuristic
    (define (determine-local-address)
      (if local?
          #u8(127 0 0 1)
        (let ((info (host-info (host-name))))
          (let ((addresses (host-info-addresses info)))
            (if (= 1 (length addresses))
                (car addresses)
              #u8(0 0 0 0))))))
    
    (set! udp-port (open-udp (list
                               local-address: local-host
                               address: host
                               port-number: service)))
    (set! udp-stopping? #f)
    (set! receive-task (new Task 'udp-receive (lambda (task)
                                                (receive-loop self task))
                            priority: udp-priority))
    (set! ack-task (new Task 'udp-ack (lambda (task)
                                        (ack-loop self task))
                        priority: udp-priority))
    (let ((local-host (determine-local-address))
          (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (mutex-lock! write-mutex)
        (let ((data (make-u8vector (+ 8 4 4 4 4 4 4 4))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-connect)
          (write-udp-origin data client-no)
          (write-udp-connect-local-host data local-host)
          (write-udp-connect-local-port data local-port)
          (write-udp-connect-latency data (or udp-latency -1.))
          (write-udp-connect-lag data (or udp-lag -1.))
          (write-udp-connect-drop data (or udp-drop -1.))
          (retrying-write data udp-port))
        (mutex-unlock! write-mutex))
      
      (set! self.local-host local-host)
      (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! write-mutex (make-mutex 'write))
      (set! send-channels (make-table))
      (set! receive-channels (make-table))
      (set! camera-reset #f)
      (set! topology (world-setting 'world.udp-topology 'server))
      (set! peers (make-table))
      (set! peers-mutex (make-mutex 'peers))
      (set! simulator (if (or udp-latency udp-lag udp-drop udp-congestion)
                          (new UDP-Simulator udp-latency udp-lag udp-drop
                               (lambda (data)
                                 (send-topology self data)))
                        #f))
      (record-event udp-id-connect
                    0.
                    0.
                    0.
                    0.)
      (send-connect)
      ;; togetherimprove
      ;; quick solution to receiving media instead of the expected response
      ;; need to revisit this code for a cleaner solution. this is like doing
      ;; a call using UDP which is really difficult
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (let ((reply (read udp-port)))
            (let ((kind (read-udp-kind reply)))
              (if (not (= kind udp-connected))
                  (if (>= n 100)
                      (begin
                        (terminal 'BAILOUT 'did 'not 'received 'udp-connected)
                        (exit 1))
                    (loop (+ n 1)))
                (let ((source-info (udp-source-socket-info udp-port)))
                  (set! server-host (socket-info-address source-info))
                  (set! server-port (socket-info-port-number source-info)))
                (let ((round-trip (- (current-seconds) (read-udp-sent reply))))
                  (record-event udp-id-connected
                                round-trip
                                0.
                                0.
                                0.)))))))
      (start-task receive-task)
      (start-task ack-task)))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (thread-send (get-thread ack-task) #t)
    (thread-join! (get-thread ack-task))
    (close-port udp-port)
    (thread-join! (get-thread receive-task))
    (set! udp-port #f)
    (set! receive-task #f)
    (set! ack-task #f))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((client-no (get-client-no (current-tier)))
          (p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (or (/= origin client-no)
                                  audio-self?
                                  video-self?)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (require-send-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref send-channels key #f)
          (let ((channel (new UDP-Send-Channel origin media-kind)))
            (table-set! send-channels key channel)
            channel))))
  
  
  (method package (require-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref receive-channels key #f)
          (let ((channel (new UDP-Receive-Channel origin media-kind)))
            (table-set! receive-channels key channel)
            channel))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method (send-audio self buffer timestamp duration)
    (send-media self udp-audio buffer timestamp duration))
  
  
  (method (send-video self buffer timestamp duration)
    (send-media self udp-video buffer timestamp duration))
  
  
  (method (send-media self kind buffer timestamp duration)
    (mutex-lock! write-mutex)
    (let ((origin (get-client-no (current-tier))))
      (when udp-video-action
        (let ((key (cons origin kind)))
          (cond ((and buffer (not (table-ref send-channels key #f)))
                 (set! udp-video-port (case udp-video-action
                                        ((record)
                                         (create-directories udp-video-file)
                                         (open-output-file (path-settings udp-video-file)))
                                        ((play)
                                         (open-input-file (path-settings udp-video-file))))))
                ((and (not buffer) (table-ref send-channels key #f))
                 (when udp-video-port
                   (close-port udp-video-port)
                   (set! udp-video-port #f))))))
      (let ((channel (require-send-channel self origin kind)))
        ;; quick hack to give media off a timestamp
        (let ((last-timestamp (or (get-last-timestamp channel) 0)))
          (let ((off? (not buffer))
                (frame (next-frame-sequence! channel))
                (timestamp (or timestamp (+ last-timestamp 1)))
                (duration (or duration 1))
                (buffer (or buffer udp-media-off)))
            (set-last-timestamp channel timestamp)
            (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4))
                  (payload-size (u8vector-length buffer)))
              (let ((max-content-size (- udp-datagram-max header-size)))
                (let ((total (fxceiling/ payload-size max-content-size)))
                  (let (loop (part 0) (pos 0))
                    (let ((remain (- payload-size pos)))
                      (when (> remain 0)
                        (let ((sequence (next-data-sequence! channel))
                              (content-size (min remain max-content-size)))
                          (let ((size (+ header-size content-size)))
                            (let ((data (make-u8vector size)))
                              (write-udp-sent data (current-seconds))
                              (write-udp-kind data kind)
                              (write-udp-origin data origin)
                              (write-udp-sequence data sequence)
                              (write-udp-frame data frame)
                              (write-udp-part data part)
                              (write-udp-total data total)
                              (write-udp-timestamp data timestamp)
                              (write-udp-duration data duration)
                              (write-udp-subpayload data buffer pos content-size)
                              (when udp-video-port
                                (case udp-video-action
                                  ((record)
                                   (write data udp-video-port)
                                   (newline udp-video-port)
                                   (force-output udp-video-port))
                                  ((play)
                                   (let ((obj (read udp-video-port)))
                                     (unless (eof-object? obj)
                                       (set! data obj))))))
                              (send-data self data)
                              (update-time channel sequence data (get-retain-ring channel))
                              (retain channel data)
                              (record-event udp-id-send-media
                                            (fixnum->flonum kind)
                                            (fixnum->flonum sequence)
                                            (if off? 0. 1.)
                                            0.)
                              (loop (+ part 1) (+ pos content-size)))))))))))))))
    (mutex-unlock! write-mutex))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       (udp-destination-set! server-host server-port udp-port)
       (retrying-write data udp-port))
      ((peer)
       (iterate-table peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (retrying-write data udp-port)))))))
  
  
  ;;;
  ;;;; Ack
  ;;;
  
  
  (method (ack-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((end? (thread-receive udp-ack-period #f)))
            (if end?
                (continuation-return exit #f)
              (site (udp-ack on?: #t)
                (send-ack self))
              (loop)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (receive-data self data))
              (loop)))))))
  
  
  (method (receive-data self data)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-ack self data)
    (let ((sent (read-udp-sent data))
          (states (u8vector->object (read-udp-ack-channel-states data))))
      @wait
      (let ((round-trip (- (current-seconds) sent)))
        (record-event udp-id-receive-ack
                      (fixnum->flonum media-kind)
                      (fixnum->flonum sequence)
                      round-trip
                      0.))
      (let ((client-no (get-client-no (current-client))))
        (for-each (lambda (info)
                    (bind (origin media-kind state) info
                      (when (= origin client-no)
                        (when (= media-kind udp-video)
                          (when (eq? state 'waiting)
                            (let ((channel (require-send-channel self origin media-kind)))
                              ;; if camera is already resetting, ignore
                              (if (and camera-reset
                                       (= camera-reset (read-video-data-sequence (current-client))))
                                  (when udp-show-resets?
                                    (format :terminal "{s} {s} {s}{%}" remote-name 'RESET 'IN-PROGRESS))
                                (let ((header (locate (get-retain-ring channel) video-packet-header?)))
                                  (if header
                                      (when udp-show-resets?
                                        (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name 'VIDEO 'RESET 'AVOIDED (read-udp-sequence header)))
                                    (let ((video (current-video)))
                                      (let ((sequence (reset-camera video)))
                                        (set! camera-reset sequence)
                                        (when udp-show-resets?
                                          (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name 'VIDEO 'RESET 'CAMERA sequence)))))))))))))
                  states))))
  
  
  (method (receive-nack self data)
    (let ((origin (read-udp-origin data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-latest-missing data))))
      (send-missing self origin media-kind missing)))
  
  
  (method (receive-media self kind data)
    (let ((origin (read-udp-origin data))
          (sequence (read-udp-sequence data)))
      (let ((channel (require-receive-channel self origin kind)))
        (let ((last-sequence (get-last-sequence channel)))
          (let ((in-order? (or (not last-sequence)
                               (> sequence last-sequence))))
            (if (not in-order?)
                (remove-nack channel sequence)
              ;; send nacks to server
              (when last-sequence
                (let ((expected (+ last-sequence 1)))
                  (when (> sequence expected)
                    (loop (for seq from expected below sequence)
                          (add-nack channel seq))
                    (send-nack self origin kind (get-latest-nacks channel)))))
              ;; remember time information
              (update-time channel sequence data (get-process-ring channel)))
            (insert-media channel data))))))
  
  
  (method (send-missing self origin media-kind missing)
    (let ((channel (require-send-channel self origin media-kind)))
      (let ((ring (get-retain-ring channel)))
        (for-each (lambda (sequence)
                    (let ((found (locate ring (lambda (data)
                                                (= (read-udp-sequence data) sequence)))))
                      (record-event udp-id-receive-nack
                                    (fixnum->flonum media-kind)
                                    (fixnum->flonum sequence)
                                    (if found 1. 0.)
                                    0.)
                      (if found
                          (send-data self found)
                        (when udp-debug-nack?
                          (terminal remote-name (udp-name media-kind) '***nack-missing*** sequence)))))
                  missing))))
  
  
  (method (send-ack self)
    (define (collect-states)
      (let ((queue (new-queue)))
        (iterate-table receive-channels
          (lambda (key channel)
            (let ((state (get-process-state channel)))
              (when state
                (enqueue queue
                         (list (get-origin channel)
                               (get-media-kind channel)
                               state))))))
        (queue-list queue)))
    
    (let ((states (collect-states)))
      (mutex-lock! write-mutex)
      (let ((states (object->u8vector states)))
        (let ((size (+ 8 4 4 4 (u8vector-length states))))
          (let ((data (make-u8vector size)))
            (write-udp-sent data (current-seconds))
            (write-udp-kind data udp-ack)
            (write-udp-origin data (get-client-no (current-client)))
            (write-udp-ack-channel-states data states)
            (send-data self data))))
      (mutex-unlock! write-mutex)))
  
  
  (method (send-nack self origin media-kind latest-missing)
    (when udp-debug-nack?
      (terminal remote-name (udp-name media-kind) 'send-nack latest-missing))
    (mutex-lock! write-mutex)
    (let ((missing (object->u8vector latest-missing)))
      (let ((size (+ 8 4 4 4 4 (u8vector-length missing))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-origin data origin)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-latest-missing data missing)
          (send-data self data))))
    (mutex-unlock! write-mutex)))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Channel
  
  
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-timestamp accessors generate)
  (slot retain-ring    getter generate)
  (slot release-task   getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self origin media-kind)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f)
    ;; make it really big until time ring is a real ring
    (set! self.retain-ring (new Time-Ring 400096 @w 512 @max-size: +inf.0 now-proc: (~ now-timestamp self)))
    ;; development
    (set-$s retain-ring)
    (set! self.release-task (new Task 'udp-release (lambda (task)
                                                     (release-loop self task))
                                 priority: udp-priority))
    (start-task release-task))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (retain self data)
    (insert retain-ring (read-udp-seconds data) data))
  
  
  (method protected (release-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (wait retain-ring)
          (site (udp-release on?: #t)
            ;; nothing to do
            #f)
          (loop))))))


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot latest-nacks       accessors generate)
  (slot next-ack           accessors generate)
  (slot process-state      getter generate)
  (slot process-last-frame getter generate)
  (slot process-ring       getter generate)
  (slot process-task       getter generate)
  (slot processed          getter generate)
  (slot missing            getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self origin media-kind)
    (set! self.latest-nacks '())
    (set! self.next-ack #f)
    (set! self.process-state #f)
    (set! self.process-last-frame #f)
    ;; make it really big until time ring is a real ring
    (set! self.process-ring (new Time-Ring 40096 @w 512 @max-size: +inf.0 now-proc: (~ now-timestamp self)))
    ;; development
    (set-$c self)
    (set-$r process-ring)
    (set! self.process-task (new Task 'udp-process (lambda (task)
                                                     (process-loop self task))
                                 priority: udp-priority))
    (set! self.processed 0)
    (set! self.missing 0)
    (start-task process-task))
  
  
  (method protected (add-nack self sequence)
    (set! latest-nacks (cons sequence latest-nacks))
    ;; trim when more than udp-latest-nacks
    (when (> (length latest-nacks) udp-latest-nacks)
      (set-cdr! (tail latest-nacks (- udp-latest-nacks 1)) '()))
    latest-nacks)
  
  
  (method protected (remove-nack self sequence)
    (set! latest-nacks (remove! sequence latest-nacks)))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method private (process-state-ok self kind)
    (unless (eq? process-state 'ok)
      (set! process-state 'ok)
      (when udp-show-resets?
        (format :terminal "{s} {s} {s}{%}" remote-name (if (= kind udp-audio) 'AUDIO 'VIDEO) 'OK))))
  
  
  (method private (process-state-waiting self kind)
    (unless (eq? process-state 'waiting)
      (set! process-state 'waiting)
      (when udp-show-resets?
        (format :terminal "{s} {s} {s}{%}" remote-name (if (= kind udp-audio) 'AUDIO 'VIDEO) 'WAITING))))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected (insert-nack self data)
    )
  
  
  (method protected (insert-media self data)
    (let ((sequence (read-udp-sequence data)))
      (let ((inserted? (insert process-ring (read-udp-seconds data) data)))
        (when (and udp-show-discard? (not inserted?))
          (let ((kind (read-udp-kind data))
                (sequence (read-udp-sequence data)))
            (record-event udp-id-discard
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          0.
                          0.)
            (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name kind) '***discard*** sequence))))))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((lst (wait-all process-ring)))
            (site (udp-process on?: #t)
              (for-each (lambda (partition)
                          (bind (frame . datas) partition
                            (let ((unique-datas (remove-duplicates datas key: read-udp-sequence)))
                              (when (and udp-show-duplicates? (> (length datas) (length unique-datas)))
                                (let ((duplicates (difference datas unique-datas)))
                                  (format :terminal "{s} {s} {s} {l}{%}" remote-name (udp-name media-kind) '***duplicates*** (map read-udp-sequence duplicates))))
                              (process-frame self (sort < unique-datas key: read-udp-sequence)))))
                        (sort < (partition lst key: read-udp-frame) key: car))
              (when (eq? process-state 'waiting)
                (send-ack (get-udp-client (current-client))))))
          (loop)))))
  
  
  (method (process-frame self datas)
    (let ((count (length datas))
          (first (car datas)))
      (increase! processed count)
      (let ((kind (read-udp-kind first))
            (origin (read-udp-origin first))
            (sequence (read-udp-sequence first))
            (frame (read-udp-frame first))
            (part (read-udp-part first))
            (total (read-udp-total first))
            (timestamp (read-udp-timestamp first))
            (duration (read-udp-duration first)))
        ;; there is a gap in the frames
        (when (and process-last-frame (> frame (+ process-last-frame 1)))
          ;; audio has no problem with gaps
          (when (= kind udp-video)
            (process-state-waiting self kind)))
        (if (= total count)
            ;; complete frame
            (let ((last-sequence (+ sequence total -1)))
              (if (= total 1)
                  (process-media self kind origin sequence last-sequence frame timestamp duration (read-udp-payload first))
                (let ((chunks (map read-udp-payload datas)))
                  (let ((data (apply u8vector-append chunks)))
                    (process-media self kind origin sequence last-sequence frame timestamp duration data)))))
          ;; incomplete frame
          ;; audio has no problem with drops
          (when (= kind udp-video)
            (process-state-waiting self kind))
          @reported-by-process-missing
          (let ((missing (difference (naturals sequence (+ sequence total)) (map read-udp-sequence datas))))
            (format :terminal "{s} {s} {s} {s} {l}{%}" remote-name (udp-name kind) '***partial-frame*** 'missing missing))))))
  
  
  (method (process-media self kind origin sequence last-sequence frame timestamp duration buffer)
    (let ((player (find-player-by-no origin)))
      ;; togetherimprove
      ;; quick solution for when logging in and starting receiving
      ;; someone's media before the client is actually registered
      ;; need to revisit this code for a cleaner solution
      (when player
        (let ((id (get-id player)))
          (define (process-audio)
            (if (equal? buffer udp-media-off)
                (receive-server-audio (current-audio) id #f #f #f)
              (receive-server-audio (current-audio) id buffer timestamp duration)))
          
          (define (process-video)
            (if (equal? buffer udp-media-off)
                (receive-server-video (current-video) id #f #f #f)
              (if (eq? process-state 'ok)
                  (receive-server-video (current-video) id buffer timestamp duration)
                (when (video-buffer-header? buffer)
                  (process-state-ok self kind)
                  (receive-server-video (current-video) id buffer timestamp duration)))))
          
          (ecase kind
            ((udp-audio)
             (process-audio))
            ((udp-video)
             (process-video)))))))))
