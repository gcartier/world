;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.event)
        (jazz.io)
        (jazz.math)
        (jazz.presence)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.audio)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.player)
        (world.profiling)
        (world.record (phase syntax))
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.throttle)
        (world.time)
        (world.udp)
        (world.video))


(class UDP-Client extends UDP-Tier
  
  
  (slot client-no              initialize #f getter generate)
  (slot character-name         initialize #f getter generate)
  (slot udp-port               initialize #f getter generate)
  (slot udp-stopping?          initialize #f getter generate)
  @peer2peer
  (slot local-host             initialize #f getter generate)
  @peer2peer
  (slot local-port             initialize #f getter generate)
  (slot server-host            initialize #f getter generate)
  (slot server-port            initialize #f getter generate)
  (slot write-mutex            initialize #f getter generate)
  (slot receive-streams        initialize #f getter generate)
  (slot receive-channels       initialize #f getter generate)
  (slot alive-task             initialize #f getter generate)
  (slot receive-task           initialize #f getter generate)
  (slot heartbeat-task         initialize #f getter generate)
  (slot heartbeat-sequence     initialize 0  getter generate)
  (slot noack-ring             initialize #f getter generate)
  (slot noack-thread           initialize #f getter generate)
  (slot noack-time             initialize #f getter generate)
  (slot started?               initialize #f getter generate)
  (slot monitor                initialize #f getter generate)
  (slot statistics             initialize #f getter generate)
  (slot invalid-packets        initialize 0  getter generate)
  (slot last-received-ack      initialize #f getter generate)
  (slot throttle               initialize #f getter generate)
  (slot throttle-media?        initialize #f getter generate)
  (slot topology               initialize #f getter generate)
  @peer2peer
  (slot peers                  initialize #f getter generate)
  @peer2peer
  (slot peers-mutex            initialize #f getter generate)
  (slot profile-ack-callback   initialize #f accessors generate)
  (slot profile-pulse-sequence initialize #f getter generate)
  (slot profile-media-sequence initialize #f getter generate)
  (slot profile-last-sequence  initialize #f getter generate)
  (slot profile-monitor        initialize #f getter generate)
  (slot profile-statistics     initialize #f getter generate)
  (slot profile-chronology     initialize #f getter generate)
  (slot profile-evolution      initialize #f getter generate)
  (slot simulator              initialize #f accessors generate)
  
  
  (method override (initialize self client-no character-name)
    (nextmethod self)
    (set! self.client-no client-no)
    (set! self.character-name character-name)
    (set! write-mutex (make-mutex 'write))
    (set! receive-streams (make-table))
    (set! receive-channels (make-table))
    (set! throttle (new UDP-Throttle))
    (register-snapshot-callback (~ snapshot-receive-streams self)))
  
  
  (method package (connect self local-address host service)
    ;; quick heuristic
    @peer2peer
    (define (determine-local-host)
      (let ((info (host-info (host-name))))
        (let ((addresses (host-info-addresses info)))
          (if (= 1 (length addresses))
              (car addresses)
            #u8(0 0 0 0)))))
    
    (unless (simulation?)
    (set! udp-port (open-udp (list
                               local-address: local-address
                               address: host
                               port-number: service)))
    (setup-udp-port-buffers udp-port)
    (set! udp-stopping? #f)
    (let (@peer2peer (local-host (determine-local-host))
          @peer2peer (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (with-write-mutex self
          (lambda ()
            (with-record connect
              (let ((data (make-u8vector (+ (calculate-connect-size) udp-code-size))))
                (write-header-kind data udp-connect)
                (write-header-sender data client-no)
                @peer2peer
                (write-connect-local-host data local-host)
                @peer2peer
                (write-connect-local-port data local-port)
                (write-connect-video-level data (or (video-profile-level) -1))
                (write-udp-code data)
                (write-data data udp-port))))))
      
      @peer2peer (set! self.local-host local-host)
      @peer2peer (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! monitor (new UDP-Monitor))
      (set! statistics (new UDP-Statistics))
      (set! topology (world-setting 'world.udp-topology 'server))
      @peer2peer (set! peers (make-table))
      @peer2peer (set! peers-mutex (make-mutex 'peers))
      (set! simulator (cond-expand
                        (devel (if (or udp-latency udp-drop udp-congestion)
                                   (new-simulator self udp-latency udp-drop)
                                 #f))
                        (else #f)))
      (record-event udp-id-connecting
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.)
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (with-record connect
              (if (or (eof-object? reply) (not (= (read-header-kind reply) udp-connected)))
                  (if (>= n 100)
                      (begin
                        (terminal 'BAILOUT 'did 'not 'receive 'udp-connected)
                        (exit 1))
                    (loop (+ n 1)))
                (let ((source-info (udp-source-socket-info udp-port)))
                  (set! server-host (socket-info-address source-info))
                  (set! server-port (socket-info-port-number source-info)))
                (record-event udp-id-connected
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.)
                (set! alive-task (new Task 'udp-alive (~ run-alive self) priority: alive-priority))
                (set! receive-task (new Task 'udp-receive (~ run-receive self) priority: udp-priority))
                (start-task alive-task)
                (start-task receive-task)))))))))

  
  (method (deconnect self)
    (set! udp-stopping? #t)
    (stop-task alive-task)
    (set! alive-task #f)
    (close-port udp-port)
    (thread-join! (get-thread receive-task))
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (unless (simulation?)
        (set! heartbeat-task (new Task 'udp-heartbeat (~ run-heartbeat self) priority: udp-priority))
        (start-task heartbeat-task))
      (let ((thread (new-thread
                      (lambda ()
                        (declare (proper-tail-calls))
                        (let (loop)
                          (let ((proc (wait noack-ring)))
                            (when proc
                              (proc)
                              (loop)))))
                      'udp-noack)))
        (set! noack-ring (new Time-Ring 1))
        (set! noack-thread thread)
        (thread-base-priority-set! thread udp-priority)
        (thread-start! thread)
        (schedule-noack self 1.))
      (set! last-received-ack (current-seconds))
      (set! throttle-media? #f)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (stop-task heartbeat-task)
      (set! heartbeat-task #f)
      (terminate noack-ring)
      (thread-join! noack-thread)
      (set! noack-ring #f)
      (set! noack-thread #f)
      (set! started? #f)))
  
  
  (method (with-write-mutex self thunk)
    (unwind-protect
        (begin
          (mutex-lock! write-mutex)
          (thunk))
      (mutex-unlock! write-mutex)))
  
  
  (method (snapshot-receive-streams self)
    (let ((info (map (lambda (stream)
                       (list (get-sender stream)
                             (get-name stream)
                             (get-source-kind stream)))
                     (table-values receive-streams))))
      (add-snapshot-property 'live.udp-receive info)))
  
  
  (method protected (new-simulator self latency drop)
    (new UDP-Simulator latency drop
         (lambda (data info drop?)
           (if drop?
               (increase-sent self data)
             (send-topology self data)))))
  
  
  (method package (require-simulator self)
    (or simulator
        (let ((sim (new-simulator self #f #f)))
          (set! simulator sim)
          sim)))
  
  
  (method protected (increase-sent self data)
    (increase-sent monitor data))
  
  
  (method protected (increase-received self data)
    (increase-received monitor data))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (set! profile-pulse-sequence 0)
    (set! profile-media-sequence 0)
    (set! profile-last-sequence 0)
    (set! profile-monitor (new UDP-Monitor))
    (set! profile-statistics (new UDP-Statistics))
    (set! profile-chronology (new Chronology 0))
    (set! profile-evolution (new Evolution 5000)))
  
  
  (method package (retrieve-profile self)
    (let ((metadata (list client-no character-name '() '() (sites-metadata)))
          (chronology (copy-chronology profile-chronology))
          (evolution (copy-evolution profile-evolution)))
      (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
  
  
  (method package (stop-profile self)
    (set! profile-chronology #f)
    (set! profile-evolution #f))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  @peer2peer
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (/= origin client-no)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  @peer2peer
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (close-send-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-send-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (unregister-stream (current-client) stream-no)
      (table-clear send-streams stream-no)))
  
  
  (method package (close-send-streams self)
    (iterate-table-safe send-streams
      (lambda (no stream)
        (close-send-stream self stream))))
  
  
  (method package (register-receive-stream self sender name stream-no origin source-kind video-level channels)
    (let ((stream (new UDP-Receive-Stream sender name stream-no origin source-kind video-level)))
      (for-each (lambda (info)
                  (bind (channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata) info
                    (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                channels)
      (table-set! receive-streams stream-no stream)
      stream))
  
  
  (method public (find-receive-stream self stream-no)
    (table-ref receive-streams stream-no #f))
  
  
  (method package (close-receive-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-receive-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (table-clear receive-streams stream-no)))
  
  
  (method package (close-receive-streams self)
    (iterate-table-safe receive-streams
      (lambda (no stream)
        (close-receive-stream self stream))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (register-send-channel self stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (let ((stream (find-send-stream self stream-no)))
      (let ((channel (new UDP-Send-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
        (table-set! send-channels channel-no channel)
        channel)))
  
  
  (method package (close-send-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear send-channels channel-no)))
  
  
  (method public (find-receive-channel self channel-no)
    (table-ref receive-channels channel-no #f))
  
  
  (method package (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (let ((channel (new UDP-Receive-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
      (table-set! receive-channels channel-no channel)
      channel))
  
  
  (method package (close-receive-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear receive-channels channel-no)))
  
  
  (method package (close-channel-output self channel)
    (let ((id (get-no channel))
          (kind (get-media-kind channel)))
      (ecase kind
        ((udp-audio)
         (let ((audio (current-audio)))
           (let ((output (find-output audio id)))
             (when output
               (close-output audio id output)
               (close-empty-audio audio)))))
        ((udp-video)
         (let ((video (current-video)))
           (let ((output (find-output video id)))
             (when output
               (close-output video id output))))))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method package (send-media self channel-no buffer dts pts duration keyframe?)
    (with-write-mutex self
      (lambda ()
        (let ((channel (find-send-channel self channel-no)))
          (when channel
            (let ((kind (get-media-kind channel)))
              (define (send)
                (send-media channel buffer dts pts duration keyframe?
                  (lambda (data)
                    (send-data self data))))
              
              (define (advance-frame!)
                (let ((frame (next-frame-sequence! channel)))
                  (record-event udp-id-throttle-frame
                                (fixnum->flonum channel-no)
                                (fixnum->flonum client-no)
                                (fixnum->flonum kind)
                                -1.
                                (fixnum->flonum frame)
                                -1.
                                -1.)))
              
              (if (simulation?)
                  (send)
                (if throttle-media?
                    (advance-frame!)
                  (if (waiting-keyframe? channel)
                      (if (not keyframe?)
                          (advance-frame!)
                        (got-keyframe channel)
                        (send))
                    (let ((now (current-seconds)))
                      (if (and udp-throttle (> (- now last-received-ack) udp-throttle))
                          (begin
                            (set! throttle-media? #t)
                            (iterate-table send-channels
                              (lambda (no channel)
                                (wait-keyframe channel)))
                            (record-event udp-id-throttle-on
                                          -1.
                                          (fixnum->flonum server-no)
                                          -1.
                                          -1.
                                          -1.
                                          -1.
                                          -1.))
                        (send))))))))))))
  
  
  (method protected (next-profile-pulse-sequence! self)
    (prog1 profile-pulse-sequence
      (increase! profile-pulse-sequence)))
  
  
  (method protected (next-profile-media-sequence! self)
    (prog1 profile-media-sequence
      (increase! profile-media-sequence)))
  
  
  (method package (send-profile-pulse self)
    (with-write-mutex self
      (lambda ()
        (with-record profile-pulse
          (let ((size (calculate-profile-pulse-size)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-profile-pulse)
              (write-header-sender data client-no)
              (write-profile-pulse-sent data (current-seconds))
              (write-profile-pulse-sequence data (next-profile-pulse-sequence! self))
              (write-udp-code data)
              (send-data self data)
              data))))))
  
  
  (method package (send-profile-media self payload)
    (with-write-mutex self
      (lambda ()
        (with-record profile-media
          (let ((size (calculate-profile-media-size payload)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-profile-media)
              (write-header-sender data client-no)
              (write-profile-media-sequence data (next-profile-media-sequence! self))
              (write-profile-media-payload data payload)
              (write-udp-code data)
              (send-data self data)
              (increase-sent profile-monitor data)))))))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data #f)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       ;; quick temporary hack to get back the safe behavior
       ;; of retrying-write until port being false is fixed
       (when udp-port
         (udp-destination-set! server-host server-port udp-port)
         (send-udp data udp-port)
         (increase-sent self data)))
      @peer2peer
      ((peer)
       (iterate-table peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (send-udp data udp-port)))))))
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (method (run-alive self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site alive
                  (let ((client (current-client)))
                    (let ((udp-client (get-udp-client client)))
                      (when udp-client
                        (send-alive udp-client))))))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task alive-period duration exit))
              (iter time)))))))
  
  
  ;;;
  ;;;; Heartbeat
  ;;;
  
  
  (method (run-heartbeat self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (site udp-heartbeat
            (send-heartbeat self))
          (task-sleep task udp-heartbeat-period exit)
          (loop)))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (run-receive self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (catch-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read-data udp-port)))))
            (when data
              (site udp-receive
                (receive-data self data))
              (loop)))))))
  
  
  (method protected (receive-data self data)
    (if (or (< (u8vector-length data) 4)
            (/= (read-udp-code data) udp-code))
        (increase! invalid-packets)
      (increase-received self data)
      (let ((kind (with-record header
                    (read-header-kind data))))
        (if (not started?)
            (ecase kind
              ((udp-connected))
              ((udp-ack))
              ((udp-nack))
              ((udp-audio udp-video))
              ((udp-alive-ack)
               (receive-alive-ack self data))
              ((udp-profile-ack)
               (receive-profile-ack self data))
              ((udp-profile-media)
               (receive-profile-media self data))
              (else
               (error "Unknown UDP kind: {s}" kind)))
          (ecase kind
            ((udp-connected))
            ((udp-ack)
             (receive-ack self data))
            ((udp-nack)
             (receive-nack self data))
            ((udp-audio udp-video)
             (receive-media self kind data))
            ((udp-alive-ack)
             (receive-alive-ack self data))
            ((udp-profile-pulse))
            ((udp-profile-media))
            (else
             (error "Unknown UDP kind: {s}" kind)))))))
  
  
  (method (receive-ack self data)
    (with-record ack
      (let ((now (current-seconds))
            (sender (read-header-sender data))
            (heartbeat-sent (read-ack-heartbeat-sent data))
            (heartbeat-sequence (read-ack-heartbeat-sequence data)))
        ;; statistics
        (let ((ack-sent (read-ack-sent data))
              (server-packets-sent (read-ack-packets-sent data))
              (server-bytes-sent (read-ack-bytes-sent data))
              (server-packets-received (read-ack-packets-received data))
              (server-bytes-received (read-ack-bytes-received data))
              (server-missed-media-packets (read-ack-missed-media-packets data)))
          (let ((round-trip (- now heartbeat-sent)))
            (update statistics now monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received server-missed-media-packets)
            (record-event udp-id-receive-ack
                          -1.
                          (fixnum->flonum sender)
                          -1.
                          (fixnum->flonum heartbeat-sequence)
                          round-trip
                          heartbeat-sent
                          ack-sent
                          -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                          -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received))))
          (let ((last-send-rate (get-last-send-rate statistics))
                (last-receive-rate (get-last-receive-rate statistics)))
            (unless (= last-send-rate -1.)
              (record-event udp-id-traffic-rate
                            -1.
                            (fixnum->flonum sender)
                            -1.
                            (fixnum->flonum heartbeat-sequence)
                            -1.
                            last-send-rate
                            last-receive-rate))))
        ;; throttle
        (received-ack throttle heartbeat-sent heartbeat-sequence statistics
          (lambda (adjustment reason)
            (delay-throttle-upload self adjustment reason)))
        (schedule-noack self)
        ;; throttling
        (set! last-received-ack now)
        (when throttle-media?
          (set! throttle-media? #f)
          ;; force camera reset
          ;; (maybe-reset-media self server-no udp-video #f)
          (record-event udp-id-throttle-off
                        -1.
                        (fixnum->flonum server-no)
                        -1.
                        (fixnum->flonum heartbeat-sequence)
                        -1.
                        -1.
                        -1.)))))
  
  
  (method (noack-receive self)
    (noack-received throttle
      (lambda (adjustment reason)
        (delay-throttle-upload self adjustment reason)))
    (schedule-noack self))
  
  
  (method (delay-throttle-upload self adjustment reason)
    (delay-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (throttle-upload (current-client))
            (record-event udp-id-throttle-upload
                          -1.
                          -1.
                          -1.
                          adjustment
                          reason
                          -1.
                          -1.
                          -1.))))))
  
  
  (method (schedule-noack self (delay #f))
    (let ((time (+ (current-seconds) (or delay (* udp-heartbeat-period 2.)))))
      ;; mostly so we don't overwrite the initial longer 1s delay
      (when (or (not noack-time)
                (> time noack-time))
        (set! noack-time time)
        (empty noack-ring)
        (insert noack-ring noack-time (lambda ()
                                        (noack-receive self))))))
  
  
  (method (receive-nack self data)
    (with-record nack
      (let ((sender (read-header-sender data))
            (channel-no (read-nack-channel data))
            (start (read-nack-start data))
            (gap (read-nack-gap data)))
        (send-missing self sender channel-no start gap))))
  
  
  (method protected (receive-media self kind data)
    (with-record media
      (let ((channel-no (read-media-channel data)))
        (let ((channel (find-receive-channel self channel-no)))
          (when channel
            (remember-media channel data)
            (insert-media channel data))))))
  
  
  (method (send-missing self sender channel-no start gap)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((media-kind (get-media-kind channel))
              (ring (get-retain-ring channel)))
          (loop (for sequence from start below (+ start gap))
                (let ((data (locate-data ring sequence)))
                  (if data
                      (with-record media
                        (increase-media-resent data)
                        (send-data self data)
                        (let ((frame (read-media-frame data)))
                          (record-event udp-id-resend-packet
                                        (fixnum->flonum channel-no)
                                        (fixnum->flonum sender)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        (fixnum->flonum frame)
                                        -1.
                                        -1.)))
                    (record-event udp-id-absent-packet
                                  (fixnum->flonum channel-no)
                                  (fixnum->flonum sender)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  -1.
                                  -1.
                                  -1.))))))))
  
  
  (method (receive-alive-ack self data)
    )
  
  
  (method (receive-profile-ack self data)
    (let ((include-receive-rate?
            (if profile-ack-callback
                (profile-ack-callback data)
              #t)))
      (with-record profile-ack
        (let ((now (current-seconds)))
          (let ((ack-sent (read-profile-ack-sent data))
                (pulse-sent (read-profile-ack-pulse-sent data))
                (pulse-sequence (read-profile-ack-pulse-sequence data))
                (latency (read-profile-ack-latency data))
                (server-packets-sent (read-profile-ack-packets-sent data))
                (server-bytes-sent (read-profile-ack-bytes-sent data))
                (server-packets-received (read-profile-ack-packets-received data))
                (server-bytes-received (read-profile-ack-bytes-received data))
                (server-missed-media-packets 0)) ;; todo
            (let ((round-trip (- now pulse-sent)))
              (update profile-statistics now profile-monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received server-missed-media-packets)
              (parameterize ((simulation-evolution profile-evolution))
                ;; hack to plot latency
                (record-event udp-id-insert-packet
                              (fixnum->flonum pulse-sequence)
                              (fixnum->flonum client-no)
                              (fixnum->flonum udp-audio)
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              latency)
                ;; hack to plot roundtrip
                (record-event udp-id-receive-ack
                              -1.
                              (fixnum->flonum client-no)
                              -1.
                              (fixnum->flonum pulse-sequence)
                              round-trip
                              pulse-sent
                              ack-sent
                              -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                              -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received)))
                (let ((last-send-rate (get-last-send-rate profile-statistics))
                      (last-receive-rate (get-last-receive-rate profile-statistics)))
                  (unless (= last-send-rate -1.)
                    ;; hack to plot upload
                    (record-event udp-id-traffic-rate
                                  -1.
                                  (fixnum->flonum client-no)
                                  -1.
                                  (fixnum->flonum pulse-sequence)
                                  -1.
                                  last-send-rate
                                  (if include-receive-rate?
                                      last-receive-rate
                                    -1.)))))))))))
  
  
  (method (receive-profile-media self data)
    (with-record profile-media
      (let ((sender (read-header-sender data))
            (sequence (read-profile-media-sequence data)))
        (when profile-last-sequence
          (let ((expected-sequence (+ profile-last-sequence 1)))
            (when (/= sequence expected-sequence)
              (parameterize ((simulation-evolution profile-evolution))
                (loop (for seq from expected-sequence below sequence)
                      (record-event udp-id-lost-packet
                                    -1.
                                    (fixnum->flonum sender)
                                    (fixnum->flonum udp-profile-media)
                                    (fixnum->flonum seq)
                                    -1.
                                    -1.
                                    -1.))))))
        (set! profile-last-sequence sequence)
        (increase-received profile-monitor data))))
  
  
  (method protected (next-heartbeat-sequence! self)
    (prog1 heartbeat-sequence
      ;; wrap around acceptable
      (if (= heartbeat-sequence max-heartbeat-sequence)
          (set! heartbeat-sequence 0)
        (increase! heartbeat-sequence))))
  
  
  (method (send-heartbeat self)
    (let ((heartbeat-sequence (next-heartbeat-sequence! self)))
      (with-write-mutex self
        (lambda ()
          (with-record heartbeat
            (let ((size (calculate-heartbeat-size)))
              (let ((data (make-u8vector (+ size udp-code-size))))
                (write-header-kind data udp-heartbeat)
                (write-header-sender data client-no)
                (write-heartbeat-sent data (current-seconds))
                (write-heartbeat-sequence data heartbeat-sequence)
                (write-udp-code data)
                (send-data self data))))
          (record-event udp-id-send-heartbeat
                        -1.
                        (fixnum->flonum client-no)
                        -1.
                        (fixnum->flonum heartbeat-sequence)
                        -1.
                        -1.
                        -1.)))))
  
  
  (method override (add-missed-media-packets self sender gap)
    (increase-missed-media-packets monitor gap))
  
  
  (method override (send-nack self sender channel-no start gap)
    (with-write-mutex self
      (lambda ()
        (with-record nack
          (let ((size (calculate-nack-size)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-nack)
              (write-header-sender data client-no)
              (write-nack-channel data channel-no)
              (write-nack-start data start)
              (write-nack-gap data gap)
              (write-udp-code data)
              (send-data self data)))))))
  
  
  (method (send-alive self)
    ;; keep clean during profile
    (unless profile-ack-callback
      (with-write-mutex self
        (lambda ()
          (with-record header
            (let ((size (calculate-alive-size)))
              (let ((data (make-u8vector (+ size udp-code-size))))
                (write-header-kind data udp-alive)
                (write-header-sender data client-no)
                (write-udp-code data)
                (send-data self data)))))))))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Receive Stream
;;;


(class UDP-Receive-Stream extends UDP-Stream)


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot process-ring      getter generate)
  (slot process-task      getter generate)
  (slot replay-ring       getter generate)
  (slot processed         getter generate)
  (slot missing           getter generate)
  (slot insert-rate-frame getter generate)
  (slot insert-rate       getter generate)
  (slot process-rate      getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (nextmethod self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (set! self.replay-ring (and (developer?) (remember-ring media-kind source-kind level framerate)))
    (set! self.process-ring (new UDP-Ring self no (get-origin stream) media-kind udp-process-size max-size: udp-process-max-size overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
    (unless (simulation?)
      (set! self.process-task (new Task 'udp-process (~ run-process self) priority: udp-process-priority)))
    (set! self.processed 0)
    (set! self.missing 0)
    (set! self.insert-rate-frame 0)
    (set! self.insert-rate (new Rate))
    (set! self.process-rate (new Rate))
    (unless (simulation?)
      (start-task process-task)))
  
  
  (method override (destroy self)
    (terminate process-ring)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (remember-media self data)
    (when replay-ring
      (remember replay-ring data)))
  
  
  (method protected (insert-media self data)
    (when framerate
      (with-record media
        (let ((frame (read-media-frame data)))
          (when (or (not insert-rate-frame)
                    (> frame insert-rate-frame))
            (update insert-rate framerate)
            (set! insert-rate-frame frame)))))
    (insert process-ring data))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (run-process self task)
    (ecase media-kind
      ((udp-audio) (run-process-audio self task))
      ((udp-video) (run-process-video self task))))
  
  
  (method (run-process-audio self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-audio process-ring #f)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site present-audio
                (present-audio self info))
              (looping)))))))
  
  
  (method (run-process-video self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-video process-ring #f)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site present-video
                (present-video self info))
              (looping)))))))
  
  
  (method (record-play-frame self sender frame keyframe? dts pts)
    (record-event udp-id-play-frame
                  (fixnum->flonum no)
                  (fixnum->flonum sender)
                  (fixnum->flonum media-kind)
                  -1.
                  (fixnum->flonum frame)
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method (record-freeze-frame self sender frame keyframe? dts pts)
    (record-event udp-id-freeze-frame
                  (fixnum->flonum no)
                  (fixnum->flonum sender)
                  (fixnum->flonum media-kind)
                  -1.
                  (fixnum->flonum frame)
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method (assemble-chunks self datas first total)
    (with-record media
      (if (= total 1)
          (read-media-payload first)
        (let ((chunks (map (lambda (data)
                             (read-media-payload data))
                           datas)))
          (apply u8vector-append chunks)))))
  

  (method protected (present-audio self datas)
    (let ((first (car datas)))
      (with-record media
        (let ((sender (read-header-sender first))
              (channel-no (read-media-channel first))
              (frame (read-media-frame first))
              (total (read-media-total first))
              (dts (read-media-dts first))
              (pts (read-media-pts first))
              (duration (read-media-duration first))
              (keyframe? (read-media-keyframe? first))
              (off? (read-media-off? first)))
          (increase! processed total)
          (let ((id/output (or (simulation-audio) channel-no)))
            (let ((buffer (assemble-chunks self datas first total)))
              (if off?
                  (receive-audio (current-audio) id/output #f #f #f #f)
                (receive-audio (current-audio) id/output buffer dts pts duration)
                (record-play-frame self sender frame keyframe? dts pts))))))))
  
  
  (method protected (present-video self datas)
    (let ((first (car datas)))
      (with-record media
        (let ((sender (read-header-sender first))
              (channel-no (read-media-channel first))
              (frame (read-media-frame first))
              (total (read-media-total first))
              (dts (read-media-dts first))
              (pts (read-media-pts first))
              (duration (read-media-duration first))
              (keyframe? (read-media-keyframe? first))
              (off? (read-media-off? first)))
          (increase! processed total)
          (let ((id/output (or (simulation-video) channel-no)))
            (let ((buffer (assemble-chunks self datas first total)))
              (if off?
                  (receive-video (current-video) id/output #f #f #f #f #f)
                (receive-video (current-video) id/output buffer dts pts duration keyframe?)
                (when framerate
                  (update process-rate framerate))
                (if (eq? (get-state process-ring) 'late)
                    (record-freeze-frame self sender frame keyframe? dts pts)
                  (record-play-frame self sender frame keyframe? dts pts)))))))))))
