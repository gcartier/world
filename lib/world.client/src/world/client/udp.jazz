;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.math)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.audio)
        (world.configure)
        (world.context)
        (world.event)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.udp)
        (world.video))


(definition record-output?
  (world-setting 'world.record-output? #f))

(definition recordings
  (make-table))


(definition udp-video-action
  (world-setting 'world.udp-video-action #f))

(definition udp-video-file
  {File Settings "captures" "video.mpj"})

(definition udp-video-port
  #f)


(class UDP-Client extends Object
  
  
  (slot client-no             initialize #f getter generate)
  (slot udp-port              initialize #f getter generate)
  (slot udp-stopping?         initialize #f getter generate)
  (slot local-host            initialize #f getter generate)
  (slot local-port            initialize #f getter generate)
  (slot server-host           initialize #f getter generate)
  (slot server-port           initialize #f getter generate)
  (slot write-mutex           initialize #f getter generate)
  (slot send-channels         initialize #f getter generate)
  (slot receive-channels      initialize #f getter generate)
  (slot receive-task          initialize #f getter generate)
  (slot state-task            initialize #f getter generate)
  (slot started?              initialize #f getter generate)
  (slot packets-sent          initialize 0  getter generate)
  (slot packets-received      initialize 0  getter generate)
  (slot last-packets-sent     initialize 0  getter generate)
  (slot last-packets-received initialize 0  getter generate)
  (slot last-server-sent      initialize 0  getter generate)
  (slot last-server-received  initialize 0  getter generate)
  (slot outgoing-drop         initialize 0  getter generate)
  (slot incoming-drop         initialize 0  getter generate)
  (slot last-received-state   initialize #f getter generate)
  (slot throttle-media?       initialize #f getter generate)
  (slot camera-resetting      initialize #f getter generate)
  (slot topology              initialize #f getter generate)
  (slot peers                 initialize #f getter generate)
  (slot peers-mutex           initialize #f getter generate)
  (slot simulator             initialize #f getter generate)
  
  
  (method override (initialize self client-no)
    (nextmethod self)
    (set! self.client-no client-no))
  
  
  (method (connect self local-host host service)
    ;; quick heuristic
    (define (determine-local-address)
      (if local?
          #u8(127 0 0 1)
        (let ((info (host-info (host-name))))
          (let ((addresses (host-info-addresses info)))
            (if (= 1 (length addresses))
                (car addresses)
              #u8(0 0 0 0))))))
    
    (set! udp-port (open-udp (list
                               local-address: local-host
                               address: host
                               port-number: service)))
    (set! udp-stopping? #f)
    (let ((local-host (determine-local-address))
          (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (mutex-lock! write-mutex)
        (let ((data (make-u8vector (+ 8 4 4 4 4 4 4 4))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-connect)
          (write-udp-origin data client-no)
          (write-udp-connect-local-host data local-host)
          (write-udp-connect-local-port data local-port)
          (write-udp-connect-latency data (or udp-latency -1.))
          (write-udp-connect-lag data (or udp-lag -1.))
          (write-udp-connect-drop data (or udp-drop -1.))
          (write-udp-connect-audio-self? data audio-self?)
          (write-udp-connect-video-self? data video-self?)
          (retrying-write data udp-port))
        (mutex-unlock! write-mutex))
      
      (set! self.local-host local-host)
      (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! write-mutex (make-mutex 'write))
      (set! send-channels (make-table))
      (set! receive-channels (make-table))
      (set! packets-sent 0)
      (set! packets-received 0)
      (set! outgoing-drop 0)
      (set! incoming-drop 0)
      (set! camera-resetting #f)
      (set! topology (world-setting 'world.udp-topology 'server))
      (set! peers (make-table))
      (set! peers-mutex (make-mutex 'peers))
      (set! simulator (if (or udp-latency udp-lag udp-drop udp-congestion)
                          (new UDP-Simulator udp-latency udp-lag udp-drop
                               (lambda (data drop?)
                                 (if drop?
                                     (increase! packets-sent)
                                   @fix-me-can-deadlock-the-threads
                                   (mutex-lock! write-mutex)
                                   (send-topology self data)
                                   @fix-me-can-deadlock-the-threads
                                   (mutex-unlock! write-mutex))))
                        #f))
      (record-event udp-id-connect
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.)
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (if (or (eof-object? reply) (not (= (read-udp-kind reply) udp-connected)))
                (if (>= n 100)
                    (begin
                      (terminal 'BAILOUT 'did 'not 'receive 'udp-connected)
                      (exit 1))
                  (loop (+ n 1)))
              (let ((source-info (udp-source-socket-info udp-port)))
                (set! server-host (socket-info-address source-info))
                (set! server-port (socket-info-port-number source-info)))
              (let ((round-trip (- (current-seconds) (read-udp-sent reply))))
                (record-event udp-id-connected
                              -1.
                              -1.
                              -1.
                              -1.
                              round-trip
                              -1.)
                (when udp-show-roundtrip?
                  (format :terminal "{s} {s} {s}{%}" remote-name '***roundtrip*** round-trip)))))))))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (set! receive-task (new Task 'udp-receive (lambda (task)
                                                  (receive-loop self task))
                              priority: udp-priority))
      (start-task receive-task)
      (set! state-task (new Task 'udp-state (lambda (task)
                                              (state-loop self task))
                            priority: udp-priority))
      (start-task state-task)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (exit-thread (get-thread receive-task))
      (thread-join! (get-thread receive-task))
      (set! receive-task #f)
      (thread-send (get-thread state-task) #t)
      (thread-join! (get-thread state-task))
      (set! state-task #f)
      (set! started? #f)))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (or (/= origin client-no)
                                  audio-self?
                                  video-self?)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method public (find-send-channel self media-kind)
    (let ((key media-kind))
      (table-ref send-channels key #f)))
  
  
  (method package (require-send-channel self media-kind)
    (let ((key media-kind))
      (or (table-ref send-channels key #f)
          (let ((channel (new UDP-Send-Channel media-kind)))
            (table-set! send-channels key channel)
            channel))))
  
  
  (method package (close-send-channel self media-kind)
    (let ((key media-kind))
      (let ((channel (table-ref send-channels key #f)))
        (close channel)
        (table-clear send-channels key))))
  
  
  (method package (close-send-channels self)
    (iterate-table-safe send-channels
      (lambda (media-kind channel)
        (close-send-channel self media-kind))))
  
  
  (method public (find-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (table-ref receive-channels key #f)))
  
  
  (method package (require-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref receive-channels key #f)
          (let ((channel (new UDP-Receive-Channel origin media-kind)))
            (table-set! receive-channels key channel)
            channel))))
  
  
  (method package (close-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (let ((channel (table-ref receive-channels key #f)))
        (close channel)
        (table-clear receive-channels key))))
  
  
  (method package (close-receive-channels self)
    (iterate-table-safe receive-channels
      (lambda (key channel)
        (bind (origin . media-kind) key
          (close-receive-channel self origin media-kind)))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method (send-audio self buffer header? timestamp duration)
    (send-media self udp-audio buffer header? timestamp duration))
  
  
  (method (send-video self buffer header? timestamp duration)
    (send-media self udp-video buffer header? timestamp duration))
  
  
  (method (send-media self kind buffer header? timestamp duration)
    (mutex-lock! write-mutex)
    (let ((channel (find-send-channel self kind)))
      (when channel
        (let ()
          (define (send)
            (when udp-video-action
              (let ((key kind))
                (cond ((and buffer (not (table-ref send-channels key #f)))
                       (set! udp-video-port (case udp-video-action
                                              ((record)
                                               (create-directories udp-video-file)
                                               (open-output-file (path-settings udp-video-file)))
                                              ((play)
                                               (open-input-file (path-settings udp-video-file))))))
                      ((and (not buffer) (table-ref send-channels key #f))
                       (when udp-video-port
                         (close-port udp-video-port)
                         (set! udp-video-port #f))))))
            (let ((off? (not buffer))
                  (frame (next-frame-sequence! channel))
                  ;; give media off and resent header a sequential timestamp so it gets inserted correctly
                  (timestamp (or timestamp (+ (or (get-last-timestamp channel) 0) 1)))
                  (duration (or duration 1))
                  ;; udp-media-off is not really used for its content anymore
                  ;; but it is still useful as an empty buffer ends the logic
                  (buffer (or buffer udp-media-off)))
              ;; -1 means no timestamp used by vorbis header
              (unless (= timestamp -1)
                (set-last-timestamp channel timestamp))
              (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4))
                    (payload-size (u8vector-length buffer)))
                (let ((max-content-size (- udp-datagram-max header-size)))
                  (let ((total (fxceiling/ payload-size max-content-size)))
                    (let (loop-part (part 0) (pos 0))
                      (let ((remain (- payload-size pos)))
                        (when (> remain 0)
                          (let ((sequence (next-data-sequence! channel))
                                (content-size (min remain max-content-size)))
                            (let ((size (+ header-size content-size)))
                              (let ((data (make-u8vector size)))
                                (write-udp-sent data (current-seconds))
                                (write-udp-kind data kind)
                                (write-udp-origin data client-no)
                                (write-udp-sequence data sequence)
                                (write-udp-frame data frame)
                                (write-udp-part data part)
                                (write-udp-total data total)
                                (write-udp-media-timestamp data timestamp)
                                (write-udp-media-duration data duration)
                                (write-udp-media-subpayload data buffer pos content-size)
                                (write-udp-media-header? data header?)
                                (write-udp-media-off? data off?)
                                (when udp-video-port
                                  (case udp-video-action
                                    ((record)
                                     (write data udp-video-port)
                                     (newline udp-video-port)
                                     (force-output udp-video-port))
                                    ((play)
                                     (let ((obj (read udp-video-port)))
                                       (unless (eof-object? obj)
                                         (set! data obj))))))
                                ;; quick hack to make media off more robust
                                (if off?
                                    (loop (repeat 3)
                                          (send-data self data))
                                  (send-data self data))
                                (record-event udp-id-create-packet
                                              (fixnum->flonum client-no)
                                              (fixnum->flonum kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              -1.
                                              (if (= timestamp -1)
                                                  -1.
                                                (timestamp->flonum timestamp)))
                                (retain channel data)
                                (loop-part (+ part 1) (+ pos content-size)))))))))))))
          
          (when last-received-state
            (if throttle-media?
                ;; advance frame
                (let ((frame (next-frame-sequence! channel)))
                  (record-event udp-id-throttle-frame
                                (fixnum->flonum client-no)
                                (fixnum->flonum kind)
                                -1.
                                (fixnum->flonum frame)
                                -1.
                                -1.))
              (let ((now (current-seconds))
                    (throttle (if (= kind udp-audio) udp-audio-throttle udp-video-throttle)))
                (if (> (- now last-received-state) throttle)
                    (begin
                      (set! throttle-media? #t)
                      (record-event udp-id-throttle-on
                                    (fixnum->flonum server-no)
                                    (fixnum->flonum kind)
                                    -1.
                                    -1.
                                    -1.
                                    -1.)
                      (when udp-show-throttle?
                        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind kind) 'THROTTLE 'ON)))
                  (send))))))))
    (mutex-unlock! write-mutex))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       (udp-destination-set! server-host server-port udp-port)
       (retrying-write data udp-port)
       (increase! packets-sent))
      ((peer)
       (iterate-table peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (retrying-write data udp-port)))))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (state-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((end? (thread-receive udp-state-period #f)))
            (if end?
                (continuation-return exit #f)
              (site (udp-state on?: #t)
                (send-state self))
              (loop)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (when udp-record-read/write?
                  (let ((origin (read-udp-origin data))
                        (media-kind (read-udp-kind data))
                        (sequence (read-udp-sequence data))
                        (frame (read-udp-frame data)))
                    (record-event udp-id-read-data
                                  (fixnum->flonum origin)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum frame)
                                  -1.
                                  (fixnum->flonum (u8vector-length data)))))
                (receive-data self data))
              (loop)))))))
  
  
  (method (receive-data self data)
    (increase! packets-received)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-connected))
        ((udp-state)
         (receive-state self data))
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-state self data)
    (let ((states (u8vector->object (read-udp-state-channels data))))
      (for-each (lambda (info)
                  (bind (channel-origin media-kind client-state) info
                    (when (= channel-origin client-no)
                      ;; throttling
                      (set! last-received-state (current-seconds))
                      (when throttle-media?
                        (set! throttle-media? #f)
                        ;; force camera reset in the code below
                        (set! client-state 'waiting)
                        (record-event udp-id-throttle-off
                                      (fixnum->flonum server-no)
                                      (fixnum->flonum media-kind)
                                      -1.
                                      -1.
                                      -1.
                                      -1.)
                        (when udp-show-throttle?
                          (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'THROTTLE 'OFF)))
                      ;; waiting
                      (when (eq? client-state 'waiting)
                        (let ((channel (find-send-channel self media-kind)))
                          (when channel
                            (ecase media-kind
                              ((udp-audio)
                               ;; resend headers
                               (let ((audio (current-audio)))
                                 (when (audio-playing? audio)
                                   (when (eq? audio-codec 'vorbis)
                                     (let ((header (locate (get-retain-ring channel) media-packet-header?)))
                                       (if header
                                           (when udp-show-resetting?
                                             (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESEND 'AVOIDED (read-udp-sequence header)))
                                         (resend-mic-header audio)
                                         (record-event udp-id-reset-media
                                                       (fixnum->flonum channel-origin)
                                                       (fixnum->flonum media-kind)
                                                       -1.
                                                       -1.
                                                       -1.
                                                       -1.)
                                         (when udp-show-resets?
                                           (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESEND 'HEADERS))))))))
                              ((udp-video)
                               ;; camera reset
                               (let ((video (current-video)))
                                 (when (video-playing? video)
                                   (if (and camera-resetting
                                            (= camera-resetting (get-data-sequence channel)))
                                       (when udp-show-resetting?
                                         (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESET 'IN-PROGRESS))
                                     (let ((header (locate (get-retain-ring channel) media-packet-header?)))
                                       (if header
                                           (when udp-show-resetting?
                                             (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESET 'AVOIDED (read-udp-sequence header)))
                                         (reset-camera video)
                                         (let ((sequence (get-data-sequence channel)))
                                           (set! camera-resetting sequence)
                                           (record-event udp-id-reset-media
                                                         (fixnum->flonum channel-origin)
                                                         (fixnum->flonum media-kind)
                                                         -1.
                                                         -1.
                                                         -1.
                                                         -1.)
                                           (when udp-show-resets?
                                             (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'RESET sequence))))))))))))))))
                states)))
  
  
  (method (receive-ack self data)
    (let ((round-trip (- (current-seconds) (read-udp-sent data)))
          (server-sent (read-udp-ack-packets-sent data))
          (server-received (read-udp-ack-packets-received data)))
      (let ((fresh-packets-sent (- packets-sent last-packets-sent))
            (fresh-packets-received (- packets-received last-packets-received))
            (fresh-server-sent (- server-sent last-server-sent))
            (fresh-server-received (- server-received last-server-received)))
          (set! last-packets-sent packets-sent)
          (set! last-packets-received packets-received)
          (set! last-server-sent server-sent)
          (set! last-server-received server-received)
          (record-event udp-id-receive-ack
                        -1.
                        -1.
                        (fixnum->flonum (- fresh-packets-sent fresh-server-received))
                        (fixnum->flonum (- fresh-server-sent fresh-packets-received))
                        round-trip
                        -1.))
      (let ((outgoing-dropped (- packets-sent server-received))
            (incoming-dropped (- server-sent packets-received)))
        (set! outgoing-drop (and (> packets-sent 0) (percentage outgoing-dropped packets-sent)))
        (set! incoming-drop (and (> server-sent 0) (percentage incoming-dropped server-sent))))))
  
  
  (method (receive-nack self data)
    (let ((origin (read-udp-origin data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-latest-missing data))))
      (send-missing self origin media-kind missing)))
  
  
  (method (receive-media self kind data)
    (let ((origin (read-udp-origin data))
          (sequence (read-udp-sequence data)))
      (let ((channel (find-receive-channel self origin kind)))
        (when channel
          (let ((last-sequence (get-last-sequence channel)))
            (let ((in-order? (or (not last-sequence)
                                 (> sequence last-sequence)))
                  (now (current-seconds)))
              (if (not in-order?)
                  (begin
                    (remove-nack channel sequence)
                    (insert-media channel data now))
                ;; remember last sequence
                (set-last-sequence channel sequence)
                ;; insert media
                (when (insert-media channel data now)
                  ;; remember time
                  (update-time channel sequence data now (get-process-ring channel))
                  ;; add nacks to list
                  (when last-sequence
                    (let ((expected (+ last-sequence 1)))
                      (when (> sequence expected)
                        (let ((from-sequence (max expected (- sequence udp-max-nacks))))
                          (loop (for seq from from-sequence below sequence)
                                (add-nack channel now seq sequence)))
                        (let ((gap (- sequence expected)))
                          (when (> gap 0)
                            (let ((frame (read-udp-frame data)))
                              (record-event udp-id-packet-gap
                                            (fixnum->flonum origin)
                                            (fixnum->flonum kind)
                                            (fixnum->flonum sequence)
                                            (fixnum->flonum frame)
                                            (fixnum->flonum gap)
                                            -1.))
                            (when udp-show-gaps?
                              (terminal remote-name (present-media-kind kind) '***packet-gap*** now gap sequence)))))))
                  ;; send the lastest nacks
                  (let ((latest-missing (filter-latest-missing channel)))
                    (unless (null? latest-missing)
                      (send-nack self origin kind latest-missing)))))))))))
  
  
  (method (send-missing self origin media-kind missing)
    (let ((channel (find-send-channel self media-kind)))
      (when channel
        (let ((ring (get-retain-ring channel))
              (entries (get-retain-entries channel)))
          (for-each (lambda (sequence)
                      (let ((found (table-ref entries sequence #f) @old (locate ring (lambda (data)
                                                  (= (read-udp-sequence data) sequence)))))
                        (if found
                            (begin
                              (send-data self found)
                              (let ((frame (read-udp-frame found)))
                                (record-event udp-id-resend-packet
                                              (fixnum->flonum origin)
                                              (fixnum->flonum media-kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              -1.
                                              -1.)))
                          (record-event udp-id-absent-packet
                                        (fixnum->flonum origin)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        -1.
                                        -1.
                                        -1.)
                          (when udp-show-nacks?
                            (terminal remote-name (present-media-kind media-kind) '***nack-missing*** sequence)))))
                    missing)))))
  
  
  (method (send-state self)
    (define (collect-states)
      (let ((queue (new-queue)))
        (iterate-table receive-channels
          (lambda (key channel)
            (let ((state (get-process-state channel)))
              (enqueue queue
                       (list (get-origin channel)
                             (get-media-kind channel)
                             state)))))
        (queue-list queue)))
    
    (let ((states (collect-states)))
      (mutex-lock! write-mutex)
      (let ((states (object->u8vector states)))
        (let ((size (+ 8 4 4 4 (u8vector-length states))))
          (let ((data (make-u8vector size)))
            (write-udp-sent data (current-seconds))
            (write-udp-kind data udp-state)
            (write-udp-origin data client-no)
            (write-udp-state-channels data states)
            (send-data self data))))
      (mutex-unlock! write-mutex)))
  
  
  (method (send-nack self origin media-kind latest-missing)
    (when udp-show-nacks?
      (terminal remote-name (present-media-kind media-kind) '***send-nack*** latest-missing))
    (mutex-lock! write-mutex)
    (let ((missing (object->u8vector latest-missing)))
      (let ((size (+ 8 4 4 4 4 (u8vector-length missing))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-origin data origin)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-latest-missing data missing)
          (send-data self data))))
    (mutex-unlock! write-mutex)))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Channel
  
  
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-timestamp accessors generate)
  (slot retain-ring    getter generate)
  (slot retain-entries getter generate)
  (slot release-task   getter generate)
  
  
  (method override (initialize self media-kind)
    (nextmethod self media-kind)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f)
    (set! self.retain-ring (new Time-Ring udp-retain-size max-size: udp-retain-max-size overflow-proc: (udp-ring-overflow 'retain udp-ring-kind-retain)))
    (set! self.retain-entries (make-table test: eqv?))
    (set! self.release-task (new Task 'udp-release (lambda (task)
                                                     (release-loop self task))
                                 priority: udp-priority))
    (start-task release-task))
  
  
  (method override (destroy self)
    (insert-earliest retain-ring #f)
    (thread-join! (get-thread release-task))
    (nextmethod self))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (retain self data)
    (insert retain-ring (+ (current-seconds) udp-retain-window) data)
    (table-set! retain-entries (read-udp-sequence data) data)
    (let ((kind (read-udp-kind data)))
      (let ((origin (read-udp-origin data))
            (sequence (read-udp-sequence data))
            (frame (read-udp-frame data))
            (ring-size (get-count retain-ring))
            (timestamp (read-udp-media-timestamp data)))
        (record-event udp-id-retain-packet
                      (fixnum->flonum origin)
                      (fixnum->flonum media-kind)
                      (fixnum->flonum sequence)
                      (fixnum->flonum frame)
                      (fixnum->flonum ring-size)
                      (timestamp->flonum timestamp)))))
  
  
  (method protected (release-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (wait retain-ring)))
            (if (not data)
                (continuation-return exit #f)
              (site (udp-release on?: #t)
                (table-clear retain-entries (read-udp-sequence data))
                (let ((kind (read-udp-kind data)))
                  (let ((origin (read-udp-origin data))
                        (sequence (read-udp-sequence data))
                        (frame (read-udp-frame data))
                        (ring-size (get-count retain-ring))
                        (timestamp (read-udp-media-timestamp data)))
                    (record-event udp-id-release-packet
                                  (fixnum->flonum origin)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum frame)
                                  (fixnum->flonum ring-size)
                                  (timestamp->flonum timestamp)))))
              (loop))))))))


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot origin                  getter generate)
  (slot latest-nacks            accessors generate)
  (slot process-state           getter generate)
  (slot process-ring            getter generate)
  (slot process-task            getter generate)
  (slot process-average         getter generate)
  (slot ready-buffers           getter generate)
  (slot ready-count             getter generate)
  (slot last-processed-frame    getter generate)
  (slot last-processed-sequence getter generate)
  (slot last-processed-seconds  getter generate)
  (slot processed               getter generate)
  (slot missing                 getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self media-kind)
    (set! self.origin origin)
    (set! self.latest-nacks '())
    (set! self.process-state 'waiting)
    (set! self.ready-buffers (make-table test: eqv?))
    (set! self.ready-count 0)
    (set! self.last-processed-frame #f)
    (set! self.last-processed-sequence #f)
    (set! self.last-processed-seconds #f)
    (set! self.process-ring (new Time-Ring udp-process-size max-size: udp-process-max-size key-proc: udp-ring-key invalid-proc: (udp-ring-invalid origin media-kind) overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
    (set! self.process-task (new Task 'udp-process (lambda (task)
                                                     (process-loop self task))
                                 priority: udp-priority))
    (set! self.process-average (new Average .05 1.))
    (set! self.processed 0)
    (set! self.missing 0)
    (start-task process-task))
  
  
  (method override (destroy self)
    (insert-earliest process-ring #f)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (add-nack self seconds seq sequence)
    (set! latest-nacks (cons (cons seconds seq) latest-nacks))
    (let ((ring-size (length latest-nacks)))
      (record-event udp-id-nack-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum seq)
                    (fixnum->flonum sequence)
                    (fixnum->flonum ring-size)
                    -1.))
    ;; trim when more than udp-latest-nacks
    (when (> (length latest-nacks) udp-latest-nacks)
      (let ((removed-sequence (cdr (last latest-nacks))))
        (set-cdr! (tail latest-nacks (- udp-latest-nacks 1)) '())
        (let ((ring-size (length latest-nacks)))
          (record-event udp-id-giveup-packet
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        (fixnum->flonum removed-sequence)
                        -1.
                        (fixnum->flonum ring-size)
                        -1.))))
    latest-nacks)
  
  
  (method protected (remove-nack self sequence)
    (set! latest-nacks (remove! sequence latest-nacks key: cdr)))
  
  
  (method protected (filter-latest-missing self)
    ;; discard any nack older than udp-process-window
    (let ((now (current-seconds))
          (ring-size (length latest-nacks))
          (gaveup-on #f))
      (set! latest-nacks (collect-if (lambda (nack)
                                       (let ((seconds (car nack)))
                                         (let ((keep? (< (- now seconds) udp-nack-window)))
                                           (when (not keep?)
                                             (let ((removed-sequence (cdr nack)))
                                               (set! gaveup-on removed-sequence)
                                               (decrease! ring-size)
                                               (record-event udp-id-giveup-packet
                                                             (fixnum->flonum origin)
                                                             (fixnum->flonum media-kind)
                                                             (fixnum->flonum removed-sequence)
                                                             -1.
                                                             (fixnum->flonum ring-size)
                                                             -1.)))
                                           keep?)))
                                     latest-nacks))
      (when (and gaveup-on (= media-kind udp-video))
        (unless (eq? process-state 'waiting)
          (process-state-waiting self gaveup-on)
          (let ((udp-client (get-udp-client (current-client))))
            ;; should not be necessary but lets
            ;; do the necessary changes later...
            (when udp-client
              (send-state udp-client))))))
    (map cdr latest-nacks))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method private (process-state-ok self)
    (unless (eq? process-state 'ok)
      (set! process-state 'ok)
      (record-event udp-id-state-ok
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    -1.
                    -1.
                    -1.)
      (when udp-show-states?
        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'STATE 'OK))))
  
  
  (method private (process-state-waiting self (gaveup-on #f))
    (unless (eq? process-state 'waiting)
      (set! process-state 'waiting)
      (record-event udp-id-state-waiting
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    -1.
                    (if gaveup-on (fixnum->flonum gaveup-on) -1.)
                    -1.)
      (when udp-show-states?
        (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) 'STATE 'WAITING))))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected (insert-nack self data)
    )
  
  
  (method protected (insert-media self data now)
    (let ((sequence (read-udp-sequence data)))
      (let ((timeless? (= (read-udp-media-timestamp data) -1)))
        (let ((timestamp (read-udp-media-seconds data)))
          (let ((process-time (cond (timeless?
                                     #f)
                                    ((not time-base)
                                     (+ now udp-process-window))
                                    (else
                                     (+ timestamp time-base udp-process-window)
                                     ;; (+ timestamp (- base-time base-timestamp) udp-process-window)
                                     ;; (+ base-time (- timestamp base-timestamp) udp-process-window)
                                     ))))
            (let ((problem (insert process-ring process-time data)))
              (if (not problem)
                  (let ((origin (read-udp-origin data))
                        (ring-size (get-count process-ring)))
                    (record-event udp-id-insert-packet
                                  (fixnum->flonum origin)
                                  (fixnum->flonum media-kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum ring-size)
                                  (if timeless? -1. process-time)
                                  (if timeless? -1. timestamp))
                    #t)
                (case problem
                  ((duplicate)
                   (let ((origin (read-udp-origin data))
                         (ring-size (get-count process-ring)))
                     (record-event udp-id-duplicate-packet
                                   (fixnum->flonum origin)
                                   (fixnum->flonum media-kind)
                                   (fixnum->flonum sequence)
                                   (fixnum->flonum ring-size)
                                   (if timeless? -1. process-time)
                                   (if timeless? -1. timestamp)))
                   (when udp-show-duplicates?
                     (format :terminal "{s} {s} {s} {s}{%}" remote-name (present-media-kind media-kind) '***duplicate*** sequence))))
                #f)))))))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((data (wait process-ring)))
            (if (not data)
                (continuation-return exit #f)
              (site (udp-process on?: #t)
                (process-data self data))
              (looping)))))))
  
  
  (method (process-data self data)
    (define (record-reject-packet origin sequence frame timestamp)
      (record-event udp-id-process-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    -1.
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (define (record-process-packet origin sequence frame timestamp)
      (record-event udp-id-process-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    -1.
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (define (record-repeat-packet origin sequence frame timestamp)
      (record-event udp-id-repeat-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    -1.
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (define (record-discard-packet origin sequence frame timestamp)
      (record-event udp-id-discard-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    -1.
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (define (record-missing-packet origin sequence frame timestamp)
      (record-event udp-id-missing-packet
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    (fixnum->flonum sequence)
                    (fixnum->flonum frame)
                    -1.
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (let ((origin (read-udp-origin data))
          (sequence (read-udp-sequence data))
          (frame (read-udp-frame data))
          (part (read-udp-part data))
          (total (read-udp-total data))
          (timestamp (read-udp-media-timestamp data)))
      (if (and last-processed-frame (<= frame last-processed-frame))
          ;; reject
          (record-reject-packet origin sequence frame timestamp)
        ;; process
        (record-process-packet origin sequence frame timestamp)
        ;; add
        (let ((buffer (table-ref ready-buffers frame #f)))
          (if (not buffer)
              (let ((chunks (make-vector total #f))
                    (base (- sequence part))
                    (count 1))
                (vector-set! chunks part data)
                (table-set! ready-buffers frame (new UDP-Ready-Buffer origin base frame count total timestamp chunks))
                (increase! ready-count))
            (let ((chunks (get-chunks buffer)))
              (if (vector-ref chunks part)
                  (record-repeat-packet origin sequence frame timestamp)
                (add-count! buffer 1)
                (vector-set! chunks part data)
                (increase! ready-count)))))
        ;; process
        (let ((now (current-seconds))
              (keys (table-keys ready-buffers)))
          (let ((lowest (minimum keys))
                (highest (maximum keys)))
            (define (flush-frames to)
              (let ((from (if (not last-processed-frame)
                              lowest
                            (+ last-processed-frame 1))))
                (loop (for f from from below to)
                      (flush-frame f))
                (let ((buffer (table-ref ready-buffers to #f)))
                  (when buffer
                    (missing-buffers buffer)))))
            
            (define (flush-frame f)
              (let ((buffer (table-ref ready-buffers f #f)))
                (when buffer
                  (missing-buffers buffer)
                  (let ((origin (get-origin buffer))
                        (frame (get-frame buffer))
                        (count (get-count buffer))
                        (total (get-total buffer))
                        (timestamp (get-timestamp buffer))
                        (chunks (get-chunks buffer)))
                    (loop (for part from 0 below total)
                          (let ((data (vector-ref chunks part)))
                            (if data
                                (let ((discard-sequence (read-udp-sequence data)))
                                  (record-discard-packet origin discard-sequence frame timestamp))
                              (let ((missing-sequence (rebase-sequence buffer part)))
                                  (record-missing-packet origin missing-sequence frame timestamp)))))
                    (decrease! ready-count count))
                  (set! last-processed-frame f)
                  (set! last-processed-sequence (rebase-last buffer))
                  (set! last-processed-seconds now)))
              (table-clear ready-buffers f))
            
            (define (missing-buffers buffer)
              (when last-processed-sequence
                (let ((expected-sequence (+ last-processed-sequence 1)))
                  (loop (for seq from expected-sequence below (rebase-first buffer))
                        (record-missing-packet origin seq -1 -1)))))
            
            (define (scan-audio)
              (let (loop-frame (frame lowest))
                (when (<= frame highest)
                  (let ((buffer (table-ref ready-buffers frame #f)))
                    (if (and buffer
                             (complete? buffer))
                        (begin
                          (missing-buffers buffer)
                          (table-clear ready-buffers frame)
                          (decrease! ready-count (get-count buffer))
                          (present-frame self (get-chunks buffer))
                          (set! last-processed-frame frame)
                          (set! last-processed-sequence (rebase-last buffer))
                          (set! last-processed-seconds now)
                          (loop-frame (+ frame 1)))
                      (when (> (table-length ready-buffers) 1)
                        (let ((next-frame (max (+ frame 1) highest)))
                          (flush-frames next-frame)
                          (loop-frame next-frame))))))))
            
            (define (scan-video)
              (let (loop-frame (frame lowest))
                (when (<= frame highest)
                  (let ((buffer (table-ref ready-buffers frame #f)))
                    (if (and buffer
                             (complete? buffer)
                             (or (complete-header? buffer)
                                 (not last-processed-frame)
                                 (= frame (+ last-processed-frame 1))))
                        ;; complete
                        (begin
                          (missing-buffers buffer)
                          (table-clear ready-buffers frame)
                          (decrease! ready-count (get-count buffer))
                          (present-frame self (get-chunks buffer))
                          (set! last-processed-frame frame)
                          (set! last-processed-sequence (rebase-last buffer))
                          (set! last-processed-seconds now)
                          (loop-frame (+ frame 1)))
                      ;; incomplete
                      (let ((header (loop (for f from (+ frame 1) to highest)
                                          (when (let ((buffer (table-ref ready-buffers f #f)))
                                                  (and buffer (complete-header? buffer)))
                                            (return f))
                                          (finally #f))))
                        (if header
                            ;; found header
                            (begin
                              (flush-frames header)
                              (loop-frame header))
                          ;; go to waiting
                          (unless (read-udp-media-header? data)
                            (when (and last-processed-seconds (> (- now last-processed-seconds) .5))
                              (unless (eq? process-state 'waiting)
                                (process-state-waiting self)
                                (let ((udp-client (get-udp-client (current-client))))
                                  ;; should not be necessary but lets
                                  ;; do the necessary changes later...
                                  (when udp-client
                                    (send-state udp-client)))))))))))))
            
            ;; scan
            (ecase media-kind
              ((udp-audio)
               (scan-audio))
              ((udp-video)
               (scan-video)))))
        @redo
        (let ((gap (if (not last-processed) 0 (- frame (+ last-processed 1)))))
          (loop (repeat gap)
                (add process-average 0.))
          (add process-average 1.)))))
  
  
  (method (present-frame self datas)
    (define (record-present-frame origin frame timestamp header?)
      (record-event udp-id-present-frame
                    (fixnum->flonum origin)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (if header? 1. -1.)
                    (if (= timestamp -1)
                        -1.
                      (timestamp->flonum timestamp))))
    
    (let ((member (find-group-member-by-no (current-client) origin)))
      ;; quick solution for when logging in and starting receiving
      ;; someone's media before the client is actually registered
      ;; need to revisit this code for a cleaner solution
      (when member
        (let ((id (second member)))
          (let ((count (vector-length datas))
                (first (vector-ref datas 0)))
            (increase! processed count)
            (let ((kind (read-udp-kind first))
                  (origin (read-udp-origin first))
                  (frame (read-udp-frame first))
                  (total (read-udp-total first))
                  (timestamp (read-udp-media-timestamp first))
                  (duration (read-udp-media-duration first))
                  (header? (read-udp-media-header? first))
                  (off? (read-udp-media-off? first)))
              (define (process-audio)
                (let ((buffer (assemble-chunks)))
                  (if off?
                      (receive-server-audio (current-audio) id #f #f #f)
                    (when header?
                      (process-state-ok self))
                    (if (and header? (eq? audio-codec 'vorbis))
                        (let ((headers (u8vector->object buffer)))
                          (for-each (lambda (header)
                                      (bind (buffer timestamp duration) header
                                        ;; be very careful as timestamp is incorrect as it
                                        ;; is the timestamp at time the header was captured
                                        ;; this only works because gst_app_src_write3
                                        ;; doesn't actually use the timestamp
                                        (receive-server-audio (current-audio) id buffer timestamp duration)))
                                    headers))
                      (receive-server-audio (current-audio) id buffer timestamp duration))
                    (record-present-frame origin frame timestamp header?))))
              
              (define (process-video)
                (let ((buffer (assemble-chunks)))
                  (if off?
                      (receive-server-video (current-video) id #f #f #f)
                    (when header?
                      (process-state-ok self))
                    (receive-server-video (current-video) id buffer timestamp duration)
                    (record-present-frame origin frame timestamp header?))))
              
              (define (assemble-chunks)
                (if (= total 1)
                    (read-udp-media-payload first)
                  (let ((chunks (loop (for data in-vector datas)
                                      (collect (read-udp-media-payload data)))))
                    (apply u8vector-append chunks))))
              
              (ecase kind
                ((udp-audio)
                 (process-audio))
                ((udp-video)
                 (process-video))))))))))


;;;
;;;; Ready Buffer
;;;


(class UDP-Ready-Buffer extends Object
  
  
  (slot origin    getter generate)
  (slot base      getter generate)
  (slot frame     getter generate)
  (slot count     getter generate)
  (slot total     getter generate)
  (slot timestamp getter generate)
  (slot chunks    getter generate)
  
  
  (method override (initialize self origin base frame count total timestamp chunks)
    (nextmethod self)
    (set! self.origin origin)
    (set! self.base base)
    (set! self.frame frame)
    (set! self.count count)
    (set! self.total total)
    (set! self.timestamp timestamp)
    (set! self.chunks chunks))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (when (complete? self)
          (format output "complete")))))
  
  
  (method protected (complete? self)
    (= count total))
  
  
  (method protected (complete-header? self)
    (and (complete? self)
         (read-udp-media-header? (vector-ref chunks 0))))
  
  
  (method protected (rebase-sequence self part)
    (+ base part))
  
  
  (method protected (rebase-first self)
    base)
  
  
  (method protected (rebase-last self)
    (+ base (- total 1)))
  
  
  (method protected (add-count! self delta)
    (set! count (+ count delta)))))
