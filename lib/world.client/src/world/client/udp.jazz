;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.presence)
        (jazz.syntax (phase syntax))
        (world)
        (world.audio)
        (world.configure)
        (world.context)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.udp)
        (world.video))


(definition record-output?
  (world-setting 'world.record-output? #f))

(definition recordings
  (make-table))


(definition udp-video-action
  (world-setting 'world.udp-video-action #f))

(definition udp-video-file
  {File Settings "captures" "video.mpj"})

(definition udp-video-port
  #f)


(class UDP-Client extends Object
  
  
  (slot udp-port         initialize #f getter generate)
  (slot udp-stopping?    initialize #f getter generate)
  (slot local-host       initialize #f getter generate)
  (slot local-port       initialize #f getter generate)
  (slot server-host      initialize #f getter generate)
  (slot server-port      initialize #f getter generate)
  (slot write-mutex      initialize #f getter generate)
  (slot send-channels    initialize #f getter generate)
  (slot receive-channels initialize #f getter generate)
  (slot receive-task     initialize #f getter generate)
  (slot ack-task         initialize #f getter generate)
  (slot started?         initialize #f getter generate)
  (slot camera-resetting initialize #f getter generate)
  (slot topology         initialize #f getter generate)
  (slot peers            initialize #f getter generate)
  (slot peers-mutex      initialize #f getter generate)
  (slot simulator        initialize #f getter generate)
  
  
  (method (connect self client-no local-host host service)
    ;; quick heuristic
    (define (determine-local-address)
      (if local?
          #u8(127 0 0 1)
        (let ((info (host-info (host-name))))
          (let ((addresses (host-info-addresses info)))
            (if (= 1 (length addresses))
                (car addresses)
              #u8(0 0 0 0))))))
    
    (set! udp-port (open-udp (list
                               local-address: local-host
                               address: host
                               port-number: service)))
    (set! udp-stopping? #f)
    (let ((local-host (determine-local-address))
          (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (mutex-lock! write-mutex)
        (let ((data (make-u8vector (+ 8 4 4 4 4 4 4 4))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-connect)
          (write-udp-origin data client-no)
          (write-udp-connect-local-host data local-host)
          (write-udp-connect-local-port data local-port)
          (write-udp-connect-latency data (or udp-latency -1.))
          (write-udp-connect-lag data (or udp-lag -1.))
          (write-udp-connect-drop data (or udp-drop -1.))
          (retrying-write data udp-port))
        (mutex-unlock! write-mutex))
      
      (set! self.local-host local-host)
      (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! write-mutex (make-mutex 'write))
      (set! send-channels (make-table))
      (set! receive-channels (make-table))
      (set! camera-resetting #f)
      (set! topology (world-setting 'world.udp-topology 'server))
      (set! peers (make-table))
      (set! peers-mutex (make-mutex 'peers))
      (set! simulator (if (or udp-latency udp-lag udp-drop udp-congestion)
                          (new UDP-Simulator udp-latency udp-lag udp-drop
                               (lambda (data)
                                 (send-topology self data)))
                        #f))
      (record-event udp-id-connect
                    0.
                    0.
                    0.
                    0.)
      (send-connect)
      ;; togetherimprove
      ;; quick solution to receiving media instead of the expected response
      ;; need to revisit this code for a cleaner solution. this is like doing
      ;; a call using UDP which is really difficult
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (let ((reply (read udp-port)))
            (let ((kind (read-udp-kind reply)))
              (if (not (= kind udp-connected))
                  (if (>= n 100)
                      (begin
                        (terminal 'BAILOUT 'did 'not 'received 'udp-connected)
                        (exit 1))
                    (loop (+ n 1)))
                (let ((source-info (udp-source-socket-info udp-port)))
                  (set! server-host (socket-info-address source-info))
                  (set! server-port (socket-info-port-number source-info)))
                (let ((round-trip (- (current-seconds) (read-udp-sent reply))))
                  (record-event udp-id-connected
                                round-trip
                                0.
                                0.
                                0.)))))))))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (set! receive-task (new Task 'udp-receive (lambda (task)
                                                  (receive-loop self task))
                              priority: udp-priority))
      (start-task receive-task)
      (set! ack-task (new Task 'udp-ack (lambda (task)
                                          (ack-loop self task))
                          priority: udp-priority))
      (start-task ack-task)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (exit-thread (get-thread receive-task))
      (thread-join! (get-thread receive-task))
      (set! receive-task #f)
      (thread-send (get-thread ack-task) #t)
      (thread-join! (get-thread ack-task))
      (set! ack-task #f)
      (set! started? #f)))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((client-no (get-client-no (current-tier)))
          (p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (or (/= origin client-no)
                                  audio-self?
                                  video-self?)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method public (find-send-channel self media-kind)
    (let ((key media-kind))
      (table-ref send-channels key #f)))
  
  
  (method package (require-send-channel self media-kind)
    (let ((key media-kind))
      (or (table-ref send-channels key #f)
          (let ((channel (new UDP-Send-Channel media-kind)))
            (table-set! send-channels key channel)
            channel))))
  
  
  (method package (close-send-channel self media-kind)
    (let ((key media-kind))
      (let ((channel (table-ref send-channels key #f)))
        (close channel)
        (table-clear send-channels key))))
  
  
  (method public (find-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (table-ref receive-channels key #f)))
  
  
  (method package (require-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref receive-channels key #f)
          (let ((channel (new UDP-Receive-Channel origin media-kind)))
            (table-set! receive-channels key channel)
            channel))))
  
  
  (method package (close-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (let ((channel (table-ref receive-channels key #f)))
        (close channel)
        (table-clear receive-channels key))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method (send-audio self buffer timestamp duration)
    (send-media self udp-audio buffer timestamp duration))
  
  
  (method (send-video self buffer timestamp duration)
    (send-media self udp-video buffer timestamp duration))
  
  
  (method (send-media self kind buffer timestamp duration)
    (mutex-lock! write-mutex)
    (let ((channel (find-send-channel self kind)))
      (when channel
        (let ()
          (define (send)
            (when udp-video-action
              (let ((key kind))
                (cond ((and buffer (not (table-ref send-channels key #f)))
                       (set! udp-video-port (case udp-video-action
                                              ((record)
                                               (create-directories udp-video-file)
                                               (open-output-file (path-settings udp-video-file)))
                                              ((play)
                                               (open-input-file (path-settings udp-video-file))))))
                      ((and (not buffer) (table-ref send-channels key #f))
                       (when udp-video-port
                         (close-port udp-video-port)
                         (set! udp-video-port #f))))))
            ;; quick hack to give media off a timestamp
            (let ((last-timestamp (or (get-last-timestamp channel) 0)))
              (let ((off? (not buffer))
                    (frame (next-frame-sequence! channel))
                    (timestamp (or timestamp (+ last-timestamp 1)))
                    (duration (or duration 1))
                    (buffer (or buffer udp-media-off)))
                (set-last-timestamp channel timestamp)
                (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4))
                      (payload-size (u8vector-length buffer)))
                  (let ((max-content-size (- udp-datagram-max header-size)))
                    (let ((total (fxceiling/ payload-size max-content-size)))
                      (let (loop (part 0) (pos 0))
                        (let ((remain (- payload-size pos)))
                          (when (> remain 0)
                            (let ((sequence (next-data-sequence! channel))
                                  (content-size (min remain max-content-size)))
                              (let ((size (+ header-size content-size)))
                                (let ((data (make-u8vector size)))
                                  (write-udp-sent data (current-seconds))
                                  (write-udp-kind data kind)
                                  (write-udp-origin data (get-client-no (current-client)))
                                  (write-udp-sequence data sequence)
                                  (write-udp-frame data frame)
                                  (write-udp-part data part)
                                  (write-udp-total data total)
                                  (write-udp-timestamp data timestamp)
                                  (write-udp-duration data duration)
                                  (write-udp-subpayload data buffer pos content-size)
                                  (when udp-video-port
                                    (case udp-video-action
                                      ((record)
                                       (write data udp-video-port)
                                       (newline udp-video-port)
                                       (force-output udp-video-port))
                                      ((play)
                                       (let ((obj (read udp-video-port)))
                                         (unless (eof-object? obj)
                                           (set! data obj))))))
                                  (send-data self data)
                                  (update-time channel sequence data (get-retain-ring channel))
                                  (retain channel data)
                                  (record-event udp-id-send-media
                                                (fixnum->flonum kind)
                                                (fixnum->flonum sequence)
                                                (if off? 0. 1.)
                                                0.)
                                  (loop (+ part 1) (+ pos content-size))))))))))))))
          
          (send)
          @wait-debug-throttle-logic
          (unless (get-throttle-media channel)
            (let ((last-received-ack (get-last-received-ack channel)))
              (if (not last-received-ack)
                  (send)
                (let ((now (current-seconds))
                      (stop (if (= kind udp-audio) udp-ack-audio-stop udp-ack-video-stop)))
                  (if (> (- now last-received-ack) stop)
                      (begin
                        (set-throttle-media channel #t)
                        (when udp-show-throttle?
                          (format :terminal "{s} {s} {s} {s}{%}" remote-name 'THROTTLE (present-media-kind kind) 'ON)))
                    (send)))))))))
    (mutex-unlock! write-mutex))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       (udp-destination-set! server-host server-port udp-port)
       (retrying-write data udp-port))
      ((peer)
       (iterate-table peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (retrying-write data udp-port)))))))
  
  
  ;;;
  ;;;; Ack
  ;;;
  
  
  (method (ack-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((end? (thread-receive udp-ack-period #f)))
            (if end?
                (continuation-return exit #f)
              (site (udp-ack on?: #t)
                (send-ack self))
              (loop)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (receive-data self data))
              (loop)))))))
  
  
  (method (receive-data self data)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-ack self data)
    (let ((sent (read-udp-sent data))
          (states (u8vector->object (read-udp-ack-channel-states data))))
      @wait
      (let ((round-trip (- (current-seconds) sent)))
        (record-event udp-id-receive-ack
                      (fixnum->flonum media-kind)
                      (fixnum->flonum sequence)
                      round-trip
                      0.))
      (let ((client-no (get-client-no (current-client))))
        (for-each (lambda (info)
                    (bind (origin media-kind state) info
                      (when (= origin client-no)
                        (let ((channel (find-send-channel self media-kind)))
                          (when channel
                            ;; throttling
                            (set-last-received-ack channel (current-seconds))
                            (when (get-throttle-media channel)
                              (set-throttle-media channel #f)
                              (when udp-show-throttle?
                                (format :terminal "{s} {s} {s} {s}{%}" remote-name 'THROTTLE (present-media-kind media-kind) 'OFF)))
                            ;; camera reset
                            (when (= media-kind udp-video)
                              (when (eq? state 'waiting)
                                (if (and camera-resetting
                                         (= camera-resetting (get-data-sequence channel)))
                                    (when udp-show-resets?
                                      (format :terminal "{s} {s} {s}{%}" remote-name 'RESET 'IN-PROGRESS))
                                  (let ((header (locate (get-retain-ring channel) video-packet-header?)))
                                    (if header
                                        (when udp-show-resets?
                                          (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name 'VIDEO 'RESET 'AVOIDED (read-udp-sequence header)))
                                      (let ((video (current-video)))
                                        (reset-camera video)
                                        (let ((sequence (get-data-sequence channel)))
                                          (set! camera-resetting sequence)
                                          (when udp-show-resets?
                                            (format :terminal "{s} {s} {s} {s} {s}{%}" remote-name 'VIDEO 'RESET 'CAMERA sequence))))))))))))))
                  states))))
  
  
  (method (receive-nack self data)
    (let ((origin (read-udp-origin data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-latest-missing data))))
      (send-missing self origin media-kind missing)))
  
  
  (method (receive-media self kind data)
    (let ((origin (read-udp-origin data))
          (sequence (read-udp-sequence data)))
      (let ((channel (find-receive-channel self origin kind)))
        (when channel
          (let ((last-sequence (get-last-sequence channel)))
            (let ((in-order? (or (not last-sequence)
                                 (> sequence last-sequence))))
              (if (not in-order?)
                  (remove-nack channel sequence)
                ;; send nacks to server
                (when last-sequence
                  (let ((expected (+ last-sequence 1)))
                    (when (> sequence expected)
                      ;; zanzaa braindead if gap is huge
                      (loop (for seq from expected below sequence)
                            (add-nack channel seq))
                      (send-nack self origin kind (get-latest-nacks channel)))))
                ;; remember time information
                (update-time channel sequence data (get-process-ring channel)))
              (insert-media channel data)))))))
  
  
  (method (send-missing self origin media-kind missing)
    (let ((channel (find-send-channel self media-kind)))
      (when channel
        (let ((ring (get-retain-ring channel)))
          (for-each (lambda (sequence)
                      (let ((found (locate ring (lambda (data)
                                                  (= (read-udp-sequence data) sequence)))))
                        (record-event udp-id-receive-nack
                                      (fixnum->flonum media-kind)
                                      (fixnum->flonum sequence)
                                      (if found 1. 0.)
                                      0.)
                        (if found
                            (send-data self found)
                          (when udp-debug-nack?
                            (terminal remote-name (udp-name media-kind) '***nack-missing*** sequence)))))
                    missing)))))
  
  
  (method (send-ack self)
    (define (collect-states)
      (let ((queue (new-queue)))
        (iterate-table receive-channels
          (lambda (key channel)
            (let ((state (get-process-state channel)))
              (when state
                (enqueue queue
                         (list (get-origin channel)
                               (get-media-kind channel)
                               state))))))
        (queue-list queue)))
    
    (let ((states (collect-states)))
      (mutex-lock! write-mutex)
      (let ((states (object->u8vector states)))
        (let ((size (+ 8 4 4 4 (u8vector-length states))))
          (let ((data (make-u8vector size)))
            (write-udp-sent data (current-seconds))
            (write-udp-kind data udp-ack)
            (write-udp-origin data (get-client-no (current-client)))
            (write-udp-ack-channel-states data states)
            (send-data self data))))
      (mutex-unlock! write-mutex)))
  
  
  (method (send-nack self origin media-kind latest-missing)
    (when udp-debug-nack?
      (terminal remote-name (udp-name media-kind) 'send-nack latest-missing))
    (mutex-lock! write-mutex)
    (let ((missing (object->u8vector latest-missing)))
      (let ((size (+ 8 4 4 4 4 (u8vector-length missing))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-origin data origin)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-latest-missing data missing)
          (send-data self data))))
    (mutex-unlock! write-mutex)))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Channel
  
  
  (slot data-sequence     accessors generate)
  (slot frame-sequence    accessors generate)
  (slot last-timestamp    accessors generate)
  (slot last-received-ack accessors generate)
  (slot throttle-media    accessors generate)
  (slot retain-ring       getter generate)
  (slot release-task      getter generate)
  
  
  (method override (initialize self media-kind)
    (nextmethod self media-kind)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f)
    (set! self.last-received-ack #f)
    (set! self.throttle-media #f)
    ;; make it really big until time ring is a real ring
    (set! self.retain-ring (new Time-Ring 400096 @w 512 @max-size: +inf.0 now-proc: (~ now-timestamp self)))
    (set! self.release-task (new Task 'udp-release (lambda (task)
                                                     (release-loop self task))
                                 priority: udp-priority))
    (start-task release-task))
  
  
  (method override (destroy self)
    (insert-earliest retain-ring #f)
    (thread-join! (get-thread release-task))
    (nextmethod self))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (retain self data)
    (insert retain-ring (read-udp-seconds data) data))
  
  
  (method protected (release-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (wait retain-ring)))
            (if (not data)
                (continuation-return exit #f)
              (site (udp-release on?: #t)
                ;; nothing to do
                #f)
              (loop))))))))


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot origin             getter generate)
  (slot latest-nacks       accessors generate)
  (slot process-state      getter generate)
  (slot process-last-frame getter generate)
  (slot process-ring       getter generate)
  (slot process-task       getter generate)
  (slot processed          getter generate)
  (slot missing            getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self media-kind)
    (set! self.origin origin)
    (set! self.latest-nacks '())
    (set! self.process-state #f)
    (set! self.process-last-frame #f)
    ;; make it really big until time ring is a real ring
    (set! self.process-ring (new Time-Ring 40096 @w 512 @max-size: +inf.0 now-proc: (~ now-timestamp self)))
    (set! self.process-task (new Task 'udp-process (lambda (task)
                                                     (process-loop self task))
                                 priority: udp-priority))
    (set! self.processed 0)
    (set! self.missing 0)
    (start-task process-task))
  
  
  (method override (destroy self)
    (insert-earliest process-ring #f)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (add-nack self sequence)
    (set! latest-nacks (cons sequence latest-nacks))
    ;; trim when more than udp-latest-nacks
    (when (> (length latest-nacks) udp-latest-nacks)
      (set-cdr! (tail latest-nacks (- udp-latest-nacks 1)) '()))
    latest-nacks)
  
  
  (method protected (remove-nack self sequence)
    (set! latest-nacks (remove! sequence latest-nacks)))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method private (process-state-ok self kind)
    (unless (eq? process-state 'ok)
      (set! process-state 'ok)
      (when udp-show-resets?
        (format :terminal "{s} {s} {s}{%}" remote-name (present-media-kind kind) 'OK))))
  
  
  (method private (process-state-waiting self kind)
    (unless (eq? process-state 'waiting)
      (set! process-state 'waiting)
      (when udp-show-resets?
        (format :terminal "{s} {s} {s}{%}" remote-name (present-media-kind kind) 'WAITING))))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected (insert-nack self data)
    )
  
  
  (method protected (insert-media self data)
    (let ((sequence (read-udp-sequence data)))
      (let ((inserted? (insert process-ring (read-udp-seconds data) data)))
        (when (and udp-show-discard? (not inserted?))
          (let ((kind (read-udp-kind data))
                (sequence (read-udp-sequence data)))
            (record-event udp-id-discard
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          0.
                          0.)
            (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name kind) '***discard*** sequence))))))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((lst (wait-all process-ring)))
            ;; quick solution until we have a clean way to
            ;; unblock a time ring and make it return false
            (if (memq? #f lst)
                (continuation-return exit #f)
              (site (udp-process on?: #t)
                (for-each (lambda (partition)
                            (bind (frame . datas) partition
                              (let ((unique-datas (remove-duplicates datas key: read-udp-sequence)))
                                (when (and udp-show-duplicates? (> (length datas) (length unique-datas)))
                                  (let ((duplicates (difference datas unique-datas)))
                                    (format :terminal "{s} {s} {s} {l}{%}" remote-name (udp-name media-kind) '***duplicates*** (map read-udp-sequence duplicates))))
                                (process-frame self (sort < unique-datas key: read-udp-sequence)))))
                          (sort < (partition lst key: read-udp-frame) key: car))
                (when (eq? process-state 'waiting)
                  (send-ack (get-udp-client (current-client)))))))
          (loop)))))
  
  
  (method (process-frame self datas)
    (let ((member (find-group-member-by-no (current-client) origin)))
      ;; quick solution for when logging in and starting receiving
      ;; someone's media before the client is actually registered
      ;; need to revisit this code for a cleaner solution
      (when member
        (let ((id (second member)))
          (let ((count (length datas))
                (first (car datas)))
            (increase! processed count)
            (let ((kind (read-udp-kind first))
                  (origin (read-udp-origin first))
                  (sequence (read-udp-sequence first))
                  (frame (read-udp-frame first))
                  (part (read-udp-part first))
                  (total (read-udp-total first))
                  (timestamp (read-udp-timestamp first))
                  (duration (read-udp-duration first)))
              (define (process-audio)
                (let ((complete-buffer (assemble-chunks)))
                  ;; audio has no problem with gaps
                  (when complete-buffer
                    (if (equal? complete-buffer udp-media-off)
                        (receive-server-audio (current-audio) id #f #f #f)
                      (receive-server-audio (current-audio) id complete-buffer timestamp duration)))))
              
              (define (process-video)
                (let ((complete-buffer (assemble-chunks)))
                  (if complete-buffer
                      (if (equal? complete-buffer udp-media-off)
                          (receive-server-video (current-video) id #f #f #f)
                        (let ((no-gap? (or (not process-last-frame) (= frame (+ process-last-frame 1)))))
                          (if (or (and no-gap? (eq? process-state 'ok))
                                  (video-buffer-header? complete-buffer))
                              (begin
                                (process-state-ok self kind)
                                (set! process-last-frame frame)
                                (receive-server-video (current-video) id complete-buffer timestamp duration))
                            (process-state-waiting self kind))))
                    (process-state-waiting self kind))))
              
              (define (assemble-chunks)
                (and (= total count)
                     (if (= total 1)
                         (read-udp-payload first)
                       (let ((chunks (map read-udp-payload datas)))
                         (apply u8vector-append chunks)))))
              
              (ecase kind
                ((udp-audio)
                 (process-audio))
                ((udp-video)
                 (process-video)))))))))))
