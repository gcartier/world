;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.presence)
        (jazz.syntax (phase syntax))
        (world)
        (world.configure)
        (world.context)
        (world.player)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.udp))


(definition udp-video-action
  (world-setting 'world.udp-video-action #f))

(definition udp-video-file
  {File Home "video.mpj"})

(definition udp-video-port
  #f)


(class UDP-Client extends Object
  
  
  (slot udp-port         initialize #f getter generate)
  (slot udp-task         initialize #f getter generate)
  (slot udp-stopping?    initialize #f getter generate)
  (slot local-host       initialize #f getter generate)
  (slot local-port       initialize #f getter generate)
  (slot server-host      initialize #f getter generate)
  (slot server-port      initialize #f getter generate)
  (slot write-mutex      initialize #f getter generate)
  (slot send-channels    initialize #f getter generate)
  (slot receive-channels initialize #f getter generate)
  (slot topology         initialize #f getter generate)
  (slot peers            initialize #f getter generate)
  (slot peers-mutex      initialize #f getter generate)
  (slot simulator        initialize #f getter generate)
  
  
  (method (connect self client-no local-host host service)
    ;; quick heuristic
    (define (determine-local-address)
      (if local?
          #u8(127 0 0 1)
        (let ((info (host-info (host-name))))
          (let ((addresses (host-info-addresses info)))
            (if (= 1 (length addresses))
                (car addresses)
              #u8(0 0 0 0))))))
    
    (set! udp-port (open-udp (list
                               local-address: local-host
                               address: host
                               port-number: service)))
    (set! udp-task (new Task 'udp-receive (lambda (task)
                                            (receive-loop self task))
                        priority: udp-priority))
    (set! udp-stopping? #f)
    (let ((local-host (determine-local-address))
          (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (mutex-lock! write-mutex)
        (let ((data (make-u8vector (+ 8 4 4 4 4 4 4 4))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-connect)
          (write-udp-origin data client-no)
          (write-udp-connect-local-host data local-host)
          (write-udp-connect-local-port data local-port)
          (write-udp-connect-latency data (or udp-latency -1.))
          (write-udp-connect-lag data (or udp-lag -1.))
          (write-udp-connect-drop data (or udp-drop -1.))
          (retrying-write data udp-port))
        (mutex-unlock! write-mutex))
      
      (set! self.local-host local-host)
      (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! write-mutex (make-mutex 'write))
      (set! send-channels (make-table))
      (set! receive-channels (make-table))
      (set! topology (world-setting 'world.udp-topology 'server))
      (set! peers (make-table))
      (set! peers-mutex (make-mutex 'peers))
      (set! simulator (if (or udp-latency udp-lag udp-drop)
                          (new UDP-Simulator udp-latency udp-lag udp-drop
                               (lambda (data)
                                 (send-topology self data)))
                        #f))
      (record-event udp-id-connect
                    0.
                    0.
                    0.
                    0.)
      (send-connect)
      ;; togetherimprove
      ;; quick solution to receiving media instead of the expected response
      ;; need to revisit this code for a cleaner solution. this is like doing
      ;; a call using UDP which is really difficult
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (let ((reply (read udp-port)))
            (let ((kind (read-udp-kind reply)))
              (if (not (= kind udp-connected))
                  (if (>= n 100)
                      (begin
                        (terminal 'BAILOUT 'did 'not 'received 'udp-connected)
                        (exit 1))
                    (loop (+ n 1)))
                (let ((source-info (udp-source-socket-info udp-port)))
                  (set! server-host (socket-info-address source-info))
                  (set! server-port (socket-info-port-number source-info)))
                (let ((round-trip (- (current-seconds) (read-udp-sent reply))))
                  (record-event udp-id-connected
                                round-trip
                                0.
                                0.
                                0.)))))))
      (start-task udp-task)))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (thread-join! (get-thread udp-task))
    (set! udp-port #f)
    (set! udp-task #f))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((client-no (get-client-no (current-tier)))
          (p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (or (/= origin client-no)
                                  audio-self?
                                  video-self?)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method (require-send-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref send-channels key #f)
          (let ((channel (new UDP-Send-Channel origin media-kind)))
            (table-set! send-channels key channel)
            channel))))
  
  
  (method (require-receive-channel self origin media-kind)
    (let ((key (cons origin media-kind)))
      (or (table-ref receive-channels key #f)
          (let ((channel (new UDP-Receive-Channel origin media-kind)))
            (table-set! receive-channels key channel)
            channel))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method (send-audio self buffer timestamp duration)
    (send-media self udp-audio buffer timestamp duration))
  
  
  (method (send-video self buffer timestamp duration)
    (send-media self udp-video buffer timestamp duration))
  
  
  (method (send-media self kind buffer timestamp duration)
    (mutex-lock! write-mutex)
    (let ((origin (get-client-no (current-tier))))
      (when udp-video-action
        (let ((key (cons origin kind)))
          (cond ((and buffer (not (table-ref send-channels key #f)))
                 (set! udp-video-port (case udp-video-action
                                        ((record)
                                         (open-output-file (path-settings udp-video-file)))
                                        ((play)
                                         (open-input-file (path-settings udp-video-file))))))
                ((and (not buffer) (table-ref send-channels key #f))
                 (when udp-video-port
                   (close-port udp-video-port)
                   (set! udp-video-port #f))))))
      (let ((channel (require-send-channel self origin kind)))
        ;; quick hack to give media off a timestamp
        (let ((last-timestamp (or (get-last-timestamp channel) 0)))
          (let ((off? (not buffer))
                (frame (next-frame-sequence! channel))
                (timestamp (or timestamp (+ last-timestamp 1)))
                (duration (or duration 1))
                (buffer (or buffer udp-media-off)))
            (set-last-timestamp channel timestamp)
            (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4))
                  (payload-size (u8vector-length buffer)))
              (let ((max-content-size (- udp-datagram-max header-size)))
                (let ((total (fxceiling/ payload-size max-content-size)))
                  (let (loop (part 0) (pos 0))
                    (let ((remain (- payload-size pos)))
                      (when (> remain 0)
                        (let ((sequence (next-data-sequence! channel))
                              (content-size (min remain max-content-size)))
                          (let ((size (+ header-size content-size)))
                            (let ((data (make-u8vector size)))
                              (write-udp-sent data (current-seconds))
                              (write-udp-kind data kind)
                              (write-udp-origin data origin)
                              (write-udp-sequence data sequence)
                              (write-udp-frame data frame)
                              (write-udp-part data part)
                              (write-udp-total data total)
                              (write-udp-timestamp data timestamp)
                              (write-udp-duration data duration)
                              (write-udp-subpayload data buffer pos content-size)
                              (when udp-video-port
                                (case udp-video-action
                                  ((record)
                                   (write data udp-video-port)
                                   (newline udp-video-port)
                                   (force-output udp-video-port))
                                  ((play)
                                   (let ((obj (read udp-video-port)))
                                     (unless (eof-object? obj)
                                       (set! data obj))))))
                              (send-data self data)
                              (retain channel data)
                              (record-event udp-id-send-media
                                            (fixnum->flonum kind)
                                            (fixnum->flonum sequence)
                                            (if off? 0. 1.)
                                            0.)
                              (loop (+ part 1) (+ pos content-size)))))))))))))))
    (mutex-unlock! write-mutex))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       (udp-destination-set! server-host server-port udp-port)
       (retrying-write data udp-port))
      ((peer)
       (iterate-table peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (retrying-write data udp-port)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (with-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read udp-port)))))
            (when data
              (site (udp-receive on?: #t)
                (receive-data self data))
              (loop)))))))
  
  
  (method (receive-data self data)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-ack)
         (receive-ack self data))
        ((udp-nack)
         (receive-nack self data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-ack self data)
    (let ((sent (read-udp-sent data))
          (origin (read-udp-origin data))
          (sequence (read-udp-sequence data))
          (media-kind (read-udp-ack-media-kind data))
          (missing (u8vector->object (read-udp-ack-latest-missing data))))
      (let ((round-trip (- (current-seconds) sent)))
        (record-event udp-id-receive-ack
                      (fixnum->flonum media-kind)
                      (fixnum->flonum sequence)
                      round-trip
                      0.))
      (send-missing self origin media-kind missing)))
  
  
  (method (receive-nack self data)
    (let ((origin (read-udp-origin data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-latest-missing data))))
      (send-missing self origin media-kind missing)))
  
  
  (method (receive-media self kind data)
    (let ((origin (read-udp-origin data))
          (sequence (read-udp-sequence data)))
      (let ((channel (require-receive-channel self origin kind)))
        ;; send ack
        (let ((next-ack (get-next-ack channel))
              (now (current-seconds)))
          (when (or (not next-ack)
                    (>= now next-ack))
            (send-ack self (read-udp-sent data) origin sequence kind (get-latest-nacks channel))
            (set-next-ack channel (+ now udp-ack-period))))
        (let ((last-sequence (get-last-sequence channel)))
          (let ((in-order? (or (not last-sequence)
                               (> sequence last-sequence))))
            (if (not in-order?)
                (remove-nack channel sequence)
              ;; send nacks to server
              (when last-sequence
                (let ((expected (+ last-sequence 1)))
                  (when (> sequence expected)
                    (loop (for seq from expected below sequence)
                          (send-nack self origin kind (add-nack channel seq))))))
              ;; remember last sequence
              (set-last-sequence channel sequence))
            (insert-media channel data in-order?))))))
  
  
  (method (send-missing self origin media-kind missing)
    (let ((channel (require-send-channel self origin media-kind)))
      (let ((ring (get-retain-ring channel)))
        (for-each (lambda (sequence)
                    (let ((found (locate ring (lambda (data)
                                                (= (read-udp-sequence data) sequence)))))
                      (record-event udp-id-receive-nack
                                    (fixnum->flonum media-kind)
                                    (fixnum->flonum sequence)
                                    (if found 1. 0.)
                                    0.)
                      (if found
                          (send-data self found)
                        (when udp-debug-nack?
                          (terminal remote-name (udp-name media-kind) '***nack-missing*** sequence)))))
                  missing))))
  
  
  (method (send-ack self sent origin sequence media-kind latest-missing)
    (mutex-lock! write-mutex)
    (let ((missing (object->u8vector latest-missing)))
      (let ((size (+ 8 4 4 4 4 4 (u8vector-length missing))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data sent)
          (write-udp-kind data udp-ack)
          (write-udp-origin data origin)
          (write-udp-sequence data sequence)
          (write-udp-ack-media-kind data media-kind)
          (write-udp-ack-latest-missing data missing)
          (send-data self data))))
    (mutex-unlock! write-mutex))
  
  
  (method (send-nack self origin media-kind latest-missing)
    (when udp-debug-nack?
      (terminal remote-name (udp-name media-kind) 'send-nack latest-missing))
    (mutex-lock! write-mutex)
    (let ((missing (object->u8vector latest-missing)))
      (let ((size (+ 8 4 4 4 4 (u8vector-length missing))))
        (let ((data (make-u8vector size)))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-origin data origin)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-latest-missing data missing)
          (send-data self data))))
    (mutex-unlock! write-mutex)))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Send Channel
;;;


(class UDP-Send-Channel extends UDP-Channel
  
  
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-timestamp accessors generate)
  (slot retain-ring    getter generate)
  (slot release-task   getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self origin media-kind)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f)
    ;; make it really big until time ring is a real ring
    (set! self.retain-ring (new Time-Ring 400096 @w 512 @max-size: +inf.0 now-proc: (~ now-timestamp self)))
    ;; development
    (set-$s retain-ring)
    (set! self.release-task (new Task 'udp-release (lambda (task)
                                                     (release-loop self task))
                                 priority: udp-priority))
    (start-task release-task))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence)))
  
  
  (method protected (retain self data)
    (update-time self data)
    (insert retain-ring (read-udp-seconds data) data))
  
  
  (method protected (release-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (wait retain-ring)
          (site (udp-release on?: #f)
            ;; nothing to do
            #f)
          (loop))))))


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot last-sequence         accessors generate)
  (slot latest-nacks          accessors generate)
  (slot next-ack              accessors generate)
  (slot process-last-sequence getter generate)
  (slot process-ring          getter generate)
  (slot process-task          getter generate)
  (slot processed             getter generate)
  (slot missing               getter generate)
  
  
  (method override (initialize self origin media-kind)
    (nextmethod self origin media-kind)
    (set! self.last-sequence #f)
    (set! self.latest-nacks '())
    (set! self.next-ack #f)
    (set! self.process-last-sequence #f)
    ;; make it really big until time ring is a real ring
    (set! self.process-ring (new Time-Ring 40096 @w 512 @max-size: +inf.0 now-proc: (~ now-timestamp self)))
    ;; development
    (set-$c self)
    (set-$r process-ring)
    (set! self.process-task (new Task 'udp-process (lambda (task)
                                                     (process-loop self task))
                                 priority: udp-priority))
    (set! self.processed 0)
    (set! self.missing 0)
    (start-task process-task))
  
  
  (method protected (add-nack self sequence)
    (set! latest-nacks (cons sequence latest-nacks))
    ;; trim when more than udp-latest-nacks
    (when (> (length latest-nacks) udp-latest-nacks)
      (set-cdr! (tail latest-nacks (- udp-latest-nacks 1)) '()))
    latest-nacks)
  
  
  (method protected (remove-nack self sequence)
    (set! latest-nacks (remove! sequence latest-nacks)))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected (insert-nack self data)
    )
  
  
  (method protected (insert-media self data in-order?)
    (let ((sequence (read-udp-sequence data)))
      (when in-order?
        (update-time self data))
      (let ((inserted? (insert process-ring (read-udp-seconds data) data)))
        (when (and udp-show-discard? (not inserted?))
          (let ((kind (read-udp-kind data))
                (sequence (read-udp-sequence data)))
            (record-event udp-id-discard
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          0.
                          0.)
            (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name kind) '***discard*** sequence))))))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((lst (wait-all process-ring)))
            (site (udp-process on?: #t)
              (process-missing self lst)
              (for-each (lambda (partition)
                          (bind (frame . datas) partition
                            (let ((unique-datas (remove-duplicates datas key: read-udp-sequence)))
                              (when (and udp-show-duplicates? (> (length datas) (length unique-datas)))
                                (let ((duplicates (difference datas unique-datas)))
                                  (format :terminal "{s} {s} {s} {l}{%}" remote-name (udp-name media-kind) '***duplicates*** (map read-udp-sequence duplicates))))
                              (process-frame self (sort < unique-datas key: read-udp-sequence)))))
                        (sort < (partition lst key: read-udp-frame) key: car))))
          (loop)))))
  
  
  (method (process-missing self lst)
    (let ((sorted (sort < lst key: read-udp-sequence)))
      (for-each (lambda (data)
                  (let ((sequence (read-udp-sequence data)))
                    (when (and udp-show-missing? process-last-sequence)
                      (let ((expected (+ process-last-sequence 1)))
                        (when (/= sequence expected)
                          (loop (for seq from expected below sequence)
                                (increase! missing)
                                (record-event udp-id-missing
                                              (fixnum->flonum media-kind)
                                              (fixnum->flonum seq)
                                              (fixnum->flonum missing)
                                              (fixnum->flonum processed))
                                (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name media-kind) '***missing*** seq)))))
                    (set! process-last-sequence sequence)))
                sorted)))
  
  
  (method (process-frame self datas)
    (let ((count (length datas))
          (first (car datas)))
      (increase! processed count)
      (let ((kind (read-udp-kind first))
            (origin (read-udp-origin first))
            (sequence (read-udp-sequence first))
            (frame (read-udp-frame first))
            (part (read-udp-part first))
            (total (read-udp-total first))
            (timestamp (read-udp-timestamp first))
            (duration (read-udp-duration first)))
        (if (= total count)
            (if (= total 1)
                (process-data self kind origin sequence frame timestamp duration (read-udp-payload first))
              (let ((chunks (map read-udp-payload datas)))
                (let ((data (apply u8vector-append chunks)))
                  (process-data self kind origin sequence frame timestamp duration data))))
          @reported-by-process-missing
          (let ((missing (difference (naturals sequence (+ sequence total)) (map read-udp-sequence datas))))
            (format :terminal "{s} {s} {s} {s} {l}{%}" remote-name (udp-name kind) '***partial-frame*** 'missing missing))))))
  
  
  (method (process-data self kind origin sequence frame timestamp duration buffer)
    (define (player-no->id no)
      (get-id (find-player-by-no no)))
    
    (define (process-audio)
      (if (equal? buffer udp-media-off)
          (receive-server-audio (current-audio) (player-no->id origin) #f #f #f)
        (receive-server-audio (current-audio) (player-no->id origin) buffer timestamp duration)))
    
    (define (process-video)
      (if (equal? buffer udp-media-off)
          (receive-server-video (current-video) (player-no->id origin) #f #f #f)
        (receive-server-video (current-video) (player-no->id origin) buffer timestamp duration)))
    
    (ecase kind
      ((udp-audio)
       (process-audio))
      ((udp-video)
       (process-video))))))
