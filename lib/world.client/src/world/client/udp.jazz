;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.math)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.audio)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.player)
        (world.profiling)
        (world.ring)
        (world.settings)
        (world.support)
        (world.task)
        (world.time)
        (world.udp)
        (world.video))


(class UDP-Client extends UDP-Tier
  
  
  (slot client-no              initialize #f getter generate)
  (slot character-name         initialize #f getter generate)
  (slot udp-port               initialize #f getter generate)
  (slot udp-stopping?          initialize #f getter generate)
  @peer2peer
  (slot local-host             initialize #f getter generate)
  @peer2peer
  (slot local-port             initialize #f getter generate)
  (slot server-host            initialize #f getter generate)
  (slot server-port            initialize #f getter generate)
  (slot write-mutex            initialize #f getter generate)
  (slot receive-streams        initialize #f getter generate)
  (slot receive-channels       initialize #f getter generate)
  (slot receive-task           initialize #f getter generate)
  (slot state-task             initialize #f getter generate)
  (slot state-sequence         initialize 0  getter generate)
  (slot started?               initialize #f getter generate)
  (slot monitor                initialize #f getter generate)
  (slot statistics             initialize #f getter generate)
  (slot invalid-packets        initialize 0  getter generate)
  (slot last-received-ack      initialize #f getter generate)
  (slot throttle-media?        initialize #f getter generate)
  (slot topology               initialize #f getter generate)
  @peer2peer
  (slot peers                  initialize #f getter generate)
  @peer2peer
  (slot peers-mutex            initialize #f getter generate)
  (slot profile-pulse-sequence initialize #f getter generate)
  (slot profile-media-sequence initialize #f getter generate)
  (slot profile-last-sequence  initialize #f getter generate)
  (slot profile-monitor        initialize #f getter generate)
  (slot profile-statistics     initialize #f getter generate)
  (slot profile-chronology     initialize #f getter generate)
  (slot profile-evolution      initialize #f getter generate)
  (slot simulator              initialize #f accessors generate)
  
  
  (method override (initialize self client-no character-name)
    (nextmethod self)
    (set! self.client-no client-no)
    (set! self.character-name character-name)
    (set! write-mutex (make-mutex 'write))
    (set! receive-streams (make-table))
    (set! receive-channels (make-table)))
  
  
  (method package (connect self local-address host service)
    ;; quick heuristic
    @peer2peer
    (define (determine-local-host)
      (if local?
          #u8(127 0 0 1)
        (let ((info (host-info (host-name))))
          (let ((addresses (host-info-addresses info)))
            (if (= 1 (length addresses))
                (car addresses)
              #u8(0 0 0 0))))))
    
    (unless (simulation?)
    (set! udp-port (open-udp (list
                               local-address: local-address
                               address: host
                               port-number: service)))
    (setup-udp-port-buffers udp-port)
    (set! udp-stopping? #f)
    (let (@peer2peer (local-host (determine-local-host))
          @peer2peer (local-port (socket-info-port-number (udp-local-socket-info udp-port))))
      (define (send-connect)
        (mutex-lock! write-mutex)
        (let ((data (make-u8vector (+ (udp-connect-size) udp-code-size))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-connect)
          (write-udp-sender data client-no)
          @peer2peer
          (write-udp-connect-local-host data local-host)
          @peer2peer
          (write-udp-connect-local-port data local-port)
          (write-udp-connect-video-level data (or (video-profile-level) -1))
          (write-udp-code data)
          (write-data data udp-port))
        (mutex-unlock! write-mutex))
      
      @peer2peer (set! self.local-host local-host)
      @peer2peer (set! self.local-port local-port)
      (set! server-host #f)
      (set! server-port #f)
      (set! monitor (new UDP-Monitor))
      (set! statistics (new UDP-Statistics))
      (set! topology (world-setting 'world.udp-topology 'server))
      @peer2peer (set! peers (make-table))
      @peer2peer (set! peers-mutex (make-mutex 'peers))
      (set! simulator (cond-expand
                        (devel (if (or udp-latency udp-drop udp-congestion)
                                   (new-simulator self udp-latency udp-drop)
                                 #f))
                        (else #f)))
      (record-event udp-id-connecting
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.
                    -1.)
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (if (or (eof-object? reply) (not (= (read-udp-kind reply) udp-connected)))
                (if (>= n 100)
                    (begin
                      (terminal 'BAILOUT 'did 'not 'receive 'udp-connected)
                      (exit 1))
                  (loop (+ n 1)))
              (let ((source-info (udp-source-socket-info udp-port)))
                (set! server-host (socket-info-address source-info))
                (set! server-port (socket-info-port-number source-info)))
              (let ((round-trip (- (current-seconds) (read-udp-sent reply))))
                (record-event udp-id-connected
                              -1.
                              -1.
                              -1.
                              -1.
                              -1.
                              round-trip
                              -1.)
                (when udp-show-roundtrip?
                  (format :terminal "{s} {s} {s}{%}" presence-name '***roundtrip*** round-trip)))
              (set! receive-task (new Task 'udp-receive (lambda (task)
                                                          (receive-loop self task))
                                      priority: udp-priority))
              (start-task receive-task))))))))

  
  (method (disconnect self)
    (exit-thread (get-thread receive-task))
    (thread-join! (get-thread receive-task))
    (set! receive-task #f)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (unless (simulation?)
        (set! state-task (new Task 'udp-state (lambda (task)
                                                (state-loop self task))
                              priority: udp-priority))
        (start-task state-task))
      (set! last-received-ack (current-seconds))
      (set! throttle-media? #f)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (thread-send (get-thread state-task) #t)
      (thread-join! (get-thread state-task))
      (set! state-task #f)
      (set! started? #f)))
  
  
  (method protected (new-simulator self latency drop)
    (new UDP-Simulator latency drop
         (lambda (data info drop?)
           (if drop?
               (increase-sent self data)
             @fix-me-can-deadlock-the-threads
             (mutex-lock! write-mutex)
             (send-topology self data)
             @fix-me-can-deadlock-the-threads
             (mutex-unlock! write-mutex)))))
  
  
  (method package (require-simulator self)
    (or simulator
        (let ((sim (new-simulator self #f #f)))
          (set! simulator sim)
          sim)))
  
  
  (method protected (increase-sent self data)
    (increase-sent monitor data))
  
  
  (method protected (increase-received self data)
    (increase-received monitor data))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (set! profile-pulse-sequence 0)
    (set! profile-media-sequence 0)
    (set! profile-last-sequence 0)
    (set! profile-monitor (new UDP-Monitor))
    (set! profile-statistics (new UDP-Statistics))
    (set! profile-chronology (new Chronology 0))
    (set! profile-evolution (new Evolution 5000)))
  
  
  (method package (retrieve-profile self)
    (let ((metadata (list client-no character-name '() '() (sites-metadata)))
          (chronology (copy-chronology profile-chronology))
          (evolution (copy-evolution profile-evolution)))
      (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
  
  
  (method package (stop-profile self)
    (set! profile-chronology #f)
    (set! profile-evolution #f))
  
  
  ;;;
  ;;;; Topology
  ;;;
  
  
  @peer2peer
  (method protected (peers-update self peers-info)
    (mutex-lock! peers-mutex)
    (let ((p (make-table)))
      (let ((my-info (cdr (assv client-no peers-info))))
        (bind (my-host my-port my-local) my-info
          (for-each (lambda (info)
                      (bind (origin host port local-host local-port) info
                        (when (/= origin client-no)
                          ;; same intranet heuristic
                          (if (equal? host my-host)
                              (table-set! p origin (new UDP-Peer local-host local-port))
                            (table-set! p origin (new UDP-Peer host port))))))
                    peers-info)
          (set! peers p))))
    (mutex-unlock! peers-mutex))
  
  
  @peer2peer
  (method protected (cycle-topologies self)
    (let ((world (current-world)))
      (case topology
        ((server)
         (set! topology 'peer)
         (display-message world "Peer to peer"))
        ((peer)
         (set! topology 'server)
         (display-message world "Server based")))))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (close-send-stream self stream)
    (table-iterate (get-channels stream)
      (lambda (no channel)
        (close-send-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (unregister-stream (current-client) stream-no)
      (table-clear send-streams stream-no)))
  
  
  (method package (close-send-streams self)
    (iterate-table send-streams
      (lambda (no stream)
        (close-send-stream self stream))))
  
  
  (method package (register-receive-stream self sender name stream-no origin source-kind video-level channels)
    (let ((stream (new UDP-Receive-Stream sender name stream-no origin source-kind video-level)))
      (for-each (lambda (info)
                  (bind (channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata) info
                    (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
                channels)
      (table-set! receive-streams stream-no stream)
      stream))
  
  
  (method public (find-receive-stream self stream-no)
    (table-ref receive-streams stream-no #f))
  
  
  (method package (close-receive-stream self stream)
    (table-iterate (get-channels stream)
      (lambda (no channel)
        (close-receive-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (table-clear receive-streams stream-no)))
  
  
  (method package (close-receive-streams self)
    (iterate-table receive-streams
      (lambda (no stream)
        (close-receive-stream self stream))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (register-send-channel self stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (let ((stream (find-send-stream self stream-no)))
      (let ((channel (new UDP-Send-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
        (table-set! send-channels channel-no channel)
        channel)))
  
  
  (method package (close-send-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear send-channels channel-no)))
  
  
  (method public (find-receive-channel self channel-no)
    (table-ref receive-channels channel-no #f))
  
  
  (method package (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (let ((channel (new UDP-Receive-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata)))
      (table-set! receive-channels channel-no channel)
      channel))
  
  
  (method package (close-receive-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear receive-channels channel-no)))
  
  
  (method package (close-channel-output self channel)
    (let ((id (get-no channel))
          (kind (get-media-kind channel)))
      (ecase kind
        ((udp-audio)
         (let ((audio (current-audio)))
           (let ((output (find-output audio id)))
             (when output
               (close-output audio id output)))))
        ((udp-video)
         (let ((video (current-video)))
           (let ((output (find-output video id)))
             (when output
               (close-output video id output))))))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method package (send-media self channel-no buffer dts pts duration keyframe?)
    (mutex-lock! write-mutex)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((kind (get-media-kind channel)))
          (define (send)
            (send-media channel buffer dts pts duration keyframe?
              (lambda (data)
                (send-data self data))))
          
          (define (advance-frame!)
            (let ((frame (next-frame-sequence! channel)))
              (record-event udp-id-throttle-frame
                            (fixnum->flonum channel-no)
                            (fixnum->flonum client-no)
                            (fixnum->flonum kind)
                            -1.
                            (fixnum->flonum frame)
                            -1.
                            -1.)))
          
          (if (simulation?)
              (send)
            (if throttle-media?
                (advance-frame!)
              (if (waiting-keyframe? channel)
                  (if (not keyframe?)
                      (begin
                        (advance-frame!)
                        (when udp-show-skipping?
                          (format :terminal "{s} {s} {s}{%}" presence-name 'SKIPPING (get-frame-sequence channel))))
                    (got-keyframe channel)
                    (send))
                (let ((now (current-seconds)))
                  (if (and udp-throttle (> (- now last-received-ack) udp-throttle))
                      (begin
                        (set! throttle-media? #t)
                        (table-iterate send-channels
                          (lambda (no channel)
                            (wait-keyframe channel)))
                        (record-event udp-id-throttle-on
                                      -1.
                                      (fixnum->flonum server-no)
                                      -1.
                                      -1.
                                      -1.
                                      -1.
                                      -1.)
                        (when udp-show-throttle?
                          (format :terminal "{s} {s} {s}{%}" presence-name 'THROTTLE 'ON)))
                    (send)))))))))
    (mutex-unlock! write-mutex))
  
  
  (method protected (next-profile-pulse-sequence! self)
    (prog1 profile-pulse-sequence
      (increase! profile-pulse-sequence)))
  
  
  (method protected (next-profile-media-sequence! self)
    (prog1 profile-media-sequence
      (increase! profile-media-sequence)))
  
  
  (method package (send-profile-pulse self)
    (mutex-lock! write-mutex)
    (let ((size (udp-profile-pulse-size)))
      (let ((data (make-u8vector (+ size udp-code-size))))
        (write-udp-sent data (current-seconds))
        (write-udp-kind data udp-profile-pulse)
        (write-udp-sender data client-no)
        (write-udp-sequence data (next-profile-pulse-sequence! self))
        (write-udp-profile-pulse-packets-sent data 0)
        (write-udp-profile-pulse-bytes-sent data 0)
        (write-udp-profile-pulse-packets-received data 0)
        (write-udp-profile-pulse-bytes-received data 0)
        (write-udp-code data)
        (send-data self data)))
    (mutex-unlock! write-mutex))
  
  
  (method package (send-profile-media self payload)
    (mutex-lock! write-mutex)
    (let ((size (udp-profile-media-size payload)))
      (let ((data (make-u8vector (+ size udp-code-size))))
        (write-udp-sent data (current-seconds))
        (write-udp-kind data udp-profile-media)
        (write-udp-sender data client-no)
        (write-udp-sequence data (next-profile-media-sequence! self))
        (write-udp-profile-media-payload data payload)
        (write-udp-code data)
        (send-data self data)
        (increase-sent profile-monitor data)))
    (mutex-unlock! write-mutex))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data #f)
      (send-topology self data)))
  
  
  (method (send-topology self data)
    (case topology
      ((server)
       (udp-destination-set! server-host server-port udp-port)
       (safe-write data udp-port)
       (increase-sent self data))
      @peer2peer
      ((peer)
       (table-iterate peers
         (lambda (origin peer)
           (let ((host (get-host peer))
                 (port (get-port peer)))
             (udp-destination-set! host port udp-port)
             (safe-write data udp-port)))))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (state-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((end? (thread-receive udp-state-period #f)))
            (if end?
                (continuation-return exit #f)
              (site (udp-state)
                (send-state self))
              (loop)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (receive-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (catch-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read-data udp-port)))))
            (when data
              (site (udp-receive)
                (receive-data self data))
              (loop)))))))
  
  
  (method protected (receive-data self data)
    (if (or (< (u8vector-length data) 4)
            (/= (read-udp-code data) udp-code))
        (increase! invalid-packets)
      (increase-received self data)
      (let ((kind (read-udp-kind data)))
        (if (not started?)
            (ecase kind
              ((udp-connected))
              ((udp-state))
              ((udp-ack))
              ((udp-nack))
              ((udp-audio udp-video))
              ((udp-alive-ack)
               (receive-alive-ack self data))
              ((udp-profile-pulse)
               (receive-profile-pulse self data))
              ((udp-profile-media)
               (receive-profile-media self data))
              (else
               (error "Unknown UDP kind: {s}" kind)))
          (ecase kind
            ((udp-connected))
            ((udp-state)
             (receive-state self data))
            ((udp-ack)
             (receive-ack self data))
            ((udp-nack)
             (receive-nack self data))
            ((udp-audio udp-video)
             (receive-media self kind data))
            ((udp-alive-ack)
             (receive-alive-ack self data))
            ((udp-profile-pulse))
            ((udp-profile-media))
            (else
             (error "Unknown UDP kind: {s}" kind)))))))
  
  
  (method (receive-state self data)
    (let ((states (u8vector->object (read-udp-state-channels data))))
      (for-each (lambda (info)
                  (bind (channel-no client-state) info
                    (let ((channel (find-send-channel self channel-no)))
                      (when (and channel (eq? client-state 'waiting))
                        (reset-media channel)))))
                states)))
  
  
  (method (receive-ack self data)
    (let ((now (current-seconds))
          (sender (read-udp-sender data))
          (state-sequence (read-udp-ack-state-sequence data)))
      ;; throttling
      (set! last-received-ack now)
      (when throttle-media?
        (set! throttle-media? #f)
        ;; force camera reset
        ;; (maybe-reset-media self server-no udp-video #f)
        (record-event udp-id-throttle-off
                      -1.
                      (fixnum->flonum server-no)
                      -1.
                      (fixnum->flonum state-sequence)
                      -1.
                      -1.
                      -1.)
        (when udp-show-throttle?
          (format :terminal "{s} {s} {s}{%}" presence-name 'THROTTLE 'OFF)))
      ;; statistics
      (let ((state-sent (read-udp-ack-state-sent data))
            (ack-sent (read-udp-sent data))
            (server-packets-sent (read-udp-ack-packets-sent data))
            (server-bytes-sent (read-udp-ack-bytes-sent data))
            (server-packets-received (read-udp-ack-packets-received data))
            (server-bytes-received (read-udp-ack-bytes-received data)))
        (let ((round-trip (- now state-sent)))
          (update statistics now monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received)
          (record-event udp-id-receive-ack
                        -1.
                        (fixnum->flonum sender)
                        -1.
                        (fixnum->flonum state-sequence)
                        round-trip
                        state-sent
                        ack-sent
                        -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                        -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received))))
        (let ((last-send-rate (get-last-send-rate statistics))
              (last-receive-rate (get-last-receive-rate statistics)))
          (unless (= last-send-rate -1.)
            (record-event udp-id-traffic-rate
                          -1.
                          (fixnum->flonum sender)
                          -1.
                          (fixnum->flonum state-sequence)
                          -1.
                          last-send-rate
                          last-receive-rate))))))
  
  
  (method (receive-nack self data)
    (let ((channel-no (read-udp-channel data))
          (sender (read-udp-sender data))
          (media-kind (read-udp-nack-media-kind data))
          (missing (u8vector->object (read-udp-nack-missing data))))
      (send-missing self sender channel-no media-kind missing)))
  
  
  (method protected (receive-media self kind data)
    (let ((channel-no (read-udp-channel data)))
      (let ((channel (find-receive-channel self channel-no)))
        (when channel
          (remember-media channel data)
          (insert-media channel data)
          (let ((frame (read-udp-frame data))
                (last-nacked-frame (get-last-nacked-frame channel)))
            (when (or (not last-nacked-frame)
                      (> frame last-nacked-frame))
              (send-nacks self channel-no kind channel)
              (set-last-nacked-frame channel frame)))))))
  
  
  (method protected (send-nacks self channel-no kind channel)
    (unless (simulation?)
      (let ((missing (collect-missing channel)))
        (unless (null? missing)
          (send-nack self channel-no kind missing)))))
  
  
  (method (send-missing self sender channel-no media-kind missing)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((ring (get-retain-ring channel)))
          (for-each (lambda (sequence)
                      (let ((data (locate-data ring sequence)))
                        (if data
                            (begin
                              (when udp-show-resend?
                                (let ((packet (locate-packet ring sequence)))
                                  (when packet
                                    (let ((dts (get-dts packet)))
                                      (let ((time (remote->local (get-time-base ring) dts)))
                                        (terminal (- (current-seconds) time)))))))
                              (increase-udp-resent data)
                              (send-data self data)
                              (let ((frame (read-udp-frame data)))
                                (record-event udp-id-resend-packet
                                              (fixnum->flonum channel-no)
                                              (fixnum->flonum sender)
                                              (fixnum->flonum media-kind)
                                              (fixnum->flonum sequence)
                                              (fixnum->flonum frame)
                                              -1.
                                              -1.)))
                          (record-event udp-id-absent-packet
                                        (fixnum->flonum channel-no)
                                        (fixnum->flonum sender)
                                        (fixnum->flonum media-kind)
                                        (fixnum->flonum sequence)
                                        -1.
                                        -1.
                                        -1.)
                          (when udp-show-nacks?
                            (terminal presence-name (present-media-kind media-kind) '***nack-missing*** sequence)))))
                    missing)))))
  
  
  (method (receive-alive-ack self data)
    )
  
  
  (method (receive-profile-pulse self data)
    (let ((now (current-seconds)))
      (let ((sequence (read-udp-sequence data))
            (state-sent (read-udp-ack-state-sent data))
            (ack-sent (read-udp-sent data))
            (server-packets-sent (read-udp-profile-pulse-packets-sent data))
            (server-bytes-sent (read-udp-profile-pulse-bytes-sent data))
            (server-packets-received (read-udp-profile-pulse-packets-received data))
            (server-bytes-received (read-udp-profile-pulse-bytes-received data)))
        (let ((round-trip (- now state-sent)))
          (update profile-statistics now profile-monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received)
          (parameterize ((simulation-evolution profile-evolution))
            (record-event udp-id-receive-ack
                          -1.
                          (fixnum->flonum client-no)
                          -1.
                          (fixnum->flonum sequence)
                          round-trip
                          state-sent
                          ack-sent
                          -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                          -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received)))
            (let ((last-send-rate (get-last-send-rate profile-statistics))
                  (last-receive-rate (get-last-receive-rate profile-statistics)))
              (unless (= last-send-rate -1.)
                (record-event udp-id-traffic-rate
                              -1.
                              (fixnum->flonum client-no)
                              -1.
                              (fixnum->flonum sequence)
                              -1.
                              last-send-rate
                              last-receive-rate)))))))
    (when udp-show-profile?
      (format :terminal "{s} {s} {s}{%}" presence-name 'PROFILE 'PULSE)))
  
  
  (method (receive-profile-media self data)
    (let ((sender (read-udp-sender data))
          (sequence (read-udp-sequence data)))
      (when profile-last-sequence
        (let ((expected-sequence (+ profile-last-sequence 1)))
          (when (/= sequence expected-sequence)
            (parameterize ((simulation-evolution profile-evolution))
              (loop (for seq from expected-sequence below sequence)
                    (record-event udp-id-lost-packet
                                  -1.
                                  (fixnum->flonum sender)
                                  (fixnum->flonum udp-audio)
                                  (fixnum->flonum seq)
                                  -1.
                                  -1.
                                  -1.))))))
      (set! profile-last-sequence sequence)
      (increase-received profile-monitor data))
    (when udp-show-profile?
      (format :terminal "{s} {s} {s}{%}" presence-name 'PROFILE 'MEDIA)))
  
  
  (method protected (next-state-sequence! self)
    (prog1 state-sequence
      (increase! state-sequence)))
  
  
  (method (send-state self)
    (define (collect-states)
      (let ((queue (new-queue)))
        (table-iterate receive-channels
          (lambda (key channel)
            (let ((state (get-state (get-process-ring channel))))
              (enqueue queue
                       (list (get-no channel)
                             state)))))
        (queue-list queue)))
    
    (let ((state-sequence (next-state-sequence! self))
          (states (collect-states)))
      (mutex-lock! write-mutex)
      (let ((states (object->u8vector states)))
        (let ((size (udp-state-size states)))
          (let ((data (make-u8vector (+ size udp-code-size))))
            (write-udp-sent data (current-seconds))
            (write-udp-kind data udp-state)
            (write-udp-sender data client-no)
            (write-udp-state-sequence data state-sequence)
            (write-udp-state-channels data states)
            (write-udp-code data)
            (send-data self data))))
      (record-event udp-id-send-state
                    -1.
                    (fixnum->flonum client-no)
                    -1.
                    (fixnum->flonum state-sequence)
                    -1.
                    -1.
                    -1.)
      (mutex-unlock! write-mutex)))
  
  
  (method (send-nack self channel-no media-kind missing)
    (when udp-show-nacks?
      (terminal presence-name (present-media-kind media-kind) '***send-nack*** missing))
    (mutex-lock! write-mutex)
    (let ((missing-vector (object->u8vector missing)))
      (let ((size (udp-nack-size missing-vector)))
        (let ((data (make-u8vector (+ size udp-code-size))))
          (write-udp-sent data (current-seconds))
          (write-udp-kind data udp-nack)
          (write-udp-sender data client-no)
          (write-udp-channel data channel-no)
          (write-udp-nack-media-kind data media-kind)
          (write-udp-nack-missing data missing-vector)
          (write-udp-code data)
          (send-data self data))))
    (mutex-unlock! write-mutex))
  
  
  (method (send-alive self)
    (mutex-lock! write-mutex)
    (let ((size (udp-sender-header-size)))
      (let ((data (make-u8vector (+ size udp-code-size))))
        (write-udp-sent data (current-seconds))
        (write-udp-kind data udp-alive)
        (write-udp-sender data client-no)
        (write-udp-code data)
        (send-data self data)))
    (mutex-unlock! write-mutex)))


;;;
;;;; UDP Peer
;;;


(class UDP-Peer extends Object
  
  
  (slot host getter generate)
  (slot port getter generate)
  
  
  (method override (initialize self host port)
    (nextmethod self)
    (set! self.host host)
    (set! self.port port))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" host port)))))


;;;
;;;; Receive Stream
;;;


(class UDP-Receive-Stream extends UDP-Stream)


;;;
;;;; Receive Channel
;;;


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot process-ring      getter generate)
  (slot process-task      getter generate)
  (slot process-average   getter generate)
  (slot last-nacked-frame accessors generate)
  (slot replay-ring       getter generate)
  (slot processed         getter generate)
  (slot missing           getter generate)
  (slot insert-rate-frame getter generate)
  (slot insert-rate       getter generate)
  (slot process-rate      getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (nextmethod self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata)
    (set! self.last-nacked-frame #f)
    (set! self.replay-ring (and (developer?) (remember-ring media-kind source-kind level framerate)))
    (set! self.process-ring (new UDP-Ring self no (get-origin stream) media-kind udp-process-size max-size: udp-process-max-size overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
    (unless (simulation?)
      (set! self.process-task (new Task 'udp-process (lambda (task)
                                                       (process-loop self task))
                                   priority: udp-process-priority)))
    (set! self.process-average (new Average .05 1.))
    (set! self.processed 0)
    (set! self.missing 0)
    (set! self.insert-rate-frame 0)
    (set! self.insert-rate (new Rate))
    (set! self.process-rate (new Rate))
    (unless (simulation?)
      (start-task process-task)))
  
  
  (method override (destroy self)
    (terminate process-ring)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (collect-missing self)
    (let ((missing (new-queue)))
      (iterate-earliest process-ring
        (lambda (packet)
          (when (not (get-data packet))
            (enqueue missing (get-sequence packet)))))
      (queue-list missing)))
  
  
  (method protected (count-missing self)
    (let ((count 0))
      (iterate-earliest process-ring
        (lambda (packet)
          (when (not (get-data packet))
            (increase! count))))
      count))
  
  
  (method protected (remember-media self data)
    (when replay-ring
      (remember replay-ring data)))
  
  
  (method protected (insert-media self data)
    (when framerate
      (let ((frame (read-udp-frame data)))
        (when (or (not insert-rate-frame)
                  (> frame insert-rate-frame))
          (update insert-rate framerate)
          (set! insert-rate-frame frame))))
    (insert process-ring data))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process-loop self task)
    (ecase media-kind
      ((udp-audio) (process-audio-loop self task))
      ((udp-video) (process-video-loop self task))))
  
  
  (method (process-audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-audio process-ring process-average #f)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site (udp-process)
                (bind (presentation-time . datas) info
                  (present-audio self presentation-time datas)))
              (looping)))))))
  
  
  (method (process-video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (looping)
          (let ((info (process-video process-ring process-average #f)))
            (if (eq? info 'terminate)
                (continuation-return exit #f)
              (site (udp-process)
                (present-video self info))
              (looping)))))))
  
  
  (method (record-play-frame self sender frame keyframe? dts pts)
    (record-event udp-id-play-frame
                  (fixnum->flonum no)
                  (fixnum->flonum sender)
                  (fixnum->flonum media-kind)
                  -1.
                  (fixnum->flonum frame)
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method (record-freeze-frame self sender frame keyframe? dts pts)
    (record-event udp-id-freeze-frame
                  (fixnum->flonum no)
                  (fixnum->flonum sender)
                  (fixnum->flonum media-kind)
                  -1.
                  (fixnum->flonum frame)
                  (barbara-keyframe-hack keyframe?)
                  (timestamp->flonum dts)))
  
  
  (method (assemble-chunks self datas first total)
    (if (= total 1)
        (read-udp-media-payload first)
      (let ((chunks (map read-udp-media-payload datas)))
        (apply u8vector-append chunks))))
  

  (method protected (present-audio self presentation-time datas)
    (let ((first (car datas)))
      (let ((kind (read-udp-kind first))
            (sender (read-udp-sender first))
            (channel-no (read-udp-channel first))
            (frame (read-udp-frame first))
            (total (read-udp-total first))
            (dts (read-udp-media-dts first))
            (pts (read-udp-media-pts first))
            (duration (read-udp-media-duration first))
            (keyframe? (read-udp-media-keyframe? first))
            (off? (read-udp-media-off? first)))
        (increase! processed total)
        (let ((id/output (or (simulation-audio) channel-no)))
          (let ((buffer (assemble-chunks self datas first total)))
            (if off?
                (receive-audio (current-audio) id/output #f #f #f #f)
              (receive-audio (current-audio) id/output buffer dts pts duration)
              (record-play-frame self sender frame keyframe? dts pts)))))))
  
  
  (method protected (present-video self datas)
    (let ((first (car datas)))
      (let ((kind (read-udp-kind first))
            (sender (read-udp-sender first))
            (channel-no (read-udp-channel first))
            (frame (read-udp-frame first))
            (total (read-udp-total first))
            (dts (read-udp-media-dts first))
            (pts (read-udp-media-pts first))
            (duration (read-udp-media-duration first))
            (keyframe? (read-udp-media-keyframe? first))
            (off? (read-udp-media-off? first)))
        (increase! processed total)
        (let ((id/output (or (simulation-video) channel-no)))
          (let ((buffer (assemble-chunks self datas first total)))
            (if off?
                (receive-video (current-video) id/output #f #f #f #f #f)
              (receive-video (current-video) id/output buffer dts pts duration keyframe?)
              (when framerate
                (update process-rate framerate))
              (if (eq? (get-state process-ring) 'late)
                  (record-freeze-frame self sender frame keyframe? dts pts)
                (record-play-frame self sender frame keyframe? dts pts))))))))))
