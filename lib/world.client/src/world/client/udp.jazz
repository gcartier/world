;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.application)
        (jazz.event)
        (jazz.io)
        (jazz.math)
        (jazz.platform)
        (jazz.presence)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.audio)
        (world.chronology)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.player)
        (world.profiling)
        (world.record (phase syntax))
        (world.ring)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.throttle)
        (world.time)
        (world.udp)
        (world.video))


(definition protected round-trip-tolerance
  .01)


(class UDP-Client extends UDP-Tier
  
  
  (slot client-no              initialize #f  getter generate)
  (slot character-name         initialize #f  getter generate)
  (slot udp-port               initialize #f  getter generate)
  (slot udp-stopping?          initialize #f  getter generate)
  (slot server-host            initialize #f  getter generate)
  (slot server-port            initialize #f  getter generate)
  (slot write-mutex            initialize #f  getter generate)
  (slot receive-streams        initialize #f  getter generate)
  (slot receive-channels       initialize #f  getter generate)
  (slot alive-task             initialize #f  getter generate)
  (slot awake-task             initialize #f  getter generate)
  (slot receive-task           initialize #f  getter generate)
  (slot state-task             initialize #f  getter generate)
  (slot heartbeat-task         initialize #f  getter generate)
  (slot heartbeat-sequence     initialize 0   getter generate)
  (slot noack-ring             initialize #f  getter generate)
  (slot noack-thread           initialize #f  getter generate)
  (slot noack-time             initialize #f  getter generate)
  (slot started?               initialize #f  getter generate)
  (slot monitor                initialize #f  getter generate)
  (slot statistics             initialize #f  getter generate)
  (slot invalid-packets        initialize 0   getter generate)
  (slot resending-nacks        initialize '() getter generate)
  (slot last-send-state        initialize #f  getter generate)
  (slot last-received-ack      initialize #f  getter generate)
  (slot stable-received-acks   initialize 0   getter generate)
  (slot stable-round-trip      initialize #f  getter generate)
  (slot moving-round-trip      initialize #f  getter generate)
  (slot throttle               initialize #f  getter generate)
  (slot throttle-media?        initialize #f  getter generate)
  (slot profile-ack-callback   initialize #f  accessors generate)
  (slot profile-pulse-sequence initialize #f  getter generate)
  (slot profile-media-sequence initialize #f  getter generate)
  (slot profile-last-sequence  initialize #f  getter generate)
  (slot profile-monitor        initialize #f  getter generate)
  (slot profile-statistics     initialize #f  getter generate)
  (slot profile-chronology     initialize #f  getter generate)
  (slot profile-evolution      initialize #f  getter generate)
  (slot simulator              initialize #f  accessors generate)
  
  
  (method override (initialize self client-no character-name)
    (nextmethod self)
    (set! self.client-no client-no)
    (set! self.character-name character-name)
    (set! write-mutex (make-mutex 'write))
    (set! receive-streams (make-table))
    (set! receive-channels (make-table))
    (set! throttle (new UDP-Throttle))
    (register-snapshot-callback (~ snapshot-receive-streams self)))
  
  
  (method package (connect self local-address host service)
    (unless (simulation?)
    (set! udp-port (open-udp (list
                               local-address: local-address
                               address: host
                               port-number: service)))
    (setup-udp-port-buffers udp-port)
    (set! udp-stopping? #f)
    (let ()
      (define (send-connect)
        (with-write-mutex self
          (lambda ()
            (with-record connect
              (let ((data (make-u8vector (+ (calculate-connect-size) udp-code-size))))
                (write-header-kind data udp-connect)
                (write-header-sender data client-no)
                (write-connect-sent data (current-seconds))
                (write-connect-video-level data (or (video-profile-level) -1))
                (write-udp-code data)
                (write-data data udp-port))))))
      
      (set! server-host #f)
      (set! server-port #f)
      (set! monitor (new UDP-Monitor))
      (set! statistics (new UDP-Statistics))
      (set! simulator #f)
      (when record-events?
        (record-event udp-id-connecting
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.))
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (with-record connected
              (if (or (eof-object? reply) (/= (read-header-kind reply) udp-connected))
                  (if (>= n 100)
                      (begin
                        (terminal 'BAILOUT 'did 'not 'receive 'udp-connected)
                        (exit 1))
                    (loop (+ n 1)))
                (let ((source-info (udp-source-socket-info udp-port)))
                  (set! server-host (socket-info-address source-info))
                  (set! server-port (socket-info-port-number source-info)))
                (when record-events?
                  (record-event udp-id-connected
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.))
                (set! alive-task (new Task 'udp-alive (~ run-alive self) priority: alive-priority))
                (set! awake-task (new Task 'udp-awake (~ run-awake self) priority: awake-priority))
                (set! receive-task (new Task 'udp-receive (~ run-receive self) priority: udp-priority))
                (start-task alive-task)
                (start-task awake-task)
                (start-task receive-task)))))))))

  
  (method (deconnect self)
    (set! udp-stopping? #t)
    (stop-task alive-task)
    (set! alive-task #f)
    (stop-task awake-task)
    (set! awake-task #f)
    (close-port udp-port)
    (thread-join! (get-thread receive-task))
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (unless (simulation?)
        (set! state-task (new Task 'udp-state (~ run-state self) priority: udp-priority))
        (start-task state-task)
        (set! heartbeat-task (new Task 'udp-heartbeat (~ run-heartbeat self) priority: udp-priority))
        (start-task heartbeat-task)
        (let ((thread (new-thread
                        (lambda ()
                          (declare (proper-tail-calls))
                          (let (loop)
                            (let ((proc (wait noack-ring)))
                              (when proc
                                (proc)
                                (loop)))))
                        'udp-noack)))
          (set! noack-ring (new Time-Ring 1))
          (set! noack-thread thread)
          (thread-base-priority-set! thread udp-priority)
          (thread-start! thread)
          (schedule-noack self 1.)))
      (set! last-received-ack (current-seconds))
      (set! throttle-media? #f)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (stop-task state-task)
      (set! state-task #f)
      (stop-task heartbeat-task)
      (set! heartbeat-task #f)
      (terminate noack-ring)
      (thread-join! noack-thread)
      (set! noack-ring #f)
      (set! noack-thread #f)
      (set! started? #f)))
  
  
  (method (with-write-mutex self thunk)
    (unwind-protect
        (begin
          (mutex-lock! write-mutex)
          (thunk))
      (mutex-unlock! write-mutex)))
  
  
  (method (snapshot-receive-streams self)
    (let ((info (map (lambda (stream)
                       (list (get-sender stream)
                             (get-name stream)
                             (get-source-kind stream)))
                     (table-values receive-streams))))
      (add-snapshot-property 'live.udp-receive info)))
  
  
  (method protected (new-simulator self)
    (new UDP-Simulator
         (lambda (data info drop?)
           (if drop?
               (increase-sent self data)
             (send-server self data)))))
  
  
  (method package (require-simulator self)
    (or simulator
        (let ((sim (new-simulator self)))
          (set! simulator sim)
          sim)))
  
  
  (method protected (increase-sent self data)
    (increase-sent monitor data))
  
  
  (method protected (increase-received self data)
    (increase-received monitor data))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (set! profile-pulse-sequence 0)
    (set! profile-media-sequence 0)
    (set! profile-last-sequence 0)
    (set! profile-monitor (new UDP-Monitor))
    (set! profile-statistics (new UDP-Statistics))
    (set! profile-chronology (new Chronology 0))
    (set! profile-evolution (new Evolution 5000)))
  
  
  (method package (retrieve-profile self)
    (let ((metadata (list client-no character-name '() '() (sites-metadata)))
          (chronology (copy-chronology profile-chronology))
          (evolution (copy-evolution profile-evolution)))
      (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
  
  
  (method package (stop-profile self)
    (set! profile-chronology #f)
    (set! profile-evolution #f))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (close-send-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-send-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (unregister-stream (current-client) stream-no)
      (table-clear send-streams stream-no)))
  
  
  (method package (close-send-streams self)
    (iterate-table-safe send-streams
      (lambda (no stream)
        (close-send-stream self stream))))
  
  
  (method package (register-receive-stream self sender name stream-no origin source-kind video-level channels)
    (let ((stream (new UDP-Receive-Stream sender name stream-no origin source-kind video-level)))
      (for-each (lambda (info)
                  (bind (channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state) info
                    (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                channels)
      (table-set! receive-streams stream-no stream)
      stream))
  
  
  (method public (find-receive-stream self stream-no)
    (table-ref receive-streams stream-no #f))
  
  
  (method package (close-receive-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-receive-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (table-clear receive-streams stream-no)))
  
  
  (method package (close-receive-streams self)
    (iterate-table-safe receive-streams
      (lambda (no stream)
        (close-receive-stream self stream))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (register-send-channel self stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (let ((stream (find-send-stream self stream-no)))
      (let ((channel (new UDP-Send-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
        (table-set! send-channels channel-no channel)
        channel)))
  
  
  (method package (close-send-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear send-channels channel-no)))
  
  
  (method public (find-receive-channel self channel-no)
    (table-ref receive-channels channel-no #f))
  
  
  (method package (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (let ((channel (new UDP-Receive-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
      (table-set! receive-channels channel-no channel)
      channel))
  
  
  (method package (close-receive-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear receive-channels channel-no)))
  
  
  (method package (close-channel-output self channel)
    (let ((id (get-no channel))
          (kind (get-media-kind channel)))
      (ecase kind
        ((udp-audio)
         (let ((audio (current-audio)))
           (let ((output (find-output audio id)))
             (when output
               (close-output audio id output)
               (close-empty-audio audio)))))
        ((udp-video)
         (let ((video (current-video)))
           (let ((output (find-output video id)))
             (when output
               (close-output video id output))))))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method package (send-media self channel-no buffer dts pts duration flags)
    (with-write-mutex self
      (lambda ()
        (let ((channel (find-send-channel self channel-no)))
          (when channel
            (let ((kind (get-media-kind channel)))
              (define (send)
                (send-media channel client-no buffer dts pts duration flags
                  (lambda (data)
                    (send-data self data))))
              
              (define (advance-frame!)
                (let ((frame (next-frame-sequence! channel)))
                  (when record-events?
                    (record-event udp-id-throttle-frame
                                  (fixnum->flonum channel-no)
                                  (fixnum->flonum client-no)
                                  (fixnum->flonum kind)
                                  -1.
                                  (fixnum->flonum frame)
                                  -1.
                                  -1.))))
              
              (if (simulation?)
                  (send)
                (if throttle-media?
                    (advance-frame!)
                  (if (waiting-keyframe? channel)
                      (if (not (frame-keyframe? flags))
                          (advance-frame!)
                        (got-keyframe channel)
                        (send))
                    (let ((now (current-seconds)))
                      (if (and udp-throttle (> (- now last-received-ack) udp-throttle))
                          (begin
                            (set! throttle-media? #t)
                            (iterate-table send-channels
                              (lambda (no channel)
                                (wait-keyframe channel)))
                            (when record-events?
                              (record-event udp-id-throttle-on
                                            -1.
                                            (fixnum->flonum server-no)
                                            -1.
                                            -1.
                                            -1.
                                            -1.
                                            -1.)))
                        (send))))))))))))
  
  
  (method (send-state self)
    (define (collect-waiting)
      (let ((waiting '()))
        (iterate-table receive-channels
          (lambda (key channel)
            (when (eq? (get-source-kind channel) 'image)
              (let ((state (get-state (get-process-ring channel))))
                (when (eq? state 'wait)
                  (set! waiting (cons (get-no channel) waiting)))))))
        waiting))
    
    (let ((waiting (collect-waiting)))
      (when (not-null? waiting)
        (let ((now (current-seconds)))
          (when (or (not last-send-state)
                    (> now (+ last-send-state 1.)))
            (with-write-mutex self
              (lambda ()
                (with-record state
                  (let ((waiting (object->u8vector waiting)))
                    (let ((size (calculate-state-size waiting)))
                      (let ((data (make-u8vector (+ size udp-code-size))))
                        (write-header-kind data udp-state)
                        (write-header-sender data client-no)
                        (write-state-waiting data waiting)
                        (write-udp-code data)
                        (send-data self data)))))))
            (set! last-send-state now))))))
  
  
  (method protected (next-profile-pulse-sequence! self)
    (prog1 profile-pulse-sequence
      (increase! profile-pulse-sequence)))
  
  
  (method protected (next-profile-media-sequence! self)
    (prog1 profile-media-sequence
      (increase! profile-media-sequence)))
  
  
  (method package (send-profile-pulse self)
    (with-write-mutex self
      (lambda ()
        (with-record profile-pulse
          (let ((size (calculate-profile-pulse-size)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-profile-pulse)
              (write-header-sender data client-no)
              (write-profile-pulse-sent data (current-seconds))
              (write-profile-pulse-sequence data (next-profile-pulse-sequence! self))
              (write-udp-code data)
              (send-data self data)
              data))))))
  
  
  (method package (send-profile-media self payload)
    (with-write-mutex self
      (lambda ()
        (with-record profile-media
          (let ((size (calculate-profile-media-size payload)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-profile-media)
              (write-header-sender data client-no)
              (write-profile-media-sequence data (next-profile-media-sequence! self))
              (write-profile-media-payload data payload)
              (write-udp-code data)
              (send-data self data)
              (increase-sent profile-monitor data)))))))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data #f)
      (send-server self data)))
  
  
  (method (send-server self data)
    ;; quick temporary hack to get back the safe behavior
    ;; of retrying-write until port being false is fixed
    (when udp-port
      (udp-destination-set! server-host server-port udp-port)
      (send-udp data udp-port)
      (increase-sent self data)))
  
  
  ;;;
  ;;;; Alive
  ;;;
  
  
  (method (run-alive self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site alive
                  (send-alive self)))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task alive-period duration exit))
              (iter time)))))))
  
  
  ;;;
  ;;;; Awake
  ;;;
  
  
  (method (run-awake self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site awake
                  (adjust-computer-sleep self)))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task awake-period duration exit))
              (iter time)))))))
  
  
  (method (adjust-computer-sleep self)
    (if (not application-active?)
        ;; when in the background we let the os manage sleep and we
        ;; disconnect from group or circle when actually going to sleep
        (allow-computer-sleep)
      (let ((keep-awake? #f))
        ;; send
        (iterate-table send-channels
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio udp-video)
               (when (or (neq? (get-source-kind channel) 'live)
                         (on? channel))
                 (set! keep-awake? #t))))))
        ;; receive
        (iterate-table receive-channels
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio udp-video)
               (set! keep-awake? #t)))))
        ;; policy
        (if keep-awake?
            (prevent-computer-sleep)
          (allow-computer-sleep)))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (run-state self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (site udp-state
            (send-state self))
          (task-sleep task udp-state-period exit)
          (loop)))))
  
  
  ;;;
  ;;;; Heartbeat
  ;;;
  
  
  (method (run-heartbeat self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (site udp-heartbeat
            (send-heartbeat self))
          (task-sleep task udp-heartbeat-period exit)
          (loop)))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (run-receive self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (catch-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read-data udp-port)))))
            (when data
              (site udp-receive
                (receive-data self data))
              (loop)))))))
  
  
  (method protected (receive-data self data)
    (if (or (< (u8vector-length data) 4)
            (/= (read-udp-code data) udp-code))
        (increase! invalid-packets)
      (increase-received self data)
      (let ((kind (with-record header
                    (read-header-kind data))))
        (if (not started?)
            (ecase kind
              ((udp-connected))
              ((udp-ack))
              ((udp-nack))
              ((udp-audio udp-video))
              ((udp-alive-ack)
               (receive-alive-ack self data))
              ((udp-profile-ack)
               (receive-profile-ack self data))
              ((udp-profile-media)
               (receive-profile-media self data))
              (else
               (error "Unknown UDP kind: {s}" kind)))
          (ecase kind
            ((udp-connected))
            ((udp-ack)
             (receive-ack self data))
            ((udp-nack)
             (receive-nack self data))
            ((udp-audio udp-video)
             (receive-medias self kind data))
            ((udp-state)
             (receive-state self data))
            ((udp-alive-ack)
             (receive-alive-ack self data))
            ((udp-profile-pulse))
            ((udp-profile-media))
            (else
             (error "Unknown UDP kind: {s}" kind)))))))
  
  
  (method (receive-ack self data)
    (with-record ack
      (let ((now (current-seconds))
            (sender (read-header-sender data))
            (heartbeat-sent (read-ack-heartbeat-sent data))
            (heartbeat-sequence (read-ack-heartbeat-sequence data)))
        ;; statistics
        (let ((ack-sent (read-ack-sent data))
              (server-packets-sent (read-ack-packets-sent data))
              (server-bytes-sent (read-ack-bytes-sent data))
              (server-packets-received (read-ack-packets-received data))
              (server-bytes-received (read-ack-bytes-received data))
              (server-missed-media-packets (read-ack-missed-media-packets data)))
          (let ((round-trip (- now heartbeat-sent)))
            (let ((variance (abs (- (- now last-received-ack) .1))))
              (if (>= variance .01)
                  (set! stable-received-acks 0)
                (increase! stable-received-acks)
                (when (>= stable-received-acks 3)
                  (cond ((not moving-round-trip)
                         (set! moving-round-trip round-trip)
                         (set! stable-round-trip round-trip))
                        (else
                         (set! moving-round-trip (/ (+ (* moving-round-trip 7.) round-trip) 8.))
                         (when (> (abs (- moving-round-trip stable-round-trip)) round-trip-tolerance)
                           (set! stable-round-trip moving-round-trip)))))))
            (update statistics now monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received server-missed-media-packets)
            (when record-events?
              (record-event udp-id-receive-ack
                            -1.
                            (fixnum->flonum sender)
                            -1.
                            (fixnum->flonum heartbeat-sequence)
                            round-trip
                            heartbeat-sent
                            ack-sent
                            -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                            -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received)))))
          (when record-events?
            (let ((last-send-rate (get-last-send-rate statistics))
                  (last-receive-rate (get-last-receive-rate statistics)))
              (unless (= last-send-rate -1.)
                (record-event udp-id-traffic-rate
                              -1.
                              (fixnum->flonum sender)
                              -1.
                              (fixnum->flonum heartbeat-sequence)
                              -1.
                              last-send-rate
                              last-receive-rate)))))
        ;; throttle
        (received-ack throttle heartbeat-sent heartbeat-sequence statistics
          (lambda (adjustment reason)
            (delay-throttle-upload self adjustment reason)))
        (schedule-noack self)
        ;; throttling
        (set! last-received-ack now)
        (when throttle-media?
          (set! throttle-media? #f)
          ;; force camera reset
          ;; (maybe-reset-media self server-no udp-video #f)
          (when record-events?
            (record-event udp-id-throttle-off
                          -1.
                          (fixnum->flonum server-no)
                          -1.
                          (fixnum->flonum heartbeat-sequence)
                          -1.
                          -1.
                          -1.))))))
  
  
  (method (noack-receive self)
    (noack-received throttle statistics
      (lambda (adjustment reason)
        (delay-throttle-upload self adjustment reason)))
    (schedule-noack self))
  
  
  (method (delay-throttle-upload self adjustment reason)
    (delay-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (client?)
              (throttle-upload (current-client))
              (when record-events?
                (record-event udp-id-throttle-upload
                              -1.
                              -1.
                              -1.
                              adjustment
                              reason
                              -1.
                              -1.
                              -1.))))))))
  
  
  (method (schedule-noack self (delay #f))
    (let ((time (+ (current-seconds) (or delay (* udp-heartbeat-period noack-heartbeats)))))
      ;; mostly so we don't overwrite the initial longer 1s delay
      (when (or (not noack-time)
                (> time noack-time))
        (set! noack-time time)
        (empty noack-ring)
        (insert noack-ring noack-time (lambda ()
                                        (noack-receive self))))))
  
  
  (method (receive-nack self data)
    (with-record nack
      (let ((sender (read-header-sender data))
            (channel-no (read-nack-channel data))
            (start (read-nack-start data))
            (gap (read-nack-gap data)))
        (send-missing self sender channel-no start gap))))
  
  
  ;; receive and reorder all available packets
  (method protected (receive-medias self kind data)
    (declare (proper-tail-calls))
    (with-record media
      (let ((no (read-media-channel data)))
        ;; so a sequence of one doesn't allocate a pair
        (let (loop (ordered #f))
          (define (receive)
            (resend-nacks self)
            (if (not ordered)
                (receive-media self kind data)
              (for-each (lambda (data)
                          (receive-media self kind data))
                        ordered)))
          
          (input-port-timeout-set! udp-port 0)
          (let ((next (read udp-port)))
            (input-port-timeout-set! udp-port +inf.0)
            (cond ((eof-object? next)
                   (receive))
                  ((and (= (read-header-kind next) kind)
                        (= (read-media-channel next) no))
                   (loop (add-ordered! next (or ordered (list data)) key: (lambda (data)
                                                                            (read-media-sequence data)))))
                  (else
                   (receive)
                   (receive-data self next))))))))
  
  
  (method protected (receive-media self kind data)
    (with-record media
      (let ((channel-no (read-media-channel data)))
        (let ((channel (find-receive-channel self channel-no)))
          (when channel
            (let ((ring (get-process-ring channel)))
              (with-mutex ring
                (lambda ()
                  (when (eq? (get-send-state channel) 'on)
                    (when (get-appsrc ring)
                      (remember-media channel data)
                      (insert-media channel data)))))))))))
  
  
  (method (send-missing self sender channel-no start gap)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((media-kind (get-media-kind channel))
              (ring (get-retain-ring channel)))
          (loop (for sequence from start below (+ start gap))
                (let ((data (locate-data ring sequence)))
                  (if data
                      (with-record media
                        (increase-media-resent data)
                        (send-data self data)
                        (when record-events?
                          (let ((frame (read-media-frame data)))
                            (record-event udp-id-resend-packet
                                          (fixnum->flonum channel-no)
                                          (fixnum->flonum sender)
                                          (fixnum->flonum media-kind)
                                          (fixnum->flonum sequence)
                                          (fixnum->flonum frame)
                                          -1.
                                          -1.))))
                    (when record-events?
                      (record-event udp-id-absent-packet
                                    (fixnum->flonum channel-no)
                                    (fixnum->flonum sender)
                                    (fixnum->flonum media-kind)
                                    (fixnum->flonum sequence)
                                    -1.
                                    -1.
                                    -1.)))))))))
  
  
  (method (receive-state self data)
    (with-record state
      (let ((waiting (u8vector->object (read-state-waiting data))))
        (for-each (lambda (channel-no)
                    (let ((channel (find-send-channel self channel-no)))
                      (when channel
                        (reset-media channel))))
                  waiting))))
  
  
  (method (receive-alive-ack self data)
    )
  
  
  (method (receive-profile-ack self data)
    (let ((include-receive-rate?
            (if profile-ack-callback
                (profile-ack-callback data)
              #t)))
      (with-record profile-ack
        (let ((now (current-seconds)))
          (let ((ack-sent (read-profile-ack-sent data))
                (pulse-sent (read-profile-ack-pulse-sent data))
                (pulse-sequence (read-profile-ack-pulse-sequence data))
                (latency (read-profile-ack-latency data))
                (server-packets-sent (read-profile-ack-packets-sent data))
                (server-bytes-sent (read-profile-ack-bytes-sent data))
                (server-packets-received (read-profile-ack-packets-received data))
                (server-bytes-received (read-profile-ack-bytes-received data))
                (server-missed-media-packets 0)) ;; todo
            (let ((round-trip (- now pulse-sent)))
              (update profile-statistics now profile-monitor round-trip server-packets-sent server-bytes-sent server-packets-received server-bytes-received server-missed-media-packets)
              (parameterize ((simulation-evolution profile-evolution))
                ;; hack to plot latency
                (when record-events?
                  (record-event udp-id-insert-packet
                                (fixnum->flonum pulse-sequence)
                                (fixnum->flonum client-no)
                                (fixnum->flonum udp-audio)
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.
                                latency))
                ;; hack to plot round trip
                (when record-events?
                  (record-event udp-id-receive-ack
                                -1.
                                (fixnum->flonum client-no)
                                -1.
                                (fixnum->flonum pulse-sequence)
                                round-trip
                                pulse-sent
                                ack-sent
                                -1. @PROFILE (fixnum->flonum (- fresh-bytes-sent fresh-server-bytes-received))
                                -1. @PROFILE (fixnum->flonum (- fresh-server-bytes-sent fresh-bytes-received))))
                (when record-events?
                  (let ((last-send-rate (get-last-send-rate profile-statistics))
                        (last-receive-rate (get-last-receive-rate profile-statistics)))
                    (unless (= last-send-rate -1.)
                      ;; hack to plot upload
                      (record-event udp-id-traffic-rate
                                    -1.
                                    (fixnum->flonum client-no)
                                    -1.
                                    (fixnum->flonum pulse-sequence)
                                    -1.
                                    last-send-rate
                                    (if include-receive-rate?
                                        last-receive-rate
                                      -1.))))))))))))
  
  
  (method (receive-profile-media self data)
    (with-record profile-media
      (let ((sender (read-header-sender data))
            (sequence (read-profile-media-sequence data)))
        (when record-events?
          (when profile-last-sequence
            (let ((expected-sequence (+ profile-last-sequence 1)))
              (when (/= sequence expected-sequence)
                (parameterize ((simulation-evolution profile-evolution))
                  (loop (for seq from expected-sequence below sequence)
                        (record-event udp-id-lost-packet
                                      -1.
                                      (fixnum->flonum sender)
                                      (fixnum->flonum udp-profile-media)
                                      (fixnum->flonum seq)
                                      -1.
                                      -1.
                                      -1.)))))))
        (set! profile-last-sequence sequence)
        (increase-received profile-monitor data))))
  
  
  (method protected (next-heartbeat-sequence! self)
    (prog1 heartbeat-sequence
      ;; wrap around acceptable
      (if (= heartbeat-sequence max-heartbeat-sequence)
          (set! heartbeat-sequence 0)
        (increase! heartbeat-sequence))))
  
  
  (method (send-heartbeat self)
    (let ((heartbeat-sequence (next-heartbeat-sequence! self)))
      (with-write-mutex self
        (lambda ()
          (with-record heartbeat
            (let ((size (calculate-heartbeat-size)))
              (let ((data (make-u8vector (+ size udp-code-size))))
                (write-header-kind data udp-heartbeat)
                (write-header-sender data client-no)
                (write-heartbeat-sent data (current-seconds))
                (write-heartbeat-sequence data heartbeat-sequence)
                (write-udp-code data)
                (send-data self data))))
          (when record-events?
            (record-event udp-id-send-heartbeat
                          -1.
                          (fixnum->flonum client-no)
                          -1.
                          (fixnum->flonum heartbeat-sequence)
                          -1.
                          -1.
                          -1.))))))
  
  
  (method override (add-missed-media-packets self sender gap)
    (increase-missed-media-packets monitor gap))
  
  
  (method override (send-nack self sender channel-no start gap resend)
    (with-write-mutex self
      (lambda ()
        (with-record nack
          (let ((size (calculate-nack-size)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-nack)
              (write-header-sender data client-no)
              (write-nack-channel data channel-no)
              (write-nack-start data start)
              (write-nack-gap data gap)
              (write-udp-code data)
              (send-data self data)
              (when (> resend 0)
                (set! resending-nacks (cons (cons resend data) resending-nacks)))))))))
  
  
  (method (resend-nacks self)
    (declare (proper-tail-calls))
    (when (not-null? resending-nacks)
      (let (loop (previous #f) (scan resending-nacks))
        (when (not-null? scan)
          (bind (info . next) scan
            (bind (resend . data) info
              (send-data self data)
              (let ((resend (- resend 1)))
                (cond ((<= resend 0)
                       (if (not previous)
                           (set! resending-nacks next)
                         (set-cdr! previous next))
                       (loop previous next))
                      (else
                       (set-car! info resend)
                       (loop scan next))))))))))
  
  
  (method (send-alive self)
    ;; keep clean during profile
    (unless profile-ack-callback
      (with-write-mutex self
        (lambda ()
          (with-record header
            (let ((size (calculate-alive-size)))
              (let ((data (make-u8vector (+ size udp-code-size))))
                (write-header-kind data udp-alive)
                (write-header-sender data client-no)
                (write-udp-code data)
                (send-data self data)))))))))


;;;
;;;; Receive Base
;;;


(definition cutoff-latency
  udp-live-retain-window)

(definition cutoff-last-past-time
  0.5)


(definition max-latency <fx>
  (flonum->timestamp 5.))


(class UDP-Receive-Base extends UDP-Base
  
  
  (slot stream      getter generate)
  (slot media-kind  getter generate)
  (slot source-kind getter generate)
  
  
  (method override (initialize self stream media-kind source-kind)
    (nextmethod self)
    (set! self.stream stream)
    (set! self.media-kind media-kind)
    (set! self.source-kind (if live-streaming? 'live source-kind)))
  
  
  (method override (effective-latency self)
    (media-latency stream media-kind))
  
  
  (method protected (latency-remote->local self latency remote) <fx>
    (+ base remote latency)))


(definition plateau-duration <fl>
  5.)

(definition plateau-grace <fx>
  (flonum->timestamp 1.))

(definition plateau-minimum <fx>
  (flonum->timestamp 2.))

(definition drop-minimum <fx>
  (flonum->timestamp 0.05))

(definition low-drop-variance <fl>
  0.01)


(class UDP-Audio-Base extends UDP-Receive-Base
  
  
  (slot ring                  accessors generate)
  (slot last-raw-latency      getter generate)
  (slot plateau-start         getter generate)
  (slot plateau-highest       getter generate)
  (slot state                 getter generate)
  (slot drop-total       <fl> getter generate)
  (slot drop-count       <fl> getter generate)
  (slot drop-variance    <fl> getter generate)
  
  
  (method override (initialize self stream media-kind source-kind)
    (nextmethod self stream media-kind source-kind)
    (set! self.last-raw-latency 0)
    (set! self.plateau-start 0)
    (set! self.plateau-highest #f)
    (set! self.state 'plateau))
  
  
  (method override (reset self)
    (nextmethod self)
    (set! self.last-raw-latency 0)
    (set! self.plateau-start 0)
    (set! self.plateau-highest #f)
    (set! self.state 'plateau))
  
  
  (method (determine-earliest-ontime self local)
    (let ((earliest (earliest-packet ring)))
      (and earliest
           (let ((earliest-dts (get-dts earliest)))
             (let ((earliest-base (- local earliest-dts)))
               (let ((earliest-latency (- earliest-base base)))
                 (- earliest-latency udp-audio-tolerance)))))))
  
  
  (method (update-mean/variance self drop plateau-time)
    (let ((raw-drop (timestamp->flonum drop)))
      (increase! drop-total raw-drop)
      (increase! drop-count 1.)
      (let ((mean-drop (/ drop-total drop-count))
            (alpha (min 1. (/ (timestamp->flonum (- plateau-time plateau-grace)) plateau-duration))))
        (let ((fresh-variance (sqr (- mean-drop raw-drop))))
          (set! drop-variance (+ (* drop-variance (- 1. alpha)) (* fresh-variance alpha)))))))
  
  
  (method (check-low-variance? self smallest-drop)
    (let ((low-variance-limit (* low-drop-variance (timestamp->flonum smallest-drop))))
      (< drop-variance low-variance-limit)))
  
  
  (method override (update-time self local remote update-proc)
    (let ((new-base (- local remote)))
      (define (reset-plateau)
        (set! plateau-start local)
        (set! plateau-highest #f)
        (set! drop-total 0.)
        (set! drop-count 0.)
        (set! drop-variance 0.))
      
      (if (not base)
          (begin
            (set! base new-base)
            (set! raw-latency 0)
            (set! latency 0)
            (reset-plateau)
            (update-latency stream media-kind raw-latency latency)
            (update-proc raw-latency latency udp-latency-raw))
        (let ((raw (- new-base base)))
          (set! raw-latency raw)
          (case state
            ((plateau)
             (cond ;; up
                   ((> raw (+ latency udp-audio-tolerance))
                    (set! state 'rise)
                    (set! latency +inf.ts)
                    (set! last-raw-latency raw))
                   ;; extend
                   ((>= raw (- latency drop-minimum))
                    (reset-plateau))
                   ;; down
                   ((and (eq? source-kind 'live)
                         (>= local (+ plateau-start plateau-grace)))
                    (when (or (not plateau-highest)
                              (> raw plateau-highest))
                      (set! plateau-highest raw))
                    (let ((plateau-time (- local plateau-start))
                          (drop (- latency raw))
                          (smallest-drop (- latency plateau-highest)))
                      (update-mean/variance self drop plateau-time)
                      (let ((low-variance? (check-low-variance? self smallest-drop)))
                        (when (and low-variance? (>= plateau-time plateau-minimum))
                          ;; fall
                          (when (= (voice-percentage ring) 0.)
                            (set! latency plateau-highest)
                            (reset-plateau))))))))
            ((rise)
             (if (> raw last-raw-latency)
                 (set! last-raw-latency raw)
               (let ((earliest-ontime (determine-earliest-ontime self local)))
                 (if (and earliest-ontime (< earliest-ontime last-raw-latency))
                     (set! last-raw-latency raw)
                   ;; plateau
                   (set! state 'plateau)
                   (set! latency (if earliest-ontime (max earliest-ontime last-raw-latency) last-raw-latency))
                   (reset-plateau))))))
          ;; update
          (update-latency stream media-kind raw-latency latency)
          (update-proc raw-latency latency udp-latency-raw))))))


(class UDP-Video-Base extends UDP-Receive-Base
  
  
  (slot last-raw-latency getter generate)
  (slot plateau-start    getter generate)
  (slot plateau-highest  getter generate)
  (slot state            getter generate)
  (slot nack-window <fx> getter generate)
  
  
  (method override (initialize self stream media-kind source-kind)
    (nextmethod self stream media-kind source-kind)
    (set! self.last-raw-latency 0)
    (set! self.plateau-start 0)
    (set! self.plateau-highest #f)
    (set! self.state 'plateau)
    (set! self.nack-window 0))
  
  
  (method override (reset self)
    (nextmethod self)
    (set! self.last-raw-latency 0)
    (set! self.plateau-start 0)
    (set! self.plateau-highest #f)
    (set! self.state 'plateau)
    (set! self.nack-window 0))
  
  
  (method override (update-time self local remote update-proc)
    (let ((new-base (- local remote)))
      (define (reset-plateau)
        (set! plateau-start local)
        (set! plateau-highest #f))
      
      (if (not base)
          (begin
            (set! base new-base)
            (set! raw-latency 0)
            (set! latency 0)
            (reset-plateau)
            (update-latency stream media-kind raw-latency latency)
            (update-proc raw-latency latency udp-latency-raw))
        (let ((raw (- new-base base)))
          (set! raw-latency raw)
          (case state
            ((plateau)
             (cond ;; up
                   ((> raw (+ latency udp-video-tolerance))
                    (set! state 'rise)
                    (set! latency +inf.ts)
                    (set! last-raw-latency raw))
                   ;; extend
                   ((>= raw (- latency drop-minimum))
                    (reset-plateau))
                   ;; down
                   ((and (eq? source-kind 'live)
                         (>= local (+ plateau-start plateau-grace)))
                    (when (or (not plateau-highest)
                              (> raw plateau-highest))
                      (set! plateau-highest raw))
                    (let ((plateau-time (- local plateau-start))
                          (drop (- latency raw))
                          (smallest-drop (- latency plateau-highest)))
                      (when (>= plateau-time plateau-minimum)
                        ;; fall
                        (set! latency plateau-highest)
                        (reset-plateau))))))
            ((rise)
             (if (> raw last-raw-latency)
                 (set! last-raw-latency raw)
               ;; plateau
               (set! state 'plateau)
               (set! latency last-raw-latency)
               (reset-plateau))))
          ;; update
          (update-latency stream media-kind raw-latency latency)
          (update-proc raw-latency latency udp-latency-raw)))))
  
  
  (method override (update-past self local remote update-proc)
    (when (neq? source-kind 'live)
      (let ((new-base (- local remote)))
        (let ((raw-latency (min max-latency (- new-base base))))
          (let ((window (- raw-latency latency)))
            (when (> window nack-window)
              (set! nack-window window)
              (update-nack stream media-kind window))))))))


;;;
;;;; Receive Ring
;;;


(class UDP-Receive-Ring extends UDP-Ring
  
  
  (slot appsrc initialize #f accessors generate)
  
  
  (method override (local-timestamp self)
    (gst_element_get_running_time appsrc))
  
  
  (method protected (determine-write-time self packet <UDP-Packet> latency <fx> process-window <fx>) <fx>
    (let ((dts (get-dts packet)))
      (let ((time (latency-remote->local time-base latency dts)))
        (+ time process-window)))))


;;;
;;;; Audio Ring
;;;


(definition audio-clock-resolution <fl>
  .01)


(definition not-ready-max-sleep <fl>
  .1)


(definition (not-ready-sleep mutex timeout)
  (mutex-unlock! mutex)
  (sleep (min not-ready-max-sleep timeout)))


(class UDP-Audio-Ring extends UDP-Receive-Ring
  
  
  (slot audio-duration initialize 0 getter generate)
  (slot voice-count    initialize 0 getter generate)
  
  
  (method override (empty self)
    (nextmethod self)
    (set! audio-duration 0)
    (set! voice-count 0))
  
  
  (method override (audio-added self packet)
    (let ((duration (get-duration packet)))
      (when duration
        (set! audio-duration (+ audio-duration duration))))
    (when (has-voice? packet)
      (increase! voice-count)))
  
  
  (method override (audio-removed self packet)
    (let ((duration (get-duration packet)))
      (when duration
        (set! audio-duration (- audio-duration duration))))
    (when (has-voice? packet)
      (decrease! voice-count)))
  
  
  (method protected (voice-percentage self)
    (if (= count 0)
        0.
      (percentage voice-count count)))
  
  
  (method protected (process-audio self channel exit)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          (continuation-return exit #f)
        (mutex-lock! mutex)
        ;; empty
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((latency (effective-latency time-base)))
            ;; rising
            (if (= latency +inf.ts)
                (begin
                  (mutex-unlock! mutex wait-condvar audio-clock-resolution)
                  (loop-wait))
              (let ((running-time (gst_element_get_running_time appsrc))
                    (earliest <UDP-Packet> (vector-ref packets head)))
                (let ((write-time (determine-write-time self earliest latency udp-audio-process)))
                  (let ((giveup-time (+ write-time udp-audio-giveup)))
                    (cond ;; giveup
                          ((>= running-time giveup-time)
                           (flush-earliest self)
                           (mutex-unlock! mutex)
                           (loop-wait))
                          ;; not ready
                          ((< running-time write-time)
                           (not-ready-sleep mutex (max audio-clock-resolution (timestamp->flonum (- write-time running-time))))
                           (loop-wait))
                          ;; frame
                          ((complete-frame? self)
                           (receive (sender channel-no packet data) (extract-complete self)
                             (give-audio channel sender channel-no packet data latency))
                           (mutex-unlock! mutex)
                           (loop-wait))
                          ;; flush
                          (else
                           (flush-earliest self)
                           (mutex-unlock! mutex)
                           (loop-wait)))))))))))))


;;;
;;;; Video Ring
;;;


(class UDP-Video-Ring extends UDP-Receive-Ring
  
  
  (method protected (state-play self)
    (unless (eq? state 'play)
      (set! state 'play)
      (gst_element_send_thaw appsrc)
      (unless (emulation?)
        (when record-events?
          (record-event udp-id-state-play
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        -1.)))))
  
  
  (method protected (state-freeze self)
    (unless (eq? state 'freeze)
      (set! state 'freeze)
      (gst_element_send_freeze appsrc)
      (unless (emulation?)
        (when record-events?
          (record-event udp-id-state-freeze
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        -1.)))))
  
  
  (method protected (process-video self channel exit)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if terminate?
          (continuation-return exit #f)
        (mutex-lock! mutex)
        ;; empty
        (if (= count 0)
            (begin
              (mutex-unlock! mutex wait-condvar)
              (loop-wait))
          (let ((latency (effective-latency time-base)))
            ;; rising
            (if (= latency +inf.ts)
                (begin
                  (mutex-unlock! mutex wait-condvar .01)
                  (loop-wait))
              (let ((running-time (gst_element_get_running_time appsrc))
                    (earliest <UDP-Packet> (vector-ref packets head)))
                (let ((write-time (determine-write-time self earliest latency udp-video-process)))
                  (let ((late-time (+ write-time udp-video-late))
                        (giveup-time (+ write-time udp-video-giveup)))
                    (cond ;; giveup
                          ((>= running-time giveup-time)
                           (flush-earliest self)
                           (state-wait self)
                           (mutex-unlock! mutex)
                           (loop-wait))
                          ;; wait
                          ((eq? state 'wait)
                           (let ((keyframe (complete-keyframe self)))
                             (cond ;; keyframe
                                   (keyframe
                                    (let ((packet (packet-ref self keyframe)))
                                      (let ((packet-write (determine-write-time self packet latency udp-video-process)))
                                        (cond ;; not ready
                                              ((< running-time packet-write)
                                               (not-ready-sleep mutex (timestamp->flonum (- packet-write running-time)))
                                               (loop-wait))
                                              ;; ready
                                              (else
                                               (flush-before self keyframe)
                                               (state-ok self)
                                               (mutex-unlock! mutex)
                                               (loop-wait))))))
                                   ;; no keyframe
                                   (else
                                    (mutex-unlock! mutex wait-condvar (timestamp->flonum (- giveup-time running-time)))
                                    (loop-wait)))))
                          ;; not ready
                          ((< running-time write-time)
                           (not-ready-sleep mutex (timestamp->flonum (- write-time running-time)))
                           (loop-wait))
                          ;; frame
                          ((complete-frame? self)
                           (cond ;; ontime
                                 ((< running-time late-time)
                                  (state-play self))
                                 ;; late
                                 (else
                                  (state-freeze self)))
                           (receive (sender channel-no packet data) (extract-complete self)
                             (give-video channel sender channel-no packet data latency))
                           (mutex-unlock! mutex)
                           (loop-wait))
                          ;; wakeup on late
                          ((< running-time late-time)
                           (mutex-unlock! mutex wait-condvar (timestamp->flonum (- late-time running-time)))
                           (loop-wait))
                          ;; wakeup on giveup
                          (else
                           (mutex-unlock! mutex wait-condvar (timestamp->flonum (- giveup-time running-time)))
                           (loop-wait)))))))))))))


;;;
;;;; Receive Stream
;;;


(class UDP-Receive-Stream extends UDP-Stream
  
  
  (slot latency-mutex        initialize (make-mutex 'latency) getter generate)
  (slot audio-on?            initialize #t getter generate)
  (slot audio-time     <fl+> initialize #f getter generate)
  (slot audio-raw      <fx+> initialize #f getter generate)
  (slot audio-latency  <fx+> initialize #f getter generate)
  (slot video-time     <fl+> initialize #f getter generate)
  (slot video-raw      <fx+> initialize #f getter generate)
  (slot video-latency  <fx+> initialize #f getter generate)
  (slot moving-base    <fl+> initialize #f getter generate)
  (slot base           <fx+> initialize #f getter generate)
  (slot nack-window    <fx>  initialize 0  getter generate)
  
  
  (method protected (with-locked-channels self thunk (media-kind #f))
    (iterate-table channels
      (lambda (no channel)
        (when (or (not media-kind)
                  (= media-kind (get-media-kind channel)))
          (mutex-lock! (get-mutex (get-process-ring channel))))))
    (unwind-protect (thunk)
      (iterate-table channels
        (lambda (no channel)
          (when (or (not media-kind)
                    (= media-kind (get-media-kind channel)))
            (mutex-unlock! (get-mutex (get-process-ring channel))))))))
  
  
  (method protected (channel-on self media-kind)
    (mutex-lock! latency-mutex)
    (when (= media-kind udp-audio)
      (set! audio-on? #t))
    (mutex-unlock! latency-mutex))
  
  
  (method protected (channel-off self media-kind)
    (mutex-lock! latency-mutex)
    (when (= media-kind udp-audio)
      (set! audio-on?     #f)
      (set! audio-time    #f)
      (set! audio-raw     #f)
      (set! audio-latency #f)
      (set! moving-base   #f)
      (set! base          #f))
    (mutex-unlock! latency-mutex))
  
  
  (method protected (reset-video-latency self)
    (mutex-lock! latency-mutex)
    (set! video-time    #f)
    (set! video-raw     #f)
    (set! video-latency #f)
    (set! moving-base   #f)
    (set! base          #f)
    (mutex-unlock! latency-mutex))
  
  
  (method protected (update-latency self media-kind raw-latency latency)
    (mutex-lock! latency-mutex)
    (let ((now (current-seconds)))
      (define (update-base)
        (when (< (abs (- audio-time video-time)) .01)
          (let ((fresh-base (- video-raw audio-raw)))
            (when (not base)
              (set! base fresh-base))
            (let ((fresh (timestamp->flonum fresh-base)))
              (if (not moving-base)
                  (set! moving-base fresh)
                (set! moving-base (/ (+ (* moving-base 63.) fresh) 64.)))))
          (when (> (abs (- moving-base (timestamp->flonum base))) .01)
            (set! base (flonum->timestamp moving-base)))))
      
      (ecase media-kind
        ((udp-audio)
         (set! audio-time now)
         (set! audio-raw raw-latency)
         (set! audio-latency latency)
         (when video-raw
           (update-base)))
        (else
         (set! video-time now)
         (set! video-raw raw-latency)
         (set! video-latency latency)
         (when audio-raw
           (update-base)))))
    (mutex-unlock! latency-mutex))
  
  
  (method protected (update-nack self media-kind window)
    (mutex-lock! latency-mutex)
    (set! nack-window window)
    (mutex-unlock! latency-mutex))
  
  
  (method protected (media-latency self media-kind)
    (mutex-lock! latency-mutex)
    (prog1 (let ((latency (ecase media-kind
                            ((udp-audio) audio-latency)
                            (else (cond ((or (not audio-on?)
                                             (not base))
                                         video-latency)
                                        ((= audio-latency +inf.ts)
                                         audio-latency)
                                        (else
                                         (+ audio-latency base)))))))
             (if (= latency +inf.ts)
                 latency
               (+ latency nack-window)))
      (mutex-unlock! latency-mutex))))


;;;
;;;; Receive Channel
;;;


(definition protected max-audio-gap
  5)


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot process-ring                      getter generate)
  (slot process-task                      getter generate)
  (slot replay-ring                       getter generate)
  (slot insert-rate-frame                 getter generate)
  (slot insert-rate                       getter generate)
  (slot process-rate                      getter generate)
  (slot last-audio-frame    initialize #f getter generate)
  (slot last-audio-buffer   initialize #f getter generate)
  (slot last-audio-pts      initialize #f getter generate)
  (slot last-audio-dts      initialize #f getter generate)
  (slot last-audio-duration initialize #f getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (nextmethod self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (set! self.replay-ring (and (developer?) (remember-ring media-kind source-kind level framerate)))
    (let ((time-base (cond ((simulation?)
                            (new UDP-Visualizer-Base))
                           ((= media-kind udp-audio)
                            (new UDP-Audio-Base stream media-kind source-kind))
                           (else
                            (new UDP-Video-Base stream media-kind source-kind)))))
      (set! self.process-ring (ecase media-kind
                                ((udp-audio)
                                 (new UDP-Audio-Ring self no (get-origin stream) media-kind source-kind udp-process-size max-size: udp-process-max-size time-base: time-base overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
                                (else
                                 (new UDP-Video-Ring self no (get-origin stream) media-kind source-kind udp-process-size max-size: udp-process-max-size time-base: time-base overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))))
      (unless (simulation?)
        (when (= media-kind udp-audio)
          (set-ring time-base self.process-ring))))
    (unless (simulation?)
      (set! self.process-task (new Task (if (= media-kind udp-audio) 'udp-audio 'udp-video) (~ run-process self) priority: udp-process-priority)))
    (set! self.insert-rate-frame 0)
    (set! self.insert-rate (new Rate))
    (set! self.process-rate (new Rate))
    (unless (simulation?)
      (start-task process-task)))
  
  
  (method override (destroy self)
    (terminate process-ring)
    (thread-join! (get-thread process-task))
    (nextmethod self))
  
  
  (method protected (remember-media self data)
    (when replay-ring
      (remember replay-ring data)))
  
  
  (method protected (insert-media self data)
    (with-record media
      (let ((frame (read-media-frame data)))
        (when (or (not insert-rate-frame)
                  (> frame insert-rate-frame))
          (update insert-rate)
          (set! insert-rate-frame frame))))
    (insert-unlocked process-ring data))
  
  
  (method protected (channel-on self)
    (set! send-state 'on))
  
  
  (method protected (channel-off self)
    (set! send-state 'off)
    (reset self))
  
  
  (method override (reset self)
    (reset process-ring)
    (set! last-audio-frame #f)
    (set! last-audio-buffer #f)
    (set! last-audio-dts #f)
    (set! last-audio-pts #f)
    (set! last-audio-duration #f)
    ;; quick test
    (ecase media-kind
      ((udp-audio)
       (let ((output (find-output (current-audio) no)))
         (when output
           (reset (get-source-adapter output)))))
      (else
       (let ((output (find-output (current-video) no)))
         (when output
           (reset (get-source-adapter output)))))))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (run-process self task)
    (with-task task
      (lambda (exit)
        (ecase media-kind
          ((udp-audio)
           (process-audio process-ring self exit))
          ((udp-video)
           (process-video process-ring self exit))))))
  
  
  (method (record-play-frame self sender frame flags dts pts)
    (when record-events?
      (record-event udp-id-play-frame
                    (fixnum->flonum no)
                    (fixnum->flonum sender)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (fixnum->flonum flags)
                    (timestamp->flonum dts))))
  
  
  (method (record-freeze-frame self sender frame flags dts pts)
    (when record-events?
      (record-event udp-id-freeze-frame
                    (fixnum->flonum no)
                    (fixnum->flonum sender)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (fixnum->flonum flags)
                    (timestamp->flonum dts))))
  
  
  (method (chop-audio self buffer buffer-duration duration)
    (let ((size (fxround (exact->inexact (* (u8vector-length buffer) (/ duration buffer-duration))))))
      (subu8vector buffer 0 size)))
  

  (method protected (give-audio self sender channel-no packet buffer latency)
    (site give-audio
      (let ((frame (get-frame packet))
            (total (get-total packet))
            (dts (get-dts packet))
            (pts (get-pts packet))
            (duration (get-duration packet))
            (flags (get-flags packet)))
        (let ((id/output (or (simulation-audio) channel-no)))
          ;; duplicate last buffer to fill missing audio which sounds a lot better
          ;; than doing nothing and have gstreamer use silence which sounds gritchy
          (when (and last-audio-frame (> last-audio-duration 0))
            (let ((audio-gap (- frame last-audio-frame)))
              (when (and (> audio-gap 1) (< audio-gap max-audio-gap))
                (let ((missing-dts (+ last-audio-dts last-audio-duration))
                      (missing-pts (+ last-audio-pts last-audio-duration)))
                  (let (loop (missing-dts missing-dts) (missing-pts missing-pts) (missing-duration (- pts missing-pts)))
                    (when (> missing-duration 0)
                      (if (< missing-duration last-audio-duration)
                          (let ((buffer (chop-audio self last-audio-buffer last-audio-duration missing-duration)))
                            (receive-audio (current-audio) id/output buffer missing-dts missing-pts missing-duration))
                        (receive-audio (current-audio) id/output last-audio-buffer missing-dts missing-pts last-audio-duration)
                        (loop (+ missing-dts last-audio-duration) (+ missing-pts last-audio-duration) (- missing-duration last-audio-duration)))))))))
          (set! last-audio-frame frame)
          (set! last-audio-buffer buffer)
          (set! last-audio-dts dts)
          (set! last-audio-pts pts)
          (set! last-audio-duration duration)
          (let ((dts (max 0 (+ dts latency)))
                (pts (max 0 (+ pts latency))))
            (receive-audio (current-audio) id/output buffer dts pts duration))
          (record-play-frame self sender frame flags dts pts)))))
  
  
  (method protected (give-video self sender channel-no packet buffer latency)
    (site give-video
      (let ((frame (get-frame packet))
            (total (get-total packet))
            (dts (get-dts packet))
            (pts (get-pts packet))
            (duration (get-duration packet))
            (flags (get-flags packet)))
        (let ((id/output (or (simulation-video) channel-no)))
          (let ((dts (max 0 (+ dts latency)))
                (pts (max 0 (+ pts latency))))
            (receive-video (current-video) id/output buffer dts pts duration flags))
          (update process-rate)
          (if (eq? (get-state process-ring) 'late)
              (record-freeze-frame self sender frame flags dts pts)
            (record-play-frame self sender frame flags dts pts)))))))


;;;
;;;; Audio Only
;;;


(class UDP-Audio-Only-Channel-Hack extends UDP-Receive-Channel))
