;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; UDP Client
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.application)
        (jazz.event)
        (jazz.flow)
        (jazz.io)
        (jazz.math)
        (jazz.platform)
        (jazz.presence)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.audio)
        (world.chronology)
        (world.configure)
        (world.congestion)
        (world.context)
        (world.event)
        (world.evolution)
        (world.format)
        (world.player)
        (world.profile)
        (world.profiling)
        (world.queue)
        (world.record (phase syntax))
        (world.rate)
        (world.ring)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.throttle)
        (world.time)
        (world.udp)
        (world.video))


(definition protected round-trip-tolerance
  .01)


(class UDP-Client extends UDP-Tier
  
  
  (slot client-no                  initialize #f  getter generate)
  (slot character-name             initialize #f  getter generate)
  (slot udp-port                   initialize #f  getter generate)
  (slot udp-stopping?              initialize #f  getter generate)
  (slot server-host                initialize #f  getter generate)
  (slot server-port                initialize #f  getter generate)
  (slot write-mutex                initialize #f  getter generate)
  (slot receive-streams            initialize #f  getter generate)
  (slot receive-channels           initialize #f  getter generate)
  (slot live-task                  initialize #f  getter generate)
  (slot awake-task                 initialize #f  getter generate)
  (slot receive-task               initialize #f  getter generate)
  (slot state-task                 initialize #f  getter generate)
  (slot heartbeat-task             initialize #f  getter generate)
  (slot heartbeat-sequence         initialize 0   getter generate)
  (slot noack-ring                 initialize #f  getter generate)
  (slot noack-task                 initialize #f  getter generate)
  (slot noack-time                 initialize #f  getter generate)
  (slot started?                   initialize #f  getter generate)
  (slot monitor                    initialize #f  getter generate)
  (slot statistics                 initialize #f  getter generate)
  (slot upload-mutex               initialize #f  getter generate)
  (slot upload-state               initialize #f  getter generate)
  (slot upload-rate                initialize #f  getter generate)
  (slot upload-congestion          initialize #f  getter generate)
  (slot upload-queue               initialize #f  getter generate)
  (slot upload-task                initialize #f  getter generate)
  (slot upload-done?               initialize #f  getter generate)
  (slot invalid-packets            initialize 0   getter generate)
  (slot resending-nacks            initialize '() getter generate)
  (slot last-send-state            initialize #f  getter generate)
  (slot last-received-ack          initialize #f  getter generate)
  (slot stable-received-acks       initialize 0   getter generate)
  (slot stable-round-trip          initialize #f  getter generate)
  (slot moving-round-trip          initialize #f  getter generate)
  (slot throttle                   initialize #f  getter generate)
  (slot throttle-media?            initialize #f  getter generate)
  (slot profile-ack-callback       initialize #f  accessors generate)
  (slot profile-media-ack-callback initialize #f  accessors generate)
  (slot profile-pulse-sequence     initialize #f  getter generate)
  (slot profile-media-sequence     initialize #f  getter generate)
  (slot profile-last-sequence      initialize #f  getter generate)
  (slot profile-monitor            initialize #f  getter generate)
  (slot profile-statistics         initialize #f  getter generate)
  (slot profile-chronology         initialize #f  getter generate)
  (slot profile-evolution          initialize #f  getter generate)
  (slot simulator                  initialize #f  accessors generate)
  (slot profile-changed-hook       initialize #f  accessors generate)
  
  
  (method override (initialize self client-no character-name)
    (nextmethod self)
    (set! self.client-no client-no)
    (set! self.character-name character-name)
    (set! write-mutex (make-mutex 'write))
    (set! receive-streams (make-table))
    (set! receive-channels (make-table))
    (set! throttle (new UDP-Throttle))
    (register-snapshot-callback (~ snapshot-receive-streams self)))
  
  
  (method package (connect self local-address host service)
    (unless (simulation?)
    (set! udp-port (open-udp (list
                               local-address: local-address
                               address: host
                               port-number: service)))
    (setup-udp-port-buffers udp-port)
    (set! udp-stopping? #f)
    (let ()
      (define (send-connect)
        (with-write-mutex self
          (lambda ()
            (with-record connect
              (let ((data (make-u8vector (+ (calculate-connect-size) udp-code-size))))
                (write-header-kind data udp-connect)
                (write-header-sender data client-no)
                (write-connect-sent data (current-seconds))
                (write-connect-upload-level data (or (video-upload-level) -1))
                (write-connect-download-level data (or (video-download-level) -1))
                (write-udp-code data)
                (write-data data udp-port))))))
      
      (set! server-host #f)
      (set! server-port #f)
      (set! monitor (new UDP-Monitor))
      (set! statistics (new UDP-Statistics))
      (set! upload-mutex (make-mutex 'connection))
      (set! upload-state (new UDP-Connection-State))
      (set! upload-rate (new UDP-Rate-Sample))
      (set! upload-congestion (new UDP-Congestion))
      (init upload-congestion upload-state udp-datagram-max)
      (set! upload-queue (new Priorities-Queue 2))
      (set! upload-done? #f)
      (set! simulator #f)
      (when record-events?
        (record-event udp-id-connecting
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.
                      -1.))
      (let ()
        (declare (proper-tail-calls))
        (let (loop (n 0))
          (define (read-udp)
            (input-port-timeout-set! udp-port .01)
            (prog1 (read udp-port)
              (input-port-timeout-set! udp-port +inf.0)))
          
          (send-connect)
          (let ((reply (read-udp)))
            (with-record connected
              (if (or (eof-object? reply) (/= (read-header-kind reply) udp-connected))
                  (if (>= n 500)
                      (begin
                        (terminal 'BAILOUT 'did 'not 'receive 'udp-connected 'from 'server)
                        (exit 1))
                    (loop (+ n 1)))
                (let ((source-info (udp-source-socket-info udp-port)))
                  (set! server-host (socket-info-address source-info))
                  (set! server-port (socket-info-port-number source-info)))
                (when record-events?
                  (record-event udp-id-connected
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.
                                -1.))
                (set! live-task (new Task '(live server) (~ run-live self) priority: live-priority))
                (set! awake-task (new Task 'awake (~ run-awake self) priority: awake-priority))
                (set! receive-task (new Task 'receive (~ run-receive self) priority: receive-priority))
                (start-task live-task)
                (start-task awake-task)
                (start-task receive-task)))))))))

  
  (method (deconnect self)
    (set! udp-stopping? #t)
    (stop-task live-task)
    (set! live-task #f)
    (stop-task awake-task)
    (set! awake-task #f)
    (close-port udp-port)
    (thread-join! (get-thread receive-task))
    (set! udp-port #f)
    (set! receive-task #f))
  
  
  (method (start self)
    (unless started?
      (unless (simulation?)
        (set! upload-done? #f)
        (set! upload-task (new Task 'upload (~ run-upload self) priority: upload-priority))
        (start-task upload-task)
        (set! state-task (new Task 'state (~ run-state self) priority: state-priority))
        (start-task state-task)
        (set! heartbeat-task (new Task 'heartbeat (~ run-heartbeat self) priority: heartbeat-priority))
        (start-task heartbeat-task)
        (set! noack-ring (new Time-Ring 1))
        (set! noack-task (new Task 'noack (~ run-noack self) priority: noack-priority))
        (start-task noack-task)
        (schedule-noack self))
      (set! last-received-ack (current-seconds))
      (set! throttle-media? #f)
      (set! started? #t)))
  
  
  (method (stop self)
    (when started?
      (set! upload-done? #t)
      (thread-join! (get-thread upload-task))
      (set! upload-task #f)
      (stop-task state-task)
      (set! state-task #f)
      (stop-task heartbeat-task)
      (set! heartbeat-task #f)
      (terminate noack-ring)
      (thread-join! (get-thread noack-task))
      (set! noack-ring #f)
      (set! noack-task #f)
      (set! started? #f)))
  
  
  (method (with-write-mutex self thunk)
    (unwind-protect
        (begin
          (mutex-lock! write-mutex)
          (thunk))
      (mutex-unlock! write-mutex)))
  
  
  (method (snapshot-receive-streams self)
    (let ((info (map (lambda (stream)
                       (list (get-sender stream)
                             (get-name stream)
                             (get-source-kind stream)))
                     (table-values receive-streams))))
      (add-snapshot-property 'live.udp-receive info)))
  
  
  (method protected (new-simulator self)
    (new UDP-Simulator
         (lambda (data info drop?)
           (unless drop?
             (send-server self data)))))
  
  
  (method package (require-simulator self)
    (or simulator
        (let ((sim (new-simulator self)))
          (set! simulator sim)
          sim)))
  
  
  (method protected (increase-sent self data)
    (increase-sent monitor data))
  
  
  (method protected (increase-received self data)
    (increase-received monitor data))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (set! profile-pulse-sequence 0)
    (set! profile-media-sequence 0)
    (set! profile-last-sequence 0)
    (set! profile-monitor (new UDP-Monitor))
    (set! profile-statistics (new UDP-Statistics))
    (set! profile-chronology (new Chronology 0))
    (set! profile-evolution (new Evolution 10000)))
  
  
  (method package (retrieve-profile self)
    (let ((metadata (list client-no character-name '() '() (sites-metadata)))
          (chronology (copy-chronology profile-chronology))
          (evolution (copy-evolution profile-evolution)))
      (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
  
  
  (method package (stop-profile self)
    (set! profile-chronology #f)
    (set! profile-evolution #f))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (close-send-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-send-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (unregister-stream (current-client) stream-no)
      (table-clear send-streams stream-no)))
  
  
  (method package (close-send-streams self)
    (iterate-table send-streams
      (lambda (no stream)
        (close-send-stream self stream))))
  
  
  (method package (register-receive-stream self sender name stream-no origin source-kind video-level channels)
    (let ((stream (new UDP-Receive-Stream sender name stream-no origin source-kind video-level)))
      (for-each (lambda (info)
                  (bind (channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state) info
                    (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
                channels)
      (table-set! receive-streams stream-no stream)
      stream))
  
  
  (method public (find-receive-stream self stream-no)
    (table-ref receive-streams stream-no #f))
  
  
  (method package (close-receive-stream self stream)
    (iterate-table (get-channels stream)
      (lambda (no channel)
        (close-receive-channel self channel)))
    (let ((stream-no (get-no stream)))
      (close stream)
      (table-clear receive-streams stream-no)))
  
  
  (method package (close-receive-streams self)
    (iterate-table receive-streams
      (lambda (no stream)
        (with-locked-channels stream
          (lambda ()
            (close-receive-stream self stream))))))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method package (register-send-channel self stream-no channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (let ((stream (find-send-stream self stream-no)))
      (let ((channel (new UDP-Send-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
        (table-set! send-channels channel-no channel)
        channel)))
  
  
  (method package (close-send-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear send-channels channel-no)))
  
  
  (method public (find-receive-channel self channel-no)
    (table-ref receive-channels channel-no #f))
  
  
  (method package (register-receive-channel self stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (let ((channel (new UDP-Receive-Channel stream channel-no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)))
      (table-set! receive-channels channel-no channel)
      channel))
  
  
  (method package (close-receive-channel self channel)
    (let ((channel-no (get-no channel)))
      (close channel)
      (close-channel-output self channel)
      (table-clear receive-channels channel-no)))
  
  
  (method package (close-channel-output self channel)
    (let ((id (get-no channel))
          (kind (get-media-kind channel)))
      (ecase kind
        ((udp-audio)
         (let ((audio (current-audio)))
           (let ((output (get-output channel)))
             (when output
               (close-output audio id output)
               (close-empty-audio audio)))))
        ((udp-video)
         (let ((video (current-video)))
           (let ((output (get-output channel)))
             (when output
               (close-output video id output))))))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method package (send-media self channel-no buffer dts pts duration flags)
    (with-write-mutex self
      (lambda ()
        (let ((channel (find-send-channel self channel-no)))
          (when channel
            (let ((kind (get-media-kind channel)))
              (define (send)
                (send-media channel client-no buffer dts pts duration flags
                  (lambda (data)
                    (let ((priority (if (= kind udp-audio)
                                        0
                                      1)))
                      (upload-send self data priority)))))
              
              (define (advance-frame!)
                (let ((frame (next-frame-sequence! channel)))
                  (when record-events?
                    (record-event udp-id-throttle-frame
                                  (fixnum->flonum channel-no)
                                  (fixnum->flonum client-no)
                                  (fixnum->flonum kind)
                                  -1.
                                  (fixnum->flonum frame)
                                  -1.
                                  -1.))))
              
              (if (simulation?)
                  (send)
                (if throttle-media?
                    (advance-frame!)
                  (if (waiting-keyframe? channel)
                      (if (not (frame-keyframe? flags))
                          (advance-frame!)
                        (got-keyframe channel)
                        (send))
                    (let ((now (current-seconds)))
                      (if (and udp-throttle (> (- now last-received-ack) udp-throttle))
                          (begin
                            (set! throttle-media? #t)
                            (iterate-table send-channels
                              (lambda (no channel)
                                (wait-keyframe channel)))
                            (when record-events?
                              (record-event udp-id-throttle-on
                                            -1.
                                            (fixnum->flonum server-no)
                                            -1.
                                            -1.
                                            -1.
                                            -1.
                                            -1.)))
                        (send))))))))))))
  
  
  (method (send-state self)
    (define (collect-waiting)
      (let ((waiting '()))
        (iterate-table receive-channels
          (lambda (key channel)
            (when (eq? (get-source-kind channel) 'image)
              (let ((state (get-state (get-process-ring channel))))
                (when (eq? state 'wait)
                  (set! waiting (cons (get-no channel) waiting)))))))
        waiting))
    
    (let ((waiting (collect-waiting)))
      (when (not-null? waiting)
        (let ((now (current-seconds)))
          (when (or (not last-send-state)
                    (> now (+ last-send-state 1.)))
            (with-write-mutex self
              (lambda ()
                (with-record state
                  (let ((waiting (object->u8vector waiting)))
                    (let ((size (calculate-state-size waiting)))
                      (let ((data (make-u8vector (+ size udp-code-size))))
                        (write-header-kind data udp-state)
                        (write-header-sender data client-no)
                        (write-state-waiting data waiting)
                        (write-udp-code data)
                        (send-data self data)))))))
            (set! last-send-state now))))))
  
  
  (method protected (next-profile-pulse-sequence! self)
    (prog1 profile-pulse-sequence
      (increase! profile-pulse-sequence)))
  
  
  (method protected (next-profile-media-sequence! self)
    (prog1 profile-media-sequence
      (increase! profile-media-sequence)))
  
  
  (method package (send-profile-pulse self)
    (with-write-mutex self
      (lambda ()
        (with-record profile-pulse
          (let ((size (calculate-profile-pulse-size)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-profile-pulse)
              (write-header-sender data client-no)
              (write-profile-pulse-sent data (current-seconds))
              (write-profile-pulse-sequence data (next-profile-pulse-sequence! self))
              (write-profile-pulse-bytes-sent data (get-bytes-sent profile-monitor))
              (write-udp-code data)
              (send-data self data)
              (increase-sent profile-monitor data)
              data))))))
  
  
  (method package (send-profile-media self payload)
    (with-write-mutex self
      (lambda ()
        (with-record profile-media
          (let ((size (calculate-profile-media-size payload)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-profile-media)
              (write-header-sender data client-no)
              (write-profile-media-sequence data (next-profile-media-sequence! self))
              (write-profile-media-payload data payload)
              (write-udp-code data)
              (send-data self data)
              (increase-sent profile-monitor data)
              data))))))
  
  
  (method (send-data self data)
    (if simulator
        (send simulator data #f)
      (send-server self data))
    (increase-sent self data))
  
  
  (method (send-server self data)
    ;; quick temporary hack to get back the safe behavior
    ;; of retrying-write until port being false is fixed
    (when udp-port
      (udp-destination-set! server-host server-port udp-port)
      (send-udp data udp-port)))
  
  
  ;;;
  ;;;; Upload
  ;;;
  
  
  (method (upload-send self data priority)
    (push upload-queue data priority))
  
  
  (method (receive-media-ack self data)
    (mutex-lock! upload-mutex)
    (with-record media-ack
      (let ((sequence (read-media-ack-order data)))
        (let ((packet-state (ack-received upload-state sequence)))
          (when packet-state
            (ack-received upload-rate upload-state packet-state)
            (ack-received upload-congestion upload-rate packet-state)
            (record-event udp-id-rate-sample
                          -1.
                          -1.
                          -1.
                          (fixnum->flonum sequence)
                          (bytes->mbps (get-delivery-rate upload-rate))
                          -1.
                          -1.)))))
    (mutex-unlock! upload-mutex))
  
  
  (method (upload-data self data)
    (with-record media
      (let ((sent (current-seconds))
            (sequence (next-media-order! self))
            (size (u8vector-length data)))
        (write-media-order data sequence)
        (send-data self data)
        (let ((packet-state (packet-sent upload-state sent sequence size)))
          (packet-sent upload-rate upload-state packet-state)
          (packet-sent upload-congestion)))))
  
  
  (method (pop-upload self)
    (pop upload-queue 0))
  
  
  (method (run-upload self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop (n 0) (data (pop-upload self)) (next (current-seconds)))
          (if upload-done?
              (continuation-return exit #f)
            (wake-upload self n data next loop))))))
  
  
  (method (wake-upload self n data next loop)
    (declare (proper-tail-calls))
    (define (wait size)
      (/ size (get-pacing-rate upload-congestion)))
    
    (define (pace next)
      (sleep (- next (current-seconds))))
    
    (mutex-lock! upload-mutex)
    (cond ;; no data
          ((eof-object? data)
           ;(terminal-string ".")
           (set-app-limited upload-state (+ (get-delivered upload-state) (get-inflight upload-state)))
           (pace next)
           (mutex-unlock! upload-mutex)
           (loop (+ n 1) (pop-upload self) (+ next .0001)))
          ;; data
          (else
           (let ((size (u8vector-length data)))
             (cond ;; exceeding congestion window
                   ((> (+ (get-inflight upload-state) size) (get-cwnd upload-congestion))
                    ;(terminal-string "$")
                    (pace next)
                    (mutex-unlock! upload-mutex)
                    (loop (+ n 1) data (+ next .0001)))
                   ;; send packet
                   (else
                    ;(terminal-string "^")
                    (upload-data self data)
                    (pace next)
                    (mutex-unlock! upload-mutex)
                    (loop (+ n 1) (pop-upload self) (+ next (wait size)))))))))
  
  
  (method package (upload-info self)
    (and (> (get-sent upload-state) 0)
         (let ((average-rtt (get-average (get-movingRTT upload-state)))
               (btlbw (get-btlbw upload-congestion))
               (pacing-rate (get-pacing-rate upload-congestion))
               (delivery-rate (get-delivery-rate upload-rate))
               (delivery-average (get-delivery-average upload-rate))
               (upload-rate (get-last-upload-rate statistics))
               (upload-drop (percentage (get-lost upload-state) (get-sent upload-state)) @w (get-upload-drop statistics))
               (delayed (size upload-queue))
               (limited? (get-app-limited? upload-rate)))
           (and average-rtt
                upload-rate
                upload-drop
                (format "RTT: {r precision: 3}s, btlbw: {r precision: 3}, Pacing: {r precision: 1}Mbps, Upload: {r precision: 1}Mbps, Delivery: {r precision: 1}Mbps, Drop: {r precision: 1}%, Delayed: {a}, Limited: {a}"
                        average-rtt
                        (bytes->mbps btlbw)
                        (bytes->mbps pacing-rate)
                        (bytes->mbps upload-rate)
                        (bytes->mbps delivery-rate)
                        upload-drop
                        delayed
                        (if limited? "Yes" "No"))))))
  
  
  ;;;
  ;;;; Live
  ;;;
  
  
  (method (run-live self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site live
                  (send-live self)))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task live-period duration exit))
              (iter time)))))))
  
  
  ;;;
  ;;;; Awake
  ;;;
  
  
  (method (run-awake self task <Task>)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-monotonic)))
          (let ((time (current-monotonic)))
            (let ((elapse (- time previous)))
              (unless (stopping? task)
                (site awake
                  (adjust-computer-sleep self)))
              (let ((duration (- (current-monotonic) time)))
                (task-wait task awake-period duration exit))
              (iter time)))))))
  
  
  (method (adjust-computer-sleep self)
    (if (not application-active?)
        ;; when in the background we let the os manage sleep and we
        ;; disconnect from group or circle when actually going to sleep
        (allow-computer-sleep)
      (let ((keep-awake? #f))
        ;; send
        (iterate-table send-channels
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio udp-video)
               (when (or (neq? (get-source-kind channel) 'live)
                         (on? channel))
                 (set! keep-awake? #t))))))
        ;; receive
        (iterate-table receive-channels
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio udp-video)
               (set! keep-awake? #t)))))
        ;; policy
        (if keep-awake?
            (prevent-computer-sleep)
          (allow-computer-sleep)))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method (run-state self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (site state
            (send-state self))
          (task-sleep task udp-state-period exit)
          (loop)))))
  
  
  ;;;
  ;;;; Heartbeat
  ;;;
  
  
  (method (run-heartbeat self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (site heartbeat
            (send-heartbeat self))
          (task-sleep task udp-heartbeat-period exit)
          (loop)))))
  
  
  ;;;
  ;;;; Noack
  ;;;
  
  
  (method (run-noack self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((proc (wait noack-ring)))
            (if (not proc)
                (continuation-return exit #f)
              (proc)
              (loop)))))))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (run-receive self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (loop)
          (let ((data (catch-exception-filter
                        (lambda (exc)
                          udp-stopping?)
                        (lambda (exc)
                          (continuation-return exit #f))
                        (lambda ()
                          (read-data udp-port)))))
            (when data
              (site receive
                (receive-data self data))
              (loop)))))))
  
  
  (method protected (receive-data self data)
    (if (or (< (u8vector-length data) 4)
            (/= (read-udp-code data) udp-code))
        (increase! invalid-packets)
      (increase-received self data)
      (let ((kind (with-record header
                    (read-header-kind data))))
        (if (not started?)
            (ecase kind
              ((udp-connected))
              ((udp-ack))
              ((udp-nack))
              ((udp-audio udp-video))
              ((udp-media-ack))
              ((udp-state))
              ((udp-reset))
              ((udp-live-ack)
               (receive-live-ack self data))
              ((udp-profile-ack)
               (receive-profile-ack self data))
              ((udp-profile-pulse))
              ((udp-profile-media)
               (receive-profile-media self data))
              ((udp-profile-media-ack)
               (receive-profile-media-ack self data))
              (else
               (error "Unknown UDP kind: {s}" kind)))
          (ecase kind
            ((udp-connected))
            ((udp-ack)
             (receive-ack self data))
            ((udp-nack)
             (receive-nack self data))
            ((udp-audio udp-video)
             (receive-medias self kind data))
            ((udp-media-ack)
             (receive-media-ack self data))
            ((udp-state)
             (receive-state self data))
            ((udp-reset)
             (receive-reset self data))
            ((udp-live-ack)
             (receive-live-ack self data))
            ((udp-profile-ack))
            ((udp-profile-pulse))
            ((udp-profile-media))
            (else
             (error "Unknown UDP kind: {s}" kind)))))))
  
  
  (method (receive-ack self data)
    (with-record ack
      (let ((now (current-seconds))
            (sender (read-header-sender data))
            (heartbeat-sent (read-ack-heartbeat-sent data))
            (heartbeat-sequence (read-ack-heartbeat-sequence data))
            (heartbeat-bytes-sent (read-ack-heartbeat-bytes-sent data)))
        ;; statistics
        (let ((ack-sent (read-ack-sent data))
              (server-bytes-sent (read-ack-bytes-sent data))
              (server-bytes-received (read-ack-bytes-received data))
              (server-missed-media-packets (read-ack-missed-media-packets data))
              (round-trip (- now heartbeat-sent)))
          (let ((variance (abs (- (- now last-received-ack) .1))))
            (if (>= variance .01)
                (set! stable-received-acks 0)
              (increase! stable-received-acks)
              (when (>= stable-received-acks 3)
                (cond ((not moving-round-trip)
                       (set! moving-round-trip round-trip)
                       (set! stable-round-trip round-trip))
                      (else
                       (set! moving-round-trip (/ (+ (* moving-round-trip 7.) round-trip) 8.))
                       (when (> (abs (- moving-round-trip stable-round-trip)) round-trip-tolerance)
                         (set! stable-round-trip moving-round-trip)))))))
          (update statistics now monitor round-trip heartbeat-sequence heartbeat-bytes-sent server-bytes-sent server-bytes-received server-missed-media-packets)
          (when record-events?
            (record-event udp-id-receive-ack
                          -1.
                          (fixnum->flonum sender)
                          -1.
                          (fixnum->flonum heartbeat-sequence)
                          round-trip
                          heartbeat-sent
                          ack-sent))
          (when record-events?
            (let ((last-upload-rate (get-last-upload-rate statistics))
                  (last-download-rate (get-last-download-rate statistics)))
              (unless (= last-upload-rate -1.)
                (record-event udp-id-traffic-rate
                              -1.
                              (fixnum->flonum sender)
                              -1.
                              (fixnum->flonum heartbeat-sequence)
                              -1.
                              last-upload-rate
                              last-download-rate)))))
        ;; throttle
        (received-ack throttle heartbeat-sent heartbeat-sequence statistics
          (lambda (adjustment reason)
            (delay-throttle-upload self adjustment reason))
          (lambda (profile)
            (delay-event
              (lambda ()
                (set-download-profile profile)
                (download-profile-update)
                (when profile-changed-hook
                  (profile-changed-hook profile))))))
        (schedule-noack self)
        ;; throttling
        (set! last-received-ack now)
        (when throttle-media?
          (set! throttle-media? #f)
          ;; force camera reset
          ;; (maybe-reset-media self server-no udp-video #f)
          (when record-events?
            (record-event udp-id-throttle-off
                          -1.
                          (fixnum->flonum server-no)
                          -1.
                          (fixnum->flonum heartbeat-sequence)
                          -1.
                          -1.
                          -1.))))))
  
  
  (method (noack-receive self)
    (noack-received throttle statistics
      (lambda (adjustment reason)
        (delay-throttle-upload self adjustment reason)))
    (schedule-noack self))
  
  
  (method (delay-throttle-upload self adjustment reason)
    (delay-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (client?)
              (throttle-upload (current-client))
              (when record-events?
                (record-event udp-id-throttle-upload
                              -1.
                              -1.
                              -1.
                              adjustment
                              reason
                              -1.
                              -1.))))))))
  
  
  (method (schedule-noack self)
    (let ((time (+ (current-seconds) noack-delay)))
      (when (or (not noack-time)
                (> time noack-time))
        (set! noack-time time)
        (empty noack-ring)
        (insert noack-ring noack-time (lambda ()
                                        (noack-receive self))))))
  
  
  (method (receive-nack self data)
    (with-record nack
      (let ((sender (read-header-sender data))
            (channel-no (read-nack-channel data))
            (start (read-nack-start data))
            (gap (read-nack-gap data)))
        (send-missing self sender channel-no start gap))))
  
  
  ;; receive and reorder all available packets
  (method protected (receive-medias self kind data)
    (declare (proper-tail-calls))
    (with-record media
      (let ((no (read-media-channel data)))
        ;; so a sequence of one doesn't allocate a pair
        (let (loop (ordered #f))
          (define (receive)
            (resend-nacks self)
            (if (not ordered)
                (receive-media self kind data)
              (for-each (lambda (data)
                          (receive-media self kind data))
                        ordered)))
          
          (input-port-timeout-set! udp-port 0)
          (let ((next (read udp-port)))
            (input-port-timeout-set! udp-port +inf.0)
            (cond ((eof-object? next)
                   (receive))
                  ((and (= (read-header-kind next) kind)
                        (= (read-media-channel next) no))
                   (increase-received self next)
                   (loop (add-ordered! next (or ordered (list data)) key: (lambda (data)
                                                                            (read-media-sequence data)))))
                  (else
                   (receive)
                   (receive-data self next))))))))
  
  
  (method protected (receive-media self kind data)
    (with-record media
      (let ((channel-no (read-media-channel data)))
        (let ((channel (find-receive-channel self channel-no)))
          (when channel
            (let ((ring (get-process-ring channel)))
              (with-mutex ring
                (lambda ()
                  (when (eq? (get-send-state channel) 'on)
                    (when (get-flow ring)
                      (remember-media channel data)
                      (insert-media channel data)))))))))))
  
  
  (method (send-missing self sender channel-no start gap)
    (let ((channel (find-send-channel self channel-no)))
      (when channel
        (let ((media-kind (get-media-kind channel))
              (ring (get-retain-ring channel)))
          (loop (for sequence from start below (+ start gap))
                (let ((data (locate-data ring sequence)))
                  (if data
                      (with-record media
                        (increase-media-resent data)
                        (send-data self data)
                        (when record-events?
                          (let ((frame (read-media-frame data)))
                            (record-event udp-id-resend-packet
                                          (fixnum->flonum channel-no)
                                          (fixnum->flonum sender)
                                          (fixnum->flonum media-kind)
                                          (fixnum->flonum sequence)
                                          (fixnum->flonum frame)
                                          -1.
                                          -1.))))
                    (when record-events?
                      (record-event udp-id-absent-packet
                                    (fixnum->flonum channel-no)
                                    (fixnum->flonum sender)
                                    (fixnum->flonum media-kind)
                                    (fixnum->flonum sequence)
                                    -1.
                                    -1.
                                    -1.)))))))))
  
  
  (method (receive-state self data)
    (with-record state
      (let ((waiting (u8vector->object (read-state-waiting data))))
        (for-each (lambda (channel-no)
                    (let ((channel (find-send-channel self channel-no)))
                      (when channel
                        (reset-media channel))))
                  waiting))))
  
  
  (method (receive-reset self data)
    (with-record reset
      (let ((channel-no (read-reset-channel data)))
        (let ((channel (find-send-channel self channel-no)))
          (when channel
            (reset-media channel))))))
  
  
  (method (receive-live-ack self data)
    )
  
  
  (method (receive-profile-ack self data)
    (let ((include-download-rate?
            (if profile-ack-callback
                (profile-ack-callback data)
              #t)))
      (with-record profile-ack
        (let ((now (current-seconds)))
          (let ((ack-sent (read-profile-ack-sent data))
                (pulse-sent (read-profile-ack-pulse-sent data))
                (pulse-sequence (read-profile-ack-pulse-sequence data))
                (pulse-bytes-sent (read-profile-ack-pulse-bytes-sent data))
                (latency (read-profile-ack-latency data))
                (server-bytes-sent (read-profile-ack-bytes-sent data))
                (server-bytes-received (read-profile-ack-bytes-received data))
                (server-missed-media-packets 0)) ;; todo
            (let ((round-trip (- now pulse-sent)))
              (update profile-statistics now profile-monitor round-trip pulse-sequence pulse-bytes-sent server-bytes-sent server-bytes-received server-missed-media-packets)
              (parameterize ((simulation-evolution profile-evolution))
                ;; hack to plot latency
                (when record-events?
                  (record-event udp-id-insert-packet
                                (fixnum->flonum pulse-sequence)
                                (fixnum->flonum client-no)
                                (fixnum->flonum udp-audio)
                                -1.
                                -1.
                                -1.
                                latency))
                ;; hack to plot round trip
                (when record-events?
                  (record-event udp-id-receive-ack
                                -1.
                                (fixnum->flonum client-no)
                                -1.
                                (fixnum->flonum pulse-sequence)
                                round-trip
                                pulse-sent
                                ack-sent))
                (when record-events?
                  (let ((last-upload-rate (get-last-upload-rate profile-statistics))
                        (last-download-rate (get-last-download-rate profile-statistics)))
                    (unless (= last-upload-rate -1.)
                      ;; hack to plot upload
                      (record-event udp-id-traffic-rate
                                    -1.
                                    (fixnum->flonum client-no)
                                    -1.
                                    (fixnum->flonum pulse-sequence)
                                    -1.
                                    last-upload-rate
                                    (if include-download-rate?
                                        last-download-rate
                                      -1.))))))))))
      (increase-received profile-monitor data)))
  
  
  (method (receive-profile-media self data)
    (with-record profile-media
      (let ((sender (read-header-sender data))
            (sequence (read-profile-media-sequence data)))
        (when record-events?
          (when profile-last-sequence
            (let ((expected-sequence (+ profile-last-sequence 1)))
              (when (/= sequence expected-sequence)
                (parameterize ((simulation-evolution profile-evolution))
                  (loop (for seq from expected-sequence below sequence)
                        (record-event udp-id-lost-packet
                                      -1.
                                      (fixnum->flonum sender)
                                      (fixnum->flonum udp-profile-media)
                                      (fixnum->flonum seq)
                                      -1.
                                      -1.
                                      -1.)))))))
        (set! profile-last-sequence sequence)
        (increase-received profile-monitor data))))
  
  
  (method (receive-profile-media-ack self data)
    (when profile-media-ack-callback
      (profile-media-ack-callback data)))
  
  
  (method protected (next-heartbeat-sequence! self)
    (prog1 heartbeat-sequence
      ;; wrap around acceptable
      (if (= heartbeat-sequence max-heartbeat-sequence)
          (set! heartbeat-sequence 0)
        (increase! heartbeat-sequence))))
  
  
  (method (send-heartbeat self)
    (let ((heartbeat-sequence (next-heartbeat-sequence! self)))
      (with-write-mutex self
        (lambda ()
          (with-record heartbeat
            (let ((size (calculate-heartbeat-size)))
              (let ((data (make-u8vector (+ size udp-code-size))))
                (write-header-kind data udp-heartbeat)
                (write-header-sender data client-no)
                (write-heartbeat-sent data (current-seconds))
                (write-heartbeat-sequence data heartbeat-sequence)
                (write-heartbeat-bytes-sent data (get-bytes-sent monitor))
                (write-udp-code data)
                (send-data self data))))
          (when record-events?
            (record-event udp-id-send-heartbeat
                          -1.
                          (fixnum->flonum client-no)
                          -1.
                          (fixnum->flonum heartbeat-sequence)
                          -1.
                          -1.
                          -1.))))))
  
  
  (method override (send-nack self sender channel-no start gap ring)
    (with-write-mutex self
      (lambda ()
        (with-record nack
          (let ((size (calculate-nack-size)))
            (let ((data (make-u8vector (+ size udp-code-size))))
              (write-header-kind data udp-nack)
              (write-header-sender data client-no)
              (write-nack-channel data channel-no)
              (write-nack-start data start)
              (write-nack-gap data gap)
              (write-udp-code data)
              (send-data self data)
              (set! resending-nacks (cons data resending-nacks))))))))
  
  
  (method (resend-nacks self)
    (when (not-null? resending-nacks)
      (with-write-mutex self
        (lambda ()
          (for-each (lambda (data)
                      (send-data self data))
                    resending-nacks)
          (set! resending-nacks '())))))
  
  
  (method (send-live self)
    ;; keep clean during profile
    (unless profile-ack-callback
      (with-write-mutex self
        (lambda ()
          (with-record header
            (let ((size (calculate-live-size)))
              (let ((data (make-u8vector (+ size udp-code-size))))
                (write-header-kind data udp-live)
                (write-header-sender data client-no)
                (write-udp-code data)
                (send-data self data)))))))))


;;;
;;;; Receive Base
;;;


(definition stop-rising-grace <fx>
  (flonum->timestamp .1))

(definition plateau-grace <fx>
  (flonum->timestamp 1.))

(definition plateau-sampling <fx>
  (flonum->timestamp 2.))

(definition drop-minimum <fx>
  (flonum->timestamp 0.05))

(definition drop-into-bumps-minimum <fx>
  (flonum->timestamp 0.2))

(definition minimum-duration <fx>
  (flonum->timestamp .2))


(class UDP-Receive-Base extends UDP-Base
  
  
  (slot stream           getter generate)
  (slot media-kind       getter generate)
  (slot source-kind      getter generate)
  (slot rise-tolerance   getter generate)
  (slot last-raw-latency getter generate)
  (slot plateau-start    getter generate)
  (slot plateau-highest  getter generate)
  (slot state            getter generate)
  (slot ring             accessors generate)
  
  (slot contour-start                 getter generate)
  (slot contour-raw-latency      <fx> getter generate)
  (slot contour-latency          <fx> getter generate)
  (slot contour-last-raw-latency      getter generate)
  (slot contour-plateau-start         getter generate)
  (slot contour-plateau-highest       getter generate)
  (slot contour-state                 getter generate)
  (slot contour-history               getter generate)
  
  
  (method override (initialize self stream media-kind source-kind)
    (nextmethod self)
    (set! self.stream stream)
    (set! self.media-kind media-kind)
    (set! self.source-kind (if live-streaming? 'live source-kind))
    (set! self.rise-tolerance (if (= media-kind udp-audio) udp-audio-tolerance udp-video-tolerance))
    (set! self.last-raw-latency 0)
    (set! self.plateau-start 0)
    (set! self.plateau-highest #f)
    (set! self.state 'plateau)
    (reset-contour self))
  
  
  (method override (reset self)
    (nextmethod self)
    (set! self.last-raw-latency 0)
    (set! self.plateau-start 0)
    (set! self.plateau-highest #f)
    (set! self.state 'plateau)
    (reset-contour self))
  
  
  (method (reset-contour self)
    (set! self.contour-raw-latency 0)
    (set! self.contour-latency 0)
    (set! self.contour-last-raw-latency 0)
    (set! self.contour-plateau-start 0)
    (set! self.contour-plateau-highest #f)
    (set! self.contour-state 'plateau)
    (set! self.contour-history (new Windowed-History 30. 60)))
  
  
  (method protected virtual (voice-under-threshold? self)
    #t)
  
  
  (method (update-contour-base self local remote)
    (set! contour-start (current-seconds))
    (set! contour-raw-latency 0)
    (set! contour-latency 0)
    (set! contour-plateau-start local)
    (set! contour-plateau-highest #f))
  
  
  (method (update-contour self local remote raw)
    (define (reset-plateau)
      (set! contour-plateau-start local)
      (set! contour-plateau-highest #f))
    
    (define (record-plateau latency)
      (let ((latency (timestamp->flonum latency)))
        (record contour-history (current-seconds) latency)
        (record-event udp-id-contour-latency
                      -1.
                      -1.
                      (fixnum->flonum media-kind)
                      -1.
                      -1.
                      latency
                      -1.)))
    
    (set! contour-raw-latency raw)
    (case contour-state
      ((plateau)
       (cond ;; up
             ((> raw (+ contour-latency rise-tolerance))
              (set! contour-state 'rise)
              (set! contour-latency +inf.ts)
              (set! contour-last-raw-latency raw)
              (record-plateau raw))
             ;; extend
             ((>= raw (- contour-latency drop-minimum))
              (reset-plateau))
             ;; down
             ((>= local (+ contour-plateau-start plateau-grace))
              (when (or (not contour-plateau-highest)
                        (> raw contour-plateau-highest))
                (set! contour-plateau-highest raw))
              (let ((plateau-time (- local contour-plateau-start)))
                ;; fall
                (when (>= plateau-time plateau-sampling)
                  (set! contour-latency contour-plateau-highest)
                  (reset-plateau)
                  (record-plateau contour-latency))))))
      ((rise)
       (if (> raw contour-last-raw-latency)
           (set! contour-last-raw-latency raw)
         ;; plateau
         (set! contour-state 'plateau)
         (set! contour-latency (+ contour-last-raw-latency stop-rising-grace))
         (reset-plateau)
         (record-plateau contour-latency)))))
  
  
  (method override (update-time self local remote update-proc)
    (let ((new-base (- local remote)))
      (define (reset-plateau)
        (set! plateau-start local)
        (set! plateau-highest #f))
      
      (define (analyse-bumps target)
        (let ((now (current-seconds))
              ;; include slightly lower bumps
              (target (- (timestamp->flonum target) .05))
              (rising? #t)
              (total 0.)
              (count 0)
              (bumps 0))
          (let ((starting? (< (- now contour-start) 20.))
                (previous target))
            (iterate-window contour-history now
              (lambda (time latency)
                (cond ((>= latency previous)
                       (set! rising? #t))
                      (else
                       (when rising?
                         (let ((top previous))
                           (when (>= top target)
                             ;; skip first bump and average next 3
                             (when (and (> bumps 0) (< count 3))
                               (increase! total top)
                               (increase! count))
                             (increase! bumps))))
                       (set! rising? #f)))
                (set! previous latency)))
            (and (>= bumps (if starting? 2 3))
                 (flonum->timestamp (/ total (cast <fl> count)))))))
      
      (if (not base)
          (begin
            (set! base new-base)
            (set! raw-latency 0)
            (set! latency 0)
            (reset-plateau)
            (update-contour-base self local remote)
            (update-latency stream media-kind raw-latency latency)
            (update-proc raw-latency latency))
        (unless (eq? source-kind 'image)
          (let ((raw (- new-base base)))
            (set! raw-latency raw)
            (update-contour self local remote raw)
            (case state
              ((plateau)
               (cond ;; up
                     ((> raw (+ latency rise-tolerance))
                      (set! state 'rise)
                      (set! latency +inf.ts)
                      (set! last-raw-latency raw))
                     ;; extend
                     ((>= raw (- latency drop-minimum))
                      (reset-plateau))
                     ;; down
                     ((and (eq? source-kind 'live)
                           (>= local (+ plateau-start plateau-grace)))
                      (when (or (not plateau-highest)
                                (> raw plateau-highest))
                        (set! plateau-highest raw))
                      (let ((plateau-time (- local plateau-start)))
                        ;; fall
                        (when (and (>= plateau-time plateau-sampling)
                                   (voice-under-threshold? self))
                          (let ((bumps-average (analyse-bumps plateau-highest)))
                            (if bumps-average
                                (let ((drop (- latency bumps-average)))
                                  (when (>= drop drop-into-bumps-minimum)
                                    (set! latency bumps-average)))
                              (set! latency plateau-highest)))
                          (reset-plateau))))))
              ((rise)
               (if (> raw last-raw-latency)
                   (set! last-raw-latency raw)
                 ;; plateau
                 (set! state 'plateau)
                 (set! latency (+ last-raw-latency stop-rising-grace))
                 (reset-plateau))))
            ;; update
            (update-latency stream media-kind raw-latency latency)
            (update-proc raw-latency latency))))))
  
  
  (method override (update-past self local remote)
    (when (neq? source-kind 'live)
      (unless (eq? state 'rise)
        (let ((running-latency (running-time-latency self local remote)))
          (when (> running-latency (+ latency rise-tolerance))
            (set! latency running-latency)
            (set! state 'plateau)
            (set! plateau-start local)
            (set! plateau-highest #f)
            (update-past-latency stream media-kind latency))))))
  
  
  (method (running-time-latency self local remote)
    (- local (+ base remote)))
  
  
  (method override (effective-latency self)
    (media-latency stream media-kind))
  
  
  (method protected (latency-remote->local self latency remote) <fx>
    (+ base remote latency)))


(definition voice-threshold <fl>
  10.)


(class UDP-Audio-Base extends UDP-Receive-Base
  
  
  (method override (voice-under-threshold? self)
    (<= (voice-percentage ring) voice-threshold)))


(class UDP-Video-Base extends UDP-Receive-Base)


;;;
;;;; Receive Ring
;;;


(class UDP-Receive-Ring extends UDP-Ring
  
  
  (slot flow initialize #f accessors generate)
  @assert-mutex
  (slot flow initialize #f getter generate)
  
  
  @assert-mutex
  (method public (set-flow self fl)
    (assert-mutex self 'set-flow)
    (set! flow fl))
  
  
  (method override (local-timestamp self)
    ;; quick hack todo
    (and flow
    (running-time flow)))
  
  
  (method protected (determine-write-time self packet <UDP-Packet> latency <fx> process-window <fx>) <fx>
    (let ((dts (get-dts packet)))
      (let ((time (latency-remote->local time-base latency dts)))
        (+ time process-window)))))


;;;
;;;; Audio Ring
;;;


(definition audio-clock-resolution <fl>
  .01)


(definition not-ready-max-sleep <fl>
  .1)


(definition (not-ready-sleep mutex timeout)
  (mutex-unlock! mutex)
  (sleep (min not-ready-max-sleep timeout)))


(definition voice-size
  100)

(definition (make-windowed-voice)
  (new Windowed-Count voice-size))


(class UDP-Audio-Ring extends UDP-Receive-Ring
  
  
  (slot windowed-voice initialize (make-windowed-voice) getter generate)
  
  
  (method override (empty self)
    (nextmethod self)
    (set! windowed-voice (make-windowed-voice)))
  
  
  (method override (audio-added self packet)
    (record windowed-voice (if (has-voice? packet) 1 0)))
  
  
  (method protected (voice-percentage self)
    (percentage (get-count windowed-voice) voice-size))
  
  
  (method protected (process-audio self channel exit)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (wake-audio self channel exit loop-wait)))
  
  
  ;; separate function that can be evaluated until full debugged
  (method (wake-audio self channel exit loop-wait)
    (declare (proper-tail-calls))
    (if terminate?
        (continuation-return exit #f)
      (mutex-lock! mutex)
      ;; empty
      (if (= count 0)
          (begin
            (mutex-unlock! mutex wait-condvar)
            (loop-wait))
        (let ((latency (effective-latency time-base)))
          ;; rising
          (if (or (= latency +inf.ts)
                  ;; quick hack todo
                  (not flow))
              (begin
                (mutex-unlock! mutex wait-condvar audio-clock-resolution)
                (loop-wait))
            (let ((running-time (running-time flow))
                  (earliest <UDP-Packet> (vector-ref packets head)))
              (let ((write-time (determine-write-time self earliest latency (base-latency flow))))
                (let ((giveup-time (+ write-time udp-audio-giveup)))
                  (cond ;; giveup
                        ((>= running-time giveup-time)
                         (flush-earliest self)
                         (mutex-unlock! mutex)
                         (loop-wait))
                        ;; not ready
                        ((< running-time write-time)
                         (not-ready-sleep mutex (max audio-clock-resolution (timestamp->flonum (- write-time running-time))))
                         (loop-wait))
                        ;; frame
                        ((complete-frame? self)
                         (site process-audio
                           (receive (sender packet data) (extract-complete self)
                             (give-audio channel sender packet data (get-base time-base) latency)))
                         (mutex-unlock! mutex)
                         (loop-wait))
                        ;; not live wakeup on giveup
                        ((neq? source-kind 'live)
                         (mutex-unlock! mutex wait-condvar (timestamp->flonum (- giveup-time running-time)))
                         (loop-wait))
                        ;; live flush
                        (else
                         (flush-earliest self)
                         (mutex-unlock! mutex)
                         (loop-wait))))))))))))


;;;
;;;; Video Ring
;;;


(class UDP-Video-Ring extends UDP-Receive-Ring
  
  
  (method protected (state-play self)
    (unless (eq? state 'play)
      (set! state 'play)
      (thaw flow)
      (unless (emulation?)
        (when record-events?
          (record-event udp-id-state-play
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        -1.)))))
  
  
  (method protected (state-freeze self)
    (unless (eq? state 'freeze)
      (set! state 'freeze)
      (freeze flow)
      (unless (emulation?)
        (when record-events?
          (record-event udp-id-state-freeze
                        (fixnum->flonum no)
                        (fixnum->flonum origin)
                        (fixnum->flonum media-kind)
                        -1.
                        -1.
                        -1.
                        -1.)))))
  
  
  (method protected (process-video self channel exit)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (wake-video self channel exit loop-wait)))
  
  
  ;; separate function that can be evaluated until full debugged
  (method (wake-video self channel exit loop-wait)
    (declare (proper-tail-calls))
    (if terminate?
        (continuation-return exit #f)
      (mutex-lock! mutex)
      ;; empty
      (if (= count 0)
          (begin
            (mutex-unlock! mutex wait-condvar)
            (loop-wait))
        (let ((latency (effective-latency time-base)))
          ;; rising
          (if (or (= latency +inf.ts)
                  ;; quick hack todo
                  (not flow))
              (begin
                (mutex-unlock! mutex wait-condvar .01)
                (loop-wait))
            @assert-mutex
            (assert-mutex self 'wake-video)
            (let ((running-time (running-time flow))
                  (earliest <UDP-Packet> (vector-ref packets head)))
              (let ((write-time (determine-write-time self earliest latency (base-latency flow))))
                (let ((late-time (+ write-time udp-video-late))
                      (giveup-time (+ write-time udp-video-giveup)))
                  (cond ;; giveup
                        ((>= running-time giveup-time)
                         (flush-earliest self)
                         (state-wait self)
                         (mutex-unlock! mutex)
                         (loop-wait))
                        ;; wait
                        ((eq? state 'wait)
                         (let ((keyframe (complete-keyframe self)))
                           (cond ;; keyframe
                                 (keyframe
                                  (let ((packet (packet-ref self keyframe)))
                                    (let ((packet-write (determine-write-time self packet latency udp-video-process)))
                                      (cond ;; not ready
                                            ((< running-time packet-write)
                                             (not-ready-sleep mutex (timestamp->flonum (- packet-write running-time)))
                                             (loop-wait))
                                            ;; ready
                                            (else
                                             (flush-before self keyframe)
                                             (state-ok self)
                                             (mutex-unlock! mutex)
                                             (loop-wait))))))
                                 ;; no keyframe
                                 (else
                                  (mutex-unlock! mutex wait-condvar (timestamp->flonum (- giveup-time running-time)))
                                  (loop-wait)))))
                        ;; not ready
                        ((< running-time write-time)
                         (not-ready-sleep mutex (timestamp->flonum (- write-time running-time)))
                         (loop-wait))
                        ;; frame
                        ((complete-frame? self)
                         (cond ;; ontime
                               ((< running-time late-time)
                                (state-play self))
                               ;; late
                               (else
                                (state-freeze self)))
                         (site process-video
                           (receive (sender packet data) (extract-complete self)
                             (give-video channel sender packet data (get-base time-base) latency)))
                         (mutex-unlock! mutex)
                         (loop-wait))
                        ;; wakeup on late
                        ((< running-time late-time)
                         (mutex-unlock! mutex wait-condvar (timestamp->flonum (- late-time running-time)))
                         (loop-wait))
                        ;; wakeup on giveup
                        (else
                         (let ((keyframe (complete-keyframe self)))
                           ;; use keyframe if available
                           (cond (keyframe
                                  (flush-before self keyframe)
                                  (mutex-unlock! mutex)
                                  (loop-wait))
                                 (else
                                  (mutex-unlock! mutex wait-condvar (timestamp->flonum (- giveup-time running-time)))
                                  (loop-wait)))))))))))))))


;;;
;;;; Receive Stream
;;;


(class UDP-Receive-Stream extends UDP-Stream
  
  
  (slot latency-mutex           initialize (make-mutex 'latency) getter generate)
  (slot audio-on?               initialize #t getter generate)
  (slot audio-time        <fl+> initialize #f getter generate)
  (slot audio-raw         <fx+> initialize #f getter generate)
  (slot audio-latency     <fx+> initialize #f getter generate)
  (slot video-time        <fl+> initialize #f getter generate)
  (slot video-raw         <fx+> initialize #f getter generate)
  (slot video-latency     <fx+> initialize #f getter generate)
  (slot moving-base       <fl+> initialize #f getter generate)
  (slot base              <fx+> initialize #f getter generate)
  (slot video-placeholder       initialize #f accessors generate)
  
  
  (method override (initialize self sender name no origin source-kind video-level)
    (nextmethod self sender name no origin source-kind video-level)
    (when live-streaming?
      (set! self.source-kind 'live)))
  
  
  (method protected (with-locked-channels self thunk (media-kind #f))
    (iterate-table channels
      (lambda (no channel)
        (when (or (not media-kind)
                  (= media-kind (get-media-kind channel)))
          (mutex-lock! (get-mutex (get-process-ring channel))))))
    (unwind-protect (thunk)
      (iterate-table channels
        (lambda (no channel)
          (when (or (not media-kind)
                    (= media-kind (get-media-kind channel)))
            (mutex-unlock! (get-mutex (get-process-ring channel))))))))
  
  
  (method protected (media-on self media-kind)
    (mutex-lock! latency-mutex)
    (when (= media-kind udp-audio)
      (set! audio-on? #t))
    (mutex-unlock! latency-mutex))
  
  
  (method protected (media-off self media-kind)
    (mutex-lock! latency-mutex)
    (when (= media-kind udp-audio)
      (set! audio-on?     #f)
      (set! audio-time    #f)
      (set! audio-raw     #f)
      (set! audio-latency #f)
      (set! moving-base   #f)
      (set! base          #f))
    (mutex-unlock! latency-mutex))
  
  
  (method protected (reset-video-latency self)
    (mutex-lock! latency-mutex)
    (set! video-time    #f)
    (set! video-raw     #f)
    (set! video-latency #f)
    (set! moving-base   #f)
    (set! base          #f)
    (mutex-unlock! latency-mutex))
  
  
  (method protected (update-latency self media-kind raw-latency latency)
    (mutex-lock! latency-mutex)
    (let ((now (current-seconds)))
      (define (update-base)
        (when (< (abs (- audio-time video-time)) .01)
          (let ((fresh-base (- video-raw audio-raw)))
            (when (not base)
              (set! base fresh-base))
            (let ((fresh (timestamp->flonum fresh-base)))
              (if (not moving-base)
                  (set! moving-base fresh)
                (set! moving-base (/ (+ (* moving-base 63.) fresh) 64.)))))
          (when (> (abs (- moving-base (timestamp->flonum base))) .01)
            (set! base (flonum->timestamp moving-base)))))
      
      (ecase media-kind
        ((udp-audio)
         (set! audio-time now)
         (set! audio-raw raw-latency)
         (set! audio-latency latency)
         (when video-raw
           (update-base)))
        (else
         (set! video-time now)
         (set! video-raw raw-latency)
         (set! video-latency latency)
         (when audio-raw
           (update-base)))))
    (mutex-unlock! latency-mutex))
  
  
  (method protected (update-past-latency self media-kind latency)
    (mutex-lock! latency-mutex)
    (ecase media-kind
      ((udp-audio)
       (set! audio-latency latency))
      (else
       (set! video-latency latency)))
    (mutex-unlock! latency-mutex))
  
  
  (method protected (media-latency self media-kind)
    (mutex-lock! latency-mutex)
    (prog1 (if (neq? source-kind 'live)
               ;; non-live take max of audio and video
               (ecase media-kind
                 ((udp-audio)
                  (cond ((or (not video-latency)
                             (not base))
                         audio-latency)
                        ((= video-latency +inf.ts)
                         video-latency)
                        (else
                         (max (- video-latency base)
                              audio-latency))))
                 (else
                  (cond ((or (not audio-latency)
                             (not base))
                         video-latency)
                        ((= audio-latency +inf.ts)
                         audio-latency)
                        (else
                         (max (+ audio-latency base)
                              video-latency)))))
             ;; live slave video to audio
             (ecase media-kind
               ((udp-audio)
                audio-latency)
               (else
                (cond ((or (not audio-on?)
                           (not base))
                       video-latency)
                      ((= audio-latency +inf.ts)
                       audio-latency)
                      (else
                       (+ audio-latency base))))))
      (mutex-unlock! latency-mutex))))


;;;
;;;; Receive Channel
;;;


(definition protected max-audio-gap
  5)


(class UDP-Receive-Channel extends UDP-Channel
  
  
  (slot process-ring                    getter generate)
  (slot process-task                    getter generate)
  (slot replay-ring                     getter generate)
  (slot insert-rate-frame               getter generate)
  (slot insert-rate                     getter generate)
  (slot process-rate                    getter generate)
  (slot expected-pts      initialize #f getter generate)
  
  
  (method override (initialize self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (nextmethod self stream no media-kind source-kind level resolution framerate bitrate codec caps metadata send-state)
    (set! self.replay-ring (and (developer?) record-media? (remember-ring media-kind source-kind level framerate)))
    (let ((time-base (cond ((simulation?)
                            (new UDP-Visualizer-Base))
                           ((= media-kind udp-audio)
                            (new UDP-Audio-Base stream media-kind source-kind))
                           (else
                            (new UDP-Video-Base stream media-kind source-kind)))))
      (set! self.process-ring (ecase media-kind
                                ((udp-audio)
                                 (new UDP-Audio-Ring self no (get-origin stream) media-kind source-kind udp-process-size max-size: udp-process-max-size time-base: time-base overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
                                (else
                                 (new UDP-Video-Ring self no (get-origin stream) media-kind source-kind udp-process-size max-size: udp-process-max-size time-base: time-base overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))))
      (unless (simulation?)
        (set-ring time-base self.process-ring)))
    (unless (simulation?)
      (set! self.process-task (if (= media-kind udp-audio)
                                  (new Task (list 'process-audio (determine-channel-name self)) (~ run-process-audio self) priority: process-audio-priority)
                                (new Task (list 'process-video (determine-channel-name self) level) (~ run-process-video self) priority: process-video-priority))))
    (set! self.insert-rate-frame 0)
    (set! self.insert-rate (new Rate))
    (set! self.process-rate (new Rate))
    (unless (simulation?)
      (start-task process-task)))
  
  
  (method override (destroy self)
    @assert-mutex
    (assert-mutex self 'destroy)
    (terminate process-ring)
    (let ((mutex (get-mutex process-ring)))
      (mutex-unlock! mutex)
      (thread-join! (get-thread process-task))
      (mutex-lock! mutex))
    (nextmethod self))
  
  
  @assert-mutex
  (method protected (assert-mutex self tag)
    (assert process-ring
      (assert-mutex process-ring tag)))
  
  
  (method override (receiver? self)
    #t)
  
  
  (method protected (remember-media self data)
    (when replay-ring
      (remember replay-ring data)))
  
  
  (method protected (insert-media self data)
    (with-record media
      (let ((frame (read-media-frame data)))
        (when (or (not insert-rate-frame)
                  (> frame insert-rate-frame))
          (update insert-rate)
          (set! insert-rate-frame frame))))
    (insert-unlocked process-ring data #f))
  
  
  (method protected (channel-on self)
    (set! send-state 'on))
  
  
  (method protected (channel-off self)
    (set! send-state 'off)
    (reset self))
  
  
  (method override (reset self)
    (reset process-ring)
    (set! expected-pts #f)
    (when output
      (reset output)))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (run-process-audio self task)
    (with-task task
      (lambda (exit)
        (process-audio process-ring self exit))))
  
  
  (method (run-process-video self task)
    (with-task task
      (lambda (exit)
        (process-video process-ring self exit))))
  
  
  (method (record-play-frame self sender frame flags dts pts)
    (when record-play?
      (record-event udp-id-play-frame
                    (fixnum->flonum no)
                    (fixnum->flonum sender)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (fixnum->flonum flags)
                    (timestamp->flonum dts))))
  
  
  (method (record-freeze-frame self sender frame flags dts pts)
    (when record-play?
      (record-event udp-id-freeze-frame
                    (fixnum->flonum no)
                    (fixnum->flonum sender)
                    (fixnum->flonum media-kind)
                    -1.
                    (fixnum->flonum frame)
                    (fixnum->flonum flags)
                    (timestamp->flonum dts))))
  

  (method protected (give-audio self sender packet buffer base latency)
    (let ((frame (get-frame packet))
          (dts (get-dts packet))
          (pts (get-pts packet))
          (duration (get-duration packet))
          (flags (get-flags packet)))
      (let ((dts (max 0 (+ dts latency)))
            (pts (max 0 (+ pts latency))))
        (define (receive)
          (receive-audio (current-audio) output buffer dts pts duration base)
          (set! expected-pts (+ pts duration)))
        
        (define (receive-gap pts duration)
          (receive-audio (current-audio) output #f pts pts duration base))
        
        (cond ;; perfect timestamp
              ((or (not expected-pts)
                   (= pts expected-pts))
               (receive))
              ;; generate gap for opus packet loss concealment
              ((> pts expected-pts)
               (let ((gap (- pts expected-pts)))
                 (when (< gap udp-audio-mixer)
                   (receive-gap expected-pts gap)))
               (receive))
              ;; do not send decreasing timestamps
              ))
      (when recorder
        (world.recording:record-media recorder buffer dts pts duration flags))
      (record-play-frame self sender frame flags dts pts)))
  
  
  (method protected (give-video self sender packet buffer base latency)
    (let ((frame (get-frame packet))
          (total (get-total packet))
          (dts (get-dts packet))
          (pts (get-pts packet))
          (duration (get-duration packet))
          (flags (get-flags packet)))
      (let ((dts (max 0 (+ dts latency)))
            (pts (max 0 (+ pts latency))))
        (receive-video (current-video) output buffer dts pts duration flags base))
      (when recorder
        (world.recording:record-media recorder buffer dts pts duration flags))
      (update process-rate)
      (if (eq? (get-state process-ring) 'late)
          (record-freeze-frame self sender frame flags dts pts)
        (record-play-frame self sender frame flags dts pts))))))
