;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client UDP
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.udp jazz


(import (jazz.io)
        (jazz.network)
        (jazz.presence)
        (world)
        (world.context)
        (world.evolution)
        (world.player)
        (world.ring)
        (world.settings)
        (world.udp))


(definition udp-video-action
  (world-setting 'world.udp-video-action #f))

(definition udp-video-file
  {File Home "video.mpj"})

(definition udp-video-port
  #f)


(class UDP-Client extends Object
  
  
  (slot udp-port         initialize #f getter generate)
  (slot udp-thread       initialize #f getter generate)
  (slot udp-stopping?    initialize #f getter generate)
  (slot write-mutex      initialize #f getter generate)
  (slot send-channels    initialize #f getter generate)
  (slot receive-channels initialize #f getter generate)
  
  
  (method (connect self local-host host service)
    (define (send-connect)
      (mutex-lock! write-mutex)
      (let ((data (make-u8vector 4)))
        (write-udp-kind data udp-connect)
        (write data udp-port))
      (mutex-unlock! write-mutex))
    
    (set! udp-port (open-udp (list
                               local-address: local-host
                               address: host
                               port-number: service)))
    (set! udp-thread (new-thread
                       (lambda ()
                         (process self))
                       'udp))
    (set! udp-stopping? #f)
    (set! write-mutex (make-mutex 'write))
    (set! send-channels (make-table))
    (set! receive-channels (make-table))
    (send-connect)
    (thread-start! udp-thread))

  
  (method (disconnect self)
    (set! udp-stopping? #t)
    (close-port udp-port)
    (thread-join! udp-thread)
    (set! udp-port #f)
    (set! udp-thread #f))
  
  
  ;;;
  ;;;; Channel
  ;;;
  
  
  (method (require-send-channel self kind origin)
    (let ((key (cons kind origin)))
      (or (table-ref send-channels key #f)
          (let ((channel (new UDP-Client-Send-Channel kind origin)))
            (table-set! send-channels key channel)
            channel))))
  
  
  (method (require-receive-channel self kind origin)
    (let ((key (cons kind origin)))
      (or (table-ref receive-channels key #f)
          (let ((channel (new UDP-Client-Receive-Channel kind origin)))
            (table-set! receive-channels key channel)
            channel))))
  
  
  ;;;
  ;;;; Send
  ;;;
  
  
  (method (send-audio self buffer timestamp duration)
    (send-media self udp-audio buffer timestamp duration))
  
  
  (method (send-video self buffer timestamp duration)
    (send-media self udp-video buffer timestamp duration))
  
  
  (method (send-media self kind buffer timestamp duration)
    (mutex-lock! write-mutex)
    (let ((origin (get-client-no (current-tier))))
      (when udp-video-action
        (let ((key (cons kind origin)))
          (cond ((and buffer (not (table-ref send-channels key #f)))
                 (set! udp-video-port (case udp-video-action
                                        ((record)
                                         (open-output-file (path-settings udp-video-file)))
                                        ((play)
                                         (open-input-file (path-settings udp-video-file))))))
                ((and (not buffer) (table-ref send-channels key #f))
                 (when udp-video-port
                   (close-port udp-video-port)
                   (set! udp-video-port #f))))))
      (let ((channel (require-send-channel self kind origin)))
        ;; quick hack to give media off a timestamp
        (let ((last-timestamp (or (get-last-timestamp channel) 0)))
          (let ((off? (not buffer))
                (frame (next-frame-sequence! channel))
                (timestamp (or timestamp (+ last-timestamp 1)))
                (duration (or duration 1))
                (buffer (or buffer udp-media-off)))
            (set-last-timestamp channel timestamp)
            (let ((header-size (+ 4 4 4 4 4 4 8 8 4))
                  (payload-size (u8vector-length buffer)))
              (let ((max-content-size (- udp-datagram-max header-size)))
                (let ((total (fxceiling/ payload-size max-content-size)))
                  (let (loop (part 0) (pos 0))
                    (let ((remain (- payload-size pos)))
                      (when (> remain 0)
                        (let ((sequence (next-data-sequence! channel))
                              (content-size (min remain max-content-size)))
                          (let ((size (+ header-size content-size)))
                            (let ((data (make-u8vector size)))
                              (write-udp-kind data kind)
                              (write-udp-origin data origin)
                              (write-udp-sequence data sequence)
                              (write-udp-frame data frame)
                              (write-udp-part data part)
                              (write-udp-total data total)
                              (write-udp-timestamp data timestamp)
                              (write-udp-duration data duration)
                              (write-udp-subpayload data buffer pos content-size)
                              (when udp-video-port
                                (case udp-video-action
                                  ((record)
                                   (write data udp-video-port)
                                   (newline udp-video-port)
                                   (force-output udp-video-port))
                                  ((play)
                                   (let ((obj (read udp-video-port)))
                                     (unless (eof-object? obj)
                                       (set! data obj))))))
                              (when (or (not udp-drop-percentage)
                                        (> (random-real) (/ udp-drop-percentage 100.)))
                                (write data udp-port))
                              (retain channel data)
                              (record-event udp-id-send-media
                                            (fixnum->flonum kind)
                                            (fixnum->flonum sequence)
                                            (if off? 0. 1.))
                              (loop (+ part 1) (+ pos content-size)))))))))))))))
    (mutex-unlock! write-mutex))
  
  
  ;;;
  ;;;; Receive
  ;;;
  
  
  (method (process self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((data (with-exception-filter
                    (lambda (exc)
                      udp-stopping?)
                    (lambda (exc)
                      #f)
                    (lambda ()
                      (read udp-port)))))
        (when data
          (receive-data self data)
          (loop)))))
  
  
  (method (receive-data self data)
    (let ((kind (read-udp-kind data)))
      (ecase kind
        ((udp-nack)
         (receive-nack self kind data))
        ((udp-audio udp-video)
         (receive-media self kind data))
        (else
         (error "Unknown UDP kind: {s}" kind)))))
  
  
  (method (receive-nack self kind data)
    (let ((media-kind (read-udp-nack-kind data))
          (origin (read-udp-origin data))
          (sequence (read-udp-sequence data)))
      (let ((channel (require-send-channel self media-kind origin)))
        (let ((ring (get-retain-ring channel)))
          (let ((found (locate ring (lambda (data)
                                      (= (read-udp-sequence data) sequence)))))
            (record-event udp-id-receive-nack
                          (fixnum->flonum media-kind)
                          (fixnum->flonum sequence)
                          (if found 1. 0.))
            (if found
                (write found udp-port)
              (terminal remote-name (udp-name media-kind) '***nack-missing*** sequence)))))))
  
  
  (method (receive-media self kind data)
    (let ((origin (read-udp-origin data))
          (sequence (read-udp-sequence data)))
      (let ((channel (require-receive-channel self kind origin)))
        (unless (member? sequence (get-nack-sequences channel))
          (let ((last-sequence (get-receive-last-sequence channel)))
            (when last-sequence
              (let ((expected (+ last-sequence 1)))
                (when (> sequence expected)
                  (loop (for seq from expected below sequence)
                        (send-nack self origin seq kind)
                        (set-nack-sequences channel (cons seq (get-nack-sequences channel))))))))
          (set-receive-last-sequence channel sequence))
        (insert-media channel data))))
  
  
  (method (send-nack self origin sequence media-kind)
    (when udp-debug-nack?
      (terminal remote-name (udp-name media-kind) 'send-nack sequence))
    (mutex-lock! write-mutex)
    (let ((size (+ 4 4 4 4)))
      (let ((data (make-u8vector size)))
        (write-udp-kind data udp-nack)
        (write-udp-origin data origin)
        (write-udp-sequence data sequence)
        (write-udp-nack-kind data media-kind)
        (write data udp-port)))
    (mutex-unlock! write-mutex)))


;;;
;;;; Client Send Channel
;;;


(class UDP-Client-Send-Channel extends UDP-Send-Channel
  
  
  (slot data-sequence  accessors generate)
  (slot frame-sequence accessors generate)
  (slot last-timestamp accessors generate)
  
  
  (method override (initialize self kind origin)
    (nextmethod self kind origin)
    (set! self.data-sequence 0)
    (set! self.frame-sequence 0)
    (set! self.last-timestamp #f))
  
  
  (method protected (next-data-sequence! self)
    (prog1 data-sequence
      (increase! data-sequence)))
  
  
  (method protected (next-frame-sequence! self)
    (prog1 frame-sequence
      (increase! frame-sequence))))


;;;
;;;; Client Receive Channel
;;;


(class UDP-Client-Receive-Channel extends UDP-Receive-Channel
  
  
  (slot process-last-sequence getter generate)
  (slot process-ring          getter generate)
  (slot process-thread        getter generate)
  
  
  (method override (initialize self kind origin)
    (nextmethod self kind origin)
    (set! self.process-last-sequence #f)
    ;; make it really big until time ring is a real ring
    (set! self.process-ring (new Time-Ring 40096 @w 512 @max-size: +inf.0 timestamp-proc: read-udp-timestamp now-proc: (~ now-timestamp self)))
    ;; development
    (set-$c self)
    (set-$r process-ring)
    (set! self.process-thread (new-thread
                                (lambda ()
                                  (process self))))
    (thread-start! process-thread))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method protected (insert-nack self data)
    )
  
  
  (method protected (insert-media self data)
    (insert-data self data))
  
  
  (method protected (insert-data self data)
    (let ((sequence (read-udp-sequence data)))
      (let ((nack? (member? sequence nack-sequences)))
        (when (and udp-debug-nack? nack?)
          (terminal remote-name (udp-name kind) 'insert-resent sequence))
        (unless nack?
          (update-time self data))
        (let ((inserted? (insert process-ring data)))
          (when (and udp-show-discard? (not inserted?))
            (let ((kind (read-udp-kind data))
                  (sequence (read-udp-sequence data)))
              (let ((label (if nack? '***discard-resent*** '***discard***)))
                (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name kind) label sequence))))))))
  
  
  (method protected (wait-data self)
    (wait process-ring))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (process self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((lst (wait-data self)))
        (process-missing self lst)
        (for-each (lambda (partition)
                    (bind (frame . datas) partition
                      (let ((unique-datas (remove-duplicates datas key: read-udp-sequence)))
                        (when (and udp-show-duplicates? (> (length datas) (length unique-datas)))
                          (let ((duplicates (difference datas unique-datas)))
                            (format :terminal "{s} {s} {s} {l}{%}" remote-name (udp-name kind) '***received-duplicates*** (map read-udp-sequence duplicates))))
                        (process-frame self (sort < unique-datas key: read-udp-sequence)))))
                  (sort < (partition lst key: read-udp-frame) key: car)))
      (loop)))
  
  
  (method (process-missing self lst)
    (let ((sorted (sort < lst key: read-udp-sequence)))
      (for-each (lambda (data)
                  (let ((sequence (read-udp-sequence data)))
                    (when (and udp-show-missing? process-last-sequence)
                      (let ((expected (+ process-last-sequence 1)))
                        (when (/= sequence expected)
                          (loop (for seq from expected below sequence)
                                (let ((label (if (member? seq nack-sequences) '***missing-resent*** '***missing***)))
                                  (format :terminal "{s} {s} {s} {s}{%}" remote-name (udp-name kind) label seq))))))
                    (set! process-last-sequence sequence)))
                sorted)))
  
  
  (method (process-frame self datas)
    (let ((received (length datas))
          (first (car datas)))
      (let ((kind (read-udp-kind first))
            (origin (read-udp-origin first))
            (sequence (read-udp-sequence first))
            (frame (read-udp-frame first))
            (part (read-udp-part first))
            (total (read-udp-total first))
            (timestamp (read-udp-timestamp first))
            (duration (read-udp-duration first)))
        (if (= total received)
            (if (= total 1)
                (process-data self kind origin sequence frame timestamp duration (read-udp-payload first))
              (let ((chunks (map read-udp-payload datas)))
                (let ((data (apply u8vector-append chunks)))
                  (process-data self kind origin sequence frame timestamp duration data))))
          @reported-by-process-missing
          (let ((missing (difference (naturals sequence (+ sequence total)) (map read-udp-sequence datas))))
            (format :terminal "{s} {s} {s} {s} {l}{%}" remote-name (udp-name kind) '***partial-frame*** 'missing missing))))))
  
  
  (method (process-data self kind origin sequence frame timestamp duration buffer)
    (define (player-no->id no)
      (get-id (find-player-by-no no)))
    
    (define (process-audio)
      (if (equal? buffer udp-media-off)
          (receive-server-audio (current-audio) (player-no->id origin) #f #f #f)
        (receive-server-audio (current-audio) (player-no->id origin) buffer timestamp duration)))
    
    (define (process-video)
      (if (equal? buffer udp-media-off)
          (receive-server-video (current-video) (player-no->id origin) #f #f #f)
        (receive-server-video (current-video) (player-no->id origin) buffer timestamp duration)))
    
    (ecase kind
      ((udp-audio)
       (process-audio))
      ((udp-video)
       (process-video))))))
