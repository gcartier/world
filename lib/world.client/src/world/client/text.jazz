;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier Text
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.client.text jazz


(import (jazz.action)
        (jazz.console)
        (jazz.editor.jazz)
        (jazz.event)
        (jazz.exemplar)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.markup)
        (jazz.moment)
        (jazz.network)
        (jazz.platform)
        (jazz.stream)
        (jazz.text)
        (jazz.zlib)
        (world)
        (world.asset)
        (world.audio)
        (world.circle)
        (world.client.request)
        (world.client.tier)
        (world.client.udp)
        (world.configure)
        (world.context)
        (world.evolution)
        (world.format)
        (world.interface)
        (world.interface.evolution)
        (world.interface.text)
        (world.platform)
        (world.record (phase syntax))
        (world.settings)
        (world.task)
        (world.udp))


;;;
;;;; Admin-Text
;;;


(class Admin-Text-View extends World-Text-View
  
  
  (slot inserted initialize (new Inserted))
  (slot banner   initialize #f getter generate)
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 8))
  
  
  (method override (new-syntax self)
    (new Jazz-Syntax model colorize?: #f))
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set-default-style model {Text-Style Entry})
    (set-propagate-styles? model #f)
    (set-colorize? syntax #f)
    (add-style self 'Banner           {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Dark-Green}})
    (add-style self 'Prompt           {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Dark-Ochre}})
    (add-style self 'Entry            {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Purple}})
    (add-style self 'Input            {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Purple}})
    (add-style self 'Output           {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color White}})
    (add-style self 'Header           {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    (add-style self 'Link             {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    (add-style self 'Err              {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Red}})
    (add-style self 'Error            {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Red}})
    (add-style self 'Log              {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin}})
    (add-style self 'LogNone          {Text-Style Log color: {Color White}})
    (add-style self 'LogFatalError    {Text-Style Log color: {Color Red}})
    (add-style self 'LogFatalCritical {Text-Style Log color: {Color Orange}})
    (add-style self 'LogFatalWarning  {Text-Style Log color: {Color Yellow}})
    (add-style self 'LogError         {Text-Style Log color: {Color Green}})
    (add-style self 'LogWarning       {Text-Style Log color: {Color Cyan}})
    (add-style self 'LogInfo          {Text-Style Log color: {Color Cyan}})
    (add-style self 'LogDebug         {Text-Style Log color: {Color Cyan}})
    (add-style self 'LogLog           {Text-Style Log color: {Color Cyan}})
    ;(add-style self 'Run-Read         {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Orange}})
    ;(add-style self 'Run-Walk         {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Orange}})
    ;(add-style self 'Run-Error        {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Red}})
    ;(add-style self 'Run-Result       {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    )
  
  
  (method override (focus-actions self)
    (cons (cache-admin-actions)
          (nextmethod self)))
  
  
  (method override (set-selection self range . rest)
    (apply nextmethod self range rest)
    (set-where inserted #f))
  
  
  (method override (backspace-allowed? self)
    (console-backspace-allowed? self))
  
  
  (method package (on-clear self evt)
    (let ((current (get-string self (current-command self))))
      (clear-console self)
      (reset inserted)
      (unless (empty-string? current)
        (insert-styled self current {Text-Style Entry}))))
  
  
  (method package (on-insert-previous self evt)
    (console-insert-previous-block self inserted))
  
  
  (method package (on-insert-next self evt)
    (console-insert-next-block self inserted))
  
  
  (method package (initial-banner self banner)
    (set! self.banner banner)
    (display-banner self))
  
  
  (method package (display-banner self)
    (insert-styled self banner 'Banner)
    (insert-newline self)
    (insert-newline self)
    (display-prompt self))
  
  
  (method package (display-prompt self)
    (insert-styled self "> " 'Prompt))
  
  
  (method override (return-press self evt)
    (console-return self
      (lambda ()
        (console-evaluate self))))

  
  (method (console-evaluate self (range #f))
    (let ((client (current-client))
          (world (current-world)))
      (set-caret self (text-ending self))
      (let ((range (or range (current-command self))))
        (define (match-error . rest)
          (new Error message: (apply format rest)))
        
        (define (boolean-type val)
          (if (boolean? val)
              val
            (match-error "Invalid boolean: {s}" val)))
        
        (define (string-type val)
          (if (string? val)
              val
            (match-error "Invalid string: {s}" val)))
        
        (define (strings-type val)
          (if (and (list? val)
                   (every? string? val))
              val
            (match-error "Invalid strings: {s}" val)))
        
        (define (int-type val)
          (if (integer? val)
              val
            (match-error "Invalid int: {s}" val)))
        
        (define (real-type val)
          (if (real? val)
              val
            (match-error "Invalid real: {s}" val)))
        
        (define (daytime-type val)
          (if (or (real? val)
                  (memq? val '(dawn day dusk night)))
              val
            (match-error "Invalid daytime: {s}" val)))
        
        (define (latency-type val)
          (if (or (real? val)
                  (symbol? val)
                  (pair? val))
              val
            (match-error "Invalid latency: {s}" val)))
        
        (define (identity-type val)
          (cond ((string? val)
                 val)
                ((symbol? val)
                 (symbol->string val))
                (else
                 (match-error "Invalid identity: {s}" val))))
        
        (define (invitation-type val)
          (cond ((string? val)
                 val)
                ((symbol? val)
                 (symbol->string val))
                (else
                 (match-error "Invalid invitation: {s}" val))))
        
        (define (key-type val)
          (if (uuid? val)
              val
            (match-error "Invalid key: {s}" val)))
        
        (define (machine-type val)
          (if (string? val)
              val
            (match-error "Invalid machine: {s}" val)))
        
        (define (type-type val)
          (if (or (not val)
                  (symbol? val))
              val
            (match-error "Invalid type: {s}" val)))
        
        (define (role-type val)
          (if (memq? val '(#f user explorer builder developer))
              val
            (match-error "Invalid role: {s}" val)))
        
        (define (who-type val)
          (cond ((eq? val 'me)
                 (get-character-name client))
                ((or (memq? val '(all server processor processors))
                     (string? val))
                 val)
                ((symbol? val)
                 (symbol->string val))
                (else
                 (match-error "Invalid who: {s}" val))))
        
        (define (client-type val)
          (cond ((eq? val 'me)
                 (get-character-name client))
                ((string? val)
                 val)
                ((symbol? val)
                 (symbol->string val))
                (else
                 (match-error "Invalid client: {s}" val))))
        
        (define (ring-type val)
          (if (memq? val '(evolution))
              val
            (match-error "Invalid ring: {s}" val)))
        
        (define (debugger-type val)
          (cond ((not val)
                 ":56000")
                ((string? val)
                 val)
                (else
                 (match-error "Invalid debugger: {s}" val))))
        
        (define types
          (list
            (list 'boolean boolean-type "#f #t")
            (list 'string string-type "\"string\"")
            (list 'strings strings-type "<list of strings>")
            (list 'int int-type "integer number")
            (list 'real real-type "real number")
            (list 'daytime daytime-type "<real-or-symbol>")
            (list 'delay real-type "<real>")
            (list 'duration real-type "<real>")
            (list 'drop real-type "<real>")
            (list 'latency latency-type "<real-or-latency>")
            (list 'name string-type "<string>")
            (list 'names string-type "<string>")
            (list 'user string-type "<string>")
            (list 'location string-type "<string>")
            (list 'identity identity-type "<string-or-symbol>")
            (list 'invitation invitation-type "<string-or-symbol>")
            (list 'key key-type "<uuid key>")
            (list 'machine machine-type "<string>")
            (list 'type type-type "#f <symbol>")
            (list 'role role-type "#f user explorer builder developer")
            (list 'email string-type "<string>")
            (list 'who who-type "all server processor processors me \"username\"")
            (list 'client client-type "me \"username\"")
            (list 'no int-type "<int>")
            (list 'count int-type "<int>")
            (list 'spacing real-type "<real>")
            (list 'ring ring-type "evolution")
            (list 'debugger debugger-type "\"host:port\"")))
       
        (define commands
          '((activity)
            (date)
            (dayduration (<duration>))
            (daytime (<daytime>))
            (disconnected)
            (drop <who> (<drop>))
            (identity list (<name>))
            (identity type (<type>))
            (identity show <identity>)
            (identity add <name> (type: <type>) (role: <role>) (admin?: <boolean>) (email: <email>))
            (identity create <names> (type: <type>) (role: <role>))
            (identity existing <key> <name> (type: <type>) (role: <role>) (admin?: <boolean>) (email: <email>))
            (identity modify <identity> (name: <name>) (type: <type>) (role: <role>) (admin?: <boolean>) (email: <email>))
            (identity verify <identity>)
            (identity upgrade <identity> <role>)
            (identity remove <identity>)
            (identity convert)
            (invitation list (<name>))
            (invitation show <invitation>)
            (invitation add <name> <name>)
            (invitation remove <invitation>)
            (kick <who>)
            (latency <who> (<latency>))
            (list profile)
            (list replay)
            (list simulation)
            (machine list (<user>))
            (machine caps <machine>)
            (machine features <machine>)
            (machine settings <machine>)
            (machine set <machine> <setting> <value>)
            (machine unset <machine> <setting>)
            (metadata)
            (problems)
            (request caps <who>)
            (request info <who>)
            (request monitor <who>)
            (request health <who>)
            (request energy <who>)
            (request moments <who>)
            (request settings <who>)
            (request capture <who>)
            (request uncapture <who>)
            (request retrieve <who>)
            (request evolution <who>)
            (request replay <who>)
            (request shared <who>)
            (request transfer <who> <location>)
            (request gst-validate <client>)
            (request gst-device-monitor <client> . <strings>)
            (request gst-inspect <client> . <strings>)
            (request gst-launch <client> <string>)
            (request gst-play <client> <string>)
            (request gst-done <client>)
            (request snapshot <who>)
            (request attach <who> <debugger>)
            (request detach <who>)
            (reset (<ring> evolution))
            (restart <delay>)
            (send)
            (simulate (<location>))
            (stop)
            (stream audio)
            (stream video)
            (stream media)
            (stream loop)
            (stream list)
            (stream play <symbol> <location> (<count>) (<spacing>))
            (stream compare <symbol> . <locations>)
            (stream stop <symbol> <location>)
            (stream done)
            (stream convert)
            (stream parse)
            (test (<no>))
            (threads)
            (version)
            (who)
            (zone list (<name>))
            (zone load <name>)
            (zone unload <name>)
            (clear)
            (help (<what> commands))))
        
        (define (symbol->variable sym)
          (let ((str (symbol->string sym)))
            (if (and (starts-with? str "<")
                     (ends-with? str ">"))
                (string->symbol (substring str 1 (- (string-length str) 1)))
              #f)))
        
        (define (match-type var val)
          (if (unspecified? val)
              val
            (let ((pair (assq var types)))
              (if pair
                  (let ((type (cadr pair)))
                    (type val))
                val))))
        
        (define (info-type name)
          (let ((pair (assq name types)))
            (if pair
                (caddr pair)
              #f)))
        
        (define (match-list match lst)
          (let ((matches '()))
            (define (add sym val)
              (set! matches (append! matches (list (cons sym val)))))
            
            (let (loop (match match) (lst lst))
              (cond ((null? match)
                     (if (null? lst)
                         matches
                       #f))
                    ((symbol? match)
                     (if (not (symbol->variable match))
                         #f
                       (add match lst)
                       matches))
                    (else
                     (let ((obj (car match)))
                       (if (pair? obj)
                           ;; keyword
                           (if (keyword? (car obj))
                               (bind (key sym . others) obj
                                 (bind-optionals ((default (unspecified))) others
                                   (let ((var (symbol->variable sym)))
                                     (if (null? lst)
                                         (let ((val (match-type var default)))
                                           (if (error? val)
                                               val
                                             (add sym val)
                                             (loop (cdr match) lst)))
                                       (if (even? (length lst))
                                           (let ((val (getf lst key not-found: (unspecified))))
                                             (if (unspecified? val)
                                                 (let ((val (match-type var default)))
                                                   (if (error? val)
                                                       val
                                                     (add sym val)
                                                     (loop (cdr match) lst)))
                                               (let ((val (match-type var val)))
                                                 (if (error? val)
                                                     val
                                                   (add sym val)
                                                   (loop (cdr match) (plist-remove lst key))))))
                                         #f)))))
                             ;; optional
                             (bind (sym . others) obj
                               (bind-optionals ((default (unspecified))) others
                                 (let ((var (symbol->variable sym)))
                                   (if (null? lst)
                                       (let ((val (match-type var default)))
                                         (if (error? val)
                                             val
                                           (add sym val)
                                           (loop (cdr match) lst)))
                                     (let ((val (car lst)))
                                       (let ((val (match-type var val)))
                                         (if (error? val)
                                             val
                                           (add sym val)
                                           (loop (cdr match) (cdr lst))))))))))
                         (if (null? lst)
                             #f
                           (let ((var (symbol->variable obj))
                                 (val (car lst)))
                             (if (not var)
                                 ;; symbol
                                 (if (eq? val obj)
                                     (begin
                                       (add #f val)
                                       (loop (cdr match) (cdr lst)))
                                   #f)
                               ;; variable
                               (let ((val (match-type var val)))
                                 (if (error? val)
                                     val
                                   (add obj val)
                                   (loop (cdr match) (cdr lst))))))))))))))
        
        (define (replace-list matches lst)
          (let ((queue (new-queue)))
            (let (loop (lst lst))
              (if (null? lst)
                  (queue-list queue)
                (bind (first . rest) lst
                  (cond ((and (pair? first) (eq? (car first) 'unquote))
                         (enqueue queue (cdr (assq (cadr first) matches))))
                        ((and (pair? first) (eq? (car first) 'unquote-splicing))
                         (enqueue-list queue (cdr (assq (cadr first) matches))))
                        (else
                         (enqueue queue first)))
                  (loop rest))))))
        
        (define (process-aliases all)
          (let ((aliases (world-setting 'world.console-aliases #f)))
            (if (not aliases)
                all
              (continuation-capture
                (lambda (return)
                  (let ((command (car all)))
                    (loop (for pattern in aliases)
                          (when (and (pair? (car pattern)) ;; quick robust hack for old aliases
                                     (eq? (caar pattern) command))
                            (bind (match replace) pattern
                              (let ((matches (match-list match all)))
                                (when matches
                                  (if (error? matches)
                                      (continuation-return return (get-message matches))
                                    (continuation-return return (replace-list matches replace)))))))))
                  all)))))
        
        (define (process-commands all)
          (continuation-capture
            (lambda (return)
              (let ((command (car all)))
                (loop (for pattern in commands)
                      (when (eq? (car pattern) command)
                        (let ((matches (match-list pattern all)))
                          (when matches
                            (if (error? matches)
                                (continuation-return return (get-message matches))
                              (continuation-return return (map cdr matches)))))))
                "Unable to match command"))))
        
        (let ((all (let ((all (with-exception-catcher
                                (lambda (exc)
                                  #f)
                                (lambda ()
                                  (read-string-content (get-string self range))))))
                     (if (or (not all) (null? all))
                         "Invalid syntax"
                       (process-aliases all)))))
          (unless (null? all)
            (let ((processed (if (string? all) all (process-commands all))))
              (define (insert-line line style)
                (insert-styled self line style)
                (insert-newline self))
              
              (define (insert-error line)
                (insert-line line 'Error)
                (insert-newline self)
                (display-prompt self))
              
              (if (string? processed)
                  (begin
                    (insert-newline self)
                    (insert-error processed))
                (bind (command . arguments) processed
                  (define (replay-action directory)
                    (if (alt-down?)
                        (process-replay-threaded directory)
                      (view-replay-directory directory)))
                  
                  (define (simulation-action directory)
                    (let ((file (new-file directory "client.sim")))
                      (if (not (exists? file))
                          (bell)
                        (let ((off? (shift-down?))
                              (server-side? (alt-down?))
                              (simulate? (control-down?)))
                          (cond (off?
                                 (let ((simulator (require-simulator (get-udp-client client))))
                                   (setup-simulation simulator #f)
                                   (admin-server-command client 'simulate (list (unspecified)))
                                   (display-message world "Simulation off")))
                                (server-side?
                                 (let ((simulator (require-simulator (get-udp-client client))))
                                   (setup-simulation simulator #f)
                                   (setup-simulation-start simulator)
                                   (admin-server-command client 'simulate (list (together.simulation:load-simulation file)))
                                   (display-message world "Simulation on (server)")))
                                @wait
                                (simulate?
                                 (together.simulation:simulate-latency (get-name directory) file))
                                (else
                                 (let ((simulator (require-simulator (get-udp-client client))))
                                   (setup-simulation simulator (together.simulation:load-simulation file))
                                   (admin-server-command client 'simulate (list (unspecified)))
                                   (display-message world "Simulation on (client)"))))))))
                  
                  (case command
                    ((activity)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((log (admin-server-command client command arguments)))
                       (if (not log)
                           (insert-line "Activity log not found" 'Error)
                         (for-each (lambda (line)
                                     (insert-line line 'Output))
                                   (remove-trailing "" log test: equal?))))
                     (insert-newline self)
                     (display-prompt self))
                    ((date)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((date (admin-server-command client command arguments)))
                       (insert-line date 'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((dayduration)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((dayduration (admin-processor-command client command arguments)))
                       (insert-line (if (specified? dayduration)
                                        (format "{r precision: 1}" dayduration)
                                      "dayduration set")
                                    'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((daytime)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((daytime (admin-processor-command client command arguments)))
                       (insert-line (if (specified? daytime)
                                        (format "{r precision: 1}" daytime)
                                      "daytime set")
                                    'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((disconnected)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((disconnected (admin-server-command client command arguments))
                           (first? #t))
                       (for-each (lambda (disconnected)
                                   (if first?
                                       (set! first? #f)
                                     (insert-newline self))
                                   (bind (name exception stack) disconnected
                                     (insert-line name 'Header)
                                     (for-each (lambda (line)
                                                 (insert-line line 'Header))
                                               (split-string exception #\newline))
                                     (for-each (lambda (frame)
                                                 (insert-line (format "  {a}" frame) 'Output))
                                               stack)))
                                 disconnected))
                     (insert-newline self)
                     (display-prompt self))
                    ((drop)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (who drop) arguments
                       (if (equal? who (get-character-name client))
                           (let ((simulator (require-simulator (get-udp-client client))))
                             (setup-drop simulator (if (unspecified? drop) #f drop))
                             (insert-line (if (unspecified? drop)
                                              "drop cleared"
                                            "drop set")
                                          'Output))
                         (let ((result (admin-server-command client command arguments)))
                           (if result
                               (insert-line result 'Error)
                             (insert-line (if (unspecified? drop)
                                              "drop cleared"
                                            "drop set")
                                          'Output)))))
                     (insert-newline self)
                     (display-prompt self))
                    ((identity)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (action . rest) arguments
                       (let ((result (admin-server-command client command arguments)))
                         (case action
                           ((list)
                            (for-each (lambda (info)
                                        (insert-line (format "{l}" info) 'Output))
                                      (sort ci<? result key: second)))
                           ((type)
                            (bind (target) rest
                              (when (specified? target)
                                (insert-line (format "{a}" (or target "<untyped>")) 'Header))
                              (let ((first? #t))
                                (for-each (lambda (info)
                                            (if first?
                                                (set! first? #f)
                                              (insert-line "" 'Output))
                                            (bind (type . lst) info
                                              (when (unspecified? target)
                                                (insert-line (format "{a}" (or type "<untyped>")) 'Header))
                                              (for-each (lambda (info)
                                                          (insert-line (format "{l}" (cdr info)) 'Output))
                                                        (sort ci<? lst key: third))))
                                          (sort (lambda (x y)
                                                  (cond ((not x)
                                                         #f)
                                                        ((not y)
                                                         #t)
                                                        (else
                                                         (nu<? x y))))
                                                (partition result key: car)
                                                key: car)))))
                           ((show)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "{l}" result) 'Output)))
                           ((add existing)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "{l}" result) 'Output)))
                           ((create)
                            (if (string? result)
                                (insert-line result 'Error)
                              (for-each (lambda (info)
                                          (bind (name email key) info
                                            (insert-line (if (not email)
                                                             (format "{a}: {a}" name key)
                                                           (format "{a} <{a}>: {a}" name email key))
                                                         'Output)))
                                        result)))
                           ((modify)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "{l}" result) 'Output)))
                           ((verify)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line "verified" 'Output)))
                           ((upgrade)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line "upgraded" 'Output)))
                           ((remove)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line "removed" 'Output)))
                           ((convert)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line "converted" 'Output))))))
                     (insert-newline self)
                     (display-prompt self))
                    ((invitation)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (action . rest) arguments
                       (let ((result (admin-server-command client command arguments)))
                         (case action
                           ((list)
                            (for-each (lambda (info)
                                        (insert-line (format "{l}" info) 'Output))
                                      (sort ci<? result key: second)))
                           ((show)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "{l}" result) 'Output)))
                           ((add)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "{l}" result) 'Output)))
                           ((remove)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line "removed" 'Output))))))
                     (insert-newline self)
                     (display-prompt self))
                    ((kick)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((result (admin-server-command client command arguments)))
                       (if result
                           (insert-line result 'Error)
                         (insert-line "kicked" 'Output)))
                     (insert-newline self)
                     (display-prompt self))
                    ((latency)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (who latency) arguments
                       (if (equal? who (get-character-name client))
                           (let ((simulator (require-simulator (get-udp-client client))))
                             (setup-latency simulator (if (unspecified? latency) #f latency))
                             (insert-line (if (unspecified? latency)
                                              "latency cleared"
                                            "latency set")
                                          'Output))
                         (let ((result (admin-server-command client command arguments)))
                           (if result
                               (insert-line result 'Error)
                             (insert-line (if (unspecified? latency)
                                              "latency cleared"
                                            "latency set")
                                          'Output)))))
                     (insert-newline self)
                     (display-prompt self))
                    ((list)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (what) arguments
                       (if (eq? what 'shared)
                           (iterate-directory {Directory Documents "shared"}
                             (lambda (file)
                               (let ((name (get-name file)))
                                 (unless (filename=? name ".DS_Store")
                                   (insert-styled self name
                                     (new Link-Style
                                       base: 'Link
                                       action: (lambda (text pos style)
                                                 (bell))))
                                   (insert-newline self))))
                             files?: #t
                             directories?: #f
                             recursive?: #f)
                         (let ((prefix (case what
                                         ((replay) "replay_")
                                         ((profile) "profile_")
                                         ((simulation) #f))))
                           (let ((directory (case what
                                              ((replay) {Directory Documents "replays"})
                                              ((profile) {Directory Documents "profiles"})
                                              ((simulation) {Directory Documents "simulations"}))))
                             (when (exists? directory)
                               (iterate-directory directory
                                 (lambda (dir)
                                   (let ((name (get-name dir)))
                                     (when (or (not prefix) (starts-with? name prefix))
                                       (insert-styled self name
                                         (new Link-Style
                                           base: 'Link
                                           action: (lambda (text pos style)
                                                     (case what
                                                       ((replay)
                                                        (replay-action dir))
                                                       ((profile)
                                                        (replay-action dir))
                                                       ((simulation)
                                                        (simulation-action dir))))))
                                       (insert-newline self))))
                                 files?: #f
                                 directories?: #t
                                 recursive?: #f))))))
                     (insert-newline self)
                     (display-prompt self))
                    ((machine)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (action . rest) arguments
                       (define (insert-result result name (sort?: sort? #f))
                         (if result
                             (if (null? result)
                                 (insert-line (format "No {a} defined" name) 'Output)
                               (for-each (lambda (pair)
                                           (bind (key . value) pair
                                             (insert-line (format "{s} {s}" key value) 'Output)))
                                         (if sort?
                                             (sort nu<? result key: car)
                                           result)))
                           (insert-line "Machine not found" 'Error)))
                       
                       (let ((result (admin-server-command client command arguments)))
                         (case action
                           ((list)
                            (for-each (lambda (info)
                                        (insert-line (format "{l}" info) 'Output))
                                      (sort ci<? result key: second)))
                           ((caps)
                            (insert-result result action sort?: #t))
                           ((features settings)
                            (insert-result result action))
                           ((set unset)
                            (insert-result result "settings")
                            (when result
                              ;; temp copy of request code until the right approach becomes clear
                              (let ((insertion-line (get-line (get-end self)))
                                    (insertion-col 0))
                                (define (insert-at str style last?)
                                  (let ((insert-range (new Range$Cell$ (new Cell insertion-line insertion-col) (new Cell insertion-line insertion-col))))
                                    (replace-styled self insert-range (if last? (list str "") (list str)) style)
                                    (if (not last?)
                                        (increase! insertion-col (string-length str))
                                      (increase! insertion-line)
                                      (set! insertion-col 0)
                                      (ensure-displayed self))))
                                
                                (define (insert str (style 'Output))
                                  (insert-at str style #t))
                                
                                ;; live update to client
                                (bind (machine setting . others) rest
                                  (let ((cookie (register-request-cookie))
                                        (what action)
                                        (action (case action ((set) (cons setting (car others))) (else setting))))
                                    (let ((err (admin-server-command client 'request (list cookie what machine action))))
                                      (if err
                                          (insert-line err 'Error)
                                        (register-request-procedure cookie
                                          (lambda (sender name chunk done?)
                                            (when done?
                                              (insert (format "live {a}" name)))))))))))))))
                     (insert-newline self)
                     (display-prompt self))
                    ((metadata)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (insert-line "metadata" 'Output)
                     (let ((metadata (admin-server-command client command arguments)))
                       (pp metadata)
                       (insert-newline self)
                       (display-prompt self)))
                    ((problems)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((log (admin-server-command client command arguments)))
                       (if (not log)
                           (insert-line "Problems log not found" 'Error)
                         (for-each (lambda (line)
                                     (insert-line line 'Output))
                                   (remove-trailing "" log test: equal?))))
                     (insert-newline self)
                     (display-prompt self))
                    ((request)
                     (let ((udp-client (get-udp-client client))
                           (cookie (register-request-cookie)))
                       (define (extract-send-ring)
                         (let ((table (make-table test: equal?)))
                           (iterate-table (get-send-channels udp-client)
                             (lambda (no channel)
                               (let ((name (get-name (get-stream channel)))
                                     (origin (get-origin (get-stream channel)))
                                     (kind (get-media-kind channel))
                                     (source-kind (get-source-kind channel))
                                     (ring (get-replay-ring channel)))
                                 (when ring
                                   (let ((ring (copy-remember-ring ring)))
                                     (table-set! table no (list name origin kind source-kind ring)))))))
                           table))
                       
                       (define (extract-receive-ring)
                         (let ((table (make-table test: equal?)))
                           (iterate-table (get-receive-channels udp-client)
                             (lambda (no channel)
                               (let ((name (get-name (get-stream channel)))
                                     (origin (get-origin (get-stream channel)))
                                     (kind (get-media-kind channel))
                                     (source-kind (get-source-kind channel))
                                     (ring (get-replay-ring channel)))
                                 (when ring
                                   (let ((ring (copy-remember-ring ring)))
                                     (table-set! table no (list name origin kind source-kind ring)))))))
                           table))
                       
                       (stylize-range model range (locate-style self 'Input))
                       (insert-newline self)
                       (bind (what who . rest) arguments
                         (let ((send-ring (and (eq? what 'replay) (extract-send-ring)))
                               (receive-ring (and (eq? what 'replay) (extract-receive-ring))))
                           (define (collect-receive-missing)
                             (let ((queue (new-queue))
                                   (count 0))
                               (iterate-table receive-ring
                                 (lambda (no info)
                                   (bind (channel-name origin kind source-kind ring) info
                                     (let ((missing (collect-missing ring)))
                                       (when (not-null? missing)
                                         (let ((missing-count (length missing)))
                                           (enqueue queue (cons no missing))
                                           (increase! count missing-count)))))))
                               (values (queue-list queue) count)))
                           
                           (define (default-action what)
                             (if (eq? what 'replay)
                                 (receive (missing count) (collect-receive-missing)
                                   missing)
                               'send))
                           
                           (bind-optionals ((action (default-action what))) rest
                             (let ((err (admin-server-command client command (list cookie what who action))))
                               (if err
                                   (begin
                                     (insert-line err 'Error)
                                     (insert-newline self)
                                     (display-prompt self))
                                 (let ((infos (make-table test: equal?))
                                       (missings (make-table test: equal?)))
                                   (define (receive-directory)
                                     (cond ((memq? what '(caps info monitor health energy moments settings capture uncapture shared gst-validate gst-device-monitor gst-inspect gst-launch gst-play gst-done snapshot attach detach))
                                            #f)
                                           ((eq? what 'transfer)
                                            (let ((directory {Directory Documents "requested"}))
                                              (create-directories directory)
                                              directory))
                                           (else
                                            (let ((parent (case what
                                                            ((retrieve) {Directory Documents "retrieves"})
                                                            ((evolution replay) {Directory Documents "replays"})
                                                            (else {Directory Documents "requested"}))))
                                              (let ((directory (timestamped-directory parent (->string (if (eq? what 'evolution) 'replay what)))))
                                                (create-directories directory)
                                                (insert-styled self (get-name directory)
                                                  (new Link-Style
                                                    base: 'Link
                                                    action: (lambda (text pos style)
                                                              (case what
                                                                ((evolution replay)
                                                                 (replay-action directory))))))
                                                (insert-newline self)
                                                directory)))))
                                   
                                   (let ((directory (receive-directory))
                                         (insertion-line (get-line (get-end self)))
                                         (insertion-col 0)
                                         (insertion-fresh? #t))
                                     (define (insert-at str style last?)
                                       (let ((insert-range (new Range$Cell$ (new Cell insertion-line insertion-col) (new Cell insertion-line insertion-col))))
                                         (replace-styled self insert-range (if last? (list str "") (list str)) style)
                                         (if (not last?)
                                             (increase! insertion-col (string-length str))
                                           (increase! insertion-line)
                                           (set! insertion-col 0)
                                           (ensure-displayed self))))
                                     
                                     (define (insert-string str (style 'Output))
                                       (insert-at str style #f))
                                     
                                     (define (insert str (style 'Output))
                                       (insert-at str style #t))
                                     
                                     (define (insert-header str)
                                       (if insertion-fresh?
                                           (begin
                                             (insert str 'Header)
                                             (set! insertion-fresh? #f))
                                         (insert "")
                                         (insert str 'Header)))
                                     
                                     (define (hack-around-text-bug)
                                       (layout-scrollee model))
                                     
                                     (insert-newline self)
                                     (display-prompt self)
                                     (register-request-procedure cookie
                                       (lambda (sender name chunk done?)
                                         (define (determine-info)
                                           (let ((key (cons sender name)))
                                             (or (table-ref infos key #f)
                                                 (let ((info (list (determine-file) #f #f (new-queue))))
                                                   (table-set! infos key info)
                                                   info))))
                                         
                                         (define (determine-missings)
                                           (let ((key sender))
                                             (or (table-ref missings key #f)
                                                 (let ((info (new-queue)))
                                                   (table-set! missings key info)
                                                   info))))
                                         
                                         (define (determine-file)
                                           (case what
                                             ((transfer)
                                              (new-file directory action))
                                             ((retrieve evolution replay)
                                              (case name
                                                ((0)
                                                 (new-file directory (add-extension sender (->string (if (eq? what 'evolution) 'replay what)))))
                                                ((moments)
                                                 (new-file directory (add-extension sender "moments")))
                                                ((missing)
                                                 #f)
                                                (else
                                                 (bind (name extension) (split name "/")
                                                   (new-file directory (add-extension (format "{a}.{a}" sender name) extension))))))
                                             (else
                                              (new-file directory (add-extension sender (->string (if (eq? what 'evolution) 'replay what)))))))
                                         
                                         (define (present-meg bytes)
                                           (format "{a}m" (meg bytes)))
                                         
                                         (define (meg bytes)
                                           (fxround (/ bytes 1024. 1024.)))
                                         
                                         (define (present-gig bytes)
                                           (format "{r precision: 2}g" (gig bytes)))
                                         
                                         (define (gig bytes)
                                           (/ bytes 1024. 1024. 1024.))
                                         
                                         (case what
                                           ((caps settings)
                                            (when done?
                                              (insert-header sender)
                                              (let ((lines (remove-trailing "" (u8vector->object (zlib-inflate chunk)) test: equal?)))
                                                (for-each insert lines))))
                                           ((info)
                                            (when done?
                                              (insert-header sender)
                                              (let ((info (u8vector->object (zlib-inflate chunk))))
                                                (define (present-garbage-collect garbage-collect)
                                                  (format "{a}ms" (seconds->milliseconds garbage-collect)))
                                                
                                                (define (present-cpu% cpu%)
                                                  (format "{r precision: 1}%" cpu%))
                                                
                                                (cond ((eq? who 'server)
                                                       (bind (host service clients processors presences hierarchy garbage-collect cpu% threads memory live movable nonmovable udp outgoing) info
                                                         (define (present-hierarchy hierarchy)
                                                           (map (lambda (info)
                                                                  (bind (group owner invite-only? persistent? require-microphone? require-camera? zone position zoom? link description . members) info
                                                                    (cons group (cons owner (cons invite-only? (cons persistent? (cons require-microphone? (cons require-camera? (cons zone (cons position (cons zoom? (cons link (cons description (map car members))))))))))))))
                                                                hierarchy))
                                                         
                                                         (insert (format "host         : {a}" host))
                                                         (insert (format "service      : {a}" service))
                                                         (insert (format "clients      : {a}" clients))
                                                         (insert (format "processors   : {a}" processors))
                                                         (insert (format "presences    : {a}" presences))
                                                         (insert (format "groups       : {a}" (present-hierarchy hierarchy)))
                                                         (insert (format "gc           : {a}" (present-garbage-collect garbage-collect)))
                                                         (insert (format "cpu%         : {a}" (present-cpu% cpu%)))
                                                         (insert (format "threads      : {a}" threads))
                                                         (insert (format "memory       : {a}" (if memory (present-gig memory) "unavailable")))
                                                         (insert (format "live         : {a}" (present-meg live)))
                                                         (insert (format "movable      : {a}" (present-meg movable)))
                                                         (insert (format "nonmovable   : {a}" (present-meg nonmovable)))
                                                         (insert (format "udp          : {a}" udp))
                                                         (insert (format "outgoing     : {a}" outgoing))))
                                                      ((memq? who '(processor processors))
                                                       (bind (clients garbage-collect cpu% threads memory live movable nonmovable) info
                                                         (insert (format "clients      : {a}" clients))
                                                         (insert (format "gc           : {a}" (present-garbage-collect garbage-collect)))
                                                         (insert (format "cpu%         : {a}" (present-cpu% cpu%)))
                                                         (insert (format "threads      : {a}" threads))
                                                         (insert (format "memory       : {a}" (if memory (present-gig memory) "unavailable")))
                                                         (insert (format "live         : {a}" (present-meg live)))
                                                         (insert (format "movable      : {a}" (present-meg movable)))
                                                         (insert (format "nonmovable   : {a}" (present-meg nonmovable)))))
                                                      (else
                                                       (bind (platform version release graphic-profile upload-profile download-profile presences garbage-collect cpu% threads memory live movable nonmovable gstreamer-live udp camera) info
                                                         (insert (format "platform     : {a}" platform))
                                                         (insert (format "version      : {a}" version))
                                                         (insert (format "release      : {a}" release))
                                                         (insert (format "graphic      : {a}" graphic-profile))
                                                         (insert (format "upload       : {a}" upload-profile))
                                                         (insert (format "download     : {a}" download-profile))
                                                         (insert (format "presences    : {a}" presences))
                                                         (insert (format "gc           : {a}" (present-garbage-collect garbage-collect)))
                                                         (insert (format "cpu%         : {a}" (present-cpu% cpu%)))
                                                         (insert (format "threads      : {a}" threads))
                                                         (insert (format "memory       : {a}" (if memory (present-gig memory) "unavailable")))
                                                         (insert (format "live         : {a}" (present-meg live)))
                                                         (insert (format "movable      : {a}" (present-meg movable)))
                                                         (insert (format "nonmovable   : {a}" (present-meg nonmovable)))
                                                         (insert (format "gstreamer    : {a}" (if gstreamer-live (format "{a} live" gstreamer-live) "n/a")))
                                                         (insert (format "udp          : {a}" udp))
                                                         (insert (format "camera       : {a}" camera))))))))
                                           ((monitor)
                                            (when done?
                                              (insert-header sender)
                                              (bind (memory last-gc-live last-gc-movable last-gc-nonmovable gstreamer-live threads) (u8vector->object (zlib-inflate chunk))
                                                (if (not threads)
                                                    (insert "  CPU%: n/a")
                                                  (receive (main gstreamer other) (process-threads-cpu threads)
                                                    (let ((total (+ main gstreamer other)))
                                                      (insert (format "  CPU%: {r width: 5 justify: :right precision: 1} (total) {r width: 5 justify: :right precision: 1} (main) {r width: 5 justify: :right precision: 1} (gstreamer) {r width: 5 justify: :right precision: 1} (other)"
                                                                      (* total 100.)
                                                                      (* main 100.)
                                                                      (* gstreamer 100.)
                                                                      (* other 100.))))))
                                                (insert (format "  Memory: {a} (process) {a} (live) {a} (movable) {a} (nonmovable) {a} (gstreamer)"
                                                                (if memory (present-gig memory) "n/a")
                                                                (present-meg last-gc-live)
                                                                (present-meg last-gc-movable)
                                                                (present-meg last-gc-nonmovable)
                                                                (if gstreamer-live (format "{a} live" gstreamer-live) "n/a"))))))
                                           ((health)
                                            (when done?
                                              (insert-header sender)
                                              (let ((outputs (u8vector->object (zlib-inflate chunk))))
                                                (for-each (lambda (info)
                                                            (bind (name kind usage max-usage sink-count rendered-count) info
                                                              (let ((dropped-count (- sink-count rendered-count)))
                                                                (insert (format "  {a}: {a} {a} max {a} {a} {a} dropped {a}" name kind usage max-usage sink-count rendered-count dropped-count)))))
                                                          outputs))))
                                           ((energy)
                                            (when done?
                                              (insert-header sender)
                                              (let ((threads (u8vector->object (zlib-inflate chunk))))
                                                (if (not threads)
                                                    (insert "unavailable")
                                                  (receive (main gstreamer other) (process-threads-cpu threads)
                                                    (let ((total (+ main gstreamer other)))
                                                      (insert (format "Total: {r precision: 1}%" (* total 100.)))
                                                      (insert (format "Main: {r precision: 1}%" (* main 100.)))
                                                      (let ((gstreamer-threads '())
                                                            (other-threads '()))
                                                        (for-each (lambda (thread)
                                                                    (bind (fullname) thread
                                                                      (let ((fullname (or fullname "")))
                                                                        (if (gstreamer-thread? fullname)
                                                                            (set! gstreamer-threads (cons thread gstreamer-threads))
                                                                          (set! other-threads (cons thread other-threads))))))
                                                                  (cdr threads))
                                                        (insert (format "GStreamer: {r precision: 1}%" (* gstreamer 100.)))
                                                        (for-each (lambda (thread)
                                                                    (bind (fullname percentage) thread
                                                                      (let ((fullname (or fullname "")))
                                                                        (let ((gstreamer? (gstreamer-thread? fullname)))
                                                                          (let ((name (cond (gstreamer?
                                                                                             (gstreamer-streaming-name fullname))
                                                                                            ((empty-string? fullname)
                                                                                             "unknown")
                                                                                            (else
                                                                                             fullname))))
                                                                            (insert (format "  {a} {r precision: 1}%" name (* percentage 100.))))))))
                                                                  (sort > gstreamer-threads key: second))
                                                        (insert (format "Other: {r precision: 1}%" (* other 100.)))
                                                        (for-each (lambda (thread)
                                                                    (bind (fullname percentage) thread
                                                                      (let ((fullname (or fullname "")))
                                                                        (let ((gstreamer? (gstreamer-thread? fullname)))
                                                                          (let ((name (cond (gstreamer?
                                                                                             (gstreamer-streaming-name fullname))
                                                                                            ((empty-string? fullname)
                                                                                             "unknown")
                                                                                            (else
                                                                                             fullname))))
                                                                            (insert (format "  {a} {r precision: 1}%" name (* percentage 100.))))))))
                                                                  (sort > other-threads key: second)))))))))
                                           ((capture uncapture)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           ((shared)
                                            (when done?
                                              (let ((filenames (u8vector->object (zlib-inflate chunk))))
                                                (for-each (lambda (filename)
                                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                                              (replace-styled self insert-range (list filename "")
                                                                (new Link-Style
                                                                  base: 'Link
                                                                  action: (lambda (text pos style)
                                                                            (let ((start (get-start self)))
                                                                              (insert-styled self (format "request transfer {s} {s}" who filename) 'Entry)
                                                                              (let ((end (get-end self)))
                                                                                (let ((range (new Range$Cell$ start end)))
                                                                                  (console-evaluate self range)))))))
                                                              (ensure-displayed self)
                                                              (increase! insertion-line)))
                                                          filenames))))
                                           ((moments)
                                            (when done?
                                              (insert-header sender)
                                              (let ((moments (u8vector->object (zlib-inflate chunk) deserialize)))
                                                (define moment-names
                                                  #(NONE FATAL_ERROR FATAL_CRITICAL FATAL_WARNING ERROR WARNING INFO DEBUG LOG))
                                                
                                                (define moment-styles
                                                  #(LogNone LogFatalError LogFatalCritical LogFatalWarning LogError LogWarning LogInfo LogDebug LogLog))
                                                
                                                (define max-category
                                                  20)
                                                
                                                (define max-function
                                                  30)
                                                
                                                (define (present-category category)
                                                  (format "{a width: :v}"
                                                          (cond ((not category)
                                                                 "")
                                                                ((> (string-length category) max-category)
                                                                 (string-append (substring category 0 (- max-category 3)) "..."))
                                                                (else
                                                                 category))
                                                          max-category))
                                                
                                                (define (present-function function)
                                                  (format "{a width: :v}"
                                                          (cond ((not function)
                                                                 "")
                                                                ((> (string-length function) max-function)
                                                                 (string-append (substring function 0 (- max-function 3)) "..."))
                                                                (else
                                                                 function))
                                                          max-function))
                                                
                                                (for-each (lambda (moment)
                                                            (let ((level (get-level moment))
                                                                  (category (->string (get-category moment)))
                                                                  (function (->string (get-function moment)))
                                                                  (message (->string (get-message moment))))
                                                              (let ((name (vector-ref moment-names level))
                                                                    (style (vector-ref moment-styles level)))
                                                                (insert-string (format "{r width: 9 justify: :right padding: #\\0 precision: 3}" (get-time moment)) 'Output)
                                                                (insert-string (format "   {a width: 11}" name) style)
                                                                (insert-string (format "   {a}" (present-category category)) 'Output)
                                                                (insert-string (format "   {a}" (present-function function)) 'Output)
                                                                (insert (format "   {a}" message) 'Output)
                                                                (ensure-displayed self))))
                                                          moments))))
                                           ((gst-validate)
                                            (when chunk
                                              (let ((problems (u8vector->object (zlib-inflate chunk))))
                                                (for-each (lambda (info)
                                                            (bind (name . problem) info
                                                              (if (eq? problem 'blacklisted)
                                                                  (insert (format "{a} -> *** blacklisted ***" name) 'Output)
                                                                (insert (format "{a} -> {s}" name problem) 'Output))))
                                                          (sort nu<? problems key: car)))))
                                           ((gst-device-monitor gst-inspect gst-launch gst-play)
                                            (when chunk
                                              (let ((line (u8vector->object (zlib-inflate chunk))))
                                                (insert line 'Output))))
                                           ((gst-done)
                                            (insert "done" 'Output))
                                           ((snapshot)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           ((attach)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           ((detach)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           (else
                                            (let ((info (determine-info))
                                                  (missings (determine-missings)))
                                              (if (eq? name 'missing)
                                                  (enqueue missings chunk)
                                                (bind (file name-end line-end chunks) info
                                                  (when (not chunk)
                                                    (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                                      (let ((end (get-end (replace-styled self insert-range (list (format "  {a}" (get-name file))) 'Output))))
                                                        (set-second! info end)
                                                        (replace-styled self (new Range$Cell$ end end) (list "" "") 'Output)
                                                        (ensure-displayed self)
                                                        (increase! insertion-line))))
                                                  (when chunk
                                                    (enqueue chunks chunk))
                                                  (when done?
                                                    (let ((thread
                                                            (new-thread
                                                              (lambda ()
                                                                (define (save-moments file data)
                                                                  (let ((moments (u8vector->object data deserialize)))
                                                                    (call-with-output-file (path-settings file)
                                                                      (lambda (output)
                                                                        (format output "(<moments>")
                                                                        (for-each (lambda (moment)
                                                                                    (let ((domain (get-domain moment))
                                                                                          (time (get-time moment))
                                                                                          (id (get-id moment))
                                                                                          (level (get-level moment))
                                                                                          (category (get-category moment))
                                                                                          (function (get-function moment))
                                                                                          (message (get-message moment)))
                                                                                      (format output "{%}")
                                                                                      (format output "  (<moment> domain: {s} time: {r precision: 3} id: {s} level: {s} category: {s} function: {s} message: {s})" domain time id level category function message)))
                                                                                  moments)
                                                                        (format output "){%}")))))
                                                                
                                                                (let ((deflated (apply u8vector-append (queue-list chunks))))
                                                                  (case what
                                                                    ((retrieve evolution replay)
                                                                     (case name
                                                                       ((0)
                                                                        (save-binary file deflated))
                                                                       ((moments)
                                                                        (save-moments file (zlib-inflate deflated)))
                                                                       (else
                                                                        (save-binary file (zlib-inflate deflated)))))
                                                                    ((transfer)
                                                                     (save-binary file (zlib-inflate deflated)))))
                                                                (when (eq? what 'replay)
                                                                  (let ((missings (queue-list missings)))
                                                                    (for-each (lambda (missing)
                                                                                (with-record media
                                                                                  (let ((channel-no (read-media-channel missing))
                                                                                        (sequence (read-media-sequence missing)))
                                                                                    (let ((info (table-ref receive-ring channel-no #f)))
                                                                                      (when info
                                                                                        (bind (channel-name origin kind source-kind ring) info
                                                                                          (let ((packet (locate-packet ring sequence)))
                                                                                            (when (and packet
                                                                                                       (not (get-data packet)))
                                                                                              (set-data packet missing)))))))))
                                                                              missings))
                                                                  (let ()
                                                                    (define (media-channel name source-kind)
                                                                      (if (eq? source-kind 'live)
                                                                          ""
                                                                        (format ".{a}" name)))
                                                                    
                                                                    (define (media-extension kind)
                                                                      (if (= kind udp-audio)
                                                                          "replayaudio"
                                                                        "replayvideo"))
                                                                    
                                                                    (iterate-table send-ring
                                                                      (lambda (no info)
                                                                        (bind (channel-name origin kind source-kind ring) info
                                                                          (unless (= (get-count ring) 0)
                                                                            (let ((file (new-file directory (format "{a}{a}.{a}" (get-character-name client) (media-channel channel-name source-kind) (media-extension kind))))
                                                                                  (content (object->u8vector ring serialize)))
                                                                              (save-binary file content))))))
                                                                    (iterate-table receive-ring
                                                                      (lambda (no info)
                                                                        (bind (channel-name origin kind source-kind ring) info
                                                                          (let ((member (find-group-member-by-no client origin)))
                                                                            (let ((name (if member
                                                                                            (first member)
                                                                                          ;; quick hack
                                                                                          (if (= origin server-no)
                                                                                              "_server"
                                                                                            "_unknown"))))
                                                                              (unless (= (get-count ring) 0)
                                                                                (let ((file (new-file directory (format "{a}{a}.{a}" name (media-channel channel-name source-kind) (media-extension kind))))
                                                                                      (content (object->u8vector ring serialize)))
                                                                                  (save-binary file content))))))))))
                                                                (stylize-range self (new Range$Cell$ (new Cell (get-line name-end) 0) name-end)
                                                                  (new Link-Style
                                                                    base: 'Link
                                                                    action: (lambda (text pos style)
                                                                              (case what
                                                                                ((evolution replay transfer)
                                                                                 (bell))))))
                                                                (let ((range (new Range$Cell$ name-end name-end)))
                                                                  (let ((end (get-end (replace-styled self range (list " done") 'Link))))
                                                                    (ensure-displayed self)
                                                                    (set-third! info (new Range$Cell$ end end)))))
                                                              'save)))
                                                      (thread-base-priority-set! thread background-priority)
                                                      (thread-start! thread)))))))))))))))))))
                    ((reset)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((successful? (admin-server-command client command arguments)))
                       (if (not successful?)
                           (insert-line "Unable to reset" 'Error)
                         (insert-line "Reset" 'Output)))
                     (insert-newline self)
                     (display-prompt self))
                    ((restart)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (admin-server-command client command arguments)
                     (insert-line "Restarting" 'Output)
                     (insert-newline self)
                     (display-prompt self))
                    ;((run)
                    ; (stylize-range model range (locate-style self 'Input))
                    ; (insert-newline self)
                    ; (if (null? arguments)
                    ;     (insert-error "Not enough arguments for run")
                    ;   (bind (script-no . rest) arguments
                    ;     (bind-optionals ((who #f)) rest
                    ;       (if (not (and (integer? script-no)
                    ;                     (between? script-no 0 9)))
                    ;           (insert-error (format "Script no expected: {s}" script-no))
                    ;         (let ((cookie (register-request-cookie))
                    ;               (script (load-text (find-script-no world script-no)))
                    ;               (who (if (or (not who) (eq? who 'me)) (get-character-name client) (->string who))))
                    ;           (let ((result (admin-server-command client command (list cookie script who))))
                    ;             (if (string? result)
                    ;                 (begin
                    ;                   (insert-line result 'Error)
                    ;                   (insert-newline self)
                    ;                   (display-prompt self))
                    ;               (let ((infos (make-table test: equal?))
                    ;                     (insertion-line (get-line (get-end self))))
                    ;                 (register-request-procedure cookie
                    ;                   (lambda (sender state data)
                    ;                     (define (determine-info)
                    ;                       (let ((key sender))
                    ;                         (or (table-ref infos key #f)
                    ;                             (let ((info (list #f)))
                    ;                               (table-set! infos key info)
                    ;                               info))))
                    ;                     
                    ;                     (define (present-state)
                    ;                       (case state
                    ;                         ((read)
                    ;                          (bind (reason location) data
                    ;                            (values 'Run-Read
                    ;                                    (truncate (format " {a}" (present reason)))
                    ;                                    (lambda (text pos style)
                    ;                                      (insert-line (format "show {a}" sender) 'Input)
                    ;                                      (insert-line reason 'Output)
                    ;                                      (insert-newline self)
                    ;                                      (display-prompt self)))))
                    ;                         ((walk)
                    ;                          (bind (reason detail) data
                    ;                            (values 'Run-Walk
                    ;                                    (truncate (format " {a}" (present reason)))
                    ;                                    (lambda (text pos style)
                    ;                                      (insert-line (format "show {a}" sender) 'Input)
                    ;                                      (insert-line reason 'Output)
                    ;                                      (insert-newline self)
                    ;                                      (display-prompt self)))))
                    ;                         ((error)
                    ;                          (bind (reason location stack) data
                    ;                            (values 'Run-Error
                    ;                                    (truncate (format " {a}" (present reason)))
                    ;                                    (lambda (text pos style)
                    ;                                      (insert-line (format "show {a}" sender) 'Input)
                    ;                                      (insert-line reason 'Output)
                    ;                                      (insert-newline self)
                    ;                                      (display-prompt self)))))
                    ;                         ((run)
                    ;                          (values 'Output #f #f))
                    ;                         ((result)
                    ;                          (values 'Run-Result
                    ;                                  (if (null? data)
                    ;                                      ""
                    ;                                    (truncate (format " {l detail: :human}" (map present data))))
                    ;                                  (lambda (text pos style)
                    ;                                    (insert-line (format "show {a}" sender) 'Input)
                    ;                                    (for-each (lambda (str)
                    ;                                                (insert-line str 'Output))
                    ;                                              data)
                    ;                                    (insert-newline self)
                    ;                                    (display-prompt self))))))
                    ;                     
                    ;                     (define (present str)
                    ;                       (substitute #\newline #\space str))
                    ;                     
                    ;                     (define (truncate str)
                    ;                       (let ((max-width 128))
                    ;                         (if (> (cardinality str) max-width)
                    ;                             (concatenate (subseq str 0 max-width) "...")
                    ;                           str)))
                    ;                     
                    ;                     (let ((info (determine-info)))
                    ;                       (let ((name-end (first info)))
                    ;                         (receive (style content action) (present-state)
                    ;                           (when (not name-end)
                    ;                             (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                    ;                               (let ((end (get-end (replace-styled self insert-range (list sender) style))))
                    ;                                 (set-first! info end)
                    ;                                 (replace-styled self (new Range$Cell$ end end) (list "" "") 'Output)
                    ;                                 (ensure-displayed self)
                    ;                                 (increase! insertion-line))))
                    ;                           (when content
                    ;                             (let ((name-end (first info)))
                    ;                               (stylize-range self (new Range$Cell$ (new Cell (get-line name-end) 0) name-end)
                    ;                                 (new Link-Style
                    ;                                   base: style
                    ;                                   action: action))
                    ;                               (let ((range (new Range$Cell$ name-end name-end)))
                    ;                                 (let ((end (get-end (replace-styled self range (list content) 'Output))))
                    ;                                   (ensure-displayed self)))
                    ;                               (hack-around-text-bug))))))))
                    ;                 (insert-newline self)
                    ;                 (display-prompt self))))))))))
                    ((send)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((count (admin-server-command client command arguments)))
                       (insert-line (if (= count 0)
                                        "No reports to send"
                                      (format "Sending {a} report{a}" count (format-plural count)))
                                    'Output)
                       (insert-newline self)
                       (display-prompt self)))
                    ((simulate)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (location) arguments
                       (let ((simulator (require-simulator (get-udp-client client))))
                         (cond ((unspecified? location)
                                (setup-simulation simulator #f)
                                (admin-server-command client command (list (unspecified)))
                                (insert-line "simulate off" 'Output))
                               (else
                                (let ((simulation (together.simulation:load-simulation (new-file {Directory Documents} location)))
                                      (server-side? (alt-down?)))
                                  (if server-side?
                                      (admin-server-command client command (list simulation))
                                    (setup-simulation simulator simulation))
                                  (insert-line (format "simulate on ({a})" (if server-side? "server" "client")) 'Output))))))
                     (insert-newline self)
                     (display-prompt self))
                    ((stop)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (admin-server-command client command arguments)
                     (insert-line "Stopping" 'Output)
                     (insert-newline self)
                     (display-prompt self))
                    ((stream)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (action . rest) arguments
                       (let ((result (admin-server-command client command arguments)))
                         (case action
                           ((audio video media)
                            (insert-line (format "streaming {s}" result) 'Output))
                           ((loop)
                            (insert-line (format "looping {a}" (if result "on" "off")) 'Output))
                           ((list)
                            (for-each (lambda (info)
                                        (bind (kind base suffix state) info
                                          (let ((insertion-pos #f))
                                            (insert-styled self (string-append base suffix)
                                              (new Link-Style
                                                base: 'Link
                                                action: (lambda (text pos style)
                                                          (define (replace str style)
                                                            (let ((insertion-line (get-line insertion-pos)))
                                                              (let ((insertion-end (new Cell insertion-line (paragraph-length self insertion-line))))
                                                                (let ((insertion-range (new Range$Cell$ insertion-pos insertion-end)))
                                                                  (replace-styled self insertion-range (list str) style)))))
                                                          
                                                          (cond ((not state)
                                                                 (replace " (starting)" 'Output)
                                                                 (register-server-streaming base)
                                                                 (let ((result (admin-server-command client 'stream (list 'play kind base (unspecified) (unspecified)))))
                                                                   (if result
                                                                       (replace (format " ({a})" result) 'Err)
                                                                     (replace " (playing)" 'Output)
                                                                     (set! state 'playing))))
                                                                (else
                                                                 (replace " (stopping)" 'Output)
                                                                 (unregister-server-streaming base)
                                                                 (let ((result (admin-server-command client 'stream (list 'stop kind base (unspecified) (unspecified)))))
                                                                   (if result
                                                                       (replace (format " ({a})" result) 'Err)
                                                                     (replace "" 'Output)
                                                                     (set! state #f))))))))
                                            (set! insertion-pos (get-end self)))
                                          (when state
                                            (insert-styled self (format " ({a})" state) 'Output))
                                          (insert-newline self)))
                                      result))
                           ((play)
                            (bind (kind location) rest
                              (if result
                                  (insert-line result 'Error)
                                (insert-line "playing" 'Output)
                                (register-server-streaming location))))
                           ((compare)
                            (bind (kind locations) rest
                              (if result
                                  (insert-line result 'Error)
                                (insert-line "comparing" 'Output)
                                (for-each register-server-streaming locations))))
                           ((stop)
                            (bind (kind location) rest
                              (if result
                                  (insert-line result 'Error)
                                (insert-line "stopped" 'Output)
                                (unregister-server-streaming location))))
                           ((done)
                            (if result
                                (insert-line result 'Error)
                              (insert-line "done" 'Output)))
                           ((convert)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "converted {a} file{a}" result (format-plural result)) 'Output)))
                           ((parse)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "parsed {a} file{a}" result (format-plural result)) 'Output)))))
                       (insert-newline self)
                       (display-prompt self)))
                    ((test)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((lines (admin-server-command client command arguments)))
                       (if (not lines)
                           (insert-line "Test not found" 'Error)
                         (for-each (lambda (filename)
                                     (insert-line filename 'Output))
                                   lines)))
                     (insert-newline self)
                     (display-prompt self))
                    ((threads)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((lines (admin-server-command client command arguments)))
                       (for-each (lambda (line)
                                   (insert-line line 'Output))
                                 lines))
                     (insert-newline self)
                     (display-prompt self))
                    ((version)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((version (admin-server-command client command arguments)))
                       (insert-line version 'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((who)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((who (admin-server-command client command arguments)))
                       (for-each (lambda (name)
                                   (insert-line name 'Output))
                                 who))
                     (insert-newline self)
                     (display-prompt self))
                    ((clear)
                     (clear-console self))
                    ((zone)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (action . rest) arguments
                       (let ((result (admin-server-command client command arguments)))
                         (case action
                           ((list)
                            (for-each (lambda (info)
                                        (bind (path available?) info
                                          (let ((insertion-pos #f))
                                            (insert-styled self (join path "/")
                                              (new Link-Style
                                                base: 'Link
                                                action: (lambda (text pos style)
                                                          (define (replace str style)
                                                            (let ((insertion-line (get-line insertion-pos)))
                                                              (let ((insertion-end (new Cell insertion-line (paragraph-length self insertion-line))))
                                                                (let ((insertion-range (new Range$Cell$ insertion-pos insertion-end)))
                                                                  (replace-styled self insertion-range (list str) style)))))
                                                          
                                                          (cond ((not available?)
                                                                 (let ((result (admin-server-command client 'zone (list 'available path))))
                                                                   (if result
                                                                       (replace (format " ({a})" result) 'Err)
                                                                     (replace " (available)" 'Output)
                                                                     (set! available? #t))))
                                                                (else
                                                                 (let ((result (admin-server-command client 'zone (list 'unavailable path))))
                                                                   (if result
                                                                       (replace (format " ({a})" result) 'Err)
                                                                     (replace "" 'Output)
                                                                     (set! available? #f))))))))
                                            (set! insertion-pos (get-end self)))
                                          (when available?
                                            (insert-styled self " (available)" 'Output))
                                          (insert-newline self)))
                                      result)))))
                     (insert-newline self)
                     (display-prompt self))
                    ((help)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (what) arguments
                       (case what
                         ((help)
                          (insert-line "help -> list commands" 'Output)
                          (insert-line "help commands -> list commands" 'Output)
                          (insert-line "help <command> -> list <command>" 'Output)
                          (insert-line "help types -> list types" 'Output)
                          (insert-line "help <type> -> list <type>" 'Output)
                          (insert-line "help aliases -> list aliases" 'Output)
                          (insert-line "help help -> list help" 'Output))
                         ((types)
                          (for-each (lambda (info)
                                      (bind (name type desc) info
                                        (insert-line (format "<{a}> : {a}" name desc) 'Output)))
                                    types))
                         ((aliases)
                          (for-each (lambda (info)
                                      (bind (match replace) info
                                        (insert-line (format "{l} -> {l}" match replace) 'Output)))
                                    (world-setting 'world.console-aliases #f)))
                         (else
                          (let ((name (or (and (symbol? what) (symbol->variable what)) what)))
                            (let ((info (info-type name)))
                              (when info
                                (insert-line (format "<{a}> : {a}" name info) 'Output))))
                          (for-each (lambda (pattern)
                                      (when (cond ((eq? what 'commands) #t)
                                                  (else (eq? (car pattern) what)))
                                        (insert-line (format "{l}" pattern) 'Output)))
                                    commands)
                          (when what
                            (for-each (lambda (info)
                                        (bind (match replace) info
                                          (when (eq? (car match) what)
                                            (insert-line (format "{l} -> {l}" match replace) 'Output))))
                                      (world-setting 'world.console-aliases #f))))))
                     (insert-newline self)
                     (display-prompt self))))))
            (reset inserted))))))
  
  
  (method (clear-console self)
    (empty-text self)
    (display-banner self))
  
  
  (method (current-command self)
    (console-select-style self (text-ending self)
      (lambda (style)
        (inherits? style 'Entry)))))


;;;
;;;; Admin-Actions
;;;


(class Admin-Actions extends Actions
  
  
  (form
    (<install>
      (<Action-Item> name: clear           visible?: #t action-handler: {Event-Handler :focus on-clear} shortcut: {Shortcut :control #\L})
      (<Action-Item> name: insert-previous visible?: #t action-handler: {Event-Handler :focus on-insert-previous} shortcut: {Shortcut Tab} alternate-shortcut: {Shortcut :alt #\P})
      (<Action-Item> name: insert-next     visible?: #t action-handler: {Event-Handler :focus on-insert-next} shortcut: {Shortcut :shift Tab} alternate-shortcut: {Shortcut :alt #\N}))))


(definition admin-actions
  #f)

(definition (cache-admin-actions)
  (or admin-actions
      (let ((actions (new Admin-Actions)))
        (set! admin-actions actions)
        actions))))
