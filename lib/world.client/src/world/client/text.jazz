;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier Text
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.client.text jazz


(import (jazz.action)
        (jazz.console)
        (jazz.event)
        (jazz.exemplar)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.markup)
        (jazz.platform)
        (jazz.stream)
        (jazz.text)
        (jazz.zlib)
        (world)
        (world.audio)
        (world.client.request)
        (world.client.udp)
        (world.configure)
        (world.context)
        (world.evolution)
        (world.interface)
        (world.interface.evolution)
        (world.interface.text)
        (world.settings)
        (world.task)
        (world.udp))


;;;
;;;; Admin-Text
;;;


(class Admin-Text-View extends World-Text-View
  
  
  (slot inserted initialize (new Inserted))
  (slot banner   initialize #f getter generate)
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 8))
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set-default-style model {Text-Style Entry})
    (set-propagate-styles? model #f)
    (set-colorize? syntax #f)
    (add-style self 'Banner  {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Dark-Green}})
    (add-style self 'Prompt  {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Dark-Ochre}})
    (add-style self 'Entry   {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Purple}})
    (add-style self 'Input   {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Purple}})
    (add-style self 'Output  {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color White}})
    (add-style self 'Link    {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    (add-style self 'Error   {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Red}}))
  
  
  (method override (focus-actions self)
    (cons (cache-admin-actions)
          (nextmethod self)))
  
  
  (method override (set-selection self range . rest)
    (apply nextmethod self range rest)
    (set-where inserted #f))
  
  
  (method package (on-clear self evt)
    (let ((current (get-string self (current-command self))))
      (clear-console self)
      (reset inserted)
      (unless (empty-string? current)
        (insert-styled self current {Text-Style Entry}))))
  
  
  (method package (on-insert-previous self evt)
    (console-insert-previous-block self inserted))
  
  
  (method package (on-insert-next self evt)
    (console-insert-next-block self inserted))
  
  
  (method package (initial-banner self banner)
    (set! self.banner banner)
    (display-banner self))
  
  
  (method package (display-banner self)
    (insert-styled self banner 'Banner)
    (insert-newline self)
    (insert-newline self)
    (display-prompt self))
  
  
  (method package (display-prompt self)
    (insert-styled self "> " 'Prompt))
  
  
  (method override (return-press self evt)
    (console-return self
      (lambda ()
        (console-evaluate self))))

  
  (method (console-evaluate self (range #f))
    (let ((client (current-client)))
      (let ((range (or range (current-command self))))
        (define (process-aliases all)
          (let ((aliases (world-setting 'world.console-aliases #f)))
            (if (not aliases)
                all
              (or (getf aliases all test: equal?)
                  all))))
        
        (define (process-command/arguments all)
          (bind (command . arguments) all
            (case command
              ((caps)
               (bind (who) arguments
                 (values 'request (list who 'caps))))
              ((shared)
               (bind (who) arguments
                 (values 'request (list who 'shared))))
              ((transfer)
               (values 'request arguments))
              ((settings)
               (bind (who . rest) arguments
                 (bind-optionals ((action 'send)) rest
                   (values 'request (list who 'settings action)))))
              (else
               (values command arguments)))))
        
        (let ((all (process-aliases (read-string-content (get-string self range)))))
          (unless (null? all)
            (receive (command arguments) (process-command/arguments all)
              (define (insert-line line style)
                (insert-styled self line style)
                (insert-newline self))
              
              (define (caps-action directory)
                (iterate-directory directory
                  (lambda (file)
                    (let ((lines (load-lines file)))
                      (insert-line (format "show {a}" (get-name file)) 'Input)
                      (for-each (lambda (line)
                                  (insert-line line 'Output))
                                lines)
                      (display-prompt self)))
                  recursive?: #f))
              
              (define (settings-action directory)
                (iterate-directory directory
                  (lambda (file)
                    (let ((lines (load-lines file)))
                      (insert-line (format "show {a}" (get-name file)) 'Input)
                      (for-each (lambda (line)
                                  (insert-line line 'Output))
                                lines)
                      (display-prompt self)))
                  recursive?: #f))
              
              (define (replay-action directory)
                (if (alt-down?)
                    (process-replay-threaded directory)
                  (view-replay-directory directory)))
              
              (case command
                ((who)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((who (admin-command client command arguments)))
                   (for-each (lambda (name)
                               (insert-line name 'Output))
                             who))
                 (insert-newline self)
                 (display-prompt self))
                ((crashes)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((crashes (admin-command client command arguments)))
                   (if (equal? arguments '(clear))
                       (insert-line "clear" 'Output)
                     (for-each (lambda (filename)
                                 (insert-line filename 'Output))
                               crashes)))
                 (insert-newline self)
                 (display-prompt self))
                ((crash)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((crash (admin-command client command (map ->string arguments))))
                   (if (not crash)
                       (insert-line "Crash not found" 'Error)
                     (for-each (lambda (line)
                                 (insert-line line 'Output))
                               crash)))
                 (insert-newline self)
                 (display-prompt self))
                ((logs)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((logs (admin-command client command arguments)))
                   (if (equal? arguments '(clear))
                       (insert-line "clear" 'Output)
                     (for-each (lambda (filename)
                                 (insert-line filename 'Output))
                               logs)))
                 (insert-newline self)
                 (display-prompt self))
                ((log)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((log (admin-command client command (map ->string arguments))))
                   (if (not log)
                       (insert-line "Log not found" 'Error)
                     (for-each (lambda (line)
                                 (insert-line line 'Output))
                               (remove-trailing "" log test: equal?))))
                 (insert-newline self)
                 (display-prompt self))
                ((info)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (bind (host service clients disconnected processors groups threads live movable nonmovable outgoing) (admin-command client command arguments)
                   (define (present-meg bytes)
                     (format "{a}m" (meg bytes)))
                   
                   (define (meg bytes)
                     (fxround (/ bytes 1024. 1024.)))
                   
                   (define (present-hierarchy hierarchy)
                     (map (lambda (info)
                            (bind (group . members) info
                              (cons group (map car members))))
                          hierarchy))
                   
                   (insert-line (format "host         : {a}" host) 'Output)
                   (insert-line (format "service      : {a}" service) 'Output)
                   (insert-line (format "clients      : {a}" clients) 'Output)
                   (insert-line (format "disconnected : {a}" disconnected) 'Output)
                   (insert-line (format "processors   : {a}" processors) 'Output)
                   (insert-line (format "groups       : {a}" (present-hierarchy groups)) 'Output)
                   (insert-line (format "threads      : {a}" threads) 'Output)
                   (insert-line (format "live         : {a}" live) 'Output)
                   (insert-line (format "movable      : {a}" movable) 'Output)
                   (insert-line (format "nonmovable   : {a}" nonmovable) 'Output)
                   (insert-line (format "outgoing     : {a}" outgoing) 'Output))
                 (insert-newline self)
                 (display-prompt self))
                ((threads)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((lines (admin-command client command arguments)))
                   (for-each (lambda (line)
                               (insert-line line 'Output))
                             lines))
                 (insert-newline self)
                 (display-prompt self))
                ((test)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((lines (admin-command client command arguments)))
                   (if (not lines)
                       (insert-line "Test not found" 'Error)
                     (for-each (lambda (filename)
                                 (insert-line filename 'Output))
                               lines)))
                 (insert-newline self)
                 (display-prompt self))
                ((attach)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((debugger (if (null? arguments)
                                     (world-setting 'jazz.server-panel.debugger #f)
                                   (->string (car arguments)))))
                   (admin-command client command (list debugger)))
                 (insert-line "Attached to debugger" 'Output)
                 (insert-newline self)
                 (display-prompt self))
                ((detach)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (admin-command client command arguments)
                 (insert-line "Detached from debugger" 'Output)
                 (insert-newline self)
                 (display-prompt self))
                ((restart)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (admin-command client command arguments)
                 (insert-line "Restarting" 'Output)
                 (insert-newline self)
                 (display-prompt self))
                ((reset)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((successful? (admin-command client command arguments)))
                   (if (not successful?)
                       (insert-line "Unable to reset" 'Error)
                     (insert-line "Reset" 'Output)))
                 (insert-newline self)
                 (display-prompt self))
                ((stream)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((result (admin-command client command arguments)))
                   (bind (action . rest) arguments
                     (case action
                       ((list)
                        (for-each (lambda (info)
                                    (bind (base state) info
                                      (insert-styled self (if state
                                                              (format "{a} ({a})" base state)
                                                            base)
                                        (new Link-Style
                                          base: 'Link
                                          action: (lambda (text pos style)
                                                    (let ((start (get-start self)))
                                                      (insert-styled self (if state
                                                                              (format "stream stop {s}" base)
                                                                            (format "stream play {s}" base))
                                                        'Entry)
                                                      (let ((end (get-end self)))
                                                        (let ((range (new Range$Cell$ start end)))
                                                          (console-evaluate self range))))))))
                                    (insert-newline self))
                                  result))
                       ((start)
                        (if result
                            (insert-line result 'Error)
                          (insert-line "started" 'Output)))
                       ((stop)
                        (if result
                            (insert-line result 'Error)
                          (insert-line "stopped" 'Output))))))
                 (insert-newline self)
                 (display-prompt self))
                ((request)
                 (let ((udp-client (get-udp-client client))
                       (cookie (register-request-cookie)))
                   (define (extract-send-ring/header)
                     (let ((table (make-table test: equal?)))
                       (iterate-table (get-send-channels udp-client)
                         (lambda (no channel)
                           (let ((name (get-name channel))
                                 (origin (get-origin channel))
                                 (kind (get-media-kind channel)))
                             (let ((ring (copy-remember-ring (get-replay-ring channel)))
                                   (header (and (= kind udp-audio) (get-audio-header (get-src (get-pipeline channel))))))
                               (table-set! table no (list name origin kind ring header))))))
                       table))
                   
                   (define (extract-receive-ring/header)
                     (let ((table (make-table test: equal?)))
                       (iterate-table (get-receive-channels udp-client)
                         (lambda (no channel)
                           (let ((name (get-name channel))
                                 (origin (get-origin channel))
                                 (kind (get-media-kind channel)))
                             (let ((ring (copy-remember-ring (get-replay-ring channel)))
                                   (header (get-replay-header channel)))
                               (table-set! table no (list name origin kind ring header))))))
                       table))
                   
                   (stylize-range model range (locate-style self 'Input))
                   (insert-newline self)
                   (bind (who what . rest) arguments
                     (bind-optionals ((action 'send)) rest
                       (let ((send-ring/header (and (eq? what 'replay) (extract-send-ring/header)))
                             (receive-ring/header (and (eq? what 'replay) (extract-receive-ring/header))))
                         (define (collect-receive-missing)
                           (let ((queue (new-queue))
                                 (count 0))
                             (iterate-table receive-ring/header
                               (lambda (no info)
                                 (bind (channel-name origin kind ring header) info
                                   (let ((missing (collect-missing ring)))
                                     (when (not-null? missing)
                                       (enqueue queue (list origin kind missing))
                                       (increase! count (length missing)))))))
                             (values (queue-list queue) count)))
                         
                         (when (eq? what 'replay)
                           (receive (missing count) (collect-receive-missing)
                             (set! action missing)
                             (when (and udp-show-replay? (> count 0))
                               (format :terminal "Missing {a}{%}" count))))
                         (let ((err (admin-command client command (list cookie (->string who) what action))))
                           (if err
                               (begin
                                 (insert-line err 'Error)
                                 (insert-newline self)
                                 (display-prompt self))
                             (let ((infos (make-table test: equal?))
                                   (missings (make-table test: equal?)))
                               (define (receive-directory)
                                 (cond ((eq? what 'shared)
                                        #f)
                                       ((string? what)
                                        {Directory Settings "work" "requests"})
                                       (else
                                        (let ((parent (if (eq? what 'replay)
                                                          {Directory Settings "work" "replays"}
                                                        {Directory Settings "work" "requests"})))
                                          (let ((directory (timestamped-directory parent (->string what))))
                                            (create-directories directory)
                                            (insert-styled self (get-name directory)
                                              (new Link-Style
                                                base: 'Link
                                                action: (lambda (text pos style)
                                                          (case what
                                                            ((caps)
                                                             (caps-action directory))
                                                            ((settings)
                                                             (settings-action directory))
                                                            ((replay)
                                                             (replay-action directory))))))
                                            (insert-newline self)
                                            directory)))))
                               
                               (let ((directory (receive-directory))
                                     (insertion-line (get-line (get-end self))))
                                 (insert-newline self)
                                 (display-prompt self)
                                 (register-request-procedure cookie
                                   (lambda (sender name chunk done?)
                                     (define (determine-info)
                                       (let ((key (cons sender name)))
                                         (or (table-ref infos key #f)
                                             (let ((info (list (determine-file) #f #f (new-queue))))
                                               (table-set! infos key info)
                                               info))))
                                     
                                     (define (determine-missings)
                                       (let ((key sender))
                                         (or (table-ref missings key #f)
                                             (let ((info (new-queue)))
                                               (table-set! missings key info)
                                               info))))
                                     
                                     (define (determine-file)
                                       (if (string? what)
                                           (new-file directory what)
                                         (new-file directory (add-extension sender (->string what)))))
                                     
                                     (if (eq? what 'shared)
                                         (when done?
                                           (let ((filenames (u8vector->object (zlib-inflate chunk))))
                                             (for-each (lambda (filename)
                                                         (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                                           (replace-styled self insert-range (list filename "")
                                                             (new Link-Style
                                                               base: 'Link
                                                               action: (lambda (text pos style)
                                                                         (let ((start (get-start self)))
                                                                           (insert-styled self (format "transfer {a} {s}" who filename) 'Entry)
                                                                           (let ((end (get-end self)))
                                                                             (let ((range (new Range$Cell$ start end)))
                                                                               (console-evaluate self range)))))))
                                                           (ensure-displayed self)
                                                           (increase! insertion-line)))
                                                       filenames)))
                                       (let ((info (determine-info))
                                             (missings (determine-missings)))
                                         (if (eq? name 'missing)
                                             (enqueue missings chunk)
                                           (bind (file name-end line-end chunks) info
                                             (when (not chunk)
                                               (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                                 (let ((end (get-end (replace-styled self insert-range (list (format "  {a}" (get-name file))) 'Output))))
                                                   (set-second! info end)
                                                   (replace-styled self (new Range$Cell$ end end) (list "" "") 'Output)
                                                   (ensure-displayed self)
                                                   (increase! insertion-line))))
                                             (when chunk
                                               (enqueue chunks chunk))
                                             (when done?
                                               (let ((thread
                                                       (new-thread
                                                         (lambda ()
                                                           (let ((deflated (apply u8vector-append (queue-list chunks))))
                                                             (if (string? what)
                                                                 (save-binary file (zlib-inflate deflated))
                                                               (case what
                                                                 ((caps)
                                                                  (save-binary file (zlib-inflate deflated)))
                                                                 ((settings)
                                                                  (save-binary file (zlib-inflate deflated)))
                                                                 ((replay)
                                                                  (save-binary file deflated)))))
                                                           (when (eq? what 'replay)
                                                             (let ((missings (queue-list missings)))
                                                               (for-each (lambda (missing)
                                                                           (let ((channel-no (read-udp-channel missing))
                                                                                 (sequence (read-udp-sequence missing)))
                                                                             (let ((info (table-ref receive-ring/header channel-no #f)))
                                                                               (when info
                                                                                 (bind (channel-name origin kind ring header) info
                                                                                   (let ((packet (locate-packet ring sequence)))
                                                                                     (when (and packet
                                                                                                (not (get-data packet)))
                                                                                       (set-data packet missing))))))))
                                                                         missings)
                                                               (when udp-show-replay?
                                                                 (let ((len (length missings)))
                                                                   (when (> len 0)
                                                                     (format :terminal "Got {a} from {a}{%}" len sender)))))
                                                             (let ()
                                                               (define (media-channel name)
                                                                 (if (equal? name "Live")
                                                                     ""
                                                                   (format ".{a}" name)))
                                                               
                                                               (define (media-extension kind)
                                                                 (if (= kind udp-audio)
                                                                     "replayaudio"
                                                                   "replayvideo"))
                                                               
                                                               (iterate-table send-ring/header
                                                                 (lambda (no info)
                                                                   (bind (channel-name origin kind ring header) info
                                                                     (unless (= (get-count ring) 0)
                                                                       (let ((file (new-file directory (format "{a}{a}.{a}" (get-character-name client) (media-channel channel-name) (media-extension kind))))
                                                                             (content (object->u8vector (list ring header) serialize)))
                                                                         (save-binary file content))))))
                                                               (iterate-table receive-ring/header
                                                                 (lambda (no info)
                                                                   (bind (channel-name origin kind ring header) info
                                                                     (let ((member (find-group-member-by-no client origin)))
                                                                       (let ((name (if member
                                                                                       (first member)
                                                                                     ;; quick hack
                                                                                     (if (= origin server-no)
                                                                                         "<server>"
                                                                                       "<unknown>"))))
                                                                         (unless (= (get-count ring) 0)
                                                                           (let ((file (new-file directory (format "{a}{a}.{a}" name (media-channel channel-name) (media-extension kind))))
                                                                                 (content (object->u8vector (list ring header) serialize)))
                                                                             (save-binary file content))))))))))
                                                           (stylize-range self (new Range$Cell$ (new Cell (get-line name-end) 0) name-end)
                                                             (new Link-Style
                                                               base: 'Link
                                                               action: (lambda (text pos style)
                                                                         (if (string? what)
                                                                             (bell)
                                                                           (case what
                                                                             ((caps)
                                                                              (let ((lines (load-lines file)))
                                                                                (insert-line (format "show {a}" (get-name file)) 'Input)
                                                                                (for-each (lambda (line)
                                                                                            (insert-line line 'Output))
                                                                                          lines)
                                                                                (display-prompt self)))
                                                                             ((settings)
                                                                              (let ((lines (load-lines file)))
                                                                                (insert-line (format "show {a}" (get-name file)) 'Input)
                                                                                (for-each (lambda (line)
                                                                                            (insert-line line 'Output))
                                                                                          lines)
                                                                                (display-prompt self)))
                                                                             ((replay)
                                                                              (bell)))))))
                                                           (let ((range (new Range$Cell$ name-end name-end)))
                                                             (let ((end (get-end (replace-styled self range (list " done") 'Output))))
                                                               (ensure-displayed self)
                                                               (set-third! info (new Range$Cell$ end end)))))
                                                         'save)))
                                                 (thread-base-priority-set! thread background-priority)
                                                 (thread-start! thread))))))))))))))))))
                ((list)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (bind (what) arguments
                   (if (eq? what 'shared)
                       (iterate-directory {Directory Settings "work" "shared"}
                         (lambda (file)
                           (let ((name (get-name file)))
                             (unless (filename=? name ".DS_Store")
                               (insert-styled self name
                                 (new Link-Style
                                   base: 'Link
                                   action: (lambda (text pos style)
                                             (bell))))
                               (insert-newline self))))
                         files?: #t
                         directories?: #f
                         recursive?: #f)
                     (let ((prefix (case what
                                     ((caps) "caps_")
                                     ((settings) "settings_")
                                     ((replay) "replay_")
                                     ((simulation) "replay_"))))
                       (iterate-directory (case what
                                            ((replay) {Directory Settings "work" "replays"})
                                            ((simulation) {Directory Settings "work" "simulations"})
                                            (else {Directory Settings "work" "requests"}))
                         (lambda (dir)
                           (let ((name (get-name dir)))
                             (when (starts-with? name prefix)
                               (insert-styled self name
                                 (new Link-Style
                                   base: 'Link
                                   action: (lambda (text pos style)
                                             (case what
                                               ((caps)
                                                (caps-action dir))
                                               ((settings)
                                                (settings-action dir))
                                               ((replay)
                                                (replay-action dir))
                                               ((simulation)
                                                (replay-action dir))))))
                               (insert-newline self))))
                         files?: #f
                         directories?: #t
                         recursive?: #f))))
                 (insert-newline self)
                 (display-prompt self))
                @goes-into-request
                ((settings)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (let ((info (admin-command client command arguments)))
                   (cond ((equal? arguments '(show))
                          (if (not info)
                              (insert-line "No settings installed" 'Output)
                            (for-each (lambda (filename)
                                        (insert-line filename 'Output))
                                      info)))
                         ((equal? arguments '(clear))
                          (insert-line "Settings cleared" 'Output))
                         (else
                          (insert-line "Settings installed" 'Output))))
                 (insert-newline self)
                 (display-prompt self))
                ((clear)
                 (clear-console self))
                ((help ?)
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (insert-line "attach <debugger>" 'Output)
                 (insert-line "crashes <clear>" 'Output)
                 (insert-line "crash <filename>" 'Output)
                 (insert-line "detach" 'Output)
                 (insert-line "info" 'Output)
                 (insert-line "list <what>" 'Output)
                 (insert-line "logs <clear>" 'Output)
                 (insert-line "log <filename>" 'Output)
                 (insert-line "request <what> <who>" 'Output)
                 (insert-line "reset <what>" 'Output)
                 (insert-line "restart" 'Output)
                 (insert-line "settings <who> <filename>" 'Output)
                 (insert-line "shared <who>" 'Output)
                 (insert-line "test <no>" 'Output)
                 (insert-line "threads" 'Output)
                 (insert-line "transfer <who> <filename>" 'Output)
                 (insert-line "who" 'Output)
                 (insert-line "clear" 'Output)
                 (insert-line "help / ?" 'Output)
                 (insert-newline self)
                 (display-prompt self))
                (else
                 (stylize-range model range (locate-style self 'Input))
                 (insert-newline self)
                 (insert-line (format "Unknown command: {a}" command) 'Error)
                 (insert-newline self)
                 (display-prompt self)))))))))
  
  
  (method (clear-console self)
    (empty-text self)
    (display-banner self))
  
  
  (method (current-command self)
    (console-select-style self (text-ending self)
      (lambda (style)
        (inherits? style 'Entry)))))


;;;
;;;; Admin-Actions
;;;


(class Admin-Actions extends Actions
  
  
  (form
    (<install>
      (<Action-Item> name: clear           visible?: #t action-handler: {Event-Handler :focus on-clear} shortcut: {Shortcut :control #\L})
      (<Action-Item> name: insert-previous visible?: #t action-handler: {Event-Handler :focus on-insert-previous} shortcut: {Shortcut Tab})
      (<Action-Item> name: insert-next     visible?: #t action-handler: {Event-Handler :focus on-insert-next} shortcut: {Shortcut :shift Tab}))))


(definition admin-actions
  #f)

(definition (cache-admin-actions)
  (or admin-actions
      (let ((actions (new Admin-Actions)))
        (set! admin-actions actions)
        actions))))
