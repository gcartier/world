;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier Text
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.client.text jazz


(import (jazz.action)
        (jazz.console)
        (jazz.editor.jazz)
        (jazz.event)
        (jazz.exemplar)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.markup)
        (jazz.network)
        (jazz.platform)
        (jazz.stream)
        (jazz.text)
        (jazz.zlib)
        (world)
        (world.asset)
        (world.audio)
        (world.circle)
        (world.client.request)
        (world.client.tier)
        (world.client.udp)
        (world.configure)
        (world.context)
        (world.evolution)
        (world.interface)
        (world.interface.evolution)
        (world.interface.text)
        (world.record (phase syntax))
        (world.settings)
        (world.task)
        (world.udp))


;;;
;;;; Admin-Text
;;;


(class Admin-Text-View extends World-Text-View
  
  
  (slot inserted initialize (new Inserted))
  (slot banner   initialize #f getter generate)
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 8))
  
  
  (method override (new-syntax self)
    (new Jazz-Syntax model colorize?: #f))
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set-default-style model {Text-Style Entry})
    (set-propagate-styles? model #f)
    (set-colorize? syntax #f)
    (add-style self 'Banner        {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Dark-Green}})
    (add-style self 'Prompt        {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Dark-Ochre}})
    (add-style self 'Entry         {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Purple}})
    (add-style self 'Input         {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Purple}})
    (add-style self 'Output        {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color White}})
    (add-style self 'Header        {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    (add-style self 'Link          {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    (add-style self 'Err           {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Red}})
    (add-style self 'Error         {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Red}})
    (add-style self 'LogNone       {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color White}})
    (add-style self 'LogGError     {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Red}})
    (add-style self 'LogGCritical  {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Orange}})
    (add-style self 'LogGWarning   {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Yellow}})
    (add-style self 'LogGstError   {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Green}})
    (add-style self 'LogGstWarning {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Cyan}})
    ;(add-style self 'Run-Read      {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Orange}})
    ;(add-style self 'Run-Walk      {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Orange}})
    ;(add-style self 'Run-Error     {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Red}})
    ;(add-style self 'Run-Result    {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    )
  
  
  (method override (focus-actions self)
    (cons (cache-admin-actions)
          (nextmethod self)))
  
  
  (method override (set-selection self range . rest)
    (apply nextmethod self range rest)
    (set-where inserted #f))
  
  
  (method override (backspace-allowed? self)
    (console-backspace-allowed? self))
  
  
  (method package (on-clear self evt)
    (let ((current (get-string self (current-command self))))
      (clear-console self)
      (reset inserted)
      (unless (empty-string? current)
        (insert-styled self current {Text-Style Entry}))))
  
  
  (method package (on-insert-previous self evt)
    (console-insert-previous-block self inserted))
  
  
  (method package (on-insert-next self evt)
    (console-insert-next-block self inserted))
  
  
  (method package (initial-banner self banner)
    (set! self.banner banner)
    (display-banner self))
  
  
  (method package (display-banner self)
    (insert-styled self banner 'Banner)
    (insert-newline self)
    (insert-newline self)
    (display-prompt self))
  
  
  (method package (display-prompt self)
    (insert-styled self "> " 'Prompt))
  
  
  (method override (return-press self evt)
    (console-return self
      (lambda ()
        (console-evaluate self))))

  
  (method (console-evaluate self (range #f))
    (let ((client (current-client))
          (world (current-world)))
      (set-caret self (text-ending self))
      (let ((range (or range (current-command self))))
        (define (match-error . rest)
          (new Error message: (apply format rest)))
        
        (define (boolean-type val)
          (if (boolean? val)
              val
            (match-error "Invalid boolean: {s}" val)))
        
        (define (string-type val)
          (if (string? val)
              val
            (match-error "Invalid string: {s}" val)))
        
        (define (int-type val)
          (if (integer? val)
              val
            (match-error "Invalid int: {s}" val)))
        
        (define (real-type val)
          (if (real? val)
              val
            (match-error "Invalid real: {s}" val)))
        
        (define (identity-type val)
          (if (string? val)
              val
            (match-error "Invalid identity: {s}" val)))
        
        (define (key-type val)
          (if (uuid? val)
              val
            (match-error "Invalid key: {s}" val)))
        
        (define (machine-type val)
          (if (string? val)
              val
            (match-error "Invalid machine: {s}" val)))
        
        (define (role-type val)
          (if (memq? val '(#f user builder developer))
              val
            (match-error "Invalid role: {s}" val)))
        
        (define (who-type val)
          (cond ((eq? val 'me)
                 (get-character-name client))
                ((or (memq? val '(all server))
                     (string? val))
                 val)
                ((symbol? val)
                 (symbol->string val))
                (else
                 (match-error "Invalid who: {s}" val))))
        
        (define (client-type val)
          (cond ((eq? val 'me)
                 (get-character-name client))
                ((string? val)
                 val)
                ((symbol? val)
                 (symbol->string val))
                (else
                 (match-error "Invalid client: {s}" val))))
        
        (define (pads-type val)
          (cond ((eq? val #t)
                 '("sink.sink" "mic%src.src" "mic%processor.src"))
                ((or (not val)
                     (list? val))
                 val)
                (else
                 (match-error "Invalid pads: {s}" val))))
        
        (define (ring-type val)
          (if (memq? val '(evolution))
              val
            (match-error "Invalid ring: {s}" val)))
        
        (define (debugger-type val)
          (cond ((not val)
                 ":56000")
                ((string? val)
                 val)
                (else
                 (match-error "Invalid debugger: {s}" val))))
        
        (define types
          (list
            (list 'boolean boolean-type "#f #t")
            (list 'string string-type "\"string\"")
            (list 'int int-type "integer number")
            (list 'real real-type "real number")
            (list 'time real-type "<real>")
            (list 'delay real-type "<real>")
            (list 'duration real-type "<real>")
            (list 'drop real-type "<real>")
            (list 'latency real-type "<real>")
            (list 'name string-type "<string>")
            (list 'user string-type "<string>")
            (list 'location string-type "<string>")
            (list 'identity identity-type "<string>")
            (list 'key key-type "<uuid key>")
            (list 'machine machine-type "<string>")
            (list 'role role-type "#f user builder developer")
            (list 'who who-type "all server me \"username\"")
            (list 'client client-type "me \"username\"")
            (list 'pads pads-type "#t pads #f")
            (list 'no int-type "<int>")
            (list 'count int-type "<int>")
            (list 'spacing real-type "<real>")
            (list 'ring ring-type "evolution")
            (list 'debugger debugger-type "\"host:port\"")))
       
        (define commands
          '((activity)
            (date)
            (dayduration (<duration>))
            (daytime (<time>))
            (disconnected)
            (drop <who> (<drop>))
            (identity list (<name>))
            (identity show <identity>)
            (identity add <name> (role: <role>) (admin?: <boolean>))
            (identity existing <key> <name> (role: <role>) (admin?: <boolean>))
            (identity modify <identity> (name: <name>) (role: <role>) (admin?: <boolean>))
            (identity remove <identity>)
            (kick <who>)
            (latency <who> (<latency>))
            (list caps)
            (list profile)
            (list replay)
            (list settings)
            (list shared)
            (machine list (<user>))
            (machine caps <machine>)
            (machine features <machine>)
            (machine settings <machine>)
            (machine set <machine> <setting> <value>)
            (machine unset <machine> <setting>)
            (metadata)
            (request caps <who>)
            (request info <who>)
            (request record <who> <pads>)
            (request recording <who>)
            (request replay <who>)
            (request shared <who>)
            (request settings <who>)
            (request log <client>)
            (request gst-device-monitor <client>)
            (request gst-inspect <client>)
            (request gst-launch <client>)
            (request gst-play <client>)
            (request gst-done <client>)
            (request snapshot <who>)
            (request attach <who> <debugger>)
            (request detach <who>)
            (request transfer <who> <location>)
            (reset (<ring> evolution))
            (restart <delay>)
            (stop)
            (stream audio)
            (stream video)
            (stream media)
            (stream list)
            (stream play <location> (<count>) (<spacing>))
            (stream compare . <locations>)
            (stream stop <location>)
            (stream done)
            (test (<no>))
            (threads)
            (version)
            (who)
            (clear)
            (help (<what> commands))))
        
        (define (symbol->variable sym)
          (let ((str (symbol->string sym)))
            (if (and (starts-with? str "<")
                     (ends-with? str ">"))
                (string->symbol (substring str 1 (- (string-length str) 1)))
              #f)))
        
        (define (match-type var val)
          (if (unspecified? val)
              val
            (let ((pair (assq var types)))
              (if pair
                  (let ((type (cadr pair)))
                    (type val))
                val))))
        
        (define (info-type name)
          (let ((pair (assq name types)))
            (if pair
                (caddr pair)
              #f)))
        
        (define (match-list match lst)
          (let ((matches '()))
            (define (add sym val)
              (set! matches (append! matches (list (cons sym val)))))
            
            (let (loop (match match) (lst lst))
              (cond ((null? match)
                     (if (null? lst)
                         matches
                       #f))
                    ((symbol? match)
                     (if (not (symbol->variable match))
                         #f
                       (add match lst)
                       matches))
                    (else
                     (let ((obj (car match)))
                       (if (pair? obj)
                           ;; keyword
                           (if (keyword? (car obj))
                               (bind (key sym . others) obj
                                 (bind-optionals ((default (unspecified))) others
                                   (let ((var (symbol->variable sym)))
                                     (if (null? lst)
                                         (let ((val (match-type var default)))
                                           (if (error? val)
                                               val
                                             (add sym val)
                                             (loop (cdr match) lst)))
                                       (if (even? (length lst))
                                           (let ((val (getf lst key not-found: (unspecified))))
                                             (if (unspecified? val)
                                                 (let ((val (match-type var default)))
                                                   (if (error? val)
                                                       val
                                                     (add sym val)
                                                     (loop (cdr match) lst)))
                                               (let ((val (match-type var val)))
                                                 (if (error? val)
                                                     val
                                                   (add sym val)
                                                   (loop (cdr match) (plist-remove lst key))))))
                                         #f)))))
                             ;; optional
                             (bind (sym . others) obj
                               (bind-optionals ((default (unspecified))) others
                                 (let ((var (symbol->variable sym)))
                                   (if (null? lst)
                                       (let ((val (match-type var default)))
                                         (if (error? val)
                                             val
                                           (add sym val)
                                           (loop (cdr match) lst)))
                                     (let ((val (car lst)))
                                       (let ((val (match-type var val)))
                                         (if (error? val)
                                             val
                                           (add sym val)
                                           (loop (cdr match) (cdr lst))))))))))
                         (if (null? lst)
                             #f
                           (let ((var (symbol->variable obj))
                                 (val (car lst)))
                             (if (not var)
                                 ;; symbol
                                 (if (eq? val obj)
                                     (begin
                                       (add #f val)
                                       (loop (cdr match) (cdr lst)))
                                   #f)
                               ;; variable
                               (let ((val (match-type var val)))
                                 (if (error? val)
                                     val
                                   (add obj val)
                                   (loop (cdr match) (cdr lst))))))))))))))
        
        (define (replace-list matches lst)
          (let ((queue (new-queue)))
            (let (loop (lst lst))
              (if (null? lst)
                  (queue-list queue)
                (bind (first . rest) lst
                  (cond ((and (pair? first) (eq? (car first) 'unquote))
                         (enqueue queue (cdr (assq (cadr first) matches))))
                        ((and (pair? first) (eq? (car first) 'unquote-splicing))
                         (enqueue-list queue (cdr (assq (cadr first) matches))))
                        (else
                         (enqueue queue first)))
                  (loop rest))))))
        
        (define (process-aliases all)
          (let ((aliases (world-setting 'world.console-aliases #f)))
            (if (not aliases)
                all
              (continuation-capture
                (lambda (return)
                  (let ((command (car all)))
                    (loop (for pattern in aliases)
                          (when (eq? (caar pattern) command)
                            (bind (match replace) pattern
                              (let ((matches (match-list match all)))
                                (when matches
                                  (if (error? matches)
                                      (continuation-return return (get-message matches))
                                    (continuation-return return (replace-list matches replace)))))))))
                  all)))))
        
        (define (process-commands all)
          (continuation-capture
            (lambda (return)
              (let ((command (car all)))
                (loop (for pattern in commands)
                      (when (eq? (car pattern) command)
                        (let ((matches (match-list pattern all)))
                          (when matches
                            (if (error? matches)
                                (continuation-return return (get-message matches))
                              (continuation-return return (map cdr matches)))))))
                "Unable to match command"))))
        
        (let ((all (let ((all (with-exception-catcher
                                (lambda (exc)
                                  #f)
                                (lambda ()
                                  (read-string-content (get-string self range))))))
                     (if (or (not all) (null? all))
                         "Invalid syntax"
                       (process-aliases all)))))
          (unless (null? all)
            (let ((processed (if (string? all) all (process-commands all))))
              (define (insert-line line style)
                (insert-styled self line style)
                (insert-newline self))
              
              (define (insert-error line)
                (insert-line line 'Error)
                (insert-newline self)
                (display-prompt self))
              
              (if (string? processed)
                  (begin
                    (insert-newline self)
                    (insert-error processed))
                (bind (command . arguments) processed
                  (define (caps-action directory)
                    (iterate-directory directory
                      (lambda (file)
                        (let ((lines (load-lines file)))
                          (insert-line (format "show {a}" (get-name file)) 'Input)
                          (for-each (lambda (line)
                                      (insert-line line 'Output))
                                    lines)
                          (display-prompt self)))
                      recursive?: #f))
                  
                  (define (settings-action directory)
                    (iterate-directory directory
                      (lambda (file)
                        (let ((lines (load-lines file)))
                          (insert-line (format "show {a}" (get-name file)) 'Input)
                          (for-each (lambda (line)
                                      (insert-line line 'Output))
                                    lines)
                          (display-prompt self)))
                      recursive?: #f))
                  
                  (define (replay-action directory)
                    (if (alt-down?)
                        (process-replay-threaded directory)
                      (view-replay-directory directory)))
                  
                  (case command
                    ((activity)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((log (admin-server-command client command arguments)))
                       (if (not log)
                           (insert-line "Activity log not found" 'Error)
                         (for-each (lambda (line)
                                     (insert-line line 'Output))
                                   (remove-trailing "" log test: equal?))))
                     (insert-newline self)
                     (display-prompt self))
                    ((date)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((date (admin-server-command client command arguments)))
                       (insert-line date 'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((dayduration)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((dayduration (admin-processor-command client command arguments)))
                       (insert-line (if (specified? dayduration)
                                        (format "{r precision: 1}" dayduration)
                                      "dayduration set")
                                    'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((daytime)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((daytime (admin-processor-command client command arguments)))
                       (insert-line (if (specified? daytime)
                                        (format "{r precision: 1}" daytime)
                                      "daytime set")
                                    'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((disconnected)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((disconnected (admin-server-command client command arguments))
                           (first? #t))
                       (for-each (lambda (disconnected)
                                   (if first?
                                       (set! first? #f)
                                     (insert-newline self))
                                   (bind (name exception stack) disconnected
                                     (insert-line name 'Header)
                                     (for-each (lambda (line)
                                                 (insert-line line 'Header))
                                               (split-string exception #\newline))
                                     (for-each (lambda (frame)
                                                 (insert-line (format "  {a}" frame) 'Output))
                                               stack)))
                                 disconnected))
                     (insert-newline self)
                     (display-prompt self))
                    ((drop)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (who drop) arguments
                       (if (equal? who (get-character-name client))
                           (let ((simulator (require-simulator (get-udp-client client))))
                             (setup-drop simulator (if (unspecified? drop) #f drop))
                             (insert-line (if (unspecified? drop)
                                              "drop cleared"
                                            "drop set")
                                          'Output))
                         (let ((result (admin-server-command client command arguments)))
                           (if result
                               (insert-line result 'Error)
                             (insert-line (if (unspecified? drop)
                                              "drop cleared"
                                            "drop set")
                                          'Output)))))
                     (insert-newline self)
                     (display-prompt self))
                    ((identity)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (action) arguments
                       (let ((result (admin-server-command client command arguments)))
                         (case action
                           ((list)
                            (for-each (lambda (info)
                                        (insert-line (format "{l}" info) 'Output))
                                      result))
                           ((show)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "{l}" result) 'Output)))
                           ((add existing)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "{l}" result) 'Output)))
                           ((modify)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line (format "{l}" result) 'Output)))
                           ((remove)
                            (if (string? result)
                                (insert-line result 'Error)
                              (insert-line "removed" 'Output))))))
                     (insert-newline self)
                     (display-prompt self))
                    ((kick)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((result (admin-server-command client command arguments)))
                       (if result
                           (insert-line result 'Error)
                         (insert-line "kicked" 'Output)))
                     (insert-newline self)
                     (display-prompt self))
                    ((latency)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (who latency) arguments
                       (if (equal? who (get-character-name client))
                           (let ((simulator (require-simulator (get-udp-client client))))
                             (setup-latency simulator (if (unspecified? latency) #f latency))
                             (insert-line (if (unspecified? latency)
                                              "latency cleared"
                                            "latency set")
                                          'Output))
                         (let ((result (admin-server-command client command arguments)))
                           (if result
                               (insert-line result 'Error)
                             (insert-line (if (unspecified? latency)
                                              "latency cleared"
                                            "latency set")
                                          'Output)))))
                     (insert-newline self)
                     (display-prompt self))
                    ((list)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (what) arguments
                       (if (eq? what 'shared)
                           (iterate-directory {Directory Documents "shared"}
                             (lambda (file)
                               (let ((name (get-name file)))
                                 (unless (filename=? name ".DS_Store")
                                   (insert-styled self name
                                     (new Link-Style
                                       base: 'Link
                                       action: (lambda (text pos style)
                                                 (bell))))
                                   (insert-newline self))))
                             files?: #t
                             directories?: #f
                             recursive?: #f)
                         (let ((prefix (case what
                                         ((caps) "caps_")
                                         ((settings) "settings_")
                                         ((replay) "replay_")
                                         ((profile) "profile_"))))
                           (iterate-directory (case what
                                                ((replay) {Directory Documents "replays"})
                                                ((profile) {Directory Documents "profiles"})
                                                (else {Directory Documents "requested"}))
                             (lambda (dir)
                               (let ((name (get-name dir)))
                                 (when (starts-with? name prefix)
                                   (insert-styled self name
                                     (new Link-Style
                                       base: 'Link
                                       action: (lambda (text pos style)
                                                 (case what
                                                   ((caps)
                                                    (caps-action dir))
                                                   ((settings)
                                                    (settings-action dir))
                                                   ((replay)
                                                    (replay-action dir))
                                                   ((profile)
                                                    (replay-action dir))))))
                                   (insert-newline self))))
                             files?: #f
                             directories?: #t
                             recursive?: #f))))
                     (insert-newline self)
                     (display-prompt self))
                    ((machine)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (action . rest) arguments
                       (define (insert-result result name)
                         (if result
                             (if (null? result)
                                 (insert-line (format "No {a} defined" name) 'Output)
                               (for-each (lambda (pair)
                                           (bind (key . value) pair
                                             (insert-line (format "{s} {s}" key value) 'Output)))
                                         result))
                           (insert-line "Machine not found" 'Error)))
                       
                       (let ((result (admin-server-command client command arguments)))
                         (case action
                           ((list)
                            (for-each (lambda (info)
                                        (insert-line (format "{l}" info) 'Output))
                                      result))
                           ((caps features settings)
                            (insert-result result action))
                           ((set unset)
                            (insert-result result "settings")
                            (when result
                              ;; temp copy of request code until the right approach becomes clear
                              (let ((insertion-line (get-line (get-end self)))
                                    (insertion-col 0))
                                (define (insert-at str style last?)
                                  (let ((insert-range (new Range$Cell$ (new Cell insertion-line insertion-col) (new Cell insertion-line insertion-col))))
                                    (replace-styled self insert-range (if last? (list str "") (list str)) style)
                                    (if (not last?)
                                        (increase! insertion-col (string-length str))
                                      (increase! insertion-line)
                                      (set! insertion-col 0)
                                      (ensure-displayed self))))
                                
                                (define (insert str (style 'Output))
                                  (insert-at str style #t))
                                
                                (bind (machine setting . others) rest
                                  (let ((cookie (register-request-cookie))
                                        (what action)
                                        (action (case action ((set) (cons setting (car others))) (else setting))))
                                    (let ((err (admin-server-command client 'request (list cookie what machine action))))
                                      (if err
                                          (insert-line err 'Error)
                                        (register-request-procedure cookie
                                          (lambda (sender name chunk done?)
                                            (when done?
                                              (insert (format "live {a}" name)))))))))))))))
                     (insert-newline self)
                     (display-prompt self))
                    ((metadata)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (insert-line "metadata" 'Output)
                     (let ((metadata (admin-server-command client command arguments)))
                       (pp metadata)
                       (insert-newline self)
                       (display-prompt self)))
                    ((request)
                     (let ((udp-client (get-udp-client client))
                           (cookie (register-request-cookie)))
                       (define (extract-send-ring)
                         (let ((table (make-table test: equal?)))
                           (iterate-table (get-send-channels udp-client)
                             (lambda (no channel)
                               (let ((name (get-name (get-stream channel)))
                                     (origin (get-origin (get-stream channel)))
                                     (kind (get-media-kind channel))
                                     (source-kind (get-source-kind channel))
                                     (ring (get-replay-ring channel)))
                                 (when ring
                                   (let ((ring (copy-remember-ring ring)))
                                     (table-set! table no (list name origin kind source-kind ring)))))))
                           table))
                       
                       (define (extract-receive-ring)
                         (let ((table (make-table test: equal?)))
                           (iterate-table (get-receive-channels udp-client)
                             (lambda (no channel)
                               (let ((name (get-name (get-stream channel)))
                                     (origin (get-origin (get-stream channel)))
                                     (kind (get-media-kind channel))
                                     (source-kind (get-source-kind channel))
                                     (ring (get-replay-ring channel)))
                                 (when ring
                                   (let ((ring (copy-remember-ring ring)))
                                     (table-set! table no (list name origin kind source-kind ring)))))))
                           table))
                       
                       (stylize-range model range (locate-style self 'Input))
                       (insert-newline self)
                       (bind (what who . rest) arguments
                         (let ((send-ring (and (eq? what 'replay) (extract-send-ring)))
                               (receive-ring (and (eq? what 'replay) (extract-receive-ring))))
                           (define (collect-receive-missing)
                             (let ((queue (new-queue))
                                   (count 0))
                               (iterate-table receive-ring
                                 (lambda (no info)
                                   (bind (channel-name origin kind source-kind ring) info
                                     (let ((missing (collect-missing ring)))
                                       (when (not-null? missing)
                                         (let ((missing-count (length missing)))
                                           (enqueue queue (cons no missing))
                                           (increase! count missing-count)
                                           (when udp-show-replay?
                                             (format :terminal "Missing {a} in {a} ({a}){%}" missing-count channel-name (udp-name kind)))))))))
                               (values (queue-list queue) count)))
                           
                           (define (default-action what)
                             (if (eq? what 'replay)
                                 (receive (missing count) (collect-receive-missing)
                                   missing)
                               'send))
                           
                           (bind-optionals ((action (default-action what))) rest
                             (let ((err (admin-server-command client command (list cookie what who action))))
                               (if err
                                   (begin
                                     (insert-line err 'Error)
                                     (insert-newline self)
                                     (display-prompt self))
                                 (let ((infos (make-table test: equal?))
                                       (missings (make-table test: equal?)))
                                   (define (receive-directory)
                                     (cond ((memq? what '(info shared log record gst-device-monitor gst-inspect gst-launch gst-play gst-done snapshot attach detach))
                                            #f)
                                           ((eq? what 'transfer)
                                            (let ((directory {Directory Documents "requested"}))
                                              (create-directories directory)
                                              directory))
                                           (else
                                            (let ((parent (case what
                                                            ((recording) {Directory Documents "recordings"})
                                                            ((replay) {Directory Documents "replays"})
                                                            (else {Directory Documents "requested"}))))
                                              (let ((directory (timestamped-directory parent (->string what))))
                                                (create-directories directory)
                                                (insert-styled self (get-name directory)
                                                  (new Link-Style
                                                    base: 'Link
                                                    action: (lambda (text pos style)
                                                              (case what
                                                                ((caps)
                                                                 (caps-action directory))
                                                                ((settings)
                                                                 (settings-action directory))
                                                                ((replay)
                                                                 (replay-action directory))))))
                                                (insert-newline self)
                                                directory)))))
                                   
                                   (let ((directory (receive-directory))
                                         (insertion-line (get-line (get-end self)))
                                         (insertion-col 0))
                                     (define (insert-at str style last?)
                                       (let ((insert-range (new Range$Cell$ (new Cell insertion-line insertion-col) (new Cell insertion-line insertion-col))))
                                         (replace-styled self insert-range (if last? (list str "") (list str)) style)
                                         (if (not last?)
                                             (increase! insertion-col (string-length str))
                                           (increase! insertion-line)
                                           (set! insertion-col 0)
                                           (ensure-displayed self))))
                                     
                                     (define (insert-string str (style 'Output))
                                       (insert-at str style #f))
                                     
                                     (define (insert str (style 'Output))
                                       (insert-at str style #t))
                                     
                                     (define (hack-around-text-bug)
                                       (layout-scrollee model))
                                     
                                     (insert-newline self)
                                     (display-prompt self)
                                     (register-request-procedure cookie
                                       (lambda (sender name chunk done?)
                                         (define (determine-info)
                                           (let ((key (cons sender name)))
                                             (or (table-ref infos key #f)
                                                 (let ((info (list (determine-file) #f #f (new-queue))))
                                                   (table-set! infos key info)
                                                   info))))
                                         
                                         (define (determine-missings)
                                           (let ((key sender))
                                             (or (table-ref missings key #f)
                                                 (let ((info (new-queue)))
                                                   (table-set! missings key info)
                                                   info))))
                                         
                                         (define (determine-file)
                                           (case what
                                             ((recording)
                                              (new-file directory (format "{a}_{a}" sender name)))
                                             ((transfer)
                                              (new-file directory action))
                                             (else
                                              (new-file directory (add-extension sender (->string what))))))
                                         
                                         (case what
                                           ((info)
                                            (when done?
                                              (let ((info (u8vector->object (zlib-inflate chunk))))
                                                (define (present-garbage-collect garbage-collect)
                                                  (format "{a}ms" (seconds->milliseconds garbage-collect)))
                                                
                                                (define (present-cpu% cpu%)
                                                  (format "{r precision: 1}%" cpu%))
                                                
                                                (define (present-meg bytes)
                                                  (format "{a}m" (meg bytes)))
                                                
                                                (define (meg bytes)
                                                  (fxround (/ bytes 1024. 1024.)))
                                                
                                                (if (eq? who 'server)
                                                    (bind (host service clients processors presences hierarchy garbage-collect cpu% threads live movable nonmovable udp outgoing) info
                                                      (define (present-hierarchy hierarchy)
                                                        (map (lambda (info)
                                                               (bind (group allow-audio-only? zone . members) info
                                                                 (cons group (cons allow-audio-only? (cons zone (map car members))))))
                                                             hierarchy))
                                                      
                                                      (insert (format "host         : {a}" host))
                                                      (insert (format "service      : {a}" service))
                                                      (insert (format "clients      : {a}" clients))
                                                      (insert (format "processors   : {a}" processors))
                                                      (insert (format "presences    : {a}" presences))
                                                      (insert (format "groups       : {a}" (present-hierarchy hierarchy)))
                                                      (insert (format "gc           : {a}" (present-garbage-collect garbage-collect)))
                                                      (insert (format "cpu%         : {a}" (present-cpu% cpu%)))
                                                      (insert (format "threads      : {a}" threads))
                                                      (insert (format "live         : {a}" (present-meg live)))
                                                      (insert (format "movable      : {a}" (present-meg movable)))
                                                      (insert (format "nonmovable   : {a}" (present-meg nonmovable)))
                                                      (insert (format "udp          : {a}" udp))
                                                      (insert (format "outgoing     : {a}" outgoing)))
                                                  (bind (version release effective-base-profile presences garbage-collect cpu% threads live movable nonmovable udp camera) info
                                                    (insert (format "version      : {a}" version))
                                                    (insert (format "release      : {a}" release))
                                                    (insert (format "profile      : {a}" effective-base-profile))
                                                    (insert (format "presences    : {a}" presences))
                                                    (insert (format "gc           : {a}" (present-garbage-collect garbage-collect)))
                                                    (insert (format "cpu%         : {a}" (present-cpu% cpu%)))
                                                    (insert (format "threads      : {a}" threads))
                                                    (insert (format "live         : {a}" (present-meg live)))
                                                    (insert (format "movable      : {a}" (present-meg movable)))
                                                    (insert (format "nonmovable   : {a}" (present-meg nonmovable)))
                                                    (insert (format "udp          : {a}" udp))
                                                    (insert (format "camera       : {a}" camera)))))))
                                           ((record)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)
                                              (hack-around-text-bug)))
                                           ((shared)
                                            (when done?
                                              (let ((filenames (u8vector->object (zlib-inflate chunk))))
                                                (for-each (lambda (filename)
                                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                                              (replace-styled self insert-range (list filename "")
                                                                (new Link-Style
                                                                  base: 'Link
                                                                  action: (lambda (text pos style)
                                                                            (let ((start (get-start self)))
                                                                              (insert-styled self (format "transfer {s} {s}" who filename) 'Entry)
                                                                              (let ((end (get-end self)))
                                                                                (let ((range (new Range$Cell$ start end)))
                                                                                  (console-evaluate self range)))))))
                                                              (ensure-displayed self)
                                                              (increase! insertion-line)))
                                                          filenames))))
                                           ((log)
                                            (when done?
                                              (let ((entries (u8vector->object (zlib-inflate chunk))))
                                                (define log-names
                                                  #(NONE G_ERROR G_CRITICAL G_WARNING GST_ERROR GST_WARNING))
                                                
                                                (define log-styles
                                                  #(LogNone LogGError LogGCritical LogGWarning LogGstError LogGstWarning))
                                                
                                                (define max-category
                                                  20)
                                                
                                                (define max-function
                                                  30)
                                                
                                                (define (present-category category)
                                                  (format "{a width: :v}"
                                                          (cond ((not category)
                                                                 "")
                                                                ((> (string-length category) max-category)
                                                                 (string-append (substring category 0 (- max-category 3)) "..."))
                                                                (else
                                                                 category))
                                                          max-category))
                                                
                                                (define (present-function function)
                                                  (format "{a width: :v}"
                                                          (cond ((not function)
                                                                 "")
                                                                ((> (string-length function) max-function)
                                                                 (string-append (substring function 0 (- max-function 3)) "..."))
                                                                (else
                                                                 function))
                                                          max-function))
                                                
                                                (for-each (lambda (entry)
                                                            (bind (time level category function message stack) entry
                                                              (let ((name (vector-ref log-names level))
                                                                    (style (vector-ref log-styles level)))
                                                                (insert-string (format "{r width: 9 justify: :right padding: #\\0 precision: 3}" time) 'Output)
                                                                (insert-string (format "   {a width: 11}" name) style)
                                                                (insert-string (format "   {a}" (present-category category)) 'Output)
                                                                (insert-string (format "   {a}" (present-function function)) 'Output)
                                                                (insert (format "   {a}" message) 'Output)
                                                                (ensure-displayed self))))
                                                          entries))))
                                           ((gst-device-monitor gst-inspect gst-launch gst-play)
                                            (when chunk
                                              (let ((line (u8vector->object (zlib-inflate chunk))))
                                                (insert line 'Output))))
                                           ((gst-done)
                                            (insert "done" 'Output))
                                           ((snapshot)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           ((attach)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           ((detach)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           (else
                                            (let ((info (determine-info))
                                                  (missings (determine-missings)))
                                              (if (eq? name 'missing)
                                                  (enqueue missings chunk)
                                                (bind (file name-end line-end chunks) info
                                                  (when (not chunk)
                                                    (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                                      (let ((end (get-end (replace-styled self insert-range (list (format "  {a}" (get-name file))) 'Output))))
                                                        (set-second! info end)
                                                        (replace-styled self (new Range$Cell$ end end) (list "" "") 'Output)
                                                        (ensure-displayed self)
                                                        (increase! insertion-line))))
                                                  (when chunk
                                                    (enqueue chunks chunk))
                                                  (when done?
                                                    (let ((thread
                                                            (new-thread
                                                              (lambda ()
                                                                (let ((deflated (apply u8vector-append (queue-list chunks))))
                                                                  (case what
                                                                    ((caps)
                                                                     (save-binary file (zlib-inflate deflated)))
                                                                    ((settings)
                                                                     (save-binary file (zlib-inflate deflated)))
                                                                    ((recording)
                                                                     (save-binary file (zlib-inflate deflated)))
                                                                    ((replay)
                                                                     (save-binary file deflated))
                                                                    ((transfer)
                                                                     (save-binary file (zlib-inflate deflated)))))
                                                                (when (eq? what 'replay)
                                                                  (let ((missings (queue-list missings)))
                                                                    (for-each (lambda (missing)
                                                                                (with-record media
                                                                                  (let ((channel-no (read-media-channel missing))
                                                                                        (sequence (read-media-sequence missing)))
                                                                                    (let ((info (table-ref receive-ring channel-no #f)))
                                                                                      (when info
                                                                                        (bind (channel-name origin kind source-kind ring) info
                                                                                          (let ((packet (locate-packet ring sequence)))
                                                                                            (when (and packet
                                                                                                       (not (get-data packet)))
                                                                                              (set-data packet missing)))))))))
                                                                              missings)
                                                                    (when udp-show-replay?
                                                                      (let ((len (length missings)))
                                                                        (when (> len 0)
                                                                          (format :terminal "Got {a} from {a}{%}" len sender)))))
                                                                  (let ()
                                                                    (define (media-channel name source-kind)
                                                                      (if (eq? source-kind 'live)
                                                                          ""
                                                                        (format ".{a}" name)))
                                                                    
                                                                    (define (media-extension kind)
                                                                      (if (= kind udp-audio)
                                                                          "replayaudio"
                                                                        "replayvideo"))
                                                                    
                                                                    (iterate-table send-ring
                                                                      (lambda (no info)
                                                                        (bind (channel-name origin kind source-kind ring) info
                                                                          (unless (= (get-count ring) 0)
                                                                            (let ((file (new-file directory (format "{a}{a}.{a}" (get-character-name client) (media-channel channel-name source-kind) (media-extension kind))))
                                                                                  (content (object->u8vector ring serialize)))
                                                                              (save-binary file content))))))
                                                                    (iterate-table receive-ring
                                                                      (lambda (no info)
                                                                        (bind (channel-name origin kind source-kind ring) info
                                                                          (let ((member (find-group-member-by-no client origin)))
                                                                            (let ((name (if member
                                                                                            (first member)
                                                                                          ;; quick hack
                                                                                          (if (= origin server-no)
                                                                                              "_server"
                                                                                            "_unknown"))))
                                                                              (unless (= (get-count ring) 0)
                                                                                (let ((file (new-file directory (format "{a}{a}.{a}" name (media-channel channel-name source-kind) (media-extension kind))))
                                                                                      (content (object->u8vector ring serialize)))
                                                                                  (save-binary file content))))))))))
                                                                (stylize-range self (new Range$Cell$ (new Cell (get-line name-end) 0) name-end)
                                                                  (new Link-Style
                                                                    base: 'Link
                                                                    action: (lambda (text pos style)
                                                                              (case what
                                                                                ((caps)
                                                                                 (let ((lines (load-lines file)))
                                                                                   (insert-line (format "show {a}" (get-name file)) 'Input)
                                                                                   (for-each (lambda (line)
                                                                                               (insert-line line 'Output))
                                                                                             lines)
                                                                                   (display-prompt self)))
                                                                                ((settings)
                                                                                 (let ((lines (load-lines file)))
                                                                                   (insert-line (format "show {a}" (get-name file)) 'Input)
                                                                                   (for-each (lambda (line)
                                                                                               (insert-line line 'Output))
                                                                                             lines)
                                                                                   (display-prompt self)))
                                                                                ((replay transfer)
                                                                                 (bell))))))
                                                                (let ((range (new Range$Cell$ name-end name-end)))
                                                                  (let ((end (get-end (replace-styled self range (list " done") 'Link))))
                                                                    (ensure-displayed self)
                                                                    (set-third! info (new Range$Cell$ end end)))))
                                                              'save)))
                                                      (thread-base-priority-set! thread background-priority)
                                                      (thread-start! thread)))))))))))))))))))
                    ((reset)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((successful? (admin-server-command client command arguments)))
                       (if (not successful?)
                           (insert-line "Unable to reset" 'Error)
                         (insert-line "Reset" 'Output)))
                     (insert-newline self)
                     (display-prompt self))
                    ((restart)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (admin-server-command client command arguments)
                     (insert-line "Restarting" 'Output)
                     (insert-newline self)
                     (display-prompt self))
                    ;((run)
                    ; (stylize-range model range (locate-style self 'Input))
                    ; (insert-newline self)
                    ; (if (null? arguments)
                    ;     (insert-error "Not enough arguments for run")
                    ;   (bind (script-no . rest) arguments
                    ;     (bind-optionals ((who #f)) rest
                    ;       (if (not (and (integer? script-no)
                    ;                     (between? script-no 0 9)))
                    ;           (insert-error (format "Script no expected: {s}" script-no))
                    ;         (let ((cookie (register-request-cookie))
                    ;               (script (load-text (find-script-no world script-no)))
                    ;               (who (if (or (not who) (eq? who 'me)) (get-character-name client) (->string who))))
                    ;           (let ((result (admin-server-command client command (list cookie script who))))
                    ;             (if (string? result)
                    ;                 (begin
                    ;                   (insert-line result 'Error)
                    ;                   (insert-newline self)
                    ;                   (display-prompt self))
                    ;               (let ((infos (make-table test: equal?))
                    ;                     (insertion-line (get-line (get-end self))))
                    ;                 (register-request-procedure cookie
                    ;                   (lambda (sender state data)
                    ;                     (define (determine-info)
                    ;                       (let ((key sender))
                    ;                         (or (table-ref infos key #f)
                    ;                             (let ((info (list #f)))
                    ;                               (table-set! infos key info)
                    ;                               info))))
                    ;                     
                    ;                     (define (present-state)
                    ;                       (case state
                    ;                         ((read)
                    ;                          (bind (reason location) data
                    ;                            (values 'Run-Read
                    ;                                    (truncate (format " {a}" (present reason)))
                    ;                                    (lambda (text pos style)
                    ;                                      (insert-line (format "show {a}" sender) 'Input)
                    ;                                      (insert-line reason 'Output)
                    ;                                      (insert-newline self)
                    ;                                      (display-prompt self)))))
                    ;                         ((walk)
                    ;                          (bind (reason detail) data
                    ;                            (values 'Run-Walk
                    ;                                    (truncate (format " {a}" (present reason)))
                    ;                                    (lambda (text pos style)
                    ;                                      (insert-line (format "show {a}" sender) 'Input)
                    ;                                      (insert-line reason 'Output)
                    ;                                      (insert-newline self)
                    ;                                      (display-prompt self)))))
                    ;                         ((error)
                    ;                          (bind (reason location stack) data
                    ;                            (values 'Run-Error
                    ;                                    (truncate (format " {a}" (present reason)))
                    ;                                    (lambda (text pos style)
                    ;                                      (insert-line (format "show {a}" sender) 'Input)
                    ;                                      (insert-line reason 'Output)
                    ;                                      (insert-newline self)
                    ;                                      (display-prompt self)))))
                    ;                         ((run)
                    ;                          (values 'Output #f #f))
                    ;                         ((result)
                    ;                          (values 'Run-Result
                    ;                                  (if (null? data)
                    ;                                      ""
                    ;                                    (truncate (format " {l detail: :human}" (map present data))))
                    ;                                  (lambda (text pos style)
                    ;                                    (insert-line (format "show {a}" sender) 'Input)
                    ;                                    (for-each (lambda (str)
                    ;                                                (insert-line str 'Output))
                    ;                                              data)
                    ;                                    (insert-newline self)
                    ;                                    (display-prompt self))))))
                    ;                     
                    ;                     (define (present str)
                    ;                       (substitute #\newline #\space str))
                    ;                     
                    ;                     (define (truncate str)
                    ;                       (let ((max-width 128))
                    ;                         (if (> (cardinality str) max-width)
                    ;                             (concatenate (subseq str 0 max-width) "...")
                    ;                           str)))
                    ;                     
                    ;                     (let ((info (determine-info)))
                    ;                       (let ((name-end (first info)))
                    ;                         (receive (style content action) (present-state)
                    ;                           (when (not name-end)
                    ;                             (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                    ;                               (let ((end (get-end (replace-styled self insert-range (list sender) style))))
                    ;                                 (set-first! info end)
                    ;                                 (replace-styled self (new Range$Cell$ end end) (list "" "") 'Output)
                    ;                                 (ensure-displayed self)
                    ;                                 (increase! insertion-line))))
                    ;                           (when content
                    ;                             (let ((name-end (first info)))
                    ;                               (stylize-range self (new Range$Cell$ (new Cell (get-line name-end) 0) name-end)
                    ;                                 (new Link-Style
                    ;                                   base: style
                    ;                                   action: action))
                    ;                               (let ((range (new Range$Cell$ name-end name-end)))
                    ;                                 (let ((end (get-end (replace-styled self range (list content) 'Output))))
                    ;                                   (ensure-displayed self)))
                    ;                               (hack-around-text-bug))))))))
                    ;                 (insert-newline self)
                    ;                 (display-prompt self))))))))))
                    ((stop)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (admin-server-command client command arguments)
                     (insert-line "Stopping" 'Output)
                     (insert-newline self)
                     (display-prompt self))
                    ((stream)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (action . rest) arguments
                       (let ((result (admin-server-command client command arguments)))
                         (case action
                           ((audio video media)
                            (insert-line (format "streaming {s}" result) 'Output))
                           ((list)
                            (for-each (lambda (info)
                                        (bind (base state) info
                                          (let ((insertion-pos #f))
                                            (insert-styled self base
                                              (new Link-Style
                                                base: 'Link
                                                action: (lambda (text pos style)
                                                          (define (replace str style)
                                                            (let ((insertion-line (get-line insertion-pos)))
                                                              (let ((insertion-end (new Cell insertion-line (paragraph-length self insertion-line))))
                                                                (let ((insertion-range (new Range$Cell$ insertion-pos insertion-end)))
                                                                  (replace-styled self insertion-range (list str) style)))))
                                                          
                                                          (cond ((not state)
                                                                 (replace " (starting)" 'Output)
                                                                 (register-server-streaming base)
                                                                 (let ((result (admin-server-command client 'stream (list 'play base (unspecified) (unspecified)))))
                                                                   (if result
                                                                       (replace (format " ({a})" result) 'Err)
                                                                     (replace " (playing)" 'Output)
                                                                     (set! state 'playing))))
                                                                (else
                                                                 (replace " (stopping)" 'Output)
                                                                 (unregister-server-streaming base)
                                                                 (let ((result (admin-server-command client 'stream (list 'stop base (unspecified) (unspecified)))))
                                                                   (if result
                                                                       (replace (format " ({a})" result) 'Err)
                                                                     (replace "" 'Output)
                                                                     (set! state #f))))))))
                                            (set! insertion-pos (get-end self)))
                                          (when state
                                            (insert-styled self (format " ({a})" state) 'Output))
                                          (insert-newline self)))
                                      result))
                           ((play)
                            (bind (location) rest
                              (if result
                                  (insert-line result 'Error)
                                (insert-line "playing" 'Output)
                                (register-server-streaming location))))
                           ((compare)
                            (bind (locations) rest
                              (if result
                                  (insert-line result 'Error)
                                (insert-line "comparing" 'Output)
                                (for-each register-server-streaming locations))))
                           ((stop)
                            (bind (location) rest
                              (if result
                                  (insert-line result 'Error)
                                (insert-line "stopped" 'Output)
                                (unregister-server-streaming location))))
                           ((done)
                            (if result
                                (insert-line result 'Error)
                              (insert-line "done" 'Output)))))
                       (insert-newline self)
                       (display-prompt self)))
                    ((test)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((lines (admin-server-command client command arguments)))
                       (if (not lines)
                           (insert-line "Test not found" 'Error)
                         (for-each (lambda (filename)
                                     (insert-line filename 'Output))
                                   lines)))
                     (insert-newline self)
                     (display-prompt self))
                    ((threads)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((lines (admin-server-command client command arguments)))
                       (for-each (lambda (line)
                                   (insert-line line 'Output))
                                 lines))
                     (insert-newline self)
                     (display-prompt self))
                    ((version)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((version (admin-server-command client command arguments)))
                       (insert-line version 'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((who)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((who (admin-server-command client command arguments)))
                       (for-each (lambda (name)
                                   (insert-line name 'Output))
                                 who))
                     (insert-newline self)
                     (display-prompt self))
                    ((clear)
                     (clear-console self))
                    ((help)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (what) arguments
                       (case what
                         ((help)
                          (insert-line "help -> list commands" 'Output)
                          (insert-line "help commands -> list commands" 'Output)
                          (insert-line "help <command> -> list <command>" 'Output)
                          (insert-line "help types -> list types" 'Output)
                          (insert-line "help <type> -> list <type>" 'Output)
                          (insert-line "help aliases -> list aliases" 'Output)
                          (insert-line "help help -> list help" 'Output))
                         ((types)
                          (for-each (lambda (info)
                                      (bind (name type desc) info
                                        (insert-line (format "<{a}> : {a}" name desc) 'Output)))
                                    types))
                         ((aliases)
                          (for-each (lambda (info)
                                      (bind (match replace) info
                                        (insert-line (format "{l} -> {l}" match replace) 'Output)))
                                    (world-setting 'world.console-aliases #f)))
                         (else
                          (let ((name (or (and (symbol? what) (symbol->variable what)) what)))
                            (let ((info (info-type name)))
                              (when info
                                (insert-line (format "<{a}> : {a}" name info) 'Output))))
                          (for-each (lambda (pattern)
                                      (when (cond ((eq? what 'commands) #t)
                                                  (else (eq? (car pattern) what)))
                                        (insert-line (format "{l}" pattern) 'Output)))
                                    commands)
                          (when what
                            (for-each (lambda (info)
                                        (bind (match replace) info
                                          (when (eq? (car match) what)
                                            (insert-line (format "{l} -> {l}" match replace) 'Output))))
                                      (world-setting 'world.console-aliases #f))))))
                     (insert-newline self)
                     (display-prompt self))))))
            (reset inserted))))))
  
  
  (method (clear-console self)
    (empty-text self)
    (display-banner self))
  
  
  (method (current-command self)
    (console-select-style self (text-ending self)
      (lambda (style)
        (inherits? style 'Entry)))))


;;;
;;;; Admin-Actions
;;;


(class Admin-Actions extends Actions
  
  
  (form
    (<install>
      (<Action-Item> name: clear           visible?: #t action-handler: {Event-Handler :focus on-clear} shortcut: {Shortcut :control #\L})
      (<Action-Item> name: insert-previous visible?: #t action-handler: {Event-Handler :focus on-insert-previous} shortcut: {Shortcut Tab} alternate-shortcut: {Shortcut :alt #\P})
      (<Action-Item> name: insert-next     visible?: #t action-handler: {Event-Handler :focus on-insert-next} shortcut: {Shortcut :shift Tab} alternate-shortcut: {Shortcut :alt #\N}))))


(definition admin-actions
  #f)

(definition (cache-admin-actions)
  (or admin-actions
      (let ((actions (new Admin-Actions)))
        (set! admin-actions actions)
        actions))))
