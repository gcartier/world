;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier Text
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.client.text jazz


(import (jazz.action)
        (jazz.console)
        (jazz.event)
        (jazz.exemplar)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.markup)
        (jazz.platform)
        (jazz.stream)
        (jazz.text)
        (jazz.zlib)
        (world)
        (world.asset)
        (world.audio)
        (world.circle)
        (world.client.request)
        (world.client.tier)
        (world.client.udp)
        (world.configure)
        (world.context)
        (world.evolution)
        (world.interface)
        (world.interface.evolution)
        (world.interface.text)
        (world.settings)
        (world.task)
        (world.udp))


;;;
;;;; Admin-Text
;;;


(class Admin-Text-View extends World-Text-View
  
  
  (slot inserted initialize (new Inserted))
  (slot banner   initialize #f getter generate)
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 8))
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set-default-style model {Text-Style Entry})
    (set-propagate-styles? model #f)
    (set-colorize? syntax #f)
    (add-style self 'Banner        {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Dark-Green}})
    (add-style self 'Prompt        {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Dark-Ochre}})
    (add-style self 'Entry         {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Purple}})
    (add-style self 'Input         {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Purple}})
    (add-style self 'Output        {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color White}})
    (add-style self 'Header        {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    (add-style self 'Link          {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    (add-style self 'Err           {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Red}})
    (add-style self 'Error         {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin} color: {Color World-Red}})
    (add-style self 'LogNone       {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color White}})
    (add-style self 'LogGError     {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Red}})
    (add-style self 'LogGCritical  {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Orange}})
    (add-style self 'LogGWarning   {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Yellow}})
    (add-style self 'LogGstError   {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Green}})
    (add-style self 'LogGstWarning {Text-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color Cyan}})
    ;(add-style self 'Run-Read      {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Orange}})
    ;(add-style self 'Run-Walk      {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Orange}})
    ;(add-style self 'Run-Error     {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Red}})
    ;(add-style self 'Run-Result    {Link-Style Text-Base font: {Font Code point-size: 14.5 shadow: thin} color: {Color World-Blue}})
    )
  
  
  (method override (focus-actions self)
    (cons (cache-admin-actions)
          (nextmethod self)))
  
  
  (method override (set-selection self range . rest)
    (apply nextmethod self range rest)
    (set-where inserted #f))
  
  
  (method package (on-clear self evt)
    (let ((current (get-string self (current-command self))))
      (clear-console self)
      (reset inserted)
      (unless (empty-string? current)
        (insert-styled self current {Text-Style Entry}))))
  
  
  (method package (on-insert-previous self evt)
    (console-insert-previous-block self inserted))
  
  
  (method package (on-insert-next self evt)
    (console-insert-next-block self inserted))
  
  
  (method package (initial-banner self banner)
    (set! self.banner banner)
    (display-banner self))
  
  
  (method package (display-banner self)
    (insert-styled self banner 'Banner)
    (insert-newline self)
    (insert-newline self)
    (display-prompt self))
  
  
  (method package (display-prompt self)
    (insert-styled self "> " 'Prompt))
  
  
  (method override (return-press self evt)
    (console-return self
      (lambda ()
        (console-evaluate self))))

  
  (method (console-evaluate self (range #f))
    (let ((client (current-client))
          (world (current-world)))
      (set-caret self (text-ending self))
      (let ((range (or range (current-command self))))
        (define (process-aliases all)
          (let ((aliases (world-setting 'world.console-aliases #f)))
            (if (not aliases)
                all
              (bind (command . arguments) all
                (let ((match (assq command aliases)))
                  (if (not match)
                      all
                    (append (cadr match) arguments)))))))
        
        (define (process-command/arguments all)
          (bind (command . arguments) all
            (define (parse-who)
              (if (null? arguments)
                  (values (get-character-name client) '())
                (bind (who . rest) arguments
                  (values (if (eq? who 'me) (get-character-name client) who) rest))))
            
            (case command
              ((caps)
               (receive (who rest) (parse-who)
                 (values 'request (list who 'caps))))
              ((info)
               (receive (who rest) (parse-who)
                 (values 'request (list who 'info))))
              ((shared)
               (receive (who rest) (parse-who)
                 (values 'request (list who 'shared))))
              ((transfer)
               (values 'request arguments))
              ((settings)
               (receive (who rest) (parse-who)
                 (bind-optionals ((action 'send)) rest
                   (values 'request (list who 'settings action)))))
              ((log)
               (receive (who rest) (parse-who)
                 (if (memq? who '(server all))
                     (format "Invalid who (valid values are me and <name>): {a}" who)
                   (values 'request (list who 'log)))))
              ((snapshot)
               (receive (who rest) (parse-who)
                 (values 'request (list who 'snapshot))))
              ((attach)
               (receive (who rest) (parse-who)
                 (let ((debugger (if (null? rest)
                                     (world-setting 'jazz.debugger ":56000")
                                   (->string (car rest)))))
                   (values 'request (list who 'attach debugger)))))
              ((detach)
               (receive (who rest) (parse-who)
                 (values 'request (list who 'detach))))
              (else
               (values command arguments)))))
        
        (let ((all (process-aliases (read-string-content (get-string self range)))))
          (unless (null? all)
            (let ((processed (process-command/arguments all)))
              (define (insert-line line style)
                (insert-styled self line style)
                (insert-newline self))
              
              (define (insert-error line)
                (insert-line line 'Error)
                (insert-newline self)
                (display-prompt self))
              
              (if (string? processed)
                  (begin
                    (insert-newline self)
                    (insert-error processed))
                (receive (command arguments) processed
                  (define (caps-action directory)
                    (iterate-directory directory
                      (lambda (file)
                        (let ((lines (load-lines file)))
                          (insert-line (format "show {a}" (get-name file)) 'Input)
                          (for-each (lambda (line)
                                      (insert-line line 'Output))
                                    lines)
                          (display-prompt self)))
                      recursive?: #f))
                  
                  (define (settings-action directory)
                    (iterate-directory directory
                      (lambda (file)
                        (let ((lines (load-lines file)))
                          (insert-line (format "show {a}" (get-name file)) 'Input)
                          (for-each (lambda (line)
                                      (insert-line line 'Output))
                                    lines)
                          (display-prompt self)))
                      recursive?: #f))
                  
                  (define (replay-action directory)
                    (if (alt-down?)
                        (process-replay-threaded directory)
                      (view-replay-directory directory)))
                  
                  (case command
                    ((date)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((date (admin-server-command client command arguments)))
                       (insert-line date 'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((daytime)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((daytime (admin-processor-command client command arguments)))
                       (insert-line (if (null? arguments)
                                        (format "{r precision: 1}" daytime)
                                      "daytime set")
                                    'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((version)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((version (admin-server-command client command arguments)))
                       (insert-line version 'Output))
                     (insert-newline self)
                     (display-prompt self))
                    ((who)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((who (admin-server-command client command arguments)))
                       (for-each (lambda (name)
                                   (insert-line name 'Output))
                                 who))
                     (insert-newline self)
                     (display-prompt self))
                    ((activity)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((log (admin-server-command client command arguments)))
                       (if (not log)
                           (insert-line "Activity log not found" 'Error)
                         (for-each (lambda (line)
                                     (insert-line line 'Output))
                                   (remove-trailing "" log test: equal?))))
                     (insert-newline self)
                     (display-prompt self))
                    ((threads)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((lines (admin-server-command client command arguments)))
                       (for-each (lambda (line)
                                   (insert-line line 'Output))
                                 lines))
                     (insert-newline self)
                     (display-prompt self))
                    ((disconnected)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((disconnected (admin-server-command client command arguments))
                           (first? #t))
                       (for-each (lambda (disconnected)
                                   (if first?
                                       (set! first? #f)
                                     (insert-newline self))
                                   (bind (name exception stack) disconnected
                                     (insert-line name 'Header)
                                     (for-each (lambda (line)
                                                 (insert-line line 'Header))
                                               (split-string exception #\newline))
                                     (for-each (lambda (frame)
                                                 (insert-line (format "  {a}" frame) 'Output))
                                               stack)))
                                 disconnected))
                     (insert-newline self)
                     (display-prompt self))
                    ((metadata)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (insert-line "metadata" 'Output)
                     (let ((metadata (admin-server-command client command arguments)))
                       (pp metadata)
                       (insert-newline self)
                       (display-prompt self)))
                    ((identity)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (bind (action) arguments
                       (let ((result (admin-server-command client command arguments)))
                         (case action
                           ((list)
                            (for-each (lambda (info)
                                        (insert-line (format "{l}" info) 'Output))
                                      result))
                           ((show)
                            (if result
                                (insert-line (format "{l}" result) 'Output)
                              (insert-line "Identity not found" 'Error)))
                           ((add)
                            (if result
                                (insert-line result 'Error)
                              (insert-line "added" 'Output)))
                           ((modify)
                            (if result
                                (insert-line result 'Error)
                              (insert-line "modified" 'Output)))
                           ((remove)
                            (if result
                                (insert-line result 'Error)
                              (insert-line "removed" 'Output))))))
                     (insert-newline self)
                     (display-prompt self))
                    ((latency)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (if (and (not-null? arguments)
                              (eq? (car arguments) 'me))
                         (bind-optionals ((latency #f)) (cdr arguments)
                           (let ((simulator (require-simulator (get-udp-client client))))
                             (setup-latency simulator latency)
                             (insert-line (if (not latency)
                                              "latency cleared"
                                            "latency set")
                                          'Output)))
                       (let ((who 'server))
                         (let ((result (admin-server-command client command (cons who arguments))))
                           (if result
                               (insert-line result 'Error)
                             (insert-line (if (null? arguments)
                                              "latency cleared"
                                            "latency set")
                                          'Output)))))
                     (insert-newline self)
                     (display-prompt self))
                    ((drop)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (if (and (not-null? arguments)
                              (eq? (car arguments) 'me))
                         (bind-optionals ((drop #f)) (cdr arguments)
                           (let ((simulator (require-simulator (get-udp-client client))))
                             (setup-drop simulator drop)
                             (insert-line (if (not drop)
                                              "drop cleared"
                                            "drop set")
                                          'Output)))
                       (let ((who 'server))
                         (let ((result (admin-server-command client command (cons who arguments))))
                           (if result
                               (insert-line result 'Error)
                             (insert-line (if (null? arguments)
                                              "drop cleared"
                                            "drop set")
                                          'Output)))))
                     (insert-newline self)
                     (display-prompt self))
                    ((test)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((lines (admin-server-command client command arguments)))
                       (if (not lines)
                           (insert-line "Test not found" 'Error)
                         (for-each (lambda (filename)
                                     (insert-line filename 'Output))
                                   lines)))
                     (insert-newline self)
                     (display-prompt self))
                    ((stop)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (admin-server-command client command arguments)
                     (insert-line "Stopping" 'Output)
                     (insert-newline self)
                     (display-prompt self))
                    ((restart)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (admin-server-command client command arguments)
                     (insert-line "Restarting" 'Output)
                     (insert-newline self)
                     (display-prompt self))
                    ((reset)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((successful? (admin-server-command client command arguments)))
                       (if (not successful?)
                           (insert-line "Unable to reset" 'Error)
                         (insert-line "Reset" 'Output)))
                     (insert-newline self)
                     (display-prompt self))
                    ((stream)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (if (null? arguments)
                         (insert-error "Not enough arguments for stream")
                       (let ((result (admin-server-command client command arguments)))
                         (bind (action . rest) arguments
                           (if (integer? action)
                               (if result
                                   (insert-line result 'Error)
                                 (insert-line (format "playing {s}" action) 'Output))
                             (case action
                               ((audio video media)
                                (insert-line (format "streaming {s}" result) 'Output))
                               ((list)
                                (for-each (lambda (info)
                                            (bind (base state) info
                                              (let ((insertion-pos #f))
                                                (insert-styled self base
                                                  (new Link-Style
                                                    base: 'Link
                                                    action: (lambda (text pos style)
                                                              (define (replace str style)
                                                                (let ((insertion-line (get-line insertion-pos)))
                                                                  (let ((insertion-end (new Cell insertion-line (paragraph-length self insertion-line))))
                                                                    (let ((insertion-range (new Range$Cell$ insertion-pos insertion-end)))
                                                                      (replace-styled self insertion-range (list str) style)))))
                                                              
                                                              (cond ((not state)
                                                                     (replace " (starting)" 'Output)
                                                                     (register-server-streaming base)
                                                                     (let ((result (admin-server-command client 'stream (list 'play base))))
                                                                       (if result
                                                                           (replace (format " ({a})" result) 'Err)
                                                                         (replace " (playing)" 'Output)
                                                                         (set! state 'playing))))
                                                                    (else
                                                                     (replace " (stopping)" 'Output)
                                                                     (unregister-server-streaming base)
                                                                     (let ((result (admin-server-command client 'stream (list 'stop base))))
                                                                       (if result
                                                                           (replace (format " ({a})" result) 'Err)
                                                                         (replace "" 'Output)
                                                                         (set! state #f))))))))
                                                (set! insertion-pos (get-end self)))
                                              (when state
                                                (insert-styled self (format " ({a})" state) 'Output))
                                              (insert-newline self)))
                                          result))
                               ((play)
                                (if result
                                    (insert-line result 'Error)
                                  (insert-line "playing" 'Output)
                                  (let ((base (car rest)))
                                    (register-server-streaming base))))
                               ((compare)
                                (if result
                                    (insert-line result 'Error)
                                  (insert-line "comparing" 'Output)
                                  (for-each register-server-streaming rest)))
                               ((stop)
                                (if result
                                    (insert-line result 'Error)
                                  (insert-line "stopped" 'Output)
                                  (let ((base (car rest)))
                                    (unregister-server-streaming base))))
                               ((done)
                                (if result
                                    (insert-line result 'Error)
                                  (insert-line "done" 'Output)))))))
                       (insert-newline self)
                       (display-prompt self)))
                    ((request)
                     (let ((udp-client (get-udp-client client))
                           (cookie (register-request-cookie)))
                       (define (extract-send-ring)
                         (let ((table (make-table test: equal?)))
                           (iterate-table (get-send-channels udp-client)
                             (lambda (no channel)
                               (let ((name (get-name (get-stream channel)))
                                     (origin (get-origin (get-stream channel)))
                                     (kind (get-media-kind channel))
                                     (source-kind (get-source-kind channel))
                                     (ring (get-replay-ring channel)))
                                 (when ring
                                   (let ((ring (copy-remember-ring ring)))
                                     (table-set! table no (list name origin kind source-kind ring)))))))
                           table))
                       
                       (define (extract-receive-ring)
                         (let ((table (make-table test: equal?)))
                           (iterate-table (get-receive-channels udp-client)
                             (lambda (no channel)
                               (let ((name (get-name (get-stream channel)))
                                     (origin (get-origin (get-stream channel)))
                                     (kind (get-media-kind channel))
                                     (source-kind (get-source-kind channel))
                                     (ring (get-replay-ring channel)))
                                 (when ring
                                   (let ((ring (copy-remember-ring ring)))
                                     (table-set! table no (list name origin kind source-kind ring)))))))
                           table))
                       
                       (stylize-range model range (locate-style self 'Input))
                       (insert-newline self)
                       (bind (who what . rest) arguments
                         (bind-optionals ((action 'send)) rest
                           (let ((send-ring (and (eq? what 'replay) (extract-send-ring)))
                                 (receive-ring (and (eq? what 'replay) (extract-receive-ring))))
                             (define (collect-receive-missing)
                               (let ((queue (new-queue))
                                     (count 0))
                                 (iterate-table receive-ring
                                   (lambda (no info)
                                     (bind (channel-name origin kind source-kind ring) info
                                       (let ((missing (collect-missing ring)))
                                         (when (not-null? missing)
                                           (let ((missing-count (length missing)))
                                             (enqueue queue (cons no missing))
                                             (increase! count missing-count)
                                             (when udp-show-replay?
                                               (format :terminal "Missing {a} in {a} ({a}){%}" missing-count channel-name (udp-name kind)))))))))
                                 (values (queue-list queue) count)))
                             
                             (when (eq? what 'replay)
                               (receive (missing count) (collect-receive-missing)
                                 (set! action missing)))
                             (let ((err (admin-server-command client command (list cookie (->string who) what action))))
                               (if err
                                   (begin
                                     (insert-line err 'Error)
                                     (insert-newline self)
                                     (display-prompt self))
                                 (let ((infos (make-table test: equal?))
                                       (missings (make-table test: equal?)))
                                   (define (receive-directory)
                                     (cond ((memq? what '(info shared log snapshot attach detach))
                                            #f)
                                           ((string? what)
                                            (let ((directory {Directory Documents "requested"}))
                                              (create-directories directory)
                                              directory))
                                           (else
                                            (let ((parent (if (eq? what 'replay)
                                                              {Directory Documents "replays"}
                                                            {Directory Documents "requested"})))
                                              (let ((directory (timestamped-directory parent (->string what))))
                                                (create-directories directory)
                                                (insert-styled self (get-name directory)
                                                  (new Link-Style
                                                    base: 'Link
                                                    action: (lambda (text pos style)
                                                              (case what
                                                                ((caps)
                                                                 (caps-action directory))
                                                                ((settings)
                                                                 (settings-action directory))
                                                                ((replay)
                                                                 (replay-action directory))))))
                                                (insert-newline self)
                                                directory)))))
                                   
                                   (let ((directory (receive-directory))
                                         (insertion-line (get-line (get-end self))))
                                     (insert-newline self)
                                     (display-prompt self)
                                     (register-request-procedure cookie
                                       (lambda (sender name chunk done?)
                                         (define (determine-info)
                                           (let ((key (cons sender name)))
                                             (or (table-ref infos key #f)
                                                 (let ((info (list (determine-file) #f #f (new-queue))))
                                                   (table-set! infos key info)
                                                   info))))
                                         
                                         (define (determine-missings)
                                           (let ((key sender))
                                             (or (table-ref missings key #f)
                                                 (let ((info (new-queue)))
                                                   (table-set! missings key info)
                                                   info))))
                                         
                                         (define (determine-file)
                                           (if (string? what)
                                               (new-file directory what)
                                             (new-file directory (add-extension sender (->string what)))))
                                         
                                         (case what
                                           ((info)
                                            (when done?
                                              (let ((info (u8vector->object (zlib-inflate chunk))))
                                                (define (insert line)
                                                  (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                                    (replace-styled self insert-range (list line "") 'Output)
                                                    (ensure-displayed self)
                                                    (increase! insertion-line)))
                                                
                                                (define (present-garbage-collect garbage-collect)
                                                  (format "{a}ms" (seconds->milliseconds garbage-collect)))
                                                
                                                (define (present-cpu% cpu%)
                                                  (format "{r precision: 1}%" cpu%))
                                                
                                                (define (present-meg bytes)
                                                  (format "{a}m" (meg bytes)))
                                                
                                                (define (meg bytes)
                                                  (fxround (/ bytes 1024. 1024.)))
                                                
                                                (if (eq? who 'server)
                                                    (bind (host service clients processors presences hierarchy garbage-collect cpu% threads live movable nonmovable udp outgoing) info
                                                      (define (present-hierarchy hierarchy)
                                                        (map (lambda (info)
                                                               (bind (group allow-audio-only? zone . members) info
                                                                 (cons group (cons allow-audio-only? (cons zone (map car members))))))
                                                             hierarchy))
                                                      
                                                      (insert (format "host         : {a}" host))
                                                      (insert (format "service      : {a}" service))
                                                      (insert (format "clients      : {a}" clients))
                                                      (insert (format "processors   : {a}" processors))
                                                      (insert (format "presences    : {a}" presences))
                                                      (insert (format "groups       : {a}" (present-hierarchy hierarchy)))
                                                      (insert (format "gc           : {a}" (present-garbage-collect garbage-collect)))
                                                      (insert (format "cpu%         : {a}" (present-cpu% cpu%)))
                                                      (insert (format "threads      : {a}" threads))
                                                      (insert (format "live         : {a}" (present-meg live)))
                                                      (insert (format "movable      : {a}" (present-meg movable)))
                                                      (insert (format "nonmovable   : {a}" (present-meg nonmovable)))
                                                      (insert (format "udp          : {a}" udp))
                                                      (insert (format "outgoing     : {a}" outgoing)))
                                                  (bind (version release effective-base-profile presences garbage-collect cpu% threads live movable nonmovable udp camera) info
                                                    (insert (format "version      : {a}" version))
                                                    (insert (format "release      : {a}" release))
                                                    (insert (format "profile      : {a}" effective-base-profile))
                                                    (insert (format "presences    : {a}" presences))
                                                    (insert (format "gc           : {a}" (present-garbage-collect garbage-collect)))
                                                    (insert (format "cpu%         : {a}" (present-cpu% cpu%)))
                                                    (insert (format "threads      : {a}" threads))
                                                    (insert (format "live         : {a}" (present-meg live)))
                                                    (insert (format "movable      : {a}" (present-meg movable)))
                                                    (insert (format "nonmovable   : {a}" (present-meg nonmovable)))
                                                    (insert (format "udp          : {a}" udp))
                                                    (insert (format "camera       : {a}" camera)))))))
                                           ((shared)
                                            (when done?
                                              (let ((filenames (u8vector->object (zlib-inflate chunk))))
                                                (for-each (lambda (filename)
                                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                                              (replace-styled self insert-range (list filename "")
                                                                (new Link-Style
                                                                  base: 'Link
                                                                  action: (lambda (text pos style)
                                                                            (let ((start (get-start self)))
                                                                              (insert-styled self (format "transfer {s} {s}" who filename) 'Entry)
                                                                              (let ((end (get-end self)))
                                                                                (let ((range (new Range$Cell$ start end)))
                                                                                  (console-evaluate self range)))))))
                                                              (ensure-displayed self)
                                                              (increase! insertion-line)))
                                                          filenames))))
                                           ((log)
                                            (when done?
                                              (let ((entries (u8vector->object (zlib-inflate chunk))))
                                                (define log-names
                                                  #(NONE G_ERROR G_CRITICAL G_WARNING GST_ERROR GST_WARNING))
                                                
                                                (define log-styles
                                                  #(LogNone LogGError LogGCritical LogGWarning LogGstError LogGstWarning))
                                                
                                                (define insertion-col
                                                  0)
                                                
                                                (define (insert str style (last? #f))
                                                  (let ((insert-range (new Range$Cell$ (new Cell insertion-line insertion-col) (new Cell insertion-line insertion-col))))
                                                    (replace-styled self insert-range (if last? (list str "") (list str)) style)
                                                    (increase! insertion-col (string-length str))))
                                                
                                                (for-each (lambda (entry)
                                                            (bind (time level message stack) entry
                                                              (let ((time (- time kernel-boot))
                                                                    (name (vector-ref log-names level))
                                                                    (style (vector-ref log-styles level)))
                                                                (insert (format "{r width: 9 justify: :right padding: #\\0 precision: 3}" time) 'Output)
                                                                (insert (format "   {a width: 11}" name) style)
                                                                (insert (format "   {a}" message) 'Output #t)
                                                                (ensure-displayed self)
                                                                (increase! insertion-line)
                                                                (set! insertion-col 0))))
                                                          entries))))
                                           ((snapshot)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           ((attach)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           ((detach)
                                            (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                              (replace-styled self insert-range (list name "") (if done? 'Output 'Error))
                                              (ensure-displayed self)))
                                           (else
                                            (let ((info (determine-info))
                                                  (missings (determine-missings)))
                                              (if (eq? name 'missing)
                                                  (enqueue missings chunk)
                                                (bind (file name-end line-end chunks) info
                                                  (when (not chunk)
                                                    (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                                                      (let ((end (get-end (replace-styled self insert-range (list (format "  {a}" (get-name file))) 'Output))))
                                                        (set-second! info end)
                                                        (replace-styled self (new Range$Cell$ end end) (list "" "") 'Output)
                                                        (ensure-displayed self)
                                                        (increase! insertion-line))))
                                                  (when chunk
                                                    (enqueue chunks chunk))
                                                  (when done?
                                                    (let ((thread
                                                            (new-thread
                                                              (lambda ()
                                                                (let ((deflated (apply u8vector-append (queue-list chunks))))
                                                                  (if (string? what)
                                                                      (save-binary file (zlib-inflate deflated))
                                                                    (case what
                                                                      ((caps)
                                                                       (save-binary file (zlib-inflate deflated)))
                                                                      ((settings)
                                                                       (save-binary file (zlib-inflate deflated)))
                                                                      ((replay)
                                                                       (save-binary file deflated)))))
                                                                (when (eq? what 'replay)
                                                                  (let ((missings (queue-list missings)))
                                                                    (for-each (lambda (missing)
                                                                                (let ((channel-no (read-udp-channel missing))
                                                                                      (sequence (read-udp-sequence missing)))
                                                                                  (let ((info (table-ref receive-ring channel-no #f)))
                                                                                    (when info
                                                                                      (bind (channel-name origin kind source-kind ring) info
                                                                                        (let ((packet (locate-packet ring sequence)))
                                                                                          (when (and packet
                                                                                                     (not (get-data packet)))
                                                                                            (set-data packet missing))))))))
                                                                              missings)
                                                                    (when udp-show-replay?
                                                                      (let ((len (length missings)))
                                                                        (when (> len 0)
                                                                          (format :terminal "Got {a} from {a}{%}" len sender)))))
                                                                  (let ()
                                                                    (define (media-channel name source-kind)
                                                                      (if (eq? source-kind 'live)
                                                                          ""
                                                                        (format ".{a}" name)))
                                                                    
                                                                    (define (media-extension kind)
                                                                      (if (= kind udp-audio)
                                                                          "replayaudio"
                                                                        "replayvideo"))
                                                                    
                                                                    (iterate-table send-ring
                                                                      (lambda (no info)
                                                                        (bind (channel-name origin kind source-kind ring) info
                                                                          (unless (= (get-count ring) 0)
                                                                            (let ((file (new-file directory (format "{a}{a}.{a}" (get-character-name client) (media-channel channel-name source-kind) (media-extension kind))))
                                                                                  (content (object->u8vector ring serialize)))
                                                                              (save-binary file content))))))
                                                                    (iterate-table receive-ring
                                                                      (lambda (no info)
                                                                        (bind (channel-name origin kind source-kind ring) info
                                                                          (let ((member (find-group-member-by-no client origin)))
                                                                            (let ((name (if member
                                                                                            (first member)
                                                                                          ;; quick hack
                                                                                          (if (= origin server-no)
                                                                                              "_server"
                                                                                            "_unknown"))))
                                                                              (unless (= (get-count ring) 0)
                                                                                (let ((file (new-file directory (format "{a}{a}.{a}" name (media-channel channel-name source-kind) (media-extension kind))))
                                                                                      (content (object->u8vector ring serialize)))
                                                                                  (save-binary file content))))))))))
                                                                (stylize-range self (new Range$Cell$ (new Cell (get-line name-end) 0) name-end)
                                                                  (new Link-Style
                                                                    base: 'Link
                                                                    action: (lambda (text pos style)
                                                                              (if (string? what)
                                                                                  (bell)
                                                                                (case what
                                                                                  ((caps)
                                                                                   (let ((lines (load-lines file)))
                                                                                     (insert-line (format "show {a}" (get-name file)) 'Input)
                                                                                     (for-each (lambda (line)
                                                                                                 (insert-line line 'Output))
                                                                                               lines)
                                                                                     (display-prompt self)))
                                                                                  ((settings)
                                                                                   (let ((lines (load-lines file)))
                                                                                     (insert-line (format "show {a}" (get-name file)) 'Input)
                                                                                     (for-each (lambda (line)
                                                                                                 (insert-line line 'Output))
                                                                                               lines)
                                                                                     (display-prompt self)))
                                                                                  ((replay)
                                                                                   (bell)))))))
                                                                (let ((range (new Range$Cell$ name-end name-end)))
                                                                  (let ((end (get-end (replace-styled self range (list " done") 'Link))))
                                                                    (ensure-displayed self)
                                                                    (set-third! info (new Range$Cell$ end end)))))
                                                              'save)))
                                                      (thread-base-priority-set! thread background-priority)
                                                      (thread-start! thread)))))))))))))))))))
                    ;((run)
                    ; (stylize-range model range (locate-style self 'Input))
                    ; (insert-newline self)
                    ; (if (null? arguments)
                    ;     (insert-error "Not enough arguments for run")
                    ;   (bind (script-no . rest) arguments
                    ;     (bind-optionals ((who #f)) rest
                    ;       (if (not (and (integer? script-no)
                    ;                     (between? script-no 0 9)))
                    ;           (insert-error (format "Script no expected: {s}" script-no))
                    ;         (let ((cookie (register-request-cookie))
                    ;               (script (load-text (find-script-no world script-no)))
                    ;               (who (if (or (not who) (eq? who 'me)) (get-character-name client) (->string who))))
                    ;           (let ((result (admin-server-command client command (list cookie script who))))
                    ;             (if (string? result)
                    ;                 (begin
                    ;                   (insert-line result 'Error)
                    ;                   (insert-newline self)
                    ;                   (display-prompt self))
                    ;               (let ((infos (make-table test: equal?))
                    ;                     (insertion-line (get-line (get-end self))))
                    ;                 (register-request-procedure cookie
                    ;                   (lambda (sender state data)
                    ;                     (define (determine-info)
                    ;                       (let ((key sender))
                    ;                         (or (table-ref infos key #f)
                    ;                             (let ((info (list #f)))
                    ;                               (table-set! infos key info)
                    ;                               info))))
                    ;                     
                    ;                     (define (present-state)
                    ;                       (case state
                    ;                         ((read)
                    ;                          (bind (reason location) data
                    ;                            (values 'Run-Read
                    ;                                    (truncate (format " {a}" (present reason)))
                    ;                                    (lambda (text pos style)
                    ;                                      (insert-line (format "show {a}" sender) 'Input)
                    ;                                      (insert-line reason 'Output)
                    ;                                      (insert-newline self)
                    ;                                      (display-prompt self)))))
                    ;                         ((walk)
                    ;                          (bind (reason detail) data
                    ;                            (values 'Run-Walk
                    ;                                    (truncate (format " {a}" (present reason)))
                    ;                                    (lambda (text pos style)
                    ;                                      (insert-line (format "show {a}" sender) 'Input)
                    ;                                      (insert-line reason 'Output)
                    ;                                      (insert-newline self)
                    ;                                      (display-prompt self)))))
                    ;                         ((error)
                    ;                          (bind (reason location stack) data
                    ;                            (values 'Run-Error
                    ;                                    (truncate (format " {a}" (present reason)))
                    ;                                    (lambda (text pos style)
                    ;                                      (insert-line (format "show {a}" sender) 'Input)
                    ;                                      (insert-line reason 'Output)
                    ;                                      (insert-newline self)
                    ;                                      (display-prompt self)))))
                    ;                         ((run)
                    ;                          (values 'Output #f #f))
                    ;                         ((result)
                    ;                          (values 'Run-Result
                    ;                                  (if (null? data)
                    ;                                      ""
                    ;                                    (truncate (format " {l detail: :human}" (map present data))))
                    ;                                  (lambda (text pos style)
                    ;                                    (insert-line (format "show {a}" sender) 'Input)
                    ;                                    (for-each (lambda (str)
                    ;                                                (insert-line str 'Output))
                    ;                                              data)
                    ;                                    (insert-newline self)
                    ;                                    (display-prompt self))))))
                    ;                     
                    ;                     (define (present str)
                    ;                       (substitute #\newline #\space str))
                    ;                     
                    ;                     (define (truncate str)
                    ;                       (let ((max-width 128))
                    ;                         (if (> (cardinality str) max-width)
                    ;                             (concatenate (subseq str 0 max-width) "...")
                    ;                           str)))
                    ;                     
                    ;                     (let ((info (determine-info)))
                    ;                       (let ((name-end (first info)))
                    ;                         (receive (style content action) (present-state)
                    ;                           (when (not name-end)
                    ;                             (let ((insert-range (new Range$Cell$ (new Cell insertion-line 0) (new Cell insertion-line 0))))
                    ;                               (let ((end (get-end (replace-styled self insert-range (list sender) style))))
                    ;                                 (set-first! info end)
                    ;                                 (replace-styled self (new Range$Cell$ end end) (list "" "") 'Output)
                    ;                                 (ensure-displayed self)
                    ;                                 (increase! insertion-line))))
                    ;                           (when content
                    ;                             (let ((name-end (first info)))
                    ;                               (stylize-range self (new Range$Cell$ (new Cell (get-line name-end) 0) name-end)
                    ;                                 (new Link-Style
                    ;                                   base: style
                    ;                                   action: action))
                    ;                               (let ((range (new Range$Cell$ name-end name-end)))
                    ;                                 (let ((end (get-end (replace-styled self range (list content) 'Output))))
                    ;                                   (ensure-displayed self)))
                    ;                               ;; hack around a text bug that I do not want to investigate at this time
                    ;                               (layout-scrollee model))))))))
                    ;                 (insert-newline self)
                    ;                 (display-prompt self))))))))))
                    ((list)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (if (null? arguments)
                         (insert-error "Not enough arguments for list")
                       (bind (what) arguments
                         (if (eq? what 'shared)
                             (iterate-directory {Directory Documents "shared"}
                               (lambda (file)
                                 (let ((name (get-name file)))
                                   (unless (filename=? name ".DS_Store")
                                     (insert-styled self name
                                       (new Link-Style
                                         base: 'Link
                                         action: (lambda (text pos style)
                                                   (bell))))
                                     (insert-newline self))))
                               files?: #t
                               directories?: #f
                               recursive?: #f)
                           (let ((prefix (case what
                                           ((caps) "caps_")
                                           ((settings) "settings_")
                                           ((replay) "replay_")
                                           ((profile) "profile_"))))
                             (iterate-directory (case what
                                                  ((replay) {Directory Documents "replays"})
                                                  ((profile) {Directory Documents "profiles"})
                                                  (else {Directory Documents "requested"}))
                               (lambda (dir)
                                 (let ((name (get-name dir)))
                                   (when (starts-with? name prefix)
                                     (insert-styled self name
                                       (new Link-Style
                                         base: 'Link
                                         action: (lambda (text pos style)
                                                   (case what
                                                     ((caps)
                                                      (caps-action dir))
                                                     ((settings)
                                                      (settings-action dir))
                                                     ((replay)
                                                      (replay-action dir))
                                                     ((profile)
                                                      (replay-action dir))))))
                                     (insert-newline self))))
                               files?: #f
                               directories?: #t
                               recursive?: #f))))
                       (insert-newline self)
                       (display-prompt self)))
                    @goes-into-request
                    ((settings)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (let ((info (admin-server-command client command arguments)))
                       (cond ((equal? arguments '(show))
                              (if (not info)
                                  (insert-line "No settings installed" 'Output)
                                (for-each (lambda (filename)
                                            (insert-line filename 'Output))
                                          info)))
                             ((equal? arguments '(clear))
                              (insert-line "Settings cleared" 'Output))
                             (else
                              (insert-line "Settings installed" 'Output))))
                     (insert-newline self)
                     (display-prompt self))
                    ((clear)
                     (clear-console self))
                    ((help)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (insert-line "activity" 'Output)
                     (insert-line "date" 'Output)
                     (insert-line "daytime <time>" 'Output)
                     (insert-line "info <who>" 'Output)
                     (insert-line "restart <seconds>" 'Output)
                     (insert-line "shared <who>" 'Output)
                     (insert-line "stop" 'Output)
                     (insert-line "stream <what>" 'Output)
                     (insert-line "version" 'Output)
                     (insert-line "clear" 'Output)
                     (insert-line "help" 'Output)
                     (insert-newline self)
                     (display-prompt self))
                    ((?)
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (insert-line "activity" 'Output)
                     (insert-line "attach <debugger>" 'Output)
                     (insert-line "date" 'Output)
                     (insert-line "daytime <time>" 'Output)
                     (insert-line "detach" 'Output)
                     (insert-line "disconnected" 'Output)
                     (insert-line "drop <who> <drop>" 'Output)
                     (insert-line "identity <action>" 'Output)
                     (insert-line "info <who>" 'Output)
                     (insert-line "latency <who> <latency>" 'Output)
                     (insert-line "list <what>" 'Output)
                     (insert-line "log <who>" 'Output)
                     (insert-line "metadata" 'Output)
                     (insert-line "request <what> <who>" 'Output)
                     (insert-line "reset <what>" 'Output)
                     (insert-line "restart <seconds>" 'Output)
                     (insert-line "settings <who> <filename>" 'Output)
                     (insert-line "shared <who>" 'Output)
                     (insert-line "snapshot <who>" 'Output)
                     (insert-line "stop" 'Output)
                     (insert-line "stream <what>" 'Output)
                     (insert-line "test <no>" 'Output)
                     (insert-line "threads" 'Output)
                     (insert-line "transfer <who> <filename>" 'Output)
                     (insert-line "version" 'Output)
                     (insert-line "who" 'Output)
                     (insert-line "clear" 'Output)
                     (insert-line "help / ?" 'Output)
                     (insert-newline self)
                     (display-prompt self))
                    (else
                     (stylize-range model range (locate-style self 'Input))
                     (insert-newline self)
                     (insert-line (format "Unknown command: {a}" command) 'Error)
                     (insert-newline self)
                     (display-prompt self))))))
            (reset inserted))))))
  
  
  (method (clear-console self)
    (empty-text self)
    (display-banner self))
  
  
  (method (current-command self)
    (console-select-style self (text-ending self)
      (lambda (style)
        (inherits? style 'Entry)))))


;;;
;;;; Admin-Actions
;;;


(class Admin-Actions extends Actions
  
  
  (form
    (<install>
      (<Action-Item> name: clear           visible?: #t action-handler: {Event-Handler :focus on-clear} shortcut: {Shortcut :control #\L})
      (<Action-Item> name: insert-previous visible?: #t action-handler: {Event-Handler :focus on-insert-previous} shortcut: {Shortcut Tab})
      (<Action-Item> name: insert-next     visible?: #t action-handler: {Event-Handler :focus on-insert-next} shortcut: {Shortcut :shift Tab}))))


(definition admin-actions
  #f)

(definition (cache-admin-actions)
  (or admin-actions
      (let ((actions (new Admin-Actions)))
        (set! admin-actions actions)
        actions))))
