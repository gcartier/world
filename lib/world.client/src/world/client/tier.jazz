;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.tier jazz


(import (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.graphic)
        (jazz.io)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.zlib)
        (world)
        (world.audio)
        (world.autoload)
        (world.camera)
        (world.change)
        (world.client)
        (world.client.request)
        (world.client.udp)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.id)
        (world.io)
        (world.log)
        (world.player)
        (world.protocol)
        (world.scriptum)
        (world.scriptum)
        (world.settings)
        (world.sound)
        (world.support)
        (world.task)
        (world.tier)
        (world.udp)
        (world.video))


(hub connect)
(hub disconnect)
(hub send-audio)
(hub send-video)


(class Client-Tier extends Tier
  
  
  (slot configuration                         getter generate)
  (slot state                  initialize #f  getter generate)
  (slot client-id              initialize #f  getter generate)
  (slot client-no              initialize #f  getter generate)
  (slot welcome                initialize #f  getter generate)
  (slot welcomed?              initialize #f  accessors generate)
  (slot mutex                                 getter generate)
  (slot form                   initialize #f  getter generate)
  (slot spawnpoint             initialize #f  getter generate)
  (slot player-spawnpoint      initialize #f  getter generate)
  (slot character-name         initialize #f  getter generate)
  (slot character-avatar       initialize #f  getter generate)
  (slot character-script       initialize #f  getter generate)
  (slot player-id              initialize #f  getter generate)
  (slot player-no              initialize #f  getter generate)
  (slot player-position        initialize #f  getter generate)
  (slot player-lookat          initialize #f  getter generate)
  (slot other-players          initialize #f  getter generate)
  (slot remote-client          initialize #f  getter generate)
  (slot remote-server          initialize #f  getter generate)
  (slot remote-processor       initialize #f  getter generate)
  (slot udp-client             initialize #f  getter generate)
  (slot group                  initialize #f  getter generate)
  (slot group-members          initialize '() getter generate)
  (slot players-cache                         getter generate)
  (slot server-entered-hook    initialize #f  accessors generate)
  (slot server-exited-hook     initialize #f  accessors generate)
  (slot processor-entered-hook initialize #f  accessors generate)
  (slot processor-exited-hook  initialize #f  accessors generate)
  (slot hierarchy-update-hook  initialize #f  accessors generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (set-connection-problem-handler
      (lambda (process connection remote-uuid)
        (catch (connection-exception? exc
                 (delay-bailout-client self exc))
          (process connection remote-uuid))))
    (set! configuration (if local?
                            (get-client-configuration)
                          (instantiate (read-form (new-file dir ".client")))))
    (set! mutex (make-mutex 'client))
    (set! assets (make-assets self directory))
    (set! players-cache (make-table test: eqv?))
    (connect-to-server self)
    (connect-to-udp-server self)
    (set-client-id/no client-id client-no))
  
  
  (method override (enter self)
    (let ((zone (current-zone))
          (me (current-me)))
      (set-spawnpoint zone spawnpoint)
      (set-player-spawnpoint zone player-spawnpoint)
      (set-name me character-name)
      (set-avatar me character-avatar)
      (register-id me player-id)
      (register-no me player-no)
      (set-position me player-position)
      (set-lookat me player-lookat)
      ;; quick hack around server not having camera info
      (set-position (player-camera me) player-position)
      (set-lookat (player-camera me) player-lookat)
      (for-each (lambda (info)
                  (bind (character-name character-avatar player-id player-no player-position player-lookat player-script) info
                    (add-player self character-name character-avatar player-id player-no player-position (make-standard-lookat) @why-is-it-corrupted??? player-lookat player-script)))
                other-players)
      (autostart (current-audio))
      (autostart (current-video))))
  
  
  (method override (shutdown self)
    (stop-to-server self)
    (stop (current-audio))
    (stop (current-video))
    (disconnect-from-udp-server self)
    (disconnect-from-server self)
    (when (and (not (get-server-host configuration))
               (not (get-server-service configuration)))
      (set-local-server #f)))
  
  
  (method package (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-cycle-topologies self evt)
    (cycle-topologies udp-client))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (when (effective-show-blocking?)
      (debug 'register-literal literal))
    (calling-server self
      (lambda ()
        (register-literal remote-server literal))))
  
  
  (method override (tier-id->literal self id)
    (let ((literal
            (calling-server self
              (lambda ()
                (registered-id remote-server id)))))
      (when (effective-show-blocking?)
        (debug 'registered-id id '-> literal))
      literal))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  ;; player info will be given by server
  (method override (setup-me self)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((player (new Player)))
        (new Camera parent: player)
        (set-current-me player)
        (when character-script
          (let ((script (new Script parent: player text: (load-asset-text (find-script world character-script)))))
            (run-task player script))))))
  
  
  ;;;
  ;;;; Remote
  ;;;
  
  
  (method override (unimplemented-connected self)
    (let ((world (current-world)))
      (unless (world-setting 'world.allow-connected? #f)
        (display-cancel world "Unimplemented when connected"))))


  ;;;
  ;;;; Server
  ;;;


  (method (connect-to-server self)
    (define (connect)
      (if local?
          local-server
        (let ((host (get-server-host configuration))
              (port (get-server-service configuration)))
          (assert (and host port)
            (start-remote-presence)
            (let ((remote-register (connect-remote-register host port)))
              (load-object remote-register 'world.server.remote 'world-remote-server))))))
    
    (set! character-name (get-character-name configuration))
    (set! character-avatar (get-character-avatar configuration))
    (set! character-script (get-character-script configuration))
    (let ((server (connect))
          (client (load-object (get-local-register) 'world.client.remote 'world-remote-client))
          (uuid (get-uuid (require-presence #f)))
          (character-zone (get-character-zone configuration)))
      (let ((info
              (calling-server self
                (lambda ()
                  (client-connect server client uuid character-name character-avatar character-script character-zone)))))
        (if (string? info)
            (begin
              (close-remote-proxy server)
              (throw info))
          (set! remote-client client)
          (set! remote-server server)
          (add-exit-job! (~ disconnect-from-server self))
          (bind (client-id client-no assets processor welcome form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) info
            (set! self.client-id client-id)
            (set! self.client-no client-no)
            (reset-last-forward)
            (set! self.remote-processor (if together? #f (connect-remote-proxy processor)))
            (set! self.welcome welcome)
            ;; open test quicky to send form as a string
            (set! self.form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from))
            (set! self.spawnpoint spawnpoint)
            (set! self.player-spawnpoint player-spawnpoint)
            (set! self.player-id player-id)
            (set! self.player-no player-no)
            (set! self.player-position player-position)
            (set! self.player-lookat player-lookat)
            (set! self.other-players other-players)
            (set! self.state 'connected)
            (load-point 'connected))))))
  
  
  (method (connect-to-udp-server self)
    (define (determine-parameters)
      (if local-server
          (values "localhost" "localhost" (get-service (remote-proxy->connection local-server)))
        (values "*" (get-server-host configuration) (get-server-service configuration))))
    
    (receive (local-host host service) (determine-parameters)
      (let ((client (new UDP-Client)))
        (connect client client-no local-host host service)
        (set! udp-client client))))
  
  
  (method (start-to-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-start remote-server remote-client)))
      (set! state 'started)))
  
  
  (method (stop-to-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-stop remote-server remote-client)))
      (set! state 'stopped)))
  
  
  (method (disconnect-from-udp-server self)
    (with-mutex self
      (lambda ()
        (when udp-client
          (stop udp-client)
          (disconnect udp-client)
          (set! udp-client #f)))))
  
  
  (method (disconnect-from-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-disconnect remote-server remote-client character-name)))
      (detach-from-server self)
      (set! state 'disconnected)))
  
  
  (method (detach-from-server self)
    (request-shutdown)
    (with-mutex self
      (lambda ()
        (when remote-server
          (close-remote-proxy remote-server)
          (set! remote-server #f)
          (set! remote-processor #f)
          (set! remote-client #f)))))
  
  
  (method package (detach-client self)
    (detach-from-server self)
    (if (window?)
        (let ((world (current-world)))
          (open-welcome world exception: "Disconnected from server"))
      (quit)))
  
  
  (method (bailout-client self exc)
    (if (window?)
        ;; this test is a simple solution
        ;; to having multiple threads bailout
        (unless (welcome? (current-zone))
          (detach-from-server self)
          (let ((world (current-world)))
            (open-welcome world exception: "Disconnected from server")))
      ;; too much for bots
      (unless bot?
        (snapshot-process exception: exc))
      (quit)))
  
  
  (method (delay-bailout-client self exc)
    (delay-event
      (lambda ()
        (with-maybe-task-mutex
          (lambda ()
            (bailout-client self exc))))))
  
  
  (method package (send-client-alive self)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-server
          (calling-server self
            (lambda ()
              (client-alive remote-server remote-client)))))))
  
  
  (method package (send-client-audio self buffer header? timestamp duration)
    (with-mutex self
      (lambda ()
        (when udp-client
          (send-audio udp-client buffer header? timestamp duration)))))
  
  
  (method package (send-client-video self buffer header? timestamp duration)
    (with-mutex self
      (lambda ()
        (when udp-client
          (send-video udp-client buffer header? timestamp duration)))))
  
  
  (method package (send-client-update self changes)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-processor
          (calling-processor self
            (lambda ()
              (client-update remote-processor remote-client (current-seconds) changes)))))))
  
  
  (method override (connected-player self no)
    (or (table-ref players-cache no #f)
        (let ((player (calling-server self
                        (lambda ()
                          (client-connected-player remote-server remote-client no)))))
          (table-set! players-cache no player)
          player)))
  
  
  (method override (connected-players self)
    (calling-server self
      (lambda ()
        (client-connected-players remote-server remote-client))))
  
  
  (method override (available-templates self)
    (calling-server self
      (lambda ()
        (client-available-templates remote-server remote-client))))
  
  
  (method override (available-zone-base self from)
    (calling-server self
      (lambda ()
        (client-available-zone-base remote-server remote-client from))))
  
  
  (method override (available-zone-base? self base)
    (calling-server self
      (lambda ()
        (client-available-zone-base? remote-server remote-client base))))
  
  
  (method override (create-zone self from base)
    (let ((zone (calling-server self
                  (lambda ()
                    (client-create-zone remote-server remote-client from base)))))
      (when zone
        (change-zone self zone))))
  
  
  (method override (available-zones self)
    (calling-server self
      (lambda ()
        (client-available-zones remote-server remote-client))))
  
  
  (method override (change-zone self zone)
    (let ((info (calling-server self
                  (lambda ()
                    (client-change-zone remote-server remote-client zone)))))
      (bind (processor form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) info
        (reset-last-forward)
        (set! self.remote-processor (connect-remote-proxy processor))
        ;; open test quicky to send form as a string
        (let ((form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from)))
          (set! self.form form)
          (set! self.spawnpoint spawnpoint)
          (set! self.player-spawnpoint player-spawnpoint)
          (set! self.player-id player-id)
          (set! self.player-no player-no)
          (set! self.player-position player-position)
          (set! self.player-lookat player-lookat)
          (set! self.other-players other-players)
          (close (current-zone))
          ;; quicky
          (let ((file (zone-file directory 'client)))
            (set-origin form file)
            (open-zone file form: form))))))
  
  
  (method package (create-group self name)
    (calling-server self
      (lambda ()
        (client-create-group remote-server remote-client name))))
  
  
  (method package (delete-group self name)
    (calling-server self
      (lambda ()
        (client-delete-group remote-server remote-client name))))
  
  
  (method package (disband-group self name)
    (calling-server self
      (lambda ()
        (client-disband-group remote-server remote-client name))))
  
  
  (method package (join-group self name)
    (calling-server self
      (lambda ()
        (client-join-group remote-server remote-client name))))
  
  
  (method package (leave-group self name)
    (calling-server self
      (lambda ()
        (client-leave-group remote-server remote-client name))))
  
  
  (method package (list-group-members self name)
    (calling-server self
      (lambda ()
        (client-list-group-members remote-server name))))
  
  
  (method package (list-hierarchy self)
    (calling-server self
      (lambda ()
        (client-list-hierarchy remote-server))))
  
  
  (method package (retrieve-asset self path)
    (calling-server self
      (lambda ()
        (retrieve-asset remote-server path))))
  
  
  (method override (retrieve-entity self id)
    (or (find-entity id)
        (if together?
            #f
          (let ((class-name+info (calling-processor self
                                   (lambda ()
                                     (retrieve-entity remote-processor id)))))
            (bind (class-name . info) class-name+info
              (when (effective-show-blocking?)
                (debug 'retrieve-entity id '-> class-name))
              (let ((class (class-name->class (current-world) class-name)))
                (let ((entity (unpackage class info)))
                  (when (or (eq? (get-name entity) 'NOT-FOUND)
                            (eq? (get-name entity) 'PLAYER))
                    (debug (get-name entity) entity))
                  entity)))))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method package (retrieve-region self region-index)
    (when (effective-show-blocking?)
      (debug 'retrieve-region region-index))
    (if together?
        #f
      (calling-processor self
        (lambda ()
          (retrieve-region remote-processor region-index)))))
  
  
  (method package (retrieve-chunk self region-index chunk-index chunk-digest)
    (when (effective-show-blocking?)
      (debug 'retrieve-chunk region-index chunk-index))
    (if together?
        #f
      (calling-processor self
        (lambda ()
          (retrieve-chunk remote-processor region-index chunk-index chunk-digest)))))
  
  
  (method package (pause-processor self)
    (calling-processor self
      (lambda ()
        (pause remote-processor))))
  
  
  (method package (unpause-processor self)
    (calling-processor self
      (lambda ()
        (unpause remote-processor))))
  
  
  (method package (client-message self kind recipient message)
    (calling-server self
      (lambda ()
        (client-message remote-server remote-client kind recipient message))))
  
  
  (method package (admin-command self command arguments)
    (calling-server self
      (lambda ()
        (admin-command remote-server remote-client command arguments))))
  
  
  (method package (admin-chunk self requester cookie sender name chunk done?)
    (calling-server self
      (lambda ()
        (admin-chunk remote-server requester cookie sender name chunk done?))))
  
  
  (method (calling-server self thunk)
    (calling-processing self thunk))
  
  
  (method (calling-processor self thunk)
    (calling-processing self thunk))
  
  
  (method (calling-processing self thunk)
    (let ((exit (current-exit)))
      (define (bailout exc)
        ;; else if the current thread is the mutex owner
        ;; and terminates the mutex will become abandoned
        (mutex-unlock! mutex)
        (if (not exit)
            (let ((restart (or (boot-restart) (event-restart))))
              (if restart
                  (continuation-graft restart
                    (lambda ()
                      (with-maybe-task-mutex
                        (lambda ()
                          (bailout-client self exc)))))
                (snapshot-process exception: (new Error message: "No exit"))
                (quit)))
          (continuation-graft exit
            (lambda ()
              (delay-bailout-client self exc)))))
      
      (catch (connection-exception? exc
               (bailout exc))
        (let ((result (thunk)))
          (if (eq? result disconnect-marker)
              (bailout (new Error message: "Received disconnect marker"))
            result)))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (add-player self character-name character-avatar player-id player-no player-position player-lookat player-script)
    (let ((zone (current-zone)))
      (let ((player (new Player name: character-name me?: #f avatar: character-avatar position: player-position lookat: player-lookat)))
        (register-id player player-id)
        (register-no player player-no)
        (set-name-pane player character-name color: (if player-script {Color World-Yellow} {Color World-Purple}))
        (add-element zone player))))
  
  
  (method (remove-player self character-name)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; sejour quicky
        (when player
          (remove-element zone player)))))
    
  
  (method package (server-entered self client-id client-no character-name)
    (when server-entered-hook
      (server-entered-hook character-name)))
  
  
  (method package (server-exited self character-name disconnected?)
    (when server-exited-hook
      (server-exited-hook character-name disconnected?)))

  
  (method package (processor-entered self client-id client-no character-name character-avatar character-script player-id player-no player-position player-lookat player-script)
    (let ((world (current-world)))
      (add-player self character-name character-avatar player-id player-no player-position player-lookat player-script)
      (if processor-entered-hook
          (processor-entered-hook character-name)
        (display-message world (format "{a} entered world" character-name)))))
  
  
  (method package (processor-exited self character-name)
    (let ((world (current-world)))
      (remove-player self character-name)
      (if processor-exited-hook
          (processor-exited-hook character-name)
        (display-message world (format "{a} exited world" character-name)))))
  
  
  (method package (processor-update self sent changes)
    ;; should probably be applied by a task
    (forward-changes sent (current-seconds) changes))
  
  
  (method package (processor-draw self id color alpha timestamp duration background slide?)
    (receive-processor-draw (current-video) id color alpha timestamp duration background slide?))
  
  
  (method package (server-message self sender kind message)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (let ((interface (current-interface)))
              (let ((chat (child interface 'chat)))
                (show-message chat sender kind message)
                (unless (equal? sender character-name)
                  (play-ambient-sound 'message volume: .25)))))))))
  
  
  (method package (server-protocol self protocol)
    @convert-to-presence
    (let ((uuid (get-uuid (get-ior remote-server))))
      (let ((connection (require-remote-connection uuid)))
        (set-protocol connection protocol))))
  
  
  (method package (peers-update self peers)
    (peers-update udp-client peers))
  
  
  (method package (hierarchy-update self hierarchy)
    (define (find-group)
      (continuation-capture
        (lambda (return)
          (for-each (lambda (info)
                      (bind (group . members) info
                        (when group
                          (for-each (lambda (member-info)
                                      (let ((name (car member-info)))
                                        (when (equal? name character-name)
                                          (continuation-return return info))))
                                    members))))
                    hierarchy)
          (cons #f '()))))
    
    (bind (new-group . new-group-members) (find-group)
      (let ((removed (difference group-members new-group-members test: equal?))
            (added (difference new-group-members group-members test: equal?)))
        (set! group new-group)
        (set! group-members new-group-members)
        ;; audio
        (let ((audio (current-audio)))
          (for-each (lambda (info)
                      (bind (name id no) info
                        (let ((output (find-output audio id)))
                          (when output
                            (close-output audio id output)))))
                    removed)
          (for-each (lambda (info)
                      (bind (name id no) info
                        (if (equal? name character-name)
                            (when audio-self?
                              (player-output audio id))
                          (player-output audio id))))
                    added))
        ;; video
        (let ((video (current-video)))
          (for-each (lambda (info)
                      (bind (name id no) info
                        (let ((output (find-output video id)))
                          (when output
                            (close-output video id output))
                          (when (equal? name character-name)
                            (let ((self-output (get-self-output video)))
                              (when self-output
                                (close-output video #f self-output)))))))
                    removed)
          (for-each (lambda (info)
                      (bind (name id no) info
                        (if (equal? name character-name)
                            (begin
                              ;; self output
                              (player-output video #f player: (current-me))
                              (when video-self?
                                (player-output video id)))
                          (player-output video id))))
                    added))
        ;; channel
        (let ((client (current-client)))
          (let ((udp-client (get-udp-client client)))
            (for-each (lambda (info)
                        (bind (name id no) info
                          (when (or (not (equal? name character-name))
                                    audio-self?)
                            (close-receive-channel udp-client no udp-audio))
                          (when (or (not (equal? name character-name))
                                    video-self?)
                            (close-receive-channel udp-client no udp-video))
                          (when (equal? name character-name)
                            (stop udp-client)
                            (close-send-channel udp-client udp-audio)
                            (close-send-channel udp-client udp-video))))
                      removed)
            (for-each (lambda (info)
                        (bind (name id no) info
                          (when (or (not (equal? name character-name))
                                    audio-self?)
                            (require-receive-channel udp-client no udp-audio))
                          (when (or (not (equal? name character-name))
                                    video-self?)
                            (require-receive-channel udp-client no udp-video))
                          (when (equal? name character-name)
                            (require-send-channel udp-client udp-audio)
                            (require-send-channel udp-client udp-video)
                            (start udp-client))))
                      added)))))
    (when hierarchy-update-hook
      (hierarchy-update-hook hierarchy)))
  
  
  (method (find-group-member-by-id self id)
    (find group-members id key: second return: 'item))
  
  
  (method (find-group-member-by-no self no)
    (find group-members no key: third return: 'item))
  
  
  (method package (pause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (pause-world world)))))))
  
  
  (method package (unpause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (unpause-world world)))))))
  
  
  (method package (goto-client self time)
    (post-event
      (lambda ()
        (let ((history (current-history)))
          (with-task-mutex
            (lambda ()
              (goto-time history time)))))))
  
  
  (method package (camera-client self pos lookat)
    (post-event
      (lambda ()
        (let ((camera (current-camera)))
          (with-task-mutex
            (lambda ()
              (camera-init camera pos lookat)))))))
  
  
  (method package (protocol-client self simulate?)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (set-simulate-protocol? simulate?)
              (if simulate-protocol?
                  (lock-history-tooltip world)
                (unlock-history-tooltip world))))))))
  
  
  (method package (position-client self rect)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:position-client-window rect))))))
  
  
  (method package (restore-client self)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:restore-client-window))))))
  
  
  (method package (admin-request self requester cookie what)
    (define (send-caps)
      (send-file 0 {File Settings "work" "logs" "client.caps"}))
    
    (define (send-crashes)
      )
    
    (define (send-evolution)
      (send-threaded 0
        (lambda ()
          (object->u8vector evolution serialize))))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (send-threaded name extract)
      (thread-start!
        (new-thread
          (lambda ()
            (let ((sender character-name))
              (admin-chunk self requester cookie sender name #f #f)
              (let ((content (extract)))
                (let ((deflated (zlib-deflate content)))
                  (admin-chunk self requester cookie sender name deflated #t)))))
          'request)))
    
    (case what
      ((caps)
       (send-caps))
      ((crashes)
       (send-crashes))
      ((evolution)
       (send-evolution))))
  
  
  (method package (admin-result self cookie sender name chunk done?)
    (let ((proc (registered-request-procedure cookie)))
      (proc sender name chunk done?)))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (tile-server remote-server))))))
  
  
  (method override (restore self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (restore-server remote-server))))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (calling-server self
        (lambda ()
          (client-log remote-server remote-client (current-seconds) message)))))))
