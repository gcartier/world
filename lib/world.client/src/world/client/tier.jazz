;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.client.tier jazz


(import (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.graphic)
        (jazz.jrm)
        (jazz.process)
        (jazz.settings)
        (world)
        (world.assets)
        (world.audio)
        (world.autoload)
        (world.camera)
        (world.change)
        (world.id)
        (world.io)
        (world.protocol)
        (world.scripter)
        (world.scripting)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.tier))


(class Client-Tier extends Tier
  
  
  (slot configuration                  getter generate)
  (slot mutex                          getter generate)
  (slot client-id        initialize #f getter generate)
  (slot client-no        initialize #f getter generate)
  (slot welcome          initialize #f getter generate)
  (slot welcomed?        initialize #f accessors generate)
  (slot form             initialize #f getter generate)
  (slot spawnpoint       initialize #f getter generate)
  (slot character-name   initialize #f getter generate)
  (slot character-avatar initialize #f getter generate)
  (slot character-script initialize #f getter generate)
  (slot player-id        initialize #f getter generate)
  (slot player-position  initialize #f getter generate)
  (slot player-lookat    initialize #f getter generate)
  (slot other-players    initialize #f getter generate)
  (slot remote-client    initialize #f getter generate)
  (slot remote-server    initialize #f getter generate)
  (slot remote-processor initialize #f getter generate)
  (slot players-cache                  getter generate)
  
  
  (method override (initialize dir)
    (nextmethod dir)
    (set! configuration (instantiate~ (read-form (new-file~ dir ".client"))))
    (set! mutex (make-mutex 'client))
    (set! assets (gather-assets 'tier (new-directory~ directory "assets")))
    (set! players-cache (make-table test: eqv?))
    (simulate-protocol 'world.client-protocol)
    ;; aec quicky
    (set-remote-problem-handler #f)
    (start-remote-switchboard)
    (connect-to-server)
    (set-client-id/no client-id client-no))
  
  
  (method override (enter)
    (let ((zone (current-zone))
          (me (current-me)))
      (set-spawnpoint~ zone spawnpoint)
      (set-name~ me character-name)
      (set-avatar~ me character-avatar)
      (register-id~ me player-id)
      (set-position~ me player-position)
      (set-lookat~ me player-lookat)
      ;; quick hack around server not having camera info
      (set-position~ (player-camera~ me) player-position)
      (set-lookat~ (player-camera~ me) player-lookat)
      (for-each (lambda (info)
                  (bind (character-name character-avatar player-id player-position player-lookat) info
                    (add-player character-name character-avatar player-id player-position player-lookat)))
                other-players)))
  
  
  (method override (shutdown)
    (disconnect-from-server))
  
  
  (method (with-mutex thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id literal)
    (when (effective-show-blocking?)
      (debug 'register-literal literal))
    (calling-server
      (lambda ()
        (register-literal~ remote-server literal))))
  
  
  (method override (tier-id->literal id)
    (let ((literal
            (calling-server
              (lambda ()
                (registered-id~ remote-server id)))))
      (when (effective-show-blocking?)
        (debug 'registered-id id '-> literal))
      literal))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  ;; player info will be given by server
  (method override (setup-me)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((player (new Player)))
        (new Camera parent: player)
        (set-current-me player)
        (when character-script
          (let ((script (new Script parent: player text: (load-script-text (find-script~ world character-script)))))
            (run-task~ player script))))))
  
  
  ;;;
  ;;;; Remote
  ;;;
  
  
  (method override (unimplemented-connected)
    (let ((world (current-world)))
      (unless (world-setting 'world.allow-connected? #f)
        (display-cancel~ world "Unimplemented when connected"))))


  ;;;
  ;;;; Server
  ;;;


  (method (connect-to-server)
    (set! character-name (get-character-name~ configuration))
    (set! character-avatar (get-character-avatar~ configuration))
    (set! character-script (get-character-script~ configuration))
    (let ((host (get-server-host~ configuration))
          (port (get-server-service~ configuration)))
      (assert (and host port)
        (let ((remote-register (connect-remote-register host port)))
          (let ((server (load-object~ remote-register 'world.server.remote 'world-remote-server))
                (client (load-object~ (get-local-register) 'world.client.remote 'world-remote-client)))
            (let ((info
                    ;; quick hack until changing instance is asynchronous as client-enter might spawn an instance
                    (parameterize ((receive-timeout 60))
                      (client-enter~ server client character-name character-avatar))))
              (if (string? info)
                  (throw info)
                (set! remote-client client)
                (set! remote-server server)
                (add-exit-job! disconnect-from-server)
                (bind (client-id client-no assets processor welcome form spawnpoint player-id player-position player-lookat other-players) info
                  (set! client-id~self client-id)
                  (set! client-no~self client-no)
                  (retrieve-assets assets)
                  (reset-last-forward)
                  (set! remote-processor~self (connect-remote-proxy processor))
                  (set! welcome~self welcome)
                  ;; open test quicky to send form as a string
                  (set! form~self (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from))
                  (set! spawnpoint~self spawnpoint)
                  (set! player-id~self player-id)
                  (set! player-position~self player-position)
                  (set! player-lookat~self player-lookat)
                  (set! other-players~self other-players)))))))))
  
  
  (method (disconnect-from-server)
    (when remote-server
      (client-exit~ remote-server remote-client character-name)
      (detach-from-server)))
  
  
  (method (detach-from-server)
    (with-mutex
      (lambda ()
        (close-remote-proxy remote-server)
        (set! remote-server #f)
        (set! remote-client #f))))
  
  
  (method (retrieve-assets server-assets)
    )
  
  
  (method (send-client-update changes)
    (with-mutex
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-processor
          (client-update~ remote-processor remote-client (current-seconds) changes)))))
  
  
  (method (send-client-alive)
    (with-mutex
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-server
          (client-alive~ remote-server remote-client)))))
  
  
  (method override (connected-player no)
    (or (table-ref players-cache no #f)
        (let ((player (calling-server
                        (lambda ()
                          (client-connected-player~ remote-server remote-client no)))))
          (table-set! players-cache no player)
          player)))
  
  
  (method override (connected-players)
    (calling-server
      (lambda ()
        (client-connected-players~ remote-server remote-client))))
  
  
  (method override (available-templates)
    (calling-server
      (lambda ()
        (client-available-templates~ remote-server remote-client))))
  
  
  (method override (available-zone-base from)
    (calling-server
      (lambda ()
        (client-available-zone-base~ remote-server remote-client from))))
  
  
  (method override (available-zone-base? base)
    (calling-server
      (lambda ()
        (client-available-zone-base?~ remote-server remote-client base))))
  
  
  (method override (create-zone from base)
    (let ((zone (calling-server
                  (lambda ()
                    (client-create-zone~ remote-server remote-client from base)))))
      (when zone
        (change-zone zone))))
  
  
  (method override (available-zones)
    (calling-server
      (lambda ()
        (client-available-zones~ remote-server remote-client))))
  
  
  (method override (change-zone zone)
    (calling-server
      (lambda ()
        ;; quick hack until changing zone is asynchronous
        (parameterize ((receive-timeout 60))
          (let ((info (client-change-zone~ remote-server remote-client zone)))
            (bind (processor form spawnpoint player-id player-position player-lookat other-players) info
              (reset-last-forward)
              (set! remote-processor~self (connect-remote-proxy processor))
              ;; open test quicky to send form as a string
              (let ((form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from)))
                (set! form~self form)
                (set! spawnpoint~self spawnpoint)
                (set! player-id~self player-id)
                (set! player-position~self player-position)
                (set! player-lookat~self player-lookat)
                (set! other-players~self other-players)
                (close~ (current-zone))
                ;; quicky
                (let ((file (zone-file directory 'client)))
                  (set-origin~ form file)
                  (open-zone file form: form)))))))))
  
  
  (method override (retrieve-entity id)
    (or (find-entity id)
        (calling-processor
          (lambda ()
            (let ((class-name+info (retrieve-entity~ remote-processor id)))
              (bind (class-name . info) class-name+info
                (when (effective-show-blocking?)
                  (debug 'retrieve-entity id '-> class-name))
                (let ((class (class-name->class~ (current-world) class-name)))
                  (unpackage~ class info))))))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (retrieve-region region-index)
    (when (effective-show-blocking?)
      (debug 'retrieve-region region-index))
    (calling-processor
      (lambda ()
        (retrieve-region~ remote-processor region-index))))
  
  
  (method (retrieve-chunk region-index chunk-index chunk-digest)
    (when (effective-show-blocking?)
      (debug 'retrieve-chunk region-index chunk-index))
    (calling-processor
      (lambda ()
        (retrieve-chunk~ remote-processor region-index chunk-index chunk-digest))))
  
  
  (method (client-message kind recipient message)
    (calling-server
      (lambda ()
        (client-message~ remote-server remote-client kind recipient message))))
  
  
  (method (calling-server thunk)
    ;; longer timeout while in development
    ;; as we might be running under a debugger
    (parameterize ((receive-timeout 60))
      (thunk)))
  
  
  (method (calling-processor thunk)
    ;; longer timeout while in development
    ;; as we might be running under a debugger
    (parameterize ((receive-timeout 60))
      (thunk)))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (add-player character-name character-avatar player-id player-position player-lookat)
    (let ((zone (current-zone)))
      (let ((player (new Player name: character-name me?: #f avatar: character-avatar position: player-position lookat: player-lookat)))
        (register-id~ player player-id)
        (set-billboard-name~ player character-name)
        (add-element~ zone player))))
  
  
  (method (remove-player character-name)
    (let ((zone (current-zone)))
      (let ((player (find-player~ zone character-name)))
        (remove-element~ zone player))))
  
  
  (method (server-entered client-id client-no character-name character-avatar player-id player-position player-lookat)
    (let ((world (current-world)))
      (add-player character-name character-avatar player-id player-position player-lookat)
      (debug-client 'server-entered client-id client-no character-name character-avatar player-id player-position player-lookat)
      (display-message~ world (format "{a} entered world" character-name))))
  
  
  (method (server-exited character-name)
    (let ((world (current-world)))
      (debug-client 'server-exited character-name)
      (remove-player character-name)
      (display-message~ world (format "{a} exited world" character-name))))
  
  
  (method (server-update sent changes)
    ;; should probably be applied by a task
    (forward-changes sent (current-seconds) changes))
  
  
  (method (server-message sender kind message)
    (post-event
      (lambda ()
        (let ((interface (current-interface)))
          (let ((chat (child~ interface 'chat)))
            (show-message~ chat sender kind message)
            (play-sound-file "sound/user/MapPing"))))))
  
  
  (method (server-protocol protocol)
    (let ((uuid (get-uuid~ (get-ior~ remote-server))))
      (let ((connection (require-remote-connection uuid)))
        (set-protocol~ connection protocol))))
  
  
  (method (detach-client)
    (detach-from-server)
    (if (window?)
        (let ((world (current-world)))
          (open-welcome~ world)
          (report-exception~ (current-zone) "Disconnected from server" #f))
      (quit-process~ (get-process))))
  
  
  (method (pause-client)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (pause-world~ world)))))))
  
  
  (method (unpause-client)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (unpause-world~ world)))))))
  
  
  (method (goto-client time)
    (post-event
      (lambda ()
        (let ((history (current-history)))
          (with-task-mutex
            (lambda ()
              (goto-time~ history time)))))))
  
  
  (method (camera-client pos lookat)
    (post-event
      (lambda ()
        (let ((camera (current-camera)))
          (with-task-mutex
            (lambda ()
              (camera-init camera pos lookat)))))))
  
  
  (method (protocol-client simulate?)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (set-simulate-protocol? simulate?)
              (if simulate-protocol?
                  (lock-history-tooltip~ world)
                (unlock-history-tooltip~ world))))))))
  
  
  (method (position-client rect)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:position-client rect))))))
  
  
  (method (restore-client)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:restore-client))))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile)
    (post-event
      (lambda ()
        (tile-server~ remote-server))))
  
  
  (method override (restore)
    (post-event
      (lambda ()
        (restore-server~ remote-server))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log message)
    (when (world-setting 'world.log? #f)
      (client-log~ remote-server remote-client (current-seconds) message)))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (debug-client . rest)
    (when (world-setting 'world.client.debug? #f)
      (client-debug~ remote-server remote-client rest)))))
