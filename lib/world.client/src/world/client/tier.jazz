;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.tier jazz


(import (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.listener)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.view)
        (jazz.zlib)
        (world)
        (world.audio)
        (world.autoload)
        (world.camera)
        (world.change)
        (world.chronology)
        (world.client)
        (world.client.request)
        (world.client.udp)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.id)
        (world.interface)
        (world.io)
        (world.log)
        (world.player)
        (world.profile)
        (world.profiling)
        (world.protocol)
        (world.ring)
        (world.scriptum)
        (world.scriptum)
        (world.settings)
        (world.sound)
        (world.stream)
        (world.streaming)
        (world.support)
        (world.task)
        (world.tier)
        (world.udp)
        (world.video))


(hub connect)
(hub disconnect)


(class Client-Tier extends Tier
  
  
  (slot configuration                         getter generate)
  (slot state                  initialize #f  getter generate)
  (slot client-id              initialize #f  getter generate)
  (slot client-no              initialize #f  getter generate)
  (slot welcome                initialize #f  getter generate)
  (slot welcomed?              initialize #f  accessors generate)
  (slot mutex                                 getter generate)
  (slot form                   initialize #f  getter generate)
  (slot spawnpoint             initialize #f  getter generate)
  (slot player-spawnpoint      initialize #f  getter generate)
  (slot character-name         initialize #f  getter generate)
  (slot character-avatar       initialize #f  getter generate)
  (slot character-script       initialize #f  getter generate)
  (slot player-id              initialize #f  getter generate)
  (slot player-no              initialize #f  getter generate)
  (slot player-position        initialize #f  getter generate)
  (slot player-lookat          initialize #f  getter generate)
  (slot other-players          initialize #f  getter generate)
  (slot remote-client          initialize #f  getter generate)
  (slot remote-server          initialize #f  getter generate)
  (slot remote-processor       initialize #f  getter generate)
  (slot group                  initialize #f  getter generate)
  (slot group-members          initialize '() getter generate)
  (slot players-cache                         getter generate)
  (slot udp-client             initialize #f  getter generate)
  (slot live-stream            initialize #f  accessors generate)
  (slot mic-channel            initialize #f  accessors generate)
  (slot camera-channel         initialize #f  accessors generate)
  (slot server-entered-hook    initialize #f  accessors generate)
  (slot server-exited-hook     initialize #f  accessors generate)
  (slot processor-entered-hook initialize #f  accessors generate)
  (slot processor-exited-hook  initialize #f  accessors generate)
  (slot hierarchy-update-hook  initialize #f  accessors generate)
  (slot stream-add-hook        initialize #f  accessors generate)
  (slot stream-remove-hook     initialize #f  accessors generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (if (remote-proxy? (get-controller-debugger))
        (set-connection-problem-handler #f)
      (set-connection-problem-handler
        (lambda (process connection remote-uuid)
          (catch (connection-exception? exc
                   (delay-bailout-client self exc))
            (process connection remote-uuid)))))
    (set! configuration (if local?
                            (get-client-configuration)
                          (instantiate (read-form (new-file dir ".client")))))
    (set! mutex (make-mutex 'client))
    (set! assets (make-assets self directory))
    (set! players-cache (make-table test: eqv?))
    (snapshot-properties (list user: (get-character-name configuration)))
    (connect-to-server self)
    (connect-to-udp-server self)
    (set-client-id/no client-id client-no))
  
  
  (method override (startup self)
    (nextmethod self)
    ;; open test quick hacks
    ;; be careful this was also done for server
    ;; and ended up resetting some literal being
    ;; registered during the boot process
    (world.history:reset-literals))
  
  
  (method override (enter self)
    (let ((zone (current-zone))
          (me (current-me)))
      (set-spawnpoint zone spawnpoint)
      (set-player-spawnpoint zone player-spawnpoint)
      (set-name me character-name)
      (set-avatar me character-avatar)
      (register-id me player-id)
      (register-no me player-no)
      (set-position me player-position)
      (set-lookat me player-lookat)
      ;; quick hack around server not having camera info
      (set-position (player-camera me) player-position)
      (set-lookat (player-camera me) player-lookat)
      (for-each (lambda (info)
                  (bind (character-name character-avatar player-id player-no player-position player-lookat player-script) info
                    (add-player self character-name character-avatar player-id player-no player-position (make-standard-lookat) @why-is-it-corrupted??? player-lookat player-script)))
                other-players)))
  
  
  (method override (shutdown self)
    (stop-to-server self)
    (close-live-stream self)
    (disconnect-from-udp-server self)
    (disconnect-from-server self)
    (when (and (not (get-server-host configuration))
               (not (get-server-service configuration)))
      (set-local-server #f)))
  
  
  (method override (get-udp-tier self)
    udp-client)
  
  
  (method package (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  @peer2peer
  (method (on-cycle-topologies self evt)
    (cycle-topologies udp-client))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (when (effective-show-blocking?)
      (debug 'register-literal literal))
    (calling-server self
      (lambda ()
        (register-literal remote-server literal))))
  
  
  (method override (tier-id->literal self id)
    (let ((literal
            (calling-server self
              (lambda ()
                (registered-id remote-server id)))))
      (when (effective-show-blocking?)
        (debug 'registered-id id '-> literal))
      literal))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  ;; player info will be given by server
  (method override (setup-me self)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((player (new Player)))
        (new Camera parent: player)
        (set-current-me player)
        (when character-script
          (let ((script (new Script parent: player text: (load-asset-text (find-script world character-script)))))
            (run-task player script))))))
  
  
  ;;;
  ;;;; Remote
  ;;;
  
  
  (method override (unimplemented-connected self)
    (let ((world (current-world)))
      (unless (world-setting 'world.allow-connected? #f)
        (display-cancel world "Unimplemented when connected"))))


  ;;;
  ;;;; Server
  ;;;


  (method (connect-to-server self)
    (define (connect)
      (if local?
          local-server
        (let ((host (get-server-host configuration))
              (port (get-server-service configuration)))
          (assert (and host port)
            (start-remote-presence)
            (let ((remote-register (connect-remote-register host port)))
              (load-object remote-register 'world.server.remote 'world-remote-server))))))
    
    (set! character-name (get-character-name configuration))
    (set! character-avatar (get-character-avatar configuration))
    (set! character-script (get-character-script configuration))
    (when character-name
      (set-fifo-prefix (format "{a}_" (downcase character-name))))
    (let ((server (connect))
          (client (load-object (get-local-register) 'world.client.remote 'world-remote-client))
          (uuid (get-uuid (require-presence #f)))
          (character-zone (get-character-zone configuration)))
      (let ((info
              (calling-server self
                (lambda ()
                  (client-connect server client uuid character-name character-avatar character-script character-zone current-role sphere?)))))
        (if (string? info)
            (begin
              (close-remote-proxy server)
              (throw info))
          (set! remote-client client)
          (set! remote-server server)
          (bind (client-id client-no assets processor welcome form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) info
            (set! self.client-id client-id)
            (set! self.client-no client-no)
            (reset-last-forward)
            (set! self.remote-processor (if sphere? (connect-remote-proxy processor) #f))
            (set! self.welcome welcome)
            ;; open test quicky to send form as a string
            (set! self.form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from))
            (set! self.spawnpoint spawnpoint)
            (set! self.player-spawnpoint player-spawnpoint)
            (set! self.player-id player-id)
            (set! self.player-no player-no)
            (set! self.player-position player-position)
            (set! self.player-lookat player-lookat)
            (set! self.other-players other-players)
            (set! self.state 'connected)
            (load-point 'connected))))))
  
  
  (method (connect-to-udp-server self)
    (define (determine-parameters)
      (if local-server
          (values "localhost" "localhost" (get-service (remote-proxy->connection local-server)))
        (values "*" (get-server-host configuration) (get-server-service configuration))))
    
    (receive (local-address host service) (determine-parameters)
      (let ((client (new UDP-Client client-no character-name)))
        (connect client local-address host service)
        (set! udp-client client)
        (set-?u client))))
  
  
  (method (start-to-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-start remote-server remote-client)))
      (set! state 'started)))
  
  
  (method (stop-to-server self)
    (when remote-server
      ;; COMMUNICATION quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-server)
        (calling-server self
          (lambda ()
            (client-stop remote-server remote-client))))
      (set! state 'stopped)))
  
  
  (method (sleep-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-sleep remote-server remote-client)))))))
  
  
  (method (wake-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-wake remote-server remote-client)))))))
  
  
  (method (disconnect-from-udp-server self)
    (with-mutex self
      (lambda ()
        (when udp-client
          (stop udp-client)
          (disconnect udp-client)
          (set! udp-client #f)))))
  
  
  (method (disconnect-from-server self)
    (when remote-server
      ;; COMMUNICATION quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-server)
        (calling-server self
          (lambda ()
            (client-disconnect remote-server remote-client character-name))))
      (detach-from-server self)
      (set! state 'disconnected)))
  
  
  (method (detach-from-server self)
    (request-shutdown)
    (with-mutex self
      (lambda ()
        (when remote-server
          (close-remote-proxy remote-server)
          (set! remote-server #f)
          (set! remote-processor #f)
          (set! remote-client #f)))))
  
  
  (method package (detach-client self)
    ;; together's login is not connected to the server
    ;; so going to the welcome screen takes care of it
    (unless together?
      (detach-from-server self))
    (if (window?)
        (let ((world (current-world)))
          (open-welcome world exception-title: "Disconnected from server"))
      (quit)))
  
  
  (method (bailout-client self exc)
    (if (window?)
        ;; this test is a simple solution
        ;; to having multiple threads bailout
        (let ((zone (current-zone+)))
          (unless (and zone (welcome? zone))
            ;; together's login is not connected to the server
            ;; so going to the welcome screen takes care of it
            (unless together?
              (detach-from-server self))
            (let ((world (current-world)))
              (open-welcome world exception-title: "Disconnected from server" exception: exc))))
      ;; too much for bots
      (unless bot?
        (snapshot-process exception: exc))
      (quit)))
  
  
  (method (delay-bailout-client self exc)
    (delay-event
      (lambda ()
        (with-reentrant-task-mutex
          (lambda ()
            (bailout-client self exc))))))
  
  
  (method package (send-client-alive self)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-server
          (calling-server self
            (lambda ()
              (client-alive remote-server remote-client)))))))
  
  
  (method package (send-client-media self channel-no buffer header? timestamp duration)
    (with-mutex self
      (lambda ()
        (when udp-client
          (send-media udp-client channel-no buffer header? timestamp duration)))))
  
  
  (method package (send-client-update self changes)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-processor
          (calling-processor self
            (lambda ()
              (client-update remote-processor remote-client (current-seconds) changes)))))))
  
  
  (method override (connected-player self no)
    (or (table-ref players-cache no #f)
        (let ((player (calling-server self
                        (lambda ()
                          (client-connected-player remote-server remote-client no)))))
          (table-set! players-cache no player)
          player)))
  
  
  (method override (connected-players self)
    (calling-server self
      (lambda ()
        (client-connected-players remote-server remote-client))))
  
  
  (method override (available-templates self)
    (calling-server self
      (lambda ()
        (client-available-templates remote-server remote-client))))
  
  
  (method override (available-zone-base self from)
    (calling-server self
      (lambda ()
        (client-available-zone-base remote-server remote-client from))))
  
  
  (method override (available-zone-base? self base)
    (calling-server self
      (lambda ()
        (client-available-zone-base? remote-server remote-client base))))
  
  
  (method override (create-zone self from base)
    (let ((zone (calling-server self
                  (lambda ()
                    (client-create-zone remote-server remote-client from base)))))
      (when zone
        (change-zone self zone))))
  
  
  (method override (available-zones self)
    (calling-server self
      (lambda ()
        (client-available-zones remote-server remote-client))))
  
  
  (method override (change-zone self zone)
    (let ((info (calling-server self
                  (lambda ()
                    (client-change-zone remote-server remote-client zone)))))
      (bind (processor form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) info
        (reset-last-forward)
        (set! self.remote-processor (connect-remote-proxy processor))
        ;; open test quicky to send form as a string
        (let ((form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from)))
          (set! self.form form)
          (set! self.spawnpoint spawnpoint)
          (set! self.player-spawnpoint player-spawnpoint)
          (set! self.player-id player-id)
          (set! self.player-no player-no)
          (set! self.player-position player-position)
          (set! self.player-lookat player-lookat)
          (set! self.other-players other-players)
          (close (current-zone))
          ;; quicky
          (let ((file (zone-file directory 'client)))
            (set-origin form file)
            (open-zone file form: form))))))
  
  
  (method package (create-group self name persistent?)
    (calling-server self
      (lambda ()
        (client-create-group remote-server remote-client name persistent?))))
  
  
  (method package (delete-group self name)
    (calling-server self
      (lambda ()
        (client-delete-group remote-server remote-client name))))
  
  
  (method package (disband-group self name)
    (calling-server self
      (lambda ()
        (client-disband-group remote-server remote-client name))))
  
  
  (method package (join-group self name)
    (calling-server self
      (lambda ()
        (client-join-group remote-server remote-client name))))
  
  
  (method package (leave-group self name)
    (calling-server self
      (lambda ()
        (client-leave-group remote-server remote-client name))))
  
  
  (method package (change-video-level self video-level)
    (calling-server self
      (lambda ()
        (client-change-video-level remote-server remote-client video-level))))
  
  
  (method package (register-stream self name source-kind video-level channels recipient)
    (calling-server self
      (lambda ()
        (client-register-stream remote-server remote-client character-name name source-kind video-level channels recipient))))
  
  
  (method package (unregister-stream self stream-no)
    ;; COMMUNICATION quicky around server closing the connection on shutdown
    (when (remote-proxy-connected? remote-server)
      (calling-server self
        (lambda ()
          (client-unregister-stream remote-server remote-client stream-no)))))
  
  
  (method package (stream-action self stream-no action arguments)
    (calling-server self
      (lambda ()
        (client-stream-action remote-server remote-client stream-no action arguments))))
  
  
  (method package (channel-action self channel-no action arguments)
    (calling-server self
      (lambda ()
        (client-channel-action remote-server remote-client channel-no action arguments))))
  
  
  (method package (list-group-members self name)
    (calling-server self
      (lambda ()
        (client-list-group-members remote-server name))))
  
  
  (method package (list-hierarchy self)
    (calling-server self
      (lambda ()
        (client-list-hierarchy remote-server))))
  
  
  (method package (retrieve-asset self path)
    (calling-server self
      (lambda ()
        (retrieve-asset remote-server path))))
  
  
  (method override (retrieve-entity self id)
    (or (find-entity id)
        (if (not sphere?)
            #f
          (let ((class-name+info (calling-processor self
                                   (lambda ()
                                     (retrieve-entity remote-processor id)))))
            (bind (class-name . info) class-name+info
              (when (effective-show-blocking?)
                (debug 'retrieve-entity id '-> class-name))
              (let ((class (class-name->class (current-world) class-name)))
                (let ((entity (unpackage class info)))
                  (when (or (eq? (get-name entity) 'NOT-FOUND)
                            (eq? (get-name entity) 'PLAYER))
                    (debug (get-name entity) entity))
                  entity)))))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method package (retrieve-region self region-index)
    (when (effective-show-blocking?)
      (debug 'retrieve-region region-index))
    (if (not sphere?)
        #f
      (calling-processor self
        (lambda ()
          (retrieve-region remote-processor region-index)))))
  
  
  (method package (retrieve-chunk self region-index chunk-index chunk-digest)
    (when (effective-show-blocking?)
      (debug 'retrieve-chunk region-index chunk-index))
    (if (not sphere?)
        #f
      (calling-processor self
        (lambda ()
          (retrieve-chunk remote-processor region-index chunk-index chunk-digest)))))
  
  
  (method package (pause-processor self)
    (calling-processor self
      (lambda ()
        (pause remote-processor))))
  
  
  (method package (unpause-processor self)
    (calling-processor self
      (lambda ()
        (unpause remote-processor))))
  
  
  (method package (client-message self kind recipient message)
    (calling-server self
      (lambda ()
        (client-message remote-server remote-client kind recipient message))))
  
  
  (method package (admin-command self command arguments)
    (calling-server self
      (lambda ()
        (admin-command remote-server remote-client command arguments))))
  
  
  (method package (admin-chunk self requester cookie sender name chunk done?)
    (calling-server self
      (lambda ()
        (admin-chunk remote-server requester cookie sender name chunk done?))))
  
  
  (method (calling-server self thunk)
    (calling-processing self thunk))
  
  
  (method (calling-processor self thunk)
    (calling-processing self thunk))
  
  
  (method (calling-processing self thunk)
    (let ((exit (current-exit)))
      (define (bailout exc)
        ;; else if the current thread is the mutex owner
        ;; and terminates the mutex will become abandoned
        (mutex-unlock! mutex)
        (if (not exit)
            (let ((restart (or (boot-restart) (event-restart))))
              (if restart
                  (continuation-graft restart
                    (lambda ()
                      (with-reentrant-task-mutex
                        (lambda ()
                          (bailout-client self exc)))))
                (snapshot-process exception: (new Error message: "No exit"))
                (quit)))
          (continuation-graft exit
            (lambda ()
              (delay-bailout-client self exc)))))
      
      (define (call)
        (let ((result (thunk)))
          (if (eq? result disconnect-marker)
              (bailout (new Error message: "Received disconnect marker"))
            result)))
      
      (if (remote-proxy? (get-controller-debugger))
          (call)
        (catch (connection-exception? exc
                 (bailout exc))
          (call)))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (add-player self character-name character-avatar player-id player-no player-position player-lookat player-script)
    (let ((zone (current-zone)))
      (let ((player (new Player name: character-name me?: #f avatar: character-avatar position: player-position lookat: player-lookat)))
        (register-id player player-id)
        (register-no player player-no)
        (set-name-pane player character-name color: (if player-script {Color World-Yellow} {Color World-Purple}))
        (add-element zone player))))
  
  
  (method (remove-player self character-name)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; sejour quicky
        (when player
          (remove-element zone player)))))
    
  
  (method package (server-entered self client-id client-no character-name)
    (when server-entered-hook
      (server-entered-hook character-name)))
  
  
  (method package (server-exited self character-name disconnected?)
    (when server-exited-hook
      (server-exited-hook character-name disconnected?)))

  
  (method package (processor-entered self client-id client-no character-name character-avatar character-script player-id player-no player-position player-lookat player-script)
    (let ((world (current-world)))
      (add-player self character-name character-avatar player-id player-no player-position player-lookat player-script)
      (if processor-entered-hook
          (processor-entered-hook character-name)
        (display-message world (format "{a} entered world" character-name)))))
  
  
  (method package (processor-exited self character-name)
    (let ((world (current-world)))
      (remove-player self character-name)
      (if processor-exited-hook
          (processor-exited-hook character-name)
        (display-message world (format "{a} exited world" character-name)))))
  
  
  (method package (processor-update self sent changes)
    ;; should probably be applied by a task
    (forward-changes sent (current-seconds) changes))
  
  
  (method package (processor-draw self id color alpha timestamp duration background slide?)
    (receive-processor-draw (current-video) id color alpha timestamp duration background slide?))
  
  
  (method package (server-message self sender kind message)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (let ((interface (current-interface)))
              (let ((chat (child interface 'chat)))
                (show-message chat sender kind message)
                (unless (eq? kind 'activity)
                  (unless (equal? sender character-name)
                    (play-ambient-sound 'message volume: .25))))))))))
  
  
  (method package (server-messages self messages)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (let ((interface (current-interface)))
              (let ((chat (child interface 'chat)))
                (for-each (lambda (message)
                            (bind (sender kind message) message
                              (show-message chat sender kind message)))
                          messages))))))))
  
  
  (method package (server-protocol self protocol)
    @convert-to-presence
    (let ((uuid (get-uuid (get-ior remote-server))))
      (let ((connection (require-remote-connection uuid)))
        (set-protocol connection protocol))))
  
  
  @peer2peer
  (method package (peers-update self peers)
    (peers-update udp-client peers))
  
  
  (method package (hierarchy-update self hierarchy)
    (define (find-group)
      (continuation-capture
        (lambda (return)
          (for-each (lambda (info)
                      (bind (group . members) info
                        (when group
                          (for-each (lambda (member-info)
                                      (let ((name (car member-info)))
                                        (when (equal? name character-name)
                                          (continuation-return return info))))
                                    members))))
                    hierarchy)
          (cons #f '()))))
    
    (bind (new-group . new-group-members) (find-group)
      (set! group new-group)
      (set! group-members new-group-members))
    (when hierarchy-update-hook
      (hierarchy-update-hook hierarchy)))
  
  
  (method package (stream-add self sender name stream-no origin source-kind video-level channels)
    (let ((stream (register-receive-stream udp-client sender name stream-no origin source-kind video-level)))
      (let ((receive-video-level (stream-receive-video-level stream)))
        (for-each (lambda (info)
                    (bind (channel-no media-kind source-kind level resolution framerate bitrate codec caps) info
                      (ecase media-kind
                        ((udp-audio)
                         (let ((channel (register-receive-channel udp-client stream-no channel-no origin media-kind source-kind level resolution framerate bitrate codec caps)))
                           (channel-output (current-audio) channel volume: (and (eq? source-kind 'stream) .5))
                           (let ((video-channel (locate-stream-video-channel (get-stream channel))))
                             (when video-channel
                               (let ((output (find-output (current-video) (get-no video-channel))))
                                 (when output
                                   (setup-audio (get-root (get-interface-pane output)))))))))
                        ((udp-video)
                         (let ((channel (register-receive-channel udp-client stream-no channel-no origin media-kind source-kind level resolution framerate bitrate codec caps)))
                           (when (or stream-compare? (eqv? level receive-video-level))
                             (channel-output (current-video) channel)))))))
                  channels))
      (when stream-add-hook
        (stream-add-hook stream))))
  
  
  (method package (stream-remove self stream-no)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (when stream-remove-hook
          (stream-remove-hook stream))
        (close-receive-stream udp-client stream))))
  
  
  (method package (streamer-update self origin video-level)
    (let ((video (current-video)))
      (iterate-table (get-receive-streams udp-client)
        (lambda (no stream)
          (when (and (get-video-level stream)
                     (= (get-origin stream) origin))
            (set-video-level stream video-level)
            (let ((receive-video-level (stream-receive-video-level stream)))
              (define (find-output)
                (find-if (lambda (output)
                           (let ((channel (get-channel output)))
                             (and channel
                                  (eq? (get-stream channel) stream))))
                         (get-ordered-outputs video)))
              
              (let ((output (find-output)))
                (when output
                  (let ((actual-channel (get-channel output)))
                    (iterate-table (get-channels stream)
                      (lambda (no channel)
                        (when (and (= (get-media-kind channel) udp-video)
                                   (= (get-level channel) receive-video-level)
                                   (neq? channel actual-channel))
                          (replace-output video output channel)))))))))))))
  
  
  (method package (action-stream self stream-no action arguments)
    (let ((stream (find-send-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (let ((action-proc (get-action-proc stream)))
          (when action-proc
            (action-proc stream action arguments))))))
  
  
  (method package (channel-remove self channel-no)
    (let ((channel (find-receive-channel udp-client channel-no)))
      ;; lets be robust
      (when channel
        (close-receive-channel udp-client channel))))
  
  
  (method package (action-channel self channel-no action arguments)
    (let ((channel (find-send-channel udp-client channel-no)))
      ;; lets be robust
      (when channel
        (let ((action-proc (get-action-proc channel)))
          (when action-proc
            (action-proc channel action arguments))))))
  
  
  (method (find-group-member-by-id self id)
    (find group-members id key: second return: 'item))
  
  
  (method (find-group-member-by-no self no)
    (find group-members no key: third return: 'item))
  
  
  (method package (pause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (pause-world world)))))))
  
  
  (method package (unpause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (unpause-world world)))))))
  
  
  (method package (goto-client self time)
    (post-event
      (lambda ()
        (let ((history (current-history)))
          (with-task-mutex
            (lambda ()
              (goto-time history time)))))))
  
  
  (method package (camera-client self pos lookat)
    (post-event
      (lambda ()
        (let ((camera (current-camera)))
          (with-task-mutex
            (lambda ()
              (camera-init camera pos lookat)))))))
  
  
  (method package (protocol-client self simulate?)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (set-simulate-protocol? simulate?)
              (if simulate-protocol?
                  (lock-history-tooltip world)
                (unlock-history-tooltip world))))))))
  
  
  (method package (position-client self rect)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:position-client-window rect))))))
  
  
  (method package (restore-client self)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:restore-client-window))))))
  
  
  (method (admin-metadata self)
    (define (send-streams)
      (streams-metadata (get-send-streams udp-client)))
    
    (define (receive-streams)
      (streams-metadata (get-receive-streams udp-client)))
    
    (list client-no character-name (send-streams) (receive-streams)))
  
  
  (method package (admin-request self requester cookie what action)
    (define (send-caps)
      (let ((file {File Settings "caps" "client.caps"}))
        (when (exists? file)
          (send-file 0 file))))
    
    (define (send-crashes)
      )
    
    (define (send-replay)
      (send-threaded 0
        (lambda ()
          (let ((metadata (admin-metadata self))
                (chronology (copy-chronology (current-chronology)))
                (evolution (copy-evolution (current-evolution))))
            (object->u8vector (list metadata chronology evolution) serialize)))
        (lambda ()
          (gather-replay-missing udp-client action))))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Documents "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file name)
      (let ((dir {Directory Documents "shared"}))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (send-threaded name extract (missing #f))
      (let ((thread
              (new-thread
                (lambda ()
                  (let ((sender character-name))
                    (admin-chunk self requester cookie sender name #f #f)
                    (let ((content (zlib-deflate (extract)))
                          (give-time .01))
                      (when missing
                        (let ((missing (missing)))
                          (for-each (lambda (missing)
                                      (sleep give-time)
                                      (admin-chunk self requester cookie sender 'missing missing #f))
                                    missing)))
                      (let ((content-size (u8vector-length content))
                            (max-size 8192))
                        (let (loop-chunk (part 0) (pos 0))
                          (let ((remain (- content-size pos)))
                            (when (> remain 0)
                              (sleep give-time)
                              (let ((chunk-size (min remain max-size)))
                                (let ((chunk (make-u8vector chunk-size))
                                      (done? (>= chunk-size remain)))
                                  (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                                  (admin-chunk self requester cookie sender name chunk done?))
                                (loop-chunk (+ part 1) (+ pos chunk-size))))))))))
                'request)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)))
    
    (define (process-settings)
      (let ((file {File Settings ".admin"}))
        (when (exists? file)
          (send-file 0 file))))
    
    (if (string? what)
        (send-shared-file what)
      (case what
        ((caps)
         (send-caps))
        ((crashes)
         (send-crashes))
        ((replay)
         (send-replay))
        ((shared)
         (send-shared))
        ((settings)
         (process-settings)))))
  
  
  (method package (admin-result self cookie sender name chunk done?)
    (let ((proc (registered-request-procedure cookie)))
      (proc sender name chunk done?)))
  
  
  (method package (change-base-profile self profile)
    (let ((video (current-video)))
      (unless (eq? profile base-profile)
        (set-base-profile profile)
        (change-graphic-profile profile)
        (change-video-profile profile)
        (change-camera-profile-override profile)
        (let ((video-profile (active-video-profile)))
          (let ((new-video-level (get-level video-profile))
                (new-video-name (get-name video-profile)))
            ;; server
            (change-video-level self new-video-level)
            ;; receive
            (iterate-table (get-receive-streams udp-client)
              (lambda (no stream)
                (define (find-output)
                  (find-if (lambda (output)
                             (let ((channel (get-channel output)))
                               (and channel
                                    (eq? (get-stream channel) stream))))
                           (get-ordered-outputs video)))
                
                (define (streaming-channel)
                  (continuation-capture
                    (lambda (return)
                      (let ((receive-video-level (stream-receive-video-level stream)))
                        (iterate-table (get-channels stream)
                          (lambda (no channel)
                            (when (= (get-media-kind channel) udp-video)
                              (let ((level (get-level channel)))
                                (when (eqv? level receive-video-level)
                                  (continuation-return return channel)))))))
                      #f)))
                
                (let ((output (find-output)))
                  (when output
                    (let ((actual-channel (get-channel output))
                          (streaming-channel (streaming-channel)))
                      (when (neq? streaming-channel actual-channel)
                        (replace-output video output streaming-channel)))))))
            ;; send
            (iterate-table (get-send-streams udp-client)
              (lambda (no stream)
                (define (find-self-output)
                  (find-if (lambda (output)
                             (let ((channel (get-channel output)))
                               (and channel
                                    (eq? (get-stream channel) stream))))
                           (get-ordered-outputs video)))
                
                (when (eq? (get-source-kind stream) 'stream)
                  (let ((self-output (find-self-output)))
                    (let ((self-channel (and self-output (get-channel self-output))))
                      (iterate-table (get-channels stream)
                        (lambda (no channel)
                          (when (= (get-media-kind channel) udp-video)
                            (let ((src (get-src (get-pipeline channel))))
                              (when (is? src File-Stream-Video-Src)
                                (let ((channel-level (get-level channel)))
                                  (let ((stream? (<= channel-level new-video-level)))
                                    (set-stream? src stream?)
                                    (when (and self-channel
                                               (neq? channel self-channel)
                                               (= channel-level new-video-level))
                                      (replace-output video self-output channel sync-audio?: #t))))))))))))))
            ;; camera
            (when (camera-playing? self)
              (let ((camera-pipeline (get-pipeline camera-channel)))
                (let ((pipeline (get-pipeline (get-src camera-pipeline))))
                  (let ((elements (get-elements camera-pipeline)))
                    (define (find-actual-consumer)
                      (find-if (lambda (element)
                                 (and (is? element Camera-Self-Consumer)
                                      (get-processing? element)))
                               elements))
                    
                    (define (find-new-consumer)
                      (find-if (lambda (element)
                                 (and (is? element Camera-Self-Consumer)
                                      (= (get-level (get-profile element)) new-video-level)))
                               elements))
                    
                    ;; self
                    (let ((actual-consumer (find-actual-consumer))
                          (new-consumer (find-new-consumer)))
                      (define (update-probe consumer on?)
                        (let ((profile (get-profile consumer)))
                          (let ((name (get-name profile))
                                (framerate (get-framerate profile)))
                            (let ((pad (gst_element_get_static_pad (gst_bin_get_by_name pipeline (tie "queueself{name}")) "sink")))
                              (let ((new-probe (if on?
                                                   (gst_pad_add_rate_probe pad framerate)
                                                 (gst_pad_add_drop_probe pad))))
                                (let ((probe (get-probe consumer)))
                                  (when probe
                                    (gst_pad_remove_probe pad probe)))
                                (set-probe consumer new-probe))))))
                      
                      (when (neq? new-consumer actual-consumer)
                        (update-probe new-consumer #t)
                        (let ((self-output (get-self-output video))
                              (self-consumer (get-self-consumer video)))
                          (let ((rank (if self-split? #f (and self-output (find-output-rank video self-output)))))
                            (let ((new-output (if self-split? #f (create-self-output new-consumer))))
                              (unless self-split?
                                (set-output new-consumer new-output))
                              (gst_app_sink_process_one new-consumer)
                              (update-probe actual-consumer #f)
                              (set-processing? actual-consumer #f)
                              (stop-processing actual-consumer)
                              (set-stream-state (get-output actual-consumer) #f)
                              (unless self-split?
                                (when self-output
                                  (close-self-output self-consumer))
                                (install-self-output new-consumer rank: rank)))))
                        (set-processing? new-consumer #t)
                        (start-processing new-consumer video-priority)))
                    ;; media
                    (for-each (lambda (element)
                                (when (is? element Camera-Video-Consumer)
                                  (let ((profile (get-profile element)))
                                    (let ((name (get-name profile))
                                          (level (get-level profile))
                                          (framerate (get-framerate profile)))
                                      (let ((processing? (<= level new-video-level)))
                                        (when (neq? processing? (get-processing? element))
                                          (let ((pad (gst_element_get_static_pad (gst_bin_get_by_name pipeline (tie "queue{name}")) "sink")))
                                            (let ((new-probe (if processing?
                                                                 (gst_pad_add_rate_probe pad framerate)
                                                               (gst_pad_add_drop_probe pad))))
                                              (let ((probe (get-probe element)))
                                                (when probe
                                                  (gst_pad_remove_probe pad probe)))
                                              (set-probe element new-probe)))
                                          (set-processing? element processing?)
                                          (if processing?
                                              (start-processing element video-priority)
                                            (stop-processing element))))))))
                              elements))))))))))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (require-live-stream self)
    (or live-stream
        (let ((channels (cons (make-mic-channel)
                              (make-camera-channels))))
          (let ((stream (make-stream "Live" 'live (camera-profile-override-level) channels)))
            ;; mic
            (let ((channel (locate-audio-channel stream)))
              (setup channel)
              (set! mic-channel channel))
            ;; camera
            (let ((channels (collect-video-channels stream)))
              (let ((pipeline (make-shared-camera-pipeline channels)))
                (for-each (lambda (channel)
                            (set-pipeline channel pipeline))
                          channels)
                ;; any channel will do as they all share the same pipeline
                (let ((channel (car channels)))
                  (setup channel)
                  (set! camera-channel channel))))
            (set! live-stream stream)
            stream))))
  
  
  (method package (close-live-stream self)
    (when live-stream
      (close-send-stream udp-client live-stream)
      (set! live-stream #f)
      (set! mic-channel #f)
      (set! camera-channel #f)))
  
  
  ;;;
  ;;;; Mic
  ;;;
  
  
  (method package (toggle-mic self)
    (if (mic-playing? self)
        (release-mic self)
      (play-mic self)))
  
  
  (method package (play-mic self)
    (let ((world (current-world)))
      (play mic-channel)
      (invalidate-self-output self)
      (update-parameter world 'audio)
      (display-on/off world "Audio" (mic-playing? self))))
  
  
  ;; the mic needs to be released for
  ;; the denoiser thread to terminate
  (method package (release-mic self)
    (let ((world (current-world)))
      (release mic-channel)
      (invalidate-self-output self)
      (update-parameter world 'audio)
      (display-on/off world "Audio" (mic-playing? self))))
  
  
  (method (invalidate-self-output self)
    (let ((video (current-video)))
      (let ((self-output (get-self-output video)))
        (when self-output
          (invalidate-state self-output)))))

  
  (method package (mic-playing? self)
    (and mic-channel
         (playing? mic-channel)))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method package (toggle-camera self)
    @processpresent
    (processreset)
    (if (camera-playing? self)
        (release-camera self)
      (play-camera self)))
  
  
  (method package (play-camera self)
    (let ((world (current-world)))
      (play camera-channel)
      (update-parameter world 'video)
      (display-on/off world "Video" (camera-playing? self))))
  
  
  (method package (release-camera self)
    (let ((world (current-world)))
      (release camera-channel)
      (update-parameter world 'video)
      (display-on/off world "Video" (camera-playing? self))))
  
  
  (method package (camera-playing? self)
    (and camera-channel
         (playing? camera-channel)))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method (invalidate-audio-state self output)
    (let ((audio (current-audio))
          (video (current-video)))
      (let ((channel (get-channel output)))
        (when channel
          (let ((video-channel (locate-stream-video-channel (get-stream channel))))
            (when video-channel
              (let ((output (find-output video (get-no video-channel))))
                (when output
                  (invalidate-state output #t)))))))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (tile-server remote-server))))))
  
  
  (method override (restore self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (restore-server remote-server))))))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (start-profile udp-client)
    (calling-server self
      (lambda ()
        (profile-start remote-server remote-client))))
  
  
  (method package (test-profile self test arguments)
    (calling-server self
      (lambda ()
        (profile-test remote-server remote-client test arguments))))
  
  
  (method package (retrieve-profiles self)
    (let ((server-profile
            (calling-server self
              (lambda ()
                (profile-retrieve remote-server remote-client))))
          (client-profile
            (retrieve-profile udp-client)))
      (values server-profile client-profile)))
  
  
  (method package (stop-profile self)
    (stop-profile udp-client)
    (calling-server self
      (lambda ()
        (profile-stop remote-server remote-client))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (calling-server self
        (lambda ()
          (client-log remote-server remote-client (current-seconds) message)))))))
