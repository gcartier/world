;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.tier jazz


(import (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.listener)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.view)
        (jazz.zlib)
        (world)
        (world.asset)
        (world.audio)
        (world.autoload)
        (world.build)
        (world.camera)
        (world.capabilities)
        (world.change)
        (world.chronology)
        (world.client)
        (world.client.request)
        (world.client.udp)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.id)
        (world.interface)
        (world.io)
        (world.log)
        (world.player)
        (world.profile)
        (world.profiling)
        (world.protocol)
        (world.ring)
        (world.scriptum)
        (world.script.remote)
        (world.settings)
        (world.sound)
        (world.stream)
        (world.streaming)
        (world.support)
        (world.task)
        (world.tier)
        (world.udp)
        (world.video))


(hub connect)
(hub disconnect)


(class Client-Tier extends Tier
  
  
  (slot configuration                           getter generate)
  (slot state                    initialize #f  getter generate)
  (slot client-id                initialize #f  getter generate)
  (slot client-no                initialize #f  getter generate)
  (slot welcome                  initialize #f  getter generate)
  (slot welcomed?                initialize #f  accessors generate)
  (slot mutex                                   getter generate)
  (slot form                     initialize #f  getter generate)
  (slot spawnpoint               initialize #f  getter generate)
  (slot player-spawnpoint        initialize #f  getter generate)
  (slot character-name           initialize #f  getter generate)
  (slot character-avatar         initialize #f  getter generate)
  (slot character-script         initialize #f  getter generate)
  (slot player-id                initialize #f  getter generate)
  (slot player-no                initialize #f  getter generate)
  (slot player-position          initialize #f  getter generate)
  (slot player-lookat            initialize #f  getter generate)
  (slot other-players            initialize #f  getter generate)
  (slot remote-client            initialize #f  getter generate)
  (slot remote-server            initialize #f  getter generate)
  (slot remote-processor         initialize #f  getter generate)
  (slot group                    initialize #f  getter generate)
  (slot group-members            initialize '() getter generate)
  (slot players-cache                           getter generate)
  (slot udp-client               initialize #f  getter generate)
  (slot live-stream              initialize #f  accessors generate)
  (slot mic-channel              initialize #f  accessors generate)
  (slot camera-channel           initialize #f  accessors generate)
  (slot server-entered-hook      initialize #f  accessors generate)
  (slot server-exited-hook       initialize #f  accessors generate)
  (slot server-disconnected-hook initialize #f  accessors generate)
  (slot server-reconnected-hook  initialize #f  accessors generate)
  (slot processor-entered-hook   initialize #f  accessors generate)
  (slot processor-exited-hook    initialize #f  accessors generate)
  (slot hierarchy-update-hook    initialize #f  accessors generate)
  (slot stream-addable-hook      initialize #f  accessors generate)
  (slot stream-add-hook          initialize #f  accessors generate)
  (slot stream-remove-hook       initialize #f  accessors generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (set-presence-process-handler
      (lambda (proc connection)
        (handle-exception-filter
          connection-exception?
          (lambda (exc)
            (bailout-client self exc (execution-stack)))
          (lambda ()
            (proc connection)))))
    (set! configuration (if local?
                            (get-client-configuration)
                          (instantiate (read-form (new-file dir ".client")))))
    (set! mutex (make-mutex 'client))
    (set! assets (make-assets self directory))
    (set! players-cache (make-table test: eqv?))
    (snapshot-user (get-character-name configuration))
    (connect-to-server self)
    (connect-to-udp-server self)
    (set-client-id/no client-id client-no))
  
  
  (method override (startup self)
    (nextmethod self)
    ;; open test quick hacks
    ;; be careful this was also done for server
    ;; and ended up resetting some literal being
    ;; registered during the boot process
    (world.history:reset-literals))
  
  
  (method override (enter self)
    (let ((zone (current-zone))
          (me (current-me)))
      (set-spawnpoint zone spawnpoint)
      (set-player-spawnpoint zone player-spawnpoint)
      (set-name me character-name)
      (set-avatar me character-avatar)
      (register-id me player-id)
      (register-no me player-no)
      (set-position me player-position)
      (set-lookat me player-lookat)
      ;; quick hack around server not having camera info
      (set-position (player-camera me) player-position)
      (set-lookat (player-camera me) player-lookat)
      (for-each (lambda (info)
                  (bind (character-name character-avatar player-id player-no player-position player-lookat player-script) info
                    (add-player self character-name character-avatar player-id player-no player-position (make-standard-lookat) @why-is-it-corrupted??? player-lookat player-script)))
                other-players)))
  
  
  (method override (shutdown self)
    (stop-to-server self)
    (close-live-stream self)
    (disconnect-from-udp-server self)
    (disconnect-from-server self)
    (when (and (not (get-server-host configuration))
               (not (get-server-service configuration)))
      (set-local-server #f)))
  
  
  (method override (get-udp-tier self)
    udp-client)
  
  
  (method package (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  @peer2peer
  (method (on-cycle-topologies self evt)
    (cycle-topologies udp-client))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (when (effective-show-blocking?)
      (debug 'register-literal literal))
    (calling-server self
      (lambda ()
        (register-literal remote-server literal))))
  
  
  (method override (tier-id->literal self id)
    (let ((literal
            (calling-server self
              (lambda ()
                (registered-id remote-server id)))))
      (when (effective-show-blocking?)
        (debug 'registered-id id '-> literal))
      literal))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  ;; player info will be given by server
  (method override (setup-me self)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((player (new Player)))
        (new Camera parent: player)
        (set-current-me player)
        (when character-script
          (let ((script (new Script parent: player text: (load-text (find-script world character-script)))))
            (run-task player script))))))
  
  
  ;;;
  ;;;; Remote
  ;;;
  
  
  (method override (unimplemented-connected self)
    (let ((world (current-world)))
      (unless (world-setting 'world.allow-connected? #f)
        (display-cancel world "Unimplemented when connected"))))


  ;;;
  ;;;; Server
  ;;;


  (method (connect-to-server self)
    (define (connect)
      (if local?
          local-server
        (let ((host (get-server-host configuration))
              (port (get-server-service configuration)))
          (assert (and host port)
            (start-remote-presence)
            (let ((remote-register (connect-remote-register host port)))
              (load-object remote-register 'world.server.remote 'world-remote-server))))))
    
    (set! character-name (get-character-name configuration))
    (set! character-avatar (get-character-avatar configuration))
    (set! character-script (get-character-script configuration))
    (when character-name
      (set-fifo-prefix (format "{a}_" (downcase character-name))))
    (let ((server (connect))
          (client (load-object (get-local-register) 'world.client.remote 'world-remote-client))
          (uuid (get-uuid (require-presence #f)))
          (character-zone (get-character-zone configuration)))
      (let ((info
              (calling-server self
                (lambda ()
                  (client-connect server client uuid character-name character-avatar character-script character-zone current-role sphere?)))))
        (if (string? info)
            (begin
              (close-remote-proxy server)
              (throw info))
          (set! remote-client client)
          (set! remote-server server)
          (bind (client-id client-no assets processor welcome form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) info
            (set! self.client-id client-id)
            (set! self.client-no client-no)
            (reset-last-forward)
            (set! self.remote-processor (if sphere? (connect-remote-proxy processor) #f))
            (set! self.welcome welcome)
            ;; open test quicky to send form as a string
            (set! self.form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from))
            (set! self.spawnpoint spawnpoint)
            (set! self.player-spawnpoint player-spawnpoint)
            (set! self.player-id player-id)
            (set! self.player-no player-no)
            (set! self.player-position player-position)
            (set! self.player-lookat player-lookat)
            (set! self.other-players other-players)
            (set! self.state 'connected)
            (load-point 'connected))))))
  
  
  (method (connect-to-udp-server self)
    (define (determine-parameters)
      (if local-server
          (values "localhost" "localhost" (get-service (remote-proxy->connection local-server)))
        (values "*" (get-server-host configuration) (get-server-service configuration))))
    
    (receive (local-address host service) (determine-parameters)
      (let ((client (new UDP-Client client-no character-name)))
        (connect client local-address host service)
        (set! udp-client client)
        (set-?u client))))
  
  
  (method (start-to-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-start remote-server remote-client)))
      (set! state 'started)))
  
  
  (method (stop-to-server self)
    (when remote-server
      ;; quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-server)
        (calling-server self
          (lambda ()
            (client-stop remote-server remote-client))))
      (set! state 'stopped)))
  
  
  (method (sleep-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-sleep remote-server remote-client)))))))
  
  
  (method (wake-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-wake remote-server remote-client)))))))
  
  
  (method (disconnect-from-udp-server self)
    (with-mutex self
      (lambda ()
        (when udp-client
          (stop udp-client)
          (disconnect udp-client)
          (set! udp-client #f)))))
  
  
  (method (disconnect-from-server self)
    (when remote-server
      ;; quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-server)
        (calling-server self
          (lambda ()
            (client-disconnect remote-server remote-client character-name))))
      (detach-from-server self)
      (set! state 'disconnected)))
  
  
  (method (detach-from-server self)
    (request-shutdown)
    (with-mutex self
      (lambda ()
        (when remote-server
          (close-remote-proxy remote-server)
          (set! remote-server #f)
          (set! remote-processor #f)
          (set! remote-client #f)))))
  
  
  (method package (detach-client self)
    (detach-from-server self)
    (if (window?)
        (let ((world (current-world)))
          (open-welcome world exception-title: "Disconnected from server"))
      (quit)))
  
  
  (method (bailout-client self exc (stack #f))
    (with-reentrant-task-mutex
      (lambda ()
        (if (window?)
            ;; this test is a simple solution
            ;; to having multiple threads bailout
            (let ((zone (current-zone+)))
              (unless (and zone (welcome? zone))
                (detach-from-server self)
                (let ((world (current-world)))
                  (open-welcome world exception-title: "Disconnected from server" exception: exc exception-stack: stack))))
          ;; too much for bots
          (unless bot?
            (snapshot-process exception: exc))
          (quit)))))
  
  
  (method package (send-client-alive self)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-server
          (calling-server self
            (lambda ()
              (client-alive remote-server remote-client)))))))
  
  
  (method package (send-client-media self channel-no buffer dts pts duration keyframe?)
    (with-mutex self
      (lambda ()
        (when udp-client
          (send-media udp-client channel-no buffer dts pts duration keyframe?)))))
  
  
  (method package (send-client-update self changes)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-processor
          (calling-processor self
            (lambda ()
              (client-update remote-processor remote-client (current-seconds) changes)))))))
  
  
  (method override (connected-player self no)
    (or (table-ref players-cache no #f)
        (let ((player (calling-server self
                        (lambda ()
                          (client-connected-player remote-server remote-client no)))))
          (table-set! players-cache no player)
          player)))
  
  
  (method override (connected-players self)
    (calling-server self
      (lambda ()
        (client-connected-players remote-server remote-client))))
  
  
  (method override (available-templates self)
    (calling-server self
      (lambda ()
        (client-available-templates remote-server remote-client))))
  
  
  (method override (available-zone-base self from)
    (calling-server self
      (lambda ()
        (client-available-zone-base remote-server remote-client from))))
  
  
  (method override (available-zone-base? self base)
    (calling-server self
      (lambda ()
        (client-available-zone-base? remote-server remote-client base))))
  
  
  (method override (create-zone self from base)
    (let ((zone (calling-server self
                  (lambda ()
                    (client-create-zone remote-server remote-client from base)))))
      (when zone
        (change-zone self zone))))
  
  
  (method override (available-zones self)
    (calling-server self
      (lambda ()
        (client-available-zones remote-server remote-client))))
  
  
  (method override (change-zone self zone)
    (let ((info (calling-server self
                  (lambda ()
                    (client-change-zone remote-server remote-client zone)))))
      (bind (processor form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) info
        (reset-last-forward)
        (set! self.remote-processor (connect-remote-proxy processor))
        ;; open test quicky to send form as a string
        (let ((form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from)))
          (set! self.form form)
          (set! self.spawnpoint spawnpoint)
          (set! self.player-spawnpoint player-spawnpoint)
          (set! self.player-id player-id)
          (set! self.player-no player-no)
          (set! self.player-position player-position)
          (set! self.player-lookat player-lookat)
          (set! self.other-players other-players)
          (close (current-zone))
          ;; quicky
          (let ((file (zone-file directory 'client)))
            (set-origin form file)
            (open-zone file form: form))))))
  
  
  (method package (create-group self name persistent?)
    (calling-server self
      (lambda ()
        (client-create-group remote-server remote-client name persistent?))))
  
  
  (method package (delete-group self name)
    (calling-server self
      (lambda ()
        (client-delete-group remote-server remote-client name))))
  
  
  (method package (disband-group self name)
    (calling-server self
      (lambda ()
        (client-disband-group remote-server remote-client name))))
  
  
  (method package (join-group self name)
    (calling-server self
      (lambda ()
        (client-join-group remote-server remote-client name))))
  
  
  (method package (leave-group self name)
    (calling-server self
      (lambda ()
        (client-leave-group remote-server remote-client name))))
  
  
  (method package (change-video-level self video-level)
    (calling-server self
      (lambda ()
        (client-change-video-level remote-server remote-client video-level))))
  
  
  (method package (register-stream self name source-kind video-level channels recipient)
    (calling-server self
      (lambda ()
        (client-register-stream remote-server remote-client character-name name source-kind video-level channels recipient))))
  
  
  (method package (unregister-stream self stream-no)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-unregister-stream remote-server remote-client stream-no)))))
  
  
  (method package (stream-action self stream-no action arguments)
    (calling-server self
      (lambda ()
        (client-stream-action remote-server remote-client stream-no action arguments))))
  
  
  (method package (channel-action self channel-no action arguments)
    (calling-server self
      (lambda ()
        (client-channel-action remote-server remote-client channel-no action arguments))))
  
  
  (method package (list-group-members self name)
    (calling-server self
      (lambda ()
        (client-list-group-members remote-server name))))
  
  
  (method package (list-hierarchy self)
    (calling-server self
      (lambda ()
        (client-list-hierarchy remote-server))))
  
  
  (method package (retrieve-asset self path)
    (calling-server self
      (lambda ()
        (retrieve-asset remote-server path))))
  
  
  (method override (retrieve-entity self id)
    (or (find-entity id)
        (if (not sphere?)
            #f
          (let ((class-name+info (calling-processor self
                                   (lambda ()
                                     (retrieve-entity remote-processor id)))))
            (bind (class-name . info) class-name+info
              (when (effective-show-blocking?)
                (debug 'retrieve-entity id '-> class-name))
              (let ((class (class-name->class (current-world) class-name)))
                (let ((entity (unpackage class info)))
                  (when (or (eq? (get-name entity) 'NOT-FOUND)
                            (eq? (get-name entity) 'PLAYER))
                    (debug (get-name entity) entity))
                  entity)))))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method package (retrieve-region self region-index)
    (when (effective-show-blocking?)
      (debug 'retrieve-region region-index))
    (if (not sphere?)
        #f
      (calling-processor self
        (lambda ()
          (retrieve-region remote-processor region-index)))))
  
  
  (method package (retrieve-chunk self region-index chunk-index chunk-digest)
    (when (effective-show-blocking?)
      (debug 'retrieve-chunk region-index chunk-index))
    (if (not sphere?)
        #f
      (calling-processor self
        (lambda ()
          (retrieve-chunk remote-processor region-index chunk-index chunk-digest)))))
  
  
  (method override (pause-tier self)
    (calling-processor self
      (lambda ()
        (pause remote-processor))))
  
  
  (method override (unpause-tier self)
    (calling-processor self
      (lambda ()
        (unpause remote-processor))))
  
  
  (method package (client-message self kind recipient message)
    (calling-server self
      (lambda ()
        (client-message remote-server remote-client kind recipient message))))
  
  
  (method package (admin-command self command arguments)
    (calling-server self
      (lambda ()
        (admin-command remote-server remote-client command arguments))))
  
  
  (method package (admin-request-chunk self requester cookie sender name chunk done?)
    (calling-server self
      (lambda ()
        (admin-request-chunk remote-server requester cookie sender name chunk done?))))
  
  
  ;(method package (admin-run-return self requester cookie sender state data)
  ;  (calling-server self
  ;    (lambda ()
  ;      (admin-run-return remote-server requester cookie sender state data))))
  
  
  (method (calling-server self thunk)
    (calling-processing self thunk))
  
  
  (method (calling-processor self thunk)
    (calling-processing self thunk))
  
  
  (method (calling-processing self thunk)
    (let ((exit (current-exit)))
      (define (bailout exc stack)
        ;; else if the current thread is the mutex owner
        ;; and terminates the mutex will become abandoned
        (mutex-unlock! mutex)
        (if (not exit)
            (let ((restart (or (boot-restart) (event-restart))))
              (if restart
                  (continuation-graft restart
                    (lambda ()
                      (bailout-client self exc stack)))
                (snapshot-process exception: (new Error message: "No exit"))
                (quit)))
          (continuation-graft exit
            (lambda ()
              (bailout-client self exc stack)))))
      
      (define (call)
        (let ((result (thunk)))
          (if (eq? result disconnect-marker)
              (bailout (new Error message: "Received disconnect marker") (execution-stack))
            result)))
      
      (handle-exception-filter
        connection-exception?
        (lambda (exc)
          (bailout exc (execution-stack)))
        (lambda ()
          (call)))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (add-player self character-name character-avatar player-id player-no player-position player-lookat player-script)
    (let ((zone (current-zone)))
      (let ((player (new Player name: character-name me?: #f avatar: character-avatar position: player-position lookat: player-lookat)))
        (register-id player player-id)
        (register-no player player-no)
        (set-name-pane player character-name color: (if player-script {Color World-Yellow} {Color World-Purple}))
        (add-element zone player))))
  
  
  (method (remove-player self character-name)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; sejour quicky
        (when player
          (remove-element zone player)))))
    
  
  (method package (server-entered self client-id client-no character-name)
    (when server-entered-hook
      (server-entered-hook character-name)))
  
  
  (method package (server-exited self character-name)
    (when server-exited-hook
      (server-exited-hook character-name)))
  
  
  (method package (server-disconnected self character-name)
    (when server-disconnected-hook
      (server-disconnected-hook character-name)))
  
  
  (method package (server-reconnected self character-name)
    (when server-reconnected-hook
      (server-reconnected-hook character-name)))

  
  (method package (processor-entered self client-id client-no character-name character-avatar character-script player-id player-no player-position player-lookat player-script)
    (let ((world (current-world)))
      (add-player self character-name character-avatar player-id player-no player-position player-lookat player-script)
      (if processor-entered-hook
          (processor-entered-hook character-name)
        (display-message world (format "{a} entered world" character-name)))))
  
  
  (method package (processor-exited self character-name)
    (let ((world (current-world)))
      (remove-player self character-name)
      (if processor-exited-hook
          (processor-exited-hook character-name)
        (display-message world (format "{a} exited world" character-name)))))
  
  
  (method package (processor-update self sent changes)
    ;; should probably be applied by a task
    (forward-changes sent (current-seconds) changes))
  
  
  (method package (processor-draw self id color alpha dts pts duration background slide?)
    (receive-processor-draw (current-video) id color alpha dts pts duration background slide?))
  
  
  (method package (server-message self sender kind message)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (let ((interface (current-interface)))
              (let ((chat (child interface 'chat)))
                (show-message chat sender kind message)
                (unless (eq? kind 'activity)
                  (unless (equal? sender character-name)
                    (play-ambient-sound 'message volume: .25))))))))))
  
  
  (method package (server-messages self messages)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (let ((interface (current-interface)))
              (let ((chat (child interface 'chat)))
                (for-each (lambda (message)
                            (bind (sender kind message) message
                              (show-message chat sender kind message)))
                          messages))))))))
  
  
  (method package (server-protocol self protocol)
    @convert-to-presence
    (let ((uuid (get-uuid (get-ior remote-server))))
      (let ((connection (require-remote-connection uuid)))
        (set-protocol connection protocol))))
  
  
  @peer2peer
  (method package (peers-update self peers)
    (peers-update udp-client peers))
  
  
  (method package (hierarchy-update self hierarchy)
    (define (find-group)
      (continuation-capture
        (lambda (return)
          (for-each (lambda (info)
                      (bind (group . members) info
                        (when group
                          (for-each (lambda (member-info)
                                      (let ((name (car member-info)))
                                        (when (equal? name character-name)
                                          (continuation-return return info))))
                                    members))))
                    hierarchy)
          (cons #f '()))))
    
    (bind (new-group . new-group-members) (find-group)
      (set! group new-group)
      (set! group-members new-group-members))
    (when hierarchy-update-hook
      (hierarchy-update-hook hierarchy)))
  
  
  (method package (stream-add self group-no sender name stream-no origin source-kind video-level channels)
    (when (or (not stream-addable-hook)
              (stream-addable-hook group-no))
      (let ((stream (register-receive-stream udp-client sender name stream-no origin source-kind video-level channels)))
        (let ((receive-video-level (stream-receive-video-level stream))
              (has-video? #f))
          (table-iterate (get-channels stream)
            (lambda (channel-no channel)
              (let ((media-kind (get-media-kind channel)))
                (ecase media-kind
                  ((udp-audio)
                   (channel-output (current-audio) channel volume: (and (eq? source-kind 'stream) .5))
                   (let ((video-channel (locate-stream-video-channel (get-stream channel))))
                     (when video-channel
                       (let ((output (find-output (current-video) (get-no video-channel))))
                         (when output
                           (setup-audio (get-root (get-interface-pane output))))))))
                  ((udp-video)
                   (let ((level (get-level channel)))
                     (when (or stream-compare? (eqv? level receive-video-level))
                       (let ((video (current-video)))
                         (let ((output (channel-output video channel)))
                           (when (not (get-focused-output video))
                             (change-focused-output video output))
                           (set! has-video? #t)
                           output)))))))))
          ;; QUICK TRY
          (when (not has-video?)
            (let ((channel (new UDP-Channel stream stream-no udp-video source-kind 2 video-resolution video-framerate video-bitrate video-codec #f '())))
              (channel-output (current-video) channel)))
          (when stream-add-hook
            (stream-add-hook stream))))))
  
  
  (method package (stream-remove self stream-no)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (when stream-remove-hook
          (stream-remove-hook stream))
        (close-receive-stream udp-client stream))))
  
  
  (method package (streamer-update self origin video-level)
    (let ((video (current-video)))
      (table-iterate (get-receive-streams udp-client)
        (lambda (no stream)
          (when (and (get-video-level stream)
                     (= (get-origin stream) origin))
            (set-video-level stream video-level)
            (let ((receive-video-level (stream-receive-video-level stream)))
              (define (find-output)
                (find-if (lambda (output)
                           (let ((channel (get-channel output)))
                             (and channel
                                  (eq? (get-stream channel) stream))))
                         (get-ordered-outputs video)))
              
              (let ((output (find-output)))
                (when output
                  (let ((actual-channel (get-channel output)))
                    (table-iterate (get-channels stream)
                      (lambda (no channel)
                        (when (and (= (get-media-kind channel) udp-video)
                                   (= (get-level channel) receive-video-level)
                                   (neq? channel actual-channel))
                          (replace-output video output channel)))))))))))))
  
  
  (method package (action-stream self stream-no action arguments)
    (let ((stream (find-send-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (let ((action-proc (get-action-proc stream)))
          (when action-proc
            (action-proc stream action arguments))))))
  
  
  (method package (channel-remove self channel-no)
    (let ((channel (find-receive-channel udp-client channel-no)))
      ;; lets be robust
      (when channel
        (close-receive-channel udp-client channel))))
  
  
  (method package (action-channel self channel-no action arguments)
    (let ((channel (find-send-channel udp-client channel-no)))
      ;; lets be robust
      (when channel
        (let ((action-proc (get-action-proc channel)))
          (when action-proc
            (action-proc channel action arguments))))))
  
  
  (method (find-group-member-by-id self id)
    (find group-members id key: second return: 'item))
  
  
  (method (find-group-member-by-no self no)
    (find group-members no key: third return: 'item))
  
  
  (method package (pause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (pause-world world)))))))
  
  
  (method package (unpause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (unpause-world world)))))))
  
  
  (method package (goto-client self time)
    (post-event
      (lambda ()
        (let ((history (current-history)))
          (with-task-mutex
            (lambda ()
              (goto-time history time)))))))
  
  
  (method package (camera-client self pos lookat)
    (post-event
      (lambda ()
        (let ((camera (current-camera)))
          (with-task-mutex
            (lambda ()
              (camera-init camera pos lookat)))))))
  
  
  (method package (protocol-client self simulate?)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (set-simulate-protocol? simulate?)
              (if simulate-protocol?
                  (lock-history-tooltip world)
                (unlock-history-tooltip world))))))))
  
  
  (method package (position-client self rect)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:position-client-window rect))))))
  
  
  (method package (restore-client self)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:restore-client-window))))))
  
  
  (method (admin-metadata self)
    (define (send-streams)
      (streams-metadata (get-send-streams udp-client)))
    
    (define (receive-streams)
      (streams-metadata (get-receive-streams udp-client)))
    
    (list client-no character-name (send-streams) (receive-streams) (sites-metadata)))
  
  
  (method package (admin-request self requester cookie what action)
    (define (send-caps)
      (let ((file {File Settings "caps" "client.caps"}))
        (when (exists? file)
          (send-file 0 file))))
    
    (define (send-info)
      (send-threaded 0
        (lambda ()
          (let ((version (process-version (current-process)))
                (date (build-short-date)))
            ;; gc before process-memory
            (let ((garbage-collect (estimate-garbage-collect)))
              (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
                (object->u8vector
                  (list
                    (format "v{a}{a}" (present version) environment-suffix)
                    date
                    effective-base-profile
                    (map get-purpose (table-values presences))
                    garbage-collect
                    (estimate-cpu%)
                    (length (top-threads))
                    last-gc-live
                    last-gc-movable
                    last-gc-nonmovable
                    (let ((port (get-udp-port udp-client)))
                      (list (udp-socket-receive-buffer-size port)
                            (udp-socket-send-buffer-size port)
                            (udp-socket-send-again-count port)))
                    (camera-caps self)))))))))
    
    (define (send-replay)
      (send-threaded 0
        (lambda ()
          (let ((metadata (admin-metadata self))
                (chronology (copy-chronology (current-chronology)))
                (evolution (copy-evolution (current-evolution))))
            (object->u8vector (list metadata chronology evolution) serialize)))
        (lambda ()
          (gather-replay-missing udp-client action))))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Documents "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file name)
      (let ((dir {Directory Documents "shared"}))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (send-threaded name extract (missing #f))
      (let ((thread
              (new-thread
                (lambda ()
                  (let ((sender character-name))
                    (admin-request-chunk self requester cookie sender name #f #f)
                    (let ((content (zlib-deflate (extract)))
                          (give-time .01))
                      (when missing
                        (let ((missing (missing)))
                          (for-each (lambda (missing)
                                      (sleep give-time)
                                      (admin-request-chunk self requester cookie sender 'missing missing #f))
                                    missing)))
                      (let ((content-size (u8vector-length content))
                            (max-size 8192))
                        (let (loop-chunk (part 0) (pos 0))
                          (let ((remain (- content-size pos)))
                            (when (> remain 0)
                              (sleep give-time)
                              (let ((chunk-size (min remain max-size)))
                                (let ((chunk (make-u8vector chunk-size))
                                      (done? (>= chunk-size remain)))
                                  (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                                  (admin-request-chunk self requester cookie sender name chunk done?))
                                (loop-chunk (+ part 1) (+ pos chunk-size))))))))))
                'request)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)))
    
    (define (send-settings)
      (let ((file support-settings-file))
        (when (exists? file)
          (send-file 0 file))))
    
    (if (string? what)
        (send-shared-file what)
      (case what
        ((caps)
         (send-caps))
        ((info)
         (send-info))
        ((replay)
         (send-replay))
        ((shared)
         (send-shared))
        ((settings)
         (send-settings)))))
  
  
  (method package (admin-chunk self cookie sender name chunk done?)
    (let ((proc (registered-request-procedure cookie)))
      (proc sender name chunk done?)))
  
  
  ;(method package (admin-run self requester cookie script)
  ;  (run-remote-script script
  ;    (lambda (state data)
  ;      (let ((sender character-name))
  ;        (admin-run-return self requester cookie sender state data)))))
  
  
  ;(method package (admin-return self cookie sender state data)
  ;  (let ((proc (registered-request-procedure cookie)))
  ;    (proc sender state data)))
  
  
  (method package (update-effective-base-profile self)
    (let ((video (current-video)))
      (let ((count (length (get-ordered-outputs video))))
        (let ((profile (determine-effective-base-profile count)))
          (change-effective-base-profile self profile)))))
  
  
  (method package (change-effective-base-profile self profile)
    (let ((video (current-video)))
      (unless (eq? profile effective-base-profile)
        (set-effective-base-profile profile)
        (change-graphic-profile profile)
        (change-video-profile profile)
        (change-camera-profile-override profile)
        (let ((video-profile (active-video-profile)))
          (let ((new-video-level (get-level video-profile))
                (new-video-name (get-name video-profile)))
            ;; server
            (change-video-level self new-video-level)
            ;; receive
            (table-iterate (get-receive-streams udp-client)
              (lambda (no stream)
                (define (find-output)
                  (find-if (lambda (output)
                             (let ((channel (get-channel output)))
                               (and channel
                                    (eq? (get-stream channel) stream))))
                           (get-ordered-outputs video)))
                
                (define (streaming-channel)
                  (continuation-capture
                    (lambda (return)
                      (let ((receive-video-level (stream-receive-video-level stream)))
                        (table-iterate (get-channels stream)
                          (lambda (no channel)
                            (when (= (get-media-kind channel) udp-video)
                              (let ((level (get-level channel)))
                                (when (eqv? level receive-video-level)
                                  (continuation-return return channel)))))))
                      #f)))
                
                (let ((output (find-output)))
                  (when output
                    (let ((actual-channel (get-channel output))
                          (streaming-channel (streaming-channel)))
                      (when (neq? streaming-channel actual-channel)
                        (replace-output video output streaming-channel)))))))
            ;; send
            (table-iterate (get-send-streams udp-client)
              (lambda (no stream)
                (define (find-self-output)
                  (find-if (lambda (output)
                             (let ((channel (get-channel output)))
                               (and channel
                                    (eq? (get-stream channel) stream))))
                           (get-ordered-outputs video)))
                
                (when (eq? (get-source-kind stream) 'stream)
                  (let ((self-output (find-self-output)))
                    (let ((self-channel (and self-output (get-channel self-output)))
                          (stream-video-channels (let ((queue (new-queue)))
                                                   (table-iterate (get-channels stream)
                                                     (lambda (no channel)
                                                       (when (= (get-media-kind channel) udp-video)
                                                         (let ((src (get-src (get-pipeline channel))))
                                                           (when (is? src File-Stream-Video-Src)
                                                             (enqueue queue channel))))))
                                                   (queue-list queue))))
                      (let ((unique-channel? (= 1 (length stream-video-channels))))
                        (for-each (lambda (channel)
                                    (let ((src (get-src (get-pipeline channel))))
                                      (let ((channel-level (get-level channel)))
                                        (let ((stream? (or (<= channel-level new-video-level) unique-channel?)))
                                          (set-stream? src stream?)
                                          (when (and self-channel
                                                     (neq? channel self-channel)
                                                     (= channel-level new-video-level))
                                            (replace-output video self-output channel sync-audio?: #t))))))
                                  stream-video-channels)))))))
            ;; camera
            (when (camera-playing? self)
              (let ((camera-pipeline (get-pipeline camera-channel)))
                (let ((pipeline (get-pipeline (get-src camera-pipeline))))
                  (let ((elements (get-elements camera-pipeline)))
                    (define (find-actual-consumer)
                      (find-if (lambda (element)
                                 (and (is? element Camera-Self-Consumer)
                                      (get-processing? element)))
                               elements))
                    
                    (define (find-new-consumer)
                      (find-if (lambda (element)
                                 (and (is? element Camera-Self-Consumer)
                                      (= (get-level (get-profile element)) new-video-level)))
                               elements))
                    
                    ;; self
                    (let ((actual-consumer (find-actual-consumer))
                          (new-consumer (find-new-consumer)))
                      (define (update-probe consumer on?)
                        (let ((profile (get-profile consumer)))
                          (let ((name (get-name profile))
                                (selfrate (get-selfrate profile)))
                            (with-unref ((queueself (gst_bin_get_by_name pipeline (tie "queueself{name}"))))
                              (with-unref ((pad (gst_element_get_static_pad queueself "sink")))
                                (let ((new-probe (if on?
                                                     (gst_pad_add_rate_probe pad selfrate)
                                                   (gst_pad_add_drop_probe pad))))
                                  (let ((probe (get-probe consumer)))
                                    (when probe
                                      (gst_pad_remove_probe pad probe)))
                                  (set-probe consumer new-probe)))))))
                      
                      (when (neq? new-consumer actual-consumer)
                        (update-probe new-consumer #t)
                        (let ((self-output (get-self-output video))
                              (self-consumer (get-self-consumer video)))
                          (let ((rank (if self-split? #f (and self-output (find-output-rank video self-output)))))
                            (let ((new-output (if self-split? #f (create-self-output new-consumer))))
                              (unless self-split?
                                (set-output new-consumer new-output))
                              (gst_app_sink_process_one new-consumer)
                              (update-probe actual-consumer #f)
                              (set-processing? actual-consumer #f)
                              (stop-processing actual-consumer)
                              (set-stream-state (get-output actual-consumer) #f)
                              (unless self-split?
                                (when self-output
                                  (close-self-output self-consumer))
                                (install-self-output new-consumer rank: rank)))))
                        (set-processing? new-consumer #t)
                        (start-processing new-consumer video-priority)))
                    ;; media
                    (for-each (lambda (element)
                                (when (is? element Camera-Video-Consumer)
                                  (let ((profile (get-profile element)))
                                    (let ((name (get-name profile))
                                          (level (get-level profile))
                                          (framerate (get-framerate profile)))
                                      (let ((processing? (<= level new-video-level)))
                                        (when (neq? processing? (get-processing? element))
                                          (with-unref ((queue (gst_bin_get_by_name pipeline (tie "queue{name}"))))
                                            (with-unref ((pad (gst_element_get_static_pad queue "sink")))
                                              (let ((new-probe (if processing?
                                                                   (gst_pad_add_rate_probe pad framerate)
                                                                 (gst_pad_add_drop_probe pad))))
                                                (let ((probe (get-probe element)))
                                                  (when probe
                                                    (gst_pad_remove_probe pad probe)))
                                                (set-probe element new-probe))))
                                          (set-processing? element processing?)
                                          (if processing?
                                              (start-processing element video-priority)
                                            (stop-processing element))))))))
                              elements))))))))))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (require-live-stream self)
    (or live-stream
        (let ((channels (cons (make-mic-channel)
                              (make-camera-channels))))
          (let ((stream (make-stream "Live" 'live (camera-profile-override-level) channels)))
            ;; mic
            (let ((channel (locate-audio-channel stream)))
              (setup channel)
              (set! mic-channel channel))
            ;; camera
            (let ((channels (collect-video-channels stream)))
              (let ((pipeline (make-shared-camera-pipeline channels)))
                (for-each (lambda (channel)
                            (set-pipeline channel pipeline))
                          channels)
                ;; any channel will do as they all share the same pipeline
                (let ((channel (car channels)))
                  (setup channel)
                  (set! camera-channel channel))))
            (set! live-stream stream)
            stream))))
  
  
  (method package (close-live-stream self)
    (when live-stream
      (close-send-stream udp-client live-stream)
      (set! live-stream #f)
      (set! mic-channel #f)
      (set! camera-channel #f)))
  
  
  ;;;
  ;;;; Mic
  ;;;
  
  
  (method package (toggle-mic self)
    (if (mic-playing? self)
        (release-mic self)
      (play-mic self)))
  
  
  (method package (play-mic self)
    (let ((world (current-world)))
      (play mic-channel)
      (invalidate-self-output self)
      (update-parameter world 'audio)
      (display-on/off world "Audio" (mic-playing? self))))
  
  
  ;; the mic needs to be released for
  ;; the denoiser thread to terminate
  (method package (release-mic self)
    (let ((world (current-world)))
      (release mic-channel)
      (invalidate-self-output self)
      (update-parameter world 'audio)
      (display-on/off world "Audio" (mic-playing? self))))
  
  
  (method (invalidate-self-output self)
    (let ((video (current-video)))
      (let ((self-output (get-self-output video)))
        (when self-output
          (invalidate-state self-output)))))

  
  (method package (mic-playing? self)
    (and mic-channel
         (playing? mic-channel)))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method package (toggle-camera self)
    (if (camera-playing? self)
        (release-camera self)
      (play-camera self)))
  
  
  (method package (play-camera self)
    (let ((world (current-world)))
      (play camera-channel)
      (update-parameter world 'video)
      (display-on/off world "Video" (camera-playing? self))))
  
  
  (method package (release-camera self)
    (let ((world (current-world)))
      (release camera-channel)
      (update-parameter world 'video)
      (display-on/off world "Video" (camera-playing? self))))
  
  
  (method package (camera-playing? self)
    (and camera-channel
         (playing? camera-channel)))
  
  
  (method package (camera-caps self)
    (and (camera-playing? self)
         (let ((pipeline (get-pipeline (get-src (get-pipeline camera-channel)))))
           (with-unref ((src (gst_bin_get_by_name pipeline "src")))
             (with-unref ((pad (gst_element_get_static_pad src "src")))
               (let ((caps (gst_pad_get_current_caps pad)))
                 (prog1 (gst_caps_to_string caps)
                   (gst_caps_unref caps))))))))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method (invalidate-audio-state self output)
    (let ((audio (current-audio))
          (video (current-video)))
      (let ((channel (get-channel output)))
        (when channel
          (let ((video-channel (locate-stream-video-channel (get-stream channel))))
            (when video-channel
              (let ((output (find-output video (get-no video-channel))))
                (when output
                  (invalidate-state output #t)))))))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (tile-server remote-server))))))
  
  
  (method override (restore self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (restore-server remote-server))))))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (start-profile udp-client)
    (calling-server self
      (lambda ()
        (profile-start remote-server remote-client))))
  
  
  (method package (test-profile self test arguments)
    (calling-server self
      (lambda ()
        (profile-test remote-server remote-client test arguments))))
  
  
  (method package (retrieve-profiles self)
    (let ((server-profile
            (calling-server self
              (lambda ()
                (profile-retrieve remote-server remote-client))))
          (client-profile
            (retrieve-profile udp-client)))
      (values server-profile client-profile)))
  
  
  (method package (stop-profile self)
    (stop-profile udp-client)
    (calling-server self
      (lambda ()
        (profile-stop remote-server remote-client))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (calling-server self
        (lambda ()
          (client-log remote-server remote-client (current-seconds) message)))))))
