;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.tier jazz


(import (jazz.application)
        (jazz.associative)
        (jazz.component)
        (jazz.debuggee)
        (jazz.debugger.stub)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.listener)
        (jazz.network)
        (jazz.platform)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.view)
        (jazz.zlib)
        (gaea.geometry)
        (world)
        (world.asset)
        (world.assets)
        (world.audio)
        (world.autoload)
        (world.build)
        (world.camera)
        (world.capabilities)
        (world.capture)
        (world.change)
        (world.chronology)
        (world.client)
        (world.client.assets)
        (world.client.processor)
        (world.client.request)
        (world.client.udp)
        (world.colors)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.group)
        (world.hierarchy)
        (world.history)
        (world.index)
        (world.interface)
        (world.interface.dialogs)
        (world.io)
        (world.log)
        (world.logging)
        (world.moment)
        (world.moment.syntax (phase syntax))
        (world.participation)
        (world.player)
        (world.problem)
        (world.profile)
        (world.profiling)
        (world.region)
        (world.report)
        (world.ring)
        (world.scriptum)
        (world.script.remote)
        (world.settings)
        (world.sound)
        (world.stream)
        (world.streaming)
        (world.stub)
        (world.support)
        (world.task)
        (world.tier)
        (world.time)
        (world.udp)
        (world.urgency)
        (world.video))


(hub connect)
(hub deconnect)


(definition show-activity?
  (world-setting 'world.show-activity? #f))


(definition max-upload-assets-count
  50)

(definition max-upload-assets-size
  (* 1024 1024 50))


(definition initial-stream-volume
  .5)


(class Client-Tier extends Tier
  
  
  (slot configuration                           getter generate)
  (slot state                    initialize #f  getter generate)
  (slot tier-id                  initialize #f  getter generate)
  (slot tier-no                  initialize #f  getter generate)
  (slot banner                   initialize #f  getter generate)
  (slot welcome                  initialize #f  getter generate)
  (slot welcomed?                initialize #f  accessors generate)
  (slot mutex                                   getter generate)
  (slot form                     initialize #f  getter generate)
  (slot asset-requests                          getter generate)
  (slot asset-requests-mutex                    getter generate)
  (slot zone-daytime             initialize #f  getter generate)
  (slot zone-asset-entries       initialize #f  getter generate)
  (slot spawnpoint               initialize #f  getter generate)
  (slot player-spawnpoint        initialize #f  getter generate)
  (slot character-name           initialize #f  getter generate)
  (slot character-role           initialize #f  getter generate)
  (slot character-admin?         initialize #f  getter generate)
  (slot character-verified?      initialize #f  getter generate)
  (slot character-avatar         initialize #f  getter generate)
  (slot character-dye            initialize #f  getter generate)
  (slot character-script         initialize #f  getter generate)
  (slot player-id                initialize #f  getter generate)
  (slot player-no                initialize #f  getter generate)
  (slot player-position          initialize #f  getter generate)
  (slot player-lookat            initialize #f  getter generate)
  (slot camera-position          initialize #f  getter generate)
  (slot camera-lookat            initialize #f  getter generate)
  (slot other-players            initialize #f  getter generate)
  (slot circles                  initialize #f  getter generate)
  (slot reconnect-info           initialize #f  getter generate)
  (slot remote-client            initialize #f  getter generate)
  (slot remote-server            initialize #f  getter generate)
  (slot remote-processor         initialize #f  getter generate)
  (slot urgency-port             initialize #f  getter generate)
  (slot urgency-thread           initialize #f  getter generate)
  (slot group                    initialize #f  getter generate)
  (slot group-members            initialize '() getter generate)
  (slot players-cache                           getter generate)
  (slot udp-client               initialize #f  getter generate)
  (slot udp-processor-client     initialize #f  getter generate)
  (slot forwarding-debugged?     initialize #f  getter generate)
  (slot live-stream              initialize #f  accessors generate)
  (slot microphone-channel       initialize #f  accessors generate)
  (slot camera-channel           initialize #f  accessors generate)
  (slot camera-channels          initialize '() accessors generate)
  (slot user-verified-hook       initialize #f  accessors generate)
  (slot user-upgraded-hook       initialize #f  accessors generate)
  (slot server-entered-hook      initialize #f  accessors generate)
  (slot server-exited-hook       initialize #f  accessors generate)
  (slot server-disconnected-hook initialize #f  accessors generate)
  (slot server-reconnected-hook  initialize #f  accessors generate)
  (slot processor-entered-hook   initialize #f  accessors generate)
  (slot processor-exited-hook    initialize #f  accessors generate)
  (slot zone-loaded-hook         initialize #f  accessors generate)
  (slot hierarchy-update-hook    initialize #f  accessors generate)
  (slot group-invite-hook        initialize #f  accessors generate)
  (slot group-leave-hook         initialize #f  accessors generate)
  (slot circle-acquire-hook      initialize #f  accessors generate)
  (slot circle-invite-hook       initialize #f  accessors generate)
  (slot stream-addable-hook      initialize #f  accessors generate)
  (slot stream-add-hook          initialize #f  accessors generate)
  (slot stream-remove-hook       initialize #f  accessors generate)
  (slot message-received-hook    initialize #f  accessors generate)
  (slot teleport-hook            initialize #f  accessors generate)
  
  
  (method override (initialize self dir zone)
    (define (instantiate-client)
      (let ((conf (instantiate (read-form (new-file dir ".client")))))
        (when (and zone (neq? zone 'start))
          (set-character-zone conf (cons 'zone zone)))
        conf))
    
    (nextmethod self dir)
    (set-presence-process-handler
      (lambda (proc connection)
        (handle-exception-filter
          connection-exception?
          (lambda (exc)
            (connection-disconnected self connection exc))
          (lambda ()
            (proc connection)))))
    (set-presence-processing-handler
      (lambda ()
        (bailout-point 'tcp-read)))
    (set! configuration (instantiate-client))
    (set! mutex (make-mutex 'client))
    (set! asset-requests (make-table test: equal?))
    (set! asset-requests-mutex (make-mutex 'asset-requests))
    (set! players-cache (make-table test: eqv?))
    (prepare-assets self)
    (connect-to-server self)
    (connect-to-udp-server self)
    (connect-urgency self)
    (update-name-setting character-name)
    (set-tier-id/no tier-id tier-no))
  
  
  (method override (prepare-assets self)
    (let ((assets-dir {Directory Settings "universe"}))
      (set! universe-assets (new Client-Assets 'universe assets-dir)))
    (let ((assets-dir {Directory Documents "assets"}))
      (set! world-assets (new Client-Assets 'world assets-dir))))
  
  
  (method override (make-zone-assets self zone-dir)
    (new Client-Assets 'zone (new-directory zone-dir "assets")))
  
  
  (method override (enter self)
    (let ((world (current-world))
          (zone (current-zone))
          (me (current-me)))
      (set-spawnpoint zone spawnpoint)
      (set-player-spawnpoint zone player-spawnpoint)
      (set-name me character-name)
      (set-avatar me character-avatar)
      (set-color me character-dye)
      (register-id me player-id)
      (register-no me player-no)
      (set-position me player-position)
      (set-lookat me player-lookat)
      (setup-camera self)
      (for-each (lambda (info)
                  (bind (character-name character-avatar character-dye player-id player-no player-mode player-position player-lookat player-script) info
                    (add-player self character-name character-avatar character-dye player-id player-no player-mode player-position player-lookat player-script)))
                other-players)))
  
  
  (method package (retrieve-camera self)
    (bind (position lookat) (retrieve-from-processor self)
      (set! camera-position position)
      (set! camera-lookat lookat)
      (setup-camera self)))
  
  
  (method package (setup-camera self)
    (let ((world (current-world))
          (me (current-me)))
      (let ((camera (player-camera me))
            (eye (get-eye world)))
        (set-position camera camera-position)
        (set-lookat camera camera-lookat)
        (camera-copy! eye camera))))
  
  
  (method override (shutdown self)
    (reset-presence-process-handler)
    (reset-presence-processing-handler)
    (save-to-processor self)
    (stop-to-server self)
    (close-live-stream self)
    (close-send-streams udp-client)
    ;; quick hack todo
    (iterate-table (get-receive-streams udp-client)
      (lambda (stream-no stream)
        (with-locked-channels stream
          (lambda ()
            (iterate-table (get-channels stream)
              (lambda (channel-no channel)
                (let ((ring (get-process-ring channel)))
                  (set-flow ring #f))))))))
    (close-receive-streams udp-client)
    (world.circle:reset-current-circle)
    (deconnect-urgency self)
    (deconnect-from-udp-processor self)
    (deconnect-from-udp-server self)
    (deconnect-from-server self))
  
  
  (method override (get-udp-tier self)
    udp-client)
  
  
  (method package (personal-key? self key)
    (equal? key (get-personal-key configuration)))
  
  
  (method package (with-mutex self thunk)
    (unwind-protect
        (begin
          (mutex-lock! mutex)
          (thunk))
      (mutex-unlock! mutex)))
  
  
  ;;;
  ;;;; Presence
  ;;;
  
  
  (method override (connection-disconnected self connection exc)
    (let ((disconnected-uuid (get-remote-uuid connection)))
      (if (and remote-processor
               (uuid=? (get-uuid (get-ior remote-processor)) disconnected-uuid))
          (bailout-processor self exc)
        (bailout self exc))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  ;; player info will be given by server
  (method override (setup-me self mode)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((player (new Player)))
        (new Camera parent: player)
        (set-current-me player)
        (set-current-mode mode)
        (set-mode player mode)
        (add-snapshot-property 'live.player-mode current-mode)
        (when character-script
          (set-bot? #t)
          (let ((script (new Script parent: player text: (load-text (find-script world character-script)))))
            (run-task player script))))))


  ;;;
  ;;;; Urgency
  ;;;
  
  
  (method (connect-urgency self)
    (let ((host (effective-server-host configuration))
          (service (+ (effective-server-service configuration) urgency-service-offset)))
      (assert (and host service)
        (let ((port (open-tcp-client (list server-address: host port-number: service))))
          (retry-exception-handler
            (lambda ()
              (write-transmission-header urgency-code urgency-version port)
              (force-output port)))
          (write tier-no port)
          (newline port)
          (force-output port)
          (let ((thread (new-thread
                          (lambda ()
                            (process-urgency port))
                          'urgency)))
            (thread-base-priority-set! thread urgency-priority)
            (thread-start! thread)
            (set! urgency-port port)
            (set! urgency-thread thread))))))
  
  
  (method (deconnect-urgency self)
    (when urgency-thread
      (exit-thread urgency-thread)
      (thread-join! urgency-thread)
      (close-port urgency-port)
      (set! urgency-port #f)
      (set! urgency-thread #f)))


  ;;;
  ;;;; Server
  ;;;


  (method (connect-to-server self)
    (define (connect)
      (let ((host (effective-server-host configuration))
            (port (effective-server-service configuration)))
        (assert (and host port)
          (start-remote-presence)
          (connect-remote-reference host port (list 'world.server.remote 'world-remote-server)))))
    
    (set! character-avatar (get-character-avatar configuration))
    (set! character-dye (get-character-dye configuration))
    (set! character-script (get-character-script configuration))
    (let ((server (connect))
          (client (load-object (get-local-register) 'world.client.remote 'world-remote-client))
          (uuid (get-uuid (require-presence #f)))
          (personal-key (get-personal-key configuration))
          (machine-caps (determine-machine-caps))
          (machine-features (determine-machine-features))
          (character-zone (get-character-zone configuration)))
      (let ((info
              (calling-server self
                (lambda ()
                  (client-connect server client uuid personal-key machine-identity machine-caps machine-features character-avatar character-dye character-script)))))
        (if (string? info)
            (begin
              (close-remote-proxy server)
              (throw info))
          (set! remote-client client)
          (set! remote-server server)
          (bind (tier-id tier-no machine-identity machine-settings character-name character-role character-admin? character-verified? universe-asset-entries world-asset-entries banner welcome reconnect-info) info
            (set! self.tier-id tier-id)
            (set! self.tier-no tier-no)
            (update-machine machine-identity machine-settings)
            (set! self.character-name character-name)
            (set! self.character-role character-role)
            (set! self.character-admin? character-admin?)
            (set! self.character-verified? character-verified?)
            (set-initial-role character-role)
            (set-current-role character-role)
            (set-admin-rights? character-admin?)
            (set-user-verified? character-verified?)
            (add-snapshot-property 'live.initial-role initial-role)
            (add-snapshot-property 'live.current-role current-role)
            (add-snapshot-property 'live.admin-rights? admin-rights?)
            (install-role (current-application))
            (setup-remote-index universe-assets (list->entries (u8vector->object (zlib-inflate universe-asset-entries))))
            (setup-remote-index world-assets (list->entries world-asset-entries))
            (set! self.banner banner)
            (set! self.welcome welcome)
            (set! self.reconnect-info reconnect-info)
            (let ((info (calling-server self
                          (lambda ()
                            (client-enter remote-server remote-client character-zone)))))
              (if (string? info)
                  info
                (bind (processor form zone-asset-entries spawnpoint player-spawnpoint player-id player-no player-position player-lookat camera-position camera-lookat zone-daytime other-players circles) info
                  (set! self.remote-processor (connect-remote-proxy processor))
                  (connect-to-udp-processor self processor mode-visitor)
                  ;; quicky to send form as a string
                  (set! self.form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from))
                  (set! self.zone-daytime zone-daytime)
                  (set! self.zone-asset-entries (list->entries zone-asset-entries))
                  (set! self.spawnpoint spawnpoint)
                  (set! self.player-spawnpoint player-spawnpoint)
                  (set! self.player-id player-id)
                  (set! self.player-no player-no)
                  (set! self.player-position player-position)
                  (set! self.player-lookat player-lookat)
                  (set! self.camera-position camera-position)
                  (set! self.camera-lookat camera-lookat)
                  (set! self.other-players other-players)
                  (init-circles self circles)
                  (set! self.state 'connected)
                  (load-point 'connected)))))))))
  
  
  (method (connect-to-udp-server self)
    (define (determine-parameters)
      (values "*" (effective-server-host configuration) (effective-server-service configuration)))
    
    (receive (local-address host service) (determine-parameters)
      (let ((client (new UDP-Client tier-no character-name)))
        (connect client local-address host service)
        (set! udp-client client)
        (set-?u client))))
  
  
  (method (connect-to-udp-processor self info mode)
    (bind (proxy host port) info
      (let ((client (new UDP-Processor-Client tier-no)))
        (connect client "*" host port mode)
        (start client)
        (set! udp-processor-client client))))
  
  
  (method (start-to-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-start remote-server remote-client)))
      (set! state 'started)))
  
  
  (method (ready-to-server self)
    (calling-server self
      (lambda ()
        (client-ready remote-server remote-client))))
  
  
  (method package (retrieve-from-processor self)
    (calling-processor self
      (lambda ()
        (client-retrieve remote-processor remote-client character-name))))
  
  
  (method package (save-to-processor self)
    (when remote-processor
      ;; quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-processor)
        (let ((world (current-world)))
          (when (participant?)
            (let ((eye (get-eye world)))
              (calling-processor self
                (lambda ()
                  (client-save remote-processor remote-client character-name (get-position eye) (get-lookat eye))))))))))
  
  
  (method (stop-to-server self)
    (when remote-server
      ;; quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-server)
        (calling-server self
          (lambda ()
            (client-stop remote-server remote-client))))
      (set! state 'stopped)))
  
  
  (method package (visit-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-visit remote-server remote-client)))))))
  
  
  (method package (observe-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-observe remote-server remote-client)))))))
  
  
  (method package (participate-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-participate remote-server remote-client)))))))
  
  
  (method (sleep-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-sleep remote-server remote-client)))))))
  
  
  (method (wake-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-wake remote-server remote-client)))))))
  
  
  (method (deconnect-from-udp-server self)
    (with-mutex self
      (lambda ()
        (when udp-client
          (stop udp-client)
          (deconnect udp-client)
          (set! udp-client #f)))))
  
  
  (method (deconnect-from-udp-processor self)
    (with-mutex self
      (lambda ()
        (when udp-processor-client
          (stop udp-processor-client)
          (deconnect udp-processor-client)
          (set! udp-processor-client #f)))))
  
  
  (method (deconnect-from-server self)
    (when remote-server
      ;; quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-server)
        (when forwarding-debugged?
          (detach-from-debugger #f)
          (set! forwarding-debugged? #f))
        (calling-server self
          (lambda ()
            (client-deconnect remote-server remote-client))))
      (detach-from-server self)
      (set! state 'deconnected)))
  
  
  (method (detach-from-server self)
    (request-shutdown)
    (when forwarding-debugged?
      (bailout-from-debugger)
      (set! forwarding-debugged? #f))
    (with-mutex self
      (lambda ()
        (when remote-processor
          (close-remote-proxy remote-processor))
        (when remote-server
          (close-remote-proxy remote-server))
        (set! remote-server #f)
        (set! remote-processor #f)
        (set! remote-client #f))))
  
  
  (method package (detach-client self)
    (detach-from-server self)
    (if (window?)
        (let ((world (current-world)))
          (open-welcome world exception-title: "Disconnected from server"))
      (quit)))
  
  
  (method (bailout self exc)
    (with-bailout-mutex
      (lambda ()
        (let ((bailout-continuation (current-bailout-continuation)))
          (if bailout?
              (continuation-return bailout-continuation #f)
            @debugging-read-header-received-eof-disconnects
            (snapshot-process kind: "Bailout" exception: exc max-depth: 0)
            (let ((stack (execution-stack)))
              @debug
              (let ((thread (thread-name (current-thread)))
                    (mutexes (map mutex-name (thread-mutexes (current-thread))))
                    (task (let ((task (current-task))) (if task (get-name task) '$$$$$))))
                (terminal 'bailout thread stack mutexes task))
              (set-bailout? #t)
              (delay-event
                (lambda ()
                  (bailout-from-server self exc stack)
                  (with-bailout-mutex
                    (lambda ()
                      (reset-bailout-target)
                      (set-bailout? #f)))))
              (continuation-return bailout-continuation #f)))))))
  
  
  (method (bailout-from-server self exc stack)
    (with-task-mutex
      (lambda ()
        (if (window?)
            (begin
              (detach-from-server self)
              (let ((world (current-world)))
                (open-welcome world exception-title: "Disconnected from server" exception: exc exception-stack: stack)))
          ;; too much for bots
          (unless bot?
            (snapshot-process exception: exc))
          (quit)))))
  
  
  (method (bailout-processor self exc)
    (let ((zone (current-zone)))
      (if (or (not zone) (eq? (get-path zone) 'start))
          (bailout self exc)
        (set-bailout? #t)
        (delay-event
          (lambda ()
            (bailout-from-processor self exc)
            (set-bailout? #f))))))
  
  
  (method (bailout-from-processor self exc)
    (with-task-mutex
      (lambda ()
        (define (ground pos)
          (vertex (vertex-x pos) 4. (vertex-z pos)))
        
        (let ((me (current-me)))
          (let ((position (ground (get-position me)))
                (sight (copy-vertex (get-sight me))))
            (world.portal:load/wait-zone 'start (format "Disconnected from {a}" (present-zone (get-path (current-zone))))
              (lambda ()
                (set-circle-position (ground circle-position))
                (teleport (current-zone) position sight))))))))
  
  
  (method package (send-client-alive self)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-server
          (calling-server self
            (lambda ()
              (client-alive remote-server remote-client)))))))
  
  
  (method package (send-client-media self channel-no buffer dts pts duration flags)
    (with-mutex self
      (lambda ()
        (when udp-client
          (send-media udp-client channel-no buffer dts pts duration flags)))))
  
  
  (method package (send-client-update self changes)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-processor
          (calling-processor self
            (lambda ()
              (client-update remote-processor remote-client (current-seconds) changes)))))))
  
  
  (method override (connected-player self no)
    (or (table-ref players-cache no #f)
        (let ((player (calling-server self
                        (lambda ()
                          (client-connected-player remote-server remote-client no)))))
          (table-set! players-cache no player)
          player)))
  
  
  (method override (connected-players self)
    (calling-server self
      (lambda ()
        (client-connected-players remote-server remote-client))))
  
  
  (method override (available-templates self)
    (calling-server self
      (lambda ()
        (client-available-templates remote-server remote-client))))
  
  
  (method override (available-zone-base self from)
    (calling-server self
      (lambda ()
        (client-available-zone-base remote-server remote-client from))))
  
  
  (method override (available-zone-base? self base)
    (calling-server self
      (lambda ()
        (client-available-zone-base? remote-server remote-client base))))
  
  
  (method override (create-zone self from base)
    (let ((zone (calling-server self
                  (lambda ()
                    (client-create-zone remote-server remote-client from base)))))
      (when zone
        (change-zone self zone))))
  
  
  (method override (available-zones self)
    (calling-server self
      (lambda ()
        (client-available-zones remote-server remote-client))))
  
  
  (method package (load-zone self zone)
    (calling-server self
      (lambda ()
        (client-load-zone remote-server remote-client zone))))
  
  
  (method override (change-zone self zone)
    (save-to-processor self)
    (let ((info (calling-server self
                  (lambda ()
                    (client-change-zone remote-server remote-client zone)))))
      (if (string? info)
          info
        (bind (processor form zone-asset-entries spawnpoint player-spawnpoint player-id player-no player-position player-lookat camera-position camera-lookat zone-daytime other-players circles) info
          (close (current-zone))
          (deconnect-from-udp-processor self)
          (when remote-processor
            (close-remote-proxy remote-processor))
          (client-changed-zone remote-server remote-client)
          (set! self.remote-processor (connect-remote-proxy processor))
          (connect-to-udp-processor self processor mode-participant)
          ;; quicky to send form as a string
          (let ((form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from))
                (zone-asset-entries (list->entries zone-asset-entries)))
            (set! self.form form)
            (set! self.zone-daytime zone-daytime)
            (set! self.zone-asset-entries zone-asset-entries)
            (set! self.spawnpoint spawnpoint)
            (set! self.player-spawnpoint player-spawnpoint)
            (set! self.player-id player-id)
            (set! self.player-no player-no)
            (set! self.player-position player-position)
            (set! self.player-lookat player-lookat)
            (set! self.camera-position camera-position)
            (set! self.camera-lookat camera-lookat)
            (set! self.other-players other-players)
            (init-circles self circles)
            (let ((dir (zone-directory directory zone)))
              (let ((file (zone-file dir 'client)))
                (set-origin form file)
                (add-snapshot-property 'live.zone zone)
                (open-zone file form: form path: zone processor-updates?: #t daytime: zone-daytime asset-entries: zone-asset-entries))))
          (update-render-rate)
          (client-ready remote-processor remote-client)))))
  
  
  (method package (create-group self name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone zoom? link description)
    (calling-server self
      (lambda ()
        (client-create-group remote-server remote-client name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone zoom? link description))))
  
  
  (method package (create-circle self name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone zoom? link description mode)
    (calling-server self
      (lambda ()
        (client-create-circle remote-server remote-client name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone zoom? link description mode))))
  
  
  (method package (delete-group self name)
    (calling-server self
      (lambda ()
        (client-delete-group remote-server remote-client name))))
  
  
  (method package (group-requirements self name)
    (calling-server self
      (lambda ()
        (client-group-requirements remote-server remote-client name))))
  
  
  (method package (join-group self name mode)
    (calling-server self
      (lambda ()
        (client-join-group remote-server remote-client name mode))))
  
  
  (method package (reconnection self zone group)
    (calling-server self
      (lambda ()
        (client-reconnection remote-server remote-client zone group))))
  
  
  (method package (rejoin-group self name/no)
    (calling-server self
      (lambda ()
        (client-rejoin-group remote-server remote-client name/no))))
  
  
  (method package (leave-group self name)
    (calling-server self
      (lambda ()
        (client-leave-group remote-server remote-client name))))
  
  
  (method package (change-upload-specs self stream-no upload-specs upload-closing)
    (calling-server self
      (lambda ()
        (client-change-upload-specs remote-server remote-client stream-no upload-specs upload-closing))))
  
  
  (method package (change-mode/focused self mode focused)
    (calling-server self
      (lambda ()
        (client-change-mode/focused remote-server remote-client mode focused))))
  
  
  (method package (register-stream self name source-kind video-levels video-on? channels)
    (calling-server self
      (lambda ()
        (client-register-stream remote-server remote-client character-name name source-kind video-levels video-on? channels))))
  
  
  (method package (unregister-stream self stream-no)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-unregister-stream remote-server remote-client stream-no)))))
  
  
  (method package (media-init self stream-no channels-init)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-media-init remote-server remote-client stream-no channels-init)))))
  
  
  (method package (media-on self stream-no media-kind)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-media-on remote-server remote-client stream-no media-kind)))))
  
  
  (method package (media-off self stream-no media-kind)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-media-off remote-server remote-client stream-no media-kind)))))
  
  
  (method package (stream-action self stream-no action arguments)
    (calling-server self
      (lambda ()
        (client-stream-action remote-server remote-client stream-no action arguments))))
  
  
  (method package (channel-action self channel-no action arguments)
    (calling-server self
      (lambda ()
        (client-channel-action remote-server remote-client channel-no action arguments))))
  
  
  (method package (circle-properties self circle-name)
    (calling-server self
      (lambda ()
        (client-circle-properties remote-server remote-client circle-name))))
  
  
  (method package (circle-property self circle-name property)
    (calling-server self
      (lambda ()
        (client-circle-property remote-server remote-client circle-name property))))
  
  
  (method package (change-circle-property self circle-name property value)
    (calling-server self
      (lambda ()
        (client-change-circle-property remote-server remote-client circle-name property value))))
  
  
  (method package (circle-information self circle-name)
    (calling-server self
      (lambda ()
        (client-circle-information remote-server remote-client circle-name))))
  
  
  (method package (circle-shape self circle-name)
    (calling-server self
      (lambda ()
        (client-circle-shape remote-server remote-client circle-name))))
  
  
  (method package (change-circle-shape self circle-name shape)
    (calling-server self
      (lambda ()
        (client-change-circle-shape remote-server remote-client circle-name shape))))
  
  
  (method package (change-circle-order self circle-name order)
    (calling-server self
      (lambda ()
        (client-change-circle-order remote-server remote-client circle-name order))))

  
  (method package (list-group-members self name)
    (calling-server self
      (lambda ()
        (client-list-group-members remote-server name))))
  
  
  (method package (list-hierarchy self)
    (calling-server self
      (lambda ()
        (client-list-hierarchy remote-server))))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (method package (request-asset self where path)
    (mutex-lock! asset-requests-mutex)
    (let ((locator (cons where path)))
      (prog1 (or (table-ref asset-requests locator #f)
                 (let ((asset-mutex (make-mutex 'asset)))
                   (mutex-lock! asset-mutex)
                   (table-set! asset-requests locator asset-mutex)
                   (case where
                     ((universe)
                      (calling-server self
                        (lambda ()
                          (request-universe-asset remote-server remote-client path))))
                     ((world)
                      (calling-server self
                        (lambda ()
                          (request-world-asset remote-server remote-client path))))
                     ((zone)
                      (calling-processor self
                        (lambda ()
                          (request-zone-asset remote-processor remote-client path)))))
                   asset-mutex))
        (mutex-unlock! asset-requests-mutex))))
  
  
  (method package (receive-asset self where path info)
    (mutex-lock! asset-requests-mutex)
    (let ((locator (cons where path)))
      (let ((asset-mutex (table-ref asset-requests locator)))
        (mutex-specific-set! asset-mutex info)
        (table-clear asset-requests locator)
        (mutex-unlock! asset-mutex)))
    (mutex-unlock! asset-requests-mutex))
  
  
  (method package (retrieve-asset self where path)
    (let ((asset-mutex (request-asset self where path)))
      (mutex-lock! asset-mutex)
      (mutex-unlock! asset-mutex)
      (mutex-specific asset-mutex)))
  
  
  (method package (upload-assets self where)
    (let ((world (current-world)))
      (let ((assets (case where
                      ((world) world-assets)
                      ((zone) (get-zone-assets world)))))
        ;; quick robust solution to activate occuring too early
        (when assets
          (let ((repository (get-repository assets))
                (remote-index (get-remote-index assets)))
            (let ((diff (diff repository (working-index repository) (staging-index repository))))
              (let ((changes (get-changes diff)))
                (define (calculate-size)
                  (let ((size 0))
                    (for-each (lambda (change)
                                (bind (what path . rest) change
                                  (case what
                                    ((added modified)
                                     (let ((file (new-file (get-working repository) (tokenise-filename path))))
                                       (increase! size (file-size (parse file))))))))
                              changes)
                    size))
                
                (define (present-meg bytes)
                  (format "{a}M" (meg bytes)))
                
                (define (meg bytes)
                  (fxround (/ bytes 1024. 1024.)))
                
                (when (not-null? changes)
                  (let ((count (length changes)))
                    (if (> count max-upload-assets-count)
                        (display-error world (format "Max {a} assets upload exceeded: {a}" max-upload-assets-count count))
                      (let ((size (calculate-size)))
                        (if (> size max-upload-assets-size)
                            (display-error world (format "Max {a} assets upload exceeded: {a}" (present-meg max-upload-assets-size) (present-meg size)))
                          (let ((added 0)
                                (modified 0)
                                (removed 0))
                            (let ((post-processing
                                    (working world
                                      (lambda ()
                                        (define (upload path)
                                          (let ((file (new-file (get-working repository) (tokenise-filename path))))
                                            (let ((entry (scan-file repository path file base: (get-index repository))))
                                              (let ((digest (get-digest entry)))
                                                (let ((content (store-file repository file digest)))
                                                  (case where
                                                    ((world)
                                                     (calling-server self
                                                       (lambda ()
                                                         (upload-world-asset remote-server content digest))))
                                                    ((zone)
                                                     (calling-processor self
                                                       (lambda ()
                                                         (upload-zone-asset remote-processor content digest))))))))))
                                        
                                        (for-each (lambda (change)
                                                    (bind (what path . rest) change
                                                      (case what
                                                        ((added)
                                                         (upload path)
                                                         (increase! added))
                                                        ((modified)
                                                         (upload path)
                                                         (increase! modified))
                                                        ((removed)
                                                         (increase! removed)))))
                                                  changes)
                                        (case where
                                          ((world)
                                           (calling-server self
                                             (lambda ()
                                               (update-world-assets remote-server remote-client (changes->list changes)))))
                                          ((zone)
                                           (calling-processor self
                                             (lambda ()
                                               (update-zone-assets remote-processor remote-client (changes->list changes))))))
                                        (update-changes remote-index changes)
                                        (update-changes (get-index repository) changes)
                                        (changes-update world changes))
                                      color: {Color World-Blue})))
                              ;; post processing that needs the task mutex
                              (post-processing))
                            (display-message world (format "{a} asset{a} added, {a} asset{a} modified, {a} asset{a} removed"
                                                           added (format-plural added)
                                                           modified (format-plural modified)
                                                           removed (format-plural removed))
                              font: {Font Status}
                              color: {Color World-Blue}
                              duration: 2.))))))))))))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method package (request-chunk self chunk-locator no)
    (calling-processor self
      (lambda ()
        (request-chunk remote-processor remote-client chunk-locator no))))
  
  
  (method package (receive-chunk self chunk-locator chunk-raw no)
    (let ((zone (current-zone)))
      (receive-chunk zone chunk-locator chunk-raw no)))

  
  (method override (pause-tier self)
    (calling-processor self
      (lambda ()
        (pause remote-processor))))
  
  
  (method override (unpause-tier self)
    (calling-processor self
      (lambda ()
        (unpause remote-processor))))
    
  
  (method (client-verify self verifier verified)
    (calling-server self
      (lambda ()
        (client-verify remote-server remote-client verifier verified))))

  
  (method package (client-invite self recipient circle-name)
    (calling-server self
      (lambda ()
        (client-invite remote-server remote-client recipient circle-name))))
  
  
  (method package (client-accept self sender circle-name)
    (calling-server self
      (lambda ()
        (client-accept remote-server remote-client sender circle-name))))
  
  
  (method package (client-decline self sender reason)
    (calling-server self
      (lambda ()
        (client-decline remote-server remote-client sender reason))))
  
  
  (method package (client-problem self sender problem)
    (calling-server self
      (lambda ()
        (client-problem remote-server remote-client sender problem))))
  
  
  (method (client-teleport self teleported zone position sight)
    (calling-server self
      (lambda ()
        (client-teleport remote-server remote-client teleported zone position sight))))
  
  
  (method package (client-status self status)
    (calling-server self
      (lambda ()
        (client-status remote-server remote-client status))))
  
  
  (method package (client-leave self)
    (let ((error (calling-server self
                   (lambda ()
                     (client-leave remote-server remote-client)))))
      (or error
          (begin
            (stop udp-client)
            (close-live-stream self)
            (close-send-streams udp-client)
            (close-receive-streams udp-client)
            (when group-leave-hook
              (group-leave-hook))
            #f))))
  
  
  (method package (client-message self kind recipient message)
    (calling-server self
      (lambda ()
        (client-message remote-server remote-client kind recipient message))))
  
  
  (method package (invitation-list self)
    (calling-server self
      (lambda ()
        (invitation-list remote-server remote-client))))
  
  
  (method package (invitation-add self invitation-word expires)
    (calling-server self
      (lambda ()
        (invitation-add remote-server remote-client invitation-word expires))))
  
  
  (method package (invitation-modify self invitation-word expires)
    (calling-server self
      (lambda ()
        (invitation-modify remote-server remote-client invitation-word expires))))
  
  
  (method package (invitation-remove self key)
    (calling-server self
      (lambda ()
        (invitation-remove remote-server remote-client key))))
  
  
  (method package (admin-server-command self command arguments)
    (calling-server self
      (lambda ()
        (admin-command remote-server remote-client command arguments))))
  
  
  (method package (admin-processor-command self command arguments)
    (calling-processor self
      (lambda ()
        (admin-command remote-processor remote-client command arguments))))
  
  
  (method package (admin-request-chunk self requester cookie sender name chunk done?)
    (calling-server self
      (lambda ()
        (admin-request-chunk remote-server requester cookie sender name chunk done?))))
  
  
  ;(method package (admin-run-return self requester cookie sender state data)
  ;  (calling-server self
  ;    (lambda ()
  ;      (admin-run-return remote-server requester cookie sender state data))))
  
  
  (method (calling-server self thunk)
    (handle-exception-filter
      connection-exception?
      (lambda (exc)
        (bailout self exc))
      (lambda ()
        (bailout-point 'tcp-write)
        (let ((result (thunk)))
          (if (eq? result disconnect-marker)
              (bailout self (new Error message: "Received disconnect marker"))
            result)))))
  
  
  (method (calling-processor self thunk)
    (handle-exception-filter
      connection-exception?
      (lambda (exc)
        (bailout-processor self exc))
      (lambda ()
        (bailout-point 'tcp-write)
        (let ((result (thunk)))
          (if (eq? result disconnect-marker)
              (bailout-processor self (new Error message: "Received disconnect marker"))
            result)))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (add-player self character-name character-avatar character-dye player-id player-no player-mode player-position player-lookat player-script)
    (let ((zone (current-zone)))
      (let ((player (new Player name: character-name me?: #f avatar: character-avatar position: player-position lookat: player-lookat)))
        (register-id player player-id)
        (register-no player player-no)
        (set-mode player player-mode)
        (set-color player character-dye)
        (set-name-pane player character-name color: (if player-script {Color World-Yellow} {Color World-Blue}))
        (add-element zone player))))
  
  
  (method (remove-player self character-name)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; quicky
        (when player
          (remove-element zone player)))))
  
  
  (method (init-circles self lst)
    (set! circles (make-table test: equal?))
    (for-each (lambda (circle)
                (bind (name stone) circle
                  (table-set! circles name stone)))
              lst))
  
  
  (method package (find-circle-stone self name)
    (table-ref circles name #f))
    
  
  (method package (server-entered self tier-id tier-no character-name)
    (when server-entered-hook
      (server-entered-hook character-name)))
  
  
  (method package (server-exited self character-name)
    (when server-exited-hook
      (server-exited-hook character-name)))
  
  
  (method package (server-disconnected self character-name)
    (when server-disconnected-hook
      (server-disconnected-hook character-name)))
  
  
  (method package (server-reconnected self character-name)
    (when server-reconnected-hook
      (server-reconnected-hook character-name)))

  
  (method package (processor-entered self tier-id tier-no character-name character-avatar character-dye character-script player-id player-no player-mode player-position player-lookat player-script)
    (let ((world (current-world)))
      (add-player self character-name character-avatar character-dye player-id player-no player-mode player-position player-lookat player-script)
      (if processor-entered-hook
          (processor-entered-hook character-name)
        (display-message world (format "{a} entered world" character-name)))))
  
  
  (method package (processor-exited self character-name)
    (let ((world (current-world)))
      (remove-player self character-name)
      (if processor-exited-hook
          (processor-exited-hook character-name)
        (display-message world (format "{a} exited world" character-name)))))
  
  
  (method package (processor-update self sent changes)
    ;; should probably be applied by a task
    (forward-changes sent (current-seconds) changes))
  
  
  (method package (processor-draw self id color-caps alpha-caps color alpha dts pts duration background slide?)
    (receive-processor-draw (current-video) id color-caps alpha-caps color alpha dts pts duration background slide?))
  
  
  (method package (zone-loaded self zone error-string)
    (when zone-loaded-hook
      (zone-loaded-hook zone error-string)))
  
  
  (method package (server-verified self verifier)
    (define (layout box)
      (let ((border (child box 'border))
            (yes (child box 'yes)))
        (define (set-v view v)
          (let ((pos (get-position view)))
            (set-position view (new Point (get-h pos) v))))
        
        (set-v border 3)
        (set-v yes 65)))
    
    (define (verified)
      (set-user-verified? #t)
      (when user-verified-hook
        (user-verified-hook)))
    
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (eq? (current-tier) self)
              (play-ambient-sound "warcraft/user/LevelUp" volume: .1)
              (open-message `(<span>
                               (<paragraph> justification: center
                                 (<text> ,(format "{a} has verified you" verifier)))
                               (<paragraph> (<text> font: Spacer-Small " "))
                               (<paragraph> justification: center
                                 (<text> color: {Color World-Blue} "You now have full access to Together!")))
                            caption: "Welcome"
                            layouter: layout
                            type: 'message
                            closable?: #f
                            yes: "Yay!"
                            execute: (lambda (evt)
                                       (let ((dialog (find-ascendant (get-sender evt) World-Dialog)))
                                         (close dialog))
                                       (verified))
                            user-closed: (lambda (dialog)
                                           (close dialog)
                                           (verified)))))))))
  
  
  (method package (server-upgraded self upgrader role)
    (define (layout box)
      (let ((border (child box 'border))
            (yes (child box 'yes)))
        (define (set-v view v)
          (let ((pos (get-position view)))
            (set-position view (new Point (get-h pos) v))))
        
        (set-v border 3)
        (set-v yes 65)))
    
    (define (upgraded)
      (when user-upgraded-hook
        (user-upgraded-hook role)))
    
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (eq? (current-tier) self)
              (play-ambient-sound "warcraft/user/LevelUp" volume: .1)
              (let ((participation (present-participation role))
                    (message (case role
                               ((user) "You can now create and join circles")
                               ((explorer) "You can now explore the world")
                               ((builder) "You can now shape the world")
                               ((developer) "You can now script the world"))))
                (open-message `(<span>
                                 (<paragraph> justification: center
                                   (<text> ,(format "{a} has changed your participation to {a}" upgrader participation)))
                                 (<paragraph> (<text> font: Spacer-Small " "))
                                 (<paragraph> justification: center
                                   (<text> color: {Color World-Blue} ,message)))
                              caption: "Participation"
                              layouter: layout
                              type: 'message
                              closable?: #f
                              yes: "Yay!"
                              execute: (lambda (evt)
                                         (let ((dialog (find-ascendant (get-sender evt) World-Dialog)))
                                           (close dialog))
                                         (upgraded))
                              user-closed: (lambda (dialog)
                                             (close dialog)
                                             (upgraded))))))))))
  
  
  (method package (server-invite self sender circle-name require-microphone? require-camera?)
    (define (layout box)
      (when circle-name
        (let ((border (child box 'border))
              (yes (child box 'yes))
              (no (child box 'no)))
          (define (set-v view v)
            (let ((pos (get-position view)))
              (set-position view (new Point (get-h pos) v))))
          
          (set-v border 3)
          (set-v yes 65)
          (set-v no 65))))
    
    (define (acquire)
      (if circle-name
          (assert circle-acquire-hook
            (circle-acquire-hook require-microphone? require-camera?))
        (if (not (has-microphone?))
            no-microphone-found
          (if (not (acquire-microphone-pipeline))
              unable-to-acquire-microphone
            #f))))
    
    (define (problem problem)
      (display-problem problem)
      (client-problem self sender problem))
    
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (eq? (current-tier) self)
              (play-ambient-sound "warcraft/user/iPlayerInviteA" volume: .05)
              (open-message (if circle-name
                                `(<span>
                                   (<paragraph> justification: center
                                     (<text> ,(format "{a} invites you to join" sender)))
                                   (<paragraph> (<text> font: Spacer-Small " "))
                                   (<paragraph> justification: center
                                     (<text> color: {Color red: .938 green: .428 blue: .066} ,circle-name)))
                              (format "{a} invites you to join an audio group" sender))
                            caption: "Invitation"
                            location: '(center (center -150))
                            layouter: layout
                            type: 'question
                            yes: "Accept"
                            no: "Decline"
                            execute: (lambda (evt)
                                       (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                             (button (get-property evt button:)))
                                         (close dialog)
                                         (case button
                                           ((yes)
                                            (with-cursor :wait
                                              (lambda ()
                                                (let ((err (acquire)))
                                                  (client-status self err)
                                                  (if err
                                                      (problem err)
                                                    (let ((group-info/exception (client-accept self sender circle-name)))
                                                      (if (string? group-info/exception)
                                                          (display-error (current-world) group-info/exception)
                                                        (if circle-name
                                                            (assert circle-invite-hook
                                                              (circle-invite-hook circle-name group-info/exception))
                                                          (bind (no require-microphone? require-camera? duration zone stone shape . streams) group-info/exception
                                                            (start udp-client)
                                                            (require-live-stream self in-group?: #t)
                                                            (streams-add self no require-microphone? require-camera? streams)
                                                            (play-microphone self)
                                                            (when group-invite-hook
                                                              (group-invite-hook)))))))))))
                                           ((no)
                                            (client-decline self sender #f)))))
                            user-closed: (lambda (dialog)
                                           (close dialog)
                                           (client-decline self sender #f)))))))))
  
  
  (method package (server-accept self recipient circle-name)
    (let ((world (current-world)))
      (if circle-name
          (chat-show world (format "{a} joined circle" recipient))
        (start udp-client)
        (require-live-stream self in-group?: #t)
        (play-microphone self)
        (when group-invite-hook
          (group-invite-hook)))))
  
  
  (method package (server-decline self recipient reason)
    (let ((world (current-world)))
      (play-ambient-sound "warcraft/user/LFG_Denied" volume: .1)
      (chat-show world (or reason (format "{a} declined your invitation" recipient)))))
  
  
  (method package (server-problem self recipient problem)
    (let ((world (current-world)))
      (play-ambient-sound "warcraft/user/LFG_Denied" volume: .1)
      (chat-problem world (format "{a} problem: {a}" recipient problem))))
  
  
  (method package (server-teleport self teleporter zone position sight)
    (if (world.circle:circling?)
        (client-decline self teleporter (format "{a} is in a circle" character-name))
      (post-event
        (lambda ()
          (with-task-mutex
            (lambda ()
              (when (eq? (current-tier) self)
                (play-ambient-sound "warcraft/user/iPlayerInviteA" volume: .05)
                (open-message (format "{a} wants to teleport you to his location" teleporter)
                              caption: "Teleport"
                              location: '(center (center -150))
                              type: 'question
                              yes: "Accept"
                              no: "Decline"
                              execute: (lambda (evt)
                                         (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                               (button (get-property evt button:)))
                                           (close dialog)
                                           (case button
                                             ((yes)
                                              (with-cursor :wait
                                                (lambda ()
                                                  (when teleport-hook
                                                    (teleport-hook zone position sight)))))
                                             ((no)
                                              (client-decline self teleporter #f)))))
                              user-closed: (lambda (dialog)
                                             (close dialog)
                                             (client-decline self teleporter #f))))))))))
  
  
  (method package (server-join self recipient)
    (let ((world (current-world)))
      (play-ambient-sound "warcraft/user/MagicClick" volume: .3)
      (chat-show world (format "{a} joined group" recipient))))
  
  
  (method package (server-leave self recipient)
    (let ((world (current-world)))
      (chat-show world (format "{a} left group" recipient))))
  
  
  (method package (server-disband self)
    (let ((world (current-world)))
      (stop udp-client)
      (close-live-stream self)
      (close-send-streams udp-client)
      (close-receive-streams udp-client)
      (when group-leave-hook
        (group-leave-hook))
      (chat-show world "Your group was disbanded")))
  
  
  (method package (server-message self sender kind message)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (eq? (current-tier) self)
              (let ((interface (current-interface)))
                (let ((chat (child interface 'chat)))
                  (when (or (neq? kind 'activity) show-activity?)
                    (show-message chat sender kind message)
                    (when message-received-hook
                      (message-received-hook sender kind message)))))))))))
  
  
  (method package (server-messages self messages)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (eq? (current-tier) self)
              (let ((interface (current-interface)))
                (let ((chat (child interface 'chat)))
                  (for-each (lambda (message)
                              (bind (sender kind message) message
                                (when (or (neq? kind 'activity) show-activity?)
                                  (show-message chat sender kind message))))
                            messages)))))))))
  
  
  (method package (positions-update self positions)
    (let ((zone (current-zone)))
      (for-each (lambda (info)
                  (bind (id position) info
                    (let ((player (registered-entity-id zone id)))
                      (when player
                        (set-position player position)))))
                positions)))
  
  
  (method package (mode-update self character-name mode)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; robust
        (when player
          (set-mode player mode)))))
  
  
  (method package (world-assets-update self changes)
    (let ((world (current-world)))
      (let ((assets world-assets)
            (changes (list->changes changes)))
        (update-changes (get-remote-index assets) changes)
        (removed-update assets changes)
        (changes-update world changes))))
  
  
  (method package (zone-assets-update self changes)
    (let ((world (current-world)))
      (let ((assets (get-zone-assets world))
            (changes (list->changes changes)))
        (update-changes (get-remote-index assets) changes)
        (removed-update assets changes)
        (changes-update world changes))))
  
  
  (method package (hierarchy-update self hierarchy)
    (define (find-group)
      (continuation-capture
        (lambda (return)
          (for-each (lambda (info)
                      (bind (group owner persistent? invite-only? require-microphone? require-camera? zone stone zoom? link description . members) info
                        (when group
                          (for-each (lambda (member-info)
                                      (let ((name (car member-info)))
                                        (when (equal? name character-name)
                                          (continuation-return return info))))
                                    members))))
                    hierarchy)
          (cons #f (cons #f (cons #f (cons #f (cons #f (cons #f (cons #f (cons #f (cons #f (cons #f (cons #f '()))))))))))))))
    
    (bind (new-group new-group-owner new-group-persistent? new-group-invite-only? new-group-require-microphone? new-group-require-camera? new-group-zone new-group-stone new-group-zoom? new-group-link new-group-description . new-group-members) (find-group)
      (set! group new-group)
      (set! group-members new-group-members))
    (register-hierarchy hierarchy)
    (when hierarchy-update-hook
      (hierarchy-update-hook hierarchy)))
  
  
  (method package (circle-added self name stone)
    (table-set! circles name stone))
  
  
  (method package (circle-removed self name)
    (table-clear circles name))
  
  
  (method package (circle-change-shape self name shape)
    (world.circle:set-current-circle-shape name shape))
  
  
  (method package (circle-change-order self name order)
    (world.circle:set-current-circle-order name order))
  
  
  (method package (streams-add self group-no group-require-microphone? group-require-camera? streams)
    (for-each (lambda (info)
                (bind (sender name stream-no origin source-kind video-levels channels) info
                  (stream-add self group-no group-require-microphone? group-require-camera? sender name stream-no origin source-kind video-levels channels)))
              streams))
  
  
  (method package (stream-add self group-no group-require-microphone? group-require-camera? sender name stream-no origin source-kind video-levels channels)
    (when (or (not stream-addable-hook)
              (stream-addable-hook group-no))
      (let ((stream (register-receive-stream udp-client sender name stream-no origin source-kind video-levels channels)))
        (with-locked-channels stream
          (lambda ()
            (iterate-table (get-channels stream)
              (lambda (channel-no channel)
                (let ((media-kind (get-media-kind channel)))
                  (when (= media-kind udp-audio)
                    (when (get-caps channel)
                      (let ((output (channel-output (current-audio) channel volume: (and (eq? source-kind 'stream) initial-stream-volume))))
                        (let ((ring (get-process-ring channel)))
                          (play-audio output)
                          (set-output channel output)
                          (set-flow ring (get-flow output)))))))))
            (let ((video-channel (locate-highest-video-channel stream)))
              (if video-channel
                  (let ((output (channel-output (current-video) video-channel process?: #f)))
                    (set-video-output stream output)
                    (set-output video-channel output))
                (let ((audio-channel (locate-audio-channel stream)))
                  (let ((output (channel-output (current-video) audio-channel process?: #f)))
                    (set-video-output stream output)))))
            (when stream-add-hook
              (stream-add-hook stream)))))))
  
  
  (method package (stream-remove self stream-no)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (with-locked-channels stream
          (lambda ()
            (when stream-remove-hook
              (stream-remove-hook stream))
            ;; quick hack todo
            (iterate-table (get-channels stream)
              (lambda (channel-no channel)
                (let ((ring (get-process-ring channel)))
                  (set-flow ring #f))))
            (close-receive-stream udp-client stream))))))
  
  
  (method package (stream-disconnect self stream-no)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (iterate-table (get-channels stream)
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio)
               (let ((output (get-output channel)))
                 (when output
                   (set-stream-disconnected output))))
              ((udp-video)
               (let ((output (get-output channel)))
                 (when output
                   (set-stream-disconnected output))))))))))
  
  
  (method package (stream-media-init self stream-no channels-init)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (with-locked-channels stream
          (lambda ()
            (for-each (lambda (channel-init)
                        (bind (channel-no caps resolution) channel-init
                          (let ((channel (find-receive-channel udp-client channel-no)))
                            ;; lets be robust
                            (when channel
                              (set-caps channel caps)
                              (set-resolution channel resolution)
                              (when (= (get-media-kind channel) udp-audio)
                                (let ((audio (current-audio)))
                                  (let ((output (get-output channel)))
                                    (unless output
                                      (let ((output (channel-output audio channel volume: (and (eq? (get-source-kind channel) 'stream) initial-stream-volume))))
                                        (let ((ring (get-process-ring channel)))
                                          (play-audio output)
                                          (set-output channel output)
                                          (set-flow ring (get-flow output))))))))))))
                      channels-init))))))
  
  
  (method package (stream-media-on self stream-no media-kind)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (with-locked-channels stream
          (lambda ()
            (media-on stream media-kind)
            (iterate-table (get-channels stream)
              (lambda (no channel)
                (when (= (get-media-kind channel) media-kind)
                  (channel-on channel)
                  (ecase media-kind
                    ((udp-audio)
                     (let ((output (get-output channel)))
                       (when output
                         (set-stream-state output 'on))))
                    ((udp-video)
                     (let ((output (get-output channel)))
                       (when output
                         (set-stream-state output 'on)))))))))))))
  
  
  (method package (stream-media-off self stream-no media-kind)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (with-locked-channels stream
          (lambda ()
            (media-off stream media-kind)
            (iterate-table (get-channels stream)
              (lambda (no channel)
                (when (= (get-media-kind channel) media-kind)
                  (channel-off channel)
                  (ecase media-kind
                    ((udp-audio)
                     (let ((output (get-output channel)))
                       (when output
                         (set-stream-state output 'off))))
                    ((udp-video)
                     (let ((output (get-output channel)))
                       (when output
                         (set-stream-state output 'off)))))))))))))
  
  
  (method package (max-streaming-level self)
    (let ((graphic-level (active-graphic-level)))
      (if (<= (count-send-streams udp-client) 1)
          (min (+ graphic-level 1) max-graphic-level)
        graphic-level)))


  (method (limit-upload self video-levels needs max-upload)
    (let ((max-level (find-video-level max-upload video-levels))
          (queue (new-queue)))
      (for-each (lambda (need)
                  (let ((effective-need (if (<= need max-upload) need max-level)))
                    (unless (member? effective-need (queue-list queue))
                      (enqueue queue effective-need))))
                needs)
      (queue-list queue)))
  
  
  (method package (user-rate self rate)
    (cond ((not rate)
           (set-upload-user-rate udp-client #f)
           (display-message (current-world) "No rate"))
          (else
           (set-upload-user-rate udp-client (mbps->bytes rate))
           (display-message (current-world) (format "Rate {r precision: 1}" rate)))))
  
  
  (method package (user-update self source-kind upload-needs)
    (with-task-mutex
      (lambda ()
        (let ((streams (collect-if (lambda (stream)
                                     (or (eq? source-kind 'all)
                                         (eq? (get-source-kind stream) source-kind)))
                                   (table-values (get-send-streams udp-client)))))
          (if (null? streams)
              (error "Unable to find source-kind {a}" source-kind)
            (let ((max-upload (max-upload-level)))
              (for-each (lambda (stream)
                          (let ((effective-needs (limit-upload self (get-video-levels stream) upload-needs max-upload)))
                            (update-needs (get-upload-queue udp-client) stream effective-needs)))
                        streams)))))))
  
  
  (method package (upload-update self upload-changed)
    (let ((max-upload (max-upload-level)))
      (for-each (lambda (changed)
                  (bind (stream-no . upload-needs) changed
                    (let ((stream (find-send-stream udp-client stream-no)))
                      (when stream
                        (let ((effective-needs (limit-upload self (get-video-levels stream) upload-needs max-upload)))
                          (update-needs (get-upload-queue udp-client) stream effective-needs))))))
                upload-changed)))
  
  
  (method package (update-specs self stream spec-levels closing-levels)
    (case (get-source-kind stream)
      ((live)
       (update-camera-specs self stream spec-levels closing-levels))
      ((window)
       (update-window-specs self stream spec-levels closing-levels))
      ((screen)
       (update-screen-specs self stream spec-levels closing-levels))
      ((stream image)
       (update-stream-specs self stream spec-levels closing-levels))))
  
  
  (method (update-camera-specs self stream spec-levels closing-levels)
    (let ((specs (new-queue)))
      (when camera-channel
        (let ((on? (camera-on? self)))
          (iterate-table (get-channels stream)
            (lambda (no channel)
              (let ((element (get-consumer channel)))
                (when element
                  (let ((profile (get-profile element)))
                    (let ((name (get-name profile))
                          (level (get-level profile))
                          (framerate (get-framerate profile)))
                      (let ((processing? (or (memv? level spec-levels)
                                             (memv? level closing-levels))))
                        (when (neq? processing? (get-processing? element))
                          (when on?
                            (let ((probe (get-probe element))
                                  (rate (if processing? framerate 0)))
                              (gst_rate_probe_set_rate probe rate)))
                          (set-processing? element processing?))
                        (when (and on? processing? (memv? level spec-levels))
                          (receive (caps resolution) (require-consumer-caps/resolution channel)
                            (enqueue specs (cons level caps)))))))))))))
      (sort < (queue-list specs) key: car)))
  
  
  (method (update-window-specs self stream spec-levels closing-levels)
    (let ((channel (locate-window-channel stream)))
      (receive (caps resolution) (require-caps/resolution channel)
        (set-send-state channel 'on)
        (set-caps channel caps)
        (set-resolution channel resolution)
        (list (cons (get-level channel) caps)))))
  
  
  (method (update-screen-specs self stream spec-levels closing-levels)
    (let ((channel (locate-screen-channel stream)))
      (let ((caps/resolution (require-caps/resolution channel)))
        ;; quick solution for mac screen permissions
        (if (not caps/resolution)
            #f
          (receive (caps resolution) caps/resolution
            (set-send-state channel 'on)
            (set-caps channel caps)
            (set-resolution channel resolution)
            (list (cons (get-level channel) caps)))))))
  
  
  (method (update-stream-specs self stream spec-levels closing-levels)
    (let ((video (current-video)))
      (let ((specs (new-queue)))
        (let ((self-output (get-video-output stream)))
          (let ((self-channel (get-channel self-output)))
            (let ((self-level (get-level self-channel))
                  (self-output (get-output self-channel)))
              (iterate-video-channels stream
                (lambda (channel-level channel)
                  (let ((src (get-src (get-pipeline channel))))
                    (let ((sending? (or (memv? channel-level spec-levels)
                                        (memv? channel-level closing-levels))))
                      (let ((stream? (or (eqv? channel-level self-level) sending?)))
                        (set-sending? channel sending?)
                        (set-stream? src stream?)
                        (when (and self-channel
                                   (neq? channel self-channel)
                                   (= channel-level self-level))
                          (let ((new-output (replace-output video self-output channel sync-audio?: #t)))
                            (play-video new-output)
                            (set-video-output stream new-output)
                            (set-output channel new-output)
                            (set-output self-channel #f)))
                        (when (and sending? (memv? channel-level spec-levels))
                          (enqueue specs (cons channel-level (get-caps channel))))))))))))
        (sort < (queue-list specs) key: car))))
  
  
  (method package (download-update self stream-no download-spec)
    (let ((video (current-video)))
      (let ((stream (find-receive-stream udp-client stream-no)))
        (when stream
          (close-waiting-video stream)
          (bind (level . caps) download-spec
            (let ((new-channel (locate-video-level-channel stream level)))
              (set-caps new-channel caps)
              (let ((actual-output (get-video-output stream)))
                (unless (and actual-output
                             (get-process? actual-output)
                             (eq? (get-channel actual-output) new-channel))
                  (let ((new-output (circle-output video new-channel)))
                    (set-waiting-video stream new-output)
                    (set-wait-replace? new-output #t)
                    (start new-output)
                    (play-video new-output)
                    (set-output new-channel new-output)
                    (set-flow (get-process-ring new-channel) (get-color-flow new-output))
                    (setup-audio (get-root (get-interface-pane new-output)))))))
            (when record-events?
              (record-event udp-id-download-level
                            -1.
                            (fixnum->flonum (get-origin stream))
                            (fixnum->flonum udp-video)
                            (fixnum->flonum (get-no stream))
                            (fixnum->flonum level)
                            -1.
                            -1.)))))))
  
  
  (method package (replace-channel self new-channel)
    (let ((video (current-video)))
      (let ((stream (get-stream new-channel))
            (new-output (get-output new-channel)))
        (with-locked-channels stream
          (lambda ()
            (let ((actual-output (get-video-output stream)))
              (let ((actual-channel (get-channel actual-output)))
                (let ((actual-rank (find-output-rank video actual-output)))
                  (close-output video (get-id actual-output) actual-output layout?: #f)
                  (install-output video (get-id new-output) new-output rank: actual-rank)
                  (set-video-output stream new-output))
                (unless (eq? new-channel actual-channel)
                  (set-flow (get-process-ring actual-channel) #f)
                  (set-output actual-channel #f))))
            (set-waiting-video stream #f))
          udp-video))))
  
  
  (method package (action-stream self stream-no action arguments)
    (let ((stream (find-send-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (let ((action-proc (get-action-proc stream)))
          (when action-proc
            (action-proc stream action arguments))))))
  
  
  (method package (action-channel self channel-no action arguments)
    (let ((channel (find-send-channel udp-client channel-no)))
      ;; lets be robust
      (when channel
        (let ((action-proc (get-action-proc channel)))
          (when action-proc
            (action-proc channel action arguments))))))
  
  
  (method (find-group-member-by-id self id)
    (find group-members id key: second return: 'item))
  
  
  (method (find-group-member-by-no self no)
    (find group-members no key: third return: 'item))
  
  
  (method package (pause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (when (eq? (current-tier) self)
                (pause-world world))))))))
  
  
  (method package (unpause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (when (eq? (current-tier) self)
                (unpause-world world))))))))
  
  
  (method package (dayduration-client self duration)
    (post-event
      (lambda ()
        (let ((zone (current-zone)))
          (with-task-mutex
            (lambda ()
              (when (eq? (current-tier) self)
                (set-day-duration zone duration))))))))
  
  
  (method package (daytime-client self time)
    (post-event
      (lambda ()
        (let ((zone (current-zone)))
          (with-task-mutex
            (lambda ()
              (when (eq? (current-tier) self)
                (goto-daytime zone (effective-daytime zone time)))))))))
  
  
  (method package (goto-client self time)
    (post-event
      (lambda ()
        (let ((history (current-history)))
          (with-task-mutex
            (lambda ()
              (when (eq? (current-tier) self)
                (goto-time history time))))))))
  
  
  (method package (position-client self rect)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (eq? (current-tier) self)
              (world.window:position-client-window rect)))))))
  
  
  (method package (restore-client self)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (eq? (current-tier) self)
              (world.window:restore-client-window)))))))
  
  
  (method (admin-metadata self)
    (define (send-streams)
      (streams-metadata (get-send-streams udp-client)))
    
    (define (receive-streams)
      (streams-metadata (get-receive-streams udp-client)))
    
    (list tier-no character-name (send-streams) (receive-streams) (sites-metadata)))
  
  
  ;; quicky
  (definition last-gst-pid
    #f)
  
  
  (method package (admin-request self requester requester-name cookie what action)
    (define (send-caps)
      (let ((file (client-machine-file "caps")))
        (when (exists? file)
          (send-content 0 file))))
    
    (define (send-info)
      (send-threaded 0
        (lambda ()
          (let ((version (process-version (current-process)))
                (date (build-short-date)))
            ;; gc before process-memory
            (let ((garbage-collect (estimate-garbage-collect)))
              (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
                (object->u8vector
                  (list
                    (format "{a} v{a}" kernel-platform (present (get-platform-version)))
                    (format "v{a}{a}" (present version) environment-suffix)
                    date
                    graphic-profile
                    (map get-purpose (table-values presences))
                    garbage-collect
                    (estimate-cpu%)
                    (length (top-threads))
                    (current-monotonic-frequency)
                    (current-process-memory)
                    last-gc-live
                    last-gc-movable
                    last-gc-nonmovable
                    (leaks-tracer-live-count)
                    (let ((port (get-udp-port udp-client)))
                      (list (udp-socket-receive-buffer-size port)
                            (udp-socket-send-buffer-size port)
                            (udp-socket-send-again-count port)))))))))))
    
    (define (send-monitor)
      (send-threaded 0
        (lambda ()
          (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
            (object->u8vector
              (list (current-process-memory)
                    last-gc-live
                    last-gc-movable
                    last-gc-nonmovable
                    (leaks-tracer-live-count)
                    (current-process-threads)))))))
    
    (define (send-health)
      (send-threaded 0
        (lambda ()
          (object->u8vector
            (map gather-health (get-ordered-outputs (current-video)))))))
    
    (define (send-energy)
      (send-threaded 0
        (lambda ()
          (object->u8vector (current-process-threads)))))
    
    (define (send-camera)
      (send-threaded 0
        (lambda ()
          (object->u8vector
            (list
              (camera-caps self))))))
    
    (define (send-microphone)
      (send-threaded 0
        (lambda ()
          (object->u8vector
            (list)))))
    
    (define (send-speaker)
      (send-threaded 0
        (lambda ()
          (object->u8vector
            (list)))))
    
    (define (send-capture)
      (start-captures)
      (send-reply "capture on" #t))
    
    (define (send-uncapture)
      (stop-captures)
      (send-reply "capture off" #t))
    
    (define (send-retrieve)
      (let ((captures (copy-captures)))
        (for-each (lambda (capture)
                    (bind (name info . data) capture
                      (send-threaded (format "{a}/{a}" name (rawaudio-extension info))
                        (lambda ()
                          data))))
                      captures)))
    
    (define (report-replay dir)
      (let ((metadata (admin-metadata self))
            (chronology (copy-chronology (current-chronology)))
            (evolution (copy-evolution (current-evolution))))
        (let ((file (new-file dir (add-extension character-name "replay")))
              (content (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
          (save-binary file content))))
    
    (define (report-missing dir missing)
      @convert
      (gather-replay-missing udp-client missing))
    
    (define (report-moments dir)
      (let ((moments (copy-moments)))
        (let ((file (new-file dir (add-extension character-name "moments")))
              (content (zlib-deflate (object->u8vector moments serialize))))
          (save-binary file content))))
    
    (define (report-captures dir)
      @convert
      (let ((captures (copy-captures)))
        (for-each (lambda (capture)
                    (bind (name info . data) capture
                      (send-threaded (format "{a}/{a}" name (rawaudio-extension info))
                        (lambda ()
                          (thread-join! moments-thread)
                          data))))
                  captures)))
    
    (define (with-replay-directory timestamp proc)
      (let ((parent {Directory Settings "work" "reports"}))
        (let ((dir (new-directory parent (format "replay_{a}_{a}" timestamp tier-no))))
          (create-directories dir)
          (proc dir))))
    
    (define (send-evolution)
      (let ((timestamp action))
        (with-replay-directory timestamp
          (lambda (dir)
            (report-replay dir)
            (report-moments dir)))
        (send-done)))
    
    (define (send-replay)
      (bind (timestamp . missing) action
        (with-replay-directory timestamp
          (lambda (dir)
            (report-replay dir)
            (report-missing dir missing)
            (report-moments dir)
            (report-captures dir)))
        (send-done)))
    
    (define (send-done)
      (let ((sender character-name))
        (admin-request-chunk self requester cookie sender 0 #f #t)))
    
    (define (send-profile)
      (define (send server-profile client-profile)
        (let ((server-thread
                (send-threaded 'server
                  (lambda ()
                    server-profile)
                  deflate?: #f give-time: #f)))
          (thread-join! server-thread)
          (send-threaded 0
            (lambda ()
              client-profile)
            deflate?: #f give-time: #f)))
      
      (bind (duration window pacing speedup size dummy?) action
        (let ((duration (if (unspecified? duration) #f duration))
              (parameters (list window: window pacing: pacing speedup: speedup size: size dummy?: dummy?)))
          (together.network:profile-network parameters: parameters duration: duration duration-done: send))))
    
    (define (send-now)
      (send-reports)
      (send-done))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Documents "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file)
      (let ((dir {Directory Documents "shared"})
            (name action))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-settings)
      (let ((file (client-machine-file "settings")))
        (when (exists? file)
          (send-content 0 file))))
    
    (define (send-moments)
      (send-threaded 0
        (lambda ()
          (object->u8vector (retrieve-moments) serialize))))
    
    (define (send-gst-validate)
      (send-threaded 0
        (lambda ()
          (object->u8vector (gst-validate) serialize))))
    
    (define (send-gst)
      (let ((port (case what
                    ((gst-device-monitor) (apply gst-device-monitor (map ->string action)))
                    ((gst-inspect) (apply gst-inspect (map ->string action)))
                    ((gst-launch) (apply gst-launch "--gst-debug-no-color" (split-string action #\space)))
                    ((gst-play) (gst-play "--quiet" "--gst-debug-no-color" action)))))
        (set! last-gst-pid (process-pid port))
        (send-streaming what
          (lambda ()
            (read-platform-line port)))))
    
    (define (send-gst-done)
      (let ((result
              (if last-gst-pid
                  (begin
                    (interrupt-process last-gst-pid)
                    (set! last-gst-pid #f)
                    'done)
                #f)))
        (send-reply result #t)))
    
    (define (send-digest)
      (let ((sender character-name)
            (name 'digest))
        (define (send-line line)
          (let ((chunk (zlib-deflate (object->u8vector line))))
             (admin-request-chunk self requester cookie sender name chunk #f)))
        
        (admin-request-chunk self requester cookie sender name #f #f)
        (case action
          ((gstreamer)
           (let ((digest (digest-directory {Directory Libraries "gstreamer"} 'SHA-1
                           filter: (lambda (path)
                                     (not (equal? (get-name path) "registry.bin"))))))
             (send-line digest)))
          ((list)
           (let ((directory {Directory Libraries}))
             (iterate-directory directory
               (lambda (subpath kind)
                 (when (or (= 1 (length subpath))
                           (equal? (car subpath) "gstreamer"))
                   (let ((file (new-file directory subpath)))
                     (let ((digest (digest-file (parse file) 'SHA-1)))
                       (send-line (format "{s} {s}" (join subpath "/") digest))))))
               full?: #f
               files?: #t
               directories?: #f
               recursive?: #t))))
        (admin-request-chunk self requester cookie sender name #f #t)))
    
    (define (send-verify)
      (let ((sender character-name)
            (name 'verify))
        (define (send-line line)
          (let ((chunk (zlib-deflate (object->u8vector line))))
             (admin-request-chunk self requester cookie sender name chunk #f)))
      
        (admin-request-chunk self requester cookie sender name #f #f)
        (receive (subpath diff) (case action
                                  ((plugins) (together.settings:verify-gstreamer-plugins))
                                  ((gstreamer) (together.settings:verify-gstreamer))
                                  ((all) (together.settings:verify-together)))
          (let ((changes (get-changes diff)))
            (if (null? changes)
                (send-line "Nothing changed")
              (for-each (lambda (change)
                          (bind (what path) change
                            (let ((path (if (not subpath) path (substring path (string-length subpath) (string-length path)))))
                              (send-line
                                (case what
                                  ((added)    (format "    added:    {a}" path))
                                  ((removed)  (format "    removed:  {a}" path))
                                  ((modified) (format "    modified: {a}" path)))))))
                        changes))))
        (admin-request-chunk self requester cookie sender name #f #t)))
    
    (define (send-repair)
      (let ((sender character-name)
            (name 'repair))
        (define (send-line line)
          (let ((chunk (zlib-deflate (object->u8vector line))))
             (admin-request-chunk self requester cookie sender name chunk #f)))
      
        (admin-request-chunk self requester cookie sender name #f #f)
        (receive (subpath diff) (case action
                                  ((plugins) (together.settings:repair-gstreamer-plugins))
                                  ((gstreamer) (together.settings:repair-gstreamer))
                                  ((all) (together.settings:repair-together)))
          (let ((changes (get-changes diff)))
            (if (null? changes)
                (send-line "Nothing to repair")
              (for-each (lambda (change)
                          (bind (what path) change
                            (let ((path (if (not subpath) path (substring path (string-length subpath) (string-length path)))))
                              (send-line
                                (case what
                                  ((added)    (format "    removed:  {a}" path))
                                  ((removed)  (format "    readded:  {a}" path))
                                  ((modified) (format "    replaced: {a}" path)))))))
                        changes))))
        (admin-request-chunk self requester cookie sender name #f #t)))
    
    (define (send-set)
      (bind (setting . value) action
        (set-machine-setting setting value)
        (send-reply "set" #t)))
    
    (define (send-unset)
      (let ((setting action))
        (unset-machine-setting setting)
        (send-reply "unset" #t)))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (send-content name file)
      (send-threaded name
        (lambda ()
          (object->u8vector (load-lines file)))))
    
    (define (generate-snapshot)
      (snapshot-process reason: (format "Snapshot requested by {a}" requester-name))
      (send-reply "done" #t))
    
    (define (attach-to-debugger)
      (if (get-controller-debugger)
          (send-reply "Already attached" #f)
        (let ((debugger (if (unspecified? action) ":55000" action)))
          (background
            (lambda ()
              (current-process-title-set! character-name)
              ;; setup-debuggee because of calling tcp-client-peer-socket-info
              ;; can take a very long time to timeout so run in the background
              (let ((exc (setup-debuggee debugger: debugger connection-exception-exit?: #f)))
                (if exc
                    (with-task-mutex
                      (lambda ()
                        (send-reply "Unable to connect to debugger" #f)))
                  (thread-int! (primordial-thread)
                    (lambda ()
                      (with-reentrant-task-mutex
                        (lambda ()
                          (start-repl-thread (current-thread) #f (current-console-port))
                          (select-debugger-console)
                          (current-input-port (console-input-port))
                          (current-output-port (console-output-port))
                          (ready-to-controller)
                          (send-reply "attached" #t))))))))
            'attach))))
    
    (define (detach-from-debugger)
      (if (not (get-controller-debugger))
          (send-reply "Already detached" #f)
        (current-input-port (standard-input-port))
        (current-output-port (standard-output-port))
        (detach-from-controller)
        (send-reply "detached" #t)))
    
    (define (send-reply name done?)
      (let ((sender character-name))
        (admin-request-chunk self requester cookie sender name #f done?)))
    
    (define (send-threaded name extract (missing: missing #f) (deflate?: deflate? #t) (give-time: give-time .01))
      (background
        (lambda ()
          (let ((data (extract))
                (sender character-name))
            (admin-request-chunk self requester cookie sender name #f #f)
            (let ((content (if deflate? (zlib-deflate data) data)))
              (when missing
                (let ((missing (missing)))
                  (for-each (lambda (missing)
                              (when give-time
                                (sleep give-time))
                              (admin-request-chunk self requester cookie sender 'missing missing #f))
                            missing)))
              (let ((content-size (u8vector-length content))
                    (max-size 8192))
                (let (loop-chunk (part 0) (pos 0))
                  (let ((remain (- content-size pos)))
                    (when (> remain 0)
                      (when give-time
                        (sleep give-time))
                      (let ((chunk-size (min remain max-size)))
                        (let ((chunk (make-u8vector chunk-size))
                              (done? (>= chunk-size remain)))
                          (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                          (admin-request-chunk self requester cookie sender name chunk done?))
                        (loop-chunk (+ part 1) (+ pos chunk-size))))))))))))
    
    (define (send-streaming name next)
      (background
        (lambda ()
          (declare (proper-tail-calls))
          (let ((sender character-name))
            (admin-request-chunk self requester cookie sender name #f #f)
            (let (loop)
              (let ((data (next)))
                (if (eof-object? data)
                    (admin-request-chunk self requester cookie sender name #f #t)
                  (let ((chunk (zlib-deflate (object->u8vector data))))
                    (admin-request-chunk self requester cookie sender name chunk #f))
                  (loop))))))))
    
    (define (background thunk (name 'request))
      (let ((thread (new-thread thunk name)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)
        thread))
    
    (case what
      ((caps)
       (send-caps))
      ((info)
       (send-info))
      ((monitor)
       (send-monitor))
      ((health)
       (send-health))
      ((energy)
       (send-energy))
      ((camera)
       (send-camera))
      ((microphone)
       (send-microphone))
      ((speaker)
       (send-speaker))
      ((capture)
       (send-capture))
      ((uncapture)
       (send-uncapture))
      ((retrieve)
       (send-retrieve))
      ((evolution)
       (send-evolution))
      ((replay)
       (send-replay))
      ((profile)
       (send-profile))
      ((send)
       (send-now))
      ((shared)
       (send-shared))
      ((transfer)
       (send-shared-file))
      ((settings)
       (send-settings))
      ((moments)
       (send-moments))
      ((gst-validate)
       (send-gst-validate))
      ((gst-device-monitor gst-inspect gst-launch gst-play)
       (send-gst))
      ((gst-done)
       (send-gst-done))
      ((digest)
       (send-digest))
      ((verify)
       (send-verify))
      ((repair)
       (send-repair))
      ((set)
       (send-set))
      ((unset)
       (send-unset))
      ((snapshot)
       (generate-snapshot))
      ((attach)
       (attach-to-debugger))
      ((detach)
       (detach-from-debugger))))
  
  
  (method package (admin-chunk self cookie sender name chunk done?)
    (let ((proc (registered-request-procedure cookie)))
      (proc sender name chunk done?)))
  
  
  (method package (attach self who)
    (if (equal? who character-name)
        (format "You cannot attach yourself")
      (if (not (get-controller-debugger))
          (format "You must be attached to a debugger")
        (calling-server self
          (lambda ()
            (let ((sender character-name)
                  (debugger-proxy (get-controller-debugger)))
              (if (eq? who 'server)
                  (let ((process-proxy (forwarding-server remote-server remote-client debugger-proxy)))
                    (register-forwarding process-proxy remote-server)
                    (debugger-forwarding debugger-proxy process-proxy (get-local-process))
                    (attach-server remote-server debugger-proxy)
                    (chat-show (current-world) "Server attached")
                    #f)
                (debug-invite remote-server sender debugger-proxy who))))))))
  
  
  (method package (detach self who)
    (calling-server self
      (lambda ()
        (if (eq? who 'server)
            (begin
              (detach-server remote-server)
              (chat-show (current-world) "Server detached"))
          (debug-detach remote-server who))
        #f)))
  
  
  (method package (debug-invite self sender debugger-proxy origin-proxy)
    (define (allow)
      (setup-local-process)
      (register-forwarding debugger-proxy origin-proxy)
      (let ((process-proxy (get-local-process)))
        (calling-server self
          (lambda ()
            (debug-allow remote-server remote-client sender debugger-proxy process-proxy)))))
    
    (define (deny)
      (calling-server self
        (lambda ()
          (debug-deny remote-server remote-client sender))))
    
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (when (eq? (current-tier) self)
              (play-ambient-sound "warcraft/user/iPlayerInviteA" volume: .05)
              (open-message (format "{a} wants to debug your Together" sender)
                            caption: "Debug"
                            location: '(center (center -150))
                            type: 'message
                            yes: "Allow"
                            no: "Deny"
                            execute: (lambda (evt)
                                       (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                             (button (get-property evt button:)))
                                         (close dialog)
                                         (case button
                                           ((yes)
                                            (allow))
                                           ((no)
                                            (deny)))))
                            user-closed: (lambda (dialog)
                                           (close dialog)
                                           (deny)))))))))
  
  
  (method package (debug-allow self recipient client process-proxy)
    (let ((world (current-world)))
      (let ((debugger-proxy (get-controller-debugger)))
        (register-forwarding process-proxy remote-server)
        (debugger-forwarding debugger-proxy process-proxy (get-local-process))
        (calling-server self
          (lambda ()
            (debug-attach remote-server client debugger-proxy))))
      (chat-show world (format "{a} allowed debugging" recipient))))
  
  
  (method package (debug-deny self recipient)
    (let ((world (current-world)))
      (play-ambient-sound "warcraft/user/LFG_Denied" volume: .1)
      (chat-show world (format "{a} denied debugging" recipient))))
  
  
  (method package (debug-attach self debugger-proxy)
    (let ((world (current-world)))
      (thread-post (primordial-thread) 'attach-client
        (lambda ()
          (with-task-mutex
            (lambda ()
              (when (eq? (current-tier) self)
                (unless forwarding-debugged?
                  (current-process-title-set! character-name)
                  (attach-debuggee-to-controller debugger-proxy focus?: #t)
                  (start-repl-thread (current-thread) #f (current-console-port))
                  (select-debugger-console)
                  (ready-to-controller)
                  (set! forwarding-debugged? #t))
                (chat-show world "Debugging session started"))))))))
  
  
  (method package (debug-detach self)
    (let ((world (current-world)))
      (when forwarding-debugged?
        (detach-from-debugger #f)
        (set! forwarding-debugged? #f))
      (chat-show world "Debugging session ended")))
  
  
  ;(method package (admin-run self requester cookie script)
  ;  (run-remote-script script
  ;    (lambda (state data)
  ;      (let ((sender character-name))
  ;        (admin-run-return self requester cookie sender state data)))))
  
  
  ;(method package (admin-return self cookie sender state data)
  ;  (let ((proc (registered-request-procedure cookie)))
  ;    (proc sender state data)))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (require-live-stream self (audio-only?: audio-only? #f) (in-group?: in-group? #f))
    (or live-stream
        (let ((channels (cons (make-microphone-channel)
                              (make-camera-channels))))
          (let ((video-levels (determine-stream-video-levels channels))
                (video-on? (not audio-only?)))
            (let ((stream (make-stream "Live" 'live video-levels video-on? channels)))
              ;; microphone
              (let ((channel (locate-audio-channel stream)))
                (set! microphone-channel channel))
              ;; camera
              (unless in-group?
                (let ((channels (collect-video-channels stream)))
                  (let ((pipeline (make-shared-camera-pipeline (get-no stream) channels)))
                    (for-each (lambda (channel)
                                (set-pipeline channel pipeline))
                              channels)
                    ;; any channel will do as they all share the same pipeline
                    (let ((channel (car channels)))
                      (set! camera-channel channel))
                    (set! camera-channels channels))))
              (set! live-stream stream)
              stream)))))
  
  
  (method package (close-live-stream self)
    (when live-stream
      (close-send-stream udp-client live-stream)
      (set! live-stream #f)
      (set! microphone-channel #f)
      (set! camera-channel #f)))
  
  
  ;;;
  ;;;; Microphone
  ;;;
  
  
  (method package (toggle-microphone self)
    (if (microphone-on? self)
        (release-microphone self feedback?: #t)
      (play-microphone self feedback?: #t)))
  
  
  (method package (play-microphone self (feedback?: feedback? #f))
    (let ((world (current-world)))
      (unless (on? microphone-channel)
        (let ((stream-no (get-no live-stream)))
          (media-on self stream-no udp-audio)
          (play microphone-channel)
          (let ((caps (require-caps microphone-channel)))
            (media-init self stream-no (list (list (get-no microphone-channel) caps #f)))
            (set-send-state microphone-channel 'on)
            (set-caps microphone-channel caps))
          (invalidate-self-output self)
          (update-parameter world 'microphone)
          (when feedback?
            (display-on/off world "Microphone" (microphone-on? self)))))))
  
  
  (method package (release-microphone self (feedback?: feedback? #f))
    (let ((world (current-world)))
      (when (on? microphone-channel)
        (media-off self (get-no live-stream) udp-audio)
        (release microphone-channel)
        (set-send-state microphone-channel 'off)
        (set-caps microphone-channel #f)
        (invalidate-self-output self)
        (update-parameter world 'microphone)
        (when feedback?
          (display-on/off world "Microphone" (microphone-on? self))))))
  
  
  (method package (update-microphone-identifier self name identifier)
    (write-microphone-name name)
    (when (microphone-on? self)
      (update-identifier (get-src (get-pipeline microphone-channel)) identifier)))
  
  
  (method package (invalidate-self-output self)
    (let ((video (current-video)))
      (let ((self-output (get-self-output video)))
        (when self-output
          (invalidate-state self-output)))))

  
  (method package (microphone-on? self)
    (and microphone-channel
         (on? microphone-channel)))
  
  
  (method package (change-rndenoise self flag)
    (set-audio-rndenoise? flag)
    (when (microphone-on? self)
      (let ((src (get-src (get-pipeline microphone-channel))))
        (update-rndenoise src flag))))
  
  
  ;;;
  ;;;; Speaker
  ;;;

  
  (method package (with-update-audio self thunk)
    (assert-task-mutex)
    (if (not cached-audio)
        (thunk)
      (let ((udp (current-udp))
            (audio (current-audio)))
        (iterate-table (get-receive-channels udp)
          (lambda (no channel)
            (when (= (get-media-kind channel) udp-audio)
              (mutex-lock! (get-mutex (get-process-ring channel))))))
        (iterate-table (get-send-channels udp)
          (lambda (no channel)
            (when (= (get-media-kind channel) udp-audio)
              (mutex-lock! (get-audio-mirror-mutex channel)))))
        (let ((preserved '()))
          (iterate-table (get-outputs audio)
            (lambda (id output)
              (let ((info (list
                            (get-channel output)
                            (get-volume output)
                            (muted? output))))
                (set! preserved (cons info preserved)))
              (close-output audio id output)))
          (close-audio)
          (thunk)
          (cache-audio)
          (for-each (lambda (info)
                      (bind (channel volume muted?) info
                        (let ((output (channel-output audio channel volume: volume)))
                          (when muted?
                            (mute output))
                          (set-output channel output)
                          (when (is? channel UDP-Receive-Channel)
                            (reset channel)
                            (let ((ring (get-process-ring channel)))
                              (set-flow ring (get-flow output))))
                          (play-audio output))))
                    preserved))
        (iterate-table (get-receive-channels udp)
          (lambda (no channel)
            (when (= (get-media-kind channel) udp-audio)
              (mutex-unlock! (get-mutex (get-process-ring channel))))))
        (iterate-table (get-send-channels udp)
          (lambda (no channel)
            (when (= (get-media-kind channel) udp-audio)
              (mutex-unlock! (get-audio-mirror-mutex channel))))))))
  
  
  (method package (update-speaker-identifier self name identifier)
    (with-update-audio self
      (lambda ()
        (write-speaker-name name))))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method package (toggle-camera self)
    (if (camera-on? self)
        (release-camera self feedback?: #t)
      (play-camera self feedback?: #t)))
  
  
  (method package (stop-camera self)
    (when (camera-on? self)
      (release-camera self)))
  
  
  (method package (play-camera self (feedback?: feedback? #f))
    (let ((world (current-world)))
      (unless (on? camera-channel)
        (let ((stream-no (get-no live-stream)))
          (media-on self stream-no udp-video)
          (play camera-channel)
          (set-send-state camera-channel 'on)
          (update-parameter world 'camera)
          (when feedback?
            (display-on/off world "Camera" (camera-on? self)))))))
  
  
  (method package (release-camera self (feedback?: feedback? #f))
    (let ((world (current-world)))
      (when (on? camera-channel)
        (release camera-channel)
        (set-send-state camera-channel 'off)
        (set-caps camera-channel #f)
        (media-off self (get-no live-stream) udp-video)
        (update-parameter world 'camera)
        (when feedback?
          (display-on/off world "Camera" (camera-on? self))))))
  
  
  (method package (update-camera-ksvideosrc? self ksvideosrc?)
    (cond ((camera-on? self)
           (release-camera self)
           (set-camera-ksvideosrc? ksvideosrc?)
           (if (has-camera?)
               (play-camera self)
             (display-problem no-camera-found)))
          (else
           (set-camera-ksvideosrc? ksvideosrc?))))
  
  
  (method package (update-camera-identifier self name identifier)
    (write-camera-name name)
    (when (camera-on? self)
      (update-identifier (get-src (get-pipeline camera-channel)) identifier)))
  
  
  (method package (camera-on? self)
    (and camera-channel
         (on? camera-channel)))
  
  
  (method package (camera-caps self)
    (and (camera-on? self)
         (determine-caps (get-src (get-pipeline camera-channel)))))
  
  
  (method package (camera-bitrate self)
    (and (camera-on? self)
         (determine-bitrate (get-src (get-pipeline camera-channel)))))
  
  
  (method package (camera-bitrate-modifier self)
    (get-bitrate-modifier (get-consumer (camera-highest-channel self))))
  
  
  (method package (camera-highest-channel self)
    (locate-highest-video-channel live-stream))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method (invalidate-audio-state self output)
    (let ((channel (get-channel output)))
      (when channel
        (let ((video-channel (locate-video-output-channel (get-stream channel))))
          (when video-channel
            (let ((output (get-output video-channel)))
              (when output
                (invalidate-state output #t))))))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (post-event
      (lambda ()
        (when (eq? (current-tier) self)
          (calling-server self
            (lambda ()
              (tile-server remote-server)))))))
  
  
  (method override (restore self)
    (post-event
      (lambda ()
        (when (eq? (current-tier) self)
          (calling-server self
            (lambda ()
              (restore-server remote-server)))))))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (start-profile udp-client)
    (calling-server self
      (lambda ()
        (profile-start remote-server remote-client))))
  
  
  (method package (test-profile self test arguments)
    (calling-server self
      (lambda ()
        (profile-test remote-server remote-client test arguments))))
  
  
  (method package (retrieve-profiles self)
    (let ((server-profile
            (calling-server self
              (lambda ()
                (profile-retrieve remote-server remote-client))))
          (client-profile
            (retrieve-profile udp-client)))
      (values server-profile client-profile)))
  
  
  (method package (stop-profile self)
    (stop-profile udp-client)
    (calling-server self
      (lambda ()
        (profile-stop remote-server remote-client))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (calling-server self
        (lambda ()
          (client-log remote-server remote-client (current-seconds) message)))))))
