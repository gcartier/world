;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.tier jazz


(import (jazz.application)
        (jazz.associative)
        (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.listener)
        (jazz.platform)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.view)
        (jazz.zlib)
        (gaea.geometry)
        (world)
        (world.asset)
        (world.assets)
        (world.audio)
        (world.autoload)
        (world.build)
        (world.camera)
        (world.capabilities)
        (world.capture)
        (world.change)
        (world.chronology)
        (world.client)
        (world.client.assets)
        (world.client.processor)
        (world.client.request)
        (world.client.udp)
        (world.colors)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.id)
        (world.index)
        (world.interface)
        (world.interface.dialogs)
        (world.io)
        (world.log)
        (world.logging)
        (world.moment)
        (world.moment.syntax (phase syntax))
        (world.player)
        (world.problem)
        (world.profile)
        (world.profiling)
        (world.region)
        (world.ring)
        (world.scriptum)
        (world.script.remote)
        (world.settings)
        (world.sound)
        (world.stream)
        (world.streaming)
        (world.stub)
        (world.support)
        (world.task)
        (world.tier)
        (world.time)
        (world.udp)
        (world.video))


(hub connect)
(hub deconnect)


(definition show-activity?
  (world-setting 'world.show-activity? #f))


(definition max-upload-assets-count
  50)

(definition max-upload-assets-size
  (* 1024 1024 10))


(definition initial-stream-volume
  .5)


(class Client-Tier extends Tier
  
  
  (slot configuration                           getter generate)
  (slot state                    initialize #f  getter generate)
  (slot client-id                initialize #f  getter generate)
  (slot client-no                initialize #f  getter generate)
  (slot banner                   initialize #f  getter generate)
  (slot welcome                  initialize #f  getter generate)
  (slot welcomed?                initialize #f  accessors generate)
  (slot mutex                                   getter generate)
  (slot form                     initialize #f  getter generate)
  (slot asset-requests                          getter generate)
  (slot asset-requests-mutex                    getter generate)
  (slot zone-daytime             initialize #f  getter generate)
  (slot zone-asset-entries       initialize #f  getter generate)
  (slot spawnpoint               initialize #f  getter generate)
  (slot player-spawnpoint        initialize #f  getter generate)
  (slot character-name           initialize #f  getter generate)
  (slot character-role           initialize #f  getter generate)
  (slot character-admin?         initialize #f  getter generate)
  (slot character-verified?      initialize #f  getter generate)
  (slot character-avatar         initialize #f  getter generate)
  (slot character-dye            initialize #f  getter generate)
  (slot character-script         initialize #f  getter generate)
  (slot player-id                initialize #f  getter generate)
  (slot player-no                initialize #f  getter generate)
  (slot player-position          initialize #f  getter generate)
  (slot player-lookat            initialize #f  getter generate)
  (slot camera-position          initialize #f  getter generate)
  (slot camera-lookat            initialize #f  getter generate)
  (slot other-players            initialize #f  getter generate)
  (slot circles                  initialize #f  getter generate)
  (slot reconnect-info           initialize #f  getter generate)
  (slot remote-client            initialize #f  getter generate)
  (slot remote-server            initialize #f  getter generate)
  (slot remote-processor         initialize #f  getter generate)
  (slot group                    initialize #f  getter generate)
  (slot group-members            initialize '() getter generate)
  (slot players-cache                           getter generate)
  (slot streaming-levels         initialize '() accessors generate)
  (slot roaming?                 initialize #f  accessors generate)
  (slot udp-client               initialize #f  getter generate)
  (slot udp-processor-client     initialize #f  getter generate)
  (slot live-stream              initialize #f  accessors generate)
  (slot microphone-channel       initialize #f  accessors generate)
  (slot camera-channel           initialize #f  accessors generate)
  (slot camera-channels          initialize '() accessors generate)
  (slot user-verified-hook       initialize #f  accessors generate)
  (slot server-entered-hook      initialize #f  accessors generate)
  (slot server-exited-hook       initialize #f  accessors generate)
  (slot server-disconnected-hook initialize #f  accessors generate)
  (slot server-reconnected-hook  initialize #f  accessors generate)
  (slot processor-entered-hook   initialize #f  accessors generate)
  (slot processor-exited-hook    initialize #f  accessors generate)
  (slot zone-loaded-hook         initialize #f  accessors generate)
  (slot hierarchy-update-hook    initialize #f  accessors generate)
  (slot group-join-hook          initialize #f  accessors generate)
  (slot group-leave-hook         initialize #f  accessors generate)
  (slot circle-acquire-hook      initialize #f  accessors generate)
  (slot circle-join-hook         initialize #f  accessors generate)
  (slot stream-addable-hook      initialize #f  accessors generate)
  (slot stream-add-hook          initialize #f  accessors generate)
  (slot stream-remove-hook       initialize #f  accessors generate)
  (slot message-received-hook    initialize #f  accessors generate)
  
  
  (method override (initialize self dir zone)
    (define (instantiate-client)
      (let ((conf (instantiate (read-form (new-file dir ".client")))))
        (when zone
          (set-character-zone conf (cons 'zone zone)))
        conf))
    
    (nextmethod self dir)
    (set-presence-process-handler
      (lambda (proc connection)
        (handle-exception-filter
          connection-exception?
          (lambda (exc)
            (bailout self exc))
          (lambda ()
            (proc connection)))))
    (set-presence-processing-handler
      (lambda ()
        (bailout-point 'tcp-read)))
    (set! configuration (instantiate-client))
    (set! mutex (make-mutex 'client))
    (set! asset-requests (make-table test: equal?))
    (set! asset-requests-mutex (make-mutex 'asset-requests))
    (set! players-cache (make-table test: eqv?))
    (prepare-assets self)
    (connect-to-server self)
    (connect-to-udp-server self)
    (snapshot-user character-name)
    (set-client-id/no client-id client-no))
  
  
  (method override (prepare-assets self)
    (let ((assets-dir {Directory Settings "universe"}))
      (set! universe-assets (new Client-Assets 'universe assets-dir)))
    (let ((assets-dir (new-directory directory "assets")))
      (set! world-assets (new Client-Assets 'world assets-dir))))
  
  
  (method override (make-zone-assets self zone-dir)
    (new Client-Assets 'zone (new-directory zone-dir "assets")))
  
  
  (method override (startup self)
    (nextmethod self)
    ;; open test quick hacks
    ;; be careful this was also done for server
    ;; and ended up resetting some literal being
    ;; registered during the boot process
    (world.history:reset-literals))
  
  
  (method override (enter self)
    (let ((world (current-world))
          (zone (current-zone))
          (me (current-me)))
      (set-spawnpoint zone spawnpoint)
      (set-player-spawnpoint zone player-spawnpoint)
      (set-name me character-name)
      (set-avatar me character-avatar)
      (set-color me character-dye)
      (register-id me player-id)
      (register-no me player-no)
      (set-position me player-position)
      (set-lookat me player-lookat)
      (setup-camera self)
      (for-each (lambda (info)
                  (bind (character-name character-avatar character-dye player-id player-no player-mode player-position player-lookat player-script) info
                    (add-player self character-name character-avatar character-dye player-id player-no player-mode player-position player-lookat player-script)))
                other-players)))
  
  
  (method package (retrieve-camera self)
    (bind (position lookat) (retrieve-from-processor self)
      (set! camera-position position)
      (set! camera-lookat lookat)
      (setup-camera self)))
  
  
  (method package (setup-camera self)
    (let ((world (current-world))
          (me (current-me)))
      (let ((camera (player-camera me))
            (eye (get-eye world)))
        (set-position camera camera-position)
        (set-lookat camera camera-lookat)
        (camera-copy! eye camera))))
  
  
  (method override (shutdown self)
    (reset-presence-process-handler)
    (reset-presence-processing-handler)
    (save-to-processor self)
    (stop-to-server self)
    (close-live-stream self)
    (close-send-streams udp-client)
    ;; quick hack todo
    (iterate-table (get-receive-streams udp-client)
      (lambda (stream-no stream)
        (with-locked-channels stream
          (lambda ()
            (iterate-table (get-channels stream)
              (lambda (channel-no channel)
                (let ((ring (get-process-ring channel)))
                  (set-flow ring #f))))))))
    (close-receive-streams udp-client)
    (deconnect-from-udp-processor self)
    (deconnect-from-udp-server self)
    (deconnect-from-server self))
  
  
  (method override (get-udp-tier self)
    udp-client)
  
  
  (method package (with-mutex self thunk)
    (unwind-protect
        (begin
          (mutex-lock! mutex)
          (thunk))
      (mutex-unlock! mutex)))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (calling-server self
      (lambda ()
        (register-literal remote-server literal))))
  
  
  (method override (tier-id->literal self id)
    (calling-server self
      (lambda ()
        (registered-id remote-server id))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  ;; player info will be given by server
  (method override (setup-me self)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((player (new Player)))
        (new Camera parent: player)
        (set-current-me player)
        (add-snapshot-property 'live.player-mode (get-mode player))
        (when character-script
          (set-bot? #t)
          (let ((script (new Script parent: player text: (load-text (find-script world character-script)))))
            (run-task player script))))))


  ;;;
  ;;;; Server
  ;;;


  (method (connect-to-server self)
    (define (connect)
      (let ((host (effective-server-host configuration))
            (port (effective-server-service configuration)))
        (assert (and host port)
          (start-remote-presence)
          (let ((remote-register (connect-remote-register host port)))
            (load-object remote-register 'world.server.remote 'world-remote-server)))))
    
    (set! character-avatar (get-character-avatar configuration))
    (set! character-dye (get-character-dye configuration))
    (set! character-script (get-character-script configuration))
    (let ((server (connect))
          (client (load-object (get-local-register) 'world.client.remote 'world-remote-client))
          (uuid (get-uuid (require-presence #f)))
          (personal-key (get-personal-key configuration))
          (machine-caps (determine-machine-caps))
          (machine-features (determine-machine-features))
          (character-zone (get-character-zone configuration)))
      (let ((info
              (calling-server self
                (lambda ()
                  (client-connect server client uuid personal-key machine-identity machine-caps machine-features character-avatar character-dye character-script)))))
        (if (string? info)
            (begin
              (close-remote-proxy server)
              (throw info))
          (set! remote-client client)
          (set! remote-server server)
          (bind (client-id client-no machine-identity machine-settings character-name character-role character-admin? character-verified? universe-asset-entries world-asset-entries banner welcome reconnect-info) info
            (set! self.client-id client-id)
            (set! self.client-no client-no)
            (update-machine machine-identity machine-settings)
            (set! self.character-name character-name)
            (set! self.character-role character-role)
            (set! self.character-admin? character-admin?)
            (set! self.character-verified? character-verified?)
            (set-initial-role character-role)
            (set-current-role character-role)
            (set-admin-rights? character-admin?)
            (set-user-verified? character-verified?)
            (add-snapshot-property 'live.initial-role initial-role)
            (add-snapshot-property 'live.current-role current-role)
            (add-snapshot-property 'live.admin-rights? admin-rights?)
            (install-role (current-application))
            (setup-remote-index universe-assets (list->entries (u8vector->object (zlib-inflate universe-asset-entries))))
            (setup-remote-index world-assets (list->entries world-asset-entries))
            (set-fifo-prefix (format "{a}_" (downcase character-name)))
            (set! self.banner banner)
            (set! self.welcome welcome)
            (set! self.reconnect-info reconnect-info)
            (let ((info (calling-server self
                          (lambda ()
                            (client-enter remote-server remote-client character-zone)))))
              (if (string? info)
                  info
                (bind (processor form zone-asset-entries spawnpoint player-spawnpoint player-id player-no player-position player-lookat camera-position camera-lookat zone-daytime other-players circles) info
                  (set! self.remote-processor (connect-remote-proxy processor))
                  (connect-to-udp-processor self processor)
                  ;; open test quicky to send form as a string
                  (set! self.form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from))
                  (set! self.zone-daytime zone-daytime)
                  (set! self.zone-asset-entries (list->entries zone-asset-entries))
                  (set! self.spawnpoint spawnpoint)
                  (set! self.player-spawnpoint player-spawnpoint)
                  (set! self.player-id player-id)
                  (set! self.player-no player-no)
                  (set! self.player-position player-position)
                  (set! self.player-lookat player-lookat)
                  (set! self.camera-position camera-position)
                  (set! self.camera-lookat camera-lookat)
                  (set! self.other-players other-players)
                  (init-circles self circles)
                  (set! self.state 'connected)
                  (load-point 'connected)))))))))
  
  
  (method (connect-to-udp-server self)
    (define (determine-parameters)
      (values "*" (effective-server-host configuration) (effective-server-service configuration)))
    
    (receive (local-address host service) (determine-parameters)
      (let ((client (new UDP-Client client-no character-name)))
        (connect client local-address host service)
        (set! udp-client client)
        (set-?u client))))
  
  
  (method (connect-to-udp-processor self info)
    (bind (proxy host port) info
      (let ((client (new UDP-Processor-Client client-no)))
        (connect client "*" host port)
        (start client)
        (set! udp-processor-client client))))
  
  
  (method (start-to-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-start remote-server remote-client)))
      (set! state 'started)))
  
  
  (method package (retrieve-from-processor self)
    (calling-processor self
      (lambda ()
        (client-retrieve remote-processor remote-client character-name))))
  
  
  (method package (save-to-processor self)
    (when remote-processor
      ;; quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-processor)
        (let ((world (current-world))
              (me (current-me)))
          (when (eq? (get-mode me) 'player)
            (let ((eye (get-eye world)))
              (calling-processor self
                (lambda ()
                  (client-save remote-processor remote-client character-name (get-position eye) (get-lookat eye))))))))))
  
  
  (method (stop-to-server self)
    (when remote-server
      ;; quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-server)
        (calling-server self
          (lambda ()
            (client-stop remote-server remote-client))))
      (set! state 'stopped)))
  
  
  (method package (observe-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-observe remote-server remote-client)))))))
  
  
  (method package (play-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-play remote-server remote-client)))))))
  
  
  (method package (roam-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-roam remote-server remote-client)))
          (set! roaming? #t)))))
  
  
  (method package (anchor-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-anchor remote-server remote-client)))
          (set! roaming? #f)))))
  
  
  (method (sleep-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-sleep remote-server remote-client)))))))
  
  
  (method (wake-to-server self)
    (with-mutex self
      (lambda ()
        (when remote-server
          (calling-server self
            (lambda ()
              (client-wake remote-server remote-client)))))))
  
  
  (method (deconnect-from-udp-server self)
    (with-mutex self
      (lambda ()
        (when udp-client
          (stop udp-client)
          (deconnect udp-client)
          (set! udp-client #f)))))
  
  
  (method (deconnect-from-udp-processor self)
    (with-mutex self
      (lambda ()
        (when udp-processor-client
          (stop udp-processor-client)
          (deconnect udp-processor-client)
          (set! udp-processor-client #f)))))
  
  
  (method (deconnect-from-server self)
    (when remote-server
      ;; quicky around server closing the connection on shutdown
      (when (remote-proxy-connected? remote-server)
        (calling-server self
          (lambda ()
            (client-deconnect remote-server remote-client))))
      (detach-from-server self)
      (set! state 'deconnected)))
  
  
  (method (detach-from-server self)
    (request-shutdown)
    (with-mutex self
      (lambda ()
        (when remote-processor
          (close-remote-proxy remote-processor))
        (when remote-server
          (close-remote-proxy remote-server))
        (set! remote-server #f)
        (set! remote-processor #f)
        (set! remote-client #f))))
  
  
  (method package (detach-client self)
    (detach-from-server self)
    (if (window?)
        (let ((world (current-world)))
          (open-welcome world exception-title: "Disconnected from server"))
      (quit)))
  
  
  (method (bailout self exc)
    (with-bailout-mutex
      (lambda ()
        (let ((exit/restart/pristine (or (current-exit) (boot-restart) (event-restart) pristine-thread-continuation)))
          (if bailout?
              (continuation-return exit/restart/pristine #f)
            @debugging-read-header-received-eof-disconnects
            (snapshot-process kind: "Bailout" exception: exc max-depth: 0)
            (let ((stack (execution-stack)))
              @debug
              (let ((thread (thread-name (current-thread)))
                    (mutexes (map mutex-name (thread-mutexes (current-thread))))
                    (task (let ((task (current-task))) (if task (get-name task) '$$$$$))))
                (terminal 'bailout thread stack mutexes task))
              (set-bailout? #t)
              (delay-event
                (lambda ()
                  (bailout-client self exc stack)
                  (with-bailout-mutex
                    (lambda ()
                      (reset-bailout-target)
                      (set-bailout? #f)))))
              (continuation-return exit/restart/pristine #f)))))))
  
  
  (method (bailout-client self exc stack)
    (with-task-mutex
      (lambda ()
        (if (window?)
            (begin
              (detach-from-server self)
              (let ((world (current-world)))
                (open-welcome world exception-title: "Disconnected from server" exception: exc exception-stack: stack)))
          ;; too much for bots
          (unless bot?
            (snapshot-process exception: exc))
          (quit)))))
  
  
  (method package (send-client-alive self)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-server
          (calling-server self
            (lambda ()
              (client-alive remote-server remote-client)))))))
  
  
  (method package (send-client-media self channel-no buffer dts pts duration flags)
    (with-mutex self
      (lambda ()
        (when udp-client
          (send-media udp-client channel-no buffer dts pts duration flags)))))
  
  
  (method package (send-client-update self changes)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-processor
          (calling-processor self
            (lambda ()
              (client-update remote-processor remote-client (current-seconds) changes)))))))
  
  
  (method override (connected-player self no)
    (or (table-ref players-cache no #f)
        (let ((player (calling-server self
                        (lambda ()
                          (client-connected-player remote-server remote-client no)))))
          (table-set! players-cache no player)
          player)))
  
  
  (method override (connected-players self)
    (calling-server self
      (lambda ()
        (client-connected-players remote-server remote-client))))
  
  
  (method override (available-templates self)
    (calling-server self
      (lambda ()
        (client-available-templates remote-server remote-client))))
  
  
  (method override (available-zone-base self from)
    (calling-server self
      (lambda ()
        (client-available-zone-base remote-server remote-client from))))
  
  
  (method override (available-zone-base? self base)
    (calling-server self
      (lambda ()
        (client-available-zone-base? remote-server remote-client base))))
  
  
  (method override (create-zone self from base)
    (let ((zone (calling-server self
                  (lambda ()
                    (client-create-zone remote-server remote-client from base)))))
      (when zone
        (change-zone self zone))))
  
  
  (method override (available-zones self)
    (calling-server self
      (lambda ()
        (client-available-zones remote-server remote-client))))
  
  
  (method package (load-zone self zone)
    (calling-server self
      (lambda ()
        (client-load-zone remote-server remote-client zone))))
  
  
  (method override (change-zone self zone)
    (let ((info (calling-server self
                  (lambda ()
                    (client-change-zone remote-server remote-client zone)))))
      (if (string? info)
          info
        (bind (processor form zone-asset-entries spawnpoint player-spawnpoint player-id player-no player-position player-lookat camera-position camera-lookat zone-daytime other-players circles) info
          (close (current-zone))
          (deconnect-from-udp-processor self)
          (when remote-processor
            (close-remote-proxy remote-processor))
          (client-changed-zone remote-server remote-client)
          (set! self.remote-processor (connect-remote-proxy processor))
          (connect-to-udp-processor self processor)
          ;; open test quicky to send form as a string
          (let ((form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from))
                (zone-asset-entries (list->entries zone-asset-entries)))
            (set! self.form form)
            (set! self.zone-daytime zone-daytime)
            (set! self.zone-asset-entries zone-asset-entries)
            (set! self.spawnpoint spawnpoint)
            (set! self.player-spawnpoint player-spawnpoint)
            (set! self.player-id player-id)
            (set! self.player-no player-no)
            (set! self.player-position player-position)
            (set! self.player-lookat player-lookat)
            (set! self.camera-position camera-position)
            (set! self.camera-lookat camera-lookat)
            (set! self.other-players other-players)
            (init-circles self circles)
            (let ((dir (zone-directory directory zone)))
              (let ((file (zone-file dir 'client)))
                (set-origin form file)
                (add-snapshot-property 'live.zone zone)
                (open-zone file form: form path: zone daytime: zone-daytime asset-entries: zone-asset-entries))))
          (client-ready remote-processor remote-client)))))
  
  
  (method package (create-group self name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone)
    (calling-server self
      (lambda ()
        (client-create-group remote-server remote-client name persistent? require-microphone? require-camera? broadcast-hierarchy? auto-create? stone))))
  
  
  (method package (delete-group self name)
    (calling-server self
      (lambda ()
        (client-delete-group remote-server remote-client name))))
  
  
  (method package (group-requirements self name)
    (calling-server self
      (lambda ()
        (client-group-requirements remote-server remote-client name))))
  
  
  (method package (join-group self name mode)
    (calling-server self
      (lambda ()
        (client-join-group remote-server remote-client name mode))))
  
  
  (method package (reconnection self zone group)
    (calling-server self
      (lambda ()
        (client-reconnection remote-server remote-client zone group))))
  
  
  (method package (rejoin-group self name/no)
    (calling-server self
      (lambda ()
        (client-rejoin-group remote-server remote-client name/no))))
  
  
  (method package (leave-group self name mode)
    (calling-server self
      (lambda ()
        (client-leave-group remote-server remote-client name mode))))
  
  
  (method package (change-video-level self video-level)
    (calling-server self
      (lambda ()
        (client-change-video-level remote-server remote-client video-level))))
  
  
  (method package (register-stream self name source-kind video-level channels recipient)
    (calling-server self
      (lambda ()
        (client-register-stream remote-server remote-client character-name name source-kind video-level channels recipient))))
  
  
  (method package (unregister-stream self stream-no)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-unregister-stream remote-server remote-client stream-no)))))
  
  
  (method package (maybe-media-init self channel)
    (unless (get-caps channel)
      (receive (caps resolution) (require-consumer-caps channel)
        (media-init self (get-no (get-stream channel)) (list (list (get-no channel) caps resolution)))
        (set-caps channel caps)
        (set-resolution channel resolution))))
  
  
  (method package (media-init self stream-no channels-init)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-media-init remote-server remote-client stream-no channels-init)))))
  
  
  (method package (media-on self stream-no media-kind)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-media-on remote-server remote-client stream-no media-kind)))))
  
  
  (method package (media-off self stream-no media-kind)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-media-off remote-server remote-client stream-no media-kind)))))
  
  
  (method package (stream-action self stream-no action arguments)
    (calling-server self
      (lambda ()
        (client-stream-action remote-server remote-client stream-no action arguments))))
  
  
  (method package (channel-action self channel-no action arguments)
    (calling-server self
      (lambda ()
        (client-channel-action remote-server remote-client channel-no action arguments))))
  
  
  (method package (circle-property self circle-name property)
    (calling-server self
      (lambda ()
        (client-circle-property remote-server circle-name property))))
  
  
  (method package (change-circle-property self circle-name property value)
    (calling-server self
      (lambda ()
        (client-change-circle-property remote-server circle-name property value))))
  
  
  (method package (list-group-members self name)
    (calling-server self
      (lambda ()
        (client-list-group-members remote-server name))))
  
  
  (method package (list-hierarchy self)
    (calling-server self
      (lambda ()
        (client-list-hierarchy remote-server))))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (method package (request-asset self where path)
    (mutex-lock! asset-requests-mutex)
    (let ((locator (cons where path)))
      (prog1 (or (table-ref asset-requests locator #f)
                 (let ((asset-mutex (make-mutex 'asset)))
                   (mutex-lock! asset-mutex)
                   (table-set! asset-requests locator asset-mutex)
                   (case where
                     ((universe)
                      (calling-server self
                        (lambda ()
                          (request-universe-asset remote-server remote-client path))))
                     ((world)
                      (calling-server self
                        (lambda ()
                          (request-world-asset remote-server remote-client path))))
                     ((zone)
                      (calling-processor self
                        (lambda ()
                          (request-zone-asset remote-processor remote-client path)))))
                   asset-mutex))
        (mutex-unlock! asset-requests-mutex))))
  
  
  (method package (receive-asset self where path info)
    (mutex-lock! asset-requests-mutex)
    (let ((locator (cons where path)))
      (let ((asset-mutex (table-ref asset-requests locator)))
        (mutex-specific-set! asset-mutex info)
        (table-clear asset-requests locator)
        (mutex-unlock! asset-mutex)))
    (mutex-unlock! asset-requests-mutex))
  
  
  (method package (retrieve-asset self where path)
    (let ((asset-mutex (request-asset self where path)))
      (mutex-lock! asset-mutex)
      (mutex-unlock! asset-mutex)
      (mutex-specific asset-mutex)))
  
  
  (method package (upload-assets self where)
    (let ((world (current-world)))
      (let ((assets (case where
                      ((world) world-assets)
                      ((zone) (get-zone-assets world)))))
        ;; quick robust solution to activate occuring too early
        (when assets
          (let ((repository (get-repository assets))
                (remote-index (get-remote-index assets)))
            (let ((diff (diff repository (working-index repository) (staging-index repository))))
              (let ((changes (get-changes diff)))
                (define (calculate-size)
                  (let ((size 0))
                    (for-each (lambda (change)
                                (bind (what path . rest) change
                                  (case what
                                    ((added modified)
                                     (let ((file (new-file (get-working repository) (tokenise-filename path))))
                                       (increase! size (file-size (parse file))))))))
                              changes)
                    size))
                
                (define (present-meg bytes)
                  (format "{a}M" (meg bytes)))
                
                (define (meg bytes)
                  (fxround (/ bytes 1024. 1024.)))
                
                (when (not-null? changes)
                  (let ((count (length changes)))
                    (if (> count max-upload-assets-count)
                        (display-error world (format "Max {a} assets upload exceeded: {a}" max-upload-assets-count count))
                      (let ((size (calculate-size)))
                        (if (> size max-upload-assets-size)
                            (display-error world (format "Max {a} assets upload exceeded: {a}" (present-meg max-upload-assets-size) (present-meg size)))
                          (let ((added 0)
                                (modified 0)
                                (removed 0))
                            (working world
                              (lambda ()
                                (define (upload path)
                                  (let ((file (new-file (get-working repository) (tokenise-filename path))))
                                    (let ((entry (scan-file repository path file base: (get-index repository))))
                                      (bind (path digest seconds) entry
                                        (let ((content (store-file repository file digest)))
                                          (case where
                                            ((world)
                                             (calling-server self
                                               (lambda ()
                                                 (upload-world-asset remote-server content digest))))
                                            ((zone)
                                             (calling-processor self
                                               (lambda ()
                                                 (upload-zone-asset remote-processor content digest))))))))))
                                
                                (for-each (lambda (change)
                                            (bind (what path . rest) change
                                              (case what
                                                ((added)
                                                 (upload path)
                                                 (increase! added))
                                                ((modified)
                                                 (upload path)
                                                 (increase! modified))
                                                ((removed)
                                                 (increase! removed)))))
                                          changes)
                                (case where
                                  ((world)
                                   (calling-server self
                                     (lambda ()
                                       (update-world-assets remote-server remote-client changes))))
                                  ((zone)
                                   (calling-processor self
                                     (lambda ()
                                       (update-zone-assets remote-processor remote-client changes)))))
                                (update-changes remote-index changes)
                                (update-changes repository changes)
                                (changes-update world changes))
                              color: {Color World-Blue})
                            (display-message world (format "{a} asset{a} added, {a} asset{a} modified, {a} asset{a} removed"
                                                           added (format-plural added)
                                                           modified (format-plural modified)
                                                           removed (format-plural removed))
                              font: {Font Status}
                              color: {Color World-Blue}
                              duration: 2.))))))))))))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method package (request-chunk self chunk-locator)
    (calling-processor self
      (lambda ()
        (request-chunk remote-processor remote-client chunk-locator))))
  
  
  (method package (receive-chunk self chunk-locator chunk-raw)
    (let ((zone (current-zone)))
      (receive-chunk zone chunk-locator chunk-raw)))

  
  (method override (pause-tier self)
    (calling-processor self
      (lambda ()
        (pause remote-processor))))
  
  
  (method override (unpause-tier self)
    (calling-processor self
      (lambda ()
        (unpause remote-processor))))
    
  
  (method (client-verify self verifier verified)
    (calling-server self
      (lambda ()
        (client-verify remote-server remote-client verifier verified))))

  
  (method package (client-invite self recipient circle-name)
    (calling-server self
      (lambda ()
        (client-invite remote-server remote-client recipient circle-name))))
  
  
  (method package (client-accept self sender circle-name)
    (calling-server self
      (lambda ()
        (client-accept remote-server remote-client sender circle-name))))
  
  
  (method package (client-decline self sender circle-name)
    (calling-server self
      (lambda ()
        (client-decline remote-server remote-client sender circle-name))))
  
  
  (method package (client-problem self sender problem)
    (calling-server self
      (lambda ()
        (client-problem remote-server remote-client sender problem))))
  
  
  (method package (client-status self status)
    (calling-server self
      (lambda ()
        (client-status remote-server remote-client status))))
  
  
  (method package (client-leave self)
    (let ((error (calling-server self
                   (lambda ()
                     (client-leave remote-server remote-client)))))
      (or error
          (begin
            (stop udp-client)
            (close-live-stream self)
            (close-send-streams udp-client)
            (close-receive-streams udp-client)
            (when group-leave-hook
              (group-leave-hook))
            #f))))
  
  
  (method package (client-message self kind recipient message)
    (calling-server self
      (lambda ()
        (client-message remote-server remote-client kind recipient message))))
  
  
  (method package (invitation-list self)
    (calling-server self
      (lambda ()
        (invitation-list remote-server remote-client))))
  
  
  (method package (invitation-add self invitation-word expires)
    (calling-server self
      (lambda ()
        (invitation-add remote-server remote-client invitation-word expires))))
  
  
  (method package (invitation-modify self invitation-word expires)
    (calling-server self
      (lambda ()
        (invitation-modify remote-server remote-client invitation-word expires))))
  
  
  (method package (invitation-remove self key)
    (calling-server self
      (lambda ()
        (invitation-remove remote-server remote-client key))))
  
  
  (method package (admin-server-command self command arguments)
    (calling-server self
      (lambda ()
        (admin-command remote-server remote-client command arguments))))
  
  
  (method package (admin-processor-command self command arguments)
    (calling-processor self
      (lambda ()
        (admin-command remote-processor remote-client command arguments))))
  
  
  (method package (admin-request-chunk self requester cookie sender name chunk done?)
    (calling-server self
      (lambda ()
        (admin-request-chunk remote-server requester cookie sender name chunk done?))))
  
  
  ;(method package (admin-run-return self requester cookie sender state data)
  ;  (calling-server self
  ;    (lambda ()
  ;      (admin-run-return remote-server requester cookie sender state data))))
  
  
  (method (calling-server self thunk)
    (calling-serving self thunk))
  
  
  (method (calling-processor self thunk)
    (calling-serving self thunk))
  
  
  (method (calling-serving self thunk)
    (handle-exception-filter
      connection-exception?
      (lambda (exc)
        (bailout self exc))
      (lambda ()
        (bailout-point 'tcp-write)
        (let ((result (thunk)))
          (if (eq? result disconnect-marker)
              (bailout self (new Error message: "Received disconnect marker"))
            result)))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (add-player self character-name character-avatar character-dye player-id player-no player-mode player-position player-lookat player-script)
    (let ((zone (current-zone)))
      (let ((player (new Player name: character-name me?: #f avatar: character-avatar position: player-position lookat: player-lookat)))
        (register-id player player-id)
        (register-no player player-no)
        (set-mode player player-mode)
        (set-color player character-dye)
        (set-name-pane player character-name color: (if player-script {Color World-Yellow} player-color))
        (add-element zone player))))
  
  
  (method (remove-player self character-name)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; sejour quicky
        (when player
          (remove-element zone player)))))
  
  
  (method (init-circles self lst)
    (set! circles (make-table test: equal?))
    (for-each (lambda (circle)
                (bind (name stone) circle
                  (table-set! circles name stone)))
              lst))
  
  
  (method package (find-circle-stone self name)
    (table-ref circles name #f))
    
  
  (method package (server-entered self client-id client-no character-name)
    (when server-entered-hook
      (server-entered-hook character-name)))
  
  
  (method package (server-exited self character-name)
    (when server-exited-hook
      (server-exited-hook character-name)))
  
  
  (method package (server-disconnected self character-name)
    (when server-disconnected-hook
      (server-disconnected-hook character-name)))
  
  
  (method package (server-reconnected self character-name)
    (when server-reconnected-hook
      (server-reconnected-hook character-name)))

  
  (method package (processor-entered self client-id client-no character-name character-avatar character-dye character-script player-id player-no player-mode player-position player-lookat player-script)
    (let ((world (current-world)))
      (add-player self character-name character-avatar character-dye player-id player-no player-mode player-position player-lookat player-script)
      (if processor-entered-hook
          (processor-entered-hook character-name)
        (display-message world (format "{a} entered world" character-name)))))
  
  
  (method package (processor-exited self character-name)
    (let ((world (current-world)))
      (remove-player self character-name)
      (if processor-exited-hook
          (processor-exited-hook character-name)
        (display-message world (format "{a} exited world" character-name)))))
  
  
  (method package (processor-update self sent changes)
    ;; should probably be applied by a task
    (forward-changes sent (current-seconds) changes))
  
  
  (method package (processor-draw self id color alpha dts pts duration background slide?)
    (receive-processor-draw (current-video) id color alpha dts pts duration background slide?))
  
  
  (method package (zone-loaded self zone error-string)
    (when zone-loaded-hook
      (zone-loaded-hook zone error-string)))
  
  
  (method package (server-verified self verifier)
    (define (layout box)
      (let ((border (child box 'border))
            (yes (child box 'yes)))
        (define (set-v view v)
          (let ((pos (get-position view)))
            (set-position view (new Point (get-h pos) v))))
        
        (set-v border 3)
        (set-v yes 65)))
    
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (play-ambient-sound "warcraft/user/LevelUp" volume: .1)
            (set-user-verified? #t)
            (when user-verified-hook
              (user-verified-hook))
            (open-message `(<span>
                             (<paragraph> justification: center
                               (<text> ,(format "{a} has verified you" verifier)))
                             (<paragraph> (<text> font: Spacer-Small " "))
                             (<paragraph> justification: center
                               (<text> color: {Color World-Blue} "You now have full access to Together!")))
                          caption: "Welcome"
                          layouter: layout
                          type: 'message
                          yes: "Yay!"
                          execute: (lambda (evt)
                                     (let ((dialog (find-ascendant (get-sender evt) World-Dialog)))
                                       (close dialog)))))))))
  
  
  (method package (server-invite self sender circle-name require-microphone? require-camera?)
    (define (layout box)
      (when circle-name
        (let ((border (child box 'border))
              (yes (child box 'yes))
              (no (child box 'no)))
          (define (set-v view v)
            (let ((pos (get-position view)))
              (set-position view (new Point (get-h pos) v))))
          
          (set-v border 3)
          (set-v yes 65)
          (set-v no 65))))
    
    (define (acquire)
      (if circle-name
          (assert circle-acquire-hook
            (circle-acquire-hook require-microphone? require-camera?))
        (if (not (has-microphone?))
            no-microphone-found
          (if (not (acquire-microphone-pipeline))
              unable-to-acquire-microphone
            #f))))
    
    (define (problem problem)
      (display-problem problem)
      (client-problem self sender problem))
    
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (play-ambient-sound "warcraft/user/iPlayerInviteA" volume: .05)
            (open-message (if circle-name
                              `(<span>
                                 (<paragraph> justification: center
                                   (<text> ,(format "{a} invites you to join" sender)))
                                 (<paragraph> (<text> font: Spacer-Small " "))
                                 (<paragraph> justification: center
                                   (<text> color: {Color red: .938 green: .428 blue: .066} ,circle-name)))
                            (format "{a} invites you to join an audio group" sender))
                          caption: "Invitation"
                          location: '(center (center -150))
                          layouter: layout
                          type: 'question
                          yes: "Accept"
                          no: "Decline"
                          execute: (lambda (evt)
                                     (let ((dialog (find-ascendant (get-sender evt) World-Dialog))
                                           (button (get-property evt button:)))
                                       (close dialog)
                                       (case button
                                         ((yes)
                                          (with-cursor :wait
                                            (lambda ()
                                              (let ((err (acquire)))
                                                (client-status self err)
                                                (if err
                                                    (problem err)
                                                  (let ((group-info/exception (client-accept self sender circle-name)))
                                                    (if (string? group-info/exception)
                                                        (display-error (current-world) group-info/exception)
                                                      (if circle-name
                                                          (assert circle-join-hook
                                                            (circle-join-hook circle-name group-info/exception))
                                                        (bind (no require-microphone? require-camera? duration position . streams) group-info/exception
                                                          (start udp-client)
                                                          (require-live-stream self)
                                                          (streams-add self no require-microphone? require-camera? streams)
                                                          (play-microphone self)
                                                          (when group-join-hook
                                                            (group-join-hook)))))))))))
                                         ((no)
                                          (client-decline self sender circle-name)))))))))))
  
  
  (method package (server-accept self recipient circle-name)
    (let ((world (current-world)))
      (if circle-name
          (chat-show world (format "{a} joined circle" recipient))
        (start udp-client)
        (require-live-stream self)
        (play-microphone self)
        (when group-join-hook
          (group-join-hook)))))
  
  
  (method package (server-decline self recipient circle-name)
    (let ((world (current-world)))
      (play-ambient-sound "warcraft/user/LFG_Denied" volume: .1)
      (chat-show world (format "{a} declined your invitation" recipient))))
  
  
  (method package (server-problem self recipient problem)
    (let ((world (current-world)))
      (play-ambient-sound "warcraft/user/LFG_Denied" volume: .1)
      (chat-problem world (format "{a} problem: {a}" recipient problem))))
  
  
  (method package (server-join self recipient)
    (let ((world (current-world)))
      (play-ambient-sound "warcraft/user/MagicClick" volume: .3)
      (chat-show world (format "{a} joined group" recipient))))
  
  
  (method package (server-leave self recipient)
    (let ((world (current-world)))
      (chat-show world (format "{a} left group" recipient))))
  
  
  (method package (server-disband self)
    (let ((world (current-world)))
      (stop udp-client)
      (close-live-stream self)
      (close-send-streams udp-client)
      (close-receive-streams udp-client)
      (when group-leave-hook
        (group-leave-hook))
      (chat-show world "Your group was disbanded")))
  
  
  (method package (server-message self sender kind message)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (let ((interface (current-interface)))
              (let ((chat (child interface 'chat)))
                (when (or (neq? kind 'activity) show-activity?)
                  (show-message chat sender kind message)
                  (when message-received-hook
                    (message-received-hook sender kind message))))))))))
  
  
  (method package (server-messages self messages)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (let ((interface (current-interface)))
              (let ((chat (child interface 'chat)))
                (for-each (lambda (message)
                            (bind (sender kind message) message
                              (when (or (neq? kind 'activity) show-activity?)
                                (show-message chat sender kind message))))
                          messages))))))))
  
  
  (method package (mode-update self character-name mode)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; sejour quicky
        (when player
          (set-mode player mode)))))
  
  
  (method package (world-assets-update self changes)
    (let ((world (current-world)))
      (let ((assets world-assets))
        (update-changes (get-remote-index assets) changes)
        (removed-update assets changes)
        (changes-update world changes))))
  
  
  (method package (zone-assets-update self changes)
    (let ((world (current-world)))
      (let ((assets (get-zone-assets world)))
        (update-changes (get-remote-index assets) changes)
        (removed-update assets changes)
        (changes-update world changes))))
  
  
  (method package (hierarchy-update self hierarchy)
    (define (find-group)
      (continuation-capture
        (lambda (return)
          (for-each (lambda (info)
                      (bind (group require-microphone? require-camera? zone position . members) info
                        (when group
                          (for-each (lambda (member-info)
                                      (let ((name (car member-info)))
                                        (when (equal? name character-name)
                                          (continuation-return return info))))
                                    members))))
                    hierarchy)
          (cons #f (cons #f (cons #f (cons #f (cons #f '()))))))))
    
    (bind (new-group new-group-require-microphone? new-group-require-camera? new-group-zone new-group-position . new-group-members) (find-group)
      (set! group new-group)
      (set! group-members new-group-members))
    (when hierarchy-update-hook
      (hierarchy-update-hook hierarchy)))
  
  
  (method package (circle-added self name stone)
    (table-set! circles name stone))
  
  
  (method package (circle-removed self name)
    (table-clear circles name))
  
  
  (method package (streams-add self group-no group-require-microphone? group-require-camera? streams)
    (for-each (lambda (info)
                (bind (sender name stream-no origin source-kind video-level channels) info
                  (stream-add self group-no group-require-microphone? group-require-camera? sender name stream-no origin source-kind video-level channels)))
              streams))
  
  
  (method package (stream-add self group-no group-require-microphone? group-require-camera? sender name stream-no origin source-kind video-level channels)
    (when (or (not stream-addable-hook)
              (stream-addable-hook group-no))
      (let ((stream (register-receive-stream udp-client sender name stream-no origin source-kind video-level channels)))
        (let ((receive-video-level (stream-receive-video-level stream))
              (highest-video #f)
              (has-video? #f))
          (with-locked-channels stream
            (lambda ()
              (iterate-table (get-channels stream)
                (lambda (channel-no channel)
                  (let ((media-kind (get-media-kind channel)))
                    (ecase media-kind
                      ((udp-audio)
                       (when (get-caps channel)
                         (let ((output (channel-output (current-audio) channel volume: (and (eq? source-kind 'stream) initial-stream-volume))))
                           (let ((ring (get-process-ring channel)))
                             (play-audio output)
                             (set-output channel output)
                             (set-flow ring (get-flow output)))))
                       (let ((video-channel (locate-stream-video-channel (get-stream channel))))
                         (when video-channel
                           (let ((output (get-output video-channel)))
                             (when output
                               (setup-audio (get-root (get-interface-pane output))))))))
                      ((udp-video)
                       (if (get-caps channel)
                           (let ((level (get-level channel)))
                             (when (eqv? level receive-video-level)
                               (let ((video (current-video)))
                                 (let ((output (channel-output video stream-no channel)))
                                   (let ((ring (get-process-ring channel)))
                                     (play-video output)
                                     (set-output channel output)
                                     (set-flow ring (get-color-flow output)))
                                   (when (not (get-focused-output video))
                                     (change-focused-output video output))
                                   (set! has-video? #t)))))
                         (when (or (not highest-video)
                                   (> (get-level channel) (get-level highest-video)))
                           (set! highest-video channel))))))))
              ;; video placeholder
              (when (and (not has-video?)
                         (neq? source-kind 'screen)
                         (neq? source-kind 'view))
                (let ((channel (or highest-video (new UDP-Receive-Channel stream stream-no udp-video source-kind 2 video-resolution video-framerate video-bitrate video-codec #f '() 'on))))
                  (let ((output (channel-output (current-video) stream-no channel process?: #f)))
                    (set-video-placeholder stream output)
                    (set-output channel output))))
              (when stream-add-hook
                (stream-add-hook stream))))))))
  
  
  (method package (stream-remove self stream-no)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (with-locked-channels stream
          (lambda ()
            (when stream-remove-hook
              (stream-remove-hook stream))
            ;; quick hack todo
            (iterate-table (get-channels stream)
              (lambda (channel-no channel)
                (let ((ring (get-process-ring channel)))
                  (set-flow ring #f))))
            (close-receive-stream udp-client stream))))))
  
  
  (method package (stream-disconnect self stream-no)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (iterate-table (get-channels stream)
          (lambda (no channel)
            (ecase (get-media-kind channel)
              ((udp-audio)
               (let ((output (get-output channel)))
                 (when output
                   (set-stream-disconnected output))))
              ((udp-video)
               (let ((output (get-output channel)))
                 (when output
                   (set-stream-disconnected output))))))))))
  
  
  (method package (stream-media-init self stream-no channels-init)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (with-locked-channels stream
          (lambda ()
            (for-each (lambda (channel-init)
                        (bind (channel-no caps resolution) channel-init
                          (let ((channel (find-receive-channel udp-client channel-no)))
                            ;; lets be robust
                            (when channel
                              (set-caps channel caps)
                              (set-resolution channel resolution)
                              (ecase (get-media-kind channel)
                                ((udp-audio)
                                 (let ((audio (current-audio)))
                                   (let ((output (get-output channel)))
                                     (unless output
                                       (let ((output (channel-output audio channel volume: (and (eq? (get-source-kind channel) 'stream) initial-stream-volume))))
                                         (let ((ring (get-process-ring channel)))
                                           (play-audio output)
                                           (set-output channel output)
                                           (set-flow ring (get-flow output))))))))
                                ((udp-video)
                                 (let ((stream (get-stream channel)))
                                   (let ((level (get-level channel))
                                         (receive-video-level (stream-receive-video-level stream))
                                         (video (current-video)))
                                     (when (eqv? level receive-video-level)
                                       (let ((placeholder (get-video-placeholder stream)))
                                         (define (find-output)
                                           (find-if (lambda (output)
                                                      (let ((channel (get-channel output)))
                                                        (and channel
                                                             (eq? (get-stream channel) stream))))
                                                    (get-ordered-outputs video)))
                                         
                                         (let ((output (if placeholder
                                                           (begin
                                                             (set-video-placeholder stream #f)
                                                             (replace-output video placeholder (get-no stream) channel))
                                                         (let ((actual-output (find-output)))
                                                           (if actual-output
                                                               (replace-output video actual-output (get-no stream) channel)
                                                             (channel-output video (get-no stream) channel))))))
                                           (let ((ring (get-process-ring channel)))
                                             (play-video output)
                                             (set-output channel output)
                                             (set-flow ring (get-color-flow output)))
                                           (when (not (get-focused-output video))
                                             (change-focused-output video output)))))))))))))
                      channels-init))))))
  
  
  (method package (stream-media-on self stream-no media-kind)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (with-locked-channels stream
          (lambda ()
            (media-on stream media-kind)
            (iterate-table (get-channels stream)
              (lambda (no channel)
                (when (= (get-media-kind channel) media-kind)
                  (channel-on channel)
                  (ecase media-kind
                    ((udp-audio)
                     (let ((output (get-output channel)))
                       (when output
                         (set-stream-state output 'on))))
                    ((udp-video)
                     (let ((output (get-output channel)))
                       (when output
                         (set-stream-state output 'on)))))))))))))
  
  
  (method package (stream-media-off self stream-no media-kind)
    (let ((stream (find-receive-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (with-locked-channels stream
          (lambda ()
            (media-off stream media-kind)
            (iterate-table (get-channels stream)
              (lambda (no channel)
                (when (= (get-media-kind channel) media-kind)
                  (channel-off channel)
                  (ecase media-kind
                    ((udp-audio)
                     (let ((output (get-output channel)))
                       (when output
                         (set-stream-state output 'off))))
                    ((udp-video)
                     (let ((output (get-output channel)))
                       (when output
                         (set-stream-state output 'off)))))))))))))
  
  
  (method package (streaming-update self video-levels)
    (set! streaming-levels video-levels)
    (streaming-levels-update self))
  
  
  (method package (streamer-update self origin video-level)
    (let ((video (current-video)))
      (iterate-table (get-receive-streams udp-client)
        (lambda (no stream)
          (when (and (get-video-level stream)
                     (= (get-origin stream) origin))
            (with-locked-channels stream
              (lambda ()
                (reset-video-latency stream)
                ;; reset video channels to ensure no video
                ;; processing wakes up to video latency #f
                (iterate-table (get-channels stream)
                  (lambda (no channel)
                    (when (= (get-media-kind channel) udp-video)
                      (reset channel))))
                (set-video-level stream video-level)
                (let ((receive-video-level (stream-receive-video-level stream)))
                  (define (find-output)
                    (find-if (lambda (output)
                               (let ((channel (get-channel output)))
                                 (and channel
                                      (eq? (get-stream channel) stream))))
                             (get-ordered-outputs video)))
                  
                  (let ((output (find-output)))
                    (when output
                      (let ((stream-no (get-stream-no output))
                            (actual-channel (get-channel output)))
                        (iterate-table (get-channels stream)
                          (lambda (no channel)
                            (when (and (= (get-media-kind channel) udp-video)
                                       (= (get-level channel) receive-video-level)
                                       (neq? channel actual-channel))
                              (reset actual-channel)
                              (set-flow (get-process-ring actual-channel) #f)
                              (when (get-caps channel)
                                (let ((new-output (replace-output video output stream-no channel)))
                                  (play-video new-output)
                                  (set-output channel new-output)
                                  (set-flow (get-process-ring channel) (get-color-flow new-output))))))))))))
              udp-video))))))
  
  
  (method package (action-stream self stream-no action arguments)
    (let ((stream (find-send-stream udp-client stream-no)))
      ;; lets be robust
      (when stream
        (let ((action-proc (get-action-proc stream)))
          (when action-proc
            (action-proc stream action arguments))))))
  
  
  (method package (action-channel self channel-no action arguments)
    (let ((channel (find-send-channel udp-client channel-no)))
      ;; lets be robust
      (when channel
        (let ((action-proc (get-action-proc channel)))
          (when action-proc
            (action-proc channel action arguments))))))
  
  
  (method (find-group-member-by-id self id)
    (find group-members id key: second return: 'item))
  
  
  (method (find-group-member-by-no self no)
    (find group-members no key: third return: 'item))
  
  
  (method package (pause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (pause-world world)))))))
  
  
  (method package (unpause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (unpause-world world)))))))
  
  
  (method package (dayduration-client self duration)
    (post-event
      (lambda ()
        (let ((zone (current-zone)))
          (with-task-mutex
            (lambda ()
              (set-day-duration zone duration)))))))
  
  
  (method package (daytime-client self time)
    (post-event
      (lambda ()
        (let ((zone (current-zone)))
          (with-task-mutex
            (lambda ()
              (goto-daytime zone (effective-daytime zone time))))))))
  
  
  (method package (goto-client self time)
    (post-event
      (lambda ()
        (let ((history (current-history)))
          (with-task-mutex
            (lambda ()
              (goto-time history time)))))))
  
  
  (method package (position-client self rect)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:position-client-window rect))))))
  
  
  (method package (restore-client self)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:restore-client-window))))))
  
  
  (method (admin-metadata self)
    (define (send-streams)
      (streams-metadata (get-send-streams udp-client)))
    
    (define (receive-streams)
      (streams-metadata (get-receive-streams udp-client)))
    
    (list client-no character-name (send-streams) (receive-streams) (sites-metadata)))
  
  
  ;; quicky
  (definition last-gst-pid
    #f)
  
  
  (definition preserved-exception-debugger
    #f)
  
  (definition preserved-exception-hook
    #f)
  
  
  (method package (admin-request self requester requester-name cookie what action)
    (define (send-caps)
      (let ((file (client-machine-file "caps")))
        (when (exists? file)
          (send-content 0 file))))
    
    (define (send-info)
      (send-threaded 0
        (lambda ()
          (let ((version (process-version (current-process)))
                (date (build-short-date)))
            ;; gc before process-memory
            (let ((garbage-collect (estimate-garbage-collect)))
              (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
                (object->u8vector
                  (list
                    (format "{a} v{a}" kernel-platform (present (get-platform-version)))
                    (format "v{a}{a}" (present version) environment-suffix)
                    date
                    effective-base-profile
                    (map get-purpose (table-values presences))
                    garbage-collect
                    (estimate-cpu%)
                    (length (top-threads))
                    (current-process-memory)
                    last-gc-live
                    last-gc-movable
                    last-gc-nonmovable
                    (leaks-tracer-live-count)
                    (let ((port (get-udp-port udp-client)))
                      (list (udp-socket-receive-buffer-size port)
                            (udp-socket-send-buffer-size port)
                            (udp-socket-send-again-count port)))
                    (camera-caps self)))))))))
    
    (define (send-monitor)
      (send-threaded 0
        (lambda ()
          (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
            (object->u8vector
              (list (current-process-memory)
                    last-gc-live
                    last-gc-movable
                    last-gc-nonmovable
                    (leaks-tracer-live-count)
                    (current-process-threads)))))))
    
    (define (send-health)
      (send-threaded 0
        (lambda ()
          (object->u8vector
            (map get-max-usage (get-ordered-outputs (current-video)))))))
    
    (define (send-energy)
      (send-threaded 0
        (lambda ()
          (object->u8vector (current-process-threads)))))
    
    (define (send-capture)
      (start-captures)
      (send-reply "capture on" #t))
    
    (define (send-uncapture)
      (stop-captures)
      (send-reply "capture off" #t))
    
    (define (send-retrieve)
      (let ((captures (copy-captures)))
        (for-each (lambda (capture)
                    (bind (name info . data) capture
                      (send-threaded (format "{a}/{a}" name (rawaudio-extension info))
                        (lambda ()
                          data))))
                      captures)))
    
    (define (send-evolution)
      (let ((metadata (admin-metadata self))
            (chronology (empty-chronology))
            (evolution (copy-evolution (current-evolution))))
        (send-threaded 0
          (lambda ()
            (object->u8vector (list metadata chronology evolution) serialize)))))
    
    (define (send-replay)
      (let ((metadata (admin-metadata self))
            (chronology (copy-chronology (current-chronology)))
            (evolution (copy-evolution (current-evolution)))
            (moments (copy-moments))
            (captures (copy-captures)))
        (let ((replay-thread
                (send-threaded 0
                  (lambda ()
                    (object->u8vector (list metadata chronology evolution) serialize))
                  (lambda ()
                    (gather-replay-missing udp-client action)))))
          (let ((moments-thread
                  (send-threaded 'moments
                    (lambda ()
                      (thread-join! replay-thread)
                      (object->u8vector moments serialize)))))
            (for-each (lambda (capture)
                        (bind (name info . data) capture
                          (send-threaded (format "{a}/{a}" name (rawaudio-extension info))
                            (lambda ()
                              (thread-join! moments-thread)
                              data))))
                      captures)))))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Documents "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file)
      (let ((dir {Directory Documents "shared"})
            (name action))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-settings)
      (let ((file (client-machine-file "settings")))
        (when (exists? file)
          (send-content 0 file))))
    
    (define (send-moments)
      (send-threaded 0
        (lambda ()
          (object->u8vector (retrieve-moments) serialize))))
    
    (define (send-gst-validate)
      (send-threaded 0
        (lambda ()
          (object->u8vector (gst-validate) serialize))))
    
    (define (send-gst)
      (let ((port (case what
                    ((gst-device-monitor) (apply gst-device-monitor (map ->string action)))
                    ((gst-inspect) (apply gst-inspect (map ->string action)))
                    ((gst-launch) (apply gst-launch "--gst-debug-no-color" (split-string action #\space)))
                    ((gst-play) (gst-play "--quiet" "--gst-debug-no-color" action)))))
        (set! last-gst-pid (process-pid port))
        (send-streaming what
          (lambda ()
            (read-platform-line port)))))
    
    (define (send-gst-done)
      (let ((result
              (if last-gst-pid
                  (begin
                    (interrupt-process last-gst-pid)
                    (set! last-gst-pid #f)
                    'done)
                #f)))
        (send-reply result #t)))
    
    (define (send-set)
      (bind (setting . value) action
        (set-machine-setting setting value)
        (send-reply "set" #t)))
    
    (define (send-unset)
      (let ((setting action))
        (unset-machine-setting setting)
        (send-reply "unset" #t)))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (send-content name file)
      (send-threaded name
        (lambda ()
          (object->u8vector (load-lines file)))))
    
    (define (generate-snapshot)
      (snapshot-process reason: (format "Snapshot requested by {a}" requester-name))
      (send-reply "done" #t))
    
    (define (attach-to-debugger)
      (if (get-controller-debugger)
          (send-reply "Already attached" #f)
        (let ((debugger action))
          (background
            (lambda ()
              (let ((exception-debugger (get-exception-debugger))
                    (exception-hook (jazz:get-exception-hook)))
                (current-process-title-set! character-name)
                ;; setup-debuggee because of calling tcp-client-peer-socket-info
                ;; can take a very long time to timeout so run in the background
                (let ((exc (setup-debuggee debugger: debugger connection-exception-exit?: #f)))
                  (if exc
                      (with-task-mutex
                        (lambda ()
                          (send-reply "Unable to connect to debugger" #f)))
                    (thread-int! (primordial-thread)
                      (lambda ()
                        (with-reentrant-task-mutex
                          (lambda ()
                            (set! preserved-exception-debugger exception-debugger)
                            (set! preserved-exception-hook exception-hook)
                            (start-repl-thread (current-thread) #f (current-console-port))
                            (select-debugger-console)
                            (current-input-port (console-input-port))
                            (current-output-port (console-output-port))
                            (ready-to-controller)
                            (send-reply "attached" #t)))))))))
            'attach))))
    
    (define (detach-from-debugger)
      (if (not (get-controller-debugger))
          (send-reply "Already detached" #f)
        (current-input-port (standard-input-port))
        (current-output-port (standard-output-port))
        (detach-from-controller)
        (set-exception-debugger preserved-exception-debugger)
        (set-exception-hook preserved-exception-hook)
        (set! preserved-exception-debugger #f)
        (set! preserved-exception-hook #f)
        (send-reply "detached" #t)))
    
    (define (send-reply name done?)
      (let ((sender character-name))
        (admin-request-chunk self requester cookie sender name #f done?)))
    
    (define (send-threaded name extract (missing #f))
      (background
        (lambda ()
          (let ((data (extract))
                (sender character-name))
            (admin-request-chunk self requester cookie sender name #f #f)
            (let ((content (zlib-deflate data))
                  (give-time .01))
              (when missing
                (let ((missing (missing)))
                  (for-each (lambda (missing)
                              (sleep give-time)
                              (admin-request-chunk self requester cookie sender 'missing missing #f))
                            missing)))
              (let ((content-size (u8vector-length content))
                    (max-size 8192))
                (let (loop-chunk (part 0) (pos 0))
                  (let ((remain (- content-size pos)))
                    (when (> remain 0)
                      (sleep give-time)
                      (let ((chunk-size (min remain max-size)))
                        (let ((chunk (make-u8vector chunk-size))
                              (done? (>= chunk-size remain)))
                          (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                          (admin-request-chunk self requester cookie sender name chunk done?))
                        (loop-chunk (+ part 1) (+ pos chunk-size))))))))))))
    
    (define (send-streaming name next)
      (background
        (lambda ()
          (declare (proper-tail-calls))
          (let ((sender character-name))
            (admin-request-chunk self requester cookie sender name #f #f)
            (let (loop)
              (let ((data (next)))
                (if (eof-object? data)
                    (admin-request-chunk self requester cookie sender name #f #t)
                  (let ((chunk (zlib-deflate (object->u8vector data))))
                    (admin-request-chunk self requester cookie sender name chunk #f))
                  (loop))))))))
    
    (define (background thunk (name 'request))
      (let ((thread (new-thread thunk name)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)
        thread))
    
    (case what
      ((caps)
       (send-caps))
      ((info)
       (send-info))
      ((monitor)
       (send-monitor))
      ((health)
       (send-health))
      ((energy)
       (send-energy))
      ((capture)
       (send-capture))
      ((uncapture)
       (send-uncapture))
      ((retrieve)
       (send-retrieve))
      ((evolution)
       (send-evolution))
      ((replay)
       (send-replay))
      ((shared)
       (send-shared))
      ((transfer)
       (send-shared-file))
      ((settings)
       (send-settings))
      ((moments)
       (send-moments))
      ((gst-validate)
       (send-gst-validate))
      ((gst-device-monitor gst-inspect gst-launch gst-play)
       (send-gst))
      ((gst-done)
       (send-gst-done))
      ((set)
       (send-set))
      ((unset)
       (send-unset))
      ((snapshot)
       (generate-snapshot))
      ((attach)
       (attach-to-debugger))
      ((detach)
       (detach-from-debugger))))
  
  
  (method package (admin-chunk self cookie sender name chunk done?)
    (let ((proc (registered-request-procedure cookie)))
      (proc sender name chunk done?)))
  
  
  ;(method package (admin-run self requester cookie script)
  ;  (run-remote-script script
  ;    (lambda (state data)
  ;      (let ((sender character-name))
  ;        (admin-run-return self requester cookie sender state data)))))
  
  
  ;(method package (admin-return self cookie sender state data)
  ;  (let ((proc (registered-request-procedure cookie)))
  ;    (proc sender state data)))
  
  
  (method package (update-effective-base-profile self)
    (let ((video (current-video)))
      (let ((count (length (get-ordered-outputs video))))
        (let ((profile (determine-effective-base-profile count)))
          (change-effective-base-profile self profile)))))
  
  
  (method package (change-effective-base-profile self profile)
    (let ((video (current-video)))
      (unless (eq? profile effective-base-profile)
        (set-effective-base-profile profile)
        (change-graphic-profile profile)
        (change-video-profile profile)
        (change-camera-profile-override profile)
        (update-render-rate)
        (let ((video-profile (active-video-profile)))
          (let ((new-video-level (get-level video-profile))
                (new-video-name (get-name video-profile)))
            ;; server
            (change-video-level self new-video-level)
            ;; throttle
            (reset-throttle-upload self)
            ;; receive
            (iterate-table (get-receive-streams udp-client)
              (lambda (no stream)
                (define (find-output)
                  (find-if (lambda (output)
                             (let ((channel (get-channel output)))
                               (and channel
                                    (eq? (get-stream channel) stream))))
                           (get-ordered-outputs video)))
                
                (define (streaming-channel)
                  (continuation-capture
                    (lambda (return)
                      (let ((receive-video-level (stream-receive-video-level stream)))
                        (iterate-table (get-channels stream)
                          (lambda (no channel)
                            (when (= (get-media-kind channel) udp-video)
                              (let ((level (get-level channel)))
                                (when (eqv? level receive-video-level)
                                  (continuation-return return channel)))))))
                      #f)))
                
                (with-locked-channels stream
                  (lambda ()
                    (let ((output (find-output)))
                      (when output
                        (let ((stream-no (get-stream-no output))
                              (actual-channel (get-channel output))
                              (streaming-channel (streaming-channel)))
                          (when (neq? streaming-channel actual-channel)
                            (reset actual-channel)
                            (set-flow (get-process-ring actual-channel) #f)
                            (when (get-caps streaming-channel)
                              (let ((new-output (replace-output video output stream-no streaming-channel)))
                                (play-video new-output)
                                (set-output streaming-channel new-output)
                                (set-flow (get-process-ring streaming-channel) (get-color-flow new-output))))))))))))
            ;; send
            (iterate-table (get-send-streams udp-client)
              (lambda (no stream)
                (define (find-self-output)
                  (find-if (lambda (output)
                             (let ((channel (get-channel output)))
                               (and channel
                                    (eq? (get-stream channel) stream))))
                           (get-ordered-outputs video)))
                
                (when (eq? (get-source-kind stream) 'stream)
                  (let ((self-output (find-self-output)))
                    (let ((self-stream-no (and self-output (get-stream-no self-output)))
                          (self-channel (and self-output (get-channel self-output)))
                          (stream-video-channels (let ((queue (new-queue)))
                                                   (iterate-table (get-channels stream)
                                                     (lambda (no channel)
                                                       (when (= (get-media-kind channel) udp-video)
                                                         (let ((pipeline (get-pipeline channel)))
                                                           (when pipeline
                                                             (let ((src (get-src pipeline)))
                                                               (when (is? src File-Stream-Video-Src)
                                                                 (enqueue queue channel))))))))
                                                   (queue-list queue))))
                      (let ((unique-channel? (= 1 (length stream-video-channels))))
                        (for-each (lambda (channel)
                                    (let ((src (get-src (get-pipeline channel))))
                                      (let ((channel-level (get-level channel)))
                                        (let ((stream? (or (<= channel-level new-video-level) unique-channel?)))
                                          (set-stream? src stream?)
                                          (when (and self-channel
                                                     (neq? channel self-channel)
                                                     (= channel-level new-video-level))
                                            (let ((new-output (replace-output video self-output self-stream-no channel sync-audio?: #t)))
                                              (play-video new-output)
                                              (set-output channel new-output)))))))
                                  stream-video-channels)))))))
            ;; camera
            (when camera-channel
              (let ((on? (camera-on? self))
                    (camera-pipeline (get-pipeline camera-channel)))
                (let ((pipeline (get-pipeline (get-src camera-pipeline))))
                  (let ((elements (get-elements camera-pipeline)))
                    ;; self
                    (define (find-actual-consumer)
                      (find-if (lambda (element)
                                 (and (is? element Camera-Self-Consumer)
                                      (get-processing? element)))
                               elements))
                    
                    (define (find-new-consumer)
                      (find-if (lambda (element)
                                 (and (is? element Camera-Self-Consumer)
                                      (= (get-level (get-profile element)) new-video-level)))
                               elements))
                    
                    (define (update-probe consumer processing?)
                      (let ((profile (get-profile consumer))
                            (probe (get-probe consumer)))
                        (let ((name (get-name profile))
                              (selfrate (get-selfrate profile)))
                          (let ((rate (if processing? selfrate 0)))
                            (gst_rate_probe_set_rate probe rate)))))
                    
                    (let ((actual-consumer (find-actual-consumer))
                          (new-consumer (find-new-consumer)))
                      (when (neq? new-consumer actual-consumer)
                        (when on?
                          (update-probe new-consumer #t))
                        (let ((self-output (get-self-output video))
                              (self-consumer (get-self-consumer video)))
                          (let ((rank (and self-output (find-output-rank video self-output))))
                            (let ((new-output (create-self-output new-consumer)))
                              (set-output new-consumer new-output)
                              (when on?
                                ;; display one new buffer before stopping the
                                ;; actual consumer in order to remove flicker
                                (gst_app_sink_process_one_buffer new-consumer)
                                (update-probe actual-consumer #f))
                              (set-processing? actual-consumer #f)
                              (when on?
                                (stop-processing actual-consumer))
                              (set-stream-state (get-output actual-consumer) 'off)
                              (when self-output
                                (close-self-output self-consumer))
                              (install-self-output new-consumer rank: rank))))
                        (set-processing? new-consumer #t)
                        (when on?
                          (start-processing new-consumer camera-priority))))
                    ;; media
                    (for-each (lambda (channel)
                                (let ((element (get-consumer channel)))
                                  (let ((profile (get-profile element)))
                                    (let ((name (get-name profile))
                                          (level (get-level profile))
                                          (framerate (get-framerate profile)))
                                      (let ((processing? (and (<= level new-video-level)
                                                              (streaming-level? self level new-video-level))))
                                        (when (neq? processing? (get-processing? element))
                                          (when on?
                                            (let ((probe (get-probe element))
                                                  (rate (if processing? framerate 0)))
                                              (gst_rate_probe_set_rate probe rate)))
                                          (set-processing? element processing?)
                                          (when on?
                                            (if processing?
                                                (begin
                                                  (start-processing element camera-priority)
                                                  (maybe-media-init self channel))
                                              (stop-processing element)))))))))
                              camera-channels))))))))))
  
  
  (method package (streaming-levels-update self)
    ;; camera
    (let ((on? (camera-on? self))
          (camera-video-level (camera-profile-override-level)))
      (for-each (lambda (channel)
                  (let ((element (get-consumer channel)))
                    (let ((profile (get-profile element)))
                      (let ((name (get-name profile))
                            (level (get-level profile))
                            (framerate (get-framerate profile)))
                        (let ((processing? (and (<= level camera-video-level)
                                                (streaming-level? self level camera-video-level))))
                          (when (neq? processing? (get-processing? element))
                            (when on?
                              (let ((probe (get-probe element))
                                    (rate (if processing? framerate 0)))
                                (gst_rate_probe_set_rate probe rate)))
                            (set-processing? element processing?)
                            (when on?
                              (if processing?
                                  (begin
                                    (start-processing element camera-priority)
                                    (maybe-media-init self channel))
                                (stop-processing element)))))))))
                camera-channels)))
  
  
  (method package (streaming-level? self video-level max-video-level)
    (or camera-all?
        (and camera-single? (= video-level max-video-level))
        (memv? video-level streaming-levels)
        (and (= video-level max-video-level)
             (some? (lambda (level)
                      (>= level video-level))
                    streaming-levels))))
  
  
  ;;;
  ;;;; Stream
  ;;;
  
  
  (method package (require-live-stream self)
    (or live-stream
        (let ((channels (cons (make-microphone-channel)
                              (make-camera-channels))))
          (let ((stream (make-stream "Live" 'live (camera-profile-override-level) channels)))
            ;; microphone
            (let ((channel (locate-audio-channel stream)))
              (set! microphone-channel channel))
            ;; camera
            (let ((channels (collect-video-channels stream)))
              (let ((pipeline (make-shared-camera-pipeline (get-no stream) channels)))
                (for-each (lambda (channel)
                            (set-pipeline channel pipeline))
                          channels)
                ;; any channel will do as they all share the same pipeline
                (let ((channel (car channels)))
                  (set! camera-channel channel))
                (set! camera-channels channels)))
            (set! live-stream stream)
            stream))))
  
  
  (method package (close-live-stream self)
    (when live-stream
      (close-send-stream udp-client live-stream)
      (set! live-stream #f)
      (set! microphone-channel #f)
      (set! camera-channel #f)))
  
  
  ;;;
  ;;;; Microphone
  ;;;
  
  
  (method package (toggle-microphone self)
    (if (microphone-on? self)
        (release-microphone self feedback?: #t)
      (play-microphone self feedback?: #t)))
  
  
  (method package (play-microphone self (feedback?: feedback? #f))
    (let ((world (current-world)))
      (unless (on? microphone-channel)
        (let ((stream-no (get-no live-stream)))
          (media-on self stream-no udp-audio)
          (play microphone-channel)
          (let ((caps (require-caps microphone-channel)))
            (media-init self stream-no (list (list (get-no microphone-channel) caps #f)))
            (set-send-state microphone-channel 'on)
            (set-caps microphone-channel caps))
          (invalidate-self-output self)
          (update-parameter world 'microphone)
          (when feedback?
            (display-on/off world "Microphone" (microphone-on? self)))))))
  
  
  (method package (release-microphone self (feedback?: feedback? #f))
    (let ((world (current-world)))
      (when (on? microphone-channel)
        (media-off self (get-no live-stream) udp-audio)
        (release microphone-channel)
        (set-send-state microphone-channel 'off)
        (set-caps microphone-channel #f)
        (invalidate-self-output self)
        (update-parameter world 'microphone)
        (when feedback?
          (display-on/off world "Microphone" (microphone-on? self))))))
  
  
  (method package (update-microphone-identifier self name identifier)
    (write-microphone-name name)
    (when (microphone-on? self)
      (update-identifier (get-src (get-pipeline microphone-channel)) identifier)))
  
  
  (method package (invalidate-self-output self)
    (let ((video (current-video)))
      (let ((self-output (get-self-output video)))
        (when self-output
          (invalidate-state self-output)))))

  
  (method package (microphone-on? self)
    (and microphone-channel
         (on? microphone-channel)))
  
  
  (method package (change-rndenoise self flag)
    (set-audio-rndenoise? flag)
    (when (microphone-on? self)
      (let ((src (get-src (get-pipeline microphone-channel))))
        (update-rndenoise src flag))))
  
  
  ;;;
  ;;;; Speaker
  ;;;

  
  (method package (with-update-audio self thunk)
    (assert-task-mutex)
    (if (not cached-audio)
        (thunk)
      (let ((udp (current-udp))
            (audio (current-audio)))
        (iterate-table (get-receive-channels udp)
          (lambda (no channel)
            (when (= (get-media-kind channel) udp-audio)
              (mutex-lock! (get-mutex (get-process-ring channel))))))
        (iterate-table (get-send-channels udp)
          (lambda (no channel)
            (when (= (get-media-kind channel) udp-audio)
              (mutex-lock! (get-audio-mirror-mutex channel)))))
        (let ((preserved '()))
          (iterate-table (get-outputs audio)
            (lambda (id output)
              (let ((info (list
                            id
                            (get-channel output)
                            (get-codec output)
                            (get-caps output)
                            (get-volume output)
                            (muted? output))))
                (set! preserved (cons info preserved)))
              (close-output audio id output)))
          (close-audio)
          (thunk)
          (cache-audio)
          (for-each (lambda (info)
                      (bind (id channel codec caps volume muted?) info
                        (let ((output (player-output audio id channel: channel codec: codec caps: caps volume: volume)))
                          (when muted?
                            (mute output))
                          (when (is? channel UDP-Receive-Channel)
                            (reset channel)
                            (let ((ring (get-process-ring channel)))
                              (play-audio output)
                              (set-output channel output)
                              (set-flow ring (get-flow output)))))))
                    preserved))
        (iterate-table (get-receive-channels udp)
          (lambda (no channel)
            (when (= (get-media-kind channel) udp-audio)
              (mutex-unlock! (get-mutex (get-process-ring channel))))))
        (iterate-table (get-send-channels udp)
          (lambda (no channel)
            (when (= (get-media-kind channel) udp-audio)
              (mutex-unlock! (get-audio-mirror-mutex channel))))))))
  
  
  (method package (update-speaker-identifier self name identifier)
    (with-update-audio self
      (lambda ()
        (write-speaker-name name))))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method package (toggle-camera self)
    (if (camera-on? self)
        (release-camera self feedback?: #t)
      (play-camera self feedback?: #t)))
  
  
  (method package (stop-camera self)
    (when (camera-on? self)
      (release-camera self)))
  
  
  (method package (play-camera self (feedback?: feedback? #f))
    (let ((world (current-world)))
      (unless (on? camera-channel)
        (let ((stream-no (get-no live-stream)))
          (media-on self stream-no udp-video)
          (play camera-channel)
          (let ((channels-init (collect (lambda (channel)
                                          (let ((info (require-consumer-caps channel)))
                                            (and info
                                                 (receive (caps resolution) info
                                                   (set-caps channel caps)
                                                   (set-resolution channel resolution)
                                                   (list (get-no channel) caps resolution)))))
                                        camera-channels)))
            (when (not-null? channels-init)
              (media-init self stream-no channels-init)))
          (set-send-state camera-channel 'on)
          (update-parameter world 'camera)
          (when feedback?
            (display-on/off world "Camera" (camera-on? self)))))))
  
  
  (method package (release-camera self (feedback?: feedback? #f))
    (let ((world (current-world)))
      (when (on? camera-channel)
        (release camera-channel)
        (set-send-state camera-channel 'off)
        (set-caps camera-channel #f)
        (media-off self (get-no live-stream) udp-video)
        (update-parameter world 'camera)
        (when feedback?
          (display-on/off world "Camera" (camera-on? self))))))
  
  
  (method package (update-camera-identifier self name identifier)
    (write-camera-name name)
    (when (camera-on? self)
      (update-identifier (get-src (get-pipeline camera-channel)) identifier)))
  
  
  (method package (camera-on? self)
    (and camera-channel
         (on? camera-channel)))
  
  
  (method package (camera-caps self)
    (and (camera-on? self)
         (determine-caps (get-src (get-pipeline camera-channel)))))
  
  
  (method package (camera-bitrate self)
    (and (camera-on? self)
         (determine-bitrate (get-src (get-pipeline camera-channel)))))
  
  
  (method package (throttle-upload self)
    (when (camera-on? self)
      (throttle-bitrate (get-src (get-pipeline camera-channel))))
    (let ((stream (world.streamer:locate-screen-stream)))
      (when stream
        (let ((channel (locate-screen-channel stream)))
          (throttle-bitrate (get-src (get-pipeline channel)))))))
  
  
  (method package (reset-throttle-upload self)
    (reset (get-throttle udp-client))
    ;; the previous call having reset the multiplier to 1
    ;; this call will reset the actual bitrates to 100%
    (throttle-upload self))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method (invalidate-audio-state self output)
    (let ((channel (get-channel output)))
      (when channel
        (let ((video-channel (locate-stream-video-channel (get-stream channel))))
          (when video-channel
            (let ((output (get-output video-channel)))
              (when output
                (invalidate-state output #t))))))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (tile-server remote-server))))))
  
  
  (method override (restore self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (restore-server remote-server))))))
  
  
  ;;;
  ;;;; Profile
  ;;;
  
  
  (method package (start-profile self)
    (start-profile udp-client)
    (calling-server self
      (lambda ()
        (profile-start remote-server remote-client))))
  
  
  (method package (test-profile self test arguments)
    (calling-server self
      (lambda ()
        (profile-test remote-server remote-client test arguments))))
  
  
  (method package (retrieve-profiles self)
    (let ((server-profile
            (calling-server self
              (lambda ()
                (profile-retrieve remote-server remote-client))))
          (client-profile
            (retrieve-profile udp-client)))
      (values server-profile client-profile)))
  
  
  (method package (stop-profile self)
    (stop-profile udp-client)
    (calling-server self
      (lambda ()
        (profile-stop remote-server remote-client))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (calling-server self
        (lambda ()
          (client-log remote-server remote-client (current-seconds) message)))))))
