;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.client.tier jazz


(import (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.view)
        (jazz.zlib)
        (world)
        (world.audio)
        (world.autoload)
        (world.camera)
        (world.change)
        (world.chronology)
        (world.client)
        (world.client.request)
        (world.client.udp)
        (world.configure)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.id)
        (world.interface)
        (world.io)
        (world.log)
        (world.player)
        (world.profiling)
        (world.protocol)
        (world.ring)
        (world.scriptum)
        (world.scriptum)
        (world.settings)
        (world.sound)
        (world.stream)
        (world.streaming)
        (world.support)
        (world.task)
        (world.tier)
        (world.udp)
        (world.video))


(hub connect)
(hub disconnect)


(class Client-Tier extends Tier
  
  
  (slot configuration                         getter generate)
  (slot state                  initialize #f  getter generate)
  (slot client-id              initialize #f  getter generate)
  (slot client-no              initialize #f  getter generate)
  (slot welcome                initialize #f  getter generate)
  (slot welcomed?              initialize #f  accessors generate)
  (slot mutex                                 getter generate)
  (slot form                   initialize #f  getter generate)
  (slot spawnpoint             initialize #f  getter generate)
  (slot player-spawnpoint      initialize #f  getter generate)
  (slot character-name         initialize #f  getter generate)
  (slot character-avatar       initialize #f  getter generate)
  (slot character-script       initialize #f  getter generate)
  (slot player-id              initialize #f  getter generate)
  (slot player-no              initialize #f  getter generate)
  (slot player-position        initialize #f  getter generate)
  (slot player-lookat          initialize #f  getter generate)
  (slot other-players          initialize #f  getter generate)
  (slot remote-client          initialize #f  getter generate)
  (slot remote-server          initialize #f  getter generate)
  (slot remote-processor       initialize #f  getter generate)
  (slot group                  initialize #f  getter generate)
  (slot group-members          initialize '() getter generate)
  (slot players-cache                         getter generate)
  (slot udp-client             initialize #f  getter generate)
  (slot mic-channel            initialize #f  accessors generate)
  (slot camera-channel         initialize #f  accessors generate)
  (slot server-entered-hook    initialize #f  accessors generate)
  (slot server-exited-hook     initialize #f  accessors generate)
  (slot processor-entered-hook initialize #f  accessors generate)
  (slot processor-exited-hook  initialize #f  accessors generate)
  (slot hierarchy-update-hook  initialize #f  accessors generate)
  
  
  (method override (initialize self dir)
    (nextmethod self dir)
    (set-connection-problem-handler
      (lambda (process connection remote-uuid)
        (catch (connection-exception? exc
                 (delay-bailout-client self exc))
          (process connection remote-uuid))))
    (set! configuration (if local?
                            (get-client-configuration)
                          (instantiate (read-form (new-file dir ".client")))))
    (set! mutex (make-mutex 'client))
    (set! assets (make-assets self directory))
    (set! players-cache (make-table test: eqv?))
    (connect-to-server self)
    (connect-to-udp-server self)
    (set-client-id/no client-id client-no))
  
  
  (method override (startup self)
    (nextmethod self)
    ;; open test quick hacks
    ;; be careful this was also done for server
    ;; and ended up resetting some literal being
    ;; registered during the boot process
    (world.history:reset-literals))
  
  
  (method override (enter self)
    (let ((zone (current-zone))
          (me (current-me)))
      (set-spawnpoint zone spawnpoint)
      (set-player-spawnpoint zone player-spawnpoint)
      (set-name me character-name)
      (set-avatar me character-avatar)
      (register-id me player-id)
      (register-no me player-no)
      (set-position me player-position)
      (set-lookat me player-lookat)
      ;; quick hack around server not having camera info
      (set-position (player-camera me) player-position)
      (set-lookat (player-camera me) player-lookat)
      (for-each (lambda (info)
                  (bind (character-name character-avatar player-id player-no player-position player-lookat player-script) info
                    (add-player self character-name character-avatar player-id player-no player-position (make-standard-lookat) @why-is-it-corrupted??? player-lookat player-script)))
                other-players)))
  
  
  (method override (shutdown self)
    (stop-to-server self)
    (close-mic-channel self)
    (close-camera-channel self)
    (disconnect-from-udp-server self)
    (disconnect-from-server self)
    (when (and (not (get-server-host configuration))
               (not (get-server-service configuration)))
      (set-local-server #f)))
  
  
  (method override (get-udp-tier self)
    udp-client)
  
  
  (method package (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-cycle-topologies self evt)
    (cycle-topologies udp-client))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (when (effective-show-blocking?)
      (debug 'register-literal literal))
    (calling-server self
      (lambda ()
        (register-literal remote-server literal))))
  
  
  (method override (tier-id->literal self id)
    (let ((literal
            (calling-server self
              (lambda ()
                (registered-id remote-server id)))))
      (when (effective-show-blocking?)
        (debug 'registered-id id '-> literal))
      literal))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  ;; player info will be given by server
  (method override (setup-me self)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((player (new Player)))
        (new Camera parent: player)
        (set-current-me player)
        (when character-script
          (let ((script (new Script parent: player text: (load-asset-text (find-script world character-script)))))
            (run-task player script))))))
  
  
  ;;;
  ;;;; Remote
  ;;;
  
  
  (method override (unimplemented-connected self)
    (let ((world (current-world)))
      (unless (world-setting 'world.allow-connected? #f)
        (display-cancel world "Unimplemented when connected"))))


  ;;;
  ;;;; Server
  ;;;


  (method (connect-to-server self)
    (define (connect)
      (if local?
          local-server
        (let ((host (get-server-host configuration))
              (port (get-server-service configuration)))
          (assert (and host port)
            (start-remote-presence)
            (let ((remote-register (connect-remote-register host port)))
              (load-object remote-register 'world.server.remote 'world-remote-server))))))
    
    (set! character-name (get-character-name configuration))
    (set! character-avatar (get-character-avatar configuration))
    (set! character-script (get-character-script configuration))
    (set-fifo-prefix (format "{a}_" (downcase character-name)))
    (let ((server (connect))
          (client (load-object (get-local-register) 'world.client.remote 'world-remote-client))
          (uuid (get-uuid (require-presence #f)))
          (character-zone (get-character-zone configuration)))
      (let ((info
              (calling-server self
                (lambda ()
                  (client-connect server client uuid character-name character-avatar character-script character-zone sphere?)))))
        (if (string? info)
            (begin
              (close-remote-proxy server)
              (throw info))
          (set! remote-client client)
          (set! remote-server server)
          (bind (client-id client-no assets processor welcome form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) info
            (set! self.client-id client-id)
            (set! self.client-no client-no)
            (reset-last-forward)
            (set! self.remote-processor (if sphere? (connect-remote-proxy processor) #f))
            (set! self.welcome welcome)
            ;; open test quicky to send form as a string
            (set! self.form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from))
            (set! self.spawnpoint spawnpoint)
            (set! self.player-spawnpoint player-spawnpoint)
            (set! self.player-id player-id)
            (set! self.player-no player-no)
            (set! self.player-position player-position)
            (set! self.player-lookat player-lookat)
            (set! self.other-players other-players)
            (set! self.state 'connected)
            (load-point 'connected))))))
  
  
  (method (connect-to-udp-server self)
    (define (determine-parameters)
      (if local-server
          (values "localhost" "localhost" (get-service (remote-proxy->connection local-server)))
        (values "*" (get-server-host configuration) (get-server-service configuration))))
    
    (receive (local-host host service) (determine-parameters)
      (let ((client (new UDP-Client client-no)))
        (connect client local-host host service)
        (set! udp-client client))))
  
  
  (method (start-to-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-start remote-server remote-client)))
      (set! state 'started)))
  
  
  (method (stop-to-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-stop remote-server remote-client)))
      (set! state 'stopped)))
  
  
  (method (disconnect-from-udp-server self)
    (with-mutex self
      (lambda ()
        (when udp-client
          (stop udp-client)
          (disconnect udp-client)
          (set! udp-client #f)))))
  
  
  (method (disconnect-from-server self)
    (when remote-server
      (calling-server self
        (lambda ()
          (client-disconnect remote-server remote-client character-name)))
      (detach-from-server self)
      (set! state 'disconnected)))
  
  
  (method (detach-from-server self)
    (request-shutdown)
    (with-mutex self
      (lambda ()
        (when remote-server
          (close-remote-proxy remote-server)
          (set! remote-server #f)
          (set! remote-processor #f)
          (set! remote-client #f)))))
  
  
  (method package (detach-client self)
    (detach-from-server self)
    (if (window?)
        (let ((world (current-world)))
          (open-welcome world exception: "Disconnected from server"))
      (quit)))
  
  
  (method (bailout-client self exc)
    (if (window?)
        ;; this test is a simple solution
        ;; to having multiple threads bailout
        (let ((zone (current-zone+)))
          (unless (and zone (welcome? zone))
            (detach-from-server self)
            (let ((world (current-world)))
              (open-welcome world exception: "Disconnected from server"))))
      ;; too much for bots
      (unless bot?
        (snapshot-process exception: exc))
      (quit)))
  
  
  (method (delay-bailout-client self exc)
    (delay-event
      (lambda ()
        (with-reentrant-task-mutex
          (lambda ()
            (bailout-client self exc))))))
  
  
  (method package (send-client-alive self)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-server
          (calling-server self
            (lambda ()
              (client-alive remote-server remote-client)))))))
  
  
  (method package (send-client-audio self channel-no buffer header? timestamp duration)
    (with-mutex self
      (lambda ()
        (when udp-client
          (send-media udp-client channel-no buffer header? timestamp duration)))))
  
  
  (method package (send-client-video self channel-no buffer header? timestamp duration)
    (with-mutex self
      (lambda ()
        (when udp-client
          (send-media udp-client channel-no buffer header? timestamp duration)))))
  
  
  (method package (send-client-update self changes)
    (with-mutex self
      (lambda ()
        ;; we have to test because as we don't acquire the
        ;; task mutex a detach client is asynchronous for us
        (when remote-processor
          (calling-processor self
            (lambda ()
              (client-update remote-processor remote-client (current-seconds) changes)))))))
  
  
  (method override (connected-player self no)
    (or (table-ref players-cache no #f)
        (let ((player (calling-server self
                        (lambda ()
                          (client-connected-player remote-server remote-client no)))))
          (table-set! players-cache no player)
          player)))
  
  
  (method override (connected-players self)
    (calling-server self
      (lambda ()
        (client-connected-players remote-server remote-client))))
  
  
  (method override (available-templates self)
    (calling-server self
      (lambda ()
        (client-available-templates remote-server remote-client))))
  
  
  (method override (available-zone-base self from)
    (calling-server self
      (lambda ()
        (client-available-zone-base remote-server remote-client from))))
  
  
  (method override (available-zone-base? self base)
    (calling-server self
      (lambda ()
        (client-available-zone-base? remote-server remote-client base))))
  
  
  (method override (create-zone self from base)
    (let ((zone (calling-server self
                  (lambda ()
                    (client-create-zone remote-server remote-client from base)))))
      (when zone
        (change-zone self zone))))
  
  
  (method override (available-zones self)
    (calling-server self
      (lambda ()
        (client-available-zones remote-server remote-client))))
  
  
  (method override (change-zone self zone)
    (let ((info (calling-server self
                  (lambda ()
                    (client-change-zone remote-server remote-client zone)))))
      (bind (processor form spawnpoint player-spawnpoint player-id player-no player-position player-lookat other-players) info
        (reset-last-forward)
        (set! self.remote-processor (connect-remote-proxy processor))
        ;; open test quicky to send form as a string
        (let ((form (call-with-input-string (list init: form readtable: jazz-readtable) read-form-from)))
          (set! self.form form)
          (set! self.spawnpoint spawnpoint)
          (set! self.player-spawnpoint player-spawnpoint)
          (set! self.player-id player-id)
          (set! self.player-no player-no)
          (set! self.player-position player-position)
          (set! self.player-lookat player-lookat)
          (set! self.other-players other-players)
          (close (current-zone))
          ;; quicky
          (let ((file (zone-file directory 'client)))
            (set-origin form file)
            (open-zone file form: form))))))
  
  
  (method package (create-group self name)
    (calling-server self
      (lambda ()
        (client-create-group remote-server remote-client name))))
  
  
  (method package (delete-group self name)
    (calling-server self
      (lambda ()
        (client-delete-group remote-server remote-client name))))
  
  
  (method package (disband-group self name)
    (calling-server self
      (lambda ()
        (client-disband-group remote-server remote-client name))))
  
  
  (method package (join-group self name)
    (calling-server self
      (lambda ()
        (client-join-group remote-server remote-client name))))
  
  
  (method package (leave-group self name)
    (calling-server self
      (lambda ()
        (client-leave-group remote-server remote-client name))))
  
  
  (method package (register-channel self name media-kind source-kind resolution framerate bitrate codec recipient mirror?)
    (let ((no
            (calling-server self
              (lambda ()
                (client-register-channel remote-server remote-client character-name name media-kind source-kind resolution framerate bitrate codec recipient mirror?)))))
      (if (string? no)
          no
        (register-send-channel udp-client character-name name no media-kind source-kind resolution framerate bitrate codec))))
  
  
  (method package (unregister-channel self channel-no)
    (calling-server self
      (lambda ()
        (client-unregister-channel remote-server remote-client channel-no))))
  
  
  (method package (channel-action self channel-no action)
    (calling-server self
      (lambda ()
        (client-channel-action remote-server remote-client channel-no action))))
  
  
  (method package (list-group-members self name)
    (calling-server self
      (lambda ()
        (client-list-group-members remote-server name))))
  
  
  (method package (list-hierarchy self)
    (calling-server self
      (lambda ()
        (client-list-hierarchy remote-server))))
  
  
  (method package (retrieve-asset self path)
    (calling-server self
      (lambda ()
        (retrieve-asset remote-server path))))
  
  
  (method override (retrieve-entity self id)
    (or (find-entity id)
        (if (not sphere?)
            #f
          (let ((class-name+info (calling-processor self
                                   (lambda ()
                                     (retrieve-entity remote-processor id)))))
            (bind (class-name . info) class-name+info
              (when (effective-show-blocking?)
                (debug 'retrieve-entity id '-> class-name))
              (let ((class (class-name->class (current-world) class-name)))
                (let ((entity (unpackage class info)))
                  (when (or (eq? (get-name entity) 'NOT-FOUND)
                            (eq? (get-name entity) 'PLAYER))
                    (debug (get-name entity) entity))
                  entity)))))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method package (retrieve-region self region-index)
    (when (effective-show-blocking?)
      (debug 'retrieve-region region-index))
    (if (not sphere?)
        #f
      (calling-processor self
        (lambda ()
          (retrieve-region remote-processor region-index)))))
  
  
  (method package (retrieve-chunk self region-index chunk-index chunk-digest)
    (when (effective-show-blocking?)
      (debug 'retrieve-chunk region-index chunk-index))
    (if (not sphere?)
        #f
      (calling-processor self
        (lambda ()
          (retrieve-chunk remote-processor region-index chunk-index chunk-digest)))))
  
  
  (method package (pause-processor self)
    (calling-processor self
      (lambda ()
        (pause remote-processor))))
  
  
  (method package (unpause-processor self)
    (calling-processor self
      (lambda ()
        (unpause remote-processor))))
  
  
  (method package (client-message self kind recipient message)
    (calling-server self
      (lambda ()
        (client-message remote-server remote-client kind recipient message))))
  
  
  (method package (admin-command self command arguments)
    (calling-server self
      (lambda ()
        (admin-command remote-server remote-client command arguments))))
  
  
  (method package (admin-chunk self requester cookie sender name chunk done?)
    (calling-server self
      (lambda ()
        (admin-chunk remote-server requester cookie sender name chunk done?))))
  
  
  (method (calling-server self thunk)
    (calling-processing self thunk))
  
  
  (method (calling-processor self thunk)
    (calling-processing self thunk))
  
  
  (method (calling-processing self thunk)
    (let ((exit (current-exit)))
      (define (bailout exc)
        ;; else if the current thread is the mutex owner
        ;; and terminates the mutex will become abandoned
        (mutex-unlock! mutex)
        (if (not exit)
            (let ((restart (or (boot-restart) (event-restart))))
              (if restart
                  (continuation-graft restart
                    (lambda ()
                      (with-reentrant-task-mutex
                        (lambda ()
                          (bailout-client self exc)))))
                (snapshot-process exception: (new Error message: "No exit"))
                (quit)))
          (continuation-graft exit
            (lambda ()
              (delay-bailout-client self exc)))))
      
      (catch (connection-exception? exc
               (bailout exc))
        (let ((result (thunk)))
          (if (eq? result disconnect-marker)
              (bailout (new Error message: "Received disconnect marker"))
            result)))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (add-player self character-name character-avatar player-id player-no player-position player-lookat player-script)
    (let ((zone (current-zone)))
      (let ((player (new Player name: character-name me?: #f avatar: character-avatar position: player-position lookat: player-lookat)))
        (register-id player player-id)
        (register-no player player-no)
        (set-name-pane player character-name color: (if player-script {Color World-Yellow} {Color World-Purple}))
        (add-element zone player))))
  
  
  (method (remove-player self character-name)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; sejour quicky
        (when player
          (remove-element zone player)))))
    
  
  (method package (server-entered self client-id client-no character-name)
    (when server-entered-hook
      (server-entered-hook character-name)))
  
  
  (method package (server-exited self character-name disconnected?)
    (when server-exited-hook
      (server-exited-hook character-name disconnected?)))

  
  (method package (processor-entered self client-id client-no character-name character-avatar character-script player-id player-no player-position player-lookat player-script)
    (let ((world (current-world)))
      (add-player self character-name character-avatar player-id player-no player-position player-lookat player-script)
      (if processor-entered-hook
          (processor-entered-hook character-name)
        (display-message world (format "{a} entered world" character-name)))))
  
  
  (method package (processor-exited self character-name)
    (let ((world (current-world)))
      (remove-player self character-name)
      (if processor-exited-hook
          (processor-exited-hook character-name)
        (display-message world (format "{a} exited world" character-name)))))
  
  
  (method package (processor-update self sent changes)
    ;; should probably be applied by a task
    (forward-changes sent (current-seconds) changes))
  
  
  (method package (processor-draw self id color alpha timestamp duration background slide?)
    (receive-processor-draw (current-video) id color alpha timestamp duration background slide?))
  
  
  (method package (server-message self sender kind message)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (let ((interface (current-interface)))
              (let ((chat (child interface 'chat)))
                (show-message chat sender kind message)
                (unless (equal? sender character-name)
                  (play-ambient-sound 'message volume: .25)))))))))
  
  
  (method package (server-protocol self protocol)
    @convert-to-presence
    (let ((uuid (get-uuid (get-ior remote-server))))
      (let ((connection (require-remote-connection uuid)))
        (set-protocol connection protocol))))
  
  
  (method package (peers-update self peers)
    (peers-update udp-client peers))
  
  
  (method package (hierarchy-update self hierarchy)
    (define (find-group)
      (continuation-capture
        (lambda (return)
          (for-each (lambda (info)
                      (bind (group . members) info
                        (when group
                          (for-each (lambda (member-info)
                                      (let ((name (car member-info)))
                                        (when (equal? name character-name)
                                          (continuation-return return info))))
                                    members))))
                    hierarchy)
          (cons #f '()))))
    
    (bind (new-group . new-group-members) (find-group)
      (set! group new-group)
      (set! group-members new-group-members))
    (when hierarchy-update-hook
      (hierarchy-update-hook hierarchy)))
  
  
  (method package (add-channel self sender name channel-no origin media-kind source-kind resolution framerate bitrate codec)
    (let ((channel (register-receive-channel udp-client sender name channel-no origin media-kind source-kind resolution framerate bitrate codec)))
      (ecase media-kind
        ((udp-audio)
         (channel-output (current-audio)
                         channel)
         (let ((udp (current-udp)))
           (let ((video-channel (find-receive-video-channel udp-client origin name)))
             (when video-channel
               (let ((output (find-output (current-video) (get-no video-channel))))
                 (when output
                   (update-volume (get-root (get-interface-pane output)))))))))
        ((udp-video)
         (channel-output (current-video)
                         channel
                         player: (current-me)
                         resolution: resolution
                         framerate: framerate
                         bitrate: bitrate
                         codec: codec)))))
  
  
  (method package (remove-channel self channel-no)
    (let ((channel (find-receive-channel udp-client channel-no)))
      ;; lets be robust
      (when channel
        (close-receive-channel udp-client channel-no))))
  
  
  (method package (action-channel self channel-no action)
    (let ((channel (find-send-channel udp-client channel-no)))
      ;; lets be robust
      (when channel
        (let ((action-proc (get-action-proc channel)))
          (when action-proc
            (action-proc channel action))))))
  
  
  (method (find-group-member-by-id self id)
    (find group-members id key: second return: 'item))
  
  
  (method (find-group-member-by-no self no)
    (find group-members no key: third return: 'item))
  
  
  (method package (pause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (pause-world world)))))))
  
  
  (method package (unpause-client self)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (unpause-world world)))))))
  
  
  (method package (goto-client self time)
    (post-event
      (lambda ()
        (let ((history (current-history)))
          (with-task-mutex
            (lambda ()
              (goto-time history time)))))))
  
  
  (method package (camera-client self pos lookat)
    (post-event
      (lambda ()
        (let ((camera (current-camera)))
          (with-task-mutex
            (lambda ()
              (camera-init camera pos lookat)))))))
  
  
  (method package (protocol-client self simulate?)
    (post-event
      (lambda ()
        (let ((world (current-world)))
          (with-task-mutex
            (lambda ()
              (set-simulate-protocol? simulate?)
              (if simulate-protocol?
                  (lock-history-tooltip world)
                (unlock-history-tooltip world))))))))
  
  
  (method package (position-client self rect)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:position-client-window rect))))))
  
  
  (method package (restore-client self)
    (post-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (world.window:restore-client-window))))))
  
  
  (method package (admin-request self requester cookie what action)
    (define (send-caps)
      (let ((file {File Settings "work" "logs" "client.caps"}))
        (when (exists? file)
          (send-file 0 file))))
    
    (define (send-crashes)
      )
    
    (define (send-replay)
      (send-threaded 0
        (lambda ()
          (define (metadata)
            (define (send-channels)
              (channels-metadata (get-send-channels udp-client)))
            
            (define (receive-channels)
              (channels-metadata (get-receive-channels udp-client)))
              
            (list client-no character-name (send-channels) (receive-channels)))
          
          (let ((metadata (metadata))
                (chronology (copy-chronology (current-chronology)))
                (evolution (copy-evolution (current-evolution))))
            (object->u8vector (list metadata chronology evolution) serialize)))
        (lambda ()
          (gather-replay-missing udp-client action))))
    
    (define (send-shared)
      (send-threaded 0
        (lambda ()
          (let ((dir {Directory Settings "work" "shared"})
                (queue (new-queue)))
            (when (exists? dir)
              (iterate-directory dir
                (lambda (file)
                  (let ((name (get-name file)))
                    (unless (filename=? name ".DS_Store")
                      (enqueue queue (get-name file)))))
                files?: #t
                directories?: #f
                sort?: #t))
            (object->u8vector (queue-list queue))))))
    
    (define (send-shared-file name)
      (let ((dir {Directory Settings "work" "shared"}))
        (let ((file (new-file dir name)))
          (when (exists? file)
            (send-file name file)))))
    
    (define (send-file name file)
      (send-threaded name
        (lambda ()
          (load-binary file))))
    
    (define (send-threaded name extract (missing #f))
      (let ((thread
              (new-thread
                (lambda ()
                  (let ((sender character-name))
                    (admin-chunk self requester cookie sender name #f #f)
                    (let ((content (zlib-deflate (extract))))
                      (when missing
                        (let ((missing (missing)))
                          (for-each (lambda (missing)
                                      (admin-chunk self requester cookie sender 'missing missing #f))
                                    missing)))
                      (let ((content-size (u8vector-length content))
                            (max-size 8192)
                            (give-time .01))
                        (let (loop-chunk (part 0) (pos 0))
                          (let ((remain (- content-size pos)))
                            (when (> remain 0)
                              (sleep give-time)
                              (let ((chunk-size (min remain max-size)))
                                (let ((chunk (make-u8vector chunk-size))
                                      (done? (>= chunk-size remain)))
                                  (subu8vector-move! content pos (+ pos chunk-size) chunk 0)
                                  (admin-chunk self requester cookie sender name chunk done?))
                                (loop-chunk (+ part 1) (+ pos chunk-size))))))))))
                'request)))
        (thread-base-priority-set! thread background-priority)
        (thread-start! thread)))
    
    (define (process-settings)
      (let ((file {File Settings ".admin"}))
        (when (exists? file)
          (send-file 0 file))))
    
    (if (string? what)
        (send-shared-file what)
      (case what
        ((caps)
         (send-caps))
        ((crashes)
         (send-crashes))
        ((replay)
         (send-replay))
        ((shared)
         (send-shared))
        ((settings)
         (process-settings)))))
  
  
  (method package (admin-result self cookie sender name chunk done?)
    (let ((proc (registered-request-procedure cookie)))
      (proc sender name chunk done?)))
  
  
  ;;;
  ;;;; Mic
  ;;;
  
  
  (method package (require-mic-channel self)
    (or mic-channel
        (let ((channel (make-mic-channel "Live")))
          (setup channel)
          (set! mic-channel channel)
          channel)))
  
  
  (method package (toggle-mic self)
    (if (mic-playing? self)
        (release-mic self)
      (play-mic self)))
  
  
  (method package (play-mic self)
    (let ((world (current-world)))
      (play mic-channel)
      (invalidate-self-output self)
      (update-parameter world 'audio)
      (display-on/off world "Audio" (mic-playing? self))))
  
  
  ;; for the moment the mic needs to be released
  ;; in order for the denoiser thread to terminate
  (method package (release-mic self)
    (let ((world (current-world)))
      (release mic-channel)
      (consume (get-sink (get-pipeline mic-channel)) #f #f #f)
      (invalidate-self-output self)
      (update-parameter world 'audio)
      (display-on/off world "Audio" (mic-playing? self))))
  
  
  (method (invalidate-self-output self)
    (let ((video (current-video)))
      (let ((self-output (get-self-output video)))
        (when self-output
          (invalidate-state self-output)))))

  
  (method package (mic-playing? self)
    (and mic-channel
         (playing? mic-channel)))
  
  
  (method package (close-mic-channel self)
    (when mic-channel
      (close-send-channel udp-client (get-no mic-channel))
      (set! mic-channel #f)))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method package (require-camera-channel self)
    (or camera-channel
        (let ((channel (make-camera-channel "Live")))
          (setup channel)
          (set! camera-channel channel)
          channel)))
  
  
  (method package (toggle-camera self)
    (if (camera-playing? self)
        (stop-camera self)
      (play-camera self)))
  
  
  (method package (play-camera self)
    (let ((world (current-world)))
      (play camera-channel)
      (update-parameter world 'video)
      (display-on/off world "Video" (camera-playing? self))))
  
  
  (method package (stop-camera self)
    (let ((world (current-world)))
      (stop camera-channel)
      (let ((sink (get-sink (get-pipeline camera-channel)))
            (sinkself (get-sinkself (get-pipeline camera-channel))))
        (consume sink #f #f #f)
        (when sinkself
          (consume sinkself #f #f #f)))
      (update-parameter world 'video)
      (display-on/off world "Video" (camera-playing? self))))
  
  
  (method package (camera-playing? self)
    (and camera-channel
         (playing? camera-channel)))
  
  
  (method package (close-camera-channel self)
    (when camera-channel
      (close-send-channel udp-client (get-no camera-channel))
      (set! camera-channel #f)))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method (invalidate-audio-state self output)
    (let ((audio (current-audio))
          (video (current-video)))
      (let ((channel-no (table-find (get-outputs audio) output)))
        (when channel-no
          (let ((channel (find-receive-channel udp-client channel-no)))
            (when channel
              (let ((origin (get-origin channel))
                    (name (get-name channel)))
                (let ((video-channel (find-receive-video-channel udp-client origin name)))
                  (when video-channel
                    (let ((output (find-output video (get-no video-channel))))
                      (when output
                        (invalidate-state output))))))))))))
  
  
  ;;;
  ;;;; Tile
  ;;;
  
  
  (method override (tile self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (tile-server remote-server))))))
  
  
  (method override (restore self)
    (post-event
      (lambda ()
        (calling-server self
          (lambda ()
            (restore-server remote-server))))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (log-if self message)
    (when log?
      (calling-server self
        (lambda ()
          (client-log remote-server remote-client (current-seconds) message)))))))
