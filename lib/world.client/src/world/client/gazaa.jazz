;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Client Gazaa
;;;
;;;  The Initial Developer of the Original Code is Barbara Samson.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.client.gazaa jazz


(import (jazz.application)
        (jazz.event)
        (jazz.io)
        (jazz.math)
        (jazz.platform)
        (jazz.presence)
        (jazz.snapshot)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.audio)
        (world.chronology)
        (world.client.udp)
        (world.configure)
        (world.context)
        (world.event)
        (world.evolution)
        (world.player)
        (world.profiling)
        (world.record (phase syntax))
        (world.ring)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task)
        (world.throttle)
        (world.time)
        (world.udp)
        (world.video))


;; TODO
;; - time-factor
;; - (* total-delay .8)
;; - make constants for barbara

(definition min-silence <fx>
  (flonum->timestamp 0.5))

(definition min-drain-target <fx>
  (flonum->timestamp .05))

(definition three-seconds <fx>
  (flonum->timestamp 3.))

(definition ring-tolerance <fx>
  (flonum->timestamp .02))

(definition gazaa-duration <fl>
  .02)

(definition gazaa-mixer <fx>
  (flonum->timestamp .15))

(definition gazaa-pipeline <fx>
  (flonum->timestamp .27))

(definition gazaa-mixer-boundary <fx>
  (+ (- gazaa-pipeline gazaa-mixer) (flonum->timestamp .02)))


;;;
;;;; Gazaa Audio Base
;;;


(definition debug-gazaa-audio?
  #t)

(definition debug-gazaa-audio-state?
  #t)


(class Gazaa-Audio-Base extends UDP-Base
  
  
  (slot ring        accessors generate)
  (slot stream      getter generate)
  (slot source-kind getter generate)
  
  
  (method override (initialize self stream source-kind)
    (nextmethod self)
    (set! self.stream stream)
    (set! self.source-kind (if live-streaming? 'live source-kind)))
  
  
  (method override (effective-latency self)
    (or visualizer-latency (media-latency stream udp-audio)))
  
  
  (method override (update-time self local remote update-proc)
    (let ((new-base (- local remote)))
      (if (not base)
          (begin
            (set! base new-base)
            (set! raw-latency 0)
            (set! latency gazaa-pipeline)
            (update-latency stream udp-audio raw-latency latency))
        (let ((raw (- new-base base)))
          (set! raw-latency raw)
          (update-time-gazaa ring local raw-latency update-proc)))))
  
  
  (method override (update-past self local remote update-proc)
    (update-past-gazaa self local remote update-proc))
  
  
  (method override (remote->local self remote) <fl>
    (error "Should not be happening")))


;;;
;;;; Gazaa Audio Ring
;;;


(class Gazaa-Audio-Ring extends UDP-Audio-Ring
  
  
  ;; from base
  (slot last-arrival-time   getter generate)
  (slot average-delay       getter generate)
  (slot average-count       getter generate)
  (slot average-divergence  getter generate)
  (slot last-adjustment     getter generate)
  (slot previous-latency    getter generate)
  (slot latency-count       getter generate)
  (slot local-min           getter generate)
  (slot local-min-time      getter generate)
  
  (slot last-dts           getter generate)
  (slot last-pts           getter generate)
  (slot last-duration      getter generate)
  (slot real-audio-latency getter generate)
  (slot audio-state        accessors generate)
  (slot target-drain       accessors generate)
  (slot drained            accessors generate)
  (slot begin-clocktime    accessors generate)
  
  
  (method override (initialize self . rest)
    (apply nextmethod self rest)
    ;; from base
    (set! self.last-arrival-time #f)
    (set! self.average-delay #f)
    (set! self.average-count #f)
    (set! self.average-divergence #f)
    (set! self.last-adjustment #f)
    (set! self.previous-latency #f)
    (set! self.latency-count 0)
    (set! self.local-min #f)
    (set! self.local-min-time #f)
    
    (set! self.last-dts 0)
    (set! self.last-pts 0)
    (set! self.last-duration 0)
    (set! self.real-audio-latency 0)
    (set! self.audio-state #f)
    (set! self.target-drain 0)
    (set! self.drained 0)
    (set! self.begin-clocktime 0))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  ;; this one is for noticing when the ring count is up
  (method protected (update-count self ring-count)
    (let ((debug? debug-gazaa-audio?))
      (let ((fresh-count (cast <fl> ring-count)))
        (if (not average-count)
            (set! average-count fresh-count)
          (let ((new-average-count (/ (+ (* average-count 31.) fresh-count) 32.)))
            (set! average-count new-average-count))
          @w (when debug? (terminal 'average-count average-count)))))
    (let ((time-factor (max (- 10. (timestamp->flonum (- (current-timestamp) last-adjustment))) 0.)))
      (if (> average-count time-factor)
          #t ;;average-count
        #f)))
  
  
  ;; this one is for noticing when the real audio latency has diverged from
  ;; desired latency
  (method protected (update-divergence self desired-latency actual-latency)
    (let ((debug? debug-gazaa-audio?))
      (let ((fresh-divergence (- desired-latency actual-latency)))
        (if (not average-divergence)
            (set! average-divergence fresh-divergence)
          (let ((new-average-divergence (/ (+ (* average-divergence 15.) fresh-divergence) 16.)))
            (set! average-divergence new-average-divergence))
          @w (when debug? (terminal 'average-divergence average-divergence)))))
    (let ((time-factor (max (- 10. (timestamp->flonum (- (current-timestamp) last-adjustment))) 0.)))
      (if (> average-divergence time-factor)
          #t ;;average-divergence
        #f)))
  
  
  ;; this one is good for playing audio as soon as possible but leaves
  ;; us vulnerable to the flood of packets coming in when the wave collapses
  (method protected (update-delay self ring-elapse ring-count now play?)
    (let ((debug? debug-gazaa-audio?))
      (let ((fresh-delay (timestamp->flonum (- now last-arrival-time))))
        (if (not average-delay)
            (set! average-delay fresh-delay)
          (let ((new-average-delay (/ (+ (* average-delay 5.) fresh-delay) 6.)))
            (set! average-delay new-average-delay)))
        (cond ((<= ring-count 1)
               #f)
              (play?
               (let ((average-duration (/ ring-elapse ring-count)))
                 (if (>= average-delay average-duration)
                     (begin
                       (when debug? (terminal 'average-delay 'from 'play average-delay))
                       average-delay)
                   #f)))
              (else
               (let ((total-delay (* average-delay ring-count)))
                 (if (and (>= ring-elapse (* total-delay .8)) (<= fresh-delay average-delay))
                     (begin
                       (when debug? (terminal 'average-delay 'from 'accumulate average-delay))
                       average-delay)
                   #f)))))))
  
  
  (method protected (update-time-gazaa self now raw-latency update-proc)
    (let ((debug? debug-gazaa-audio?)
          (debug-state? debug-gazaa-audio-state?))
      (define (drain drain-target)
        (let ((target drain-target))
          (when drain-target
            (set! target (max drain-target 0)))
          (when debug-state? (terminal 'DRAIN 'target target 'count count))
          (set! audio-state 'drain)
          (set! target-drain target)))
      
      (define (get-time-base-latency)
        (get-latency time-base))
      
      (define (set-time-base-latency lat)
        (let ((new-latency (max lat gazaa-pipeline)))
          (set-latency time-base new-latency)
          (update-latency (get-stream time-base) udp-audio raw-latency new-latency)
          (when debug? (terminal 'set-latency new-latency))))
      
      (when (not last-arrival-time)
        (set! last-arrival-time now)
        (set! last-adjustment now))
      ;; need to accumulate for at least minimum time
      (case audio-state
        ((accumulate)
         (let ((accumulate-finished? (update-delay self (timestamp->flonum audio-duration) count now #f))
               (accumulate-time (- now begin-clocktime)))
           (when (and accumulate-finished? (>= accumulate-time min-silence))
             (set! last-adjustment now)
             (let ((drain-target (- audio-duration accumulate-time)))
               (when (< (abs drain-target) min-drain-target)
                 (set! drain-target 0))
               (when debug? (terminal 'accumulate-time accumulate-time))
               (when debug? (terminal 'audio-duration (timestamp->flonum audio-duration)))
               (set-time-base-latency (+ real-audio-latency (- audio-duration drain-target)))
               (when debug? (terminal 'latency (get-time-base-latency)))
               (when debug? (terminal 'count count))
               (set! accumulate-time 0)
               (drain drain-target))
             (set! average-delay #f))))
        ((init)
         (when (>= real-audio-latency gazaa-pipeline)
           (set! last-adjustment now)
           (set-time-base-latency real-audio-latency))) ;; barbara check this
        ((play)
         (let ((expected-delay? (update-delay self (timestamp->flonum audio-duration) count now #t))
               (divergence-count? (update-count self count))
               (divergence-latency? (update-divergence self (get-time-base-latency) real-audio-latency)))
           (cond ((and expected-delay? divergence-count?)
                  (set! last-adjustment now)
                  (set-time-base-latency real-audio-latency)
                  (when debug? (terminal 'ring-count-too-high 'latency (get-time-base-latency)))
                  (when debug? (terminal 'count count))
                  (drain #f)
                  (set! average-delay #f)
                  (set! average-count #f))
                 ((and divergence-latency? (= count 0))
                  (set! last-adjustment now)
                  (set-time-base-latency real-audio-latency)
                  (when debug? (terminal 'real-latency-diverged-from-desired 'latency (get-time-base-latency)))
                  (when debug? (terminal 'count count))
                  (set! average-delay #f)
                  (set! average-divergence #f))
                 ((> (- now last-adjustment) three-seconds)
                  (let ((extra-latency (- real-audio-latency gazaa-pipeline)))
                    (set! last-adjustment now)
                    (set-time-base-latency (+ average-divergence gazaa-pipeline))
                    (when debug? (terminal 'three-seconds-of-quiet 'latency (get-time-base-latency)))
                    (when debug? (terminal 'count count))
                    (set! average-delay #f)
                    (set! average-divergence #f))))))))
    (set! last-arrival-time now))
  
  
  (method protected (update-past-gazaa self now update-proc)
    ;; handle nacks
    )
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method protected (process-audio-gazaa self channel exit)
    (define debug?
      debug-gazaa-audio?)
    
    (define debug-state?
      debug-gazaa-audio-state?)
    
    (declare (proper-tail-calls))
    (mutex-lock! mutex)
    (mutex-unlock! mutex wait-condvar)
    (let (loop-wait)
      
      ;; init
      (define (init)
        (unless (simulation?)
          (when (not appsrc)
            (let ((output (world.audio:find-output (current-audio) no)))
              ;; need to do this better
              (if (not output)
                  (begin
                    (mutex-unlock! mutex wait-condvar (simulable-elapse gazaa-duration))
                    (loop-wait))
                (set! appsrc (slot-value output 'appsrc))))))
        (let ((running-time (gst_element_get_running_time appsrc)))
          (when debug? (terminal 'running-time (timestamp->flonum running-time)))
          (set! last-dts running-time)
          (set! last-pts running-time)
          (set! last-duration 0)
          @w (set! real-audio-latency 0)
          (set! audio-state 'init)
          (when debug-state? (terminal 'INIT))))
      
      ;; check state of mixer queue
      (define (check-for-accumulate)
        (if (<= real-audio-latency gazaa-mixer-boundary)
            (begin
              (when (neq? audio-state 'accumulate)
                (set! begin-clocktime (current-timestamp))
                (set! audio-state 'accumulate)
                (when debug-state? (terminal 'ACCUMULATE 'count count)))
              #t)
          #f))
      
      ;; extract and present count earliest complete frames
      (define (extract&present present-count)
        (loop (repeat present-count)
              (when (> count 0)
                (receive (sender channel-no packet data) (extract-complete self)
                  (let ((dts (max (+ last-dts last-duration) 0))
                        (pts (max (+ last-pts last-duration) 0))
                        (duration (get-duration packet)))
                    (set! last-dts dts)
                    (set! last-pts pts)
                    (set! last-duration duration)
                    (simulable-present packet dts duration)
                    (give-audio channel sender channel-no packet data dts pts duration))))))
      
      ;; extract and drain count earliest complete frames
      (define (extract&drain drain-count)
        (loop (repeat drain-count)
              (when (> count 0)
                ;; quicky
                (let ((earliest <UDP-Packet> (vector-ref packets head)))
                  (simulable-flush earliest))
                (flush-earliest self))))
      
      (if terminate?
          (continuation-return exit #f)
        (mutex-lock! mutex)
        (when (not audio-state)
          (init))
        (let ((running-time (gst_element_get_running_time appsrc)))
          @w (set! real-audio-latency (- (+ last-dts last-duration) running-time))
          (set! real-audio-latency (- last-dts running-time))
          (if (= count 0)
              (begin
                (when (neq? audio-state 'init)
                  (check-for-accumulate))
                (mutex-unlock! mutex wait-condvar (simulable-elapse .05))
                (loop-wait))
            (let ((earliest <UDP-Packet> (vector-ref packets head)))
              (cond ;; frame
                    ((complete-frame? self)
                     (case audio-state
                       ((init)
                        (extract&present count)
                        (set! audio-state 'play)
                        (when debug-state? (terminal 'PLAY))
                        (mutex-unlock! mutex wait-condvar (simulable-elapse gazaa-duration))
                        (loop-wait))
                       ((play)
                        (let ((desired-latency (get-latency time-base))
                              (packet-duration (get-duration earliest)))
                          (cond ;; pull from ring
                                ((and (> real-audio-latency (- desired-latency ring-tolerance))
                                      (< real-audio-latency (+ desired-latency ring-tolerance)))
                                 (when debug? (terminal-string "."))
                                 (extract&present 1))
                                ((and (<= real-audio-latency gazaa-mixer-boundary) (> count 1))
                                 (when debug? (terminal-string "..."))
                                 (extract&present count))
                                ((<= real-audio-latency gazaa-mixer-boundary)
                                 (set! audio-state 'accumulate)
                                 (set! begin-clocktime (current-timestamp))
                                 (when debug-state? (terminal 'ACCUMULATE 'from 'play 'count count)))
                                ((< real-audio-latency desired-latency)
                                 (if (> count 1)
                                     (begin
                                       (when debug? (terminal-string ".."))
                                       (extract&present 2))
                                   (when debug? (terminal-string "."))
                                   (extract&present 1))))
                        (mutex-unlock! mutex)
                        (sleep (simulable-elapse (timestamp->flonum packet-duration)))
                        (loop-wait)))
                       ((drain)
                        (terminal 111111)
                        (set! begin-clocktime 0)
                        (extract&present count)
                        (set! audio-state 'play)
                        (mutex-unlock! mutex wait-condvar (simulable-elapse .001))
                        (loop-wait))
                       ;; not off and incomplete frame???
                       (else
                        (when debug? (terminal-string "?"))
                        (mutex-unlock! mutex wait-condvar (simulable-elapse 0.1))
                        (loop-wait)))))))))))
  
  
  @w (method protected (process-audio-gazaa self channel exit)
    (define debug?
      debug-gazaa-audio?)
    
    (define debug-state?
      debug-gazaa-audio-state?)
    
    (declare (proper-tail-calls))
    (mutex-lock! mutex)
    (mutex-unlock! mutex wait-condvar)
    (let (loop-wait)
      
      ;; init
      (define (init)
        (unless (simulation?)
          (when (not appsrc)
            (let ((output (world.audio:find-output (current-audio) no)))
              ;; need to do this better
              (if (not output)
                  (begin
                    (mutex-unlock! mutex wait-condvar (simulable-elapse gazaa-duration))
                    (loop-wait))
                (set! appsrc (slot-value output 'appsrc))))))
        (let ((running-time (gst_element_get_running_time appsrc)))
          (when debug? (terminal 'running-time (timestamp->flonum running-time)))
          (set! last-dts running-time)
          (set! last-pts running-time)
          (set! last-duration 0)
          @w (set! real-audio-latency 0)
          (set! audio-state 'init)
          (when debug-state? (terminal 'INIT))))
      
      ;; check state of mixer queue
      (define (check-for-accumulate)
        (if (<= real-audio-latency gazaa-mixer-boundary)
            (begin
              (when (neq? audio-state 'accumulate)
                (set! begin-clocktime (current-timestamp))
                (set! audio-state 'accumulate)
                (when debug-state? (terminal 'ACCUMULATE 'count count)))
              #t)
          #f))
      
      ;; extract and present count earliest complete frames
      (define (extract&present present-count)
        (loop (repeat present-count)
              (when (> count 0)
                (receive (sender channel-no packet data) (extract-complete self)
                  (let ((dts (max (+ last-dts last-duration) 0))
                        (pts (max (+ last-pts last-duration) 0))
                        (duration (get-duration packet)))
                    (set! last-dts dts)
                    (set! last-pts pts)
                    (set! last-duration duration)
                    ;; quicky
                    (simulable-present packet dts duration)
                    (give-audio channel sender channel-no packet data dts pts duration))))))
      
      ;; extract and drain count earliest complete frames
      (define (extract&drain drain-count)
        (loop (repeat drain-count)
              (when (> count 0)
                ;; quicky
                (let ((earliest <UDP-Packet> (vector-ref packets head)))
                  (simulable-flush earliest))
                (flush-earliest self))))
      
      (if terminate?
          (continuation-return exit #f)
        (mutex-lock! mutex)
        (when (not audio-state)
          (init))
        (let ((running-time (gst_element_get_running_time appsrc)))
          @w (set! real-audio-latency (- (+ last-dts last-duration) running-time))
          (set! real-audio-latency (- last-dts running-time))
          (if (= count 0)
              (begin
                (when (neq? audio-state 'init)
                  (check-for-accumulate))
                (mutex-unlock! mutex wait-condvar (simulable-elapse .05))
                (loop-wait))
            (let ((earliest <UDP-Packet> (vector-ref packets head)))
              (cond ;; frame
                    ((complete-frame? self)
                     (let ((duration (get-duration earliest)))
                       (case audio-state
                         ((init)
                          (if (> real-audio-latency gazaa-mixer-boundary)
                              (begin
                                (set! audio-state 'play)
                                (when debug-state? (terminal 'PLAY)))
                            (extract&present count)
                            (when debug? (terminal-string ".")))
                          (mutex-unlock! mutex wait-condvar (simulable-elapse (timestamp->flonum duration)))
                          (loop-wait))
                         ((drain)                                    
                          (set! begin-clocktime 0)
                          (cond ((not target-drain)
                                 (extract&drain count)
                                 (when debug-state? (terminal 'PLAY 'from 'drain-all))
                                 (set! audio-state 'play)
                                 (set! target-drain 0))
                                ((>= drained target-drain)
                                 (when (< real-audio-latency gazaa-mixer-boundary)
                                   (when debug? (terminal 'ts 'to 'running-time 'duration (timestamp->flonum audio-duration) 'drained (timestamp->flonum drained)))
                                   (set! last-dts running-time)
                                   (set! last-pts running-time)
                                   (set! last-duration 0))
                                 (set! audio-state 'play)
                                 (when debug-state? (terminal 'PLAY))
                                 (set! drained 0)
                                 (set! target-drain 0)
                                 (when (> count 0)
                                   (extract&present count)))
                                (else
                                 ;; quicky
                                 (let ((earliest <UDP-Packet> (vector-ref packets head)))
                                   (simulable-flush earliest))
                                 (flush-earliest self)
                                 (increase! drained duration)))
                          (mutex-unlock! mutex wait-condvar (simulable-elapse .001))
                          (loop-wait))
                         ((accumulate)
                          (when debug? (terminal-string "*"))
                          (mutex-unlock! mutex wait-condvar (simulable-elapse .05))
                          (loop-wait))
                         ((play)
                          (let ((desired-latency (get-latency time-base)))
                            @w (when debug? (terminal 'rl real-audio-latency 'dl desired-latency))
                            (cond ;; pull from ring
                                  ((and (> real-audio-latency (- desired-latency ring-tolerance))
                                        (< real-audio-latency (+ desired-latency ring-tolerance)))
                                   (when debug? (terminal-string "."))
                                   (extract&present 1))
                                  ((and (<= real-audio-latency gazaa-mixer-boundary) (> count 1))
                                   (when debug? (terminal-string "..."))
                                   (extract&present count))
                                  ((<= real-audio-latency gazaa-mixer-boundary)
                                   (set! audio-state 'accumulate)
                                   (set! begin-clocktime (current-timestamp))
                                   (when debug-state? (terminal 'ACCUMULATE 'from 'play 'count count)))
                                  ((< real-audio-latency desired-latency)
                                   (if (> count 1)
                                       (begin
                                         (when debug? (terminal-string ".."))
                                         (extract&present 2))
                                     (when debug? (terminal-string "."))
                                     (extract&present 1)))))
                          (mutex-unlock! mutex)
                          (sleep (simulable-elapse (timestamp->flonum duration)))
                          (loop-wait)))))
                    ;; not off and incomplete frame???
                    (else
                     (when debug? (terminal-string "?"))
                     (mutex-unlock! mutex wait-condvar (simulable-elapse 0.1))
                     (loop-wait)))))))))))
