;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Live
;;;


(module world.client.live jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl)
        (jazz.graphic.opengl.platform)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world.autoload)
        (world.client)
        (world.geometry)
        (world.object)
        (world.texture)
        (world.window))


;;;
;;;; Parameters
;;;


(definition in-history?
  (make-parameter #f))


;;;
;;;; Sprite
;;;


(class Sprite extends World-Object
  
  
  (slot origin    <object> getter generate)
  (slot width     <fl>     getter generate)
  (slot height    <fl>     getter generate)
  (slot depth     <fl>     getter generate)
  (slot right     <fl>     getter generate)
  (slot top       <fl>     getter generate)
  (slot near      <fl>     getter generate)
  (slot radius-x  <fl>     getter generate)
  (slot radius-y  <fl>     getter generate)
  (slot radius-z  <fl>     getter generate)
  (slot center-x  <fl>     getter generate)
  (slot center-y  <fl>     getter generate)
  (slot center-z  <fl>     getter generate)
  (slot red       <fl>     accessors generate)
  (slot green     <fl>     accessors generate)
  (slot blue      <fl>     accessors generate)
  (slot alpha     <fl>     accessors generate)
  (slot texture   <object> accessors generate)
  (slot user-data <object> accessors generate)
  
  
  (method override (initialize world x y z width height depth texture (color: color #f) (user-data: user-data #f))
    (nextmethod world x y z)
    (set! origin~self self)
    (set! width~self width)
    (set! height~self height)
    (set! depth~self depth)
    (set! radius-x (/ width 2))
    (set! radius-y (/ height 2))
    (set! radius-z (/ depth 2))
    (when color
      (set-color color))
    (set! texture~self texture)
    (set! user-data~self user-data)
    (update-position))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{r precision: 1} {r precision: 1} {r precision: 1} {a} {a} {a}" x y z width height depth))))
  
  
  (method public inline (get-left) <fl>
    x)
  
  
  (method public inline (get-bottom) <fl>
    y)
  
  
  (method public inline (get-far) <fl>
    z)
  
  
  (method public (get-center) <f32vector>
    (vertex
      (get-center-x)
      (get-center-y)
      (get-center-z)))
  
  
  (method public (set-position v <f32vector>) <void>
    (set! x (vertex-x v))
    (set! y (vertex-y v))
    (set! z (vertex-z v))
    (update-position))
  
  
  (method (update-position)
    (set! right (+ x width))
    (set! top (+ y height))
    (set! near (+ z depth))
    (set! center-x (/ (+ (get-left) (get-right)) 2))
    (set! center-y (/ (+ (get-bottom) (get-top)) 2))
    (set! center-z (/ (+ (get-far) (get-near)) 2)))
  
  
  (method public (set-color color)
    (set! red~self (get-red~ color))
    (set! green~self (get-green~ color))
    (set! blue~self (get-blue~ color))
    (set! alpha~self (get-alpha~ color)))
  
  
  (method protected virtual (serialize-sprite)
    )
  
  
  (method override (draw)
    (if (get-3d?~ world)
        (if (get-textures?~ world)
            (draw-3d-textured)
          (draw-3d))
      (if (get-textures?~ world)
          (draw-2d-textured)
        (draw-2d))))
  
  
  (method protected virtual (draw-3d)
    (glColor4f red green blue alpha)
    (let ((x1 (get-left))
          (x2 (get-right))
          (y1 (get-bottom))
          (y2 (get-top))
          (z1 (get-far))
          (z2 (get-near)))
      ;; top
      (glNormal3f 0.0 1.0 0.0)
      (glBegin GL_QUADS)
      (glVertex3f x2 y2 z1)
      (glVertex3f x1 y2 z1)
      (glVertex3f x1 y2 z2)
      (glVertex3f x2 y2 z2)
      (glEnd)
      ;; bottom
      (glNormal3f 0.0 -1.0 0.0)
      (glBegin GL_QUADS)
      (glVertex3f x2 y1 z2)
      (glVertex3f x1 y1 z2)
      (glVertex3f x1 y1 z1)
      (glVertex3f x2 y1 z1)
      (glEnd)
      ;; front
      (glNormal3f 0.0 0.0 1.0)
      (glBegin GL_QUADS)
      (glVertex3f x1 y1 z2)
      (glVertex3f x2 y1 z2)
      (glVertex3f x2 y2 z2)
      (glVertex3f x1 y2 z2)
      (glEnd)
      ;; back
      (glNormal3f 0.0 0.0 -1.0)
      (glBegin GL_QUADS)
      (glVertex3f x2 y1 z1)
      (glVertex3f x1 y1 z1)
      (glVertex3f x1 y2 z1)
      (glVertex3f x2 y2 z1)
      (glEnd)
      ;; left
      (glNormal3f -1.0 0.0 0.0)
      (glBegin GL_QUADS)
      (glVertex3f x1 y2 z2)
      (glVertex3f x1 y2 z1)
      (glVertex3f x1 y1 z1)
      (glVertex3f x1 y1 z2)
      (glEnd)
      ;; right
      (glNormal3f 1.0 0.0 0.0)
      (glBegin GL_QUADS)
      (glVertex3f x2 y2 z1)
      (glVertex3f x2 y2 z2)
      (glVertex3f x2 y1 z2)
      (glVertex3f x2 y1 z1)
      (glEnd))
    (when (get-block-stiches?~ world)
      (gl-colorize {Color red: ".459" green: ".280" blue: ".002"})
      (let ((x1 (get-left))
            (x2 (get-right))
            (y1 (get-bottom))
            (y2 (get-top))
            (z1 (get-far))
            (z2 (get-near)))
        ;; top
        (glNormal3f 0.0 1.0 0.0)
        (glBegin GL_LINE_LOOP)
        (glVertex3f x2 y2 z1)
        (glVertex3f x1 y2 z1)
        (glVertex3f x1 y2 z2)
        (glVertex3f x2 y2 z2)
        (glEnd)
        ;; bottom
        (glNormal3f 0.0 -1.0 0.0)
        (glBegin GL_LINE_LOOP)
        (glVertex3f x2 y1 z2)
        (glVertex3f x1 y1 z2)
        (glVertex3f x1 y1 z1)
        (glVertex3f x2 y1 z1)
        (glEnd)
        ;; front
        (glNormal3f 0.0 0.0 1.0)
        (glBegin GL_LINE_LOOP)
        (glVertex3f x1 y1 z2)
        (glVertex3f x2 y1 z2)
        (glVertex3f x2 y2 z2)
        (glVertex3f x1 y2 z2)
        (glEnd)
        ;; back
        (glNormal3f 0.0 0.0 -1.0)
        (glBegin GL_LINE_LOOP)
        (glVertex3f x2 y1 z1)
        (glVertex3f x1 y1 z1)
        (glVertex3f x1 y2 z1)
        (glVertex3f x2 y2 z1)
        (glEnd)
        ;; left
        (glNormal3f -1.0 0.0 0.0)
        (glBegin GL_LINE_LOOP)
        (glVertex3f x1 y2 z2)
        (glVertex3f x1 y2 z1)
        (glVertex3f x1 y1 z1)
        (glVertex3f x1 y1 z2)
        (glEnd)
        ;; right
        (glNormal3f 1.0 0.0 0.0)
        (glBegin GL_LINE_LOOP)
        (glVertex3f x2 y2 z1)
        (glVertex3f x2 y2 z2)
        (glVertex3f x2 y1 z2)
        (glVertex3f x2 y1 z1)
        (glEnd))))
  
  
  (method (draw-3d-textured)
    (glPushMatrix)
    (glTranslatef x y z)
    (glRotatef rtri 1.0 1.0 1.0)
    (glScalef 1.0 1.0 1.0)
    (let ((f -2.5)
          (t 2.5))
      ;; top
      (glNormal3f 0.0 1.0 0.0)
      (textured-quad~ texture
        (lambda () (glVertex3f t t f))
        (lambda () (glVertex3f f t f))
        (lambda () (glVertex3f f t t))
        (lambda () (glVertex3f t t t)))
      ;; bottom
      (glNormal3f 0.0 -1.0 0.0)
      (textured-quad~ texture
        (lambda () (glVertex3f t f t))
        (lambda () (glVertex3f f f t))
        (lambda () (glVertex3f f f f))
        (lambda () (glVertex3f t f f)))
      ;; front
      (glNormal3f 0.0 0.0 1.0)
      (textured-quad~ texture
        (lambda () (glVertex3f f f t))
        (lambda () (glVertex3f t f t))
        (lambda () (glVertex3f t t t))
        (lambda () (glVertex3f f t t)))
      ;; back
      (glNormal3f 0.0 0.0 -1.0)
      (textured-quad~ texture
        (lambda () (glVertex3f t f f))
        (lambda () (glVertex3f f f f))
        (lambda () (glVertex3f f t f))
        (lambda () (glVertex3f t t f)))
      ;; left
      (glNormal3f -1.0 0.0 0.0)
      (textured-quad~ texture
        (lambda () (glVertex3f f t t))
        (lambda () (glVertex3f f t f))
        (lambda () (glVertex3f f f f))
        (lambda () (glVertex3f f f t)))
      ;; right
      (glNormal3f 1.0 0.0 0.0)
      (textured-quad~ texture
        (lambda () (glVertex3f t t f))
        (lambda () (glVertex3f t t t))
        (lambda () (glVertex3f t f t))
        (lambda () (glVertex3f t f f))))
    (glPopMatrix))
  
  
  (method (draw-2d)
    (let ((x1 (get-left))
          (y1 (get-top))
          (x2 (get-right))
          (y2 (get-bottom)))
      (glNormal3f 0.0 0.0 1.0)
      (if (in-history?)
          (glColor4f red green blue 0.5)
        (glColor4f red green blue alpha))
      (unless (in-history?)
        (glBegin GL_QUADS)
        (glVertex2f x1 y1)
        (glVertex2f x2 y1)
        (glVertex2f x2 y2)
        (glVertex2f x1 y2)
        (glEnd))
      (glColor3f .41176 .23921 .00392)
      (glBegin GL_LINE_LOOP)
      (glVertex2f x1 y1)
      (glVertex2f x2 y1)
      (glVertex2f x2 y2)
      (glVertex2f x1 y2)
      (glEnd)))
  
  
  (method (draw-2d-textured)
    (glPushMatrix)
    (glTranslatef x y z)
    (textured-quad~ texture
      (lambda () (glVertex3f 0.0 0.0 0.0))
      (lambda () (glVertex3f width 0.0 0.0))
      (lambda () (glVertex3f width height 0.0))
      (lambda () (glVertex3f 0.0 height 0.0)))
    (glPopMatrix))
  
  
  @w
  (method (draw-2d-textured)
    (glPushMatrix)
    (glTranslatef x y z)
    (textured-quad~ texture
      (lambda () (glVertex3f 0.0 0.0 0.0))
      (lambda () (glVertex3f 5.0 0.0 0.0))
      (lambda () (glVertex3f 5.0 5.0 0.0))
      (lambda () (glVertex3f 0.0 5.0 0.0)))
    (glPopMatrix)))


;;;
;;;; Block
;;;


(class Block extends Sprite
  
  
  (method override (serialize-sprite)
    (list 'block x y z)))


(class Block-Red extends Block
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set-color {Color Red}))
  
  
  (method override (serialize-sprite)
    (list 'block-red x y z)))


(class Block-Green extends Block
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set-color {Color Green}))
  
  
  (method override (serialize-sprite)
    (list 'block-green x y z)))


(class Block-Blue extends Block
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set-color {Color Blue}))
  
  
  (method override (serialize-sprite)
    (list 'block-blue x y z)))


;;;
;;;; Actor
;;;


(definition gravity
  .09)


(class Actor extends Sprite
  
  
  (slot lookat <LookAt+> initialize #f accessors generate)
  
  
  (method override (draw-3d)
    (glPushMatrix)
    (glTranslatef center-x center-y center-z)
    (when lookat
      (let ((sight (get-sight~ lookat))
            (up (get-up~ lookat))
            (right (get-right~ lookat)))
        (glMultMatrixv
          (vertex-x right) (vertex-x up) (vertex-x sight) 0.
          (vertex-y right) (vertex-y up) (vertex-y sight) 0.
          (vertex-z right) (vertex-z up) (vertex-z sight) 0.
          0. 0. 0. 1.)))
    (glColor4f red green blue alpha)
    (let ((x1 (- radius-x))
          (x2 radius-x)
          (y1 (- radius-y))
          (y2 radius-y)
          (z1 (- radius-z))
          (z2 radius-z))
      ;; top
      (glNormal3f 0.0 1.0 0.0)
      (glBegin GL_QUADS)
      (glVertex3f x2 y2 z1)
      (glVertex3f x1 y2 z1)
      (glVertex3f x1 y2 z2)
      (glVertex3f x2 y2 z2)
      (glEnd)
      ;; bottom
      (glNormal3f 0.0 -1.0 0.0)
      (glBegin GL_QUADS)
      (glVertex3f x2 y1 z2)
      (glVertex3f x1 y1 z2)
      (glVertex3f x1 y1 z1)
      (glVertex3f x2 y1 z1)
      (glEnd)
      ;; front
      (glNormal3f 0.0 0.0 1.0)
      (glBegin GL_QUADS)
      (glVertex3f x1 y1 z2)
      (glVertex3f x2 y1 z2)
      (glVertex3f x2 y2 z2)
      (glVertex3f x1 y2 z2)
      (glEnd)
      ;; back
      (glNormal3f 0.0 0.0 -1.0)
      (glBegin GL_QUADS)
      (glVertex3f x2 y1 z1)
      (glVertex3f x1 y1 z1)
      (glVertex3f x1 y2 z1)
      (glVertex3f x2 y2 z1)
      (glEnd)
      ;; left
      (glNormal3f -1.0 0.0 0.0)
      (glBegin GL_QUADS)
      (glVertex3f x1 y2 z2)
      (glVertex3f x1 y2 z1)
      (glVertex3f x1 y1 z1)
      (glVertex3f x1 y1 z2)
      (glEnd)
      ;; right
      (glNormal3f 1.0 0.0 0.0)
      (glBegin GL_QUADS)
      (glVertex3f x2 y2 z1)
      (glVertex3f x2 y2 z2)
      (glVertex3f x2 y1 z2)
      (glVertex3f x2 y1 z1)
      (glEnd))
    (glPopMatrix)))


;;;
;;;; Enemy
;;;


(class Enemy extends Actor)


;;;
;;;; Turtle
;;;


(definition turtle-speed
  .1)


(class Turtle extends Enemy
  
  
  (slot vx         <fl> initialize 0. accessors generate)
  (slot vy         <fl> initialize 0. accessors generate)
  (slot stomp-time <fl> initialize 0. accessors generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! vx turtle-speed))
  
  
  (method override (tick commands elapse)
    (continuation-capture
      (lambda (exit)
        (define (player-hit obj)
          (when (eq? obj (get-player~ world))
            (lose~ world)
            (continuation-return exit)))
        
        (define (reverse-speed)
          (if (< vx 0)
              (set! vx .1)
            (set! vx -.1)))
        
        (if stomp-time
            (when (>= (time->seconds (current-time)) stomp-time)
              (set! stomp-time #f))
          (let ((old-x x)
                (old-y y)
                (old-z z)
                (old-center (get-center))
                (factor (* elapse 65)))
            (increase! x (* vx factor))
            (increase! y (* vy factor))
            (when (< y 0.)
              (set! y 0.))
            (decrease! vy gravity)
            (when (< vy -1.0)
              (set! vy -1.))
            (receive (hit-x hit-y hit-z) (hit-test~ world self old-x old-y old-z x y z width height depth)
              (when hit-x
                (bind (obj direction border reset) hit-x
                  (player-hit obj)
                  (set! x reset)
                  (reverse-speed)))
              (when hit-y
                (bind (obj direction border reset) hit-y
                  (player-hit obj)
                  (set! y reset)))
              (when hit-z
                (bind (obj direction border reset) hit-z
                  (player-hit obj)
                  (set! z reset)
                  (reverse-speed))))
            @w
            (when (or (< x -35.)
                      (> x -27.))
              (reverse-speed))
            (update-position)
            (update-area~ world self old-center))))))
  
  
  (method (stomp)
    (set! stomp-time (+ (time->seconds (current-time)) 3.)))
  
  
  (method override (serialize-sprite)
    (list 'turtle x y z)))


;;;
;;;; Player
;;;


(definition player-speed
  .5)

(definition jump-impulsion
  2.0)

(definition floor-deceleration
  .25)

(definition air-deceleration
  .05)

(definition max-vy
  -.8)

(definition die-bottom
  -6.)


(class Player extends Actor
  
  
  (slot vx       <fl>      initialize 0.    accessors generate)
  (slot vy       <fl>      initialize 0.    accessors generate)
  (slot vz       <fl>      initialize 0.    accessors generate)
  (slot ready?   <bool>    initialize #f    accessors generate)
  (slot jumping? <bool>    initialize #f    accessors generate)
  (slot floor?   <bool>    initialize #f    accessors generate)
  (slot facing   <symbol>  initialize 'left accessors generate)
  (slot state    <symbol+> initialize #f    accessors generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! lookat (new LookAt (vertex 0. 0. -1.) (vertex 0. 1. 0.) (vertex 1. 0. 0.))))
  
  
  (method override (tick commands elapse)
    (continuation-capture
      (lambda (exit)
        (define (win-hit obj)
          (when (eq? (get-user-data~ obj) 'win)
            (win~ world)
            (continuation-return exit)))
        
        (let ((old-x x)
              (old-y y)
              (old-z z)
              (old-center (get-center))
              (moving? #f)
              (target-vx #f)
              (target-vz #f)
              (factor (* elapse 65)))
          (when (get-move-left?~ commands)
            (set! moving? #t)
            (set! target-vx (- player-speed)))
          (when (get-move-right?~ commands)
            (set! moving? #t)
            (set! target-vx player-speed))
          (when (get-move-down?~ commands)
            (if (get-first-person?~ world)
                (move-player-backward~ world factor)
              (set! moving? #t)
              (set! target-vz player-speed)))
          (when (get-move-up?~ commands)
            (if (get-first-person?~ world)
                (move-player-forward~ world factor)
              (set! moving? #t)
              (set! target-vz (- player-speed))))
          (when (get-strafe-left?~ commands)
            (when (get-first-person?~ world)
              (strafe-player-left~ world factor)))
          (when (get-strafe-right?~ commands)
            (when (get-first-person?~ world)
              (strafe-player-right~ world factor)))
          (when (get-rotate-left?~ commands)
            (when (get-first-person?~ world)
              (rotate-player-left~ world factor)))
          (when (get-rotate-right?~ commands)
            (when (get-first-person?~ world)
              (rotate-player-right~ world factor)))
          (when (and (get-fly?~ world)
                     (not (get-rotate-left?~ commands))
                     (not (get-rotate-right?~ commands)))
            (reset-player-tilt~ world))
          (when (not moving?)
            (set! target-vx 0.)
            (set! target-vz 0.))
          (when target-vx
            (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
              (cond ((> vx target-vx)
                     (decrease! vx deceleration)
                     (if (< vx target-vx)
                         (set! vx target-vx)))
                    ((< vx target-vx)
                     (increase! vx deceleration)
                     (if (> vx target-vx)
                         (set! vx target-vx))))))
          (when target-vz
            (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
              (cond ((> vz target-vz)
                     (decrease! vz deceleration)
                     (if (< vz target-vz)
                         (set! vz target-vz)))
                    ((< vz target-vz)
                     (increase! vz deceleration)
                     (if (> vz target-vz)
                         (set! vz target-vz))))))
          (if (not (get-jump?~ commands))
              (set! ready? #t)
            (when (and floor? ready? (not jumping?))
              (set! ready? #f)
              (set! jumping? #t)
              (set! vy jump-impulsion)))
          
          (increase! x (* vx factor))
          (increase! z (* vz factor))
          (unless (get-fly?~ world)
            (decrease! vy gravity)
            (increase! y vy))
          (when (< vy max-vy)
            (set! vy max-vy))
          (receive (hit-x hit-y hit-z) (hit-test~ world self old-x old-y old-z x y z width height depth)
            (when hit-x
              (bind (obj direction border reset) hit-x
                (win-hit obj)
                (set! x reset)))
            (if (not hit-y)
                (set! floor? #f)
              (bind (obj direction border reset) hit-y
                (win-hit obj)
                (set! y reset)
                (set! vy 0.)
                (when (= direction -1)
                  (set! jumping? #f)
                  (set! floor? #t)
                  (when (is? obj Turtle)
                    (set! vy 3.)
                    (stomp~ obj)))))
            (when hit-z
              (bind (obj direction border reset) hit-z
                (win-hit obj)
                (set! z reset))))
          (when (and (< y 0.) (not (get-fly?~ world)))
            (set! y 0.)
            (set! vy 0.)
            (set! jumping? #f)
            (set! floor? #t))
          @w
          (when (< y die-bottom)
            (lose~ world)
            (continuation-return exit))
          (update-position)
          (update-area~ world self old-center)
          (when (or (/= x old-x)
                    (/= y old-y)
                    (/= z old-z))
            (center-camera~ world))))))
  
  
  (method (move-left commands)
    (set-move-left?~ commands #t))
  
  
  (method (move-right commands)
    (set-move-right?~ commands #t))
  
  
  (method (move-down commands)
    (set-move-down?~ commands #t))
  
  
  (method (move-up commands)
    (set-move-up?~ commands #t))
  
  
  (method (strafe-left commands)
    (set-strafe-left?~ commands #t))
  
  
  (method (strafe-right commands)
    (set-strafe-right?~ commands #t))
  
  
  (method (rotate-left commands)
    (set-rotate-left?~ commands #t))
  
  
  (method (rotate-right commands)
    (set-rotate-right?~ commands #t))
  
  
  (method (space commands)
    (jump commands))
  
  
  (method (jump commands)
    (set-jump?~ commands #t))
  
  
  (method (win)
    (set! jumping? #f)
    (set! state 'win)
    (update-position))
  
  
  (method (lose)
    (set! jumping? #f)
    (set! state 'lose)
    (update-position))
  
  
  (method (reset-state)
    (set! state #f))
  
  
  (method (reset-position)
    (set! x (get-start-x~ world))
    (set! y (get-start-y~ world))
    (set! z (get-start-z~ world))
    (update-position))
  
  
  (method override (serialize-sprite)
    (list 'player x y z))
  
  
  (method override (draw-3d)
    (nextmethod)
    (when (get-fly?~ world)
      (glPushMatrix)
      (glTranslatef center-x center-y center-z)
      (let ((sight (get-sight~ lookat))
            (up (get-up~ lookat))
            (right (get-right~ lookat)))
        (glMultMatrixv
          (vertex-x right) (vertex-x up) (vertex-x sight) 0.
          (vertex-y right) (vertex-y up) (vertex-y sight) 0.
          (vertex-z right) (vertex-z up) (vertex-z sight) 0.
          0. 0. 0. 1.))
      (glColor4f .4 0. 0. 1.)
      (let ((width 16.)
            (depth 8.))
        (let ((x1 (- depth))
              (x2 depth)
              (y (- radius-y))
              (z1 (- width))
              (z2 width))
          ;; flying carpet
          (glNormal3f 0.0 -1.0 0.0)
          (glBegin GL_QUADS)
          (glVertex3f x2 y z2)
          (glVertex3f x1 y z2)
          (glVertex3f x1 y z1)
          (glVertex3f x2 y z1)
          (glEnd)))
      (glPopMatrix))))


;;;
;;;; Pacman
;;;


(class Pacman extends Player
  
  
  (method override (serialize-sprite)
    (list 'pacman x y z)))


;;;
;;;; Commands
;;;


(class Commands extends Object
  
  
  (slot move-left?    <bool> initialize #f accessors generate)
  (slot move-right?   <bool> initialize #f accessors generate)
  (slot move-down?    <bool> initialize #f accessors generate)
  (slot move-up?      <bool> initialize #f accessors generate)
  (slot strafe-left?  <bool> initialize #f accessors generate)
  (slot strafe-right? <bool> initialize #f accessors generate)
  (slot rotate-left?  <bool> initialize #f accessors generate)
  (slot rotate-right? <bool> initialize #f accessors generate)
  (slot jump?         <bool> initialize #f accessors generate)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{l}"
          `(,@(if move-left? '(move-left) '())
            ,@(if move-right? '(move-right) '())
            ,@(if move-down? '(move-down) '())
            ,@(if move-up? '(move-up) '())
            ,@(if strafe-left? '(strafe-left) '())
            ,@(if strafe-right? '(strafe-right) '())
            ,@(if rotate-left? '(rotate-left) '())
            ,@(if rotate-right? '(rotate-right) '())
            ,@(if jump? '(jump) '())))))))


;;;
;;;; Folio
;;;


(class Folio extends Object
  
  
  (slot class initialize #f  accessors generate)
  (slot list  initialize '() accessors generate)
  
  
  (method override (initialize class list)
    (nextmethod)
    (set! class~self class)
    (set! list~self list))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" class list)))))


;;;
;;;; Moment
;;;


(class Moment extends Object
  
  
  (slot snapshot <object> initialize #f accessors generate)
  (slot commands <object> initialize #f accessors generate)
  (slot elapse   <object> initialize #f accessors generate)
  
  
  (method override (initialize snapshot commands elapse)
    (nextmethod)
    (set! snapshot~self snapshot)
    (set! commands~self commands)
    (set! elapse~self elapse)))


;;;
;;;; Area
;;;


(class Area extends Object
  
  
  (slot actors <list> initialize '() accessors generate)
  (slot blocks <list> initialize '() accessors generate)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((actors (length actors))
              (blocks (length blocks)))
          (format output
                  "{a}{a}"
                  (if (= actors 0) "" (format "{a} actor{a}" actors (format-plural actors)))
                  (if (= blocks 0) "" (format "{a}{a} block{a}" (if (= actors 0) "" ", ") blocks (format-plural blocks)))))))))


;;;
;;;; World
;;;


(class Live-World extends World
  
  
  (property block-stiches? <bool>   initialize #f            accessors generate)
  
  
  (slot areas              <object> initialize #f            getter generate)
  (slot area-size          <fx>     initialize #f            getter generate)
  (slot actors             <list>   initialize '()           getter generate)
  (slot blocks             <list>   initialize '()           getter generate)
  (slot sprites            <list>   initialize '()           getter generate)
  (slot player             <object> initialize #f            getter generate)
  (slot projection         <symbol> initialize 'orthographic getter generate)
  (slot zoom-factor        <fl>                              getter generate)
  (slot desired-tilt       <fl>     initialize 0.            getter generate)
  (slot tilt-speed         <fl>     initialize 0.            getter generate)
  (slot last-tilt-time     <fl+>    initialize #f            getter generate)
  (slot 3d?                <bool>   initialize #f            getter generate)
  (slot eye?               <bool>   initialize #f            getter generate)
  (slot fly?               <bool>   initialize #f            getter generate)
  (slot viewing?           <bool>   initialize #f            getter generate)
  (slot moving?            <bool>   initialize #f            getter generate)
  (slot moved?             <bool>   initialize #f            getter generate)
  (slot preserved-mouse    <object> initialize #f            getter generate)
  (slot first-person?      <bool>   initialize #f            getter generate)
  (slot first-distance     <fl>     initialize 7.5           getter generate)
  (slot first-camera       <object> initialize #f            getter generate)
  (slot textures?          <bool>   initialize #f            getter generate)
  (slot axes               <object>                          getter generate)
  (slot pulse              <object>                          getter generate)
  (slot last-tick          <fl>     initialize #f            getter generate)
  (slot down?              <bool>   initialize #f            getter generate)
  (slot paused?            <bool>   initialize #f            getter generate)
  (slot info               <object>                          getter generate)
  (slot info?              <bool>   initialize #f            getter generate)
  (slot gc-counter         <object> initialize #f            getter generate)
  (slot tick-counter       <object> initialize #f            getter generate)
  (slot render-counter     <object> initialize #f            getter generate)
  (slot counters?          <bool>   initialize #f            getter generate)
  (slot start-x            <fl+>    initialize #f            getter generate)
  (slot start-y            <fl+>    initialize #f            getter generate)
  (slot start-z            <fl+>    initialize #f            getter generate)
  (slot commands           <object> initialize #f            getter generate)
  (slot player-texture     <object> initialize #f            getter generate)
  (slot turtle-texture     <object> initialize #f            getter generate)
  (slot block-texture      <object> initialize #f            getter generate)
  (slot background-texture <object> initialize #f            getter generate)
  (slot history?           <object> initialize #f            getter generate)
  (slot history            <object> initialize #f            getter generate)
  (slot now                <object> initialize #f            getter generate)
  (slot current            <object> initialize #f            getter generate)
  (slot message            <object> initialize #f            getter generate)
  (slot message-time       <object> initialize #f            getter generate)
  (slot message-color      <object> initialize #f            getter generate)
  (slot message-texture    <object> initialize #f            getter generate)
  (slot status             <object> initialize #f            getter generate)
  (slot status-time        <object> initialize #f            getter generate)
  (slot status-color       <object> initialize #f            getter generate)
  (slot status-texture     <object> initialize #f            getter generate)
  (slot information        <object> initialize #f            getter generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (setup-opengl)
    (nextmethod)
    (initialize-camera)
    (prepare-tick)
    (prepare-textures)
    (prepare-light)
    (prepare-editor)
    (reset-commands))
  
  
  (method (prepare-textures)
    (let ((resources-dir (new Directory (tokenise-filename (repository-pathname (find-repository 'World) "world.client/resources")))))
      (set! player-texture (make-png-texture (new-file~ resources-dir "player/Idle.png")))
      (set! turtle-texture (make-png-texture (new-file~ resources-dir "player/Idle.png")))
      (set! block-texture (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")))
      (set! background-texture (make-png-texture (new-file~ resources-dir "background/Layer0_0.png")))
      (set! message-texture (make-cairo-texture 500 100))
      (set! status-texture (make-cairo-texture 500 35))))
  
  
  (method (prepare-light)
    (set! light? #f))
  
  
  (method (reset-commands)
    (set! commands (new Commands)))
  
  
  (method (setup-world)
    (set! last-tick (time->seconds (current-time)))
    (set! paused? #f))
  
  
  (method (setup-boundaries)
    @w
    (set! boundaries (new Cuboid left bottom far right top near)))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method override (initialize-world)
    (nextmethod)
    (setup-areas)
    (set! axes (add-axes visible?: #f))
    (set! info (new Info self -10.0 0.0 0.0))
    (set! gc-counter (new Counter self -10.0 0.0 0.0 "GC" 62.0))
    (set! tick-counter (new Counter self -10.0 0.0 0.0 "Tick" 35.0))
    (set! render-counter (new Counter self -10.0 0.0 0.0 "Render" 8.0))
    (set! start-x -9.5)
    (set! start-y 60.0)
    (set! start-z 0.0)
    (set! player (add-actor (new Player self start-x start-y start-z 4. 4. 4. player-texture color: {Color red: 173 green: 12 blue: 230})))
    (add-actor (new Turtle self 0.0 20.0 0.0 2. 2. 2.0 turtle-texture color: {Color Green}))
    (loop (for n from -6 to 6)
          (add-block (new Block self (cast <fl> (* n 5)) 30.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    (loop (for n from 0 to 6)
          (add-block (new Block self (cast <fl> (* n 5)) 50.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    (loop (for n from -2 to 2)
          (add-block (new Block self (cast <fl> (* n 5)) 15.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    (add-block (new Block self -10. 20.0 0.0 5.0 5.0 5.0 block-texture color: {Color Light-Purple} user-data: 'win))
    (add-block (new Block self 10. 20.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (add-block (new Block self 20.  4.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (add-block (new Block self 28. 10.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (add-block (new Block self 19.5 17.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (loop (for n from -2 to 2)
          (add-block (new Block self (cast <fl> (* n 5)) 0.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    @w
    (add-block (new Block self -50.0 -30.0 -5.0 100. 100. .1 background-texture color: {Color Light-Blue}))
    (set! first-camera 'free)
    (setup-world)
    (setup-boundaries)
    (setup-history)
    (setup-gc)
    (update-title))
    
  
  ;;;
  ;;;; Sprites
  ;;;
  
  
  (method (add-actor actor)
    (set! actors (cons actor actors))
    (set! sprites (cons actor sprites))
    (area-add-actor (sprite-area actor) actor)
    actor)

  
  (method (add-block block)
    (set! blocks (cons block blocks))
    (set! sprites (cons block sprites))
    (area-add-block (sprite-area block) block)
    block)
  
  
  (method (iterate-sprites proc)
    (for-each proc sprites))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (prepare-tick)
    (set! pulse (new Pulse 'tick .01 tick-world)))
  
  
  (method (tick-world)
    (unless (or paused? (is-inactive?))
      (let ((elapse (- (time->seconds (current-time)) last-tick)))
        (set! last-tick (time->seconds (current-time)))
        (when history?
          (add-history elapse))
        (start~ tick-counter)
        (tick-actors commands elapse)
        (reset-commands)
        (end~ tick-counter))))
  
  
  (method (tick-actors commands elapse)
    (unless (and player (get-state~ player))
      (for-each (lambda (actor)
                  (tick~ actor commands elapse))
                actors)))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (history-start)
    0)
  
  
  (method (history-end)
    (cardinality history))
  
  
  (method (history-first)
    0)
  
  
  (method (history-last)
    (- (history-end) 1))
  
  
  (method (historical-moment n)
    (element history n))
  
  
  (method (in-history n)
    (max (history-first) (min n (history-end))))
  
  
  (method (setup-history)
    (set! history (new Axis 0))
    (set! now 0))
  
  
  (method (add-history elapse)
    (axis-add history (new Moment (snapshot-world) (object-copy commands) elapse))
    (increase! now))
  
  
  (method (backward-history)
    (goto-history (- now 1)))
  
  
  (method (forward-history)
    (goto-history (+ now 1)))
  
  
  (method (goto-history n)
    (let ((n (in-history n)))
      (unless (= n now)
        (set! now n)
        (if (= n (history-end))
            (load-world current)
          (load-world (get-snapshot~ (historical-moment now)))))))
  
  
  (method (slide-history where)
    (goto-history (fxround (* where (history-end)))))
  
  
  (method (truncate-future)
    (axis-adjust history now))
  
  
  (method (toggle-history)
    (set! history? (not history?))
    (when (not history?)
      (setup-history))
    (display-on/off "History" history?))
  
  
  (method (reset-history)
    (setup-history)
    (display-message "History reset"))
  
  
  (method (step-world)
    (when (< now (cardinality history))
      (let ((moment (historical-moment now)))
        (let ((commands (get-commands~ moment))
              (elapse (get-elapse~ moment)))
          (increase! now)
          (tick-actors commands elapse)))))
  
  
  (method (recalculate-future)
    (let ((end (history-end)))
      (loop (for n from now below end)
            (let ((moment (historical-moment n)))
              (let ((commands (get-commands~ moment))
                    (elapse (get-elapse~ moment)))
                (tick-actors commands elapse)
                (let ((next (+ n 1)))
                  (let ((moment (historical-moment next))
                        (snapshot (snapshot-world)))
                    (if (= next end)
                        (set! current snapshot)
                      (set-snapshot~ moment snapshot)))))))
      ;; for now
      (if (= now end)
          (load-world current)
        (load-world (get-snapshot~ (historical-moment now))))))
  
  
  (method (update-future)
    (when (and history? paused?)
      (recalculate-future)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method override (move-forward)
    (if first-person?
        (move-up~ player commands)
      (nextmethod)))
  
  
  (method override (move-backward)
    (if first-person?
        (move-down~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-left)
    (if first-person?
        (strafe-left~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-right)
    (if first-person?
        (strafe-right~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-up)
    (if first-person?
        (strafe-player-up)
      (nextmethod)))
  
  
  (method override (strafe-down)
    (if first-person?
        (strafe-player-down)
      (nextmethod)))
  
  
  (method override (rotate-left)
    (if first-person?
        (rotate-left~ player commands)
      (nextmethod)))
  
  
  (method override (rotate-right)
    (if first-person?
        (rotate-right~ player commands)
      (nextmethod)))
  
  
  (method (move-left)
    (move-left~ player commands))
  
  
  (method (move-right)
    (move-right~ player commands))
  
  
  (method (move-down)
    (move-down~ player commands))
  
  
  (method (move-up)
    (move-up~ player commands))
  
  
  (method (space)
    (space~ player commands))
  
  
  ;;;
  ;;;; Area
  ;;;
  
  
  (method (setup-areas)
    (set! areas (make-table test: equal?))
    (set! area-size 10))
  
  
  (method (sprite-area-index sprite)
    (position-area-index (get-center-x~ sprite)
                         (get-center-y~ sprite)
                         (get-center-z~ sprite)))
  
  
  (method (position-area-index x y z)
    (define (offset r)
      (let ((i (fxfloor r)))
        (/ (- i (modulo i area-size))
           area-size)))
    
    (list (offset x)
          (offset y)
          (offset z)))
  
  
  (method (sprite-area sprite)
    (index-area (sprite-area-index sprite)))
  
  
  (method (index-area index)
    (or (table-ref areas index #f)
        (let ((area (new Area)))
          (table-set! areas index area)
          area)))
  
  
  (method (area-add-sprite area sprite)
    (if (is? sprite Actor)
        (area-add-actor area sprite)
      (area-add-block area sprite)))
  
  
  (method (area-add-actor area actor)
    (set-actors~ area (cons actor (get-actors~ area))))
  
  
  (method (area-add-block area block)
    (set-blocks~ area (cons block (get-blocks~ area))))
  
  
  (method (area-remove-sprite area sprite)
    (if (is? sprite Actor)
        (area-remove-actor area sprite)
      (area-remove-block area sprite)))
  
  
  (method (area-remove-actor area actor)
    (set-actors~ area (remove! actor (get-actors~ area))))
  
  
  (method (area-remove-block area block)
    (set-blocks~ area (remove! block (get-blocks~ area))))
  
  
  (method (update-area sprite old-center)
    (let ((old-index (position-area-index (vertex-x old-center) (vertex-y old-center) (vertex-z old-center)))
          (new-index (sprite-area-index sprite)))
      (when (not (equal? old-index new-index))
        (let ((old-area (index-area old-index))
              (new-area (index-area new-index)))
          (area-remove-sprite old-area sprite)
          (area-add-sprite new-area sprite)))))
  
  
  (method (iterate-sprite-areas-3d sprite proc)
    (bind (x y z) (sprite-area-index sprite)
      (loop (for i from -1 to 1)
            (loop (for j from -1 to 1)
                  (loop (for k from -1 to 1)
                        (proc (index-area (list (+ x i) (+ y j) (+ z k)))))))))
  
  
  (method (sprite-areas-3d sprite)
    (let ((queue (new-queue)))
      (iterate-sprite-areas-3d sprite (lambda (area) (enqueue queue area)))
      (queue-list queue)))
  
  
  (method (iterate-areas-sprites areas proc)
    (for-each (lambda (area)
                (for-each proc (get-actors~ area))
                (for-each proc (get-blocks~ area)))
              areas))
  
  
  (method (iterate-area-sprites area proc)
    (for-each proc (get-actors~ area))
    (for-each proc (get-blocks~ area)))
  
  
  (method (collect-area-sprites)
    (let ((queue (new-queue)))
      (iterate-table areas
        (lambda (index area)
          (enqueue-list queue (get-actors~ area))
          (enqueue-list queue (get-blocks~ area))))
      (queue-list queue)))
  
  
  (method (validate-areas)
    (let ((count 0))
      (iterate-table areas
        (lambda (index area)
          (increase! count (length (get-actors~ area)))
          (increase! count (length (get-blocks~ area)))))
      (let ((sprites (length sprites)))
        (if (= count sprites)
            (reset-information)
          (set-information
            `("Area corruption detected"
              ,(format "  Sprite count: {s}" sprites)
              ,(format "  Area count: {s}" count)))))))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method (hit-test object from-x <fl> from-y <fl> from-z <fl> to-x <fl> to-y <fl> to-z <fl> width <fl> height <fl> depth <fl>)
    (let ((from-right (+ from-x width))
          (from-top (+ from-y height))
          (from-near (+ from-z depth))
          (to-right #f)
          (to-top #f)
          (to-near #f)
          (areas (sprite-areas-3d object)))
      (define (hit-y)
        (cond ;; going up
              ((> to-y from-y)
               (continuation-capture
                 (lambda (hit-found)
                   (iterate-areas-sprites areas
                     (lambda (obj)
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (far (get-far~ obj))
                             (near (get-near~ obj))
                             (border (get-bottom~ obj)))
                         (when (and (neq? obj object)
                                    (<= from-top border)
                                    (> to-top border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-near far)
                                             (>= to-z near))))
                           (set! to-top border)
                           (set! to-y (- to-top height))
                           (continuation-return hit-found (list obj 1 border (- border height)))))))
                   #f)))
              ;; going down
              ((< to-y from-y)
               (continuation-capture
                 (lambda (hit-found)
                   (iterate-areas-sprites areas
                     (lambda (obj)
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (far (get-far~ obj))
                             (near (get-near~ obj))
                             (border (get-top~ obj)))
                         (when (and (neq? obj object)
                                    (>= from-y border)
                                    (< to-y border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-near far)
                                             (>= to-z near))))
                           (set! to-y border)
                           (set! to-top (+ to-y height))
                           (continuation-return hit-found (list obj -1 border border))))))
                   #f)))
              ;; not moving
              (else
               #f)))
      
      (define (hit-x)
        (cond ;; going right
              ((> to-x from-x)
               (continuation-capture
                 (lambda (hit-found)
                   (iterate-areas-sprites areas
                     (lambda (obj)
                       (let ((bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (far (get-far~ obj))
                             (near (get-near~ obj))
                             (border (get-left~ obj)))
                         (when (and (neq? obj object)
                                    (<= from-right border)
                                    (> to-right border)
                                    (not (or (<= to-top bottom)
                                             (>= to-y top)
                                             (<= to-near far)
                                             (>= to-z near))))
                           (set! to-right border)
                           (set! to-x (- to-right width))
                           (continuation-return hit-found (list obj 1 border (- border width)))))))
                   #f)))
              ;; going left
              ((< to-x from-x)
               (continuation-capture
                 (lambda (hit-found)
                   (iterate-areas-sprites areas
                     (lambda (obj)
                       (let ((bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (far (get-far~ obj))
                             (near (get-near~ obj))
                             (border (get-right~ obj)))
                         (when (and (neq? obj object)
                                    (>= from-x border)
                                    (< to-x border)
                                    (not (or (<= to-top bottom)
                                             (>= to-y top)
                                             (<= to-near far)
                                             (>= to-z near))))
                           (set! to-x border)
                           (set! to-right (+ to-x width))
                           (continuation-return hit-found (list obj -1 border border))))))
                   #f)))
              ;; not moving
              (else
               #f)))
      
      (define (hit-z)
        (cond ;; going near
              ((> to-z from-z)
               (continuation-capture
                 (lambda (hit-found)
                   (iterate-areas-sprites areas
                     (lambda (obj)
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (border (get-far~ obj)))
                         (when (and (neq? obj object)
                                    (<= from-near border)
                                    (> to-near border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-top bottom)
                                             (>= to-y top))))
                           (set! to-near border)
                           (set! to-z (- to-near depth))
                           (continuation-return hit-found (list obj 1 border (- border depth)))))))
                   #f)))
              ;; going far
              ((< to-z from-z)
               (continuation-capture
                 (lambda (hit-found)
                   (iterate-areas-sprites areas
                     (lambda (obj)
                       (let ((left (get-left~ obj))
                             (right (get-right~ obj))
                             (bottom (get-bottom~ obj))
                             (top (get-top~ obj))
                             (border (get-near~ obj)))
                         (when (and (neq? obj object)
                                    (>= from-z border)
                                    (< to-z border)
                                    (not (or (<= to-right left)
                                             (>= to-x right)
                                             (<= to-top bottom)
                                             (>= to-y top))))
                           (set! to-z border)
                           (set! to-near (+ to-z depth))
                           (continuation-return hit-found (list obj -1 border border))))))
                   #f)))
              ;; not moving
              (else
               #f)))
      
      (define (hit h1 h2 h3)
        (let ((count 0))
          (let ((h1 (h1)))
            (when h1
              (increase! count))
            (let ((h2 (h2)))
              (when h2
                (increase! count))
              (let ((h3 (h3)))
                (when h3
                  (increase! count))
                (values count h1 h2 h3))))))
      
      (let ((preserved-x to-x)
            (preserved-y to-y)
            (preserved-z to-z))
        (define (restore)
          (set! to-x preserved-x)
          (set! to-y preserved-y)
          (set! to-z preserved-z)
          (set! to-right (+ to-x width))
          (set! to-top (+ to-y height))
          (set! to-near (+ to-z depth)))
        
        (restore)
        (receive (count hy hx hz) (hit hit-y hit-x hit-z)
          (if (<= count 1)
              (values hx hy hz)
            (restore)
            (receive (count hx hy hz) (hit hit-x hit-y hit-z)
              (if (<= count 1)
                  (values hx hy hz)
                (restore)
                (receive (count hz hy hx) (hit hit-z hit-y hit-x)
                  (values hx hy hz)))))))))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method override (prepare-projection)
    (let ((ratio (/ (cast <fl> width) (cast <fl> height))))
      (glMatrixMode GL_PROJECTION)
      (glLoadIdentity)
      (case projection
        ((perspective)
         (gluPerspective 45.0 ratio 0.1 1000.0))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (glOrtho (- width) width (- height) height -50.0 50.0)))))))
  
  
  (method (toggle-projection)
    (set! projection
          (case projection
            ((perspective) 'orthographic)
            ((orthographic) 'perspective)))
    (display-message (format "Projection {a}" projection)))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (definition camera-limit
    5.)
  
  
  (method override (camera-speed)
    1.0)
  
  
  (method (initialize-camera)
    (set! zoom-factor 54.5)
    (prepare-camera)
    (update-camera))
  
  
  (method override (prepare-camera)
    (set! eye (vertex 0.0 36.25 40.0))
    (set! eye-lookat (new LookAt (vertex 0.0 0.0 -1.0) (vertex 0.0 1.0 0.0) (vertex 1.0 0.0 0.0))))
  
  
  (method (reset-camera)
    (set-lookat~ player (new LookAt (vertex 0.0 0.0 -1.0) (vertex 0.0 1.0 0.0) (vertex 1.0 0.0 0.0)))
    (set! eye-lookat (new LookAt (vertex 0.0 0.0 -1.0) (vertex 0.0 1.0 0.0) (vertex 1.0 0.0 0.0)))
    (follow-player)
    (display-message "Reset"))
  
  
  (method (toggle-eye)
    (set! eye? (not eye?)))
  
  
  (method (draw-eye)
    (let ((center (vertex- (vertex- (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) 5.)) (vertex-scalar* (get-right~ eye-lookat) 1.5)) (get-up~ eye-lookat))))
      (let ((sight (vertex+ center (get-sight~ eye-lookat)))
            (up (vertex+ center (get-up~ eye-lookat)))
            (right (vertex+ center (get-right~ eye-lookat)))
            (axis-x (vertex+ center (vertex 1. 0. 0.)))
            (axis-y (vertex+ center (vertex 0. 1. 0.)))
            (axis-z (vertex+ center (vertex 0. 0. 1.))))
        (let ((cx (vertex-x center))
              (cy (vertex-y center))
              (cz (vertex-z center)))
          (glLineWidth 2.)
          (glDisable GL_LIGHTING)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x sight) (vertex-y sight) (vertex-z sight))
          (glEnd)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x right) (vertex-y right) (vertex-z right))
          (glEnd)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x up) (vertex-y up) (vertex-z up))
          (glEnd)
          (gl-colorize {Color Red})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-x) (vertex-y axis-x) (vertex-z axis-x))
          (glEnd)
          (gl-colorize {Color Green})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-y) (vertex-y axis-y) (vertex-z axis-y))
          (glEnd)
          (gl-colorize {Color Blue})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-z) (vertex-y axis-z) (vertex-z axis-z))
          (glEnd)
          (glLineWidth 1.)))))

  
  (method override (zoom-in)
    (if first-person?
        (first-distance-closer)
      (if (eq? projection 'perspective)
          (nextmethod)
        (set! zoom-factor (* zoom-factor .75)))))
  
  
  (method override (zoom-out)
    (if first-person?
        (first-distance-further)
      (if (eq? projection 'perspective)
          (nextmethod)
        (set! zoom-factor (/ zoom-factor .75)))))
  
  
  (method override (zoom-speed)
    10.)
  
  
  (method (change-first-camera)
    (let ((camera (next-element '(locked free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'locked)
        (follow-player))
      (display-message (format "Camera {a}" camera))))
  
  
  (method (follow-player)
    (when first-person?
      (unless (or viewing? (eq? first-camera 'free))
        (set-sight~ eye-lookat (get-sight~ (get-lookat~ player)))
        (set-up~ eye-lookat (if fly? (get-up~ (get-lookat~ player)) (vertex 0.0 1.0 0.0)))
        (set-right~ eye-lookat (vertex-normalize (cross-product (get-sight~ eye-lookat) (get-up~ eye-lookat)))))
      (let ((center (vertex+ (get-center~ player) (vertex-scalar* (if fly? (get-up~ eye-lookat) world-up) (+ (get-radius-y~ player) 1.5)))))
        (set! eye-target (vertex- center (vertex-scalar* (get-sight~ eye-lookat) first-distance)))
        (set! eye (vertex- eye-target (get-sight~ eye-lookat))))))
  
  
  (method (strafe-camera center-x)
    (let ((eye-x (vertex-x eye)))
      (if (> center-x (+ eye-x camera-limit))
          (strafe-horizontally (- center-x (+ eye-x camera-limit))))
      (if (< center-x (- eye-x camera-limit))
          (strafe-horizontally (- center-x (- eye-x camera-limit))))))
  
  
  (method (center-camera)
    (unless paused?
      (case projection
        ((perspective)
         (follow-player))
        ((orthographic)
         (strafe-camera (get-center-x~ player))))))
  
  
  (method (first-distance-closer)
    (set! first-distance (* first-distance .75))
    (update-player-alpha)
    (center-camera))
  
  
  (method (first-distance-further)
    (set! first-distance (/ first-distance .75))
    (update-player-alpha)
    (center-camera))
  
  
  (method (update-player-alpha)
    (set-alpha~ (get-color~ player) (max 0.3 (min 1. (/ first-distance 10.)))))
  
  
  (method (move-player-forward factor)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* (get-sight~ (get-lookat~ player)) (* factor (if fly? 1.5 0.5)))))
    (follow-player))
  
  
  (method (move-player-backward factor)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* (get-sight~ (get-lookat~ player)) (* factor (if fly? 1.5 0.5)))))
    (follow-player))
  
  
  (method (strafe-player-left factor)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* (get-right~ eye-lookat) (* factor (if fly? 1.0 0.5)))))
    (follow-player))
  
  
  (method (strafe-player-right factor)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* (get-right~ eye-lookat) (* factor (if fly? 1.0 0.5)))))
    (follow-player))
  
  
  (method (strafe-player-up)
    (strafe-player-vertical (* (camera-speed) 2)))
  
  
  (method (strafe-player-down)
    (strafe-player-vertical (- (* (camera-speed) 2))))
  
  
  (method (strafe-player-vertical distance)
    (set! eye (vertex+ eye (vertex-scalar* world-up distance)))
    (update-camera)
    (set-y~ player (+ (get-y~ player) distance))
    (follow-player))
  
  
  (definition player-rotation-speed
    0.02)
  
  
  (method (rotate-player-left factor)
    (rotate-player-horizontal (* player-rotation-speed factor))
    (when fly?
      (tilt-player -1.)))
  
  
  (method (rotate-player-right factor)
    (rotate-player-horizontal (- (* player-rotation-speed factor)))
    (when fly?
      (tilt-player 1.)))
  
  
  (method (rotate-player-horizontal angle)
    (rotate~ (get-lookat~ player) angle world-up)
    (unless (and down? (not moving?))
      (rotate~ eye-lookat angle world-up))
    (follow-player))
  
  
  (method (rotate-player-vertical angle)
    (let ((lookat (get-lookat~ player)))
      (rotate~ lookat angle (get-right~ lookat)))
    (rotate~ eye-lookat angle (get-right~ eye-lookat))
    (follow-player))
  
  
  (method (tilt-player speed)
    @fix-me
    (let ((lookat (get-lookat~ player))
          (max-tilt PI/8)
          (max-speed 0.4))
      (let ((current (vertical-angle (get-right~ lookat) world-up))
            (desired (* (sign speed) max-tilt)))
        (set! desired-tilt desired)
        (set! tilt-speed (min (/ (abs speed) 50000.) max-speed))
        (set! last-tilt-time (time->seconds (current-time)))
        (process-tilt))))
  
  
  (method (reset-player-tilt)
    @fix-me
    (when (or (not last-tilt-time)
              (> (- (time->seconds (current-time)) last-tilt-time) .1))
      (set! desired-tilt 0.)
      (set! tilt-speed .015)
      (process-tilt)))
  
  
  (method (process-tilt)
    @fix-me
    (let ((lookat (get-lookat~ player)))
      (let ((current (vertical-angle (get-right~ lookat) world-up)))
        (unless (near? current desired-tilt .001)
          (let ((direction (sign (- desired-tilt current))))
            (let ((new-tilt (+ current (* direction tilt-speed))))
              (case direction
                ((1) (when (> new-tilt desired-tilt) (set! new-tilt desired-tilt)))
                ((-1) (when (< new-tilt desired-tilt) (set! new-tilt desired-tilt))))
              (let ((inc (- new-tilt current)))
                (increase-player-tilt inc))))))))
  
  
  (method (increase-player-tilt inc)
    @fix-me
    (let ((lookat (get-lookat~ player)))
      (rotate~ lookat inc (get-sight~ lookat))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-objects)
    (case projection
      ((perspective)
       (if 3d?
           (glEnable GL_DEPTH_TEST)
         (glDisable GL_DEPTH_TEST)))
      ((orthographic)
       (glDisable GL_DEPTH_TEST)))
    (draw-grid)
    (cond ((not paused?)
           (start~ render-counter)
           (iterate-sprites draw~)
           (end~ render-counter))
          (else
           (iterate-sprites draw~)
           (draw-history)))
    (when target
      (draw-target))
    (when eye?
      (draw-eye)))
  
  
  (method (draw-target)
    (let ((x1 (get-left~ target))
          (y1 (get-bottom~ target))
          (z1 (get-far~ target))
          (x2 (get-right~ target))
          (y2 (get-top~ target))
          (z2 (get-near~ target)))
      (case projection
        ((perspective)
         (gl-colorize {Color Red})
         (render-cube x1 y1 z1 x2 y2 z2
           (lambda (proc)
             (glBegin GL_QUADS)
             (proc)
             (glEnd))))
        ((orthographic)
         (glNormal3f 0.0 0.0 1.0)
         (gl-colorize {Color Red})
         (glBegin GL_LINE_LOOP)
         (glVertex2f x1 y1)
         (glVertex2f x2 y1)
         (glVertex2f x2 y2)
         (glVertex2f x1 y2)
         (glEnd)))))
  
  
  (method (draw-grid)
    (when grid?
      (when grid-x?
        (let ((min -500.)
              (max 500.))
          (gl-colorize {Color Yellow})
          (glBegin GL_LINES)
          (loop (for y <fl> from min to max by 5.)
                (glVertex3f grid-x y min)
                (glVertex3f grid-x y max))
          (loop (for z <fl> from min to max by 5.)
                (glVertex3f grid-x min z)
                (glVertex3f grid-x max z))
          (glEnd)))
      (when grid-y?
        (let ((min -500.)
              (max 500.))
          (gl-colorize {Color Green})
          (glBegin GL_LINES)
          (loop (for x <fl> from min to max by 5.)
                (glVertex3f x grid-y min)
                (glVertex3f x grid-y max))
          (loop (for z <fl> from min to max by 5.)
                (glVertex3f min grid-y z)
                (glVertex3f max grid-y z))
          (glEnd)))
      (when grid-z?
        (let ((min -500.)
              (max 500.))
          (gl-colorize {Color Red})
          (glBegin GL_LINES)
          (loop (for x <fl> from min to max by 5.)
                (glVertex3f x min grid-z)
                (glVertex3f x max grid-z))
          (loop (for y <fl> from min to max by 5.)
                (glVertex3f min y grid-z)
                (glVertex3f max y grid-z))
          (glEnd)))))
  
  
  (method (draw-history)
    (let ((step 1)
          (max 1000))
      ;; past
      (loop (for n from (- now 1) downto (history-first) by step)
            (repeat max)
            (draw-player n))
      ;; future
      (loop (for n from now to (history-last) by step)
            (repeat max)
            (draw-player n))))
  
  
  (method (draw-player n)
    (let ((snapshot (get-snapshot~ (historical-moment n))))
      (let ((player (find-player snapshot)))
        (when player
          (parameterize ((in-history? #t))
            (draw~ player))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method override (draw-interface)
    (nextmethod)
    (when info?
      (draw~ info))
    (when message
      (draw-message))
    (when status
      (draw-status))
    (when counters?
      (draw-rate~ gc-counter #t)
      (draw-rate~ tick-counter)
      (draw-rate~ render-counter))
    (when (and history? paused?)
      (draw-history-slider)))
  
  
  (method (draw-history-slider)
    (let ((cx (fxround/ width 2)))
      (gl-frame-rect (new Rect (- cx 200) (- height 30) (+ cx 200) (- height 31)) {Color Gray})
      (gl-frame-rect (new Rect (- cx 200) (- height 32) (+ cx 200) (- height 33)) {Color Light-Gray})
      (let ((end (history-end)))
        (when (> end 0)
          (let ((h (+ (fxround (- (* (/ (cast <fl> now) end) 400.) 200.)) cx)))
            (gl-segment-circle (new Point h (- height 32)) 7 {Color Light-Blue} 100))))))
  
  
  ;;;
  ;;;; Win / Lose
  ;;;
  
  
  (method (win)
    (win~ player)
    (let ((block (find-if (lambda (obj)
                            (eq? (get-user-data~ obj) 'win))
                          blocks)))
      (set-color~ block {Color Blue}))
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (lose)
    (lose~ player)
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (reset-game)
    (setup-history))
    
  
  ;;;
  ;;;; Save / Open
  ;;;
  
  
  (slot moniker   initialize #f)
  (slot modified? initialize #f)

  
  (method (new-world)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (setup-areas)
    (set! moniker #f)
    (set-target #f)
    (center-camera)
    (reset-counters))
  
  
  (method (save-world)
    (if (not moniker)
        (save-as-world)
      (save-to moniker)))
  
  
  (method (save-as-world)
    (let ((file (choose-new-file default-extension: "wrl" extensions: '(("World Files" . "wrl")) directory: {Directory Home ".world" "levels"})))
      (save-to file)
      (set! moniker file)
      (update-title)))
  
  
  (method (save-to file)
    (call-with-output-file (path-settings file)
      (lambda (output)
        (format output "(")
        (let ((first? #t))
          (for-each (lambda (property)
                      (if first?
                          (set! first? #f)
                        (format output "{%} "))
                      (format output "{a}: {s}" property (read-property self property)))
                  (world-properties)))
        (format output "){%}{%}")
        (iterate-sprites
          (lambda (obj)
            (format output "{s}{%}" (serialize-sprite~ obj))))))
    (set-modified? #f))
  
  
  (method (world-properties)
    (difference (map get-name~ (get-properties~ (class-of self))) '(before children visible? class-info name-info presentation-info)))
  
  
  (method (open-world (reversed?: reversed? #f))
    (define (open file)
      (open-file file)
      (display-message (get-base~ file)))
    
    (let ((files (collect-files~ {Directory Home ".world" "levels"} (lambda (file) (extension=? (get-extension~ file) "wrl")))))
      (if (null? files)
          (begin
            (display-error "No files found")
            (bell))
        (if (not moniker)
            (open (car files))
          (let ((next (if reversed? previous-element next-element)))
            (let ((file (next files moniker test: pathname=?)))
              (open file)))))))
  
  
  (method (open-file file)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (setup-areas)
    (call-with-input-file (path-settings file)
      (lambda (input)
        (for-each-property (lambda (property value)
                             (write-property self property value))
                           (read input))
        (let (iter)
          (let ((info (read input)))
            (when (not (eof-object? info))
              (bind (class x y z) info
                (when (eq? class 'player)
                  (set! start-x x)
                  (set! start-y y)
                  (set! start-z z))
                (add-sprite class x y z)
                (iter)))))))
    (set! moniker file)
    (setup-world)
    (setup-history)
    (update-title)
    (center-camera)
    (reset-counters))
  
  
  (method (revert-world)
    (if moniker
        (open-file moniker)
      (bell)))
  
  
  (method (update-title)
    (define (present-title)
      (format "World - {a}{a}{a}"
              (present-name)
              (present-modified)
              (present-directory)))
    
    (define (present-name)
      (if (not moniker)
          "New"
        (get-name~ moniker)))
    
    (define (present-modified)
      (if modified?
          " *"
        ""))
    
    (define (present-directory)
      (if (not moniker)
          ""
        (let ((parent (get-parent~ moniker)))
          (if (not parent)
              ""
            (format " ~{{a}}" (present-location~ parent))))))
    
    (set-title~ window (present-title)))
  
  
  (method (set-modified? flag)
    (when (neq? flag modified?)
      (set! modified? flag)
      (update-title)))
  
  
  (method (reset-live)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (set-target #f)
    (reset-world)
    (center-camera)
    (reset-counters)
    (display-message "World reset"))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot editor-mode   <object> initialize #f  getter generate)
  (slot editor-anchor <object> initialize #f  getter generate)
  (slot editor-last   <object> initialize #f  getter generate)
  (slot editor-added  <object> initialize #f  getter generate)
  (slot adding?       <bool>   initialize #f  getter generate)
  (slot deleting?     <bool>   initialize #f  getter generate)
  (slot grid-x        <fl>     initialize 0.  getter generate)
  (slot grid-y        <fl>     initialize 0.  getter generate)
  (slot grid-z        <fl>     initialize 10. getter generate)
  (slot grid?         <bool>   initialize #f  getter generate)
  (slot grid-x?       <bool>   initialize #f  getter generate)
  (slot grid-y?       <bool>   initialize #f  getter generate)
  (slot grid-z?       <bool>   initialize #f  getter generate)
  (slot last-added    <object> initialize #f  getter generate)
  (slot players-folio <Folio>                 getter generate)
  (slot enemies-folio <Folio>                 getter generate)
  (slot blocks-folio  <Folio>                 getter generate)
  
  
  (method (prepare-editor)
    (set! editor-mode 'rectangle)
    (set! players-folio (new Folio 'player '(player pacman)))
    (set! enemies-folio (new Folio 'turtle '(turtle)))
    (set! blocks-folio (new Folio 'block '(block block-red block-green block-blue))))
  
  
  (method (switch-editor-mode)
    (let ((new-mode (next-element '(point @wait line rectangle) editor-mode)))
      (set! editor-mode new-mode)
      (display-message (capitalize (->string new-mode)))))
  
  
  (method (find-sprite vert)
    (continuation-capture
      (lambda (return)
        (let ((x (vertex-x vert))
              (y (vertex-y vert))
              (z (vertex-z vert)))
          (let ((area (index-area (position-area-index x y z))))
            (iterate-area-sprites area
              (lambda (obj)
                (when (and (>= x (get-left~ obj))
                           (>= y (get-bottom~ obj))
                           (>= z (get-far~ obj))
                           (<  x (get-right~ obj))
                           (<  y (get-top~ obj))
                           (<  z (get-near~ obj)))
                  (continuation-return return obj))))))
        #f)))
  
  
  (method (screen->world h v)
    (let ((ratio (/ (cast <fl> width) (cast <fl> height)))
          (ch (- h (fxfloor/ width 2)))
          (cv (- (- height v) (fxfloor/ height 2))))
      (define (perspective->world norm plane-k)
        (let ((norm-eye-sight-dot-product (dot-product norm (vertex-normalize (get-sight~ eye-lookat)))))
          (unless (and (= norm-eye-sight-dot-product 0.)
                       (cond (grid-x? (= (vertex-x eye) grid-x))
                             (grid-y? (= (vertex-y eye) grid-y))
                             (grid-z? (= (vertex-z eye) grid-z))))
            (let ((f-over-y (/ PI/4 2)))
              (let ((cone (tan f-over-y))
                    (d (vertex-distance eye eye-target))
                    (right (cross-product (vertex- eye-target eye) (get-up~ eye-lookat))))
                (let ((target-in-eye-space (vertex+ (vertex-scalar* (get-up~ eye-lookat) (/ (* cv d cone 2.) height))
                                                    (vertex+ (vertex-scalar* right (/ (* ch d cone 2. ratio) width))
                                                             eye-target))))
                  (let ((intersect (/ (- plane-k (dot-product norm eye))
                                      (dot-product (vertex- target-in-eye-space eye) norm))))
                    (unless (<= intersect 0)
                      (let ((point (vertex+ eye (vertex-scalar* (vertex- target-in-eye-space eye) intersect))))
                        point)))))))))
      
      (define (orthographic->world)
        (let ((x (+ (/ (* 2. ch zoom-factor) width) (vertex-x eye)))
              (y (+ (/ (* 2. cv zoom-factor) height ratio) (vertex-y eye))))
         (vertex x y 0.)))
      
      (case projection
        ((perspective)
         (when grid?
           (cond (grid-x? (let ((vert (perspective->world (vertex 1. 0. 0.) grid-x)))
                            (and vert (vertex
                                        grid-x
                                        (vertex-y vert)
                                        (vertex-z vert)))))
                 (grid-y? (let ((vert (perspective->world (vertex 0. 1. 0.) grid-y)))
                            (and vert (vertex
                                        (vertex-x vert)
                                        grid-y
                                        (vertex-z vert)))))
                 (grid-z? (let ((vert (perspective->world (vertex 0. 0. 1.) grid-z)))
                            (and vert (vertex
                                        (vertex-x vert)
                                        (vertex-y vert)
                                        grid-z))))
                 (else #f))))
        ((orthographic)
         (orthographic->world)))))
  
  
  (method (add-sprite class x y z)
    (let ((sprite
            (case class
              ((player)
               (add-actor (new Player self x y z 4. 4. 4. player-texture color: {Color red: 173 green: 12 blue: 230})))
              ((pacman)
               (add-actor (new Pacman self x y z 4. 4. 4. player-texture color: {Color Yellow})))
              ((turtle)
               (add-actor (new Turtle self x y z 2. 2. 2. turtle-texture color: {Color Green})))
              ((block)
               (add-block (new Block self x y z 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
              ((block-red)
               (add-block (new Block-Red self x y z 5.0 5.0 5.0 block-texture)))
              ((block-green)
               (add-block (new Block-Green self x y z 5.0 5.0 5.0 block-texture)))
              ((block-blue)
               (add-block (new Block-Blue self x y z 5.0 5.0 5.0 block-texture))))))
      (when (is? sprite Player)
        (when player
          (remove-sprite player))
        (set! player sprite))
      sprite))
  
  
  (method (editor-add-sprite class vert)
    (define (sign r)
      (if (< r 0)
          -1
        1))
    
    (define (sign-test sign)
      (if (= sign -1)
          >=
        <=))
    
    (let ((to-x (* (floor (/ (vertex-x vert) 5.)) 5.))
          (to-y (* (floor (/ (vertex-y vert) 5.)) 5.))
          (to-z (* (floor (/ (vertex-z vert) 5.)) 5.)))
      (if (not editor-anchor)
          (let ((sprite (add-sprite class to-x to-y to-z)))
            (set! last-added sprite)
            (set! editor-anchor (vertex to-x to-y to-z)))
        (unless (and editor-last
                     (= (vertex-x editor-last) to-x)
                     (= (vertex-y editor-last) to-y)
                     (= (vertex-z editor-last) to-z))
          (case editor-mode
            ((point)
             (let ((sprite (add-sprite class to-x to-y to-z)))
               (set! last-added sprite)))
            ((line))
            ((rectangle)
             (let ((anchor-x (vertex-x editor-anchor))
                   (anchor-y (vertex-y editor-anchor))
                   (anchor-z (vertex-z editor-anchor)))
               (let ((sign-x (sign (- to-x anchor-x)))
                     (sign-y (sign (- to-y anchor-y)))
                     (sign-z (sign (- to-z anchor-z))))
                 (let ((step-x (* sign-x 5.))
                       (step-y (* sign-y 5.))
                       (step-z (* sign-z 5.))
                       (test-x (sign-test sign-x))
                       (test-y (sign-test sign-y))
                       (test-z (sign-test sign-z)))
                   (let ((queue (new-queue))
                         (max-size 30))
                     (let (iter-x (x anchor-x) (count-x 0))
                       (when (and (< count-x max-size)
                                  (test-x x to-x))
                         (let (iter-y (y anchor-y) (count-y 0))
                           (when (and (< count-y max-size)
                                      (test-y y to-y))
                             (let (iter-z (z anchor-z) (count-z 0))
                               (when (and (< count-z max-size)
                                          (test-z z to-z))
                                 (let ((sprite (or (find-sprite (vertex x y z))
                                                   (add-sprite class x y z))))
                                   (enqueue queue sprite))
                                 (iter-z (+ z step-z) (+ count-z 1))))
                             (iter-y (+ y step-y) (+ count-y 1))))
                         (iter-x (+ x step-x) (+ count-x 1))))
                     (let ((added (queue-list queue)))
                       (when editor-added
                         (for-each remove-sprite (difference editor-added added)))
                       (set! editor-added added))))))))
          (set! editor-last (vertex to-x to-y to-z))))))
  
  
  (method (editor-sprite-class)
    (cond ((alt-down?) (get-class~ players-folio))
          ((shift-down?) (get-class~ enemies-folio))
          (else (get-class~ blocks-folio))))
  
  
  (method (sprite-folio sprite)
    (typecase sprite
      ((Player) players-folio)
      ((Enemy) enemies-folio)
      ((Block) blocks-folio)
      (else #f)))
  
  
  (method (forward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (next-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)
          (display-message (format "{a}" new-class))))))
  
  
  (method (backward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (previous-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)
          (display-message (format "{a}" new-class))))))
  
  
  (method (change-class sprite class)
    (let ((vert (vertex (get-x~ sprite) (get-y~ sprite) (get-z~ sprite))))
      (remove-sprite sprite)
      (editor-add-sprite class vert)))
  
  
  (method (remove-target)
    (if (not target)
        (bell)
      (remove-sprite target)
      (set-modified? #t)))
  
  
  (method (remove-sprite obj)
    (typecase obj
      ((Actor) (set! actors (remove! obj actors)))
      ((Block) (set! blocks (remove! obj blocks))))
    (set! sprites (remove! obj sprites))
    (when (eq? obj player)
      (set! player #f))
    (when (eq? obj target)
      (set-target #f))
    (area-remove-sprite (sprite-area obj) obj))
  
  
  (method (toggle-grid)
    (set! grid? (not grid?))
    (activate-3d))
  
  
  (method (toggle-grid-x)
    (set! grid-x? (not grid-x?))
    (when grid-x?
      (set! grid? #t)
      (set! grid-y? #f)
      (set! grid-z? #f)
      (activate-3d)))
  
  
  (method (toggle-grid-y)
    (set! grid-y? (not grid-y?))
    (when grid-y?
      (set! grid? #t)
      (set! grid-x? #f)
      (set! grid-z? #f)
      (activate-3d)))
  
  
  (method (toggle-grid-z)
    (set! grid-z? (not grid-z?))
    (when grid-z?
      (set! grid? #t)
      (set! grid-x? #f)
      (set! grid-y? #f)
      (activate-3d)))
  
  
  (method (decrease-grid)
    (move-grid-by -1))
  
  
  (method (increase-grid)
    (move-grid-by 1))
  
  
  (method (move-grid delta)
    (move-grid-by (fxround/ (- delta) 120)))
  
  
  (method (move-grid-by incr)
    (let ((dist (* incr 5.)))
      (cond (grid-x? (increase! grid-x dist) (display-status (format "Grid at {a}" grid-x)))
            (grid-y? (increase! grid-y dist) (display-status (format "Grid at {a}" grid-y)))
            (grid-z? (increase! grid-z dist) (display-status (format "Grid at {a}" grid-z))))))
  
  
  (method (editor-mouse-down h v)
    (let ((vert (screen->world h v)))
      (if (not vert)
          (when (control-down?)
            (display-error "3d edition requires a grid")
            (bell))
        (let ((obj (find-sprite vert)))
          (if obj
              (if (control-down?)
                  (begin
                    (show-cursor)
                    (set! preserved-mouse #f)
                    (set! deleting? #t)
                    (set! editor-anchor #f)
                    (set! editor-last #f)
                    (remove-sprite obj)
                    (set-modified? #t)
                    (update-future)))
            (if (control-down?)
                (begin
                  (show-cursor)
                  (set! preserved-mouse #f)
                  (set! editor-anchor #f)
                  (set! editor-last #f)
                  (set! adding? #t)
                  (let ((class (editor-sprite-class)))
                    (editor-add-sprite class vert)
                    (set-modified? #t))
                  (update-future))))))))
  
  
  (method (editor-mouse-move h v)
    (when down?
      (let ((vert (screen->world h v)))
        (when vert
          (let ((obj (find-sprite vert)))
            (if (and obj (not editor-anchor))
                (when deleting?
                  (remove-sprite obj)
                  (set-modified? #t)
                  (update-future))
              (when adding?
                (let ((class (editor-sprite-class)))
                  (editor-add-sprite class vert)
                  (set-modified? #t))
                (update-future))))))))
  
  
  (method (editor-mouse-up h v)
    (unless (or adding? deleting?)
      (let ((vert (screen->world h v)))
        (if (not vert)
            (set-target #f)
          (let ((obj (find-sprite vert)))
            (if (not obj)
                (set-target #f)
              (set-target obj))))))
    (set! adding? #f)
    (set! deleting? #f)
    (set! editor-anchor #f)
    (set! editor-last #f)
    (set! editor-added #f))
  
  
  (method (set-target obj)
    (set! target obj)
    (set-?t obj))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-hook? initialize #t getter generate)
  
  
  (method (toggle-paused)
    (if paused?
        (unpause-world)
      (pause-world)))
  
  
  (method (toggle-evaluation)
    (set! evaluate-hook? (not evaluate-hook?))
    (display-on/off "Evaluation" evaluate-hook?))
  
  
  (method (pause-world)
    (when history?
      (set! current (snapshot-world)))
    (set! paused? #t)
    (set! animate? #f)
    (reset-counters))
  
  
  (method (unpause-world)
    (truncate-future)
    (set! current #f)
    (set! paused? #f)
    (set! animate? #t)
    (reset-counters))
  
  
  (method (snapshot-world)
    (map object-copy actors))
  
  
  (method (load-world snapshot)
    (let ((previous-target target))
      (set! actors (map object-copy snapshot))
      (set! sprites (append blocks actors))
      (set! player (find-player actors))
      (set-target (and previous-target (find-target previous-target sprites)))
      (setup-areas)
      (for-each (lambda (sprite)
                  (area-add-sprite (sprite-area sprite) sprite))
                sprites)))
  
  
  (method (find-player snapshot)
    (find-if (lambda (obj)
               (is? obj Player))
             snapshot))
  
  
  (method (find-target target snapshot)
    (let ((origin (get-origin~ target)))
      (find-if (lambda (obj)
                 (eq? (get-origin~ obj) origin))
               snapshot)))
  
  
  (method override (evaluate-hook)
    (when evaluate-hook?
      (update-future)))
  
  
  (method (test-world)
    (validate-areas))
  
  
  ;;;
  ;;;; GC
  ;;;
  
  
  (method (setup-gc)
    (add-gc-interrupt-job!
      (lambda ()
        (process~ gc-counter (last-gc-real-time)))))
  
  
  ;;;
  ;;;; Slider
  ;;;
  
  
  (slot sliding? initialize #f)
  
  
  (method (slider-mouse-down h v)
    (set! sliding? #t)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-move h v)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-up h v)
    (set! sliding? #f))
  
  
  (method (h->where h)
    (let ((cx (fxround/ width 2)))
      (let ((where (/ (+ (- h cx) 200.) 400.)))
        (max 0. (min 1. where)))))
  
  
  (method (in-slider? v)
    (< v 60))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down h v)
    (hide/preserve-cursor)
    (set! down? #t)
    (if (and history? paused? (in-slider? v))
        (slider-mouse-down h v)
      (editor-mouse-down h v)))
  
  
  (method override (mouse-move h v)
    (if (and history? paused? sliding?)
        (slider-mouse-move h v)
      (if last-point
          (begin
            (nextmethod h v)
            (unless moving?
              (follow-player)))
        (if (or adding? deleting?)
            (editor-mouse-move h v)
          (when down?
            (set! viewing? #t)
            (setup-viewing h v))))))
  
  
  (method override (mouse-track elapse dh dv)
    (if (and player moving?)
        (let ((tilt (vertical-angle (get-right~ eye-lookat) world-up)))
          ;; remove tilt
          (when (not fly?)
            @fix-me
            (rotate~ eye-lookat (- tilt) (get-sight~ eye-lookat)))
          (let ((pitch (vertical-angle (get-sight~ eye-lookat) world-up)))
            ;; remove pitch
            (when (not fly?)
              (rotate-vertical pitch))
            (when (not moved?)
              (let ((lookat (get-lookat~ player)))
                (set-sight~ lookat (get-sight~ eye-lookat))
                (set-up~ lookat (get-up~ eye-lookat))
                (set-right~ lookat (get-right~ eye-lookat)))
              (set! moved? #t))
            ;; remove tilt
            (when fly?
              @fix-me
              (rotate~ eye-lookat (- tilt) (get-sight~ eye-lookat)))
            ;; remove pitch
            (when fly?
              (rotate-vertical pitch))
            (rotate-player-horizontal (/ (- dh) 200.))
            ;; restore pitch
            (rotate-vertical (- pitch))
            (if fly?
                (rotate-player-vertical (/ (- dv) 200.))
              (rotate-vertical (/ (- dv) 200.)))
            (follow-player)
            ;; restore tilt
            @fix-me
            (rotate~ eye-lookat tilt (get-sight~ eye-lookat))
            @fix-me
            (when (and fly? (/= dh 0))
              (let ((speed (/ (cast <fl> dh) elapse)))
                (tilt-player speed)))))
      (nextmethod elapse dh dv)))
  
  
  (method override (mouse-up h v)
    (restore/show-cursor)
    (set! down? #f)
    (set! viewing? #f)
    (if (and history? paused? sliding?)
        (slider-mouse-up h v)
      (if last-point
          (begin
            (nextmethod h v)
            (follow-player))
        (editor-mouse-up h v))))
  
  
  (method override (right-mouse-down h v)
    (hide/preserve-cursor)
    (set! moving? #t)
    (set! moved? #f)
    (nextmethod h v))
  
  
  (method override (right-mouse-up h v)
    (reset-player-tilt)
    (restore/show-cursor)
    (set! moving? #f)
    (nextmethod h v))
  
  
  (method (hide/preserve-cursor)
    (hide-cursor)
    (set! preserved-mouse (mouse-position~ window)))
  
  
  (method (restore/show-cursor)
    (when preserved-mouse
      (set-mouse-position~ window preserved-mouse)
      (set! preserved-mouse #f))
    (show-cursor))
  
  
  (method override (mouse-wheel h v delta)
    (if (control-down?)
        (move-grid delta)
      (nextmethod h v delta)))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (process-keys)
    (let ((evt (make-event Keyboard-Event :char self)))
      ;; camera
      (unless (key-down? (char->integer #\space))
        (process-movement evt))
      ;; player
      (when (eq? window (get-window-focus))
        (receive (shift? control? alt?) (modifiers-down)
          (unless (or shift? control? alt?)
            (when (key-down? VK_LEFT)
              (move-left))
            (when (key-down? VK_RIGHT)
              (move-right))
            (when (key-down? VK_DOWN)
              (move-down))
            (when (key-down? VK_UP)
              (move-up))
            (when (key-down? (char->integer #\space))
              (if (and first-person? fly?)
                  (strafe-player-up)
                (space))))))))
  
  
  (method override (process-shortcut shortcut)
    (continuation-capture
      (lambda (return)
        (cond ;; window
              ((shortcut=? shortcut {Shortcut F11}) (toggle-fullscreen))
              ;; select
              ((shortcut=? shortcut {Shortcut :alt #\1}) (select-bubbles))
              ((shortcut=? shortcut {Shortcut :alt #\2}) (select-snakes))
              ((shortcut=? shortcut {Shortcut :alt #\3}) (select-tree))
              ((shortcut=? shortcut {Shortcut :alt #\4}) (select-live))
              ;; world
              ((shortcut=? shortcut {Shortcut :control #\N}) (new-world))
              ((shortcut=? shortcut {Shortcut :control #\S}) (save-world))
              ((shortcut=? shortcut {Shortcut :control #\O}) (open-world))
              ((shortcut=? shortcut {Shortcut :control :shift #\O}) (open-world reversed?: #t))
              ((shortcut=? shortcut {Shortcut :control #\R}) (revert-world))
              ((shortcut=? shortcut {Shortcut #\0}) (reset-live))
              ;; history
              ((shortcut=? shortcut {Shortcut :shift #\H}) (reset-history))
              ;; editor
              ((shortcut=? shortcut {Shortcut :control #\1}) (toggle-grid-z))
              ((shortcut=? shortcut {Shortcut :control #\2}) (toggle-grid-y))
              ((shortcut=? shortcut {Shortcut :control #\3}) (toggle-grid-x))
              ((shortcut=? shortcut {Shortcut :control Left}) (decrease-grid))
              ((shortcut=? shortcut {Shortcut :control Right}) (increase-grid))
              ((shortcut=? shortcut {Shortcut :control Tab}) (forward-sprite-class))
              ((shortcut=? shortcut {Shortcut :control :shift Tab}) (backward-sprite-class))
              ((shortcut=? shortcut {Shortcut :control #\W}) (switch-editor-mode))
              ;; debug
              ((shortcut=? shortcut {Shortcut :control #\T}) (test-world))
              (else (continuation-return return #f)))
        #t)))
  
  
  (method override (key-press key)
    (let ((evt (make-event Keyboard-Event :char self key: key)))
      (case key
        ;; editor
        ((#\backspace) (remove-target))
        ((#\g) (toggle-grid))
        ;; debug
        ((#\p #\tab) (toggle-paused))
        ((#\\) (toggle-evaluation))
        ((#\[) (backward-history))
        ((#\]) (forward-history))
        ((#\return) (step-world))
        ((#\h) (toggle-history))
        ((#\c) (clear-terminal))
        ;; projection
        ((#\1) (first-person))
        ((#\3) (toggle-3d))
        ((#\8) (toggle-eye))
        ((#\f) (toggle-fly))
        ;; camera
        ((#\2 #\9) (reset-camera))
        ((#\k) (change-first-camera))
        ;; music
        ((#\m) (change-music))
        ;; settings
        ((#\z) (toggle-interface))
        ((#\-) (toggle-counters))
        ((#\_) (reset-counters) (display-message "Counters reset"))
        ((#\=) (toggle-axes))
        ((#\i) (toggle-info))
        ((#\y) (toggle-polygon-mode))
        ((#\l) (toggle-lighting) (display-on/off "Light" light?))
        ((#\v) (toggle-projection))
        ((#\t) (toggle-textures)))))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (first-person)
    (if (not player)
        (display-error "No player")
      (if first-person?
          (set! first-person? #f)
        (set! first-person? #t)
        (set-sight~ (get-lookat~ player) (vertex 0. 0. -1.))
        (set-up~ (get-lookat~ player) (vertex 0. 1. 0.))
        (set-right~ (get-lookat~ player) (vertex 1. 0. 0.))
        (center-camera)
        (activate-3d))
      (display-on/off "First person" first-person?)))
    
  
  (method (toggle-3d)
    (if 3d?
        (deactivate-3d)
      (activate-3d))
    (display-on/off "3d" 3d?))
  
  
  (method (activate-3d)
    (set! 3d? #t)
    (set! light? #t)
    (set! projection 'perspective))
  
  
  (method (deactivate-3d)
    (set! 3d? #f)
    (set! light? #f)
    (set! projection 'orthographic))
  
  
  (method (toggle-fly)
    (set! fly? (not fly?))
    (if fly?
        (begin
          (set-y~ player (+ (get-y~ player) 2.))
          (update-position~ player))
      (rotate-player-vertical (vertical-angle (get-sight~ (get-lookat~ player)) world-up)))
    (follow-player))

  
  (method (toggle-textures)
    (set! textures? (not textures?))
    (display-on/off "Textures" textures?))
  
  
  (method (toggle-axes)
    (set-visible?~ axes (not (get-visible?~ axes))))
  
  
  (method (toggle-info)
    (set! info? (not info?)))
  
  
  (method (toggle-counters)
    (set! counters? (not counters?))
    (reset-counters))
  
  
  (method (reset-counters)
    (reset~ gc-counter)
    (reset~ tick-counter)
    (reset~ render-counter))
  
  
  (method (display-on/off title flag)
    (display-message (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method (display-message msg (color: color #f))
    (set! message msg)
    (set! message-color color)
    (set! message-time (time->seconds (current-time))))
  
  
  (method (draw-message)
    (let ((elapse (- (time->seconds (current-time)) message-time)))
      (if (> elapse 2.)
          (begin
            (set! message #f)
            (set! message-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ message-texture))
                (font {Font Heading1})
                (color (or message-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 message)
            (map-texture~ message-texture)
            (let ((w (text-width~ font message)))
              (let ((c (center w width)))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) (cast <fl> (- height 200)) 0.0)
                (textured-quad~ message-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 100.0 0.0))
                  (lambda () (glVertex3f 0.0 100.0 0.0)))
                (glPopMatrix))))))))
    
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method (display-error msg)
    (display-message msg color: {Color Red}))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method (display-status msg (color: color #f))
    (set! status msg)
    (set! status-color color)
    (set! status-time (time->seconds (current-time))))
  
  
  (method (draw-status)
    (let ((elapse (- (time->seconds (current-time)) status-time)))
      (if (> elapse 2.)
          (begin
            (set! status #f)
            (set! status-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ status-texture))
                (font {Font Heading2})
                (color (or status-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 status)
            (map-texture~ status-texture)
            (let ((w (text-width~ font status)))
              (let ((c (center w width)))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) 30.0 0.0)
                (textured-quad~ status-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 35.0 0.0))
                  (lambda () (glVertex3f 0.0 35.0 0.0)))
                (glPopMatrix))))))))
  
  
  ;;;
  ;;;; Info
  ;;;
  
  
  (method (debug-info)
    (define (present-object obj)
      (format "~{{s} #{s}}"
              (reference-name (get-name~ (class-of obj)))
              (object->serial obj)))
    
    (define (present-boolean bool)
      (if bool "true" "false"))
    
    (define (present-history)
      (define (present-coordinates obj)
        (format "{r precision: 1} {r precision: 1}" (get-x~ obj) (get-y~ obj)))
      
      `(,(format "c -> {a}" (present-coordinates player))
        ,@(loop (for n from 0 to (history-last))
                (collect
                  (let ((moment (historical-moment n)))
                    (let ((snapshot (get-snapshot~ moment))
                          (commands (get-commands~ moment)))
                      (let ((player (find-player snapshot)))
                        (format "{a} -> {a}" n (present-coordinates player)))))))))
    
    `(,(format "window: {a}" (present-object window))
      ,(format "width: {s}" width)
      ,(format "height: {s}" height)
      ""
      ,(format "self: {s}" self)
      ,(format "actors: {s}" (length actors))
      ,(format "blocks: {s}" (length blocks))
      ,(format "sprites: {s}" (length sprites))
      ""
      ,(format "history: {s}" (history-end))
      ,(format "now: {s}" now)
      ,@(if (and history? paused? (< (history-end) 5))
            (present-history)
          '())
      ""
      ,(format "projection: {s}" projection)
      ,(format "eye: {s}" eye)
      ,(format "eye-lookat: {s}" eye-lookat)
      ,(format "eye-target: {s}" eye-target)
      ,(format "camera-distance: {s}" camera-distance)
      ,(format "zoom-factor: {s}" zoom-factor)
      ,(format "first-distance: {s}" first-distance)
      ,(format "first-camera: {s}" first-camera)
      ,(format "desired-tilt: {s}" desired-tilt)
      ""
      ,@(if information
            `(,@information
              "")
          '())
      ,@(if player
            `(,(format "player: {a}" (present-object player))
              ,(format "  x: {r precision: 1}" (get-x~ player))
              ,(format "  y: {r precision: 1}" (get-y~ player))
              ,(format "  z: {r precision: 1}" (get-z~ player))
              ,(format "  width: {s}" (get-width~ player))
              ,(format "  height: {s}" (get-height~ player))
              ,(format "  depth: {s}" (get-depth~ player))
              ,(format "  texture: {s}" (get-texture~ player))
              ,(format "  color: {s}" (get-color~ player))
              ,(format "  user-data: {s}" (get-user-data~ player))
              ,(format "  vx: {s}" (get-vx~ player))
              ,(format "  vy: {s}" (get-vy~ player))
              ,(format "  vz: {s}" (get-vz~ player))
              ,(format "  lookat: {s}" (get-lookat~ player))
              ,(format "  jumping?: {a}" (present-boolean (get-jumping?~ player)))
              ,(format "  facing: {s}" (get-facing~ player))
              ,(format "  state: {s}" (get-state~ player))
              "")
          '())
      ,@(if target
            `(,(format "target: {a}" (present-object target))
              ,(format "  x: {r precision: 1}" (get-x~ target))
              ,(format "  y: {r precision: 1}" (get-y~ target))
              ,(format "  z: {r precision: 1}" (get-z~ target))
              ,(format "  width: {s}" (get-width~ target))
              ,(format "  height: {s}" (get-height~ target))
              ,(format "  depth: {s}" (get-depth~ target))
              ,(format "  texture: {s}" (get-texture~ target))
              ,(format "  color: {s}" (get-color~ target))
              ,(format "  user-data: {s}" (get-user-data~ target))
              "")
          '())
      ,(format "editor-mode: {a}" (capitalize (->string editor-mode)))
      ,(format "animate?: {a}" (present-boolean animate?))
      ,(format "light?: {a}" (present-boolean light?))
      ,(format "music?: {a}" (present-boolean music?))
      ,(format "3d?: {a}" (present-boolean 3d?))
      ,(format "fly?: {a}" (present-boolean fly?))
      ,(format "first-person?: {a}" (present-boolean first-person?))
      ,(format "textures?: {a}" (present-boolean textures?))
      ,(format "paused?: {a}" (present-boolean paused?))
      ""
      ,(format "gc-count: {a}" (gc-count))))
  
  
  (method (reset-information)
    (set! information #f))
  
  
  (method (set-information info)
    (set! information (map ->string info)))
  
  
  (method (add-information info)
    (set! information (append (or information '()) (list (->string info))))))


;;;
;;;; Info
;;;


(class Info extends World-Object
  
  
  (slot texture <object> getter generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! texture (make-cairo-texture 500 800)))
  
  
  (method override (draw)
    (let ((surface (get-surface~ texture)))
      (set-operator~ surface CAIRO_OPERATOR_CLEAR)
      (paint~ surface)
      (set-operator~ surface CAIRO_OPERATOR_OVER)
      (set-font~ surface {Font font-name: "Courier New" point-size: 10 antialias: none})
      (set-color~ surface {Color Red})
      (let ((rank 0))
        (for-each (lambda (info)
                    (draw-text~ surface 10 (+ 10 (* rank 15)) (->string info))
                    (increase! rank))
                  (debug-info~ world)))
      (map-texture~ texture)
      (glPushMatrix)
      (glTranslatef 0.0 (cast <fl> (- (get-height~ world) 800.0)) 0.0)
      (textured-quad~ texture
        (lambda () (glVertex3f 0.0 0.0 0.0))
        (lambda () (glVertex3f 500.0 0.0 0.0))
        (lambda () (glVertex3f 500.0 800.0 0.0))
        (lambda () (glVertex3f 0.0 800.0 0.0)))
      (glPopMatrix))))


;;;
;;;; Counter
;;;


(class Counter extends World-Object
  
  
  (slot texture     <object> getter generate)
  (slot origin      <fl>     getter generate)
  (slot count       <number> getter generate)
  (slot elapse      <fl>     getter generate)
  (slot rate        <fl+>    getter generate)
  (slot max-rate    <fl+>    getter generate)
  (slot max-percent <fl+>    getter generate)
  (slot started     <fl>     getter generate)
  (slot title       <string> getter generate)
  (slot vert        <fl>     getter generate)
  
  
  (method override (initialize world x y z t v)
    (nextmethod world x y z)
    (set! texture (make-cairo-texture 300 35))
    (set! rate #f)
    (set! max-percent #f)
    (set! title t)
    (set! vert v)
    (reset))
  
  
  (method (reset)
    (set! origin (time->seconds (current-time)))
    (set! count 0)
    (set! elapse 0.))
  
  
  (method (start)
    (set! started (time->seconds (current-time))))
  
  
  (method (end)
    (process (- (time->seconds (current-time)) started)))
  
  
  (method (process duration)
    (increase! count)
    (let ((now (time->seconds (current-time))))
      (increase! elapse duration)
      (let ((total (- now origin)))
        (set! rate (/ count total))
        (set! max-rate (/ count elapse))
        (set! max-percent (percentage elapse total)))))
  
  
  (method (draw-rate (period? #f))
    (let ((surface (get-surface~ texture)))
      (set-operator~ surface CAIRO_OPERATOR_CLEAR)
      (paint~ surface)
      (set-operator~ surface CAIRO_OPERATOR_OVER)
      (set-font~ surface {Font Heading2})
      (set-color~ surface {Color Red})
      (draw-text~ surface 0 10 (format "{a}: {a}"
                                       title
                                       (cond ((not rate) "unavailable")
                                             ((not period?) (format "{r precision: 0}/s, {r precision: 0}% of {r precision: 0}/s" rate max-percent max-rate))
                                             (else (format "{r precision: 1}s" (/ rate))))))
      (map-texture~ texture)
      (glPushMatrix)
      (glTranslatef 10.0 vert 0.0)
      (textured-quad~ texture
        (lambda () (glVertex3f 0.0 0.0 0.0))
        (lambda () (glVertex3f 300.0 0.0 0.0))
        (lambda () (glVertex3f 300.0 35.0 0.0))
        (lambda () (glVertex3f 0.0 35.0 0.0)))
      (glPopMatrix)))))
