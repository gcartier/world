;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Live
;;;


(module world.client.live jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl)
        (jazz.graphic.opengl.platform)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world)
        (world.client)
        (world.geometry)
        (world.object)
        (world.texture)
        (world.window))


;; TODO
;; - Relate orthographic and perspective zooming
;; - World editor
;;   - Load / Save
;; - Character as a sphere!?
;;   - Add blinking eyes showing the direction!?
;; - Implement fullscreen
;; - Port to other platforms
;;   - Can glut be used without any sacrifice?
;; - Port to mobiles
;;   - Be wary of Cairo uses
;;   - Be extra wary of Jazz UI uses


;;;
;;;; Sprite
;;;


(class Sprite extends World-Object
  
  
  (slot width     getter generate)
  (slot height    getter generate)
  (slot depth     getter generate)
  (slot texture   accessors generate)
  (slot color     accessors generate)
  (slot user-data accessors generate)
  
  
  (method override (initialize world x y z width height depth texture (color: color #f) (user-data: user-data #f))
    (nextmethod world x y z)
    (set! width~self width)
    (set! height~self height)
    (set! depth~self depth)
    (set! texture~self texture)
    (set! color~self color)
    (set! user-data~self user-data))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{r precision: 1} {r precision: 1} {a} {a}" x y width height))))
  
  
  (method public (get-left)
    x)
  
  
  (method public (get-right)
    (+ x width))
  
  
  (method public (get-bottom)
    y)
  
  
  (method public (get-top)
    (+ y height))
  
  
  (method public (get-far)
    z)
  
  
  (method public (get-near)
    (+ z depth))
  
  
  (method override (draw)
    (if (get-3d?~ world)
        (if (get-textures?~ world)
            (draw-3d-textured)
          (draw-3d))
      (if (get-textures?~ world)
          (draw-2d-textured)
        (draw-2d))))
  
  
  ;; from Cube
  (method (draw-3d)
    (with-gl-matrix
      (lambda ()
        (gl-rotate rtri 1.0 1.0 1.0)
        (gl-scale 1.0 1.0 1.0)
        (gl-set-color color)
        (let ((scale 1.))
        (let ((x1 (* scale (get-left)))
              (x2 (* scale (get-right)))
              (y1 (* scale (get-bottom)))
              (y2 (* scale (get-top)))
              (z1 (* scale (get-far)))
              (z2 (* scale (get-near))))
          ;; top
          (gl-normal 0.0 1.0 0.0)
          (with-gl-begin/end GL_QUADS
            (lambda ()
              (gl-vertex x2 y2 z1)
              (gl-vertex x1 y2 z1)
              (gl-vertex x1 y2 z2)
              (gl-vertex x2 y2 z2)))
          ;; bottom
          (gl-normal 0.0 -1.0 0.0)
          (with-gl-begin/end GL_QUADS
            (lambda ()
              (gl-vertex x2 y1 z2)
              (gl-vertex x1 y1 z2)
              (gl-vertex x1 y1 z1)
              (gl-vertex x2 y1 z1)))
          ;; front
          (gl-normal 0.0 0.0 1.0)
          (with-gl-begin/end GL_QUADS
            (lambda ()
              (gl-vertex x1 y1 z2)
              (gl-vertex x2 y1 z2)
              (gl-vertex x2 y2 z2)
              (gl-vertex x1 y2 z2)))
          ;; back
          (gl-normal 0.0 0.0 -1.0)
          (with-gl-begin/end GL_QUADS
            (lambda ()
              (gl-vertex x2 y1 z1)
              (gl-vertex x1 y1 z1)
              (gl-vertex x1 y2 z1)
              (gl-vertex x2 y2 z1)))
          ;; left
          (gl-normal -1.0 0.0 0.0)
          (with-gl-begin/end GL_QUADS
            (lambda ()
              (gl-vertex x1 y2 z2)
              (gl-vertex x1 y2 z1)
              (gl-vertex x1 y1 z1)
              (gl-vertex x1 y1 z2)))
          ;; right
          (gl-normal 1.0 0.0 0.0)
          (with-gl-begin/end GL_QUADS
            (lambda ()
              (gl-vertex x2 y2 z1)
              (gl-vertex x2 y2 z2)
              (gl-vertex x2 y1 z2)
              (gl-vertex x2 y1 z1)))))))
    @rotate
    (when (get-animate?~ world)
      (increase! rtri 0.4)
      (decrease! rquad 0.3)))
  
  
  ;; from Cube
  (method (draw-3d-textured)
    (with-gl-matrix
      (lambda ()
        (gl-translate x y z)
        (gl-rotate rtri 1.0 1.0 1.0)
        (gl-scale 1.0 1.0 1.0)
        (let ((f -2.5)
              (t 2.5))
          ;; top
          (gl-normal 0.0 1.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t t f))
            (lambda () (gl-vertex f t f))
            (lambda () (gl-vertex f t t))
            (lambda () (gl-vertex t t t)))
          ;; bottom
          (gl-normal 0.0 -1.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t f t))
            (lambda () (gl-vertex f f t))
            (lambda () (gl-vertex f f f))
            (lambda () (gl-vertex t f f)))
          ;; front
          (gl-normal 0.0 0.0 1.0)
          (textured-quad~ texture
            (lambda () (gl-vertex f f t))
            (lambda () (gl-vertex t f t))
            (lambda () (gl-vertex t t t))
            (lambda () (gl-vertex f t t)))
          ;; back
          (gl-normal 0.0 0.0 -1.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t f f))
            (lambda () (gl-vertex f f f))
            (lambda () (gl-vertex f t f))
            (lambda () (gl-vertex t t f)))
          ;; left
          (gl-normal -1.0 0.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex f t t))
            (lambda () (gl-vertex f t f))
            (lambda () (gl-vertex f f f))
            (lambda () (gl-vertex f f t)))
          ;; right
          (gl-normal 1.0 0.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t t f))
            (lambda () (gl-vertex t t t))
            (lambda () (gl-vertex t f t))
            (lambda () (gl-vertex t f f))))))
    @rotate
    (when (get-animate?~ world)
      (increase! rtri 0.4)
      (decrease! rquad 0.3)))
  
  
  (method (draw-2d)
    (let ((x1 (get-left))
          (y1 (get-top))
          (x2 (get-right))
          (y2 (get-bottom)))
      (gl-normal 0.0 0.0 1.0)
      (gl-set-color color)
      (with-gl-begin/end GL_QUADS
        (lambda ()
          (gl-vertex2f x1 y1)
          (gl-vertex2f x2 y1)
          (gl-vertex2f x2 y2)
          (gl-vertex2f x1 y2)))
      (gl-set-color {Color red: 105 green: 61 blue: 1})
      (with-gl-begin/end GL_LINE_LOOP
        (lambda ()
          (gl-vertex2f x1 y1)
          (gl-vertex2f x2 y1)
          (gl-vertex2f x2 y2)
          (gl-vertex2f x1 y2)))))
  
  
  (method (draw-2d-textured)
    (with-gl-matrix
      (lambda ()
        (gl-translate x y z)
        (textured-quad~ texture
          (lambda () (gl-vertex 0.0 0.0 0.0))
          (lambda () (gl-vertex width 0.0 0.0))
          (lambda () (gl-vertex width height 0.0))
          (lambda () (gl-vertex 0.0 height 0.0))))))
  
  
  @w
  (method (draw-2d-textured)
    (with-gl-matrix
      (lambda ()
        (gl-translate x y z)
        (textured-quad~ texture
          (lambda () (gl-vertex 0.0 0.0 0.0))
          (lambda () (gl-vertex 5.0 0.0 0.0))
          (lambda () (gl-vertex 5.0 5.0 0.0))
          (lambda () (gl-vertex 0.0 5.0 0.0)))))))


;;;
;;;; Actor
;;;


(definition gravity
  .09)


(definition turtle-speed
  .1)


(definition character-speed
  .5)

(definition jump-impulsion
  2.0)

(definition max-vy
  -.8)


(class Actor extends Sprite)


;;;
;;;; Turtle
;;;


(class Turtle extends Actor
  
  
  (slot vx initialize 0. accessors generate)
  (slot vy initialize 0. accessors generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! vx turtle-speed))
  
  
  (method override (tick)
    (define (character-hit obj)
      (when (eq? obj (get-character~ world))
        (lose~ world)))
    
    (let ((old-x x)
          (old-y y))
      (increase! x vx)
      (increase! y vy)
      (when (< y 0.)
        (set! y 0.))
      (decrease! vy gravity)
      (when (< vy -1.0)
        (set! vy -1.))
      (receive (hit-x hit-y) (hit-test~ world self old-x old-y x y width height)
        (when hit-x
          (bind (obj direction border reset) hit-x
            (character-hit obj)
            (set! x reset)
            (if (= direction -1)
                (set! vx .1)
              (set! vx -.1))))
        (when hit-y
          (bind (obj direction border reset) hit-y
            (character-hit obj)
            (set! y reset)))))))


;;;
;;;; Character
;;;


(class Character extends Actor
  
  
  (slot vx       initialize 0.    accessors generate)
  (slot vy       initialize 0.    accessors generate)
  (slot left?    initialize #f    accessors generate)
  (slot right?   initialize #f    accessors generate)
  (slot jump?    initialize #f    accessors generate)
  (slot jumping? initialize #f    accessors generate)
  (slot facing   initialize 'left accessors generate)
  
  
  (method override (tick)
    (define (win-hit obj)
      (when (eq? (get-user-data~ obj) 'win)
        (win~ world)))
    
    (let ((old-x x)
          (old-y y)
          (moving? #f))
      (when left?
        (set! left? #f)
        (set! moving? #t)
        (decrease! x character-speed))
      (when right?
        (set! right? #f)
        (set! moving? #t)
        (increase! x character-speed))
      (when jump?
        (set! jump? #f)
        (when (not jumping?)
          (set! jumping? #t)
          (set! vy jump-impulsion)))
      
      (increase! x vx)
      (increase! y vy)
      (decrease! vy gravity)
      (when (< vy max-vy)
        (set! vy max-vy))
      (receive (hit-x hit-y) (hit-test~ world self old-x old-y x y width height)
        (when hit-x
          (bind (obj direction border reset) hit-x
            (win-hit obj)
            (set! x reset)))
        (when hit-y
          (bind (obj direction border reset) hit-y
            (win-hit obj)
            (set! y reset)
            (set! vy 0.)
            (when (= direction -1)
              (set! jumping? #f)))))
      (when (< y -6.)
        (lose~ world))
      (when moving?
        (let ((eye-x (get-x~ (get-eye~ world)))
              (center-x (/ (+ (get-left) (get-right)) 2))
              (limit 2.))
          (if (> center-x (+ eye-x limit))
              (strafe-horizontally~ world (- center-x (+ eye-x limit))))
          (if (< center-x (- eye-x limit))
              (strafe-horizontally~ world (- center-x (- eye-x limit))))))))
  
  
  (method (move-left)
    (set! left? #t))
  
  
  (method (move-right)
    (set! right? #t))
  
  
  (method (move-down)
    )
  
  
  (method (move-up)
    )
  
  
  (method (space)
    (set! jump? #t))
  
  
  (method (lose)
    (set! jumping? #f)
    (set! x (get-start-x~ world))
    (set! y (get-start-y~ world))))


;;;
;;;; World
;;;


(class Live-World extends World
  
  
  (slot character  initialize #f            getter generate)
  (slot projection initialize 'orthographic getter generate)
  (slot zoom-factor                         getter generate)
  (slot 3d?        initialize #f            getter generate)
  (slot textures?  initialize #f            getter generate)
  
  (slot pulse)
  (slot paused?    initialize #f)
  (slot info)
  (slot axes)
  (slot start-x    initialize #f            getter generate)
  (slot start-y    initialize #f            getter generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (initialize-opengl)
    (nextmethod)
    (set! light? #f)
    (initialize-camera)
    (prepare-tick))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method override (initialize-world)
    (nextmethod)
    (let ((resources-dir (new Directory (tokenise-filename (repository-pathname (find-repository 'World) "world.client/resources")))))
      (set! axes (add-axes visible?: #f))
      (set! info (new Info-Object self -10.0 0.0 0.0 visible?: #f))
      (set! start-x -10.0)
      (set! start-y 60.0)
      (set! character (add-object (new Character self start-x start-y 5.0 2.5 4. 4.0 (make-png-texture (new-file~ resources-dir "player/Idle.png")) color: {Color red: 173 green: 12 blue: 230})))
      (add-object (new Turtle self 0.0 20.0 5.0 2. 2. 2.0 (make-png-texture (new-file~ resources-dir "player/Idle.png")) color: {Color Green}))
      (loop (for n from -6 to 6)
            (add-object (new Sprite self (cast <fl> (* n 5)) 30.0 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1})))
      (loop (for n from 0 to 6)
            (add-object (new Sprite self (cast <fl> (* n 5)) 50.0 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1})))
      (loop (for n from -2 to 2)
            (add-object (new Sprite self (cast <fl> (* n 5)) 15.0 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1})))
      (loop (for n from 0 to 11)
            (add-object (new Sprite self -40. (cast <fl> (* n 5)) 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1})))
      (loop (for n from 12 to 16)
            (add-object (new Sprite self -40. (cast <fl> (* n 5)) 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color Purple})))
      (add-object (new Sprite self -10. 20.0 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color Light-Purple} user-data: 'win))
      (add-object (new Sprite self 10. 20.0 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1}))
      (add-object (new Sprite self 20.  4.0 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1}))
      (add-object (new Sprite self 28. 10.0 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1}))
      (add-object (new Sprite self 19.5 17.0 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1}))
      (loop (for n from -2 to 2)
            (add-object (new Sprite self (cast <fl> (* n 5)) 0.0 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1})))
      @w
      (add-object (new Sprite self -50.0 -30.0 -5.0 100. 100. .1 (make-png-texture (new-file~ resources-dir "background/Layer0_0.png")) color: {Color Light-Blue}))))
  
  
  (method (iterate-sprites proc)
    (for-each (lambda (obj)
                (when (is? obj Sprite)
                  (proc obj)))
              objects))
  
  
  ;;;
  ;;;; Settings
  ;;;
    
  
  (method (toggle-3d)
    (set! 3d? (not 3d?))
    (set! light? 3d?)
    (set! projection (if 3d? 'perspective 'orthographic)))

  
  (method (toggle-textures)
    (set! textures? (not textures?)))
  
  
  (method (toggle-paused)
    (set! paused? (not paused?))
    (set! animate? (not paused?)))
  
  
  (method (toggle-info)
    (set-visible?~ info (not (get-visible?~ info))))
  
  
  (method (toggle-axes)
    (set-visible?~ axes (not (get-visible?~ axes))))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (prepare-tick)
    (set! pulse (new Pulse 'tick .01 tick-world)))
  
  
  (method (tick-world)
    (unless paused?
      (iterate-sprites
        tick~)))
  
  
  (method (move-left)
    (move-left~ character))
  
  
  (method (move-right)
    (move-right~ character))
  
  
  (method (move-down)
    (move-down~ character))
  
  
  (method (move-up)
    (move-up~ character))
  
  
  (method (space)
    (space~ character))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method (hit-test object from-left from-bottom to-left to-bottom width height)
    (let ((dx (sign (- to-left from-left)))
          (dy (sign (- to-bottom from-bottom)))
          (from-right (+ from-left width))
          (from-top (+ from-bottom height))
          (to-right (+ to-left width))
          (to-top (+ to-bottom height)))
      (let ((hit-x
              (case dx
                ;; going right
                ((1)
                 (continuation-capture
                   (lambda (return)
                     (iterate-sprites
                       (lambda (obj)
                         (let ((bottom (get-bottom~ obj))
                               (top (get-top~ obj))
                               (border (get-left~ obj)))
                           (when (and (not (or (<= from-top bottom)
                                               (>= from-bottom top)))
                                      (<= from-right border)
                                      (> to-right border))
                             (continuation-return return (list obj dx border (- border width)))))))
                     #f)))
                ;; going left
                ((-1)
                 (continuation-capture
                   (lambda (return)
                     (iterate-sprites
                       (lambda (obj)
                         (let ((bottom (get-bottom~ obj))
                               (top (get-top~ obj))
                               (border (get-right~ obj)))
                           (when (and (not (or (<= from-top bottom)
                                               (>= from-bottom top)))
                                      (>= from-left border)
                                      (< to-left border))
                             (continuation-return return (list obj dx border border))))))
                     #f)))
                (else
                 #f)))
            (hit-y
              (case dy
                ;; going up
                ((1)
                 (continuation-capture
                   (lambda (return)
                     (iterate-sprites
                       (lambda (obj)
                         (let ((left (get-left~ obj))
                               (right (get-right~ obj))
                               (border (get-bottom~ obj)))
                           (when (and (not (or (<= from-right left)
                                               (>= from-left right)))
                                      (<= from-top border)
                                      (> to-top border))
                             (continuation-return return (list obj dy border (- border height)))))))
                     #f)))
                ;; going down
                ((-1)
                 (continuation-capture
                   (lambda (return)
                     (iterate-sprites
                       (lambda (obj)
                         (let ((left (get-left~ obj))
                               (right (get-right~ obj))
                               (border (get-top~ obj)))
                           (when (and (not (or (<= from-right left)
                                               (>= from-left right)))
                                      (>= from-bottom border)
                                      (< to-bottom border))
                             (continuation-return return (list obj dy border border))))))
                     #f)))
                (else
                 #f))))
        (values hit-x hit-y))))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method override (movement-speed)
    0.25)
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method (initialize-camera)
    (set! zoom-factor 54.5)
    (prepare-camera)
    (reset-camera))
  
  
  (method override (prepare-camera)
    (set! eye (new Vertex 0.0 36.25 40.0))
    (set! eye-sight (new Vertex 0.0 0.0 -1.0))
    (set! right (new Vertex 1.0 0.0 0.0))
    (set! up (new Vertex 0.0 1.0 0.0)))

  
  (method override (zoom-in)
    (if (eq? projection 'perspective)
        (nextmethod)
      (set! zoom-factor (* zoom-factor .75))))
  
  
  (method override (zoom-out)
    (if (eq? projection 'perspective)
        (nextmethod)
      (set! zoom-factor (/ zoom-factor .75))))
  
  
  (method override (zoom-speed)
    10.)
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method override (prepare-projection)
    (let ((ratio (/ (cast <fl> width) (cast <fl> height))))
      (gl-matrix-mode GL_PROJECTION)
      (gl-load-identity)
      (case projection
        ((perspective)
         (glu-perspective 45.0 ratio 0.1 1000.0))
        ((orthographic)
         (let ((cx -0.)
               (cy -0.)
               (w zoom-factor))
           (let ((h (/ w ratio)))
             (gl-ortho (- cx w) (+ cx w) (- cy h) (+ cy h) -50.0 50.0)))))))
  
  
  (method (toggle-projection)
    (set! projection
          (case projection
            ((perspective) 'orthographic)
            ((orthographic) 'perspective))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-objects)
    (case projection
      ((perspective)
       (if 3d?
           (gl-enable GL_DEPTH_TEST)
         (gl-disable GL_DEPTH_TEST)))
      ((orthographic)
       (gl-disable GL_DEPTH_TEST)))
    (nextmethod)
    (when target
      (let ((x1 (get-left~ target))
            (y1 (get-top~ target))
            (x2 (get-right~ target))
            (y2 (get-bottom~ target)))
        (gl-normal 0.0 0.0 1.0)
        (gl-set-color {Color Red})
        (with-gl-begin/end GL_LINE_LOOP
          (lambda ()
            (gl-vertex2f x1 y1)
            (gl-vertex2f x2 y1)
            (gl-vertex2f x2 y2)
            (gl-vertex2f x1 y2))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method override (draw-interface)
    (nextmethod)
    (when (get-visible?~ info)
      (draw~ info)))
  
  
  ;;;
  ;;;; Win / Lose
  ;;;
  
  
  (method (win)
    (let ((block (find-if (lambda (obj)
                            (eq? (get-user-data~ obj) 'win))
                          objects)))
      (set-color~ block {Color Blue})))
  
  
  (method (lose)
    (sleep .5)
    (lose~ character))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (slot down?   initialize #f)
  (slot delete? initialize #f)
  
  
  (method (find-block x y)
    (continuation-capture
      (lambda (return)
        (iterate-sprites
          (lambda (obj)
            (let ((left (get-left~ obj))
                  (right (get-right~ obj))
                  (bottom (get-bottom~ obj))
                  (top (get-top~ obj)))
              (when (and (>= x left)
                         (>= y bottom)
                         (<  x right)
                         (<  y top))
                (continuation-return return obj)))))
        #f)))
  
  
  (method (screen->world h v)
    (let ((x (+ (/ (- h (fxfloor/ width 2)) 11.) (get-x~ eye)))
          (y (/ (- height v) 11.)))
      (values x y)))
  
  
  (method (add-block class x y)
    (let ((x (* (floor (/ x 5.)) 5.))
          (y (* (floor (/ y 5.)) 5.)))
      (let ((resources-dir (new Directory (tokenise-filename (repository-pathname (find-repository 'World) "world.client/resources")))))
        (case class
          ((character)
           (set! character (add-object (new Character self x y 5.0 2.5 4. 5.0 (make-png-texture (new-file~ resources-dir "player/Idle.png")) color: {Color red: 173 green: 12 blue: 230}))))
          ((turtle)
           (add-object (new Turtle self x y 5.0 2. 2. 2. (make-png-texture (new-file~ resources-dir "player/Idle.png")) color: {Color Green})))
          ((block)
           (add-object (new Sprite self x y 5.0 5.0 5.0 5.0 (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")) color: {Color red: 134 green: 82 blue: 1})))))))
  
  
  (method (sprite-class)
    (cond ((and (control-down?) (alt-down?)) 'character)
          ((control-down?) 'turtle)
          (else 'block)))
  
  
  (method override (mouse-down h v)
    (receive (x y) (screen->world h v)
      (let ((obj (find-block x y)))
        (if obj
            (if (shift-down?)
                (begin
                  (delete-object obj)
                  (set! down? #t)
                  (set! delete? #t))
              (set! target obj))
          (set! down? #t)
          (let ((class (sprite-class)))
            (add-block class x y))))))
  
  
  (method override (mouse-move h v)
    (if last-point
        (nextmethod h v)
      (when down?
        (receive (x y) (screen->world h v)
          (let ((obj (find-block x y)))
            (if obj
                (when delete?
                  (delete-object obj))
              (unless delete?
                (let ((class (sprite-class)))
                  (add-block class x y)))))))))
  
  
  (method override (mouse-up h v)
    (set! down? #f)
    (set! delete? #f))
  
  
  (method override (process-keys)
    (unless (key-down? (char->integer #\space))
      (process-movement))
    (when (eq? window (get-window-focus))
      (receive (shift? control? alt?) (modifiers-down)
        (when (key-down? VK_LEFT)
          (move-left))
        (when (key-down? VK_RIGHT)
          (move-right))
        (when (key-down? VK_DOWN)
          (move-down))
        (when (key-down? VK_UP)
          (space~ character)
          @w
          (move-up))
        (when (key-down? (char->integer #\space))
          (space)))))
  
  
  (method (new-world)
    (set! objects '())
    (set! target #f))
  
  
  (method (save-world)
    (call-with-output-file (path-settings {File Home ".world" "test.wrl"})
      (lambda (output)
        (iterate-sprites
          (lambda (obj)
            (let ((class (cond ((eq? (class-of obj) Character) 'character)
                               ((eq? (class-of obj) Turtle) 'turtle)
                               (else 'block))))
              (format output "{s}{%}" (list class (get-x~ obj) (get-y~ obj)))))))))
  
  
  (method (open-world)
    (set! objects '())
    (call-with-input-file (path-settings {File Home ".world" "test.wrl"})
      (lambda (input)
        (let (iter)
          (let ((info (read input)))
            (when (not (eof-object? info))
              (bind (class x y) info
                (when (eq? class 'character)
                  (set! start-x x)
                  (set! start-y y))
                (add-block class x y)
                (iter))))))))
  
  
  (method override (key-press c)
    (case c
      ((#\backspace) (delete-target))
      ((#\n) (new-world))
      ((#\s) (save-world))
      ((#\o) (open-world))
      ((#\0) (reset-world))
      ((#\1) (initialize-camera))
      ((#\3) (toggle-3d))
      ((#\b) (select-bubbles))
      ((#\B) (select-bubbles #t))
      ((#\k) (select-snakes))
      ((#\K) (select-snakes #t))
      ((#\m) (change-music))
      ((#\r) (reset-camera))
      ((#\z) (toggle-interface))
      ((#\-) (toggle-fps))
      ((#\=) (toggle-axes))
      ((#\i) (toggle-info))
      ((#\h) (toggle-polygon-mode))
      ((#\l) (toggle-lighting))
      ((#\p) (toggle-paused))
      ((#\f) (toggle-fullscreen))
      ((#\v) (toggle-projection))
      ((#\t) (toggle-textures))))
  
  
  (method (delete-target)
    (if (not target)
        (bell)
      (delete-object target)))
  
  
  (method (delete-object obj)
    (set! objects (remove! obj objects))
    (set! target #f))
  
  
  ;;;
  ;;;; Info
  ;;;
  
  
  (method (debug-info)
    (define (present-object obj)
      (format "~{{s} #{s}}"
              (reference-name (get-name~ (class-of obj)))
              (object->serial obj)))
    
    (define (present-boolean bool)
      (if bool "true" "false"))
    
    `(,(format "self: {s}" self)
      ""
      ,(format "window: {a}" (present-object window))
      ,(format "width: {s}" width)
      ,(format "height: {s}" height)
      ""
      ,(format "projection: {s}" projection)
      ,(format "eye: {s}" eye)
      ,(format "eye-sight: {s}" eye-sight)
      ,(format "center: {s}" center)
      ,(format "right: {s}" right)
      ,(format "up: {s}" up)
      ,(format "camera-distance: {s}" camera-distance)
      ,(format "zoom-factor: {s}" zoom-factor)
      ""
      ,(format "character: {a}" (present-object character))
      ,(format "  x: {r precision: 1}" (get-x~ character))
      ,(format "  y: {r precision: 1}" (get-y~ character))
      ,(format "  z: {r precision: 1}" (get-z~ character))
      ,(format "  width: {s}" (get-width~ character))
      ,(format "  height: {s}" (get-height~ character))
      ,(format "  depth: {s}" (get-depth~ character))
      ,(format "  texture: {s}" (get-texture~ character))
      ,(format "  color: {s}" (get-color~ character))
      ,(format "  user-data: {s}" (get-user-data~ character))
      ,(format "  vx: {s}" (get-vx~ character))
      ,(format "  left?: {a}" (present-boolean (get-left?~ character)))
      ,(format "  right?: {a}" (present-boolean (get-right?~ character)))
      ,(format "  jump?: {a}" (present-boolean (get-jump?~ character)))
      ,(format "  jumping?: {a}" (present-boolean (get-jumping?~ character)))
      ,(format "  facing: {s}" (get-facing~ character))
      ""
      ,@(if target
            `(,(format "target: {a}" (present-object target))
              ,(format "  x: {r precision: 1}" (get-x~ target))
              ,(format "  y: {r precision: 1}" (get-y~ target))
              ,(format "  z: {r precision: 1}" (get-z~ target))
              ,(format "  width: {s}" (get-width~ target))
              ,(format "  height: {s}" (get-height~ target))
              ,(format "  depth: {s}" (get-depth~ target))
              ,(format "  texture: {s}" (get-texture~ target))
              ,(format "  color: {s}" (get-color~ target))
              ,(format "  user-data: {s}" (get-user-data~ target))
              "")
          '())
      ,(format "objects: {s}" (length objects))
      ,(format "animate?: {a}" (present-boolean animate?))
      ,(format "light?: {a}" (present-boolean light?))
      ,(format "music?: {a}" (present-boolean music?))
      ,(format "3d?: {a}" (present-boolean 3d?))
      ,(format "textures?: {a}" (present-boolean textures?))
      ,(format "paused?: {a}" (present-boolean paused?)))))


;;;
;;;; Info
;;;


(class Info-Object extends World-Object
  
  
  (slot texture)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! texture (make-cairo-texture 500 800)))
  
  
  (method override (draw)
    (let ((surface (get-surface~ texture)))
      (set-operator~ surface CAIRO_OPERATOR_CLEAR)
      (paint~ surface)
      (set-operator~ surface CAIRO_OPERATOR_OVER)
      (set-font~ surface {Font font-name: "Courier New" point-size: 10 antialias: none})
      (set-color~ surface {Color Red})
      (let ((rank 0))
        (for-each (lambda (info)
                    (draw-text~ surface 10 (+ 10 (* rank 15)) (->string info))
                    (increase! rank))
                  (debug-info~ world)))
      (map-texture~ texture)
      (with-gl-matrix
        (lambda ()
          (gl-translate 0.0 0.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex 0.0 0.0 0.0))
            (lambda () (gl-vertex 500.0 0.0 0.0))
            (lambda () (gl-vertex 500.0 800.0 0.0))
            (lambda () (gl-vertex 0.0 800.0 0.0)))))))))
