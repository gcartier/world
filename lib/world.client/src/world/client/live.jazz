;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Live
;;;


(module world.client.live jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl)
        (jazz.graphic.opengl.platform)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world.autoload)
        (world.client)
        (world.geometry)
        (world.object)
        (world.texture)
        (world.window))


;;;
;;;; Parameters
;;;


(definition in-history?
  (make-parameter #f))


;;;
;;;; Sprite
;;;


(class Sprite extends World-Object
  
  
  (slot origin    <object> getter generate)
  (slot width     <fl>     getter generate)
  (slot height    <fl>     getter generate)
  (slot depth     <fl>     getter generate)
  (slot right     <fl>     getter generate)
  (slot top       <fl>     getter generate)
  (slot near      <fl>     getter generate)
  (slot radius-x  <fl>     getter generate)
  (slot radius-y  <fl>     getter generate)
  (slot radius-z  <fl>     getter generate)
  (slot center-x  <fl>     getter generate)
  (slot center-y  <fl>     getter generate)
  (slot center-z  <fl>     getter generate)
  (slot texture   <object> accessors generate)
  (slot color     <object> getter generate)
  (slot red       <fl>     getter generate)
  (slot green     <fl>     getter generate)
  (slot blue      <fl>     getter generate)
  (slot user-data <object> accessors generate)
  
  
  (method override (initialize world x y z width height depth texture (color: color #f) (user-data: user-data #f))
    (nextmethod world x y z)
    (set! origin~self self)
    (set! width~self width)
    (set! height~self height)
    (set! depth~self depth)
    (set! radius-x (/ width 2))
    (set! radius-y (/ height 2))
    (set! radius-z (/ depth 2))
    (set! texture~self texture)
    (set! color~self color)
    (set! user-data~self user-data)
    (update)
    (update-color))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{r precision: 1} {r precision: 1} {r precision: 1} {a} {a} {a}" x y z width height depth))))
  
  
  (method public inline (get-left) <fl>
    x)
  
  
  (method public inline (get-bottom) <fl>
    y)
  
  
  (method public inline (get-far) <fl>
    z)
  
  
  (method public (get-center) <Vertex>
    (new Vertex
      (get-center-x)
      (get-center-y)
      (get-center-z)))
  
  
  (method public (set-position v <Vertex>) <void>
    (set! x (get-x~ v))
    (set! y (get-y~ v))
    (set! z (get-z~ v))
    (update))
  
  
  (method (update)
    (set! right (+ x width))
    (set! top (+ y height))
    (set! near (+ z depth))
    (set! center-x (/ (+ (get-left) (get-right)) 2))
    (set! center-y (/ (+ (get-bottom) (get-top)) 2))
    (set! center-z (/ (+ (get-far) (get-near)) 2)))
  
  
  (method (set-color col)
    (set! color col)
    (update-color))
  
  
  (method (update-color)
    (when color
      (set! red (/ (cast <fl> (get-red~ color)) 255.))
      (set! green (/ (cast <fl> (get-green~ color)) 255.))
      (set! blue (/ (cast <fl> (get-blue~ color)) 255.))))
  
  
  (method protected virtual (serialize-sprite)
    )
  
  
  (method override (draw)
    (if (get-3d?~ world)
        (if (get-textures?~ world)
            (draw-3d-textured)
          (draw-3d))
      (if (get-textures?~ world)
          (draw-2d-textured)
        (draw-2d))))
  
  
  (method protected virtual (draw-3d)
    (with-gl-matrix
      (lambda ()@w
        (let ((cx (get-center-x))
              (cy (get-center-y))
              (cz (get-center-z)))
          (gl-translate (- cx) (- cy) (- cz))
          (gl-rotate 15.0 0.0 1.0 0.0)
          (gl-translate cx cy cz))
        (glColor3f red green blue)
        (let ((x1 (get-left))
              (x2 (get-right))
              (y1 (get-bottom))
              (y2 (get-top))
              (z1 (get-far))
              (z2 (get-near)))
          ;; top
          (glNormal3f 0.0 1.0 0.0)
          (glBegin GL_QUADS)
          (glVertex3f x2 y2 z1)
          (glVertex3f x1 y2 z1)
          (glVertex3f x1 y2 z2)
          (glVertex3f x2 y2 z2)
          (glEnd)
          ;; bottom
          (glNormal3f 0.0 -1.0 0.0)
          (glBegin GL_QUADS)
          (glVertex3f x2 y1 z2)
          (glVertex3f x1 y1 z2)
          (glVertex3f x1 y1 z1)
          (glVertex3f x2 y1 z1)
          (glEnd)
          ;; front
          (glNormal3f 0.0 0.0 1.0)
          (glBegin GL_QUADS)
          (glVertex3f x1 y1 z2)
          (glVertex3f x2 y1 z2)
          (glVertex3f x2 y2 z2)
          (glVertex3f x1 y2 z2)
          (glEnd)
          ;; back
          (glNormal3f 0.0 0.0 -1.0)
          (glBegin GL_QUADS)
          (glVertex3f x2 y1 z1)
          (glVertex3f x1 y1 z1)
          (glVertex3f x1 y2 z1)
          (glVertex3f x2 y2 z1)
          (glEnd)
          ;; left
          (glNormal3f -1.0 0.0 0.0)
          (glBegin GL_QUADS)
          (glVertex3f x1 y2 z2)
          (glVertex3f x1 y2 z1)
          (glVertex3f x1 y1 z1)
          (glVertex3f x1 y1 z2)
          (glEnd)
          ;; right
          (glNormal3f 1.0 0.0 0.0)
          (glBegin GL_QUADS)
          (glVertex3f x2 y2 z1)
          (glVertex3f x2 y2 z2)
          (glVertex3f x2 y1 z2)
          (glVertex3f x2 y1 z1)
          (glEnd)))))
  
  
  (method (draw-3d-textured)
    (with-gl-matrix
      (lambda ()
        (gl-translate x y z)
        (gl-rotate rtri 1.0 1.0 1.0)
        (gl-scale 1.0 1.0 1.0)
        (let ((f -2.5)
              (t 2.5))
          ;; top
          (gl-normal 0.0 1.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t t f))
            (lambda () (gl-vertex f t f))
            (lambda () (gl-vertex f t t))
            (lambda () (gl-vertex t t t)))
          ;; bottom
          (gl-normal 0.0 -1.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t f t))
            (lambda () (gl-vertex f f t))
            (lambda () (gl-vertex f f f))
            (lambda () (gl-vertex t f f)))
          ;; front
          (gl-normal 0.0 0.0 1.0)
          (textured-quad~ texture
            (lambda () (gl-vertex f f t))
            (lambda () (gl-vertex t f t))
            (lambda () (gl-vertex t t t))
            (lambda () (gl-vertex f t t)))
          ;; back
          (gl-normal 0.0 0.0 -1.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t f f))
            (lambda () (gl-vertex f f f))
            (lambda () (gl-vertex f t f))
            (lambda () (gl-vertex t t f)))
          ;; left
          (gl-normal -1.0 0.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex f t t))
            (lambda () (gl-vertex f t f))
            (lambda () (gl-vertex f f f))
            (lambda () (gl-vertex f f t)))
          ;; right
          (gl-normal 1.0 0.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t t f))
            (lambda () (gl-vertex t t t))
            (lambda () (gl-vertex t f t))
            (lambda () (gl-vertex t f f)))))))
  
  
  (method (draw-2d)
    (let ((x1 (get-left))
          (y1 (get-top))
          (x2 (get-right))
          (y2 (get-bottom)))
      (glNormal3f 0.0 0.0 1.0)
      (if (in-history?)
          (glColor4f red green blue 0.5)
        (glColor3f red green blue))
      (unless (in-history?)
      (glBegin GL_QUADS)
      (glVertex2f x1 y1)
      (glVertex2f x2 y1)
      (glVertex2f x2 y2)
      (glVertex2f x1 y2)
      (glEnd))
      (glColor3f .41176 .23921 .00392)
      (glBegin GL_LINE_LOOP)
      (glVertex2f x1 y1)
      (glVertex2f x2 y1)
      (glVertex2f x2 y2)
      (glVertex2f x1 y2)
      (glEnd)))
  
  
  (method (draw-2d-textured)
    (with-gl-matrix
      (lambda ()
        (gl-translate x y z)
        (textured-quad~ texture
          (lambda () (gl-vertex 0.0 0.0 0.0))
          (lambda () (gl-vertex width 0.0 0.0))
          (lambda () (gl-vertex width height 0.0))
          (lambda () (gl-vertex 0.0 height 0.0))))))
  
  
  @w
  (method (draw-2d-textured)
    (with-gl-matrix
      (lambda ()
        (gl-translate x y z)
        (textured-quad~ texture
          (lambda () (gl-vertex 0.0 0.0 0.0))
          (lambda () (gl-vertex 5.0 0.0 0.0))
          (lambda () (gl-vertex 5.0 5.0 0.0))
          (lambda () (gl-vertex 0.0 5.0 0.0)))))))


;;;
;;;; Block
;;;


(class Block extends Sprite
  
  
  (method override (serialize-sprite)
    (list 'block x y z)))


(class Block-Blue extends Block
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! color {Color Blue})
    (update-color))
  
  
  (method override (serialize-sprite)
    (list 'block-blue x y z)))


(class Block-Green extends Block
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! color {Color Green})
    (update-color))
  
  
  (method override (serialize-sprite)
    (list 'block-green x y z)))


;;;
;;;; Actor
;;;


(definition gravity
  .09)


(class Actor extends Sprite
  
  
  (slot direction <Vertex> initialize #f accessors generate)
  
  
  (method override (draw-3d)
    (with-gl-matrix
      (lambda ()
        (let ((rx (get-radius-x))
              (ry (get-radius-y))
              (rz (get-radius-z)))
          (gl-translate (+ x rx) (+ y ry) (+ z rz))
          (gl-rotate (get-first-angle~ world) 0. 1. 0.)
          (glColor3f red green blue)
          (let ((x1 (- rx))
                (x2 rx)
                (y1 (- ry))
                (y2 ry)
                (z1 (- rz))
                (z2 rz))
            ;; top
            (glNormal3f 0.0 1.0 0.0)
            (glBegin GL_QUADS)
            (glVertex3f x2 y2 z1)
            (glVertex3f x1 y2 z1)
            (glVertex3f x1 y2 z2)
            (glVertex3f x2 y2 z2)
            (glEnd)
            ;; bottom
            (glNormal3f 0.0 -1.0 0.0)
            (glBegin GL_QUADS)
            (glVertex3f x2 y1 z2)
            (glVertex3f x1 y1 z2)
            (glVertex3f x1 y1 z1)
            (glVertex3f x2 y1 z1)
            (glEnd)
            ;; front
            (glNormal3f 0.0 0.0 1.0)
            (glBegin GL_QUADS)
            (glVertex3f x1 y1 z2)
            (glVertex3f x2 y1 z2)
            (glVertex3f x2 y2 z2)
            (glVertex3f x1 y2 z2)
            (glEnd)
            ;; back
            (glNormal3f 0.0 0.0 -1.0)
            (glBegin GL_QUADS)
            (glVertex3f x2 y1 z1)
            (glVertex3f x1 y1 z1)
            (glVertex3f x1 y2 z1)
            (glVertex3f x2 y2 z1)
            (glEnd)
            ;; left
            (glNormal3f -1.0 0.0 0.0)
            (glBegin GL_QUADS)
            (glVertex3f x1 y2 z2)
            (glVertex3f x1 y2 z1)
            (glVertex3f x1 y1 z1)
            (glVertex3f x1 y1 z2)
            (glEnd)
            ;; right
            (glNormal3f 1.0 0.0 0.0)
            (glBegin GL_QUADS)
            (glVertex3f x2 y2 z1)
            (glVertex3f x2 y2 z2)
            (glVertex3f x2 y1 z2)
            (glVertex3f x2 y1 z1)
            (glEnd)))))))


;;;
;;;; Enemy
;;;


(class Enemy extends Actor)


;;;
;;;; Turtle
;;;


(definition turtle-speed
  .1)


(class Turtle extends Enemy
  
  
  (slot vx         <fl> initialize 0. accessors generate)
  (slot vy         <fl> initialize 0. accessors generate)
  (slot stomp-time <fl> initialize 0. accessors generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! vx turtle-speed))
  
  
  (method override (tick commands)
    (continuation-capture
      (lambda (exit)
        (define (player-hit obj)
          (when (eq? obj (get-player~ world))
            (lose~ world)
            (continuation-return exit)))
        
        (define (reverse-speed)
          (if (< vx 0)
              (set! vx .1)
            (set! vx -.1)))
        
        (if stomp-time
            (when (>= (time->seconds (current-time)) stomp-time)
              (set! stomp-time #f))
          (let ((old-x x)
                (old-y y)
                (old-z z))
            (increase! x vx)
            (increase! y vy)
            (when (< y 0.)
              (set! y 0.))
            (decrease! vy gravity)
            (when (< vy -1.0)
              (set! vy -1.))
            (receive (hit-x hit-y hit-z) (hit-test~ world self old-x old-y old-z x y z width height depth)
              (when hit-x
                (bind (obj direction border reset) hit-x
                  (player-hit obj)
                  (set! x reset)
                  (reverse-speed)))
              (when hit-y
                (bind (obj direction border reset) hit-y
                  (player-hit obj)
                  (set! y reset)))
              (when hit-z
                (bind (obj direction border reset) hit-z
                  (player-hit obj)
                  (set! z reset)
                  (reverse-speed))))
            @w
            (when (or (< x -35.)
                      (> x -27.))
              (reverse-speed))
            (update))))))
  
  
  (method (stomp)
    (set! stomp-time (+ (time->seconds (current-time)) 3.)))
  
  
  (method override (serialize-sprite)
    (list 'turtle x y z)))


;;;
;;;; Player
;;;


(definition player-speed
  .5)

(definition jump-impulsion
  2.0)

(definition floor-deceleration
  .25)

(definition air-deceleration
  .05)

(definition max-vy
  -.8)

(definition die-bottom
  -6.)


(class Player extends Actor
  
  
  (slot vx       <fl>      initialize 0.    accessors generate)
  (slot vy       <fl>      initialize 0.    accessors generate)
  (slot vz       <fl>      initialize 0.    accessors generate)
  (slot ready?   <bool>    initialize #f    accessors generate)
  (slot jumping? <bool>    initialize #f    accessors generate)
  (slot floor?   <bool>    initialize #f    accessors generate)
  (slot facing   <symbol>  initialize 'left accessors generate)
  (slot state    <symbol+> initialize #f    accessors generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! direction (new Vertex 0. 0. -1)))
  
  
  (method override (tick commands)
    (continuation-capture
      (lambda (exit)
        (define (win-hit obj)
          (when (eq? (get-user-data~ obj) 'win)
            (win~ world)
            (continuation-return exit)))
        
        (let ((old-x x)
              (old-y y)
              (old-z z)
              (moving? #f)
              (target-vx #f)
              (target-vz #f))
          (when (get-move-left?~ commands)
            (set! moving? #t)
            (set! target-vx (- player-speed)))
          (when (get-move-right?~ commands)
            (set! moving? #t)
            (set! target-vx player-speed))
          (when (get-move-down?~ commands)
            (if (get-first-person?~ world)
                (move-player-backward~ world)
              (set! moving? #t)
              (set! target-vz player-speed)))
          (when (get-move-up?~ commands)
            (if (get-first-person?~ world)
                (move-player-forward~ world)
              (set! moving? #t)
              (set! target-vz (- player-speed))))
          (when (get-strafe-left?~ commands)
            (when (get-first-person?~ world)
              (strafe-player-left~ world)))
          (when (get-strafe-right?~ commands)
            (when (get-first-person?~ world)
              (strafe-player-right~ world)))
          (when (not moving?)
            (set! target-vx 0.)
            (set! target-vz 0.))
          (when target-vx
            (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
              (cond ((> vx target-vx)
                     (decrease! vx deceleration)
                     (if (< vx target-vx)
                         (set! vx target-vx)))
                    ((< vx target-vx)
                     (increase! vx deceleration)
                     (if (> vx target-vx)
                         (set! vx target-vx))))))
          (when target-vz
            (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
              (cond ((> vz target-vz)
                     (decrease! vz deceleration)
                     (if (< vz target-vz)
                         (set! vz target-vz)))
                    ((< vz target-vz)
                     (increase! vz deceleration)
                     (if (> vz target-vz)
                         (set! vz target-vz))))))
          (if (not (get-jump?~ commands))
              (set! ready? #t)
            (when (and floor? ready? (not jumping?))
              (set! ready? #f)
              (set! jumping? #t)
              (set! vy jump-impulsion)))
          
          (decrease! vy gravity)
          (increase! x vx)
          (increase! y vy)
          (increase! z vz)
          (when (< vy max-vy)
            (set! vy max-vy))
          (receive (hit-x hit-y hit-z) (hit-test~ world self old-x old-y old-z x y z width height depth)
            (set-information~ world (list hit-x hit-y hit-z))
            (when hit-x
              (bind (obj direction border reset) hit-x
                (win-hit obj)
                (set! x reset)))
            (if (not hit-y)
                (set! floor? #f)
              (bind (obj direction border reset) hit-y
                (win-hit obj)
                (set! y reset)
                (set! vy 0.)
                (when (= direction -1)
                  (set! jumping? #f)
                  (set! floor? #t)
                  (when (is? obj Turtle)
                    (set! vy 3.)
                    (stomp~ obj)))))
            (when hit-z
              (bind (obj direction border reset) hit-z
                (win-hit obj)
                (set! z reset))))
          (when (< y 0.)
            (set! y 0.)
            (set! vy 0.)
            (set! jumping? #f)
            (set! floor? #t))
          @w
          (when (< y die-bottom)
            (lose~ world)
            (continuation-return exit))
          (update)
          (when (or (/= x old-x)
                    (/= y old-y)
                    (/= z old-z))
            (center-camera~ world))))))
  
  
  (method (move-left commands)
    (set-move-left?~ commands #t))
  
  
  (method (move-right commands)
    (set-move-right?~ commands #t))
  
  
  (method (move-down commands)
    (set-move-down?~ commands #t))
  
  
  (method (move-up commands)
    (set-move-up?~ commands #t))
  
  
  (method (strafe-left commands)
    (set-strafe-left?~ commands #t))
  
  
  (method (strafe-right commands)
    (set-strafe-right?~ commands #t))
  
  
  (method (space commands)
    (jump commands))
  
  
  (method (jump commands)
    (set-jump?~ commands #t))
  
  
  (method (win)
    (set! jumping? #f)
    (set! state 'win)
    (update))
  
  
  (method (lose)
    (set! jumping? #f)
    (set! state 'lose)
    (update))
  
  
  (method (reset-state)
    (set! state #f))
  
  
  (method (reset-position)
    (set! x (get-start-x~ world))
    (set! y (get-start-y~ world))
    (set! z (get-start-z~ world))
    (update))
  
  
  (method override (serialize-sprite)
    (list 'player x y z)))


;;;
;;;; Pacman
;;;


(class Pacman extends Player
  
  
  (method override (serialize-sprite)
    (list 'pacman x y z)))


;;;
;;;; Commands
;;;


(class Commands extends Object
  
  
  (slot move-left?    <bool> initialize #f accessors generate)
  (slot move-right?   <bool> initialize #f accessors generate)
  (slot move-down?    <bool> initialize #f accessors generate)
  (slot move-up?      <bool> initialize #f accessors generate)
  (slot strafe-left?  <bool> initialize #f accessors generate)
  (slot strafe-right? <bool> initialize #f accessors generate)
  (slot jump?         <bool> initialize #f accessors generate)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{l}"
          `(,@(if move-left? '(move-left) '())
            ,@(if move-right? '(move-right) '())
            ,@(if move-down? '(move-down) '())
            ,@(if move-up? '(move-up) '())
            ,@(if strafe-left? '(strafe-left) '())
            ,@(if strafe-right? '(strafe-right) '())
            ,@(if jump? '(jump) '())))))))


;;;
;;;; Folio
;;;


(class Folio extends Object
  
  
  (slot class initialize #f  accessors generate)
  (slot list  initialize '() accessors generate)
  
  
  (method override (initialize class list)
    (nextmethod)
    (set! class~self class)
    (set! list~self list))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" class list)))))


;;;
;;;; Moment
;;;


(class Moment extends Object
  
  
  (slot snapshot <object> initialize #f accessors generate)
  (slot commands <object> initialize #f accessors generate)
  
  
  (method override (initialize snap cmd)
    (nextmethod)
    (set! snapshot snap)
    (set! commands cmd)))


;;;
;;;; World
;;;


(class Live-World extends World
  
  
  (slot actors             <list>   initialize '()           getter generate)
  (slot blocks             <list>   initialize '()           getter generate)
  (slot sprites            <list>   initialize '()           getter generate)
  (slot player             <object> initialize #f            getter generate)
  (slot projection         <symbol> initialize 'orthographic getter generate)
  (slot zoom-factor        <fl>                              getter generate)
  (slot 3d?                <bool>   initialize #f            getter generate)
  (slot first-person?      <bool>   initialize #f            getter generate)
  (slot first-distance     <fl>     initialize 7.5           getter generate)
  (slot first-angle        <fl>     initialize 0.            getter generate)
  (slot textures?          <bool>   initialize #f            getter generate)
  (slot axes               <object>                          getter generate)
  (slot pulse              <object>                          getter generate)
  (slot paused?            <bool>   initialize #f            getter generate)
  (slot info               <object>                          getter generate)
  (slot info?              <bool>   initialize #f            getter generate)
  (slot tps                <object> initialize #f            getter generate)
  (slot tps?               <bool>   initialize #f            getter generate)
  (slot rps                <object> initialize #f            getter generate)
  (slot rps?               <bool>   initialize #f            getter generate)
  (slot start-x            <fl+>    initialize #f            getter generate)
  (slot start-y            <fl+>    initialize #f            getter generate)
  (slot start-z            <fl+>    initialize #f            getter generate)
  (slot commands           <object> initialize #f            getter generate)
  (slot player-texture     <object> initialize #f            getter generate)
  (slot turtle-texture     <object> initialize #f            getter generate)
  (slot block-texture      <object> initialize #f            getter generate)
  (slot background-texture <object> initialize #f            getter generate)
  (slot current            <object> initialize #f            getter generate)
  (slot history            <object> initialize #f            getter generate)
  (slot now                <object> initialize #f            getter generate)
  (slot message            <object> initialize #f            getter generate)
  (slot message-time       <object> initialize #f            getter generate)
  (slot message-texture    <object> initialize #f            getter generate)
  (slot information        <object> initialize #f            getter generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (initialize-opengl)
    (nextmethod)
    (initialize-camera)
    (prepare-tick)
    (prepare-textures)
    (prepare-light)
    (prepare-editor)
    (reset-commands))
  
  
  (method (prepare-textures)
    (let ((resources-dir (new Directory (tokenise-filename (repository-pathname (find-repository 'World) "world.client/resources")))))
      (set! player-texture (make-png-texture (new-file~ resources-dir "player/Idle.png")))
      (set! turtle-texture (make-png-texture (new-file~ resources-dir "player/Idle.png")))
      (set! block-texture (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")))
      (set! background-texture (make-png-texture (new-file~ resources-dir "background/Layer0_0.png")))
      (set! message-texture (make-cairo-texture 250 100))))
  
  
  (method (prepare-light)
    (set! light? #f))
  
  
  (method (reset-commands)
    (set! commands (new Commands)))
  
  
  (method (setup-world)
    (set! paused? #f))
  
  
  (method (setup-boundaries)
    @w
    (set! boundaries (new Cuboid left bottom far right top near)))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method override (initialize-world)
    (nextmethod)
    (set! axes (add-axes visible?: #f))
    (set! info (new Info self -10.0 0.0 0.0))
    (set! tps (new Counter self -10.0 0.0 0.0 "Tick" 35.0))
    (set! rps (new Counter self -10.0 0.0 0.0 "Render" 8.0))
    (set! start-x -10.0)
    (set! start-y 60.0)
    (set! start-z 0.0)
    (set! player (add-actor (new Player self start-x start-y start-z 4. 4. 4. player-texture color: {Color red: 173 green: 12 blue: 230})))
    (add-actor (new Turtle self 0.0 20.0 0.0 2. 2. 2.0 turtle-texture color: {Color Green}))
    (loop (for n from -6 to 6)
          (add-block (new Block self (cast <fl> (* n 5)) 30.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    (loop (for n from 0 to 6)
          (add-block (new Block self (cast <fl> (* n 5)) 50.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    (loop (for n from -2 to 2)
          (add-block (new Block self (cast <fl> (* n 5)) 15.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    (add-block (new Block self -10. 20.0 0.0 5.0 5.0 5.0 block-texture color: {Color Light-Purple} user-data: 'win))
    (add-block (new Block self 10. 20.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (add-block (new Block self 20.  4.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (add-block (new Block self 28. 10.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (add-block (new Block self 19.5 17.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (loop (for n from -2 to 2)
          (add-block (new Block self (cast <fl> (* n 5)) 0.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    @w
    (add-block (new Block self -50.0 -30.0 -5.0 100. 100. .1 background-texture color: {Color Light-Blue}))
    (setup-world)
    (setup-boundaries)
    (setup-history)
    (update-title))
    
  
  ;;;
  ;;;; Sprites
  ;;;
  
  
  (method (add-actor actor)
    (set! actors (cons actor actors))
    (set! sprites (cons actor sprites))
    actor)

  
  (method (add-block block)
    (set! blocks (cons block blocks))
    (set! sprites (cons block sprites))
    block)
  
  
  (method (iterate-sprites proc)
    (for-each proc sprites))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (prepare-tick)
    (set! pulse (new Pulse 'tick .01 tick-world)))
  
  
  (method (tick-world)
    (unless (or paused? (is-inactive?))
      (add-history)
      (start~ tps)
      (tick-actors commands)
      (reset-commands)
      (end~ tps)))
  
  
  (method (tick-actors commands)
    (unless (get-state~ player)
      (for-each (lambda (actor)
                  (tick~ actor commands))
                actors)))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (history-start)
    0)
  
  
  (method (history-end)
    (cardinality history))
  
  
  (method (history-first)
    0)
  
  
  (method (history-last)
    (- (history-end) 1))
  
  
  (method (historical-moment n)
    (element history n))
  
  
  (method (in-history n)
    (max (history-first) (min n (history-end))))
  
  
  (method (setup-history)
    (set! history (new Axis 0))
    (set! now 0))
  
  
  (method (add-history)
    (axis-add history (new Moment (snapshot-world) (object-copy commands)))
    (increase! now))
  
  
  (method (backward-history)
    (goto-history (- now 1)))
  
  
  (method (forward-history)
    (goto-history (+ now 1)))
  
  
  (method (goto-history n)
    (let ((n (in-history n)))
      (unless (= n now)
        (set! now n)
        (if (= n (history-end))
            (load-world current)
          (load-world (get-snapshot~ (historical-moment now)))))))
  
  
  (method (slide-history where)
    (goto-history (fxround (* where (history-end)))))
  
  
  (method (truncate-future)
    (axis-adjust history now))
  
  
  (method (reset-history)
    (setup-history)
    (display-message "History reset"))
  
  
  (method (step-world)
    (when (< now (cardinality history))
      (let ((commands (get-commands~ (historical-moment now))))
        (increase! now)
        (tick-actors commands))))
  
  
  (method (recalculate-future)
    (let ((end (history-end)))
      (loop (for n from now below end)
            (let ((moment (historical-moment n)))
              (let ((commands (get-commands~ moment)))
                (tick-actors commands)
                (let ((next (+ n 1)))
                  (let ((moment (historical-moment next))
                        (snapshot (snapshot-world)))
                    (if (= next end)
                        (set! current snapshot)
                      (set-snapshot~ moment snapshot)))))))
      ;; for now
      (if (= now end)
          (load-world current)
        (load-world (get-snapshot~ (historical-moment now))))))
  
  
  (method (update-future)
    (when paused?
      (recalculate-future)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method override (move-forward)
    (if first-person?
        (move-up~ player commands)
      (nextmethod)))
  
  
  (method override (move-backward)
    (if first-person?
        (move-down~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-left)
    (if first-person?
        (strafe-left~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-right)
    (if first-person?
        (strafe-right~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-up)
    (if first-person?
        (move-player-forward)
      (nextmethod)))
  
  
  (method override (strafe-down)
    (if first-person?
        (move-player-backward)
      (nextmethod)))
  
  
  (method override (rotate-left)
    (if first-person?
        (rotate-player-left)
      (nextmethod)))
  
  
  (method override (rotate-right)
    (if first-person?
        (rotate-player-right)
      (nextmethod)))
  
  
  (method (move-left)
    (move-left~ player commands))
  
  
  (method (move-right)
    (move-right~ player commands))
  
  
  (method (move-down)
    (move-down~ player commands))
  
  
  (method (move-up)
    (move-up~ player commands))
  
  
  (method (space)
    (space~ player commands))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method (hit-test object from-x <fl> from-y <fl> from-z <fl> to-x <fl> to-y <fl> to-z <fl> width <fl> height <fl> depth <fl>)
    (let ((from-right (+ from-x width))
          (from-top (+ from-y height))
          (from-near (+ from-z depth))
          (to-right #f)
          (to-top #f)
          (to-near #f))
      (define (hit-y)
        (cond ;; going up
              ((> to-y from-y)
               (let (iter (scan sprites))
                 (if (null? scan)
                     #f
                   (let ((obj (car scan)))
                     (let ((left (get-left~ obj))
                           (right (get-right~ obj))
                           (far (get-far~ obj))
                           (near (get-near~ obj))
                           (border (get-bottom~ obj)))
                       (if (and (neq? obj object)
                                (<= from-top border)
                                (> to-top border)
                                (not (or (<= to-right left)
                                         (>= to-x right)
                                         (<= to-near far)
                                         (>= to-z near))))
                           (begin
                             (set! to-top border)
                             (set! to-y (- to-top height))
                             (list obj 1 border (- border height)))
                         (iter (cdr scan))))))))
              ;; going down
              ((< to-y from-y)
               (let (iter (scan sprites))
                 (if (null? scan)
                     #f
                   (let ((obj (car scan)))
                     (let ((left (get-left~ obj))
                           (right (get-right~ obj))
                           (far (get-far~ obj))
                           (near (get-near~ obj))
                           (border (get-top~ obj)))
                       (if (and (neq? obj object)
                                (>= from-y border)
                                (< to-y border)
                                (not (or (<= to-right left)
                                         (>= to-x right)
                                         (<= to-near far)
                                         (>= to-z near))))
                           (begin
                             (set! to-y border)
                             (set! to-top (+ to-y height))
                             (list obj -1 border border))
                         (iter (cdr scan))))))))
              ;; not moving
              (else
               #f)))
      
      (define (hit-x)
        (cond ;; going right
              ((> to-x from-x)
               (let (iter (scan sprites))
                 (if (null? scan)
                     #f
                   (let ((obj (car scan)))
                     (let ((bottom (get-bottom~ obj))
                           (top (get-top~ obj))
                           (far (get-far~ obj))
                           (near (get-near~ obj))
                           (border (get-left~ obj)))
                       (if (and (neq? obj object)
                                (<= from-right border)
                                (> to-right border)
                                (not (or (<= to-top bottom)
                                         (>= to-y top)
                                         (<= to-near far)
                                         (>= to-z near))))
                           (begin
                             (set! to-right border)
                             (set! to-x (- to-right width))
                             (list obj 1 border (- border width)))
                         (iter (cdr scan))))))))
              ;; going left
              ((< to-x from-x)
               (let (iter (scan sprites))
                 (if (null? scan)
                     #f
                   (let ((obj (car scan)))
                     (let ((bottom (get-bottom~ obj))
                           (top (get-top~ obj))
                           (far (get-far~ obj))
                           (near (get-near~ obj))
                           (border (get-right~ obj)))
                       (if (and (neq? obj object)
                                (>= from-x border)
                                (< to-x border)
                                (not (or (<= to-top bottom)
                                         (>= to-y top)
                                         (<= to-near far)
                                         (>= to-z near))))
                           (begin
                             (set! to-x border)
                             (set! to-right (+ to-x width))
                             (list obj -1 border border))
                         (iter (cdr scan))))))))
              ;; not moving
              (else
               #f)))
      
      (define (hit-z)
        (cond ;; going near
              ((> to-z from-z)
               (let (iter (scan sprites))
                 (if (null? scan)
                     #f
                   (let ((obj (car scan)))
                     (let ((left (get-left~ obj))
                           (right (get-right~ obj))
                           (bottom (get-bottom~ obj))
                           (top (get-top~ obj))
                           (border (get-far~ obj)))
                       (if (and (neq? obj object)
                                (<= from-near border)
                                (> to-near border)
                                (not (or (<= to-right left)
                                         (>= to-x right)
                                         (<= to-top bottom)
                                         (>= to-y top))))
                           (begin
                             (set! to-near border)
                             (set! to-z (- to-near depth))
                             (list obj 1 border (- border depth)))
                         (iter (cdr scan))))))))
              ;; going far
              ((< to-z from-z)
               (let (iter (scan sprites))
                 (if (null? scan)
                     #f
                   (let ((obj (car scan)))
                     (let ((left (get-left~ obj))
                           (right (get-right~ obj))
                           (bottom (get-bottom~ obj))
                           (top (get-top~ obj))
                           (border (get-near~ obj)))
                       (if (and (neq? obj object)
                                (>= from-z border)
                                (< to-z border)
                                (not (or (<= to-right left)
                                         (>= to-x right)
                                         (<= to-top bottom)
                                         (>= to-y top))))
                           (begin
                             (set! to-z border)
                             (set! to-near (+ to-z depth))
                             (list obj -1 border border))
                         (iter (cdr scan))))))))
              ;; not moving
              (else
               #f)))
      
      (define (hit h1 h2 h3)
        (let ((count 0))
          (let ((h1 (h1)))
            (when h1
              (increase! count))
            (let ((h2 (h2)))
              (when h2
                (increase! count))
              (let ((h3 (h3)))
                (when h3
                  (increase! count))
                (values count h1 h2 h3))))))
      
      (let ((preserved-x to-x)
            (preserved-y to-y)
            (preserved-z to-z))
        (define (restore)
          (set! to-x preserved-x)
          (set! to-y preserved-y)
          (set! to-z preserved-z)
          (set! to-right (+ to-x width))
          (set! to-top (+ to-y height))
          (set! to-near (+ to-z depth)))
        
        (restore)
        (receive (count hy hx hz) (hit hit-y hit-x hit-z)
          (if (<= count 1)
              (values hx hy hz)
            (restore)
            (receive (count hx hy hz) (hit hit-x hit-y hit-z)
              (if (<= count 1)
                  (values hx hy hz)
                (restore)
                (receive (count hz hy hx) (hit hit-z hit-y hit-x)
                  (values hx hy hz)))))))))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method override (prepare-projection)
    (let ((ratio (/ (cast <fl> width) (cast <fl> height))))
      (gl-matrix-mode GL_PROJECTION)
      (gl-load-identity)
      (case projection
        ((perspective)
         (glu-perspective 45.0 ratio 0.1 1000.0))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (gl-ortho (- width) width (- height) height -50.0 50.0)))))))
  
  
  (method (toggle-projection)
    (set! projection
          (case projection
            ((perspective) 'orthographic)
            ((orthographic) 'perspective))))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (definition camera-limit
    5.)
  
  
  (method override (camera-speed)
    0.5)
  
  
  (method (initialize-camera)
    (set! zoom-factor 54.5)
    (prepare-camera)
    (update-camera))
  
  
  (method override (prepare-camera)
    (set! eye (new Vertex 0.0 36.25 40.0))
    (set! eye-sight (new Vertex 0.0 0.0 -1.0))
    (set! eye-right (new Vertex 1.0 0.0 0.0))
    (set! eye-up (new Vertex 0.0 1.0 0.0)))

  
  (method override (zoom-in)
    (if first-person?
        (first-distance-closer)
      (if (eq? projection 'perspective)
          (nextmethod)
        (set! zoom-factor (* zoom-factor .75)))))
  
  
  (method override (zoom-out)
    (if first-person?
        (first-distance-further)
      (if (eq? projection 'perspective)
          (nextmethod)
        (set! zoom-factor (/ zoom-factor .75)))))
  
  
  (method override (zoom-speed)
    10.)
  
  
  (method (follow-player)
    (when first-person?
      (let ((center (new Vertex
                      (get-center-x~ player)
                      (+ (get-top~ player) 1.5)
                      (get-center-z~ player))))
        (set! eye-sight (get-direction~ player))
        (set! eye-right (vertex-normalize (cross-product eye-sight eye-up)))
        (set! eye-target (vertex- center (vertex-scalar* eye-sight first-distance)))
        (set! eye (vertex- eye-target eye-sight))
        (update-camera))))
  
  
  (method (strafe-camera center-x)
    (let ((eye-x (get-x~ eye)))
      (if (> center-x (+ eye-x camera-limit))
          (strafe-horizontally (- center-x (+ eye-x camera-limit))))
      (if (< center-x (- eye-x camera-limit))
          (strafe-horizontally (- center-x (- eye-x camera-limit))))))
  
  
  (method (center-camera)
    (unless paused?
      (case projection
        ((perspective)
         (follow-player))
        ((orthographic)
         (strafe-camera (get-center-x~ player))))))
  
  
  (method (first-distance-closer)
    (set! first-distance (* first-distance .75))
    (center-camera))
  
  
  (method (first-distance-further)
    (set! first-distance (/ first-distance .75))
    (center-camera))
  
  
  (method (move-player-forward)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* (get-direction~ player) 0.5)))
    (follow-player))
  
  
  (method (move-player-backward)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* (get-direction~ player) 0.5)))
    (follow-player))
  
  
  (method (strafe-player-left)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* eye-right 0.5)))
    (follow-player))
  
  
  (method (strafe-player-right)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* eye-right 0.5)))
    (follow-player))
  
  
  (definition player-rotation-speed
    0.02)
  
  
  (method (rotate-player-left)
    (rotate-player-horizontal player-rotation-speed))
  
  
  (method (rotate-player-right)
    (rotate-player-horizontal (- player-rotation-speed)))
  
  
  (method (rotate-player-horizontal angle)
    (set-direction~ player (rotate-upon angle eye-up (get-direction~ player)))
    (set! first-angle (first-person-angle))
    (follow-player))
  
  
  (method (first-person-angle)
    (let ((front (new Vertex 0. 0. -1.)))
      (let ((angle (vector-angle eye-sight front))
            (cross (cross-product eye-sight front)))
        (* -1
           (sign (get-y~ cross))
           (radian->degree angle)))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-objects)
    (case projection
      ((perspective)
       (if 3d?
           (gl-enable GL_DEPTH_TEST)
         (gl-disable GL_DEPTH_TEST)))
      ((orthographic)
       (gl-disable GL_DEPTH_TEST)))
    (draw-grid)
    (cond ((not paused?)
           (start~ rps)
           (iterate-sprites draw~)
           (end~ rps))
          (else
           (iterate-sprites draw~)
           (draw-history)))
    (when target
      (draw-target)))
  
  
  (method (draw-target)
    (unless down?
      (let ((x1 (get-left~ target))
            (y1 (get-bottom~ target))
            (z1 (get-far~ target))
            (x2 (get-right~ target))
            (y2 (get-top~ target))
            (z2 (get-near~ target)))
        (case projection
          ((perspective)
           (gl-set-color {Color Red})
           (glLineWidth 10.)
           (render-cube x1 y1 z1 x2 y2 z2
             (lambda (proc)
               (with-gl-begin/end GL_QUADS
                 proc)))
           (glLineWidth 1.))
          ((orthographic)
           (gl-normal 0.0 0.0 1.0)
           (gl-set-color {Color Red})
           (with-gl-begin/end GL_LINE_LOOP
             (lambda ()
               (gl-vertex2f x1 y1)
               (gl-vertex2f x2 y1)
               (gl-vertex2f x2 y2)
               (gl-vertex2f x1 y2))))))))
  
  
  (method (draw-grid)
    (when grid?
      (when grid-x?
        (let ((min -500)
              (max 500))
          (gl-set-color {Color Yellow})
          (with-gl-begin/end GL_LINES
            (lambda ()
              (loop (for y from min to max by 5)
                    (gl-vertex grid-x y min)
                    (gl-vertex grid-x y max))
              (loop (for z from min to max by 5)
                    (gl-vertex grid-x min z)
                    (gl-vertex grid-x max z))))))
      (when grid-y?
        (let ((min -500)
              (max 500))
          (gl-set-color {Color Green})
          (with-gl-begin/end GL_LINES
            (lambda ()
              (loop (for x from min to max by 5)
                    (gl-vertex x grid-y min)
                    (gl-vertex x grid-y max))
              (loop (for z from min to max by 5)
                    (gl-vertex min grid-y z)
                    (gl-vertex max grid-y z))))))
      (when grid-z?
        (let ((min -500)
              (max 500))
          (gl-set-color {Color Red})
          (with-gl-begin/end GL_LINES
            (lambda ()
              (loop (for x from min to max by 5)
                    (gl-vertex x min grid-z)
                    (gl-vertex x max grid-z))
              (loop (for y from min to max by 5)
                    (gl-vertex min y grid-z)
                    (gl-vertex max y grid-z))))))))
  
  
  (method (draw-history)
    (let ((step 1)
          (max 1000))
      ;; past
      (loop (for n from (- now 1) downto (history-first) by step)
            (repeat max)
            (draw-player n))
      ;; future
      (loop (for n from now to (history-last) by step)
            (repeat max)
            (draw-player n))))
  
  
  (method (draw-player n)
    (let ((snapshot (get-snapshot~ (historical-moment n))))
      (let ((player (find-player snapshot)))
        (when player
          (parameterize ((in-history? #t))
            (draw~ player))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method override (draw-interface)
    (nextmethod)
    (when info?
      (draw~ info))
    (when message
      (draw-message))
    (when tps?
      (draw~ tps))
    (when rps?
      (draw~ rps))
    (when paused?
      (draw-history-slider)))
  
  
  (method (draw-history-slider)
    (let ((cx (fxround/ width 2)))
      (gl-frame-rect (new Rect (- cx 200) (- height 30) (+ cx 200) (- height 31)) {Color Gray})
      (gl-frame-rect (new Rect (- cx 200) (- height 32) (+ cx 200) (- height 33)) {Color Light-Gray})
      (let ((h (+ (fxround (- (* (/ (cast <fl> now) (history-end)) 400.) 200.)) cx)))
        (gl-segment-circle (new Point h (- height 32)) 7 {Color Light-Blue} 100))))
  
  
  ;;;
  ;;;; Win / Lose
  ;;;
  
  
  (method (win)
    (win~ player)
    (let ((block (find-if (lambda (obj)
                            (eq? (get-user-data~ obj) 'win))
                          blocks)))
      (set-color~ block {Color Blue}))
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (lose)
    (lose~ player)
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (reset-game)
    (setup-history))
    
  
  ;;;
  ;;;; Save / Open
  ;;;
  
  
  (slot moniker   initialize #f)
  (slot modified? initialize #f)

  
  (method (new-world)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (set! target #f)
    (set! moniker #f)
    (center-camera)
    (reset-counters))
  
  
  (method (save-world)
    (if (not moniker)
        (save-as-world)
      (save-to moniker)))
  
  
  (method (save-as-world)
    (let ((file (choose-new-file default-extension: "wrl" extensions: '(("World Files" . "wrl")) directory: {Directory Home ".world"})))
      (save-to file)
      (set! moniker file)
      (update-title)))
  
  
  (method (save-to file)
    (call-with-output-file (path-settings file)
      (lambda (output)
        (iterate-sprites
          (lambda (obj)
            (format output "{s}{%}" (serialize-sprite~ obj))))))
    (set-modified? #f))
  
  
  (method (open-world)
    (define (open file)
      (open-file file)
      (display-message (get-base~ file)))
    
    (let ((files (collect-files~ {Directory Home ".world"} (lambda (file) (extension=? (get-extension~ file) "wrl")))))
      (if (null? files)
          (bell)
        (if (not moniker)
            (open (car files))
          (let ((file (next-element files moniker test: pathname=?)))
            (open file))))))
  
  
  (method (open-file file)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (call-with-input-file (path-settings file)
      (lambda (input)
        (let (iter)
          (let ((info (read input)))
            (when (not (eof-object? info))
              (bind (class x y z) info
                (when (eq? class 'player)
                  (set! start-x x)
                  (set! start-y y)
                  (set! start-z z))
                (add-sprite class (new Vertex x y z))
                (iter)))))))
    (set! moniker file)
    (setup-world)
    (setup-history)
    (update-title)
    (center-camera)
    (reset-counters))
  
  
  (method (revert-world)
    (if moniker
        (open-file moniker)
      (bell)))
  
  
  (method (update-title)
    (define (present-title)
      (format "World - {a}{a}{a}"
              (present-name)
              (present-modified)
              (present-directory)))
    
    (define (present-name)
      (if (not moniker)
          "New"
        (get-name~ moniker)))
    
    (define (present-modified)
      (if modified?
          " *"
        ""))
    
    (define (present-directory)
      (if (not moniker)
          ""
        (let ((parent (get-parent~ moniker)))
          (if (not parent)
              ""
            (format " ~{{a}}" (present-location~ parent))))))
    
    (set-title~ window (present-title)))
  
  
  (method (set-modified? flag)
    (when (neq? flag modified?)
      (set! modified? flag)
      (update-title)))
  
  
  (method (reset-live)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (set! target #f)
    (reset-world)
    (center-camera)
    (reset-counters))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot down?         <bool>   initialize #f  getter generate)
  (slot deleting?     <bool>   initialize #f  getter generate)
  (slot grid-x        <fl>     initialize 0.  getter generate)
  (slot grid-y        <fl>     initialize 0.  getter generate)
  (slot grid-z        <fl>     initialize 10. getter generate)
  (slot grid?         <bool>   initialize #f  getter generate)
  (slot grid-x?       <bool>   initialize #f  getter generate)
  (slot grid-y?       <bool>   initialize #f  getter generate)
  (slot grid-z?       <bool>   initialize #f  getter generate)
  (slot last-added    <object> initialize #f  getter generate)
  (slot players-folio <Folio>                 getter generate)
  (slot enemies-folio <Folio>                 getter generate)
  (slot blocks-folio  <Folio>                 getter generate)
  
  
  (method (prepare-editor)
    (set! players-folio (new Folio 'player '(player pacman)))
    (set! enemies-folio (new Folio 'turtle '(turtle)))
    (set! blocks-folio (new Folio 'block '(block block-blue block-green))))
  
  
  (method (find-block vert)
    (continuation-capture
      (lambda (return)
        (iterate-sprites
          (lambda (obj)
            (let ((left (get-left~ obj))
                  (right (get-right~ obj))
                  (bottom (get-bottom~ obj))
                  (top (get-top~ obj))
                  (far (get-far~ obj))
                  (near (get-near~ obj)))
              (when (and (>= (get-x~ vert) left)
                         (>= (get-y~ vert) bottom)
                         (>= (get-z~ vert) far)
                         (<  (get-x~ vert) right)
                         (<  (get-y~ vert) top)
                         (<  (get-z~ vert) near))
                (continuation-return return obj)))))
        #f)))
  
  
  (method (screen->world h v)
    (let ((ratio (/ (cast <fl> width) (cast <fl> height)))
          (ch (- h (fxfloor/ width 2)))
          (cv (- (- height v) (fxfloor/ height 2))))
      (define (perspective->world norm plane-k)
        (let ((norm-eye-sight-dot-product (dot-product norm (vertex-normalize eye-sight))))
          (unless (and (= norm-eye-sight-dot-product 0.)
                       (cond (grid-x? (= (get-x~ eye) grid-x))
                             (grid-y? (= (get-y~ eye) grid-y))
                             (grid-z? (= (get-z~ eye) grid-z))))
            (let ((f-over-y (/ PI/4 2)))
              (let ((cone (tan f-over-y))
                    (d (vertex-distance eye eye-target))
                    (right (cross-product (vertex- eye-target eye) eye-up)))
                (let ((target-in-eye-space (vertex+ (vertex-scalar* eye-up (/ (* cv d cone 2.) height))
                                                    (vertex+ (vertex-scalar* right (/ (* ch d cone 2. ratio) width))
                                                             eye-target))))
                  (let ((intersect (/ (- plane-k (dot-product norm eye))
                                      (dot-product (vertex- target-in-eye-space eye) norm))))
                    (unless (<= intersect 0)
                      (let ((point (vertex+ eye (vertex-scalar* (vertex- target-in-eye-space eye) intersect))))
                        point)))))))))
      
      (define (orthographic->world)
        (let ((x (+ (/ (* 2. ch zoom-factor) width) (get-x~ eye)))
              (y (+ (/ (* 2. cv zoom-factor) height ratio) (get-y~ eye))))
         (new Vertex x y 0.)))
      
      (case projection
        ((perspective)
         (cond (grid-x? (let ((vert (perspective->world (new Vertex 1. 0. 0.) grid-x)))
                          (and vert (new Vertex
                                      grid-x
                                      (get-y~ vert)
                                      (get-z~ vert)))))
               (grid-y? (let ((vert (perspective->world (new Vertex 0. 1. 0.) grid-y)))
                          (and vert (new Vertex
                                      (get-x~ vert)
                                      grid-y
                                      (get-z~ vert)))))
               (grid-z? (let ((vert (perspective->world (new Vertex 0. 0. 1.) grid-z)))
                          (and vert (new Vertex
                                      (get-x~ vert)
                                      (get-y~ vert)
                                      grid-z))))
               (else (bell)
                     #f)))
        ((orthographic)
         (orthographic->world)))))
  
  
  (method (add-sprite class vert)
    (let ((x (* (floor (/ (get-x~ vert) 5.)) 5.))
          (y (* (floor (/ (get-y~ vert) 5.)) 5.))
          (z (* (floor (/ (get-z~ vert) 5.)) 5.)))
      (let ((sprite
              (case class
                ((player)
                 (add-actor (new Player self x y z 4. 4. 4. player-texture color: {Color red: 173 green: 12 blue: 230})))
                ((pacman)
                 (add-actor (new Pacman self x y z 4. 4. 4. player-texture color: {Color Yellow})))
                ((turtle)
                 (add-actor (new Turtle self x y z 2. 2. 2. turtle-texture color: {Color Green})))
                ((block)
                 (add-block (new Block self x y z 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
                ((block-blue)
                 (add-block (new Block-Blue self x y z 5.0 5.0 5.0 block-texture)))
                ((block-green)
                 (add-block (new Block-Green self x y z 5.0 5.0 5.0 block-texture))))))
        (when (is? sprite Player)
          (when player
            (remove-sprite player))
          (set! player sprite))
        sprite)))
  
  
  (method (editor-add-sprite class vert)
    (let ((sprite (add-sprite class vert)))
      (set! last-added sprite)
      sprite))
  
  
  (method (editor-sprite-class)
    (cond ((alt-down?) (get-class~ players-folio))
          ((shift-down?) (get-class~ enemies-folio))
          (else (get-class~ blocks-folio))))
  
  
  (method (sprite-folio sprite)
    (typecase sprite
      ((Player) players-folio)
      ((Enemy) enemies-folio)
      ((Block) blocks-folio)
      (else #f)))
  
  
  (method (forward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (next-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)))))
  
  
  (method (backward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (previous-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)))))
  
  
  (method (change-class sprite class)
    (let ((vert (new Vertex (get-x~ sprite) (get-y~ sprite) (get-z~ sprite))))
      (remove-sprite sprite)
      (editor-add-sprite class vert)))
  
  
  (method (remove-target)
    (if (not target)
        (bell)
      (remove-sprite target)
      (set-modified? #t)))
  
  
  (method (remove-sprite obj)
    (typecase obj
      ((Actor) (set! actors (remove! obj actors)))
      ((Block) (set! blocks (remove! obj blocks))))
    (set! sprites (remove! obj sprites))
    (set! target #f))
  
  
  (method (toggle-grid)
    (set! grid? (not grid?))
    (activate-3d))
  
  
  (method (toggle-grid-x)
    (set! grid-x? (not grid-x?))
    (when grid-x?
      (set! grid? #t)
      (set! grid-y? #f)
      (set! grid-z? #f)
      (activate-3d)))
  
  
  (method (toggle-grid-y)
    (set! grid-y? (not grid-y?))
    (when grid-y?
      (set! grid? #t)
      (set! grid-x? #f)
      (set! grid-z? #f)
      (activate-3d)))
  
  
  (method (toggle-grid-z)
    (set! grid-z? (not grid-z?))
    (when grid-z?
      (set! grid? #t)
      (set! grid-x? #f)
      (set! grid-y? #f)
      (activate-3d)))
  
  
  (method (decrease-grid)
    (cond (grid-x? (decrease! grid-x 5.))
          (grid-y? (decrease! grid-y 5.))
          (grid-z? (decrease! grid-z 5.))))
  
  
  (method (increase-grid)
    (cond (grid-x? (increase! grid-x 5.))
          (grid-y? (increase! grid-y 5.))
          (grid-z? (increase! grid-z 5.))))
  
  
  (method (editor-mouse-down h v)
    (let ((vert (screen->world h v)))
      (when vert
        (let ((obj (find-block vert)))
          (if obj
              (if (control-down?)
                  (begin
                    (remove-sprite obj)
                    (set! down? #t)
                    (set! deleting? #t)
                    (set-modified? #t)
                    (update-future))
                (set! target obj)
                (set-?t obj))
            (if (control-down?)
                (begin
                  (set! down? #t)
                  (let ((class (editor-sprite-class)))
                    (editor-add-sprite class vert)
                    (set-modified? #t))
                  (update-future))
              (set! target #f)
              (set-?t #f)))))))
  
  
  (method (editor-mouse-move h v)
    (when down?
      (let ((vert (screen->world h v)))
        (when vert
          (let ((obj (find-block vert)))
            (if obj
                (when deleting?
                  (remove-sprite obj)
                  (set-modified? #t)
                  (update-future))
              (unless deleting?
                (let ((class (editor-sprite-class)))
                  (editor-add-sprite class vert)
                  (set-modified? #t))
                (update-future))))))))
  
  
  (method (editor-mouse-up h v)
    (set! down? #f)
    (set! deleting? #f))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-hook? initialize #t getter generate)
  
  
  (method (toggle-paused)
    (if paused?
        (unpause-world)
      (pause-world)))
  
  
  (method (toggle-evaluation)
    (set! evaluate-hook? (not evaluate-hook?))
    (display-message (format "Evaluation {a}" (if evaluate-hook? "on" "off"))))
  
  
  (method (pause-world)
    (set! current (snapshot-world))
    (set! paused? #t)
    (set! animate? #f)
    (reset-counters))
  
  
  (method (unpause-world)
    (truncate-future)
    (set! current #f)
    (set! paused? #f)
    (set! animate? #t)
    (reset-counters))
  
  
  (method (snapshot-world)
    (map object-copy actors))
  
  
  (method (load-world snapshot)
    (let ((previous-target target))
      (set! actors (map object-copy snapshot))
      (set! sprites (append blocks actors))
      (set! player (find-player actors))
      (set! target (and previous-target (find-target previous-target sprites)))
      (set-?t target)))
  
  
  (method (find-player snapshot)
    (find-if (lambda (obj)
               (is? obj Player))
             snapshot))
  
  
  (method (find-target target snapshot)
    (let ((origin (get-origin~ target)))
      (find-if (lambda (obj)
                 (eq? (get-origin~ obj) origin))
               snapshot)))
  
  
  (method override (evaluate-hook)
    (when evaluate-hook?
      (update-future)))
  
  
  (method (test-world)
    )
  
  
  ;;;
  ;;;; Slider
  ;;;
  
  
  (slot sliding? initialize #f)
  
  
  (method (slider-mouse-down h v)
    (set! sliding? #t)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-move h v)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-up h v)
    (set! sliding? #f))
  
  
  (method (h->where h)
    (let ((cx (fxround/ width 2)))
      (let ((where (/ (+ (- h cx) 200.) 400.)))
        (max 0. (min 1. where)))))
  
  
  (method (in-slider? v)
    (< v 60))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down h v)
    (if (and paused? (in-slider? v))
        (slider-mouse-down h v)
      (editor-mouse-down h v)))
  
  
  (method override (mouse-move h v)
    (if (and paused? sliding?)
        (slider-mouse-move h v)
      (if last-point
          (nextmethod h v)
        (editor-mouse-move h v))))
  
  
  (method override (mouse-up h v)
    (if (and paused? sliding?)
        (slider-mouse-up h v)
      (if last-point
          (nextmethod h v)
        (editor-mouse-up h v))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (process-keys)
    (let ((evt (make-event Keyboard-Event :char self)))
      ;; camera
      (unless (key-down? (char->integer #\space))
        (process-movement evt))
      ;; player
      (when (eq? window (get-window-focus))
        (receive (shift? control? alt?) (modifiers-down)
          (unless (or shift? control? alt?)
            (when (key-down? VK_LEFT)
              (move-left))
            (when (key-down? VK_RIGHT)
              (move-right))
            (when (key-down? VK_DOWN)
              (move-down))
            (when (key-down? VK_UP)
              (move-up))
            (when (key-down? (char->integer #\space))
              (space)))))))
  
  
  (method override (process-shortcut shortcut)
    (continuation-capture
      (lambda (return)
        (cond ;; select
              ((shortcut=? shortcut {Shortcut :alt #\1}) (select-bubbles))
              ((shortcut=? shortcut {Shortcut :alt #\2}) (select-snakes))
              ((shortcut=? shortcut {Shortcut :alt #\3}) (select-tree))
              ((shortcut=? shortcut {Shortcut :alt #\4}) (select-live))
              ;; world
              ((shortcut=? shortcut {Shortcut :control #\N}) (new-world))
              ((shortcut=? shortcut {Shortcut :control #\S}) (save-world))
              ((shortcut=? shortcut {Shortcut :control #\O}) (open-world))
              ((shortcut=? shortcut {Shortcut :control #\R}) (revert-world))
              ((shortcut=? shortcut {Shortcut #\0}) (reset-live))
              ;; editor
              ((shortcut=? shortcut {Shortcut :control #\1}) (toggle-grid-z))
              ((shortcut=? shortcut {Shortcut :control #\2}) (toggle-grid-y))
              ((shortcut=? shortcut {Shortcut :control #\3}) (toggle-grid-x))
              ((shortcut=? shortcut {Shortcut :control Left}) (decrease-grid))
              ((shortcut=? shortcut {Shortcut :control Right}) (increase-grid))
              ((shortcut=? shortcut {Shortcut :control Tab}) (forward-sprite-class))
              ((shortcut=? shortcut {Shortcut :control :shift Tab}) (backward-sprite-class))
              ;; debug
              ((shortcut=? shortcut {Shortcut :control #\T}) (test-world))
              (else (continuation-return return #f)))
        #t)))
  
  
  (method override (key-press key)
    (let ((evt (make-event Keyboard-Event :char self key: key)))
      (case key
        ;; editor
        ((#\backspace) (remove-target))
        ((#\g) (toggle-grid))
        ;; debug
        ((#\p #\tab) (toggle-paused))
        ((#\\) (toggle-evaluation))
        ((#\[) (backward-history))
        ((#\]) (forward-history))
        ((#\return) (step-world))
        ((#\h) (reset-history))
        ((#\c) (clear-terminal))
        ;; projection
        ((#\1) (first-person))
        ((#\3) (toggle-3d))
        ;; camera
        ((#\9) (initialize-camera))
        ;; music
        ((#\m) (change-music))
        ;; settings
        ((#\z) (toggle-interface))
        ((#\-) (toggle-counters))
        ((#\_) (reset-counters))
        ((#\=) (toggle-axes))
        ((#\i) (toggle-info))
        ((#\y) (toggle-polygon-mode))
        ((#\l) (toggle-lighting))
        ((#\f) (toggle-fullscreen))
        ((#\v) (toggle-projection))
        ((#\t) (toggle-textures)))))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (first-person)
    (if first-person?
        (set! first-person? #f)
      (set! first-person? #t)
      (set-direction~ player (new Vertex 0. 0. -1.))
      (set! eye-up (new Vertex 0.0 1.0 0.0))
      (center-camera)
      (activate-3d)))
    
  
  (method (toggle-3d)
    (if 3d?
        (deactivate-3d)
      (activate-3d)))
  
  
  (method (activate-3d)
    (set! 3d? #t)
    (set! light? #t)
    (set! projection 'perspective))
  
  
  (method (deactivate-3d)
    (set! 3d? #f)
    (set! light? #f)
    (set! projection 'orthographic))

  
  (method (toggle-textures)
    (set! textures? (not textures?)))
  
  
  (method (toggle-axes)
    (set-visible?~ axes (not (get-visible?~ axes))))
  
  
  (method (toggle-info)
    (set! info? (not info?)))
  
  
  (method (toggle-counters)
    (set! tps? (not tps?))
    (set! rps? (not rps?))
    (reset-counters))
  
  
  (method (reset-counters)
    (reset~ tps)
    (reset~ rps))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method (display-message msg)
    (set! message msg)
    (set! message-time (time->seconds (current-time))))
  
  
  (method (draw-message)
    (if (> (- (time->seconds (current-time)) message-time) 1.)
        (begin
          (set! message #f)
          (set! message-time #f))
      (let ((surface (get-surface~ message-texture))
            (font {Font Heading1})
            (color {Color Red}))
        (set-operator~ surface CAIRO_OPERATOR_CLEAR)
        (paint~ surface)
        (set-operator~ surface CAIRO_OPERATOR_OVER)
        (set-font~ surface font)
        (set-color~ surface color)
        (draw-text~ surface 0 10 message)
        (map-texture~ message-texture)
        (let ((w (text-width~ font message)))
          (let ((c (center w width)))
            (with-gl-matrix
              (lambda ()
                (gl-translate (cast <fl> c) (cast <fl> (- height 200)) 0.0)
                (textured-quad~ message-texture
                  (lambda () (gl-vertex 0.0 0.0 0.0))
                  (lambda () (gl-vertex 250.0 0.0 0.0))
                  (lambda () (gl-vertex 250.0 100.0 0.0))
                  (lambda () (gl-vertex 0.0 100.0 0.0))))))))))
  
  
  ;;;
  ;;;; Info
  ;;;
  
  
  (method (debug-info)
    (define (present-object obj)
      (format "~{{s} #{s}}"
              (reference-name (get-name~ (class-of obj)))
              (object->serial obj)))
    
    (define (present-boolean bool)
      (if bool "true" "false"))
    
    (define (present-history)
      (define (present-coordinates obj)
        (format "{r precision: 1} {r precision: 1}" (get-x~ obj) (get-y~ obj)))
      
      `(,(format "c -> {a}" (present-coordinates player))
        ,@(loop (for n from 0 to (history-last))
                (collect
                  (let ((moment (historical-moment n)))
                    (let ((snapshot (get-snapshot~ moment))
                          (commands (get-commands~ moment)))
                      (let ((player (find-player snapshot)))
                        (format "{a} -> {a}" n (present-coordinates player)))))))))
    
    `(,(format "window: {a}" (present-object window))
      ,(format "width: {s}" width)
      ,(format "height: {s}" height)
      ""
      ,(format "self: {s}" self)
      ,(format "actors: {s}" (length actors))
      ,(format "blocks: {s}" (length blocks))
      ,(format "sprites: {s}" (length sprites))
      ""
      ,(format "history: {s}" (history-end))
      ,(format "now: {s}" now)
      ,@(if (and paused? (< (history-end) 5))
            (present-history)
          '())
      ""
      ,(format "projection: {s}" projection)
      ,(format "eye: {s}" eye)
      ,(format "eye-sight: {s}" eye-sight)
      ,(format "eye-target: {s}" eye-target)
      ,(format "eye-right: {s}" eye-right)
      ,(format "eye-up: {s}" eye-up)
      ,(format "camera-distance: {s}" camera-distance)
      ,(format "zoom-factor: {s}" zoom-factor)
      ,(format "first-distance: {s}" first-distance)
      ,(format "first-angle: {s}" first-angle)
      ""
      ,@(if information
            `(,@information
              "")
          '())
      ,(format "player: {a}" (present-object player))
      ,(format "  x: {r precision: 1}" (get-x~ player))
      ,(format "  y: {r precision: 1}" (get-y~ player))
      ,(format "  z: {r precision: 1}" (get-z~ player))
      ,(format "  width: {s}" (get-width~ player))
      ,(format "  height: {s}" (get-height~ player))
      ,(format "  depth: {s}" (get-depth~ player))
      ,(format "  texture: {s}" (get-texture~ player))
      ,(format "  color: {s}" (get-color~ player))
      ,(format "  user-data: {s}" (get-user-data~ player))
      ,(format "  vx: {s}" (get-vx~ player))
      ,(format "  vy: {s}" (get-vy~ player))
      ,(format "  vz: {s}" (get-vz~ player))
      ,(format "  direction: {s}" (get-direction~ player))
      ,(format "  jumping?: {a}" (present-boolean (get-jumping?~ player)))
      ,(format "  facing: {s}" (get-facing~ player))
      ,(format "  state: {s}" (get-state~ player))
      ""
      ,@(if target
            `(,(format "target: {a}" (present-object target))
              ,(format "  x: {r precision: 1}" (get-x~ target))
              ,(format "  y: {r precision: 1}" (get-y~ target))
              ,(format "  z: {r precision: 1}" (get-z~ target))
              ,(format "  width: {s}" (get-width~ target))
              ,(format "  height: {s}" (get-height~ target))
              ,(format "  depth: {s}" (get-depth~ target))
              ,(format "  texture: {s}" (get-texture~ target))
              ,(format "  color: {s}" (get-color~ target))
              ,(format "  user-data: {s}" (get-user-data~ target))
              "")
          '())
      ,(format "animate?: {a}" (present-boolean animate?))
      ,(format "light?: {a}" (present-boolean light?))
      ,(format "music?: {a}" (present-boolean music?))
      ,(format "3d?: {a}" (present-boolean 3d?))
      ,(format "first-person?: {a}" (present-boolean first-person?))
      ,(format "textures?: {a}" (present-boolean textures?))
      ,(format "paused?: {a}" (present-boolean paused?))))
  
  
  (method (reset-information)
    (set! information #f))
  
  
  (method (set-information info)
    (set! information (map ->string info)))
  
  
  (method (add-information info)
    (set! information (append (or information '()) (list (->string info))))))


;;;
;;;; Info
;;;


(class Info extends World-Object
  
  
  (slot texture <object> getter generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! texture (make-cairo-texture 500 800)))
  
  
  (method override (draw)
    (let ((surface (get-surface~ texture)))
      (set-operator~ surface CAIRO_OPERATOR_CLEAR)
      (paint~ surface)
      (set-operator~ surface CAIRO_OPERATOR_OVER)
      (set-font~ surface {Font font-name: "Courier New" point-size: 10 antialias: none})
      (set-color~ surface {Color Red})
      (let ((rank 0))
        (for-each (lambda (info)
                    (draw-text~ surface 10 (+ 10 (* rank 15)) (->string info))
                    (increase! rank))
                  (debug-info~ world)))
      (map-texture~ texture)
      (with-gl-matrix
        (lambda ()
          (gl-translate 0.0 (cast <fl> (- (get-height~ world) 800.0)) 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex 0.0 0.0 0.0))
            (lambda () (gl-vertex 500.0 0.0 0.0))
            (lambda () (gl-vertex 500.0 800.0 0.0))
            (lambda () (gl-vertex 0.0 800.0 0.0))))))))


;;;
;;;; Counter
;;;


(class Counter extends World-Object
  
  
  (slot texture <object> getter generate)
  (slot count   <number> getter generate)
  (slot elapse  <fl>     getter generate)
  (slot rate    <fl>     getter generate)
  (slot started <fl+>    getter generate)
  (slot title   <string> getter generate)
  (slot vert    <fl>     getter generate)
  
  
  (method override (initialize world x y z t v)
    (nextmethod world x y z)
    (set! texture (make-cairo-texture 150 35))
    (set! rate 0.0)
    (set! title t)
    (set! vert v)
    (reset))
  
  
  (method (reset)
    (set! elapse 0.)
    (set! count 0))
  
  
  (method (start)
    (set! started (time->seconds (current-time))))
  
  
  (method (end)
    (increase! count)
    (let ((ended (time->seconds (current-time))))
      (increase! elapse (- ended started)))
    (set! rate (/ count elapse)))
  
  
  (method override (draw)
    (draw-rate))
  
  
  (method (draw-rate)
    (let ((surface (get-surface~ texture)))
      (set-operator~ surface CAIRO_OPERATOR_CLEAR)
      (paint~ surface)
      (set-operator~ surface CAIRO_OPERATOR_OVER)
      (set-font~ surface {Font Heading2})
      (set-color~ surface {Color Red})
      (draw-text~ surface 0 10 (format "{a}: {r precision: 0}" title rate))
      (map-texture~ texture)
      (with-gl-matrix
        (lambda ()
          (gl-translate 10.0 vert 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex 0.0 0.0 0.0))
            (lambda () (gl-vertex 150.0 0.0 0.0))
            (lambda () (gl-vertex 150.0 35.0 0.0))
            (lambda () (gl-vertex 0.0 35.0 0.0)))))))))
