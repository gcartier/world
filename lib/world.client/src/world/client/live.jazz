;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Live
;;;


(module world.client.live jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl)
        (jazz.graphic.opengl.platform)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (time)
        (world.autoload)
        (world.client)
        (world.geometry)
        (world.object)
        (world.texture)
        (world.window))


;;;
;;;; Parameters
;;;


(definition in-history?
  (make-parameter #f))


;;;
;;;; Sprite
;;;


(class Sprite extends World-Object
  
  
  (slot origin    <object> getter generate)
  (slot width     <fl>     getter generate)
  (slot height    <fl>     getter generate)
  (slot depth     <fl>     getter generate)
  (slot right     <fl>     getter generate)
  (slot top       <fl>     getter generate)
  (slot near      <fl>     getter generate)
  (slot texture   <object> accessors generate)
  (slot color     <object> getter generate)
  (slot red       <fl>     getter generate)
  (slot green     <fl>     getter generate)
  (slot blue      <fl>     getter generate)
  (slot user-data <object> accessors generate)
  
  
  (method override (initialize world x y z width height depth texture (color: color #f) (user-data: user-data #f))
    (nextmethod world x y z)
    (set! origin~self self)
    (set! width~self width)
    (set! height~self height)
    (set! depth~self depth)
    (set! texture~self texture)
    (set! color~self color)
    (set! user-data~self user-data)
    (update)
    (update-color))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{r precision: 1} {r precision: 1} {a} {a}" x y width height))))
  
  
  (method public inline (get-left) <fl>
    x)
  
  
  (method public inline (get-bottom) <fl>
    y)
  
  
  (method public inline (get-far) <fl>
    z)
  
  
  (method public (get-center) <Vertex>
    (new Vertex
      (get-center-x)
      (get-center-y)
      (get-center-z)))
  
  
  (method public (get-center-x) <fl>
    (/ (+ (get-left) (get-right)) 2))
  
  
  (method public (get-center-y) <fl>
    (/ (+ (get-bottom) (get-top)) 2))
  
  
  (method public (get-center-z) <fl>
    (/ (+ (get-far) (get-near)) 2))
  
  
  (method (update)
    (set! right (+ x width))
    (set! top (+ y height))
    (set! near (+ z depth)))
  
  
  (method (set-color col)
    (set! color col)
    (update-color))
  
  
  (method (update-color)
    (when color
      (set! red (/ (cast <fl> (get-red~ color)) 255.))
      (set! green (/ (cast <fl> (get-green~ color)) 255.))
      (set! blue (/ (cast <fl> (get-blue~ color)) 255.))))
  
  
  (method protected virtual (serialize-sprite)
    )
  
  
  (method override (draw)
    (if (get-3d?~ world)
        (if (get-textures?~ world)
            (draw-3d-textured)
          (draw-3d))
      (if (get-textures?~ world)
          (draw-2d-textured)
        (draw-2d))))
  
  
  ;; from Cube
  (method (draw-3d)
    (with-gl-matrix
      (lambda ()
        (glColor3f red green blue)
        (let ((x1 (get-left))
              (x2 (get-right))
              (y1 (get-bottom))
              (y2 (get-top))
              (z1 (get-far))
              (z2 (get-near)))
          ;; top
          (glNormal3f 0.0 1.0 0.0)
          (glBegin GL_QUADS)
          (glVertex3f x2 y2 z1)
          (glVertex3f x1 y2 z1)
          (glVertex3f x1 y2 z2)
          (glVertex3f x2 y2 z2)
          (glEnd)
          ;; bottom
          (glNormal3f 0.0 -1.0 0.0)
          (glBegin GL_QUADS)
          (glVertex3f x2 y1 z2)
          (glVertex3f x1 y1 z2)
          (glVertex3f x1 y1 z1)
          (glVertex3f x2 y1 z1)
          (glEnd)
          ;; front
          (glNormal3f 0.0 0.0 1.0)
          (glBegin GL_QUADS)
          (glVertex3f x1 y1 z2)
          (glVertex3f x2 y1 z2)
          (glVertex3f x2 y2 z2)
          (glVertex3f x1 y2 z2)
          (glEnd)
          ;; back
          (glNormal3f 0.0 0.0 -1.0)
          (glBegin GL_QUADS)
          (glVertex3f x2 y1 z1)
          (glVertex3f x1 y1 z1)
          (glVertex3f x1 y2 z1)
          (glVertex3f x2 y2 z1)
          (glEnd)
          ;; left
          (glNormal3f -1.0 0.0 0.0)
          (glBegin GL_QUADS)
          (glVertex3f x1 y2 z2)
          (glVertex3f x1 y2 z1)
          (glVertex3f x1 y1 z1)
          (glVertex3f x1 y1 z2)
          (glEnd)
          ;; right
          (glNormal3f 1.0 0.0 0.0)
          (glBegin GL_QUADS)
          (glVertex3f x2 y2 z1)
          (glVertex3f x2 y2 z2)
          (glVertex3f x2 y1 z2)
          (glVertex3f x2 y1 z1)
          (glEnd)))))
  
  
  ;; from Cube
  (method (draw-3d-textured)
    (with-gl-matrix
      (lambda ()
        (gl-translate x y z)
        (gl-rotate rtri 1.0 1.0 1.0)
        (gl-scale 1.0 1.0 1.0)
        (let ((f -2.5)
              (t 2.5))
          ;; top
          (gl-normal 0.0 1.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t t f))
            (lambda () (gl-vertex f t f))
            (lambda () (gl-vertex f t t))
            (lambda () (gl-vertex t t t)))
          ;; bottom
          (gl-normal 0.0 -1.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t f t))
            (lambda () (gl-vertex f f t))
            (lambda () (gl-vertex f f f))
            (lambda () (gl-vertex t f f)))
          ;; front
          (gl-normal 0.0 0.0 1.0)
          (textured-quad~ texture
            (lambda () (gl-vertex f f t))
            (lambda () (gl-vertex t f t))
            (lambda () (gl-vertex t t t))
            (lambda () (gl-vertex f t t)))
          ;; back
          (gl-normal 0.0 0.0 -1.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t f f))
            (lambda () (gl-vertex f f f))
            (lambda () (gl-vertex f t f))
            (lambda () (gl-vertex t t f)))
          ;; left
          (gl-normal -1.0 0.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex f t t))
            (lambda () (gl-vertex f t f))
            (lambda () (gl-vertex f f f))
            (lambda () (gl-vertex f f t)))
          ;; right
          (gl-normal 1.0 0.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex t t f))
            (lambda () (gl-vertex t t t))
            (lambda () (gl-vertex t f t))
            (lambda () (gl-vertex t f f)))))))
  
  
  (method (draw-2d)
    (let ((x1 (get-left))
          (y1 (get-top))
          (x2 (get-right))
          (y2 (get-bottom)))
      (glNormal3f 0.0 0.0 1.0)
      (if (in-history?)
          (glColor4f red green blue 0.5)
        (glColor3f red green blue))
      (unless (in-history?)
      (glBegin GL_QUADS)
      (glVertex2f x1 y1)
      (glVertex2f x2 y1)
      (glVertex2f x2 y2)
      (glVertex2f x1 y2)
      (glEnd))
      (glColor3f .41176 .23921 .00392)
      (glBegin GL_LINE_LOOP)
      (glVertex2f x1 y1)
      (glVertex2f x2 y1)
      (glVertex2f x2 y2)
      (glVertex2f x1 y2)
      (glEnd)))
  
  
  (method (draw-2d-textured)
    (with-gl-matrix
      (lambda ()
        (gl-translate x y z)
        (textured-quad~ texture
          (lambda () (gl-vertex 0.0 0.0 0.0))
          (lambda () (gl-vertex width 0.0 0.0))
          (lambda () (gl-vertex width height 0.0))
          (lambda () (gl-vertex 0.0 height 0.0))))))
  
  
  @w
  (method (draw-2d-textured)
    (with-gl-matrix
      (lambda ()
        (gl-translate x y z)
        (textured-quad~ texture
          (lambda () (gl-vertex 0.0 0.0 0.0))
          (lambda () (gl-vertex 5.0 0.0 0.0))
          (lambda () (gl-vertex 5.0 5.0 0.0))
          (lambda () (gl-vertex 0.0 5.0 0.0)))))))


;;;
;;;; Block
;;;


(class Block extends Sprite
  
  
  (method override (serialize-sprite)
    (list 'block x y z)))


(class Block-Blue extends Block
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! color {Color Blue})
    (update-color))
  
  
  (method override (serialize-sprite)
    (list 'block-blue x y z)))


(class Block-Green extends Block
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! color {Color Green})
    (update-color))
  
  
  (method override (serialize-sprite)
    (list 'block-green x y z)))


;;;
;;;; Actor
;;;


(definition gravity
  .09)


(class Actor extends Sprite)


;;;
;;;; Enemy
;;;


(class Enemy extends Actor)


;;;
;;;; Turtle
;;;


(definition turtle-speed
  .1)


(class Turtle extends Enemy
  
  
  (slot vx         <fl> initialize 0. accessors generate)
  (slot vy         <fl> initialize 0. accessors generate)
  (slot stomp-time <fl> initialize 0. accessors generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! vx turtle-speed))
  
  
  (method override (tick commands)
    (continuation-capture
      (lambda (exit)
        (define (character-hit obj)
          (when (eq? obj (get-character~ world))
            (lose~ world)
            (continuation-return exit)))
        
        (define (reverse-speed)
          (if (< vx 0)
              (set! vx .1)
            (set! vx -.1)))
        
        (if stomp-time
            (when (>= (time->seconds (current-time)) stomp-time)
              (set! stomp-time #f))
          (let ((old-x x)
                (old-y y)
                (old-z z))
            (increase! x vx)
            (increase! y vy)
            (when (< y 0.)
              (set! y 0.))
            (decrease! vy gravity)
            (when (< vy -1.0)
              (set! vy -1.))
            (receive (hit-x hit-y hit-z) (hit-test~ world self old-x old-y old-z x y z width height depth)
              (when hit-x
                (bind (obj direction border reset) hit-x
                  (character-hit obj)
                  (set! x reset)
                  (reverse-speed)))
              (when hit-y
                (bind (obj direction border reset) hit-y
                  (character-hit obj)
                  (set! y reset)))
              (when hit-z
                (bind (obj direction border reset) hit-z
                  (character-hit obj)
                  (set! z reset)
                  (reverse-speed))))
            @w
            (when (or (< x -35.)
                      (> x -27.))
              (reverse-speed))
            (update))))))
  
  
  (method (stomp)
    (set! stomp-time (+ (time->seconds (current-time)) 3.)))
  
  
  (method override (serialize-sprite)
    (list 'turtle x y z)))


;;;
;;;; Character
;;;


(definition character-speed
  .5)

(definition jump-impulsion
  2.0)

(definition floor-deceleration
  .25)

(definition air-deceleration
  .05)

(definition max-vy
  -.8)

(definition camera-limit
  5.)

(definition die-bottom
  -6.)


(class Character extends Actor
  
  
  (slot vx       <fl>      initialize 0.    accessors generate)
  (slot vy       <fl>      initialize 0.    accessors generate)
  (slot vz       <fl>      initialize 0.    accessors generate)
  (slot ready?   <bool>    initialize #f    accessors generate)
  (slot jumping? <bool>    initialize #f    accessors generate)
  (slot floor?   <bool>    initialize #f    accessors generate)
  (slot facing   <symbol>  initialize 'left accessors generate)
  (slot state    <symbol+> initialize #f    accessors generate)
  
  
  (method override (tick commands)
    (continuation-capture
      (lambda (exit)
        (define (win-hit obj)
          (when (eq? (get-user-data~ obj) 'win)
            (win~ world)
            (continuation-return exit)))
        
        (let ((old-x x)
              (old-y y)
              (old-z z)
              (moving? #f)
              (target-vx #f)
              (target-vz #f))
          (when (get-left?~ commands)
            (set! moving? #t)
            (set! target-vx (- character-speed)))
          (when (get-right?~ commands)
            (set! moving? #t)
            (set! target-vx character-speed))
          (when (get-down?~ commands)
            (set! moving? #t)
            (set! target-vz character-speed))
          (when (get-up?~ commands)
            (set! moving? #t)
            (set! target-vz (- character-speed)))
          (when (not moving?)
            (set! target-vx 0.)
            (set! target-vz 0.))
          (when target-vx
            (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
              (cond ((> vx target-vx)
                     (decrease! vx deceleration)
                     (if (< vx target-vx)
                         (set! vx target-vx)))
                    ((< vx target-vx)
                     (increase! vx deceleration)
                     (if (> vx target-vx)
                         (set! vx target-vx))))))
          (when target-vz
            (let ((deceleration (if jumping? air-deceleration floor-deceleration)))
              (cond ((> vz target-vz)
                     (decrease! vz deceleration)
                     (if (< vz target-vz)
                         (set! vz target-vz)))
                    ((< vz target-vz)
                     (increase! vz deceleration)
                     (if (> vz target-vz)
                         (set! vz target-vz))))))
          (if (not (get-jump?~ commands))
              (set! ready? #t)
            (when (and floor? ready? (not jumping?))
              (set! ready? #f)
              (set! jumping? #t)
              (set! vy jump-impulsion)))
          
          (decrease! vy gravity)
          (increase! x vx)
          (increase! y vy)
          (increase! z vz)
          (when (< vy max-vy)
            (set! vy max-vy))
          (receive (hit-x hit-y hit-z) (hit-test~ world self old-x old-y old-z x y z width height depth)
            (when hit-x
              (bind (obj direction border reset) hit-x
                (win-hit obj)
                (set! x reset)))
            (if (not hit-y)
                (set! floor? #f)
              (bind (obj direction border reset) hit-y
                (win-hit obj)
                (set! y reset)
                (set! vy 0.)
                (when (= direction -1)
                  (set! jumping? #f)
                  (set! floor? #t)
                  (when (is? obj Turtle)
                    (set! vy 3.)
                    (stomp~ obj)))))
            (when hit-z
              (bind (obj direction border reset) hit-z
                (win-hit obj)
                (set! z reset))))
          (when (< y 0.)
            (set! y 0.)
            (set! vy 0.)
            (set! jumping? #f)
            (set! floor? #t))
          @w
          (when (< y die-bottom)
            (lose~ world)
            (continuation-return exit))
          (when (or (/= vx 0.)
                    (/= vz 0.))
            (center-camera~ world))
          (update)))))
  
  
  (method (move-left commands)
    (set-left?~ commands #t))
  
  
  (method (move-right commands)
    (set-right?~ commands #t))
  
  
  (method (move-down commands)
    (set-down?~ commands #t))
  
  
  (method (move-up commands)
    (set-up?~ commands #t))
  
  
  (method (space commands)
    (jump commands))
  
  
  (method (jump commands)
    (set-jump?~ commands #t))
  
  
  (method (win)
    (set! jumping? #f)
    (set! state 'win)
    (update))
  
  
  (method (lose)
    (set! jumping? #f)
    (set! state 'lose)
    (update))
  
  
  (method (reset-state)
    (set! state #f))
  
  
  (method (reset-position)
    (set! x (get-start-x~ world))
    (set! y (get-start-y~ world))
    (set! z (get-start-z~ world))
    (update))
  
  
  (method override (serialize-sprite)
    (list 'character x y z)))


;;;
;;;; Pacman
;;;


(class Pacman extends Character
  
  
  (method override (serialize-sprite)
    (list 'pacman x y z)))


;;;
;;;; Commands
;;;


(class Commands extends Object
  
  
  (slot left?  <bool> initialize #f accessors generate)
  (slot right? <bool> initialize #f accessors generate)
  (slot down?  <bool> initialize #f accessors generate)
  (slot up?    <bool> initialize #f accessors generate)
  (slot jump?  <bool> initialize #f accessors generate)
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{l}"
          `(,@(if left? '(left) '())
            ,@(if right? '(right) '())
            ,@(if down? '(down) '())
            ,@(if up? '(up) '())
            ,@(if jump? '(jump) '())))))))


;;;
;;;; Folio
;;;


(class Folio extends Object
  
  
  (slot class initialize #f  accessors generate)
  (slot list  initialize '() accessors generate)
  
  
  (method override (initialize class list)
    (nextmethod)
    (set! class~self class)
    (set! list~self list))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" class list)))))


;;;
;;;; Moment
;;;


(class Moment extends Object
  
  
  (slot snapshot <object> initialize #f accessors generate)
  (slot commands <object> initialize #f accessors generate)
  
  
  (method override (initialize snap cmd)
    (nextmethod)
    (set! snapshot snap)
    (set! commands cmd)))


;;;
;;;; World
;;;


(class Live-World extends World
  
  
  (slot actors             <list>   initialize '()           getter generate)
  (slot blocks             <list>   initialize '()           getter generate)
  (slot sprites            <list>   initialize '()           getter generate)
  (slot character          <object> initialize #f            getter generate)
  (slot projection         <symbol> initialize 'orthographic getter generate)
  (slot zoom-factor        <fl>                              getter generate)
  (slot 3d?                <bool>   initialize #f            getter generate)
  (slot first-person?      <bool>   initialize #f            getter generate)
  (slot textures?          <bool>   initialize #f            getter generate)
  (slot axes               <object>                          getter generate)
  (slot pulse              <object>                          getter generate)
  (slot paused?            <bool>   initialize #f            getter generate)
  (slot info               <object>                          getter generate)
  (slot info?              <bool>   initialize #f            getter generate)
  (slot tps                <object> initialize #f            getter generate)
  (slot tps?               <bool>   initialize #f            getter generate)
  (slot rps                <object> initialize #f            getter generate)
  (slot rps?               <bool>   initialize #f            getter generate)
  (slot start-x            <fl+>    initialize #f            getter generate)
  (slot start-y            <fl+>    initialize #f            getter generate)
  (slot start-z            <fl+>    initialize #f            getter generate)
  (slot commands           <object> initialize #f            getter generate)
  (slot character-texture  <object> initialize #f            getter generate)
  (slot turtle-texture     <object> initialize #f            getter generate)
  (slot block-texture      <object> initialize #f            getter generate)
  (slot background-texture <object> initialize #f            getter generate)
  (slot current            <object> initialize #f            getter generate)
  (slot history            <object> initialize #f            getter generate)
  (slot now                <object> initialize #f            getter generate)
  (slot message            <object> initialize #f            getter generate)
  (slot message-time       <object> initialize #f            getter generate)
  (slot message-texture    <object> initialize #f            getter generate)
  (slot information        <object> initialize #f            getter generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (initialize-opengl)
    (nextmethod)
    (initialize-camera)
    (prepare-tick)
    (prepare-textures)
    (prepare-light)
    (prepare-editor)
    (reset-commands))
  
  
  (method (prepare-textures)
    (let ((resources-dir (new Directory (tokenise-filename (repository-pathname (find-repository 'World) "world.client/resources")))))
      (set! character-texture (make-png-texture (new-file~ resources-dir "player/Idle.png")))
      (set! turtle-texture (make-png-texture (new-file~ resources-dir "player/Idle.png")))
      (set! block-texture (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png")))
      (set! background-texture (make-png-texture (new-file~ resources-dir "background/Layer0_0.png")))
      (set! message-texture (make-cairo-texture 250 100))))
  
  
  (method (prepare-light)
    (set! light? #f))
  
  
  (method (reset-commands)
    (set! commands (new Commands)))
  
  
  (method (setup-world)
    (set! paused? #f))
  
  
  (method (setup-boundaries)
    @w
    (set! boundaries (new Cuboid left bottom far right top near)))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method override (initialize-world)
    (nextmethod)
    (set! axes (add-axes visible?: #f))
    (set! info (new Info self -10.0 0.0 0.0))
    (set! tps (new Counter self -10.0 0.0 0.0 "Tick" 35.0))
    (set! rps (new Counter self -10.0 0.0 0.0 "Render" 8.0))
    (set! start-x -10.0)
    (set! start-y 60.0)
    (set! start-z 0.0)
    (set! character (add-actor (new Character self start-x start-y start-z 4. 4. 4. character-texture color: {Color red: 173 green: 12 blue: 230})))
    (add-actor (new Turtle self 0.0 20.0 0.0 2. 2. 2.0 turtle-texture color: {Color Green}))
    (loop (for n from -6 to 6)
          (add-block (new Block self (cast <fl> (* n 5)) 30.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    (loop (for n from 0 to 6)
          (add-block (new Block self (cast <fl> (* n 5)) 50.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    (loop (for n from -2 to 2)
          (add-block (new Block self (cast <fl> (* n 5)) 15.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    (add-block (new Block self -10. 20.0 0.0 5.0 5.0 5.0 block-texture color: {Color Light-Purple} user-data: 'win))
    (add-block (new Block self 10. 20.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (add-block (new Block self 20.  4.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (add-block (new Block self 28. 10.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (add-block (new Block self 19.5 17.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1}))
    (loop (for n from -2 to 2)
          (add-block (new Block self (cast <fl> (* n 5)) 0.0 0.0 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
    @w
    (add-block (new Block self -50.0 -30.0 -5.0 100. 100. .1 background-texture color: {Color Light-Blue}))
    (setup-world)
    (setup-boundaries)
    (setup-history)
    (update-title))
    
  
  ;;;
  ;;;; Sprites
  ;;;
  
  
  (method (add-actor actor)
    (set! actors (cons actor actors))
    (set! sprites (cons actor sprites))
    actor)

  
  (method (add-block block)
    (set! blocks (cons block blocks))
    (set! sprites (cons block sprites))
    block)
  
  
  (method (iterate-sprites proc)
    (for-each proc sprites))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (prepare-tick)
    (set! pulse (new Pulse 'tick .01 tick-world)))
  
  
  (method (tick-world)
    (unless (or paused? (is-inactive?))
      (add-history)
      (start~ tps)
      (tick-actors commands)
      (reset-commands)
      (end~ tps)))
  
  
  (method (tick-actors commands)
    (unless (get-state~ character)
      (for-each (lambda (actor)
                  (tick~ actor commands))
                actors)))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (history-start)
    0)
  
  
  (method (history-end)
    (cardinality history))
  
  
  (method (history-first)
    0)
  
  
  (method (history-last)
    (- (history-end) 1))
  
  
  (method (historical-moment n)
    (element history n))
  
  
  (method (in-history n)
    (max (history-first) (min n (history-end))))
  
  
  (method (setup-history)
    (set! history (new Axis 0))
    (set! now 0))
  
  
  (method (add-history)
    (axis-add history (new Moment (snapshot-world) (object-copy commands)))
    (increase! now))
  
  
  (method (backward-history)
    (goto-history (- now 1)))
  
  
  (method (forward-history)
    (goto-history (+ now 1)))
  
  
  (method (goto-history n)
    (let ((n (in-history n)))
      (unless (= n now)
        (set! now n)
        (if (= n (history-end))
            (load-world current)
          (load-world (get-snapshot~ (historical-moment now)))))))
  
  
  (method (slide-history where)
    (goto-history (fxround (* where (history-end)))))
  
  
  (method (truncate-future)
    (axis-adjust history now))
  
  
  (method (step-world)
    (when (< now (cardinality history))
      (let ((commands (get-commands~ (historical-moment now))))
        (increase! now)
        (tick-actors commands))))
  
  
  (method (recalculate-future)
    (let ((end (history-end)))
      (loop (for n from now below end)
            (let ((moment (historical-moment n)))
              (let ((commands (get-commands~ moment)))
                (tick-actors commands)
                (let ((next (+ n 1)))
                  (let ((moment (historical-moment next))
                        (snapshot (snapshot-world)))
                    (if (= next end)
                        (set! current snapshot)
                      (set-snapshot~ moment snapshot)))))))
      ;; for now
      (if (= now end)
          (load-world current)
        (load-world (get-snapshot~ (historical-moment now))))))
  
  
  (method (update-future)
    (when paused?
      (recalculate-future)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  @w
  (method override (move-forward)
    (if #t;first-person?
        (begin
          (move-up~ character commands)
          (set! eye (vertex+ eye (vertex-scalar* eye-sight (camera-speed))))
          (reset-camera)
          (movement))
      (nextmethod)))
  
  
  @w
  (method override (move-backward)
    (if #t;first-person?
        (begin
          (move-down~ character commands)
          (set! eye (vertex+ eye (vertex-scalar* eye-sight (- (camera-speed)))))
          (reset-camera)
          (movement))
      (nextmethod)))
  
  
  @w
  (method override (strafe-left)
    (strafe-horizontally (- (* (camera-speed) 2))))
  
  
  @w
  (method override (strafe-right)
    (strafe-horizontally (* (camera-speed) 2)))
  
  
  @w
  (method override (strafe-up)
    (set! eye (vertex+ eye (vertex-scalar* up (* (camera-speed) 2))))
    (reset-camera)
    (movement))
  
  
  @w
  (method override (strafe-down)
    (set! eye (vertex+ eye (vertex-scalar* up (- (* (camera-speed) 2)))))
    (reset-camera)
    (movement))
  
  
  @w
  (method override (rotate-left)
    )
  
  
  @w
  (method override (rotate-right)
    )
  
  
  (method (move-left)
    (move-left~ character commands))
  
  
  (method (move-right)
    (move-right~ character commands))
  
  
  (method (move-down)
    (move-down~ character commands))
  
  
  (method (move-up)
    (move-up~ character commands))
  
  
  (method (space)
    (space~ character commands))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method (hit-test object from-x <fl> from-y <fl> from-z <fl> to-x <fl> to-y <fl> to-z <fl> width <fl> height <fl> depth <fl>)
    (let ((from-right (+ from-x width))
          (from-top (+ from-y height))
          (from-near (+ from-z depth))
          (to-right (+ to-x width))
          (to-top (+ to-y height))
          (to-near (+ to-z depth)))
      (values
        (cond
          ;; going right
          ((> to-x from-x)
           (let (iter (scan sprites))
             (if (null? scan)
                 #f
               (let ((obj (car scan)))
                 (let ((bottom (get-bottom~ obj))
                       (top (get-top~ obj))
                       (far (get-far~ obj))
                       (near (get-near~ obj))
                       (border (get-left~ obj)))
                   (if (and (neq? obj object)
                            (<= from-right border)
                            (> to-right border)
                            (not (or (<= from-top bottom)
                                     (>= from-y top)
                                     (<= from-near far)
                                     (>= from-z near))))
                       (list obj 1 border (- border width))
                     (iter (cdr scan))))))))
          ;; going left
          ((< to-x from-x)
           (let (iter (scan sprites))
             (if (null? scan)
                 #f
               (let ((obj (car scan)))
                 (let ((bottom (get-bottom~ obj))
                       (top (get-top~ obj))
                       (far (get-far~ obj))
                       (near (get-near~ obj))
                       (border (get-right~ obj)))
                   (if (and (neq? obj object)
                            (>= from-x border)
                            (< to-x border)
                            (not (or (<= from-top bottom)
                                     (>= from-y top)
                                     (<= from-near far)
                                     (>= from-z near))))
                       (list obj -1 border border)
                     (iter (cdr scan))))))))
          ;; not moving
          (else
           #f))
        (cond
          ;; going up
          ((> to-y from-y)
           (let (iter (scan sprites))
             (if (null? scan)
                 #f
               (let ((obj (car scan)))
                 (let ((left (get-left~ obj))
                       (right (get-right~ obj))
                       (far (get-far~ obj))
                       (near (get-near~ obj))
                       (border (get-bottom~ obj)))
                   (if (and (neq? obj object)
                            (<= from-top border)
                            (> to-top border)
                            (not (or (<= from-right left)
                                     (>= from-x right)
                                     (<= from-near far)
                                     (>= from-z near))))
                       (list obj 1 border (- border height))
                     (iter (cdr scan))))))))
          ;; going down
          ((< to-y from-y)
           (let (iter (scan sprites))
             (if (null? scan)
                 #f
               (let ((obj (car scan)))
                 (let ((left (get-left~ obj))
                       (right (get-right~ obj))
                       (far (get-far~ obj))
                       (near (get-near~ obj))
                       (border (get-top~ obj)))
                   (if (and (neq? obj object)
                            (>= from-y border)
                            (< to-y border)
                            (not (or (<= from-right left)
                                     (>= from-x right)
                                     (<= from-near far)
                                     (>= from-z near))))
                       (list obj -1 border border)
                     (iter (cdr scan))))))))
          ;; not moving
          (else
           #f))
        (cond
          ;; going near
          ((> to-z from-z)
           (let (iter (scan sprites))
             (if (null? scan)
                 #f
               (let ((obj (car scan)))
                 (let ((left (get-left~ obj))
                       (right (get-right~ obj))
                       (bottom (get-bottom~ obj))
                       (top (get-top~ obj))
                       (border (get-far~ obj)))
                   (if (and (neq? obj object)
                            (<= from-near border)
                            (> to-near border)
                            (not (or (<= from-right left)
                                     (>= from-x right)
                                     (<= from-top bottom)
                                     (>= from-y top))))
                       (list obj 1 border (- border width))
                     (iter (cdr scan))))))))
          ;; going far
          ((< to-z from-z)
           (let (iter (scan sprites))
             (if (null? scan)
                 #f
               (let ((obj (car scan)))
                 (let ((left (get-left~ obj))
                       (right (get-right~ obj))
                       (bottom (get-bottom~ obj))
                       (top (get-top~ obj))
                       (border (get-near~ obj)))
                   (if (and (neq? obj object)
                            (>= from-z border)
                            (< to-z border)
                            (not (or (<= from-right left)
                                     (>= from-x right)
                                     (<= from-top bottom)
                                     (>= from-y top))))
                       (list obj -1 border border)
                     (iter (cdr scan))))))))
          ;; not moving
          (else
           #f)))))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method override (prepare-projection)
    (let ((ratio (/ (cast <fl> width) (cast <fl> height))))
      (gl-matrix-mode GL_PROJECTION)
      (gl-load-identity)
      (case projection
        ((perspective)
         (glu-perspective 45.0 ratio 0.1 1000.0))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (gl-ortho (- width) width (- height) height -50.0 50.0)))))))
  
  
  (method (toggle-projection)
    (set! projection
          (case projection
            ((perspective) 'orthographic)
            ((orthographic) 'perspective))))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method override (camera-speed)
    0.5)
  
  
  (method (initialize-camera)
    (set! zoom-factor 54.5)
    (prepare-camera)
    (reset-camera))
  
  
  (method override (prepare-camera)
    (set! eye (new Vertex 0.0 36.25 40.0))
    (set! eye-sight (new Vertex 0.0 0.0 -1.0))
    (set! right (new Vertex 1.0 0.0 0.0))
    (set! up (new Vertex 0.0 1.0 0.0)))

  
  (method override (zoom-in)
    (if (eq? projection 'perspective)
        (nextmethod)
      (set! zoom-factor (* zoom-factor .75))))
  
  
  (method override (zoom-out)
    (if (eq? projection 'perspective)
        (nextmethod)
      (set! zoom-factor (/ zoom-factor .75))))
  
  
  (method override (zoom-speed)
    10.)
  
  
  (method (strafe-camera center-x)
    (let ((eye-x (get-x~ eye)))
      (if (> center-x (+ eye-x camera-limit))
          (strafe-horizontally (- center-x (+ eye-x camera-limit))))
      (if (< center-x (- eye-x camera-limit))
          (strafe-horizontally (- center-x (- eye-x camera-limit))))))
  
  
  (method (center-camera)
    (unless paused?
      (strafe-camera (get-center-x~ character))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-objects)
    (case projection
      ((perspective)
       (if 3d?
           (gl-enable GL_DEPTH_TEST)
         (gl-disable GL_DEPTH_TEST)))
      ((orthographic)
       (gl-disable GL_DEPTH_TEST)))
    (draw-grid)
    (cond ((not paused?)
           (start~ rps)
           (iterate-sprites draw~)
           (end~ rps))
          (else
           (iterate-sprites draw~)
           (draw-history)))
    (when target
      (draw-target)))
  
  
  (method (draw-target)
    (unless down?
      (let ((x1 (get-left~ target))
            (y1 (get-bottom~ target))
            (z1 (get-far~ target))
            (x2 (get-right~ target))
            (y2 (get-top~ target))
            (z2 (get-near~ target)))
        (case projection
          ((perspective)
           (gl-set-color {Color Red})
           (glLineWidth 10.)
           (render-cube x1 y1 z1 x2 y2 z2
             (lambda (proc)
               (with-gl-begin/end GL_QUADS
                 proc)))
           (glLineWidth 1.))
          ((orthographic)
           (gl-normal 0.0 0.0 1.0)
           (gl-set-color {Color Red})
           (with-gl-begin/end GL_LINE_LOOP
             (lambda ()
               (gl-vertex2f x1 y1)
               (gl-vertex2f x2 y1)
               (gl-vertex2f x2 y2)
               (gl-vertex2f x1 y2))))))))
  
  
  (method (draw-grid)
    (when grid?
      (when grid-x?
        (let ((min -100)
              (max 100))
          (gl-set-color {Color Yellow})
          (with-gl-begin/end GL_LINES
            (lambda ()
              (loop (for y from min to max by 5)
                    (gl-vertex grid-x y min)
                    (gl-vertex grid-x y max))
              (loop (for z from min to max by 5)
                    (gl-vertex grid-x min z)
                    (gl-vertex grid-x max z))))))
      (when grid-y?
        (let ((min -100)
              (max 100))
          (gl-set-color {Color Green})
          (with-gl-begin/end GL_LINES
            (lambda ()
              (loop (for x from min to max by 5)
                    (gl-vertex x grid-y min)
                    (gl-vertex x grid-y max))
              (loop (for z from min to max by 5)
                    (gl-vertex min grid-y z)
                    (gl-vertex max grid-y z))))))
      (when grid-z?
        (let ((min -100)
              (max 100))
          (gl-set-color {Color Red})
          (with-gl-begin/end GL_LINES
            (lambda ()
              (loop (for x from min to max by 5)
                    (gl-vertex x min grid-z)
                    (gl-vertex x max grid-z))
              (loop (for y from min to max by 5)
                    (gl-vertex min y grid-z)
                    (gl-vertex max y grid-z))))))))
  
  
  (method (draw-history)
    (let ((step 1)
          (max 1000))
      ;; past
      (loop (for n from (- now 1) downto (history-first) by step)
            (repeat max)
            (draw-character n))
      ;; future
      (loop (for n from now to (history-last) by step)
            (repeat max)
            (draw-character n))))
  
  
  (method (draw-character n)
    (let ((snapshot (get-snapshot~ (historical-moment n))))
      (let ((character (find-character snapshot)))
        (when character
          (parameterize ((in-history? #t))
            (draw~ character))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method override (draw-interface)
    (nextmethod)
    (when info?
      (draw~ info))
    (when message
      (draw-message))
    (when tps?
      (draw~ tps))
    (when rps?
      (draw~ rps))
    (when paused?
      (draw-history-slider)))
  
  
  (method (draw-history-slider)
    (let ((cx (fxround/ width 2)))
      (gl-frame-rect (new Rect (- cx 200) (- height 30) (+ cx 200) (- height 31)) {Color Gray})
      (gl-frame-rect (new Rect (- cx 200) (- height 32) (+ cx 200) (- height 33)) {Color Light-Gray})
      (let ((h (+ (fxround (- (* (/ (cast <fl> now) (history-end)) 400.) 200.)) cx)))
        (gl-segment-circle (new Point h (- height 32)) 7 {Color Light-Blue} 100))))
  
  
  ;;;
  ;;;; Win / Lose
  ;;;
  
  
  (method (win)
    (win~ character)
    (let ((block (find-if (lambda (obj)
                            (eq? (get-user-data~ obj) 'win))
                          blocks)))
      (set-color~ block {Color Blue}))
    (unless paused?
      (sleep .5)
      (reset-position~ character)
      (reset-state~ character)
      (reset-game)))
  
  
  (method (lose)
    (lose~ character)
    (unless paused?
      (sleep .5)
      (reset-position~ character)
      (reset-state~ character)
      (reset-game)))
  
  
  (method (reset-game)
    (setup-history))
    
  
  ;;;
  ;;;; Save / Open
  ;;;
  
  
  (slot moniker   initialize #f)
  (slot modified? initialize #f)

  
  (method (new-world)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (set! target #f)
    (set! moniker #f)
    (center-camera)
    (reset-counters))
  
  
  (method (save-world)
    (if (not moniker)
        (save-as-world)
      (save-to moniker)))
  
  
  (method (save-as-world)
    (let ((file (choose-new-file default-extension: "wrl" extensions: '(("World Files" . "wrl")) directory: {Directory Home ".world"})))
      (save-to file)
      (set! moniker file)
      (update-title)))
  
  
  (method (save-to file)
    (call-with-output-file (path-settings file)
      (lambda (output)
        (iterate-sprites
          (lambda (obj)
            (format output "{s}{%}" (serialize-sprite~ obj))))))
    (set-modified? #f))
  
  
  (method (open-world)
    (open-file (choose-file title: "Choose World File" extensions: '(("World Files" . "wrl")) directory: {Directory Home ".world"})))
  
  
  (method (open-file file)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (call-with-input-file (path-settings file)
      (lambda (input)
        (let (iter)
          (let ((info (read input)))
            (when (not (eof-object? info))
              (bind (class x y z) info
                (when (eq? class 'character)
                  (set! start-x x)
                  (set! start-y y)
                  (set! start-z z))
                (add-sprite class (new Vertex x y z))
                (iter)))))))
    (set! moniker file)
    (setup-world)
    (setup-history)
    (update-title)
    (center-camera)
    (reset-counters))
  
  
  (method (revert-world)
    (if moniker
        (open-file moniker)
      (bell)))
  
  
  (method (update-title)
    (define (present-title)
      (format "World - {a}{a}{a}"
              (present-name)
              (present-modified)
              (present-directory)))
    
    (define (present-name)
      (if (not moniker)
          "New"
        (get-name~ moniker)))
    
    (define (present-modified)
      (if modified?
          " *"
        ""))
    
    (define (present-directory)
      (if (not moniker)
          ""
        (let ((parent (get-parent~ moniker)))
          (if (not parent)
              ""
            (format " ~{{a}}" (present-location~ parent))))))
    
    (set-title~ window (present-title)))
  
  
  (method (set-modified? flag)
    (when (neq? flag modified?)
      (set! modified? flag)
      (update-title)))
  
  
  (method (reset-live)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (set! target #f)
    (reset-world)
    (center-camera)
    (reset-counters))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot down?            <bool>   initialize #f  getter generate)
  (slot deleting?        <bool>   initialize #f  getter generate)
  (slot grid-x           <fl>     initialize 0.  getter generate)
  (slot grid-y           <fl>     initialize 0.  getter generate)
  (slot grid-z           <fl>     initialize 10. getter generate)
  (slot grid?            <bool>   initialize #f  getter generate)
  (slot grid-x?          <bool>   initialize #f  getter generate)
  (slot grid-y?          <bool>   initialize #f  getter generate)
  (slot grid-z?          <bool>   initialize #f  getter generate)
  (slot last-added       <object> initialize #f  getter generate)
  (slot characters-folio <Folio>                 getter generate)
  (slot enemies-folio    <Folio>                 getter generate)
  (slot blocks-folio     <Folio>                 getter generate)
  
  
  (method (prepare-editor)
    (set! characters-folio (new Folio 'character '(character pacman)))
    (set! enemies-folio (new Folio 'turtle '(turtle)))
    (set! blocks-folio (new Folio 'block '(block block-blue block-green))))
  
  
  (method (find-block vert)
    (continuation-capture
      (lambda (return)
        (iterate-sprites
          (lambda (obj)
            (let ((left (get-left~ obj))
                  (right (get-right~ obj))
                  (bottom (get-bottom~ obj))
                  (top (get-top~ obj))
                  (far (get-far~ obj))
                  (near (get-near~ obj)))
              (when (and (>= (get-x~ vert) left)
                         (>= (get-y~ vert) bottom)
                         (>= (get-z~ vert) far)
                         (<  (get-x~ vert) right)
                         (<  (get-y~ vert) top)
                         (<  (get-z~ vert) near))
                (continuation-return return obj)))))
        #f)))
  
  
  (method (screen->world h v)
    (let ((ratio (/ (cast <fl> width) (cast <fl> height)))
          (ch (- h (fxfloor/ width 2)))
          (cv (- (- height v) (fxfloor/ height 2))))
      (define (perspective->world norm plane-k)
        (let ((norm-eye-sight-dot-product (dot-product norm (vertex-normalize eye-sight))))
          (unless (and (= norm-eye-sight-dot-product 0.)
                       (cond (grid-x? (= (get-x~ eye) grid-x))
                             (grid-y? (= (get-y~ eye) grid-y))
                             (grid-z? (= (get-z~ eye) grid-z))))
            (let ((f-over-y (/ PI/4 2)))
              (let ((cone (tan f-over-y))
                    (d (vertex-distance eye eye-target))
                    (right (cross-product (vertex2- eye-target eye) up)))
                (let ((target-in-eye-space (vertex+ (vertex-scalar* up (/ (* cv d cone 2.) height))
                                                    (vertex+ (vertex-scalar* right (/ (* ch d cone 2. ratio) width))
                                                             eye-target))))
                  (let ((intersect (/ (- plane-k (dot-product norm eye))
                                      (dot-product (vertex2- target-in-eye-space eye) norm))))
                    (unless (<= intersect 0)
                      (let ((point (vertex+ eye (vertex-scalar* (vertex2- target-in-eye-space eye) intersect))))
                        point)))))))))
      
      (define (orthographic->world)
        (let ((x (+ (/ (* 2. ch zoom-factor) width) (get-x~ eye)))
              (y (+ (/ (* 2. cv zoom-factor) height ratio) (get-y~ eye))))
         (new Vertex x y 0.)))
      
      (case projection
        ((perspective)
         (cond (grid-x? (let ((vert (perspective->world (new Vertex 1. 0. 0.) grid-x)))
                          (and vert (new Vertex
                                      grid-x
                                      (get-y~ vert)
                                      (get-z~ vert)))))
               (grid-y? (let ((vert (perspective->world (new Vertex 0. 1. 0.) grid-y)))
                          (and vert (new Vertex
                                      (get-x~ vert)
                                      grid-y
                                      (get-z~ vert)))))
               (grid-z? (let ((vert (perspective->world (new Vertex 0. 0. 1.) grid-z)))
                          (and vert (new Vertex
                                      (get-x~ vert)
                                      (get-y~ vert)
                                      grid-z))))
               (else (bell)
                     #f)))
        ((orthographic)
         (orthographic->world)))))
  
  
  (method (add-sprite class vert)
    (let ((x (* (floor (/ (get-x~ vert) 5.)) 5.))
          (y (* (floor (/ (get-y~ vert) 5.)) 5.))
          (z (* (floor (/ (get-z~ vert) 5.)) 5.)))
      (let ((sprite
              (case class
                ((character)
                 (add-actor (new Character self x y z 4. 4. 4. character-texture color: {Color red: 173 green: 12 blue: 230})))
                ((pacman)
                 (add-actor (new Pacman self x y z 4. 4. 4. character-texture color: {Color Yellow})))
                ((turtle)
                 (add-actor (new Turtle self x y z 2. 2. 2. turtle-texture color: {Color Green})))
                ((block)
                 (add-block (new Block self x y z 5.0 5.0 5.0 block-texture color: {Color red: 134 green: 82 blue: 1})))
                ((block-blue)
                 (add-block (new Block-Blue self x y z 5.0 5.0 5.0 block-texture)))
                ((block-green)
                 (add-block (new Block-Green self x y z 5.0 5.0 5.0 block-texture))))))
        (when (is? sprite Character)
          (when character
            (remove-sprite character))
          (set! character sprite))
        sprite)))
  
  
  (method (editor-add-sprite class vert)
    (let ((sprite (add-sprite class vert)))
      (set! last-added sprite)
      sprite))
  
  
  (method (editor-sprite-class)
    (cond ((alt-down?) (get-class~ characters-folio))
          ((shift-down?) (get-class~ enemies-folio))
          (else (get-class~ blocks-folio))))
  
  
  (method (sprite-folio sprite)
    (typecase sprite
      ((Character) characters-folio)
      ((Enemy) enemies-folio)
      ((Block) blocks-folio)
      (else #f)))
  
  
  (method (forward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (next-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)))))
  
  
  (method (backward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (previous-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)))))
  
  
  (method (change-class sprite class)
    (let ((vert (new Vertex (get-x~ sprite) (get-y~ sprite) (get-z~ sprite))))
      (remove-sprite sprite)
      (editor-add-sprite class vert)))
  
  
  (method (remove-target)
    (if (not target)
        (bell)
      (remove-sprite target)
      (set-modified? #t)))
  
  
  (method (remove-sprite obj)
    (typecase obj
      ((Actor) (set! actors (remove! obj actors)))
      ((Block) (set! blocks (remove! obj blocks))))
    (set! sprites (remove! obj sprites))
    (set! target #f))
  
  
  (method (toggle-grid)
    (set! grid? (not grid?))
    (activate-3d))
  
  
  (method (toggle-grid-x)
    (set! grid-x? (not grid-x?))
    (when grid-x?
      (set! grid? #t)
      (set! grid-y? #f)
      (set! grid-z? #f)
      (activate-3d)))
  
  
  (method (toggle-grid-y)
    (set! grid-y? (not grid-y?))
    (when grid-y?
      (set! grid? #t)
      (set! grid-x? #f)
      (set! grid-z? #f)
      (activate-3d)))
  
  
  (method (toggle-grid-z)
    (set! grid-z? (not grid-z?))
    (when grid-z?
      (set! grid? #t)
      (set! grid-x? #f)
      (set! grid-y? #f)
      (activate-3d)))
  
  
  (method (decrease-grid)
    (cond (grid-x? (decrease! grid-x 5.))
          (grid-y? (decrease! grid-y 5.))
          (grid-z? (decrease! grid-z 5.))))
  
  
  (method (increase-grid)
    (cond (grid-x? (increase! grid-x 5.))
          (grid-y? (increase! grid-y 5.))
          (grid-z? (increase! grid-z 5.))))
  
  
  (method (editor-mouse-down h v)
    (let ((vert (screen->world h v)))
      (when vert
        (let ((obj (find-block vert)))
          (if obj
              (if (control-down?)
                  (begin
                    (remove-sprite obj)
                    (set! down? #t)
                    (set! deleting? #t)
                    (set-modified? #t)
                    (update-future))
                (set! target obj)
                (set-?t obj))
            (if (control-down?)
                (begin
                  (set! down? #t)
                  (let ((class (editor-sprite-class)))
                    (editor-add-sprite class vert)
                    (set-modified? #t))
                  (update-future))
              (set! target #f)
              (set-?t #f)))))))
  
  
  (method (editor-mouse-move h v)
    (when down?
      (let ((vert (screen->world h v)))
        (when vert
          (let ((obj (find-block vert)))
            (if obj
                (when deleting?
                  (remove-sprite obj)
                  (set-modified? #t)
                  (update-future))
              (unless deleting?
                (let ((class (editor-sprite-class)))
                  (editor-add-sprite class vert)
                  (set-modified? #t))
                (update-future))))))))
  
  
  (method (editor-mouse-up h v)
    (set! down? #f)
    (set! deleting? #f))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-hook? initialize #t getter generate)
  
  
  (method (toggle-paused)
    (if paused?
        (unpause-world)
      (pause-world)))
  
  
  (method (toggle-evaluation)
    (set! evaluate-hook? (not evaluate-hook?))
    (display-message (format "Evaluation {a}" (if evaluate-hook? "on" "off"))))
  
  
  (method (pause-world)
    (set! current (snapshot-world))
    (set! paused? #t)
    (set! animate? #f)
    (reset-counters))
  
  
  (method (unpause-world)
    (truncate-future)
    (set! current #f)
    (set! paused? #f)
    (set! animate? #t)
    (reset-counters))
  
  
  (method (snapshot-world)
    (map object-copy actors))
  
  
  (method (load-world snapshot)
    (let ((previous-target target))
      (set! actors (map object-copy snapshot))
      (set! sprites (append blocks actors))
      (set! character (find-character actors))
      (set! target (and previous-target (find-target previous-target sprites)))
      (set-?t target)))
  
  
  (method (find-character snapshot)
    (find-if (lambda (obj)
               (is? obj Character))
             snapshot))
  
  
  (method (find-target target snapshot)
    (let ((origin (get-origin~ target)))
      (find-if (lambda (obj)
                 (eq? (get-origin~ obj) origin))
               snapshot)))
  
  
  (method override (evaluate-hook)
    (when evaluate-hook?
      (update-future)))
  
  
  (method (test-world)
    )
  
  
  ;;;
  ;;;; Slider
  ;;;
  
  
  (slot sliding? initialize #f)
  
  
  (method (slider-mouse-down h v)
    (set! sliding? #t)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-move h v)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-up h v)
    (set! sliding? #f))
  
  
  (method (h->where h)
    (let ((cx (fxround/ width 2)))
      (let ((where (/ (+ (- h cx) 200.) 400.)))
        (max 0. (min 1. where)))))
  
  
  (method (in-slider? v)
    (< v 60))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down h v)
    (if (and paused? (in-slider? v))
        (slider-mouse-down h v)
      (editor-mouse-down h v)))
  
  
  (method override (mouse-move h v)
    (if (and paused? sliding?)
        (slider-mouse-move h v)
      (if last-point
          (nextmethod h v)
        (editor-mouse-move h v))))
  
  
  (method override (mouse-up h v)
    (if (and paused? sliding?)
        (slider-mouse-up h v)
      (if last-point
          (nextmethod h v)
        (editor-mouse-up h v))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (process-keys)
    (let ((evt (make-event Keyboard-Event :char self)))
      ;; camera
      (unless (key-down? (char->integer #\space))
        (process-movement evt))
      ;; character
      (when (eq? window (get-window-focus))
        (receive (shift? control? alt?) (modifiers-down)
          (unless (or shift? control? alt?)
            (when (key-down? VK_LEFT)
              (move-left))
            (when (key-down? VK_RIGHT)
              (move-right))
            (when (key-down? VK_DOWN)
              (move-down))
            (when (key-down? VK_UP)
              (move-up))
            (when (key-down? (char->integer #\space))
              (space)))))))
  
  
  (method override (process-shortcut shortcut)
    (continuation-capture
      (lambda (return)
        (cond ;; select
              ((shortcut=? shortcut {Shortcut :alt #\1}) (select-bubbles))
              ((shortcut=? shortcut {Shortcut :alt #\2}) (select-snakes))
              ((shortcut=? shortcut {Shortcut :alt #\3}) (select-tree))
              ((shortcut=? shortcut {Shortcut :alt #\4}) (select-live))
              ;; world
              ((shortcut=? shortcut {Shortcut :control #\N}) (new-world))
              ((shortcut=? shortcut {Shortcut :control #\S}) (save-world))
              ((shortcut=? shortcut {Shortcut :control #\O}) (open-world))
              ((shortcut=? shortcut {Shortcut :control #\R}) (revert-world))
              ((shortcut=? shortcut {Shortcut #\0}) (reset-live))
              ;; editor
              ((shortcut=? shortcut {Shortcut :control #\1}) (toggle-grid-z))
              ((shortcut=? shortcut {Shortcut :control #\2}) (toggle-grid-y))
              ((shortcut=? shortcut {Shortcut :control #\3}) (toggle-grid-x))
              ((shortcut=? shortcut {Shortcut :control Left}) (decrease-grid))
              ((shortcut=? shortcut {Shortcut :control Right}) (increase-grid))
              ((shortcut=? shortcut {Shortcut :control Tab}) (forward-sprite-class))
              ((shortcut=? shortcut {Shortcut :control :shift Tab}) (backward-sprite-class))
              ;; debug
              ((shortcut=? shortcut {Shortcut :control #\T}) (test-world))
              (else (continuation-return return #f)))
        #t)))
  
  
  (method override (key-press key)
    (let ((evt (make-event Keyboard-Event :char self key: key)))
      (case key
        ;; editor
        ((#\backspace) (remove-target))
        ((#\g) (toggle-grid))
        ;; debug
        ((#\p #\tab) (toggle-paused))
        ((#\\) (toggle-evaluation))
        ((#\[) (backward-history))
        ((#\]) (forward-history))
        ((#\return) (step-world))
        ((#\c) (clear-terminal))
        ;; projection
        ((#\1) (first-person))
        ((#\3) (toggle-3d))
        ;; camera
        ((#\9) (initialize-camera))
        ;; music
        ((#\m) (change-music))
        ;; settings
        ((#\u) (toggle-interface))
        ((#\-) (toggle-counters))
        ((#\_) (reset-counters))
        ((#\=) (toggle-axes))
        ((#\i) (toggle-info))
        ((#\h) (toggle-polygon-mode))
        ((#\l) (toggle-lighting))
        ((#\f) (toggle-fullscreen))
        ((#\v) (toggle-projection))
        ((#\t) (toggle-textures)))))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (first-person)
    (if first-person?
        (set! first-person? #f)
      (set! first-person? #t)
      (set! eye (new Vertex 0.0 2.5 40.0))
      (set! eye-sight (new Vertex 0.0 0.0 -1.0))
      (set! right (new Vertex 1.0 0.0 0.0))
      (set! up (new Vertex 0.0 1.0 0.0))
      (reset-camera)
      (activate-3d)))
    
  
  (method (toggle-3d)
    (if 3d?
        (deactivate-3d)
      (activate-3d)))
  
  
  (method (activate-3d)
    (set! 3d? #t)
    (set! light? #t)
    (set! projection 'perspective))
  
  
  (method (deactivate-3d)
    (set! 3d? #f)
    (set! light? #f)
    (set! projection 'orthographic))

  
  (method (toggle-textures)
    (set! textures? (not textures?)))
  
  
  (method (toggle-axes)
    (set-visible?~ axes (not (get-visible?~ axes))))
  
  
  (method (toggle-info)
    (set! info? (not info?)))
  
  
  (method (toggle-counters)
    (set! tps? (not tps?))
    (set! rps? (not rps?))
    (reset-counters))
  
  
  (method (reset-counters)
    (reset~ tps)
    (reset~ rps))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method (display-message msg)
    (set! message msg)
    (set! message-time (time->seconds (current-time))))
  
  
  (method (draw-message)
    (if (> (- (time->seconds (current-time)) message-time) 1.)
        (begin
          (set! message #f)
          (set! message-time #f))
      (let ((surface (get-surface~ message-texture))
            (font {Font Heading1})
            (color {Color Red}))
        (set-operator~ surface CAIRO_OPERATOR_CLEAR)
        (paint~ surface)
        (set-operator~ surface CAIRO_OPERATOR_OVER)
        (set-font~ surface font)
        (set-color~ surface color)
        (draw-text~ surface 0 10 message)
        (map-texture~ message-texture)
        (let ((w (text-width~ font message)))
          (let ((c (center w width)))
            (with-gl-matrix
              (lambda ()
                (gl-translate (cast <fl> c) (cast <fl> (- height 200)) 0.0)
                (textured-quad~ message-texture
                  (lambda () (gl-vertex 0.0 0.0 0.0))
                  (lambda () (gl-vertex 250.0 0.0 0.0))
                  (lambda () (gl-vertex 250.0 100.0 0.0))
                  (lambda () (gl-vertex 0.0 100.0 0.0))))))))))
  
  
  ;;;
  ;;;; Info
  ;;;
  
  
  (method (debug-info)
    (define (present-object obj)
      (format "~{{s} #{s}}"
              (reference-name (get-name~ (class-of obj)))
              (object->serial obj)))
    
    (define (present-boolean bool)
      (if bool "true" "false"))
    
    (define (present-history)
      (define (present-coordinates obj)
        (format "{r precision: 1} {r precision: 1}" (get-x~ obj) (get-y~ obj)))
      
      `(,(format "c -> {a}" (present-coordinates character))
        ,@(loop (for n from 0 to (history-last))
                (collect
                  (let ((moment (historical-moment n)))
                    (let ((snapshot (get-snapshot~ moment))
                          (commands (get-commands~ moment)))
                      (let ((character (find-character snapshot)))
                        (format "{a} -> {a}" n (present-coordinates character)))))))))
    
    `(,(format "window: {a}" (present-object window))
      ,(format "width: {s}" width)
      ,(format "height: {s}" height)
      ""
      ,(format "self: {s}" self)
      ,(format "actors: {s}" (length actors))
      ,(format "blocks: {s}" (length blocks))
      ,(format "sprites: {s}" (length sprites))
      ""
      ,(format "history: {s}" (history-end))
      ,(format "now: {s}" now)
      ,@(if (and paused? (< (history-end) 5))
            (present-history)
          '())
      ""
      ,(format "projection: {s}" projection)
      ,(format "eye: {s}" eye)
      ,(format "eye-sight: {s}" eye-sight)
      ,(format "eye-target: {s}" eye-target)
      ,(format "right: {s}" right)
      ,(format "up: {s}" up)
      ,(format "camera-distance: {s}" camera-distance)
      ,(format "zoom-factor: {s}" zoom-factor)
      ""
      ,@(if information
            `(,@information
              "")
          '())
      ,(format "character: {a}" (present-object character))
      ,(format "  x: {r precision: 1}" (get-x~ character))
      ,(format "  y: {r precision: 1}" (get-y~ character))
      ,(format "  z: {r precision: 1}" (get-z~ character))
      ,(format "  width: {s}" (get-width~ character))
      ,(format "  height: {s}" (get-height~ character))
      ,(format "  depth: {s}" (get-depth~ character))
      ,(format "  texture: {s}" (get-texture~ character))
      ,(format "  color: {s}" (get-color~ character))
      ,(format "  user-data: {s}" (get-user-data~ character))
      ,(format "  vx: {s}" (get-vx~ character))
      ,(format "  vy: {s}" (get-vy~ character))
      ,(format "  vz: {s}" (get-vz~ character))
      ,(format "  jumping?: {a}" (present-boolean (get-jumping?~ character)))
      ,(format "  facing: {s}" (get-facing~ character))
      ,(format "  state: {s}" (get-state~ character))
      ""
      ,@(if target
            `(,(format "target: {a}" (present-object target))
              ,(format "  x: {r precision: 1}" (get-x~ target))
              ,(format "  y: {r precision: 1}" (get-y~ target))
              ,(format "  z: {r precision: 1}" (get-z~ target))
              ,(format "  width: {s}" (get-width~ target))
              ,(format "  height: {s}" (get-height~ target))
              ,(format "  depth: {s}" (get-depth~ target))
              ,(format "  texture: {s}" (get-texture~ target))
              ,(format "  color: {s}" (get-color~ target))
              ,(format "  user-data: {s}" (get-user-data~ target))
              "")
          '())
      ,(format "animate?: {a}" (present-boolean animate?))
      ,(format "light?: {a}" (present-boolean light?))
      ,(format "music?: {a}" (present-boolean music?))
      ,(format "3d?: {a}" (present-boolean 3d?))
      ,(format "textures?: {a}" (present-boolean textures?))
      ,(format "paused?: {a}" (present-boolean paused?))))
  
  
  (method (reset-information)
    (set! information #f))
  
  
  (method (set-information info)
    (set! information info))
  
  
  (method (add-information info)
    (set! information (append (or information '()) (list (->string info))))))


;;;
;;;; Info
;;;


(class Info extends World-Object
  
  
  (slot texture <object> getter generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (set! texture (make-cairo-texture 500 800)))
  
  
  (method override (draw)
    (let ((surface (get-surface~ texture)))
      (set-operator~ surface CAIRO_OPERATOR_CLEAR)
      (paint~ surface)
      (set-operator~ surface CAIRO_OPERATOR_OVER)
      (set-font~ surface {Font font-name: "Courier New" point-size: 10 antialias: none})
      (set-color~ surface {Color Red})
      (let ((rank 0))
        (for-each (lambda (info)
                    (draw-text~ surface 10 (+ 10 (* rank 15)) (->string info))
                    (increase! rank))
                  (debug-info~ world)))
      (map-texture~ texture)
      (with-gl-matrix
        (lambda ()
          (gl-translate 0.0 0.0 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex 0.0 0.0 0.0))
            (lambda () (gl-vertex 500.0 0.0 0.0))
            (lambda () (gl-vertex 500.0 800.0 0.0))
            (lambda () (gl-vertex 0.0 800.0 0.0))))))))


;;;
;;;; Counter
;;;


(class Counter extends World-Object
  
  
  (slot texture <object> getter generate)
  (slot count   <number> getter generate)
  (slot elapse  <fl>     getter generate)
  (slot rate    <fl>     getter generate)
  (slot started <fl+>    getter generate)
  (slot title   <string> getter generate)
  (slot vert    <fl>     getter generate)
  
  
  (method override (initialize world x y z t v)
    (nextmethod world x y z)
    (set! texture (make-cairo-texture 150 35))
    (set! rate 0.0)
    (set! title t)
    (set! vert v)
    (reset))
  
  
  (method (reset)
    (set! elapse 0.)
    (set! count 0))
  
  
  (method (start)
    (set! started (time->seconds (current-time))))
  
  
  (method (end)
    (increase! count)
    (let ((ended (time->seconds (current-time))))
      (increase! elapse (- ended started)))
    (set! rate (/ count elapse)))
  
  
  (method override (draw)
    (draw-rate))
  
  
  (method (draw-rate)
    (let ((surface (get-surface~ texture)))
      (set-operator~ surface CAIRO_OPERATOR_CLEAR)
      (paint~ surface)
      (set-operator~ surface CAIRO_OPERATOR_OVER)
      (set-font~ surface {Font Heading2})
      (set-color~ surface {Color Red})
      (draw-text~ surface 0 10 (format "{a}: {r precision: 0}" title rate))
      (map-texture~ texture)
      (with-gl-matrix
        (lambda ()
          (gl-translate 10.0 vert 0.0)
          (textured-quad~ texture
            (lambda () (gl-vertex 0.0 0.0 0.0))
            (lambda () (gl-vertex 150.0 0.0 0.0))
            (lambda () (gl-vertex 150.0 35.0 0.0))
            (lambda () (gl-vertex 0.0 35.0 0.0)))))))))
