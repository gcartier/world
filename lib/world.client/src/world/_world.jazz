;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World
;;;


(module world jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl)
        (jazz.graphic.opengl.platform)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world.client)
        (world.geometry)
        (world.object)
        (world.texture))


;; TODO
;; - We are redoing all the camera stuff all the time in draw-world


(class World extends Component
  
  
  (slot window          <OpenGL-Window> initialize #f       accessors generate)
  (slot width           <fx>            initialize #f       accessors generate)
  (slot height          <fx>            initialize #f       accessors generate)
  (slot boundaries      <Cuboid+>       initialize #f       getter generate)
  (slot objects         <list>          initialize '()      getter generate)
  (slot eye             <f32vector>     initialize #f       getter generate)
  (slot eye-lookat      <LookAt>        initialize #f       getter generate)
  (slot eye-target      <f32vector>     initialize #f       getter generate)
  (slot world-up        <f32vector>     initialize #f       getter generate)
  (slot animate?        <bool>          initialize #t       getter generate)
  (slot light?          <bool>          initialize #t       getter generate)
  (slot mode            <symbol>        initialize 'explore getter generate)
  (slot what            <object>        initialize #f       getter generate)
  (slot target          <object>        initialize #f       getter generate)
  (slot last-point      <object>        initialize #f       getter generate)
  (slot last-time       <object>        initialize #f       getter generate)
  (slot camera-distance <fl>            initialize 0.6      getter generate)
  (slot polygon-mode    <fx>            initialize GL_FILL  getter generate)
  (slot fps             <object>        initialize #f       getter generate)
  (slot fps?            <bool>          initialize #f       getter generate)
  (slot interface?      <bool>          initialize #t       getter generate)
  (slot music?          <bool>          initialize #f       getter generate)
  (slot test            <object>        initialize #f       getter generate)
  
  
  (method override (initialize)
    (prepare-camera)
    (update-camera)
    (set! world-up (vertex 0. 1. 0.))
    (when music?
      (change-music)))
  
  
  (method override (destroy)
    (nextmethod)
    (close-music "ambiance"))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method (is-active?)
    (eq? self (current-world)))
  
  
  (method (is-inactive?)
    (not (is-active?)))
  
  
  ;;;
  ;;;; Window
  ;;;
  
  
  (method protected virtual (setup-opengl)
    (let ((size (get-size~ window)))
      (set! width (get-width~ size))
      (set! height (get-height~ size)))
    (glPolygonMode GL_FRONT GL_FILL)
    (glMatrixMode GL_MODELVIEW)
    (glEnable GL_NORMALIZE))
  
  
  (method protected virtual (initialize-world)
    (set! fps (new FPS self 0.0 0.0 0.0))
    (set! test (make-cairo-texture 200 200)))
  
  
  (method (add-object object)
    (set! objects (cons object objects))
    object)
  
  
  (method (reset-world)
    (set! objects '())
    (initialize-world))
  
  
  (method protected virtual (draw-world)
    (process-keys)
    (prepare-world)
    (setup-camera)
    (setup-lighting)
    (update-fps~ fps)
    (glEnable GL_DEPTH_TEST)
    (draw-objects)
    (render-interface))
  
  
  (method protected virtual (prepare-world)
    (glClear (bitwise-ior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
    (prepare-projection)
    (glMatrixMode GL_MODELVIEW)
    (glLoadIdentity)
    (glDisable GL_LIGHTING)
    (glDisable GL_LIGHT0)
    (glDisable GL_LIGHT1)
    (glEnable GL_BLEND)
    (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA))
  
  
  (method protected virtual (prepare-projection)
    (glMatrixMode GL_PROJECTION)
    (glLoadIdentity)
    (let ((ratio (/ (cast <fl> width) (cast <fl> height))))
      (gluPerspective 45.0 ratio 0.1 100.0)))
  
  
  (method (change-music)
    (set! music? #t)
    (let ((music-dir {Directory Settings "resources" "music"}))
      (when (exists?~ music-dir)
        (let ((music-list (get-content~ music-dir nodes?: #f)))
          (let ((music (random-element music-list)))
            (play-music-file music "ambiance"))))))
  
  
  (method (setup-camera)
    (let ((up (get-up~ eye-lookat)))
      (gluLookAt
        (vertex-x eye) (vertex-y eye) (vertex-z eye)
        (vertex-x eye-target) (vertex-y eye-target) (vertex-z eye-target)
        (vertex-x up) (vertex-y up) (vertex-z up))))
  
  
  (method (setup-lighting)
    (when light?
      (glEnable GL_LIGHTING)
      (glEnable GL_LIGHT0)
      (glEnable GL_LIGHT1)
      (gl-material-specular GL_FRONT 0.1 0.1 0.1 1.0)
      (gl-material-shininess GL_FRONT 50.0)
      (gl-light-model GL_LIGHT_MODEL_AMBIENT 0.2 0.2 0.2 1.0)
      ;; positioned light
      (gl-light GL_LIGHT0 GL_DIFFUSE 0.5 0.5 0.5 1.0)
      (gl-light GL_LIGHT0 GL_POSITION 4.0 0.0 8.0 1.0)
      ;; directed light
      (gl-light GL_LIGHT1 GL_DIFFUSE 0.5 0.5 0.4 1.0)
      (gl-light GL_LIGHT1 GL_POSITION -1.0 0.5 0.5 0.0)
      @debug-lighting
      (draw-sphere 4.0 0.0 8.0 0.5 26 52 {Color Orange})
      @debug-lighting
      (draw-sphere -1.0 0.5 0.5 0.5 26 52 {Color Yellow})))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method protected virtual (process-keys)
    )
  
  
  (method protected virtual (key-down c)
    )
  
  
  (method protected virtual (key-press c)
    )
  
  
  (method protected virtual (process-shortcut shortcut)
    #f)
  
  
  (method (process-movement evt)
    (when (eq? window (get-window-focus))
      (let ((shift? (get-shift?~ evt))
            (control? (get-control?~ evt))
            (alt? (get-alt?~ evt)))
        (unless (or shift? control? alt?)
          (when (key-down? (char->integer #\W))
            (move-forward))
          (when (key-down? (char->integer #\S))
            (move-backward))
          (when (key-down? (char->integer #\Q))
            (strafe-left))
          (when (key-down? (char->integer #\E))
            (strafe-right))
          (when (or (key-down? (char->integer #\R))
                    (key-down? (char->integer #\space)))
            (strafe-up))
          (when (key-down? (char->integer #\X))
            (strafe-down))
          (when (key-down? (char->integer #\A))
            (rotate-left))
          (when (key-down? (char->integer #\D))
            (rotate-right))))))
  
  
  ;;;
  ;;;; Music
  ;;;
  
  
  (method (play-music-file file name)
    (when (exists?~ file)
      (close-music name)
      (open-music file name)
      (play-music name)))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method protected virtual (draw-objects)
    (for-each (lambda (object)
                (when (get-visible?~ object)
                  (draw~ object)))
              objects))
  
  
  (method (render-interface)
    (when (or interface? fps?)
      (glDisable GL_LIGHTING)
      (glDisable GL_LIGHT0)
      (glDisable GL_LIGHT1)
      (glMatrixMode GL_MODELVIEW)
      (glLoadIdentity)
      (glMatrixMode GL_PROJECTION)
      (glEnable GL_BLEND)
      (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
      (glPushMatrix)
      (glLoadIdentity)
      (glOrtho 0.0 (exact->inexact width) 0.0 (exact->inexact height) -10.0 10.0)
      (when interface?
        (draw-interface)
        @test (
               (glColor3f 1.0 0.0 0.0)
               (let ((surface (get-surface~ test)))
                 (set-operator~ surface CAIRO_OPERATOR_CLEAR)
                 (paint~ surface)
                 (set-operator~ surface CAIRO_OPERATOR_SOURCE)
                 (let ((color {Color Red alpha: 0.5}))
                   (ellipse~ surface {Rect 0 0 200 200} color color)))
               (map-texture~ test)
               (glPushMatrix)
               (glTranslatef (exact->inexact (- width 200)) 0.0 0.0)
               (textured-quad~ test
                 (lambda () (glVertex3f 0.0   0.0 0.0))
                 (lambda () (glVertex3f 200.0   0.0 0.0))
                 (lambda () (glVertex3f 200.0 200.0 0.0))
                 (lambda () (glVertex3f 0.0 200.0 0.0)))
               (glPopMatrix)))
      (glPopMatrix)))
  
  
  (method protected virtual (draw-interface)
    (when fps?
      (draw~ fps)))
  
  
  ;;;
  ;;;; Backend
  ;;;
  
  
  (method (gl-pixel point color)
    (let ((x (cast <fl> (get-h~ point)))
          (y (cast <fl> (get-v~ point))))
      (gl-colorize color)
      (glBegin GL_POINTS)
      (glVertex2f x y)
      (glEnd)))
  
  
  (method (gl-line from to color)
    (let ((x1 (cast <fl> (get-h~ from)))
          (y1 (cast <fl> (get-v~ from)))
          (x2 (cast <fl> (get-h~ to)))
          (y2 (cast <fl> (get-v~ to))))
      (gl-colorize color)
      (glBegin GL_LINES)
      (glVertex2f x1 y1)
      (glVertex2f x2 y2)
      (glEnd)))
  
  
  (method (gl-fill-rect rect color)
    (let ((x1 (cast <fl> (get-left~ rect)))
          (y1 (cast <fl> (get-top~ rect)))
          (x2 (cast <fl> (get-right~ rect)))
          (y2 (cast <fl> (get-bottom~ rect))))
      (gl-colorize color)
      (glBegin GL_QUADS)
      (glVertex2f x1 y1)
      (glVertex2f x2 y1)
      (glVertex2f x2 y2)
      (glVertex2f x1 y2)
      (glEnd)))
  
  
  (method (gl-frame-rect rect color)
    (let ((x1 (cast <fl> (get-left~ rect)))
          (y1 (cast <fl> (get-top~ rect)))
          (x2 (cast <fl> (get-right~ rect)))
          (y2 (cast <fl> (get-bottom~ rect))))
      (gl-colorize color)
      (glBegin GL_LINE_LOOP)
      (glVertex2f x1 y1)
      (glVertex2f x2 y1)
      (glVertex2f x2 y2)
      (glVertex2f x1 y2)
      (glEnd)))
  
  
  (method (gl-frame-circle center radius color)
    (let ((x (cast <fl> (get-h~ center)))
          (y (cast <fl> (get-v~ center))))
      (gl-colorize color)
      (glBegin GL_LINE_LOOP)
      (loop (for angle from 0 to 365 by 5)
            (glVertex2f (+ x (* (sin angle) radius))
                        (+ y (* (cos angle) radius))))
      (glEnd)))
  
  
  (method (gl-segment-circle center radius color segments)
    (let ((segments (max 3 segments)))
      (let ((cx (cast <fl> (get-h~ center)))
            (cy (cast <fl> (get-v~ center)))
            (theta (/ PI*2 segments)))
        (let ((c (cos theta))
              (s (sin theta))
              (x radius)
              (y 0))
          (gl-colorize color)
          (glBegin GL_LINE_LOOP)
          (loop (for n from 0 below segments)
                (glVertex2f (+ x cx) (+ y cy))
                (let ((t x))
                  (set! x (- (* c x) (* s y)))
                  (set! y (+ (* s t) (* c y)))))
          (glEnd)))))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method protected virtual (prepare-camera)
    (set! eye (vertex 0.0 3.0 10.0))
    (set! eye-lookat (new LookAt (vertex 0.0 0.0 -1.0) (vertex 0.0 1.0 0.0) (vertex 1.0 0.0 0.0))))
  
  
  (method (get-me)
    (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) camera-distance)))

  
  (method protected virtual (zoom-in)
    (let ((me (get-me)))
      (increase! camera-distance (- (zoom-speed)))
      (set! eye (vertex+ me (vertex-scalar* (get-sight~ eye-lookat) (- camera-distance))))
      (update-camera)))
  
  
  (method protected virtual (zoom-out)
    (let ((me (get-me)))
      (increase! camera-distance (zoom-speed))
      (set! eye (vertex+ me (vertex-scalar* (get-sight~ eye-lookat) (- camera-distance))))
      (update-camera)))
  
  
  (method protected virtual (zoom-speed)
    0.1)
  
  
  (method (update-camera)
    (set! eye-target (vertex+ eye (get-sight~ eye-lookat))))
  
  
  (method protected virtual (mouse-wheel h v delta)
    (if (> delta 0)
        (zoom-in)
      (zoom-out)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method protected virtual (camera-speed)
    0.05)
  
  
  (method protected virtual (move-forward)
    (set! eye (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) (camera-speed))))
    (update-camera)
    (movement))
  
  
  (method protected virtual (move-backward)
    (set! eye (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) (- (camera-speed)))))
    (update-camera)
    (movement))
  
  
  (method protected virtual (strafe-left)
    (strafe-horizontally (- (* (camera-speed) 2))))
  
  
  (method protected virtual (strafe-right)
    (strafe-horizontally (* (camera-speed) 2)))
  
  
  (method (strafe-horizontally d)
    (set! eye (vertex+ eye (vertex-scalar* (get-right~ eye-lookat) d)))
    (update-camera)
    (movement))
  
  
  (method protected virtual (strafe-up)
    (set! eye (vertex+ eye (vertex-scalar* (get-up~ eye-lookat) (* (camera-speed) 2))))
    (update-camera)
    (movement))
  
  
  (method protected virtual (strafe-down)
    (set! eye (vertex+ eye (vertex-scalar* (get-up~ eye-lookat) (- (* (camera-speed) 2)))))
    (update-camera)
    (movement))
  
  
  (method protected virtual (movement)
    )
  
  
  (definition rotation-speed
    0.02)
  
  
  (method protected virtual (rotate-left)
    (rotate-horizontal rotation-speed))
  
  
  (method protected virtual (rotate-right)
    (rotate-horizontal (- rotation-speed)))
  
  
  (method (rotate-horizontal angle)
    (rotate~ eye-lookat angle world-up)
    (update-camera))
  
  
  (method (rotate-up)
    @wrong-number-of-parameters???
    (rotate-vertical rotation-speed (get-right~ eye-lookat) (get-sight~ eye-lookat)))
  
  
  (method (rotate-down)
    (rotate-vertical (- rotation-speed)))
  
  
  (method (rotate-vertical angle)
    (set-sight~ eye-lookat (vertex-normalize (rotate-upon angle (get-right~ eye-lookat) (get-sight~ eye-lookat))))
    (set-up~ eye-lookat (vertex-normalize (rotate-upon angle (get-right~ eye-lookat) (get-up~ eye-lookat))))
    (update-camera))
  
  
  (method protected virtual (cursor-update)
    (set-cursor :arrow))
  
  
  (method protected virtual (mouse-down h v)
    (set! animate? (not animate?)))
  
  
  (method protected virtual (mouse-move h v)
    (when last-point
      (let ((new-point (new Point h v))
            (new-time (time->seconds (current-time))))
         (let ((elapse (- new-time last-time)))
           (when (> elapse 0)
             (let ((delta (nu- new-point last-point)))
               (let ((dh (get-h~ delta))
                     (dv (get-v~ delta)))
                 (mouse-track elapse dh dv)))))
         (set! last-point new-point)
         (set! last-time new-time))))
  
  
  (method protected virtual (mouse-track elapse dh dv)
    (rotate-horizontal (/ (- dh) 200.))
    (rotate-vertical (/ (- dv) 200.)))
  
  
  (method protected virtual (mouse-up h v)
    (reset-viewing))
  
  
  (method protected virtual (right-mouse-down h v)
    (setup-viewing h v)
    @w
    (case mode
      ((explore)
       (set! animate? (not animate?)))
      ((insert)
       (case what
         ((cube)
          (add-object (new Cube self (random-in 3.0) (random-in 3.0) -6.0)))))))
  
  
  (method protected virtual (right-mouse-up h v)
    (reset-viewing))
  
  
  (method (setup-viewing h v)
    (set! last-point (new Point h v))
    (set! last-time (time->seconds (current-time))))
  
  
  (method (reset-viewing)
    (set! last-point #f)
    (set! last-time #f))
  
  
  ;;;
  ;;;; Objects
  ;;;
    
  
  (method (add-axes . rest)
    (add-object (apply new Axes self rest)))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method protected virtual (evaluate-hook)
    )
  
  
  ;;;
  ;;;; Toggle
  ;;;
  
  
  (method (toggle-interface)
    (set! interface? (not interface?)))
  
  
  (method (toggle-fps)
    (if (shift-down?)
        (reset~ fps)
      (set! fps? (not fps?))))
  
  
  (method (toggle-polygon-mode)
    (set! polygon-mode (ecase polygon-mode
                         ((GL_POINT) GL_LINE)
                         ((GL_LINE) GL_FILL)
                         ((GL_FILL) GL_POINT)))
    (glPolygonMode GL_FRONT_AND_BACK polygon-mode))
  
  
  (method (toggle-lighting)
    (set! light? (not light?)))
  
  
  (method (toggle-fullscreen)
    (toggle-fullscreen~ window))))
