;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World
;;;


(module world jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl)
        (jazz.graphic.opengl.platform)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (time)
        (world.client)
        (world.geometry)
        (world.object)
        (world.texture))


;; TODO
;; - We are redoing all the camera stuff all the time in draw-world


(class World extends Object
  
  
  (slot window          <OpenGL-Window> initialize #f       accessors generate)
  (slot width           <fx>            initialize #f       accessors generate)
  (slot height          <fx>            initialize #f       accessors generate)
  (slot boundaries      <Cuboid+>       initialize #f       getter generate)
  (slot objects         <list>          initialize '()      getter generate)
  (slot eye             <Vertex>        initialize #f       getter generate)
  (slot eye-target      <Vertex>        initialize #f       getter generate)
  (slot eye-sight       <Vertex>        initialize #f       getter generate)
  (slot eye-up          <Vertex>        initialize #f       getter generate)
  (slot eye-right       <Vertex>        initialize #f       getter generate)
  (slot animate?        <bool>          initialize #t       getter generate)
  (slot light?          <bool>          initialize #t       getter generate)
  (slot mode            <symbol>        initialize 'explore getter generate)
  (slot what            <object>        initialize #f       getter generate)
  (slot target          <object>        initialize #f       getter generate)
  (slot last-point      <object>        initialize #f       getter generate)
  (slot camera-distance <fl>            initialize 0.6      getter generate)
  (slot polygon-mode    <fx>            initialize GL_FILL  getter generate)
  (slot fps             <object>        initialize #f       getter generate)
  (slot fps?            <bool>          initialize #f       getter generate)
  (slot interface?      <bool>          initialize #t       getter generate)
  (slot music?          <bool>          initialize #f       getter generate)
  (slot test            <object>        initialize #f       getter generate)
  
  
  (method override (initialize)
    (prepare-camera)
    (update-camera)
    (when music?
      (change-music)))
  
  
  (method override (destroy)
    (nextmethod)
    (close-music "ambiance"))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method (is-active?)
    (eq? self (current-world)))
  
  
  (method (is-inactive?)
    (not (is-active?)))
  
  
  ;;;
  ;;;; Window
  ;;;
  
  
  (method protected virtual (initialize-opengl)
    (let ((size (get-size~ window)))
      (set! width (get-width~ size))
      (set! height (get-height~ size)))
    (gl-polygon-mode GL_FRONT GL_FILL)
    (gl-matrix-mode GL_MODELVIEW)
    (gl-enable GL_NORMALIZE))
  
  
  (method protected virtual (initialize-world)
    (set! fps (new FPS self 0.0 0.0 0.0))
    (set! test (make-cairo-texture 200 200)))
  
  
  (method (add-object object)
    (set! objects (cons object objects))
    object)
  
  
  (method (reset-world)
    (set! objects '())
    (initialize-world))
  
  
  (method protected virtual (draw-world)
    (process-keys)
    (prepare-world)
    (setup-camera)
    (setup-lighting)
    (update-fps~ fps)
    (gl-enable GL_DEPTH_TEST)
    (draw-objects)
    (render-interface))
  
  
  (method protected virtual (prepare-world)
    (gl-clear (bitwise-ior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
    (prepare-projection)
    (gl-matrix-mode GL_MODELVIEW)
    (gl-load-identity)
    (gl-disable GL_LIGHTING)
    (gl-disable GL_LIGHT0)
    (gl-disable GL_LIGHT1)
    (glEnable GL_BLEND)
    (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA))
  
  
  (method protected virtual (prepare-projection)
    (gl-matrix-mode GL_PROJECTION)
    (gl-load-identity)
    (let ((ratio (/ (cast <fl> width) (cast <fl> height))))
      (glu-perspective 45.0 ratio 0.1 100.0)))
  
  
  (method (change-music)
    (set! music? #t)
    (let ((music-dir {Directory Home ".world" "music"}))
      (when (exists?~ music-dir)
        (let ((music-list (get-content~ music-dir nodes?: #f)))
          (let ((music (random-element music-list)))
            (play-music-file music "ambiance"))))))
  
  
  (method (setup-camera)
    (glu-look-at
      (get-x~ eye) (get-y~ eye) (get-z~ eye)
      (get-x~ eye-target) (get-y~ eye-target) (get-z~ eye-target)
      (get-x~ eye-up) (get-y~ eye-up) (get-z~ eye-up)))
  
  
  (method (setup-lighting)
    (when light?
      (gl-enable GL_LIGHTING)
      (gl-enable GL_LIGHT0)
      (gl-enable GL_LIGHT1)
      (gl-material-specular GL_FRONT 0.1 0.1 0.1 1.0)
      (gl-material-shininess GL_FRONT 50.0)
      (gl-light-model GL_LIGHT_MODEL_AMBIENT 0.2 0.2 0.2 1.0)
      ;; positioned light
      (gl-light GL_LIGHT0 GL_DIFFUSE 0.5 0.5 0.5 1.0)
      (gl-light GL_LIGHT0 GL_POSITION 4.0 0.0 8.0 1.0)
      ;; directed light
      (gl-light GL_LIGHT1 GL_DIFFUSE 0.5 0.5 0.4 1.0)
      (gl-light GL_LIGHT1 GL_POSITION -1.0 0.5 0.5 0.0)
      @debug-lighting
      (draw-sphere 4.0 0.0 8.0 0.5 26 52 {Color Orange})
      @debug-lighting
      (draw-sphere -1.0 0.5 0.5 0.5 26 52 {Color Yellow})))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method protected virtual (process-keys)
    )
  
  
  (method protected virtual (key-down c)
    )
  
  
  (method protected virtual (key-press c)
    )
  
  
  (method protected virtual (process-shortcut shortcut)
    #f)
  
  
  (method (process-movement evt)
    (when (eq? window (get-window-focus))
      (let ((shift? (get-shift?~ evt))
            (control? (get-control?~ evt))
            (alt? (get-alt?~ evt)))
        (when (key-down? (char->integer #\W))
          (move-forward))
        (when (and (key-down? (char->integer #\S))
                   (not control?))
          (move-backward))
        (when (key-down? (char->integer #\Q))
          (strafe-left))
        (when (key-down? (char->integer #\E))
          (strafe-right))
        (when (or (key-down? (char->integer #\R))
                  (key-down? (char->integer #\space)))
          (strafe-up))
        (when (key-down? (char->integer #\X))
          (strafe-down))
        (when (key-down? (char->integer #\A))
          (rotate-left))
        (when (key-down? (char->integer #\D))
          (rotate-right)))))
  
  
  ;;;
  ;;;; Music
  ;;;
  
  
  (method (play-music-file file name)
    (when (exists?~ file)
      (close-music name)
      (open-music file name)
      (play-music name)))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method protected virtual (draw-objects)
    (for-each (lambda (object)
                (when (get-visible?~ object)
                  (draw~ object)))
              objects))
  
  
  (method (render-interface)
    (when (or interface? fps?)
      (gl-disable GL_LIGHTING)
      (gl-disable GL_LIGHT0)
      (gl-disable GL_LIGHT1)
      (gl-matrix-mode GL_MODELVIEW)
      (gl-load-identity)
      (gl-matrix-mode GL_PROJECTION)
      (glEnable GL_BLEND)
      (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
      (with-gl-matrix
        (lambda ()
          (gl-load-identity)
          (gl-ortho 0.0 (exact->inexact width) 0.0 (exact->inexact height) -10.0 10.0)
          (when interface?
            (draw-interface)
            @test (
            (gl-color 1.0 0.0 0.0)
            (let ((surface (get-surface~ test)))
              (set-operator~ surface CAIRO_OPERATOR_CLEAR)
              (paint~ surface)
              (set-operator~ surface CAIRO_OPERATOR_SOURCE)
              (let ((color {Color Red alpha: 0.5}))
                (ellipse~ surface {Rect 0 0 200 200} color color)))
            (map-texture~ test)
            (with-gl-matrix
              (lambda ()
                (gl-translate (exact->inexact (- width 200)) 0.0 0.0)
                (textured-quad~ test
                  (lambda () (gl-vertex 0.0   0.0 0.0))
                  (lambda () (gl-vertex 200.0   0.0 0.0))
                  (lambda () (gl-vertex 200.0 200.0 0.0))
                  (lambda () (gl-vertex 0.0 200.0 0.0)))))))))))
  
  
  (method protected virtual (draw-interface)
    (when fps?
      (draw~ fps)))
  
  
  ;;;
  ;;;; Backend
  ;;;
  
  
  (method (gl-pixel point color)
    (let ((x (get-h~ point))
          (y (get-v~ point)))
      (gl-set-color color)
      (with-gl-begin/end GL_POINTS
        (lambda ()
          (gl-vertex2f x y)))))
  
  
  (method (gl-line from to color)
    (let ((x1 (get-h~ from))
          (y1 (get-v~ from))
          (x2 (get-h~ to))
          (y2 (get-v~ to)))
      (gl-set-color color)
      (with-gl-begin/end GL_LINES
        (lambda ()
          (gl-vertex2f x1 y1)
          (gl-vertex2f x2 y2)))))
  
  
  (method (gl-fill-rect rect color)
    (let ((x1 (get-left~ rect))
          (y1 (get-top~ rect))
          (x2 (get-right~ rect))
          (y2 (get-bottom~ rect)))
      (gl-set-color color)
      (with-gl-begin/end GL_QUADS
        (lambda ()
          (gl-vertex2f x1 y1)
          (gl-vertex2f x2 y1)
          (gl-vertex2f x2 y2)
          (gl-vertex2f x1 y2)))))
  
  
  (method (gl-frame-rect rect color)
    (let ((x1 (get-left~ rect))
          (y1 (get-top~ rect))
          (x2 (get-right~ rect))
          (y2 (get-bottom~ rect)))
      (gl-set-color color)
      (with-gl-begin/end GL_LINE_LOOP
        (lambda ()
          (gl-vertex2f x1 y1)
          (gl-vertex2f x2 y1)
          (gl-vertex2f x2 y2)
          (gl-vertex2f x1 y2)))))
  
  
  (method (gl-frame-circle center radius color)
    (let ((x (get-h~ center))
          (y (get-v~ center)))
      (gl-set-color color)
      (with-gl-begin/end GL_LINE_LOOP
        (lambda ()
          (loop (for angle from 0 to 365 by 5)
                (gl-vertex2f (+ x (* (sin angle) radius))
                             (+ y (* (cos angle) radius))))))))
  
  
  (method (gl-segment-circle center radius color segments)
    (let ((segments (max 3 segments)))
      (let ((cx (get-h~ center))
            (cy (get-v~ center))
            (theta (/ PI*2 segments)))
        (let ((c (cos theta))
              (s (sin theta))
              (x radius)
              (y 0))
          (gl-set-color color)
          (with-gl-begin/end GL_LINE_LOOP
            (lambda ()
              (loop (for n from 0 below segments)
                    (gl-vertex2f (+ x cx) (+ y cy))
                    (let ((t x))
                      (set! x (- (* c x) (* s y)))
                      (set! y (+ (* s t) (* c y)))))))))))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method protected virtual (prepare-camera)
    (set! eye (new Vertex 0.0 3.0 10.0))
    (set! eye-sight (new Vertex 0.0 0.0 -6.0))
    (set! eye-up (new Vertex 0.0 1.0 0.0))
    (set! eye-right (new Vertex 1.0 0.0 0.0)))
  
  
  (method (get-me)
    (vertex+ eye (vertex-scalar* eye-sight camera-distance)))

  
  (method protected virtual (zoom-in)
    (let ((me (get-me)))
      (increase! camera-distance (- (zoom-speed)))
      (set! eye (vertex+ me (vertex-scalar* eye-sight (- camera-distance))))
      (update-camera)))
  
  
  (method protected virtual (zoom-out)
    (let ((me (get-me)))
      (increase! camera-distance (zoom-speed))
      (set! eye (vertex+ me (vertex-scalar* eye-sight (- camera-distance))))
      (update-camera)))
  
  
  (method protected virtual (zoom-speed)
    0.1)
  
  
  (method (update-camera)
    (set! eye-target (vertex+ eye eye-sight)))
  
  
  (method (mouse-wheel h v delta)
    (if (> delta 0)
        (zoom-in)
      (zoom-out)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method protected virtual (camera-speed)
    0.05)
  
  
  (method protected virtual (move-forward)
    (set! eye (vertex+ eye (vertex-scalar* eye-sight (camera-speed))))
    (update-camera)
    (movement))
  
  
  (method protected virtual (move-backward)
    (set! eye (vertex+ eye (vertex-scalar* eye-sight (- (camera-speed)))))
    (update-camera)
    (movement))
  
  
  (method protected virtual (strafe-left)
    (strafe-horizontally (- (* (camera-speed) 2))))
  
  
  (method protected virtual (strafe-right)
    (strafe-horizontally (* (camera-speed) 2)))
  
  
  (method (strafe-horizontally d)
    (set! eye (vertex+ eye (vertex-scalar* eye-right d)))
    (update-camera)
    (movement))
  
  
  (method protected virtual (strafe-up)
    (set! eye (vertex+ eye (vertex-scalar* eye-up (* (camera-speed) 2))))
    (update-camera)
    (movement))
  
  
  (method protected virtual (strafe-down)
    (set! eye (vertex+ eye (vertex-scalar* eye-up (- (* (camera-speed) 2)))))
    (update-camera)
    (movement))
  
  
  (method protected virtual (movement)
    )
  
  
  (definition rotation-speed
    0.02)
  
  
  (method protected virtual (rotate-left)
    (rotate-horizontal rotation-speed))
  
  
  (method protected virtual (rotate-right)
    (rotate-horizontal (- rotation-speed)))
  
  
  (method (rotate-horizontal angle)
    (let ((world-up (new Vertex 0. 1. 0.)))
      (set! eye-sight (rotate-upon angle world-up eye-sight))
      (set! eye-right (vertex-normalize (cross-product eye-sight world-up)))
      (set! eye-up (cross-product eye-right eye-sight)))
    (update-camera))
  
  
  (method (rotate-up)
    @wrong-number-of-parameters???
    (rotate-vertical rotation-speed eye-right eye-sight))
  
  
  (method (rotate-down)
    (rotate-vertical (- rotation-speed)))
  
  
  (method (rotate-vertical angle)
    (set! eye-sight (rotate-upon angle eye-right eye-sight))
    (set! eye-up (vertex-normalize (rotate-upon angle eye-right eye-up)))
    (update-camera))
  
  
  (method protected virtual (cursor-update)
    (set-cursor :arrow))
  
  
  (method protected virtual (mouse-down h v)
    (set! animate? (not animate?)))
  
  
  (method protected virtual (mouse-move h v)
    (when last-point
      (let ((new-point (new Point h v)))
        (let ((delta (nu- new-point last-point)))
          (let ((dh (get-h~ delta))
                (dv (get-v~ delta)))
            (mouse-track dh dv)))
        (set! last-point new-point))))
  
  
  (method protected virtual (mouse-track dh dv)
    (rotate-horizontal (/ (- dh) 200.))
    (rotate-vertical (/ (- dv) 200.)))
  
  
  (method protected virtual (mouse-up h v)
    (set! last-point #f))
  
  
  (method protected virtual (right-mouse-down h v)
    (setup-viewing h v)
    @w
    (case mode
      ((explore)
       (set! animate? (not animate?)))
      ((insert)
       (case what
         ((cube)
          (add-object (new Cube self (random-in 3.0) (random-in 3.0) -6.0)))))))
  
  
  (method protected virtual (right-mouse-up h v)
    (set! last-point #f))
  
  
  (method (setup-viewing h v)
    (set! last-point (new Point h v)))
  
  
  ;;;
  ;;;; Objects
  ;;;
    
  
  (method (add-axes . rest)
    (add-object (apply new Axes self rest)))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method protected virtual (evaluate-hook)
    )
  
  
  ;;;
  ;;;; Toggle
  ;;;
  
  
  (method (toggle-interface)
    (set! interface? (not interface?)))
  
  
  (method (toggle-fps)
    (if (shift-down?)
        (reset~ fps)
      (set! fps? (not fps?))))
  
  
  (method (toggle-polygon-mode)
    (set! polygon-mode (ecase polygon-mode
                         ((GL_POINT) GL_LINE)
                         ((GL_LINE) GL_FILL)
                         ((GL_FILL) GL_POINT)))
    (glPolygonMode GL_FRONT_AND_BACK polygon-mode))
  
  
  (method (toggle-lighting)
    (set! light? (not light?)))
  
  
  (method (toggle-fullscreen)
    (toggle-fullscreen~ window))))
