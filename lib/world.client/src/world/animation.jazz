;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Animations
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.animation jazz


(import (jazz.syntax (phase syntax))
        (world.geometry)
        (world.homogeneous)
        (world.support))


;;;
;;;; Debug
;;;


(definition public (animation-bone animation name)
  (loop (for bone in-vector (get-bones~ animation))
        (when (equal? (get-name~ bone) name)
          (return bone))
        (finally #f)))


(definition public (present-bones animation)
  (define (debug-children parent-index level)
    (loop (for bone in-vector (get-bones~ animation))
          (when (eqv? (get-parent-index~ bone) parent-index)
            (let ((name (get-name~ bone))
                  (index (get-index~ bone))
                  (global (get-global-skeleton-matrix~ bone)))
              (format :console "{_ :v}{a} {a}{%}" (* level 2) name (present-vertex (matrix-translation global)))
              (debug-children index (+ level 1))))))
  
  (debug-children #f 0))


(definition public (compare-bones animation other)
  (define (compare-children parent-index level)
    (loop (for bone in-vector (get-bones~ animation))
          (when (eqv? (get-parent-index~ bone) parent-index)
            (let ((name (get-name~ bone))
                  (index (get-index~ bone)))
              (let ((other-bone (vector-ref (get-bones~ other) index)))
                (format :console "{_ :v}{a} {a}{%}" (* level 2) name
                  (if (equal? (get-global-skeleton-matrix~ bone) (get-global-skeleton-matrix~ other-bone))
                      ""
                    "*****"))
                (compare-children index (+ level 1)))))))
  
  (compare-children #f 0))


(definition public (debug-chain morphing chain)
  (let ((morphs (get-morphs~ morphing)))
    (for-each (lambda (index)
                (let ((morph (vector-ref morphs index)))
                  (debug index (get-animation-position~ morph) (get-animation-rotation~ morph))))
              chain)))


(definition public (bone-chain animation index)
  (let (iter (chain '()) (index index))
    (if (not index)
        chain
      (iter (cons index chain) (get-parent-index~ (vector-ref (get-bones~ animation) index))))))


(definition public (present-rotation . rest)
  (let ((quat (if (= 1 (length rest)) (car rest) (apply quaternion rest))))
    (present-vertex (euler-radian->degree (quaternion-euler quat)))))


(proclaim (warn optimizations))


;;;
;;;; KeyFrame
;;;


(class KeyFrame extends Object

  
  (slot frame <fl>        accessors generate)
  (slot key   <f64vector> accessors generate)
  
  
  (method override (initialize frame key)
    (set! frame~self frame)
    (set! key~self key)))


;;;
;;;; Tangent
;;;


(class Tangent extends Object
  
  
  (slot in  <f64vector> initialize (make-vertex) accessors generate)
  (slot out <f64vector> initialize (make-vertex) accessors generate))


;;;
;;;; Bone
;;;


(class Bone extends Object
  
  
  (slot flags                  <fx>                                          accessors generate)
  (slot name                   <object>                                      accessors generate)
  (slot index                  <object>                                      accessors generate)
  (slot parent-name            <object>                                      accessors generate)
  (slot parent-index           <fx+>       initialize #f                     accessors generate)
  
  (slot rotation               <f64vector> initialize (make-vertex)          accessors generate)
  (slot position               <f64vector> initialize (make-vertex)          accessors generate)
  
  (slot rotation-keys          <vector>                                      accessors generate)
  (slot position-keys          <vector>                                      accessors generate)
  (slot tangents               <vector>                                      accessors generate)
  
  (slot local-skeleton-matrix  <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot global-skeleton-matrix <f64vector> initialize (make-identity-matrix) accessors generate)
  
  
  (method override (initialize flags name index parent-name rotation position rotation-keys position-keys)
    (set! flags~self flags)
    (set! name~self name)
    (set! index~self index)
    (set! parent-name~self parent-name)
    (set! rotation~self rotation)
    (set! position~self position)
    (set! rotation-keys~self rotation-keys)
    (set! position-keys~self position-keys))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))

  
;;;
;;;; Animator
;;;


(class Animator extends Object)


;;;
;;;; Animation
;;;


(definition default-transition-duration <fl>
  .15)

(definition public (get-default-transition-duration)
  default-transition-duration)

(definition public (set-default-transition-duration duration)
  (set! default-transition-duration duration))


(class Animation extends Object
  
  
  (slot name          <object> accessors generate)
  (slot animation-fps <fl>     accessors generate)
  (slot total-frames  <fx>     accessors generate)
  (slot bones         <vector> accessors generate)
  
  
  (method override (initialize name animation-fps total-frames bones)
    (set! name~self name)
    (set! animation-fps~self animation-fps)
    (set! total-frames~self total-frames)
    (set! bones~self bones))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method public (get-duration)
    (/ (cast <fl> total-frames) animation-fps))
  
  
  (method public (get-frame-duration)
    (/ 1. animation-fps))
  
  
  (method public (has-bones?)
    (and bones (> (vector-length bones) 0)))
  
  
  ;;;
  ;;;; Setup
  ;;;
  
  
  (method (setup-bones) <void>
    (define (find-bone-by-name name) <fx+>
      (loop (for i from 0 below (vector-length bones))
            (when (equal? (get-name~ (cast <Bone> (vector-ref bones i))) name)
              (return i))
            (finally #f)))
    
    (loop (for i from 0 below (cast <fx> (vector-length bones)))
          (let ((bone <Bone> (vector-ref bones i)))
            (set-parent-index~ bone (find-bone-by-name (get-parent-name~ bone)))))
    (loop (for i from 0 below (cast <fx> (vector-length bones)))
          (let ((bone <Bone> (vector-ref bones i)))
            (let ((bone-pos (get-position~ bone))
                  (bone-rot (get-rotation~ bone))
                  (bone-local-skeleton-matrix (get-local-skeleton-matrix~ bone))
                  (bone-global-skeleton-matrix (get-global-skeleton-matrix~ bone)))
              (quaternion-matrix! bone-local-skeleton-matrix bone-rot)
              (translate-matrix! bone-local-skeleton-matrix bone-pos)
              (let ((parent-index (get-parent-index~ bone)))
                (if (not parent-index)
                    (matrix-copy! bone-global-skeleton-matrix bone-local-skeleton-matrix)
                  (let ((parent-bone <Bone> (vector-ref bones parent-index)))
                    (matrix-multiply!
                      bone-global-skeleton-matrix
                      (get-global-skeleton-matrix~ parent-bone)
                      bone-local-skeleton-matrix))))
              (setup-tangents)))))
  
  
  (method (setup-tangents) <void>
    (loop (for j from 0 below (cast <fx> (vector-length bones)))
          (let ((bone <Bone> (vector-ref bones j)))
            (let ((position-keys (get-position-keys~ bone)))
              (let ((num-position-keys <fx> (vector-length position-keys)))
                (let ((tangents (make-vector num-position-keys)))
                  (set-tangents~ bone tangents)
                  (loop (for i from 0 below num-position-keys)
                        (vector-set! tangents i (new Tangent)))
                  ;; clear all tangents (zero derivatives)
                  (loop (for k from 0 below num-position-keys)
                        (let ((tangent <Tangent> (vector-ref tangents k)))
                          (vertex! (get-in~ tangent) 0. 0. 0.)
                          (vertex! (get-out~ tangent) 0. 0. 0.)))
                  ;; if there are more than 2 keys, we can calculate tangents, otherwise we use zero derivatives
                  (when (> num-position-keys 2)
                    (loop (for k from 0 below num-position-keys)
                          ;; make the curve tangents looped
                          (let ((k0 <fx> (- k 1)))
                            (when (< k0 0) (set! k0 (- num-position-keys 1)))
                            (let ((k1 <fx> k)
                                  (k2 <fx> (+ k 1)))
                              (when (>= k2 num-position-keys) (set! k2 0))
                              ;; calculate the tangent, which is the vector from key[k - 1] to key[k + 1]
                              (let ((key0 <KeyFrame> (vector-ref position-keys k0))
                                    (key1 <KeyFrame> (vector-ref position-keys k1))
                                    (key2 <KeyFrame> (vector-ref position-keys k2)))
                                (let ((tangent (vertex-& (get-key~ key2)
                                                         (get-key~ key0))))
                                  ;; weight the incoming and outgoing tangents by their frame to avoid changes in speed if the keys are not within the same interval
                                  (let ((df1 <fl> (- (get-frame~ key1) (get-frame~ key0)))
                                        (df2 <fl> (- (get-frame~ key2) (get-frame~ key1))))
                                    (let ((df <fl> (+ df1 df2))
                                          (tan1 <Tangent> (vector-ref tangents k1)))
                                      (vertex-scalar*! (get-in~  tan1) tangent (/ df1 df))
                                      (vertex-scalar*! (get-out~ tan1) tangent (/ df2 df)))))))))))))))))


;;;
;;;; Morph
;;;


(class Morph extends Object
  
  
  (slot parent              <object>    initialize #f                     accessors generate)
  (slot bone                <Bone>                                        accessors generate)
  (slot local-matrix        <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot global-matrix       <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot bone-transformation <f64vector> initialize (make-identity-matrix) accessors generate)
  
  
  ;; for debugging
  (slot animation-rotation  <f64vector> initialize (make-quaternion) getter generate)
  (slot animation-position  <f64vector> initialize (make-vertex)     getter generate)
  
  
  (method override (initialize bone)
    (set! bone~self bone)))


;;;
;;;; Morphing
;;;


(class Morphing extends Object
  
  
  (slot animation           <Animation>  accessors generate)
  (slot animation-next      <object>     initialize #f accessors generate)
  (slot current-frame       <fl>         accessors generate)
  (slot morphs              <vector+>    initialize #f getter generate)
  (slot morphs-count        <fx>         initialize #f getter generate)
  (slot bone-matrices       <f32vector+> initialize #f getter generate)
  (slot transition          <Morphing+>  initialize #f accessors generate)
  (slot transition-frame    <fl+>        initialize #f accessors generate)
  (slot transition-elapsed  <fl+>        initialize #f accessors generate)
  (slot transition-duration <fl+>        initialize #f accessors generate)
  (slot speed               <fl>         initialize 1. accessors generate)
  
  
  (method override (initialize animation (speed: speed #f))
    (change-animation animation speed: speed))
  
  
  (method (change-animation animation (speed: speed #f))
    (set! animation~self animation)
    (when speed
      (set! speed~self speed))
    (update-morphs))
  
  
  (method (update-morphs)
    (let ((bones (get-bones~ animation)))
      (let ((num-bones (vector-length bones)))
        (let ((morphs (if (and morphs (<= num-bones (vector-length morphs)))
                          morphs
                        (make-vector num-bones))))
          ;; create morphs
          (loop (for i from 0 below num-bones)
                (let ((bone (vector-ref bones i)))
                  (vector-set! morphs i (new Morph bone))))
          ;; setup parents
          (loop (for i from 0 below num-bones)
                (let ((bone <Bone> (vector-ref bones i))
                      (morph <Morph> (vector-ref morphs i)))
                  (let ((parent-index (get-parent-index~ bone)))
                    (let ((parent (and parent-index (vector-ref morphs parent-index))))
                      (set-parent~ morph parent)))))
          (set! morphs~self morphs)
          (set! morphs-count~self num-bones)))))
  
  
  (method (effective-duration)
    (if transition
        (/ (get-duration~ (get-animation~ transition)) (get-speed~ transition))
      (/ (get-duration~ animation) speed)))
  
  
  (method (accelerate)
    (set-speed (/ speed .75)))
  
  (method (decelerate)
    (set-speed (* speed .75)))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method (evaluate-frame frame <fl>) <void>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (site (evaluate-frame on?: #f parent: animate-morphing)
      (if (< frame 0.)
          (loop (for i from 0 below morphs-count)
                (let ((morph <Morph> (allege morphs (vector-ref morphs i))))
                  (let ((bone (get-bone~ morph)))
                    (matrix-copy! (get-local-matrix~ morph) (get-local-skeleton-matrix~ bone))
                    (matrix-copy! (get-global-matrix~ morph) (get-global-skeleton-matrix~ bone))
                    (evaluate-bone morph))))
        (loop (for i from 0 below morphs-count)
              (evaluate-morph i frame)))
      (set! current-frame frame)))
  
  
  (method (evaluate-morph index <fx> frame <fl>) <void>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((morph <Morph> (allege morphs (vector-ref morphs index)))
          (transition-morph <Morph+> (and transition (vector-ref (allege (get-morphs~ transition)) index))))
      (let ((bone (get-bone~ morph))
            (transition-bone (and transition-morph (get-bone~ transition-morph))))
        ;; find the two keys where frame is in between
        (define (find-keys! i1 <s32vector> i2 <s32vector> frame <fl> keys <vector> num-keys <fx>)
          (let ((last (- num-keys 1)))
            (let (iter (i <fx> 0))
              (if (< i last)
                  (if (and (>= frame (get-frame~ (cast <KeyFrame> (vector-ref keys i))))
                           (< frame (get-frame~ (cast <KeyFrame> (vector-ref keys (+ i 1))))))
                      (begin
                        (fx-set! i1 i)
                        (fx-set! i2 (+ i 1)))
                    (iter (+ i 1)))
                ;; none found so either take the first
                (let ((first-key (cast <KeyFrame> (vector-ref keys 0))))
                  (if (< frame (get-frame~ first-key))
                      (fx-set! i2 0)
                    ;; or the last
                    (fx-set! i1 last)))))))
        
        (define (find-position! pos <f64vector> frame <fl> keys <vector> tangents <vector>)
          (let ((num-keys (vector-length keys)))
            (if (> num-keys 0)
                (let ((i1 (fx& -1))
                      (i2 (fx& -1)))
                  (find-keys! i1 i2 frame keys num-keys)
                  (cond ((= (fx-ref i1) -1)
                         ;; first key
                         (vertex-copy! pos (get-key~ (cast <KeyFrame> (vector-ref keys (fx-ref i2))))))
                        ((= (fx-ref i2) -1)
                         ;; last key
                         (vertex-copy! pos (get-key~ (cast <KeyFrame> (vector-ref keys (fx-ref i1))))))
                        (else
                         ;; between keys so interpolate using hermite interpolation
                         (let ((key1 <KeyFrame> (vector-ref keys (fx-ref i1)))
                               (key2 <KeyFrame> (vector-ref keys (fx-ref i2)))
                               (tan1 <Tangent> (vector-ref tangents (fx-ref i1)))
                               (tan2 <Tangent> (vector-ref tangents (fx-ref i2))))
                           ;; normalize the elapsed between the keys into [0..1]
                           (let ((t <fl>
                                   (/ (- frame (get-frame~ key1))
                                      (- (get-frame~ key2) (get-frame~ key1)))))
                             (let ((t2 <fl> (* t t)))
                               (let ((t3 <fl> (* t2 t)))
                                 ;; calculate hermite basis
                                 (let ((h1 <fl> (+ (- (* 2. t3) (* 3. t2)) 1.))
                                       (h2 <fl> (+ (* (- 2.) t3) (* 3. t2)))
                                       (h3 <fl> (+ (- t3 (* 2. t2)) t))
                                       (h4 <fl> (- t3 t2)))
                                   ;; do hermite interpolation
                                   (vertex-x-set! pos (+ (* h1 (vertex-x (get-key~ key1))) (* h3 (vertex-x (get-out~ tan1))) (* h2 (vertex-x (get-key~ key2))) (* h4 (vertex-x (get-in~ tan2)))))
                                   (vertex-y-set! pos (+ (* h1 (vertex-y (get-key~ key1))) (* h3 (vertex-y (get-out~ tan1))) (* h2 (vertex-y (get-key~ key2))) (* h4 (vertex-y (get-in~ tan2)))))
                                   (vertex-z-set! pos (+ (* h1 (vertex-z (get-key~ key1))) (* h3 (vertex-z (get-out~ tan1))) (* h2 (vertex-z (get-key~ key2))) (* h4 (vertex-z (get-in~ tan2)))))))))))))
              (vertex! pos 0. 0. 0.))
            pos))
        
        (define (find-rotation! quat <f64vector> frame <fl> keys <vector>)
          (let ((num-keys (vector-length keys)))
            (if (> num-keys 0)
                (let ((i1 (fx& -1))
                      (i2 (fx& -1)))
                  (find-keys! i1 i2 frame keys num-keys)
                  (cond ((= (fx-ref i1) -1)
                         ;; first key
                         (quaternion-copy! quat (get-key~ (cast <KeyFrame> (vector-ref keys (fx-ref i2))))))
                        ((= (fx-ref i2) -1)
                         ;; last key
                         (quaternion-copy! quat (get-key~ (cast <KeyFrame> (vector-ref keys (fx-ref i1))))))
                        (else
                         ;; between keys so do the quaternion slerp interpolation
                         (let ((key1 <KeyFrame> (vector-ref keys (fx-ref i1)))
                               (key2 <KeyFrame> (vector-ref keys (fx-ref i2))))
                           ;; normalize the elapsed between the keys into [0..1]
                           (let ((t <fl>
                                   (/ (- frame (get-frame~ key1))
                                      (- (get-frame~ key2) (get-frame~ key1)))))
                             (quaternion-slerp! quat (get-key~ key1) (get-key~ key2) (f64& t)))))))
              (quaternion! quat 0. 0. 0. 1.))
            quat))
        
        ;; calculate bone animation matrix, this matrix will animate local-skeleton-matrix
        (let ((pos (find-position! (make-vertex&) frame (get-position-keys~ bone) (get-tangents~ bone)))
              (quat (find-rotation! (make-quaternion&) frame (get-rotation-keys~ bone))))
          ;; transition smoothly between animations
          (when transition-bone
            (let ((transition-pos (find-position! (make-vertex&) transition-frame (get-position-keys~ transition-bone) (get-tangents~ transition-bone)))
                  (transition-quat (find-rotation! (make-quaternion&) transition-frame (get-rotation-keys~ transition-bone)))
                  (t (f64& (/ (allege transition-elapsed) (allege transition-duration)))))
              ;; we are not guaranteed to have tangents so use lerp
              (vertex-lerp! pos pos transition-pos t)
              (quaternion-slerp! quat quat transition-quat t)))
          ;; make a matrix from pos/quat
          (let ((animation-matrix (make-identity-matrix&)))
            (quaternion-matrix! animation-matrix quat)
            (translate-matrix! animation-matrix pos)
            (when debug-animations?
              (quaternion-copy! (get-animation-rotation~ morph) quat)
              (vertex-copy! (get-animation-position~ morph) pos))
            ;; animate the local bone matrix: local-matrix = local-skeleton-matrix * animation-matrix
            (matrix-multiply! (get-local-matrix~ morph) (get-local-skeleton-matrix~ bone) animation-matrix)
            ;; build up the hierarchy: global-matrix = global-matrix(parent) * local-matrix
            (let ((parent-morph <Morph+> (get-parent~ morph)))
              (if (not parent-morph)
                  (matrix-copy! (get-global-matrix~ morph) (get-local-matrix~ morph))
                (matrix-multiply!
                  (get-global-matrix~ morph)
                  (get-global-matrix~ parent-morph)
                  (get-local-matrix~ morph)))))
          ;; construct the bone transformation
          (evaluate-bone morph)))))
  
  
  (method (evaluate-bone morph <Morph>) <void>
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((t (make-identity-matrix&))
          (u (make-identity-matrix&))
          (v (make-identity-matrix&))
          (bone (get-bone~ morph)))
      (let ((bone-global-skeleton-matrix (get-global-skeleton-matrix~ bone)))
        (matrix-set! t 12 (- (matrix-ref bone-global-skeleton-matrix 12)))
        (matrix-set! t 13 (- (matrix-ref bone-global-skeleton-matrix 13)))
        (matrix-set! t 14 (- (matrix-ref bone-global-skeleton-matrix 14)))
        (matrix-transpose-3x3! u bone-global-skeleton-matrix)
        (matrix-multiply! v u t)
        (matrix-multiply! (get-bone-transformation~ morph) (get-global-matrix~ morph) v))))
  
  
  ;;;
  ;;;; Animate
  ;;;
  
  
  (method public (animate-morphing elapse <fl> update-morphing change-next)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (site (animate-morphing on?: #f parent: animate)
      (let ((total-frames (cast <fl> (get-total-frames~ animation)))
            (new-frame (+ current-frame (* elapse (get-animation-fps~ animation) speed))))
        (if transition
            (let ((new-elapsed (+ (allege transition-elapsed) (* elapse speed))))
              (goto-transition (flmodulo new-frame total-frames) new-elapsed)
              (when (>= transition-elapsed transition-duration)
                (let ((new-morphing transition))
                  (set! transition #f)
                  (set! transition-elapsed #f)
                  (set! transition-duration #f)
                  (update-morphing new-morphing)
                  (goto-frame~ new-morphing transition-frame))))
          (if (= total-frames 0.)
              (goto-frame 0.)
            (if (and animation-next (> new-frame total-frames))
                (begin
                  (goto-frame total-frames)
                  (change-next animation-next))
              (let ((new-frame (flmodulo new-frame total-frames)))
                (goto-frame new-frame))))))))
  
  
  (method public (reset-transition)
    (set! transition #f)
    (set! transition-frame #f)
    (set! transition-elapsed #f)
    (set! transition-duration #f))
  
  
  (method public (random-frame)
    (random-between 0. (cast <fl> (get-total-frames~ animation))))
  
  
  (method public (goto-frame frame <fl>)
    (declare (optimize-dead-local-variables))
    (set! current-frame frame)
    (evaluate-frame current-frame)
    (set! bone-matrices (extract-bone-matrices)))
  
  
  (method (goto-transition frame <fl> elapsed <fl>)
    (declare (optimize-dead-local-variables))
    (set! current-frame frame)
    (set! transition-elapsed elapsed)
    (evaluate-frame current-frame)
    (set! bone-matrices (extract-bone-matrices)))
  
  
  (method (get-current-time)
    (/ current-frame (get-animation-fps~ animation)))
  
  
  (method (extract-bone-matrices)
    (declare (proper-tail-calls))
    (declare (optimize-dead-local-variables))
    (declare (inline))
    (declare (inlining-limit 1000))
    (let ((count morphs-count))
      (let ((content (or bone-matrices (make-f32vector (* 200 16)))))
        (loop (for i from 0 below count)
              (let ((morph <Morph> (allege morphs (vector-ref morphs i))))
                (let ((bone-transformation <f64vector> (get-bone-transformation~ morph))
                      (offset (* i 16)))
                  (loop (for j from 0 below 16)
                        (f32vector-set! content (+ offset j) (f64vector-ref bone-transformation j))))))
        content)))))
