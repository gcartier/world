;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Animations
;;;


(module world.animation jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (world)
        (world.geometry)
        (world.homogeneous))


(proclaim (warn optimizations))


;;;
;;;; KeyFrame
;;;


(class KeyFrame extends Object

  
  (slot time <fl>                                 accessors generate)
  (slot key  <f64vector> initialize (make-vertex) accessors generate)
  
  
  (method override (initialize time key)
    (set! time~self time)
    (set! key~self key)))


;;;
;;;; Tangent
;;;


(class Tangent extends Object
  
  
  (slot in  <f64vector> initialize (make-vertex) accessors generate)
  (slot out <f64vector> initialize (make-vertex) accessors generate))


;;;
;;;; Joint
;;;


(class Joint extends Object
  
  
  (slot flags                  <fx>                                          accessors generate)
  (slot name                   <object>                                      accessors generate)
  (slot parent-name            <object>                                      accessors generate)
  (slot parent-index           <object>    initialize #f                     accessors generate)
  
  (slot rot                    <f64vector> initialize (make-vertex)          accessors generate)
  (slot pos                    <f64vector> initialize (make-vertex)          accessors generate)
  
  (slot rotation-keys          <Vector>                                      accessors generate)
  (slot position-keys          <Vector>                                      accessors generate)
  (slot tangents               <Vector>                                      accessors generate)
  
  (slot local-skeleton-matrix  <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot global-skeleton-matrix <f64vector> initialize (make-identity-matrix) accessors generate)
  
  
  (method override (initialize flags name parent-name rot pos rotation-keys position-keys)
    (set! flags~self flags)
    (set! name~self name)
    (set! parent-name~self parent-name)
    (set! rot~self rot)
    (set! pos~self pos)
    (set! rotation-keys~self rotation-keys)
    (set! position-keys~self position-keys)))

  
;;;
;;;; Animator
;;;


(class Animator extends Object)


;;;
;;;; Animation
;;;


(definition animations-acceleration
  1.)

(definition public (get-animations-acceleration)
  animations-acceleration)

(definition public (set-animations-acceleration acceleration)
  (set! animations-acceleration acceleration))


(definition transition-duration
  .15)


(class Animation extends Object
  
  
  (slot name          <object> accessors generate)
  (slot animation-fps <fl>     accessors generate)
  (slot total-frames  <fx>     accessors generate)
  (slot joints        <object> accessors generate)
  
  
  (method override (initialize name animation-fps total-frames joints)
    (set! name~self name)
    (set! animation-fps~self animation-fps)
    (set! total-frames~self total-frames)
    (set! joints~self joints))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method public (has-joints?)
    (and joints (> (vector-length joints) 0)))
  
  
  ;;;
  ;;;; Setup
  ;;;
  
  
  (method (find-joint-index name) <fx>
    (loop (for i from 0 below (vector-length joints))
          (when (equal? (get-name~ (cast <Joint> (vector-ref joints i))) name)
            (return i))
          (finally -1)))
  
  
  (method (setup-joints) <void>
    (for (i 0 (cast <fx> (vector-length joints)))
         (let ((joint <Joint> (vector-ref joints i)))
           (set-parent-index~ joint (find-joint-index (get-parent-name~ joint)))))
    (for (i 0 (cast <fx> (vector-length joints)))
         (let ((joint <Joint> (vector-ref joints i)))
           (let ((joint-pos (get-pos~ joint))
                 (joint-rot (get-rot~ joint))
                 (joint-local-skeleton-matrix (get-local-skeleton-matrix~ joint))
                 (joint-global-skeleton-matrix (get-global-skeleton-matrix~ joint)))
             (angle-matrix! joint-local-skeleton-matrix joint-rot)
             (translate-matrix! joint-local-skeleton-matrix joint-pos)
             (let ((parent-index (get-parent-index~ joint)))
               (if (= parent-index -1)
                   (matrix-copy! joint-global-skeleton-matrix joint-local-skeleton-matrix)
                 (let ((parent-joint <Joint> (vector-ref joints parent-index)))
                   (matrix-multiply!
                     joint-global-skeleton-matrix
                     (get-global-skeleton-matrix~ parent-joint)
                     joint-local-skeleton-matrix))))
             (setup-tangents)))))
  
  
  (method (setup-tangents) <void>
    (for (j 0 (cast <fx> (vector-length joints)))
         (let ((joint <Joint> (vector-ref joints j)))
           (let ((position-keys (get-position-keys~ joint)))
             (let ((num-position-keys <fx> (vector-length position-keys)))
               (let ((tangents (make-vector num-position-keys)))
                 (set-tangents~ joint tangents)
                 (for (i 0 num-position-keys)
                      (vector-set! tangents i (new Tangent)))
                 ;; clear all tangents (zero derivatives)
                 (for (k 0 num-position-keys)
                      (vertex-init! (get-in~ (vector-ref tangents k)) 0. 0. 0.)
                      (vertex-init! (get-out~ (vector-ref tangents k)) 0. 0. 0.))
                 ;; if there are more than 2 keys, we can calculate tangents, otherwise we use zero derivatives
                 (when (> num-position-keys 2)
                   (for (k 0 num-position-keys)
                        ;; make the curve tangents looped
                        (let ((k0 <fx> (- k 1)))
                          (when (< k0 0) (set! k0 (- num-position-keys 1)))
                          (let ((k1 <fx> k)
                                (k2 <fx> (+ k 1)))
                            (when (>= k2 num-position-keys) (set! k2 0))
                            ;; calculate the tangent, which is the vector from key[k - 1] to key[k + 1]
                            (let ((tangent (vertex- (get-key~ (vector-ref position-keys k2))
                                                    (get-key~ (vector-ref position-keys k0)))))
                              ;; weight the incoming and outgoing tangents by their time to avoid changes in speed if the keys are not within the same interval
                              (let ((dt1 <fl> (- (get-time~ (vector-ref position-keys k1)) (get-time~ (vector-ref position-keys k0))))
                                    (dt2 <fl> (- (get-time~ (vector-ref position-keys k2)) (get-time~ (vector-ref position-keys k1)))))
                                (let ((dt <fl> (+ dt1 dt2)))
                                  (vertex-scalar*! (get-in~  (vector-ref tangents k1)) tangent (/ dt1 dt))
                                  (vertex-scalar*! (get-out~ (vector-ref tangents k1)) tangent (/ dt2 dt))))))))))))))))

;;;
;;;; Morph
;;;


(class Morph extends Object
  
  
  (slot parent              <object>    initialize #f                     accessors generate)
  (slot joint               <Joint>                                       accessors generate)
  (slot local-matrix        <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot global-matrix       <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot bone-transformation <f64vector> initialize (make-identity-matrix) accessors generate)
  
  
  (method override (initialize parent joint)
    (set! parent~self parent)
    (set! joint~self joint)))


;;;
;;;; Morphing
;;;


(class Morphing extends Object
  
  
  (slot animation        <object> accessors generate)
  (slot current-time     <fl>     accessors generate)
  (slot morphs           <object> initialize #f getter generate)
  (slot morphs-count     <fx>     initialize #f getter generate)
  (slot bone-matrices    <object> initialize #f getter generate)
  (slot transition       <object> initialize #f accessors generate)
  (slot transition-frame <fl+>    initialize #f accessors generate)
  
  
  (method override (initialize animation)
    (set! animation~self animation)
    (update-morphs))
  
  
  (method (change-animation animation)
    (set! animation~self animation)
    (update-morphs))
  
  
  (method (update-morphs)
    (let ((joints (get-joints~ animation)))
      (let ((num-joints (vector-length joints)))
        (let ((morphs (if (and morphs (<= num-joints (vector-length morphs)))
                          morphs
                        (make-vector num-joints))))
          (for (i 0 num-joints)
               (let ((joint (vector-ref joints i)))
                 (let ((parent-index (get-parent-index~ joint)))
                   (let ((parent (and (/= parent-index -1) (vector-ref morphs parent-index))))
                     (vector-set! morphs i (new Morph parent joint))))))
          (set! morphs~self morphs)
          (set! morphs-count~self num-joints)))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method (evaluate-frame frame <fl>) <void>
    (declare (optimize-dead-local-variables))
    (if (< frame 0.)
        (for (i 0 morphs-count)
             (let ((morph <Morph> (vector-ref morphs i)))
               (let ((joint (get-joint~ morph)))
                 (matrix-copy! (get-local-matrix~ morph) (get-local-skeleton-matrix~ joint))
                 (matrix-copy! (get-global-matrix~ morph) (get-global-skeleton-matrix~ joint))
                 (evaluate-bone morph))))
      (for (i 0 morphs-count)
           (evaluate-morph i frame)))
    (set! current-time frame))
  
  
  (method (evaluate-morph index <fx> frame <fl>) <void>
    (declare (optimize-dead-local-variables))
    (let ((morph <Morph> (vector-ref morphs index))
          (transition-morph <Morph+> (and transition (vector-ref (get-morphs~ transition) index))))
      (let ((joint (get-joint~ morph))
            (transition-joint (and transition-morph (get-joint~ transition-morph))))
        ;; calculate joint animation matrix, this matrix will animate local-skeleton-matrix
        (let ((pos (vertex& 0. 0. 0.)))
          (let ((position-keys (get-position-keys~ joint)))
            (let ((num-position-keys <fx> (vector-length position-keys)))
              (when (and (> num-position-keys 0) (or (not transition-joint) (> (vector-length (get-position-keys~ transition-joint)) 0)))
                (let ((i1 (fx& -1))
                      (i2 (fx& -1)))
                  ;; find the two keys, where "frame" is in between for the position channel
                  (let (iter (i <fx> 0))
                    (when (< i (- num-position-keys 1))
                      (if (and (>= frame (get-time~ (cast <KeyFrame> (vector-ref position-keys i))))
                               (< frame (get-time~ (cast <KeyFrame> (vector-ref position-keys (+ i 1))))))
                          (begin
                            (fx-set! i1 i)
                            (fx-set! i2 (+ i 1)))
                        (iter (+ i 1)))))
                  ;; transition special case
                  (when (and transition (= (fx-ref i1) -1))
                    (let ((first-key (cast <KeyFrame> (vector-ref position-keys 0))))
                      (if (< frame (get-time~ first-key))
                          (fx-set! i1 0)
                        (fx-set! i1 (- num-position-keys 1)))))
                  ;; if there are no such keys
                  (if (or (= (fx-ref i1) -1) (= (fx-ref i2) -1))
                      ;; either take the first
                      (let ((first-key (cast <KeyFrame> (vector-ref position-keys 0))))
                        (if (< frame (get-time~ first-key))
                            (vertex-copy! pos (get-key~ first-key))
                          (let ((last-key (cast <KeyFrame> (vector-ref position-keys (- num-position-keys 1)))))
                            (when (>= frame (get-time~ last-key))
                              ;; or the last key
                              (vertex-copy! pos (get-key~ last-key))))))
                    ;; there are such keys, so interpolate using hermite interpolation
                    (let ((key1 <KeyFrame> (vector-ref position-keys (fx-ref i1)))
                          (key2 <KeyFrame> (if transition
                                               (vector-ref (get-position-keys~ transition-joint) 0)
                                             (vector-ref position-keys (fx-ref i2))))
                          (tan1 <Tangent> (vector-ref (get-tangents~ joint) (fx-ref i1)))
                          (tan2 <Tangent> (if transition
                                              (vector-ref (get-tangents~ transition-joint) 0)
                                            (vector-ref (get-tangents~ joint) (fx-ref i2)))))
                      ;; normalize the time between the keys into [0..1]
                      (let ((t <fl>
                              (if transition
                                  (/ transition-frame transition-duration)
                                (/ (- frame (get-time~ key1))
                                   (- (get-time~ key2) (get-time~ key1))))))
                        (let ((t2 <fl> (* t t)))
                          (let ((t3 <fl> (* t2 t)))
                            ;; calculate hermite basis
                            (let ((h1 <fl> (+ (- (* 2. t3) (* 3. t2)) 1.))
                                  (h2 <fl> (+ (* (- 2.) t3) (* 3. t2)))
                                  (h3 <fl> (+ (- t3 (* 2. t2)) t))
                                  (h4 <fl> (- t3 t2)))
                              ;; do hermite interpolation
                              (vertex-x-set! pos (+ (* h1 (vertex-x (get-key~ key1))) (* h3 (vertex-x (get-out~ tan1))) (* h2 (vertex-x (get-key~ key2))) (* h4 (vertex-x (get-in~ tan2)))))
                              (vertex-y-set! pos (+ (* h1 (vertex-y (get-key~ key1))) (* h3 (vertex-y (get-out~ tan1))) (* h2 (vertex-y (get-key~ key2))) (* h4 (vertex-y (get-in~ tan2)))))
                              (vertex-z-set! pos (+ (* h1 (vertex-z (get-key~ key1))) (* h3 (vertex-z (get-out~ tan1))) (* h2 (vertex-z (get-key~ key2))) (* h4 (vertex-z (get-in~ tan2)))))))))))))
              (let ((quat (quaternion& 0. 0. 0. 1.))
                    (rotation-keys (get-rotation-keys~ joint)))
                (let ((num-rotation-keys <fx> (vector-length rotation-keys)))
                  (when (and (> num-rotation-keys 0) (or (not transition-joint) (> (vector-length (get-rotation-keys~ transition-joint)) 0)))
                    (let ((i1 (fx& -1))
                          (i2 (fx& -1)))
                      ;; find the two keys, where "frame" is in between for the rotation channel
                      (let (iter (i <fx> 0))
                        (when (< i (- num-rotation-keys 1))
                          (if (and (>= frame (get-time~ (cast <KeyFrame> (vector-ref rotation-keys i))))
                                   (< frame (get-time~ (cast <KeyFrame> (vector-ref rotation-keys (+ i 1))))))
                              (begin
                                (fx-set! i1 i)
                                (fx-set! i2 (+ i 1)))
                            (iter (+ i 1)))))
                      ;; transition special case
                      (when (and transition (= (fx-ref i1) -1))
                        (let ((first-key (cast <KeyFrame> (vector-ref rotation-keys 0))))
                          (if (< frame (get-time~ first-key))
                              (fx-set! i1 0)
                            (fx-set! i1 (- num-rotation-keys 1)))))
                      ;; if there are no such keys
                      (if (or (= (fx-ref i1) -1) (= (fx-ref i2) -1))
                          ;; either take the first key
                          (let ((first-key (cast <KeyFrame> (vector-ref rotation-keys 0))))
                            (if (< frame (get-time~ first-key))
                                (angle-quaternion! quat (get-key~ first-key))
                              (let ((last-key (cast <KeyFrame> (vector-ref rotation-keys (- num-rotation-keys 1)))))
                                (when (>= frame (get-time~ last-key))
                                  ;; or the last key
                                  (angle-quaternion! quat (get-key~ last-key))))))
                        ;; there are such keys, so do the quaternion slerp interpolation
                        (let ((key1 <KeyFrame> (vector-ref rotation-keys (fx-ref i1)))
                              (key2 <KeyFrame> (if transition
                                                   (vector-ref (get-rotation-keys~ transition-joint) 0)
                                                 (vector-ref rotation-keys (fx-ref i2)))))
                          (let ((t <fl>
                                  (if transition
                                      (/ transition-frame transition-duration)
                                    (/ (- frame (get-time~ key1))
                                       (- (get-time~ key2) (get-time~ key1))))))
                            (let ((q1 (make-quaternion&)))
                              (angle-quaternion! q1 (get-key~ key1))
                              (let ((q2 (make-quaternion&)))
                                (angle-quaternion! q2 (get-key~ key2))
                                (quaternion-slerp! quat q1 q2 t))))))))
                  ;; make a matrix from pos/quat
                  (let ((animation-matrix (make-identity-matrix&)))
                    (quaternion-matrix! animation-matrix quat)
                    (translate-matrix! animation-matrix pos)
                    ;; animate the local joint matrix using: local-matrix = local-skeleton-matrix * animation-matrix
                    (matrix-multiply! (get-local-matrix~ morph) (get-local-skeleton-matrix~ joint) animation-matrix)
                    ;; build up the hierarchy if joints
                    ;; global-matrix = global-matrix(parent) * local-matrix
                    (let ((parent-morph <Morph+> (get-parent~ morph)))
                      (if (not parent-morph)
                          (matrix-copy! (get-global-matrix~ morph) (get-local-matrix~ morph))
                        (matrix-multiply!
                          (get-global-matrix~ morph)
                          (get-global-matrix~ parent-morph)
                          (get-local-matrix~ morph)))))
                  ;; construct the bone transformation
                  (evaluate-bone morph)))))))))
  
  
  (method (evaluate-bone morph <Morph>) <void>
    (declare (optimize-dead-local-variables))
    (let ((t (make-identity-matrix&))
          (u (make-identity-matrix&))
          (v (make-identity-matrix&))
          (joint (get-joint~ morph)))
      (let ((joint-global-skeleton-matrix (get-global-skeleton-matrix~ joint)))
        (matrix-set! t 12 (- (matrix-ref joint-global-skeleton-matrix 12)))
        (matrix-set! t 13 (- (matrix-ref joint-global-skeleton-matrix 13)))
        (matrix-set! t 14 (- (matrix-ref joint-global-skeleton-matrix 14)))
        (matrix-transpose-3x3! u joint-global-skeleton-matrix)
        (matrix-set! u 12 0.)
        (matrix-set! u 13 0.)
        (matrix-set! u 14 0.)
        (matrix-multiply! v t u)
        (matrix-multiply! (get-bone-transformation~ morph) (get-global-matrix~ morph) v))))
  
  
  ;;;
  ;;;; Animate
  ;;;
  
  
  (method public (animate elapse)
    (declare (optimize-dead-local-variables))
    (if transition
        (let ((new-time (+ transition-frame (* elapse animations-acceleration))))
          (goto-transition new-time))
      (let ((new-time (flmodulo (+ current-time (* elapse (get-animation-fps~ animation) animations-acceleration)) (cast <fl> (get-total-frames~ animation)))))
        (goto-time new-time))))
  
  
  (method public (goto-time time)
    (declare (optimize-dead-local-variables))
    (set! current-time time)
    (evaluate-frame current-time)
    (set! bone-matrices (extract-bone-matrices)))
  
  
  (method (goto-transition time)
    (set! transition-frame time)
    (evaluate-frame current-time)
    (set! bone-matrices (extract-bone-matrices)))
  
  
  (method (transition-done?)
    (and transition (>= transition-frame transition-duration)))
  
  
  (method (extract-bone-matrices)
    (declare (optimize-dead-local-variables))
    (let ((count morphs-count))
      (let ((content <f32vector> (or bone-matrices (make-f32vector (* 200 16)))))
        (for (i 0 count)
             (let ((morph (vector-ref morphs i)))
               (let ((bone-transformation <f64vector> (get-bone-transformation~ morph))
                     (offset (* i 16)))
                 (for (j 0 16)
                      (f32vector-set! content (+ offset j) (f64vector-ref bone-transformation j))))))
        content)))))
