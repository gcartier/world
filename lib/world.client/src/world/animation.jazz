;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Animations
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.animation jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (world)
        (world.geometry)
        (world.homogeneous)
        (world.support))


;;;
;;;; Debug
;;;


(definition public (animation-bone animation name)
  (loop (for bone in-vector (get-bones~ animation))
        (when (equal? (get-name~ bone) name)
          (return bone))
        (finally #f)))


(definition public (debug-bones animation)
  (loop (for bone in-vector (get-bones~ animation))
        (let ((name (get-name~ bone))
              (global (get-global-skeleton-matrix~ bone)))
          (format :console "{a} {a}{%}" name (present-vertex (matrix-translation global))))))


(definition public (debug-morphs entity (euler? #t))
  (loop (for morph in-vector (get-morphs~ (get-morphing~ entity)))
        (let ((name (get-name~ (get-bone~ morph)))
              (position (get-animation-position~ morph))
              (rotation (get-animation-rotation~ morph)))
          (format :console "{a} {a} {a}{%}" name (present-vertex position) (if euler?
                                                                               (present-vertex (quaternion-euler rotation))
                                                                             (present-quaternion rotation))))))


(definition public (present-rotation . rest)
  (let ((quat (if (= 1 (length rest)) (car rest) (apply quaternion rest))))
    (present-vertex (euler-radian->degree (quaternion-euler quat)))))


(proclaim (warn optimizations))


;;;
;;;; KeyFrame
;;;


(class KeyFrame extends Object

  
  (slot time <fl>        accessors generate)
  (slot key  <f64vector> accessors generate)
  
  
  (method override (initialize time key)
    (set! time~self time)
    (set! key~self key)))


;;;
;;;; Tangent
;;;


(class Tangent extends Object
  
  
  (slot in  <f64vector> initialize (make-vertex) accessors generate)
  (slot out <f64vector> initialize (make-vertex) accessors generate))


;;;
;;;; Bone
;;;


(class Bone extends Object
  
  
  (slot flags                  <fx>                                          accessors generate)
  (slot name                   <object>                                      accessors generate)
  (slot index                  <object>                                      accessors generate)
  (slot parent-name            <object>                                      accessors generate)
  (slot parent-index           <object>    initialize #f                     accessors generate)
  
  (slot rotation               <f64vector> initialize (make-vertex)          accessors generate)
  (slot position               <f64vector> initialize (make-vertex)          accessors generate)
  
  (slot rotation-keys          <Vector>                                      accessors generate)
  (slot position-keys          <Vector>                                      accessors generate)
  (slot tangents               <Vector>                                      accessors generate)
  
  (slot local-skeleton-matrix  <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot global-skeleton-matrix <f64vector> initialize (make-identity-matrix) accessors generate)
  
  
  (method override (initialize flags name index parent-name rotation position rotation-keys position-keys)
    (set! flags~self flags)
    (set! name~self name)
    (set! index~self index)
    (set! parent-name~self parent-name)
    (set! rotation~self rotation)
    (set! position~self position)
    (set! rotation-keys~self rotation-keys)
    (set! position-keys~self position-keys))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))

  
;;;
;;;; Animator
;;;


(class Animator extends Object)


;;;
;;;; Animation
;;;


(definition animations-acceleration
  1.)

(definition public (get-animations-acceleration)
  animations-acceleration)

(definition public (set-animations-acceleration acceleration)
  (set! animations-acceleration acceleration))


(definition transition-duration
  .15)


(class Animation extends Object
  
  
  (slot name          <object> accessors generate)
  (slot animation-fps <fl>     accessors generate)
  (slot total-frames  <fx>     accessors generate)
  (slot bones         <object> accessors generate)
  
  
  (method override (initialize name animation-fps total-frames bones)
    (set! name~self name)
    (set! animation-fps~self animation-fps)
    (set! total-frames~self total-frames)
    (set! bones~self bones))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method public (has-bones?)
    (and bones (> (vector-length bones) 0)))
  
  
  ;;;
  ;;;; Setup
  ;;;
  
  
  (method (setup-bones) <void>
    (define (find-bone-by-name name) <fx>
      (loop (for i from 0 below (vector-length bones))
            (when (equal? (get-name~ (cast <Bone> (vector-ref bones i))) name)
              (return i))
            (finally -1)))
    
    (loop (for i from 0 below (cast <fx> (vector-length bones)))
          (let ((bone <Bone> (vector-ref bones i)))
            (set-parent-index~ bone (find-bone-by-name (get-parent-name~ bone)))))
    (loop (for i from 0 below (cast <fx> (vector-length bones)))
          (let ((bone <Bone> (vector-ref bones i)))
            (let ((bone-pos (get-position~ bone))
                  (bone-rot (get-rotation~ bone))
                  (bone-local-skeleton-matrix (get-local-skeleton-matrix~ bone))
                  (bone-global-skeleton-matrix (get-global-skeleton-matrix~ bone)))
              (quaternion-matrix! bone-local-skeleton-matrix bone-rot)
              (translate-matrix! bone-local-skeleton-matrix bone-pos)
              (let ((parent-index (get-parent-index~ bone)))
                (if (= parent-index -1)
                    (matrix-copy! bone-global-skeleton-matrix bone-local-skeleton-matrix)
                  (let ((parent-bone <Bone> (vector-ref bones parent-index)))
                    (matrix-multiply!
                      bone-global-skeleton-matrix
                      (get-global-skeleton-matrix~ parent-bone)
                      bone-local-skeleton-matrix))))
              (setup-tangents)))))
  
  
  (method (setup-tangents) <void>
    (loop (for j from 0 below (cast <fx> (vector-length bones)))
          (let ((bone <Bone> (vector-ref bones j)))
            (let ((position-keys (get-position-keys~ bone)))
              (let ((num-position-keys <fx> (vector-length position-keys)))
                (let ((tangents (make-vector num-position-keys)))
                  (set-tangents~ bone tangents)
                  (loop (for i from 0 below num-position-keys)
                        (vector-set! tangents i (new Tangent)))
                  ;; clear all tangents (zero derivatives)
                  (loop (for k from 0 below num-position-keys)
                        (vertex-init! (get-in~ (vector-ref tangents k)) 0. 0. 0.)
                        (vertex-init! (get-out~ (vector-ref tangents k)) 0. 0. 0.))
                  ;; if there are more than 2 keys, we can calculate tangents, otherwise we use zero derivatives
                  (when (> num-position-keys 2)
                    (loop (for k from 0 below num-position-keys)
                          ;; make the curve tangents looped
                          (let ((k0 <fx> (- k 1)))
                            (when (< k0 0) (set! k0 (- num-position-keys 1)))
                            (let ((k1 <fx> k)
                                  (k2 <fx> (+ k 1)))
                              (when (>= k2 num-position-keys) (set! k2 0))
                              ;; calculate the tangent, which is the vector from key[k - 1] to key[k + 1]
                              (let ((tangent (vertex- (get-key~ (vector-ref position-keys k2))
                                                      (get-key~ (vector-ref position-keys k0)))))
                                ;; weight the incoming and outgoing tangents by their time to avoid changes in speed if the keys are not within the same interval
                                (let ((dt1 <fl> (- (get-time~ (vector-ref position-keys k1)) (get-time~ (vector-ref position-keys k0))))
                                      (dt2 <fl> (- (get-time~ (vector-ref position-keys k2)) (get-time~ (vector-ref position-keys k1)))))
                                  (let ((dt <fl> (+ dt1 dt2)))
                                    (vertex-scalar*! (get-in~  (vector-ref tangents k1)) tangent (/ dt1 dt))
                                    (vertex-scalar*! (get-out~ (vector-ref tangents k1)) tangent (/ dt2 dt))))))))))))))))

;;;
;;;; Morph
;;;


(class Morph extends Object
  
  
  (slot parent              <object>    initialize #f                     accessors generate)
  (slot bone                <Bone>                                        accessors generate)
  (slot local-matrix        <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot global-matrix       <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot bone-transformation <f64vector> initialize (make-identity-matrix) accessors generate)
  
  
  ;; for debugging
  (slot animation-rotation  <f64vector> initialize (make-quaternion) getter generate)
  (slot animation-position  <f64vector> initialize (make-vertex)     getter generate)
  
  
  (method override (initialize bone)
    (set! bone~self bone)))


;;;
;;;; Morphing
;;;


(class Morphing extends Object
  
  
  (slot animation        <object> accessors generate)
  (slot current-time     <fl>     accessors generate)
  (slot morphs           <object> initialize #f getter generate)
  (slot morphs-count     <fx>     initialize #f getter generate)
  (slot bone-matrices    <object> initialize #f getter generate)
  (slot transition       <object> initialize #f accessors generate)
  (slot transition-frame <fl+>    initialize #f accessors generate)
  
  
  (method override (initialize animation)
    (set! animation~self animation)
    (update-morphs))
  
  
  (method (change-animation animation)
    (set! animation~self animation)
    (update-morphs))
  
  
  (method (update-morphs)
    (let ((bones (get-bones~ animation)))
      (let ((num-bones (vector-length bones)))
        (let ((morphs (if (and morphs (<= num-bones (vector-length morphs)))
                          morphs
                        (make-vector num-bones))))
          ;; create morphs
          (loop (for i from 0 below num-bones)
                (let ((bone (vector-ref bones i)))
                  (vector-set! morphs i (new Morph bone))))
          ;; setup parents
          (loop (for i from 0 below num-bones)
                (let ((bone (vector-ref bones i))
                      (morph (vector-ref morphs i)))
                  (let ((parent-index (get-parent-index~ bone)))
                    (let ((parent (and (/= parent-index -1) (vector-ref morphs parent-index))))
                      (set-parent~ morph parent)))))
          (set! morphs~self morphs)
          (set! morphs-count~self num-bones)))))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method (evaluate-frame frame <fl>) <void>
    (declare (optimize-dead-local-variables))
    (site (evaluate-frame on?: #f parent: animate-morphing)
      (if (< frame 0.)
          (loop (for i from 0 below morphs-count)
                (let ((morph <Morph> (vector-ref morphs i)))
                  (let ((bone (get-bone~ morph)))
                    (matrix-copy! (get-local-matrix~ morph) (get-local-skeleton-matrix~ bone))
                    (matrix-copy! (get-global-matrix~ morph) (get-global-skeleton-matrix~ bone))
                    (evaluate-bone morph))))
        (loop (for i from 0 below morphs-count)
              (evaluate-morph i frame)))
      (set! current-time frame)))
  
  
  (method (evaluate-morph index <fx> frame <fl>) <void>
    (declare (optimize-dead-local-variables))
    (let ((morph <Morph> (vector-ref morphs index))
          (transition-morph <Morph+> (and transition (vector-ref (get-morphs~ transition) index))))
      (let ((bone (get-bone~ morph))
            (transition-bone (and transition-morph (get-bone~ transition-morph))))
        ;; calculate bone animation matrix, this matrix will animate local-skeleton-matrix
        (let ((pos (vertex& 0. 0. 0.)))
          (let ((position-keys (get-position-keys~ bone)))
            (let ((num-position-keys <fx> (vector-length position-keys)))
              (when (and (> num-position-keys 0) (or (not transition-bone) (> (vector-length (get-position-keys~ transition-bone)) 0)))
                (let ((i1 (fx& -1))
                      (i2 (fx& -1)))
                  ;; find the two keys, where "frame" is in between for the position channel
                  (let (iter (i <fx> 0))
                    (when (< i (- num-position-keys 1))
                      (if (and (>= frame (get-time~ (cast <KeyFrame> (vector-ref position-keys i))))
                               (< frame (get-time~ (cast <KeyFrame> (vector-ref position-keys (+ i 1))))))
                          (begin
                            (fx-set! i1 i)
                            (fx-set! i2 (+ i 1)))
                        (iter (+ i 1)))))
                  ;; transition special case
                  (when (and transition (= (fx-ref i1) -1))
                    (let ((first-key (cast <KeyFrame> (vector-ref position-keys 0))))
                      (if (< frame (get-time~ first-key))
                          (fx-set! i1 0)
                        (fx-set! i1 (- num-position-keys 1)))))
                  ;; if there are no such keys
                  (if (or (= (fx-ref i1) -1) (= (fx-ref i2) -1))
                      ;; either take the first
                      (let ((first-key (cast <KeyFrame> (vector-ref position-keys 0))))
                        (if (< frame (get-time~ first-key))
                            (vertex-copy! pos (get-key~ first-key))
                          (let ((last-key (cast <KeyFrame> (vector-ref position-keys (- num-position-keys 1)))))
                            (when (>= frame (get-time~ last-key))
                              ;; or the last key
                              (vertex-copy! pos (get-key~ last-key))))))
                    ;; there are such keys, so interpolate using hermite interpolation
                    (let ((key1 <KeyFrame> (vector-ref position-keys (fx-ref i1)))
                          (key2 <KeyFrame> (if transition
                                               (vector-ref (get-position-keys~ transition-bone) 0)
                                             (vector-ref position-keys (fx-ref i2))))
                          (tan1 <Tangent> (vector-ref (get-tangents~ bone) (fx-ref i1)))
                          (tan2 <Tangent> (if transition
                                              (vector-ref (get-tangents~ transition-bone) 0)
                                            (vector-ref (get-tangents~ bone) (fx-ref i2)))))
                      ;; normalize the time between the keys into [0..1]
                      (let ((t <fl>
                              (if transition
                                  (/ transition-frame transition-duration)
                                (/ (- frame (get-time~ key1))
                                   (- (get-time~ key2) (get-time~ key1))))))
                        (let ((t2 <fl> (* t t)))
                          (let ((t3 <fl> (* t2 t)))
                            ;; calculate hermite basis
                            (let ((h1 <fl> (+ (- (* 2. t3) (* 3. t2)) 1.))
                                  (h2 <fl> (+ (* (- 2.) t3) (* 3. t2)))
                                  (h3 <fl> (+ (- t3 (* 2. t2)) t))
                                  (h4 <fl> (- t3 t2)))
                              ;; do hermite interpolation
                              (vertex-x-set! pos (+ (* h1 (vertex-x (get-key~ key1))) (* h3 (vertex-x (get-out~ tan1))) (* h2 (vertex-x (get-key~ key2))) (* h4 (vertex-x (get-in~ tan2)))))
                              (vertex-y-set! pos (+ (* h1 (vertex-y (get-key~ key1))) (* h3 (vertex-y (get-out~ tan1))) (* h2 (vertex-y (get-key~ key2))) (* h4 (vertex-y (get-in~ tan2)))))
                              (vertex-z-set! pos (+ (* h1 (vertex-z (get-key~ key1))) (* h3 (vertex-z (get-out~ tan1))) (* h2 (vertex-z (get-key~ key2))) (* h4 (vertex-z (get-in~ tan2)))))))))))))
              (let ((quat (quaternion& 0. 0. 0. 1.))
                    (rotation-keys (get-rotation-keys~ bone)))
                (let ((num-rotation-keys <fx> (vector-length rotation-keys)))
                  (when (and (> num-rotation-keys 0) (or (not transition-bone) (> (vector-length (get-rotation-keys~ transition-bone)) 0)))
                    (let ((i1 (fx& -1))
                          (i2 (fx& -1)))
                      ;; find the two keys, where "frame" is in between for the rotation channel
                      (let (iter (i <fx> 0))
                        (when (< i (- num-rotation-keys 1))
                          (if (and (>= frame (get-time~ (cast <KeyFrame> (vector-ref rotation-keys i))))
                                   (< frame (get-time~ (cast <KeyFrame> (vector-ref rotation-keys (+ i 1))))))
                              (begin
                                (fx-set! i1 i)
                                (fx-set! i2 (+ i 1)))
                            (iter (+ i 1)))))
                      ;; transition special case
                      (when (and transition (= (fx-ref i1) -1))
                        (let ((first-key (cast <KeyFrame> (vector-ref rotation-keys 0))))
                          (if (< frame (get-time~ first-key))
                              (fx-set! i1 0)
                            (fx-set! i1 (- num-rotation-keys 1)))))
                      ;; if there are no such keys
                      (if (or (= (fx-ref i1) -1) (= (fx-ref i2) -1))
                          ;; either take the first key
                          (let ((first-key (cast <KeyFrame> (vector-ref rotation-keys 0))))
                            (if (< frame (get-time~ first-key))
                                (quaternion-copy! quat (get-key~ first-key))
                              (let ((last-key (cast <KeyFrame> (vector-ref rotation-keys (- num-rotation-keys 1)))))
                                (when (>= frame (get-time~ last-key))
                                  ;; or the last key
                                  (quaternion-copy! quat (get-key~ last-key))))))
                        ;; there are such keys, so do the quaternion slerp interpolation
                        (let ((key1 <KeyFrame> (vector-ref rotation-keys (fx-ref i1)))
                              (key2 <KeyFrame> (if transition
                                                   (vector-ref (get-rotation-keys~ transition-bone) 0)
                                                 (vector-ref rotation-keys (fx-ref i2)))))
                          (let ((t <fl>
                                  (if transition
                                      (/ transition-frame transition-duration)
                                    (/ (- frame (get-time~ key1))
                                       (- (get-time~ key2) (get-time~ key1))))))
                            (let ((q1 (make-quaternion&)))
                              (quaternion-copy! q1 (get-key~ key1))
                              (let ((q2 (make-quaternion&)))
                                (quaternion-copy! q2 (get-key~ key2))
                                (quaternion-slerp! quat q1 q2 t))))))))
                  ;; make a matrix from pos/quat
                  (let ((animation-matrix (make-identity-matrix&)))
                    (quaternion-matrix! animation-matrix quat)
                    (translate-matrix! animation-matrix pos)
                    (when (get-debug-animations?)
                      (quaternion-copy! (get-animation-rotation~ morph) quat)
                      (vertex-copy! (get-animation-position~ morph) pos))
                    ;; animate the local bone matrix using: local-matrix = local-skeleton-matrix * animation-matrix
                    (matrix-multiply! (get-local-matrix~ morph) (get-local-skeleton-matrix~ bone) animation-matrix)
                    ;; build up the hierarchy if bones
                    ;; global-matrix = global-matrix(parent) * local-matrix
                    (let ((parent-morph <Morph+> (get-parent~ morph)))
                      (if (not parent-morph)
                          (matrix-copy! (get-global-matrix~ morph) (get-local-matrix~ morph))
                        (matrix-multiply!
                          (get-global-matrix~ morph)
                          (get-global-matrix~ parent-morph)
                          (get-local-matrix~ morph)))))
                  ;; construct the bone transformation
                  (evaluate-bone morph)))))))))
  
  
  (method (evaluate-bone morph <Morph>) <void>
    (declare (optimize-dead-local-variables))
    (let ((t (make-identity-matrix&))
          (u (make-identity-matrix&))
          (v (make-identity-matrix&))
          (bone (get-bone~ morph)))
      (let ((bone-global-skeleton-matrix (get-global-skeleton-matrix~ bone)))
        (matrix-set! t 12 (- (matrix-ref bone-global-skeleton-matrix 12)))
        (matrix-set! t 13 (- (matrix-ref bone-global-skeleton-matrix 13)))
        (matrix-set! t 14 (- (matrix-ref bone-global-skeleton-matrix 14)))
        (matrix-transpose-3x3! u bone-global-skeleton-matrix)
        (matrix-multiply! v u t)
        (matrix-multiply! (get-bone-transformation~ morph) (get-global-matrix~ morph) v))))
  
  
  ;;;
  ;;;; Animate
  ;;;
  
  
  (method public (animate elapse)
    (declare (optimize-dead-local-variables))
    (site (animate-morphing on?: #f parent: animate)
      (if transition
          (let ((new-time (+ transition-frame (* elapse animations-acceleration))))
            (goto-transition new-time))
        (let ((new-time (flmodulo (+ current-time (* elapse (get-animation-fps~ animation) animations-acceleration)) (cast <fl> (get-total-frames~ animation)))))
          (goto-time new-time)))))
  
  
  (method public (goto-time time)
    (declare (optimize-dead-local-variables))
    (set! current-time time)
    (evaluate-frame current-time)
    (set! bone-matrices (extract-bone-matrices)))
  
  
  (method (goto-transition time)
    (set! transition-frame time)
    (evaluate-frame current-time)
    (set! bone-matrices (extract-bone-matrices)))
  
  
  (method (transition-done?)
    (and transition (>= transition-frame transition-duration)))
  
  
  (method (extract-bone-matrices)
    (declare (optimize-dead-local-variables))
    (let ((count morphs-count))
      (let ((content <f32vector> (or bone-matrices (make-f32vector (* 200 16)))))
        (loop (for i from 0 below count)
              (let ((morph (vector-ref morphs i)))
                (let ((bone-transformation <f64vector> (get-bone-transformation~ morph))
                      (offset (* i 16)))
                  (loop (for j from 0 below 16)
                        (f32vector-set! content (+ offset j) (f64vector-ref bone-transformation j))))))
        content)))))
