;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World History
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.history jazz


(import (jazz.cairo)
        (jazz.debuggee)
        (jazz.event)
        (jazz.graphic)
        (jazz.view)
        (world)
        (world.autoload)
        (world.interface.bars)
        (world.renderer)
        (world.shader)
        (world.shaders)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Shaders
;;;


(definition history-fs
  #/C/
#version 140

out vec4 fragColor;
 
void main()
{
    fragColor = vec4(0.45, 0.95, 0.0, 1.0);
}
//#)


;;;
;;;; Moment
;;;


(class Moment extends Object
  
  
  (slot metadata <object> accessors generate)
  (slot snapshot <object> accessors generate)
  (slot commands <object> accessors generate)
  (slot time     <object> accessors generate)
  (slot elapse   <object> accessors generate)
  
  
  (method override (initialize metadata snapshot commands time elapse)
    (nextmethod)
    (set! metadata~self metadata)
    (set! snapshot~self snapshot)
    (set! commands~self commands)
    (set! time~self time)
    (set! elapse~self elapse))
  
  
  (method meta override (marshall-object obj)
    (serialize-object (class-of obj)
                      (vector
                        (serialize (get-metadata~ obj))
                        (serialize (get-snapshot~ obj))
                        (serialize (get-commands~ obj))
                        (serialize (get-time~ obj))
                        (serialize (get-elapse~ obj)))))
  
  
  (method meta override (unmarshall-object content)
    (bind-vector (metadata snapshot commands time elapse) content
      (new self
        (deserialize metadata)
        (deserialize snapshot)
        (deserialize commands)
        (deserialize time)
        (deserialize elapse)))))


;;;
;;;; Logic
;;;


(definition stepping-history?
  (make-parameter #f))


(definition protected previous-logic
  #f)

(definition protected at-logic
  #f)

(definition protected logic-request
  #f)

(definition protected logic-continuation
  #f)


(definition any-logic
  '(any))

(definition skip-logic
  '(skip))

(definition complete-logic
  '(complete))


(definition protected logic-exit
  #f)

(definition (with-logic-exit thunk)
  (continuation-capture
    (lambda (exit)
      (set! logic-exit exit)
      (thunk))))

(definition (exit-logic)
  (let ((exit logic-exit))
    (if exit
        (begin
          (set! logic-exit #f)
          (continuation-return exit #f))
      (error "No available logic exit"))))


(definition (end-logic (reset-request? #f))
  (set! previous-logic #f)
  (set! at-logic #f)
  (when reset-request?
    (set! logic-request #f))
  (set! logic-continuation #f)
  (update-at-logic))


(definition protected (break-logic-at name)
  (let ((request logic-request))
    (when request
      (set! previous-logic at-logic)
      (set! at-logic name)
      (when (or (eq? request any-logic)
                (eq? request name))
        (mutex-unlock! task-mutex)
        (update-at-logic)
        (continuation-capture
          (lambda (cont)
            (set! logic-request #f)
            (set! logic-continuation cont)
            (exit-logic)))))))


(definition protected (break-logic-action action)
  (when logic-request
    (action)))


(definition protected (debug-logic . rest)
  (let ((request logic-request))
    (when (or (and (stepping-history?)
                   (eq? request #f))
              (eq? request any-logic)
              (eq? request complete-logic))
      (execute-event
        (lambda ()
          (apply debug rest))))))


(definition (update-at-logic)
  (let ((title (if at-logic (->string at-logic) "")))
    (set-title~ (child~ (find-bar 'history) 'at-logic) title)))


;;;
;;;; History
;;;


(class History extends Object
  
  
  (slot program  <object> initialize #f getter generate)
  (slot moments  <object> initialize #f accessors generate)
  (slot now      <object> initialize #f accessors generate)
  (slot current  <object> initialize #f accessors generate)
  (slot maximum  <fx+>    initialize #f accessors generate)
  (slot first    <fx+>    initialize #f accessors generate)
  (slot count    <fx+>    initialize #f accessors generate)
  (slot log-file <object> initialize #f getter generate)
  (slot log-port <object> initialize #f getter generate)
  
  
  (method override (initialize maximum)
    (nextmethod)
    (set! maximum~self maximum)
    (set! program~self (new Shader-Program name: 'history))
    (set-fs~ program history-fs)
    (set-vs~ program default-vs)
    (link~ program)
    (setup)
    (setup-log))
  
  
  (method (setup)
    (cond ((not maximum)
           (set! moments (new Axis 0))
           (set! now 0))
          (else
           (set! moments (make-vector maximum))
           (set! now 0)
           (set! first 0)
           (set! count 0))))
  
  
  (method (setup-log)
    @wait
    (let ((file (timestamped-file (logger-directory) "history" "log")))
      (create-directories~ file)
      (set! log-file file)
      (set! log-port (open-output-file (path-settings log-file)))))
  
  
  (method meta override (marshall-object obj)
    (serialize-object (class-of obj)
                      (vector
                        (serialize (accumulate (get-moments~ obj) serialize Vector))
                        (serialize (get-now~ obj))
                        (serialize (get-current~ obj))
                        (serialize (get-maximum~ obj))
                        (serialize (get-first~ obj))
                        (serialize (get-count~ obj)))))
  
  
  (method meta override (unmarshall-object content)
    (bind-vector (moments now current maximum first count) content
      (let ((obj (new self maximum)))
        (set-moments~ obj (accumulate moments deserialize Vector))
        (set-now~ obj (deserialize now))
        (set-current~ obj (deserialize current))
        (set-first~ obj (deserialize first))
        (set-count~ obj (deserialize count)))))
  
  
  (method (activate)
    )
  
  
  (method (deactivate)
    (end-logic #t))

  
  (method (history-start)
    0)
  
  
  (method (history-end)
    (if (not maximum)
        (cardinality moments)
      count))
  
  
  (method (history-first)
    0)
  
  
  (method (history-last)
    (- (history-end) 1))
  
  
  (method (historical-index n)
    (modulo (+ first n) maximum))
  
  
  (method (historical-moment n)
    (if (not maximum)
        (element moments n)
      (element moments (historical-index n))))
  
  
  (method (in-history n)
    (max (history-first) (min n (history-end))))
  
  
  (method (add-history moment)
    (cond ((not maximum)
           (axis-add moments moment)
           (increase! now))
          (else
           (let ((index (historical-index count)))
             (set-element! moments index moment)
             (if (< count maximum)
                 (begin
                   (increase! count)
                   (increase! now))
               (set! first (modulo (+ first 1) maximum)))))))
  
  
  (method (backward-history)
    (goto-history (- now 1)))
  
  
  (method (forward-history)
    (goto-history (+ now 1)))
  
  
  (method (goto-now)
    (goto-history now force?: #t))
  
  
  (method (goto-history n (force?: force? #f))
    (let ((world (current-world)))
      (end-logic)
      (let ((n (in-history n)))
        (when (or (/= n now) force?)
          (set! now n)
          (let ((snapshot
                  (if (= n (history-end))
                      current
                    (get-snapshot~ (historical-moment now)))))
            (load-world~ world snapshot)
            (invalidate-slider)
            (set-?n now))))))
  
  
  (method (stepped-history)
    (when (< now (history-end))
      (increase! now)
      (invalidate-slider)
      (set-?n now)))
  
  
  (method (invalidate-slider)
    (let ((world (current-world)))
      (invalidate-view~ (child~ (get-interface~ world) 'slider))))
  
  
  (method (slide-history where)
    (goto-history (fxround (* where (history-end)))))
  
  
  (method (truncate-future)
    (if (not maximum)
        (axis-adjust moments now)
      (set! count now)))
  
  
  ;;;
  ;;;; Step
  ;;;
  
  
  (method (step-history)
    (let ((world (current-world))
          (me (current-me)))
      (if logic-continuation
          ;; let logic run to completion
          (let ((cont logic-continuation))
            (set! previous-logic #f)
            (set! at-logic #f)
            (set! logic-request complete-logic)
            (set! logic-continuation #f)
            (continuation-return cont #f))
        (end-logic)
        (when (< now (history-end))
          (let ((moment (historical-moment now)))
            (when moment
              (parameterize ((stepping-history? #t))
                (let ((commands (get-commands~ moment))
                      (time (get-time~ moment))
                      (elapse (get-elapse~ moment)))
                  (complete~ commands)
                  (tick-sliced~ world me commands time elapse)
                  (tick-actors~ world commands time elapse)))))
          (stepped-history)))))
  
  
  (method (rewind-logic)
    (if (not previous-logic)
        (begin
          ;; find last logic
          (backward-history)
          (set! logic-request skip-logic)
          (step-history)
          ;; backward again to it
          (let ((request at-logic))
            (backward-history)
            (step-to request)))
      (let ((request previous-logic))
        (goto-now)
        (step-to request))))
  
  
  (method (step-logic)
    (if logic-continuation
        (with-logic-exit
          (lambda ()
            (let ((cont logic-continuation))
              (set! logic-request any-logic)
              (set! logic-continuation #f)
              (continuation-return cont #f))))
      (step-to any-logic)))
  
  
  (method (step-to request)
    (with-logic-exit
      (lambda ()
        (set! logic-request request)
        (step-history)))
    (when (not logic-continuation)
      ;; exit was not consumed so step again
      (if (and logic-exit (< now (history-end)))
          (step-logic)
        (end-logic #t))))
  
  
  ;;;
  ;;;; Future
  ;;;
  
  
  (method (recalculate-future)
    (let ((world (current-world))
          (me (current-me)))
      (let ((end (history-end)))
        (loop (for n from now below end)
              (let ((moment (historical-moment n)))
                (let ((commands (get-commands~ moment))
                      (time (get-time~ moment))
                      (elapse (get-elapse~ moment)))
                  (complete~ commands)
                  (tick-sliced~ world me commands time elapse)
                  (tick-actors~ world commands time elapse)
                  (let ((next (+ n 1)))
                    (let ((moment (historical-moment next)))
                      (receive (metadata snapshot) (snapshot-metadata/world~ world)
                        (if (= next end)
                            (set! current snapshot)
                          (set-metadata~ moment metadata)
                          (set-snapshot~ moment snapshot))))))))
        ;; for now
        (if (= now end)
            (load-world~ world current)
          (load-world~ world (get-snapshot~ (historical-moment now)))))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method (draw-history)
    (let ((max 1000))
      (loop (for n from (history-first) to (history-last))
            (repeat max)
            (draw-moment n))))
  
  
  (method (draw-moment n)
    (let ((moment (historical-moment n)))
      (let ((metadata (get-metadata~ moment))
            (now? (= n now)))
        (for-each (lambda (entity-metadata)
                    (bind (entity model matrix) entity-metadata
                      (cond ((and now? (history-draw-now?~ entity))
                             (register-ghost entity model matrix 0))
                            ((and (not now?) (history-draw-trail?~ entity))
                             (register-ghost entity model matrix 1)))))
                  metadata))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method (log-commands commands elapse)
    @wait (
    (format log-port "(commands {s} {s}){%}" (->symbolic~ commands) elapse)
    (force-output log-port)))
  
  
  (method (log-action name arguments)
    @wait (
    (format log-port "({s} {l}){%}" name arguments)
    (force-output log-port)))
  
  
  (method (flush-log)
    @wait (
    (close~ log-port)
    (set! log-port (open-output-file (path-settings log-file append: #t))))))


;;;
;;;; Snapshot
;;;


(class Snapshot extends Object
  
  
  (slot actors    getter generate)
  (slot gadgets   getter generate)
  (slot marks     getter generate)
  (slot camera    getter generate)
  (slot sun-angle getter generate)
  
  
  (method override (initialize actors gadgets marks camera sun-angle)
    (nextmethod)
    (set! actors~self actors)
    (set! gadgets~self gadgets)
    (set! marks~self marks)
    (set! camera~self camera)
    (set! sun-angle~self sun-angle))
  
  
  (method meta override (marshall-object obj)
    (serialize-object (class-of obj)
                      (vector
                        (get-actors~ obj)
                        (get-gadgets~ obj)
                        (get-marks~ obj)
                        (get-camera~ obj)
                        (get-sun-angle~ obj))))
  
  
  (method meta override (unmarshall-object content)
    (bind-vector (actors gadgets marks camera sun-angle) content
      (new self actors gadgets marks camera sun-angle))))


;;;
;;;; Slider
;;;


(class History-Slider extends View
  
  
  (slot sliding? initialize #f)
  
  
  (method (call-with-slider-info proc)
    (let ((world (current-world)))
      (let ((offset 7))
        (let ((width (- (get-width) offset offset))
              (history (get-history~ world)))
          (proc offset width
            (let ((end (history-end~ history)))
              (when (> end 0)
                (fxround (* (/ (cast <fl> (get-now~ history)) end) (cast <fl> (- width 2)))))))))))
  
  
  (method (inside-slider-thumb? h v)
    (call-with-slider-info
      (lambda (offset width thumb)
        (and thumb
             (<= (distance thumb h) 7)))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw surface context)
    (let ((world (current-world)))
      (call-with-slider-info
        (lambda (offset width thumb)
          (define (circle at size color)
            (let ((top 12))
              (ellipse~ surface (new Rect (+ at thumb) (+ top at) (+ at thumb size) (+ top at size)) color #f)))
          
          (let ((antialias (get-antialias~ surface)))
            (set-antialias~ surface CAIRO_ANTIALIAS_NONE)
            (frame-rect~ surface (new Rect offset 19 (+ offset width) 21) {Color Gray})
            (when thumb
              (circle 2 12 {Color Light-Blue alpha: .5})
              (circle 1 14 {Color Light-Blue})
              (circle 0 16 {Color Light-Blue alpha: .5}))
            (set-antialias~ surface antialias))))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down evt)
    (let ((world (current-world)))
      (let ((history (get-history~ world))
            (h (get-h~ evt))
            (v (get-v~ evt)))
        (set! sliding? #t)
        (unless (inside-slider-thumb? h v)
          (slide-history~ history (h->where h))))))
  
  
  (method override (drag-move evt)
    (let ((world (current-world)))
      (let ((history (get-history~ world)))
        (when sliding?
          (slide-history~ history (h->where (get-h~ evt)))))))
  
  
  (method override (mouse-up evt)
    (when sliding?
      (set! sliding? #f)))
  
  
  (method (h->where h)
    (let ((world (current-world)))
      (call-with-slider-info
        (lambda (offset width thumb)
          (let ((where (/ (cast <fl> (- h offset)) (cast <fl> width))))
            (max 0. (min 1. where)))))))))
