;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World History
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.history jazz


(import (jazz.event)
        (jazz.network)
        (world)
        (world.autoload)
        (world.change)
        (world.network)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Id
;;;


(definition protected (make-unique-id)
  (make-uuid))


;;;
;;;; Literal
;;;


;; 0 is reserved for #f
(definition next-literal-id
  1)

(definition protected (next-literal-id!)
  (prog1 next-literal-id
    (increase! next-literal-id)))


(definition protected literal-ids
  (make-table test: equal?))

(definition protected id-literals
  (make-table test: eqv?))

;; open test quicky these should simply go inside the tier
(definition protected (reset-literals)
  (set! next-literal-id 1)
  (set! literal-ids (make-table test: equal?))
  (set! id-literals (make-table test: eqv?)))


(definition public (literal->id literal (tier #f))
  (if (not literal)
      0
    (or (table-ref literal-ids literal #f)
        (let ((id (tier-literal->id~ (or tier (current-tier)) literal)))
          (table-set! literal-ids literal id)
          (table-set! id-literals id literal)
          id))))


(definition public (id->literal id (tier #f))
  (if (= id 0)
      #f
    (or (table-ref id-literals id #f)
        (let ((literal (tier-id->literal~ (or tier (current-tier)) id)))
          (table-set! literal-ids literal id)
          (table-set! id-literals id literal)
          literal))))


;;;
;;;; Logic
;;;


(definition protected stepping-history?
  (make-parameter #f))


(definition protected previous-logic
  #f)

(definition protected at-logic
  #f)

(definition protected logic-continuation
  #f)


(definition any-logic
  '(any))

(definition skip-logic
  '(skip))

(definition complete-logic
  '(complete))

(definition protected logic-request
  #f)


(definition protected logic-again?
  #f)


(definition protected logic-exit
  #f)

(definition (with-logic-exit thunk)
  (continuation-capture
    (lambda (exit)
      (set! logic-exit exit)
      (thunk))))

(definition (exit-logic)
  (let ((exit logic-exit))
    (if exit
        (begin
          (set! logic-exit #f)
          (continuation-return exit #f))
      (error "No available logic exit"))))

(definition (clear-exit)
  (set! logic-exit #f))


(definition (clear-where)
  (set! previous-logic #f)
  (set! at-logic #f)
  (update-at-logic))


(definition (clear-logic (reset-request? #f))
  (set! previous-logic #f)
  (set! at-logic #f)
  (when reset-request?
    (set! logic-request #f))
  (set! logic-continuation #f)
  (update-at-logic))


(definition protected (break-logic-at name)
  (let ((request logic-request))
    (when request
      (set! previous-logic at-logic)
      (set! at-logic name)
      (when (or (eq? request any-logic)
                (eq? request name))
        (update-at-logic)
        (continuation-capture
          (lambda (cont)
            (set! logic-request #f)
            (set! logic-continuation cont)
            (exit-logic)))))))


(definition protected (break-logic-action action)
  (when logic-request
    (action)))


(definition protected (in-logic?)
  (let ((request logic-request))
    (or (and (stepping-history?)
             (eq? request #f))
        (eq? request any-logic)
        (eq? request complete-logic))))


(definition protected (debug-logic . rest)
  (when (in-logic?)
    (execute-event
      (lambda ()
        (apply debug rest)))))


;;;
;;;; Update
;;;


(definition update-at-logic
  (lambda ()
    ))

(definition protected (set-update-at-logic proc)
  (set! update-at-logic proc))


;;;
;;;; History
;;;


(definition index-size <fx>
  7)

(definition metadata-size <fx>
  1)


(class History extends Object
  
  
  (slot size            <fx>     getter generate)
  (slot indexes-size    <fx>     getter generate)
  (slot indexes         <object> getter generate)
  (slot changes-size    <fx>     getter generate)
  (slot changes-head    <fx>     getter generate)
  (slot changes         <object> getter generate)
  (slot metadatas-size  <fx>     getter generate)
  (slot metadatas-head  <fx>     getter generate)
  (slot metadatas       <object> getter generate)
  (slot now             <object> accessors generate)
  (slot first           <fx>     accessors generate)
  (slot count           <fx>     accessors generate)
  (slot paused?         <bool>   accessors generate)
  
  
  (method override (initialize size)
    (nextmethod)
    (set! size~self size)
    (set! indexes-size (* size index-size))
    (set! indexes (make-u32vector indexes-size))
    (set! changes-size (* size (max-bidirectional-size)))
    (set! changes-head 0)
    (set! changes (make-f64vector changes-size))
    (set! metadatas-size (* size metadata-size))
    (set! metadatas-head 0)
    (set! metadatas (make-vector metadatas-size))
    (set! now 0)
    (set! first 0)
    (set! count 0)
    (set! paused? #f))
  
  
  (method (pause)
    (set! paused? #t))
  
  
  (method (unpause)
    (clear-logic #t)
    (clear-exit)
    (set! paused? #f))

  
  (method (history-start)
    0)
  
  
  (method (history-end)
    count)
  
  
  (method (history-first)
    0)
  
  
  (method (history-last)
    (- (history-end) 1))
  
  
  (method (historical-index n)
    (modulo (+ first (* n index-size)) indexes-size))
  
  
  (method (historical-time n)
    (u32vector-ref indexes (historical-index n)))
  
  (method (historical-client-id n)
    (u32vector-ref indexes (+ (historical-index n) 1)))
  
  (method (historical-change-id n)
    (u32vector-ref indexes (+ (historical-index n) 2)))
  
  (method (historical-action-index n)
    (u32vector-ref indexes (+ (historical-index n) 3)))
  
  (method (historical-forward-index n)
    (u32vector-ref indexes (+ (historical-index n) 4)))
  
  (method (historical-backward-index n)
    (u32vector-ref indexes (+ (historical-index n) 5)))
  
  (method (historical-metadata-index n)
    (u32vector-ref indexes (+ (historical-index n) 6)))
  
  
  (method (historical-metadata n)
    (vector-ref metadatas (historical-metadata-index n)))
  
  
  (method (in-history n)
    (max (history-first) (min n (history-end))))
  
  
  (method (changes-push val <fl>)
    (f64vector-set! changes changes-head val)
    (set! changes-head (modulo (+ changes-head 1) changes-size)))
  
  
  (method (metadatas-push val)
    (vector-set! metadatas metadatas-head val)
    (set! metadatas-head (modulo (+ metadatas-head 1) metadatas-size)))
  
  
  (method (add-change time change-id action forward backward metadata)
    (let ((index (historical-index now)))
      (assert client-no)
      (u32vector-set! indexes index time)
      (u32vector-set! indexes (+ index 1) client-no)
      (u32vector-set! indexes (+ index 2) change-id)
      (u32vector-set! indexes (+ index 3) changes-head)
      (action changes-push)
      (u32vector-set! indexes (+ index 4) changes-head)
      (forward changes-push)
      (u32vector-set! indexes (+ index 5) changes-head)
      (backward changes-push)
      (u32vector-set! indexes (+ index 6) metadatas-head)
      (metadatas-push metadata)
      (unless (stepping-history?)
        (if (< count size)
            (begin
              (increase! count)
              (increase! now))
          (set! first (modulo (+ first index-size) indexes-size)))))
    (when (or (eq? tier-kind 'client)
              (and (eq? tier-kind 'server)
                   (not (admin?))))
      (outgoing-push (cast <fl> client-no))
      (outgoing-push (cast <fl> change-id))
      (forward outgoing-push)))
  
  
  (method (backward-history)
    (goto-history (- now 1)))
  
  
  (method (forward-history)
    (goto-history (+ now 1)))
  
  
  (method (goto-now)
    (goto-history now))

  
  (method (goto-history n)
    (let ((n (in-history n)))
      (when (/= n now)
        (cond ((> n now)
               (loop (for s from now below n)
                     (let ((client-id (historical-client-id s))
                           (id (historical-change-id s))
                           (forward-index (historical-forward-index s)))
                       (forward-change client-id id
                         (lambda ()
                           (prog1 (f64vector-ref changes (modulo forward-index changes-size))
                             (increase! forward-index)))))))
              (else
               (loop (for s from (- now 1) downto n)
                     (let ((client-id (historical-client-id s))
                           (id (historical-change-id s))
                           (backward-index (historical-backward-index s)))
                       (backward-change client-id id
                         (lambda ()
                           (prog1 (f64vector-ref changes (modulo backward-index changes-size))
                             (increase! backward-index))))))))
        (set! now n)
        (invalidate-slider)
        (set-?n now))))
  
  
  (method (invalidate-slider)
    (let ((interface (current-interface)))
      (invalidate-view~ (child~ interface 'slider))))
  
  
  (method (slide-history where)
    (goto-history (fxround (* where (cast <fl> (history-end))))))
  
  
  (method (truncate-history)
    (set! count now))
  
  
  ;;;
  ;;;; Step
  ;;;

  
  (method (step-backward)
    (if previous-logic
        (let ((request previous-logic))
          (goto-now)
          (step-to request))
      ;; find last logic
      (backward-history)
      (step-request skip-logic)
      ;; backward again to it
      (let ((request at-logic))
        (backward-history)
        (step-to request))))
  
  
  (method (step-forward)
    (if logic-continuation
        (continue-logic any-logic #t)
      (step-to any-logic)))
  
  
  (method (step-over)
    (if logic-continuation
        (begin
          (clear-where)
          ;; let logic run to completion
          (continue-logic complete-logic #f))
      (step-history)))
  
  
  (method (continue-logic request again?)
    (with-logic-exit
      (lambda ()
        (let ((cont logic-continuation))
          (set! logic-request request)
          (set! logic-again? again?)
          (set! logic-continuation #f)
          (continuation-return cont #f)))))
  
  
  (method (step-to request)
    (with-logic-exit
      (lambda ()
        (step-again request))))
  
  
  (method (step-again request)
    (step-request request)
    ;; exit was not consumed so step again
    (if logic-again?
        (when (< now (history-end))
          (step-again any-logic))
      (clear-logic #t))
    (exit-logic))
  
  
  (method (step-request request)
    (set! logic-request request)
    (step-history))
  
  
  ;; this is correct as we are redoing the same action so
  ;; the space taken on the changes buffer will be the same
  (method (step-history)
    (clear-logic)
    (when (< now (history-end))
      (let ((client-id (historical-client-id now))
            (id (historical-change-id now)))
        (parameterize ((stepping-history? #t))
          (action/forward-change client-id id))
        (stepped-history))))
  
  
  (method (action/forward-change client-id id)
    (let ((change (id->change id)))
      (if (get-action-apply~ change)
          (let ((action-index (historical-action-index now)))
            (action-change client-id id
              (lambda ()
                (prog1 (f64vector-ref changes (modulo action-index changes-size))
                  (increase! action-index)))))
        (let ((forward-index (historical-forward-index now)))
          (forward-change client-id id
            (lambda ()
              (prog1 (f64vector-ref changes (modulo forward-index changes-size))
                (increase! forward-index))))))))
  
  
  (method (stepped-history)
    (when (< now (history-end))
      ;; we could let add-change advance the now but not
      ;; at the moment because some changes have no action
      (if (< count size)
          (increase! now)
        (set! first (modulo (+ first index-size) indexes-size)))
      (invalidate-slider)
      (set-?n now)))
  
  
  ;;;
  ;;;; Future
  ;;;
  
  
  ;; future can be recalculated in-place as we are redoing the same
  ;; actions so the space taken on the changes buffer stays constant
  (method (recalculate-future)
    (let ((now now)
          (end (history-end)))
      (loop (for n from now below end)
            (let ((client-id (historical-client-id n))
                  (id (historical-change-id n)))
              (parameterize ((stepping-history? #t))
                (action/forward-change client-id id))
              (stepped-history)))
      (goto-history now)))))
