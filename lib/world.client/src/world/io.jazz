;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World I/O
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.io jazz


(import (jazz.application)
        (jazz.component)
        (jazz.debuggee)
        (jazz.io)
        (jazz.markup)
        (jazz.network)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.syntax (phase syntax))
        (jazz.version)
        (jazz.view)
        (world)
        (world.assets)
        (world.autoload)
        (world.client)
        (world.context)
        (world.dye)
        (world.geometry)
        (world.master)
        (world.processor)
        (world.settings)
        (world.syntax (phase syntax))
        (world.task)
        (world.tier)
        (world.window)
        (world.work))


;;;
;;;; Default
;;;


(definition *world-directories*
  '())

(definition public (world-directories)
  *world-directories*)

(definition public (set-world-directories directories)
  (set! *world-directories* directories))


(definition public (find-world name)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (info)
                  (bind (world-name . world-dir) info
                    (when (filename=? world-name name)
                      (continuation-return return world-dir))))
                (world-directories))
      #f)))


;;;
;;;; World
;;;


(definition protected boot-restart
  (make-parameter #f))


(definition public (boot-world kind start-world (start-zone: start-zone #f))
  (with-task-mutex
    (lambda ()
      (continuation-capture
        (lambda (restart)
          (parameterize ((boot-restart restart))
            (let ((dir (find-world start-world)))
              (open-world kind (new-file dir ".world") start-zone: start-zone))))))))


(definition public (open-world kind file (start-zone: start-zone #f))
  (let ((form (convert-world (read-form file))))
    (load-point 'world-form)
    (make-world kind form start-zone: start-zone)))


(definition public (make-world kind form (start-zone: start-zone #f))
  (close-world)
  (let ((world (instantiate form)))
    (define (open-safe name)
      (define (open)
        (let ((file (if (not name) ;; quick hack
                        (if master-process ;; quick hack
                            {File Settings "servers" "Local" ".server"}
                          (get-server-file))
                      (find-tier name kind))))
          (if file
              (case kind
                ((standalone) (open-standalone file))
                ((client) (open-client-safe file))
                ((server) (open-server file)))
            (report (format "Unable to find {a}: {a}" (or kind 'zone) name)))))
      
      (define (open-client-safe file)
        (let ((obj (open-client file)))
          (if (is? obj Zone)
              obj
            (report (if (string? obj)
                        obj
                      "Unable to connect to server")))))
      
      (define (report exception-message)
        (cond ((using-debugger?)
               (error "{a}" exception-message))
              ((not (window?))
               (snapshot-process exception: (new Error message: exception-message))
               (quit))
              (else
               (let ((welcome (open-welcome-zone)))
                 (report-exception welcome exception-message #f)
                 welcome))))
      
      (if (and (window?) (process-copyright-changed? (current-application)))
          (let ((zone (open-welcome-zone)))
            (set-post-accept zone open))
        (open)))
    
    (load-point 'world-instantiate)
    (unless (get-title world)
      (let ((origin (get-origin form)))
        (when origin
          (set-title world (get-name (get-parent origin))))))
    (set-designer world (new Former form: form reference: world))
    (setup-opengl world)
    (resize-scene world)
    (initialize-world world)
    (load-point 'world-initialize)
    (unless (eq? start-zone 'none)
      (case kind
        ((client)
         (let ((client (command-argument "client")))
           (if client
               (open-safe client)
             ;; quick hack until standalone and client are unified
             (set! kind 'standalone)
             (set-tier-kind 'standalone)
             (let ((name (or start-zone (command-argument "zone") (world-setting 'world.last-zone #f))))
               (if #f @for-tests name
                   (open-safe name)
                 (open-welcome-zone))))))
        ((server)
         (open-safe #f))
        ((processor)
         (open-processor)))
      (update-title world))
    (load-point 'world-ready)
    world))


(definition public (close-world)
  (let ((world (current-world+)))
    (when world
      (close world))))


(definition protected event-restart
  (make-parameter #f))


(definition protected (world-loop done?)
  (define (thread-process-delayed-events)
    (declare (proper-tail-calls))
    (let ((thunk (read-delayed-event)))
      (when (not (eof-object? thunk))
        (thunk)
        (thread-process-delayed-events))))
  
  (declare (proper-tail-calls))
  (setup-threads (current-world))
  (let (loop)
    (continuation-capture
      (lambda (restart)
        (parameterize ((event-restart restart))
          (let ((thunk (thread-read-message timeout: +infinity)))
            (site (delayed on?: #f parent: event)
              (thread-process-delayed-events))
            (site (event on?: #t)
              (when (not (eof-object? thunk))
                (thunk)))))))
    (unless (and done? (done?))
      (loop))))


(definition protected (world-products)
  (let ((world (current-world+)))
    (if (not world)
        '()
      '()
      @cant-find-get-installed-modules
      (let ((queue (new-queue)))
        (iterate-table (get-installed-modules world)
          (lambda (name info)
            (bind (dirname . repository) info
              (for-each (lambda (package)
                          (for-each (lambda (product)
                                      (let ((name (product-descriptor-name product)))
                                        (enqueue queue name)))
                                    (package-products package)))
                        (repository-packages repository)))))
        (queue-list queue)))))


(definition protected (world-properties kind)
  (list kind: kind))


(definition protected (quit-world)
  (define (save-settings)
    (let ((zone (current-zone)))
      (let ((path (zone-path zone tier-kind)))
        (set-setting options-settings 'world.last-zone path)
        (save-content options-settings))))
  
  (save-settings)
  (close-zone)
  (close-world))


(definition (convert-world form)
  (define (convert->1.1 form)
    (set-version (get-data form) {Version 1 1})
    form)
  
  (let ((version (or (get-version (get-data form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.1 form))
          ((nu=? version {Version 1 1})
           form)
          (else
           (error "Unsupported world version: {a}" (present-string version))))))


;;;
;;;; Tier
;;;


(definition protected (startup-tier kind dir)
  ;; open test quick hacks
  (world.history:reset-literals)
  (world.id:reset-entities)
  ;; sejour quick hack to think through
  (world.generation:reset-block-actions)
  @commented-during-~-conversion-GAZOUM
  (world.script:reset-properties)
  (world.script.asset:reset-asset-entities)
  (world.spawn:initialize-spawned)
  
  (case kind
    ((standalone)
     (new Standalone-Tier dir))
    ((client)
     (new Client-Tier dir))
    ((server)
     (new Server-Tier dir))
    ((processor)
     (new Processor-Tier dir))))


(definition protected (shutdown-tier)
  (let ((tier (current-tier+)))
    (when tier
      (shutdown tier))))


;;;
;;;; Standalone
;;;


(definition public (open-standalone file)
  (let ((dir {Directory Settings "servers" "Local"}))
    (let ((tier (startup-tier 'standalone dir)))
      (close-zone)
      (set-tier-kind 'standalone)
      (set-current-tier tier)
      (open-zone file scripts?: #f))))


;;;
;;;; Local
;;;


(definition protected local-server
  #f)

(definition protected (set-local-server server)
  (set! local-server server))


(definition (spawn-local-server)
  (start-remote-presence)
  (spawn-slave "server" (get-server-filename)
    (lambda (master slave cookie)
      )
    (lambda (master slave cookie)
      slave)
    arguments: '("-panel" "false")
    debug?: (world-setting 'world.server-debug? #t)
    wait?: #t))


(definition public (open-local file (scripts?: scripts? #t))
  (when (not local-server)
    (let ((server (spawn-local-server)))
      (set! local-server server)))
  (let ((zone (cons 'zone (butlast (subpath {Directory Settings "servers" "Local" "zones"} file)))))
    (set-client-configuration (new Client character-name: "Client" character-avatar: "character/nightelffemale" character-zone: zone)))
  (open-client {File Settings "clients" "Local" ".client"} #t))


;;;
;;;; Client
;;;


(definition public common-names
  '("Emma" "Lea" "Olivia" "Alice" "Florence" "Zoe" "Chloe" "Beatrice" "Charlotte" "Rosalie" "Eva" "Juliette" "Sofia" "Jade" "Camille" "Victoria" "Mia" "Charlie" "Romy" "Laurence" "Maeva" "Alicia" "Clara" "Annabelle" "Sarah" "Rose" "Raphaelle" "Livia" "Elizabeth" "Mila" "Anais" "Elodie" "Flavie" "Laurie" "Amelia" "Julia" "Leonie" "Maelie" "Gabrielle" "Sophia" "Adele" "Coralie" "Emy" "Noemie" "Aurelie" "Alexia" "Jeanne" "Emilie" "Eve" "Ophelie" "Thomas" "William" "Jacob" "Liam" "Felix" "Nathan" "Samuel" "Logan" "Alexis" "Noah" "Olivier" "Raphael" "Gabriel" "Emile" "Leo" "Charles" "Antoine" "Benjamin" "Adam" "Edouard" "Xavier" "Victor" "Zack" "Mathis" "Jayden" "Theo" "Elliot" "Zachary" "Louis" "James" "Anthony" "Alexandre" "Lucas" "Justin" "Arthur" "Tristan" "Loic" "Ethan" "Henri" "Nolan" "Nicolas" "Arnaud" "Jeremy" "Hugo" "Dylan" "Laurent" "Eli" "Vincent" "Isaac" "Etienne"))


(definition protected (create-client-file client-name server-address server-port name avatar (script #f))
  (let ((dir (new-directory {Directory Settings "clients"} client-name)))
    (create-directories dir)
    (let ((client-file (new-file dir ".client")))
      (call-with-output-file (path-settings client-file)
        (lambda (output)
          (format output ";;;========={%}")
          (format output ";;;  Yownu{%}")
          (format output ";;;========={%}")
          (format output ";;;{%}")
          (format output ";;;; Client{%}")
          (format output ";;;{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(data jazz{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(version {a}){%}" (present-string zone-version))
          (format output "(import world.client){%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(form{%}")
          (format output "  (<Client> server-host: {s} server-service: {s} character-name: {s} character-avatar: {s}"
            (string->host server-address)
            (string->port server-port)
            name
            avatar)
          (when script
            (format output " character-script: {s}" script))
          (format output "))){%}")))
      client-file)))


(definition protected (create-client-files client-prefix count server-address server-port (script #f))
  (let ((avatars (remove "character/dwarfmale" (world.interface.avatars:collect-avatar-models) test: equal?)))
    (loop (for n from 1 to count)
          (let ((client-name (format "{a}{a}" client-prefix n))
                (name (random-element common-names))
                (avatar (random-element avatars))
                (script (or script "bot/player")))
            (let ((fullname (format "{a} ({a})" name client-name)))
              (create-client-file client-name server-address server-port fullname avatar script))))))


(definition public (open-client client-file (local? #f))
  (define (problem? obj)
    (or (connection-problem? obj)
        (string? obj)))
  
  (define (open)
    (set-local? local?)
    (let ((dir (get-parent client-file)))
      (let ((tier (startup-tier 'client dir)))
        (close-zone)
        (let ((file (zone-file dir 'client))
              (form (get-form tier)))
          (set-origin form file)
          (set-tier-kind 'client)
          (set-current-tier tier)
          (open-zone file form: form)))))
  
  (catch (problem? obj
           obj)
    (open)))


;;;
;;;; Server
;;;


(definition public (create-server-file server-name server-address server-port name avatar)
  (let ((dir (new-directory {Directory Settings "servers"} server-name)))
    (create-directories dir)
    (let ((server-file (new-file dir ".server")))
      (call-with-output-file (path-settings server-file)
        (lambda (output)
          (format output ";;;========={%}")
          (format output ";;;  Yownu{%}")
          (format output ";;;========={%}")
          (format output ";;;{%}")
          (format output ";;;; Server{%}")
          (format output ";;;{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(data jazz{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(version {a}){%}" (present-string zone-version))
          (format output "(import world.server){%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(form{%}")
          (format output "  (<Server> host: {s} service: {s} character-name: {s} character-avatar: {s}))){%}"
            (string->host server-address)
            (string->port server-port)
            name
            avatar)))
      server-file)))


(definition public (open-server server-file)
  (let ((dir (get-parent server-file)))
    (let ((tier (startup-tier 'server dir)))
      (close-zone)
      (let ((processor (new Processor)))
        (let ((file (zone-file dir 'server)))
          (set-tier-kind 'server)
          (set-current-tier tier)
          (set-current-processor processor)
          (open-zone file))))))


;;;
;;;; Processor
;;;


(definition public (open-processor)
  (let ((processor (current-processor)))
    (let ((server-name (get-server-name processor))
          (zone (get-zone processor)))
      (let ((server-dir (new-directory {Directory Settings "servers"} server-name)))
        (let ((file (case (car zone)
                      ((instance) (new-file server-dir `("instances" ,(cadr zone) ".zone")))
                      (else (new-file server-dir `("zones" ,@(cdr zone) ".zone"))))))
          (let ((dir (get-parent file)))
            (let ((tier (startup-tier 'processor dir))
                  (zone (zone-file dir 'processor)))
              (set-tier-kind 'processor)
              (set-current-tier tier)
              (open-zone zone))))))))


;;;
;;;; Zone
;;;


(definition public (open-zone file (form: form #f) (scripts?: scripts? #t))
  (close-all-popups)
  (let ((form (or form (convert-zone (read-form file)))))
    (load-point 'zone-form)
    (make-zone file form scripts?)))


(definition public (make-zone file form scripts?)
  (let ((world (current-world)))
    (let ((dir (get-parent file)))
      (prepare-zone-assets world dir)
      (prepare-template-assets world dir)
      (prepare-modules world))
    (let ((zone (instantiate form)))
      (load-point 'zone-instantiate)
      (unless (get-title zone)
        (set-title zone (zone-name (get-moniker zone) tier-kind)))
      (set-designer zone (new Former form: form reference: zone))
      (initialize-zone zone)
      (load-point 'zone-initialize)
      (when scripts?
        (let ((script (get-prepare-script zone)))
          (when script
            (launch-event world script))))
      (zone-update world)
      (player-update zone)
      (update-title world)
      (when (get-sun-cycle? zone)
        (position-sun zone #f angle: (get-sun-angle zone)))
      (populate-zone zone)
      (setup-lighting zone)
      (prepare-motion world)
      (when scripts?
        (let ((script (get-enter-script zone)))
          (when script
            (launch-event world script))))
      (let ((appl (current-application))
            (dir (get-directory zone)))
        (unless (or (admin?)
                    (not (window?))
                    (member? (get-name dir) '("welcome" "tutorial") test: filename=?))
          (check-news appl)))
      (zone-ready zone)
      (load-point 'zone-ready)
      (start-tasks zone)
      (init-stable (get-eye world))
      (init-stable (get-history-camera world))
      (set-ready? zone #t)
      (reset-shutdown)
      zone)))


(definition (close-zone)
  (let ((zone (current-zone+)))
    (when zone
      (close zone)
      (shutdown-tier)
      (set-tier-kind #f)
      (set-current-tier #f)
      (set-current-processor #f))))


(definition public (find-tier name kind)
  (let ((world (current-world)))
    (let ((directory (get-tiers-directory world kind)))
      (continuation-capture
        (lambda (return)
          (when (exists? directory)
            (iterate-directory directory
              (lambda (path path-kind)
                (let ((dir (new-directory directory path)))
                  (let ((file (tier-file dir kind)))
                    (when (and (exists? file)
                               (filename=? (filename-spine (join path "/")) name))
                      (continuation-return return file)))))
              full?: #f
              files?: #f
              directories?: #t))
          #f)))))


(definition public (find-zone name kind)
  (let ((world (current-world)))
    (let ((directory (get-tiers-directory world kind)))
      (continuation-capture
        (lambda (return)
          (when (exists? directory)
            (iterate-directory directory
              (lambda (path path-kind)
                (let ((dir (new-directory directory path)))
                  (let ((file (zone-file dir kind)))
                    (when (and (exists? file)
                               (filename=? (filename-spine (join path "/")) name))
                      (continuation-return return file)))))
              full?: #f
              files?: #f
              directories?: #t))
          #f)))))


(definition protected (tier-name file)
  (get-name (get-parent file)))


(definition protected (tier-file dir kind)
  (new-file dir (case kind
                   ((standalone) ".zone")
                   ((client) ".client")
                   ((server) ".server"))))


(definition protected (zone-file dir kind)
  (new-file dir (if (or (eq? kind 'standalone)
                         (eq? kind 'processor))
                     ".zone"
                   '("start" ".zone"))))


(definition protected (zone-name moniker kind)
  (get-name (if (or (eq? kind 'standalone)
                     (eq? kind 'processor))
                 (get-parent moniker)
               (get-parent (get-parent moniker)))))


(definition protected (new-zone-file base kind)
  (let ((world (current-world)))
    (let ((directory (get-tiers-directory world kind))
          (path (split base "/")))
      (zone-file (new-directory directory path) kind))))


(definition public (open-welcome-zone)
  (open-standalone (find-tier (copy-zone-template "welcome" 'standalone) 'standalone)))


(definition public (open-tutorial-zone (force-copy?: force-copy? #f) (scripts?: scripts? #t))
  (open-standalone (find-tier (copy-zone-template "tutorial" 'standalone force-copy?: force-copy?) 'standalone)))


(definition public (copy-zone-template name kind (force-copy?: force-copy? #f))
  (let ((world (current-world)))
    (let ((from-dir (new-directory (new-directory (get-world-directory world) "templates") name))
          (to-dir (get-parent (new-zone-file name kind))))
      (when (or force-copy? (not (exists? to-dir)))
        (duplicate from-dir to-dir))
      name)))


(definition public (tutorial-template?)
  (let ((zone (current-zone)))
    (equal? (zone-path zone 'standalone) "tutorial")))


(definition (convert-zone form)
  (define (convert->1.1 form)
    (define (convert-children form)
      (for-each convert (get-children form)))
    
    (define (convert form)
      (let ((x (get-property form x:)))
        (when x
          (let ((y (get-property form y:))
                (z (get-property form z:)))
            (remove-property form x:)
            (remove-property form y:)
            (remove-property form z:)
            (set-property form position: (vertex x y z)))))
      (let ((width (get-property form width:)))
        (when width
          (let ((height (get-property form height:))
                (depth (get-property form depth:)))
            (remove-property form width:)
            (remove-property form height:)
            (remove-property form depth:)
            (set-property form size: (vertex width height depth)))))
      (let ((color (get-property form color:)))
        (when color
          (set-property form color: (color->dye color))))
      (convert-children form))
    
    (set-version (get-data form) {Version 1 1})
    (convert-children form)
    form)
  
  (define (convert->1.2 form)
    (define (convert-children form)
      (for-each convert-child (get-children form)))
    
    (define (convert-child form)
      (scale-down form position:)
      (scale-down form radiuses:)
      (scale-down form radius:)
      (scale-down form v1:)
      (scale-down form v2:)
      (scale-down form v3:)
      (scale-down form v4:))
    
    (define (scale-down form property)
      (let ((value (get-property form property)))
        (when value
          (set-property form property (if (f32vector? value)
                                           (f32vertex-scalar/ value 5.)
                                         (/ value 5.))))))
    
    (define (f32vertex-scalar/ v <f32vector> r <fl>) <f32vector>
      (f32vector
        (/ (f32vector-ref v 0) r)
        (/ (f32vector-ref v 1) r)
        (/ (f32vector-ref v 2) r)))
    
    (set-version (get-data form) {Version 1 2})
    (scale-down form start-eye:)
    (scale-down form start-position:)
    (convert-children form)
    form)
  
  (define (convert->1.3 form)
    (define (convert-children form)
      (for-each convert-child (get-children form)))
    
    (define (convert-child form)
      (convert form position:)
      (convert form radiuses:)
      (convert form radius:)
      (convert form v1:)
      (convert form v2:)
      (convert form v3:)
      (convert form v4:))
    
    (define (convert form property)
      (let ((value (get-property form property)))
        (when (f32vector? value)
          (let ((len (f32vector-length value)))
            (let ((converted (make-f64vector len)))
              (loop (for i from 0 below len)
                    (f64vector-set! converted i (f32vector-ref value i)))
              (set-property form property converted))))))
    
    (set-version (get-data form) {Version 1 3})
    (convert form start-eye:)
    (convert form start-eye-sight:)
    (convert form start-eye-up:)
    (convert form start-position:)
    (convert form start-sight:)
    (convert form start-up:)
    (convert-children form)
    form)
  
  (define (convert->1.4 form)
    (define (convert-children form)
      (for-each convert-child (get-children form)))
    
    (define (convert-child form)
      (let ((value (get-property form scale:)))
        (when (flonum? value)
          (set-property form scale: (vertex value value value)))))
    
    (set-version (get-data form) {Version 1 4})
    (convert-children form)
    form)
  
  (let ((version (or (get-version (get-data form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.4 (convert->1.3 (convert->1.2 (convert->1.1 form)))))
          ((nu=? version {Version 1 1})
           (convert->1.4 (convert->1.3 (convert->1.2 form))))
          ((nu=? version {Version 1 2})
           (convert->1.4 (convert->1.3 form)))
          ((nu=? version {Version 1 3})
           (convert->1.4 form))
          ((nu=? version {Version 1 4})
           form)
          (else
           (error "Unsupported zone version: {a}" (present-string version)))))))
