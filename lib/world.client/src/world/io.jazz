;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World I/O
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.io jazz


(import (jazz.designer)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.system)
        (jazz.ui.window)
        (jazz.version)
        (world)
        (world.autoload)
        (world.dye)
        (world.geometry)
        (world.settings)
        (world.syntax (phase syntax))
        (world.window))


;;;
;;;; Default
;;;


(definition public (select-default-world)
  (let ((start-world (find-setting 'world.start-world #f)))
    (if (not start-world)
        (new-world)
      (let ((dir (find-world start-world)))
        (if (not dir)
            (let ((world (new-world)))
              (display-error~ world (format "Unable to find world: {s}" start-world)))
          (let ((start-zone (find-setting 'world.start-zone #f)))
            (open-world (new-file~ dir (format "_{a}.world" start-world)) start-zone: start-zone)))))))


(definition public (find-world name)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (info)
                  (bind (world-name . world-dir) info
                    (when (filename=? world-name name)
                      (continuation-return return world-dir))))
                (world-directories))
      (for-each (lambda (worlds-dir)
                  (for-each (lambda (world-dir)
                              (when (filename=? (get-base~ world-dir) name)
                                (continuation-return return world-dir)))
                            (collect-directories~ worlds-dir)))
                (worlds-directories))
      #f)))


(definition public (world-directories)
  (find-setting 'world.world-directories '()))


(definition public (worlds-directories)
  (let ((directories (find-setting 'world.worlds-directories (unspecified))))
    (if (specified? directories)
        directories
      (let ((queue (new-queue)))
        (define (add-if-exists dir)
          (when (exists?~ dir)
            (enqueue queue dir)
            #t))
        
        (add-if-exists {Directory Settings "worlds"})
        (or (add-if-exists (new-brother~ (world-directory '()) "worlds"))
            (add-if-exists {Directory Home "worlds"}))
        
        (queue-list queue)))))


;;;
;;;; World
;;;


(definition public (new-world)
  (let ((model 'World)
        (units '(world.data)))
    (let ((tag (string->symbol (format "<{a}>" model)))
          (data (new Data world-version 'jazz units #f)))
      (let ((form (construct-form (list tag) (imports-locator units) data)))
        (make-world form)))))


(definition public (open-world file (start-zone: start-zone #f))
  (define (load-settings)
    (let ((file (new-brother~ file ".settings")))
      (when (exists?~ file)
        (new File-Settings file: file))))
  
  (let ((settings (load-settings))
        (form (convert-world (read-form file))))
    (load-point 'world-form)
    (make-world form settings: settings start-zone: start-zone)))


(definition public (open-world/zone start-world start-zone)
  (let ((dir (find-world start-world)))
    (open-world (new-file~ dir (format "_{a}.world" start-world)) start-zone: start-zone)))


(definition public (make-world form (settings: settings #f) (start-zone: start-zone #f))
  (let ((current (current-world+))
        (world (instantiate~ form)))
    (load-point 'world-instantiate)
    (when current
      (close~ current))
    (when settings
      (set-newable?~ world (get-setting~ settings 'world.newable? #f))
      (set-writable?~ world (get-setting~ settings 'world.writable? #f)))
    (unless (get-title~ world)
      (let ((origin (get-origin~ form)))
        (when origin
          (set-title~ world (get-name~ (get-parent~ origin))))))
    (set-designer~ world (new Designer form: form reference: world))
    (set-window~ world (current-world-window))
    (setup-world~ world)
    (setup-opengl~ world)
    (resize-scene~ world)
    (initialize-world~ world)
    (load-point 'world-initialize)
    (let ((start-zone (and (not (find-setting 'world.start-new? #f))
                           (or start-zone
                               (find-setting 'world.start-zone #f)
                               (let ((start-zones (find-setting 'world.start-zones #f)))
                                 (and start-zones
                                      (let ((pair (assoc (get-title~ world) start-zones)))
                                        (and pair
                                             (cdr pair)))))
                               (get-start-zone~ world)))))
      (if (not start-zone)
          (new-zone)
        (open-zone (new-file~ (get-parent~ (get-moniker~ world)) (list "zones" (format "{a}.zone" start-zone))))))
    (load-point 'world-ready)
    (delay-event
      (lambda ()
        (gc)
        (reset-last-tick~ world)
        (set-render-ready?~ world #t)
        (start-world~ world)))
    world))


(definition (convert-world form)
  (define (convert->1.1 form)
    (set-version~ (get-data~ form) {Version 1 1})
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.1 form))
          ((nu=? version {Version 1 1})
           form)
          (else
           (error "Unsupported world version: {a}" (present-string~ version))))))


;;;
;;;; Zone
;;;


(definition public (new-zone)
  (let ((model 'Zone)
        (units '(world.data)))
    (let ((tag (string->symbol (format "<{a}>" model)))
          (data (new Data zone-version 'jazz units #f)))
      (let ((form (construct-form (list tag) (imports-locator units) data)))
        (make-zone form)))))


(definition public (open-zone file)
  (let ((form (convert-zone (read-form file))))
    (load-point 'zone-form)
    (make-zone form)))


(definition public (make-zone form)
  (let ((world (current-world)))
    (let ((current (current-zone+))
          (zone (instantiate~ form)))
      (load-point 'zone-instantiate)
      (when current
        (close~ current)
        (reset-eye-sectors~ current)
        (reset-camera~ world))
      (set-target~ world #f)
      (unless (get-title~ zone)
        (let ((origin (get-origin~ form)))
          (when origin
            (set-title~ zone (get-base~ origin)))))
      (set-designer~ zone (new Designer form: form reference: zone))
      (initialize-zone~ zone)
      (load-point 'zone-initialize)
      (update-children~ zone)
      (zone-update~ world)
      (update-title~ world)
      (when (get-sun-cycle?~ zone)
        (position-sun~ zone -.20))
      (populate-zone~ zone)
      (let ((script (get-start-script~ zone)))
        (when script
          (execute-script~ world script)))
      (load-point 'zone-ready)
      zone)))


(definition (convert-zone form)
  (define (convert->1.1 form)
    (define (convert-children form)
      (for-each convert (get-children~ form)))
    
    (define (convert form)
      (let ((x (get-property~ form x:)))
        (when x
          (let ((y (get-property~ form y:))
                (z (get-property~ form z:)))
            (remove-property~ form x:)
            (remove-property~ form y:)
            (remove-property~ form z:)
            (set-property~ form position: (vertex x y z)))))
      (let ((width (get-property~ form width:)))
        (when width
          (let ((height (get-property~ form height:))
                (depth (get-property~ form depth:)))
            (remove-property~ form width:)
            (remove-property~ form height:)
            (remove-property~ form depth:)
            (set-property~ form size: (vertex width height depth)))))
      (let ((color (get-property~ form color:)))
        (when color
          (set-property~ form color: (color->dye color))))
      (convert-children form))
    
    (set-version~ (get-data~ form) {Version 1 1})
    (convert-children form)
    form)
  
  (define (convert->1.2 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (scale-down form position:)
      (scale-down form radiuses:)
      (scale-down form radius:)
      (scale-down form v1:)
      (scale-down form v2:)
      (scale-down form v3:)
      (scale-down form v4:))
    
    (define (scale-down form property)
      (let ((value (get-property~ form property)))
        (when value
          (set-property~ form property (if (f32vector? value)
                                           (f32vertex-scalar/ value 5.)
                                         (/ value 5.))))))
    
    (define (f32vertex-scalar/ v <f64vector> r <fl>) <f64vector>
      (f32vector
        (/ (f32vector-ref v 0) r)
        (/ (f32vector-ref v 1) r)
        (/ (f32vector-ref v 2) r)))
    
    (set-version~ (get-data~ form) {Version 1 2})
    (scale-down form start-eye:)
    (scale-down form start-position:)
    (convert-children form)
    form)
  
  (define (convert->1.3 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (convert form position:)
      (convert form radiuses:)
      (convert form radius:)
      (convert form v1:)
      (convert form v2:)
      (convert form v3:)
      (convert form v4:))
    
    (define (convert form property)
      (let ((value (get-property~ form property)))
        (when (f32vector? value)
          (let ((len (f32vector-length value)))
            (let ((converted (make-f64vector len)))
              (for (i 0 len)
                   (f64vector-set! converted i (f32vector-ref value i)))
              (set-property~ form property converted))))))
    
    (set-version~ (get-data~ form) {Version 1 3})
    (convert form start-eye:)
    (convert form start-eye-sight:)
    (convert form start-eye-up:)
    (convert form start-position:)
    (convert form start-sight:)
    (convert form start-up:)
    (convert-children form)
    form)
  
  (define (convert->1.4 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (let ((value (get-property~ form scale:)))
        (when (flonum? value)
          (set-property~ form scale: (vertex value value value)))))
    
    (set-version~ (get-data~ form) {Version 1 4})
    (convert-children form)
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.4 (convert->1.3 (convert->1.2 (convert->1.1 form)))))
          ((nu=? version {Version 1 1})
           (convert->1.4 (convert->1.3 (convert->1.2 form))))
          ((nu=? version {Version 1 2})
           (convert->1.4 (convert->1.3 form)))
          ((nu=? version {Version 1 3})
           (convert->1.4 form))
          ((nu=? version {Version 1 4})
           form)
          (else
           (error "Unsupported zone version: {a}" (present-string~ version)))))))
