;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World I/O
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.io jazz


(import (jazz.application)
        (jazz.component)
        (jazz.debuggee)
        (jazz.io)
        (jazz.markup)
        (jazz.network)
        (jazz.process)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (jazz.syntax (phase syntax))
        (jazz.version)
        (jazz.view)
        (world)
        (world.assets)
        (world.autoload)
        (world.client)
        (world.context)
        (world.dye)
        (world.geometry)
        (world.master)
        (world.settings)
        (world.task))


(definition protected boot-restart
  (make-parameter #f))


(definition public (booting thunk)
  (with-task-mutex
    (lambda ()
      (continuation-capture
        (lambda (restart)
          (parameterize ((boot-restart restart))
            (thunk)))))))


;;;
;;;; World
;;;


(definition *world-directory*
  #f)

(definition public (get-world-directory)
  *world-directory*)

(definition public (set-world-directory dir)
  (set! *world-directory* dir))


(definition world-finder
  #f)

(definition public (get-world-finder)
  world-finder)

(definition public (set-world-finder finder)
  (set! world-finder finder))


(definition public (register-world)
  (let ((world (world-finder)))
    (register-alias 'Application-World (get-list world))
    (set-world-directory {Directory Application-World})))


(definition public (open-world)
  (load-point 'world)
  (let ((world (new World)))
    (setup-opengl world)
    (resize-scene world)
    (initialize-world world)
    (load-point 'world-ready)
    world))


(definition public (close-world)
  (let ((world (current-world+)))
    (when world
      (close world))))


(definition protected event-restart
  (make-parameter #f))


(definition protected (world-loop done?)
  (define (thread-process-delayed-events)
    (declare (proper-tail-calls))
    (let ((thunk (read-delayed-event)))
      (when (not (eof-object? thunk))
        (thunk)
        (thread-process-delayed-events))))
  
  (declare (proper-tail-calls))
  (setup-threads)
  (let (loop)
    (continuation-capture
      (lambda (restart)
        (parameterize ((event-restart restart))
          (let ((thunk (thread-read-message timeout: +infinity)))
            (site (delayed on?: #f parent: event)
              (thread-process-delayed-events))
            (site (event on?: #t)
              (when (not (eof-object? thunk))
                (thunk)))))))
    (unless (and done? (done?))
      (loop))))


(definition protected (world-products)
  (let ((world (current-world+)))
    (if (not world)
        '()
      '()
      @cant-find-get-installed-modules
      (let ((queue (new-queue)))
        (iterate-table (get-installed-modules world)
          (lambda (name info)
            (bind (dirname . repository) info
              (for-each (lambda (package)
                          (for-each (lambda (product)
                                      (let ((name (product-descriptor-name product)))
                                        (enqueue queue name)))
                                    (package-products package)))
                        (repository-packages repository)))))
        (queue-list queue)))))


(definition protected (world-properties kind)
  (list kind: kind))


(definition protected (quit-world)
  (define (save-settings)
    (let ((zone (current-zone)))
      (let ((path (if (welcome? zone)
                      #f
                    (zone-path zone tier-kind))))
        (set-setting options-settings 'world.last-zone path)
        (save-content options-settings))))
  
  @broken (save-settings)
  (close-zone)
  (close-world))


;;;
;;;; Tier
;;;


(definition public (get-tiers-directory kind)
  (case kind
    ((standalone local) {Directory Settings "servers" "Local" "zones"})
    ((client) {Directory Settings "clients"})
    ((server) {Directory Settings "servers"})))


(definition public (find-tier name kind)
  (let ((directory (get-tiers-directory kind)))
    (continuation-capture
      (lambda (return)
        (when (exists? directory)
          (iterate-directory directory
            (lambda (path path-kind)
              (let ((dir (new-directory directory path)))
                (let ((file (tier-file dir kind)))
                  (when (and (exists? file)
                             (filename=? (filename-spine (join path "/")) name))
                    (continuation-return return file)))))
            full?: #f
            files?: #f
            directories?: #t))
        #f))))


(definition protected (tier-name file)
  (get-name (get-parent file)))


(definition protected (tier-file dir kind)
  (new-file dir (case kind
                   ((standalone) ".zone")
                   ((client) ".client")
                   ((server) ".server"))))


;;;
;;;; Standalone
;;;


(definition public (open-standalone file)
  (let ((dir {Directory Settings "servers" "Local"}))
    (let ((tier (new Standalone-Tier dir)))
      (close-zone)
      (startup tier)
      (set-tier-kind 'standalone)
      (set-current-tier tier)
      (open-zone file scripts?: #f))))


;;;
;;;; Local
;;;


(definition protected local-server
  #f)

(definition protected (set-local-server server)
  (set! local-server server))


(definition (spawn-server server)
  (start-remote-presence)
  (prog1 (spawn-slave "server" (get-server-filename)
           (lambda (master slave cookie)
             )
           (lambda (master slave cookie)
             slave)
           arguments: `("-server" ,server "-panel" "false")
           debug?: (world-setting 'world.server-debug? #t)
           manual?: (world-setting 'world.server-manual? #f)
           wait?: #t)
    (load-point 'spawn-server)))


(definition public (open-local file (scripts?: scripts? #t))
  (when (not local-server)
    (let ((server (spawn-server "Local")))
      (set! local-server server)))
  (let ((zone (cons 'zone (butlast (subpath {Directory Settings "servers" "Local" "zones"} file)))))
    (set-client-configuration (new Client character-name: "Client" character-avatar: "character/nightelffemale" character-zone: zone)))
  (open-client {File Settings "clients" "Local" ".client"} #t))


(definition public (open-admin file (scripts?: scripts? #t))
  (let ((path (subpath {Directory Settings "servers"} (get-parent file))))
    (when (not local-server)
      (let ((server (spawn-server (join path "/"))))
        (set! local-server server)))
    (set-client-configuration (new Client character-name: "Client" character-avatar: "character/nightelffemale" character-zone: 'start))
    (open-client (new-file (new-directory {Directory Settings "clients"} path) ".client") #t)))


;;;
;;;; Client
;;;


(definition public (open-client-safe (start-zone: start-zone #f))
  (define (open-safe name (local? #f))
    (define (open)
      (let ((file (if local?
                      (new-file {Directory Settings "servers" "Local" "zones"} (append (tokenise-filename name) (list ".zone")))
                    (find-tier name 'client))))
        (if file
            (if local?
                (open-local file)
              (let ((obj (open-client file)))
                (if (is? obj Zone)
                    obj
                  (report (if (string? obj)
                              obj
                            "Unable to connect to server")))))
          (report (format "Unable to find client: {a}" name)))))
    
    (define (report exception-message)
      (cond ((using-debugger?)
             (error "{a}" exception-message))
            ((not (window?))
             (snapshot-process exception: (new Error message: exception-message))
             (quit))
            (else
             (let ((welcome (open-welcome-zone)))
               (report-exception welcome exception-message #f)
               welcome))))
    
    (if (and (window?) (process-copyright-changed? (current-application)))
        (let ((zone (open-welcome-zone)))
          (set-post-accept zone open))
      (open)))
  
  (unless (eq? start-zone 'none)
    (let ((client (command-argument "client")))
      (if client
          (open-safe client)
        (let ((name (or start-zone (command-argument "local") @broken (world-setting 'world.last-zone #f))))
          (if name
              (open-safe name #t)
            (open-welcome-zone)))))
    (load-point 'tier-ready)))


(definition public (open-client client-file (local? #f))
  (define (problem? obj)
    (or (connection-exception? obj)
        (string? obj)))
  
  (define (open)
    (set-local? local?)
    (let ((dir (get-parent client-file)))
      (let ((tier (new Client-Tier dir)))
        (close-zone)
        (startup tier)
        (let ((file (zone-file dir 'client))
              (form (get-form tier)))
          (set-origin form file)
          (set-tier-kind 'client)
          (set-current-tier tier)
          (start-to-server tier)
          (open-zone file form: form)))))
  
  (catch (problem? obj
           obj)
    (open)))


;;;
;;;; Server
;;;


(definition public (open-server server-file)
  (set-local? slave?)
  (let ((dir (get-parent server-file)))
    (let ((tier (new Server-Tier dir)))
      (startup tier)
      (let ((file (zone-file dir 'server)))
        (set-tier-kind 'server)
        (set-current-tier tier)))))


;;;
;;;; Processor
;;;


(definition public (open-processor)
  (let ((tier (current-tier)))
    (let ((server-path (get-server-path tier))
          (zone (get-zone tier)))
      (let ((server-dir (new-directory {Directory Settings "servers"} server-path)))
        (let ((dir (if (eq? zone 'start)
                       (new-directory server-dir `("start"))
                     (case (car zone)
                       ((instance)
                        (new-directory server-dir `("instances" ,(cadr zone))))
                       (else
                        (new-directory server-dir `("zones" ,@(cdr zone))))))))
          (setup tier dir)
          (let ((zone (zone-file dir 'processor)))
            (startup tier)
            (open-zone zone)))))))


;;;
;;;; Zone
;;;


(definition public (open-zone file (form: form #f) (scripts?: scripts? #t))
  (close-all-popups)
  (let ((form (or form (convert-zone (read-form file)))))
    (load-point 'zone-form)
    (make-zone file form scripts?)))


(definition public (make-zone file form scripts?)
  (let ((world (current-world)))
    (let ((dir (get-parent file)))
      (prepare-zone-assets world dir)
      (prepare-template-assets world dir)
      (prepare-modules world))
    (let ((zone (instantiate form)))
      (load-point 'zone-instantiate)
      (unless (get-title zone)
        (set-title zone (zone-name (get-moniker zone) tier-kind)))
      (set-designer zone (new Former form: form reference: zone))
      (initialize-zone zone)
      (load-point 'zone-initialize)
      (when scripts?
        (let ((script (get-prepare-script zone)))
          (when script
            (launch-event world script))))
      (zone-update world)
      (player-update zone)
      (update-title zone)
      (when (get-sun-cycle? zone)
        (position-sun zone #f angle: (get-sun-angle zone)))
      (populate-zone zone)
      (setup-lighting zone)
      (prepare-motion world)
      (when scripts?
        (let ((script (get-enter-script zone)))
          (when script
            (launch-event world script))))
      (let ((appl (current-application))
            (dir (get-directory zone)))
        (unless (or (admin?)
                    (not (window?))
                    (member? (get-name dir) '("welcome" "tutorial") test: filename=?))
          (check-news appl)))
      (zone-ready zone)
      (load-point 'zone-ready)
      (start-tasks zone)
      (init-stable (get-eye world))
      (init-stable (get-history-camera world))
      (set-ready? zone #t)
      (reset-shutdown)
      zone)))


(definition (close-zone)
  (let ((zone (current-zone+)))
    (when zone
      (close zone)
      (let ((tier (current-tier+)))
        (when tier
          (shutdown tier)))
      (set-tier-kind #f)
      (set-current-tier #f))))


(definition public (find-zone name kind)
  (let ((directory (get-tiers-directory kind)))
    (continuation-capture
      (lambda (return)
        (when (exists? directory)
          (iterate-directory directory
            (lambda (path path-kind)
              (let ((dir (new-directory directory path)))
                (let ((file (zone-file dir kind)))
                  (when (and (exists? file)
                             (filename=? (filename-spine (join path "/")) name))
                    (continuation-return return file)))))
            full?: #f
            files?: #f
            directories?: #t))
        #f))))


(definition protected (zone-file dir kind)
  (new-file dir (if (or (eq? kind 'standalone)
                        (eq? kind 'processor))
                    ".zone"
                  '("start" ".zone"))))


(definition protected (zone-name moniker kind)
  (get-name (if (or (eq? kind 'standalone)
                     (eq? kind 'processor))
                 (get-parent moniker)
               (get-parent (get-parent moniker)))))


(definition protected (new-zone-file base kind)
  (let ((directory (get-tiers-directory kind))
        (path (split base "/")))
    (zone-file (new-directory directory path) kind)))


;;;
;;;; Template
;;;


(definition protected welcome-zone-open
  #f)

(definition protected (welcome-zone-open-set! open)
  (set! welcome-zone-open open))


(definition public (open-welcome-zone)
  (if welcome-zone-open
      (welcome-zone-open)
    (open-standalone (find-tier (copy-zone-template "welcome" 'standalone) 'standalone))))


(definition public (open-tutorial-zone (force-copy?: force-copy? #f) (scripts?: scripts? #t))
  (open-standalone (find-tier (copy-zone-template "tutorial" 'standalone force-copy?: force-copy?) 'standalone)))


(definition public (copy-zone-template name kind (force-copy?: force-copy? #f))
  (let ((from-dir (new-directory (new-directory (get-world-directory) "templates") name))
        (to-dir (get-parent (new-zone-file name kind))))
    (when (or force-copy? (not (exists? to-dir)))
      (duplicate from-dir to-dir))
    name))


(definition public (tutorial-template?)
  (let ((zone (current-zone)))
    (equal? (zone-path zone 'standalone) "tutorial")))


(definition package (get-templates-directories)
  (let ((world-directory (get-world-directory)))
    (if world-directory
        (list (new-directory world-directory "templates"))
      '())))


(definition package (collect-templates)
  (let ((templates-directories (get-templates-directories))
        (queue (new-queue)))
    (for-each  (lambda (directory)
                 (when (exists? directory)
                   (iterate-directory directory
                     (lambda (path kind)
                       (unless (or (filename=? (car path) "welcome")
                                   (filename=? (car path) "tutorial"))
                         (let ((file (new-file directory path)))
                           (when (extension=? (get-extension file) "zone")
                             (enqueue queue (cons (butlast path) file))))))
                     full?: #f
                     files?: #t
                     directories?: #f)))
               templates-directories)
    (queue-list queue)))


(definition package (unique-zone-base from)
  (let ((from-base (get-name (get-parent from))))
    (let (iter (id #f))
      ;; no space between base and id until gambit bug fixed
      (let ((base (if (not id) from-base (format "{a}{a}" from-base id))))
        (if (exists? (new-zone-file base 'standalone))
            (iter (+ (or id 1) 1))
          base)))))


(definition package (zone-base-available? base (kind #f))
  (not (exists? (new-zone-file base (or kind 'standalone)))))


(definition package (create-new-zone from base (kind: kind #f) (replace?: replace? #f) (create: create #f) (open: open open-local))
  (let ((to (new-zone-file base (or kind 'standalone))))
    (let ((from-dir (get-parent from))
          (to-dir (get-parent to)))
      (and (or (not (exists? to-dir))
               (and replace? (begin
                               (delete to-dir)
                               #t)))
           (begin
             (duplicate from-dir to-dir)
             (call-with-output-file (path-settings (new-file to-dir ".instance"))
               (lambda (output)
                 (format output ";;;========={%}")
                 (format output ";;;  World{%}")
                 (format output ";;;========={%}")
                 (format output ";;;{%}")
                 (format output ";;;; Instance{%}")
                 (format output ";;;{%}")
                 (format output "{%}")
                 (format output "{%}")
                 (format output "(data jazz{%}")
                 (format output "{%}")
                 (format output "{%}")
                 (format output "(version {a}){%}" (present-string zone-version))
                 (format output "(import world.instance){%}")
                 (format output "{%}")
                 (format output "{%}")
                 (format output "(form{%}")
                 (format output "  (<Instance> template: {s}))){%}" (subpath {Directory Application-World "templates"} from-dir))))
             (when create
               (create to-dir))
             (let ((zone (open to)))
               (when zone
                 (save-zone zone)
                 (save-designer zone)))
             #t)))))


;;;
;;;; Create
;;;


(definition public common-names
  '("Emma" "Lea" "Olivia" "Alice" "Florence" "Zoe" "Chloe" "Beatrice" "Charlotte" "Rosalie" "Eva" "Juliette" "Sofia" "Jade" "Camille" "Victoria" "Mia" "Charlie" "Romy" "Laurence" "Maeva" "Alicia" "Clara" "Annabelle" "Sarah" "Rose" "Raphaelle" "Livia" "Elizabeth" "Mila" "Anais" "Elodie" "Flavie" "Laurie" "Amelia" "Julia" "Leonie" "Maelie" "Gabrielle" "Sophia" "Adele" "Coralie" "Emy" "Noemie" "Aurelie" "Alexia" "Jeanne" "Emilie" "Eve" "Ophelie" "Thomas" "William" "Jacob" "Liam" "Felix" "Nathan" "Samuel" "Logan" "Alexis" "Noah" "Olivier" "Raphael" "Gabriel" "Emile" "Leo" "Charles" "Antoine" "Benjamin" "Adam" "Edouard" "Xavier" "Victor" "Zack" "Mathis" "Jayden" "Theo" "Elliot" "Zachary" "Louis" "James" "Anthony" "Alexandre" "Lucas" "Justin" "Arthur" "Tristan" "Loic" "Ethan" "Henri" "Nolan" "Nicolas" "Arnaud" "Jeremy" "Hugo" "Dylan" "Laurent" "Eli" "Vincent" "Isaac" "Etienne"))


(definition protected (create-client-file client-name server-address server-port name avatar (script #f))
  (let ((dir (new-directory {Directory Settings "clients"} client-name)))
    (create-directories dir)
    (let ((client-file (new-file dir ".client")))
      (call-with-output-file (path-settings client-file)
        (lambda (output)
          (format output ";;;========={%}")
          (format output ";;;  World{%}")
          (format output ";;;========={%}")
          (format output ";;;{%}")
          (format output ";;;; Client{%}")
          (format output ";;;{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(data jazz{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(version {a}){%}" (present-string zone-version))
          (format output "(import world.client){%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(form{%}")
          (format output "  (<Client> server-host: {s} server-service: {s} character-name: {s} character-avatar: {s}"
            (string->host server-address)
            (string->port server-port)
            name
            avatar)
          (when script
            (format output " character-script: {s}" script))
          (format output "))){%}")))
      client-file)))


(definition protected (create-client-files client-prefix count server-address server-port (script #f))
  (let ((avatars (remove "character/dwarfmale" (world.interface.avatars:collect-avatar-models) test: equal?)))
    (loop (for n from 1 to count)
          (let ((client-name (format "{a}{a}" client-prefix n))
                (name (random-element common-names))
                (avatar (random-element avatars))
                (script (or script "bot/player")))
            (let ((fullname (format "{a} ({a})" name client-name)))
              (create-client-file client-name server-address server-port fullname avatar script))))))


(definition public (create-server-file server-name server-address server-port name avatar)
  (let ((dir (new-directory {Directory Settings "servers"} server-name)))
    (create-directories dir)
    (let ((server-file (new-file dir ".server")))
      (call-with-output-file (path-settings server-file)
        (lambda (output)
          (format output ";;;========={%}")
          (format output ";;;  World{%}")
          (format output ";;;========={%}")
          (format output ";;;{%}")
          (format output ";;;; Server{%}")
          (format output ";;;{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(data jazz{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(version {a}){%}" (present-string zone-version))
          (format output "(import world.server){%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(form{%}")
          (format output "  (<Server> host: {s} service: {s} character-name: {s} character-avatar: {s}))){%}"
            (string->host server-address)
            (string->port server-port)
            name
            avatar)))
      server-file)))


;;;
;;;; Convert
;;;


(definition (convert-world form)
  (define (convert->1.1 form)
    (set-version (get-data form) {Version 1 1})
    form)
  
  (let ((version (or (get-version (get-data form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.1 form))
          ((nu=? version {Version 1 1})
           form)
          (else
           (error "Unsupported world version: {a}" (present-string version))))))


(definition (convert-zone form)
  (define (convert->1.1 form)
    (define (convert-children form)
      (for-each convert (get-children form)))
    
    (define (convert form)
      (let ((x (get-property form x:)))
        (when x
          (let ((y (get-property form y:))
                (z (get-property form z:)))
            (remove-property form x:)
            (remove-property form y:)
            (remove-property form z:)
            (set-property form position: (vertex x y z)))))
      (let ((width (get-property form width:)))
        (when width
          (let ((height (get-property form height:))
                (depth (get-property form depth:)))
            (remove-property form width:)
            (remove-property form height:)
            (remove-property form depth:)
            (set-property form size: (vertex width height depth)))))
      (let ((color (get-property form color:)))
        (when color
          (set-property form color: (color->dye color))))
      (convert-children form))
    
    (set-version (get-data form) {Version 1 1})
    (convert-children form)
    form)
  
  (define (convert->1.2 form)
    (define (convert-children form)
      (for-each convert-child (get-children form)))
    
    (define (convert-child form)
      (scale-down form position:)
      (scale-down form radiuses:)
      (scale-down form radius:)
      (scale-down form v1:)
      (scale-down form v2:)
      (scale-down form v3:)
      (scale-down form v4:))
    
    (define (scale-down form property)
      (let ((value (get-property form property)))
        (when value
          (set-property form property (if (f32vector? value)
                                           (f32vertex-scalar/ value 5.)
                                         (/ value 5.))))))
    
    (define (f32vertex-scalar/ v <f32vector> r <fl>) <f32vector>
      (f32vector
        (/ (f32vector-ref v 0) r)
        (/ (f32vector-ref v 1) r)
        (/ (f32vector-ref v 2) r)))
    
    (set-version (get-data form) {Version 1 2})
    (scale-down form start-eye:)
    (scale-down form start-position:)
    (convert-children form)
    form)
  
  (define (convert->1.3 form)
    (define (convert-children form)
      (for-each convert-child (get-children form)))
    
    (define (convert-child form)
      (convert form position:)
      (convert form radiuses:)
      (convert form radius:)
      (convert form v1:)
      (convert form v2:)
      (convert form v3:)
      (convert form v4:))
    
    (define (convert form property)
      (let ((value (get-property form property)))
        (when (f32vector? value)
          (let ((len (f32vector-length value)))
            (let ((converted (make-f64vector len)))
              (loop (for i from 0 below len)
                    (f64vector-set! converted i (f32vector-ref value i)))
              (set-property form property converted))))))
    
    (set-version (get-data form) {Version 1 3})
    (convert form start-eye:)
    (convert form start-eye-sight:)
    (convert form start-eye-up:)
    (convert form start-position:)
    (convert form start-sight:)
    (convert form start-up:)
    (convert-children form)
    form)
  
  (define (convert->1.4 form)
    (define (convert-children form)
      (for-each convert-child (get-children form)))
    
    (define (convert-child form)
      (let ((value (get-property form scale:)))
        (when (flonum? value)
          (set-property form scale: (vertex value value value)))))
    
    (set-version (get-data form) {Version 1 4})
    (convert-children form)
    form)
  
  (let ((version (or (get-version (get-data form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.4 (convert->1.3 (convert->1.2 (convert->1.1 form)))))
          ((nu=? version {Version 1 1})
           (convert->1.4 (convert->1.3 (convert->1.2 form))))
          ((nu=? version {Version 1 2})
           (convert->1.4 (convert->1.3 form)))
          ((nu=? version {Version 1 3})
           (convert->1.4 form))
          ((nu=? version {Version 1 4})
           form)
          (else
           (error "Unsupported zone version: {a}" (present-string version)))))))
