;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World I/O
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.io jazz


(import (jazz.application)
        (jazz.component)
        (jazz.io)
        (jazz.jrm.protocol)
        (jazz.process)
        (jazz.syntax (phase syntax))
        (jazz.version)
        (jazz.view)
        (world)
        (world.assets)
        (world.autoload)
        (world.dye)
        (world.geometry)
        (world.id)
        (world.processor)
        (world.settings)
        (world.syntax (phase syntax))
        (world.tier)
        (world.window))


;;;
;;;; Default
;;;


(definition *world-directories*
  '())

(definition public (world-directories)
  *world-directories*)

(definition public (set-world-directories directories)
  (set! *world-directories* directories))


(definition public (find-world name)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (info)
                  (bind (world-name . world-dir) info
                    (when (filename=? world-name name)
                      (continuation-return return world-dir))))
                (world-directories))
      #f)))


;;;
;;;; World
;;;


(definition public (open-world file (start-zone: start-zone #f))
  (let ((form (convert-world (read-form file))))
    (load-point 'world-form)
    (make-world form start-zone: start-zone)))


(definition public (open-world/zone start-world start-zone)
  (let ((dir (find-world start-world)))
    (open-world (new-file~ dir ".world") start-zone: start-zone)))


(definition public (make-world form (start-zone: start-zone #f))
  (close-world)
  (let ((world (instantiate~ form)))
    (define (open-safe name kind)
      (define (open)
        (let ((file (find-tier name kind)))
          (if file
              (case kind
                ((local) (open-local file))
                ((client) (open-client file))
                ((server) (open-server file)))
            (let ((exception-message (format "Unable to find {a}: {a}" (or kind 'zone) name)))
              ;; quick robustness test
              (if (eq? kind 'server)
                  (begin
                    (terminal exception-message)
                    (exit))
                (let ((welcome (open-welcome-zone)))
                  (report-exception~ welcome exception-message #f)
                  welcome))))))
      
      (if (process-copyright-changed?~ (get-process))
          (let ((zone (open-welcome-zone)))
            (set-post-accept~ zone open))
        (open)))
    
    (load-point 'world-instantiate)
    (unless (get-title~ world)
      (let ((origin (get-origin~ form)))
        (when origin
          (set-title~ world (get-name~ (get-parent~ origin))))))
    (set-designer~ world (new Former form: form reference: world))
    (set-window~ world (current-world-window))
    (setup-opengl~ world)
    (resize-scene~ world)
    (initialize-world~ world)
    (load-point 'world-initialize)
    (let ((last (world-setting 'world.last-zone #f))
          (zone-arg (command-argument "zone"))
          (client-arg (command-argument "client"))
          (server-arg (command-argument "server"))
          (processor-arg (command-argument "processor")))
      (cond (start-zone
             (open-safe start-zone 'local))
            (zone-arg
             (open-safe zone-arg 'local))
            (client-arg
             (open-safe client-arg 'client))
            (server-arg
             (open-safe server-arg 'server))
            (processor-arg
             (open-processor))
            (last
             (open-safe last 'local))
            (else
             (open-welcome-zone))))
    (update-title~ world)
    (load-point 'world-ready)
    world))


(definition public (close-world)
  (let ((world (current-world+)))
    (when world
      (close~ world))))


(definition protected (world-loop done?)
  (define (thread-process-delayed-events)
    (declare (proper-tail-calls))
    (let ((thunk (read-delayed-event)))
      (when (not (eof-object? thunk))
        (thunk)
        (thread-process-delayed-events))))
  
  (declare (proper-tail-calls))
  (setup-threads~ (current-world))
  (let (loop)
    (let ((thunk (thread-read-message timeout: +infinity)))
      (site (delayed on?: #f parent: event)
        (thread-process-delayed-events))
      (site (event on?: #t)
        (when (not (eof-object? thunk))
          (thunk))))
    (unless (and done? (done?))
      (loop))))


(definition protected (world-products)
  (let ((world (current-world+)))
    (if (not world)
        '()
      (let ((queue (new-queue)))
        (iterate-table (get-installed-modules~ world)
          (lambda (name info)
            (bind (dirname . repository) info
              (for-each (lambda (package)
                          (for-each (lambda (product)
                                      (let ((name (product-descriptor-name product)))
                                        (enqueue queue name)))
                                    (package-products package)))
                        (repository-packages repository)))))
        (queue-list queue)))))


(definition protected (world-properties kind)
  (list kind: kind))


(definition protected (quit-world)
  (define (save-settings)
    (let ((zone (current-zone)))
      (let ((path (and (eq? tier-kind 'local) (zone-path~ zone tier-kind))))
        (set-setting~ options-settings 'world.last-zone path)
        (save-content~ options-settings))))
  
  (save-settings)
  (close-zone)
  (close-world))


(definition (convert-world form)
  (define (convert->1.1 form)
    (set-version~ (get-data~ form) {Version 1 1})
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.1 form))
          ((nu=? version {Version 1 1})
           form)
          (else
           (error "Unsupported world version: {a}" (present-string~ version))))))


;;;
;;;; Tier
;;;


;; open test quick hack
(import (world.entity)
        (world.history))

(definition protected (setup-tier kind dir)
  ;; open test quick hacks
  (reset-literals)
  (reset-entities)
  
  (case kind
    ((local)
     (new Local-Tier dir))
    ((client)
     (new Client-Tier dir))
    ((server)
     (new Server-Tier dir))
    ((processor)
     (new Processor-Tier dir))))


(definition protected (shutdown-tier)
  (let ((tier (current-tier+)))
    (when tier
      (shutdown~ tier))))


;;;
;;;; Zone
;;;


(definition public (open-local file (start-script?: start-script? #t))
  (let ((dir {Directory Settings "local"}))
    (let ((tier (setup-tier 'local dir)))
      (close-zone)
      (set-tier-kind 'local)
      (set-current-tier tier)
      (open-zone file start-script?: start-script?))))


(definition public (open-client client-file (catch-problems? #f))
  (define (problem? obj)
    (or (connection-problem? obj)
        (string? obj)))
  
  (define (open)
    (let ((dir (get-parent~ client-file)))
      (let ((tier (setup-tier 'client dir)))
        (close-zone)
        (let ((file (zone-file dir 'client))
              (form (get-form~ tier)))
          (set-origin~ form file)
          (set-tier-kind 'client)
          (set-current-tier tier)
          (open-zone file form: form)))))
  
  (if catch-problems?
      (catch (problem? obj
               obj)
        (open))
    (open)))


(definition public (open-server server-file)
  (let ((dir (get-parent~ server-file)))
    (let ((tier (setup-tier 'server dir)))
      (close-zone)
      (let ((processor (new Processor)))
        (let ((file (zone-file dir 'server)))
          (set-tier-kind 'server)
          (set-current-tier tier)
          (set-current-processor processor)
          (open-zone file))))))


(definition public (open-processor)
  (let ((processor (current-processor)))
    (let ((server-name (get-server-name~ processor))
          (zone (get-zone~ processor)))
      (let ((server-dir (new-directory~ {Directory Settings "servers"} server-name)))
        (let ((file (case (car zone)
                      ((instance) (new-file~ server-dir `("instances" ,(cadr zone) ".zone")))
                      (else (new-file~ server-dir `("zones" ,@(cdr zone) ".zone"))))))
          (let ((dir (get-parent~ file)))
            (let ((tier (setup-tier 'processor dir))
                  (zone (zone-file dir 'processor)))
              (set-tier-kind 'processor)
              (set-current-tier tier)
              (open-zone zone))))))))


(definition public (open-zone file (form: form #f) (start-script?: start-script? #t))
  (close-all-popups)
  (let ((form (or form (convert-zone (read-form file)))))
    (load-point 'zone-form)
    (make-zone file form start-script?)))


(definition public (make-zone file form start-script?)
  (let ((world (current-world)))
    ;; done before instantiating to enable custom zone class
    (let ((dir (get-parent~ file)))
      (set-zone-assets~ world (gather-assets 'zone (new-directory~ dir "assets")))
      (prepare-modules~ world (new-file~ dir ".instance")))
    (let ((zone (instantiate~ form)))
      (load-point 'zone-instantiate)
      (unless (get-title~ zone)
        (set-title~ zone (zone-name (get-moniker~ zone) tier-kind)))
      (set-designer~ zone (new Former form: form reference: zone))
      (initialize-zone~ zone)
      (load-point 'zone-initialize)
      (let ((script (get-prepare-script~ zone)))
        (when script
          (execute-script~ world script)))
      (zone-update~ world)
      (player-update~ zone)
      (update-title~ world)
      (when (get-sun-cycle?~ zone)
        (position-sun~ zone #f angle: (get-sun-angle~ zone)))
      (populate-zone~ zone)
      (setup-lighting~ zone)
      (prepare-motion~ world)
      (when start-script?
        (let ((script (get-start-script~ zone)))
          (when script
            (execute-script~ world script))))
      (let ((appl (get-application))
            (dir (get-directory~ zone)))
        (unless (or (admin?)
                    (member? (get-name~ dir) '("welcome" "tutorial") test: filename=?))
          (check-news~ appl)))
      (zone-ready~ zone)
      (load-point 'zone-ready)
      (start-tasks~ zone)
      (init-stable~ (get-eye~ world))
      (init-stable~ (get-history-camera~ world))
      (set-ready?~ zone #t)
      zone)))


(definition (close-zone)
  (let ((zone (current-zone+)))
    (when zone
      (close~ zone)
      (shutdown-tier)
      (set-tier-kind #f)
      (set-current-tier #f))))


(definition public (find-tier name kind)
  (let ((world (current-world)))
    (let ((directory (get-tiers-directory~ world kind)))
      (continuation-capture
        (lambda (return)
          (when (exists?~ directory)
            (iterate-directory~ directory
              (lambda (path path-kind)
                (let ((dir (new-directory~ directory path)))
                  (let ((file (tier-file dir kind)))
                    (when (and (exists?~ file)
                               (filename=? (extract-spine (join path "/")) name))
                      (continuation-return return file)))))
              full?: #f
              files?: #f
              directories?: #t))
          #f)))))


(definition public (find-zone name kind)
  (let ((world (current-world)))
    (let ((directory (get-tiers-directory~ world kind)))
      (continuation-capture
        (lambda (return)
          (when (exists?~ directory)
            (iterate-directory~ directory
              (lambda (path path-kind)
                (let ((dir (new-directory~ directory path)))
                  (let ((file (zone-file dir kind)))
                    (when (and (exists?~ file)
                               (filename=? (extract-spine (join path "/")) name))
                      (continuation-return return file)))))
              full?: #f
              files?: #f
              directories?: #t))
          #f)))))


(definition protected (tier-name file)
  (get-name~ (get-parent~ file)))


(definition protected (tier-file dir kind)
  (new-file~ dir (case kind
                   ((local) ".zone")
                   ((client) ".client")
                   ((server) ".server"))))


(definition protected (zone-file dir kind)
  (new-file~ dir (if (or (eq? kind 'local)
                         (eq? kind 'processor))
                     ".zone"
                   '("start" ".zone"))))


(definition protected (zone-name moniker kind)
  (get-name~ (if (or (eq? kind 'local)
                     (eq? kind 'processor))
                 (get-parent~ moniker)
               (get-parent~ (get-parent~ moniker)))))


(definition protected (new-zone-file base kind)
  (let ((world (current-world)))
    (let ((directory (get-tiers-directory~ world kind))
          (path (split base "/")))
      (zone-file (new-directory~ directory path) kind))))


(definition public (open-welcome-zone)
  (open-local (find-tier (copy-zone-template "welcome" 'local force-copy?: #t) 'local)))


(definition public (open-tutorial-zone (force-copy?: force-copy? #f) (start-script?: start-script? #t))
  (open-local (find-tier (copy-zone-template "tutorial" 'local force-copy?: force-copy?) 'local) start-script?: start-script?))


(definition public (copy-zone-template name kind (force-copy?: force-copy? #f))
  (let ((world (current-world)))
    (let ((from-dir (new-directory~ (new-directory~ (get-world-directory~ world) "templates") name))
          (to-dir (get-parent~ (new-zone-file name kind))))
      (when (or force-copy? (not (exists?~ to-dir)))
        (copy-directory~ from-dir to-dir))
      name)))


(definition public (tutorial-template?)
  (let ((zone (current-zone)))
    (equal? (zone-path~ zone 'local) "tutorial")))


(definition (convert-zone form)
  (define (convert->1.1 form)
    (define (convert-children form)
      (for-each convert (get-children~ form)))
    
    (define (convert form)
      (let ((x (get-property~ form x:)))
        (when x
          (let ((y (get-property~ form y:))
                (z (get-property~ form z:)))
            (remove-property~ form x:)
            (remove-property~ form y:)
            (remove-property~ form z:)
            (set-property~ form position: (vertex x y z)))))
      (let ((width (get-property~ form width:)))
        (when width
          (let ((height (get-property~ form height:))
                (depth (get-property~ form depth:)))
            (remove-property~ form width:)
            (remove-property~ form height:)
            (remove-property~ form depth:)
            (set-property~ form size: (vertex width height depth)))))
      (let ((color (get-property~ form color:)))
        (when color
          (set-property~ form color: (color->dye color))))
      (convert-children form))
    
    (set-version~ (get-data~ form) {Version 1 1})
    (convert-children form)
    form)
  
  (define (convert->1.2 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (scale-down form position:)
      (scale-down form radiuses:)
      (scale-down form radius:)
      (scale-down form v1:)
      (scale-down form v2:)
      (scale-down form v3:)
      (scale-down form v4:))
    
    (define (scale-down form property)
      (let ((value (get-property~ form property)))
        (when value
          (set-property~ form property (if (f32vector? value)
                                           (f32vertex-scalar/ value 5.)
                                         (/ value 5.))))))
    
    (define (f32vertex-scalar/ v <f64vector> r <fl>) <f64vector>
      (f32vector
        (/ (f32vector-ref v 0) r)
        (/ (f32vector-ref v 1) r)
        (/ (f32vector-ref v 2) r)))
    
    (set-version~ (get-data~ form) {Version 1 2})
    (scale-down form start-eye:)
    (scale-down form start-position:)
    (convert-children form)
    form)
  
  (define (convert->1.3 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (convert form position:)
      (convert form radiuses:)
      (convert form radius:)
      (convert form v1:)
      (convert form v2:)
      (convert form v3:)
      (convert form v4:))
    
    (define (convert form property)
      (let ((value (get-property~ form property)))
        (when (f32vector? value)
          (let ((len (f32vector-length value)))
            (let ((converted (make-f64vector len)))
              (loop (for i from 0 below len)
                    (f64vector-set! converted i (f32vector-ref value i)))
              (set-property~ form property converted))))))
    
    (set-version~ (get-data~ form) {Version 1 3})
    (convert form start-eye:)
    (convert form start-eye-sight:)
    (convert form start-eye-up:)
    (convert form start-position:)
    (convert form start-sight:)
    (convert form start-up:)
    (convert-children form)
    form)
  
  (define (convert->1.4 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (let ((value (get-property~ form scale:)))
        (when (flonum? value)
          (set-property~ form scale: (vertex value value value)))))
    
    (set-version~ (get-data~ form) {Version 1 4})
    (convert-children form)
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.4 (convert->1.3 (convert->1.2 (convert->1.1 form)))))
          ((nu=? version {Version 1 1})
           (convert->1.4 (convert->1.3 (convert->1.2 form))))
          ((nu=? version {Version 1 2})
           (convert->1.4 (convert->1.3 form)))
          ((nu=? version {Version 1 3})
           (convert->1.4 form))
          ((nu=? version {Version 1 4})
           form)
          (else
           (error "Unsupported zone version: {a}" (present-string~ version)))))))
