;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World I/O
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.io jazz


(import (jazz.application)
        (jazz.component)
        (jazz.event)
        (jazz.io)
        (jazz.jml)
        (jazz.settings)
        (jazz.version)
        (jazz.view)
        (world)
        (world.autoload)
        (world.dye)
        (world.geometry)
        (world.settings)
        (world.syntax (phase syntax))
        (world.window))


;;;
;;;; Default
;;;


(definition public (select-default-world)
  (let ((start-world (world-setting 'world.start-world #f)))
    (if (not start-world)
        (new-world)
      (let ((dir (find-world start-world)))
        (if (not dir)
            (let ((world (new-world)))
              (display-error~ world (format "Unable to find world: {s}" start-world)))
          (open-world (new-file~ dir (format "_{a}.world" start-world))))))))


(definition public (find-world name)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (info)
                  (bind (world-name . world-dir) info
                    (when (filename=? world-name name)
                      (continuation-return return world-dir))))
                (world-directories))
      (for-each (lambda (worlds-dir)
                  (for-each (lambda (world-dir)
                              (when (filename=? (get-base~ world-dir) name)
                                (continuation-return return world-dir)))
                            (collect-directories~ worlds-dir)))
                (worlds-directories))
      #f)))


(definition public (world-directories)
  (world-setting 'world.world-directories '()))


(definition public (worlds-directories)
  (let ((directories (world-setting 'world.worlds-directories (unspecified))))
    (if (specified? directories)
        directories
      (let ((queue (new-queue)))
        (define (add-if-exists dir)
          (when (exists?~ dir)
            (enqueue queue dir)
            #t))
        
        (add-if-exists {Directory Settings "worlds"})
        (or (add-if-exists (new-brother~ (world-directory '()) "worlds"))
            (add-if-exists {Directory Home "worlds"}))
        
        (queue-list queue)))))


;;;
;;;; World
;;;


(definition public (new-world)
  (let ((model 'World)
        (units '(world.data)))
    (let ((tag (string->symbol (format "<{a}>" model)))
          (data (new Data world-version 'jazz units #f)))
      (let ((form (construct-form (list tag) (imports-locator units) data)))
        (make-world form)))))


(definition public (open-world file (start-zone: start-zone #f))
  (let ((form (convert-world (read-form file))))
    (load-point 'world-form)
    (make-world form start-zone: start-zone)))


(definition public (open-world/zone start-world start-zone)
  (let ((dir (find-world start-world)))
    (open-world (new-file~ dir (format "_{a}.world" start-world)) start-zone: start-zone)))


(definition public (make-world form (start-zone: start-zone #f))
  (define (open-existing zone)
    (open-zone (or (find-zone zone)
                   (error "Unable to find zone: {a}" zone))))
  
  (let ((current (current-world+))
        (world (instantiate~ form)))
    (load-point 'world-instantiate)
    (when current
      (close-world current))
    (unless (get-title~ world)
      (let ((origin (get-origin~ form)))
        (when origin
          (set-title~ world (get-name~ (get-parent~ origin))))))
    (set-designer~ world (new Former form: form reference: world))
    (set-window~ world (current-world-window))
    (setup-world~ world)
    (setup-opengl~ world)
    (resize-scene~ world)
    (initialize-world~ world)
    (load-point 'world-initialize)
    (let ((last (world-setting 'world.last-zone #f)))
      (if (eq? last 'new)
          (zone-instantiate~ world)
        (cond (start-zone
               (open-existing start-zone))
              ((and last (find-zone last))
               (open-existing last))
              ((get-start-zone~ world)
               => open-existing)
              (else
               (open-welcome-zone)))))
    (load-point 'world-ready)
    (delay-event
      (lambda ()
        (set-render-ready?~ world #t)
        (start-world~ world)))
    world))


(definition public (close-world world)
  (close~ world))


(definition (convert-world form)
  (define (convert->1.1 form)
    (set-version~ (get-data~ form) {Version 1 1})
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.1 form))
          ((nu=? version {Version 1 1})
           form)
          (else
           (error "Unsupported world version: {a}" (present-string~ version))))))


;;;
;;;; Zone
;;;


(definition public (new-zone (model: model #f) (units: units #f))
  (let ((model (or model 'Zone))
        (units (or units '(world.data))))
    (let ((tag (string->symbol (format "<{a}>" model)))
          (data (new Data zone-version 'jazz units #f)))
      (let ((form (construct-form (list tag) (imports-locator units) data)))
        (make-zone form)))))


(definition public (open-zone file (start-script?: start-script? #t) (start-script: start-script #f))
  (let ((form (convert-zone (read-form file))))
    (load-point 'zone-form)
    (make-zone form start-script?: start-script? start-script: start-script)))


(definition public (make-zone form (start-script?: start-script? #t) (start-script: start-script #f))
  (let ((world (current-world)))
    (let ((current (current-zone+)))
      (load-point 'zone-base)
      (close-all-popups)
      (when current
        (close-zone current)
        (free-eye-sectors~ current)
        (reset-camera~ world))
      (let ((zone (instantiate~ form)))
        (load-point 'zone-instantiate)
        (unless (get-title~ zone)
          (let ((origin (get-origin~ form)))
            (when origin
              (set-title~ zone (get-name~ (get-parent~ origin))))))
        (set-designer~ zone (new Former form: form reference: zone))
        (initialize-zone~ zone)
        (load-point 'zone-initialize)
        (let ((script (get-prepare-script~ zone)))
          (when script
            (execute-script~ world script)))
        (update-children~ zone)
        (zone-update~ world)
        (update-title~ world)
        (when (get-sun-cycle?~ zone)
          (position-sun~ zone (get-sun-angle~ zone)))
        (populate-zone~ zone)
        (reset-selection~ world)
        (when start-script?
          (let ((script (or start-script (get-start-script~ zone))))
            (when script
              (execute-script~ world script))))
        (let ((appl (get-application))
              (moniker (get-moniker~ zone)))
          (when (client-side?~ appl)
            (unless (and moniker (let ((base (get-base~ moniker)))
                                   (or (filename=? base "welcome")
                                       (filename=? base "tutorial"))))
              (check-news~ appl))))
        (follow-player~ world)
        (load-point 'zone-ready)
        (start-tasks~ zone)
        (init-stable~ (get-eye~ world))
        (init-stable~ (get-history-camera~ world))
        zone))))


(definition public (close-zone zone <Zone>)
  (stop-tasks~ zone)
  (close~ zone))


(definition public (find-zone target)
  (let ((world (current-world)))
    (let ((zones-directories (get-zones-directories~ world)))
      (continuation-capture
        (lambda (return)
          (for-each (lambda (directory)
                      (iterate-directory~ directory
                        (lambda (path kind)
                          (let ((dir (new-directory~ directory path)))
                            (let ((file (zone-file dir)))
                              (when (and (exists?~ file)
                                         (filename=? (extract-spine (join path "/")) target))
                                (continuation-return return file)))))
                        full?: #f
                        files?: #f
                        directories?: #t))
                    zones-directories)
          #f)))))


(definition protected (zone-file dir)
  (new-file~ dir (zone-filename (get-base~ dir))))


(definition protected (zone-filename base)
  (format "_{a}.zone" base))


(definition protected (zone-directory moniker)
  (get-parent~ moniker))


(definition protected (zone-container moniker)
  (get-parent~ (zone-directory moniker)))


(definition protected (new-zone-file base)
  (let ((path (split base "/")))
    (new-file~ {Directory Settings "zones"} (append path (list (zone-filename (last path)))))))


(definition public (open-welcome-zone)
  (open-zone (find-zone (copy-zone-template "welcome" force-copy?: #t))))


(definition public (open-tutorial-zone (force-copy?: force-copy? #f) (start-script?: start-script? #t))
  (open-zone (find-zone (copy-zone-template "tutorial" force-copy?: force-copy?)) start-script?: start-script?))


(definition public (copy-zone-template name (force-copy?: force-copy? #f))
  (let ((world (current-world)))
    (let ((from-dir (new-directory~ (new-directory~ (get-world-directory~ world) "templates") name))
          (to-dir (get-parent~ (new-zone-file name))))
      (when (or force-copy? (not (exists?~ to-dir)))
        (copy-directory~ from-dir to-dir))
      name)))


(definition public (tutorial-template?)
  (let ((zone (current-zone)))
    (equal? (determine-path~ zone) '("tutorial"))))


(definition (convert-zone form)
  (define (convert->1.1 form)
    (define (convert-children form)
      (for-each convert (get-children~ form)))
    
    (define (convert form)
      (let ((x (get-property~ form x:)))
        (when x
          (let ((y (get-property~ form y:))
                (z (get-property~ form z:)))
            (remove-property~ form x:)
            (remove-property~ form y:)
            (remove-property~ form z:)
            (set-property~ form position: (vertex x y z)))))
      (let ((width (get-property~ form width:)))
        (when width
          (let ((height (get-property~ form height:))
                (depth (get-property~ form depth:)))
            (remove-property~ form width:)
            (remove-property~ form height:)
            (remove-property~ form depth:)
            (set-property~ form size: (vertex width height depth)))))
      (let ((color (get-property~ form color:)))
        (when color
          (set-property~ form color: (color->dye color))))
      (convert-children form))
    
    (set-version~ (get-data~ form) {Version 1 1})
    (convert-children form)
    form)
  
  (define (convert->1.2 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (scale-down form position:)
      (scale-down form radiuses:)
      (scale-down form radius:)
      (scale-down form v1:)
      (scale-down form v2:)
      (scale-down form v3:)
      (scale-down form v4:))
    
    (define (scale-down form property)
      (let ((value (get-property~ form property)))
        (when value
          (set-property~ form property (if (f32vector? value)
                                           (f32vertex-scalar/ value 5.)
                                         (/ value 5.))))))
    
    (define (f32vertex-scalar/ v <f64vector> r <fl>) <f64vector>
      (f32vector
        (/ (f32vector-ref v 0) r)
        (/ (f32vector-ref v 1) r)
        (/ (f32vector-ref v 2) r)))
    
    (set-version~ (get-data~ form) {Version 1 2})
    (scale-down form start-eye:)
    (scale-down form start-position:)
    (convert-children form)
    form)
  
  (define (convert->1.3 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (convert form position:)
      (convert form radiuses:)
      (convert form radius:)
      (convert form v1:)
      (convert form v2:)
      (convert form v3:)
      (convert form v4:))
    
    (define (convert form property)
      (let ((value (get-property~ form property)))
        (when (f32vector? value)
          (let ((len (f32vector-length value)))
            (let ((converted (make-f64vector len)))
              (loop (for i from 0 below len)
                    (f64vector-set! converted i (f32vector-ref value i)))
              (set-property~ form property converted))))))
    
    (set-version~ (get-data~ form) {Version 1 3})
    (convert form start-eye:)
    (convert form start-eye-sight:)
    (convert form start-eye-up:)
    (convert form start-position:)
    (convert form start-sight:)
    (convert form start-up:)
    (convert-children form)
    form)
  
  (define (convert->1.4 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (let ((value (get-property~ form scale:)))
        (when (flonum? value)
          (set-property~ form scale: (vertex value value value)))))
    
    (set-version~ (get-data~ form) {Version 1 4})
    (convert-children form)
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.4 (convert->1.3 (convert->1.2 (convert->1.1 form)))))
          ((nu=? version {Version 1 1})
           (convert->1.4 (convert->1.3 (convert->1.2 form))))
          ((nu=? version {Version 1 2})
           (convert->1.4 (convert->1.3 form)))
          ((nu=? version {Version 1 3})
           (convert->1.4 form))
          ((nu=? version {Version 1 4})
           form)
          (else
           (error "Unsupported zone version: {a}" (present-string~ version)))))))
