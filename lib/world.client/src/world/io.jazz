;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World I/O
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.io jazz


(import (jazz.application)
        (jazz.component)
        (jazz.io)
        (jazz.jrm.transmission)
        (jazz.network)
        (jazz.process)
        (jazz.snapshot)
        (jazz.syntax (phase syntax))
        (jazz.version)
        (jazz.view)
        (world)
        (world.assets)
        (world.autoload)
        (world.dye)
        (world.geometry)
        (world.id)
        (world.processor)
        (world.settings)
        (world.syntax (phase syntax))
        (world.task)
        (world.tier)
        (world.window))


;;;
;;;; Default
;;;


(definition *world-directories*
  '())

(definition public (world-directories)
  *world-directories*)

(definition public (set-world-directories directories)
  (set! *world-directories* directories))


(definition public (find-world name)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (info)
                  (bind (world-name . world-dir) info
                    (when (filename=? world-name name)
                      (continuation-return return world-dir))))
                (world-directories))
      #f)))


;;;
;;;; World
;;;


(definition protected boot-exit
  (make-parameter #f))


(definition public (boot-world start-world (start-zone: start-zone #f))
  (with-task-mutex
    (lambda ()
      (continuation-capture
        (lambda (exit)
          (parameterize ((boot-exit exit))
            (let ((dir (find-world start-world)))
              (open-world (new-file~ dir ".world") start-zone: start-zone))))))))


(definition public (open-world file (start-zone: start-zone #f))
  (let ((form (convert-world (read-form file))))
    (load-point 'world-form)
    (make-world form start-zone: start-zone)))


(definition public (make-world form (start-zone: start-zone #f))
  (close-world)
  (let ((world (instantiate~ form)))
    (define (open-safe name kind)
      (define (open)
        (let ((file (find-tier name kind)))
          (if file
              (case kind
                ((local) (open-local file))
                ((client) (open-client-safe file))
                ((server) (open-server file)))
            (report (format "Unable to find {a}: {a}" (or kind 'zone) name)))))
      
      (define (open-client-safe file)
        (let ((obj (open-client file)))
          (if (is? obj Zone)
              obj
            (report "Unable to connect to server"))))
      
      (define (report exception-message)
        (if (not (window?))
            (begin
              (snapshot-process exception: (new Error message: exception-message))
              (exit-no-jobs))
          (let ((welcome (open-welcome-zone)))
            (report-exception~ welcome exception-message #f)
            welcome)))
      
      (if (and (window?) (process-copyright-changed?~ (get-application)))
          (let ((zone (open-welcome-zone)))
            (set-post-accept~ zone open))
        (open)))
    
    (load-point 'world-instantiate)
    (unless (get-title~ world)
      (let ((origin (get-origin~ form)))
        (when origin
          (set-title~ world (get-name~ (get-parent~ origin))))))
    (set-designer~ world (new Former form: form reference: world))
    (set-window~ world (and (window?) (current-world-window)))
    (setup-opengl~ world)
    (resize-scene~ world)
    (initialize-world~ world)
    (load-point 'world-initialize)
    (unless (eq? start-zone 'none)
      (let ((last (world-setting 'world.last-zone #f))
            (zone-arg (command-argument "zone"))
            (client-arg (command-argument "client"))
            (server-arg (command-argument "server"))
            (processor-arg (command-argument "processor")))
        (cond (start-zone
               (open-safe start-zone 'local))
              (zone-arg
               (open-safe zone-arg 'local))
              (client-arg
               (open-safe client-arg 'client))
              (server-arg
               (open-safe server-arg 'server))
              (processor-arg
               (open-processor))
              (last
               (open-safe last 'local))
              (else
               (assert (window?))
               (open-welcome-zone))))
      (update-title~ world))
    (load-point 'world-ready)
    world))


(definition public (close-world)
  (let ((world (current-world+)))
    (when world
      (close~ world))))


(definition protected (world-loop done?)
  (define (thread-process-delayed-events)
    (declare (proper-tail-calls))
    (let ((thunk (read-delayed-event)))
      (when (not (eof-object? thunk))
        (thunk)
        (thread-process-delayed-events))))
  
  (declare (proper-tail-calls))
  (setup-threads~ (current-world))
  (let (loop)
    (let ((thunk (thread-read-message timeout: +infinity)))
      (site (delayed on?: #f parent: event)
        (thread-process-delayed-events))
      (site (event on?: #t)
        (when (not (eof-object? thunk))
          (thunk))))
    (unless (and done? (done?))
      (loop))))


(definition protected (world-products)
  (let ((world (current-world+)))
    (if (not world)
        '()
      (let ((queue (new-queue)))
        (iterate-table (get-installed-modules~ world)
          (lambda (name info)
            (bind (dirname . repository) info
              (for-each (lambda (package)
                          (for-each (lambda (product)
                                      (let ((name (product-descriptor-name product)))
                                        (enqueue queue name)))
                                    (package-products package)))
                        (repository-packages repository)))))
        (queue-list queue)))))


(definition protected (world-properties kind)
  (list kind: kind))


(definition protected (quit-world)
  (define (save-settings)
    (let ((zone (current-zone)))
      (let ((path (and (eq? tier-kind 'local) (zone-path~ zone tier-kind))))
        (set-setting~ options-settings 'world.last-zone path)
        (save-content~ options-settings))))
  
  (save-settings)
  (close-zone)
  (close-world))


(definition (convert-world form)
  (define (convert->1.1 form)
    (set-version~ (get-data~ form) {Version 1 1})
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.1 form))
          ((nu=? version {Version 1 1})
           form)
          (else
           (error "Unsupported world version: {a}" (present-string~ version))))))


;;;
;;;; Tier
;;;


;; open test quick hack
(import (world.entity)
        (world.history))

(definition protected (startup-tier kind dir)
  ;; open test quick hacks
  (reset-literals)
  (reset-entities)
  ;; sejour quick hack to think through
  (world.generation:reset-block-actions)
  (world.script:reset-properties)
  (world.script.entity:reset-running-scripts)
  (world.spawn:initialize-spawned)
  
  (case kind
    ((local)
     (new Local-Tier dir))
    ((client)
     (new Client-Tier dir))
    ((server)
     (new Server-Tier dir))
    ((processor)
     (new Processor-Tier dir))))


(definition protected (shutdown-tier)
  (let ((tier (current-tier+)))
    (when tier
      (shutdown~ tier))))


;;;
;;;; Local
;;;


(definition public (open-local file (start-script?: start-script? #t))
  (let ((dir {Directory Settings "local"}))
    (let ((tier (startup-tier 'local dir)))
      (close-zone)
      (set-tier-kind 'local)
      (set-current-tier tier)
      (open-zone file start-script?: start-script?))))


;;;
;;;; Client
;;;


(definition protected (create-client-file client-name server-address server-port name avatar (script #f))
  (let ((dir (new-directory~ {Directory Settings "clients"} client-name)))
    (create-directories~ dir)
    (let ((client-file (new-file~ dir ".client")))
      (call-with-output-file (path-settings client-file)
        (lambda (output)
          (format output ";;;========={%}")
          (format output ";;;  Yownu{%}")
          (format output ";;;========={%}")
          (format output ";;;{%}")
          (format output ";;;; Client{%}")
          (format output ";;;{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(data jazz{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(version {a}){%}" (present-string~ zone-version))
          (format output "(import world.data){%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(form{%}")
          (format output "  (<Client> server-host: {s} server-service: {s} character-name: {s} character-avatar: {s}"
            (string->host server-address)
            (string->port server-port)
            name
            avatar)
          (when script
            (format output " character-script: {s}" script))
          (format output "))){%}")))
      client-file)))


(definition protected (create-client-files client-prefix count server-address server-port (script #f))
  (let ((avatars (remove "character/dwarfmale" (world.interface.avatars:collect-avatar-models) test: equal?)))
    (loop (for n from 1 to count)
          (let ((client-name (format "{a}{a}" client-prefix n))
                (name (random-element '("Emma" "Lea" "Olivia" "Alice" "Florence" "Zoe" "Chloe" "Beatrice" "Charlotte" "Rosalie" "Eva" "Juliette" "Sofia" "Jade" "Camille" "Victoria" "Mia" "Charlie" "Romy" "Laurence" "Maeva" "Alicia" "Clara" "Annabelle" "Sarah" "Rose" "Raphaelle" "Livia" "Elizabeth" "Mila" "Anais" "Elodie" "Flavie" "Laurie" "Amelia" "Julia" "Leonie" "Maelie" "Gabrielle" "Sophia" "Adele" "Coralie" "Emy" "Noemie" "Aurelie" "Alexia" "Jeanne" "Emilie" "Eve" "Ophelie" "Thomas" "William" "Jacob" "Liam" "Felix" "Nathan" "Samuel" "Logan" "Alexis" "Noah" "Olivier" "Raphael" "Gabriel" "Emile" "Leo" "Charles" "Antoine" "Benjamin" "Adam" "Edouard" "Xavier" "Victor" "Zack" "Mathis" "Jayden" "Theo" "Elliot" "Zachary" "Louis" "James" "Anthony" "Alexandre" "Lucas" "Justin" "Arthur" "Tristan" "Loic" "Ethan" "Henri" "Nolan" "Nicolas" "Arnaud" "Jeremy" "Hugo" "Dylan" "Laurent" "Eli" "Vincent" "Isaac" "Etienne")))
                (avatar (random-element avatars))
                (script (or script "bot/player")))
            (let ((fullname (format "{a} ({a})" name client-name)))
              (create-client-file client-name server-address server-port fullname avatar script))))))


(definition public (open-client client-file)
  (define (problem? obj)
    (or (connection-problem? obj)
        (string? obj)))
  
  (define (open)
    (let ((dir (get-parent~ client-file)))
      (let ((tier (startup-tier 'client dir)))
        (close-zone)
        (let ((file (zone-file dir 'client))
              (form (get-form~ tier)))
          (set-origin~ form file)
          (set-tier-kind 'client)
          (set-current-tier tier)
          (open-zone file form: form)))))
  
  (catch (problem? obj
           obj)
    (open)))


;;;
;;;; Server
;;;


(definition public (create-server-file server-name server-address server-port name avatar)
  (let ((dir (new-directory~ {Directory Settings "servers"} server-name)))
    (create-directories~ dir)
    (let ((server-file (new-file~ dir ".server")))
      (call-with-output-file (path-settings server-file)
        (lambda (output)
          (format output ";;;========={%}")
          (format output ";;;  Yownu{%}")
          (format output ";;;========={%}")
          (format output ";;;{%}")
          (format output ";;;; Server{%}")
          (format output ";;;{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(data jazz{%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(version {a}){%}" (present-string~ zone-version))
          (format output "(import world.data){%}")
          (format output "{%}")
          (format output "{%}")
          (format output "(form{%}")
          (format output "  (<Server> host: {s} service: {s} character-name: {s} character-avatar: {s}))){%}"
            (string->host server-address)
            (string->port server-port)
            name
            avatar)))
      server-file)))


(definition public (open-server server-file)
  (let ((dir (get-parent~ server-file)))
    (let ((tier (startup-tier 'server dir)))
      (close-zone)
      (let ((processor (new Processor)))
        (let ((file (zone-file dir 'server)))
          (set-tier-kind 'server)
          (set-current-tier tier)
          (set-current-processor processor)
          (open-zone file))))))


;;;
;;;; Processor
;;;


(definition public (open-processor)
  (let ((processor (current-processor)))
    (let ((server-name (get-server-name~ processor))
          (zone (get-zone~ processor)))
      (let ((server-dir (new-directory~ {Directory Settings "servers"} server-name)))
        (let ((file (case (car zone)
                      ((instance) (new-file~ server-dir `("instances" ,(cadr zone) ".zone")))
                      (else (new-file~ server-dir `("zones" ,@(cdr zone) ".zone"))))))
          (let ((dir (get-parent~ file)))
            (let ((tier (startup-tier 'processor dir))
                  (zone (zone-file dir 'processor)))
              (set-tier-kind 'processor)
              (set-current-tier tier)
              (open-zone zone))))))))


;;;
;;;; Zone
;;;


(definition public (open-zone file (form: form #f) (start-script?: start-script? #t))
  (close-all-popups)
  (let ((form (or form (convert-zone (read-form file)))))
    (load-point 'zone-form)
    (make-zone file form start-script?)))


(definition public (make-zone file form start-script?)
  (let ((world (current-world)))
    ;; done before instantiating to enable custom zone class
    (let ((dir (get-parent~ file)))
      (set-zone-assets~ world (gather-assets 'zone (new-directory~ dir "assets")))
      (prepare-modules~ world (new-file~ dir ".instance")))
    (let ((zone (instantiate~ form)))
      (load-point 'zone-instantiate)
      (unless (get-title~ zone)
        (set-title~ zone (zone-name (get-moniker~ zone) tier-kind)))
      (set-designer~ zone (new Former form: form reference: zone))
      (initialize-zone~ zone)
      (load-point 'zone-initialize)
      (let ((script (get-prepare-script~ zone)))
        (when script
          (execute-script~ world script)))
      (zone-update~ world)
      (player-update~ zone)
      (update-title~ world)
      (when (get-sun-cycle?~ zone)
        (position-sun~ zone #f angle: (get-sun-angle~ zone)))
      (populate-zone~ zone)
      (setup-lighting~ zone)
      (prepare-motion~ world)
      (when start-script?
        (let ((script (get-start-script~ zone)))
          (when script
            (execute-script~ world script))))
      (let ((appl (get-application))
            (dir (get-directory~ zone)))
        (unless (or (admin?)
                    (not (window?))
                    (member? (get-name~ dir) '("welcome" "tutorial") test: filename=?))
          (check-news~ appl)))
      (zone-ready~ zone)
      (load-point 'zone-ready)
      (start-tasks~ zone)
      (init-stable~ (get-eye~ world))
      (init-stable~ (get-history-camera~ world))
      (set-ready?~ zone #t)
      (reset-shutdown)
      zone)))


(definition (close-zone)
  (let ((zone (current-zone+)))
    (when zone
      (close~ zone)
      (shutdown-tier)
      (set-tier-kind #f)
      (set-current-tier #f)
      (set-current-processor #f))))


(definition public (find-tier name kind)
  (let ((world (current-world)))
    (let ((directory (get-tiers-directory~ world kind)))
      (continuation-capture
        (lambda (return)
          (when (exists?~ directory)
            (iterate-directory~ directory
              (lambda (path path-kind)
                (let ((dir (new-directory~ directory path)))
                  (let ((file (tier-file dir kind)))
                    (when (and (exists?~ file)
                               (filename=? (extract-spine (join path "/")) name))
                      (continuation-return return file)))))
              full?: #f
              files?: #f
              directories?: #t))
          #f)))))


(definition public (find-zone name kind)
  (let ((world (current-world)))
    (let ((directory (get-tiers-directory~ world kind)))
      (continuation-capture
        (lambda (return)
          (when (exists?~ directory)
            (iterate-directory~ directory
              (lambda (path path-kind)
                (let ((dir (new-directory~ directory path)))
                  (let ((file (zone-file dir kind)))
                    (when (and (exists?~ file)
                               (filename=? (extract-spine (join path "/")) name))
                      (continuation-return return file)))))
              full?: #f
              files?: #f
              directories?: #t))
          #f)))))


(definition protected (tier-name file)
  (get-name~ (get-parent~ file)))


(definition protected (tier-file dir kind)
  (new-file~ dir (case kind
                   ((local) ".zone")
                   ((client) ".client")
                   ((server) ".server"))))


(definition protected (zone-file dir kind)
  (new-file~ dir (if (or (eq? kind 'local)
                         (eq? kind 'processor))
                     ".zone"
                   '("start" ".zone"))))


(definition protected (zone-name moniker kind)
  (get-name~ (if (or (eq? kind 'local)
                     (eq? kind 'processor))
                 (get-parent~ moniker)
               (get-parent~ (get-parent~ moniker)))))


(definition protected (new-zone-file base kind)
  (let ((world (current-world)))
    (let ((directory (get-tiers-directory~ world kind))
          (path (split base "/")))
      (zone-file (new-directory~ directory path) kind))))


(definition public (open-welcome-zone)
  (open-local (find-tier (copy-zone-template "welcome" 'local) 'local)))


(definition public (open-tutorial-zone (force-copy?: force-copy? #f) (start-script?: start-script? #t))
  (open-local (find-tier (copy-zone-template "tutorial" 'local force-copy?: force-copy?) 'local) start-script?: start-script?))


(definition public (copy-zone-template name kind (force-copy?: force-copy? #f))
  (let ((world (current-world)))
    (let ((from-dir (new-directory~ (new-directory~ (get-world-directory~ world) "templates") name))
          (to-dir (get-parent~ (new-zone-file name kind))))
      (when (or force-copy? (not (exists?~ to-dir)))
        (copy-directory~ from-dir to-dir))
      name)))


(definition public (tutorial-template?)
  (let ((zone (current-zone)))
    (equal? (zone-path~ zone 'local) "tutorial")))


(definition (convert-zone form)
  (define (convert->1.1 form)
    (define (convert-children form)
      (for-each convert (get-children~ form)))
    
    (define (convert form)
      (let ((x (get-property~ form x:)))
        (when x
          (let ((y (get-property~ form y:))
                (z (get-property~ form z:)))
            (remove-property~ form x:)
            (remove-property~ form y:)
            (remove-property~ form z:)
            (set-property~ form position: (vertex x y z)))))
      (let ((width (get-property~ form width:)))
        (when width
          (let ((height (get-property~ form height:))
                (depth (get-property~ form depth:)))
            (remove-property~ form width:)
            (remove-property~ form height:)
            (remove-property~ form depth:)
            (set-property~ form size: (vertex width height depth)))))
      (let ((color (get-property~ form color:)))
        (when color
          (set-property~ form color: (color->dye color))))
      (convert-children form))
    
    (set-version~ (get-data~ form) {Version 1 1})
    (convert-children form)
    form)
  
  (define (convert->1.2 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (scale-down form position:)
      (scale-down form radiuses:)
      (scale-down form radius:)
      (scale-down form v1:)
      (scale-down form v2:)
      (scale-down form v3:)
      (scale-down form v4:))
    
    (define (scale-down form property)
      (let ((value (get-property~ form property)))
        (when value
          (set-property~ form property (if (f32vector? value)
                                           (f32vertex-scalar/ value 5.)
                                         (/ value 5.))))))
    
    (define (f32vertex-scalar/ v <f64vector> r <fl>) <f64vector>
      (f32vector
        (/ (f32vector-ref v 0) r)
        (/ (f32vector-ref v 1) r)
        (/ (f32vector-ref v 2) r)))
    
    (set-version~ (get-data~ form) {Version 1 2})
    (scale-down form start-eye:)
    (scale-down form start-position:)
    (convert-children form)
    form)
  
  (define (convert->1.3 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (convert form position:)
      (convert form radiuses:)
      (convert form radius:)
      (convert form v1:)
      (convert form v2:)
      (convert form v3:)
      (convert form v4:))
    
    (define (convert form property)
      (let ((value (get-property~ form property)))
        (when (f32vector? value)
          (let ((len (f32vector-length value)))
            (let ((converted (make-f64vector len)))
              (loop (for i from 0 below len)
                    (f64vector-set! converted i (f32vector-ref value i)))
              (set-property~ form property converted))))))
    
    (set-version~ (get-data~ form) {Version 1 3})
    (convert form start-eye:)
    (convert form start-eye-sight:)
    (convert form start-eye-up:)
    (convert form start-position:)
    (convert form start-sight:)
    (convert form start-up:)
    (convert-children form)
    form)
  
  (define (convert->1.4 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (let ((value (get-property~ form scale:)))
        (when (flonum? value)
          (set-property~ form scale: (vertex value value value)))))
    
    (set-version~ (get-data~ form) {Version 1 4})
    (convert-children form)
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.4 (convert->1.3 (convert->1.2 (convert->1.1 form)))))
          ((nu=? version {Version 1 1})
           (convert->1.4 (convert->1.3 (convert->1.2 form))))
          ((nu=? version {Version 1 2})
           (convert->1.4 (convert->1.3 form)))
          ((nu=? version {Version 1 3})
           (convert->1.4 form))
          ((nu=? version {Version 1 4})
           form)
          (else
           (error "Unsupported zone version: {a}" (present-string~ version)))))))
