;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World I/O
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.io jazz


(import (jazz.application)
        (jazz.component)
        (jazz.event)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm.protocol)
        (jazz.process)
        (jazz.settings)
        (jazz.syntax (phase syntax))
        (jazz.version)
        (jazz.view)
        (world)
        (world.autoload)
        (world.dye)
        (world.geometry)
        (world.settings)
        (world.syntax (phase syntax))
        (world.tier)
        (world.window))


;;;
;;;; Default
;;;


(definition public (find-world name)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (info)
                  (bind (world-name . world-dir) info
                    (when (filename=? world-name name)
                      (continuation-return return world-dir))))
                (world-directories))
      (for-each (lambda (worlds-dir)
                  (for-each (lambda (world-dir)
                              (when (filename=? (get-base~ world-dir) name)
                                (continuation-return return world-dir)))
                            (collect-directories~ worlds-dir)))
                (worlds-directories))
      #f)))


(definition public (world-directories)
  (world-setting 'world.world-directories '()))


(definition public (worlds-directories)
  (let ((directories (world-setting 'world.worlds-directories (unspecified))))
    (if (specified? directories)
        directories
      (let ((queue (new-queue)))
        (define (add-if-exists dir)
          (when (exists?~ dir)
            (enqueue queue dir)
            #t))
        
        (add-if-exists {Directory Settings "worlds"})
        (or (add-if-exists (new-brother~ (world-directory '()) "worlds"))
            (add-if-exists {Directory Home "worlds"}))
        
        (queue-list queue)))))


;;;
;;;; World
;;;


(definition public (open-world file (start-zone: start-zone #f))
  (let ((form (convert-world (read-form file))))
    (load-point 'world-form)
    (make-world form start-zone: start-zone)))


(definition public (open-world/zone start-world start-zone)
  (let ((dir (find-world start-world)))
    (open-world (new-file~ dir ".world") start-zone: start-zone)))


(definition public (make-world form (start-zone: start-zone #f))
  (close-world)
  (let ((world (instantiate~ form)))
    (define (open-safe name (kind 'local))
      (define (open)
        (let ((file (find-zone name kind)))
          (if file
              (case kind
                ((local) (open-local file))
                ((client) (open-client file))
                ((server) (open-server file)))
            (let ((welcome (open-welcome-zone)))
              (report-exception~ welcome (format "Unable to find {a}: {a}" (or kind 'zone) name) #f)
              welcome))))
      
      (if (process-copyright-changed?~ (get-process))
          (let ((zone (open-welcome-zone)))
            (set-post-accept~ zone open))
        (open)))
    
    (load-point 'world-instantiate)
    (unless (get-title~ world)
      (let ((origin (get-origin~ form)))
        (when origin
          (set-title~ world (get-name~ (get-parent~ origin))))))
    (set-designer~ world (new Former form: form reference: world))
    (set-window~ world (current-world-window))
    (setup-opengl~ world)
    (resize-scene~ world)
    (initialize-world~ world)
    (load-point 'world-initialize)
    (let ((last (world-setting 'world.last-zone #f))
          (zone-arg (command-argument "zone"))
          (client-arg (command-argument "client"))
          (server-arg (command-argument "server")))
      (cond (start-zone
             (open-safe start-zone))
            (zone-arg
             (open-safe zone-arg))
            (client-arg
             (open-safe client-arg 'client))
            (server-arg
             (open-safe server-arg 'server))
            (last
             (open-safe last))
            (else
             (open-welcome-zone))))
    (load-point 'world-ready)
    world))


(definition public (close-world)
  (let ((world (current-world+)))
    (when world
      (close~ world))))


(definition protected (world-loop done?)
  (define (thread-process-delayed-events)
    (declare (proper-tail-calls))
    (let ((thunk (read-delayed-event)))
      (when (not (eof-object? thunk))
        (thunk)
        (thread-process-delayed-events))))
  
  (declare (proper-tail-calls))
  (setup-threads~ (current-world))
  (let (loop)
    (let ((thunk (thread-read-message timeout: +infinity)))
      (site (delayed on?: #f parent: event)
        (thread-process-delayed-events))
      (site (event on?: #t)
        (when (not (eof-object? thunk))
          (thunk))))
    (unless (and done? (done?))
      (loop))))


(definition protected (world-products)
  (let ((world (current-world+)))
    (if (not world)
        '()
      (let ((queue (new-queue)))
        (iterate-table (get-installed-modules~ world)
          (lambda (name info)
            (bind (dirname . repository) info
              (for-each (lambda (package)
                          (for-each (lambda (product)
                                      (let ((name (product-descriptor-name product)))
                                        (enqueue queue name)))
                                    (package-products package)))
                        (repository-packages repository)))))
        (queue-list queue)))))


(definition protected (world-properties kind)
  (list kind: kind))


(definition protected (quit-world)
  (define (save-settings)
    (let ((zone (current-zone)))
      (let ((path (zone-path~ zone)))
        (set-setting~ options-settings 'world.last-zone path)
        (save-content~ options-settings))))
  
  (close-zone)
  (close-world)
  (save-settings))


(definition (convert-world form)
  (define (convert->1.1 form)
    (set-version~ (get-data~ form) {Version 1 1})
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.1 form))
          ((nu=? version {Version 1 1})
           form)
          (else
           (error "Unsupported world version: {a}" (present-string~ version))))))


;;;
;;;; Tier
;;;


(definition protected (install-tier kind dir)
  (set-zone-kind kind)
  (set-current-tier (setup-tier kind dir)))


;; open test quick hack
(import (world.entity)
        (world.history))

(definition protected (setup-tier kind dir)
  (define (make-settings filename)
    (new File-Settings file: (new-file~ dir filename)))
  
  ;; open test quick hacks
  (reset-literals)
  (reset-entities)
  (reset-unique)
  
  (case kind
    ((local)
     (new Local-Tier))
    ((client)
     (new Client-Tier (make-settings ".client")))
    ((server)
     (new Server-Tier (make-settings ".server")))))


(definition protected (shutdown-tier)
  (let ((tier (current-tier+)))
    (when tier
      (shutdown~ tier))))


(definition protected (uninstall-tier)
  (shutdown-tier)
  (set-zone-kind #f)
  (set-current-tier #f))


;;;
;;;; Zone
;;;


(definition public (open-local file)
  (open-zone file kind: 'local))


(definition public (open-client file)
  (define (problem? obj)
    (or (os-exception? obj)
        (connection-problem? obj)
        (string? obj)))
  
  (catch (problem? obj
           obj)
    (let ((tier (setup-tier 'client (get-parent~ file))))
      (let ((form (get-form~ tier)))
        (set-origin~ form file)
        (open-zone file form: form kind: 'client tier: tier)))))


(definition public (open-server file)
  (open-zone file kind: 'server))


(definition public (open-zone file (form: form #f) (kind: kind 'local) (tier: tier #f) (start-script?: start-script? #t) (start-script: start-script #f))
  (close-all-popups)
  (close-zone)
  (let ((form (or form (convert-zone (read-form file)))))
    (load-point 'zone-form)
    (make-zone file form kind tier start-script? start-script)))


(definition public (make-zone file form kind tier start-script? start-script)
  (let ((world (current-world)))
    ;; done before instantiating to enable custom zone class
    (let ((dir (get-parent~ file)))
      (if (not tier)
          (install-tier kind dir)
        (set-zone-kind kind)
        (set-current-tier tier))
      (set-zone-assets~ world (gather-assets~ world 'zone (new-directory~ dir "assets")))
      (prepare-modules~ world (new-file~ dir ".template")))
    (let ((zone (instantiate~ form)))
      (load-point 'zone-instantiate)
      (unless (get-title~ zone)
        (let ((origin (get-origin~ form)))
          (when origin
            (set-title~ zone (get-name~ (get-parent~ origin))))))
      (set-designer~ zone (new Former form: form reference: zone))
      (initialize-zone~ zone)
      (load-point 'zone-initialize)
      (let ((script (get-prepare-script~ zone)))
        (when script
          (execute-script~ world script)))
      (zone-update~ world)
      (player-update~ zone)
      (update-title~ world)
      (when (get-sun-cycle?~ zone)
        (position-sun~ zone (get-sun-angle~ zone)))
      (populate-zone~ zone)
      (setup-lighting~ zone)
      (when start-script?
        (let ((script (or start-script (get-start-script~ zone))))
          (when script
            (execute-script~ world script))))
      (let ((appl (get-application))
            (moniker (get-moniker~ zone)))
        (unless (admin?)
          (unless (and moniker (member? (zone-name moniker) '("welcome" "tutorial") test: filename=?))
            (check-news~ appl))))
      (zone-ready~ zone)
      (load-point 'zone-ready)
      (start-tasks~ zone)
      (init-stable~ (get-eye~ world))
      (init-stable~ (get-history-camera~ world))
      (set-ready?~ zone #t)
      (run-scripts~ zone)
      zone)))


(definition (close-zone)
  (let ((zone (current-zone+)))
    (when zone
      (close~ zone))
    (uninstall-tier)))


(definition public (find-zone name (kind 'local))
  (let ((world (current-world)))
    (let ((directory (get-zones-directory~ world kind)))
      (continuation-capture
        (lambda (return)
          (when (exists?~ directory)
            (iterate-directory~ directory
              (lambda (path kind)
                (let ((dir (new-directory~ directory path)))
                  (let ((file (zone-file dir)))
                    (when (and (exists?~ file)
                               (filename=? (extract-spine (join path "/")) name))
                      (continuation-return return file)))))
              full?: #f
              files?: #f
              directories?: #t))
          #f)))))


(definition protected (zone-file dir)
  (new-file~ dir ".zone"))


(definition protected (zone-name moniker)
  (get-name~ (zone-directory moniker)))


(definition protected (zone-directory moniker)
  (get-parent~ moniker))


(definition protected (zone-container moniker)
  (get-parent~ (zone-directory moniker)))


(definition protected (new-zone-file base (kind 'local))
  (let ((world (current-world)))
    (let ((directory (get-zones-directory~ world kind))
          (path (split base "/")))
      (new-file~ directory (append path (list ".zone"))))))


(definition public (open-welcome-zone)
  (open-zone (find-zone (copy-zone-template "welcome" force-copy?: #t))))


(definition public (open-tutorial-zone (force-copy?: force-copy? #f) (start-script?: start-script? #t))
  (open-zone (find-zone (copy-zone-template "tutorial" force-copy?: force-copy?)) start-script?: start-script?))


(definition public (copy-zone-template name (force-copy?: force-copy? #f))
  (let ((world (current-world)))
    (let ((from-dir (new-directory~ (new-directory~ (get-world-directory~ world) "templates") name))
          (to-dir (get-parent~ (new-zone-file name))))
      (when (or force-copy? (not (exists?~ to-dir)))
        (copy-directory~ from-dir to-dir))
      name)))


(definition public (tutorial-template?)
  (let ((zone (current-zone)))
    (equal? (zone-path~ zone) "tutorial")))


(definition (convert-zone form)
  (define (convert->1.1 form)
    (define (convert-children form)
      (for-each convert (get-children~ form)))
    
    (define (convert form)
      (let ((x (get-property~ form x:)))
        (when x
          (let ((y (get-property~ form y:))
                (z (get-property~ form z:)))
            (remove-property~ form x:)
            (remove-property~ form y:)
            (remove-property~ form z:)
            (set-property~ form position: (vertex x y z)))))
      (let ((width (get-property~ form width:)))
        (when width
          (let ((height (get-property~ form height:))
                (depth (get-property~ form depth:)))
            (remove-property~ form width:)
            (remove-property~ form height:)
            (remove-property~ form depth:)
            (set-property~ form size: (vertex width height depth)))))
      (let ((color (get-property~ form color:)))
        (when color
          (set-property~ form color: (color->dye color))))
      (convert-children form))
    
    (set-version~ (get-data~ form) {Version 1 1})
    (convert-children form)
    form)
  
  (define (convert->1.2 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (scale-down form position:)
      (scale-down form radiuses:)
      (scale-down form radius:)
      (scale-down form v1:)
      (scale-down form v2:)
      (scale-down form v3:)
      (scale-down form v4:))
    
    (define (scale-down form property)
      (let ((value (get-property~ form property)))
        (when value
          (set-property~ form property (if (f32vector? value)
                                           (f32vertex-scalar/ value 5.)
                                         (/ value 5.))))))
    
    (define (f32vertex-scalar/ v <f64vector> r <fl>) <f64vector>
      (f32vector
        (/ (f32vector-ref v 0) r)
        (/ (f32vector-ref v 1) r)
        (/ (f32vector-ref v 2) r)))
    
    (set-version~ (get-data~ form) {Version 1 2})
    (scale-down form start-eye:)
    (scale-down form start-position:)
    (convert-children form)
    form)
  
  (define (convert->1.3 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (convert form position:)
      (convert form radiuses:)
      (convert form radius:)
      (convert form v1:)
      (convert form v2:)
      (convert form v3:)
      (convert form v4:))
    
    (define (convert form property)
      (let ((value (get-property~ form property)))
        (when (f32vector? value)
          (let ((len (f32vector-length value)))
            (let ((converted (make-f64vector len)))
              (loop (for i from 0 below len)
                    (f64vector-set! converted i (f32vector-ref value i)))
              (set-property~ form property converted))))))
    
    (set-version~ (get-data~ form) {Version 1 3})
    (convert form start-eye:)
    (convert form start-eye-sight:)
    (convert form start-eye-up:)
    (convert form start-position:)
    (convert form start-sight:)
    (convert form start-up:)
    (convert-children form)
    form)
  
  (define (convert->1.4 form)
    (define (convert-children form)
      (for-each convert-child (get-children~ form)))
    
    (define (convert-child form)
      (let ((value (get-property~ form scale:)))
        (when (flonum? value)
          (set-property~ form scale: (vertex value value value)))))
    
    (set-version~ (get-data~ form) {Version 1 4})
    (convert-children form)
    form)
  
  (let ((version (or (get-version~ (get-data~ form)) {Version 1 0})))
    (cond ((nu=? version {Version 1 0})
           (convert->1.4 (convert->1.3 (convert->1.2 (convert->1.1 form)))))
          ((nu=? version {Version 1 1})
           (convert->1.4 (convert->1.3 (convert->1.2 form))))
          ((nu=? version {Version 1 2})
           (convert->1.4 (convert->1.3 form)))
          ((nu=? version {Version 1 3})
           (convert->1.4 form))
          ((nu=? version {Version 1 4})
           form)
          (else
           (error "Unsupported zone version: {a}" (present-string~ version)))))))
