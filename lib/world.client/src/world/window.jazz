;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Window
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.window jazz


(import (jazz.debuggee)
        (jazz.opengl)
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.context)
        (world.interface)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.task))


(definition public window-fullscreen?
  ;; temporary until fullscreen crash fixed
  (cond-expand
    (windows
     #f)
    (else
     (world-setting 'world.fullscreen? (and (not (get-controller-debugger)) (not local-server/clients?) (window?))))))


(definition public (with-window-cursor cursor thunk)
  (if (not (window?))
      (thunk)
    (let ((window (current-world-window)))
      (unwind-protect
          (begin
            (set-cursor cursor)
            (thunk)
            @fix-me-this-can-cause-all-sorts-of-problems
            (prog1 (thunk)
              (render-scene window)))
        (cursor-update window #t)))))


(class World-Window extends OpenGL-Window
  
  
  (slot window-cursor initialize #f getter generate)
  
  
  (method override (destroy self)
    (destroy (current-world))
    (nextmethod self))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (method override (render-ready? self)
    (let ((zone (current-zone+)))
      (and zone (get-ready? zone))))
  
  
  (method override (render-scene self)
    )
  
  
  (cond-expand
    (windows
     ;; fixes horrible flicker
     (method override (paint update-region . platform-data)
       (with-platform-painting self platform-data
         (lambda (surface)
           ))))
    (else
     ;; needed for mac resizing
     (method override (paint self update-region . platform-data)
       (with-platform-painting self platform-data
         (lambda (surface)
           (when (window?)
             (unless being-debugged?
               (with-maybe-task-mutex
                 (lambda ()
                   (when (render-ready? self)
                     (draw-scene self)
                     (render-sync self)))))))))))
  
  
  ;; can only be called by above paint
  (method override (draw-scene self)
    (let ((world (current-world+)))
      (when world
        (render-world world))))
  
  
  ;;;
  ;;;; Cursor
  ;;;
  
  
  (method public (set-window-cursor self cursor)
    (set! window-cursor cursor)
    (update-window-cursor self))

  
  (method package (update-window-cursor self)
    (when (and window-cursor (not (active-focus)) (not (current-drag-drop)))
      (set-cursor window-cursor)))
  
  
  ;;;
  ;;;; Size
  ;;;
  
  
  (method override (size-change self state size)
    (let ((world (current-world+)))
      (when world
        (size-change world size)))
    (nextmethod self state size))
  
  
  (method override (resize-scene self width height)
    (nextmethod self width height)
    (let ((world (current-world+)))
      (when world
        (resize-scene world))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (import world.geometry)
  (method override (mouse-down self h v)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world))
                (view (find-view self (new Point h v))))
            (let ((entity ?e))
              (if #f @w (and entity (shift-down?))
                (bind-values (position direction) (screen->world (current-camera) h v)
                  (let ((pos (get-position entity))
                        (normal (vertex 0. 0. 1.)))
                    (let ((plane-k (dot-product pos normal)))
                      (let ((info (perspective->world world position direction normal plane-k)))
                        (if (not info)
                            (debug info)
                          (receive (point normal) info
                            (let ((width 6.)
                                  (height 3.)
                                  (pixel-scale (/ 1200. 6.)))
                              (let ((delta (vertex- point pos)))
                                (let ((h (* (vertex-x delta) @w (sqrt (+ (* (vertex-x delta) (vertex-x delta)) (* (vertex-z delta) (vertex-z delta)))) pixel-scale))
                                      (v (* (vertex-y delta) pixel-scale)))
                                  (debug @w (present-vertex delta) h v))))))))))
            (cond ((get-explore-interface? world)
                   (set-explore-interface? world #f)
                   (set-window-cursor (current-world-window) :arrow)
                   (set-% view))
                  ((and view (is-not? view World-Interface))
                   (nextmethod self h v))
                  (else
                   ;; weird showcase behavior
                   (cond-expand
                     ((not x11)
                      (bring-to-front self))
                     (else))
                   (acquire-capture self)
                   (acquire-focus self)
                   (set-mouse-down? #t)
                   (mouse-down world h v))))))))))
  
  
  (method override (mouse-moved self x y)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world))
                (view (find-view self (new Point (fxround x) (fxround y)))))
            (cond ((get-explore-interface? world)
                   (display-status world (format "{a}" view)))
                  ((and (not (get-down? world)) (not (is-moving? world)) (or (get-mouse-down-view) (and view (is-not? view World-Interface))))
                   (nextmethod self x y))
                  (else
                   (when (get-mouse-in)
                     (dispatch-mouse-leave (get-mouse-in)))
                   (reset-mouse-in)
                   (mouse-moved world x y))))
          (update-window-cursor self)))))
  
  
  (method override (mouse-up self h v)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world))
                (view (find-view self (new Point h v))))
            (if (and (not (get-down? world)) (not (is-moving? world)) (or (get-mouse-down-view) (and view (is-not? view World-Interface))))
                (nextmethod self h v)
              (release-capture self)
              (set-mouse-down? #f)
              (mouse-up world h v)))))))
  
  
  (method override (double-click self h v)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world))
                (view (find-view self (new Point h v))))
            (if (and (not (get-down? world)) (not (is-moving? world)) view (is-not? view World-Interface))
                (nextmethod self h v)
              (release-capture self)
              (double-click world h v)))))))
  
  
  (method override (multiple-click self count h v)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world))
                (view (find-view self (new Point h v))))
            (if (and (not (get-down? world)) (not (is-moving? world)) view (is-not? view World-Interface))
                (nextmethod self count h v)
              (release-capture self)
              (if (odd? count)
                  (mouse-down world h v)
                (double-click world h v))))))))
  
  
  (method override (right-mouse-down self h v)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world))
                (view (let ((pos (new Point h v)))
                        ;; quick pass-through hacks to be improved
                        (let ((view (find-view self pos)))
                          (if (and (is? view world.interface.inventory:Inventory-Slot)
                                   (get-id view))
                              view
                            (find-view self pos
                                       ignore: (let ((interface (current-interface)))
                                                 (list (child interface 'map)
                                                       (child interface 'compass)
                                                       (child interface 'combat)
                                                       (child interface 'character)
                                                       (child interface 'bag)
                                                       (child interface 'belt)
                                                       (child interface 'chest)
                                                       (child interface 'crafting)))))))))
            (cond ((and view (is-not? view World-Interface))
                   (nextmethod self h v))
                  (else
                   (acquire-capture self)
                   (set-mouse-right-down? #t)
                   (right-mouse-down world h v))))))))
  
  
  (method override (right-mouse-up self h v)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world))
                (view (find-view self (new Point h v))))
            (if (and (not (get-down? world)) (not (is-moving? world)) (or (get-mouse-down-view) (and view (is-not? view World-Interface))))
                (nextmethod self h v)
              (release-capture self)
              (set-mouse-right-down? #f)
              (right-mouse-up world h v)))))))
  
  
  (method override (mouse-wheel self h v delta)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world)))
            (if (get-mouse-in)
                (nextmethod self h v delta)
              (mouse-wheel world h v delta)))))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (key-down self c)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world)))
            (if (active-focus)
                (nextmethod self c)
              (key-down world c)))))))
  
  
  (method override (key-press self c)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world)))
            (if (active-focus)
                (nextmethod self c)
              (key-press world c)))))))
  
  
  (method override (key-up self c)
    (unless being-debugged?
      (with-task-mutex
        (lambda ()
          (let ((world (current-world)))
            (if (active-focus)
                (nextmethod self c)
              (key-up world c))))))))


;;;
;;;; Live
;;;


(import (jazz.application)
        (jazz.platform)
        (jazz.screen))


(definition public (tile-server/clients clients)
  (cond-expand
    (cocoa
     (let ((handle (get-handle (current-toplevel))))
       (let ((rect (get-frame-rect (main-screen))))
         (let ((left (get-left rect))
               (top (get-top rect))
               (right (get-right rect))
               (bottom (get-bottom rect))
               (mode 'horizontal))
           (case mode
             ((vertical)
              (let ((screen-width (- right left)))
                (let ((area-width (fxround (percent screen-width 45.5)))
                      (area-height (- bottom top)))
                  (with-NSRect (new Rect area-width 0 screen-width bottom)
                    (lambda (rect)
                      (platformEnterWindowed handle rect #f)))
                  (when (not-null? clients)
                    (let ((count (length clients))
                          (maximum 5)
                          (rank 0))
                      (let ((horizontal (+ (quotient (- count 1) maximum) 1))
                            (vertical (min maximum count)))
                        (let ((width (fxround (exact->inexact (/ area-width horizontal))))
                              (height (fxround (exact->inexact (/ area-height vertical)))))
                          (for-each (lambda (client)
                                      (let ((horz (quotient rank maximum))
                                            (vert (modulo rank maximum)))
                                        (let ((left (* width horz))
                                              (top (* height vert)))
                                          (let ((right (+ left width))
                                                (bottom (+ top height)))
                                            (let ((rect (new Rect left top right bottom)))
                                              (position-client client rect)))))
                                      (increase! rank))
                                    clients))))))))
             ((horizontal)
              (let ((screen-height (- bottom top)))
                (let ((area-width (- right left))
                      (area-height (fxround (percent screen-height 45.5)))
                      (server-position 'bottom))
                  (with-NSRect (case server-position
                                 ((top)
                                  (new Rect 0 area-height right screen-height))
                                 ((bottom)
                                  (new Rect 0 0 right area-height)))
                    (lambda (rect)
                      (platformEnterWindowed handle rect #f)))
                  (when (not-null? clients)
                    (let ((count (length clients))
                          (maximum 5)
                          (rank 0))
                      (let ((horizontal (min maximum count))
                            (vertical (+ (quotient (- count 1) maximum) 1)))
                        (let ((width (fxround (exact->inexact (/ area-width horizontal))))
                              (height (fxround (exact->inexact (/ area-height vertical)))))
                          (for-each (lambda (client)
                                      (let ((horz (modulo rank maximum))
                                            (vert (quotient rank maximum)))
                                        (let ((left (* width horz))
                                              (top (* height vert)))
                                          (let ((right (+ left width))
                                                (bottom (+ top height)))
                                            (let ((rect (case server-position
                                                          ((top)
                                                           (new Rect left top right bottom))
                                                          ((bottom)
                                                           (new Rect left bottom right screen-height)))))
                                              (position-client client rect)))))
                                      (increase! rank))
                                    clients)))))))))))))
    (else)))


(definition public (position-client-window rect)
  (cond-expand
    (cocoa
     (let ((handle (get-handle (current-toplevel))))
       (with-NSRect rect
         (lambda (rect)
           (platformEnterWindowed handle rect #f)))))
    (else)))


(definition public (restore-client-window)
  (cond-expand
    (cocoa
     (let ((handle (get-handle (current-toplevel))))
       (platformExitWindowed handle)))
    (else)))


(definition public (restore-server/clients clients)
  (cond-expand
    (cocoa
     (let ((handle (get-handle (current-toplevel))))
       (platformExitWindowed handle))
     (when (not-null? clients)
       (for-each restore-client clients)))
    (else))))
