;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Window
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.window jazz


(import (jazz.opengl)
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.interface)
        (world.profiling)
        (world.support)
        (world.syntax (phase syntax))
        (world.task))


(definition public (with-window-cursor cursor thunk)
  (let ((window (current-world-window)))
    (unwind-protect
        (begin
          (set-cursor cursor)
          (thunk)
          @fix-me-this-can-cause-all-sorts-of-problems
          (prog1 (thunk)
            (render-scene~ window)))
      (cursor-update~ window #t))))


(class World-Window extends OpenGL-Window
  
  
  (slot window-cursor initialize #f getter generate)
  
  
  (method override (destroy)
    (destroy~ (current-world))
    (nextmethod))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (method override (render-ready?)
    (let ((world (current-world+)))
      (and (nextmethod)
           world
           (get-render-ready?~ world))))
  
  
  (method override (render-scene)
    )
  
  
  (cond-expand
    (windows
     ;; fixes horrible flicker
     (method override (paint update-region . platform-data)
       (with-platform-painting self platform-data
         (lambda (surface)
           ))))
    (else
     ;; needed for mac resizing
     (method override (paint update-region . platform-data)
       (with-platform-painting self platform-data
         (lambda (surface)
           (with-maybe-task-mutex
             (lambda ()
               (when (render-ready?)
                 (draw-scene)
                 (render-sync)))))))))
  
  
  (method override (draw-scene)
    (let ((world (current-world+)))
      (when world
        (render-world~ world))))
  
  
  ;;;
  ;;;; Cursor
  ;;;
  
  
  (method public (set-window-cursor cursor)
    (set! window-cursor cursor)
    (update-window-cursor))

  
  (method (update-window-cursor)
    (when (and window-cursor (not (get-focus)) (not (current-drag-drop)))
      (set-cursor window-cursor)))
  
  
  ;;;
  ;;;; Size
  ;;;
  
  
  (method override (size-change state size)
    (let ((world (current-world+)))
      (when world
        (size-change~ world size)))
    (nextmethod state size))
  
  
  (method override (resize-scene width height)
    (nextmethod width height)
    (let ((world (current-world+)))
      (when world
        (resize-scene~ world))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down h v)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world))
              (view (find-view (new Point h v))))
          (cond ((get-explore-interface?~ world)
                 (set-explore-interface?~ world #f)
                 (set-window-cursor~ (current-world-window) :arrow)
                 (set-% view))
                ((and view (is-not? view World-Interface))
                 (nextmethod h v))
                (else
                 (bring-to-front)
                 (acquire-capture)
                 (acquire-focus)
                 (mouse-down~ world h v)))))))
  
  
  (method override (mouse-moved x y)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world))
              (view (find-view (new Point (fxround x) (fxround y)))))
          (cond ((get-explore-interface?~ world)
                 (display-status~ world (format "{a}" view)))
                ((and (not (get-down?~ world)) (not (is-moving?~ world)) (or (get-mouse-down-view) (and view (is-not? view World-Interface))))
                 (nextmethod x y))
                (else
                 (when (get-mouse-in)
                   (dispatch-mouse-leave~ (get-mouse-in)))
                 (reset-mouse-in)
                 (mouse-moved~ world x y))))
        (update-window-cursor))))
  
  
  (method override (mouse-up h v)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world))
              (view (find-view (new Point h v))))
          (if (and (not (get-down?~ world)) (not (is-moving?~ world)) (or (get-mouse-down-view) (and view (is-not? view World-Interface))))
              (nextmethod h v)
            (release-capture)
            (mouse-up~ world h v))))))
  
  
  (method override (double-click h v)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world))
              (view (find-view (new Point h v))))
          (if (and (not (get-down?~ world)) (not (is-moving?~ world)) view (is-not? view World-Interface))
              (nextmethod h v)
            (release-capture)
            (double-click~ world h v))))))
  
  
  (method override (multiple-click count h v)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world))
              (view (find-view (new Point h v))))
          (if (and (not (get-down?~ world)) (not (is-moving?~ world)) view (is-not? view World-Interface))
              (nextmethod count h v)
            (release-capture)
            (if (odd? count)
                (mouse-down~ world h v)
              (double-click~ world h v)))))))
  
  
  (method override (right-mouse-down h v)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world))
              (view (let ((pos (new Point h v)))
                      ;; quick pass-through hacks to be improved
                      (let ((view (find-view pos)))
                        (if (and (is? view world.interface.inventory:Inventory-Slot)
                                 (get-id~ view))
                            view
                          (find-view pos
                                     ignore: (let ((interface (current-interface)))
                                               (list (child~ interface 'combat)
                                                     (child~ interface 'character)
                                                     (child~ interface 'bag)
                                                     (child~ interface 'belt)
                                                     (child~ interface 'chest)))))))))
          (cond ((and view (is-not? view World-Interface))
                 (nextmethod h v))
                (else
                 (acquire-capture)
                 (right-mouse-down~ world h v)))))))
  
  
  (method override (right-mouse-up h v)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world))
              (view (find-view (new Point h v))))
          (if (and (not (get-down?~ world)) (not (is-moving?~ world)) (or (get-mouse-down-view) (and view (is-not? view World-Interface))))
              (nextmethod h v)
            (release-capture)
            (right-mouse-up~ world h v))))))
  
  
  (method override (mouse-wheel h v delta)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world)))
          (if (get-mouse-in)
              (nextmethod h v delta)
            (mouse-wheel~ world h v delta))))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (key-down c)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world)))
          (if (get-focus)
              (nextmethod c)
            (key-down~ world c))))))
  
  
  (method override (key-press c)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world)))
          (if (get-focus)
              (nextmethod c)
            (key-press~ world c))))))
  
  
  (method override (key-up c)
    (with-task-mutex
      (lambda ()
        (let ((world (current-world)))
          (if (get-focus)
              (nextmethod c)
            (key-up~ world c))))))))
