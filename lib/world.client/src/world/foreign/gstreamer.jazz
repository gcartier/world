;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; GStreamer
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.foreign.gstreamer jazz


(import (jazz.foreign)
        (jazz.gstreamer)
        (jazz.platform.types))


(c-enumerant GST_APP_STREAM_TYPE_STREAM)
(c-enumerant GST_APP_STREAM_TYPE_SEEKABLE)
(c-enumerant GST_APP_STREAM_TYPE_RANDOM_ACCESS)

(c-enumerant GST_EVENT_CAPS)


(c-type GstAppStreamType enum)
(c-type GstFlowReturn    enum)


;;;
;;;; AppSink
;;;


(c-declare world.foreign.gstreamer #/C/
#include <string.h>
#include <glib.h>
#include <gst/gst.h>
#include <gst/app/gstappsrc.h>
#include <gst/app/gstappsink.h>

static double present_time(GstClockTime time)
{
    if (time == GST_CLOCK_TIME_NONE)
        return -1;
    else
        return GST_TIME_AS_SECONDS((double) time);
}

static void gst_debug_pipeline(GstPipeline* pipeline)
{
    GstClockTime delay, latency;
    delay = gst_pipeline_get_delay(pipeline);
    latency = gst_pipeline_get_latency(pipeline);
    printf("INFO pipeline delay %.3f latency %.3f\n", present_time(delay), present_time(latency));
}

static void gst_debug_pad(GstElement* elem, char* name)
{
    GstPad *pad = gst_element_get_static_pad(elem, name);
    printf("pad caps %p\n", gst_pad_get_current_caps(pad));
}

static GstPadProbeReturn
cb_have_data (GstPad          *pad,
              GstPadProbeInfo *info,
              gpointer         user_data)
{
    GstBuffer* buffer;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* name;
    
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    name = gst_pad_get_name(pad);
    GstClockTime timestamp = GST_BUFFER_PTS(buffer);
    GstClockTime clockstamp = gst_clock_get_time(gst_pipeline_get_clock(pipeline)) - gst_element_get_base_time(GST_ELEMENT(pipeline));
    // printf("DATA %s %s %s %d %.3f %.3f %.3f\n", pipeline_name, element_name, name, gst_buffer_get_size(buffer), present_time(gst_element_get_start_time(element)), present_time(GST_BUFFER_PTS(buffer)), present_time(GST_BUFFER_DURATION(buffer)));
    // printf("DATA %s %s %s %.3f %.3f %.3f\n", pipeline_name, element_name, name, present_time(gst_element_get_start_time(element)), present_time(GST_BUFFER_PTS(buffer)), present_time(GST_BUFFER_DURATION(buffer)));
    printf("DATA %s %s %s %.3f %.3f %.3f\n", pipeline_name, element_name, name, present_time(timestamp), present_time(clockstamp), present_time(timestamp) - present_time(clockstamp));
    g_free(name);
    g_free(element_name);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_have_event (GstPad          *pad,
               GstPadProbeInfo *info,
               gpointer         user_data)
{
    GstEvent* event;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* name;
    
    event = GST_PAD_PROBE_INFO_EVENT(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    name = gst_pad_get_name(pad);
    if (GST_EVENT_TYPE(event) == GST_EVENT_CAPS)
    {
        GstCaps *caps;
        gst_event_parse_caps(event, &caps);
        printf("EVENT %s %s %s caps %s\n", pipeline_name, element_name, name, gst_caps_to_string(caps));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_QOS)
    {
        const char* const names[] = { "OVERFLOW", "UNDERFLOW", "THROTTLE" };
        GstQOSType type;
        gdouble proportion;
        GstClockTimeDiff diff;
        GstClockTime timestamp;
        gst_event_parse_qos(event, &type, &proportion, &diff, &timestamp);
        printf("EVENT %s %s %s qos %s %.3f %lld %llu\n", pipeline_name, element_name, name, names[type], proportion, present_time(diff), present_time(timestamp));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_SEGMENT)
    {
        const GstSegment* segment;
        gst_event_parse_segment (event, &segment);
        printf("EVENT %s %s %s segment %.3f %.3f %.3f\n", pipeline_name, element_name, name, present_time(segment->start), present_time(segment->stop), present_time(segment->duration));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_LATENCY)
    {
        GstClockTime latency;
        gst_event_parse_latency (event, &latency);
        printf("EVENT %s %s %s latency %.3f\n", pipeline_name, element_name, name, present_time(latency));
    }
    else
        printf("EVENT %s %s %s %s\n", pipeline_name, element_name, name, GST_EVENT_TYPE_NAME(event));
    g_free(name);
    g_free(element_name);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static void gst_monitor_pad(GstPipeline* pipeline, GstElement* elem, char* name)
{
    GstPad *pad = gst_element_get_static_pad(elem, name);
    gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_have_data, pipeline, NULL);
    gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_EVENT_BOTH, (GstPadProbeCallback) cb_have_event, pipeline, NULL);
    gst_object_unref(pad);
}

static void gst_present_message(GstMessage *msg)
{
    switch (GST_MESSAGE_TYPE(msg)) {

        case GST_MESSAGE_EOS: {
            g_print("MESSAGE eos\n");
            break;
        }
        case GST_MESSAGE_ERROR: {
            gchar  *debug;
            GError *error;
            gst_message_parse_error(msg, &error, &debug);
            g_free(debug);
            g_printerr("MESSAGE error %s\n", error->message);
            g_error_free(error);
            break;
        }
        case GST_MESSAGE_STATE_CHANGED: {
            GstState old_state, new_state;
            gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
            g_print("MESSAGE state-changed %s from %s to %s\n",
                GST_OBJECT_NAME(msg->src),
                gst_element_state_get_name(old_state),
                gst_element_state_get_name(new_state));
            break;
        }
        case GST_MESSAGE_STREAM_STATUS: {
            const char* const names[] = { "CREATE", "ENTER", "LEAVE", "DESTROY", "START", "PAUSE", "STOP" };
            GstStreamStatusType type;
            GstElement *owner;
            gst_message_parse_stream_status(msg, &type, &owner);
            g_print("MESSAGE stream-status %s %s\n",
                GST_OBJECT_NAME(owner),
                names[type]);
            break;
        }
        case GST_MESSAGE_QOS: {
            GstFormat format;
            guint64 rendered, dropped;
        
            gst_message_parse_qos_stats(msg, &format, &rendered, &dropped);
            if (format == GST_FORMAT_UNDEFINED)
                printf("MESSAGE qos UNDEFINED\n");
            else
                printf("MESSAGE qos %llu %llu\n", rendered, dropped);
        }
        default: {
            printf("MESSAGE %s %s\n",
                GST_MESSAGE_TYPE_NAME(msg),
                GST_OBJECT_NAME(msg->src));
            break;
        }
    }
}

static GstState gst_state_changed_new_state(GstMessage *msg)
{
    GstState old_state, new_state;
    gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
    return new_state;
}

static int gst_pull_app_sink(GstElement* elem, void* data, ___SCMOBJ info)
{
    int size = -1;
    ___U64 *info_ptr = ___CAST(___U64*, ___BODY(info));
    GstSample *sample;
    sample = gst_app_sink_try_pull_sample(GST_APP_SINK(elem), 0);
    if (sample)
    {
        GstBuffer* buffer = gst_sample_get_buffer(sample);
        if (buffer)
        {
            GstMapInfo map;
            gst_buffer_map(buffer, &map, GST_MAP_READ);
            memmove(data, map.data, map.size);
            size = map.size;
            gst_buffer_unmap(buffer, &map);
            
            info_ptr[0] = GST_BUFFER_PTS(buffer);
            info_ptr[1] = GST_BUFFER_DURATION(buffer);
            GstClock* clock = gst_element_get_clock(elem);
            GstClockTime base_time = gst_element_get_base_time(elem);
            GstClockTime abs_time = gst_clock_get_time(clock);
            GstPipeline* pipeline = (GstPipeline*) GST_ELEMENT_PARENT(elem);
            // printf("%llu %llu %llu %llu %llu %d %llu %llu\n", base_time, abs_time, GST_BUFFER_PTS(buffer), GST_BUFFER_DTS(buffer), GST_BUFFER_DURATION(buffer), GST_BUFFER_OFFSET(buffer), gst_clock_get_time(gst_pipeline_get_clock(pipeline)), gst_clock_get_time(gst_pipeline_get_pipeline_clock(pipeline)));
        }
        gst_sample_unref(sample);
    }
    return size;
}

static int gst_read_app_sink(GstElement* elem, ___SCMOBJ vec, ___SCMOBJ info)
{
    ___U8 *ptr = ___CAST(___U8*, ___BODY(vec));
    return gst_pull_app_sink(elem, (void*) ptr, info);
}

static void gst_setup_app_src(GstElement* appsrc, char* type, int width, int height, int framerate)
{
    gst_app_src_set_caps(GST_APP_SRC(appsrc),
        gst_caps_new_simple(type,
            "width", G_TYPE_INT, width,
            "height", G_TYPE_INT, height,
            "framerate", GST_TYPE_FRACTION, framerate, 1,
            "stream-format", G_TYPE_STRING, "avc",
            "alignment", G_TYPE_STRING, "au",
            NULL));
    g_object_set(G_OBJECT(appsrc),
        "stream-type", GST_APP_STREAM_TYPE_STREAM,
        "format", GST_FORMAT_TIME,
        NULL);
}

static void gst_setup_app_src2(GstElement* appsrc, char* type, char* format, int width, int height, int framerate)
{
    gst_app_src_set_caps(GST_APP_SRC(appsrc),
        gst_caps_new_simple(type,
            "format", G_TYPE_STRING, format,
            "width", G_TYPE_INT, width,
            "height", G_TYPE_INT, height,
            "framerate", GST_TYPE_FRACTION, framerate, 1,
            NULL));
    g_object_set(G_OBJECT(appsrc),
        "stream-type", GST_APP_STREAM_TYPE_STREAM,
        "format", GST_FORMAT_TIME,
        NULL);
}

static GstFlowReturn gst_write_app_src(GstElement* elem, ___SCMOBJ vec, int size, ___U64 timestamp, ___U64 duration)
{
    // static GstClockTime timestamp = 0;
    ___U8 *ptr = ___CAST(___U8*, ___BODY(vec));
    GstBuffer *buffer = gst_buffer_new_allocate(NULL, size, NULL);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_WRITE);
    memmove(map.data, ptr, size);
    gst_buffer_unmap(buffer, &map);
    GST_BUFFER_PTS(buffer) = timestamp;
    GST_BUFFER_DTS(buffer) = timestamp;
    GST_BUFFER_DURATION(buffer) = duration;
    // GST_BUFFER_PTS(buffer) = timestamp;
    // GST_BUFFER_DTS(buffer) = timestamp;
    // GST_BUFFER_DURATION(buffer) = 200000000;
    // timestamp += GST_BUFFER_DURATION(buffer);
    return gst_app_src_push_buffer(GST_APP_SRC(elem), buffer);
}

static void copy_to_texture(___SCMOBJ vec, int len, void* data)
{
    memmove(data, ___BODY(vec), len);
}
//#)


(c-external (gst_debug_pipeline (call GST_PIPELINE GstElement*)) void)
(c-external (gst_debug_pad GstElement* char-string) void)
(c-external (gst_monitor_pad (call GST_PIPELINE GstElement*) GstElement* char-string) void)
(c-external (gst_present_message GstMessage*) void)
(c-external (gst_state_changed_new_state GstMessage*) GstState)
(c-external (gst_present_time GstClockTime) double "present_time")
(c-external (gst_app_src_set_stream_type (call GST_APP_SRC GstElement*) GstAppStreamType) void)
(c-external (gst_pull_app_sink GstElement* void* scheme-object) int)
(c-external (gst_read_app_sink GstElement* scheme-object scheme-object) int)
(c-external (gst_setup_app_src GstElement* char-string int int int) void)
(c-external (gst_setup_app_src2 GstElement* char-string char-string int int int) void)
(c-external (gst_write_app_src GstElement* scheme-object int uint64 uint64) GstFlowReturn)
(c-external (copy_to_texture scheme-object int void*) void)


(definition public (gst_monitor_element pipeline elem)
  (gst_monitor_pad pipeline elem "sink")
  (gst_monitor_pad pipeline elem "src"))


;;;
;;;; OpenGL
;;;


@opengl (
(c-type GstContext  (native "GstContext"))
(c-type GstContext* (pointer GstContext GstContext*))


(c-declare world.foreign.gstreamer #/C/
#define GST_USE_UNSTABLE_API

#include <gst/gst.h>
#include <gst/gl/gl.h>
#include <gst/app/gstappsink.h>

GstGLDisplay *gst_gl_display = NULL;
GstGLContext *gst_gl_context = NULL;
CGLContextObj my_context = NULL;

static void gst_setup_gl()
{
    GstGLDisplay *display = gst_gl_display_new();
    CGLContextObj context = CGLGetCurrentContext();
    printf("current display: %p\n", display);
    printf("current context: %p\n", context);
    CGLSetCurrentContext(NULL);
    GstGLContext *new_context;
    GstGLDisplay *new_display;
    new_display = gst_gl_display_new();
    new_context = gst_gl_context_new_wrapped(new_display, (guintptr) context, GST_GL_PLATFORM_CGL, GST_GL_API_OPENGL);
    printf("new display: %p\n", new_display);
    printf("new context: %p\n", new_context);
    // printf("new context shared: %d\n", gst_gl_context_is_shared(new_context));
    // printf("%p %p\n", display, new_context);
    gst_gl_display = new_display;
    gst_gl_context = new_context;
    my_context = context;
}

static gboolean sync_bus_call (GstBus * bus, GstMessage * msg, gpointer data)
{
  switch (GST_MESSAGE_TYPE (msg)) {
    case GST_MESSAGE_NEED_CONTEXT:
    {
      const gchar *context_type;

      gst_message_parse_context_type (msg, &context_type);
      g_print ("got need context %s\n", context_type);

      if (g_strcmp0 (context_type, GST_GL_DISPLAY_CONTEXT_TYPE) == 0) {
        g_print ("111\n");
        GstContext *display_context =
            gst_context_new (GST_GL_DISPLAY_CONTEXT_TYPE, TRUE);
        gst_context_set_gl_display (display_context, gst_gl_display);
        gst_element_set_context (GST_ELEMENT (msg->src), display_context);
        return TRUE;
      } else if (g_strcmp0 (context_type, "gst.gl.app_context") == 0) {
        g_print ("222\n");
        GstContext *app_context = gst_context_new ("gst.gl.app_context", TRUE);
        GstStructure *s = gst_context_writable_structure (app_context);
        gst_structure_set (s, "context", GST_GL_TYPE_CONTEXT, gst_gl_context,
            NULL);
        gst_element_set_context (GST_ELEMENT (msg->src), app_context);
        return TRUE;
      }
      break;
    }
    default:
      break;
  }
  return FALSE;
}

static void gst_setup_callback(GstElement* pipeline)
{
    GstBus *bus = NULL;
    bus = gst_pipeline_get_bus(GST_PIPELINE (pipeline));
    gst_bus_add_signal_watch(bus);
    gst_bus_enable_sync_message_emission(bus);
    g_signal_connect(bus, "sync-message", G_CALLBACK (sync_bus_call), NULL);
    gst_object_unref(bus);
    
    /* NULL to PAUSED state pipeline to make sure the gst opengl context is created and
     * shared with the sdl one */
    gst_element_set_state (GST_ELEMENT (pipeline), GST_STATE_PAUSED);
  
    CGLSetCurrentContext(my_context);
}

unsigned int
get_texture_id_from_buffer (GstBuffer * buf)
{
  GstMapInfo mapinfo;
  unsigned int texture = 0;

  if (!gst_buffer_map (buf, &mapinfo, (GstMapFlags) (GST_MAP_READ | GST_MAP_GL))) {
    g_warning ("Failed to map the video buffer");
    return texture;
  }

  texture = (unsigned int) mapinfo.data[0];

  gst_buffer_unmap (buf, &mapinfo);

  return texture;
}

// mega quicky for test
unsigned int textureId = 0;

static GstFlowReturn new_sample(GstElement* elem, gpointer user_data)
{
    GstSample *sample;
    GstBuffer *buffer;
    sample = gst_app_sink_pull_sample(GST_APP_SINK(elem));
    buffer = gst_sample_get_buffer(sample);
    unsigned int id = get_texture_id_from_buffer(buffer);
    textureId = id;
    // printf("%i\n", id);
    return GST_FLOW_OK;
}

static unsigned int get_texture_id()
{
    return textureId;
}

static gulong gst_appsink_connect_to(gpointer instance, char* signal, gpointer data)
{
    return g_signal_connect(instance, signal, G_CALLBACK(new_sample), data);
}
//#)


(c-external (gst_setup_gl) void)
(c-external (gst_setup_callback GstElement*) void)
(c-external (get_texture_id) uint)
(c-external (gst_appsink_connect_to gpointer char-string NULL) gulong)


(definition public (init-gstreamer)
  (startup-gstreamer)
  (gst_setup_gl))


(definition public (stream-video (width: width 1920) (height: height 1080) (framerate: framerate 60))
  (declare (proper-tail-calls))
  (let ((pipeline (gst_parse_launch (format "videotestsrc ! video/x-raw, width={a}, height={a}, framerate={a}/1 ! queue max-size-buffers=3 ! glupload ! appsink caps=\"video/x-raw(memory:GLMemory), format=RGBA\" emit-signals=true name=appsink" width height framerate))))
    (gst_setup_callback pipeline)
    (let ((appsink (gst_bin_get_by_name pipeline "appsink")))
      ;(gst_appsink_connect_to appsink "new-sample")
      (gst_element_set_state pipeline GST_STATE_PLAYING)
      (thread-start!
        (new-thread
          (lambda ()
            (declare (proper-tail-calls))
            (let ((previous-id 0))
              (let (loop)
                (let ((id (get_texture_id)))
                  (when (/= id previous-id)
                    ;(gst_element_set_state pipeline GST_STATE_PAUSED)
                    (terminal id)
                    (set! previous-id id)))
                (sleep .01)
                (loop)))))))))))
