;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Foreign
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.foreign jazz


(import (jazz.foreign)
        (jazz.opengl.glew)
        (jazz.platform.types))


(c-external (test-malloc int) void*
  #/C/
    ___result = malloc(___arg1);
//#)


(c-include "<cstdio>")
(c-include "<stdlib.h>")
(c-include "<string.h>")
(c-include "<GL/glew.h>")


(c-external (sizeof-size_t) int
  #/C/
    ___result = sizeof(size_t);
//#)

(c-external (sizeof-float) int
  #/C/
    ___result = sizeof(float);
//#)

(c-external (sizeof-double) int
  #/C/
    ___result = sizeof(double);
//#)


(definition public size_t-size <fx>
  (sizeof-size_t))

(definition public float-size <fx>
  (sizeof-float))

(definition public double-size <fx>
  (sizeof-double))


(c-external (still-obj-refcount scheme-object) int
  #/C/
#define ___STILL_BODY_OFS 6
#define ___STILL_REFCOUNT_OFS 1
    ___result = ___UNTAG(___arg1)[___BODY_OFS - ___STILL_BODY_OFS + ___STILL_REFCOUNT_OFS];
//#)


(c-external (load-crg char-string int long) scheme-object
  #/C/
    FILE *f = fopen(___arg1, "rb");
    long size = ___arg3;

    ___SCMOBJ r = ___EXT(___alloc_scmobj) (___ps, ___sU8VECTOR, size);
    ___U8 *ptr = ___CAST(___U8*,___BODY(r));
    fseek(f, ___arg2, SEEK_SET);
    fread(ptr, size, 1, f);
    fclose(f);

    ___result = r;
    ___EXT(___release_scmobj)(r);
//#)


(c-external (still-u8vector-body scheme-object) void*
  #/C/
    ___U8 *ptr = ___CAST(___U8*,___BODY(___arg1));
    ___result_voidstar = ptr;
//#)


(c-external (save-crg char-string void* int) void
  #/C/
    ___U8 *ptr = (___U8 *) ___arg2;
    int size = ___arg3;
    FILE *f = fopen(___arg1, "ab");

    fwrite(ptr, 1, size, f);
    fclose(f);
//#)


(c-external (u8vector-find int scheme-object int int) scheme-object
  #/C/
    int target = ___arg1;
    ___U8 *vec = ___CAST(___U8*,___BODY(___arg2));
    int len = ___arg3;
    int from = ___arg4;
    if (from >= len)
        ___result = ___FAL;
    else
    {
        ___U8 *ptr = vec + from;
        void* res = memchr((const void*) ptr, target, len - from);
        if (res)
            ___result = ___FIX((___U8*) res - vec);
        else
            ___result = ___FAL;
    }
//#)


(c-external (subu8vector->foreign scheme-object int int) void*
  #/C/
    ___U8 *ptr = ___CAST(___U8*,___BODY(___arg1));
    int from = ___arg2;
    int to = ___arg3;
    int size = to - from;
    ___U8 *foreign = malloc(size);
    memcpy(foreign, ptr + from, size);
    ___result = foreign;
//#)


(c-external (BGRA-premultiply-alpha scheme-object int int bool) void*
  #/C/
    ___U8 *ptr = ___CAST(___U8*,___BODY(___arg1));
    int from = ___arg2;
    int to = ___arg3;
    int premultiply = ___arg4;
    int size = to - from;
    ___U8 *foreign = malloc(size);
    memcpy(foreign, ptr + from, size);
    if (premultiply)
    {
        int i, b, g, r, a;
        float alpha;
        for (i = 0; i < size; i += 4)
        {
            b = foreign[i];
            g = foreign[i+1];
            r = foreign[i+2];
            a = foreign[i+3];
            alpha = ((float) a) / 255.;
            foreign[i]   = ((float) b) * alpha;
            foreign[i+1] = ((float) g) * alpha;
            foreign[i+2] = ((float) r) * alpha;
        }
    }
    ___result = foreign;
//#)


(c-external (set-pixel void* int float float float float) void
  #/C/
    int n = ___arg2;
    float r = ___arg3;
    float g = ___arg4;
    float b = ___arg5;
    float a = ___arg6;
    ___U8 *ptr = ___CAST(___U8*, ___arg1) + n * 4;
    *ptr++ = (___U8) (b * 255);
    *ptr++ = (___U8) (g * 255);
    *ptr++ = (___U8) (r * 255);
    *ptr = (___U8) (a * 255);
//#)


@opengl-debugging
(c-declare world.foreign #/C/
BOOL logging = TRUE;

FILE *logfile = NULL;

static void print(char* string)
{
    if (logging)
    {
        if (!logfile)
            logfile = fopen("log.txt", "w");
        
        fprintf(logfile, string);
        fflush(logfile);
    }
}

static void vprint(char* format, va_list arguments)
{
    if (logging)
    {
        if (!logfile)
            logfile = fopen("log.txt", "w");
        
        vfprintf(logfile, format, arguments);
        fflush(logfile);
    }
}

static void printlog(char* format, ...)
{
    va_list arguments;

    va_start(arguments, format);
    vprint(format, arguments);
    print("\n");
    va_end(arguments);
}
//#)


@opengl-debugging
(c-declare world.foreign #/C/
static void message_callback(GLenum source,
                             GLenum type,
                             GLuint id,
                             GLenum severity,
                             GLsizei length,
                             const GLchar* message,
                             GLvoid* userParam)
{
    printlog("%s", message);
}
//#)


@opengl-debugging
(c-external (gl-setup-debugging) int
  #/C/
    // glDebugMessageEnableAMD(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, NULL, GL_TRUE);
    glDebugMessageCallbackAMD(&message_callback, NULL);
    glDebugMessageInsertAMD(GL_DEBUG_CATEGORY_OTHER_AMD, GL_DEBUG_SEVERITY_LOW_AMD, 0, 5, "hello world");
//#)


(c-external (glGenFramebuffers*) GLuint
  #/C/
    GLuint buffer;
    glGenFramebuffers(1, &buffer);
    ___result = buffer;
//#)
   
   
(c-external (glGenRenderbuffers*) GLuint
  #/C/
    GLuint buffer;
    glGenRenderbuffers(1, &buffer);
    ___result = buffer;
//#)


(c-external (glDeleteTextures* GLuint) void
  #/C/
    glDeleteTextures(1, &___arg1);
//#)


(c-external (glDeleteRenderbuffers* GLuint) void
  #/C/
    glDeleteRenderbuffers(1, &___arg1);
//#)


(c-external (glDeleteFramebuffers* GLuint) void
  #/C/
    glDeleteFramebuffers(1, &___arg1);
//#)


(c-external (glDeleteBuffers* GLuint) void
  #/C/
    glDeleteBuffers(1, &___arg1);
//#)


(c-external (glDeleteVertexArrays* GLuint) void
  #/C/
    glDeleteVertexArrays(1, &___arg1);
//#)


(c-external (glGenVertices*) GLuint
  #/C/
    GLuint vbo_fbo_vertices = 0;
    GLfloat fbo_vertices[] = {
      -1, -1,
       1, -1,
      -1,  1,
       1,  1,
    };
    glGenBuffers(1, &vbo_fbo_vertices);
    glBindBuffer(GL_ARRAY_BUFFER, vbo_fbo_vertices);
    glBufferData(GL_ARRAY_BUFFER, sizeof(fbo_vertices), fbo_vertices, GL_STATIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    ___result = vbo_fbo_vertices;
//#)


(c-external (glGetShaderInfoLog* GLuint GLsizei) char-string
  #/C/
    GLchar* log = (GLchar*)malloc(___arg2);
    GLsizei slen = 0;
    glGetShaderInfoLog(___arg1, ___arg2, &slen, log);
    ___result = log;
//#)


(c-external (glGetProgramInfoLog* GLuint GLsizei) char-string
  #/C/
    GLchar* log = (GLchar*)malloc(___arg2);
    GLsizei slen = 0;
    glGetProgramInfoLog(___arg1, ___arg2, &slen, log);
    ___result = log;
//#)


;;;
;;;; Random
;;;


(c-declare world.foreign
  #/C/
    ___S64 multiplier = 0x5DEECE66D;
    ___S64 addend = 0xB;
    ___S64 mask = ((___S64) 1 << 48) - 1;
    ___S64 seedUniquifier = 8682522807148012;
    
    void setSeed(___S64* thisSeed, ___S64 seed)
    {
        seed = ((seed) ^ multiplier) & mask;
        *thisSeed = seed;
    }

    ___S32 next(___S64* thisSeed, ___S32 bits)
    {
        ___S64 oldseed, nextseed;
        oldseed = *thisSeed;
        nextseed = (oldseed * multiplier + addend) & mask;
        *thisSeed = nextseed;
        return (___S32)((___U64) nextseed >> (48 - bits));
    }
    
    ___S32 randomInt(___S64* thisSeed, ___S32 n)
    {
        if ((n & -n) == n)
            return (___S32)((n * (___S64)next(thisSeed, 31)) >> 31);
        else
        {
            ___S32 bits, val;
            do {
                bits = next(thisSeed, 31);
                val = bits % n;
            } while (bits - val + (n-1) < 0);
            
            return val;
        }
    }
//#)


(c-external (newRandom int64) int64*
  #/C/
    ___S64 seed = ___arg1;
    ___S64* thisSeed = (___S64*) malloc(sizeof(___S64));
    *thisSeed = 0;
    setSeed(thisSeed, seed);
    ___result = thisSeed;
//#)


(c-external (setSeed int64* int64) void
  #/C/
    setSeed(___arg1, ___arg2);
//#)


(c-external (setSeedAux int64* int32 int32 int64 int64 int64) void
  #/C/
    ___S64 j1 = (___S64)___arg2 * ___arg4;
    ___S64 k1 = (___S64)___arg3 * ___arg5;
    setSeed(___arg1, j1 ^ k1 ^ ___arg6);
//#)


(c-external (randomLong int64*) int64
  #/C/
    ___S64* thisSeed = ___arg1;
    ___result = ((___S64)(next(thisSeed, 32)) << 32) + next(thisSeed, 32);
//#)


(c-external (randomInt int64* int32) int32 <fx>
  #/C/
    ___result = randomInt(___arg1, ___arg2);
//#)


(definition public (randomIntBetween rand min <fx> max <fx>) <fx>
  (+ min (randomInt rand (+ (- max min) 1))))


(definition public (randomBool rand) <bool>
  (= (randomInt rand 2) 1))


(c-external (randomFloat int64*) float <fl>
  #/C/
    ___S64* thisSeed = ___arg1;
    ___result = next(thisSeed, 24) / ((float)((___S64) 1 << 24));
//#)


;;;
;;;; Generation
;;;


(c-declare world.foreign
  #/C/
    ___S64 worldSeed;
    ___S64 chunkSeed;
    
    void initChunkSeed(___S64 arg1, ___S64 arg2)
    {
        chunkSeed = worldSeed;
        chunkSeed *= chunkSeed * 6364136223846793005 + 1442695040888963407;
        chunkSeed += arg1;
        chunkSeed *= chunkSeed * 6364136223846793005 + 1442695040888963407;
        chunkSeed += arg2;
        chunkSeed *= chunkSeed * 6364136223846793005 + 1442695040888963407;
        chunkSeed += arg1;
        chunkSeed *= chunkSeed * 6364136223846793005 + 1442695040888963407;
        chunkSeed += arg2;
    }
    
    ___S32 nextInt(___S32 n)
    {
        ___S32 i = (___S32)((chunkSeed >> 24) % (___S64) n);
    
        if (i < 0)
        {
            i += n;
        }
    
        chunkSeed *= chunkSeed * 6364136223846793005 + 1442695040888963407;
        chunkSeed += worldSeed;
        
        return i;
    }
//#)


(c-external (worldSeed) int64
  #/C/
    ___result = worldSeed;
//#)


(c-external (initWorldSeed int64) void
  #/C/
    worldSeed = ___arg1;
//#)


(c-external (initChunkSeed int64 int64) void
  #/C/
    initChunkSeed(___arg1, ___arg2);
//#)


(c-external (nextInt int32) int32 <fx>
  #/C/
    ___result = nextInt(___arg1);
//#)


;;;
;;;; Layer
;;;


(c-declare world.foreign
  #/C/
#define DEEP_OCEAN 24

int selectRandom(int a, int b)
{
    if (nextInt(2) == 0)
        return a;
    else
        return b;
}

int selectModeOrRandom(int a, int b, int c, int d, ___BOOL fuzzy)
{
    int values[] = {a, b, c, d};
  
    if (fuzzy)
        return values[nextInt(4)];
    else
        return b == c && c == d ? b : (a == b && a == c ? a : (a == b && a == d ? a : (a == c && a == d ? a : (a == b && c != d ? a : (a == c && b != d ? a : (a == d && b != c ? a : (b == c && a != d ? b : (b == d && a != c ? b : (c == d && a != b ? c : values[nextInt(4)])))))))));
}
//#)


(c-external (zoomLayer int int int int scheme-object scheme-object scheme-object bool) void
  #/C/
    int areaX = ___arg1;
    int areaY = ___arg2;
    int areaWidth = ___arg3;
    int areaHeight = ___arg4;
    ___S32* pint = ___CAST(___S32*, ___BODY(___arg5));
    ___S32* aint = ___CAST(___S32*, ___BODY(___arg6));
    ___S32* aint2 = ___CAST(___S32*, ___BODY(___arg7));
    ___BOOL fuzzy = ___arg8;
    
    int i = areaX >> 1;
    int j = areaY >> 1;
    int k = (areaWidth >> 1) + 2;
    int l = (areaHeight >> 1) + 2;
    int i1 = k - 1 << 1;
    int j1 = l - 1 << 1;

    for (int k1 = 0; k1 < l - 1; ++k1)
    {
        int l1 = (k1 << 1) * i1;
        int i2 = 0;
        int j2 = pint[i2 + 0 + (k1 + 0) * k];

        for (int k2 = pint[i2 + 0 + (k1 + 1) * k]; i2 < k - 1; ++i2)
        {
            initChunkSeed((i2 + i << 1), (k1 + j << 1));
            int l2 = pint[i2 + 1 + (k1 + 0) * k];
            int i3 = pint[i2 + 1 + (k1 + 1) * k];
            aint[l1] = j2;
            aint[l1++ + i1] = selectRandom(j2, k2);
            aint[l1] = selectRandom(j2, l2);
            aint[l1++ + i1] = selectModeOrRandom(j2, l2, k2, i3, fuzzy);
            j2 = l2;
            k2 = i3;
        }
    }

    for (int j3 = 0; j3 < areaHeight; ++j3)
    {
        memcpy(aint2 + (j3 * areaWidth), aint + ((j3 + (areaY & 1)) * i1 + (areaX & 1)), areaWidth * sizeof(___S32));
    }
//#)


(c-external (smoothLayer int int int int scheme-object scheme-object) void
  #/C/
    int areaX = ___arg1;
    int areaY = ___arg2;
    int areaWidth = ___arg3;
    int areaHeight = ___arg4;
    ___S32* pint = ___CAST(___S32*, ___BODY(___arg5));
    ___S32* aint = ___CAST(___S32*, ___BODY(___arg6));
    
    int i = areaX - 1;
    int j = areaY - 1;
    int k = areaWidth + 2;
    int l = areaHeight + 2;

    for (int i1 = 0; i1 < areaHeight; ++i1)
    {
        for (int j1 = 0; j1 < areaWidth; ++j1)
        {
            int k1 = pint[j1 + 0 + (i1 + 1) * k];
            int l1 = pint[j1 + 2 + (i1 + 1) * k];
            int i2 = pint[j1 + 1 + (i1 + 0) * k];
            int j2 = pint[j1 + 1 + (i1 + 2) * k];
            int k2 = pint[j1 + 1 + (i1 + 1) * k];

            if (k1 == l1 && i2 == j2)
            {
                initChunkSeed((j1 + areaX), (i1 + areaY));

                if (nextInt(2) == 0)
                {
                    k2 = k1;
                }
                else
                {
                    k2 = i2;
                }
            }
            else
            {
                if (k1 == l1)
                {
                    k2 = k1;
                }

                if (i2 == j2)
                {
                    k2 = i2;
                }
            }

            aint[j1 + i1 * areaWidth] = k2;
        }
    }
//#)


(c-external (deepOceanLayer int int int int scheme-object scheme-object) void
  #/C/
    int areaX = ___arg1;
    int areaY = ___arg2;
    int areaWidth = ___arg3;
    int areaHeight = ___arg4;
    ___S32* pint = ___CAST(___S32*, ___BODY(___arg5));
    ___S32* aint = ___CAST(___S32*, ___BODY(___arg6));
    
    int i = areaX - 1;
    int j = areaY - 1;
    int k = areaWidth + 2;
    int l = areaHeight + 2;

    for (int i1 = 0; i1 < areaHeight; ++i1)
    {
        for (int j1 = 0; j1 < areaWidth; ++j1)
        {
            int k1 = pint[j1 + 1 + (i1 + 1 - 1) * (areaWidth + 2)];
            int l1 = pint[j1 + 1 + 1 + (i1 + 1) * (areaWidth + 2)];
            int i2 = pint[j1 + 1 - 1 + (i1 + 1) * (areaWidth + 2)];
            int j2 = pint[j1 + 1 + (i1 + 1 + 1) * (areaWidth + 2)];
            int k2 = pint[j1 + 1 + (i1 + 1) * k];
            int l2 = 0;

            if (k1 == 0)
            {
                ++l2;
            }

            if (l1 == 0)
            {
                ++l2;
            }

            if (i2 == 0)
            {
                ++l2;
            }

            if (j2 == 0)
            {
                ++l2;
            }

            if (k2 == 0 && l2 > 3)
            {
                aint[j1 + i1 * areaWidth] = DEEP_OCEAN;
            }
            else
            {
                aint[j1 + i1 * areaWidth] = k2;
            }
        }
    }
//#)


;;;
;;;; Variation
;;;


(c-declare world.foreign
  #/C/
double smooth(double x)
{
    return x * x * x * ((x * (x * 6 - 15)) + 10);
}

void smoothandfloor(double offset, int* a, double* b, double* c)
{
    int x = offset;
    double diff = offset - x;
    *a = x & 255;
    *b = diff;
    *c = smooth(diff);
}

double grad_x[] = {1., -1., 1., -1., 1., -1., 1., -1., 0., 0., 0., 0., 1., 0., -1., 0.};
double grad_y[] = {1., 1., -1., -1., 0., 0., 0., 0., 1., -1., 1., -1., 1., -1., 1., -1.};
double grad_z[] = {0., 0., 0., 0., 1., 1., -1., -1., 1., 1., -1., -1., 0., 1., 0., -1.};

double grad(int index, double x, double y, double z)
{
    int i = index & 15;
    return grad_x[i] * x + grad_y[i] * y + grad_z[i] * z;
}

double grad2d(int index, double x, double z)
{
    int i = index & 15;
    return grad_x[i] * x + grad_z[i] * z;
}

double lerp(double a, double b, double w)
{
    return a  + w * (b - a);
}

#define permute(x) permutations[x]
//#)


(c-external (generateOctaves scheme-object scheme-object double double double double double double int int int double double double double) void
  #/C/
    ___F64* noise = ___CAST(___F64*, ___BODY(___arg1));
    ___S32* permutations = ___CAST(___S32*, ___BODY(___arg2));
    double x_coord = ___arg3;
    double y_coord = ___arg4;
    double z_coord = ___arg5;
    double x_offset = ___arg6;
    double y_offset = ___arg7;
    double z_offset = ___arg8;
    int x_size = ___arg9;
    int y_size = ___arg10;
    int z_size = ___arg11;
    double x_scale = ___arg12;
    double y_scale = ___arg13;
    double z_scale = ___arg14;
    double scaling = ___arg15;
    
    if (y_size == 1)
    {
        int j = 0;
        int i5 = 0;
        int j5 = 0;
        int k5 = 0;
        double d14 = 0.;
        double d15 = 0.;
        double d21 = 0.;
        int index = 0;
        for (int x = 0; x < x_size; x++)
        {
            int k2;
            double d17;
            double d18;
            smoothandfloor(x_offset + x * x_scale + x_coord, &k2, &d17, &d18);
            for (int z = 0; z < z_size; z++)
            {
                int l6;
                double d19;
                double d20;
                smoothandfloor(z_offset + z * z_scale + z_coord, &l6, &d19, &d20);
                i5 = permute(k2);
                j5 = permute(i5) + l6;
                j = permute(k2 + 1);
                k5 = permute(j) + l6;
                d14 = lerp(grad2d(permute(j5), d17, d19), grad2d(permute(k5), d17 - 1, d19), d18);
                d15 = lerp(grad2d(permute(j5 + 1), d17, d19 - 1), grad2d(permute(k5 + 1), d17 - 1, d19 - 1), d18);
                d21 = lerp(d14, d15, d20);
                noise[index] = noise[index] + d21 / scaling;
                index++;
            }
        }
    }
    else
    {
        int k = -1;
        int l = 0;
        int i1 = 0;
        int j1 = 0;
        int k1 = 0;
        int l1 = 0;
        int i2 = 0;
        double d1 = 0.;
        double d2 = 0.;
        double d3 = 0.;
        double d4 = 0.;
        double d11 = 0.;
        double d12 = 0.;
        double d13 = 0.;
        int index = 0;
        for (int x = 0; x < x_size; x++)
        {
            int j3;
            double d5;
            double d6;
            smoothandfloor(x_offset + x * x_scale + x_coord, &j3, &d5, &d6);
            for (int z = 0; z < z_size; z++)
            {
                int i4;
                double d7;
                double d8;
                smoothandfloor(z_offset + z * z_scale + z_coord, &i4, &d7, &d8);
                for (int y = 0; y < y_size; y++)
                {
                    int l4;
                    double d9;
                    double d10;
                    smoothandfloor(y_offset + y * y_scale + y_coord, &l4, &d9, &d10);
                    if ((y == 0) || (l4 != k))
                    {
                        k = l4;
                        l = permute(j3) + l4;
                        i1 = permute(l) + i4;
                        j1 = permute(l + 1) + i4;
                        k1 = permute(j3 + 1) + l4;
                        l1 = permute(k1) + i4;
                        i2 = permute(k1 + 1) + i4;
                        d1 = lerp(grad(permute(i1), d5, d9, d7), grad(permute(l1), d5 - 1, d9, d7), d6);
                        d2 = lerp(grad(permute(j1), d5, d9 - 1, d7), grad(permute(i2), d5 - 1, d9 - 1, d7), d6);
                        d3 = lerp(grad(permute(i1 + 1), d5, d9, d7 - 1), grad(permute(l1 + 1), d5 - 1, d9, d7 - 1), d6);
                        d4 = lerp(grad(permute(j1 + 1), d5, d9 - 1, d7 - 1), grad(permute(i2 + 1), d5 - 1, d9 - 1, d7 - 1), d6);
                    }
                    d11 = lerp(d1, d2, d10);
                    d12 = lerp(d3, d4, d10);
                    d13 = lerp(d11, d12, d8);
                    noise[index] = noise[index] + d13 / scaling;
                    index++;
                }
            }
        }
    }
  //#))
