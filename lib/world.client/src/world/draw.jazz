;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Draw
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.draw jazz


(import (jazz.geometry)
        (jazz.graphic.opengl.glew)
        (world)
        (world.autoload)
        (world.dye)
        (world.foreign)
        (world.geometry)
        (world.homogeneous)
        (world.opengl)
        (world.parallelepiped)
        (world.plane)
        (world.polygon)
        (world.shape)
        (world.syntax (phase syntax)))


(definition public (gl-pixel point color)
  (let ((x (cast <fl> (get-h~ point)))
        (y (cast <fl> (get-v~ point))))
    (gl-colorize color)
    (glBegin GL_POINTS)
    (glVertex2f x y)
    (glEnd)))


(definition public (gl-line from to color)
  (let ((x1 (cast <fl> (get-h~ from)))
        (y1 (cast <fl> (get-v~ from)))
        (x2 (cast <fl> (get-h~ to)))
        (y2 (cast <fl> (get-v~ to))))
    (gl-colorize color)
    (glBegin GL_LINES)
    (glVertex2f x1 y1)
    (glVertex2f x2 y2)
    (glEnd)))


(definition public (gl-fill-rect rect color)
  (let ((x1 (cast <fl> (get-left~ rect)))
        (y1 (cast <fl> (get-top~ rect)))
        (x2 (cast <fl> (get-right~ rect)))
        (y2 (cast <fl> (get-bottom~ rect))))
    (gl-colorize color)
    (glBegin GL_QUADS)
    (glVertex2f x1 y1)
    (glVertex2f x2 y1)
    (glVertex2f x2 y2)
    (glVertex2f x1 y2)
    (glEnd)))


(definition public (gl-frame-rect rect color)
  (let ((x1 (cast <fl> (get-left~ rect)))
        (y1 (cast <fl> (get-top~ rect)))
        (x2 (cast <fl> (get-right~ rect)))
        (y2 (cast <fl> (get-bottom~ rect))))
    (gl-colorize color)
    (glBegin GL_LINE_LOOP)
    (glVertex2f x1 y1)
    (glVertex2f x2 y1)
    (glVertex2f x2 y2)
    (glVertex2f x1 y2)
    (glEnd)))


(definition public (gl-frame-circle center radius color)
  (let ((x (cast <fl> (get-h~ center)))
        (y (cast <fl> (get-v~ center))))
    (gl-colorize color)
    (glBegin GL_LINE_LOOP)
    (loop (for angle from 0 to 365 by 5)
          (glVertex2f (+ x (* (sin angle) radius))
                      (+ y (* (cos angle) radius))))
    (glEnd)))


(definition public (gl-horizontal-circle center radius color)
  (let ((x (vertex-x center))
        (y (vertex-y center))
        (z (vertex-z center)))
    (gl-colorize color)
    (glBegin GL_LINE_LOOP)
    (loop (for angle <fl> from 0. to PI*2 by (/ PI*2 100.))
          (glVertex3f (+ x (* (sin angle) radius))
                      y
                      (+ z (* (cos angle) radius))))
    (glEnd)))


(definition public (gl-segment-circle center radius color segments)
  (let ((segments (max 3 segments)))
    (let ((cx (cast <fl> (get-h~ center)))
          (cy (cast <fl> (get-v~ center)))
          (theta (/ PI*2 segments)))
      (let ((c (cos theta))
            (s (sin theta))
            (x radius)
            (y 0))
        (gl-colorize color)
        (glBegin GL_LINE_LOOP)
        (loop (for n from 0 below segments)
              (glVertex2f (+ x cx) (+ y cy))
              (let ((t x))
                (set! x (- (* c x) (* s y)))
                (set! y (+ (* s t) (* c y)))))
        (glEnd)))))


;;;
;;;; Colors
;;;


(definition (with-colors color wire-color fill-color proc)
  (define (make-fill-color)
    (let ((color (copy-dye wire-color)))
      (dye-alpha-set! color 0.)
      color))
  
  (let ((wire-color (or color wire-color))
        (fill-color (or color fill-color (make-fill-color))))
    (proc wire-color fill-color)))


;;;
;;;; Quad
;;;


(definition quad-mesh
  #f)

(definition quad-program
  #f)


(definition (prepare-quad)
  (let ((world (current-world)))
    (unless quad-mesh
      (set! quad-program (find-mesh-program~ world 'squareframe))
      (set! quad-mesh (generate-quad-mesh neighbors?: #t))
      (set-array~ quad-mesh (create-array~ quad-program quad-mesh)))))


(definition public (render-quad matrix (color: color #f) (wire-color: wire-color #f) (fill-color: fill-color #f))
  (with-colors color wire-color fill-color
    (lambda (wire-color fill-color)
      (use~ quad-program)
      (bind-uniforms~ quad-program matrix #f 0 0. wire-color: wire-color fill-color: fill-color)
      (glEnable GL_BLEND)
      (glBindVertexArray (get-array~ quad-mesh))
      (glDrawArrays GL_TRIANGLES 0 (get-indices~ (get-vertices-buffer~ quad-mesh)))
      (glBindVertexArray 0)
      (glDisable GL_BLEND)
      (unbind-uniforms~ quad-program)
      (unuse~ quad-program))))


;;;
;;;; Cube
;;;


(definition cube-mesh
  #f)

(definition cube-program
  #f)


(definition (prepare-cube)
  (let ((world (current-world)))
    (unless cube-mesh
      (set! cube-program (find-mesh-program~ world 'squareframe))
      (set! cube-mesh (generate-cube-mesh neighbors?: #t))
      (set-array~ cube-mesh (create-array~ cube-program cube-mesh)))))


(definition public (render-cube matrix (color: color #f) (wire-color: wire-color #f) (fill-color: fill-color #f))
  (with-colors color wire-color fill-color
    (lambda (wire-color fill-color)
      (use~ cube-program)
      (bind-uniforms~ cube-program matrix #f 0 0. wire-color: wire-color fill-color: fill-color)
      (glEnable GL_BLEND)
      ;(glEnable GL_CULL_FACE)
      ;(glCullFace GL_FRONT)
      (glBindVertexArray (get-array~ cube-mesh))
      (glDrawArrays GL_TRIANGLES 0 (get-indices~ (get-vertices-buffer~ cube-mesh)))
      (glBindVertexArray 0)
      ;(glCullFace GL_BACK)
      ;(glDisable GL_CULL_FACE)
      (glDisable GL_BLEND)
      (unbind-uniforms~ cube-program)
      (unuse~ cube-program))))


;;;
;;;; Sphere
;;;


(definition sphere-mesh
  #f)

(definition sphere-program
  #f)


(definition (prepare-sphere)
  (let ((world (current-world)))
    (unless sphere-mesh
      (let ((material (get-block-opaque~ world))
            (uv (f32vector 0. 0. 0. 0. 0. 0. 0. 0.)))
        (set! sphere-program (find-mesh-program~ world 'squareframe))
        (set! sphere-mesh (generate-sphere-mesh 48 24 uv neighbors?: #t material: material))
        (set-array~ sphere-mesh (create-array~ sphere-program sphere-mesh))))))


(definition public (render-sphere matrix (color: color #f) (wire-color: wire-color #f) (fill-color: fill-color #f))
  (with-colors color wire-color fill-color
    (lambda (wire-color fill-color)
      (use~ sphere-program)
      (bind-uniforms~ sphere-program matrix #f 0 0. wire-color: wire-color fill-color: fill-color)
      (glEnable GL_BLEND)
      (glEnable GL_CULL_FACE)
      (glCullFace GL_FRONT)
      (glBindVertexArray (get-array~ sphere-mesh))
      (glDrawArrays GL_TRIANGLES 0 (get-indices~ (get-vertices-buffer~ sphere-mesh)))
      (glBindVertexArray 0)
      (glCullFace GL_BACK)
      (glDisable GL_CULL_FACE)
      (glDisable GL_BLEND)
      (unbind-uniforms~ sphere-program)
      (unuse~ sphere-program))))


;;;
;;;; Cylinder
;;;


(definition cylinder-mesh
  #f)

(definition cylinder-program
  #f)


(definition (prepare-cylinder)
  (let ((world (current-world)))
    (unless cylinder-mesh
      (let ((material (get-block-opaque~ world))
            (uv (f32vector 0. 0. 0. 0. 0. 0. 0. 0.)))
        (set! cylinder-program (find-mesh-program~ world 'squareframe))
        (set! cylinder-mesh (generate-cylinder-mesh 48 24 1. 1. uv neighbors?: #t material: material))
        (set-array~ cylinder-mesh (create-array~ cylinder-program cylinder-mesh))))))


(definition public (render-cylinder matrix (color: color #f) (wire-color: wire-color #f) (fill-color: fill-color #f))
  (with-colors color wire-color fill-color
    (lambda (wire-color fill-color)
      (use~ cylinder-program)
      (bind-uniforms~ cylinder-program matrix #f 0 0. wire-color: wire-color fill-color: fill-color)
      (glEnable GL_BLEND)
      ;(glEnable GL_CULL_FACE)
      ;(glCullFace GL_FRONT)
      (glBindVertexArray (get-array~ cylinder-mesh))
      (glDrawArrays GL_TRIANGLES 0 (get-indices~ (get-vertices-buffer~ cylinder-mesh)))
      (glBindVertexArray 0)
      ;(glCullFace GL_BACK)
      ;(glDisable GL_CULL_FACE)
      (glDisable GL_BLEND)
      (unbind-uniforms~ cylinder-program)
      (unuse~ cylinder-program))))


(definition public (render-line start end width color)
  (let ((dist (vertex-& end start)))
    (let ((norm (vertex-norm dist))
          (sight (vertex-normalize& dist))
          (mid (vertex+& start (vertex-scalar/& dist 2.))))
      (let ((up (roll-free-up sight)))
        (let ((right (cross-product& sight up)))
          (let ((matrix (matrix-multiply& (make-translation-matrix& mid)
                                          (matrix-multiply& (make-lookat-matrix& (lookat& sight up right))
                                                            (make-scaling-matrix& (vertex width width (/ norm 2.)))))))
            (render-cylinder matrix color: color)))))))


;;;
;;;; Cone
;;;


(definition cone-mesh
  #f)

(definition cone-program
  #f)


(definition (prepare-cone)
  (let ((world (current-world)))
    (unless cone-mesh
      (let ((material (get-block-opaque~ world))
            (uv (f32vector 0. 0. 0. 0. 0. 0. 0. 0.)))
        (set! cone-program (find-mesh-program~ world 'squareframe))
        (set! cone-mesh (generate-cylinder-mesh 48 24 1. 0. uv neighbors?: #t material: material))
        (set-array~ cone-mesh (create-array~ cone-program cone-mesh))))))


(definition public (render-cone matrix (color: color #f) (wire-color: wire-color #f) (fill-color: fill-color #f))
  (with-colors color wire-color fill-color
    (lambda (wire-color fill-color)
      (use~ cone-program)
      (bind-uniforms~ cone-program matrix #f 0 0. wire-color: wire-color fill-color: fill-color)
      (glEnable GL_BLEND)
      ;(glEnable GL_CULL_FACE)
      ;(glCullFace GL_FRONT)
      (glBindVertexArray (get-array~ cone-mesh))
      (glDrawArrays GL_TRIANGLES 0 (get-indices~ (get-vertices-buffer~ cone-mesh)))
      (glBindVertexArray 0)
      ;(glCullFace GL_BACK)
      ;(glDisable GL_CULL_FACE)
      (glDisable GL_BLEND)
      (unbind-uniforms~ cone-program)
      (unuse~ cone-program))))


;;;
;;;; Torus
;;;


(definition torus-mesh
  #f)

(definition torus-program
  #f)


(definition (prepare-torus)
  (let ((world (current-world)))
    (unless torus-mesh
      (let ((material (get-block-opaque~ world))
            (uv (f32vector 0. 0. 0. 0. 0. 0. 0. 0.)))
        (set! torus-program (find-mesh-program~ world 'squareframe))
        (set! torus-mesh (generate-torus-mesh 48 96 .01 uv neighbors?: #t material: material))
        (set-array~ torus-mesh (create-array~ torus-program torus-mesh))))))


(definition public (render-torus matrix (color: color #f) (wire-color: wire-color #f) (fill-color: fill-color #f))
  (with-colors color wire-color fill-color
    (lambda (wire-color fill-color)
      (use~ torus-program)
      (bind-uniforms~ torus-program matrix #f 0 0. wire-color: wire-color fill-color: fill-color)
      (glEnable GL_BLEND)
      (glEnable GL_CULL_FACE)
      (glCullFace GL_FRONT)
      (glBindVertexArray (get-array~ torus-mesh))
      (glDrawArrays GL_TRIANGLES 0 (get-indices~ (get-vertices-buffer~ torus-mesh)))
      (glBindVertexArray 0)
      (glCullFace GL_BACK)
      (glDisable GL_CULL_FACE)
      (glDisable GL_BLEND)
      (unbind-uniforms~ torus-program)
      (unuse~ torus-program))))


(definition public (render-circle center radius color)
  (let ((matrix (matrix-multiply& (make-translation-matrix& center)
                                  (make-scaling-matrix& (vertex radius radius radius)))))
    (render-torus matrix color: color)))


;;;
;;;; Draw
;;;


(definition public (prepare-draw)
  (prepare-quad)
  (prepare-cube)
  (prepare-sphere)
  (prepare-cylinder)
  (prepare-cone)
  (prepare-torus))


(definition public (reset-draw)
  (set! quad-mesh #f)
  (set! cube-mesh #f)
  (set! sphere-mesh #f)
  (set! cylinder-mesh #f)
  (set! cone-mesh #f)
  (set! torus-mesh #f))


(definition public (render-parallelepiped para <Parallelepiped> proc)
  (define (gl-vertex vert)
    (glVertex3f (vertex-x vert)
                (vertex-y vert)
                (vertex-z vert)))
  
  (let ((left/bottom/back (get-left/bottom/back~ para))
        (left/bottom/front (get-left/bottom/front~ para))
        (left/top/back (get-left/top/back~ para))
        (left/top/front (get-left/top/front~ para))
        (right/bottom/back (get-right/bottom/back~ para))
        (right/bottom/front (get-right/bottom/front~ para))
        (right/top/back (get-right/top/back~ para))
        (right/top/front (get-right/top/front~ para)))
    ;; top
    (proc
      (lambda ()
        (gl-vertex right/top/back)
        (gl-vertex left/top/back)
        (gl-vertex left/top/front)
        (gl-vertex right/top/front)))
    ;; bottom
    (proc
      (lambda ()
        (gl-vertex right/bottom/front)
        (gl-vertex left/bottom/front)
        (gl-vertex left/bottom/back)
        (gl-vertex right/bottom/back)))
    ;; front
    (proc
      (lambda ()
        (gl-vertex left/bottom/front)
        (gl-vertex right/bottom/front)
        (gl-vertex right/top/front)
        (gl-vertex left/top/front)))
    ;; back
    (proc
      (lambda ()
        (gl-vertex right/bottom/back)
        (gl-vertex left/bottom/back)
        (gl-vertex left/top/back)
        (gl-vertex right/top/back)))
    ;; left
    (proc
      (lambda ()
        (gl-vertex left/top/front)
        (gl-vertex left/top/back)
        (gl-vertex left/bottom/back)
        (gl-vertex left/bottom/front)))
    ;; right
    (proc
      (lambda ()
        (gl-vertex right/top/back)
        (gl-vertex right/top/front)
        (gl-vertex right/bottom/front)
        (gl-vertex right/bottom/back)))))


(definition public (draw-sphere x y z radius slices stacks color)
  (glPushMatrix)
  (glTranslatef x y z)
  (gl-colorize color)
  (gl-sphere radius slices stacks)
  (glPopMatrix))


(definition public (draw-polygon poly <Polygon> dye <f32vector>)
  (let ((width .01)
        (vertices (get-vertices~ poly)))
    (let ((card (vector-length vertices)))
      (loop (for n from 0 below card)
            (let ((start (vector-ref vertices n))
                  (end (vector-ref vertices (modulo (+ n 1) card))))
              (render-line start end width dye))))))


(definition public (draw-plane plane <Plane> dye <f32vector>)
  @glfc-needs-more-work
  (let ((origin (get-origin~ plane))
        (normal (get-normal~ plane))
        (width .01))
    (let ((other (vertex (vertex-y origin) (vertex-z origin) (vertex-x origin))))
      (let ((right (cross-normal& other normal)))
        (let ((sight (cross-normal& right normal)))
          (let ((matrix (matrix-multiply& (make-translation-matrix& origin)
                                          (matrix-multiply& (make-lookat-matrix& (lookat& sight normal (vertex-negate right)))
                                                            (make-scaling-matrix& (vertex width width 1.))))))
            (render-cylinder matrix color: dye))))))
  @glfc (
  (gl-colorize-dye dye)
  (let ((origin (get-origin~ plane))
        (normal (get-normal~ plane)))
    (let ((other (vertex (vertex-y origin) (vertex-z origin) (vertex-x origin))))
      (let ((right (cross-normal& other normal)))
        (let ((sight (cross-normal& right normal)))
          (glPushMatrix)
          (glMultMatrixv
            (vertex-x right) (vertex-x normal) (vertex-x sight) (vertex-x origin)
            (vertex-y right) (vertex-y normal) (vertex-y sight) (vertex-y origin)
            (vertex-z right) (vertex-z normal) (vertex-z sight) (vertex-z origin)
            0. 0. 0. 1.)
          (glLineWidth 2.)
          (gl-horizontal-circle (vertex 0. 0. 0.) .15 (dye->color dye))
          (render-line (vertex 0.0 0.0 0.0)
                       (vertex 0.0 .75 0.0)
                       .01
                       dye)
          (glPopMatrix))))))))
