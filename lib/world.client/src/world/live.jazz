;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Live
;;;


(module world.live jazz


(import (jazz.designer)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (jazz.version)
        (time)
        (world.area)
        (world.autoload)
        (world.actor)
        (world.block)
        (world.client.window)
        (world.counter)
        (world.enemy)
        (world.folio)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.light)
        (world.mark)
        (world.object)
        (world.player)
        (world.render)
        (world.shader)
        (world.sprite)
        (world.texture)
        (world.window))


;;;
;;;; World
;;;


(definition public t-vs
  #<<SHADER
#version 120


void main() {

	gl_TexCoord[0] = gl_MultiTexCoord0;
	gl_Position = ftransform();
}
SHADER
)


(definition public t-fs
  #<<SHADER
#version 120
 
uniform sampler2D tex;

void main()
{
	vec4 color = texture2D(tex, gl_TexCoord[0].st);
	gl_FragColor = color;
}
SHADER
)


(definition public pp-vs
  #<<SHADER
#version 120

attribute vec2 v_coord;
uniform sampler2D fbo_texture;
uniform sampler2D history_texture;
varying vec2 f_texcoord;
 
void main(void) {
  gl_Position = vec4(v_coord, 0.0, 1.0);
  f_texcoord = (v_coord +1.0) / 2;
}
SHADER
)


(definition public pp-fs
  #<<SHADER
#version 120
 
uniform sampler2D fbo_texture;
uniform sampler2D history_texture;
varying vec2 f_texcoord;

void main(void) {                
  gl_FragColor = texture2D(fbo_texture, f_texcoord)+(texture2D(history_texture, f_texcoord))*0.5;
}
SHADER
)

(definition public block-vs
  #<<SHADER
#version 120

attribute vec3 v_coord;
attribute vec3 v_coordtex;
uniform sampler2D block_texture;
varying vec2 f_texcoord;
 
void main(void) {
                 
  gl_Position = gl_ModelViewProjectionMatrix * vec4(v_coord,1.0);
  f_texcoord = vec2(v_coordtex.x, v_coordtex.y);
}
SHADER
)


(definition public block-fs
  #<<SHADER
#version 120
 
uniform sampler2D block_texture;
varying vec2 f_texcoord;

void main(void) {               
  gl_FragColor = texture2D(block_texture, f_texcoord);
}
SHADER
)


;;;
;;;; Live
;;;


(definition levels-version
  {Version 1 1})


(class Live-World extends World
  
  
  (property gravity            <fl>     initialize .09          accessors generate)
  (property ambient-color      <Color+> initialize #f           accessors generate)
  (property material-specular  <Color+> initialize #f           accessors generate)
  (property material-shininess <fl+>    initialize #f           accessors generate)
  (property block-color        <object> initialize #f           accessors generate)
  (property block-stiches?     <bool>   initialize #f           accessors generate)
  (property start-mode         <symbol> initialize 'free        accessors generate)
  (property start-3d?          <bool>   initialize #t           accessors generate)
  (property start-grid?        <bool>   initialize #t           accessors generate)
  (property properties         <object> initialize '()          accessors generate)
  
  
  (slot version               <object> initialize #f            getter generate)
  (slot areas                 <object> initialize #f            getter generate)
  (slot area-size             <fx>     initialize #f            getter generate)
  (slot debug-areas?          <bool>   initialize #f            getter generate)
  (slot actors                <list>   initialize '()           getter generate)
  (slot blocks                <list>   initialize '()           getter generate)
  (slot gadgets               <list>   initialize '()           getter generate)
  (slot sprites               <list>   initialize '()           getter generate)
  (slot player                <object> initialize #f            getter generate)
  (slot projection            <symbol> initialize 'orthographic getter generate)
  (slot zoom-factor           <fl>                              getter generate)
  (slot desired-tilt          <fl>     initialize 0.            getter generate)
  (slot tilt-speed            <fl>     initialize 0.            getter generate)
  (slot last-tilt-time        <fl+>    initialize #f            getter generate)
  (slot 3d?                   <bool>   initialize #f            getter generate)
  (slot eye?                  <bool>   initialize #f            getter generate)
  (slot player-target?        <bool>   initialize #f            getter generate)
  (slot fly?                  <bool>   initialize #f            getter generate)
  (slot viewing?              <bool>   initialize #f            getter generate)
  (slot moving?               <bool>   initialize #f            getter generate)
  (slot moved?                <bool>   initialize #f            getter generate)
  (slot preserved-mouse       <object> initialize #f            getter generate)
  (slot first-person?         <bool>   initialize #f            getter generate)
  (slot max-distance          <fl>     initialize 150.0         getter generate)
  (slot first-distance        <fl>     initialize 17.5          getter generate)
  (slot first-override        <fl+>    initialize #f            getter generate)
  (slot first-occlusion?      <bool>   initialize #f            getter generate)
  (slot first-camera          <object> initialize #f            getter generate)
  (slot draw-sprites?         <bool>   initialize #t            getter generate)
  (slot draw-gadgets?         <bool>   initialize #f            getter generate)
  (slot textures?             <bool>   initialize #f            getter generate)
  (slot axes?                 <bool>   initialize #f            getter generate)
  (slot pulse                 <object> initialize #f            getter generate)
  (slot last-tick             <fl>     initialize #f            getter generate)
  (slot down?                 <bool>   initialize #f            getter generate)
  (slot down-point            <object> initialize #f            getter generate)
  (slot drag-tolerance        <object> initialize 3             getter generate)
  (slot paused?               <bool>   initialize #f            getter generate)
  (slot info                  <object> initialize #f            getter generate)
  (slot info?                 <bool>   initialize #f            getter generate)
  (slot gc-counter            <object> initialize #f            getter generate)
  (slot tick-counter          <object> initialize #f            getter generate)
  (slot render-counter        <object> initialize #f            getter generate)
  (slot counters?             <bool>   initialize #f            getter generate)
  (slot marks                 <list>   initialize '()           getter generate)
  (slot start-x               <fl+>    initialize #f            getter generate)
  (slot start-y               <fl+>    initialize #f            getter generate)
  (slot start-z               <fl+>    initialize #f            getter generate)
  (slot commands              <object> initialize #f            getter generate)
  (slot player-texture        <object> initialize #f            getter generate)
  (slot turtle-texture        <object> initialize #f            getter generate)
  (slot monster-texture       <object> initialize #f            getter generate)
  (slot missile-texture       <object> initialize #f            getter generate)
  (slot block-texture         <object> initialize #f            getter generate)
  (slot background-texture    <object> initialize #f            getter generate)
  (slot explosion-sound       <object> initialize #f            getter generate)
  (slot history?              <object> initialize #t            getter generate)
  (slot history               <object> initialize #f            getter generate)
  (slot message               <object> initialize #f            getter generate)
  (slot message-time          <object> initialize #f            getter generate)
  (slot message-color         <object> initialize #f            getter generate)
  (slot message-texture       <object> initialize #f            getter generate)
  (slot status                <object> initialize #f            getter generate)
  (slot status-time           <object> initialize #f            getter generate)
  (slot status-color          <object> initialize #f            getter generate)
  (slot status-texture        <object> initialize #f            getter generate)
  (slot information           <object> initialize #f            getter generate)
  
  ;; Used for shaders
  
  (slot test-vao                       initialize #f            accessors generate)
  (slot test-vbo-total-vertices        initialize 0             accessors generate)
  (slot test-vbo-vertices              initialize #f            accessors generate)
  (slot vbo/fbo-vertices               initialize #f            accessors generate)
  (slot post-process-shader   <object> initialize #f            accessors generate)
  (slot texture-shader        <object> initialize #f            accessors generate)
  (slot block-shader          <object> initialize #f            accessors generate)
  (slot pp-attribute-name              initialize #f            accessors generate)
  (slot pp-attribute-location          initialize #f            accessors generate)
  (slot pp-uniform-name                initialize #f            accessors generate)
  (slot pp-uniform-location            initialize #f            accessors generate)
  (slot pp-size-location               initialize #f            accessors generate)
  (slot pp-history-location            initialize #f            accessors generate)
  (slot pp-history-name                initialize #f            accessors generate)
  (slot texture-location               initialize #f            accessors generate)
  (slot block-location                 initialize #f            accessors generate)
  (slot block-texture-location         initialize #f            accessors generate)
  (slot block-tex-location             initialize #f            accessors generate)
  
  ;; Render targets
  (slot render-target         <object> initialize #f            accessors generate)
  (slot history-render-target <object> initialize #f            accessors generate)
  (slot post-processing?      <bool>   initialize #f            accessors generate)
  
  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method override (add-child child)
    (set! children (cons child children)))
  
  
  (method override (setup-opengl)
    (nextmethod)
    (initialize-camera)
    (prepare-tick)
    (prepare-shaders)
    (prepare-textures)
    (prepare-editor)
    (initialize-render-targets)
    (reset-commands))
  
  
  (method (initialize-render-targets)
    (set! render-target (new Render-Target (fxround width) (fxround height)))
    (set! history-render-target (new Render-Target (fxround width) (fxround height) depth-buffer: (get-depth-buffer~ render-target))))
 
  
  (method (prepare-shaders)
    (set! vbo/fbo-vertices (glGenVertices*))
    (set! pp-attribute-name "v_coord")
    (set! pp-uniform-name "fbo_texture")
    (set! pp-history-name "history_texture")
    
    (set! block-shader (new Shader-Program))
    (set-vs~ block-shader block-vs)
    (set-fs~ block-shader block-fs)
    (create-attach~ block-shader)
    
    (set! block-location (glGetAttribLocation* (get-program~ block-shader) "v_coord"))
    (set! block-tex-location (glGetAttribLocation* (get-program~ block-shader) "v_coordtex"))
    (set! block-texture-location (glGetUniformLocation* (get-program~ block-shader) "block_texture"))
    
    (set! texture-shader (new Shader-Program))
    (set-vs~ texture-shader t-vs)
    (set-fs~ texture-shader t-fs)
    (create-attach~ texture-shader)
    
    (set! texture-location (glGetUniformLocation* (get-program~ texture-shader) "tex"))
    
    (set! post-process-shader (new Shader-Program))
    (set-vs~ post-process-shader pp-vs)
    (set-fs~ post-process-shader pp-fs)
    (create-attach~ post-process-shader)
    
    (set! pp-attribute-location (glGetAttribLocation* (get-program~ post-process-shader) pp-attribute-name))
    (set! pp-history-location (glGetUniformLocation* (get-program~ post-process-shader) pp-history-name))
    (set! pp-uniform-location (glGetUniformLocation* (get-program~ post-process-shader) pp-uniform-name)))
  
  
  (method (prepare-textures)
    (let ((resources-dir (new Directory (tokenise-filename (repository-pathname (find-repository 'World) "world.client/resources")))))
      (set! player-texture (make-png-texture (new-file~ resources-dir "player/Idle.png") texture-shader texture-location))
      (set! turtle-texture (make-png-texture (new-file~ resources-dir "player/Idle.png") texture-shader texture-location))
      (set! monster-texture (make-png-texture (new-file~ resources-dir "player/Idle.png") texture-shader texture-location))
      (set! missile-texture (make-png-texture (new-file~ resources-dir "player/Idle.png") texture-shader texture-location))
      (set! block-texture (make-png-texture (new-file~ resources-dir "tiles/BlockA1.png") texture-shader texture-location))
      (set! background-texture (make-png-texture (new-file~ resources-dir "background/Layer0_0.png") texture-shader texture-location))
      (set! message-texture (make-cairo-texture 500 100 program: texture-shader uniform-location: texture-location))
      (set! status-texture (make-cairo-texture 500 35 program: texture-shader uniform-location: texture-location))
      (set! explosion-sound (new-file~ resources-dir (list "sounds" "explosion.wav")))))
  
  
  (method (reset-commands)
    (set! commands (new Commands)))
  
  
  (method (setup-world)
    (set! last-tick (time->seconds (current-time)))
    (set! paused? #f)
    
    @w
    (when test-vao
      (glDeleteVertexArrays* 1 test-vao))
    (create-test-vbo))
  
  
  (method (setup-boundaries)
    @w
    (set! boundaries (new Cuboid left bottom back right top front)))
  
  
  (method (toggle-block-stiches)
    (set! block-stiches? (not block-stiches?))
    (display-on/off "Block Stiches" block-stiches?))
  
  
  (method override (destroy)
    (close~ pulse)
    (nextmethod))
  
  
  ;;;
  ;;;; World
  ;;;
  
  
  (method override (initialize-world)
    (setup-areas)
    (setup-lights)
    (set! version levels-version)
    (set! info (new Info parent: self x: -10.0 y: 0.0 z: 0.0))
    (set! gc-counter (new Counter parent: self x: -10.0 y: 0.0 z: 0.0 title: "GC" vertical: 62.0))
    (set! tick-counter (new Counter parent: self x: -10.0 y: 0.0 z: 0.0 title: "Tick" vertical: 35.0))
    (set! render-counter (new Counter parent: self x: -10.0 y: 0.0 z: 0.0 title: "Render" vertical: 8.0))
    (set! start-x -9.5)
    (set! start-y 62.5)
    (set! start-z 0.0)
    (set! first-camera 'free)
    (set! grid? start-grid?)
    (set! grid-y? #t)
    (cond (start-3d?
           (activate-3d))
          (else
           (set! camera-distance 0.6)
           (set! first-distance 7.5)))
    (setup-boundaries)
    (setup-history)
    (setup-gc)
    (update-title)
    (update-debug-variables)
    )
  
  
  (method (default-world)
    (for-each remove-sprite sprites)
    (set! gadgets '())
    (set! children '())
    (set! start-3d? #t)
    (set! start-grid? #t)
    (set! grid? #t)
    (setup-areas)
    (setup-lights)
    (set! player (add-sprite (new Player parent: self x: start-x y: start-y z: start-z)))
    (add-sprite (new Turtle parent: self x: 0.0 y: 21.0 z: 0.0))
    (loop (for n from -10 to 10)
          (add-sprite (new Block parent: self x: (cast <fl> (* n 5)) y: 32.5 z: 0.0)))
    (loop (for n from -10 to 10)
          (add-sprite (new Block parent: self x: (cast <fl> (* n 5)) y: (cast <fl> (* n 5)) z: 0.0)))
    (loop (for n from -15 to 15)
          (add-sprite (new Block parent: self x: (cast <fl> (* n 5)) y: (cast <fl> (* (- n) 5)) z: 0.0)))
    (add-sprite (new Block parent: self x: -10. y:  22.5 z: 0.0 color: {Color Light-Purple} user-data: 'win))
    (add-sprite (new Block parent: self x:  10. y:  22.5 z: 0.0))
    (add-sprite (new Block parent: self x:  20. y:   6.5 z: 0.0))
    (add-sprite (new Block parent: self x:  28. y:  12.5 z: 0.0))
    (add-sprite (new Block parent: self x:  19.5 y: 19.5 z: 0.0))
    (loop (for n from -2 to 2)
          (add-sprite (new Block parent: self x: (cast <fl> (* n 5)) y: 2.5 z: 0.0)))
    @w
    (add-sprite (new Block parent: self x: -50.0 y: -27.5 z: -5.0 width: 100. height: 100. depth: .1 background-texture color: {Color Light-Blue}))
    (add-sprite (new Light parent: self x: 4.0 y: 0.0 z: 8.0 w: 1.0 color: {Color red: .5 green: .5 blue: .5 alpha: 1.0}))
    (add-sprite (new Light parent: self x: -1.0 y: 0.5 z: 0.5 w: 0.0 color: {Color red: .5 green: .5 blue: .5 alpha: 1.0}))
    (when (not start-3d?)
      (deactivate-3d)
      (set! light? #t)
      (set! camera-distance 0.6)
      (set! first-distance 17.5))
    (setup-world))

  
  (method override (reset-world)
    (nextmethod)
    (default-world))

  
  (method (create-test-vbo)
    (set! test-vbo-vertices
      (let ((all (map get-triangles-texcoords~ blocks)))
        (let ((count 0))
          (for-each (lambda (triangles-texcoords)
                      (increase! count (* (length triangles-texcoords) 3)))
                   all)
          (let ((f32 (make-f32vector count)))
            (let ((n 0))
              (for-each (lambda (triangles-texcoords)
                          (for-each (lambda (vert)
                                      (f32vector-set! f32 n (vertex-x vert))
                                      (f32vector-set! f32 (+ n 1) (vertex-y vert))
                                      (f32vector-set! f32 (+ n 2) (vertex-z vert))
                                      (set! n (+ n 3)))
                                    triangles-texcoords))
                        all))
            f32))))
    
    (when (not test-vao)
      (set! test-vao (glGenBuffers*))
      (create-test-vertex-buffer)))
  
  
  (method protected (triangles->vertices vertices)
    (let ((f32 (make-f32vector (* (length vertices) 3))))
      (let (iter (n 0) (scan vertices))
        (if (null? scan)
            f32
          (let ((vert (car scan)))
            (f32vector-set! f32 n (vertex-x vert))
            (f32vector-set! f32 (+ n 1) (vertex-y vert))
            (f32vector-set! f32 (+ n 2) (vertex-z vert)))
          (iter (+ n 3) (cdr scan))))))
    
  
  (method (create-test-vertex-buffer)
    (glBindBuffer GL_ARRAY_BUFFER test-vao)
    (glBufferDataFloat* GL_ARRAY_BUFFER (f32vector-length test-vbo-vertices) test-vbo-vertices GL_STATIC_DRAW)
    (glBindBuffer GL_ARRAY_BUFFER 0))
  
  
  ;;;
  ;;;; Sprites
  ;;;
  
  
  (method (add-sprite obj)
    (define (add-actor actor)
      (set! actors (cons actor actors))
      (set! sprites (cons actor sprites))
      (area-add-actor (sprite-area actor) actor)
      actor)
    
    (define (add-block block)
      (set! blocks (cons block blocks))
      (set! sprites (cons block sprites))
      (area-add-block (sprite-area block) block)
      block)
    
    (define (add-gadget gadget)
      (set! gadgets (cons gadget gadgets))
      (area-add-gadget (sprite-area gadget) gadget)
      gadget)
    
    (typecase obj
      ((Actor) (add-actor obj))
      ((Block) (add-block obj))
      (else (add-gadget obj))))
  
  
  (method (iterate-gadgets proc)
    (for-each proc gadgets))
  
  
  (method (iterate-sprites proc)
    (for-each proc sprites))
  
  
  (method (iterate-all proc)
    (for-each proc sprites)
    (for-each proc gadgets))
  
  
  ;;;
  ;;;; Tick
  ;;;
  
  
  (method (prepare-tick)
    (set! pulse (new Pulse 'tick .01 tick-world)))
  
  
  (method (tick-world)
    (unless (or paused? (is-inactive?))
      (let ((elapse (- (time->seconds (current-time)) last-tick)))
        (set! last-tick (time->seconds (current-time)))
        (when history?
          (add-history elapse))
        (start~ tick-counter)
        (tick-actors commands elapse)
        (reset-commands)
        (end~ tick-counter)
        (restore-first-distance elapse))))
  
  
  (method (tick-actors commands elapse)
    (unless (and player (get-state~ player))
      (for-each (lambda (actor)
                  (tick~ actor commands elapse))
                actors)))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (setup-history)
    (set! history (new History self 500)))
  
  
  (method (historical-moment n)
    (historical-moment~ history n))
  
  
  (method (add-history elapse)
    (let ((moment (new Moment (snapshot-world) (object-copy commands) elapse)))
      (add-history~ history moment)))
  
  
  (method (backward-history)
    (backward-history~ history))
  
  
  (method (forward-history)
    (forward-history~ history))
  
  
  (method (slide-history where)
    (slide-history~ history where))
  
  
  (method (truncate-future)
    (truncate-future~ history))
  
  
  (method (toggle-history)
    (set! history? (not history?))
    (when (not history?)
      (setup~ history))
    (display-on/off "History" history?))
  
  
  (method (reset-history)
    (setup~ history)
    (display-message "History reset"))
  
  
  (method (step-world)
    (step-world~ history))
  
  
  (method (recalculate-future)
    (recalculate-future~ history))
  
  
  (method (update-future)
    (when (and history? paused?)
      (recalculate-future)))
  
  
  ;;;
  ;;;; Movement
  ;;;
  
  
  (method override (move-forward)
    (if (and player first-person? (not paused?))
        (move-up~ player commands)
      (nextmethod)))
  
  
  (method override (move-backward)
    (if (and player first-person? (not paused?))
        (move-down~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-left)
    (if (and player first-person? (not paused?))
        (strafe-left~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-right)
    (if (and player first-person? (not paused?))
        (strafe-right~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-up)
    (if (and player first-person? (not paused?))
        (strafe-up~ player commands)
      (nextmethod)))
  
  
  (method override (strafe-down)
    (if (and player first-person? (not paused?))
        (strafe-down~ player commands)
      (nextmethod)))
  
  
  (method override (rotate-left)
    (if (and player first-person? (not paused?))
        (rotate-left~ player commands)
      (nextmethod)))
  
  
  (method override (rotate-right)
    (if (and player first-person? (not paused?))
        (rotate-right~ player commands)
      (nextmethod)))
  
  
  (method (move-left)
    (move-left~ player commands))
  
  
  (method (move-right)
    (move-right~ player commands))
  
  
  (method (move-down)
    (move-down~ player commands))
  
  
  (method (move-up)
    (move-up~ player commands))
  
  
  (method (space)
    (space~ player commands))
  
  
  ;;;
  ;;;; Game
  ;;;
  
  
  (method (fire)
    (when (and player first-person? (not paused?))
      (fire~ player commands)))
  
  
  ;;;
  ;;;; Area
  ;;;
  
  
  (method (setup-areas)
    (set! areas (make-table test: equal?))
    (set! area-size 10))
  
  
  (method (sprite-area-index sprite)
    (position-area-index (get-x~ sprite)
                         (get-y~ sprite)
                         (get-z~ sprite)))
  
  
  (method (position-area-index x y z)
    (define (offset r)
      (let ((i (fxfloor r)))
        (/ (- i (modulo i area-size))
           area-size)))
    
    (list (offset x)
          (offset y)
          (offset z)))
  
  
  (method (sprite-area sprite)
    (index-area (sprite-area-index sprite)))
  
  
  (method (index-area index)
    (or (table-ref areas index #f)
        (let ((area (new Area index)))
          (table-set! areas index area)
          area)))
  
  
  (method (unlink-area area)
    @doesnt-work-as-is-because-hit-test-will-consult/create-the-27-adjacent-areas-even-if-they-are-empty
    (table-clear areas (get-index~ area)))
  
  
  (method (area-add-sprite area sprite)
    (cond ((is? sprite Actor)
           (area-add-actor area sprite))
          ((is? sprite Block)
           (area-add-block area sprite))
          (else
           (area-add-gadget area sprite))))
  
  
  (method (area-add-actor area actor)
    (set-actors~ area (cons actor (get-actors~ area))))
  
  
  (method (area-add-block area block)
    (set-blocks~ area (cons block (get-blocks~ area))))
  
  
  (method (area-add-gadget area gadget)
    (set-gadgets~ area (cons gadget (get-gadgets~ area))))
  
  
  (method (area-remove-sprite area sprite)
    (cond ((is? sprite Actor)
           (area-remove-actor area sprite))
          ((is? sprite Block)
           (area-remove-block area sprite))
          (else
           (area-remove-gadget area sprite))))
  
  
  (method (area-remove-actor area actor)
    (let ((actors (remove! actor (get-actors~ area))))
      (set-actors~ area actors)
      (when (and (null? actors) (null? (get-blocks~ area)) (null? (get-gadgets~ area)))
        (unlink-area area))))
  
  
  (method (area-remove-block area block)
    (let ((blocks (remove! block (get-blocks~ area))))
      (set-blocks~ area blocks)
      (when (and (null? blocks) (null? (get-actors~ area)) (null? (get-gadgets~ area)))
        (unlink-area area))))
  
  
  (method (area-remove-gadget area gadget)
    (let ((gadgets (remove! gadget (get-gadgets~ area))))
      (set-gadgets~ area gadgets)
      (when (and (null? gadgets) (null? (get-actors~ area)) (null? (get-blocks~ area)))
        (unlink-area area))))
  
  
  (method (update-area sprite old-center)
    (let ((old-index (position-area-index (vertex-x old-center) (vertex-y old-center) (vertex-z old-center)))
          (new-index (sprite-area-index sprite)))
      (when (not (equal? old-index new-index))
        (let ((old-area (index-area old-index))
              (new-area (index-area new-index)))
          (area-remove-sprite old-area sprite)
          (area-add-sprite new-area sprite)))))
  
  
  (method (iterate-sprite-areas-3d sprite proc)
    (bind (x y z) (sprite-area-index sprite)
      (loop (for i from -1 to 1)
            (loop (for j from -1 to 1)
                  (loop (for k from -1 to 1)
                        (proc (index-area (list (+ x i) (+ y j) (+ z k)))))))))
  
  
  (method (sprite-areas-3d sprite)
    (let ((queue (new-queue)))
      (iterate-sprite-areas-3d sprite (lambda (area) (enqueue queue area)))
      (queue-list queue)))
  
  
  (method (iterate-areas-sprites areas proc)
    (for-each (lambda (area)
                (for-each proc (get-actors~ area))
                (for-each proc (get-blocks~ area))
                (for-each proc (get-gadgets~ area)))
              areas))
  
  
  (method (iterate-area-sprites area proc)
    (for-each proc (get-actors~ area))
    (for-each proc (get-blocks~ area))
    (for-each proc (get-gadgets~ area)))
  
  
  (method (collect-area-sprites)
    (let ((queue (new-queue)))
      (iterate-table areas
        (lambda (index area)
          (enqueue-list queue (get-actors~ area))
          (enqueue-list queue (get-blocks~ area))
          (enqueue-list queue (get-gadgets~ area))))
      (queue-list queue)))
  
  
  (method (areas-count filter)
    (count-if filter (collect-area-sprites)))
  
  
  (method (validate-areas)
    (let ((actors-count 0)
          (blocks-count 0)
          (gadgets-count 0)
          (sprites-count 0))
      (iterate-table areas
        (lambda (index area)
          (let ((area-actors (length (get-actors~ area)))
                (area-blocks (length (get-blocks~ area)))
                (area-gadgets (length (get-gadgets~ area))))
            (increase! actors-count area-actors)
            (increase! blocks-count area-blocks)
            (increase! gadgets-count area-gadgets)
            (increase! sprites-count (+ area-actors area-blocks)))))
      (if (and (= actors-count (length actors))
               (= blocks-count (length blocks))
               (= gadgets-count (length gadgets))
               (= sprites-count (length sprites)))
          (begin
            (reset-information)
            #t)
        (set-information
          `("Area corruption detected"
            ,(format "  Actors: {s} {s}" actors-count (length actors))
            ,(format "  Blocks: {s} {s}" blocks-count (length blocks))
            ,(format "  Gadgets: {s} {s}" gadgets-count (length gadgets))
            ,(format "  Sprites: {s} {s}" sprites-count (length sprites))))
        #f)))
  
  
  (method (toggle-debug-areas)
    (set! debug-areas? (not debug-areas?)))
  
  
  (method (draw-areas)
    (let ((size (cast <fl> area-size))
          (depth 5))
      (let ((min (- (* size depth)))
            (max (* size depth)))
        (glDisable GL_LIGHTING)
        (gl-colorize {Color Red})
        (glBegin GL_LINES)
        (loop (for x <fl> from min to max by size)
              (loop (for y <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for y <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x y min)
                    (glVertex3f x y max))
              (loop (for z <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glBegin GL_LINES)
        (loop (for z <fl> from min to max by size)
              (loop (for x <fl> from min to max by size)
                    (glVertex3f x min z)
                    (glVertex3f x max z))
              (loop (for y <fl> from min to max by size)
                    (glVertex3f min y z)
                    (glVertex3f max y z)))
        (glEnd)
        (glEnable GL_LIGHTING))))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method (hit-test object from-x <fl> from-y <fl> from-z <fl> to-x <fl> to-y <fl> to-z <fl> width <fl> height <fl> depth <fl> radius-x <fl> radius-y <fl> radius-z <fl>)
    (let ((from-right (+ from-x width))
          (from-top (+ from-y height))
          (from-front (+ from-z depth))
          (to-right #f)
          (to-top #f)
          (to-front #f)
          (areas (sprite-areas-3d object)))
      (define (hit-x)
        (cond ;; going right
              ((> to-x from-x)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (let ((bottom (get-bottom~ obj))
                           (top (get-top~ obj))
                           (back (get-back~ obj))
                           (front (get-front~ obj))
                           (border (get-left~ obj)))
                       (when (and (neq? obj object)
                                  (<= from-right border)
                                  (> to-right border)
                                  (not (or (<= to-top bottom)
                                           (>= to-y top)
                                           (<= to-front back)
                                           (>= to-z front))))
                         (cond ((or (not found)
                                    (< border found))
                                (set! found border)
                                (set! found-objects (list obj))
                                (set! to-right border)
                                (set! to-x (- to-right width)))
                               ((= border found)
                                (set! found-objects (cons obj found-objects))))))))
                 (when found
                   (list found-objects 1 found (- found radius-x)))))
              ;; going left
              ((< to-x from-x)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (let ((bottom (get-bottom~ obj))
                           (top (get-top~ obj))
                           (back (get-back~ obj))
                           (front (get-front~ obj))
                           (border (get-right~ obj)))
                       (when (and (neq? obj object)
                                  (>= from-x border)
                                  (< to-x border)
                                  (not (or (<= to-top bottom)
                                           (>= to-y top)
                                           (<= to-front back)
                                           (>= to-z front))))
                         (cond ((or (not found)
                                    (> border found))
                                (set! found border)
                                (set! found-objects (list obj))
                                (set! to-x border)
                                (set! to-right (+ to-x width)))
                               ((= border found)
                                (set! found-objects (cons obj found-objects))))))))
                 (when found
                   (list found-objects -1 found (+ found radius-x)))))
              ;; not moving
              (else
               #f)))
      
      (define (hit-y)
        (cond ;; going up
              ((> to-y from-y)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (let ((left (get-left~ obj))
                           (right (get-right~ obj))
                           (back (get-back~ obj))
                           (front (get-front~ obj))
                           (border (get-bottom~ obj)))
                       (when (and (neq? obj object)
                                  (<= from-top border)
                                  (> to-top border)
                                  (not (or (<= to-right left)
                                           (>= to-x right)
                                           (<= to-front back)
                                           (>= to-z front))))
                         (cond ((or (not found)
                                    (< border found))
                                (set! found border)
                                (set! found-objects (list obj))
                                (set! to-top border)
                                (set! to-y (- to-top height)))
                               ((= border found)
                                (set! found-objects (cons obj found-objects))))))))
                 (when found
                   (list found-objects 1 found (- found radius-y)))))
              ;; going down
              ((< to-y from-y)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (let ((left (get-left~ obj))
                           (right (get-right~ obj))
                           (back (get-back~ obj))
                           (front (get-front~ obj))
                           (border (get-top~ obj)))
                       (when (and (neq? obj object)
                                  (>= from-y border)
                                  (< to-y border)
                                  (not (or (<= to-right left)
                                           (>= to-x right)
                                           (<= to-front back)
                                           (>= to-z front))))
                         (cond ((or (not found)
                                    (> border found))
                                (set! found border)
                                (set! found-objects (list obj))
                                (set! to-y border)
                                (set! to-top (+ to-y height)))
                               ((= border found)
                                (set! found-objects (cons obj found-objects))))))))
                 (when found
                   (list found-objects -1 found (+ found radius-y)))))
              ;; not moving
              (else
               #f)))
      
      (define (hit-z)
        (cond ;; going front
              ((> to-z from-z)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (let ((left (get-left~ obj))
                           (right (get-right~ obj))
                           (bottom (get-bottom~ obj))
                           (top (get-top~ obj))
                           (border (get-back~ obj)))
                       (when (and (neq? obj object)
                                  (<= from-front border)
                                  (> to-front border)
                                  (not (or (<= to-right left)
                                           (>= to-x right)
                                           (<= to-top bottom)
                                           (>= to-y top))))
                         (cond ((or (not found)
                                    (< border found))
                                (set! found border)
                                (set! found-objects (list obj))
                                (set! to-front border)
                                (set! to-z (- to-front depth)))
                               ((= border found)
                                (set! found-objects (cons obj found-objects))))))))
                 (when found
                   (list found-objects 1 found (- found radius-z)))))
              ;; going back
              ((< to-z from-z)
               (let ((found #f)
                     (found-objects #f))
                 (iterate-areas-sprites areas
                   (lambda (obj)
                     (let ((left (get-left~ obj))
                           (right (get-right~ obj))
                           (bottom (get-bottom~ obj))
                           (top (get-top~ obj))
                           (border (get-front~ obj)))
                       (when (and (neq? obj object)
                                  (>= from-z border)
                                  (< to-z border)
                                  (not (or (<= to-right left)
                                           (>= to-x right)
                                           (<= to-top bottom)
                                           (>= to-y top))))
                         (cond ((or (not found)
                                    (> border found))
                                (set! found border)
                                (set! found-objects (list obj))
                                (set! to-z border)
                                (set! to-front (+ to-z depth)))
                               ((= border found)
                                (set! found-objects (cons obj found-objects))))))))
                 (when found
                   (list found-objects -1 found (+ found radius-z)))))
              ;; not moving
              (else
               #f)))
      
      (let ((preserved-x to-x)
            (preserved-y to-y)
            (preserved-z to-z))
        (define (restore)
          (set! to-x preserved-x)
          (set! to-y preserved-y)
          (set! to-z preserved-z)
          (set! to-right (+ to-x width))
          (set! to-top (+ to-y height))
          (set! to-front (+ to-z depth)))
        
        (define (hit h1 h2 h3 order)
          (restore)
          (let ((count 0))
            (let ((h1 (h1)))
              (when h1
                (increase! count))
              (let ((h2 (h2)))
                (when h2
                  (increase! count))
                (let ((h3 (h3)))
                  (when h3
                    (increase! count))
                  (cons count (order h1 h2 h3)))))))
        
        (let ((r1 (hit hit-y hit-x hit-z (lambda (hit-y hit-x hit-z) (values hit-x hit-y hit-z)))))
          (if (<= (car r1) 1)
              (cdr r1)
            (let ((r2 (hit hit-x hit-y hit-z (lambda (hit-x hit-y hit-z) (values hit-x hit-y hit-z))))
                  (r3 (hit hit-z hit-y hit-x (lambda (hit-z hit-y hit-x) (values hit-x hit-y hit-z))))
                  (r4 (hit hit-y hit-z hit-x (lambda (hit-y hit-z hit-x) (values hit-x hit-y hit-z))))
                  (r5 (hit hit-x hit-z hit-y (lambda (hit-x hit-z hit-y) (values hit-x hit-y hit-z))))
                  (r6 (hit hit-z hit-x hit-y (lambda (hit-z hit-x hit-y) (values hit-x hit-y hit-z)))))
              (let ((lst (list r1 r2 r3 r4 r5 r6)))
                (cdr (minimum lst key: car)))))))))
  
  
  ;;;
  ;;;; Projection
  ;;;
  
  
  (method override (prepare-projection)
    (let ((ratio (/ width height)))
      (glMatrixMode GL_PROJECTION)
      (glLoadIdentity)
      (case projection
        ((perspective)
         (gluPerspective 45.0 ratio 0.1 1000.0))
        ((orthographic)
         (let ((width zoom-factor))
           (let ((height (/ width ratio)))
             (glOrtho (- width) width (- height) height -50.0 50.0)))))))
  
  
  (method (toggle-projection)
    (set! projection
          (case projection
            ((perspective) 'orthographic)
            ((orthographic) 'perspective)))
    (display-message (format "Projection {a}" projection)))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (definition camera-limit
    5.)
  
  
  (method override (camera-move-speed)
    1.0)
  
  (method override (camera-strafe-speed)
    0.5)
  
  (method override (camera-rotate-speed)
    0.03)
  
  
  (method (initialize-camera)
    (set! zoom-factor 54.5)
    (prepare-camera)
    (update-camera))
  
  
  (method override (prepare-camera)
    (vertex-init! eye 0.0 36.25 60.0)
    (standardize!~ eye-lookat))
  
  
  (method (reset-camera)
    (standardize!~ (get-lookat~ player))
    (standardize!~ eye-lookat)
    (follow-player)
    (display-message "Reset"))
  
  
  (method (toggle-eye)
    (set! eye? (not eye?)))
  
  
  (method (draw-eye)
    (let ((center (vertex- (vertex- (vertex+ eye (vertex-scalar* (get-sight~ eye-lookat) 5.)) (vertex-scalar* (get-right~ eye-lookat) 1.5)) (get-up~ eye-lookat))))
      (let ((sight (vertex+ center (get-sight~ eye-lookat)))
            (up (vertex+ center (get-up~ eye-lookat)))
            (right (vertex+ center (get-right~ eye-lookat)))
            (axis-x (vertex+ center (vertex 1. 0. 0.)))
            (axis-y (vertex+ center (vertex 0. 1. 0.)))
            (axis-z (vertex+ center (vertex 0. 0. 1.))))
        (let ((cx (vertex-x center))
              (cy (vertex-y center))
              (cz (vertex-z center)))
          (glLineWidth 2.)
          (glDisable GL_LIGHTING)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x sight) (vertex-y sight) (vertex-z sight))
          (glEnd)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x right) (vertex-y right) (vertex-z right))
          (glEnd)
          (gl-colorize {Color White})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x up) (vertex-y up) (vertex-z up))
          (glEnd)
          (gl-colorize {Color Red})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-x) (vertex-y axis-x) (vertex-z axis-x))
          (glEnd)
          (gl-colorize {Color Green})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-y) (vertex-y axis-y) (vertex-z axis-y))
          (glEnd)
          (gl-colorize {Color Blue})
          (glBegin GL_LINES)
          (glVertex3f cx cy cz)
          (glVertex3f (vertex-x axis-z) (vertex-y axis-z) (vertex-z axis-z))
          (glEnd)
          (glEnable GL_LIGHTING)
          (glLineWidth 1.)))))

  
  (method override (zoom-in)
    (if first-person?
        (first-distance-closer)
      (if (eq? projection 'perspective)
          (nextmethod)
        (set! zoom-factor (* zoom-factor .75)))))
  
  
  (method override (zoom-out)
    (if first-person?
        (first-distance-further)
      (if (eq? projection 'perspective)
          (nextmethod)
        (set! zoom-factor (/ zoom-factor .75)))))
  
  
  (method override (zoom-speed)
    10.)
  
  
  (method (change-first-camera)
    (let ((camera (next-element '(locked free) first-camera)))
      (set! first-camera camera)
      (when (eq? first-camera 'locked)
        (follow-player))
      (display-message (format "Camera {a}" camera))))
  
  
  (method (follow-player)
    (when first-person?
      (unless (or viewing? (eq? first-camera 'free))
        (set-sight~ eye-lookat (get-sight~ (get-lookat~ player)))
        (set-up~ eye-lookat (if fly? (get-up~ (get-lookat~ player)) (vertex 0.0 1.0 0.0)))
        (set-right~ eye-lookat (vertex-normalize (cross-product (get-sight~ eye-lookat) (get-up~ eye-lookat)))))
      (when player
        (let ((target (player-target)))
          (vertex-! eye target (vertex-scalar* (get-sight~ eye-lookat) (effective-first-distance)))
          (vertex+! eye-target eye (get-sight~ eye-lookat))
          (remove-eye-occlusion target)))))
  
  
  (method (player-target)
    (vertex+ (get-center~ player)
             (vertex-scalar* (get-up~ (get-lookat~ player))
                             1.5)))
  
  
  (method (restore-first-distance elapse)
    (when (and first-override (not first-occlusion?))
      (let ((augmented-override (+ first-override (* elapse 100.))))
        (if (>= augmented-override first-distance)
            (set! first-override #f)
          (set! first-override augmented-override)))
      (occlusion-update-eye (player-target))
      (adjust-player-alpha)))
  
  
  (method (remove-eye-occlusion target)
    (define (determine-eye-occlusion target)
      (receive (sprite distance) (ray-closest-sprite target (vertex-negate (get-sight~ eye-lookat)) ignore-player?: #t)
        (when (and distance
                   (< distance first-distance))
          distance)))
    
    (define (closer-eye-occlusion occlusion)
      ;; heuristic for the eye being far away and almost parallel to a wall
      (cond ((> occlusion 10.)
             (- occlusion 1.))
            ((> occlusion 5.)
             (- occlusion .75))
            (else
             (- occlusion .1))))
    
    (let ((occlusion (determine-eye-occlusion target)))
      (unless (eqv? occlusion first-override)
        (if (not occlusion)
            (set! first-occlusion? #f)
          (set! first-override (closer-eye-occlusion occlusion))
          (set! first-occlusion? #t)
          (occlusion-update-eye target))
        (adjust-player-alpha))))
  
  
  (method (occlusion-update-eye target)
    (vertex-! eye target (vertex-scalar* (get-sight~ eye-lookat) (effective-first-distance)))
    (vertex+! eye-target eye (get-sight~ eye-lookat)))
  
  
  (method (mark-eye target)
    (set-marks (list (new Mark (copy-vertex target) color: {Color Red})
                     (new Mark (copy-vertex eye-target) color: {Color Green})
                     (new Mark (copy-vertex eye) color: {Color Blue}))))
  
  
  (method (ray-closest-sprite p d (ignore-player?: ignore-player? #f))
    (let ((sprite #f)
          (distance #f))
      (iterate-all
        (lambda (targ)
          (unless (and ignore-player? (eq? targ player))
            (when (ray-intersects-sphere? p d (get-center~ targ) (get-radius~ targ))
              (let ((dist (ray-distance~ targ p d)))
                (when (and (/= dist -1.)
                           (or (not distance)
                               (< dist distance)))
                  (set! sprite targ)
                  (set! distance dist)))))))
      (values sprite distance)))
  
  
  (method (strafe-camera center-x)
    (let ((eye-x (vertex-x eye)))
      (if (> center-x (+ eye-x camera-limit))
          (strafe-horizontally (- center-x (+ eye-x camera-limit))))
      (if (< center-x (- eye-x camera-limit))
          (strafe-horizontally (- center-x (- eye-x camera-limit))))))
  
  
  (method (center-camera)
    (unless paused?
      (case projection
        ((perspective)
         (follow-player))
        ((orthographic)
         (strafe-camera (get-x~ player))))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (effective-first-distance)
    (or first-override first-distance))
  
  
  (method (first-distance-closer)
    (let ((distance (effective-first-distance)))
      (set! first-override #f)
      (set! first-distance (* distance .75))
      (center-camera)
      (adjust-player-alpha)))
  
  
  (method (first-distance-further)
    (let ((distance (effective-first-distance)))
      (set! first-override #f)
      (set! first-distance (min (/ distance .75) max-distance))
      (center-camera)
      (adjust-player-alpha)))
  
  
  (method (adjust-player-alpha)
    (when player
      (if (contains-vertex?~ player eye)
          (set-alpha~ player 0.)
        (set-alpha~ player (max 0.2 (min 1. (/ (effective-first-distance) 10.)))))))
  
  
  (method (move-player-forward factor)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* (get-sight~ (get-lookat~ player)) (* factor (if fly? 1.5 0.5))))))
  
  
  (method (move-player-backward factor)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* (get-sight~ (get-lookat~ player)) (* factor (if fly? 1.5 0.5))))))
  
  
  (method (strafe-player-left factor)
    (set-position~ player (vertex- (get-position~ player) (vertex-scalar* (get-right~ eye-lookat) (* factor (if fly? 1.0 0.5))))))
  
  
  (method (strafe-player-right factor)
    (set-position~ player (vertex+ (get-position~ player) (vertex-scalar* (get-right~ eye-lookat) (* factor (if fly? 1.0 0.5))))))
  
  
  (method (strafe-player-up factor)
    (strafe-player-vertical (* (camera-strafe-speed) 2)))
  
  
  (method (strafe-player-down factor)
    (strafe-player-vertical (- (* (camera-strafe-speed) 2))))
  
  
  (method (strafe-player-vertical distance)
    (vertex-copy! eye (vertex+ eye (vertex-scalar* world-up distance)))
    (update-camera)
    (set-y~ player (+ (get-y~ player) distance))
    (follow-player))
  
  
  (definition player-rotation-speed
    0.02)
  
  
  (method (rotate-player-left factor)
    (rotate-player-horizontal (* player-rotation-speed factor))
    (when fly?
      (tilt-player -1.)))
  
  
  (method (rotate-player-right factor)
    (rotate-player-horizontal (- (* player-rotation-speed factor)))
    (when fly?
      (tilt-player 1.)))
  
  
  (method (rotate-player-horizontal angle (follow-player?: follow-player? #t))
    (rotate~ (get-lookat~ player) angle world-up)
    (unless (and down? (not moving?))
      (rotate~ eye-lookat angle world-up))
    (when follow-player?
      (follow-player)))
  
  
  (method (rotate-player-vertical angle (follow-player?: follow-player? #t))
    (let ((lookat (get-lookat~ player)))
      (rotate~ lookat angle (get-right~ lookat)))
    (rotate~ eye-lookat angle (get-right~ eye-lookat))
    (when follow-player?
      (follow-player)))
  
  
  (method (tilt-player speed)
    @fix-me
    (let ((lookat (get-lookat~ player))
          (max-tilt PI/8)
          (max-speed 0.4))
      (let ((current (vertical-angle (get-right~ lookat) world-up))
            (desired (* (sign speed) max-tilt)))
        (set! desired-tilt desired)
        (set! tilt-speed (min (/ (abs speed) 50000.) max-speed))
        (set! last-tilt-time (time->seconds (current-time)))
        (process-tilt))))
  
  
  (method (reset-player-tilt)
    @fix-me
    (when (or (not last-tilt-time)
              (> (- (time->seconds (current-time)) last-tilt-time) .1))
      (set! desired-tilt 0.)
      (set! tilt-speed .015)
      (process-tilt)))
  
  
  (method (process-tilt)
    @fix-me
    (let ((lookat (get-lookat~ player)))
      (let ((current (vertical-angle (get-right~ lookat) world-up)))
        (unless (near? current desired-tilt .001)
          (let ((direction (sign (- desired-tilt current))))
            (let ((new-tilt (+ current (* direction tilt-speed))))
              (case direction
                ((1) (when (> new-tilt desired-tilt) (set! new-tilt desired-tilt)))
                ((-1) (when (< new-tilt desired-tilt) (set! new-tilt desired-tilt))))
              (let ((inc (- new-tilt current)))
                (increase-player-tilt inc))))))))
  
  
  (method (increase-player-tilt inc)
    @fix-me
    (let ((lookat (get-lookat~ player)))
      (rotate~ lookat inc (get-sight~ lookat))))
  
  
  (method (toggle-player-target)
    (set! player-target? (not player-target?)))

  
  (method (draw-player-target)
    (let ((target (player-target)))
      (let ((x (vertex-x target))
            (y (vertex-y target))
            (z (vertex-z target))
            (size .5))
        (glDisable GL_DEPTH_TEST)
        (glDisable GL_LIGHTING)
        (glBegin GL_LINES)
        (gl-colorize {Color Red})
        (glVertex3f (- x size) y z)
        (glVertex3f (+ x size) y z)
        (gl-colorize {Color Green})
        (glVertex3f x (- y size) z)
        (glVertex3f x (+ y size) z)
        (gl-colorize {Color Blue})
        (glVertex3f x y (- z size))
        (glVertex3f x y (+ z size))
        (glEnd)
        (glEnable GL_LIGHTING)
        (glEnable GL_DEPTH_TEST))))
  
  
  ;;;
  ;;;; Gadget
  ;;;
  
  
  (method (draw-gadgets)
    (for-each draw~ gadgets))
  
  
  (method (toggle-draw-gadgets)
    (set! draw-gadgets? (not draw-gadgets?))
    (display-on/off "Draw gadgets" draw-gadgets?))
  
  
  ;;;
  ;;;; Light
  ;;;
    
  
  (method (setup-lights)
    (set! light? #t))

  
  (method override (setup-lighting)
    (when light?
      (glEnable GL_LIGHTING)
      (glDisable GL_LIGHT0)
      (glDisable GL_LIGHT1)
      (glDisable GL_LIGHT2)
      (glDisable GL_LIGHT3)
      (glDisable GL_LIGHT4)
      (glDisable GL_LIGHT5)
      (glDisable GL_LIGHT6)
      (glDisable GL_LIGHT7)
      (let ((color (or ambient-color {Color red: .5 green: .5 blue: .5 alpha: 1.0})))
        (gl-light-model GL_LIGHT_MODEL_AMBIENT (get-red~ color) (get-green~ color) (get-blue~ color) (get-alpha~ color)))
      (let ((color (or material-specular {Color red: .1 green: .1 blue: .1 alpha: 1.0})))
        (gl-material-specular GL_FRONT (get-red~ color) (get-green~ color) (get-blue~ color) (get-alpha~ color)))
      (let ((value (or material-shininess 50.)))
        (gl-material-shininess GL_FRONT value))
      (let ((no GL_LIGHT0))
        (iterate-lights
          (lambda (light)
            (glEnable no)
            (gl-light no
                      GL_DIFFUSE
                      (get-red~ light)
                      (get-green~ light)
                      (get-blue~ light)
                      (get-alpha~ light))
            (gl-light no
                      GL_POSITION
                      (get-x~ light)
                      (get-y~ light)
                      (get-z~ light)
                      (get-w~ light))
            (increase! no))))))
  
  
  (method (iterate-lights proc)
    (iterate-gadgets
      (lambda (gadget)
        (when (is? gadget Light)
          (proc gadget)))))
  
  
  (method (count-lights)
    (let ((count 0))
      (iterate-lights
        (lambda (light)
          (increase! count)))
      count))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method (prepare-render)
    (activate~ history-render-target)
    (glClear GL_COLOR_BUFFER_BIT)
    
    (activate~ render-target)
    (glClear GL_COLOR_BUFFER_BIT)
    (glClear GL_DEPTH_BUFFER_BIT))
  
  
  (method (post-render)
    (deactivate~ render-target)
    
    (glClearColor 0. 0. 0. 1.)
    (glClear GL_COLOR_BUFFER_BIT)
    (glClear GL_DEPTH_BUFFER_BIT)
    
    (activate~ post-process-shader)
    (glActiveTexture GL_TEXTURE0)
    (glBindTexture GL_TEXTURE_2D (get-texture~ render-target))
    (glUniform1i pp-uniform-location 0)
    (glActiveTexture GL_TEXTURE1)
    (glBindTexture GL_TEXTURE_2D (get-texture~ history-render-target))
    (glUniform1i pp-history-location 1)
    (glEnableVertexAttribArray pp-attribute-location)
    
    (glBindBuffer GL_ARRAY_BUFFER vbo/fbo-vertices)
    (glVertexAttribPointer pp-attribute-location 2 GL_FLOAT GL_FALSE 0 #f)
    (glDrawArrays GL_TRIANGLE_STRIP 0 4)
    (glDisableVertexAttribArray pp-attribute-location)
    (deactivate~ post-process-shader))
  
  
  (method protected override (draw-world)
    (start~ render-counter)
    (if post-processing?
        (prepare-render)
      (deactivate~ render-target))
    (prepare-world)
    
    (process-keys)
    
    (setup-camera)
    (setup-lighting)
    (glEnable GL_DEPTH_TEST)
    (glShadeModel GL_SMOOTH)
    
    (draw-objects)
    (render-interface)
    (when post-processing?
      (post-render))
    (end~ render-counter))
  
  (method (draw-blocks)
    ;; Activate the block shader (does texturing - we need to add lighting)
    (activate~ block-shader)
    (glEnableClientState GL_VERTEX_ARRAY)
    
    ;; Pass the block texture to the shader
    (glActiveTexture GL_TEXTURE0)
    (glBindTexture GL_TEXTURE_2D (get-texture~ block-texture))
    (glUniform1i block-texture-location 0)
    
    (glEnableVertexAttribArray block-location)
    (glEnableVertexAttribArray block-tex-location)
    
    ;; Activate the VAO
    (glBindBuffer GL_ARRAY_BUFFER test-vao)
    
    ;; Tell the shader where to read the verteces from the VBO
    (glVertexAttribPointerCustom* block-location 3 GL_FLOAT GL_FALSE 24 0)
  
    ;; Tell the shader where to read texcoords from the VBO  
    (glVertexAttribPointerCustom* block-tex-location 3 GL_FLOAT GL_FALSE 24 12)
    
    ;; Draw the VBO on screen
    (glDrawArrays GL_TRIANGLES 0 (/ (f32vector-length test-vbo-vertices) 3))
    
    ;; Disable all array/pointer assignments
    (glDisableVertexAttribArray block-location)
    (glDisableVertexAttribArray block-tex-location)
    (glBindBuffer GL_ARRAY_BUFFER 0)
    (glDisableClientState GL_VERTEX_ARRAY)
    
    ;; Deactivate the block shader
    (deactivate~ block-shader))
  
  (method override (draw-objects)
    (case projection
      ((perspective)
       (if 3d?
           (glEnable GL_DEPTH_TEST)
         (glDisable GL_DEPTH_TEST)))
      ((orthographic)
       (glDisable GL_DEPTH_TEST)))
    (draw-grid)
    (when axes?
      (draw-axes))
    (when debug-areas?
      (draw-areas))
    
    (when textures?
      (draw-blocks))
    (when draw-sprites?
    (draw-sprites))
    
    
    
    (draw-marks)
    (when target
      (draw-target))
    (when (and player player-target?)
      (draw-player-target))
    (when eye?
      (draw-eye))
    (when draw-gadgets?
      (draw-gadgets))
    (when paused?
      (draw-history)))
  
  
  (method (draw-sprites)
    (iterate-sprites
      (lambda (sprite)
        (unless (eq? sprite player)
          (draw~ sprite))))
    ;; draw potentially translucent objects last
    (when player
      (draw~ player)))
  
  
  (method (draw-target)
    (let ((x1 (get-left~ target))
          (y1 (get-bottom~ target))
          (z1 (get-back~ target))
          (x2 (get-right~ target))
          (y2 (get-top~ target))
          (z2 (get-front~ target)))
      (case projection
        ((perspective)
         (gl-colorize {Color Red})
         (glLineWidth 2.)
         (render-cube x1 y1 z1 x2 y2 z2
           (lambda (proc)
             (glBegin GL_LINE_LOOP)
             (proc)
             (glEnd)))
         (glLineWidth 1.))
        ((orthographic)
         (glNormal3f 0.0 0.0 1.0)
         (gl-colorize {Color Red})
         (glBegin GL_LINE_LOOP)
         (glVertex2f x1 y1)
         (glVertex2f x2 y1)
         (glVertex2f x2 y2)
         (glVertex2f x1 y2)
         (glEnd)))))
  
  
  (method (draw-axes)
    (glLineWidth 5.)
    (glDisable GL_LIGHTING)
    (glBegin GL_LINES)
    ;; X
    (glColor3f 1.0 0.0 0.0)
    (glVertex3f -50.0  0.0  0.0)
    (glVertex3f  50.0  0.0  0.0)
    (glVertex3f  50.0  0.0  0.0)
    (glVertex3f  47.5  0.0  2.5)
    (glVertex3f  50.0  0.0  0.0)
    (glVertex3f  47.5 0.0  -2.5)
    
    ;; Y
    (glColor3f 0.0 1.0 0.0)
    (glVertex3f  0.0 -50.0  0.0)
    (glVertex3f  0.0  50.0  0.0)
    (glVertex3f  0.0  50.0  0.0)
    (glVertex3f  2.5  47.5  0.0)
    (glVertex3f  0.0  50.0  0.0)
    (glVertex3f -2.5  47.5  0.0)
    
    ;; Z
    (glColor3f 0.0 0.0 1.0)
    (glVertex3f  0.0  0.0 -50.0)
    (glVertex3f  0.0  0.0  50.0)
    (glVertex3f  0.0  0.0  50.0)
    (glVertex3f  2.5  0.0  47.5)
    (glVertex3f  0.0  0.0  50.0)
    (glVertex3f -2.5  0.0  47.5)
    (glEnd)
    (glEnable GL_LIGHTING)
    (glLineWidth 1.))
  
  
  (method (draw-grid)
    (when grid?
      (glDisable GL_LIGHTING)
      (when grid-x?
        (let ((min -500.)
              (max 500.))
          (gl-colorize {Color Yellow})
          (glBegin GL_LINES)
          (loop (for y <fl> from min to max by 5.)
                (glVertex3f grid-x y min)
                (glVertex3f grid-x y max))
          (loop (for z <fl> from min to max by 5.)
                (glVertex3f grid-x min z)
                (glVertex3f grid-x max z))
          (glEnd)))
      (when grid-y?
        (let ((min -500.)
              (max 500.))
          (gl-colorize {Color Green})
          (glBegin GL_LINES)
          (loop (for x <fl> from min to max by 5.)
                (glVertex3f x grid-y min)
                (glVertex3f x grid-y max))
          (loop (for z <fl> from min to max by 5.)
                (glVertex3f min grid-y z)
                (glVertex3f max grid-y z))
          (glEnd)))
      (when grid-z?
        (let ((min -500.)
              (max 500.))
          (gl-colorize {Color Red})
          (glBegin GL_LINES)
          (loop (for x <fl> from min to max by 5.)
                (glVertex3f x min grid-z)
                (glVertex3f x max grid-z))
          (loop (for y <fl> from min to max by 5.)
                (glVertex3f min y grid-z)
                (glVertex3f max y grid-z))
          (glEnd)))
      (glEnable GL_LIGHTING)))
  
  
  (method (draw-history)
    (draw-history~ history draw-player))
  
  
  (method (draw-player n)
    (let ((snapshot (get-snapshot~ (historical-moment n))))
      (let ((player (get-player~ snapshot)))
        (when player
          (parameterize ((in-history? #t))
            (draw~ player))))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  (method override (draw-interface)
    (nextmethod)
    (when info?
      (draw~ info))
    (when message
      (draw-message))
    (when status
      (draw-status))
    (when counters?
      (draw-rate~ gc-counter #t)
      (draw-rate~ tick-counter)
      (draw-rate~ render-counter))
    (when (and history? paused?)
      (draw-history-slider)))
  
  
  (method (draw-history-slider)
    (draw-history-slider~ history))
  
  
  ;;;
  ;;;; Win / Lose
  ;;;
  
  
  (method (win)
    (win~ player)
    (let ((block (find-if (lambda (obj)
                            (eq? (get-user-data~ obj) 'win))
                          blocks)))
      (set-color~ block {Color Blue}))
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (lose)
    (lose~ player)
    (unless paused?
      (sleep .5)
      (reset-position~ player)
      (reset-state~ player)
      (reset-game)))
  
  
  (method (reset-game)
    (setup-history))
    
  
  ;;;
  ;;;; Save / Open
  ;;;

  
  (method (new-world)
    (let ((world (make-world 'Live-World 'world.data)))
      (setup-live world)
      (set-world~ window world))
    (close))
  
  
  (method (save-world)
    (let ((moniker (get-moniker)))
      (if moniker
          (save-to moniker)
        (save-as-world))))
  
  
  (method (save-as-world)
    (let ((file (choose-new-file default-extension: "wrl" extensions: '(("World Files" . "wrl")) directory: {Directory Settings "levels"})))
      (save-to file)
      (update-title)))
  
  
  (method (save-to file)
    (set-property~ designer player 'x (get-x~ player))
    (set-property~ designer player 'y (get-y~ player))
    (set-property~ designer player 'z (get-z~ player))
    (save-to~ designer file)
    (display-message "Saved"))
  
  
  (method (open-world (reversed?: reversed? #f))
    (let ((files (collect-files~ {Directory Settings "levels"} (lambda (file) (extension=? (get-extension~ file) "wrl")))))
      (if (null? files)
          (begin
            (display-error "No files found")
            (bell))
        (let ((moniker (get-moniker)))
          (if (not moniker)
              (open-file ((if reversed? last car) files))
            (let ((next (if reversed? previous-element next-element)))
              (let ((file (next files moniker test: pathname=?)))
                (open-file file))))))))
  
  
  (method (open-file file)
    (let ((form (read-form file)))
      (let ((world (instantiate~ form)))
        (set-designer~ world (new Designer form: form reference: world))
        (setup-live world)
        (update-children~ world)
        (setup-world~ world)
        (when (eq? (get-start-mode~ world) 'first-person)
          (activate-first-person~ world)
          (follow-player~ world))
        (set-world~ window world)
        (display-message~ world (get-base~ file))))
    (close))
  
  
  (method (revert-world)
    (let ((moniker (get-moniker)))
      (if moniker
          (open-file moniker)
        (bell))))
  
  
  (method (update-children)
    (for-each (lambda (obj)
                (when (is? obj Sprite)
                  (add-sprite obj)
                  (when (is? obj Player)
                    (set! player obj))))
              children))
  
  
  (method (update-title)
    (define (present-title moniker modified?)
      (format "World - {a}{a}{a}"
              (present-name moniker)
              (present-modified modified?)
              (present-directory moniker)))
    
    (define (present-name moniker)
      (if (not moniker)
          "New"
        (get-name~ moniker)))
    
    (define (present-modified modified?)
      (if modified?
          " *"
        ""))
    
    (define (present-directory moniker)
      (if (not moniker)
          ""
        (let ((parent (get-parent~ moniker)))
          (if (not parent)
              ""
            (format " ~{{a}}" (present-location~ parent))))))
    
    (set-title~ window (present-title (get-moniker) (get-modified?))))
  
  
  (method (get-moniker)
    (get-origin~ (get-form~ designer)))
  
  
  (method (get-modified?)
    (get-modified?~ designer))
  
  
  (method (set-modified? flag)
    (when (neq? flag (get-modified?~ designer))
      (set-modified?~ designer flag)
      (update-title)))
  
  
  (method (reset-live)
    (set! actors '())
    (set! blocks '())
    (set! sprites '())
    (set-target #f)
    (reset-world)
    (center-camera)
    (reset-counters)
    (update-debug-variables)
    (display-message "World reset"))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (slot designer      <object> initialize #f  accessors generate)
  (slot editor-mode   <object> initialize #f  getter generate)
  (slot editor-anchor <object> initialize #f  getter generate)
  (slot editor-last   <object> initialize #f  getter generate)
  (slot editor-added  <object> initialize #f  getter generate)
  (slot adding?       <bool>   initialize #f  getter generate)
  (slot deleting?     <bool>   initialize #f  getter generate)
  (slot grid-x        <fl>     initialize 0.  getter generate)
  (slot grid-y        <fl>     initialize 0.  getter generate)
  (slot grid-z        <fl>     initialize 10. getter generate)
  (slot grid?         <bool>   initialize #f  getter generate)
  (slot grid-x?       <bool>   initialize #f  getter generate)
  (slot grid-y?       <bool>   initialize #f  getter generate)
  (slot grid-z?       <bool>   initialize #f  getter generate)
  (slot last-added    <object> initialize #f  getter generate)
  (slot players-folio <Folio>                 getter generate)
  (slot enemies-folio <Folio>                 getter generate)
  (slot blocks-folio  <Folio>                 getter generate)
  (slot gadgets-folio <Folio>                 getter generate)
  
  
  (method (prepare-editor)
    (set! editor-mode 'point)
    (set! players-folio (new Folio 'player '(player pacman)))
    (set! enemies-folio (new Folio 'turtle '(turtle monster)))
    (set! blocks-folio (new Folio 'block '(block block-red block-green block-blue)))
    (set! gadgets-folio (new Folio 'light '(light))))
  
  
  (method (switch-editor-mode)
    (let ((new-mode (next-element '(select point @wait line rectangle) editor-mode)))
      (set! editor-mode new-mode)
      (display-message (capitalize (->string new-mode)))))
  
  
  (method (find-sprite vert)
    (continuation-capture
      (lambda (return)
        (let ((x (vertex-x vert))
              (y (vertex-y vert))
              (z (vertex-z vert)))
          (let ((area (index-area (position-area-index x y z))))
            (iterate-area-sprites area
              (lambda (obj)
                (when (and (>= x (get-left~ obj))
                           (>= y (get-bottom~ obj))
                           (>= z (get-back~ obj))
                           (<  x (get-right~ obj))
                           (<  y (get-top~ obj))
                           (<  z (get-front~ obj)))
                  (continuation-return return obj))))))
        #f)))
  
  
  (method (screen->ray h v)
    (vertex-normalize (vertex- (screen->target h v) eye)))
  
  
  (method (screen->target h v)
    (let ((ratio (/ width height))
          (ch (- h (/ width 2)))
          (cv (- (- height v) (/ height 2))))
      (let ((f-over-y (/ PI/4 2.)))
        (let ((cone (tan f-over-y))
              (d (vertex-distance eye eye-target))
              (right (cross-product (vertex- eye-target eye) (get-up~ eye-lookat))))
          (let ((target-in-eye-space (vertex+ (vertex-scalar* (get-up~ eye-lookat) (/ (* cv d cone 2.) height))
                                              (vertex+ (vertex-scalar* right (/ (* ch d cone 2. ratio) width))
                                                       eye-target))))
            target-in-eye-space)))))
  
  
  (method (screen->world h v)
    (let ((ratio (/ width height))
          (ch (- h (/ width 2)))
          (cv (- (- height v) (/ height 2))))
      (define (perspective->world norm plane-k)
        (let ((norm-eye-sight-inner-product (inner-product norm (vertex-normalize (get-sight~ eye-lookat)))))
          (unless (and (= norm-eye-sight-inner-product 0.)
                       (cond (grid-x? (= (vertex-x eye) grid-x))
                             (grid-y? (= (vertex-y eye) grid-y))
                             (grid-z? (= (vertex-z eye) grid-z))))
            (let ((target-in-eye-space (screen->target h v)))
              (let ((intersect (/ (- plane-k (inner-product norm eye))
                                  (inner-product (vertex- target-in-eye-space eye) norm))))
                (unless (<= intersect 0)
                  (let ((point (vertex+ eye (vertex-scalar* (vertex- target-in-eye-space eye) intersect))))
                    point)))))))
      
      (define (orthographic->world)
        (let ((x (+ (/ (* 2. ch zoom-factor) width) @w (vertex-x eye)))
              (y (+ (/ (* 2. cv zoom-factor) height ratio) (vertex-y eye))))
          (vertex (- x 3.) y 0.)))
      
      (case projection
        ((perspective)
         (when grid?
           (cond (grid-x? (let ((vert (perspective->world (vertex 1. 0. 0.) grid-x)))
                            (and vert (vertex
                                        grid-x
                                        (vertex-y vert)
                                        (vertex-z vert)))))
                 (grid-y? (let ((vert (perspective->world (vertex 0. 1. 0.) grid-y)))
                            (and vert (vertex
                                        (vertex-x vert)
                                        grid-y
                                        (vertex-z vert)))))
                 (grid-z? (let ((vert (perspective->world (vertex 0. 0. 1.) grid-z)))
                            (and vert (vertex
                                        (vertex-x vert)
                                        (vertex-y vert)
                                        grid-z))))
                 (else #f))))
        ((orthographic)
         (orthographic->world)))))
  
  
  (method (add-sprite-class class x y z)
    (define (add class)
      (let ((obj (new class parent: self x: x y: y z: z)))
        (add-child~ designer obj self import: '(world.data) properties: (list x: x y: y z: z))
        (add-sprite obj)
        obj))
    
    (let ((sprite
            (case class
              ((player) (add Player))
              ((pacman) (add Pacman))
              ((turtle) (add Turtle))
              ((monster) (add Monster))
              ((block) (add Block))
              ((block-red) (add Block-Red))
              ((block-green) (add Block-Green))
              ((block-blue) (add Block-Blue))
              ((light) (add Light)))))
      (when (is? sprite Player)
        (when player
          (remove-sprite player))
        (set! player sprite))
      (update-debug-variables)
      sprite))
  
  
  (method (editor-add-sprite class vert)
    (define (sign r)
      (if (< r 0)
          -1
        1))
    
    (define (sign-test sign)
      (if (= sign -1)
          >=
        <=))
    
    (define (add-at left bottom back)
      (let ((sprite (add-sprite-class class left bottom back)))
        (set-property~ designer sprite 'x (+ (get-x~ sprite) (get-radius-x~ sprite)))
        (set-property~ designer sprite 'y (+ (get-y~ sprite) (get-radius-y~ sprite)))
        (set-property~ designer sprite 'z (+ (get-z~ sprite) (get-radius-z~ sprite)))
        (update-position~ sprite)
        sprite))
    
    (let ((to-x (* (floor (/ (vertex-x vert) 5.)) 5.))
          (to-y (* (floor (/ (vertex-y vert) 5.)) 5.))
          (to-z (* (floor (/ (vertex-z vert) 5.)) 5.)))
      (if (not editor-anchor)
          (let ((sprite (add-at to-x to-y to-z)))
            (set! last-added sprite)
            (set! editor-anchor (vertex to-x to-y to-z)))
        (unless (and editor-last
                     (= (vertex-x editor-last) to-x)
                     (= (vertex-y editor-last) to-y)
                     (= (vertex-z editor-last) to-z))
          (case editor-mode
            ((point)
             (let ((sprite (add-at to-x to-y to-z)))
               (set! last-added sprite)))
            ((line))
            ((rectangle)
             (let ((anchor-x (vertex-x editor-anchor))
                   (anchor-y (vertex-y editor-anchor))
                   (anchor-z (vertex-z editor-anchor)))
               (let ((sign-x (sign (- to-x anchor-x)))
                     (sign-y (sign (- to-y anchor-y)))
                     (sign-z (sign (- to-z anchor-z))))
                 (let ((step-x (* sign-x 5.))
                       (step-y (* sign-y 5.))
                       (step-z (* sign-z 5.))
                       (test-x (sign-test sign-x))
                       (test-y (sign-test sign-y))
                       (test-z (sign-test sign-z)))
                   (let ((queue (new-queue))
                         (max-size 30))
                     (let (iter-x (x anchor-x) (count-x 0))
                       (when (and (< count-x max-size)
                                  (test-x x to-x))
                         (let (iter-y (y anchor-y) (count-y 0))
                           (when (and (< count-y max-size)
                                      (test-y y to-y))
                             (let (iter-z (z anchor-z) (count-z 0))
                               (when (and (< count-z max-size)
                                          (test-z z to-z))
                                 (let ((sprite (or (find-sprite (vertex x y z))
                                                   (add-at x y z))))
                                   (enqueue queue sprite))
                                 (iter-z (+ z step-z) (+ count-z 1))))
                             (iter-y (+ y step-y) (+ count-y 1))))
                         (iter-x (+ x step-x) (+ count-x 1))))
                     (let ((added (queue-list queue)))
                       (when editor-added
                         (for-each remove-sprite (difference editor-added added)))
                       (set! editor-added added))))))))
          (set! editor-last (vertex to-x to-y to-z))))))
  
  
  (method (editor-sprite-class)
    (let ((alt? (alt-down?))
          (shift? (shift-down?)))
      (cond ((and alt? shift?) (get-class~ players-folio))
            (shift? (get-class~ enemies-folio))
            (alt? (get-class~ gadgets-folio))
            (else (get-class~ blocks-folio)))))
  
  
  (method (sprite-folio sprite)
    (typecase sprite
      ((Player) players-folio)
      ((Enemy) enemies-folio)
      ((Block) blocks-folio)
      (else #f)))
  
  
  (method (forward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (next-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)
          (display-message (format "{a}" new-class))))))
  
  
  (method (backward-sprite-class)
    (if (not last-added)
        (bell)
      (let ((folio (sprite-folio last-added)))
        (let ((new-class (previous-element (get-list~ folio) (get-class~ folio))))
          (set-class~ folio new-class)
          (change-class last-added new-class)
          (display-message (format "{a}" new-class))))))
  
  
  (method (change-class sprite class)
    (let ((vert (vertex (get-x~ sprite) (get-y~ sprite) (get-z~ sprite))))
      (remove-sprite sprite)
      (editor-add-sprite class vert)))
  
  
  (method (remove-target)
    (if (not target)
        (bell)
      (remove-sprite target)
      (set-modified? #t)))
  
  
  (method (remove-sprite obj)
    (typecase obj
      ((Actor) (set! actors (remove! obj actors)))
      ((Block) (set! blocks (remove! obj blocks)))
      (else (set! gadgets (remove! obj gadgets))))
    (set! sprites (remove! obj sprites))
    (when (eq? obj player)
      (set! player #f))
    (when (eq? obj target)
      (set-target #f))
    (area-remove-sprite (sprite-area obj) obj)
    (update-debug-variables))
  
  
  (method (toggle-grid)
    (set! grid? (not grid?))
    (activate-3d))
  
  
  (method (toggle-grid-x)
    (set! grid-x? (or (not grid?) (not grid-x?)))
    (when grid-x?
      (set! grid? #t)
      (set! grid-y? #f)
      (set! grid-z? #f)
      (activate-3d)))
  
  
  (method (toggle-grid-y)
    (set! grid-y? (or (not grid?) (not grid-y?)))
    (when grid-y?
      (set! grid? #t)
      (set! grid-x? #f)
      (set! grid-z? #f)
      (activate-3d)))
  
  
  (method (toggle-grid-z)
    (set! grid-z? (or (not grid?) (not grid-z?)))
    (when grid-z?
      (set! grid? #t)
      (set! grid-x? #f)
      (set! grid-y? #f)
      (activate-3d)))
  
  
  (method (decrease-grid)
    (move-grid-by -1))
  
  
  (method (increase-grid)
    (move-grid-by 1))
  
  
  (method (move-grid delta)
    (move-grid-by (fxround/ (- delta) 120)))
  
  
  (method (move-grid-by incr)
    (let ((dist (* incr 5.)))
      (cond (grid-x? (increase! grid-x dist) (display-status (format "Grid at {a}" grid-x)))
            (grid-y? (increase! grid-y dist) (display-status (format "Grid at {a}" grid-y)))
            (grid-z? (increase! grid-z dist) (display-status (format "Grid at {a}" grid-z))))))
  
  
  (method (editor-mouse-down h v)
    (let ((vert (screen->world h v)))
      (if (not vert)
          (when (control-down?)
            (unless (and grid? (or grid-x? grid-y? grid-z?))
              (display-error "3d edition requires a grid"))
            (bell))
        (let ((obj (find-sprite vert)))
          (if obj
              (if (control-down?)
                  (begin
                    (show-cursor)
                    (set! preserved-mouse #f)
                    (set! deleting? #t)
                    (set! editor-anchor #f)
                    (set! editor-last #f)
                    (remove-sprite obj)
                    (set-modified? #t)
                    (update-future)))
            (if (control-down?)
                (begin
                  (show-cursor)
                  (set! preserved-mouse #f)
                  (set! editor-anchor #f)
                  (set! editor-last #f)
                  (set! adding? #t)
                  (let ((class (editor-sprite-class)))
                    (editor-add-sprite class vert)
                    (set-modified? #t))
                  (update-future))))))))
  
  
  (method (editor-mouse-move h v)
    (when down?
      (let ((vert (screen->world h v)))
        (when vert
          (let ((obj (find-sprite vert)))
            (if (and obj (not editor-anchor))
                (when deleting?
                  (remove-sprite obj)
                  (set-modified? #t)
                  (update-future))
              (when adding?
                (let ((class (editor-sprite-class)))
                  (editor-add-sprite class vert)
                  (set-modified? #t))
                (update-future))))))))
  
  
  (method (editor-mouse-up h v)
    (when (or grid? draw-gadgets? (neq? projection 'perspective))
      (unless (or adding? deleting?)
        (case projection
          ((perspective)
           (let ((direction (screen->ray (get-h~ down-point) (get-v~ down-point))))
             (receive (sprite distance) (ray-closest-sprite eye direction ignore-player?: #t)
               (set-target sprite))))
          (else
           (let ((vert (screen->world h v)))
             ;(debug vert (and vert (find-sprite vert)))
             (if (not vert)
                 (set-target #f)
               (set-target (find-sprite vert))))))))
    (set! adding? #f)
    (set! deleting? #f)
    (set! editor-anchor #f)
    (set! editor-last #f)
    (set! editor-added #f)
    (update-debug-variables))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (slot evaluate-hook? initialize #t getter generate)
  
  
  (method (toggle-paused)
    (if paused?
        (unpause-world)
      (pause-world)))
  
  
  (method (toggle-evaluation)
    (set! evaluate-hook? (not evaluate-hook?))
    (display-on/off "Evaluation" evaluate-hook?))
  
  
  (method (pause-world)
    (when history?
      (set-current~ history (snapshot-world)))
    (set! paused? #t)
    (set! animate? #f)
    (reset-counters))
  
  
  (method (unpause-world)
    (truncate-future)
    (set-current~ history #f)
    (set! paused? #f)
    (set! animate? #t)
    (follow-player)
    (reset-counters))
  
  
  (method (snapshot-world)
    (let ((actors (map object-copy actors))
          (marks (map object-copy marks)))
      (new Snapshot
        actors
        (find-player actors)
        marks)))
  
  
  (method (load-world snapshot)
    (let ((previous-target target))
      (set! actors (map object-copy (get-actors~ snapshot)))
      (set! marks (map object-copy (get-marks~ snapshot)))
      (set! sprites (append blocks actors))
      (set! player (find-player actors))
      (set-target (and previous-target (find-target previous-target sprites)))
      (setup-areas)
      (setup-lights)
      (for-each (lambda (sprite)
                  (area-add-sprite (sprite-area sprite) sprite))
                sprites))
    (update-debug-variables))
  
  
  (method (find-player actors)
    (find-if (lambda (obj)
               (is? obj Player))
             actors))
  
  
  (method (find-target target sprites)
    (let ((origin (get-origin~ target)))
      (find-if (lambda (obj)
                 (eq? (get-origin~ obj) origin))
               sprites)))
  
  
  (method (set-target targ)
    (set! target targ)
    (set-?t targ))
  
  
  (method (update-debug-variables)
    (set-?p player)
    (set-?t target))
  
  
  (method (toggle-draw-sprites)
    (set! draw-sprites? (not draw-sprites?))
    (display-on/off "Draw sprites" draw-sprites?))
  
  
  ;;;
  ;;;; Evaluate
  ;;;
  
  
  (method override (evaluate-hook)
    (when evaluate-hook?
      (setup-lights)
      (setup-lighting)
      (update-future)))
  
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method (test-world)
    )
  
  
  (method (test-shift-world)
    )
  
  
  (method (test1-world)
    )
  
  
  (method (test2-world)
    )
  
  
  (method (test3-world)
    )
  
  
  (method (test4-world)
    )
  
  
  (method (test5-world)
    )
  
  
  (method (test6-world)
    )
  
  
  (method (test7-world)
    )
  
  
  (method (test8-world)
    )
  
  
  (method (test9-world)
    (if (validate-areas)
        (display-message "Areas valid" color: {Color Green})
      (display-message "Areas corrupted!" color: {Color Red})
      (set! info? #t)))
  
  
  (method (test0-world)
    (testing? (not (testing?)))
    (display-on/off "Testing" (testing?)))
  
  
  ;;;
  ;;;; GC
  ;;;
  
  
  (method (setup-gc)
    (add-gc-interrupt-job!
      (lambda ()
        (process~ gc-counter (last-gc-real-time)))))
  
  
  ;;;
  ;;;; Slider
  ;;;
  
  
  (slot sliding? initialize #f)
  
  
  (method (slider-mouse-down h v)
    (set! sliding? #t)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-move h v)
    (slide-history (h->where h)))
  
  
  (method (slider-mouse-up h v)
    (set! sliding? #f))
  
  
  (method (h->where h)
    (let ((cx (fxround (/ width 2.))))
      (let ((where (/ (+ (- h cx) 200.) 400.)))
        (max 0. (min 1. where)))))
  
  
  (method (in-slider? v)
    (< v 60))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down h v)
    (set! down? #t)
    (set! down-point (new Point h v))
    (cond ((and history? paused? (in-slider? v))
           (slider-mouse-down h v))
          (paused?
           (setup-viewing h v)
           (nextmethod h v))
          (else
           (editor-mouse-down h v))))
  
  
  (method override (mouse-move h v)
    (cond ((and history? paused? sliding?)
           (slider-mouse-move h v))
          (paused?
           (nextmethod h v))
          (last-point
           (nextmethod h v)
           (unless moving?
             (follow-player)))
          ((or adding? deleting?)
           (editor-mouse-move h v))
          ((and down? (not (near? (new Point h v) down-point drag-tolerance)))
           (hide/preserve-cursor)
           (set! viewing? #t)
           (setup-viewing h v))))
  
  
  (method override (mouse-track elapse dh dv)
    (when (eq? projection 'perspective)
      (if (and player moving? (not paused?))
          (let ((tilt (vertical-angle (get-right~ eye-lookat) world-up)))
            ;; remove tilt
            (when (not fly?)
              @fix-me
              (rotate~ eye-lookat (- tilt) (get-sight~ eye-lookat)))
            (let ((pitch (vertical-angle (get-sight~ eye-lookat) world-up)))
              ;; remove pitch
              (when (not fly?)
                (rotate-vertical pitch))
              (when (not moved?)
                (let ((lookat (get-lookat~ player)))
                  (set-sight~ lookat (get-sight~ eye-lookat))
                  (set-up~ lookat (get-up~ eye-lookat))
                  (set-right~ lookat (get-right~ eye-lookat)))
                (set! moved? #t))
              ;; remove tilt
              (when fly?
                @fix-me
                (rotate~ eye-lookat (- tilt) (get-sight~ eye-lookat)))
              ;; remove pitch
              (when fly?
                (rotate-vertical pitch))
              (rotate-player-horizontal (/ (- dh) 200.) follow-player?: #f)
              ;; restore pitch
              (rotate-vertical (- pitch))
              (if fly?
                  (rotate-player-vertical (/ (- dv) 200.) follow-player?: #f)
                (rotate-vertical (/ (- dv) 200.)))
              (follow-player)
              ;; restore tilt
              @fix-me
              (rotate~ eye-lookat tilt (get-sight~ eye-lookat))
              @fix-me
              (when (and fly? (/= dh 0))
                (let ((speed (/ (cast <fl> dh) elapse)))
                  (tilt-player speed)))))
        (nextmethod elapse dh dv))))
  
  
  (method override (mouse-up h v)
    (restore/show-cursor)
    (cond ((and history? paused? sliding?)
           (slider-mouse-up h v))
          (paused?
           (nextmethod h v))
          (last-point
           (nextmethod h v)
           (follow-player))
          (else
           (editor-mouse-up h v)))
    (set! down? #f)
    (set! down-point #f)
    (set! viewing? #f))
  
  
  (method override (right-mouse-down h v)
    (hide/preserve-cursor)
    (set! moving? #t)
    (set! moved? #f)
    (nextmethod h v))
  
  
  (method override (right-mouse-up h v)
    (reset-player-tilt)
    (restore/show-cursor)
    (set! moving? #f)
    (nextmethod h v))
  
  
  (method (hide/preserve-cursor)
    (hide-cursor)
    (set! preserved-mouse (mouse-position~ window)))
  
  
  (method (restore/show-cursor)
    (when preserved-mouse
      (set-mouse-position~ window preserved-mouse)
      (set! preserved-mouse #f))
    (show-cursor))
  
  
  (method override (mouse-wheel h v delta)
    (if (control-down?)
        (move-grid delta)
      (nextmethod h v delta)))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (process-keys)
    (let ((evt (make-event Keyboard-Event :char self)))
      ;; camera
      (process-movement evt allow-space?: paused?)
      ;; player
      (when (eq? window (get-window-focus))
        (receive (shift? control? alt?) (modifiers-down)
          (unless (or shift? control? alt?)
            (when (key-down? VK_LEFT)
              (move-left))
            (when (key-down? VK_RIGHT)
              (move-right))
            (when (key-down? VK_DOWN)
              (move-down))
            (when (key-down? VK_UP)
              (move-up))
            (when (key-down? (char->integer #\space))
              (if (and first-person? fly?)
                  (strafe-up)
                (space))))))))
  
  
  (method override (process-shortcut shortcut)
    (continuation-capture
      (lambda (return)
        (cond ;; window
              ((shortcut=? shortcut {Shortcut F11}) (toggle-fullscreen))
              ;; select
              ((shortcut=? shortcut {Shortcut :control :shift :alt #\1}) (select-bubbles))
              ((shortcut=? shortcut {Shortcut :control :shift :alt #\2}) (select-snakes))
              ((shortcut=? shortcut {Shortcut :control :shift :alt #\3}) (select-tree))
              ((shortcut=? shortcut {Shortcut :control :shift :alt #\4}) (select-live))
              ;; world
              ((shortcut=? shortcut {Shortcut :control #\N}) (new-world))
              ((shortcut=? shortcut {Shortcut :control #\S}) (save-world))
              ((shortcut=? shortcut {Shortcut :control :shift #\S}) (save-as-world))
              ((shortcut=? shortcut {Shortcut :control #\O}) (open-world))
              ((shortcut=? shortcut {Shortcut :control :shift #\O}) (open-world reversed?: #t))
              ((shortcut=? shortcut {Shortcut :control #\R}) (revert-world))
              ((shortcut=? shortcut {Shortcut #\0}) (reset-live))
              ;; history
              ((shortcut=? shortcut {Shortcut :shift #\H}) (reset-history))
              ;; camera
              ((shortcut=? shortcut {Shortcut :alt #\1}) (first-person))
              ((shortcut=? shortcut {Shortcut :alt #\3}) (toggle-3d))
              ((shortcut=? shortcut {Shortcut :alt #\9}) (reset-camera))
              ;; draw
              ((shortcut=? shortcut {Shortcut :control #\G}) (toggle-draw-gadgets))
              ((shortcut=? shortcut {Shortcut :control #\H}) (toggle-draw-sprites))
              ;; editor
              ((shortcut=? shortcut {Shortcut :control #\1}) (toggle-grid-z))
              ((shortcut=? shortcut {Shortcut :control #\2}) (toggle-grid-y))
              ((shortcut=? shortcut {Shortcut :control #\3}) (toggle-grid-x))
              ((shortcut=? shortcut {Shortcut :control Left}) (decrease-grid))
              ((shortcut=? shortcut {Shortcut :control Right}) (increase-grid))
              ((shortcut=? shortcut {Shortcut :control Tab}) (forward-sprite-class))
              ((shortcut=? shortcut {Shortcut :control :shift Tab}) (backward-sprite-class))
              ((shortcut=? shortcut {Shortcut :control #\W}) (switch-editor-mode))
              ;; debug
              ((shortcut=? shortcut {Shortcut :control #\M}) (reset-all-marks))
              ((shortcut=? shortcut {Shortcut :control #\T}) (test-world))
              ((shortcut=? shortcut {Shortcut :control :shift #\T}) (test-shift-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\1}) (test1-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\2}) (test2-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\3}) (test3-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\4}) (test4-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\5}) (test5-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\6}) (test6-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\7}) (test7-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\8}) (test8-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\9}) (test9-world))
              ((shortcut=? shortcut {Shortcut :control :alt #\0}) (test0-world))
              ;; game
              ((shortcut=? shortcut {Shortcut #\1}) (fire))
              (else (continuation-return return #f)))
        #t)))
  
  
  (method override (key-press key)
    (let ((evt (make-event Keyboard-Event :char self key: key)))
      (case key
        ;; editor
        ((#\backspace) (remove-target))
        ((#\g) (toggle-grid))
        ;; debug
        ((#\p #\tab) (toggle-paused))
        ((#\\) (toggle-evaluation))
        ((#\[) (backward-history))
        ((#\]) (forward-history))
        ((#\return) (step-world))
        ((#\h) (toggle-history))
        ((#\c) (clear-terminal))
        ((#\6) (toggle-debug-areas))
        ;; world
        ((#\5) (toggle-block-stiches))
        ((#\.) (toggle-post-processing))
        ;; player
        ((#\7) (toggle-player-target))
        ;; projection
        ((#\8) (toggle-eye))
        ((#\f) (toggle-fly))
        ;; camera
        ((#\k) (change-first-camera))
        ;; music
        ((#\m) (change-music))
        ;; settings
        ((#\z) (toggle-interface))
        ((#\-) (toggle-counters))
        ((#\_) (reset-counters) (display-message "Counters reset"))
        ((#\=) (toggle-axes))
        ((#\i) (toggle-info))
        ((#\y) (toggle-polygon-mode))
        ((#\l) (toggle-lighting) (display-on/off "Light" light?))
        ((#\v) (toggle-projection))
        ((#\t) (toggle-textures)))))
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method (toggle-post-processing)
    (set! post-processing? (not post-processing?))
    (display-on/off "Post processing" post-processing?))
  
  
  (method (first-person)
    (if (not player)
        (display-error "No player")
      (if first-person?
          (deactivate-first-person)
        (activate-first-person))
      (display-on/off "First person" first-person?)))
  
  
  (method (activate-first-person)
    (set! first-person? #t)
    (set-sight~ (get-lookat~ player) (vertex 0. 0. -1.))
    (set-up~ (get-lookat~ player) (vertex 0. 1. 0.))
    (set-right~ (get-lookat~ player) (vertex 1. 0. 0.))
    (center-camera)
    (activate-3d))
  
  
  (method (deactivate-first-person)
    (set! first-person? #f))
    
  
  (method (toggle-3d)
    (if 3d?
        (deactivate-3d)
      (activate-3d))
    (display-on/off "3d" 3d?))
  
  
  (method (activate-3d)
    (set! 3d? #t)
    (set! light? #t)
    (set! projection 'perspective))
  
  
  (method (deactivate-3d)
    (set! 3d? #f)
    (set! light? #f)
    (set! projection 'orthographic))
  
  
  (method (toggle-fly)
    (set! fly? (not fly?))
    (if fly?
        (begin
          (set-y~ player (+ (get-y~ player) 2.))
          (update-position~ player))
      (rotate-player-vertical (vertical-angle (get-sight~ (get-lookat~ player)) world-up)))
    (follow-player))

  
  (method (toggle-textures)
    (set! textures? (not textures?))
    (display-on/off "Textures" textures?))
  
  
  (method (toggle-axes)
    (set! axes? (not axes?))
    (display-on/off "Axes" axes?))
  
  
  (method (toggle-info)
    (set! info? (not info?)))
  
  
  (method (toggle-counters)
    (set! counters? (not counters?))
    (reset-counters))
  
  
  (method (reset-counters)
    (reset~ gc-counter)
    (reset~ tick-counter)
    (reset~ render-counter))
  
  
  (method (display-on/off title flag)
    (display-message (format "{a} {a}" title (if flag "on" "off")) color: (if flag {Color Green} {Color Red})))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method (reset-marks)
    (set! marks '()))
  
  
  (method (set-marks lst)
    (set! marks lst))
  
  
  (method (set-mark mark)
    (set! marks (list mark)))
  
  
  (method (add-mark mark)
    (set! marks (cons mark marks)))
  
  
  (method (remove-mark mark)
    (set! marks (remove! mark marks)))

  
  (method (draw-marks)
    (for-each draw-mark~ marks))
  
  
  (method (reset-all-marks)
    (reset-marks)
    (display-message "Marks reset"))
  
  
  ;;;
  ;;;; Message
  ;;;
  
  
  (method (display-message msg (color: color #f))
    (set! message msg)
    (set! message-color color)
    (set! message-time (time->seconds (current-time))))
  
  
  (method (draw-message)
    (let ((elapse (- (time->seconds (current-time)) message-time)))
      (if (> elapse 2.)
          (begin
            (set! message #f)
            (set! message-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ message-texture))
                (font {Font Heading1})
                (color (or message-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 message)
            (map-texture~ message-texture)
            (let ((w (text-width~ font message)))
              (let ((c (center w (fxround width))))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) (cast <fl> (- (fxround height) 200)) 0.0)
                (textured-quad~ message-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 100.0 0.0))
                  (lambda () (glVertex3f 0.0 100.0 0.0)))
                (glPopMatrix))))))))
    
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method (display-error msg)
    (display-message msg color: {Color Red}))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method (display-status msg (color: color #f))
    (set! status msg)
    (set! status-color color)
    (set! status-time (time->seconds (current-time))))
  
  
  (method (draw-status)
    (let ((elapse (- (time->seconds (current-time)) status-time)))
      (if (> elapse 2.)
          (begin
            (set! status #f)
            (set! status-time #f))
        (let ((alpha (if (> elapse 1.) (- 2. elapse) #f)))
          (let ((surface (get-surface~ status-texture))
                (font {Font Heading2})
                (color (or status-color {Color Red})))
            (set-operator~ surface CAIRO_OPERATOR_CLEAR)
            (paint~ surface)
            (set-operator~ surface CAIRO_OPERATOR_OVER)
            (set-font~ surface font)
            (if (not alpha)
                (set-color~ surface color)
              (let ((color (copy-object~ color #f)))
                (set-alpha~ color alpha)
                (set-color~ surface color)))
            (draw-text~ surface 0 10 status)
            (map-texture~ status-texture)
            (let ((w (text-width~ font status)))
              (let ((c (center w (fxround width))))
                (glPushMatrix)
                (glTranslatef (cast <fl> c) 30.0 0.0)
                (textured-quad~ status-texture
                  (lambda () (glVertex3f 0.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 0.0 0.0))
                  (lambda () (glVertex3f 500.0 35.0 0.0))
                  (lambda () (glVertex3f 0.0 35.0 0.0)))
                (glPopMatrix))))))))
  
  
  ;;;
  ;;;; Info
  ;;;
  
  
  (method (debug-info)
    (define (present-object obj)
      (format "~{{s} #{s}}"
              (reference-name (get-name~ (class-of obj)))
              (object->serial obj)))
    
    (define (present-boolean bool)
      (if bool "true" "false"))
    
    (define (present-vertex vert)
      (format "~{Vertex {r precision: 3} {r precision: 3} {r precision: 3}}"
              (vertex-x vert)
              (vertex-y vert)
              (vertex-z vert)))
    
    `(,(format "window: {a}" (present-object window))
      ,(format "width: {s}" width)
      ,(format "height: {s}" height)
      ""
      ,(format "self: {s}" self)
      ,(format "version: {s}" version)
      ,(format "actors: {s}" (length actors))
      ,(format "blocks: {s}" (length blocks))
      ,(format "sprites: {s}" (length sprites))
      ,(format "gadgets: {s}" (length gadgets))
      ,(format "children: {s}" (length children))
      ,(format "marks: {s}" (length marks))
      ""
      ,(format "history: {s}" (history-end~ history))
      ,(format "now: {s}" (get-now~ history))
      ,(format "first: {s}" (get-first~ history))
      ,@(if (and history? paused?)
            (present-history~ history)
          '())
      ""
      ,(format "projection: {s}" projection)
      ,(format "eye: {a}" (present-vertex eye))
      ,(format "eye-lookat: {s}" eye-lookat)
      ,(format "eye-target: {a}" (present-vertex eye-target))
      ,(format "camera-distance: {s}" camera-distance)
      ,(format "zoom-factor: {s}" zoom-factor)
      ,(format "first-distance: {s}" first-distance)
      ,(format "first-override: {s}" first-override)
      ,(format "first-occlusion?: {s}" first-occlusion?)
      ,(format "first-camera: {s}" first-camera)
      ,(format "desired-tilt: {s}" desired-tilt)
      ""
      ,(format "ambient-color: {s}" ambient-color)
      ,(format "material-specular: {s}" material-specular)
      ,(format "material-shininess: {s}" material-shininess)
      ,(format "lights: {s}" (count-lights))
      ""
      ,@(if information
            `(,@information
              "")
          '())
      ,@(if player
            `(,(format "player: {a}" (present-object player))
              ,(format "  x: {r precision: 1}" (get-x~ player))
              ,(format "  y: {r precision: 1}" (get-y~ player))
              ,(format "  z: {r precision: 1}" (get-z~ player))
              ,(format "  left: {r precision: 1}" (get-left~ player))
              ,(format "  bottom: {r precision: 1}" (get-bottom~ player))
              ,(format "  back: {r precision: 1}" (get-back~ player))
              ,(format "  right: {r precision: 1}" (get-right~ player))
              ,(format "  top: {r precision: 1}" (get-top~ player))
              ,(format "  front: {r precision: 1}" (get-front~ player))
              ,(format "  width: {s}" (get-width~ player))
              ,(format "  height: {s}" (get-height~ player))
              ,(format "  depth: {s}" (get-depth~ player))
              ,(format "  texture: {s}" (get-texture~ player))
              ,(format "  velocity: {s}" (present-vertex (get-velocity~ player)))
              ,(format "  user-data: {s}" (get-user-data~ player))
              ,(format "  lookat: {s}" (get-lookat~ player))
              ,(format "  jumping?: {a}" (present-boolean (get-jumping?~ player)))
              ,(format "  facing: {s}" (get-facing~ player))
              ,(format "  state: {s}" (get-state~ player))
              "")
          '())
      ,@(if target
            `(,(format "target: {a}" (present-object target))
              ,(format "  x: {r precision: 1}" (get-x~ target))
              ,(format "  y: {r precision: 1}" (get-y~ target))
              ,(format "  z: {r precision: 1}" (get-z~ target))
              ,(format "  width: {s}" (get-width~ target))
              ,(format "  height: {s}" (get-height~ target))
              ,(format "  depth: {s}" (get-depth~ target))
              ,(format "  texture: {s}" (get-texture~ target))
              ,(format "  user-data: {s}" (get-user-data~ target))
              "")
          '())
      ,(format "editor-mode: {a}" (capitalize (->string editor-mode)))
      ,(format "animate?: {a}" (present-boolean animate?))
      ,(format "light?: {a}" (present-boolean light?))
      ,(format "music?: {a}" (present-boolean music?))
      ,(format "3d?: {a}" (present-boolean 3d?))
      ,(format "fly?: {a}" (present-boolean fly?))
      ,(format "first-person?: {a}" (present-boolean first-person?))
      ,(format "textures?: {a}" (present-boolean textures?))
      ,(format "paused?: {a}" (present-boolean paused?))
      ""
      ,(format "gc-count: {a}" (gc-count))))
  
  
  (method (reset-information)
    (set! information #f))
  
  
  (method (set-information info)
    (set! information (map ->string info)))
  
  
  (method (add-information info)
    (set! information (append (or information '()) (list (->string info))))))


;;;
;;;; Info
;;;


(class Info extends World-Object
  
  
  (slot texture <object> getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set! texture (make-cairo-texture 500 1280 program: (get-texture-shader~ world) uniform-location: (get-texture-location~ world))))
  
  
  (method override (draw)
    (let ((surface (get-surface~ texture)))
      (set-operator~ surface CAIRO_OPERATOR_CLEAR)
      (paint~ surface)
      (set-operator~ surface CAIRO_OPERATOR_OVER)
      (set-font~ surface {Font font-name: "Courier New" point-size: 10 antialias: none})
      (set-color~ surface {Color Red})
      (let ((rank 0))
        (for-each (lambda (info)
                    (draw-text~ surface 10 (+ 10 (* rank 15)) (->string info))
                    (increase! rank))
                  (debug-info~ world)))
      (map-texture~ texture)
      (glPushMatrix)
      (glTranslatef 0.0 (cast <fl> (- (get-height~ world) 1280.0)) 0.0)
      (textured-quad~ texture
        (lambda () (glVertex3f 0.0 0.0 0.0))
        (lambda () (glVertex3f 500.0 0.0 0.0))
        (lambda () (glVertex3f 500.0 1280.0 0.0))
        (lambda () (glVertex3f 0.0 1280.0 0.0)))
      (glPopMatrix)))))
