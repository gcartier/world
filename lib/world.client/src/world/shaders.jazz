;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Shaders
;;;


(module world.shaders jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world.foreign)
        (world.shader)
        (time))


;;;
;;;; Default
;;;


(definition public default-vs
  #<<SHADER
#version 120

// precision mediump float;

void main()
{
    gl_Position = ftransform();
}
SHADER
)


(definition public default-fs
  #<<SHADER
#version 120
 
// precision mediump float;

void main()
{
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}
SHADER
)


;;;
;;;; Mesh Texture
;;;


(definition public mesh-texture-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D texture;

attribute vec3 vertex_coord;
attribute vec3 texture_coord;
attribute vec3 normal;

varying vec2 final_texture_coord;
 
void main(void)
{
	gl_Position = gl_ModelViewProjectionMatrix * vec4(vertex_coord, 1.0);
	final_texture_coord = vec2(texture_coord.x, texture_coord.y);
}
SHADER
)


(definition public mesh-texture-fs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D texture;

varying vec2 final_texture_coord;

void main(void)
{
	gl_FragColor = texture2D(texture, final_texture_coord);
}
SHADER
)


;;;
;;;; Mesh Radial Blur
;;;


;; Radial Blur by iq (2009)

(definition public mesh-radial-blur-fs
  #<<SHADER
#version 120

// precision highp float;

uniform vec2 resolution;
uniform float time;
uniform sampler2D texture;

varying vec2 final_texture_coord;

vec3 deform( in vec2 p )
{
    vec2 uv;

    vec2 q = vec2( sin(1.1*time+p.x),sin(1.2*time+p.y) );

    float a = atan(q.y,q.x);
    float r = sqrt(dot(q,q));

    uv.x = sin(0.0+1.0*time)+p.x*sqrt(r*r+1.0);
    uv.y = sin(0.6+1.1*time)+p.y*sqrt(r*r+1.0);

    return texture2D(texture,uv*.5).xyz;
}

void main(void)
{
    vec2 p = -1.0 + 2.0 * final_texture_coord.xy / resolution.xy;
    vec2 s = p;

    vec3 total = vec3(0.0);
    vec2 d = (vec2(0.0,0.0)-p)/40.0;
    float w = 1.0;
    for( int i=0; i<40; i++ )
    {
        vec3 res = deform(s);
        res = smoothstep(0.1,1.0,res*res);
        total += w*res;
        w *= .99;
        s += d;
    }
    total /= 40.0;
    float r = 1.5/(1.0+dot(p,p));
    gl_FragColor = vec4( total*r,1.0);
}
SHADER
)


;;;
;;;; Mesh Motion Blur
;;;


;; Motion Blur by iq (2009)

(definition public mesh-motion-blur-fs
  #<<SHADER
#version 120

// precision highp float;

uniform vec2 resolution;
uniform float time;
uniform sampler2D texture;

varying vec2 final_texture_coord;

vec3 deform( in vec2 p, float scale )
{
    vec2 uv;
   
    float mtime = scale+time;
    float a = atan(p.y,p.x);
    float r = sqrt(dot(p,p));
    float s = r * (1.0+0.5*cos(mtime*1.7));

    uv.x = .1*mtime +.05*p.y+.05*cos(-mtime+a*3.0)/s;
    uv.y = .1*mtime +.05*p.x+.05*sin(-mtime+a*3.0)/s;

    float w = 0.8-0.2*cos(mtime+3.0*a);

    vec3 res = texture2D(texture,uv).xyz*w;
    return  res*res;

}

void main(void)
{
    vec2 p = -1.0 + 2.0 * final_texture_coord.xy / resolution.xy;
    vec3 total = vec3(0.0);
    float w = 0.0;
    for( int i=0; i<20; i++ )
    {
        vec3 res = deform(p,w);
        total += res;
        w += 0.02;
    }
    total /= 20.0;

    gl_FragColor = vec4( 3.0*total,1.0);
}
SHADER
)


;;;
;;;; Mesh Water
;;;


;; Water by Viktor Korsun (BIT_TEK) (2012)

(definition public mesh-water-fs
  #<<SHADER
#version 120

// precision highp float;

uniform sampler2D texture;
uniform float time;
uniform vec2 resolution;
const float PI = 3.1415926535897932;

varying vec2 final_texture_coord;

//speed
const float speed = 0.2;
const float speed_x = 0.3;
const float speed_y = 0.3;

// geometry
const float intensity = 3.;
const int steps = 8;
const float frequency = 4.0;
const int angle = 7; // better when a prime

// reflection and emboss
const float delta = 20.;
const float intence = 400.;
const float emboss = 0.3;

//---------- crystals effect

float col(vec2 coord)
{
    float delta_theta = 2.0 * PI / float(angle);
    float col = 0.0;
    float theta = 0.0;
    for (int i = 0; i < steps; i++)
    {
      vec2 adjc = coord;
      theta = delta_theta*float(i);
      adjc.x += cos(theta)*time*speed + time * speed_x;
      adjc.y -= sin(theta)*time*speed - time * speed_y;
      col = col + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;
    }

    return cos(col);
}

//---------- main

void main(void)
{
vec2 p = (final_texture_coord.xy) / resolution.xy, c1 = p, c2 = p;
float cc1 = col(c1);

c2.x += resolution.x/delta;
float dx = emboss*(cc1-col(c2))/delta;

c2.x = p.x;
c2.y += resolution.y/delta;
float dy = emboss*(cc1-col(c2))/delta;

c1.x += dx;
c1.y = -(c1.y+dy);

float alpha = 1.+dot(dx,dy)*intence;
gl_FragColor = texture2D(texture,c1)*(1.0);
}
SHADER
)


;;;
;;;; Mesh Julia
;;;


;; Julia by iq (2009)

(definition public mesh-julia-fs
  #<<SHADER
#version 120

// precision highp float;

uniform vec2 resolution;
uniform float time;

varying vec2 final_texture_coord;

void main(void)
{
    vec2 p = -1.0 + 2.0 * final_texture_coord.xy / resolution.xy;
    vec2 cc = vec2( cos(.25*time), sin(.25*time*1.423) );

    float dmin = 1000.0;
    vec2 z  = p*vec2(1.33,1.0);
    for( int i=0; i<64; i++ )
    {
        z = cc + vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y );
        float m2 = dot(z,z);
        if( m2>100.0 ) break;
        dmin=min(dmin,m2);
        }

    float color = sqrt(sqrt(dmin))*0.7;
    gl_FragColor = vec4(color,color,color,1.0);
}
SHADER
)


;;;
;;;; Mesh Sierpinski
;;;


;; Sierpinski by Lars Huttar (2010)

(definition public mesh-sierpinski-fs
  #<<SHADER
#version 120

// precision highp float;

uniform vec2 resolution;
uniform float time;
uniform sampler2D texture;

varying vec2 final_texture_coord;

// Set color at the current fragment, with given coords
// and whether it should be "hole" or not.
void setColor(vec2 coord, bool isHole) {
	if (isHole)
		gl_FragColor = vec4(texture2D(texture, coord).xyz, 1.0);
	else
		gl_FragColor = vec4(coord.x, 0.5, coord.y, 1.0);
}

// Sierpinski carpet - with anti-holes!
// Maybe call it "Sierpinski tablecloth". If it doesn't already have a name.
void main(void)
{
	ivec2 sectors;
	vec2 coordOrig = final_texture_coord.xy / resolution.xy;
	const int lim = 5;
	// Toggle between "carpet" and "tablecloth" every 3 seconds.
	bool doInverseHoles = (mod(time, 6.0) < 3.0);
	
	/* If you want it to spin, just to prove that it is redrawing
	the carpet every frame: */
	vec2 center = vec2(0.5, 0.5);
	mat2 rotation = mat2(
        vec2( cos(time), sin(time)),
        vec2(-sin(time), cos(time))
    );
    vec2 coordRot = rotation * (coordOrig - center) + center;
	// rotation can put us out of bounds
	if (coordRot.x < 0.0 || coordRot.x > 1.0 ||
		coordRot.y < 0.0 || coordRot.y > 1.0) {
		setColor(coordOrig, true);
		return;
	}

	vec2 coordIter = coordRot;
	bool isHole = false;
	
	for (int i=0; i < lim; i++) {
		sectors = ivec2(floor(coordIter.xy * 3.0));
		if (sectors.x == 1 && sectors.y == 1) {
			if (doInverseHoles) {
				isHole = !isHole;
			} else {
				setColor(coordOrig, true);
				return;
			}
		}

		if (i + 1 < lim) {
			// map current sector to whole carpet
			coordIter.xy = coordIter.xy * 3.0 - vec2(sectors.xy);
		}
	}
	
	setColor(isHole ? coordOrig : coordRot, isHole);
}
SHADER
)


;;;
;;;; Mesh Multitexture
;;;


;; Multitexture by iq (2009)

(definition public mesh-multitexture-fs
  #<<SHADER
#version 120

// precision highp float;

uniform vec2 resolution;
uniform float time;
uniform sampler2D texture;
uniform sampler2D tex1;

varying vec2 final_texture_coord;

void main(void)
{
    vec2 p = -1.0 + 2.0 * final_texture_coord.xy / resolution.xy;
    // a rotozoom
    vec2 cst = vec2( cos(.5*time), sin(.5*time) );
    mat2 rot = 0.5*cst.x*mat2(cst.x,-cst.y,cst.y,cst.x);
    vec3 col1 = texture2D(texture,rot*p).xyz;

    // scroll
    vec3 col2 = texture2D(tex1,0.5*p+sin(0.1*time)).xyz;

    // blend layers
    vec3 col = col2*col1;

    gl_FragColor = vec4(col,1.0);
}
SHADER
)


;;;
;;;; Mesh Kaleidoscope
;;;


;; Kaleidoscope by iq (2009)

(definition public mesh-kaleidoscope-fs
  #<<SHADER
#version 120

// precision highp float;

uniform vec2 resolution;
uniform float time;
uniform sampler2D texture;

varying vec2 final_texture_coord;

void main(void)
{
    vec2 p = -1.0 + 2.0 * final_texture_coord.xy / resolution.xy;
    vec2 uv;
   
    float a = atan(p.y,p.x);
    float r = sqrt(dot(p,p));

    uv.x =          7.0*a/3.1416;
    uv.y = -time+ sin(7.0*r+time) + .7*cos(time+7.0*a);

    float w = .5+.5*(sin(time+7.0*r)+ .7*cos(time+7.0*a));

    vec3 col =  texture2D(texture,uv*.5).xyz;

    gl_FragColor = vec4(col*w,1.0);
}
SHADER
)


;;;
;;;; Mesh Tunnel
;;;


;; Tunnel by iq (2009)

(definition public mesh-tunnel-fs
  #<<SHADER
#version 120

// precision highp float;

uniform vec2 resolution;
uniform float time;
uniform sampler2D texture;

varying vec2 final_texture_coord;

void main(void)
{
    vec2 p = -1.0 + 2.0 * final_texture_coord.xy / resolution.xy;
    vec2 uv;
   
    float a = atan(p.y,p.x);
    float r = sqrt(dot(p,p));

    uv.x = .75*time+.1/r;
    uv.y = a/3.1416;

    vec3 col =  texture2D(texture,uv).xyz;

    gl_FragColor = vec4(col*r,1.0);
}
SHADER
)


;;;
;;;; Mesh Square Tunnel
;;;


;; Square Tunnel by iq (2009)

(definition public mesh-square-tunnel-fs
  #<<SHADER
#version 120

// precision highp float;

uniform vec2 resolution;
uniform float time;
uniform sampler2D texture;

varying vec2 final_texture_coord;

void main(void)
{
    vec2 p = -1.0 + 2.0 * final_texture_coord.xy / resolution.xy;
    vec2 uv;

    float r = pow( pow(p.x*p.x,16.0) + pow(p.y*p.y,16.0), 1.0/32.0 );
    uv.x = .5*time + 0.5/r;
    uv.y = 1.0*atan(p.y,p.x)/3.1416;

    vec3 col =  texture2D(texture,uv).xyz;

    gl_FragColor = vec4(col*r*r*r,1.0);
}
SHADER
)


;;;
;;;; Mesh Fly
;;;


;; Fly by iq (2009)

(definition public mesh-fly-fs
  #<<SHADER
#version 120

// precision highp float;

uniform vec2 resolution;
uniform float time;
uniform sampler2D texture;

varying vec2 final_texture_coord;

void main(void)
{
    vec2 p = -1.0 + 2.0 * final_texture_coord.xy / resolution.xy;
    vec2 uv;

    float an = time*.25;

    float x = p.x*cos(an)-p.y*sin(an);
    float y = p.x*sin(an)+p.y*cos(an);
     
    uv.x = .25*x/abs(y);
    uv.y = .20*time + .25/abs(y);

    gl_FragColor = vec4(texture2D(texture,uv).xyz * y*y, 1.0);
}
SHADER
)


;;;
;;;; Mesh Pulse
;;;


;; Pulse by Danguafer/Silexars (2010)

(definition public mesh-pulse-fs
  #<<SHADER
#version 120

// precision highp float;

uniform float time;
uniform vec2 resolution;
uniform sampler2D texture;

varying vec2 final_texture_coord;

void main(void)
{
    vec2 halfres = resolution.xy/2.0;
    vec2 cPos = final_texture_coord.xy;

    cPos.x -= 0.5*halfres.x*sin(time/2.0)+0.3*halfres.x*cos(time)+halfres.x;
    cPos.y -= 0.4*halfres.y*sin(time/5.0)+0.3*halfres.y*cos(time)+halfres.y;
    float cLength = length(cPos);

    vec2 uv = final_texture_coord.xy/resolution.xy+(cPos/cLength)*sin(cLength/30.0-time*10.0)/25.0;
    vec3 col = texture2D(texture,uv).xyz*50.0/cLength;

    gl_FragColor = vec4(col,1.0);
}
SHADER
)


;;;
;;;; Mesh Phong
;;;


(definition public mesh-phong-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform mat4 model_matrix;
uniform vec4 sun_ambient;
uniform vec4 sun_color;
uniform vec3 sun_coord;
uniform int lights_count;
uniform sampler2D texture;

attribute vec3 vertex_coord;
attribute vec3 texture_coord;
attribute vec3 normal;
attribute vec3 lighting;

varying vec4 final_color;
varying vec2 final_texture_coord;

void main()
{
	vec3 N = normal;

	vec3 v = vec3(gl_ModelViewMatrix * model_matrix * vec4(vertex_coord, 1.0));

	vec3 eyes = -v;
    vec3 L, li;
    float attenuation, specular, distance, attterm;
	float lambertTerm;
	N = normalize(N);
    vec3 R;
    vec3 E = normalize(eyes);
    
    final_color = sun_ambient;
    li = sun_coord - vertex_coord;
    L = normalize(li);
    lambertTerm = dot(N, L);
    if (lambertTerm > 0.0)
	{
        final_color += sun_color * lambertTerm;
	}
 
    final_color += vec4(lighting, 1.0);
	N = gl_NormalMatrix * normal;
	N = normalize(N);

    for (int i=0; i<lights_count && i<8; i++)
    {
        li = gl_LightSource[i].position.xyz - v;
        L = normalize(li);
        distance = dot(li,li);
        attterm = (gl_LightSource[i].constantAttenuation + gl_LightSource[i].linearAttenuation*sqrt(distance) + gl_LightSource[i].quadraticAttenuation*distance);
        if (attterm <= 0) attterm = 1.0;
        attenuation = 1.0 / attterm;
        if (attenuation > 1.0) attenuation = 1.0;
        lambertTerm = dot(N, L);
        final_color += gl_LightSource[i].ambient * gl_FrontMaterial.ambient;
        if (lambertTerm > 0.0)
	    {
		   final_color += gl_LightSource[i].diffuse *
                       gl_FrontMaterial.diffuse *
		               lambertTerm * attenuation;
		   R = reflect(-L, N);
		   specular = pow(max(dot(R, E), 0.0),
		                 gl_FrontMaterial.shininess);
		   final_color += (gl_LightSource[i].specular) *
                       gl_FrontMaterial.specular *
		               specular*attenuation;
	    }
    }
    if (final_color.x > 1.0) final_color.x = 1.0;
    if (final_color.y > 1.0) final_color.y = 1.0;
    if (final_color.z > 1.0) final_color.z = 1.0;
    gl_Position = gl_ModelViewProjectionMatrix * model_matrix * vec4(vertex_coord, 1.0);
    final_texture_coord = texture_coord.xy;
}
SHADER
)


(definition public mesh-phong-fs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D texture;

varying vec4 final_color;
varying vec2 final_texture_coord;

void main (void)
{
	gl_FragColor = final_color * texture2D(texture, final_texture_coord + 1.0);
}
SHADER
)


;;;
;;;; PP
;;;


(definition public pp-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D fbo_texture;

attribute vec2 vertex_coord;

varying vec2 final_texture_coord;
 
void main(void)
{
  gl_Position = vec4(vertex_coord, 0.0, 1.0);
  final_texture_coord = (vertex_coord + 1.0) / 2;
}
SHADER
)


(definition public pp-fs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D fbo_texture;

varying vec2 final_texture_coord;

void main(void)
{
  float offsetX = 1.0 / 2400.0;
  float offsetY = 1.0 / 1600.0;
  vec4 color = texture2D(fbo_texture, vec2(final_texture_coord.x              , final_texture_coord.y))+
               texture2D(fbo_texture, vec2(final_texture_coord.x+offsetX      , final_texture_coord.y))+
               texture2D(fbo_texture, vec2(final_texture_coord.x              ,final_texture_coord.y+offsetY))+
               texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX)    ,final_texture_coord.y+offsetY));
               // texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX*2.0),final_texture_coord.y+offsetY))+
               // texture2D(fbo_texture, vec2(final_texture_coord.x              ,final_texture_coord.y+(offsetY*2.0)))+
               // texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX)    ,final_texture_coord.y+(offsetY*2.0)))+
               // texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX*2.0),final_texture_coord.y+(offsetY*2.0)));
               
  gl_FragColor = color * 0.25;
}
SHADER
))
