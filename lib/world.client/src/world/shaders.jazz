;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Shaders
;;;


(module world.shaders jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world.foreign)
        (world.shader)
        (time))


;;;
;;;; Default
;;;


(definition public default-vs
  #<<SHADER
#version 120

// precision mediump float;

void main()
{
    gl_Position = ftransform();
}
SHADER
)


(definition public default-fs
  #<<SHADER
#version 120
 
// precision mediump float;

void main()
{
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}
SHADER
)


;;;
;;;; Tile Color
;;;


(definition public tile-color-vs
  #<<SHADER
#version 120

// precision mediump float;

attribute vec3 vertex_coord;

varying vec4 final_color;
 
void main(void)
{
	gl_Position = gl_ModelViewProjectionMatrix * vec4(vertex_coord, 1.0);
    final_color = vec4(.525, .322, .004, 1.0);
}
SHADER
)


(definition public tile-color-fs
  #<<SHADER
#version 120

// precision mediump float;

varying vec4 final_color;

void main(void)
{
	gl_FragColor = final_color;
}
SHADER
)


;;;
;;;; Tile Texture
;;;


(definition public tile-texture-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D texture;

attribute vec3 vertex_coord;
attribute vec3 texture_coord;
attribute vec3 normal;

varying vec2 final_texture_coord;
 
void main(void)
{
	gl_Position = gl_ModelViewProjectionMatrix * vec4(vertex_coord, 1.0);
	final_texture_coord = vec2(texture_coord.x, texture_coord.y * ((normal.x - normal.y) + (normal.y - normal.x) + 1.0));
}
SHADER
)


(definition public tile-texture-fs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D texture;

varying vec2 final_texture_coord;

void main(void)
{
	gl_FragColor = texture2D(texture, final_texture_coord);
}
SHADER
)


;;;
;;;; Tile Phong
;;;


(definition public tile-phong-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D texture;

attribute vec3 vertex_coord;
attribute vec3 texture_coord;
attribute vec3 normal;

varying vec3 N, L0, L1, L2, L3, L4, v;
varying vec2 final_texture_coord;

void main()
{
	N = gl_NormalMatrix * normal;

	v = vec3(gl_ModelViewMatrix * vec4(vertex_coord,1.0));

	L0 = vec3(gl_LightSource[0].position.xyz - v);
    L1 = vec3(gl_LightSource[1].position.xyz - v);
    L2 = vec3(gl_LightSource[2].position.xyz - v);
    L3 = vec3(gl_LightSource[3].position.xyz - v);

	gl_Position = gl_ModelViewProjectionMatrix * vec4(vertex_coord, 1.0);
    final_texture_coord = texture_coord.xy;
}
SHADER
)


(definition public tile-phong-nlights-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform int lights_count;
uniform int edit_mode;
uniform sampler2D texture;

attribute vec3 vertex_coord;
attribute vec3 texture_coord;
attribute vec3 normal;

varying vec4 final_color;
varying vec2 final_texture_coord;

void main()
{
	vec3 N = gl_NormalMatrix * normal;

	vec3 v = vec3(gl_ModelViewMatrix * vec4(vertex_coord, 1.0));
    
    final_color =  vec4(0.0, 0.0, 0.0, 1.0);

	vec3 eyes = -v;
    float invertlights = 1.0 / lights_count;
    vec3 L, li;
    float attenuation, specular, distance, attterm;
	float lambertTerm;
	N = normalize(N);
    vec3 R;
    vec3 E = normalize(eyes);
    
    for (int i=0; i<lights_count && i<8; i++)
    {
        li = gl_LightSource[i].position.xyz - v;
        L = normalize(li);
        distance = dot(li,li);
        attterm = (gl_LightSource[i].constantAttenuation + gl_LightSource[i].linearAttenuation*sqrt(distance) + gl_LightSource[i].quadraticAttenuation*distance);
        if (attterm <= 0) attterm = 1.0;
        attenuation = 1.0 / attterm;
        if (attenuation > 1.0) attenuation = 1.0;
        lambertTerm = dot(N, L);
        final_color += gl_LightSource[i].ambient * gl_FrontMaterial.ambient;
        if (lambertTerm > 0.0)
	    {
		   final_color += gl_LightSource[i].diffuse *
                       gl_FrontMaterial.diffuse *
		               lambertTerm * attenuation;
		   R = reflect(-L, N);
		   specular = pow(max(dot(R, E), 0.0),
		                 gl_FrontMaterial.shininess);
		   final_color += (gl_LightSource[i].specular) *
                       gl_FrontMaterial.specular *
		               specular*attenuation;
	    }
    }
    if (final_color.x > 1.0) final_color.x = 1.0;
    if (final_color.y > 1.0) final_color.y = 1.0;
    if (final_color.z > 1.0) final_color.z = 1.0;
	gl_Position = gl_ModelViewProjectionMatrix * vec4(vertex_coord, 1.0);
    final_texture_coord = texture_coord.xy;
}
SHADER
)


(definition public tile-phong-nlights-fs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D texture;
uniform int edit_mode;
uniform int lights_count;

varying vec4 final_color;
varying vec2 final_texture_coord;

void main (void)
{
	gl_FragColor = final_color * texture2D(texture, final_texture_coord + 1.0);
}
SHADER
)


;;;
;;;; Model Phong
;;;


(definition public model-phong-nlights-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform mat4 material;
uniform int lights_count;
uniform int edit_mode;
uniform sampler2D texture;

attribute vec3 vertex_coord;
attribute vec3 texture_coord;
attribute vec3 normal;

varying vec4 final_color;
varying vec2 final_texture_coord;

void main()
{
	vec3 N = gl_NormalMatrix * normal;

	vec3 v = vec3(gl_ModelViewMatrix * material * vec4(vertex_coord, 1.0));
    
    final_color =  vec4(0.0, 0.0, 0.0, 1.0);

	vec3 eyes = -v;
    float invertlights = 1.0 / lights_count;
    vec3 L, li;
    float attenuation, specular, distance, attterm;
	float lambertTerm;
	N = normalize(N);
    vec3 R;
    vec3 E = normalize(eyes);
    
    for (int i=0; i<lights_count && i<8; i++)
    {
        li = gl_LightSource[i].position.xyz - v;
        L = normalize(li);
        distance = dot(li,li);
        attterm = (gl_LightSource[i].constantAttenuation + gl_LightSource[i].linearAttenuation*sqrt(distance) + gl_LightSource[i].quadraticAttenuation*distance);
        if (attterm <= 0) attterm = 1.0;
        attenuation = 1.0/attterm;
        if (attenuation > 1.0) attenuation = 1.0;
        lambertTerm = dot(N,L);
        final_color += gl_LightSource[i].ambient*gl_FrontMaterial.ambient;
        if (lambertTerm > 0.0)
	    {
		   final_color += gl_LightSource[i].diffuse *
                       gl_FrontMaterial.diffuse *
		               lambertTerm * attenuation;
		   R = reflect(-L, N);
		   specular = pow(max(dot(R, E), 0.0),
		                 gl_FrontMaterial.shininess);
		   final_color += (gl_LightSource[i].specular) *
                       gl_FrontMaterial.specular *
		               specular*attenuation;
	    }
    }
    if (final_color.x > 1.0) final_color.x = 1.0;
    if (final_color.y > 1.0) final_color.y = 1.0;
    if (final_color.z > 1.0) final_color.z = 1.0;
	gl_Position = (gl_ModelViewProjectionMatrix) * material * vec4(vertex_coord, 1.0);
    final_texture_coord = texture_coord.xy;
}
SHADER
)


;;;
;;;; Texture
;;;


(definition public texture-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform float overlay;

void main()
{
	gl_TexCoord[0] = gl_MultiTexCoord0;
	gl_Position = ftransform();
}
SHADER
)


(definition public texture-fs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D texture;
uniform float overlay;

void main()
{
	vec4 color = texture2D(texture, gl_TexCoord[0].st);
    color += vec4(0.0, 0.0, 0.0, overlay);
    
	gl_FragColor = color;
}
SHADER
)


;;;
;;;; PP
;;;


(definition public pp-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D fbo_texture;

attribute vec2 vertex_coord;

varying vec2 final_texture_coord;
 
void main(void)
{
  gl_Position = vec4(vertex_coord, 0.0, 1.0);
  final_texture_coord = (vertex_coord + 1.0) / 2;
}
SHADER
)


(definition public pp-fs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D fbo_texture;

varying vec2 final_texture_coord;

void main(void)
{
  float offsetX = 1.0 / 2400.0;
  float offsetY = 1.0 / 1600.0;
  vec4 color = texture2D(fbo_texture, vec2(final_texture_coord.x              , final_texture_coord.y))+
               texture2D(fbo_texture, vec2(final_texture_coord.x+offsetX      , final_texture_coord.y))+
               texture2D(fbo_texture, vec2(final_texture_coord.x              ,final_texture_coord.y+offsetY))+
               texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX)    ,final_texture_coord.y+offsetY));
               // texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX*2.0),final_texture_coord.y+offsetY))+
               // texture2D(fbo_texture, vec2(final_texture_coord.x              ,final_texture_coord.y+(offsetY*2.0)))+
               // texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX)    ,final_texture_coord.y+(offsetY*2.0)))+
               // texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX*2.0),final_texture_coord.y+(offsetY*2.0)));
               
  gl_FragColor = color * 0.25;
}
SHADER
))
