;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Shaders
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.shaders jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world.fog)
        (world.foreign)
        (world.shader)
        (world.support)
        (world.texture)
        (time))


;;;
;;;; Default
;;;


(definition public default-vs
  #<<SHADER
#version 120

// precision mediump float;

void main()
{
    gl_Position = ftransform();
}
SHADER
)


(definition public default-fs
  #<<SHADER
#version 120
 
// precision mediump float;

void main()
{
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}
SHADER
)


;;;
;;;; Mesh Color
;;;


(definition public mesh-color-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform mat4 model_matrix;
uniform vec4 color;

attribute vec3 vertex_coord;

varying vec4 final_color;
 
void main()
{
    gl_Position = gl_ModelViewProjectionMatrix * model_matrix * vec4(vertex_coord, 1.0);
    final_color = color;
}
SHADER
)


(definition public mesh-color-fs
  #<<SHADER
#version 120

// precision mediump float;

varying vec4 final_color;

void main()
{
    gl_FragColor = final_color;
}
SHADER
)


;;;
;;;; Mesh Phong
;;;


(definition (build-mesh-phong-vs baked? skeletal?)
  (string-append
    #<<SHADER
#version 120

// precision mediump float;

uniform mat4 model_matrix;
uniform vec4 ambient_color;
uniform vec4 sun_color;
uniform vec3 sun_coord;
uniform int lights_count;
uniform sampler2D texture;

attribute vec3 vertex_coord;
attribute vec3 normal;
attribute vec3 texture_coord;
attribute float bone_id;
SHADER

(if skeletal?
#<<SHADER
uniform mat4 bone_matrices[200];
SHADER
"")

(if baked?
#<<SHADER
attribute vec3 lighting;
SHADER
"")

#<<SHADER
varying vec4 final_light;
varying vec3 final_texture_coord;

void main()

SHADER

"{"

(if skeletal?
#<<SHADER
    mat4 boneTransform = bone_matrices[int(bone_id)];
    vec4 pos = boneTransform * vec4(vertex_coord, 1.0);
    vec3 nrm = (boneTransform * vec4(normal, 0.0)).xyz;
SHADER

#<<SHADER
    vec4 pos = vec4(vertex_coord, 1.0);
    vec3 nrm = normal;
SHADER
)

#<<SHADER
    mat3 model_normal = mat3(model_matrix);
    vec3 v = vec3(gl_ModelViewMatrix * model_matrix * pos);

    vec3 N = nrm;

    vec3 eyes = -v;
    vec3 L, li;
    float attenuation, specular, distance, attterm;
    float lambertTerm;
    N = normalize(N);
    vec3 R;
    vec3 E = normalize(eyes);
    
    final_light = ambient_color;
    li = sun_coord - vertex_coord;
    L = normalize(li);
    lambertTerm = dot(model_normal*N, L);
    if (lambertTerm > 0.0)
    {
        final_light += sun_color * lambertTerm;
    }
SHADER

(if baked?
#<<SHADER
    final_light += vec4(lighting, 1.0);
SHADER
"")

#<<SHADER
    // will not work if model_matrix contains non-uniform scaling
    N = gl_NormalMatrix * model_normal * nrm;
    N = normalize(N);

    for (int i=0;
         i<lights_count;
         i++)
    {
        li = gl_LightSource[i].position.xyz - v;
        L = normalize(li);
        distance = dot(li,li);
        attterm = (gl_LightSource[i].constantAttenuation + gl_LightSource[i].linearAttenuation*sqrt(distance) + gl_LightSource[i].quadraticAttenuation*distance);
        if (attterm <= 0) attterm = 1.0;
        attenuation = 1.0 / attterm;
        if (attenuation > 1.0) attenuation = 1.0;
        lambertTerm = dot(N, L);
        final_light += gl_LightSource[i].ambient * gl_FrontMaterial.ambient;
        if (lambertTerm > 0.0)
        {
           final_light += gl_LightSource[i].diffuse *
                       gl_FrontMaterial.diffuse *
                       lambertTerm * attenuation;
           R = reflect(-L, N);
           specular = pow(max(dot(R, E), 0.0),
                         gl_FrontMaterial.shininess);
           final_light += (gl_LightSource[i].specular) *
                       gl_FrontMaterial.specular *
                       specular*attenuation;
        }
    }
    if (final_light.x > 1.0) final_light.x = 1.0;
    if (final_light.y > 1.0) final_light.y = 1.0;
    if (final_light.z > 1.0) final_light.z = 1.0;
    if (final_light.w > 1.0) final_light.w = 1.0;
    gl_Position = gl_ModelViewProjectionMatrix * model_matrix * pos;
    final_texture_coord = texture_coord;

SHADER

"}"
))


(definition (build-mesh-phong-fs texture-arrays? fog?)
  (string-append
    #<<SHADER
#version 120

SHADER

(if texture-arrays?
#<<SHADER
#extension GL_EXT_texture_array : enable

SHADER

""
)

#<<SHADER
// precision mediump float;

SHADER

(if texture-arrays?
#<<SHADER
uniform sampler2DArray texture;

SHADER

#<<SHADER
uniform sampler2D texture;

SHADER
)

#<<SHADER
varying vec4 final_light;
varying vec3 final_texture_coord;

void main()
SHADER

"{"

(if texture-arrays?
#<<SHADER
    gl_FragColor = final_light * texture2DArray(texture, final_texture_coord);
SHADER

#<<SHADER
    gl_FragColor = final_light * texture2D(texture, final_texture_coord.xy + 1.0);
SHADER
)

(if fog?
#<<SHADER
    // z-buffer visualisation
    // float z = 1.0 - (gl_FragCoord.z / gl_FragCoord.w) / 100.0;
    // gl_FragColor = vec4(z, z, z, 1.0);
    
    const float LOG2 = 1.442695;
    float z = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = exp2( -gl_Fog.density * 
				             gl_Fog.density * 
				             z * 
				             z * 
				             LOG2 );
    fogFactor = clamp(fogFactor, 0.8, 1.0);

    gl_FragColor = mix(gl_Fog.color, gl_FragColor, fogFactor );
SHADER
"")

"}"
))


(definition public mesh-dynamic-phong-vs
  #f)

(definition public mesh-skeletal-phong-vs
  #f)

(definition public mesh-phong-vs
  #f)


(definition public mesh-phong-fs
  #f)


(definition public (setup-phong-shaders)
  (let ((texture-arrays? (get-texture-arrays?))
        (fog? (get-fog?)))
    ;; vertex
    (set! mesh-dynamic-phong-vs (build-mesh-phong-vs #f #f))
    (set! mesh-skeletal-phong-vs (build-mesh-phong-vs #f #t))
    (set! mesh-phong-vs (build-mesh-phong-vs #t #f))
    ;; fragment
    (set! mesh-phong-fs (build-mesh-phong-fs texture-arrays? fog?))))


;;;
;;;; Mesh Frame
;;;


(definition (build-mesh-frame-vs square?)
  (string-append
    #<<SHADER
/*
    Input: The vertex position and vertex attributes p1_3d and p2_3d which
    are the positions of neighbouring vertices.

    Output:   dist a vector of distances from the vertex to the three edges of
    the triangle. Clearly only one of these distance is non-zero. For vertex 0
    in a triangle dist = (distance to opposite edge, 0, 0) on exit. The distance
    is multiplied by w. This is to negate perspective correction.
    
    http://www2.imm.dtu.dk/~jab/Wireframe
*/
uniform vec2 WIN_SCALE;
uniform mat4 model_matrix;
attribute vec3 vertex_coord;
attribute float swizz;
attribute vec3 neighbor1;
attribute vec3 neighbor2;

varying vec3 dist;
SHADER

(if square?
#<<SHADER
varying vec3 ignore;
SHADER

"")

#<<SHADER

void main()

SHADER

"{"

#<<SHADER
    vec4 pos = vec4(vertex_coord, 1.0);
    vec4 p1_3d = vec4(neighbor1, 1.0);
    vec4 p2_3d = vec4(neighbor2, 1.0);

    // Compute the vertex position in the usual fashion.
    gl_Position = gl_ModelViewProjectionMatrix * model_matrix * pos;

    // p0 is the 2D position of the current vertex.
    vec2 p0 = gl_Position.xy/gl_Position.w;

    // Project p1 and p2 and compute the vectors v1 = p1-p0
    // and v2 = p2-p0
    vec4 p1_3d_ = gl_ModelViewProjectionMatrix * model_matrix * p1_3d;
    vec2 v1 = WIN_SCALE*(p1_3d_.xy / p1_3d_.w - p0);

    vec4 p2_3d_ = gl_ModelViewProjectionMatrix * model_matrix * p2_3d;
    vec2 v2 = WIN_SCALE*(p2_3d_.xy / p2_3d_.w - p0);

    // Compute 2D area of triangle.
    float area2 = abs(v1.x*v2.y - v1.y * v2.x);

    // Compute distance from vertex to line in 2D coords
    float h = area2/length(v1-v2);
SHADER

(if square?
#<<SHADER
    float d01 = distance(pos, p1_3d);
    float d02 = distance(pos, p2_3d);
    float d12 = distance(p1_3d, p2_3d);
    float i;
    if (d12 >= d01 && d12 >= d02)
        i = -1.0;
    else
        i = 0.;
SHADER

"")

#<<SHADER
    // ---
    // The swizz variable tells us which of the three vertices
    // we are dealing with. The ugly comparisons would not be needed if
    // swizz was an int.

    if (swizz<0.1)
    {
        dist = vec3(h,0,0);
SHADER

(if square?
#<<SHADER
        ignore = vec3(i,0,0);
SHADER

"")

#<<SHADER
    }
    else if (swizz<1.1)
    {
        dist = vec3(0,h,0);
SHADER

(if square?
#<<SHADER
        ignore = vec3(0,i,0);
SHADER

"")

#<<SHADER
    }
    else
    {
        dist = vec3(0,0,h);
SHADER

(if square?
#<<SHADER
        ignore = vec3(0,0,i);
SHADER

"")

#<<SHADER
    }

    // ----
    // Quick fix to defy perspective correction

    dist *= gl_Position.w;
SHADER

(if square?
#<<SHADER
    ignore *= gl_Position.w;
SHADER

"")

"}"
))


(definition (build-mesh-frame-fs square? distance?)
  (string-append
    #<<SHADER
uniform vec4 WIRE_COL;
uniform vec4 FILL_COL;
SHADER

@wait
(if distance?
#<<SHADER
uniform float EYE_HEIGHT;
SHADER

"")

#<<SHADER
varying vec3 dist;
SHADER

(if square?
#<<SHADER
varying vec3 ignore;
SHADER

"")

#<<SHADER

void main()

SHADER

"{"

#<<SHADER
    // Undo perspective correction.
    vec3 dist_vec = dist * gl_FragCoord.w;
SHADER

(if square?
#<<SHADER
    vec3 ignore_vec = ignore * gl_FragCoord.w;
SHADER

"")

(if (not square?)
#<<SHADER
    // Compute the shortest distance to the edge
    float d = min(dist_vec[0], min(dist_vec[1], dist_vec[2]));
SHADER

#<<SHADER
    float d;
    if (ignore_vec[0] < 0.)
        d = min(dist_vec[1], dist_vec[2]);
    else if (ignore_vec[1] < 0.)
        d = min(dist_vec[0], dist_vec[2]);
    else if (ignore_vec[2] < 0.)
        d = min(dist_vec[0], dist_vec[1]);
    else
        d = 100.;
SHADER
)

#<<SHADER
    // Compute line intensity and then fragment color
    float I = exp2(-2.0*d*d);
SHADER

(if (not distance?)
#<<SHADER
    gl_FragColor = I*WIRE_COL + (1.0 - I)*FILL_COL;
SHADER

#<<SHADER
    float A = exp(-d);
    vec4 WIRE_ALP = vec4(0., 0., 0., 1.);
    
    // Reduce moire patterns
    float z = gl_FragCoord.z / gl_FragCoord.w;
    I = (I / z) * 7.5;
    
 //   float zhorizontal = sqrt(max(z*z - (EYE_HEIGHT*EYE_HEIGHT / 1.3), 0));
 //   I = min((I / (1. + zhorizontal)) * 7.5, 1);
    
  //  gl_FragColor = I*WIRE_COL + (1.0 - I)*FILL_COL;
  //  gl_FragColor = I*vec4(WIRE_COL.xyz, 0.) + A*WIRE_ALP + (1.0 - I)*FILL_COL;
    gl_FragColor = I*WIRE_COL + (1.0 - I)*FILL_COL;
SHADER
)

"}"
))


(definition public mesh-wireframe-vs
  #f)

(definition public mesh-squareframe-vs
  #f)

(definition public mesh-playerframe-vs
  #f)

(definition public mesh-floorframe-vs
  #f)


(definition public mesh-wireframe-fs
  #f)

(definition public mesh-squareframe-fs
  #f)

(definition public mesh-playerframe-fs
  #f)

(definition public mesh-floorframe-fs
  #f)


(definition public (setup-frame-shaders)
  (set! mesh-wireframe-vs   (build-mesh-frame-vs #f))
  (set! mesh-squareframe-vs (build-mesh-frame-vs #t))
  (set! mesh-playerframe-vs (build-mesh-frame-vs #t))
  (set! mesh-floorframe-vs  (build-mesh-frame-vs #t))
  (set! mesh-wireframe-fs   (build-mesh-frame-fs #f #f))
  (set! mesh-squareframe-fs (build-mesh-frame-fs #t #f))
  (set! mesh-playerframe-fs (build-mesh-frame-fs #t #f))
  (set! mesh-floorframe-fs  (build-mesh-frame-fs #t #t)))


;;;
;;;; Mesh Texture
;;;


(definition public mesh-texture-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform mat4 model_matrix;
// uniform sampler2D texture;
uniform sampler2DArray texture;

attribute vec3 vertex_coord;
attribute vec3 texture_coord;

// varying vec2 final_texture_coord;
varying vec3 final_texture_coord;

void main()
{
    gl_Position = gl_ModelViewProjectionMatrix * model_matrix * vec4(vertex_coord, 1.0);
    // final_texture_coord = vec2(texture_coord.x, texture_coord.y);
    final_texture_coord = texture_coord;
}
SHADER
)


(definition public mesh-texture-fs
  #<<SHADER
#version 120

// precision mediump float;

// uniform sampler2D texture;
uniform sampler2DArray texture;

// varying vec2 final_texture_coord;
varying vec3 final_texture_coord;

void main()
{
    // gl_FragColor = texture2D(texture, final_texture_coord);
    gl_FragColor = final_light * texture2DArray(texture, final_texture_coord);
}
SHADER
)


(definition (texture-macros)
  #<<SHADER
#define TEXSAMPLER sampler2DArray
#define TEXBOUNDS uniform vec4 texture_bounds[64];
#define TEXCOORD vec3
#define TEX2D texture2DArray
#define TEXUV(u,v) vec3(u,v,final_texture_coord.z)
SHADER
)


(definition (normalize-uv)
  #<<SHADER
vec4 texbounds = texture_bounds[int(final_texture_coord.z)];
float texleft = texbounds.x;
float textop = texbounds.y;
float texright = texbounds.z;
float texbottom = texbounds.w;
float texwidth = texright - texleft;
float texheight = texbottom - textop;
float texx = (final_texture_coord.x-texleft) / texwidth;
float texy = 1 - (final_texture_coord.y-textop) / texheight;
float texu;
float texv;
SHADER
)


(definition (denormalize-uv)
  #<<SHADER
texu = fract(texu);
texv = fract(texv);
texu = texu*texwidth+texleft;
texv = texv*texheight+textop;
SHADER
)


;;;
;;;; Mesh Radial Blur
;;;


;; Radial Blur by iq (2009)

(definition public mesh-radial-blur-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform mat4 model_matrix;
uniform float time;
uniform TEXSAMPLER texture;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
vec3 deform(in vec2 p)
{
    vec2 uv;

    vec2 q = vec2(sin(1.1*time+p.x),sin(1.2*time+p.y));

    float a = atan(q.y,q.x);
    float r = sqrt(dot(q,q));

    uv.x = sin(0.0+1.0*time)+p.x*sqrt(r*r+1.0);
    uv.y = sin(0.6+1.1*time)+p.y*sqrt(r*r+1.0);
    
    texu = uv.x*.5;
    texv = uv.y*.5;
SHADER

(denormalize-uv)

#<<SHADER
    return TEX2D(texture,TEXUV(texu,texv)).xyz;
}

void main()
{
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 s = p;

    vec3 total = vec3(0.0);
    vec2 d = (vec2(0.0,0.0)-p)/40.0;
    float w = 1.0;
    for (int i=0;
         i<40;
         i++)
    {
        vec3 res = deform(s);
        res = smoothstep(0.1,1.0,res*res);
        total += w*res;
        w *= .99;
        s += d;
    }
    total /= 40.0;
    float r = 1.5/(1.0+dot(p,p));
    gl_FragColor = vec4(total*r,1.0);
}
SHADER
))


;;;
;;;; Mesh Motion Blur
;;;


;; Motion Blur by iq (2009)

(definition public mesh-motion-blur-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform float time;
uniform TEXSAMPLER texture;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
vec3 deform(in vec2 p, float scale)
{
    vec2 uv;
   
    float mtime = scale+time;
    float a = atan(p.y,p.x);
    float r = sqrt(dot(p,p));
    float s = r * (1.0+0.5*cos(mtime*1.7));

    uv.x = .1*mtime +.05*p.y+.05*cos(-mtime+a*3.0)/s;
    uv.y = .1*mtime +.05*p.x+.05*sin(-mtime+a*3.0)/s;

    float w = 0.8-0.2*cos(mtime+3.0*a);

    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv)

#<<SHADER
    vec3 res = TEX2D(texture,TEXUV(texu,texv)).xyz*w;
    return res*res;

}

void main()
{
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec3 total = vec3(0.0);
    float w = 0.0;
    for (int i=0;
         i<20;
         i++)
    {
        vec3 res = deform(p,w);
        total += res;
        w += 0.02;
    }
    total /= 20.0;

    gl_FragColor = vec4(3.0*total,1.0);
}
SHADER
))


;;;
;;;; Mesh Water
;;;


;; Water by Viktor Korsun (BIT_TEK) (2012)

(definition public mesh-water-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform TEXSAMPLER texture;
TEXBOUNDS
uniform float time;

const float PI = 3.1415926535897932;

varying TEXCOORD final_texture_coord;

//speed
const float speed = 0.2;
const float speed_x = 0.3;
const float speed_y = 0.3;

// geometry
const float intensity = 3.;
const int steps = 8;
const float frequency = 4.0;
const int angle = 7; // better when a prime

// reflection and emboss
const float delta = 20.;
const float intence = 400.;
const float emboss = 0.3;
SHADER

(normalize-uv)

#<<SHADER
//---------- crystals effect

float col(vec2 coord)
{
    float delta_theta = 2.0 * PI / float(angle);
    float col = 0.0;
    float theta = 0.0;
    for (int i = 0;
         i < steps;
         i++)
    {
      vec2 adjc = coord;
      theta = delta_theta*float(i);
      adjc.x += cos(theta)*time*speed + time * speed_x;
      adjc.y -= sin(theta)*time*speed - time * speed_y;
      col = col + cos((adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;
    }

    return cos(col);
}

//---------- main

void main()
{
    vec2 p = vec2(texx, texy), c1 = p, c2 = p;
    float cc1 = col(c1);

    c2.x += 1/delta;
    float dx = emboss*(cc1-col(c2))/delta;

    c2.x = p.x;
    c2.y += 1/delta;
    float dy = emboss*(cc1-col(c2))/delta;

    c1.x += dx;
    c1.y = -(c1.y+dy);

    float alpha = 1.+dot(dx,dy)*intence;

    texu = c1.x;
    texv = c1.y;
SHADER

(denormalize-uv)

#<<SHADER
gl_FragColor = TEX2D(texture,TEXUV(texu,texv))*(1.0);
}
SHADER
))


;;;
;;;; Mesh Julia
;;;


;; Julia by iq (2009)

(definition public mesh-julia-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform float time;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
void main()
{
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 cc = vec2(cos(.25*time), sin(.25*time*1.423));

    float dmin = 1000.0;
    vec2 z  = p*vec2(1.33,1.0);
    for (int i=0;
         i<64;
         i++)
    {
        z = cc + vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);
        float m2 = dot(z,z);
        if (m2>100.0) break;
        dmin=min(dmin,m2);
        }

    float color = sqrt(sqrt(dmin))*0.7;
    gl_FragColor = vec4(color,color,color,1.0);
}
SHADER
))


;;;
;;;; Mesh Sierpinski
;;;


;; Sierpinski by Lars Huttar (2010)

(definition public mesh-sierpinski-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform float time;
uniform TEXSAMPLER texture;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
// Set color at the current fragment, with given coords
// and whether it should be "hole" or not.
void setColor(vec2 coord, bool isHole) {
    if (isHole)
        gl_FragColor = vec4(TEX2D(texture, TEXUV(final_texture_coord.x,final_texture_coord.y)).xyz, 1.0);
    else
        gl_FragColor = vec4(coord.x, 0.5, coord.y, 1.0);
}

// Sierpinski carpet - with anti-holes!
// Maybe call it "Sierpinski tablecloth". If it doesn't already have a name.
void main()
{
    ivec2 sectors;
    vec2 coordOrig = vec2(texx, texy);
    const int lim = 5;
    // Toggle between "carpet" and "tablecloth" every 3 seconds.
    bool doInverseHoles = (mod(time, 6.0) < 3.0);
    
    /* If you want it to spin, just to prove that it is redrawing
    the carpet every frame: */
    vec2 center = vec2(0.5, 0.5);
    mat2 rotation = mat2(
        vec2(cos(time), sin(time)),
        vec2(-sin(time), cos(time))
    );
    vec2 coordRot = rotation * (coordOrig - center) + center;
    // rotation can put us out of bounds
    if (coordRot.x < 0.0 || coordRot.x > 1.0 ||
        coordRot.y < 0.0 || coordRot.y > 1.0) {
        setColor(coordOrig, true);
        return;
    }

    vec2 coordIter = coordRot;
    bool isHole = false;
    
    for (int i=0;
         i < lim;
         i++)
    {
        sectors = ivec2(floor(coordIter.xy * 3.0));
        if (sectors.x == 1 && sectors.y == 1) {
            if (doInverseHoles) {
                isHole = !isHole;
            } else {
                setColor(coordOrig, true);
                return;
            }
        }

        if (i + 1 < lim) {
            // map current sector to whole carpet
            coordIter.xy = coordIter.xy * 3.0 - vec2(sectors.xy);
        }
    }
    
    setColor(isHole ? coordOrig : coordRot, isHole);
}
SHADER
))


;;;
;;;; Mesh Multitexture
;;;


;; Multitexture by iq (2009)

(definition public mesh-multitexture-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform float time;
uniform TEXSAMPLER texture;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
void main()
{
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    // a rotozoom
    vec2 cst = vec2(cos(.5*time), sin(.5*time));
    mat2 rot = 0.5*cst.x*mat2(cst.x,-cst.y,cst.y,cst.x);
    
    vec2 tmp = rot*p;
    texu = tmp.x;
    texv = tmp.y;
SHADER

(denormalize-uv)

#<<SHADER
    vec3 col1 = TEX2D(texture,TEXUV(texu,texv)).xyz;

    tmp = 0.5*p+sin(0.1*time);
    texu = tmp.x;
    texv = tmp.y;
SHADER

(denormalize-uv)

#<<SHADER
    // scroll
    vec3 col2 = TEX2D(texture,TEXUV(texu,texv)).xyz;

    // blend layers
    vec3 col = col2*col1;

    gl_FragColor = vec4(col,1.0);
}
SHADER
))


;;;
;;;; Mesh Kaleidoscope
;;;


;; Kaleidoscope by iq (2009)

(definition public mesh-kaleidoscope-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform float time;
uniform TEXSAMPLER texture;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
void main()
{
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 uv;
   
    float a = atan(p.y,p.x);
    float r = sqrt(dot(p,p));

    uv.x =          7.0*a/3.1416;
    uv.y = -time+ sin(7.0*r+time) + .7*cos(time+7.0*a);

    float w = .5+.5*(sin(time+7.0*r)+ .7*cos(time+7.0*a));

    texu = uv.x*.5;
    texv = uv.y*.5;
SHADER

(denormalize-uv)

#<<SHADER
    vec3 col = TEX2D(texture,TEXUV(texu,texv)).xyz;

    gl_FragColor = vec4(col*w,1.0);
}
SHADER
))


;;;
;;;; Mesh Tunnel
;;;


;; Tunnel by iq (2009)

(definition public mesh-tunnel-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform float time;
uniform TEXSAMPLER texture;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
void main()
{
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 uv;
   
    float a = atan(p.y,p.x);
    float r = sqrt(dot(p,p));

    uv.x = .75*time+.1/r;
    uv.y = a/3.1416;

    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv)

#<<SHADER
    vec3 col = TEX2D(texture,TEXUV(texu,texv)).xyz;

    gl_FragColor = vec4(col*r,1.0);
}
SHADER
))


;;;
;;;; Mesh Square Tunnel
;;;


;; Square Tunnel by iq (2009)

(definition public mesh-square-tunnel-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform float time;
uniform TEXSAMPLER texture;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
void main()
{
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 uv;

    float r = pow(pow(p.x*p.x,16.0) + pow(p.y*p.y,16.0), 1.0/32.0);
    uv.x = .5*time + 0.5/r;
    uv.y = 1.0*atan(p.y,p.x)/3.1416;

    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv)

#<<SHADER
    vec3 col = TEX2D(texture,TEXUV(texu,texv)).xyz;

    gl_FragColor = vec4(col*r*r*r,1.0);
}
SHADER
))


;;;
;;;; Mesh Fly
;;;


;; Fly by iq (2009)

(definition public mesh-fly-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform float time;
uniform TEXSAMPLER texture;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
void main()
{
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 uv;

    float an = time*.25;

    float x = p.x*cos(an)-p.y*sin(an);
    float y = p.x*sin(an)+p.y*cos(an);
     
    uv.x = .25*x/abs(y);
    uv.y = .20*time + .25/abs(y);

    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv)

#<<SHADER
    gl_FragColor = vec4(TEX2D(texture,TEXUV(texu,texv)).xyz * y*y, 1.0);
}
SHADER
))


;;;
;;;; Mesh Pulse
;;;


;; Pulse by Danguafer/Silexars (2010)

(definition public mesh-pulse-fs
  (string-append
    #<<SHADER
#version 120

SHADER

(texture-macros)

#<<SHADER
// precision highp float;

uniform float time;
uniform TEXSAMPLER texture;
TEXBOUNDS

varying TEXCOORD final_texture_coord;
SHADER

(normalize-uv)

#<<SHADER
void main()
{
    vec2 halfres = 0.5;
    vec2 cPos = vec2(texx, texy);

    cPos.x -= 0.5*halfres.x*sin(time/2.0)+0.3*halfres.x*cos(time)+halfres.x;
    cPos.y -= 0.4*halfres.y*sin(time/5.0)+0.3*halfres.y*cos(time)+halfres.y;
    float cLength = length(cPos);

    vec2 uv = vec2(texx, texy)+(cPos/cLength)*sin(cLength/30.0-time*10.0)/25.0;
    
    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv)

#<<SHADER
    vec3 col = TEX2D(texture,TEXUV(texu,texv)).xyz*50.0/cLength;

    gl_FragColor = vec4(col,1.0);
}
SHADER
))


;;;
;;;; PP
;;;


@wait
(definition public pp-vs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D fbo_texture;

attribute vec2 vertex_coord;

varying vec2 final_texture_coord;
 
void main()
{
  gl_Position = vec4(vertex_coord, 0.0, 1.0);
  final_texture_coord = (vertex_coord + 1.0) / 2;
}
SHADER
)


@wait
(definition public pp-fs
  #<<SHADER
#version 120

// precision mediump float;

uniform sampler2D fbo_texture;

varying vec2 final_texture_coord;

void main()
{
  float offsetX = 1.0 / 2400.0;
  float offsetY = 1.0 / 1600.0;
  vec4 color = texture2D(fbo_texture, vec2(final_texture_coord.x              , final_texture_coord.y))+
               texture2D(fbo_texture, vec2(final_texture_coord.x+offsetX      , final_texture_coord.y))+
               texture2D(fbo_texture, vec2(final_texture_coord.x              , final_texture_coord.y+offsetY))+
               texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX)    , final_texture_coord.y+offsetY));
               // texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX*2.0), final_texture_coord.y+offsetY))+
               // texture2D(fbo_texture, vec2(final_texture_coord.x              , final_texture_coord.y+(offsetY*2.0)))+
               // texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX)    , final_texture_coord.y+(offsetY*2.0)))+
               // texture2D(fbo_texture, vec2(final_texture_coord.x+(offsetX*2.0), final_texture_coord.y+(offsetY*2.0)));
               
  gl_FragColor = color * 0.25;
}
SHADER
))
